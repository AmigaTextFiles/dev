This is flex.info, produced by makeinfo version 4.2 from flex.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* flex: (flex).      Fast lexical analyzer generator (lex replacement).
END-INFO-DIR-ENTRY


File: flex.info,  Node: unnamed-faq-81,  Next: unnamed-faq-82,  Prev: unnamed-faq-80,  Up: FAQ

unnamed-faq-81
==============


     Received: from 131.173.17.11 (131.173.17.11 [131.173.17.11])
     	by ee.lbl.gov (8.9.1/8.9.1) with ESMTP id AAA03838
     	for <vern@ee.lbl.gov>; Thu, 20 Aug 1998 00:47:57 -0700 (PDT)
     Received: from hal.cl-ki.uni-osnabrueck.de (hal.cl-ki.Uni-Osnabrueck.DE [131.173.141.2])
     	by deimos.rz.uni-osnabrueck.de (8.8.7/8.8.8) with ESMTP id JAA34694
     	for <vern@ee.lbl.gov>; Thu, 20 Aug 1998 09:47:55 +0200
     Received: (from georg@localhost) by hal.cl-ki.uni-osnabrueck.de (8.6.12/8.6.12) id JAA34834 for vern@ee.lbl.gov; Thu, 20 Aug 1998 09:47:54 +0200
     From: Georg Rehm <georg@hal.cl-ki.uni-osnabrueck.de>
     Message-Id: <199808200747.JAA34834@hal.cl-ki.uni-osnabrueck.de>
     Subject: "flex scanner push-back overflow"
     To: vern@ee.lbl.gov
     Date: Thu, 20 Aug 1998 09:47:54 +0200 (MEST)
     Reply-To: Georg.Rehm@CL-KI.Uni-Osnabrueck.DE
     X-NoJunk: Do NOT send commercial mail, spam or ads to this address!
     X-URL: http://www.cl-ki.uni-osnabrueck.de/~georg/
     X-Mailer: ELM [version 2.4ME+ PL28 (25)]
     MIME-Version: 1.0
     Content-Type: text/plain; charset=US-ASCII
     Content-Transfer-Encoding: 7bit
     
     Hi Vern,
     
     Yesterday, I encountered a strange problem: I use the macro processor m4
     to include some lengthy lists into a .l file. Following is a flex macro
     definition that causes some serious pain in my neck:
     
     AUTHOR           ("A. Boucard / L. Boucard"|"A. Dastarac / M. Levent"|"A.Boucaud / L.Boucaud"|"Abderrahim Lamchichi"|"Achmat Dangor"|"Adeline Toullier"|"Adewale Maja-Pearce"|"Ahmed Ziri"|"Akram Ellyas"|"Alain Bihr"|"Alain Gresh"|"Alain Guillemoles"|"Alain Joxe"|"Alain Morice"|"Alain Renon"|"Alain Zecchini"|"Albert Memmi"|"Alberto Manguel"|"Alex De Waal"|"Alfonso Artico"| [...])
     
     The complete list contains about 10kB. When I try to "flex" this file
     (on a Solaris 2.6 machine, using a modified flex 2.5.4 (I only increased
     some of the predefined values in flexdefs.h) I get the error:
     
     myflex/flex -8  sentag.tmp.l
     flex scanner push-back overflow
     
     When I remove the slashes in the macro definition everything works fine.
     As I understand it, the double quotes escape the slash-character so it
     really means "/" and not "trailing context". Furthermore, I tried to
     escape the slashes with backslashes, but with no use, the same error message
     appeared when flexing the code.
     
     Do you have an idea what's going on here?
     
     Greetings from Germany,
     	Georg
     --
     Georg Rehm                                     georg@cl-ki.uni-osnabrueck.de
     Institute for Semantic Information Processing, University of Osnabrueck, FRG


File: flex.info,  Node: unnamed-faq-82,  Next: unnamed-faq-83,  Prev: unnamed-faq-81,  Up: FAQ

unnamed-faq-82
==============


     To: Georg.Rehm@CL-KI.Uni-Osnabrueck.DE
     Subject: Re: "flex scanner push-back overflow"
     In-reply-to: Your message of Thu, 20 Aug 1998 09:47:54 PDT.
     Date: Thu, 20 Aug 1998 07:05:35 PDT
     From: Vern Paxson <vern>
     
     > myflex/flex -8  sentag.tmp.l
     > flex scanner push-back overflow
     
     Flex itself uses a flex scanner.  That scanner is running out of buffer
     space when it tries to unput() the humongous macro you've defined.  When
     you remove the '/'s, you make it small enough so that it fits in the buffer;
     removing spaces would do the same thing.
     
     The fix is to either rethink how come you're using such a big macro and
     perhaps there's another/better way to do it; or to rebuild flex's own
     scan.c with a larger value for
     
     	#define YY_BUF_SIZE 16384
     
     - Vern


File: flex.info,  Node: unnamed-faq-83,  Next: unnamed-faq-84,  Prev: unnamed-faq-82,  Up: FAQ

unnamed-faq-83
==============


     To: Jan Kort <jan@research.techforce.nl>
     Subject: Re: Flex
     In-reply-to: Your message of Fri, 04 Sep 1998 12:18:43 +0200.
     Date: Sat, 05 Sep 1998 00:59:49 PDT
     From: Vern Paxson <vern>
     
     > %%
     >
     > "TEST1\n"       { fprintf(stderr, "TEST1\n"); yyless(5); }
     > ^\n             { fprintf(stderr, "empty line\n"); }
     > .               { }
     > \n              { fprintf(stderr, "new line\n"); }
     >
     > %%
     > -- input ---------------------------------------
     > TEST1
     > -- output --------------------------------------
     > TEST1
     > empty line
     > ------------------------------------------------
     
     IMHO, it's not clear whether or not this is in fact a bug.  It depends
     on whether you view yyless() as backing up in the input stream, or as
     pushing new characters onto the beginning of the input stream.  Flex
     interprets it as the latter (for implementation convenience, I'll admit),
     and so considers the newline as in fact matching at the beginning of a
     line, as after all the last token scanned an entire line and so the
     scanner is now at the beginning of a new line.
     
     I agree that this is counter-intuitive for yyless(), given its
     functional description (it's less so for unput(), depending on whether
     you're unput()'ing new text or scanned text).  But I don't plan to
     change it any time soon, as it's a pain to do so.  Consequently,
     you do indeed need to use yy_set_bol() and YY_AT_BOL() to tweak
     your scanner into the behavior you desire.
     
     Sorry for the less-than-completely-satisfactory answer.
     
     		Vern


File: flex.info,  Node: unnamed-faq-84,  Next: unnamed-faq-85,  Prev: unnamed-faq-83,  Up: FAQ

unnamed-faq-84
==============


     To: Patrick Krusenotto <krusenot@mac-info-link.de>
     Subject: Re: Problems with restarting flex-2.5.2-generated scanner
     In-reply-to: Your message of Thu, 24 Sep 1998 10:14:07 PDT.
     Date: Thu, 24 Sep 1998 23:28:43 PDT
     From: Vern Paxson <vern>
     
     > I am using flex-2.5.2 and bison 1.25 for Solaris and I am desperately
     > trying to make my scanner restart with a new file after my parser stops
     > with a parse error. When my compiler restarts, the parser always
     > receives the token after the token (in the old file!) that caused the
     > parser error.
     
     I suspect the problem is that your parser has read ahead in order
     to attempt to resolve an ambiguity, and when it's restarted it picks
     up with that token rather than reading a fresh one.  If you're using
     yacc, then the special "error" production can sometimes be used to
     consume tokens in an attempt to get the parser into a consistent state.
     
     		Vern


File: flex.info,  Node: unnamed-faq-85,  Next: unnamed-faq-86,  Prev: unnamed-faq-84,  Up: FAQ

unnamed-faq-85
==============


     To: Henric Jungheim <junghelh@pe-nelson.com>
     Subject: Re: flex 2.5.4a
     In-reply-to: Your message of Tue, 27 Oct 1998 16:41:42 PST.
     Date: Tue, 27 Oct 1998 16:50:14 PST
     From: Vern Paxson <vern>
     
     > This brings up a feature request:  How about a command line
     > option to specify the filename when reading from stdin?  That way one
     > doesn't need to create a temporary file in order to get the "#line"
     > directives to make sense.
     
     Use -o combined with -t (per the man page description of -o).
     
     > P.S., Is there any simple way to use non-blocking IO to parse multiple
     > streams?
     
     Simple, no.
     
     One approach might be to return a magic character on EWOULDBLOCK and
     have a rule
     
     	.*<magic-character>	// put back .*, eat magic character
     
     This is off the top of my head, not sure it'll work.
     
     		Vern


File: flex.info,  Node: unnamed-faq-86,  Next: unnamed-faq-87,  Prev: unnamed-faq-85,  Up: FAQ

unnamed-faq-86
==============


     To: "Repko, Billy D" <billy.d.repko@intel.com>
     Subject: Re: Compiling scanners
     In-reply-to: Your message of Wed, 13 Jan 1999 10:52:47 PST.
     Date: Thu, 14 Jan 1999 00:25:30 PST
     From: Vern Paxson <vern>
     
     > It appears that maybe it cannot find the lfl library.
     
     The Makefile in the distribution builds it, so you should have it.
     It's exceedingly trivial, just a main() that calls yylex() and
     a yyrap() that always returns 1.
     
     > %%
     >       \n      ++num_lines; ++num_chars;
     >       .       ++num_chars;
     
     You can't indent your rules like this - that's where the errors are coming
     from.  Flex copies indented text to the output file, it's how you do things
     like
     
     	int num_lines_seen = 0;
     
     to declare local variables.
     
     		Vern


File: flex.info,  Node: unnamed-faq-87,  Next: unnamed-faq-88,  Prev: unnamed-faq-86,  Up: FAQ

unnamed-faq-87
==============


     To: Erick Branderhorst <Erick.Branderhorst@asml.nl>
     Subject: Re: flex input buffer
     In-reply-to: Your message of Tue, 09 Feb 1999 13:53:46 PST.
     Date: Tue, 09 Feb 1999 21:03:37 PST
     From: Vern Paxson <vern>
     
     > In the flex.skl file the size of the default input buffers is set.  Can you
     > explain why this size is set and why it is such a high number.
     
     It's large to optimize performance when scanning large files.  You can
     safely make it a lot lower if needed.
     
     		Vern


File: flex.info,  Node: unnamed-faq-88,  Next: unnamed-faq-90,  Prev: unnamed-faq-87,  Up: FAQ

unnamed-faq-88
==============


     To: "Guido Minnen" <guidomi@cogs.susx.ac.uk>
     Subject: Re: Flex error message
     In-reply-to: Your message of Wed, 24 Feb 1999 15:31:46 PST.
     Date: Thu, 25 Feb 1999 00:11:31 PST
     From: Vern Paxson <vern>
     
     > I'm extending a larger scanner written in Flex and I keep running into
     > problems. More specifically, I get the error message:
     > "flex: input rules are too complicated (>= 32000 NFA states)"
     
     Increase the definitions in flexdef.h for:
     
     #define JAMSTATE -32766 /* marks a reference to the state that always j
     ams */
     #define MAXIMUM_MNS 31999
     #define BAD_SUBSCRIPT -32767
     
     recompile everything, and it should all work.
     
     		Vern


File: flex.info,  Node: unnamed-faq-90,  Next: unnamed-faq-91,  Prev: unnamed-faq-88,  Up: FAQ

unnamed-faq-90
==============


     To: "Dmitriy Goldobin" <gold@ems.chel.su>
     Subject: Re: FLEX trouble
     In-reply-to: Your message of Mon, 31 May 1999 18:44:49 PDT.
     Date: Tue, 01 Jun 1999 00:15:07 PDT
     From: Vern Paxson <vern>
     
     >   I have a trouble with FLEX. Why rule "/*".*"*/" work properly,=20
     > but rule "/*"(.|\n)*"*/" don't work ?
     
     The second of these will have to scan the entire input stream (because
     "(.|\n)*" matches an arbitrary amount of any text) in order to see if
     it ends with "*/", terminating the comment.  That potentially will overflow
     the input buffer.
     
     >   More complex rule "/*"([^*]|(\*/[^/]))*"*/ give an error
     > 'unrecognized rule'.
     
     You can't use the '/' operator inside parentheses.  It's not clear
     what "(a/b)*" actually means.
     
     >   I now use workaround with state <comment>, but single-rule is
     > better, i think.
     
     Single-rule is nice but will always have the problem of either setting
     restrictions on comments (like not allowing multi-line comments) and/or
     running the risk of consuming the entire input stream, as noted above.
     
     		Vern


File: flex.info,  Node: unnamed-faq-91,  Next: unnamed-faq-92,  Prev: unnamed-faq-90,  Up: FAQ

unnamed-faq-91
==============


     Received: from mc-qout4.whowhere.com (mc-qout4.whowhere.com [209.185.123.18])
     	by ee.lbl.gov (8.9.3/8.9.3) with SMTP id IAA05100
     	for <vern@ee.lbl.gov>; Tue, 15 Jun 1999 08:56:06 -0700 (PDT)
     Received: from Unknown/Local ([?.?.?.?]) by my-deja.com; Tue Jun 15 08:55:43 1999
     To: vern@ee.lbl.gov
     Date: Tue, 15 Jun 1999 08:55:43 -0700
     From: "Aki Niimura" <neko@my-deja.com>
     Message-ID: <KNONDOHDOBGAEAAA@my-deja.com>
     Mime-Version: 1.0
     Cc:
     X-Sent-Mail: on
     Reply-To:
     X-Mailer: MailCity Service
     Subject: A question on flex C++ scanner
     X-Sender-Ip: 12.72.207.61
     Organization: My Deja Email  (http://www.my-deja.com:80)
     Content-Type: text/plain; charset=us-ascii
     Content-Transfer-Encoding: 7bit
     
     Dear Dr. Paxon,
     
     I have been using flex for years.
     It works very well on many projects.
     Most case, I used it to generate a scanner on C language.
     However, one project I needed to generate  a scanner
     on C++ lanuage. Thanks to your enhancement, flex did
     the job.
     
     Currently, I'm working on enhancing my previous project.
     I need to deal with multiple input streams (recursive
     inclusion) in this scanner (C++).
     I did similar thing for another scanner (C) as you
     explained in your documentation.
     
     The generated scanner (C++) has necessary methods:
     - switch_to_buffer(struct yy_buffer_state *b)
     - yy_create_buffer(istream *is, int sz)
     - yy_delete_buffer(struct yy_buffer_state *b)
     
     However, I couldn't figure out how to access current
     buffer (yy_current_buffer).
     
     yy_current_buffer is a protected member of yyFlexLexer.
     I can't access it directly.
     Then, I thought yy_create_buffer() with is = 0 might
     return current stream buffer. But it seems not as far
     as I checked the source. (flex 2.5.4)
     
     I went through the Web in addition to Flex documentation.
     However, it hasn't been successful, so far.
     
     It is not my intention to bother you, but, can you
     comment about how to obtain the current stream buffer?
     
     Your response would be highly appreciated.
     
     Best regards,
     Aki Niimura
     
     --== Sent via Deja.com http://www.deja.com/ ==--
     Share what you know. Learn what you don't.


File: flex.info,  Node: unnamed-faq-92,  Next: unnamed-faq-93,  Prev: unnamed-faq-91,  Up: FAQ

unnamed-faq-92
==============


     To: neko@my-deja.com
     Subject: Re: A question on flex C++ scanner
     In-reply-to: Your message of Tue, 15 Jun 1999 08:55:43 PDT.
     Date: Tue, 15 Jun 1999 09:04:24 PDT
     From: Vern Paxson <vern>
     
     > However, I couldn't figure out how to access current
     > buffer (yy_current_buffer).
     
     Derive your own subclass from yyFlexLexer.
     
     		Vern


File: flex.info,  Node: unnamed-faq-93,  Next: unnamed-faq-94,  Prev: unnamed-faq-92,  Up: FAQ

unnamed-faq-93
==============


     To: "Stones, Darren" <Darren.Stones@nectech.co.uk>
     Subject: Re: You're the man to see?
     In-reply-to: Your message of Wed, 23 Jun 1999 11:10:29 PDT.
     Date: Wed, 23 Jun 1999 09:01:40 PDT
     From: Vern Paxson <vern>
     
     > I hope you can help me.  I am using Flex and Bison to produce an interpreted
     > language.  However all goes well until I try to implement an IF statement or
     > a WHILE.  I cannot get this to work as the parser parses all the conditions
     > eg. the TRUE and FALSE conditons to check for a rule match.  So I cannot
     > make a decision!!
     
     You need to use the parser to build a parse tree (= abstract syntax trwee),
     and when that's all done you recursively evaluate the tree, binding variables
     to values at that time.
     
     		Vern


File: flex.info,  Node: unnamed-faq-94,  Next: unnamed-faq-95,  Prev: unnamed-faq-93,  Up: FAQ

unnamed-faq-94
==============


     To: Petr Danecek <petr@ics.cas.cz>
     Subject: Re: flex - question
     In-reply-to: Your message of Mon, 28 Jun 1999 19:21:41 PDT.
     Date: Fri, 02 Jul 1999 16:52:13 PDT
     From: Vern Paxson <vern>
     
     > file, it takes an enormous amount of time. It is funny, because the
     > source code has only 12 rules!!! I think it looks like an exponencial
     > growth.
     
     Right, that's the problem - some patterns (those with a lot of
     ambiguity, where yours has because at any given time the scanner can
     be in the middle of all sorts of combinations of the different
     rules) blow up exponentially.
     
     For your rules, there is an easy fix.  Change the ".*" that comes fater
     the directory name to "[^ ]*".  With that in place, the rules are no
     longer nearly so ambiguous, because then once one of the directories
     has been matched, no other can be matched (since they all require a
     leading blank).
     
     If that's not an acceptable solution, then you can enter a start state
     to pick up the .*\n after each directory is matched.
     
     Also note that for speed, you'll want to add a ".*" rule at the end,
     otherwise rules that don't match any of the patterns will be matched
     very slowly, a character at a time.
     
     		Vern


File: flex.info,  Node: unnamed-faq-95,  Next: unnamed-faq-96,  Prev: unnamed-faq-94,  Up: FAQ

unnamed-faq-95
==============


     To: Tielman Koekemoer <tielman@spi.co.za>
     Subject: Re: Please help.
     In-reply-to: Your message of Thu, 08 Jul 1999 13:20:37 PDT.
     Date: Thu, 08 Jul 1999 08:20:39 PDT
     From: Vern Paxson <vern>
     
     > I was hoping you could help me with my problem.
     >
     > I tried compiling (gnu)flex on a Solaris 2.4 machine
     > but when I ran make (after configure) I got an error.
     >
     > --------------------------------------------------------------
     > gcc -c -I. -I. -g -O parse.c
     > ./flex -t -p  ./scan.l >scan.c
     > sh: ./flex: not found
     > *** Error code 1
     > make: Fatal error: Command failed for target `scan.c'
     > -------------------------------------------------------------
     >
     > What's strange to me is that I'm only
     > trying to install flex now. I then edited the Makefile to
     > and changed where it says "FLEX = flex" to "FLEX = lex"
     > ( lex: the native Solaris one ) but then it complains about
     > the "-p" option. Is there any way I can compile flex without
     > using flex or lex?
     >
     > Thanks so much for your time.
     
     You managed to step on the bootstrap sequence, which first copies
     initscan.c to scan.c in order to build flex.  Try fetching a fresh
     distribution from ftp.ee.lbl.gov.  (Or you can first try removing
     ".bootstrap" and doing a make again.)
     
     		Vern


File: flex.info,  Node: unnamed-faq-96,  Next: unnamed-faq-97,  Prev: unnamed-faq-95,  Up: FAQ

unnamed-faq-96
==============


     To: Tielman Koekemoer <tielman@spi.co.za>
     Subject: Re: Please help.
     In-reply-to: Your message of Fri, 09 Jul 1999 09:16:14 PDT.
     Date: Fri, 09 Jul 1999 00:27:20 PDT
     From: Vern Paxson <vern>
     
     > First I removed .bootstrap (and ran make) - no luck. I downloaded the
     > software but I still have the same problem. Is there anything else I
     > could try.
     
     Try:
     
     	cp initscan.c scan.c
     	touch scan.c
     	make scan.o
     
     If this last tries to first build scan.c from scan.l using ./flex, then
     your "make" is broken, in which case compile scan.c to scan.o by hand.
     
     		Vern


File: flex.info,  Node: unnamed-faq-97,  Next: unnamed-faq-98,  Prev: unnamed-faq-96,  Up: FAQ

unnamed-faq-97
==============


     To: Sumanth Kamenani <skamenan@crl.nmsu.edu>
     Subject: Re: Error
     In-reply-to: Your message of Mon, 19 Jul 1999 23:08:41 PDT.
     Date: Tue, 20 Jul 1999 00:18:26 PDT
     From: Vern Paxson <vern>
     
     > I am getting a compilation error. The error is given as "unknown symbol- yylex".
     
     The parser relies on calling yylex(), but you're instead using the C++ scanning
     class, so you need to supply a yylex() "glue" function that calls an instance
     scanner of the scanner (e.g., "scanner->yylex()").
     
     		Vern


File: flex.info,  Node: unnamed-faq-98,  Next: unnamed-faq-99,  Prev: unnamed-faq-97,  Up: FAQ

unnamed-faq-98
==============


     To: daniel@synchrods.synchrods.COM (Daniel Senderowicz)
     Subject: Re: lex
     In-reply-to: Your message of Mon, 22 Nov 1999 11:19:04 PST.
     Date: Tue, 23 Nov 1999 15:54:30 PST
     From: Vern Paxson <vern>
     
     Well, your problem is the
     
     switch (yybgin-yysvec-1) {      /* witchcraft */
     
     at the beginning of lex rules.  "witchcraft" == "non-portable".  It's
     assuming knowledge of the AT&T lex's internal variables.
     
     For flex, you can probably do the equivalent using a switch on YYSTATE.
     
     		Vern


File: flex.info,  Node: unnamed-faq-99,  Next: unnamed-faq-100,  Prev: unnamed-faq-98,  Up: FAQ

unnamed-faq-99
==============


     To: archow@hss.hns.com
     Subject: Re: Regarding distribution of flex and yacc based grammars
     In-reply-to: Your message of Sun, 19 Dec 1999 17:50:24 +0530.
     Date: Wed, 22 Dec 1999 01:56:24 PST
     From: Vern Paxson <vern>
     
     > When we provide the customer with an object code distribution, is it
     > necessary for us to provide source
     > for the generated C files from flex and bison since they are generated by
     > flex and bison ?
     
     For flex, no.  I don't know what the current state of this is for bison.
     
     > Also, is there any requrirement for us to neccessarily  provide source for
     > the grammar files which are fed into flex and bison ?
     
     Again, for flex, no.
     
     See the file "COPYING" in the flex distribution for the legalese.
     
     		Vern


File: flex.info,  Node: unnamed-faq-100,  Next: unnamed-faq-101,  Prev: unnamed-faq-99,  Up: FAQ

unnamed-faq-100
===============


     To: Martin Gallwey <gallweym@hyperion.moe.ul.ie>
     Subject: Re: Flex, and self referencing rules
     In-reply-to: Your message of Sun, 20 Feb 2000 01:01:21 PST.
     Date: Sat, 19 Feb 2000 18:33:16 PST
     From: Vern Paxson <vern>
     
     > However, I do not use unput anywhere. I do use self-referencing
     > rules like this:
     >
     > UnaryExpr               ({UnionExpr})|("-"{UnaryExpr})
     
     You can't do this - flex is *not* a parser like yacc (which does indeed
     allow recursion), it is a scanner that's confined to regular expressions.
     
     		Vern


File: flex.info,  Node: unnamed-faq-101,  Prev: unnamed-faq-100,  Up: FAQ

unnamed-faq-101
===============


     To: slg3@lehigh.edu (SAMUEL L. GULDEN)
     Subject: Re: Flex problem
     In-reply-to: Your message of Thu, 02 Mar 2000 12:29:04 PST.
     Date: Thu, 02 Mar 2000 23:00:46 PST
     From: Vern Paxson <vern>
     
     If this is exactly your program:
     
     > digit [0-9]
     > digits {digit}+
     > whitespace [ \t\n]+
     >
     > %%
     > "[" { printf("open_brac\n");}
     > "]" { printf("close_brac\n");}
     > "+" { printf("addop\n");}
     > "*" { printf("multop\n");}
     > {digits} { printf("NUMBER = %s\n", yytext);}
     > whitespace ;
     
     then the problem is that the last rule needs to be "{whitespace}" !
     
     		Vern


File: flex.info,  Node: Appendices,  Next: Indices,  Prev: FAQ,  Up: Top

Appendices
**********

* Menu:

* Makefiles and Flex::
* Bison Bridge::


File: flex.info,  Node: Makefiles and Flex,  Next: Bison Bridge,  Prev: Appendices,  Up: Appendices

Makefiles and Flex
==================

   In this appendix, we provide tips for writing Makefiles to build
your scanners.

   In a traditional build environment, we say that the `.c' files are
the sources, and the `.o' files are the intermediate files. When using
`flex', however, the `.l' files are the sources, and the generated `.c'
files (along with the `.o' files) are the intermediate files.  This
requires you to carefully plan your Makefile.

   Modern `make' programs understand that `foo.l' is intended to
generate `lex.yy.c' or `foo.c', and will behave accordingly(1).  The
following Makefile does not explicitly instruct `make' how to build
`foo.c' from `foo.l'. Instead, it relies on the implicit rules of the
`make' program to build the intermediate file, `scan.c':


         # Basic Makefile -- relies on implicit rules
         # Creates "myprogram" from "scan.l" and "myprogram.c"
         #
         LEX=flex
         myprogram: scan.o myprogram.o
         scan.o: scan.l

   For simple cases, the above may be sufficient. For other cases, you
may have to explicitly instruct `make' how to build your scanner.  The
following is an example of a Makefile containing explicit rules:


         # Basic Makefile -- provides explicit rules
         # Creates "myprogram" from "scan.l" and "myprogram.c"
         #
         LEX=flex
         myprogram: scan.o myprogram.o
                 $(CC) -o $@  $(LDFLAGS) $^
     
         myprogram.o: myprogram.c
                 $(CC) $(CPPFLAGS) $(CFLAGS) -o $@ -c $^
     
         scan.o: scan.c
                 $(CC) $(CPPFLAGS) $(CFLAGS) -o $@ -c $^
     
         scan.c: scan.l
                 $(LEX) $(LFLAGS) -o $@ $^
     
         clean:
                 $(RM) *.o scan.c

   Notice in the above example that `scan.c' is in the `clean' target.
This is because we consider the file `scan.c' to be an intermediate
file.

   Finally, we provide a realistic example of a `flex' scanner used
with a `bison' parser(2).  There is a tricky problem we have to deal
with. Since a `flex' scanner will typically include a header file
(e.g., `y.tab.h') generated by the parser, we need to be sure that the
header file is generated BEFORE the scanner is compiled. We handle this
case in the following example:


         # Makefile example -- scanner and parser.
         # Creates "myprogram" from "scan.l", "parse.y", and "myprogram.c"
         #
         LEX     = flex
         YACC    = bison -y
         YFLAGS  = -d
         objects = scan.o parse.o myprogram.o
     
         myprogram: $(objects)
         scan.o: scan.l parse.c
         parse.o: parse.y
         myprogram.o: myprogram.c

   In the above example, notice the line,


         scan.o: scan.l parse.c

   , which lists the file `parse.c' (the generated parser) as a
dependency of `scan.o'. We want to ensure that the parser is created
before the scanner is compiled, and the above line seems to do the
trick. Feel free to experiment with your specific implementation of
`make'.

   For more details on writing Makefiles, see *Note Top: (make)Top.

   ---------- Footnotes ----------

   (1) GNU `make' and GNU `automake' are two such programs that provide
implicit rules for flex-generated scanners.

   (2) This example also applies to yacc parsers.


File: flex.info,  Node: Bison Bridge,  Prev: Makefiles and Flex,  Up: Appendices

C Scanners with Bison Parsers
=============================

   This section describes the `flex' features useful when integrating
`flex' with `GNU bison'(1).  Skip this section if you are not using
`bison' with your scanner.  Here we discuss only the `flex' half of the
`flex' and `bison' pair.  We do not discuss `bison' in any detail.  For
more information about generating `bison' parsers, see *Note Top:
(bison)Top.

   A compatible `bison' scanner is generated by declaring `%option
bison-bridge' or by supplying `--bison-bridge' when invoking `flex'
from the command line.  This instructs `flex' that the macros `yylval'
and `yylloc' may be used. The data types for `yylval' and `yylloc',
(`YYSTYPE' and `YYLTYPE', are typically defined in a header file,
included in section 1 of the `flex' input file.  If `%option
bison-bridge' is specified, `flex' provides support for the functions
`yyget_lval', `yyset_lval', `yyget_lloc', and `yyset_lloc', defined
below, and the corresponding macros `yylval' and `yylloc', for use
within actions.

 - Function: YYSTYPE* yyget_lval ( yyscan_t scanner )

 - Function: YYLTYPE* yyget_lloc ( yyscan_t scanner )

 - Function: void yyset_lval ( YYSTYPE* lvalp, yyscan_t scanner )

 - Function: void yyset_lloc ( YYLTYPE* llocp, yyscan_t scanner )

   Where yyscan_t is defined in the reentrant scanner (2).
Accordingly, the declaration of yylex becomes one of the following:


           int yylex ( YYSTYPE * lvalp, yyscan_t scanner );
           int yylex ( YYSTYPE * lvalp, YYLTYPE * llocp, yyscan_t scanner );

   Note that the macros `yylval' and `yylloc' evaluate to pointers.
Support for `yylloc' is optional in `bison', so it is optional in
`flex' as well. This support is automatically handled by `flex'.
Specifically, support for `yyloc' is only present in a `flex' scanner
if the preprocessor symbol `YYLTYPE' is defined.  The following is an
example of a `flex' scanner that is compatible with `bison'.


         /* Scanner for "C" assignment statements... sort of. */
         %{
         #include "y.tab.h"  /* Generated by bison. */
         %}
     
         %option reentrant-bison
         %
     
         [[:digit:]]+  { yylval->num = atoi(yytext);   return NUMBER;}
         [[:alnum:]]+  { yylval->str = strdup(yytext); return STRING;}
         "="|";"       { return yytext[0];}
         .  {}
         %

   As you can see, there really is no magic here. We just use `yylval'
as we would any other variable. The data type of `yylval' is generated
by `bison', and included in the file `y.tab.h'. Here is the
corresponding `bison' parser:


         /* Parser to convert "C" assignments to lisp. */
         %{
         /* Pass the argument to yyparse through to yylex. */
         #define YYPARSE_PARAM scanner
         #define YYLEX_PARAM   scanner
         %}
         %pure_parser
         %union {
             int num;
             char* str;
         }
         %token <str> STRING
         %token <num> NUMBER
         %%
         assignment:
             STRING '=' NUMBER ';' {
                 printf( "(setf %s %d)", $1, $3 );
            }
         ;

   ---------- Footnotes ----------

   (1) The features described here are purely optional, and are by no
means the only way to use flex with bison.  We merely provide some glue
to ease development of your parser-scanner pair.

   (2) The bison bridge works with non-reentrant scanners, too.


File: flex.info,  Node: Indices,  Prev: Appendices,  Up: Top

Indices
*******

* Menu:

* Concept Index::
* Index of Functions and Macros::
* Index of Variables::
* Index of Data Types::
* Index of Hooks::
* Index of Scanner Options::


File: flex.info,  Node: Concept Index,  Next: Index of Functions and Macros,  Prev: Indices,  Up: Indices

Concept Index
=============

* Menu:

* $ as normal character in patterns:     Patterns.
* %array, advantages of:                 Matching.
* %array, use of:                        Matching.
* %array, with C++:                      Matching.
* %option nowrap:                        Generated Scanner.
* %pointer, and unput():                 Actions.
* %pointer, use of:                      Matching.
* %{ and %}, in Definitions Section:     Definitions Section.
* %{ and %}, in Rules Section:           Actions.
* <<EOF>>, use of:                       EOF.
* [] in patterns:                        Patterns.
* ^ as non-special character in patterns: Patterns.
* accessor functions, use of:            Accessor Methods.
* actions:                               Actions.
* actions, embedded C strings:           Actions.
* actions, redefining YY_BREAK:          Misc Macros.
* actions, use of { and }:               Actions.
* aliases, how to define:                Definitions Section.
* arguments, command-line:               Scanner Options.
* array, default size for yytext:        User Values.
* backing up, eliminating:               Performance.
* backing up, eliminating by adding error rules: Performance.
* backing up, eliminating with catch-all rule: Performance.
* backing up, example of eliminating:    Performance.
* BEGIN:                                 Actions.
* BEGIN, explanation:                    Start Conditions.
* beginning of line, in patterns:        Patterns.
* bison, bridging with flex:             Bison Bridge.
* bison, parser:                         Bison Bridge.
* bison, scanner to be called from bison: Bison Bridge.
* BOL, checking the BOL flag:            Misc Macros.
* BOL, in patterns:                      Patterns.
* BOL, setting it:                       Misc Macros.
* braces in patterns:                    Patterns.
* bugs, reporting:                       Reporting Bugs.
* C code in flex input:                  Definitions Section.
* C++:                                   Cxx.
* C++ and %array:                        User Values.
* C++ I/O, customizing:                  How do I use my own I/O classes in a C++ scanner?.
* C++ scanners, including multiple scanners: Cxx.
* C++ scanners, use of:                  Cxx.
* c++, experimental form of scanner class: Cxx.
* C++, multiple different scanners:      Cxx.
* C-strings, in actions:                 Actions.
* case-insensitive, effect on character classes: Patterns.
* character classes in patterns:         Patterns.
* character classes in patterns, syntax of: Patterns.
* character classes, equivalence of:     Patterns.
* clearing an input buffer:              Multiple Input Buffers.
* command-line options:                  Scanner Options.
* comments in flex input:                Definitions Section.
* comments in the input:                 Comments in the Input.
* comments, discarding:                  Actions.
* comments, example of scanning C comments: Start Conditions.
* comments, in actions:                  Actions.
* comments, in rules section:            Comments in the Input.
* comments, syntax of:                   Comments in the Input.
* comments, valid uses of:               Comments in the Input.
* compressing whitespace:                Actions.
* concatenation, in patterns:            Patterns.
* copyright of flex:                     Copyright.
* counting characters and lines:         Simple Examples.
* customizing I/O in C++ scanners:       How do I use my own I/O classes in a C++ scanner?.
* default rule <1>:                      Matching.
* default rule:                          Simple Examples.
* defining pattern aliases:              Definitions Section.
* Definitions, in flex input:            Definitions Section.
* deleting lines from input:             Actions.
* discarding C comments:                 Actions.
* distributing flex:                     Copyright.
* ECHO:                                  Actions.
* ECHO, and yyout:                       Generated Scanner.
* embedding C code in flex input:        Definitions Section.
* end of file, in patterns:              Patterns.
* end of line, in negated character classes: Patterns.
* end of line, in patterns:              Patterns.
* end-of-file, and yyrestart():          Generated Scanner.
* EOF and yyrestart():                   Generated Scanner.
* EOF in patterns, syntax of:            Patterns.
* EOF, example using multiple input buffers: Multiple Input Buffers.
* EOF, explanation:                      EOF.
* EOF, pushing back:                     Actions.
* EOL, in negated character classes:     Patterns.
* EOL, in patterns:                      Patterns.
* error messages, end of buffer missed:  Lex and Posix.
* error reporting, diagnostic messages:  Diagnostics.
* error reporting, in C++:               Cxx.
* error rules, to eliminate backing up:  Performance.
* escape sequences in patterns, syntax of: Patterns.
* exiting with yyterminate():            Actions.
* experimental form of c++ scanner class: Cxx.
* extended scope of start conditions:    Start Conditions.
* file format:                           Format.
* file format, serialized tables:        Tables File Format.
* flushing an input buffer:              Multiple Input Buffers.
* flushing the internal buffer:          Actions.
* format of flex input:                  Format.
* format of input file:                  Format.
* freeing tables:                        Loading and Unloading Serialized Tables.
* getting current start state with YY_START: Start Conditions.
* halting with yyterminate():            Actions.
* handling include files with multiple input buffers: Multiple Input Buffers.
* header files, with C++:                Cxx.
* include files, with C++:               Cxx.
* input file, Definitions section:       Definitions Section.
* input file, Rules Section:             Rules Section.
* input file, user code Section:         User Code Section.
* input():                               Actions.
* input(), and C++:                      Actions.
* input, format of:                      Format.
* input, matching:                       Matching.
* keywords, for performance:             Performance.
* lex (traditional) and POSIX:           Lex and Posix.
* LexerInput, overriding:                How do I use my own I/O classes in a C++ scanner?.
* LexerOutput, overriding:               How do I use my own I/O classes in a C++ scanner?.
* limitations of flex:                   Limitations.
* literal text in patterns, syntax of:   Patterns.
* loading tables at runtime:             Loading and Unloading Serialized Tables.
* Makefile, example of implicit rules:   Makefiles and Flex.
* Makefile, explicit example:            Makefiles and Flex.
* Makefile, syntax:                      Makefiles and Flex.
* matching C-style double-quoted strings: Start Conditions.
* matching, and trailing context:        Matching.
* matching, length of:                   Matching.
* matching, multiple matches:            Matching.
* member functions, C++:                 Cxx.
* memory management:                     Memory Management.
* memory, allocating input buffers:      Multiple Input Buffers.
* memory, considerations for reentrant scanners: Init and Destroy Functions.
* memory, deleting input buffers:        Multiple Input Buffers.
* memory, for start condition stacks:    Start Conditions.
* memory, serialized tables <1>:         Loading and Unloading Serialized Tables.
* memory, serialized tables:             Serialized Tables.
* methods, c++:                          Cxx.
* minimal scanner:                       Matching.
* multiple input streams:                Multiple Input Buffers.
* name definitions, not POSIX:           Lex and Posix.
* negating ranges in patterns:           Patterns.
* newline, matching in patterns:         Patterns.
* non-POSIX features of flex:            Lex and Posix.
* nowrap, %option:                       Generated Scanner.
* NULL character in patterns, syntax of: Patterns.
* octal characters in patterns:          Patterns.
* options, command-line:                 Scanner Options.
* overriding LexerInput:                 How do I use my own I/O classes in a C++ scanner?.
* overriding LexerOutput:                How do I use my own I/O classes in a C++ scanner?.
* overriding the memory routines:        Overriding The Default Memory Management.
* Pascal-like language:                  Simple Examples.
* pattern aliases, defining:             Definitions Section.
* pattern aliases, expansion of:         Patterns.
* pattern aliases, how to define:        Definitions Section.
* pattern aliases, use of:               Definitions Section.
* patterns and actions on different lines: Lex and Posix.
* patterns, character class equivalence: Patterns.
* patterns, end of line:                 Patterns.
* patterns, grouping and precedence:     Patterns.
* patterns, in rules section:            Patterns.
* patterns, invalid trailing context:    Patterns.
* patterns, matching:                    Matching.
* patterns, precedence of operators:     Patterns.
* patterns, repetitions with grouping:   Patterns.
* patterns, special characters treated as non-special: Patterns.
* patterns, syntax:                      Patterns.
* patterns, tuning for performance:      Performance.
* patterns, valid character classes:     Patterns.
* performance optimization, matching longer tokens: Performance.
* performance optimization, recognizing keywords: Performance.
* performance, backing up:               Performance.
* performance, considerations:           Performance.
* performance, using keywords:           Performance.
* POSIX and lex:                         Lex and Posix.
* POSIX comp;compliance:                 Lex and Posix.
* POSIX, character classes in patterns, syntax of: Patterns.
* preprocessor macros, for use in actions: Actions.
* pushing back characters with unput:    Actions.
* pushing back characters with unput():  Actions.
* pushing back characters with yyless:   Actions.
* pushing back EOF:                      Actions.
* ranges in patterns:                    Patterns.
* ranges in patterns, negating:          Patterns.
* recognizing C comments:                Start Conditions.
* reentrant scanners, multiple interleaved scanners: Reentrant Uses.
* reentrant scanners, recursive invocation: Reentrant Uses.
* reentrant, accessing flex variables:   Global Replacement.
* reentrant, accessor functions:         Accessor Methods.
* reentrant, API explanation:            Reentrant Overview.
* reentrant, calling functions:          Extra Reentrant Argument.
* reentrant, example of:                 Reentrant Example.
* reentrant, explanation:                Reentrant.
* reentrant, extra data:                 Extra Data.
* reentrant, initialization:             Init and Destroy Functions.
* regular expressions, in patterns:      Patterns.
* REJECT:                                Actions.
* REJECT, calling multiple times:        Actions.
* REJECT, performance costs:             Performance.
* reporting bugs:                        Reporting Bugs.
* restarting the scanner:                Lex and Posix.
* RETURN, within actions:                Generated Scanner.
* rules, default:                        Simple Examples.
* rules, in flex input:                  Rules Section.
* scanner, definition of:                Introduction.
* sections of flex input:                Format.
* serialization:                         Serialized Tables.
* serialization of tables:               Creating Serialized Tables.
* serialized tables, multiple scanners:  Creating Serialized Tables.
* stacks, routines for manipulating:     Start Conditions.
* start condition, applying to multiple patterns: Start Conditions.
* start conditions:                      Start Conditions.
* start conditions, behavior of default rule: Start Conditions.
* start conditions, exclusive:           Start Conditions.
* start conditions, for different interpretations of same input: Start Conditions.
* start conditions, in patterns:         Patterns.
* start conditions, inclusive:           Start Conditions.
* start conditions, inclusive v.s. exclusive: Start Conditions.
* start conditions, integer values:      Start Conditions.
* start conditions, multiple:            Start Conditions.
* start conditions, special wildcard condition: Start Conditions.
* start conditions, use of a stack:      Start Conditions.
* start conditions, use of wildcard condition (<*>): Start Conditions.
* start conditions, using BEGIN:         Start Conditions.
* stdin, default for yyin:               Generated Scanner.
* stdout, as default for yyout:          Generated Scanner.
* strings, scanning strings instead of files: Multiple Input Buffers.
* tables, creating serialized:           Creating Serialized Tables.
* tables, file format:                   Tables File Format.
* tables, freeing:                       Loading and Unloading Serialized Tables.
* tables, loading and unloading:         Loading and Unloading Serialized Tables.
* terminating with yyterminate():        Actions.
* token:                                 Matching.
* trailing context, in patterns:         Patterns.
* trailing context, limits of:           Patterns.
* trailing context, matching:            Matching.
* trailing context, performance costs:   Performance.
* trailing context, variable length:     Performance.
* unput():                               Actions.
* unput(), and %pointer:                 Actions.
* unput(), pushing back characters:      Actions.
* user code, in flex input:              User Code Section.
* username expansion:                    Simple Examples.
* using integer values of start condition names: Start Conditions.
* verbatim text in patterns, syntax of:  Patterns.
* warning, dangerous trailing context:   Limitations.
* warning, rule cannot be matched:       Diagnostics.
* warnings, diagnostic messages:         Diagnostics.
* whitespace, compressing:               Actions.
* yacc interface:                        Yacc.
* yacc, interface:                       Yacc.
* YY_CURRENT_BUFFER, and multiple buffers: Multiple Input Buffers.
* YY_EXTRA_TYPE, defining your own type: Extra Data.
* YY_FLUSH_BUFFER():                     Actions.
* YY_INPUT:                              Generated Scanner.
* YY_INPUT, overriding:                  Generated Scanner.
* YY_START, example:                     Start Conditions.
* YY_USER_ACTION to track each time a rule is matched: Misc Macros.
* yyalloc, overriding:                   Overriding The Default Memory Management.
* yyfree, overriding:                    Overriding The Default Memory Management.
* yyin:                                  Generated Scanner.
* yyinput():                             Actions.
* yyleng:                                Matching.
* yyleng, modification of:               Actions.
* yyless():                              Actions.
* yyless(), pushing back characters:     Actions.
* yylex(), in generated scanner:         Generated Scanner.
* yylex(), overriding:                   Generated Scanner.
* yylex, overriding the prototype of:    Generated Scanner.
* yylineno, in a reentrant scanner:      Reentrant Functions.
* yylineno, performance costs:           Performance.
* yymore():                              Actions.
* yymore() to append token to previous token: Actions.
* yymore(), mega-kludge:                 Actions.
* yymore, and yyleng:                    Actions.
* yymore, performance penalty of:        Actions.
* yyout:                                 Generated Scanner.
* yyrealloc, overriding:                 Overriding The Default Memory Management.
* yyrestart():                           Generated Scanner.
* yyterminate():                         Actions.
* yytext:                                Matching.
* yytext, default array size:            User Values.
* yytext, memory considerations:         A Note About yytext And Memory.
* yytext, modification of:               Actions.
* yytext, two types of:                  Matching.
* yywrap():                              Generated Scanner.
* yywrap, default for:                   Generated Scanner.
* |, in actions:                         Actions.
* |, use of:                             Actions.

