<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
    "http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="cpp2html 1.1
by Lorenzo Bettini, bettini@gnu.org
http://w3.newnet.it/bettini
http://www.gnu.org/software/cpp2html/cpp2html.html">
<title>source file</title>
<link rel="stylesheet" href="mono.css" type="text/css">
</head>
<body>
<pre>
<tt>
<span class="comment">/*
** Copyright (C) 1999, 2000, Lorenzo Bettini &lt;lorenzo.bettini@penteres.it&gt;
**  
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU General Public License as published by
** the Free Software Foundation; either version 2 of the License, or
** (at your option) any later version.
**  
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
**  
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**  
*/</span>

<span class="comment">// list.h
</span>
<span class="comment">/*
  Class List ( first element is dummy )
*/</span>

<span class="keyword">#include</span> <span class="string">&lt;iostream.h&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;stdlib.h&gt;</span>

<span class="keyword">#ifndef</span> LIST
<span class="keyword">#define</span> LIST

<span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
<span class="keyword">struct</span> ListNode
{
  TYPE elem ;
  ListNode&lt;TYPE&gt; *next ;

  ListNode() : next( <span class="number">0 </span>) {}
  ListNode( TYPE e, ListNode&lt;TYPE&gt; *n ) : elem( e ), next( n ) {}

  ListNode&lt;TYPE&gt; * Next() { <span class="keyword">return</span> next ; }
  TYPE &amp; Elem() { <span class="keyword">return</span> elem ; } 
} ;


<span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
<span class="keyword">class</span> List
{
	ListNode&lt;TYPE&gt; *first ;
	ListNode&lt;TYPE&gt; *last ;

	<span class="type">void</span> Clear() ;

<span class="keyword">public</span>:
	<span class="type">unsigned</span> length ;

	List() ;
	List( <span class="keyword">const</span> List&lt;TYPE&gt; &amp; l ) ;
	~List() ;

	ListNode&lt;TYPE&gt; * First() { <span class="keyword">return</span> first-&gt;next ; }
	<span class="type">void</span> AddToBack( TYPE el ) ; <span class="comment">// aggiunge in coda
</span>	<span class="type">void</span> AddToFront( TYPE el ) ; <span class="comment">// aggiunge in testa
</span>	<span class="type">void</span> Add( TYPE el ) { AddToBack( el ) ; }
	<span class="type">void</span> OwnsNothing() ; <span class="comment">// notifica alla lista che ha perso gli elementi
</span>	<span class="type">int</span> Empty() { <span class="keyword">return</span> first == last ; } <span class="comment">// la lista è vuota?
</span>	<span class="type">void</span> Flush() ; <span class="comment">// svuota la lista, ma senza distruggerla
</span>	TYPE ExtractFromFront() ; <span class="comment">// estrae dalla testa
</span>        <span class="type">void</span> Append( List&lt;TYPE&gt; &amp; l ) ; <span class="comment">// Append senza copia
</span>        <span class="type">void</span> Append( List&lt;TYPE&gt; *l ) ; <span class="comment">// idem
</span>	<span class="type">void</span> AppendDeep( List&lt;TYPE&gt; l ) ; <span class="comment">// Append con copia
</span>	<span class="type">unsigned</span> Length() { <span class="keyword">return</span> length ; }
	<span class="type">void</span> Copy( List&lt;TYPE&gt; &amp; source ) ; <span class="comment">// copia di un'altra lista
</span>	<span class="type">void</span> Detach( ListNode&lt;TYPE&gt; * l ) ; <span class="comment">// rimozione di un elemento
</span>	<span class="type">void</span> Check( ListNode&lt;TYPE&gt; * l ) ; <span class="comment">// L'allocazione è riuscita?
</span>	<span class="comment">// int HasMember( const TYPE &amp;i ) ;
</span>	<span class="comment">// void print() ; // stampa gli elementi della lista
</span>
} ;


<span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
List&lt;TYPE&gt;::List()
{
	first = <span class="keyword">new</span> ListNode&lt;TYPE&gt; ;
	Check( first ) ;
	last = first ;
	length = <span class="number">0 </span>;
}

<span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
List&lt;TYPE&gt;::List( <span class="keyword">const</span> List&lt;TYPE&gt; &amp; l )
{
	ListNode&lt;TYPE&gt; * tmp ;

	first = <span class="keyword">new</span> ListNode&lt;TYPE&gt; ;
	Check( first ) ;
	last = first ;
	length = <span class="number">0 </span>;

	tmp = l.first-&gt;next ;

	<span class="keyword">while</span>( tmp )
	{
		AddToBack( tmp-&gt;elem ) ;
		tmp = tmp-&gt;next ;
	}
}

<span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
<span class="type">void</span> List&lt;TYPE&gt;::Copy( List&lt;TYPE&gt; &amp; source )
{
	ListNode&lt;TYPE&gt; * tmp ;

	tmp = source.First() ;

	<span class="keyword">while</span>( tmp )
	{
		AddToBack( tmp-&gt;elem ) ;
		tmp = tmp-&gt;next ;
	}
}

<span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
<span class="type">void</span> List&lt;TYPE&gt;::Clear()
{
	ListNode&lt;TYPE&gt; *l1 ;
	ListNode&lt;TYPE&gt; *l2 ;

	l1 = first ;
	<span class="keyword">while</span> ( l1 )
	{
		l2 = l1-&gt;next ;
		<span class="keyword">delete</span> l1 ;
		l1 = l2 ;
	}
}

<span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
<span class="type">void</span> List&lt;TYPE&gt;::Flush()
{
	ListNode&lt;TYPE&gt; *l1 ;
	ListNode&lt;TYPE&gt; *l2 ;

	l1 = first-&gt;next ;
	<span class="comment">// la lista viene solo svuotata e non distrutta, quindi si deve
</span>	<span class="comment">// lasciare intatto il primo elemento fittizio
</span>
	<span class="keyword">while</span> ( l1 )
	{
		l2 = l1-&gt;next ;
		<span class="keyword">delete</span> l1 ;
		l1 = l2 ;
	}
	OwnsNothing() ;
}

<span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
List&lt;TYPE&gt;::~List()
{
	Clear() ;
}

<span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
<span class="type">void</span> List&lt;TYPE&gt;::AddToBack( TYPE el )
{
	ListNode&lt;TYPE&gt; *tmp ;
	tmp = <span class="keyword">new</span> ListNode&lt;TYPE&gt;( el, <span class="number">0 </span>) ;
	Check( tmp ) ;
	last-&gt;next = tmp ;
	last = last-&gt;next ;
	length++ ;
}

<span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
<span class="type">void</span> List&lt;TYPE&gt;::AddToFront( TYPE el )
{
	ListNode&lt;TYPE&gt; *tmp ;
	tmp = <span class="keyword">new</span> ListNode&lt;TYPE&gt;( el, <span class="number">0 </span>) ;
	Check( tmp ) ;
	<span class="keyword">if</span>( ! tmp )
	{
		cout &lt;&lt; <span class="string">"Allocazione fallita!"</span> &lt;&lt; endl ;
		abort() ;
	}
	tmp-&gt;next = first-&gt;next ;
	<span class="keyword">if</span> ( first == last ) last = tmp ;
	first-&gt;next = tmp ;
	length++ ;
}

<span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
TYPE List&lt;TYPE&gt;::ExtractFromFront()
{
	TYPE RetValue ;
	ListNode&lt;TYPE&gt; * tmp ;

	RetValue = first-&gt;next-&gt;elem ;
	tmp = first-&gt;next-&gt;next ;
	<span class="keyword">delete</span> first-&gt;next ;
	first-&gt;next = tmp ;
	length-- ;
	<span class="keyword">if</span> ( ! tmp ) last = first ;     <span class="comment">// la coda è vuota
</span>	<span class="keyword">return</span> RetValue ;
}

<span class="keyword">template</span>&lt;<span class="keyword">class</span> TYPE&gt;
<span class="type">void</span> List&lt;TYPE&gt;::Append( List&lt;TYPE&gt; * l )
{
  <span class="keyword">if</span> ( l )
    Append( *l ) ;
}
<span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
<span class="type">void</span> List&lt;TYPE&gt;::Append( List&lt;TYPE&gt; &amp; l )
{
        <span class="keyword">if</span>( ! l.Empty() )
	  {
                last-&gt;next = l.first-&gt;next ;
                last = l.last ;
                length += l.Length() ;
	  }
}

<span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
<span class="type">void</span> List&lt;TYPE&gt;::AppendDeep( List&lt;TYPE&gt; l )
{
  <span class="keyword">if</span> (!Empty()) {
    last-&gt;next=l.first;  last=l.last; 
    length+=l.length;
    l.first=l.last=NULL; <span class="comment">// to avoid destruction of elements
</span>  } <span class="keyword">else</span> {
    first=l.first;  last=l.last; 
    length=l.length;
    l.first=l.last=NULL;
  }
}

<span class="comment">// comunica alla lista che non possiede piu' i suoi elementi :
</span><span class="comment">// qualcun'altro se ne e' impossessato
</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
<span class="type">void</span> List&lt;TYPE&gt;::OwnsNothing()
{
	last = first ;
	first-&gt;next = <span class="number">0 </span>;
	length = <span class="number">0 </span>;
}

<span class="comment">// l è il puntatore al nodo precedente a quello che si vuole deallocare :
</span><span class="comment">// in pratica si vuole deallocare il nodo puntato da l-&gt;next
</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
<span class="type">void</span> List&lt;TYPE&gt;::Detach( ListNode&lt;TYPE&gt; * l )
{
	ListNode&lt;TYPE&gt; * tmp ;

	<span class="keyword">if</span>( l-&gt;next == last )
		last = l ;

	tmp = l-&gt;next-&gt;next ;
	<span class="keyword">delete</span> l-&gt;next ;
	l-&gt;next = tmp ;
	length-- ;
}

<span class="comment">// controlla che l'allocazione nello heap abbia avuto successo
</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
<span class="type">void</span> List&lt;TYPE&gt;::Check( ListNode&lt;TYPE&gt; * l )
{
	<span class="keyword">if</span>( ! l )
	{
		cout &lt;&lt; <span class="string">"List non ha potuto allocare un nodo : "</span> &lt;&lt; endl ;
		cout &lt;&lt; <span class="string">"MEMORIA ESAURITA !"</span> &lt;&lt; endl ;
		abort() ;
	}
}


<span class="keyword">#endif</span>
</tt>
</pre>
</body>
</html>
