<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ZThread::Executor class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.15 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>Executor  Class Reference</h1><code>#include &lt;Executor.h&gt;</code>
<p>
<p>Inheritance diagram for Executor:
<p><center><img src="classZThread_1_1Executor.png" usemap="#Executor_map" border="0"></center>
<map name="Executor_map">
<area href="classZThread_1_1Cancelable.html" alt="Cancelable" shape="rect" coords="73,0,210,24">
<area href="classZThread_1_1Waitable.html" alt="Waitable" shape="rect" coords="220,0,357,24">
<area href="classZThread_1_1NonCopyable.html" alt="NonCopyable" shape="rect" coords="367,0,504,24">
<area href="classZThread_1_1ConcurrentExecutor.html" alt="ConcurrentExecutor" shape="rect" coords="0,112,137,136">
<area href="classZThread_1_1PoolExecutor.html" alt="PoolExecutor" shape="rect" coords="147,112,284,136">
<area href="classZThread_1_1SynchronousExecutor.html" alt="SynchronousExecutor" shape="rect" coords="294,112,431,136">
<area href="classZThread_1_1ThreadedExecutor.html" alt="ThreadedExecutor" shape="rect" coords="441,112,578,136">
</map>
<a href="classZThread_1_1Executor-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top><a name="a0" doxytag="ZThread::Executor::~Executor"></a>
virtual&nbsp;</td><td valign=bottom><a class="el" href="classZThread_1_1Executor.html#a0">~Executor</a> ()  throw ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Destroy an <a class="el" href="classZThread_1_1Executor.html">Executor</a>.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classZThread_1_1Executor.html#a1">execute</a> (const RunnableHandle &amp;task)=0  throw (Synchronization_Exception)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classZThread_1_1Executor.html#a2">cancel</a> ()=0  throw (Synchronization_Exception)</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classZThread_1_1Executor.html#a3">wait</a> ()=0  throw (Synchronization_Exception)</td></tr>
<tr><td nowrap align=right valign=top>virtual bool&nbsp;</td><td valign=bottom><a class="el" href="classZThread_1_1Executor.html#a4">wait</a> (unsigned long)=0  throw (Synchronization_Exception)</td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<dl compact><dt><b>
Author: </b><dd>
Eric Crahen &lt;<a href="mailto:crahen@cse.buffalo.edu">crahen@cse.buffalo.edu</a>&gt; </dl><dl compact><dt><b>
Date: </b><dd>
&lt;2002-06-04T07:49:11-0400&gt; </dl><dl compact><dt><b>
Version: </b><dd>
2.2.2</dl>Execeutors are an implementation of the <a class="el" href="classZThread_1_1Executor.html">Executor</a> pattern. This is a more versatile construct than a thread pool. I have written a short  paper describing this pattern.
<p>
Executors abstract the knowledge of <em>how</em>, <em>where</em> and  <em>when</em> to run a task, from the task itself. They are quite versatile objects. <a class="el" href="classZThread_1_1Runnable.html">Runnable</a> objects can be submitted to an <a class="el" href="classZThread_1_1Executor.html">Executor</a> and they will be run by the <a class="el" href="classZThread_1_1Executor.html">Executor</a> at some point.
<p>
Executors do not need to be joined. They simply need to be <a class="el" href="classZThread_1_1Executor.html#a2">cancel</a>()ed  at some point before the termination of your program.
<p>
An <a class="el" href="classZThread_1_1Executor.html">Executor</a> implements the <a class="el" href="classZThread_1_1Cancelable.html">Cancelable</a> interface, giving you some control over the lifetime of the <a class="el" href="classZThread_1_1Executor.html">Executor</a>.
<p>
<b>Disabling</b>
<p>
Cancelling an <a class="el" href="classZThread_1_1Executor.html">Executor</a> has the effect of preparing the <a class="el" href="classZThread_1_1Executor.html">Executor</a>  to shutdown, <em>disabling</em> it. An <a class="el" href="classZThread_1_1Executor.html">Executor</a> that has been <a class="el" href="classZThread_1_1Executor.html#a2">cancel</a>()ed  will no longer accept new tasks.
<p>
<em>Disabling</em> an <a class="el" href="classZThread_1_1Executor.html">Executor</a> does not discard the tasks it has previously been assigned. Those tasks will all be executed and are not lost.
<p>
<b>Exiting</b>
<p>
An <a class="el" href="classZThread_1_1Executor.html">Executor</a> will exit only after it has been <a class="el" href="classZThread_1_1Executor.html#a2">cancel</a>()ed. When a <a class="el" href="classZThread_1_1Executor.html#a2">cancel</a>()ed  <a class="el" href="classZThread_1_1Executor.html">Executor</a> depletes the tasks in its <a class="el" href="classZThread_1_1Queue.html">Queue</a>, it will allow its threads to exit. If it is not <a class="el" href="classZThread_1_1Executor.html#a2">cancel</a>()ed, its threads will run indefnently, which will  interfere with the clean termination of your program.
<p>
<dl compact><dt><b>
See also: </b><dd>
<a class="el" href="classZThread_1_1Cancelable.html">Cancelable</a></dl>An <a class="el" href="classZThread_1_1Executor.html">Executor</a> implements the <a class="el" href="classZThread_1_1Waitable.html">Waitable</a> interface, giving you a way to interact with it.
<p>
<b>Waiting</b>
<p>
For an <a class="el" href="classZThread_1_1Executor.html">Executor</a>, <em>waiting</em> means waiting for the current batch of tasks to be serviced. A thread that <a class="el" href="classZThread_1_1Executor.html#a3">wait</a>()s on an <a class="el" href="classZThread_1_1Executor.html">Executor</a> will be blocked until  all of its enqueued tasks are being serviced.
<p>
An <a class="el" href="classZThread_1_1Executor.html">Executor</a> can be <a class="el" href="classZThread_1_1Executor.html#a3">wait</a>()ed on many times. The completion of a <a class="el" href="classZThread_1_1Executor.html#a3">wait</a>() does not neccessarily mean the <a class="el" href="classZThread_1_1Executor.html">Executor</a> is done running tasks and its lifetime is about to come to an end. It simply means that it is about to become idle.
<p>
<dl compact><dt><b>
See also: </b><dd>
<a class="el" href="classZThread_1_1Waitable.html">Waitable</a></dl>Cancel()ing and Wait()ing on an <a class="el" href="classZThread_1_1Executor.html">Executor</a> will provide a way for an application to detect when an <a class="el" href="classZThread_1_1Executor.html">Executor</a> is about to come to the end of its lifetime. A <a class="el" href="classZThread_1_1Executor.html#a2">cancel</a>()ed <a class="el" href="classZThread_1_1Executor.html">Executor</a> won't accept more tasks, so when the <a class="el" href="classZThread_1_1Executor.html#a3">wait</a>() completes  you will know that it's pretty much done doing it job. 
<p>
<hr><h2>Member Function Documentation</h2>
<a name="a2" doxytag="ZThread::Executor::cancel"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void cancel </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classZThread_1_1Synchronization__Exception.html">Synchronization_Exception</a>)<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Stop the execution of additonal tasks by this <a class="el" href="classZThread_1_1Executor.html">Executor</a>. A <a class="el" href="classZThread_1_1Executor.html#a2">cancel</a>()ed <a class="el" href="classZThread_1_1Executor.html">Executor</a> will complete the task that are pending, or executing, but it will not accept any new tasks.<dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>InterruptedException</em>&nbsp;</td><td>
</td></tr>
</table>
</dl><dl compact><dt><b>
Postcondition: </b><dd>
the <a class="el" href="classZThread_1_1Executor.html">Executor</a> no longer accepts new tasks. </dl>
<p>
Implements <a class="el" href="classZThread_1_1Cancelable.html#a1">Cancelable</a>.
<p>
Implemented in <a class="el" href="classZThread_1_1ConcurrentExecutor.html#a4">ConcurrentExecutor</a>, <a class="el" href="classZThread_1_1PoolExecutor.html#a9">PoolExecutor</a>, <a class="el" href="classZThread_1_1SynchronousExecutor.html#a4">SynchronousExecutor</a>, and <a class="el" href="classZThread_1_1ThreadedExecutor.html#a4">ThreadedExecutor</a>.    </td>
  </tr>
</table>
<a name="a1" doxytag="ZThread::Executor::execute"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void execute </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const RunnableHandle &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>task</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classZThread_1_1Synchronization__Exception.html">Synchronization_Exception</a>)<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Submit a light wieght task to an <a class="el" href="classZThread_1_1Executor.html">Executor</a>.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>task</em>&nbsp;</td><td>
- command that will be executed</td></tr>
</table>
</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classZThread_1_1Synchronization__Exception.html">Synchronization_Exception</a></em>&nbsp;</td><td>
 thrown is some other error occurs. </td></tr>
</table>
</dl>
<p>
Implemented in <a class="el" href="classZThread_1_1ConcurrentExecutor.html#a2">ConcurrentExecutor</a>, <a class="el" href="classZThread_1_1PoolExecutor.html#a7">PoolExecutor</a>, <a class="el" href="classZThread_1_1SynchronousExecutor.html#a2">SynchronousExecutor</a>, and <a class="el" href="classZThread_1_1ThreadedExecutor.html#a2">ThreadedExecutor</a>.    </td>
  </tr>
</table>
<a name="a4" doxytag="ZThread::Executor::wait"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual bool wait </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>long</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classZThread_1_1Synchronization__Exception.html">Synchronization_Exception</a>)<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait for all pending and currently executing tasks to complete or or the given amount of time to expire. This method will block the  calling thread, for an definite amount of time, until no more tasks  are available and the <a class="el" href="classZThread_1_1Executor.html">Executor</a> is about to become idle.
<p>
However, this method does not garuntee that an <a class="el" href="classZThread_1_1Executor.html">Executor</a> is finished  executing tasks. It's possible for more tasks to be submitted after  a <a class="el" href="classZThread_1_1Executor.html#a3">wait</a>()ing thread has been awakened. In order to <a class="el" href="classZThread_1_1Executor.html#a3">wait</a>() until an  <a class="el" href="classZThread_1_1Executor.html">Executor</a> is done running tasks for good, the <a class="el" href="classZThread_1_1Executor.html">Executor</a> should first be  <a class="el" href="classZThread_1_1Executor.html#a2">cancel</a>()ed.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>timeout</em>&nbsp;</td><td>
unsigned long - maximum amount of time (milliseconds) to <a class="el" href="classZThread_1_1Executor.html#a3">wait</a>() for an <a class="el" href="classZThread_1_1Executor.html">Executor</a>.</td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
true if the <a class="el" href="classZThread_1_1Executor.html#a3">wait</a>() completes in the given amount of time;  otherwise false.</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classZThread_1_1Interrupted__Exception.html">Interrupted_Exception</a></em>&nbsp;</td><td>
 a <a class="el" href="classZThread_1_1Executor.html#a3">wait</a>() can be aborted prematurely  by interrupt()ing a <a class="el" href="classZThread_1_1Executor.html#a3">wait</a>()ing thread. </td></tr>
<tr><td valign=top><em><a class="el" href="classZThread_1_1Synchronization__Exception.html">Synchronization_Exception</a></em>&nbsp;</td><td>
 throw if there is some other error. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classZThread_1_1Waitable.html#a2">Waitable</a>.
<p>
Implemented in <a class="el" href="classZThread_1_1ConcurrentExecutor.html#a7">ConcurrentExecutor</a>, <a class="el" href="classZThread_1_1PoolExecutor.html#a12">PoolExecutor</a>, <a class="el" href="classZThread_1_1SynchronousExecutor.html#a7">SynchronousExecutor</a>, and <a class="el" href="classZThread_1_1ThreadedExecutor.html#a7">ThreadedExecutor</a>.    </td>
  </tr>
</table>
<a name="a3" doxytag="ZThread::Executor::wait"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void wait </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classZThread_1_1Synchronization__Exception.html">Synchronization_Exception</a>)<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait for all pending and currently executing tasks to complete. This method will block the calling thread, for an indefinite amount of time, until no more tasks are available and the <a class="el" href="classZThread_1_1Executor.html">Executor</a> is  about to become idle.
<p>
However, this method does not garuntee that an <a class="el" href="classZThread_1_1Executor.html">Executor</a> is finished  executing tasks. It's possible for more tasks to be submitted after  a <a class="el" href="classZThread_1_1Executor.html#a3">wait</a>()ing thread has been awakened. In order to <a class="el" href="classZThread_1_1Executor.html#a3">wait</a>() until an  <a class="el" href="classZThread_1_1Executor.html">Executor</a> is done running tasks for good, the <a class="el" href="classZThread_1_1Executor.html">Executor</a> should first be  <a class="el" href="classZThread_1_1Executor.html#a2">cancel</a>()ed.<dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classZThread_1_1Interrupted__Exception.html">Interrupted_Exception</a></em>&nbsp;</td><td>
 a <a class="el" href="classZThread_1_1Executor.html#a3">wait</a>() can be aborted prematurely  by interrupt()ing a <a class="el" href="classZThread_1_1Executor.html#a3">wait</a>()ing thread. </td></tr>
<tr><td valign=top><em><a class="el" href="classZThread_1_1Synchronization__Exception.html">Synchronization_Exception</a></em>&nbsp;</td><td>
 throw if there is some other error. </td></tr>
</table>
</dl>
<p>
Reimplemented from <a class="el" href="classZThread_1_1Waitable.html#a1">Waitable</a>.
<p>
Implemented in <a class="el" href="classZThread_1_1ConcurrentExecutor.html#a6">ConcurrentExecutor</a>, <a class="el" href="classZThread_1_1PoolExecutor.html#a11">PoolExecutor</a>, <a class="el" href="classZThread_1_1SynchronousExecutor.html#a6">SynchronousExecutor</a>, and <a class="el" href="classZThread_1_1ThreadedExecutor.html#a6">ThreadedExecutor</a>.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li>Executor.h</ul>
<hr><address align="right"><small>Generated on Mon Jun 10 22:44:45 2002 for ZThread by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.15 </small></address>
</body>
</html>
