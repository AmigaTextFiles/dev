<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ZThread::Waitable class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.15 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>Waitable  Class Reference</h1><code>#include &lt;Waitable.h&gt;</code>
<p>
<p>Inheritance diagram for Waitable:
<p><center><img src="classZThread_1_1Waitable.png" usemap="#Waitable_map" border="0"></center>
<map name="Waitable_map">
<area href="classZThread_1_1Barrier.html" alt="Barrier" shape="rect" coords="0,56,137,80">
<area href="classZThread_1_1Condition.html" alt="Condition" shape="rect" coords="147,56,284,80">
<area href="classZThread_1_1Executor.html" alt="Executor" shape="rect" coords="294,56,431,80">
<area href="classZThread_1_1Future.html" alt="Future" shape="rect" coords="441,56,578,80">
<area href="classZThread_1_1PriorityCondition.html" alt="PriorityCondition" shape="rect" coords="588,56,725,80">
<area href="classZThread_1_1ConcurrentExecutor.html" alt="ConcurrentExecutor" shape="rect" coords="73,112,210,136">
<area href="classZThread_1_1PoolExecutor.html" alt="PoolExecutor" shape="rect" coords="220,112,357,136">
<area href="classZThread_1_1SynchronousExecutor.html" alt="SynchronousExecutor" shape="rect" coords="367,112,504,136">
<area href="classZThread_1_1ThreadedExecutor.html" alt="ThreadedExecutor" shape="rect" coords="514,112,651,136">
</map>
<a href="classZThread_1_1Waitable-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top><a name="a0" doxytag="ZThread::Waitable::~Waitable"></a>
virtual&nbsp;</td><td valign=bottom><a class="el" href="classZThread_1_1Waitable.html#a0">~Waitable</a> ()  throw ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Destroy a <a class="el" href="classZThread_1_1Waitable.html">Waitable</a> object.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classZThread_1_1Waitable.html#a1">wait</a> ()  throw (Synchronization_Exception)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classZThread_1_1Waitable.html#a2">wait</a> (unsigned long)  throw (Synchronization_Exception)</td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<dl compact><dt><b>
Author: </b><dd>
Eric Crahen &lt;<a href="mailto:crahen@cse.buffalo.edu">crahen@cse.buffalo.edu</a>&gt; </dl><dl compact><dt><b>
Date: </b><dd>
&lt;2002-06-04T07:40:39-0400&gt; </dl><dl compact><dt><b>
Version: </b><dd>
2.2.1</dl>The <a class="el" href="classZThread_1_1Waitable.html">Waitable</a> interface defines a common method of adding general <em>wait</em> semantics to an object. This is simply defined as waiting for some condition to occur, however the definition of that conditon is fluid in that it is left to specialization of this class to define.
<p>
The following text describes the specific meaning of <em>wait</em> semantics in more detail.
<p>
<b>Waiting</b>
<p>
An object implementng the <a class="el" href="classZThread_1_1Waitable.html">Waitable</a> interface externalizes a mechanism for testing some internal condition. Another object may <em><a class="el" href="classZThread_1_1Waitable.html#a1">wait</a>()</em>s for a <a class="el" href="classZThread_1_1Waitable.html">Waitable</a> object;  in doing so, it <a class="el" href="classZThread_1_1Waitable.html#a1">wait</a>()s for that condition to become true by blocking the caller  while the condition is false.
<p>
<a class="el" href="classZThread_1_1Waitable.html">Waitable</a> objects may <b>never</b> <em>wait</em> for themselves. For example,  an <a class="el" href="classZThread_1_1Waitable.html">Waitable</a> object that calls its own <a class="el" href="classZThread_1_1Waitable.html#a1">wait</a>() method in its constructor or  destructor would be considered to be waiting for itself. This may or may not lead  to deadlock (depending on how an object extends <em>wait</em> semantics), but it should  never be neccessary. A <a class="el" href="classZThread_1_1Waitable.html">Waitable</a> object is already privy to the condition it is  exposing a waiting mechanism for; in other words, the information is already available within the object so it does not need to wait.
<p>
Other than the previous rule, Waiting semantics do <em>not</em> neccessarily provide  any garuntees regarding nor does it place any restrictions on thread safety,  preconditions, postconditions or even what constitutes the condition being <a class="el" href="classZThread_1_1Waitable.html#a1">wait</a>()ed for or how a <a class="el" href="classZThread_1_1Waitable.html#a1">wait</a>() is accomplised. It merly establishes the base for framework of more specialized meanings for <em>wait</em>.
<p>
The details of these semantics are refined further by specializaions of this  class, but the general conotation remains intact.
<p>
For example, a <a class="el" href="classZThread_1_1Condition.html">Condition</a> is <a class="el" href="classZThread_1_1Waitable.html">Waitable</a> object that extends <em>wait</em> semantics so that <a class="el" href="classZThread_1_1Waitable.html#a1">wait</a>()ing means a thread is blocked until some external stimulus  specifically performs an operation on the <a class="el" href="classZThread_1_1Condition.html">Condition</a> to make its internal condition true.  (serialization aside)
<p>
A <a class="el" href="classZThread_1_1Future.html">Future</a> extends <em>wait</em> semantics so that <a class="el" href="classZThread_1_1Waitable.html#a1">wait</a>()ing means that a task completed  somewhere and that some action be taken prior to the wait.
<p>
A <a class="el" href="classZThread_1_1Barrier.html">Barrier</a> extends <em>wait</em> semantics so that <a class="el" href="classZThread_1_1Waitable.html#a1">wait</a>()ing mean waiting for other  waiters, and may include automatically resetting the condition once a wait is complete.
<p>
Combining the <a class="el" href="classZThread_1_1Cancelable.html">Cancelable</a> interface with the <a class="el" href="classZThread_1_1Waitable.html">Waitable</a> interface creates a method  wait for an Excutor to complete its responisiblities, executing, which really means waiting  for a number of things all at once. 
<p>
<hr><h2>Member Function Documentation</h2>
<a name="a2" doxytag="ZThread::Waitable::wait"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool wait </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>long</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classZThread_1_1Synchronization__Exception.html">Synchronization_Exception</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait()ing on this object with a timeout will cause the calling thread  to be blocked for, at most, some definite period of time. The thread  executing will not proceed any further until the <a class="el" href="classZThread_1_1Waitable.html">Waitable</a> object releases  it unless and exception is thrown.
<p>
The semantics for how and when a <a class="el" href="classZThread_1_1Waitable.html">Waitable</a> object decides to release a  blocked thread are particular to each specialization of this class. The <a class="el" href="classZThread_1_1Waitable.html">Waitable</a> interface itself does not imply any garuntees about the state  of the environment (serial or otherwise); however specializations of this interface may do so.<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>timeout</em>&nbsp;</td><td>
- maximum amount of time (milliseconds) this method could block</td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
bool, true if the <a class="el" href="classZThread_1_1Waitable.html#a1">wait</a>() completed before the timeout expired. false otherwise.</dl><dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classZThread_1_1Interrupted__Exception.html">Interrupted_Exception</a></em>&nbsp;</td><td>
  This exception may be thrown if the wait is aborted prematurely do to the thread being interrupt()ed before it begins or during the wait. </td></tr>
<tr><td valign=top><em><a class="el" href="classZThread_1_1Synchronization__Exception.html">Synchronization_Exception</a></em>&nbsp;</td><td>
  Thrown if the wait cannot be accomplished because of some other error. </td></tr>
</table>
</dl>
<p>
Reimplemented in <a class="el" href="classZThread_1_1Barrier.html#a4">Barrier</a>, <a class="el" href="classZThread_1_1ConcurrentExecutor.html#a7">ConcurrentExecutor</a>, <a class="el" href="classZThread_1_1Condition.html#a5">Condition</a>, <a class="el" href="classZThread_1_1Executor.html#a4">Executor</a>, <a class="el" href="classZThread_1_1Future.html#a3">Future</a>, <a class="el" href="classZThread_1_1PoolExecutor.html#a12">PoolExecutor</a>, <a class="el" href="classZThread_1_1PriorityCondition.html#a5">PriorityCondition</a>, <a class="el" href="classZThread_1_1SynchronousExecutor.html#a7">SynchronousExecutor</a>, and <a class="el" href="classZThread_1_1ThreadedExecutor.html#a7">ThreadedExecutor</a>.    </td>
  </tr>
</table>
<a name="a1" doxytag="ZThread::Waitable::wait"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void wait </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>  throw (<a class="el" href="classZThread_1_1Synchronization__Exception.html">Synchronization_Exception</a>)</td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait()ing on this object will cause the calling thread to be blocked for some indefinite period of time. The thread executing will not proceed any further until the <a class="el" href="classZThread_1_1Waitable.html">Waitable</a> object releases it unless and exception is thrown.
<p>
The semantics for how and when a <a class="el" href="classZThread_1_1Waitable.html">Waitable</a> object decides to release a  blocked thread are particular to each specialization of this class. The <a class="el" href="classZThread_1_1Waitable.html">Waitable</a> interface itself does not imply any garuntees about the state  of the environment (serial or otherwise); however specializations of this interface may do so.<dl compact><dt><b>
Exceptions: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="el" href="classZThread_1_1Interrupted__Exception.html">Interrupted_Exception</a></em>&nbsp;</td><td>
  This exception may be thrown if the wait is aborted prematurely do to the thread being interrupt()ed before it begins or during the wait. </td></tr>
<tr><td valign=top><em><a class="el" href="classZThread_1_1Synchronization__Exception.html">Synchronization_Exception</a></em>&nbsp;</td><td>
  Thrown if the wait cannot be accomplished because of some other error. </td></tr>
</table>
</dl>
<p>
Reimplemented in <a class="el" href="classZThread_1_1Barrier.html#a3">Barrier</a>, <a class="el" href="classZThread_1_1ConcurrentExecutor.html#a6">ConcurrentExecutor</a>, <a class="el" href="classZThread_1_1Condition.html#a4">Condition</a>, <a class="el" href="classZThread_1_1Executor.html#a3">Executor</a>, <a class="el" href="classZThread_1_1Future.html#a2">Future</a>, <a class="el" href="classZThread_1_1PoolExecutor.html#a11">PoolExecutor</a>, <a class="el" href="classZThread_1_1PriorityCondition.html#a4">PriorityCondition</a>, <a class="el" href="classZThread_1_1SynchronousExecutor.html#a6">SynchronousExecutor</a>, and <a class="el" href="classZThread_1_1ThreadedExecutor.html#a6">ThreadedExecutor</a>.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li>Waitable.h</ul>
<hr><address align="right"><small>Generated on Mon Jun 10 22:44:46 2002 for ZThread by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.15 </small></address>
</body>
</html>
