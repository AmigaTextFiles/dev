This library was created for the purpose of making sockets easier to use,
not that their that terribly hard in the first place, just rather bulky
and not nice to look at.

Writing to sockets:
	I wrote a really simple function for writing to sockets, it uses
formats, so its pretty straight forward.  It comes in handy.
		eg:
			#include <ports.h>
			sockprintf(fd, "The time is %s.\n", cTime);


Creating and reading outbound sockets:
	With 2 simple functions, plus one that you write, you can
instantly have a socket that accepts information from whomever you connect
to.  It returns either a) a socket, or b) a negative number (signifies an
error).  Later on I will explain how to deal with errors.
		eg:
			#include <ports.h>
			int socket;
			socket = connect_to("127.0.0.1", 113);

There you go, instant socket.  If you want to read from it, you /must/
create a function to handle parsing, call it whatever you want.  It needs
to accept 3 arguments:
	a char* (your buffer)
	an int (amount of data read)
	another int (which socket it was read from)

Now, to read from the socket, you create some sort of a loop that calls
something like this
		eg:
			readfrom(socket, buffersize, &parsefunction);

socket is the socket you wish to read from, buffersize is the amount to
read at one time (must be positive :), and "&parsefunction" is a pointer
to your parsing function.  Say you called your parser "myparser", you
would pass "&myparser".  Fairly straight forward.


Creating and reading inbound sockets:
	This gets a little bit more complex.  Its still much simpler then
if you had done it yourself :)  Initially, you create a socket that
listens to a certain port, you can also specify the max number of
connections as well.  It will return a struct (see ports.h for specifics),
you need to accept this and use it for reading as it contains information
about the socket.
		eg:
			#include <ports.h>
			sock_listen *sock;
			sock = listen_to(6553, 5);

The first argument is the port you want to listen to, the second argument
is the maximum number of connections allowed at one time.

Again, you will need a parser that takes these 3 arguments:
        a char* (your buffer)
        an int (amount of data read)
        another int (which socket it was read from)

You read in almost the same way as an outbound socket.  You create a loop
and pass something like this.
		eg:
			readfromlisten(sock, buffersize, &parser);

sock is the struct returned by listen_to(), buffersize is the amount to
read at one time (must be positive :), and "&parsefunction" is a pointer
to your parsing function.  Say you called your parser "myparser", you
would pass "&myparser".  Now you understand why the parser needs to take
the argument of which file descriptor this information came from.  NOTE:
when a NEW connection is established, the parsing function is called, if
the buffer is NULL and len 0, fd will equal the new socket, you should
handle it appropriatly.  When a connection is ended by the user, the
parser will be passed a NULL buffer, len will be -1 and the fd is the
socket that disconnected. This function will return -9 if the listening
socket is terminated for whatever reason.

Since we're dealing with multiple sockets, a loop is used when reading a
socket, no matter your buffer size, it will read ALL available information
and then proceed to the next socket.  My suggestion is use a fairly large
buffer.. 8-16k should be fine.


Finding sockets:
	Quite often when you work, you'll get lazy like me, you may not
want to keep another struct to keep track of which slot each FD is in, or
you want to but don't have a function to find it.  New in 0.20 i added a
"findsock" function, it was originally internal, but since it become
neccessary, I've changed it.
		eg:
			#include <ports.h>
			int x;
			x = findsock(fd, socklisten_struct);


Closing sockets:
	Since a struct is kept to hold all information about clients and
their sockets, you need a way to delete this socket and get rid of their
information to allow new connections.  It is very similar to findsock
since it takes the same arguments and returns a 1 or 0 depending on if it
succeeded or not.  You only need to use this if you plan to kill an active
socket.  An internal copy of this function is executed when a client
disconnects on its own. NOTE: You do not need to close() the sock before
hand.
		eg:
			#include <ports.h>
			int x;
			x = closesock(fd, socklisten_struct);



Handling errors:
	My error handling is rather cheesy and not very descriptive, but
it may help.  When you create your socket to listen or read from, it
always returns a number, if this number is >0 and would like to find out
what the error is, call porterror(), like this.
		eg:
			#include <ports.h>
			printf("Error: %s\n", porterror(sock->sock_fd));
						or
			printf("Error: %s\n", porterror(socket));

And thats about it.  You can look in the "tests" directory for test01, 
test02, and test03.  test01 and test02 will require some editing to suite
your needs.

test01 handles opening and reading outbound sockets  
test02 handles creating and reading inbound sockets.  
test03 tests everything all at once and returns OK or FAIL.

Read the comments I put in them, they explain what needs changing..


Hopefully this library will help some people.  
Drop me a line, miles@turboflux.net
