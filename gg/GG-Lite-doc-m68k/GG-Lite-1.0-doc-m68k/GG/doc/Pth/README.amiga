   ____  _   _
  |  _ \| |_| |__
  | |_) | __| '_ \                    ``Only those who attempt
  |  __/| |_| | | |                     the absurd can achieve
  |_|    \__|_| |_|                     the impossible.''

  GNU Pth - The GNU Portable Threads
  Version 2.0.7 (08-Jun-2006)
  (second Amiga release)

---

NEWS:
     [20-Oct-2010]   x.x   Great news, timed-events-lockup-issue was
                           located in 'ixemul' and sloved(48.3-3), thus
                           there is no need for hacks anymore.
     [30-May-2009]   x.x   Small changes again in the readme & 'bonus/'.
     [19-Oct-2008]   x.x   'README.amiga' and 'bonus/' updates/changes.

---

NOTES:

[*]
Requires 68000/68020/68040+(no FPU), ixemul 48+

[*]
This package comes with: 'sscm(soft system call mapping)' which provides
emu functions(replacements or semi wrapped of 'ixemul' ones) and 'hscm(hard
system call mapping)' which allows to use original 'ixemul' functions and
not block whole process while using them in a thread. 'hscm' is what most
of you want to link against in order to achieve "true" multi-threading.

[*]
To use 'libc.a' equivalents in 'hscm' mode directly with 'libpth.a' add 
'-D_PTH_PRIVATE' to the 'gcc' cmd line or place '#define _PTH_PRIVATE 1'
before 'pth.h'. 'hscm' with 'libpthread.a' requires '-D_PTHREAD_PRIVATE'.
If you add these defines and link to 'sscm' then 'ixemul' functions will
be used natively. You may be asking of: "Hey, man why two types of libs,
cant you just put 'libc.a' in front of 'libpth.a' and achive 'sscm' with
'hscm' ?" No. Look at the source, there is a macro that determines how to
call certain function, in 'sscm'(call is bridged):

   #define pth_sc(func) func

and in 'hscm'(call is made to the wrapper in which 'syscall()' is used):

   #define pth_sc(func) pth_sc_##func

The thing is, that this macro is also used internally, so there is no way
to be pure 'sscm' with 'hscm'.

[*]
'pth_fork()' doesnt work and is unmappable('vfork()' or 'ix_vfork()' cant
be called in a wrapper).

[*]
'pth_system()' has been modified and freed of 'pth_fork()' dependency,
thus works.

[*]
Funcs below can be used standalone, but keep in mind that they depend on
pthread internals so executable can be big. Pay attention to 'nanosleep()',
'poll()' or 'select()', the first two dont exist in 'ixemul' and last is
a great alternative.

   __pthread_sleep()    __pthread_nanosleep()    __pthread_usleep() 
   __pthread_system()   __pthread_sigwait()      __pthread_waitpid() 
   __pthread_connect()  __pthread_accept()       __pthread_select() 
   __pthread_poll()     __pthread_read()         __pthread_write() 
   __pthread_readv()    __pthread_writev()       __pthread_recv() 
   __pthread_send()     __pthread_recvfrom()     __pthread_sendto() 
   __pthread_pread()    __pthread_pwrite() 

[*]
If you want to rebuild, copy everything from 'chunks/' to your source dist.
first, and then modify it further. My 'Makefile.in' is 'libtool' free so it
allows to build whole package as twice as fast.

[*]
Interesingly or not my system(68040/33) is capable of 9319 user-space
context switches per second.

[*]
Did many tests and it seems library is quite functional.

---

PROBS:

[*]
If for some reason you cant use 'ixemul' 48.3-3 that fixes signal bug in
'select()', then try to insert following code,

        if ((delay.tv_sec == 0)     &&
            (delay.tv_usec < 5000))
        {
          delay.tv_usec = 0;
        }

at line 593 of 'pth_sched.c'(a part where polling occurrs) and recompile.

[*]
For 'pthread_switch_me()'(OBSOLETE!) see 'bonus/' directory. 

---
megacz@usa.com
