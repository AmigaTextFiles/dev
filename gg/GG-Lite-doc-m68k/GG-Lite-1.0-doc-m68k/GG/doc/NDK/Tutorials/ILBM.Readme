
V39 Support Issues related to Display Modes and ILBM's
======================================================

Copyright (c) 1985-1992 Commodore-Amiga, Inc.  All Rights Reserved
Preliminary, Confidential, and Subject to Change


For compatibility with and support of enhanced Amiga graphics
capabilities, both short-term, and long-term possibilities, you must
modify your software to remove any built-in limitations which would
prevent you from growing WITH the Amiga.


1. Get RID of Hardcoded Limits, Write Software that Adapts

Many of the Amiga graphics software packages currently on the market
are hardcoded like the old "DF0: DH0:" file requesters.

Such hardcoded graphics application software limits include:

	- offering a fixed set of display modes or sizes
	- offering a fixed range of depths or sizes for certain display modes
	- loading or handling a maximum of 32 colors
	- Dealing with color guns as 4-bit values


The first thing you need to think about when upgrading your application
for V39, is NOT to upgrade it for V39.  You must upgrade your software
so that it can adapt to arbitrary display modes, depths, and sizes.

If you offer different display modes, do not arbitrarily restrict
the modes that you offer.  If 8-bitplane hires, or hires HAM, are
supported by a new chip set, and your software restricts a user to
5-bitplane hires and lores HAM, then your software will be obsolete.

Rewrite your software to use features such as the 2.1 display mode
requester.  Make sure that can adapt to larger palettes.  Handle
R G and B values internally as 8-bits, not 4.



2. Proper IFF ILBM Support

    A. Proper ILBM.CAMG Chunk
       ======================
	1. Saving
	
	If running under V36 or higher, save ULONG GetVPModeID(viewport)
	as-is.

	ISSUE: If you save a mode like VGA, and an old loader that
	just uses the low word of the CAMG loads it, it will display
	as non-interlace picture (because the VGA ModeID does not have
	the "lace" bit set in its 32-bit modeid number).  Because of this,
	you may wish to give your user the option of saving pictures with
	CAMG modes other than their native display id. 

	
	2. Loading

	Support using full 32-bit modeid's from CAMG (with screening
	for bad ID's and fallback code if ModeNotAvailable(modeid).
	Screening required because there are some CAMG's out there with
	garbage in the upper word.  See sample "getcamg" code at end.


    B. Proper ILBM.BMHD X and Y aspect
       ===============================
	1. Saving

	See "getaspect" code below.  This code gets the correct
	aspect ratio for any viewport modeid from the display
	database.  If running under < V36, it falls back to
	updated 2.0-compatible aspect values for old modes.

	2. Loading

	Perhaps you can start to expect reasonable information
	in the ILBM.BMHD x and y aspect fields.


    C. Proper 8-bit-per-gun ILBM.CMAP
       ==============================

	1. Saving

	Either always save as eight bits per gun, or offer an
	8-bit palette option.  When saving 8-per-gun from
	4-bit-per-gun source, do NOT left justify the 4 bits
	in R, G, and B bytes, but rather SCALE each 4-bit value to
	8 bits by duplicating the 4-bit value in the upper and lower
	nibble of its R, G, or B CMAP byte.


	2. Loading

	Detect and use full color resolution 8-bit-per-gun CMAPs
	when on a V39 or higher machine.  One (only?) method
	of detection may be to check if EVERY CMAP byte has 0 as
	its low nibble.  It may be better to use an 8-bit palette
	use option to flag whether all 8 bits of of each gun should
	be considered significant.

	ISSUES: Looking for all-zero low nibbles is not really a good
	way to determine 4-bit shifted CMAPs.  We might define a bit of
	the BMHD Reserved1 (pad1) field to signify that 8 significant
	bits-per-gun have been saved.  In addition, the OS engineers
	are working on a DisplayInfo chunk (DINF) which would provide
	this and other enhanced display mode information.


    D.  Stop Limiting Color Register Load Counts to 32
        ==============================================

	Older IFF code, and even the earlier NewIFF code would
	read any number of colors from an ILBM CMAP, but would
	only set a maximum 32 colors in the display.  
	Instead, the maximum number of colors set in the display
	should be limited by the display Viewport's ColorMap->Count
	rather than a hardcoded limit.


    E.  Stop Limiting Depth to 5/6
        ==========================

	Older IFF code had fixed limits for the maximum allowable
	depth for displays and ILBMs.  Remove your limits.
	Display as much as the system can handle.  Don't reject
	depths and depth/mode combinations arbitrarily.
	Also, you may want to stop assuming that a 6-plane ILBM
	with no CAMG is HAM or HALFBRITE (although that might still
	be a good assumption since only a pretty lame program would
	write a HAM or HALFBRITE ILBM with no CAMG chunk).

	
    F. 	Watch out for interleaved bitmaps
       	=================================
	
	If your application supports capturing any screen, you
	must watch out for the new interleaved bitmaps.
	An interleaved BitMap's BytesPerRow field is still the
	modulo for getting from any one pixel to the pixel directly
	below it, BUT it is no longer related to the rounded up
	width of the screen or viewport.  Instead, it is a MUCH
	larger value which is actually the rounded up BitMap scan
	line width TIMES the depth.  Do not assume that BytesPerRow
	is related to the width of the display.

	NOTE: The 2.0 Native Developer Update release of the NewIFF
	code had 2 major bugs.  The screen.c module had a 1.3
	incompatibility, and the ilbmr.c module could not properly
	save an interleaved bitmap (such as the V39 Workbench screen).
	See the newer version 37.9 of the NewIFF code.  This has
	been placed in our listinsg area on BIX, and sent to ADSP, and
	sent to Fred Fish.  Note that this release of the NewIFF code
	(37.9) does not yet contain any direct V39 or locale support.
	However, it was written with these in mind.

	Under V39, an interleaved bitmap can be detected by:

	if(GetBitMapAttr(bitmap_ptr,BMA_FLAGS) & BMF_INTERLEAVED)
		printf("is interleaved\n");


    G. Proper Printing of new Display Modes
       ====================================

	When dumping a rastport to printer under V36 and higher,
	the following IORequest field must contain a 32-bit modeid
	such as that returned by GetVPModeID(viewport).  You
	may want to allow the user the ability to print a display
	with a different modeid than it is being displayed in.
	Passing the full modeid allows the printer.device to
	properly control the aspect of the output.

	   ULONG   io_Modes;               /* graphics viewport modes */


 
-------------------------- getcamg -------------------------------
From: /* ilbmr.c --- ILBM loading routines for use with iffparse */

/*
 * Returns CAMG or computed mode for storage in ilbm->camg
 *
 * ilbm->Bmhd structure must be initialized prior to this call.
 */
ULONG getcamg(struct ILBMInfo *ilbm)
	{
	struct IFFHandle *iff;
	struct StoredProperty *sp;
	UWORD  wide,high,deep;
	ULONG modeid = 0L;

    	if(!(iff=ilbm->ParseInfo.iff))	return(0L);

	wide = ilbm->Bmhd.pageWidth;
	high = ilbm->Bmhd.pageHeight;
	deep = ilbm->Bmhd.nPlanes;

	D(bug("Getting CAMG for w=%ld h=%ld d=%ld ILBM\n",wide,high,deep));

        /*
         * Grab CAMG's idea of the viewmodes.
         */
        if (sp = FindProp (iff, ID_ILBM, ID_CAMG))
                {
                modeid = (* (ULONG *) sp->sp_Data);

                /* knock bad bits out of old-style 16-bit viewmode CAMGs
                 */
                if((!(modeid & MONITOR_ID_MASK))||
		  ((modeid & EXTENDED_MODE)&&(!(modeid & 0xFFFF0000))))
                   modeid &= 
		    (~(EXTENDED_MODE|SPRITES|GENLOCK_AUDIO|GENLOCK_VIDEO|VP_HIDE));

                /* check for bogus CAMG like DPaintII brushes
                 * with junk in upper word and extended bit
                 * not set in lower word.
                 */
                if((modeid & 0xFFFF0000)&&(!(modeid & 0x00001000))) sp=NULL;
                }

        if(!sp) {
                /*
                 * No CAMG (or bad CAMG) present; use computed modes.
                 */
                if (wide >= 640)        modeid = HIRES;
                if (high >= 400)        modeid |= LACE;

		/* This 6 planes == HAM or HALFBRITE is not
		 * necessarily true anymore, but hopefully
		 * all NEW programs are writing a proper CAMG chunk!!
		 */
                if (deep == 6)
                        {
                        modeid |= ilbm->EHB ? EXTRA_HALFBRITE : HAM;
                        }

		D(bug("No CAMG found - using mode $%08lx\n",modeid));
                }

	D(bug("getcamg: modeid = $%08lx\n",modeid));
	return(modeid);
	}


-------------------------- getaspect -------------------------------

    bmhd->xAspect = 0;  /* So we can tell when we've got it */
    if(GfxBase->lib_Version >=36)
        {
        if(GetDisplayInfoData(NULL, (UBYTE *)&DI,
                sizeof(struct DisplayInfo), DTAG_DISP, modeid))
                {
                bmhd->xAspect =  DI.Resolution.x;
                bmhd->yAspect =  DI.Resolution.y;
                }
        }

    /* If running under 1.3 or GetDisplayInfoData failed, use old method
     * of guessing aspect ratio
     */
    if(! bmhd->xAspect)
        {
        bmhd->xAspect =  44;
        bmhd->yAspect =
                ((struct GfxBase *)GfxBase)->DisplayFlags & PAL ? 44 : 52;
        if(modeid & HIRES)      bmhd->xAspect = bmhd->xAspect >> 1;
        if(modeid & LACE)       bmhd->yAspect = bmhd->yAspect >> 1;
        }

