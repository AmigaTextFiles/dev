                              WhatIs.library

                           Copyright S.R. & P.C.

    1.Usage
    2.User's documentation
    3.Programmer's documentation


    1)

    What  is  whatis.library  ?   It  is a shared amiga library which alow
programmers  to easyly recognize type of files (ilbm, 8svx, maxiplan, exe,
PP,  etc....) BUT the final user (non-programer user) can define new types
so  all programs which use whatis.library can recognize this new type.  At
this  moment  only  BrowserII,  For  and  AddIcon use whatis.library but I
planned  to  rewrite  Icon  ( a program which make WorkBench 2.0 recognize
files  which  have  no  icon), and I encourage all programmers to use this
library  so users can define new types only one time and every program can
use it.  I actualy work on version which support the datatype of KickStart
3.0  so  user  of whatis.library can use both the customisable whatis type
and the standard datatype type.

    For  example,  you  love  graphics, you digitize lots of image with an
official  commercial  program  which  produce  file  ".img",  and you want
BrowserII  can reconised it, well, you define this new type in S:FileTypes
and  whatis.library  know  what  it  is, so you BrowserII can do automatic
thing  on  your  file ".img", but all program which use whatis.library can
reconised  the  ".img"-type  you  just  defined  and  can do what they are
supposed to do with them.

List  of  type  that  whatis.library reconize without any S:FileType file:
DOS_DEVICE  VOLUME  ASSIGN  DIR EXECUTABLE EXECPP40 EXECPP30 EXECPP SCRIPT
TEXT  OBJECT  LIB  IFF  ILBM  ILBM24  ANIM  8SVX SMUS FTXT PREFS TERM ICON
IMPDATA PPDATA ZOO LHARC MEDMOD


    2)
Well,  user.   All  you  need  is  to  know  how  to define a new type.  A
sample/starter  FileTypes  file is provided.  First, have a look at it and
then read what follows, I think there is not much to say.

There are 2 methods to scan a file: DEEP and LIGHT.
The  Light  one  is  only  based on the file name and eventualy protection
bits.  It is fast but unsafe.  if you rename an executable as "File.c" and
you   ask  for  a  light  scan  (BrowserII  with  "find  type  by  name"),
WhatIs.library think it is a C language source file.
The  DEEP  one  (currently  only one DEEP mode) is more powerfull, but the
slowest  because  each  file  must be open and the first few bytes scanned
(currently 484 bytes), so this slow down directory scans.


FileTypes syntax:

While not necessary, we recommand use of quotes (") delimiters for strings
to avoid mistakes. The # character can be found in strings while it is the
comment starting char.
The "#" char marks the begining of comment until end of ligne.

# example definition:
TYPE "Src Ada"  # you define a new type, it's IDString (curently 9
                # char max) is "Src Ada", this is the string that
                # WhatIs.library will return and you can see in
                # BrowserII  when you ask the "Show file type", it
                # is also the way you identify this FileType.

    SUBTYPE "Text"  # OPTIONNAL: First, the file MUST be a "Text" type,
                    # this means that if the file is not of this type
                    # it cannot be a "Src Ada"

    INSERTAFTER "Script"    # OPTIONNAL: You want the type "Src Ada" to be
                            # put after the "Script" type in list. The
                            # type list is not alphabetically-sorted.
                            # This determine the order in which you see
                            # files when you choose "Sort by file type"
                            # in BrowserII

    ICONNAME "def_Src Ada"  # OPTIONNAL: this the name of the default
                            # icon file name. These files should be in
                            # the "ENV:Sys/" directory, where WB 2.0 put
                            # its default icons. This will be used by
                            # AddIcon (In BrowserII and given cli command
                            # This string is returned by GetIconName()

    # now come the decription of the file, if ANY condition below is
    # not satisfied, the WhatIs.library think it is not this filetype.
    # Exepte for OPNAMEPATTERN which is used for light WhatIs() (only
    # based on the file name)

    NAMEPATTERN "#?.ada"    # OPTIONNAL: if given, the filename must match
                            # this pattern.
                            # it is mutualy exclusive with OPTNAMEPATTERN

    OPTNAMEPATTERN "#?.ada" # OPTIONNAL: same as NAMEPATTERN but it is
                            # a DEEP scan may override it.
                            # it is mutualy exclusive with NAMEPATTERN

    # NAMEPATTERN vs OPTNAMEPATTERN
    # Imagine you are used to name all your image files with .ilbm
    # extension. This way, a LIGHT scan will identify your ilbm files
    # if your specify NAMEPATTERN "#?.ilbm". But ILBM files can also be
    # internally recognized (using DEEP scan). If you specify
    # NAMEPATTERN "#?.ilbm", all ILBM files not ending with .ilbm will
    # not be recognized by whatis.library. But if you specify
    # OPTNAMEPATTERN "#?.ilbm", the DEEP scan will override the (OPT)
    # name pattern, and all ILBM files will be recognized.

    # Now come the DEEP description. It is the heart of recognition
    # process.  You can specify numbers in decimal (begining with a
    # digit), in hex (begining with $), in binary (begining with "%").
    # Strings begin with a letter or with a quote '"'
    # The search is done within the first (currently 484) few bytes of
    # the file.
    # All these conditions are optional, and are considered as TRUE
    # by LIGHT scan.

    COMPAREBYTE 12 $ABADCAFE    # Test if the file contains the bytes
                                # $AB $AD $CA $FE at offset 12

    COMPAREBYTE $23 "Hello"     # Test if the file contains the string
                                # "Hello" (i.e the bytes $48 $65 $6c $6f)
                                # at offset $23 (decimal 35)

    # in version 2 of WhatIs.library (only under KS2.x) you have an
    # optionnal CASE modifier, this means "A" is different of "a".

    SEARCHBYTE "Good"   # Search for "Good" in the first bytes of file.

    SEARCHBYTE $DEADBEEF    # Search for bytes $DE $AD $BE $EF

    SEARCHPATTERN [CASE] "ST-??:"   # Search for "ST-??:" pattern in file.

    MATCHPATTERN [CASE] 12 "ST-??:" # Search for "ST-??:" pattern in file
                                    # at offset 12.

ENDTYPE     # this marks the end of this FileType definition.


    AskReparse  is  a small executable which ask whatis.library to reparse
the  S:FileTypes  file.   The  file  will  be  effectively  parsed only if
whatis.library  is  not used except by AskReparse at call time.  Else, the
parse is defered until whatis.library has no user.

    3)
    Look in the WhatIsBase.h, you will find all you want.

    How works WhatIs() ?
    WhatIs is currently based on 2 methods:  light or deep.  The light one
is  only  based  on the information you pass to it.  In deep mode WhatIs()
open  the  file and scans the first few bytes (currently 488:  the size of
an  OldFileSystem  data-block),  so  after  loading these bytes in memory,
WhatIs()  examine them to discover what type it is.  WhatIs() also examine
the FileInfoBlock.
    WhatIs()  return  a PRIVATE ULONG.  You should not make any assumption
about how it is coded, because it may and WILL change in future.  You keep
this  ULONG and give it to the different functions of whatis.library.  All
FileTypes must be first referenced by their IDString "ILBM", "Text", "Exe,
etc..., or returned by WhatIs().

For  example you want to check if the file "Amiga" is an ILBM picture, you
should write:

    ULONG Type, ILBMType;

    Type = WhatIsTags("Amiga", WI_Deep, DEEPTYPE, TAG_DONE);
    ILBMType = GedIdType("ILBM");
    if (CmpFileType( Type, ILBMType) == 0)
    {
        /* Yes it is ILBM ! */
        your code here
    }
    else
    {
        /* Not an ILBM */
        your code here
    }

Currently supported tags by WhatIs():

    WI_FIB      /* TagItem.ti_data = struct FileInfoBlock *FIB, default = NULL */
    WI_Deep     /* TagItem.ti_data = LIGHTTYPE or DEEPTYPE. default = LIGHTTYPE */
    WI_Buffer   /* TagItem.ti_data = Buffer ptr WARNING: your buffer MUST be NUL terminated */
    WI_BufLen   /* TagItem.ti_data = Buffer Len */
    WI_DLX      /* TagItem.ti_data = DLX_numble, found in ArpBase.h */
    /* Version 2.1 or higher */
    WI_DLT      /* TagItem.ti_data = DLT_numble, found in DOS 2.0 */


Version history:

    1.0:    Version for KickStart 1.3.  Only This Version support 1.3.
            All others need KS2.0
    1.1:    Fixed a little bug.

    ALL next versions NEED KS2.0

    2.0:    First Version of whatis.library.
            (the 1.0 was a limited version made for 1.3)

    3.0:    Fixed a little bug.
            GetParentFileType() Added
            IsSubTypeOf() Added
            DLT support (KS2.0 version of the ARP DLX)

    3.4:    25/12/92
            Fixed a Little Bug: the UNKNOWNFILETYPE was not returned by NextType()

    3.5:    4/1/93
            Fixed a BIG bug born when fixed the preceding bug:
            Forgot subtype of root in FirstType()/NextType().

