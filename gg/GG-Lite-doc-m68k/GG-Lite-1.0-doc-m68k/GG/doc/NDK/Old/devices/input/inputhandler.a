* Copyright (c) 1990 Commodore-Amiga, Inc.
*
* This example is provided in electronic form by Commodore-Amiga, Inc. for
* use with the 1.3 revisions of the Addison-Wesley Amiga reference manuals.
* The 1.3 Addison-Wesley Amiga Reference Manual series contains additional
* information on the correct usage of the techniques and operating system
* functions presented in this example.  The source and executable code of
* this example may only be distributed in free electronic form, via bulletin
* board or as part of a fully non-commercial and freely redistributable
* diskette.  Both the source and executable code (including comments) must
* be included, without modification, in any copy.  This example may not be
* published in printed form or distributed with any commercial product.
* However, the programming techniques and support routines set forth in
* this example may be used in the development of original executable
* software products for Commodore Amiga computers.
* All other rights reserved.
* This example is provided "as-is" and is subject to change; no warranties
* are made.  All use is at your own risk.  No liability or responsibility
* is assumed.
*
***********************************************************************

*
* See inputswap.c for details on how to compile/assemble/link...
*

*
* InputHandler that does a Left/Right mouse button swap...
*
************************************************************************
*
* Required includes...
*
	INCLUDE	"exec/types.i"
	INCLUDE	"exec/io.i"
	INCLUDE	"devices/inputevent.i"
*
************************************************************************
*
* Make the entry point external...
*
	xdef	_ButtonSwap
*
************************************************************************
*
* This is the input handler that will swap the
* mouse buttons for left handed use.
*
* The event list gets passed to you in  a0.
* The is_Data field is passed to you in a1.
* This example does not use the is_Data field...
*
* On exit you must return the event list in d0.  In this way
* you could add or remove items from the event list.
*
************************************************************************
*
* The handler gets called here...
*
_ButtonSwap:	move.l	a0,-(sp)	; Save the event list
*
* Since the event list could be a linked list, we start a loop
* here to handle all of the events passed to us.
*
CheckLoop:	move.w	ie_Qualifier(a0),d1		; Get qualifiers...
		move.w	d1,d0				; Two places...
*
* Since we are changing left and right mouse buttons, we need to make
* sure that we change the qualifiers on all of the messages.  The
* left and right mouse buttons are tracked in the message qualifiers
* for use in such things as dragging.  To make sure that we continue
* to drag correctly, we change the qualifiers.
*
CheckRight:	btst	#IEQUALIFIERB_RBUTTON,d1	; Check for right
		beq.s	NoRight
		bset	#IEQUALIFIERB_LEFTBUTTON,d0	; Set the left...
		beq.s	CheckLeft
NoRight:	bclr	#IEQUALIFIERB_LEFTBUTTON,d0	; Clear the left...
*
CheckLeft:	btst	#IEQUALIFIERB_LEFTBUTTON,d1	; Check for left
		beq.s	NoLeft
		bset	#IEQUALIFIERB_RBUTTON,d0	; Set the right...
		beq.s	CheckLeft
NoLeft:		bclr	#IEQUALIFIERB_RBUTTON,d0	; Clear the right...
*
		move.w	d0,ie_Qualifier(a0)		; Save back...
*
* The actual button up/down events are transmitted as the
* code field in RAWMOUSE events.  The code field must the be
* checked and modified when needed on RAWMOUSE events.  If the
* event is not a RAWMOUSE, we are done with it.
*
		cmp.b	#IECLASS_RAWMOUSE,ie_Class(a0)	; Check for mouse
		bne.s	NextEvent			; If not, next...
*
		move.w	ie_Code(a0),d0			; Get code...
		move.w	d0,d1				; Save...
		and.w	#$7F,d0				; Mask UP_PREFIX
		cmp.w	#IECODE_LBUTTON,d0		; Check for Left...
		beq.s	SwapThem			; If so, swap...
		cmp.w	#IECODE_RBUTTON,d0		; Check for Right...
		bne.s	NextEvent			; If not, next...
*
SwapThem:	eor.w	#1,d1				; Flip bottom bit
		move.w	d1,ie_Code(a0)			; Save it...
*
* The event list is linked via a pointer to the next event
* in the first element of the structure.  That is why it is not
* nessesary to use:  move.l ie_NextEvent(a0),d0
*
* The reason I move to d0 first is that this also checks for zero.
* The last event in the list will have a NULL ie_NextEvent field.
* This is NOT as standard EXEC list where the node after the last
* node is NULL.  Input events are single-linked for performance.
*
NextEvent:	move.l	(a0),d0				; Get next event
		move.l	d0,a0				; into a0...
		bne.s	CheckLoop			; Do some more.
*
* All done, just return the event list...  (in d0)
*
		move.l	(sp)+,d0	; Get event list back...
		rts			; return from handler...
