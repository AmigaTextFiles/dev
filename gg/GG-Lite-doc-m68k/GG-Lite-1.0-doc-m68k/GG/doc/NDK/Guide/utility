@DATABASE "gg:doc/NDK/Guide/utility"
@MASTER   "gg:doc/NDK/AutoDocs/utility.doc"
@REMARK   This file was created by ADtoHT 2.1 on 06-Jan-13 19:25:21
@REMARK   Do not edit
@REMARK   ADtoHT is © 1993-1995 Christian Stieber

@NODE MAIN "utility.doc"
@TOC "gg:doc/NDK/Guide/TOC/MAIN"

                               @{b}utility.library@{ub}

@{"AddNamedObject()" LINK "AddNamedObject"}         @{"AllocateTagItems()" LINK "AllocateTagItems"}    @{"AllocNamedObject()" LINK "AllocNamedObjectA"}
@{"AllocNamedObjectA()" LINK "AllocNamedObjectA"}      @{"Amiga2Date()" LINK "Amiga2Date"}          @{"ApplyTagChanges()" LINK "ApplyTagChanges"}
@{"AttemptRemNamedObject()" LINK "AttemptRemNamedObject"}  @{"CallHookPkt()" LINK "CallHookPkt"}         @{"CheckDate()" LINK "CheckDate"}
@{"CloneTagItems()" LINK "CloneTagItems"}          @{"Date2Amiga()" LINK "Date2Amiga"}          @{"FilterTagChanges()" LINK "FilterTagChanges"}
@{"FilterTagItems()" LINK "FilterTagItems"}         @{"FindNamedObject()" LINK "FindNamedObject"}     @{"FindTagItem()" LINK "FindTagItem"}
@{"FreeNamedObject()" LINK "FreeNamedObject"}        @{"FreeTagItems()" LINK "FreeTagItems"}        @{"GetTagData()" LINK "GetTagData"}
@{"GetUniqueID()" LINK "GetUniqueID"}            @{"MapTags()" LINK "MapTags"}             @{"NamedObjectName()" LINK "NamedObjectName"}
@{"NextTagItem()" LINK "NextTagItem"}            @{"PackBoolTags()" LINK "PackBoolTags"}        @{"PackStructureTags()" LINK "PackStructureTags"}
@{"RefreshTagItemClones()" LINK "RefreshTagItemClones"}   @{"ReleaseNamedObject()" LINK "ReleaseNamedObject"}  @{"RemNamedObject()" LINK "RemNamedObject"}
@{"SDivMod32()" LINK "SDivMod32"}              @{"SMult32()" LINK "SMult32"}             @{"SMult64()" LINK "SMult64"}
@{"Stricmp()" LINK "Stricmp"}                @{"Strnicmp()" LINK "Strnicmp"}            @{"TagInArray()" LINK "TagInArray"}
@{"ToLower()" LINK "ToLower"}                @{"ToUpper()" LINK "ToUpper"}             @{"UDivMod32()" LINK "UDivMod32"}
@{"UMult32()" LINK "UMult32"}                @{"UMult64()" LINK "UMult64"}             @{"UnpackStructureTags()" LINK "UnpackStructureTags"}

@ENDNODE
@NODE "AddNamedObject" "utility.library/AddNamedObject()"
@{b}

   NAME@{ub}
        @{"AddNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 151} -- add a named object to the given namespace. (V39)@{b}

   SYNOPSIS@{ub}
        success = @{"AddNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 151}(nameSpace, object);
        D0                       A0         A1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"AddNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 151}(@{"struct NamedObject" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File" 25} *, @{"struct NamedObject" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File" 25} *);@{b}

   FUNCTION@{ub}
        Adds a new item to a NameSpace.  If the NameSpace doesn't support
        duplicate names, a search for a duplicate will be made, and
        0 (failure) will be returned.  Otherwise, the entry will be
        @{"Enqueue()" LINK "gg:doc/NDK/Guide/exec/Enqueue"}ed to the NameSpace.@{b}

   INPUTS@{ub}
        nameSpace - the name space to add to (@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for root namespace)
        object - the object to add  (If @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, will return failure)@{b}

   RESULT@{ub}
        success - whether the operation succeeded.  Check this always!@{b}

   SEE ALSO@{ub}
        @{"AttemptRemNamedObject()" LINK "AttemptRemNamedObject"}, @{"RemNamedObject()" LINK "RemNamedObject"}

@ENDNODE
@NODE "AllocateTagItems" "utility.library/AllocateTagItems()"
@{b}

   NAME@{ub}
        @{"AllocateTagItems" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 59} -- allocate a tag list. (V36)@{b}

   SYNOPSIS@{ub}
        tagList = @{"AllocateTagItems" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 59}(numTags);
        D0                         D0

        @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *@{"AllocateTagItems" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 59}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        Allocates the specified number of usable TagItems slots.

        Note that to access the TagItems in 'tagList', you should use
        the function @{"NextTagItem()" LINK "NextTagItem"}. This will insure you respect any
        chaining (@{"TAG_MORE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 42}) and secret hiding places (@{"TAG_IGNORE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 41}) that
        this function might generate.@{b}

   INPUTS@{ub}
        numTags - the number of TagItem slots you want to allocate.@{b}

   RESULTS@{ub}
        tagList - the allocated chain of TagItem structures, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if
                  there was not enough memory. An allocated tag list must
                  eventually be freed using @{"FreeTagItems()" LINK "FreeTagItems"}.@{b}

   SEE ALSO@{ub}
        <@{"utility/tagitem.h" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File"}>, @{"FreeTagItems()" LINK "FreeTagItems"}, @{"CloneTagItems()" LINK "CloneTagItems"}

@ENDNODE
@NODE "AllocNamedObjectA" "utility.library/AllocNamedObjectA()"
@{b}

   NAME@{ub}
        @{"AllocNamedObjectA" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 155} -- allocate a named object. (V39)@{b}

   SYNOPSIS@{ub}
        object = @{"AllocNamedObjectA" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 155}(name, tagList);
        D0                         A0    A1

        @{"struct NamedObject" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File" 25} *@{"AllocNamedObjectA" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 155}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *);

        object = @{"AllocNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 160}(name, Tag1, ...);

        @{"struct NamedObject" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File" 25} *@{"AllocNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 160}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, ...);@{b}

   FUNCTION@{ub}
        Allocates a NamedObject and initializes it as needed to the
        name given. This object can then be used as an object in the
        namespaces. Tags can be given to make an object contain a
        namespace such that nested namespaces can be built.
        When the object is allocated, it automatically has one use.
        If you later wish to release this object such that others may
        remove it from the namespace you must do a @{"ReleaseNamedObject()" LINK "ReleaseNamedObject"}.@{b}

   INPUTS@{ub}
        name - name for the object (must not be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101})
        tagList - tags with additional information for the allocation or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}@{b}

   TAGS@{ub}
        @{"ANO_NameSpace" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File" 31} - @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} tag, default @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}.  If this tag is
                        @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95}, the named object will also have a
                        name space attached to it.
        @{"ANO_UserSpace" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File" 32} - @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} tag, default 0.  If this tag is non-@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                        it defines the size (in bytes) of the user
                        space to be allocated with the named object
                        and that will be pointed to by the no_Object
                        pointer.  This memory is long-word aligned.
                        If no space is defined, no_Object will be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.
        @{"ANO_Priority" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File" 33}  - @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} tag, default 0.  This tag lets you pick
                        a priority for the named object for when it is
                        placed into a name space.
        @{"ANO_Flags" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File" 34}     - @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} tag, default 0.  This tag lets you set
                        the flags of the NameSpace (if you allocated
                        one)  There currently are only TWO flags.
                        Do *@{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500}* set *any* other bits as they are for
                        future use!!!  (You can't read them anyway)
                        The flags are:
                        @{"NSF_NODUPS" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File" 40}      - Name space must be unique.
                        @{"NSF_CASE" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File" 41}        - Name space is case sensitive@{b}

   RESULT@{ub}
        object - the object allocated, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for failure. The object
                 is defined as a pointer to a pointer.  You can do what you
                 wish with the pointer. (It may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} or contain a pointer
                 to memory that you had asked for in the tags.)@{b}

   SEE ALSO@{ub}
        @{"FreeNamedObject()" LINK "FreeNamedObject"}, <@{"utility/name.h" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File"}>

@ENDNODE
@NODE "Amiga2Date" "utility.library/Amiga2Date()"
@{b}

   NAME@{ub}
        @{"Amiga2Date" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 87} -- fill in a ClockData structure based on a system
                      time stamp (V36)@{b}

   SYNOPSIS@{ub}
        @{"Amiga2Date" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 87}(seconds,result);
                   D0      A0

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"Amiga2Date" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 87}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"struct ClockData" LINK "gg:doc/NDK/Guide/Include/utility/date.h/File" 24} *);@{b}

   FUNCTION@{ub}
        Fills in a ClockData structure with the date and time calculated
        from a @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} containing the number of seconds from 01-Jan-1978
        to the date.@{b}

   INPUTS@{ub}
        seconds - the number of seconds from 01-Jan-1978.
        result - a pointer to a ClockData structure that will be altered
                 by this function@{b}

   SEE ALSO@{ub}
        @{"CheckDate()" LINK "CheckDate"}, @{"Date2Amiga()" LINK "Date2Amiga"}

@ENDNODE
@NODE "ApplyTagChanges" "utility.library/ApplyTagChanges()"
@{b}

   NAME@{ub}
        @{"ApplyTagChanges" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 131} -- change a tag list based on a second tag list. (V39)@{b}

   SYNOPSIS@{ub}
        @{"ApplyTagChanges" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 131}(list,changeList);
                        A0   A1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"ApplyTagChanges" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 131}(@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *, @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *);@{b}

   FUNCTION@{ub}
        For any tag that appears in both 'list' and 'changeList', this
        function will change the ti_Data field of the tag in 'list' to
        match the ti_Data field of the tag in 'changeList'. In effect,
        'changeList' contains a series of new values for tags already in
        'list'. Any tag in 'changeList' that is not in 'list' is ignored.@{b}

   INPUTS@{ub}
        list - a list of existing tags (may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101})
        changeList - a list of tags to modify 'list' with (may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101})@{b}

   SEE ALSO@{ub}
        <@{"utility/tagitem.h" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File"}>, @{"FilterTagChanges()" LINK "FilterTagChanges"}

@ENDNODE
@NODE "AttemptRemNamedObject" "utility.library/AttemptRemNamedObject()"
@{b}

   NAME@{ub}
        @{"AttemptRemNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 164} -- attempt to remove a named object. (V39)@{b}

   SYNOPSIS@{ub}
        result = @{"AttemptRemNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 164}(object);
        D0                             A0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"AttemptRemNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 164}(@{"struct NamedObject" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File" 25} *);@{b}

   FUNCTION@{ub}
        Attempts to remove an object from whatever NameSpace it's in.
        You must have found the object first (in order to get a use count)
        before trying to remove it.  If the object is in use or is
        in the process of being removed, this function will return
        a failure code.  If the object is fully removed, the object will
        then be available to be @{"FreeNamedObject()" LINK "FreeNamedObject"}.@{b}

   INPUTS@{ub}
        object - the object to attempt to remove  The object must be valid@{b}

   RESULT@{ub}
        success - @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if object is still in use (somewhere)
                  @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if object was removed@{b}

   SEE ALSO@{ub}
        @{"RemNamedObject()" LINK "RemNamedObject"}, @{"AddNamedObject()" LINK "AddNamedObject"}, @{"ReleaseNamedObject()" LINK "ReleaseNamedObject"}

@ENDNODE
@NODE "CallHookPkt" "utility.library/CallHookPkt()"
@{b}

   NAME@{ub}
        @{"CallHookPkt" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 83} -- invoke a Hook function callback. (V36)@{b}

   SYNOPSIS@{ub}
        return = @{"CallHookPkt" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 83}(hook,object,message);
        D0                   A0   A2     A1

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"CallHookPkt" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 83}(@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *,@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49},@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        Performs the callback standard defined by a Hook structure.
        This function is really very simple; it effectively performs
        a JMP to Hook->h_Entry.

        It is probably just as well to do this operation in an
        assembly language function linked in to your program, possibly
        from a compiler supplied library or a builtin function.

        It is anticipated that C programs will often call a 'varargs'
        variant of this function which will be named @{"CallHook" LINK "gg:doc/NDK/Guide/amiga_lib/CallHook"}. This
        function must be provided in a compiler specific library, but
        an example of use would be:

        result = @{"CallHook" LINK "gg:doc/NDK/Guide/amiga_lib/CallHook"}(hook,dataobject,COMMAND_ID,param1,param2);

        The function @{"CallHook()" LINK "gg:doc/NDK/Guide/amiga_lib/CallHook"} can be implemented in many C compilers
        like this:

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"CallHook" LINK "gg:doc/NDK/Guide/amiga_lib/CallHook"}(@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *hook, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} object, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} command, ... )
        {
            return(@{"CallHookPkt" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 83}(hook,object,(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49})&command));
        }@{b}

   INPUTS@{ub}
        hook - pointer to an initialized Hook structure as defined in
               <@{"utility/hooks.h" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File"}>
        object - useful data structure in the particular context the hook is
                 being used for.
        message - pointer to a message to be passed to the hook. This is not
                  an Exec Message structure, but is a message in the OOP sense.@{b}

   RESULTS@{ub}
        return - the value returned by the hook function.@{b}

   WARNING@{ub}
        The functions called through this function should follow normal
        register conventions unless EXPLICITLY documented otherwise (and
        they have a good reason too).@{b}

   SEE ALSO@{ub}
        <@{"utility/hooks.h" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File"}>

@ENDNODE
@NODE "CheckDate" "utility.library/CheckDate()"
@{b}

   NAME@{ub}
        @{"CheckDate" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 95} -- checks a ClockData structure for legal date. (V36)@{b}

   SYNOPSIS@{ub}
        seconds = @{"CheckDate" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 95}(date);
        D0                  A0

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"CheckDate" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 95}(@{"struct ClockData" LINK "gg:doc/NDK/Guide/Include/utility/date.h/File" 24} *);@{b}

   FUNCTION@{ub}
        Determines if the ClockData structure contains legal date information
        and returns the number of seconds from 01-Jan-1978 to that date, or 0
        if the ClockData structure contains illegal data.@{b}

   INPUTS@{ub}
        date - a filled-in ClockData structure@{b}

   RESULTS@{ub}
        seconds - 0 if date is invalid, otherwise the number of seconds from
                  01-Jan-1978 to the date@{b}

   BUGS@{ub}
        The wday field of the ClockData structure is not checked.@{b}

   SEE ALSO@{ub}
        @{"Amiga2Date()" LINK "Amiga2Date"}, @{"Date2Amiga()" LINK "Date2Amiga"}

@ENDNODE
@NODE "CloneTagItems" "utility.library/CloneTagItems()"
@{b}

   NAME@{ub}
        @{"CloneTagItems" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 63} -- copy a tag list. (V36)@{b}

   SYNOPSIS@{ub}
        clone = @{"CloneTagItems" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 63}(original);
        D0                    A0

        @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *@{"CloneTagItems" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 63}(@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *);@{b}

   FUNCTION@{ub}
        Copies the essential contents of a tag list into a new tag list.

        The cloning is such that calling @{"FindTagItem()" LINK "FindTagItem"} with a given tag on
        the original or cloned tag lists will always return the same
        tag value. That is, the ordering of the tags is maintained.@{b}

   INPUTS@{ub}
        original - tag list to clone. May be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, in which case an
                   empty tag list is returned.@{b}

   RESULTS@{ub}
        clone - copy of the original tag list, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if there was not enough
                memory. This tag list must eventually by freed by calling
                @{"FreeTagItems()" LINK "FreeTagItems"}.@{b}

   SEE ALSO@{ub}
        <@{"utility/tagitem.h" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File"}>, @{"AllocateTagItems()" LINK "AllocateTagItems"}, @{"FreeTagItems()" LINK "FreeTagItems"},
        @{"RefreshTagItemClones()" LINK "RefreshTagItemClones"}

@ENDNODE
@NODE "Date2Amiga" "utility.library/Date2Amiga()"
@{b}

   NAME@{ub}
        @{"Date2Amiga" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 91} -- calculate seconds from 01-Jan-1978. (V36)@{b}

   SYNOPSIS@{ub}
        seconds = @{"Date2Amiga" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 91}(date);
        D0                   A0

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"Date2Amiga" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 91}(@{"struct ClockData" LINK "gg:doc/NDK/Guide/Include/utility/date.h/File" 24} *);@{b}

   FUNCTION@{ub}
        Calculates the number of seconds from 01-Jan-1978 to the date
        specified in the ClockData structure.@{b}

   INPUTS@{ub}
        date - pointer to a ClockData structure containing the date of
               interest.@{b}

   RESULTS@{ub}
        seconds - the number of seconds from 01-Jan-1978 to the date specified.@{b}

   WARNING@{ub}
        This function does no sanity checking of the data in the ClockData
        structure.@{b}

   SEE ALSO@{ub}
        @{"Amiga2Date()" LINK "Amiga2Date"}, @{"CheckDate()" LINK "CheckDate"}

@ENDNODE
@NODE "FilterTagChanges" "utility.library/FilterTagChanges()"
@{b}

   NAME@{ub}
        @{"FilterTagChanges" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 51} -- eliminate tags which specify no change. (V36)@{b}

   SYNOPSIS@{ub}
        @{"FilterTagChanges" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 51}(changeList,originalList,apply);
                         A0         A1           D0

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"FilterTagChanges" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 51}(@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *, @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This function goes through changeList. For each item found in
        changeList, if the item is also present in originalList, and their
        data values are identical, then the tag is removed from changeList.
        If the two tag's data values are different and the 'apply' value is
        non-zero, then the tag data in originalList will be updated to match
        the value from changeList.@{b}

   INPUTS@{ub}
        changeList - list of new tags (may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101})
        originalList - a list of existing tags (may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101})
        apply - boolean specification as to whether the data values in
                originalList are to be updated to the data values in
                changeList.@{b}

   EXAMPLE@{ub}
        Assume you have an attribute list for an object (originalList)
        which looks like this:

                {ATTR_Size,  "large"},
                {ATTR_Color, "orange"},
                {ATTR_Shape, "square"}

        If you receive a new tag list containing some changes (changeList),
        which looks like this:

                {ATTR_Size,  "large"},
                {ATTR_Shape, "triangle"}

        If you call @{"FilterTagChanges" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 51}(), changeList will be modified to
        contain only those attributes which are different from those
        in originalList. All other items will have their tag values set to
        @{"TAG_IGNORE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 41}. The resulting changeList will become:

                {@{"TAG_IGNORE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 41}, "large"},
                {ATTR_Shape, "triangle"}

        If 'apply' was set to 0, originalList would be unchanged. If 'apply'
        was non-zero, originalList would be changed to:

                {ATTR_Size,  "large"},
                {ATTR_Color, "orange"},
                {ATTR_Shape, "triangle"}@{b}

   SEE ALSO@{ub}
        <@{"utility/tagitem.h" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File"}>, @{"ApplyTagChanges()" LINK "ApplyTagChanges"}

@ENDNODE
@NODE "FilterTagItems" "utility.library/FilterTagItems()"
@{b}

   NAME@{ub}
        @{"FilterTagItems" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 79} -- remove selected items from a tag list. (V36)@{b}

   SYNOPSIS@{ub}
        numValid = @{"FilterTagItems" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 79}(tagList,filterArray,logic);
        D0                        A0      A1          D0

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"FilterTagItems" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 79}(@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *,Tag *,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        Removes tag items from a tag list (by changing ti_Tag to
        @{"TAG_IGNORE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 41}) depending on whether its ti_Tag value is
        found in an array of tag values.

        If the 'logic' parameter is @{"TAGFILTER_AND" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 62}, then all items
        not appearing in 'tagArray' are excluded from 'tagList'.

        If 'logic' is @{"TAGFILTER_NOT" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 63}, then items not found in 'tagArray'
        are preserved, and the ones in the array are cast out.@{b}

   INPUTS@{ub}
        tagList - input list of tag items which is to be filtered by having
                  selected items changed to @{"TAG_IGNORE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 41}.
        filterArray - an array of tag values, terminated by @{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39}, as
                      specified in the documentation for @{"TagInArray()" LINK "TagInArray"}.
        logic - specification whether items in 'tagArray' are to be included
                or excluded in the filtered result.@{b}

   RESULTS@{ub}
        numValid - number of valid items left in resulting filtered list.@{b}

   SEE ALSO@{ub}
        <@{"utility/tagitem.h" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File"}>, @{"TagInArray()" LINK "TagInArray"}

@ENDNODE
@NODE "FindNamedObject" "utility.library/FindNamedObject()"
@{b}

   NAME@{ub}
        @{"FindNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 168} -- find the next object of a given name. (V39)@{b}

   SYNOPSIS@{ub}
        object = @{"FindNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 168}(nameSpace, name, lastObject);
        D0                       A0         A1    A2

        @{"struct NamedObject" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File" 25} *@{"FindNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 168}(@{"struct NamedObject" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File" 25} *, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},
                                            @{"struct NamedObject" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File" 25} *);@{b}

   FUNCTION@{ub}
        Finds an object and adds to the open count of the object. The
        object is guaranteed not to be freed until @{"ReleaseNamedObject()" LINK "ReleaseNamedObject"} is
        called. The name comparison is caseless, using the current
        locale string comparison routines.

        If name is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, then all objects will be matched.

        If lastObject is non-@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, it must be an object from the same
        NameSpace found on a previous call to @{"FindNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 168}(). It
        will not be freed by this call. The search will start at the
        node after lastobject, if non-@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.

        nameSpace is the name space from the named object given
        or the root name space if @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} is given.@{b}

   INPUTS@{ub}
        nameSpace - the name space to search
        name - the name of the object to search for
        lastObject - the starting point for the search or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}@{b}

   RESULT@{ub}
        object - the first match found, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for no match@{b}

   SEE ALSO@{ub}
        @{"ReleaseNamedObject()" LINK "ReleaseNamedObject"}, <@{"utility/name.h" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File"}>

@ENDNODE
@NODE "FindTagItem" "utility.library/FindTagItem()"
@{b}

   NAME@{ub}
        @{"FindTagItem" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 35} -- scan a tag list for a specific tag. (V36)@{b}

   SYNOPSIS@{ub}
        tag = @{"FindTagItem" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 35}(tagValue,tagList);
        D0                D0       A0

        @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *@{"FindTagItem" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 35}(Tag,@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *);@{b}

   FUNCTION@{ub}
        Scans a tag list and returns a pointer to the first item with
        ti_Tag matching the 'tagValue' parameter.@{b}

   INPUTS@{ub}
        tagValue - tag value to search for
        tagList - tag item list to search (may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101})@{b}

   RESULTS@{ub}
        tag - a pointer to the item with ti_Tag matching 'tagValue' or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
              if no match was found.@{b}

   SEE ALSO@{ub}
        <@{"utility/tagitem.h" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File"}>, @{"GetTagData()" LINK "GetTagData"}, @{"PackBoolTags()" LINK "PackBoolTags"}, @{"NextTagItem()" LINK "NextTagItem"}

@ENDNODE
@NODE "FreeNamedObject" "utility.library/FreeNamedObject()"
@{b}

   NAME@{ub}
        @{"FreeNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 172} -- frees a name object. (V39)@{b}

   SYNOPSIS@{ub}
        @{"FreeNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 172}(object);
                        A0

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"FreeNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 172}(@{"struct NamedObject" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File" 25} *);@{b}

   FUNCTION@{ub}
        Free one of a number of structures used by utility.library.
        The item must not be a member of any NameSpace, and no one
        may have it open other than yourself. If the object also
        contained a NameSpace, that namespace must be empty.
        Any additional space allocated via the datasize parameter
        for @{"AllocNamedObject()" LINK "AllocNamedObjectA"} is also released.@{b}

   INPUTS@{ub}
        object - the object to be freed@{b}

   SEE ALSO@{ub}
        @{"AllocNamedObjectA()" LINK "AllocNamedObjectA"}

@ENDNODE
@NODE "FreeTagItems" "utility.library/FreeTagItems()"
@{b}

   NAME@{ub}
        @{"FreeTagItems" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 67} -- free an allocated tag list. (V36)@{b}

   SYNOPSIS@{ub}
        @{"FreeTagItems" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 67}(tagList);
                     A0

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"FreeTagItems" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 67}(@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *);@{b}

   FUNCTION@{ub}
        Frees the memory of a TagItem list allocated either by
        @{"AllocateTagItems()" LINK "AllocateTagItems"} or @{"CloneTagItems()" LINK "CloneTagItems"}.@{b}

   INPUTS@{ub}
        tagList - list to free, must have been obtained from
                  @{"AllocateTagItems()" LINK "AllocateTagItems"} or @{"CloneTagItems()" LINK "CloneTagItems"} (may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101})@{b}

   SEE ALSO@{ub}
        <@{"utility/tagitem.h" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File"}>, @{"AllocateTagItems()" LINK "AllocateTagItems"}, @{"CloneTagItems()" LINK "CloneTagItems"}

@ENDNODE
@NODE "GetTagData" "utility.library/GetTagData()"
@{b}

   NAME@{ub}
        @{"GetTagData" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 39} -- obtain the data corresponding to a tag. (V36)@{b}

   SYNOPSIS@{ub}
        value = @{"GetTagData" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 39}(tagValue,defaultVal,tagList);
        D0                 D0       D1         A0

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"GetTagData" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 39}(Tag,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *);@{b}

   FUNCTION@{ub}
        Searches a tag list for a matching tag, and returns the
        corresponding ti_Data value for the TagItem found. If no match is
        found, this function returns the value passed in as 'default'.@{b}

   INPUTS@{ub}
        tagValue - tag value to search for.
        defaultVal - value to be returned if tagValue is not found.
        tagList - the tag list to search.@{b}

   RESULTS@{ub}
        value - the ti_Data value for the first matching TagItem, or 'default'
                if a ti_Tag matching 'Tag' is not found.@{b}

   SEE ALSO@{ub}
        <@{"utility/tagitem.h" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File"}>, @{"FindTagItem()" LINK "FindTagItem"}, @{"PackBoolTags()" LINK "PackBoolTags"}, @{"NextTagItem()" LINK "NextTagItem"}

@ENDNODE
@NODE "GetUniqueID" "utility.library/GetUniqueID()"
@{b}

   NAME@{ub}
        @{"GetUniqueID" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 188} -- return a relatively unique number. (V39)@{b}

   SYNOPSIS@{ub}
        id = @{"GetUniqueID" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 188}();
        D0

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"GetUniqueID" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 188}(@{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24});@{b}

   FUNCTION@{ub}
        Returns a unique value each time it is called. This is useful for
        things that need unique ID such as the GadgetHelp ID, etc.
        Note that this is only unique for 4,294,967,295 calls to this
        function. Under normal use this is not a problem.
        This function is safe in interrupts.@{b}

   RESULT@{ub}
        id - a 32-bit value that is unique.

@ENDNODE
@NODE "MapTags" "utility.library/MapTags()"
@{b}

   NAME@{ub}
        @{"MapTags" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 55} -- convert ti_Tag values in a list via map pairing. (V36)@{b}

   SYNOPSIS@{ub}
        @{"MapTags" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 55}(tagList,mapList,mapType);
                A0      A1      D0

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"MapTags" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 55}(@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *,@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        Apply a "mapping list" mapList to tagList.

        If the ti_Tag field of an item in tagList appears as ti_Tag in some
        item in mapList, overwrite ti_Tag with the corresponding ti_Data
        from the map list.

        The mapType parameter specifies how the mapping operation is to
        proceed, with the following available types:

                @{"MAP_REMOVE_NOT_FOUND" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 70}
                If a tag in tagList does not appear in the mapList, remove
                it from tagList.

                @{"MAP_KEEP_NOT_FOUND" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 71}
                To have items which do not appear in the mapList survive the
                mapping process as-is.

        @{"MapTags" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 55}() is central to BOOPSI gadget interconnections where you want
        to convert the tag values from one space (the sender) to another (the
        receiver).

        The procedure will change the values of the input tag list
        tagList (but not mapList).

        You can "filter" a list by passing @{"MAP_REMOVE_NOT_FOUND" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 70} as mapType,
        and having the data items in mapList equal the corresponding tags.

        You can perform the inverse filter ("everything but") by passing
        a mapType of @{"MAP_KEEP_NOT_FOUND" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 71}, and creating a map item for every tag
        you want to filter out, pairing it with a mapped data value of
        @{"TAG_IGNORE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 41}.

        For safety and "order independence" of tag item arrays, if you
        attempt to map some tag to the value @{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39}, the value @{"TAG_IGNORE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 41}
        will be substituted instead.@{b}

   INPUTS@{ub}
        tagList - input list of tag items which is to be mapped to tag values
                  as specified in mapList.
        mapList - a "mapping list" tag list which pairs tag values expected to
                  appear in tagList with new values to be substituted in the
                  ti_Tag fields of tagList (may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101})
        mapType - one of the available mapping types as defined in
                  <@{"utility/tagitem.h" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File"}>@{b}

   EXAMPLE@{ub}
        /* Consider this source list: */
            @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} list[] =
            {
                {MY_SIZE,       71},
                {MY_WEIGHT,     200},
                {@{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39},      }
           };

        /* And the mapping list: */
            @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} map[] =
            {
                {MY_SIZE,       HIS_TALL},
                {@{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39},      }
            };

        /* Then after @{"MapTags" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 55}(list,map,@{"MAP_REMOVE_NOT_FOUND" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 70}), 'list' will
           become: */
                {HIS_TALL,71},
                {@{"TAG_IGNORE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 41},},
                {@{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39},}

        /* Or after @{"MapTags" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 55}(list,map,@{"MAP_KEEP_NOT_FOUND" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 71}), 'list' will
           become: */
                {HIS_TALL,  71},
                {MY_WEIGHT, 200},
                {@{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39},  }@{b}

   BUGS@{ub}
        Prior to V39, the mapType parameter did not work. The function
        always behaved as if the parameter was set to @{"MAP_KEEP_NOT_FOUND" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 71}.@{b}

   SEE ALSO@{ub}
        <@{"utility/tagitem.h" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File"}>, @{"ApplyTagChanges()" LINK "ApplyTagChanges"}, @{"FilterTagChanges()" LINK "FilterTagChanges"}

@ENDNODE
@NODE "NamedObjectName" "utility.library/NamedObjectName()"
@{b}

   NAME@{ub}
        @{"NamedObjectName" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 176} -- return the name of the object. (V39)@{b}

   SYNOPSIS@{ub}
        name = @{"NamedObjectName" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 176}(object);
        D0                     A0

        @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} @{"NamedObjectName" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 176}(@{"struct NamedObject" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File" 25} *);@{b}

   FUNCTION@{ub}
        Returns the name of the object passed in...
        Note that the name string is passed back as just a pointer to
        a read-only name. If the object goes away, so does the name.@{b}

   INPUTS@{ub}
        object - the object, may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} in which case this function
                 returns @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   RESULT@{ub}
        name - pointer to the name string, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if 'object' is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"FindNamedObject()" LINK "FindNamedObject"}, @{"RemNamedObject()" LINK "RemNamedObject"}

@ENDNODE
@NODE "NextTagItem" "utility.library/NextTagItem()"
@{b}

   NAME@{ub}
        @{"NextTagItem" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 47} -- iterate through a tag list. (V36)@{b}

   SYNOPSIS@{ub}
        tag = @{"NextTagItem" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 47}(tagItemPtr);
        D0                A0

        @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *@{"NextTagItem" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 47}(@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} **);@{b}

   FUNCTION@{ub}
        Iterates through a tag list, skipping and chaining as dictated by
        system tags. @{"TAG_SKIP" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 45} will cause it to skip the entry and a number
        of following tags as specified in ti_Data. @{"TAG_IGNORE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 41} ignores that
        single entry, and @{"TAG_MORE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 42} has a pointer to another array of tags (and
        terminates the current array!). @{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39} also terminates the current
        array. Each call returns either the next tagitem you should examine,
        or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} when the end of the list has been reached.@{b}

   INPUTS@{ub}
        tagItemPtr - doubly-indirect reference to a TagItem structure.
                     The pointer will be changed to keep track of the
                     iteration.@{b}

   RESULTS@{ub}
        nextTag - each TagItem in the array or chain of arrays that should be
                  processed according to system tag values defined in
                  <@{"utility/tagitem.h" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File"}>) is returned in turn with successive
                  calls.@{b}

   EXAMPLE@{ub}
        Iterate(@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *tags);
        {
        @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *tstate;
        @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *tag;

            tstate = tags;
            while (tag = @{"NextTagItem" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 47}(&tstate))
            {
                switch (tag->ti_Tag)
                {
                    case TAG1: ...
                               break;

                    case TAG2: ...
                               break;

                    ...
                }
            }
        }@{b}

   WARNING@{ub}
        Do @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} use the value of *tagItemPtr, but rather use the pointer
        returned by @{"NextTagItem" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 47}().@{b}

   SEE ALSO@{ub}
        <@{"utility/tagitem.h" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File"}>, @{"GetTagData()" LINK "GetTagData"}, @{"PackBoolTags()" LINK "PackBoolTags"}, @{"FindTagItem()" LINK "FindTagItem"}

@ENDNODE
@NODE "PackBoolTags" "utility.library/PackBoolTags()"
@{b}

   NAME@{ub}
        @{"PackBoolTags" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 43} -- builds a "flag" word from a tag list. (V36)@{b}

   SYNOPSIS@{ub}
        flags = @{"PackBoolTags" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 43}(initialFlags,tagList,boolMap);
        D0                   D0           A0      A1

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"PackBoolTags" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 43}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *,@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *);@{b}

   FUNCTION@{ub}
        Picks out the boolean tag items in a tag list and converts
        them into bit-flag representations according to a correspondence
        defined by the tag list 'boolMap'.

        A boolean tag item is one where only the logical value of
        the ti_Data is relevant. If this field is 0, the value is
        @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}, otherwise @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95}.@{b}

   INPUTS@{ub}
        initialFlags - a starting set of bit-flags which will be changed
                       by the processing of @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} and @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} boolean tags
                       in tagList.
        tagList - a TagItem list which may contain several tag items defined to
                  be boolean by their presence in boolMap. The logical value of
                  ti_Data determines whether a tag item causes the bit-flag
                  value related by boolMap to be set or cleared in the returned
                  flag longword.
        boolMap - a tag list defining the boolean tags to be recognized, and
                  the bit (or bits) in the returned longword that are to be set
                  or cleared when a boolean Tag is found to be @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} or @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} in
                  tagList.@{b}

   RESULTS@{ub}
        flags - the accumulated longword of bit-flags, starting with
                initialFlags and modified by each boolean tag item
                encountered.@{b}

   EXAMPLE@{ub}
        /* define some nice user tag values ... */
        enum mytags { tag1 = @{"TAG_USER" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 48}+1, tag2, tag3, tag4, tag5 };

        /* this TagItem list defines the correspondence between boolean tags
         * and bit-flag values.
         */
        @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} boolMap[] =
        {
            {tag1,     0x0001},
            {tag2,     0x0002},
            {tag3,     0x0004},
            {tag4,     0x0008},
            {@{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39}, }
        };

        /* You are probably passed these by some client, and you want
         * to "collapse" the boolean content into a single longword.
         */

        @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} boolExample[] =
        {
            {tag1,     @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95}},
            {tag2,     @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}},
            {tag5,     Irrelevant},
            {tag3,     @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95}},
            {@{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39}, }
        };

        /* Perhaps 'boolFlags' already has a current value of 0x800002. */
        boolFlags = @{"PackBoolTags" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 43}(boolFlags,boolExample,boolMap);

        /* The resulting new value of 'boolFlags' will be 0x80005. /*@{b}

   WARNING@{ub}
        In a case where there is duplication of a tag in tagList, the
        last of the identical tags will hold sway.@{b}

   SEE ALSO@{ub}
        <@{"utility/tagitem.h" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File"}>, @{"GetTagData()" LINK "GetTagData"}, @{"FindTagItem()" LINK "FindTagItem"}, @{"NextTagItem()" LINK "NextTagItem"}

@ENDNODE
@NODE "PackStructureTags" "utility.library/PackStructureTags()"
@{b}

   NAME@{ub}
        @{"PackStructureTags" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 143} -- pack a structure with values from taglist. (V39)@{b}

   SYNOPSIS@{ub}
        num = @{"PackStructureTags" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 143}(pack,packTable,tagList);
        D0                      A0   A1        A2

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"PackStructureTags" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 143}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} *,@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *);@{b}

   FUNCTION@{ub}
        For each table entry, a @{"FindTagItem()" LINK "FindTagItem"} will be done and if the
        matching tag is found in the taglist, the data field will be
        packed into the given structure based on the packtable
        definition.@{b}

   INPUTS@{ub}
        pack - a pointer to the data area to fill in.
        packTable - a pointer to the packing information table.
                    See <@{"utility/pack.h" LINK "gg:doc/NDK/Guide/Include/utility/pack.h/File"}> for definition and macros.
        tagList - a pointer to the taglist to pack into the structure@{b}

   RESULTS@{ub}
        num - the number of tag items packed@{b}

   SEE ALSO@{ub}
        <@{"utility/pack.h" LINK "gg:doc/NDK/Guide/Include/utility/pack.h/File"}>, @{"FindTagItem()" LINK "FindTagItem"}, @{"UnpackStructureTags()" LINK "UnpackStructureTags"}

@ENDNODE
@NODE "RefreshTagItemClones" "utility.library/RefreshTagItemClones()"
@{b}

   NAME@{ub}
        @{"RefreshTagItemClones" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 71} -- rejuvenate a clone from the original. (V36)@{b}

   SYNOPSIS@{ub}
        @{"RefreshTagItemClones" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 71}(clone,original)
                             A0    A1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"RefreshTagItemClones" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 71}(@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *,@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *);@{b}

   FUNCTION@{ub}
        If (and only if) the tag list 'clone' was created from 'original' by
        @{"CloneTagItems()" LINK "CloneTagItems"}, and if 'original' has not been changed in any way,
        you can reset the clone list to its original state by using this
        function.@{b}

   INPUTS@{ub}
        clone - return value from @{"CloneTagItems" LINK "CloneTagItems"}(original)
        original - a tag list that hasn't changed since @{"CloneTagItems()" LINK "CloneTagItems"}@{b}

   SEE ALSO@{ub}
        <@{"utility/tagitem.h" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File"}>, @{"CloneTagItems()" LINK "CloneTagItems"}, @{"AllocateTagItems()" LINK "AllocateTagItems"},
        @{"FreeTagItems()" LINK "FreeTagItems"}, @{"ApplyTagChanges()" LINK "ApplyTagChanges"}

@ENDNODE
@NODE "ReleaseNamedObject" "utility.library/ReleaseNamedObject()"
@{b}

   NAME@{ub}
        @{"ReleaseNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 180} -- free a named object. (V39)@{b}

   SYNOPSIS@{ub}
        @{"ReleaseNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 180}(object);
                           A0

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"ReleaseNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 180}(@{"struct NamedObject" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File" 25} *);@{b}

   FUNCTION@{ub}
        Decrements the open count of the object. If the object has been
        removed, and the count goes to 0, the remover will be notified
        that the object is now free.@{b}

   INPUTS@{ub}
        object - the object to release.  (No action if @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101})@{b}

   SEE ALSO@{ub}
        @{"FindNamedObject()" LINK "FindNamedObject"}, @{"RemNamedObject()" LINK "RemNamedObject"}

@ENDNODE
@NODE "RemNamedObject" "utility.library/RemNamedObject()"
@{b}

   NAME@{ub}
        @{"RemNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 184} -- remove a named object. (V39)@{b}

   SYNOPSIS@{ub}
        @{"RemNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 184}(object, message);
                       A0      A1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"RemNamedObject" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 184}(@{"struct NamedObject" LINK "gg:doc/NDK/Guide/Include/utility/name.h/File" 25} *, @{"struct Message" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 47} *);@{b}

   FUNCTION@{ub}
        This function will post a request to release the object
        from whatever NameSpace it is in.  It will reply the message
        when the object is fully removed.  The message.mn_Node.ln_Name
        field will contain the object pointer or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if the object
        was removed by another process.

        This function will effectively do a @{"ReleaseNamedObject()" LINK "ReleaseNamedObject"}
        thus you must have "found" the object first.@{b}

   INPUTS@{ub}
        object - the object to remove: Must be a valid NamedObject.
        message - message to @{"ReplyMsg()" LINK "gg:doc/NDK/Guide/exec/ReplyMsg"} (must be supplied)@{b}

   RESULT@{ub}
        The message is replied with the ln_Name field either being
        the object or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}. If it contains the object, the object
        is completely removed.@{b}

   SEE ALSO@{ub}
        @{"AttemptRemNamedObject()" LINK "AttemptRemNamedObject"}, @{"AddNamedObject()" LINK "AddNamedObject"}, @{"ReleaseNamedObject()" LINK "ReleaseNamedObject"}

@ENDNODE
@NODE "SDivMod32" "utility.library/SDivMod32()"
@{b}

   NAME@{ub}
        @{"SDivMod32" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 107} -- signed 32 by 32 bit division and modulus. (V36)@{b}

   SYNOPSIS@{ub}
        quotient:remainder = @{"SDivMod32" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 107}(dividend,divisor);
        D0       D1                    D0       D1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}:@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"SDivMod32" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 107}(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Divides the signed 32 bit dividend by the signed 32 bit divisor
        and returns a signed 32 bit quotient and remainder.@{b}

   INPUTS@{ub}
        dividend - signed 32 bit dividend.
        divisor - signed 32 bit divisor.@{b}

   RESULTS@{ub}
        quotient - signed 32 quotient of the division.
        remainder - signed 32 remainder of the division.@{b}

   NOTES@{ub}
        Unlike other Amiga library function calls, the utility.library
        32 bit math routines do @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} require A6 to be loaded with a
        pointer to the library base. A6 can contain anything the application
        wishes. This is in order to avoid overhead in calling them.

        In addition, the utility.library math routines preserve all
        address registers including A0 and A1@{b}

   SEE ALSO@{ub}
        @{"SMult32()" LINK "SMult32"}, @{"UDivMod32()" LINK "UDivMod32"}, @{"UMult32()" LINK "UMult32"}, @{"SMult64()" LINK "SMult64"}, @{"UMult64()" LINK "UMult64"}

@ENDNODE
@NODE "SMult32" "utility.library/SMult32()"
@{b}

   NAME@{ub}
        @{"SMult32" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 99} -- signed 32 by 32 bit multiply with 32 bit result. (V36)@{b}

   SYNOPSIS@{ub}
        result = @{"SMult32" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 99}(arg1,arg2);
        D0               D0   D1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"SMult32" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 99}(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Returns the signed 32 bit result of multiplying arg1 by arg2.@{b}

   INPUTS@{ub}
        arg1, arg2 - numbers to multiply@{b}

   RESULTS@{ub}
        result - the signed 32 bit result of multiplying arg1 by arg2.@{b}

   NOTES@{ub}
        Unlike other Amiga library function calls, the utility.library
        32 bit math routines do @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} require A6 to be loaded with a
        pointer to the library base. A6 can contain anything the application
        wishes. This is in order to avoid overhead in calling them.

        In addition, the utility.library math routines preserve all
        address registers including A0 and A1@{b}

   SEE ALSO@{ub}
        @{"SDivMod32()" LINK "SDivMod32"}, @{"UDivMod32()" LINK "UDivMod32"}, @{"UMult32()" LINK "UMult32"}, @{"SMult64()" LINK "SMult64"}, @{"UMult64()" LINK "UMult64"}

@ENDNODE
@NODE "SMult64" "utility.library/SMult64()"
@{b}

   NAME@{ub}
        @{"SMult64" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 135} -- signed 32 by 32 bit multiply with 64 bit result. (V39)@{b}

   SYNOPSIS@{ub}
        result = @{"SMult64" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 135}(arg1,arg2);
        D0:D1            D0   D1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"SMult64" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 135}(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Returns the signed 64 bit result of multiplying arg1 by arg2.@{b}

   INPUTS@{ub}
        arg1, arg2 - numbers to multiply@{b}

   RESULTS@{ub}
        result - the signed 64 bit result of multiplying arg1 by arg2.@{b}

   NOTES@{ub}
        Unlike other Amiga library function calls, the utility.library
        32 bit math routines do @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} require A6 to be loaded with a
        pointer to the library base. A6 can contain anything the application
        wishes. This is in order to avoid overhead in calling them.

        In addition, the utility.library math routines preserve all
        address registers including A0 and A1@{b}

   SEE ALSO@{ub}
        @{"SDivMod32()" LINK "SDivMod32"}, @{"UDivMod32()" LINK "UDivMod32"}, @{"UMult32()" LINK "UMult32"}, @{"UMult64()" LINK "UMult64"}

@ENDNODE
@NODE "Stricmp" "utility.library/Stricmp()"
@{b}

   NAME@{ub}
        Stricmp -- case-insensitive string comparison. (V37)@{b}

   SYNOPSIS@{ub}
        result = Stricmp(string1,string2);
        D0               A0      A1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} Stricmp(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67});@{b}

   FUNCTION@{ub}
        This function compares two strings, ignoring case using a generic
        case conversion routine. If the strings have different lengths,
        the shorter is treated as if it were extended with zeros.@{b}

   INPUTS@{ub}
        string1, string2 - strings to be compared@{b}

   RESULTS@{ub}
        result - relationship between string1 and string2
                        <0 means string1 < string2
                        =0 means string1 = string2
                        >0 means string1 > string2@{b}

   NOTES@{ub}
        Whenever @{"locale.library" LINK "gg:doc/NDK/Guide/locale/MAIN"} is installed in a system, this function is
        replaced by language-specific code. This means that depending on
        which language the user has currently selected, identical pairs of
        strings may return different values when passed to this function.
        This fact must be taken into consideration when using this function.@{b}

   SEE ALSO@{ub}
        @{"Strnicmp()" LINK "Strnicmp"}, @{"locale.library/StrnCmp()" LINK "gg:doc/NDK/Guide/locale/StrnCmp"}

@ENDNODE
@NODE "Strnicmp" "utility.library/Strnicmp()"
@{b}

   NAME@{ub}
        Strnicmp -- length-limited case-insensitive string compare. (V37)@{b}

   SYNOPSIS@{ub}
        result = Strnicmp(string1,string2,length);
        D0                A0      A1      D0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} Strnicmp(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        This function compares two strings, ignoring case using a generic
        case conversion routine. If the strings have different lengths,
        the shorter is treated as if it were extended with zeros. This function
        never compares more than 'length' characters.@{b}

   INPUTS@{ub}
        string1, string2 - strings to be compared
        length - maximum number of characters to examine@{b}

   RESULTS@{ub}
        result - relationship between string1 and string2
                        <0 means string1 < string2
                        =0 means string1 = string2
                        >0 means string1 > string2@{b}

   NOTES@{ub}
        Whenever @{"locale.library" LINK "gg:doc/NDK/Guide/locale/MAIN"} is installed in a system, this function is
        replaced by language-specific code. This means that depending on
        which language the user has currently selected, identical pairs of
        strings may return different values when passed to this function.
        This fact must be taken into consideration when using this function.@{b}

   SEE ALSO@{ub}
        @{"Stricmp()" LINK "Stricmp"}, @{"locale.library/StrnCmp()" LINK "gg:doc/NDK/Guide/locale/StrnCmp"}

@ENDNODE
@NODE "TagInArray" "utility.library/TagInArray()"
@{b}

   NAME@{ub}
        @{"TagInArray" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 75} -- check if a tag value appears in an array of tag values.
                      (V36)@{b}

   SYNOPSIS@{ub}
        result = @{"TagInArray" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 75}(tagValue,tagArray);
        D0                  D0       A0

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"TagInArray" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 75}(Tag,Tag *);@{b}

   FUNCTION@{ub}
        Performs a quick scan to see if a tag value appears in an array
        terminated with @{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39}. Returns @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if the value is found.

        The 'tagArray' must be terminated by @{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39}. Note that this is an
        array of tag values, @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} an array of TagItems.@{b}

   INPUTS@{ub}
        tagValue - tag value to search array for in array.
        tagArray - a simple array of tag values terminated by @{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39}.@{b}

   RESULTS@{ub}
        result - @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if tagValue was found in tagArray.@{b}

   SEE ALSO@{ub}
        <@{"utility/tagitem.h" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File"}>, @{"FilterTagItems()" LINK "FilterTagItems"}

@ENDNODE
@NODE "ToLower" "utility.library/ToLower()"
@{b}

   NAME@{ub}
        @{"ToLower" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 127} -- convert a character to lower case. (V37)@{b}

   SYNOPSIS@{ub}
        char = @{"ToLower" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 127}(char);
        D0             D0

        @{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62} @{"ToLower" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 127}(@{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62});@{b}

   FUNCTION@{ub}
        Converts a character to lower case, handling international character
        sets.@{b}

   INPUTS@{ub}
        char - character to be converted.@{b}

   RESULTS@{ub}
        char - lower case version of the input character.@{b}

   NOTES@{ub}
        Whenever @{"locale.library" LINK "gg:doc/NDK/Guide/locale/MAIN"} is installed in a system, this function is
        replaced by language-specific code. This means that depending on
        which language the user has currently selected, a given character may
        return different results when passed to this function. This fact must
        be taken into consideration when using this function.@{b}

   SEE ALSO@{ub}
        @{"ToUpper()" LINK "ToUpper"}, @{"locale.library/ConvToLower()" LINK "gg:doc/NDK/Guide/locale/ConvToLower"}

@ENDNODE
@NODE "ToUpper" "utility.library/ToUpper()"
@{b}

   NAME@{ub}
        @{"ToUpper" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 123} -- convert a character to upper case. (V37)@{b}

   SYNOPSIS@{ub}
        char = @{"ToUpper" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 123}(char);
        D0             D0

        @{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62} @{"ToUpper" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 123}(@{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62});@{b}

   FUNCTION@{ub}
        Converts a character to upper case, handling international character
        sets.@{b}

   INPUTS@{ub}
        char - character to be converted.@{b}

   RESULTS@{ub}
        char - upper case version of input character.@{b}

   NOTES@{ub}
        Whenever @{"locale.library" LINK "gg:doc/NDK/Guide/locale/MAIN"} is installed in a system, this function is
        replaced by language-specific code. This means that depending on
        which language the user has currently selected, a given character may
        return different results when passed to this function. This fact must
        be taken into consideration when using this function.@{b}

   SEE ALSO@{ub}
        @{"ToUpper" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 123}(), @{"locale.library/ConvToLower()" LINK "gg:doc/NDK/Guide/locale/ConvToLower"}

@ENDNODE
@NODE "UDivMod32" "utility.library/UDivMod32()"
@{b}

   NAME@{ub}
        @{"UDivMod32" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 111} -- unsigned 32 by 32 bit division and modulus. (V36)@{b}

   SYNOPSIS@{ub}
        quotient:remainder = @{"UDivMod32" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 111}(dividend,divisor);
        D0       D1                    D0       D1

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}:@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"UDivMod32" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 111}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        Divides the unsigned 32 bit dividend by the unsigned 32 bit divisor
        and returns an unsigned 32 bit quotient and remainder.@{b}

   INPUTS@{ub}
        dividend - unsigned 32 bit dividend.
        divisor - unsigned 32 bit divisor.@{b}

   RESULTS@{ub}
        quotient - unsigned 32 quotient of the division.
        remainder - unsigned 32 remainder of the division.@{b}

   NOTES@{ub}
        Unlike other Amiga library function calls, the utility.library
        32 bit math routines do @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} require A6 to be loaded with a
        pointer to the library base. A6 can contain anything the application
        wishes. This is in order to avoid overhead in calling them.

        In addition, the utility.library math routines preserve all
        address registers including A0 and A1@{b}

   SEE ALSO@{ub}
        @{"SDivMod32()" LINK "SDivMod32"}, @{"SMult32()" LINK "SMult32"}, @{"UMult32()" LINK "UMult32"}

@ENDNODE
@NODE "UMult32" "utility.library/UMult32()"
@{b}

   NAME@{ub}
        @{"UMult32" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 103} -- unsigned 32 by 32 bit multiply with 32 bit result. (V36)@{b}

   SYNOPSIS@{ub}
        result = @{"UMult32" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 103}(arg1,arg2);
        D0               D0   D1

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"UMult32" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 103}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        Returns the unsigned 32 bit result of multiplying arg1 by arg2.@{b}

   INPUTS@{ub}
        arg1, arg2 - numbers to multiply@{b}

   RESULTS@{ub}
        result - the unsigned 32 bit result of multiplying arg1 by arg2.@{b}

   NOTES@{ub}
        Unlike other Amiga library function calls, the utility.library
        32 bit math routines do @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} require A6 to be loaded with a
        pointer to the library base. A6 can contain anything the application
        wishes. This is in order to avoid overhead in calling them.

        In addition, the utility.library math routines preserve all
        address registers including A0 and A1@{b}

   SEE ALSO@{ub}
        @{"SDivMod32()" LINK "SDivMod32"}, @{"SMult32()" LINK "SMult32"}, @{"UDivMod32()" LINK "UDivMod32"}, @{"SMult64()" LINK "SMult64"}, @{"UMult64()" LINK "UMult64"}

@ENDNODE
@NODE "UMult64" "utility.library/UMult64()"
@{b}

   NAME@{ub}
        @{"UMult64" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 139} -- unsigned 32 by 32 bit multiply with 64 bit result. (V39)@{b}

   SYNOPSIS@{ub}
        result = @{"UMult64" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 139}(arg1,arg2);
        D0:D1               D0   D1

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"UMult64" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 139}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        Returns the unsigned 64 bit result of multiplying arg1 by arg2.@{b}

   INPUTS@{ub}
        arg1, arg2 - numbers to multiply@{b}

   RESULTS@{ub}
        result - the unsigned 64 bit result of multiplying arg1 by arg2.@{b}

   NOTES@{ub}
        Unlike other Amiga library function calls, the utility.library
        32 bit math routines do @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} require A6 to be loaded with a
        pointer to the library base. A6 can contain anything the application
        wishes. This is in order to avoid overhead in calling them.

        In addition, the utility.library math routines preserve all
        address registers including A0 and A1@{b}

   SEE ALSO@{ub}
        @{"SDivMod32()" LINK "SDivMod32"}, @{"SMult32()" LINK "SMult32"}, @{"UDivMod32()" LINK "UDivMod32"}, @{"SMult64()" LINK "SMult64"}

@ENDNODE
@NODE "UnpackStructureTags" "utility.library/UnpackStructureTags()"
@{b}

   NAME@{ub}
        @{"UnpackStructureTags" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 147} -- unpack a structure to values in taglist. (V39)@{b}

   SYNOPSIS@{ub}
        num = @{"UnpackStructureTags" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 147}(pack,packTable,tagList);
        D0                        A0   A1        A2

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"UnpackStructureTags" LINK "gg:doc/NDK/Guide/Include/inline/utility.h/File" 147}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} *,@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *);@{b}

   FUNCTION@{ub}
        For each table entry, a @{"FindTagItem()" LINK "FindTagItem"} will be done and if the
        matching tag is found in the taglist, the data in the structure
        will be placed into the memory pointed to by the tag's ti_Data.
        ti_Data *must* point to a LONGWORD.@{b}

   INPUTS@{ub}
        pack - a pointer to the data area to be unpacked
        packTable - a pointer to the packing information table.
                    See <@{"utility/pack.h" LINK "gg:doc/NDK/Guide/Include/utility/pack.h/File"}> for definition and macros
        tagList - a pointer to the taglist to unpack into@{b}

   RESULTS@{ub}
        num - the number of tag items unpacked@{b}

   SEE ALSO@{ub}
        <@{"utility/pack.h" LINK "gg:doc/NDK/Guide/Include/utility/pack.h/File"}>, @{"FindTagItem()" LINK "FindTagItem"}, @{"PackStructureTags()" LINK "PackStructureTags"}

@ENDNODE
