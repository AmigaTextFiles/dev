@DATABASE "gg:doc/NDK/Guide/mathieeesingbas"
@MASTER   "gg:doc/NDK/AutoDocs/mathieeesingbas.doc"
@REMARK   This file was created by ADtoHT 2.1 on 06-Jan-13 19:24:23
@REMARK   Do not edit
@REMARK   ADtoHT is © 1993-1995 Christian Stieber

@NODE MAIN "mathieeesingbas.doc"
@TOC "gg:doc/NDK/Guide/TOC/MAIN"

                           @{b}mathieeesingbas.library@{ub}

@{"Background" LINK "Background"}

@{"IEEESPAbs()" LINK "IEEESPAbs"}  @{"IEEESPAdd()" LINK "IEEESPAdd"}    @{"IEEESPCeil()" LINK "IEEESPCeil"}  @{"IEEESPCmp()" LINK "IEEESPCmp"}  @{"IEEESPDiv()" LINK "IEEESPDiv"}
@{"IEEESPFix()" LINK "IEEESPFix"}  @{"IEEESPFloor()" LINK "IEEESPFloor"}  @{"IEEESPFlt()" LINK "IEEESPFlt"}   @{"IEEESPMul()" LINK "IEEESPMul"}  @{"IEEESPNeg()" LINK "IEEESPNeg"}
@{"IEEESPSub()" LINK "IEEESPSub"}  @{"IEEESPTst()" LINK "IEEESPTst"}    

@ENDNODE
@NODE "Background" "mathieeesingbas.library/Background (information)"


   PURPOSE

        The @{"mathieeesingbas.library" LINK "gg:doc/NDK/Guide/mathieeesingbas/MAIN"} provides basic arithmetic functions for
        handling double precision IEEE numbers. If a FPU is found present in
        the system, this library uses the FPU for calculations. Otherwise,
        the CPU will provide a suitable emulation.

        The 68040 and 68060 built-in FPUs do not provide all instructions
        that the 68881/882 FPUs implement, and hence some of their
        instructions have to be emulated in software. This works either
        by the FPU specific trap vectors that have been installed by the
        68040 or 68060.library on boot-up, or - if available - by the
        fpsp.resource which is optionally linked into the system by the
        680?0 libraries.

        The advantage of the resource solution is that it does not require
        the overhead caused by the exception processing.
        All this - complete CPU usage, FPU usage plus optional fpsp.resource
        support - is completely transparent to the user of this library.

        As of V45 of this library, the mathieee.resources are no longer
        supported. It was felt that this solution was never very popular,
        neither very fast compared to a coprocessor interface, and highly
        obsolete.


   CAVEATS

        The library base of the @{"mathieeesingbas.library" LINK "gg:doc/NDK/Guide/mathieeesingbas/MAIN"} MUST @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} be shared
        among tasks. The reason for this restriction is that the library
        open vector requires to initialize the FPU properly for the caller's
        task context.
        Hence, you may not open this library in one task, pass the library
        base over and use it from another task as the FPU initialization
        would not be run for the second task. You must re-open the library
        again from the second task.

        This restriction has some implications in using the math IEEE
        libraries from within other libraries. The first implication is that
        opening the @{"mathieeesingbas.library" LINK "gg:doc/NDK/Guide/mathieeesingbas/MAIN"} in the LibInit() function IS @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500}
        ENOUGH to ensure proper operation as it will initialize the FPU in
        the context of the ramlib process loading the library, but not in
        the context of the caller. This is obviously of no use for the task
        that wants to use IEEE math.

        Instead, it is recommended to (re-)open the @{"mathieeesingbas.library" LINK "gg:doc/NDK/Guide/mathieeesingbas/MAIN"}
        once for each LibOpen() within your library, and to close it once
        for each LibClose() call.

        As a special rule that is hereby documented, the result code of
        subsequent @{"OpenLibrary()" LINK "gg:doc/NDK/Guide/exec/OpenLibrary"} calls once the library is open will be
        either @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} on error, or the same library base you received by the
        initial @{"OpenLibrary()" LINK "gg:doc/NDK/Guide/exec/OpenLibrary"}, i.e. in LibInit().

        Even though this releases you from the obligation to keep a private
        copy of the math library base once for each LibOpen(), it does not
        release you from re-opening the library again for each caller.
        It is enough to check wether the library opened successfully, and to
        throw the library base away afterwards, though. It will not deliver
        task-dependent library bases if it opens successfully.

        The second implication is that the same, or more restrictions apply
        to your library then as well, and, in fact, to its full tree of
        callers. Its library base may not be shared among tasks and must be
        re-openend for each potential caller.

        Note that you should document these requirements!

        The reason is again that the mathieee FPU init code must be run for
        each task that wants to use your, and hence this math library.
        Whether you deliver a per-task allocated library base, or one and
        the same library base is, of course, up to you.

        To overcome this limitation, your library might want to launch a
        side task that runs all the mathematical computations such that
        all callers of your library never enter a single function of the
        IEEE libs. Then, of course, the IEEE libs should not be opened
        in LibInit() or LibOpen(), but in the startup code of the side task,
        and should be closed by its shutdown code.


        Since the FPU initialization performed by the library depends on
        the selected precision, i.e. IEEE double vs. IEEE single precision,
        the third implication is that you must not mix the double and single
        precision math libraries within the same task. Either, you decide for
        double precision and stay with it, or you decide for single precision
        once and for all. You may not perform some calculations in double,
        and others in single precision as both kinds of libraries require the
        same hardware - namely the FPU - but with different settings.

        This goes of course, too, to the full caller tree of a library that
        runs IEEE functions in the context of its callers.



        Not following these rules may cause slightly wrong results in the
        sense that they might not be rounded properly to the selected
        precision. It may also cause other strange and wonderful side effects
        that are not mentioned here, and will make the library unreliable
        from a numerical point of view.



   BUGS
        The ROM resident @{"mathieeesingbas.library" LINK "gg:doc/NDK/Guide/mathieeesingbas/MAIN"} is not necessarely
        initialized correctly such that it might not be able to use the FPU
        of a 68040 or 68060 even though a FPU is present. This bug is
        fixed by either the 68040 or 68060.libraries, or by SetPatch.

@ENDNODE
@NODE "IEEESPAbs" "mathieeesingbas.library/IEEESPAbs()"
@{b}

   NAME@{ub}
        IEEESPAbs -- compute absolute value of IEEE single precision argument@{b}

   SYNOPSIS@{ub}
          x   = IEEESPAbs(  y  );
         d0                 d0

        float   x,y;@{b}

   FUNCTION@{ub}
        Take the absolute value of argument y and return it to caller.@{b}

   INPUTS@{ub}
        y -- IEEE single precision floating point value@{b}

   RESULT@{ub}
        x -- IEEE single precision floating point value@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}

@ENDNODE
@NODE "IEEESPAdd" "mathieeesingbas.library/IEEESPAdd()"
@{b}

   NAME@{ub}
        IEEESPAdd -- add one single precision IEEE number to another@{b}

   SYNOPSIS@{ub}
          x   = IEEESPAdd(  y  ,  z  );
         d0                d0     d1

        float   x,y,z;@{b}

   FUNCTION@{ub}
        Compute x = y + z in IEEE single precision.@{b}

   INPUTS@{ub}
        y -- IEEE single precision floating point value
        z -- IEEE single precision floating point value@{b}

   RESULT@{ub}
        x -- IEEE single precision floating point value@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"IEEESPSub()" LINK "IEEESPSub"}

@ENDNODE
@NODE "IEEESPCeil" "mathieeesingbas.library/IEEESPCeil()"
@{b}

   NAME@{ub}
        IEEESPCeil -- compute Ceil function of IEEE single precision number@{b}

   SYNOPSIS@{ub}
          x   = IEEESPCeil(  y  );
         d0                  d0

        float   x,y;@{b}

   FUNCTION@{ub}
        Calculate the least integer greater than or equal to x and return it.
        This identity is true.  Ceil(x) = -Floor(-x).@{b}

   INPUTS@{ub}
        y -- IEEE single precision floating point value@{b}

   RESULT@{ub}
        x -- IEEE single precision floating point value@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"IEEESPFloor()" LINK "IEEESPFloor"}

@ENDNODE
@NODE "IEEESPCmp" "mathieeesingbas.library/IEEESPCmp()"
@{b}

   NAME@{ub}
        IEEESPCmp -- compare two single precision floating point numbers@{b}

   SYNOPSIS@{ub}
          c   = IEEESPCmp(  y  ,  z  );
          d0                d0   d1

        float   y,z;
        long    c;@{b}

   FUNCTION@{ub}
        Compare y with z. Set the condition codes for less, greater, or
        equal. Set return value c to -1 if y<z, or +1 if y>z, or 0 if
        y == z.@{b}

   INPUTS@{ub}
        y -- IEEE single precision floating point value
        z -- IEEE single precision floating point value@{b}

   RESULT@{ub}
       c = 1   cc = gt         for (y > z)
       c = 0   cc = eq         for (y == z)
       c = -1  cc = lt         for (y < z)@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}

@ENDNODE
@NODE "IEEESPDiv" "mathieeesingbas.library/IEEESPDiv()"
@{b}

   NAME@{ub}
        IEEESPDiv -- divide one single precision IEEE by another@{b}

   SYNOPSIS@{ub}
          x   = IEEESPDiv(  y  ,  z  );
         d0                d0    d1

        float   x,y,z;@{b}

   FUNCTION@{ub}
        Compute x = y / z in IEEE single precision.
        Note that the Motorola fast floating point Div routine reverses
        the order of the arguments for the C interface, although the
        dividend is still in d0 and the divisor is in d1.@{b}

   INPUTS@{ub}
        y -- IEEE single precision floating point value
        z -- IEEE single precision floating point value@{b}

   RESULT@{ub}
        x -- IEEE single precision floating point value@{b}

   BUGS@{ub}
        Due to a bug in the ROM of some Amiga models, this function should
        not be called prior running SetPatch.@{b}

   SEE ALSO@{ub}
        @{"IEEESPMul()" LINK "IEEESPMul"}

@ENDNODE
@NODE "IEEESPFix" "mathieeesingbas.library/IEEESPFix()"
@{b}

   NAME@{ub}
        IEEESPFix -- convert IEEE single float to integer@{b}

   SYNOPSIS@{ub}
        x   = IEEESPFix(  y  );
        d0               d0

        long    x;
        float   y;@{b}

   FUNCTION@{ub}
        Convert IEEE single precision argument to a 32 bit signed integer
        and return result.@{b}

   INPUTS@{ub}
        y -- IEEE single precision floating point value@{b}

   RESULT@{ub}
        if no overflow occured then return
                x -- 32 bit signed integer
        if overflow return largest +- integer
                For round to zero@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"IEEESPFlt()" LINK "IEEESPFlt"}

@ENDNODE
@NODE "IEEESPFloor" "mathieeesingbas.library/IEEESPFloor()"
@{b}

   NAME@{ub}
        IEEESPFloor -- compute Floor function of IEEE single precision number@{b}

   SYNOPSIS@{ub}
          x   = IEEESPFloor(  y  );
          d0                  d0

        float   x,y;@{b}

   FUNCTION@{ub}
        Calculate the largest integer less than or equal to x and return it.@{b}

   INPUTS@{ub}
        y -- IEEE single precision floating point value@{b}

   RESULT@{ub}
        x -- IEEE single precision floating point value@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"IEEESPCeil()" LINK "IEEESPCeil"}

@ENDNODE
@NODE "IEEESPFlt" "mathieeesingbas.library/IEEESPFlt()"
@{b}

   NAME@{ub}
        IEEESPFlt -- convert integer to IEEE single precision number@{b}

   SYNOPSIS@{ub}
          x   = IEEESPFlt(  y  );
         d0                d0

        float   x;
        long    y;@{b}

   FUNCTION@{ub}
        Convert a signed 32 bit value to a single precision IEEE value
        and return it in d0. No exceptions can occur with this
        function.@{b}

   INPUTS@{ub}
        y -- 32 bit integer in d0@{b}

   RESULT@{ub}
        x is a 32 bit single precision IEEE value@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"IEEESPFix()" LINK "IEEESPFix"}

@ENDNODE
@NODE "IEEESPMul" "mathieeesingbas.library/IEEESPMul()"
@{b}

   NAME@{ub}
        IEEESPMul -- multiply one double precision IEEE number by another@{b}

   SYNOPSIS@{ub}
          x   = IEEESPMul(  y  ,  z  );
         d0                d0    d1

        float   x,y,z;@{b}

   FUNCTION@{ub}
        Compute x = y * z in IEEE single precision.@{b}

   INPUTS@{ub}
        y -- IEEE single precision floating point value
        z -- IEEE single precision floating point value@{b}

   RESULT@{ub}
        x -- IEEE single precision floating point value@{b}

   BUGS@{ub}
        Due to a bug in the ROM of some Amiga models, this function should
        not be called prior running SetPatch.@{b}

   SEE ALSO@{ub}
        @{"IEEESPDiv()" LINK "IEEESPDiv"}

@ENDNODE
@NODE "IEEESPNeg" "mathieeesingbas.library/IEEESPNeg()"
@{b}

   NAME@{ub}
        IEEESPNeg -- compute negative value of IEEE single precision number@{b}

   SYNOPSIS@{ub}
          x   = IEEESPNeg(  y  );
          d0               d0

        float   x,y;@{b}

   FUNCTION@{ub}
        Invert the sign of argument y and return it to caller.@{b}

   INPUTS@{ub}
        y - IEEE single precision floating point value@{b}

   RESULT@{ub}
        x - IEEE single precision floating point value@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}

@ENDNODE
@NODE "IEEESPSub" "mathieeesingbas.library/IEEESPSub()"
@{b}

   NAME@{ub}
        IEEESPSub -- subtract one single precision IEEE number from another@{b}

   SYNOPSIS@{ub}
          x   = IEEESPSub(  y  ,  z  );
         d0                d0     d1

        float   x,y,z;@{b}

   FUNCTION@{ub}
        Compute x = y - z in IEEE single precision.@{b}

   INPUTS@{ub}
        y -- IEEE single precision floating point value
        z -- IEEE single precision floating point value@{b}

   RESULT@{ub}
        x -- IEEE single precision floating point value@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"IEEESPAdd()" LINK "IEEESPAdd"}

@ENDNODE
@NODE "IEEESPTst" "mathieeesingbas.library/IEEESPTst()"
@{b}

   NAME@{ub}
        IEEESPTst -- compare IEEE single precision value to 0.0@{b}

   SYNOPSIS@{ub}
          c   = IEEESPTst(  y  );
          d0                d0

        float   y;
        long    c;@{b}

   FUNCTION@{ub}
        Compare y to 0.0, set the condition codes for less than, greater
        than, or equal to 0.0.  Set the return value c to -1 if less than,
        to +1 if greater than, or 0 if equal to 0.0.@{b}

   INPUTS@{ub}
        y -- IEEE single precision floating point value@{b}

   RESULT@{ub}
        c = 1   cc = gt         for (y > 0.0)
        c = 0   cc = eq         for (y == 0.0)
        c = -1  cc = lt         for (y < 0.0)@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}

@ENDNODE
