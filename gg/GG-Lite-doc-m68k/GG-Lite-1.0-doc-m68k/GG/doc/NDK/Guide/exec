@DATABASE "gg:doc/NDK/Guide/exec"
@MASTER   "gg:doc/NDK/AutoDocs/exec.doc"
@REMARK   This file was created by ADtoHT 2.1 on 06-Jan-13 19:20:46
@REMARK   Do not edit
@REMARK   ADtoHT is © 1993-1995 Christian Stieber

@NODE MAIN "exec.doc"
@TOC "gg:doc/NDK/Guide/TOC/MAIN"

                                @{b}exec.library@{ub}

@{"AbortIO()" LINK "AbortIO"}                    @{"AddDevice()" LINK "AddDevice"}
@{"AddHead()" LINK "AddHead"}                    @{"AddIntServer()" LINK "AddIntServer"}
@{"AddLibrary()" LINK "AddLibrary"}                 @{"AddMemHandler()" LINK "AddMemHandler"}
@{"AddMemList()" LINK "AddMemList"}                 @{"AddPort()" LINK "AddPort"}
@{"AddResource()" LINK "AddResource"}                @{"AddSemaphore()" LINK "AddSemaphore"}
@{"AddTail()" LINK "AddTail"}                    @{"AddTask()" LINK "AddTask"}
@{"Alert()" LINK "Alert"}                      @{"AllocAbs()" LINK "AllocAbs"}
@{"Allocate()" LINK "Allocate"}                   @{"AllocEntry()" LINK "AllocEntry"}
@{"AllocMem()" LINK "AllocMem"}                   @{"AllocPooled()" LINK "AllocPooled"}
@{"AllocSignal()" LINK "AllocSignal"}                @{"AllocTrap()" LINK "AllocTrap"}
@{"AllocVec()" LINK "AllocVec"}                   @{"AttemptSemaphore()" LINK "AttemptSemaphore"}
@{"AttemptSemaphoreShared()" LINK "AttemptSemaphoreShared"}     @{"AvailMem()" LINK "AvailMem"}
@{"AVL_AddNode()" LINK "AVL_AddNode"}                @{"AVL_FindFirstNode()" LINK "AVL_FindFirstNode"}
@{"AVL_FindLastNode()" LINK "AVL_FindLastNode"}           @{"AVL_FindNextNodeByAddress()" LINK "AVL_FindNextNodeByAddress"}
@{"AVL_FindNextNodeByKey()" LINK "AVL_FindNextNodeByKey"}      @{"AVL_FindNode()" LINK "AVL_FindNode"}
@{"AVL_FindPrevNodeByAddress()" LINK "AVL_FindPrevNodeByAddress"}  @{"AVL_FindPrevNodeByKey()" LINK "AVL_FindPrevNodeByKey"}
@{"AVL_RemNodeByAddress()" LINK "AVL_RemNodeByAddress"}       @{"AVL_RemNodeByKey()" LINK "AVL_RemNodeByKey"}
@{"CacheClearE()" LINK "CacheClearE"}                @{"CacheClearU()" LINK "CacheClearU"}
@{"CacheControl()" LINK "CacheControl"}               @{"CachePostDMA()" LINK "CachePostDMA"}
@{"CachePreDMA()" LINK "CachePreDMA"}                @{"Cause()" LINK "Cause"}
@{"CheckIO()" LINK "CheckIO"}                    @{"CloseDevice()" LINK "CloseDevice"}
@{"CloseLibrary()" LINK "CloseLibrary"}               @{"ColdReboot()" LINK "ColdReboot"}
@{"CopyMem()" LINK "CopyMem"}                    @{"CopyMemQuick()" LINK "CopyMemQuick"}
@{"CreateIORequest()" LINK "CreateIORequest"}            @{"CreateMsgPort()" LINK "CreateMsgPort"}
@{"CreatePool()" LINK "CreatePool"}                 @{"Deallocate()" LINK "Deallocate"}
@{"Debug()" LINK "Debug"}                      @{"DeleteIORequest()" LINK "DeleteIORequest"}
@{"DeleteMsgPort()" LINK "DeleteMsgPort"}              @{"DeletePool()" LINK "DeletePool"}
@{"Disable()" LINK "Disable"}                    @{"DoIO()" LINK "DoIO"}
@{"Enable()" LINK "Enable"}                     @{"Enqueue()" LINK "Enqueue"}
@{"FindName()" LINK "FindName"}                   @{"FindPort()" LINK "FindPort"}
@{"FindResident()" LINK "FindResident"}               @{"FindSemaphore()" LINK "FindSemaphore"}
@{"FindTask()" LINK "FindTask"}                   @{"Forbid()" LINK "Forbid"}
@{"FreeEntry()" LINK "FreeEntry"}                  @{"FreeMem()" LINK "FreeMem"}
@{"FreePooled()" LINK "FreePooled"}                 @{"FreeSignal()" LINK "FreeSignal"}
@{"FreeTrap()" LINK "FreeTrap"}                   @{"FreeVec()" LINK "FreeVec"}
@{"GetCC()" LINK "GetCC"}                      @{"GetMsg()" LINK "GetMsg"}
@{"InitCode()" LINK "InitCode"}                   @{"InitResident()" LINK "InitResident"}
@{"InitSemaphore()" LINK "InitSemaphore"}              @{"InitStruct()" LINK "InitStruct"}
@{"Insert()" LINK "Insert"}                     @{"LIB_AVL_FindFirstNode()" LINK "AVL_FindFirstNode"}
@{"LIB_AVL_FindLastNode()" LINK "AVL_FindLastNode"}       @{"MakeFunctions()" LINK "MakeFunctions"}
@{"MakeLibrary()" LINK "MakeLibrary"}                @{"ObtainQuickVector()" LINK "ObtainQuickVector"}
@{"ObtainSemaphore()" LINK "ObtainSemaphore"}            @{"ObtainSemaphoreList()" LINK "ObtainSemaphoreList"}
@{"ObtainSemaphoreShared()" LINK "ObtainSemaphoreShared"}      @{"OldOpenLibrary()" LINK "OldOpenLibrary"}
@{"OpenDevice()" LINK "OpenDevice"}                 @{"OpenLibrary()" LINK "OpenLibrary"}
@{"OpenResource()" LINK "OpenResource"}               @{"Permit()" LINK "Permit"}
@{"Procure()" LINK "Procure"}                    @{"PutMsg()" LINK "PutMsg"}
@{"RawDoFmt()" LINK "RawDoFmt"}                   @{"ReleaseSemaphore()" LINK "ReleaseSemaphore"}
@{"ReleaseSemaphoreList()" LINK "ReleaseSemaphoreList"}       @{"RemDevice()" LINK "RemDevice"}
@{"RemHead()" LINK "RemHead"}                    @{"RemIntServer()" LINK "RemIntServer"}
@{"RemLibrary()" LINK "RemLibrary"}                 @{"RemMemHandler()" LINK "RemMemHandler"}
@{"Remove()" LINK "Remove"}                     @{"RemPort()" LINK "RemPort"}
@{"RemResource()" LINK "RemResource"}                @{"RemSemaphore()" LINK "RemSemaphore"}
@{"RemTail()" LINK "RemTail"}                    @{"RemTask()" LINK "RemTask"}
@{"ReplyMsg()" LINK "ReplyMsg"}                   @{"SendIO()" LINK "SendIO"}
@{"SetExcept()" LINK "SetExcept"}                  @{"SetFunction()" LINK "SetFunction"}
@{"SetIntVector()" LINK "SetIntVector"}               @{"SetSignal()" LINK "SetSignal"}
@{"SetSR()" LINK "SetSR"}                      @{"SetTaskPri()" LINK "SetTaskPri"}
@{"Signal()" LINK "Signal"}                     @{"StackSwap()" LINK "StackSwap"}
@{"SumKickData()" LINK "SumKickData"}                @{"SumLibrary()" LINK "SumLibrary"}
@{"SuperState()" LINK "SuperState"}                 @{"Supervisor()" LINK "Supervisor"}
@{"TypeOfMem()" LINK "TypeOfMem"}                  @{"UserState()" LINK "UserState"}
@{"Vacate()" LINK "Vacate"}                     @{"Wait()" LINK "Wait"}
@{"WaitIO()" LINK "WaitIO"}                     @{"WaitPort()" LINK "WaitPort"}



                                     @{b}SAD@{ub}

@{"Overview" LINK "Overview"}

@{"ALLOCATE_MEMORY" LINK "ALLOCATE_MEMORY"}              @{"CALL_ADDRESS" LINK "CALL_ADDRESS"}
@{"FREE_MEMORY" LINK "FREE_MEMORY"}                  @{"GET_CONTEXT_FRAME" LINK "GET_CONTEXT_FRAME"}
@{"NOP" LINK "NOP"}                          @{"READ_ARRAY" LINK "READ_ARRAY"}
@{"READ_BYTE" LINK "READ_BYTE"}                    @{"READ_LONG" LINK "READ_LONG"}
@{"READ_WORD" LINK "READ_WORD"}                    @{"RESET" LINK "RESET"}
@{"RETURN_TO_SYSTEM" LINK "RETURN_TO_SYSTEM"}             @{"TURN_OFF_SINGLE" LINK "TURN_OFF_SINGLE"}
@{"TURN_ON_SINGLE" LINK "TURN_ON_SINGLE"}               @{"WRITE_ARRAY" LINK "WRITE_ARRAY"}
@{"WRITE_BYTE" LINK "WRITE_BYTE"}                   @{"WRITE_LONG" LINK "WRITE_LONG"}
@{"WRITE_WORD" LINK "WRITE_WORD"}                   

@ENDNODE
@NODE "AbortIO" "exec.library/AbortIO()"
@{b}

   NAME@{ub}
        @{"AbortIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 317} - attempt to abort an in-progress I/O request@{b}

   SYNOPSIS@{ub}
        @{"AbortIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 317}(iORequest)
                A1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"AbortIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 317}(@{"struct IORequest" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 18} *);@{b}

   FUNCTION@{ub}
        Ask a device to abort a previously started IORequest.  This is done
        by calling the device's ABORTIO vector, with your given IORequest.


        @{"AbortIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 317} is a command the device that may or may not grant.  If
        successful, the device will stop processing the IORequest, and
        reply to it earlier than it would otherwise have done.@{b}

   NOTE@{ub}
        @{"AbortIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 317}() does @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} @{"Remove()" LINK "Remove"} the IORequest from your ReplyPort, OR
        wait for it to complete.  After an @{"AbortIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 317}() you must wait normally
        for the reply message before actually reusing the request.

        If a request has already completed when @{"AbortIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 317}() is called, no
        action is taken.@{b}

   EXAMPLE@{ub}
            @{"AbortIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 317}(timer_request);
            @{"WaitIO" LINK "WaitIO"}(timer_request);
            /* Message is free to be reused */@{b}

   INPUTS@{ub}
        iORequest - pointer to an I/O request block (must have been used
                at least once.  May be active or finished).@{b}

   SEE ALSO@{ub}
        @{"WaitIO" LINK "WaitIO"}, @{"DoIO" LINK "DoIO"}, @{"SendIO" LINK "SendIO"}, @{"CheckIO" LINK "CheckIO"}

@ENDNODE
@NODE "AddDevice" "exec.library/AddDevice()"
@{b}

   NAME@{ub}
        @{"AddDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 285} -- add a device to the system@{b}

   SYNOPSIS@{ub}
        @{"AddDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 285}(device)
                  A1

        void @{"AddDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 285}(@{"struct Device" LINK "gg:doc/NDK/Guide/Include/exec/devices.h/File" 24} *);@{b}

   FUNCTION@{ub}
        This function adds a new device to the system device list, making
        it available to other programs.  The device must be ready to be
        opened at this time.@{b}

   INPUTS@{ub}
        device - pointer to a properly initialized device node@{b}

   SEE ALSO@{ub}
        @{"RemDevice" LINK "RemDevice"}, @{"OpenDevice" LINK "OpenDevice"}, @{"CloseDevice" LINK "CloseDevice"}, @{"MakeLibrary" LINK "MakeLibrary"}

@ENDNODE
@NODE "AddHead" "exec.library/AddHead()"
@{b}

   NAME@{ub}
        @{"AddHead" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 157} -- insert node at the head of a list@{b}

   SYNOPSIS@{ub}
        @{"AddHead" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 157}(list, node)
                A0    A1

        void @{"AddHead" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 157}(@{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} *, @{"struct Node" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 22} *)@{b}

   FUNCTION@{ub}
        Add a node to the head of a doubly linked list. Assembly
        programmers may prefer to use the ADDHEAD macro from
        "exec/lists.i".@{b}

   WARNING@{ub}
        This function does not arbitrate for access to the list.  The
        calling task must be the owner of the involved list.@{b}

   INPUTS@{ub}
        list - a pointer to the target list header
        node - the node to insert at head@{b}

   SEE ALSO@{ub}
        @{"AddTail" LINK "AddTail"}, @{"Enqueue" LINK "Enqueue"}, @{"Insert" LINK "Insert"}, @{"Remove" LINK "Remove"}, @{"RemHead" LINK "RemHead"}, @{"RemTail" LINK "RemTail"}

@ENDNODE
@NODE "AddIntServer" "exec.library/AddIntServer()"
@{b}

   NAME@{ub}
        @{"AddIntServer" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 109} -- add an interrupt server to a system server chain@{b}

   SYNOPSIS@{ub}
        @{"AddIntServer" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 109}(intNum, interrupt)
                     D0-0:4  A1

        void @{"AddIntServer" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 109}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"struct Interrupt" LINK "gg:doc/NDK/Guide/Include/exec/interrupts.h/File" 22} *);@{b}

   FUNCTION@{ub}
        This function adds a new interrupt server to a given server chain.
        The node is located on the chain in a priority dependent position.
        If this is the first server on a particular chain, interrupts will
        be enabled for that chain.

        Each link in the chain will be called in priority order until the
        chain ends or one of the servers returns with the 68000's Z condition
        code clear (indicating non-zero).  Servers on the chain should return
        with the Z flag clear if the interrupt was specifically for that
        server, and no one else.  VERTB servers should always return Z set.
        (Take care with High Level Language servers, the language may not
        have a mechanism for reliably setting the Z flag on exit).

        Servers are called with the following register conventions:

            D0 - scratch
            D1 - scratch

            A0 - scratch
            A1 - server is_Data pointer (scratch)

            A5 - jump vector register (scratch)
            A6 - scratch

            all other registers must be preserved@{b}

   INPUTS@{ub}
        intNum - the Paula interrupt bit number (0 through 14). Processor
                 level seven interrupts (NMI) are encoded as intNum 15.
                 The PORTS, COPER, VERTB, EXTER and NMI interrupts are
                 set up as server chains.
        interrupt - pointer to an Interrupt structure.
                 By convention, the LN_NAME of the interrupt structure must
                 point a descriptive string so that other users may
                 identify who currently has control of the interrupt.@{b}

   WARNING@{ub}
        Some compilers or assemblers may optimize code in unexpected ways,
        affecting the conditions codes returned from the function.  Watch
        out for a "MOVEM" instruction (which does not affect the condition
        codes) turning into "MOVE" (which does).@{b}

   BUGS@{ub}
        The graphics library's VBLANK server, and some user code, currently
        assume that address register A0 will contain a pointer to the custom
        chips. If you add a server at a priority of 10 or greater, you must
        compensate for this by providing the expected value ($DFF000).@{b}

   SEE ALSO@{ub}
        @{"RemIntServer" LINK "RemIntServer"}, @{"SetIntVector" LINK "SetIntVector"}, hardware/intbits.i,exec/interrupts.i

@ENDNODE
@NODE "AddLibrary" "exec.library/AddLibrary()"
@{b}

   NAME@{ub}
        @{"AddLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 261} -- add a library to the system@{b}

   SYNOPSIS@{ub}
        @{"AddLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 261}(library)
                   A1

        void @{"AddLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 261}(@{"struct Library" LINK "gg:doc/NDK/Guide/Include/exec/libraries.h/File" 34} *);@{b}

   FUNCTION@{ub}
        This function adds a new library to the system, making it available
        to other programs.  The library should be ready to be opened at
        this time.  It will be added to the system library name list, and
        the checksum on the library entries will be calculated.@{b}

   INPUTS@{ub}
        library - pointer to a properly initialized library structure@{b}

   SEE ALSO@{ub}
        @{"RemLibrary" LINK "RemLibrary"}, @{"CloseLibrary" LINK "CloseLibrary"}, @{"OpenLibrary" LINK "OpenLibrary"}, @{"MakeLibrary" LINK "MakeLibrary"}

@ENDNODE
@NODE "AddMemHandler" "exec.library/AddMemHandler()"
@{b}

   NAME@{ub}
        @{"AddMemHandler" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 485} - Add a low memory handler to exec                 (V39)@{b}

   SYNOPSIS@{ub}
        @{"AddMemHandler" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 485}(memHandler)
                      A1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"AddMemHandler" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 485}(@{"struct Interrupt" LINK "gg:doc/NDK/Guide/Include/exec/interrupts.h/File" 22} *);@{b}

   FUNCTION@{ub}
        This function adds a low memory handler to the system.  The handler
        is described in the Interrupt structure.  Due to multitasking
        issues, the handler must be ready to run the moment this function
        call is made.  (The handler may be called before the call returns)@{b}

   NOTE@{ub}
        Adding a handler from within a handler will cause undefined
        actions.  It is safe to add a handler to the list while within
        a handler but the newly added handler may or may not be called
        for the specific failure currently running.@{b}

   EXAMPLE@{ub}
        @{"struct Interrupt" LINK "gg:doc/NDK/Guide/Include/exec/interrupts.h/File" 22} *myInt;  /* Assume it is allocated */

        myInt->is_Node.ln_Pri=50;  /* Relatively early; before RAMLIB */

        /* Please fill in the name field! */
        myInt->is_Node.ln_Name="Example Handler";

        myInt->is_Data=(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49})mydata_pointer;
        myInt->is_Code=myhandler_code;

        @{"AddMemHandler" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 485}(myInt);
        ... /* and so on */

        _myhandler_code:
                        ; This is the handler code
                        ; We are passed a pointer to @{"struct MemHandlerData" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 90}
                        ; in a0, the value of is_Data in a1 and
                        ; ExecBase in a6.
                        ; We must not break forbid!!!
        ;
        ; Start off assuming we did nothing
        ;
                moveq.l #@{"MEM_DID_NOTHING" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 100},d0
                move.l  memh_RequestFlags(a0),d1
                btst.l  #MEMB_CHIP,d1   ; Did the failure happen in CHIP
                beq.s   handler_nop     ; If not, we have nothing to do
                bsr     DoMyMagic       ; Do the magic...
                ; DoMyMagic frees whatever we can and returns d0 set...
        handler_nop:
                rts                     ; Return with d0 set...@{b}

   INPUTS@{ub}
        memHandler - A pointer to a completely filled in Interrupt structure
                     The priority field determine the position of the handler
                     with respect to other handlers in the system.  The higher
                     the priority, the earlier the handler is called.
                     Positive priorities will have the handler called before
                     any of the library expunge vectors are called.  Negative
                     priority handlers will be called after the library
                     expunge routines are called.
                     (Note:  RAMLIB is a handler at priority 0)@{b}

   SEE ALSO@{ub}
        @{"RemMemHandler" LINK "RemMemHandler"}, exec/interrupts.i

@ENDNODE
@NODE "AddMemList" "exec.library/AddMemList()"
@{b}

   NAME@{ub}
        @{"AddMemList" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 397} - add memory to the system free pool@{b}

   SYNOPSIS@{ub}
        @{"AddMemList" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 397}( size, attributes, pri, base, name )
                     D0      D1        D2   A0    A1

        void @{"AddMemList" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 397}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67});@{b}

   FUNCTION@{ub}
        Add a new region of memory to the system free pool.  The first few
        bytes will be used to hold the MemHeader structure.  The remainder
        will be made available to the rest of the world.@{b}

   INPUTS@{ub}
        size - the size (in bytes) of the memory area
        attributes - the attributes word that the memory pool will have
        pri  - the priority for this memory.  CHIP memory has a pri of -10,
               16 bit expansion memory has a priority of 0.  The higher the
               priority, the closer to the head of the memory list it will
               be placed.
        base - the base of the new memory area
        name - the name that will be used in the memory header, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
               if no name is to be provided.  This name is not copied, so it
               must remain valid for as long as the memory header is in the
               system.@{b}

   NOTES@{ub}
        *DO @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500}* add memory to the system with the attribute of @{"MEMF_KICK" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 74}.
        EXEC will mark your memory as such if it is of the right type.@{b}

   SEE ALSO@{ub}
        @{"AllocMem" LINK "AllocMem"}, @{"exec/memory.h" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File"}

@ENDNODE
@NODE "AddPort" "exec.library/AddPort()"
@{b}

   NAME@{ub}
        @{"AddPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 233} -- add a public message port to the system@{b}

   SYNOPSIS@{ub}
        @{"AddPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 233}(port)
                A1

        void @{"AddPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 233}(@{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *);@{b}

   FUNCTION@{ub}
        This function attaches a message port structure to the system's
        public message port list, where it can be found by the @{"FindPort()" LINK "FindPort"}
        function.  The name and priority fields of the port structure must
        be initialized prior to calling this function.  If the user does
        not require the priority field, it should be initialized to zero.

        Only ports that will be searched for with @{"FindPort()" LINK "FindPort"} need to
        be added to the system list.  In addition, adding ports is often
        useful during debugging.  If the port will be searched for,
        the priority field should be at least 1 (to avoid the large number
        of inactive ports at priority zero).  If the port will be searched
        for often, set the priority in the 50-100 range (so it will be
        before other less used ports).

        Once a port has been added to the naming list, you must be careful
        to remove the port from the list (via @{"RemPort" LINK "RemPort"}) before deallocating
        its memory.@{b}

   NOTE@{ub}
        A point of confusion is that clearing a MsgPort structure to all
        zeros is not enough to prepare it for use.  As mentioned in the
        Exec chapter of the ROM Kernel Manual, the List for the MsgPort
        must be initialized.  This is automatically handled by @{"AddPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 233}(),
        and @{"amiga.lib/CreatePort" LINK "gg:doc/NDK/Guide/amiga_lib/CreatePort"}.  This initialization can be done manually
        with @{"amiga.lib/NewList" LINK "gg:doc/NDK/Guide/amiga_lib/NewList"} or the assembly NEWLIST macro.

        Do not @{"AddPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 233} an active port.@{b}

   INPUTS@{ub}
        port - pointer to a message port@{b}

   SEE ALSO@{ub}
        @{"RemPort" LINK "RemPort"}, @{"FindPort" LINK "FindPort"}, @{"amiga.lib/CreatePort" LINK "gg:doc/NDK/Guide/amiga_lib/CreatePort"}, @{"amiga.lib/NewList" LINK "gg:doc/NDK/Guide/amiga_lib/NewList"}

@ENDNODE
@NODE "AddResource" "exec.library/AddResource()"
@{b}

   NAME@{ub}
        @{"AddResource" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 321} -- add a resource to the system@{b}

   SYNOPSIS@{ub}
        @{"AddResource" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 321}(resource)
                    A1

        void @{"AddResource" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 321}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        This function adds a new resource to the system and makes it
        available to other users.  The resource must be ready to be called
        at this time.

        Resources currently have no system-imposed structure, however they
        must start with a standard named node (LN_SIZE), and should with
        a standard Library node (LIB_SIZE).@{b}

   INPUTS@{ub}
        resource - pointer an initialized resource node@{b}

   SEE ALSO@{ub}
        @{"RemResource" LINK "RemResource"}, @{"OpenResource" LINK "OpenResource"}, @{"MakeLibrary" LINK "MakeLibrary"}

@ENDNODE
@NODE "AddSemaphore" "exec.library/AddSemaphore()"
@{b}

   NAME@{ub}
        @{"AddSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 385} -- initialize then add a signal semaphore to the system@{b}

   SYNOPSIS@{ub}
        @{"AddSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 385}(signalSemaphore)
                     A1

        void @{"AddSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 385}(@{"struct SignalSemaphore" LINK "gg:doc/NDK/Guide/Include/exec/semaphores.h/File" 40} *);@{b}

   FUNCTION@{ub}
        This function attaches a signal semaphore structure to the system's
        public signal semaphore list.  The name and priority fields of the
        semaphore structure must be initialized prior to calling this
        function.  If you do not want to let others rendezvous with this
        semaphore, use @{"InitSemaphore()" LINK "InitSemaphore"} instead.

        If a semaphore has been added to the naming list, you must be
        careful to remove the semaphore from the list (via @{"RemSemaphore" LINK "RemSemaphore"})
        before deallocating its memory.

        Semaphores that are linked together in an allocation list (which
        @{"ObtainSemaphoreList()" LINK "ObtainSemaphoreList"} would use) may not be added to the system
        naming list, because the facilities use the link field of the
        signal semaphore in incompatible ways@{b}

   INPUTS@{ub}
       signalSemaphore -- an signal semaphore structure@{b}

   BUGS@{ub}
        Does not work in Exec <V36.  Instead use this code:

            #include <@{"exec/execbase.h" LINK "gg:doc/NDK/Guide/Include/exec/execbase.h/File"}>
            #include <@{"exec/nodes.h" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File"}>
            extern @{"struct ExecBase" LINK "gg:doc/NDK/Guide/Include/exec/execbase.h/File" 34} *SysBase;
                ...
            void LocalAddSemaphore(s)
            @{"struct SignalSemaphore" LINK "gg:doc/NDK/Guide/Include/exec/semaphores.h/File" 40} *s;
            {
                s->ss_Link.ln_Type=@{"NT_SIGNALSEM" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 58};
                @{"InitSemaphore" LINK "InitSemaphore"}(s);
                @{"Forbid()" LINK "Forbid"};
                @{"Enqueue" LINK "Enqueue"}(&SysBase->SemaphoreList,s);
                @{"Permit()" LINK "Permit"};
            }@{b}

   SEE ALSO@{ub}
        @{"RemSemaphore" LINK "RemSemaphore"}, @{"FindSemaphore" LINK "FindSemaphore"}, @{"InitSemaphore" LINK "InitSemaphore"}

@ENDNODE
@NODE "AddTail" "exec.library/AddTail()"
@{b}

   NAME@{ub}
        @{"AddTail" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 161} -- append node to tail of a list@{b}

   SYNOPSIS@{ub}
        @{"AddTail" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 161}(list, node)
                A0    A1

        void @{"AddTail" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 161}(@{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} *, @{"struct Node" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 22} *);@{b}

   FUNCTION@{ub}
        Add a node to the tail of a doubly linked list.  Assembly
        programmers may prefer to use the ADDTAIL macro from
        "exec/lists.i".@{b}

   WARNING@{ub}
        This function does not arbitrate for access to the list.  The
        calling task must be the owner of the involved list.@{b}

   INPUTS@{ub}
        list - a pointer to the target list header
        node - a pointer to the node to insert at tail of the list@{b}

   SEE ALSO@{ub}
        @{"AddHead" LINK "AddHead"}, @{"Enqueue" LINK "Enqueue"}, @{"Insert" LINK "Insert"}, @{"Remove" LINK "Remove"}, @{"RemHead" LINK "RemHead"}, @{"RemTail" LINK "RemTail"}

@ENDNODE
@NODE "AddTask" "exec.library/AddTask()"
@{b}

   NAME@{ub}
        @{"AddTask" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 185} -- add a task to the system@{b}

   SYNOPSIS@{ub}
        @{"AddTask" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 185}(task, initialPC, finalPC)
                A1    A2         A3

        @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} @{"AddTask" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 185}(@{"struct Task" LINK "gg:doc/NDK/Guide/Include/exec/tasks.h/File" 24} *, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49}, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        Add a task to the system.  A reschedule will be run; the task with
        the highest priority in the system will start to execute (this may
        or may not be the new task).

        Certain fields of the task control block must be initialized and a
        stack allocated prior to calling this function.  The absolute
        smallest stack that is allowable is something in the range of 100
        bytes, but in general the stack size is dependent on what
        subsystems are called. In general 256 bytes is sufficient if only
        Exec is called, and 4K will do if anything in the system is called.
        DO @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} UNDERESTIMATE.  If you use a stack sniffing utility,
        leave a healthy pad above the minimum value.  The system guarantees
        that its stack operations will leave the stack longword aligned.

        This function will temporarily use space from the new task's stack
        for the task's initial set of registers.  This space is allocated
        starting at the SPREG location specified in the task control block
        (not from SPUPPER).  This means that a task's stack may contain
        static data put there prior to its execution.  This is useful for
        providing initialized global variables or some tasks may want to
        use this space for passing the task its initial arguments.

        A task's initial registers are set to zero (except the PC).

        The TC_MEMENTRY field of the task structure may be extended by
        the user to hold additional MemLists (as returned by @{"AllocEntry()" LINK "AllocEntry"}).
        These will be automatically be deallocated at @{"RemTask()" LINK "RemTask"} time.
        If the code you have used to start the task has already added
        something to the MEMENTRY list, simply use @{"AddHead" LINK "AddHead"} to add your
        new MemLists in.  If no initialization has been done, a @{"NewList" LINK "gg:doc/NDK/Guide/amiga_lib/NewList"} will
        need to be performed.@{b}

   INPUTS@{ub}
        task  - pointer to the task control block (TCB).  All unset fields
                must be zero.
        initialPC - the initial entry point's address
        finalPC - the finalization code entry point's address.  If zero,
                  the system will use a general finalizer. This pointer is
                  placed on the stack as if it were the outermost return
                  address.@{b}

   RESULTS@{ub}
        For V36, @{"AddTask" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 185} returns either a @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} or the address of the new
        task.  Old code need not check this.@{b}

   WARNING@{ub}
        Tasks are a low-level building block, and are unable to call
        @{"dos.library" LINK "gg:doc/NDK/Guide/dos/MAIN"}, or any system function that might call @{"dos.library" LINK "gg:doc/NDK/Guide/dos/MAIN"}.
        See the AmigaDOS @{"CreateProc()" LINK "gg:doc/NDK/Guide/dos/CreateProc"} for information on Processes.@{b}

   SEE ALSO@{ub}
        @{"RemTask" LINK "RemTask"}, @{"FindTask" LINK "FindTask"}, @{"amiga.lib/CreateTask" LINK "gg:doc/NDK/Guide/amiga_lib/CreateTask"}, dos/@{"CreateProc" LINK "gg:doc/NDK/Guide/dos/CreateProc"},
        @{"amiga.lib/NewList" LINK "gg:doc/NDK/Guide/amiga_lib/NewList"}

@ENDNODE
@NODE "Alert" "exec.library/Alert()"
@{b}

   NAME@{ub}
        Alert -- alert the user of an error@{b}

   SYNOPSIS@{ub}
        Alert(alertNum)
              D7

        void Alert(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        Alerts the user of a serious system problem.  This function will
        bring the system to a grinding halt, and do whatever is necessary
        to present the user with a message stating what happened.
        Interrupts are disabled, and an attempt to post the alert is made.
        If that fails, the system is reset.  When the system comes up
        again, Exec notices the cause of the failure and tries again to
        post the alert.

        If the Alert is a recoverable type, this call MAY return.

        This call may be made at any time, including interrupts.
        (Well, only in interrupts if it is non-recoverable)

        New, for V39:
        The alert now times out based on the value in LastAlert[3]
        This value is transfered accross warm-reboots and thus will let
        you set it once.  The value is the number of frames that need to
        be displayed before the alert is auto-answered.  A value of
        0 will thus make the alert never be displayed.  Note that
        it is recommended that applications *@{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500}* change the value in
        LastAlert[] since the main reason for this is to make
        unattended operation of the Amiga (in production enviroments)
        possible.

        POST-MORTEM DIAGNOSIS
             There are several options for determining the cause of a crash.
             Descriptions of each alert number can be found in the "alerts.h"
             include file.

             A remote terminal can be attached to the Amiga's first built-in
             serial port.  Set the communication parameters to 9600 baud, 8 bits,
             no parity.  Before resetting the machine, the Alert function will
             blink the power LED 10 times.  While the power indicator is flashing,
             pressing DELETE on the remote terminal will invoke the ROM debugger.@{b}

   INPUT@{ub}
        alertNum   - a number indicating the particular alert.  -1 is
                     not a valid input.@{b}

   NOTE@{ub}
        Much more needs to be said about this function and its implications.@{b}

   SEE ALSO@{ub}
        @{"exec/alerts.h" LINK "gg:doc/NDK/Guide/Include/exec/alerts.h/File"}

@ENDNODE
@NODE "AllocAbs" "exec.library/AllocAbs()"
@{b}

   NAME@{ub}
        @{"AllocAbs" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 133} -- allocate at a given location@{b}

   SYNOPSIS@{ub}
        memoryBlock = @{"AllocAbs" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 133}(byteSize, location)
        D0                     D0        A1

        void *@{"AllocAbs" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 133}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        This function attempts to allocate memory at a given absolute
        memory location.  Often this is used by boot-surviving entities
        such as recoverable ram-disks.  If the memory is already being
        used, or if there is not enough memory to satisfy the request,
        @{"AllocAbs" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 133} will return @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.

        This block may not be exactly the same as the requested block
        because of rounding, but if the return value is non-zero, the block
        is guaranteed to contain the requested range.@{b}

   INPUTS@{ub}
        byteSize - the size of the desired block in bytes
                   This number is rounded up to the next larger
                   block size for the actual allocation.
        location - the address where the memory MUST be.@{b}


   RESULT@{ub}
        memoryBlock - a pointer to the newly allocated memory block, or
                      @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if failed.@{b}

   NOTE@{ub}
        If the free list is corrupt, the system will panic with alert
        @{"AN_MemCorrupt" LINK "gg:doc/NDK/Guide/Include/exec/alerts.h/File" 129}, $01000005.

        The 8 bytes past the end of an @{"AllocAbs" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 133} will be changed by Exec
        relinking the next block of memory.  Generally you can't trust
        the first 8 bytes of anything you @{"AllocAbs" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 133}.@{b}

   SEE ALSO@{ub}
        @{"AllocMem" LINK "AllocMem"}, @{"FreeMem" LINK "FreeMem"}

@ENDNODE
@NODE "Allocate" "exec.library/Allocate()"
@{b}

   NAME@{ub}
        Allocate - allocate a block of memory@{b}

   SYNOPSIS@{ub}
        memoryBlock=Allocate(memHeader, byteSize)
        D0                   A0         D0

        void *Allocate(@{"struct MemHeader" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 28} *, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This function is used to allocate blocks of memory from a given
        private free memory pool (as specified by a MemHeader and its
        memory chunk list).  Allocate will return the first free block that
        is greater than or equal to the requested size.

        All blocks, whether free or allocated, will be block aligned;
        hence, all allocation sizes are rounded up to the next block even
        value (e.g. the minimum allocation resolution is currently 8
        bytes.  A request for 8 bytes will use up exactly 8 bytes.  A
        request for 7 bytes will also use up exactly 8 bytes.).

        This function can be used to manage an application's internal data
        memory.  Note that no arbitration of the MemHeader and associated
        free chunk list is done.  You must be the owner before calling
        Allocate.@{b}

   INPUTS@{ub}
        memHeader - points to the local memory list header.
        byteSize - the size of the desired block in bytes.@{b}

   RESULT@{ub}
        memoryBlock - a pointer to the just allocated free block.
               If there are no free regions large enough to satisfy the
               request, return zero.@{b}

   EXAMPLE@{ub}
        #include <@{"exec/types.h" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File"}>
        #include <@{"exec/memory.h" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File"}>
        void *@{"AllocMem()" LINK "AllocMem"};
        #define BLOCKSIZE 4096L /* Or whatever you want */

        void main()
        {
        @{"struct MemHeader" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 28} *mh;
        @{"struct MemChunk" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 20}  *mc;
        @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49}   block1;
        @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49}   block2;

            /* Get the MemHeader needed to keep track of our new block */
            mh = (@{"struct MemHeader" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 28} *)
                 @{"AllocMem" LINK "AllocMem"}((long)sizeof(@{"struct MemHeader" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 28}), @{"MEMF_CLEAR" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 76} );
            if( !mh )
                exit(10);

            /* Get the actual block the above MemHeader will manage */
            mc = (@{"struct MemChunk" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 20} *)@{"AllocMem" LINK "AllocMem"}( BLOCKSIZE, 0L );
            if( !mc )
                {
                @{"FreeMem" LINK "FreeMem"}( mh, (long)sizeof(@{"struct MemHeader" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 28}) ); exit(10);
                }

            mh->mh_Node.ln_Type = @{"NT_MEMORY" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 53};
            mh->mh_Node.ln_Name = "myname";
            mh->mh_First = mc;
            mh->mh_Lower = (@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49}) mc;
            mh->mh_Upper = (@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49}) ( BLOCKSIZE + (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) mc );
            mh->mh_Free  = BLOCKSIZE;

            /* Set up first chunk in the freelist */
            mc->mc_Next  = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};
            mc->mc_Bytes = BLOCKSIZE;

            block1 = (@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49}) Allocate( mh, 20L );
            block2 = (@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49}) Allocate( mh, 314L );
            @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"}("mh=$%lx mc=$%lx\\n",mh,mc);
            @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"}("Block1=$%lx, Block2=$%lx\\n",block1,block2);

            @{"FreeMem" LINK "FreeMem"}( mh, (long)sizeof(@{"struct MemHeader" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 28}) );
            @{"FreeMem" LINK "FreeMem"}( mc, BLOCKSIZE );
        }@{b}

   NOTE@{ub}
        If the free list is corrupt, the system will panic with alert
        @{"AN_MemCorrupt" LINK "gg:doc/NDK/Guide/Include/exec/alerts.h/File" 129}, $01000005.@{b}

   SEE ALSO@{ub}
        @{"Deallocate" LINK "Deallocate"}, @{"exec/memory.h" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File"}

@ENDNODE
@NODE "AllocEntry" "exec.library/AllocEntry()"
@{b}

   NAME@{ub}
        @{"AllocEntry" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 145} -- allocate many regions of memory@{b}

   SYNOPSIS@{ub}
        memList = @{"AllocEntry" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 145}(memList)
        D0                   A0

        @{"struct MemList" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 56} *@{"AllocEntry" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 145}(@{"struct MemList" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 56} *);@{b}

   FUNCTION@{ub}
        This function takes a memList structure and allocates enough memory
        to hold the required memory as well as a MemList structure to keep
        track of it.

        These MemList structures may be linked together in a task control
        block to keep track of the total memory usage of this task. (See
        the description of TC_MEMENTRY under @{"RemTask" LINK "RemTask"}).@{b}

   INPUTS@{ub}
        memList -- A MemList structure filled in with MemEntry structures.@{b}

   RESULTS@{ub}
        memList -- A different MemList filled in with the actual memory
            allocated in the @{"me_Addr" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 50} field, and their sizes in me_Length.
            If enough memory cannot be obtained, then the requirements of
            the allocation that failed is returned and bit 31 is set.

            WARNING: The result is unusual!  Bit 31 indicates failure.@{b}

   EXAMPLES@{ub}
        The user wants five regions of 2, 4, 8, 16, and 32 bytes in size
        with requirements of @{"MEMF_CLEAR" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 76}, @{"MEMF_PUBLIC" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 69}, @{"MEMF_CHIP" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 70}!@{"MEMF_CLEAR" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 76},
        @{"MEMF_CLEAR" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 76}, and @{"MEMF_PUBLIC" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 69}!@{"MEMF_CLEAR" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 76} respectively.  The
        following code fragment would do that:

            MemListDecl:
                DS.B    LN_SIZE             * reserve space for list node
                DC.W    5                   * number of entries
                DC.L    @{"MEMF_CLEAR" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 76}                  * entry #0
                DC.L    2
                DC.L    @{"MEMF_PUBLIC" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 69}                 * entry #1
                DC.L    4
                DC.L    @{"MEMF_CHIP" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 70}!@{"MEMF_CLEAR" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 76}        * entry #2
                DC.L    8
                DC.L    @{"MEMF_CLEAR" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 76}                  * entry #3
                DC.L    16
                DC.L    @{"MEMF_PUBLIC" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 69}!@{"MEMF_CLEAR" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 76}      * entry #4
                DC.L    32

            start:
                LEA.L   MemListDecl(PC),A0
                JSR     _LVOAllocEntry(a6)
                BCLR.L  #31,D0
                BEQ.S   success

                ------- Type of memory that we failed on is in D0@{b}

   BUGS@{ub}
        If any one of the allocations fails, this function fails to back
        out fully.  This is fixed by the "SetPatch" program on V1.3
        Workbench disks.@{b}

   SEE ALSO@{ub}
        @{"exec/memory.h" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File"}

@ENDNODE
@NODE "AllocMem" "exec.library/AllocMem()"
@{b}

   NAME@{ub}
        @{"AllocMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 129} -- allocate memory given certain requirements@{b}

   SYNOPSIS@{ub}
        memoryBlock = @{"AllocMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 129}(byteSize, attributes)
        D0                     D0        D1

        void *@{"AllocMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 129}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This is the memory allocator to be used by system code and
        applications.  It provides a means of specifying that the allocation
        should be made in a memory area accessible to the chips, or
        accessible to shared system code.

        Memory is allocated based on requirements and options.  Any
        "requirement" must be met by a memory allocation, any "option" will
        be applied to the block regardless.  @{"AllocMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 129} will try all memory
        spaces until one is found with the proper requirements and room for
        the memory request.@{b}

   INPUTS@{ub}
        byteSize - the size of the desired block in bytes.  (The operating
                system will automatically round this number to a multiple of
                the system memory chunk size)

        attributes -
            requirements

                If no flags are set, the system will return the best
                available memory block.  For expanded systems, the fast
                memory pool is searched first.

                @{"MEMF_CHIP" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 70}:      If the requested memory will be used by
                                the Amiga custom chips, this flag *must*
                                be set.

                                Only certain parts of memory are reachable
                                by the special chip sets' DMA circuitry.
                                Chip DMA includes screen memory, images that
                                are blitted, audio data, copper lists, sprites
                                and Pre-V36 @{"trackdisk.device" LINK "gg:doc/NDK/Guide/trackdisk/MAIN"} buffers.


                @{"MEMF_FAST" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 71}:      This is non-chip memory.  If no flag is set
                                @{"MEMF_FAST" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 71} is taken as the default.

                                DO @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} SPECIFY @{"MEMF_FAST" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 71} unless you know
                                exactly what you are doing!  If @{"MEMF_FAST" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 71} is
                                set, @{"AllocMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 129}() will fail on machines that
                                only have chip memory!  This flag may not
                                be set when @{"MEMF_CHIP" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 70} is set.


                @{"MEMF_PUBLIC" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 69}:    Memory that must not be mapped, swapped,
                                or otherwise made non-addressable. ALL
                                MEMORY THAT IS REFERENCED VIA INTERRUPTS
                                AND/OR BY OTHER TASKS MUST BE EITHER PUBLIC
                                OR LOCKED INTO MEMORY! This includes both
                                code and data.


                @{"MEMF_LOCAL" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 72}:     This is memory that will not go away
                                after the CPU @{"RESET" LINK "RESET"} instruction.  Normally,
                                autoconfig memory boards become unavailable
                                after @{"RESET" LINK "RESET"} while motherboard memory
                                may still be available.  This memory type
                                is now automatically set in V36.  Pre-V36
                                systems may not have this memory type
                                and @{"AllocMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 129}() will then fail.


                @{"MEMF_24BITDMA" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 73}:  This is memory that is within the address
                                range of 24-bit DMA devices.  (Zorro-II)
                                This is required if you run a Zorro-II
                                DMA device on a machine that has memory
                                beyond the 24-bit addressing limit of
                                Zorro-II.  This memory type
                                is now automatically set in V36.  Pre-V36
                                systems may not have this memory type
                                and @{"AllocMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 129}() will then fail.


                @{"MEMF_KICK" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 74}:      This memory is memory that EXEC was able
                                to access during/before the KickMem and
                                KickTags are processed.  This means that
                                if you wish to use these, you should allocate
                                memory with this flag.  This flag is
                                automaticly set by EXEC in V39.  Pre-V39
                                systems may not have this memory type and
                                @{"AllocMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 129}() will then fail.  Also, *DO @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500}*
                                ever add memory the system with this flag
                                set.  EXEC will set the flag as needed
                                if the memory matches the needs of EXEC.


            options

                @{"MEMF_CLEAR" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 76}:     The memory will be initialized to all
                                zeros.


                @{"MEMF_REVERSE" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 78}:   This allocates memory from the top of
                                the memory pool.  It searches the pools
                                in the same order, such that FAST memory
                                will be found first.  However, the
                                memory will be allocated from the highest
                                address available in the pool.  This
                                option is new as of V36.  Note that this
                                option has a bug in pre-V39 systems.


                @{"MEMF_NO_EXPUNGE" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 81} This will prevent an expunge to happen on
                                a failed memory allocation.  This option is
                                new to V39 and will be ignored in V37.
                                If a memory allocation with this flag
                                set fails, the allocator will not cause
                                any expunge operations.  (See @{"AddMemHandler()" LINK "AddMemHandler"})@{b}


   RESULT@{ub}
        memoryBlock - a pointer to the newly allocated memory block.
                If there are no free memory regions large enough to satisfy
                the request, zero will be returned.  The pointer must be
                checked for zero before the memory block may be used!
                The memory block returned is long word aligned.@{b}

   WARNING@{ub}
        The result of any memory allocation MUST be checked, and a viable
        error handling path taken.  ANY allocation may fail if memory has
        been filled.@{b}

   EXAMPLES@{ub}
        @{"AllocMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 129}(64,0L)         - Allocate the best available memory
        @{"AllocMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 129}(25,@{"MEMF_CLEAR" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 76}) - Allocate the best available memory, and
                                  clear it before returning.
        @{"AllocMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 129}(128,@{"MEMF_CHIP" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 70}) - Allocate chip memory
        @{"AllocMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 129}(128,@{"MEMF_CHIP" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 70}|@{"MEMF_CLEAR" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 76}) - Allocate cleared chip memory
        @{"AllocMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 129}(821,@{"MEMF_CHIP" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 70}|@{"MEMF_PUBLIC" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 69}|@{"MEMF_CLEAR" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 76}) - Allocate cleared,
                public, chip memory.@{b}

   NOTE@{ub}
        If the free list is corrupt, the system will panic with alert
        @{"AN_MemCorrupt" LINK "gg:doc/NDK/Guide/Include/exec/alerts.h/File" 129}, $01000005.

        This function may not be called from interrupts.

        A DOS process will have its pr_Result2 field set to
        @{"ERROR_NO_FREE_STORE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 181} if the memory allocation fails.@{b}

   SEE ALSO@{ub}
        @{"FreeMem" LINK "FreeMem"}

@ENDNODE
@NODE "AllocPooled" "exec.library/AllocPooled()"
@{b}

    NAME@{ub}
        @{"AllocPooled" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 457} -- Allocate memory with the pool manager (V39)@{b}

    SYNOPSIS@{ub}
        memory=@{"AllocPooled" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 457}(poolHeader,memSize)
        d0                 a0         d0

        void *@{"AllocPooled" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 457}(void *,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

    FUNCTION@{ub}
        Allocate memSize bytes of memory, and return a pointer. @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} is
        returned if the allocation fails.

        Doing a @{"DeletePool()" LINK "DeletePool"} on the pool will free all of the puddles
        and thus all of the allocations done with @{"AllocPooled" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 457}() in that
        pool.  (No need to @{"FreePooled()" LINK "FreePooled"} each allocation)@{b}

    INPUTS@{ub}
        memSize - the number of bytes to allocate
        poolHeader - a specific private pool header.@{b}

    RESULT@{ub}
        A pointer to the memory, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.
        The memory block returned is long word aligned.@{b}

    NOTES@{ub}
        The pool function do not protect an individual pool from
        multiple accesses.  The reason is that in most cases the pools
        will be used by a single task.  If your pool is going to
        be used by more than one task you must Semaphore protect
        the pool from having more than one task trying to allocate
        within the same pool at the same time.  Warning:  @{"Forbid()" LINK "Forbid"}
        protection *will not work* in the future.  *Do @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500}* assume
        that we will be able to make it work in the future.  @{"AllocPooled" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 457}()
        may well break a @{"Forbid()" LINK "Forbid"} and as such can only be protected
        by a semaphore.

        To track sizes yourself, the following code can be used:
        Assumes a6=ExecBase

        ;
        ; Function to do AllocVecPooled(Pool,memSize)
        ;
        AllocVecPooled: addq.l  #4,d0           ; Get space for tracking
                        move.l  d0,-(sp)        ; Save the size
                        jsr     _LVOAllocPooled(a6)     ; Call pool...
                        move.l  (sp)+,d1        ; Get size back...
                        tst.l   d0              ; Check for error
                        beq.s   avp_fail        ; If @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, failed!
                        move.l  d0,a0           ; Get pointer...
                        move.l  d1,(a0)+        ; Store size
                        move.l  a0,d0           ; Get result
        avp_fail:       rts                     ; return

        ;
        ; Function to do FreeVecPooled(pool,memory)
        ;
        FreeVecPooled:  move.l  -(a1),d0        ; Get size / ajust pointer
                        jmp     _LVOFreePooled(a6)@{b}

    SEE ALSO@{ub}
        @{"FreePooled()" LINK "FreePooled"}, @{"CreatePool()" LINK "CreatePool"}, @{"DeletePool()" LINK "DeletePool"}

@ENDNODE
@NODE "AllocSignal" "exec.library/AllocSignal()"
@{b}

   NAME@{ub}
        @{"AllocSignal" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 217} -- allocate a signal bit@{b}

   SYNOPSIS@{ub}
        signalNum = @{"AllocSignal" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 217}(signalNum)
        D0                      D0

        @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} @{"AllocSignal" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 217}(@{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58});@{b}

   FUNCTION@{ub}
        Allocate a signal bit from the current tasks' pool.  Either a
        particular bit, or the next free bit may be allocated.  The signal
        associated with the bit will be properly initialized (cleared).  At
        least 16 user signals are available per task.  Signals should be
        deallocated before the task exits.

        If the signal is already in use (or no free signals are available)
        a -1 is returned.

        Allocated signals are only valid for use with the task that
        allocated them.@{b}


   WARNING@{ub}
        Signals may not be allocated or freed from exception handling code.@{b}

   INPUTS@{ub}
        signalNum - the desired signal number {of 0..31} or -1 for no
                    preference.@{b}

   RESULTS@{ub}
        signalNum - the signal bit number allocated {0..31}. If no signals
                    are available, this function returns -1.@{b}

   SEE ALSO@{ub}
        @{"FreeSignal" LINK "FreeSignal"}

@ENDNODE
@NODE "AllocTrap" "exec.library/AllocTrap()"
@{b}

   NAME@{ub}
        @{"AllocTrap" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 225} -- allocate a processor trap vector@{b}

   SYNOPSIS@{ub}
        trapNum = @{"AllocTrap" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 225}(trapNum)
        D0                  D0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"AllocTrap" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 225}(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Allocate a trap number from the current task's pool.  These trap
        numbers are those associated with the 68000 TRAP type instructions.
        Either a particular number, or the next free number may be
        allocated.

        If the trap is already in use (or no free traps are available) a -1
        is returned.

        This function only affects the currently running task.

        Traps are sent to the trap handler pointed at by tc_TrapCode.
        Unless changed by user code, this points to a standard trap
        handler.  The stack frame of the exception handler will be:

                0(SP) = Exception vector number.  This will be in the
                        range of 32 to 47 (corresponding to the
                        Trap #1...Trap #15 instructions).
                4(SP) = 68000/68010/68020/68030, etc. exception frame

        tc_TrapData is not used.@{b}


   WARNING@{ub}
        Traps may not be allocated or freed from exception handling code.
        You are not allowed to write to the exception table yourself.  In
        fact, on some machines you will have trouble finding it - the VBR
        register may be used to remap its location.@{b}

   INPUTS@{ub}
        trapNum - the desired trap number {of 0..15} or -1
                  for no preference.@{b}

   RESULTS@{ub}
        trapNum - the trap number allocated {of 0..15}.  If no traps are
                  available, this function returns -1.  Instructions of the
                  form "Trap #trapNum" will be sent to the task's trap
                  handler.@{b}

   SEE ALSO@{ub}
        @{"FreeTrap" LINK "FreeTrap"}

@ENDNODE
@NODE "AllocVec" "exec.library/AllocVec()"
@{b}

   NAME@{ub}
        @{"AllocVec" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 441} -- allocate memory and keep track of the size  (V36)@{b}

   SYNOPSIS@{ub}
        memoryBlock = @{"AllocVec" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 441}(byteSize, attributes)
        D0                     D0        D1

        void *@{"AllocVec" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 441}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This function works identically to @{"AllocMem()" LINK "AllocMem"}, but tracks the size
        of the allocation.

        See the @{"AllocMem()" LINK "AllocMem"} documentation for details.@{b}

   WARNING@{ub}
        The result of any memory allocation MUST be checked, and a viable
        error handling path taken.  ANY allocation may fail if memory has
        been filled.@{b}

   SEE ALSO@{ub}
        @{"FreeVec" LINK "FreeVec"}, @{"AllocMem" LINK "AllocMem"}

@ENDNODE
@NODE "AttemptSemaphore" "exec.library/AttemptSemaphore()"
@{b}

   NAME@{ub}
        @{"AttemptSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 369} -- try to obtain without blocking@{b}

   SYNOPSIS@{ub}
        success = @{"AttemptSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 369}(signalSemaphore)
        D0                         A0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"AttemptSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 369}(@{"struct SignalSemaphore" LINK "gg:doc/NDK/Guide/Include/exec/semaphores.h/File" 40} *);@{b}

   FUNCTION@{ub}
        This call is similar to @{"ObtainSemaphore()" LINK "ObtainSemaphore"}, except that it will not
        block if the semaphore could not be locked.@{b}

   INPUT@{ub}
       signalSemaphore -- an initialized signal semaphore structure@{b}

   RESULT@{ub}
        success -- @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if the semaphore was locked, false if some
            other task already possessed the semaphore.@{b}

    NOTE@{ub}
        This call does @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} preserve registers.@{b}

   SEE ALSO@{ub}
        @{"ObtainSemaphore()" LINK "ObtainSemaphore"} @{"ObtainSemaphoreShared()" LINK "ObtainSemaphoreShared"}, @{"ReleaseSemaphore()" LINK "ReleaseSemaphore"},
        @{"exec/semaphores.h" LINK "gg:doc/NDK/Guide/Include/exec/semaphores.h/File"}

@ENDNODE
@NODE "AttemptSemaphoreShared" "exec.library/AttemptSemaphoreShared()"
@{b}

   NAME@{ub}
        @{"AttemptSemaphoreShared" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 465} -- try to obtain without blocking       (V37)@{b}

   SYNOPSIS@{ub}
        success = @{"AttemptSemaphoreShared" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 465}(signalSemaphore)
        D0                               A0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"AttemptSemaphoreShared" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 465}(@{"struct SignalSemaphore" LINK "gg:doc/NDK/Guide/Include/exec/semaphores.h/File" 40} *);@{b}

   FUNCTION@{ub}
        This call is similar to @{"ObtainSemaphoreShared()" LINK "ObtainSemaphoreShared"}, except that it
        will not block if the semaphore could not be locked.@{b}

   INPUT@{ub}
       signalSemaphore -- an initialized signal semaphore structure@{b}

   RESULT@{ub}
        success -- @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if the semaphore was granted, false if some
            other task already possessed the semaphore in exclusive mode.@{b}

   NOTE@{ub}
        This call does @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} preserve registers.

        Starting in V39 this call will grant the semaphore if the
        caller is already the owner of an exclusive lock on the semaphore.
        In pre-V39 systems this would not be the case.  If you need this
        feature you can do the following workaround:

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} myAttemptSempahoreShared(@{"struct SignalSemaphore" LINK "gg:doc/NDK/Guide/Include/exec/semaphores.h/File" 40} *ss)
        {
        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} result;

                /* Try for a shared semaphore */
                if (!(result=@{"AttemptSemaphoreShared" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 465}(ss)))
                {
                        /* Now try for the exclusive one... */
                        result=AttempSemaphore(ss);
                }
                return(result);
        }@{b}

   SEE ALSO@{ub}
        @{"ObtainSemaphore()" LINK "ObtainSemaphore"} @{"ObtainSemaphoreShared()" LINK "ObtainSemaphoreShared"}, @{"ReleaseSemaphore()" LINK "ReleaseSemaphore"},
        @{"exec/semaphores.h" LINK "gg:doc/NDK/Guide/Include/exec/semaphores.h/File"}

@ENDNODE
@NODE "AvailMem" "exec.library/AvailMem()"
@{b}

   NAME@{ub}
        @{"AvailMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 141} -- memory available given certain requirements@{b}

   SYNOPSIS@{ub}
        size = @{"AvailMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 141}(attributes)
        D0              D1

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"AvailMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 141}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This function returns the amount of free memory given certain
        attributes.

        To find out what the largest block of a particular type is, add
        @{"MEMF_LARGEST" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 77} into the requirements argument.  Returning the largest
        block is a slow operation.@{b}

   WARNING@{ub}
        Due to the effect of multitasking, the value returned may not
        actually be the amount of free memory available at that instant.@{b}

   INPUTS@{ub}
        requirements - a requirements mask as specified in @{"AllocMem" LINK "AllocMem"}.  Any
                       of the @{"AllocMem" LINK "AllocMem"} bits are valid, as is @{"MEMF_LARGEST" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 77}
                       which returns the size of the largest block matching
                       the requirements.@{b}

   RESULT@{ub}
        size - total free space remaining (or the largest free block).@{b}

   NOTE@{ub}
        For V36 Exec, @{"AvailMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 141}(@{"MEMF_LARGEST" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 77}) does a consistency check on
        the memory list.  Alert @{"AN_MemoryInsane" LINK "gg:doc/NDK/Guide/Include/exec/alerts.h/File" 137} will be pulled if any mismatch
        is noted.@{b}

   EXAMPLE@{ub}
        @{"AvailMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 141}(@{"MEMF_CHIP" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 70}|@{"MEMF_LARGEST" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 77});
        /* return size of largest available chip memory chunk */@{b}

   SEE ALSO@{ub}
        @{"exec/memory.h" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File"}

@ENDNODE
@NODE "AVL_AddNode" "exec.library/AVL_AddNode()"
@{b}

    NAME@{ub}
       @{"AVL_AddNode" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 501} -- Add node to the tree (V45)@{b}

    SYNOPSIS@{ub}
       result = @{"AVL_AddNode" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 501}( root, node, func )
       D0                     A0    A1    A2

       @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *@{"AVL_FindNextNodeByKey" LINK "AVL_FindNextNodeByKey"}(@{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} **,
                                             @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *,
                                             @{"AVLNODECOMP" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 36});@{b}

    FUNCTION@{ub}
       The function will add the given node to the AVL tree in the correct
       position. The correct position is determined by the compare function
       which is also passed in and which defines relative value of nodes
       by determining their "key" values and comparing them.
       Note that the compare function works like strcmp() by returning
       <0, 0, >0 results to define a less/equal/greater relationship.
       Note that there is no arbitration for access to the tree. You
       should use a SignalSemaphore if arbitration is required.@{b}

    INPUTS@{ub}
       root  - Address of(!) the root pointer(!) of the AVL tree.
               Initially, the root pointer must be set to @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, which
               represents an empty AVL tree.
       node  - The node to add
       func  - The compare function to find the right position for
               the node in the tree@{b}

    RESULT@{ub}
       If the node could be added, @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} is returned.
       If there is already a node in the tree that has the same key, the
       pointer to that node be returned and the given node will not be
       added.@{b}

    NOTES@{ub}
       There are a few things to remember about AVL trees. First, they
       are binary balanced trees. You can expect O(log2(n)) performance
       for adding, removing, and searching by key.

       Second, the implementation does not care what kind of compare
       functions you provide to the AVL functions, i.e., what sort order
       you define.

       To work with an AVL tree you need two compare functions:
           @{"AVLNODECOMP" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 36} - Determines keys of two nodes and compares them
           @{"AVLKEYCOMP" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 37}  - Compares a node's key to a given key

       The interpretation of the keys in these two functions must match.
       If your compare functions are flawed, the AVL trees will not work.

       The implementation does not compare keys or makes any assumption
       about them. A key can be anything that fits into a 32 bit value,
       even a pointer to the "true" key, whatever it may be.

       Remember that each key in a tree must be unique. If you
       want to add elements with identical keys, you could use, e.g.,
       the memory address of the element as "second level" key to ensure
       unique keys for insertion into the tree. In that case, however,
       it is obviously not possible to retrieve the node by a single key.

       Also, remember that a @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} can be embedded anywhere
       within your element's structure.

       The example below illustrates all the points made above. If you
       don't need second level keys or embedded @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20}'s, you
       can simplify things.

       Finally, the implementation is not recursive and you don't have
       to provide a huge stack even when using AVL functions on
       huge trees.@{b}

    EXAMPLE@{ub}

       struct Element
       {
           @{"struct Node" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 22}     el_Node;    /* Normal maintenance */
           @{"UWORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 55}           el_pad;
           @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}           el_SortKey; /* Bringing order into things ... */
           @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20}  el_AVLNode; /* Fast access */
           @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}           el_Content; /* Magic private content */
       };

       ...

       @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} ASM AVLNodeComp(REG(a0) @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *avlnode1,
                            REG(a1) @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *@{"avlnode2" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 33})
       {
           struct Element *el1, *el2;
           @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} res;

           el1 = ElementStart(avlnode1);
           el2 = ElementStart(@{"avlnode2" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 33});

           res = (@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})(el1->el_SortKey - el2->el_SortKey);
           if(res == 0)
           {
               // For identical keys, use, e.g., the address as 2nd key
               res = (@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})((@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})avlnode1 - (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{"avlnode2" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 33});
           } /* if */

           return(res);

       } /* AVLNodeComp */

       static @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} ASM AVLKeyComp(REG(a0) @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *avlnode,
                                  REG(a1) @{"AVLKey" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 26} avlkey)
       {
           struct Element *el;
           @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} res;

           el = ElementStart(avlnode);

           res = (@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})(el->el_SortKey - (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})avlkey);

           return(res);

       } /* AVLKeyComp */

       ...

           /* Initially, the tree must be marked as empty! */
           avlroot = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};

           ...

           if(@{"AVL_AddNode" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 501}(&avlroot, &el->el_AVLNode, AVLNodeComp))
           {
               // This should not happen because our AVLNodeComp()
               // ensures that each node's key is unique by using its address .
               // If it happens it means that we are trying to readd a
               // node that already has been added in this case.
           } /* if */@{b}


    BUGS@{ub}@{b}

    SEE ALSO@{ub}
       @{"AVL_FindLastNode()" LINK "AVL_FindLastNode"}, @{"AVL_FindFirstNode()" LINK "AVL_FindFirstNode"}, @{"AVL_RemNodeByKey()" LINK "AVL_RemNodeByKey"},
       @{"AVL_RemNodeByAddress()" LINK "AVL_RemNodeByAddress"}, @{"AVL_FindNextNodeByKey()" LINK "AVL_FindNextNodeByKey"},
       @{"AVL_FindNextNodeByAddress()" LINK "AVL_FindNextNodeByAddress"}

@ENDNODE
@NODE "AVL_FindFirstNode" "exec.library/AVL_FindFirstNode()"
@{b}

    NAME@{ub}
       @{"AVL_FindFirstNode" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 533} -- return the lowest/smallest node (V45)@{b}

    SYNOPSIS@{ub}
       result = @{"AVL_FindFirstNode" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 533}( root )
       D0                           A0

       @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *LIB_AVL_FindFirstNode(const @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *root)@{b}


    FUNCTION@{ub}
       This functions will return the pointer to the first node in
       the given AVL tree. Using this function, you can start to
       walk the tree in a "linear" fashion.@{b}

    INPUTS@{ub}
       root  - The pointer to the root of the AVL tree@{b}

    RESULT@{ub}
       A pointer to the smallest/lowest node in the tree or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
       for an empty tree.@{b}

    NOTES@{ub}@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
       @{"AVL_FindNextNodeByAddress()" LINK "AVL_FindNextNodeByAddress"}, @{"AVL_RemNodeByAddress()" LINK "AVL_RemNodeByAddress"}

@ENDNODE
@NODE "AVL_FindLastNode" "exec.library/AVL_FindLastNode()"
@{b}

    NAME@{ub}
       @{"AVL_FindLastNode" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 537} -- return the highest/biggest node (V45)@{b}

    SYNOPSIS@{ub}
       result = @{"AVL_FindLastNode" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 537}( root )
       D0                          A0

       @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *LIB_AVL_FindLastNode(const @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *root)@{b}


    FUNCTION@{ub}
       This functions will return the pointer to the last node in
       the given AVL tree. Using this function, you can start to
       walk the tree in a "linear" fashion.@{b}

    INPUTS@{ub}
       root  - The pointer to the root of the AVL tree@{b}

    RESULT@{ub}
       A pointer to the highest/biggest node in the tree or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
       for an empty tree.@{b}

    NOTES@{ub}@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
       @{"AVL_FindPrevNodeByAddress()" LINK "AVL_FindPrevNodeByAddress"}, @{"AVL_RemNodeByAddress()" LINK "AVL_RemNodeByAddress"}

@ENDNODE
@NODE "AVL_FindNextNodeByAddress" "exec.library/AVL_FindNextNodeByAddress()"
@{b}

    NAME@{ub}
       @{"AVL_FindNextNodeByAddress" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 525} -- Return the next node of a tree (V45)@{b}

    SYNOPSIS@{ub}
       result = @{"AVL_FindNextNodeByAddress" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 525}( node )
       D0                                   A0

       @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *@{"AVL_FindNextNodeByAddress" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 525}(const @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *node)@{b}

    FUNCTION@{ub}
       Given the pointer to a @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20}, this function will return
       the logically next/higher/bigger entry in the tree
       Using this function, you can start to walk the tree in a "linear"
       fashion.@{b}

    INPUTS@{ub}
       node  - pointer to the current AVLNode@{b}

    RESULT@{ub}
       A pointer to the logically next AVLNode or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if there is none.@{b}

    NOTES@{ub}
       The node passed in *better*be* part of the tree or you
       lose big time!@{b}

    EXAMPLE@{ub}

       avlnode = @{"AVL_FindFirstNode" LINK "AVL_FindFirstNode"}(avlroot);
       while(avlnode)
       {
           nextavlnode = @{"AVL_FindNextNodeByAddress" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 525}(avlnode);

           /* look at, or remove avlnode */

           /* walk the tree */
           avlnode = nextavlnode;
       } /* while */@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
       @{"AVL_FindFirstNode()" LINK "AVL_FindFirstNode"}, @{"AVL_RemNodeByAddress()" LINK "AVL_RemNodeByAddress"}

@ENDNODE
@NODE "AVL_FindNextNodeByKey" "exec.library/AVL_FindNextNodeByKey()"
@{b}

    NAME@{ub}
       @{"AVL_FindNextNodeByKey" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 529} -- Find node identified by a key (V45)@{b}

    SYNOPSIS@{ub}
       result = @{"AVL_FindNextNodeByKey" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 529}( root, key, func )
       D0                               A0   A1    A2

       @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *@{"AVL_FindNextNodeByKey" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 529}(const @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *,
                                             @{"AVLKey" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 26},
                                             @{"AVLKEYCOMP" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 37});@{b}

    FUNCTION@{ub}
       The function will search for a node or the next higher node
       based on the key given and return a pointer to it.
       Note that the compare function works like strcmp() by returning
       <0, 0, >0 results to define a less/equal/greater relationship.@{b}

    INPUTS@{ub}
       root  - pointer to the root of the AVL tree
       key   - An abstract key to match a node by the given compare function
       func  - The compare function to check if a @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} matches the
               given key@{b}

    RESULT@{ub}
       A pointer to the node with the given key or the next higher node
       if no exact match was found.@{b}

    NOTES@{ub}@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
       @{"AVL_FindLastNode()" LINK "AVL_FindLastNode"}, @{"AVL_FindFirstNode()" LINK "AVL_FindFirstNode"}, @{"AVL_AddNode()" LINK "AVL_AddNode"},
       @{"AVL_RemNodeByAddress()" LINK "AVL_RemNodeByAddress"}, @{"AVL_FindNextNodeByAddress()" LINK "AVL_FindNextNodeByAddress"}

@ENDNODE
@NODE "AVL_FindNode" "exec.library/AVL_FindNode()"
@{b}

    NAME@{ub}
       @{"AVL_FindNode" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 513} -- Find a node identified by its key (V45)@{b}

    SYNOPSIS@{ub}
       result = @{"AVL_FindNode" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 513}( root, key, func )
       D0                      A0   A1    A2

       @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *@{"AVL_FindNode" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 513}(const @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *,
                                    @{"AVLKey" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 26},
                                    @{"AVLKEYCOMP" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 37});@{b}

    FUNCTION@{ub}
       The function will search for the node with the given key and
       return a pointer to it.
       Note that the compare function works like strcmp() by returning
       <0, 0, >0 results to define a less/equal/greater relationship.@{b}

    INPUTS@{ub}
       root  - pointer to the root of the AVL tree
       key   - An abstract key to match a node by the given compare function
       func  - The compare function to check if a @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} matches the
               given key@{b}

    RESULT@{ub}
       A pointer to the node or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if the node could not be found.@{b}

    NOTES@{ub}@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
       @{"AVL_FindLastNode()" LINK "AVL_FindLastNode"}, @{"AVL_FindFirstNode()" LINK "AVL_FindFirstNode"}, @{"AVL_AddNode()" LINK "AVL_AddNode"},
       @{"AVL_RemNodeByAddress()" LINK "AVL_RemNodeByAddress"}

@ENDNODE
@NODE "AVL_FindPrevNodeByAddress" "exec.library/AVL_FindPrevNodeByAddress()"
@{b}

    NAME@{ub}
       @{"AVL_FindPrevNodeByAddress" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 517} -- Return previous node of a tree (V45)@{b}

    SYNOPSIS@{ub}
       result = @{"AVL_FindPrevNodeByAddress" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 517}( node )
       D0                                   A0

       @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *@{"AVL_FindPrevNodeByAddress" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 517}(const @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *node)@{b}

    FUNCTION@{ub}
       Given the pointer to a @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20}, this function will return
       the logically previous/lower/smaller entry in the tree
       Using this function, you can start to walk the tree in a "linear"
       fashion.@{b}

    INPUTS@{ub}
       node  - pointer to the current AVLNode@{b}

    RESULT@{ub}
       A pointer to the logically previous AVLNode or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if there is none.@{b}

    NOTES@{ub}
       The node passed in *better*be* part of the tree or you
       lose big time!@{b}

    EXAMPLE@{ub}

       avlnode = @{"AVL_FindLastNode" LINK "AVL_FindLastNode"}(avlroot);
       while(avlnode)
       {
           prevavlnode = @{"AVL_FindPrevNodeByAddress" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 517}(avlnode);

           /* look at, or remove avlnode */

           /* walk the tree */
           avlnode = prevavlnode;
       } /* while */@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
       @{"AVL_FindLastNode()" LINK "AVL_FindLastNode"}, @{"AVL_RemNodeByAddress()" LINK "AVL_RemNodeByAddress"}

@ENDNODE
@NODE "AVL_FindPrevNodeByKey" "exec.library/AVL_FindPrevNodeByKey()"
@{b}

    NAME@{ub}
       @{"AVL_FindPrevNodeByKey" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 521} -- Find node identified by a key (V45)@{b}

    SYNOPSIS@{ub}
       result = @{"AVL_FindPrevNodeByKey" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 521}( root, key, func )
       D0                               A0   A1    A2

       @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *@{"AVL_FindPrevNodeByKey" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 521}(const @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *,
                                             @{"AVLKey" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 26},
                                             @{"AVLKEYCOMP" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 37});@{b}

    FUNCTION@{ub}
       The function will search for a node or the next lower node
       based on the key given and return a pointer to it.
       Note that the compare function works like strcmp() by returning
       <0, 0, >0 results to define a less/equal/greater relationship.@{b}

    INPUTS@{ub}
       root  - pointer to the root of the AVL tree
       key   - An abstract key to match a node by the given compare function
       func  - The compare function to check if a @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} matches the
               given key@{b}

    RESULT@{ub}
       A pointer to the node with the given key or the next lower node
       if no exact match was found.@{b}

    NOTES@{ub}@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
       @{"AVL_FindLastNode()" LINK "AVL_FindLastNode"}, @{"AVL_FindFirstNode()" LINK "AVL_FindFirstNode"}, @{"AVL_AddNode()" LINK "AVL_AddNode"},
       @{"AVL_RemNodeByAddress()" LINK "AVL_RemNodeByAddress"}, @{"AVL_FindPrevNodeByAddress()" LINK "AVL_FindPrevNodeByAddress"}

@ENDNODE
@NODE "AVL_RemNodeByAddress" "exec.library/AVL_RemNodeByAddress()"
@{b}

    NAME@{ub}
       @{"AVL_RemNodeByAddress" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 505} - Remove a given node (V45)@{b}

    SYNOPSIS@{ub}
       result = @{"AVL_RemNodeByAddress" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 505}( root, node )
       D0                              A0   A1

       @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *@{"AVL_RemNodeByAddress" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 505}(@{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} **,
                                            @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *);@{b}

    FUNCTION@{ub}
       The function will remove the given node from the tree.
       Note that there is no arbitration for access to the tree. You
       should use a SignalSemaphore if arbitration is required.@{b}

    INPUTS@{ub}
       root  - Address of(!) the root pointer(!) of the AVL tree
       node  - pointer to the @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} that should be removed@{b}

    RESULT@{ub}
       A pointer to the removed node.@{b}

    NOTES@{ub}
       The node to be removed *better*be* part of the tree or you
       lose big time!@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
       @{"AVL_FindLastNode()" LINK "AVL_FindLastNode"}, @{"AVL_FindNode()" LINK "AVL_FindNode"}, @{"AVL_FindFirstNode()" LINK "AVL_FindFirstNode"},
       @{"AVL_RemNodeByAddress" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 505}(), @{"AVL_AddNode()" LINK "AVL_AddNode"}

@ENDNODE
@NODE "AVL_RemNodeByKey" "exec.library/AVL_RemNodeByKey()"
@{b}

    NAME@{ub}
       @{"AVL_RemNodeByKey" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 509} -- Remove a node identified by its key (V45)@{b}

    SYNOPSIS@{ub}
       result = @{"AVL_RemNodeByKey" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 509}( root, key, func )
       D0                          A0   A1    A2

       @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} *@{"AVL_RemNodeByKey" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 509}(@{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} **,
                                        @{"AVLKey" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 26},
                                        @{"AVLKEYCOMP" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 37});@{b}

    FUNCTION@{ub}
       The function will search for the node with the given key and
       remove it from the tree.
       Note that there is no arbitration for access to the tree. You
       should use a SignalSemaphore if arbitration is required.@{b}

    INPUTS@{ub}
       root  - Address of(!) the root pointer(!) of the AVL tree
       key   - An abstract key to match a node by the given compare function
       func  - The compare function to check if a @{"struct AVLNode" LINK "gg:doc/NDK/Guide/Include/exec/avl.h/File" 20} matches the
               given key@{b}

    RESULT@{ub}
       A pointer to the removed node or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if the node could not be found.@{b}

    NOTES@{ub}@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
       @{"AVL_FindLastNode()" LINK "AVL_FindLastNode"}, @{"AVL_FindNode()" LINK "AVL_FindNode"}, @{"AVL_FindFirstNode()" LINK "AVL_FindFirstNode"},
       @{"AVL_RemNodeByAddress()" LINK "AVL_RemNodeByAddress"}, @{"AVL_AddNode()" LINK "AVL_AddNode"}

@ENDNODE
@NODE "CacheClearE" "exec.library/CacheClearE()"
@{b}

   NAME@{ub}
        @{"CacheClearE" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 413} - Cache clearing with extended control (V37)@{b}

   SYNOPSIS@{ub}
        @{"CacheClearE" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 413}(address,length,caches)
                    a0      d0     d1

        void @{"CacheClearE" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 413}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        Flush out the contents of the CPU instruction and/or data caches.
        If dirty data cache lines are present, push them to memory first.

        Motorola CPUs have separate instruction and data caches.  A data
        write does not update the instruction cache.  If an instruction is
        written to memory or modified, the old instruction may still exist
        in the cache.  Before attempting to execute the code, a flush of
        the instruction cache is required.

        For most systems, the data cache is not updated by Direct Memory
        Access (DMA), or if some external factor changes shared memory.

        Caches must be cleared after *any* operation that could cause
        invalid or stale data.  The most common cases are DMA and modifying
        instructions using the processor.

        Some examples:
                        Self modifying code
                        Building Jump tables
                        Run-time code patches
                        Relocating code for use at different addresses.
                        Loading code from disk@{b}

   INPUTS@{ub}
        address - Address to start the operation.  This may be rounded
                  due to hardware granularity.
        length  - Length of area to be cleared, or $FFFFFFFF to indicate all
                  addresses should be cleared.
        caches  - Bit flags to indicate what caches to affect.  The current
                  supported flags are:
                        @{"CACRF_ClearI" LINK "gg:doc/NDK/Guide/Include/exec/execbase.h/File" 195}    ;Clear instruction cache
                        @{"CACRF_ClearD" LINK "gg:doc/NDK/Guide/Include/exec/execbase.h/File" 199}    ;Clear data cache
                  All other bits are reserved for future definition.@{b}

   NOTES@{ub}
        On systems with a copyback mode cache, any dirty data is pushed
        to memory as a part of this operation.

        Regardless of the length given, the function will determine the most
        efficient way to implement the operation.  For some cache systems,
        including the 68030, the overhead partially clearing a cache is often
        too great.  The entire cache may be cleared.

        For all current Amiga models, Chip memory is set with Instruction
        caching enabled, data caching disabled.  This prevents coherency
        conflicts with the blitter or other custom chip DMA.  Custom chip
        registers are marked as non-cacheable by the hardware.

        The system takes care of appropriately flushing the caches for normal
        operations.  The instruction cache is cleared by all calls that
        modify instructions, including @{"LoadSeg()" LINK "gg:doc/NDK/Guide/dos/LoadSeg"}, @{"MakeLibrary()" LINK "MakeLibrary"} and
        @{"SetFunction()" LINK "SetFunction"}.@{b}

   SEE ALSO@{ub}
        exec/execbase.i, @{"CacheControl" LINK "CacheControl"}, @{"CacheClearU" LINK "CacheClearU"}

@ENDNODE
@NODE "CacheClearU" "exec.library/CacheClearU()"
@{b}

   NAME@{ub}
        @{"CacheClearU" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 409} - User callable simple cache clearing (V37)@{b}

   SYNOPSIS@{ub}
        @{"CacheClearU" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 409}()

        void @{"CacheClearU" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 409}(void);@{b}

   FUNCTION@{ub}
        Flush out the contents of any CPU instruction and data caches.
        If dirty data cache lines are present, push them to memory first.

        Caches must be cleared after *any* operation that could cause
        invalid or stale data.  The most common cases are DMA and modifying
        instructions using the processor.  See the @{"CacheClearE()" LINK "CacheClearE"} autodoc
        for a more complete description.

        Some examples of when the cache needs clearing:
                        Self modifying code
                        Building Jump tables
                        Run-time code patches
                        Relocating code for use at different addresses.
                        Loading code from disk@{b}

   SEE ALSO@{ub}
        exec/execbase.i, @{"CacheControl" LINK "CacheControl"}, @{"CacheClearE" LINK "CacheClearE"}

@ENDNODE
@NODE "CacheControl" "exec.library/CacheControl()"
@{b}

   NAME@{ub}
        @{"CacheControl" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 417} - Instruction & data cache control@{b}

   SYNOPSIS@{ub}
        oldBits = @{"CacheControl" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 417}(cacheBits,cacheMask)
        D0                     D0        D1

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"CacheControl" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 417}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This function provides global control of any instruction or data
        caches that may be connected to the system.  All settings are
        global -- per task control is not provided.

        The action taken by this function will depend on the type of
        CPU installed.  This function may be patched to support external
        caches, or different cache architectures.  In all cases the function
        will attempt to best emulate the provided settings.  Use of this
        function may save state specific to the caches involved.

        The list of supported settings is provided in the exec/execbase.i
        include file.  The bits currently defined map directly to the Motorola
        68030 CPU CACR register.  Alternate cache solutions may patch into
        the Exec cache functions.  Where possible, bits will be interpreted to
        have the same meaning on the installed cache.@{b}

   INPUTS@{ub}
        cacheBits - new values for the bits specified in cacheMask.

        cacheMask - a mask with ones for all bits to be changed.@{b}

   RESULT@{ub}
        oldBits   - the complete prior values for all settings.@{b}

   NOTE@{ub}
        As a side effect, this function clears all caches.@{b}

   SEE ALSO@{ub}
        exec/execbase.i, @{"CacheClearU" LINK "CacheClearU"}, @{"CacheClearE" LINK "CacheClearE"}

@ENDNODE
@NODE "CachePostDMA" "exec.library/CachePostDMA()"
@{b}

   NAME@{ub}
        @{"CachePostDMA" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 481} - Take actions after to hardware DMA  (V37)@{b}

   SYNOPSIS@{ub}
        @{"CachePostDMA" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 481}(vaddress,&length,flags)
                     a0       a1      d0

        @{"CachePostDMA" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 481}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} *,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        Take all appropriate steps after Direct Memory Access (DMA).  This
        function is primarily intended for writers of DMA device drivers.  The
        action will depend on the CPU type installed, caching modes, and the
        state of any Memory Management Unit (MMU) activity.

        As implemented
                68000 - Do nothing
                68010 - Do nothing
                68020 - Do nothing
                68030 - Flush the data cache
                68040 - Flush matching areas of the data cache
                ????? - External cache boards, Virtual Memory Systems, or
                        future hardware may patch this vector to best emulate
                        the intended behavior.
                        With a Bus-Snooping CPU, this function my end up
                        doing nothing.@{b}

   INPUTS@{ub}
        address - Same as initially passed to @{"CachePreDMA" LINK "CachePreDMA"}
        length  - Same as initially passed to @{"CachePreDMA" LINK "CachePreDMA"}
        flags   - Values:
                        @{"DMA_NoModify" LINK "gg:doc/NDK/Guide/Include/exec/execbase.h/File" 212} - If the area was not modified (and
                        thus there is no reason to flush the cache) set
                        this bit.

                        @{"DMA_ReadFromRAM" LINK "gg:doc/NDK/Guide/Include/exec/execbase.h/File" 213} - Indicates that this DMA is a
                        read from RAM to the DMA device (ie - a write
                        to the hard drive)  This flag is not required
                        but if used must match in both the PreDMA and
                        PostDMA calls.  This flag *should* be used to
                        help the system provide the best performance.
                        This flag is safe in all versions of @{"CachePostDMA" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 481}()@{b}

   SEE ALSO@{ub}
        exec/execbase.i, @{"CachePreDMA" LINK "CachePreDMA"}, @{"CacheClearU" LINK "CacheClearU"}, @{"CacheClearE" LINK "CacheClearE"}

@ENDNODE
@NODE "CachePreDMA" "exec.library/CachePreDMA()"
@{b}

   NAME@{ub}
        @{"CachePreDMA" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 477} - Take actions prior to hardware DMA  (V37)@{b}

   SYNOPSIS@{ub}
        paddress = @{"CachePreDMA" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 477}(vaddress,&length,flags)
        d0                     a0       a1      d0

        @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} @{"CachePreDMA" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 477}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} *,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        Take all appropriate steps before Direct Memory Access (DMA).  This
        function is primarily intended for writers of DMA device drivers.  The
        action will depend on the CPU type installed, caching modes, and the
        state of any Memory Management Unit (MMU) activity.

        This function supports advanced cache architectures that have
        "copyback" modes.  With copyback, write data may be cached, but not
        actually flushed out to memory.  If the CPU has unflushed data at the
        time of DMA, data may be lost.

        As implemented
                68000 - Do nothing
                68010 - Do nothing
                68020 - Do nothing
                68030 - Do nothing
                68040 - Write any matching dirty cache lines back to memory.
                        As a side effect of the 68040's design, matching data
                        cache lines are also invalidated -- future CPUs may
                        be different.
                ????? - External cache boards, Virtual Memory Systems, or
                        future hardware may patch this vector to best emulate
                        the intended behavior.
                        With a Bus-Snooping CPU, this function my end up
                        doing nothing.@{b}

   INPUTS@{ub}
        address - Base address to start the action.
        length  - Pointer to a longword with a length.
        flags   - Values:
                        @{"DMA_Continue" LINK "gg:doc/NDK/Guide/Include/exec/execbase.h/File" 211} - Indicates this call is to complete
                        a prior request that was broken up.

                        @{"DMA_ReadFromRAM" LINK "gg:doc/NDK/Guide/Include/exec/execbase.h/File" 213} - Indicates that this DMA is a
                        read from RAM to the DMA device (ie - a write
                        to the hard drive)  This flag is not required
                        but if used must match in both the PreDMA and
                        PostDMA calls.  This flag *should* be used to
                        help the system provide the best performance.
                        This flag is safe in all versions of @{"CachePreDMA" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 477}()@{b}

   RESULTS@{ub}
        paddress- Physical address that corresponds to the input virtual
                  address.
        &length - This length value will be updated to reflect the contiguous
                  length of physical memory present at paddress.  This may
                  be smaller than the requested length.  To get the mapping
                  for the next chunk of memory, call the function again with
                  a new address, length, and the @{"DMA_Continue" LINK "gg:doc/NDK/Guide/Include/exec/execbase.h/File" 211} flag.@{b}

   NOTE@{ub}
        Due to processor granularity, areas outside of the address range
        may be affected by the cache flushing actions.  Care has been taken
        to ensure that no harm is done outside the range, and that activities
        on overlapping cache lines won't harm data.@{b}

   SEE ALSO@{ub}
        exec/execbase.i, @{"CachePostDMA" LINK "CachePostDMA"}, @{"CacheClearU" LINK "CacheClearU"}, @{"CacheClearE" LINK "CacheClearE"}

@ENDNODE
@NODE "Cause" "exec.library/Cause()"
@{b}

   NAME@{ub}
       Cause -- cause a software interrupt@{b}

   SYNOPSIS@{ub}
       Cause(interrupt)
             A1

       void Cause(@{"struct Interrupt" LINK "gg:doc/NDK/Guide/Include/exec/interrupts.h/File" 22} *);@{b}

   FUNCTION@{ub}
        This function causes a software interrupt to occur.  If it is
        called from user mode (and processor level 0), the software
        interrupt will preempt the current task.  This call is often used
        by high-level hardware interrupts to defer medium-length processing
        down to a lower interrupt level.  Note that a software interrupt is
        still a real interrupt, and must obey the same restrictions on what
        system function it may call.

        Currently only 5 software interrupt priorities are implemented:
        -32, -16, 0, +16, and +32.  Priorities in between are truncated,
        values outside the -32/+32 range are not allowed.@{b}

   NOTE@{ub}
        When setting up the Interrupt structure, set the node type to
        @{"NT_INTERRUPT" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 45}, or NT_UNKOWN.@{b}

   IMPLEMENTATION@{ub}
        1> Checks if the node type is @{"NT_SOFTINT" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 54}.  If so does nothing since
           the softint is already pending.  No nest count is maintained.
        2> Sets the node type to @{"NT_SOFTINT" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 54}.
        3> Links into one of the 5 priority queues.
        4> Pokes the hardware interrupt bit used for softints.

        The node type returns to @{"NT_INTERRUPT" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 45} after removal from the list.@{b}

   INPUTS@{ub}
        interrupt - pointer to a properly initialized interrupt node@{b}

   BUGS@{ub}
        Unlike other Interrupts, SoftInts must preserve the value of A6.

@ENDNODE
@NODE "CheckIO" "exec.library/CheckIO()"
@{b}

   NAME@{ub}
        @{"CheckIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 309} -- get the status of an IORequest@{b}

   SYNOPSIS@{ub}
        result = @{"CheckIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 309}(iORequest)
        D0               A1

        @{"struct IORequest" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 18} *@{"CheckIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 309}(@{"struct IORequest" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 18} *);@{b}

   FUNCTION@{ub}
        This function determines the current state of an I/O request and
        returns @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if the I/O has not yet completed.  This function
        effectively hides the internals of the I/O completion mechanism.

        @{"CheckIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 309}() will @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} remove the returned IORequest from the reply port.
        This is best performed with @{"WaitIO()" LINK "WaitIO"}. If the request has already
        completed, @{"WaitIO()" LINK "WaitIO"} will return quickly. Use of the @{"Remove()" LINK "Remove"}
        function is dangerous, since other tasks may still be adding things
        to your message port; a @{"Disable()" LINK "Disable"} would be required.

        This function should @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} be used to busy loop (looping until IO is
        complete).  @{"WaitIO()" LINK "WaitIO"} is provided for that purpose.@{b}

   INPUTS@{ub}
        iORequest - pointer to an I/O request block@{b}

   RESULTS@{ub}
        result - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if I/O is still in progress.  Otherwise
                 D0 points to the IORequest block.@{b}

   BUGS@{ub}
        Previously, @{"CheckIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 309}() used to be documented to return a @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}
        result. This was incorrect.@{b}

   NOTE@{ub}
        @{"CheckIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 309} can hang if called on an IORequest that has never been used.
        This occurs if LN_TYPE of the IORequest is set to "@{"NT_MESSAGE" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 48}".
        Instead simply set LN_TYPE to 0.@{b}

   SEE ALSO@{ub}
        @{"DoIO" LINK "DoIO"}, @{"SendIO" LINK "SendIO"}, @{"WaitIO" LINK "WaitIO"}, @{"AbortIO" LINK "AbortIO"}

@ENDNODE
@NODE "CloseDevice" "exec.library/CloseDevice()"
@{b}

   NAME@{ub}
        @{"CloseDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 297} -- conclude access to a device@{b}

   SYNOPSIS@{ub}
        @{"CloseDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 297}(iORequest)
                    A1

        void @{"CloseDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 297}(@{"struct IORequest" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 18} *);@{b}

   FUNCTION@{ub}
        This function informs the device that access to a device/unit
        previously opened has been concluded.  The device may perform
        certain house-cleaning operations.

        The user must ensure that all outstanding IORequests have been
        returned before closing the device.  The @{"AbortIO" LINK "AbortIO"} function can kill
        any stragglers.

        After a close, the I/O request structure is free to be reused.
        Starting with V36 exec it is safe to @{"CloseDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 297}() with an
        IORequest that is either cleared to zeros, or failed to
        open.@{b}

   INPUTS@{ub}
        iORequest - pointer to an I/O request structure@{b}

   SEE ALSO@{ub}
        @{"OpenDevice" LINK "OpenDevice"}

@ENDNODE
@NODE "CloseLibrary" "exec.library/CloseLibrary()"
@{b}

   NAME@{ub}
        @{"CloseLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 273} -- conclude access to a library@{b}

   SYNOPSIS@{ub}
        @{"CloseLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 273}(library)
                     A1

        void @{"CloseLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 273}(@{"struct Library" LINK "gg:doc/NDK/Guide/Include/exec/libraries.h/File" 34} *);@{b}

   FUNCTION@{ub}
        This function informs the system that access to the given library
        has been concluded.  The user must not reference the library or any
        function in the library after this close.

        Starting with V36, it is safe to pass a @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} instead of
        a library pointer.@{b}

   INPUTS@{ub}
        library - pointer to a library node@{b}

   NOTE@{ub}
        Library writers must pass a SegList pointer or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} back from their
        open point.  This value is used by the system, and not visible as
        a return code from @{"CloseLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 273}.@{b}

   SEE ALSO@{ub}
        @{"OpenLibrary" LINK "OpenLibrary"}

@ENDNODE
@NODE "ColdReboot" "exec.library/ColdReboot()"
@{b}

    NAME@{ub}
        @{"ColdReboot" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 469} - reboot the Amiga (V36)@{b}

    SYNOPSIS@{ub}
        @{"ColdReboot" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 469}()

        void @{"ColdReboot" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 469}(void);@{b}

    FUNCTION@{ub}
        Reboot the machine.  All external memory and periperals will be
        @{"RESET" LINK "RESET"}, and the machine will start its power up diagnostics.

        This function never returns.@{b}

    INPUT@{ub}
        A chaotic pile of disoriented bits.@{b}

    RESULTS@{ub}
        An altogether totally integrated living system.

@ENDNODE
@NODE "CopyMem" "exec.library/CopyMem()"
@{b}

   NAME@{ub}
        @{"CopyMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 401} - general purpose memory copy function@{b}

   SYNOPSIS@{ub}
        @{"CopyMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 401}( source, dest, size )
                 A0      A1    D0

        void @{"CopyMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 401}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49},@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        @{"CopyMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 401} is a general purpose, fast memory copy function.  It can
        deal with arbitrary lengths, with its pointers on arbitrary
        alignments.  It attempts to optimize larger copies with more
        efficient copies, it uses byte copies for small moves, parts of
        larger copies, or the entire copy if the source and destination are
        misaligned with respect to each other.

        Arbitrary overlapping copies are not supported.

        The internal implementation of this function will change from
        system to system, and may be implemented via hardware DMA.@{b}

   INPUTS@{ub}
        source - a pointer to the source data region
        dest  - a pointer to the destination data region
        size  - the size (in bytes) of the memory area.  Zero copies
                zero bytes@{b}

   SEE ALSO@{ub}
        @{"CopyMemQuick" LINK "CopyMemQuick"}

@ENDNODE
@NODE "CopyMemQuick" "exec.library/CopyMemQuick()"
@{b}

   NAME@{ub}
        @{"CopyMemQuick" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 405} - optimized memory copy function@{b}

   SYNOPSIS@{ub}
        @{"CopyMemQuick" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 405}( source, dest, size )
                      A0      A1    D0

        void @{"CopyMemQuick" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 405}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} *,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} *,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        @{"CopyMemQuick" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 405} is a highly optimized memory copy function, with
        restrictions on the size and alignment of its arguments. Both the
        source and destination pointers must be longword aligned.  In
        addition, the size must be an integral number of longwords (e.g.
        the size must be evenly divisible by four).

        Arbitrary overlapping copies are not supported.

        The internal implementation of this function will change from system
        to system, and may be implemented via hardware DMA.@{b}

   INPUTS@{ub}
        source - a pointer to the source data region, long aligned
        dest -  a pointer to the destination data region, long aligned
        size -  the size (in bytes) of the memory area.  Zero copies
                zero bytes.@{b}

   SEE ALSO@{ub}
        @{"CopyMem" LINK "CopyMem"}

@ENDNODE
@NODE "CreateIORequest" "exec.library/CreateIORequest()"
@{b}

   NAME@{ub}
        @{"CreateIORequest" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 421}() -- create an IORequest structure  (V36)@{b}

   SYNOPSIS@{ub}
        ioReq = @{"CreateIORequest" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 421}( ioReplyPort, size );
                                 A0           D0

        @{"struct IORequest" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 18} *@{"CreateIORequest" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 421}(@{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        Allocates memory for and initializes a new IO request block
        of a user-specified number of bytes.  The number of bytes
        must be at least as large as a "@{"struct Message" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 47}".@{b}

   INPUTS@{ub}
        ioReplyPort - Pointer to a port for replies (an initialized message
                port, as created by @{"CreateMsgPort()" LINK "CreateMsgPort"} ).  If @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, this
                function fails.
        size - the size of the IO request to be created.@{b}

   RESULT@{ub}
        ioReq - A pointer to the new IORequest block, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"DeleteIORequest" LINK "DeleteIORequest"}, @{"CreateMsgPort()" LINK "CreateMsgPort"}, @{"amiga.lib/CreateExtIO()" LINK "gg:doc/NDK/Guide/amiga_lib/CreateExtIO"}

@ENDNODE
@NODE "CreateMsgPort" "exec.library/CreateMsgPort()"
@{b}

   NAME@{ub}
        @{"CreateMsgPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 429} - Allocate and initialize a new message port  (V36)@{b}

   SYNOPSIS@{ub}
        @{"CreateMsgPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 429}()

        @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} * @{"CreateMsgPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 429}(void);@{b}

   FUNCTION@{ub}
        Allocates and initializes a new message port.  The message list
        of the new port will be prepared for use (via @{"NewList" LINK "gg:doc/NDK/Guide/amiga_lib/NewList"}).  A signal
        bit will be allocated, and the port will be set to signal your
        task when a message arrives (@{"PA_SIGNAL" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 40}).

        You *must* use @{"DeleteMsgPort()" LINK "DeleteMsgPort"} to delete ports created with
        @{"CreateMsgPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 429}()!@{b}

   RESULT@{ub}
        MsgPort - A new MsgPort structure ready for use, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if out of
                memory or signals.  If you wish to add this port to the public
                port list, fill in the ln_Name and ln_Pri fields, then call
                @{"AddPort()" LINK "AddPort"}.  Don't forget @{"RemPort()" LINK "RemPort"}!@{b}

   SEE ALSO@{ub}
        @{"DeleteMsgPort()" LINK "DeleteMsgPort"}, exec/@{"AddPort()" LINK "AddPort"}, @{"exec/ports.h" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File"}, @{"amiga.lib/CreatePort()" LINK "gg:doc/NDK/Guide/amiga_lib/CreatePort"}

@ENDNODE
@NODE "CreatePool" "exec.library/CreatePool()"
@{b}

    NAME@{ub}
        @{"CreatePool" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 449} -- Generate a private memory pool header (V39)@{b}

    SYNOPSIS@{ub}
        newPool=@{"CreatePool" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 449}(memFlags,puddleSize,threshSize)
        a0                 d0       d1         d2

        void *@{"CreatePool" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 449}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

    FUNCTION@{ub}
        Allocate and prepare a new memory pool header.  Each pool is a
        separate tracking system for memory of a specific type.  Any number
        of pools may exist in the system.

        Pools automatically expand and shrink based on demand.  Fixed sized
        "puddles" are allocated by the pool manager when more total memory
        is needed.  Many small allocations can fit in a single puddle.
        Allocations larger than the threshSize are allocation in their own
        puddles.

        At any time individual allocations may be freed.  Or, the entire
        pool may be removed in a single step.@{b}

    INPUTS@{ub}
        memFlags - a memory flags specifier, as taken by @{"AllocMem" LINK "AllocMem"}.
        puddleSize - the size of Puddles...
        threshSize - the largest allocation that goes into normal puddles
                     This *MUST* be less than or equal to puddleSize
                     (@{"CreatePool" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 449}() will fail if it is not)@{b}

    RESULT@{ub}
        The address of a new pool header, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for error.@{b}

    SEE ALSO@{ub}
        @{"DeletePool()" LINK "DeletePool"}, @{"AllocPooled()" LINK "AllocPooled"}, @{"FreePooled()" LINK "FreePooled"}, exec/memory.i

@ENDNODE
@NODE "Deallocate" "exec.library/Deallocate()"
@{b}

   NAME@{ub}
        Deallocate -- deallocate a block of memory@{b}

   SYNOPSIS@{ub}
        Deallocate(memHeader, memoryBlock, byteSize)
                   A0         A1           D0

        void Deallocate(@{"struct MemHeader" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 28} *,@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This function deallocates memory by returning it to the appropriate
        private free memory pool.  This function can be used to free an
        entire block allocated with the above function, or it can be used
        to free a sub-block of a previously allocated block.  Sub-blocks
        must be an even multiple of the memory chunk size (currently 8
        bytes).

        This function can even be used to add a new free region to an
        existing MemHeader, however the extent pointers in the MemHeader
        will no longer be valid.

        If memoryBlock is not on a block boundary (@{"MEM_BLOCKSIZE" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 84}) then it
        will be rounded down in a manner compatible with @{"Allocate()" LINK "Allocate"}.  Note
        that this will work correctly with all the memory allocation
        functions, but may cause surprises if one is freeing only part of a
        region.  The size of the block will be rounded up, so the freed
        block will fill to an even memory block boundary.@{b}

   INPUTS@{ub}
        memHeader - points to the memory header this block is part of.
        memoryBlock - address of memory block to free.
        byteSize - the size of the block in bytes. If @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, nothing
                   happens.@{b}

   SEE ALSO@{ub}
        @{"Allocate" LINK "Allocate"}, @{"exec/memory.h" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File"}

@ENDNODE
@NODE "Debug" "exec.library/Debug()"
@{b}

   NAME@{ub}
        Debug -- run the system debugger@{b}

   SYNOPSIS@{ub}
        Debug(flags)
              D0

        void Debug(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This function calls the system debugger.  By default this debugger
        is "SAD" in >= V39 and "ROM-WACK" in < V39.  Other debuggers are
        encouraged to take over this entry point (via @{"SetFunction()" LINK "SetFunction"}) so
        that when an application calls Debug(), the alternative debugger
        will get control.  Currently a zero is passed to allow future
        expansion.@{b}

   NOTE@{ub}
        The Debug() call may be made when the system is in a questionable
        state; if you have a @{"SetFunction()" LINK "SetFunction"} patch, make few assumptions, be
        prepared for Supervisor mode, and be aware of differences in the
        Motorola stack frames on the 68000,'10,'20,'30,'40 (etc.)@{b}

   BUGS@{ub}
        In ROMWack, calling this function in SUPERVISOR state would have
        caused the a5 register to be trashed and the user stack pointer to
        be trashed.  As of V39 (and the instroduction of SAD) this is no
        longer the case.  However, calling this function in Supervisor
        state is a bit "tricky" at best...

        Note that due to a bug, pre-V40 SAD had the command
        codes wrong.  See the SAD autodoc for more details.@{b}

   SEE ALSO@{ub}
        @{"SetFunction()" LINK "SetFunction"}
        your favorite debugger's manual...
        the SAD autodocs...
        the ROM-WACK chapter of the ROM Kernel Manual... (pre-V39)

@ENDNODE
@NODE "DeleteIORequest" "exec.library/DeleteIORequest()"
@{b}

   NAME@{ub}
        @{"DeleteIORequest" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 425}() - Free a request made by @{"CreateIORequest()" LINK "CreateIORequest"}  (V36)@{b}

   SYNOPSIS@{ub}
        @{"DeleteIORequest" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 425}( ioReq );
                         a0

        void @{"DeleteIORequest" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 425}(@{"struct IORequest" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 18} *);@{b}

   FUNCTION@{ub}
        Frees up an IO request as allocated by @{"CreateIORequest()" LINK "CreateIORequest"}.@{b}

   INPUTS@{ub}
        ioReq - A pointer to the IORequest block to be freed, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.
                This function uses the mn_Length field to determine how
                much memory to free.@{b}

   SEE ALSO@{ub}
        @{"CreateIORequest()" LINK "CreateIORequest"}, @{"amiga.lib/DeleteExtIO()" LINK "gg:doc/NDK/Guide/amiga_lib/DeleteExtIO"}

@ENDNODE
@NODE "DeleteMsgPort" "exec.library/DeleteMsgPort()"
@{b}

   NAME@{ub}
        @{"DeleteMsgPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 433} - Free a message port created by @{"CreateMsgPort" LINK "CreateMsgPort"}  (V36)@{b}

   SYNOPSIS@{ub}
        @{"DeleteMsgPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 433}(msgPort)
                      a0

        void @{"DeleteMsgPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 433}(@{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *);@{b}

   FUNCTION@{ub}
        Frees a message port created by @{"CreateMsgPort()" LINK "CreateMsgPort"}.  All messages that
        may have been attached to this port must have already been
        replied to.@{b}

   INPUTS@{ub}
        msgPort - A message port.  @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for no action.@{b}

   SEE ALSO@{ub}
        @{"CreateMsgPort()" LINK "CreateMsgPort"}, @{"amiga.lib/DeletePort()" LINK "gg:doc/NDK/Guide/amiga_lib/DeletePort"}

@ENDNODE
@NODE "DeletePool" "exec.library/DeletePool()"
@{b}

    NAME@{ub}
        @{"DeletePool" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 453} --  Drain an entire memory pool (V39)@{b}

    SYNOPSIS@{ub}
        @{"DeletePool" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 453}(poolHeader)
                   a0

        void @{"DeletePool" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 453}(void *);@{b}

    FUNCTION@{ub}
        Frees all memory in all pudles of the specified pool header, then
        deletes the pool header.  Individual free calls are not needed.@{b}

    INPUTS@{ub}
        poolHeader - as returned by @{"CreatePool()" LINK "CreatePool"}.@{b}

    SEE ALSO@{ub}
        @{"CreatePool()" LINK "CreatePool"}, @{"AllocPooled()" LINK "AllocPooled"}, @{"FreePooled()" LINK "FreePooled"}

@ENDNODE
@NODE "Disable" "exec.library/Disable()"
@{b}

    NAME@{ub}
        Disable -- disable interrupt processing.@{b}

    SYNOPSIS@{ub}
        Disable();

        void Disable(void);@{b}

    FUNCTION@{ub}
        Prevents interrupts from being handled by the system, until a
        matching @{"Enable()" LINK "Enable"} is executed.  Disable() implies @{"Forbid()" LINK "Forbid"}.

        DO @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} USE THIS CALL WITHOUT GOOD JUSTIFICATION.  THIS CALL IS
        VERY DANGEROUS!@{b}

    RESULTS@{ub}
        All interrupt processing is deferred until the task executing makes
        a call to @{"Enable()" LINK "Enable"} or is placed in a wait state.  Normal task
        rescheduling does not occur while interrupts are disabled.  In order
        to restore normal interrupt processing, the programmer must execute
        exactly one call to @{"Enable()" LINK "Enable"} for every call to Disable().

        IMPORTANT REMINDER:

        It is important to remember that there is a danger in using
        disabled sections.  Disabling interrupts for more than ~250
        microseconds will prevent vital system functions (especially serial
        I/0) from operating in a normal fashion.

        Think twice before using Disable(), then think once more.
        After all that, think again.  With enough thought, the need
        for a Disable() can often be eliminated.  For the user of many
        device drivers, a write to disable *only* the particular interrupt
        of interest can replace a Disable().  For example:
                        MOVE.W  #@{"INTF_PORTS" LINK "gg:doc/NDK/Guide/Include/hardware/intbits.h/File" 46},_intena
        Do not use a macro for Disable(), insist on the real thing.

        This call may be made from interrupts, it will have the effect
        of locking out all higher-level interrupts (lower-level interrupts
        are automatically disabled by the CPU).

        Note: In the event of a task entering a @{"Wait()" LINK "Wait"} after disabling
              interrupts, the system "breaks" the disabled state and runs
              normally until the task which called Disable() is rescheduled.@{b}

    NOTE@{ub}
        This call is guaranteed to preserve all registers.@{b}

    SEE ALSO@{ub}
        @{"Forbid" LINK "Forbid"}, @{"Permit" LINK "Permit"}, @{"Enable" LINK "Enable"}

@ENDNODE
@NODE "DoIO" "exec.library/DoIO()"
@{b}

   NAME@{ub}
        @{"DoIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 301} -- perform an I/O command and wait for completion@{b}

   SYNOPSIS@{ub}
        error = @{"DoIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 301}(iORequest)
        D0           A1

        @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} @{"DoIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 301}(@{"struct IORequest" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 18} *);@{b}

   FUNCTION@{ub}
        This function requests a device driver to perform the I/O command
        specified in the I/O request.  This function will always wait until
        the I/O request is fully complete.

        @{"DoIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 301}() handles all the details, including Quick I/O, waiting for
        the request, and removing the reply message, etc..@{b}

   IMPLEMENTATION@{ub}
        This function first tries to complete the IO via the "Quick I/O"
        mechanism.  The io_Flags field is always set to @{"IOF_QUICK" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 46} (0x01)
        before the internal device call.

        The LN_TYPE field is used internally to flag completion.  Active
        requests have type @{"NT_MESSAGE" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 48}.  Requests that have been replied
        have type @{"NT_REPLYMSG" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 50}.  It is illegal to start IO using a
        still active IORequest, or a request with type @{"NT_REPLYMSG" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 50}.@{b}

   INPUTS@{ub}
        iORequest - pointer to an IORequest initialized by @{"OpenDevice()" LINK "OpenDevice"}@{b}

   RESULTS@{ub}
        error - a sign-extended copy of the io_Error field of the
                IORequest.  Most device commands require that the error
                return be checked.@{b}

   SEE ALSO@{ub}
        @{"SendIO" LINK "SendIO"}, @{"CheckIO" LINK "CheckIO"}, @{"WaitIO" LINK "WaitIO"}, @{"AbortIO" LINK "AbortIO"}, @{"amiga.lib/BeginIO" LINK "gg:doc/NDK/Guide/amiga_lib/BeginIO"}

@ENDNODE
@NODE "Enable" "exec.library/Enable()"
@{b}

   NAME@{ub}
        Enable -- permit system interrupts to resume.@{b}

   SYNOPSIS@{ub}
        Enable();

        void Enable(void);@{b}

   FUNCTION@{ub}
        Allow system interrupts to again occur normally, after a matching
        @{"Disable()" LINK "Disable"} has been executed.@{b}

   RESULTS@{ub}
        Interrupt processing is restored to normal operation. The
        programmer must execute exactly one call to Enable() for every call
        to @{"Disable()" LINK "Disable"}.@{b}

    NOTE@{ub}
        This call is guaranteed to preserve all registers.@{b}

   SEE ALSO@{ub}
        @{"Forbid" LINK "Forbid"}, @{"Permit" LINK "Permit"}, @{"Disable" LINK "Disable"}

@ENDNODE
@NODE "Enqueue" "exec.library/Enqueue()"
@{b}

   NAME@{ub}
        Enqueue -- insert or append node to a system queue@{b}

   SYNOPSIS@{ub}
        Enqueue(list, node)
                A0    A1

        void Enqueue(@{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} *, @{"struct Node" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 22} *);@{b}

   FUNCTION@{ub}
        Insert or append a node into a system queue.  The insert is
        performed based on the node priority -- it will keep the list
        properly sorted.  New nodes will be inserted in front of the first
        node with a lower priority.   Hence a FIFO queue for nodes of equal
        priority@{b}

   WARNING@{ub}
        This function does not arbitrate for access to the list.  The
        calling task must be the owner of the involved list.@{b}

   INPUTS@{ub}
        list - a pointer to the system queue header
        node - the node to enqueue.  This must be a full featured node
               with type, priority and name fields.@{b}

   SEE ALSO@{ub}
        @{"AddHead" LINK "AddHead"}, @{"AddTail" LINK "AddTail"}, @{"Insert" LINK "Insert"}, @{"Remove" LINK "Remove"}, @{"RemHead" LINK "RemHead"}, @{"RemTail" LINK "RemTail"}

@ENDNODE
@NODE "FindName" "exec.library/FindName()"
@{b}

   NAME@{ub}
        @{"FindName" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 181} -- find a system list node with a given name@{b}

   SYNOPSIS@{ub}
        node = @{"FindName" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 181}(start, name)
        D0,Z            A0     A1

        @{"struct Node" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 22} *@{"FindName" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 181}(@{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} *, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67});@{b}

   FUNCTION@{ub}
        Traverse a system list until a node with the given name is found.
        To find multiple occurrences of a string, this function may be
        called with a node starting point.

        No arbitration is done for access to the list!  If multiple tasks
        access the same list, an arbitration mechanism such as
        SignalSemaphores must be used.@{b}

   INPUTS@{ub}
        start - a list header or a list node to start the search
                (if node, this one is skipped)
        name - a pointer to a name string terminated with @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}@{b}

   RESULTS@{ub}
        node - a pointer to the node with the same name else
            zero to indicate that the string was not found.

@ENDNODE
@NODE "FindPort" "exec.library/FindPort()"
@{b}

   NAME@{ub}
        @{"FindPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 257} -- find a given system message port@{b}

   SYNOPSIS@{ub}
        port = @{"FindPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 257}(name)
        D0              A1

        @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *@{"FindPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 257}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67});@{b}

   FUNCTION@{ub}
        This function will search the system message port list for a port
        with the given name.  The first port matching this name will be
        returned.  No arbitration of the port list is done.  This function
        MUST be protected with A @{"Forbid()" LINK "Forbid"}/@{"Permit()" LINK "Permit"} pair!@{b}

   EXAMPLE@{ub}
        #include <@{"exec/types.h" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File"}>
        @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *@{"FindPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 257}();

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} SafePutToPort(message, portname)
        @{"struct Message" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 47} *message;
        @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}          portname;
        {
        @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *port;

            @{"Forbid()" LINK "Forbid"};
                port = @{"FindPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 257}(portname);
                if (port)
                    @{"PutMsg" LINK "PutMsg"}(port,message);
            @{"Permit()" LINK "Permit"};
            return((@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})port); /* If zero, the port has gone away */
        }@{b}

   INPUT@{ub}
        name - name of the port to find@{b}

   RETURN@{ub}
        port - a pointer to the message port, or zero if
                not found.

@ENDNODE
@NODE "FindResident" "exec.library/FindResident()"
@{b}

   NAME@{ub}
        @{"FindResident" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 61} - find a resident module by name@{b}

   SYNOPSIS@{ub}
        resident = @{"FindResident" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 61}(name)
        D0                      A1

        @{"struct Resident" LINK "gg:doc/NDK/Guide/Include/exec/resident.h/File" 18} *@{"FindResident" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 61}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67});@{b}

   FUNCTION@{ub}
        Search the system resident tag list for a resident tag ("ROMTag") with
        the given name.  If found return a pointer to the resident tag
        structure, else return zero.

        Resident modules are used by the system to pull all its parts
        together at startup.  Resident tags are also found in disk based
        devices and libraries.@{b}

   INPUTS@{ub}
        name - pointer to name string@{b}

   RESULT@{ub}
        resident - pointer to the resident tag structure or
                zero if none found.@{b}

    SEE ALSO@{ub}
        @{"exec/resident.h" LINK "gg:doc/NDK/Guide/Include/exec/resident.h/File"}, @{"InitResident" LINK "InitResident"}

@ENDNODE
@NODE "FindSemaphore" "exec.library/FindSemaphore()"
@{b}

   NAME@{ub}
        @{"FindSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 381} -- find a given system signal semaphore@{b}

   SYNOPSIS@{ub}
        signalSemaphore = @{"FindSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 381}(name)
        D0                              A1

        @{"struct SignalSemaphore" LINK "gg:doc/NDK/Guide/Include/exec/semaphores.h/File" 40} *@{"FindSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 381}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67});@{b}

   FUNCTION@{ub}
        This function will search the system signal semaphore list for a
        semaphore with the given name.  The first semaphore matching this
        name will be returned.

        This function does not arbitrate for access to the semaphore list,
        surround the call with a @{"Forbid()" LINK "Forbid"}/@{"Permit()" LINK "Permit"} pair.@{b}

   INPUT@{ub}
        name - name of the semaphore to find@{b}

   RESULT@{ub}
        semaphore - a pointer to the signal semaphore, or zero if not
                    found.

@ENDNODE
@NODE "FindTask" "exec.library/FindTask()"
@{b}

   NAME@{ub}
        @{"FindTask" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 193} -- find a task with the given name or find oneself@{b}

   SYNOPSIS@{ub}
        task = @{"FindTask" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 193}(name)
        D0              A1

        @{"struct Task" LINK "gg:doc/NDK/Guide/Include/exec/tasks.h/File" 24} *@{"FindTask" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 193}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67});@{b}

   FUNCTION@{ub}
        This function will check all task queues for a task with the given
        name, and return a pointer to its task control block.  If a @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
        name pointer is given a pointer to the current task will be
        returned.

        Finding oneself with a @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for the name is very quick.  Finding a
        task by name is very system expensive, and will disable interrupts
        for a long time.  Since a task may remove itself at any time,
        a @{"Forbid()" LINK "Forbid"}/@{"Permit()" LINK "Permit"} pair may be needed to ensure the pointer
        returned by @{"FindTask" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 193}() is still valid when used.@{b}

   INPUT@{ub}
        name - pointer to a name string@{b}

   RESULT@{ub}
        task - pointer to the task (or Process)

@ENDNODE
@NODE "Forbid" "exec.library/Forbid()"
@{b}

    NAME@{ub}
        Forbid -- forbid task rescheduling.@{b}

    SYNOPSIS@{ub}
        Forbid()

        void Forbid(void);@{b}

    FUNCTION@{ub}
        Prevents other tasks from being scheduled to run by the dispatcher,
        until a matching @{"Permit()" LINK "Permit"} is executed, or this task is scheduled to
        @{"Wait()" LINK "Wait"}.  Interrupts are @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} disabled.

        DO @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} USE THIS CALL WITHOUT GOOD JUSTIFICATION.  THIS CALL IS
        DANGEROUS!@{b}

    RESULTS@{ub}
        The current task will not be rescheduled as long as it is ready to
        run.  In the event that the current task enters a wait state, other
        tasks may be scheduled.  Upon return from the wait state, the original
        task will continue to run without disturbing the Forbid().

        Calls to Forbid() nest. In order to restore normal task rescheduling,
        the programmer must execute exactly one call to @{"Permit()" LINK "Permit"} for every
        call to Forbid().@{b}

    WARNING@{ub}
        In the event of a task entering a @{"Wait()" LINK "Wait"} after a Forbid(), the system
        "breaks" the forbidden state and runs normally until the task which
        called Forbid() is rescheduled.  If caution is not taken, this can
        cause subtle bugs, since any device or DOS call will (in effect)
        cause your task to wait.

        Forbid() is not useful or safe from within interrupt code
        (All interrupts are always higher priority than tasks, and
        interrupts are allowed to break a Forbid()).@{b}

    NOTE@{ub}
        This call is guaranteed to preserve all registers.@{b}

    SEE ALSO@{ub}
        @{"Permit" LINK "Permit"}, @{"Disable" LINK "Disable"}, @{"ObtainSemaphore" LINK "ObtainSemaphore"}, @{"ObtainSemaphoreShared" LINK "ObtainSemaphoreShared"}

@ENDNODE
@NODE "FreeEntry" "exec.library/FreeEntry()"
@{b}

   NAME@{ub}
        @{"FreeEntry" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 149} -- free many regions of memory@{b}

   SYNOPSIS@{ub}
        @{"FreeEntry" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 149}(memList)
                  A0
        void @{"FreeEntry" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 149}(@{"struct MemList" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 56} *);@{b}

   FUNCTION@{ub}
        This function takes a memList structure (as returned by @{"AllocEntry" LINK "AllocEntry"})
        and frees all the entries.@{b}

   INPUTS@{ub}
        memList -- pointer to structure filled in with MemEntry
                   structures@{b}

   SEE ALSO@{ub}
        @{"AllocEntry" LINK "AllocEntry"}

@ENDNODE
@NODE "FreeMem" "exec.library/FreeMem()"
@{b}

   NAME@{ub}
        @{"FreeMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 137} -- deallocate with knowledge@{b}

   SYNOPSIS@{ub}
        @{"FreeMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 137}(memoryBlock, byteSize)
                A1           D0

        void @{"FreeMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 137}(void *,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        Free a region of memory, returning it to the system pool from which
        it came.  Freeing partial blocks back into the system pool is
        unwise.@{b}

   NOTE@{ub}
        If a block of memory is freed twice, the system will Guru. The
        Alert is @{"AN_FreeTwice" LINK "gg:doc/NDK/Guide/Include/exec/alerts.h/File" 134} ($01000009).   If you pass the wrong pointer,
        you will probably see @{"AN_MemCorrupt" LINK "gg:doc/NDK/Guide/Include/exec/alerts.h/File" 129} $01000005.  Future versions may
        add more sanity checks to the memory lists.@{b}

   INPUTS@{ub}
        memoryBlock - pointer to the memory block to free
        byteSize - the size of the desired block in bytes.  (The operating
                system will automatically round this number to a multiple of
                the system memory chunk size)@{b}

   SEE ALSO@{ub}
        @{"AllocMem" LINK "AllocMem"}

@ENDNODE
@NODE "FreePooled" "exec.library/FreePooled()"
@{b}

    NAME@{ub}
        @{"FreePooled" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 461} -- Free pooled memory  (V39)@{b}

    SYNOPSIS@{ub}
        @{"FreePooled" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 461}(poolHeader,memory,memSize)
                   a0         a1     d0

        void @{"FreePooled" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 461}(void *,void *,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

    FUNCTION@{ub}
        Deallocates memory allocated by @{"AllocPooled()" LINK "AllocPooled"}.  The size of the
        allocation *MUST* match the size given to @{"AllocPooled()" LINK "AllocPooled"}.
        The reason the pool functions do not track individual allocation
        sizes is because many of the uses of pools have small allocation
        sizes and the tracking of the size would be a large overhead.

        Only memory allocated by @{"AllocPooled()" LINK "AllocPooled"} may be freed with this
        function!

        Doing a @{"DeletePool()" LINK "DeletePool"} on the pool will free all of the puddles
        and thus all of the allocations done with @{"AllocPooled()" LINK "AllocPooled"} in that
        pool.  (No need to @{"FreePooled" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 461}() each allocation)@{b}

    INPUTS@{ub}
        memory - pointer to memory allocated by @{"AllocPooled" LINK "AllocPooled"}.
        poolHeader - a specific private pool header.@{b}

    NOTES@{ub}
        The pool function do not protect an individual pool from
        multiple accesses.  The reason is that in most cases the pools
        will be used by a single task.  If your pool is going to
        be used by more than one task you must Semaphore protect
        the pool from having more than one task trying to allocate
        within the same pool at the same time.  Warning:  @{"Forbid()" LINK "Forbid"}
        protection *will not work* in the future.  *Do @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500}* assume
        that we will be able to make it work in the future.  @{"FreePooled" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 461}()
        may well break a @{"Forbid()" LINK "Forbid"} and as such can only be protected
        by a semaphore.

        To track sizes yourself, the following code can be used:
        Assumes a6=ExecBase

        ;
        ; Function to do AllocVecPooled(Pool,memSize)
        ;
        AllocVecPooled: addq.l  #4,d0           ; Get space for tracking
                        move.l  d0,-(sp)        ; Save the size
                        jsr     _LVOAllocPooled(a6)     ; Call pool...
                        move.l  (sp)+,d1        ; Get size back...
                        tst.l   d0              ; Check for error
                        beq.s   avp_fail        ; If @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, failed!
                        move.l  d0,a0           ; Get pointer...
                        move.l  d1,(a0)+        ; Store size
                        move.l  a0,d0           ; Get result
        avp_fail:       rts                     ; return

        ;
        ; Function to do FreeVecPooled(pool,memory)
        ;
        FreeVecPooled:  move.l  -(a1),d0        ; Get size / ajust pointer
                        jmp     _LVOFreePooled(a6)@{b}

    SEE ALSO@{ub}
        @{"AllocPooled()" LINK "AllocPooled"}, @{"CreatePool()" LINK "CreatePool"}, @{"DeletePool()" LINK "DeletePool"}

@ENDNODE
@NODE "FreeSignal" "exec.library/FreeSignal()"
@{b}

   NAME@{ub}
        @{"FreeSignal" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 221} -- free a signal bit@{b}

   SYNOPSIS@{ub}
        @{"FreeSignal" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 221}(signalNum)
                   D0

        void @{"FreeSignal" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 221}(@{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58});@{b}

   FUNCTION@{ub}
        This function frees a previously allocated signal bit for reuse.
        This call must be performed while running in the same task in which
        the signal was allocated.@{b}

   WARNING@{ub}
        Signals may not be allocated or freed from exception handling code.@{b}

   NOTE@{ub}
        Starting with V37, an attempt to free signal -1 is harmless.@{b}

   INPUTS@{ub}
        signalNum - the signal number to free {0..31}.

@ENDNODE
@NODE "FreeTrap" "exec.library/FreeTrap()"
@{b}

   NAME@{ub}
        @{"FreeTrap" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 229} -- free a processor trap@{b}

   SYNOPSIS@{ub}
        @{"FreeTrap" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 229}(trapNum)
                 D0

        void @{"FreeTrap" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 229}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This function frees a previously allocated trap number for reuse.
        This call must be performed while running in the same task in which
        the trap was allocated.@{b}

   WARNING@{ub}
        Traps may not be allocated or freed from exception handling code.@{b}

   INPUTS@{ub}
        trapNum - the trap number to free {of 0..15}

@ENDNODE
@NODE "FreeVec" "exec.library/FreeVec()"
@{b}

   NAME@{ub}
        @{"FreeVec" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 445} -- return @{"AllocVec()" LINK "AllocVec"} memory to the system  (V36)@{b}

   SYNOPSIS@{ub}
        @{"FreeVec" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 445}(memoryBlock)
                A1

        void @{"FreeVec" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 445}(void *);@{b}

   FUNCTION@{ub}
        Free an allocation made by the @{"AllocVec()" LINK "AllocVec"} call.  The memory will
        be returned to the system pool from which it came.@{b}

   NOTE@{ub}
        If a block of memory is freed twice, the system will Guru. The
        Alert is @{"AN_FreeTwice" LINK "gg:doc/NDK/Guide/Include/exec/alerts.h/File" 134} ($01000009).   If you pass the wrong pointer,
        you will probably see @{"AN_MemCorrupt" LINK "gg:doc/NDK/Guide/Include/exec/alerts.h/File" 129} $01000005.  Future versions may
        add more sanity checks to the memory lists.@{b}

   INPUTS@{ub}
        memoryBlock - pointer to the memory block to free, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"AllocVec" LINK "AllocVec"}

@ENDNODE
@NODE "GetCC" "exec.library/GetCC()"
@{b}

   NAME@{ub}
        @{"GetCC" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 337} -- get condition codes in a 68010 compatible way.@{b}

   SYNOPSIS@{ub}
        conditions = @{"GetCC" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 337}()
          D0

        @{"UWORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 55} @{"GetCC" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 337}(void);@{b}

   FUNCTION@{ub}
        The 68000 processor has a "MOVE SR,<ea>" instruction which gets a
        copy of the processor condition codes.

        On the 68010,20 and 30 CPUs, "MOVE SR,<ea>" is privileged.  User
        code will trap if it is attempted.  These processors need to use
        the "MOVE CCR,<ea>" instruction instead.

        This function provides a means of obtaining the CPU condition codes
        in a manner that will make upgrades transparent.  This function is
        VERY short and quick.@{b}

   RESULTS@{ub}
        conditions - the 680XX condition codes@{b}

    NOTE@{ub}
        This call is guaranteed to preserve all registers.  This function
        may be implemented as code right in the jump table.

@ENDNODE
@NODE "GetMsg" "exec.library/GetMsg()"
@{b}

   NAME@{ub}
        @{"GetMsg" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 245} -- get next message from a message port@{b}

   SYNOPSIS@{ub}
        message = @{"GetMsg" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 245}(port)
        D0               A0

        @{"struct Message" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 47} *@{"GetMsg" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 245}(@{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *);@{b}

   FUNCTION@{ub}
        This function receives a message from a given message port. It
        provides a fast, non-copying message receiving mechanism. The
        received message is removed from the message port.

        This function will not wait.  If a message is not present this
        function will return zero.  If a program must wait for a message,
        it can @{"Wait()" LINK "Wait"} on the signal specified for the port or use the
        @{"WaitPort()" LINK "WaitPort"} function.  There can only be one task waiting for any
        given port.

        Getting a message does not imply to the sender that the message is
        free to be reused by the sender.  When the receiver is finished
        with the message, it may @{"ReplyMsg()" LINK "ReplyMsg"} it back to the sender.


        Getting a signal does @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} always imply a message is ready.  More
        than one message may arrive per signal, and signals may show up
        without messages.  Typically you must loop to @{"GetMsg" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 245}() until it
        returns zero, then @{"Wait()" LINK "Wait"} or @{"WaitPort()" LINK "WaitPort"}.@{b}

   INPUT@{ub}
        port - a pointer to the receiver message port@{b}

   RESULT@{ub}
        message - a pointer to the first message available.  If
                  there are no messages, return zero.
                  Callers must be prepared for zero at any time.@{b}

   SEE ALSO@{ub}
        @{"PutMsg" LINK "PutMsg"}, @{"ReplyMsg" LINK "ReplyMsg"}, @{"WaitPort" LINK "WaitPort"}, @{"Wait" LINK "Wait"}, @{"exec/ports.h" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File"}

@ENDNODE
@NODE "InitCode" "exec.library/InitCode()"
@{b}

   NAME@{ub}
        @{"InitCode" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 45} - initialize resident code modules (internal function)@{b}

   SYNOPSIS@{ub}
        @{"InitCode" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 45}(startClass, version)
                 D0          D1

        void @{"InitCode" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 45}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        (This function may be ignored by application programmers)

        Call @{"InitResident()" LINK "InitResident"} for all resident modules in the ResModules array
        with the given startClass and with versions equal or greater than
        that specified.  The segList parameter is passed as zero.

        Resident modules are used by the system to pull all its parts
        together at startup.  Modules are initialized in a prioritized order.

        Modules that do not have a startclass should be of priority -120.
        @{"RTF_AFTERDOS" LINK "gg:doc/NDK/Guide/Include/exec/resident.h/File" 34} modules should start at -100 (working down).@{b}

   INPUTS@{ub}
        startClass - the class of code to be initialized:
                BITDEF RT,COLDSTART,0
                BITDEF RT,SINGLETASK,1  ;ExecBase->ThisTask==0 (V36 only)
                BITDEF RT,AFTERDOS,2    ;(V36 only)
        version - a major version number@{b}

    SEE ALSO@{ub}
        ResidentTag (RT) structure definition (resident.h)

@ENDNODE
@NODE "InitResident" "exec.library/InitResident()"
@{b}

   NAME@{ub}
        @{"InitResident" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 65} - initialize resident module@{b}

   SYNOPSIS@{ub}
        object = @{"InitResident" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 65}(resident, segList)
        D0                     A1        D1

        @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} @{"InitResident" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 65}(@{"struct Resident" LINK "gg:doc/NDK/Guide/Include/exec/resident.h/File" 18} *,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        Initialize a ROMTag.  ROMTags are used to link system modules
        together.  Each disk based device or library must contain a
        ROMTag structure in the first code hunk.

        Once the validity of the ROMTag is verified, the RT_INIT pointer
        is jumped to  with the following registers:
                D0 = 0
                A0 = segList
                A6 = ExecBase@{b}

   INPUTS@{ub}
        resident - Pointer to a ROMTag
        segList  - SegList of the loaded object, if loaded from disk.
                   Libraries & Devices will cache this value for later
                   return at close or expunge time.  Pass @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for ROM
                   modules.@{b}

   RESULTS@{ub}
        object  - Return value from the init code, usually the library
                  or device base.  @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for failure.@{b}

   AUTOINIT FEATURE@{ub}
        An automatic method of library/device base and vector table
        initialization is also provided by @{"InitResident" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 65}().  The initial code
        hunk of the library or device should contain "MOVEQ #-1,d0; RTS;".
        Following that must be an initialized Resident structure with
        @{"RTF_AUTOINIT" LINK "gg:doc/NDK/Guide/Include/exec/resident.h/File" 33} set in rt_Flags, and an rt_Init pointer which points
        to four longwords.  These four longwords will be used in a call
        to @{"MakeLibrary()" LINK "MakeLibrary"};

            - The size of your library/device base structure including initial
              Library or Device structure.

            - A pointer to a longword table of standard, then library
              specific function offsets, terminated with -1L.
              (short format offsets are also acceptable)

            - Pointer to data table in exec/@{"InitStruct" LINK "InitStruct"} format for
              initialization of Library or Device structure.

            - Pointer to library initialization function, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.
                Calling sequence:
                        D0 = library base
                        A0 = segList
                        A6 = ExecBase
              This function must return in D0 the library/device base to be
              linked into the library/device list.  If the initialization
              function fails, the device memory must be manually deallocated,
              then @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} returned in D0.@{b}

   SEE ALSO@{ub}
        exec/resident.i, @{"FindResident" LINK "FindResident"}

@ENDNODE
@NODE "InitSemaphore" "exec.library/InitSemaphore()"
@{b}

   NAME@{ub}
        @{"InitSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 357} -- initialize a signal semaphore@{b}

   SYNOPSIS@{ub}
        @{"InitSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 357}(signalSemaphore)
                      A0

        void @{"InitSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 357}(@{"struct SignalSemaphore" LINK "gg:doc/NDK/Guide/Include/exec/semaphores.h/File" 40} *);@{b}

   FUNCTION@{ub}
        This function initializes a signal semaphore and prepares it for
        use.  It does not allocate anything, but does initialize list
        pointers and the semaphore counters.

        Semaphores are often used to protect critical data structures
        or hardware that can only be accessed by one task at a time.
        After initialization, the address of the SignalSemaphore may be
        made available to any number of tasks.  Typically a task will
        try to @{"ObtainSemaphore()" LINK "ObtainSemaphore"}, passing this address in.  If no other
        task owns the semaphore, then the call will lock and return
        quickly.  If more tasks try to @{"ObtainSemaphore()" LINK "ObtainSemaphore"}, they will
        be put to sleep.  When the owner of the semaphore releases
        it, the next waiter in turn will be woken up.

        Semaphores are often preferable to the old-style @{"Forbid()" LINK "Forbid"}/@{"Permit()" LINK "Permit"}
        type arbitration.  With @{"Forbid()" LINK "Forbid"}/@{"Permit()" LINK "Permit"} *all* other tasks are
        prevented from running.  With semaphores, only those tasks that
        need access to whatever the semaphore protects are subject
        to waiting.@{b}

   INPUT@{ub}
        signalSemaphore -- a signal semaphore structure (with all fields
                           set to zero before the call)@{b}

   SEE ALSO@{ub}
        @{"ObtainSemaphore" LINK "ObtainSemaphore"}, @{"ObtainSemaphoreShared" LINK "ObtainSemaphoreShared"}, @{"AttemptSemaphore" LINK "AttemptSemaphore"},
        @{"ReleaseSemaphore" LINK "ReleaseSemaphore"}, @{"Procure" LINK "Procure"}, @{"Vacate" LINK "Vacate"}, @{"exec/semaphores.h" LINK "gg:doc/NDK/Guide/Include/exec/semaphores.h/File"}

@ENDNODE
@NODE "InitStruct" "exec.library/InitStruct()"
@{b}

   NAME@{ub}
        @{"InitStruct" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 49} - initialize memory from a table@{b}

   SYNOPSIS@{ub}
        @{"InitStruct" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 49}(initTable, memory, size);
                   A1         A2      D0

        void @{"InitStruct" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 49}(struct InitStruct *, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        Clear a memory area, then set up default values according to
        the data and offset values in the initTable.  Typically only assembly
        programs take advantage of this function, and only with the macros
        defined in "exec/initializers.i".

        The initialization table has byte commands to

             |a    ||byte|      |given||byte|         |once         |
        load |count||word| into |next ||rptr| offset, |repetitively |
                    |long|

        Not all combinations are supported.  The offset, when specified, is
        relative to the memory pointer provided (Memory), and is initially
        zero.  The initialization data (InitTable) contains byte commands
        whose 8 bits are interpreted as follows:

        ddssnnnn
            dd  the destination type (and size):
                00  no offset, use next destination, nnnn is count
                01  no offset, use next destination, nnnn is repeat
                10  destination offset is in the next byte, nnnn is count
                11  destination offset is in the next 24-bits, nnnn is count
            ss  the size and location of the source:
                00  long, from the next two aligned words
                01  word, from the next aligned word
                10  byte, from the next byte
                11  ERROR - will cause an ALERT (see below)
          nnnn  the count or repeat:
             count  the (number+1) of source items to copy
            repeat  the source is copied (number+1) times.

        initTable commands are always read from the next even byte. Given
        destination offsets are always relative to the memory pointer (A2).

        The command %00000000 ends the InitTable stream: use %00010001 if you
        really want to copy one longword without a new offset.

        24 bit @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} not supported for 68020 compatibility -- use long.@{b}

   INPUTS@{ub}
        initTable - the beginning of the commands and data to init
                Memory with.  Must be on an even boundary unless only
                byte initialization is done.  End table with "dc.b 0"
                or "dc.w 0".
        memory - the beginning of the memory to initialize.  Must be
                on an even boundary if size is specified.
        size - the size of memory, which is used to clear it before
                initializing it via the initTable.  If Size is zero,
                memory is not cleared before initializing.

                size must be an even number.@{b}

    SEE ALSO@{ub}
        exec/initializers.i

@ENDNODE
@NODE "Insert" "exec.library/Insert()"
@{b}

   NAME@{ub}
        Insert -- insert a node into a list@{b}

   SYNOPSIS@{ub}
        Insert(list, node, listNode)
               A0    A1    A2

        void Insert(@{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} *, @{"struct Node" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 22} *, @{"struct Node" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 22} *);@{b}

   FUNCTION@{ub}
        Insert a node into a doubly linked list AFTER a given node
        position.  Insertion at the head of a list is possible by passing a
        zero value for listNode, though the @{"AddHead" LINK "AddHead"} function is slightly
        faster for that special case.@{b}

   WARNING@{ub}
        This function does not arbitrate for access to the list.  The
        calling task must be the owner of the involved list.@{b}

   INPUTS@{ub}
        list - a pointer to the target list header
        node - the node to insert
        listNode - the node after which to insert@{b}

    SEE ALSO@{ub}
        @{"AddHead" LINK "AddHead"}, @{"AddTail" LINK "AddTail"}, @{"Enqueue" LINK "Enqueue"}, @{"RemHead" LINK "RemHead"}, @{"Remove" LINK "Remove"}, @{"RemTail" LINK "RemTail"}

@ENDNODE
@NODE "MakeFunctions" "exec.library/MakeFunctions()"
@{b}

   NAME@{ub}
        @{"MakeFunctions" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 57} -- construct a function jump table@{b}

   SYNOPSIS@{ub}
        tableSize = @{"MakeFunctions" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 57}(target, functionArray, funcDispBase)
        D0                        A0      A1             A2

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"MakeFunctions" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 57}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49},@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49},@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        A low level function used by @{"MakeLibrary" LINK "MakeLibrary"} to build jump tables of
        the type used by libraries, devices and resources.  It allows the
        table to be built anywhere in memory, and can be used both for
        initialization and replacement. This function also supports function
        pointer compression by expanding relative displacements into absolute
        pointers.

        The processor instruction cache is cleared after the table building.@{b}

   INPUT@{ub}
        destination - the target address for the high memory end of the
                function jump table.  Typically this will be the library
                base pointer.

        functionArray - pointer to an array of function pointers or
                function displacements.  If funcDispBase is zero, the array
                is assumed to contain absolute pointers to functions. If
                funcDispBase is not zero, then the array is assumed to
                contain word displacements to functions.  In both cases,
                the array is terminated by a -1 (of the same size as the
                actual entry.

        funcDispBase - pointer to the base about which all function
                displacements are relative.  If zero, then the function
                array contains absolute pointers.@{b}

   RESULT@{ub}
        tableSize - size of the new table in bytes (for LIB_NEGSIZE).@{b}

   SEE ALSO@{ub}
        exec/@{"MakeLibrary" LINK "MakeLibrary"}

@ENDNODE
@NODE "MakeLibrary" "exec.library/MakeLibrary()"
@{b}

   NAME@{ub}
        @{"MakeLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 53} -- construct a library@{b}

   SYNOPSIS@{ub}
        library = @{"MakeLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 53}(vectors, structure, init, dSize, segList)
        D0                    A0       A1         A2    D0     D1

        @{"struct Library" LINK "gg:doc/NDK/Guide/Include/exec/libraries.h/File" 34} *@{"MakeLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 53}
                              (@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49},struct InitStruct *,@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130});@{b}

   FUNCTION@{ub}
        This function is used for constructing a library vector and data
        area.  The same call is used to make devices.  Space for the library
        is allocated from the system's free memory pool.  The data portion of
        the library is initialized.  init may point to a library specific
        entry point.@{b}

   NOTE@{ub}
        Starting with V36, the library base is longword adjusted.  The
        lib_PosSize and lib_NegSize fields of the library structure are
        adjusted to match.@{b}

   INPUTS@{ub}
        vectors - pointer to an array of function pointers or function
                displacements.  If the first word of the array is -1, then
                the array contains relative word displacements (based off
                of vectors); otherwise, the array contains absolute
                function pointers. The vector list is terminated by a -1
                (of the same size as the pointers).

        structure - points to an "@{"InitStruct" LINK "InitStruct"}" data region.  If @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101},
                then it will not be used.

        init -  If non-@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, an entry point that will be called before adding
                the library to the system.  Registers are as follows:
                        d0 = libAddr    ;Your Library Address
                        a0 = segList    ;Your AmigaDOS segment list
                        a6 = ExecBase   ;Address of exec.library
                The result of the init function must be the library address,
                or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for failure.   If @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, the init point must manually
                deallocate the library base memory (based on the sizes stored
                in lib_PosSize and lib_NegSize).

        dSize - the size of the library data area, including the
                standard library node data.  This must be at leas
                sizeof(@{"struct Library" LINK "gg:doc/NDK/Guide/Include/exec/libraries.h/File" 34}).

       segList - pointer to an AmigaDOS SegList (segment list).
                 This is passed to a library's init code, and is used later
                 for removing the library from memory.@{b}

   RESULT@{ub}
        library - the reference address of the library.  This is the
                  address used in references to the library, not the
                  beginning of the memory area allocated.  If the library
                  vector table require more system memory than is
                  available, this function will return @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"InitStruct" LINK "InitStruct"}, @{"InitResident" LINK "InitResident"}, exec/initializers.i

@ENDNODE
@NODE "ObtainQuickVector" "exec.library/ObtainQuickVector()"
@{b}

   NAME@{ub}
        Function to obtain an install a Quick Interrupt vector            (V39)@{b}

   SYNOPSIS@{ub}
        vector=@{"ObtainQuickVector" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 493}(interruptCode)
        d0                       a0

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"ObtainQuickVector" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 493}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        This function will install the code pointer into the quick interrupt
        vector it allocates and returns to you the interrupt vector that
        your Quick Interrupt system needs to use.

        This function may also return 0 if no vectors are available.  Your
        hardware should be able to then fall back to using the shared
        interrupt server chain should this happen.

        The interrupt code is a direct connect to the physical interrupt.
        This means that it is the responsibility of your code to do all
        of the context saving/restoring required by interrupt code.

        Also, due to the performance of the interrupt controller, you may
        need to also watch for "false" interrupts.  These are interrupts
        that come in just after a DISABLE.  The reason this happens is
        because the interrupt may have been posted before the DISABLE
        hardware access is completed.  For example:

        myInt:          move.l  d0,-(sp)        ; Save d0...
                        move.w  _intenar,d0     ; Get interrupt enable state
                        btst.l  #@{"INTB_INTEN" LINK "gg:doc/NDK/Guide/Include/hardware/intbits.h/File" 16},d0  ; Check if pending disable
                        bne.s   realInt         ; If not, do real one...
        exitInt:        move.l  (sp)+,d0        ; Restore d0
                        rte                     ; Return from int...
        ;
        realInt:        ; Now do your int code...  d0 is already saved
                        ; ALL other registers need to be saved if needed
                        ; This includes a0/a1/d0/d1 as this is an interrupt
                        ; and not a function call...
                        ;
                        bra.s   exitInt         ; Exit interrupt...

        If your interrupt will not play with system (OS) structures and your
        own structures are safe to play with you do not need to check for
        the disable.  It is only needed for when the system is in disable but
        that "one last interrupt" still got through.@{b}

   NOTE@{ub}
        This function was not implemented fully until V39.  Due to a mis-cue
        it is not safe to call in V37 EXEC.  (Sorry)@{b}

   INPUTS@{ub}
        A pointer to your interrupt code.  This code is not an EXEC interrupt
        but is dirrectly connected to the hardware interrupt.  Thus, the
        interrupt code must not modify any registers and must return via
        an RTE.@{b}

   RESULTS@{ub}
        The 8-bit vector number used for Zorro-III Quick Interrupts
        If it returns 0, no quick interrupt was allocatable.  The device
        should at this point switch to using the shared interrupt server
        method.@{b}

   SEE ALSO@{ub}

@ENDNODE
@NODE "ObtainSemaphore" "exec.library/ObtainSemaphore()"
@{b}

   NAME@{ub}
        @{"ObtainSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 361} -- gain exclusive access to a semaphore@{b}

   SYNOPSIS@{ub}
        @{"ObtainSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 361}(signalSemaphore)
                        A0

        void @{"ObtainSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 361}(@{"struct SignalSemaphore" LINK "gg:doc/NDK/Guide/Include/exec/semaphores.h/File" 40} *);@{b}

   FUNCTION@{ub}
        Signal semaphores are used to gain exclusive access to an object.
        @{"ObtainSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 361} is the call used to gain this access.  If another
        user currently has the semaphore locked the call will block until
        the object is available.

        If the current task already has locked the semaphore and attempts to
        lock it again the call will still succeed.  A "nesting count" is
        incremented each time the current owning task of the semaphore calls
        @{"ObtainSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 361}().  This counter is decremented each time
        @{"ReleaseSemaphore()" LINK "ReleaseSemaphore"} is called.  When the counter returns to zero the
        semaphore is actually released, and the next waiting task is called.

        A queue of waiting tasks is maintained on the stacks of the waiting
        tasks.  Each will be called in turn as soon as the current task
        releases the semaphore.

        Signal Semaphores are different than @{"Procure()" LINK "Procure"}/@{"Vacate()" LINK "Vacate"} semaphores.
        The former requires less CPU time, especially if the semaphore is
        not currently locked.  They require very little set up and user
        thought.  The latter flavor of semaphore make no assumptions about
        how they are used -- they are completely general.  Unfortunately
        they are not as efficient as signal semaphores, and require the
        locker to have done some setup before doing the call.@{b}

   INPUT@{ub}
       signalSemaphore -- an initialized signal semaphore structure@{b}

   NOTE@{ub}
        This function preserves all registers (see BUGS).@{b}

   BUGS@{ub}
        Until V37, this function could destroy A0.@{b}

   SEE ALSO@{ub}
        @{"ObtainSemaphoreShared()" LINK "ObtainSemaphoreShared"}, @{"InitSemaphore()" LINK "InitSemaphore"}, @{"ReleaseSemaphore()" LINK "ReleaseSemaphore"},
        @{"AttemptSemaphore()" LINK "AttemptSemaphore"}, @{"ObtainSemaphoreList()" LINK "ObtainSemaphoreList"}, @{"Procure()" LINK "Procure"}, @{"Vacate()" LINK "Vacate"}

@ENDNODE
@NODE "ObtainSemaphoreList" "exec.library/ObtainSemaphoreList()"
@{b}

   NAME@{ub}
        @{"ObtainSemaphoreList" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 373} -- get a list of semaphores.@{b}

   SYNOPSIS@{ub}
        @{"ObtainSemaphoreList" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 373}(list)
                            A0

        void @{"ObtainSemaphoreList" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 373}(@{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} *);@{b}

   FUNCTION@{ub}
        Signal semaphores may be linked together into a list. This function
        takes a list of these semaphores and attempts to lock all of them at
        once. This call is preferable to applying @{"ObtainSemaphore()" LINK "ObtainSemaphore"} to each
        element in the list because it attempts to lock all the elements
        simultaneously, and won't deadlock if someone is attempting to lock
        in some other order.

        This function assumes that only one task at a time will attempt to
        lock the entire list of semaphores.  In other words, there needs to
        be a higher level lock (perhaps another signal semaphore...) that is
        used before someone attempts to lock the semaphore list via
        @{"ObtainSemaphoreList" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 373}().

        Note that deadlocks may result if this call is used AND someone
        attempts to use @{"ObtainSemaphore()" LINK "ObtainSemaphore"} to lock more than one semaphore on
        the list.  If you wish to lock more than semaphore (but not all of
        them) then you should obtain the higher level lock (see above)@{b}

   INPUT@{ub}
       list -- a list of signal semaphores@{b}

   SEE ALSO@{ub}
        @{"ObtainSemaphoreShared()" LINK "ObtainSemaphoreShared"}, @{"InitSemaphore()" LINK "InitSemaphore"}, @{"ReleaseSemaphore()" LINK "ReleaseSemaphore"},
        @{"AttemptSemaphore()" LINK "AttemptSemaphore"}, @{"ObtainSemaphoreShared()" LINK "ObtainSemaphoreShared"}, @{"Procure()" LINK "Procure"}, @{"Vacate()" LINK "Vacate"}

@ENDNODE
@NODE "ObtainSemaphoreShared" "exec.library/ObtainSemaphoreShared()"
@{b}

    NAME@{ub}
        @{"ObtainSemaphoreShared" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 437} -- gain shared access to a semaphore (V36)@{b}

    SYNOPSIS@{ub}
        @{"ObtainSemaphoreShared" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 437}(signalSemaphore)
                              a0

        void @{"ObtainSemaphoreShared" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 437}(@{"struct SignalSemaphore" LINK "gg:doc/NDK/Guide/Include/exec/semaphores.h/File" 40} *);@{b}

    FUNCTION@{ub}
        A lock on a signal semaphore may either be exclusive, or shared.
        Exclusive locks are granted by the @{"ObtainSemaphore()" LINK "ObtainSemaphore"} and
        @{"AttemptSemaphore()" LINK "AttemptSemaphore"} functions.  Shared locks are granted by
        @{"ObtainSemaphoreShared" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 437}().  Calls may be nested.

        Any number of tasks may simultaneously hold a shared lock on a
        semaphore.  Only one task may hold an exclusive lock.  A typical
        application is a list that is often read, but only occasionally
        written to.

        Any exlusive locker will be held off until all shared lockers
        release the semaphore.  Likewise, if an exlusive lock is held,
        all potential shared lockers will block until the exclusive lock
        is released.  All shared lockers are restarted at the same time.@{b}

    EXAMPLE@{ub}
                @{"ObtainSemaphoreShared" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 437}(ss);
                /* read data */
                ReleaseSemaohore(ss);

                @{"ObtainSemaphore" LINK "ObtainSemaphore"}(ss);
                /* modify data */
                ReleaseSemaohore(ss);@{b}

    NOTES@{ub}
        While this function was added for V36, the feature magically works
        with all older semaphore structures.

        A task owning a shared lock must not attempt to get an exclusive
        lock on the same semaphore.

        Starting in V39, if the caller already has an exclusive lock on the
        semaphore it will return with another nesting of the lock.  Pre-V39
        this would cause a deadlock.  For pre-V39 use, you can use the
        following workaround:

                /* Try to get the shared semaphore */
                if (!@{"AttemptSemaphoreShared" LINK "AttemptSemaphoreShared"}(ss))
                {
                        /* Check if we can get the exclusive version */
                        if (!@{"AttemptSemaphore" LINK "AttemptSemaphore"}(ss))
                        {
                                /* Oh well, wait for the shared lock */
                                @{"ObtainSemaphoreShared" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 437}(ss));
                        }
                }
                :
                :
                @{"ReleaseSemaphore" LINK "ReleaseSemaphore"}(ss);@{b}

    INPUT@{ub}
        signalSemaphore -- an initialized signal semaphore structure@{b}

    NOTE@{ub}
        This call is guaranteed to preserve all registers, starting with
        V37 exec.@{b}

    RESULT@{ub}@{b}

    SEE ALSO@{ub}
        @{"ObtainSemaphore()" LINK "ObtainSemaphore"}, @{"InitSemaphore()" LINK "InitSemaphore"}, @{"ReleaseSemaphore()" LINK "ReleaseSemaphore"},
        @{"AttemptSemaphore()" LINK "AttemptSemaphore"}, @{"ObtainSemaphoreList()" LINK "ObtainSemaphoreList"}, @{"Procure()" LINK "Procure"}, @{"Vacate()" LINK "Vacate"}

@ENDNODE
@NODE "OldOpenLibrary" "exec.library/OldOpenLibrary()"
@{b}

   NAME@{ub}
        @{"OldOpenLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 269} -- obsolete @{"OpenLibrary" LINK "OpenLibrary"}@{b}

   SYNOPSIS@{ub}
        library = @{"OldOpenLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 269}(libName)
        D0                       A1

        @{"struct Library" LINK "gg:doc/NDK/Guide/Include/exec/libraries.h/File" 34} *@{"OldOpenLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 269}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        The 1.0 release of the Amiga system had an incorrect version of
        @{"OpenLibrary" LINK "OpenLibrary"} that did not check the version number during the
        library open.  This obsolete function is provided so that object
        code compiled using a 1.0 system will still run.

        This exactly the same as "@{"OpenLibrary" LINK "OpenLibrary"}(libName,0L);"@{b}

   INPUTS@{ub}
        libName - the name of the library to open@{b}

   RESULTS@{ub}
        library - a library pointer for a successful open, else zero@{b}

   SEE ALSO@{ub}
        @{"CloseLibrary" LINK "CloseLibrary"}

@ENDNODE
@NODE "OpenDevice" "exec.library/OpenDevice()"
@{b}

   NAME@{ub}
        @{"OpenDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 293} -- gain access to a device@{b}

   SYNOPSIS@{ub}
        error = @{"OpenDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 293}(devName, unitNumber, iORequest, flags)
        D0                 A0       D0          A1         D1

        @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} @{"OpenDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 293}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"struct IORequest" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 18} *,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This function opens the named device/unit and initializes the given
        I/O request block.  Specific documentation on opening procedures
        may come with certain devices.

        The device may exist in memory, or on disk; this is transparent to
        the @{"OpenDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 293} caller.

        A full path name for the device name is legitimate.  For example
        "test:devs/fred.device".  This allows the use of custom devices
        without requiring the user to copy the device into the system's
        DEVS: directory.@{b}

   NOTES@{ub}
        All calls to @{"OpenDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 293} should have matching calls to @{"CloseDevice" LINK "CloseDevice"}!

        Devices on disk cannot be opened until after DOS has been
        started.

        As of V36 tasks can safely call @{"OpenDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 293}, though DOS may open
        system requesters (e.g., asking the user to insert the Workbench
        disk if DEVS: is not online).  You must call this function from a
        DOS Process if you want to turn off DOS requesters.@{b}

   INPUTS@{ub}
        devName - requested device name

        unitNumber - the unit number to open on that device.  The format of
                the unit number is device specific.  If the device does
                not have separate units, send a zero.

        iORequest - the I/O request block to be returned with
                appropriate fields initialized.

        flags - additional driver specific information.  This is sometimes
                used to request opening a device with exclusive access.@{b}

   RESULTS@{ub}
        error - Returns a sign-extended copy of the io_Error field
                of the IORequest.  Zero if successful, else an error code
                is returned.@{b}

   BUGS@{ub}
        AmigaDOS file names are not case sensitive, but Exec lists are.  If
        the library name is specified in a different case than it exists on
        disk, unexpected results may occur.

        Prior to V36, tasks could not make @{"OpenDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 293} calls requiring disk
        access (since tasks are not allowed to make @{"dos.library" LINK "gg:doc/NDK/Guide/dos/MAIN"} calls).
        Now @{"OpenDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 293} is protected from tasks.@{b}

   SEE ALSO@{ub}
        @{"CloseDevice" LINK "CloseDevice"}, @{"DoIO" LINK "DoIO"}, @{"SendIO" LINK "SendIO"}, @{"CheckIO" LINK "CheckIO"}, @{"AbortIO" LINK "AbortIO"}, @{"WaitIO" LINK "WaitIO"}

@ENDNODE
@NODE "OpenLibrary" "exec.library/OpenLibrary()"
@{b}

   NAME@{ub}
        @{"OpenLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 353} -- gain access to a library@{b}

   SYNOPSIS@{ub}
        library = @{"OpenLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 353}(libName, version)
        D0                    A1       D0

        @{"struct Library" LINK "gg:doc/NDK/Guide/Include/exec/libraries.h/File" 34} *@{"OpenLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 353}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This function returns a pointer to a library that was previously
        installed into the system.  If the requested library is exists, and
        if the library version is greater than or equal to the requested
        version, then the open will succeed.

        The library may exist in memory, or on disk; this is transparent to
        the @{"OpenLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 353} caller.  Only Processes are allowed to call
        @{"OpenLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 353} (since @{"OpenLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 353} may in turn call @{"dos.library" LINK "gg:doc/NDK/Guide/dos/MAIN"}).

        A full path name for the library name is legitimate.  For example
        "wp:libs/wp.library".  This allows the use of custom libraries
        without requiring the user to copy the library into the system's
        LIBS: directory.@{b}

   NOTES@{ub}
        All calls to @{"OpenLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 353} should have matching calls to @{"CloseLibrary" LINK "CloseLibrary"}!

        Libraries on disk cannot be opened until after DOS has been
        started.

        As of V36 tasks can safely call @{"OpenLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 353}, though DOS may open
        system requesters (e.g., asking the user to insert the Workbench
        disk if LIBS: is not online).  You must call this function from a
        DOS Process if you want to turn off DOS requesters.@{b}

   INPUTS@{ub}
        libName - the name of the library to open

        version - the version of the library required.@{b}

   RESULTS@{ub}
        library - a library pointer for a successful open, else zero@{b}

   BUGS@{ub}
        AmigaDOS file names are not case sensitive, but Exec lists are. If
        the library name is specified in a different case than it exists on
        disk, unexpected results may occur.

        Prior to V36, tasks could not make @{"OpenLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 353} calls requiring disk
        access (since tasks are not allowed to make @{"dos.library" LINK "gg:doc/NDK/Guide/dos/MAIN"} calls).
        Now @{"OpenLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 353} is protected from tasks.

        The version number of the resident tag in disk based library must
        match the version number of the library, or V36 may fail to load it.@{b}

   SEE ALSO@{ub}
        @{"CloseLibrary" LINK "CloseLibrary"}

@ENDNODE
@NODE "OpenResource" "exec.library/OpenResource()"
@{b}

   NAME@{ub}
        @{"OpenResource" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 329} -- gain access to a resource@{b}

   SYNOPSIS@{ub}
        resource = @{"OpenResource" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 329}(resName)
        D0                      A1

        @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} @{"OpenResource" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 329}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67});@{b}

   FUNCTION@{ub}
        This function returns a pointer to a resource that was previously
        installed into the system.

        There is no CloseResource() function.@{b}

   INPUTS@{ub}
       resName - the name of the resource requested.@{b}

   RESULTS@{ub}
        resource - if successful, a resource pointer, else @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}

@ENDNODE
@NODE "Permit" "exec.library/Permit()"
@{b}

    NAME@{ub}
        Permit -- permit task rescheduling.@{b}

    SYNOPSIS@{ub}
        Permit()

        void Permit(void);@{b}

    FUNCTION@{ub}
        Allow other tasks to be scheduled to run by the dispatcher, after a
        matching @{"Forbid()" LINK "Forbid"} has been executed.@{b}

    RESULTS@{ub}
        Other tasks will be rescheduled as they are ready to run. In order
        to restore normal task rescheduling, the programmer must execute
        exactly one call to Permit() for every call to @{"Forbid()" LINK "Forbid"}.@{b}

    NOTE@{ub}
        This call is guaranteed to preserve all registers.@{b}

    SEE ALSO@{ub}
        @{"Forbid" LINK "Forbid"}, @{"Disable" LINK "Disable"}, @{"Enable" LINK "Enable"}

@ENDNODE
@NODE "Procure" "exec.library/Procure()"
@{b}

   NAME@{ub}
        Procure -- bid for a semaphore                                   (V39)@{b}

   SYNOPSIS@{ub}
        Procure(semaphore, bidMessage)
                A0          A1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} Procure(@{"struct SignalSemaphore" LINK "gg:doc/NDK/Guide/Include/exec/semaphores.h/File" 40} *, @{"struct SemaphoreMessage" LINK "gg:doc/NDK/Guide/Include/exec/semaphores.h/File" 51} *);@{b}

   FUNCTION@{ub}
        This function is used to obtain a semaphore in an async manner.
        Like @{"ObtainSemaphore()" LINK "ObtainSemaphore"}, it will obtain a SignalSemaphore for you
        but unlike @{"ObtainSemaphore()" LINK "ObtainSemaphore"}, you will not block until you get
        the semaphore.  Procure() will just post a request for the semaphore
        and will return.  When the semaphore is available (which could
        be at any time) the bidMessage will @{"ReplyMsg()" LINK "ReplyMsg"} and you will own
        the semaphore.  This lets you wait on multiple semaphores at once
        and to continue processing while waiting for the semaphore.

        NOTE:  Pre-V39, Procure() and @{"Vacate()" LINK "Vacate"} did not work correctly.
        They also did not operate on SignalSemaphore semaphores.
        Old (and broken) MessageSemaphore use as of V39 will no longer work.@{b}

   INPUT@{ub}
        semaphore - The SignalSemaphore that you wish to Procure()
        bidMessage- The SemaphoreMessage that you wish replied when
                you obtain access to the semaphore.  The message's
                ssm_Semaphore field will point at the semaphore that
                was obtained.  If the ssm_Semaphore field is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101},
                the Procure() was aborted via @{"Vacate()" LINK "Vacate"}.
                The mn_ReplyPort field of the message must point to
                a valid message port.
                To obtain a shared semaphore, the ln_Name field
                must be set to 1.  For an exclusive lock, the ln_Name
                field must be 0.  No other values are valid.@{b}

   BUGS@{ub}
        Before V39, Procure() and @{"Vacate()" LINK "Vacate"} used a different semaphore
        system that was very broken.  This new system is only available
        as of V39 even though the LVOs are the same.@{b}

   SEE ALSO@{ub}
        @{"ObtainSemaphoreShared()" LINK "ObtainSemaphoreShared"}, @{"InitSemaphore()" LINK "InitSemaphore"}, @{"ReleaseSemaphore()" LINK "ReleaseSemaphore"},
        @{"AttemptSemaphore()" LINK "AttemptSemaphore"}, @{"ObtainSemaphoreList()" LINK "ObtainSemaphoreList"}, @{"Vacate()" LINK "Vacate"}, @{"ObtainSemaphore()" LINK "ObtainSemaphore"}

@ENDNODE
@NODE "PutMsg" "exec.library/PutMsg()"
@{b}

   NAME@{ub}
        @{"PutMsg" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 241} -- put a message to a message port@{b}

   SYNOPSIS@{ub}
        @{"PutMsg" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 241}(port, message)
               A0    A1

        void @{"PutMsg" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 241}(@{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *, @{"struct Message" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 47} *);@{b}

   FUNCTION@{ub}
        This function attaches a message to the end of a given message port.
        It provides a fast, non-copying message sending mechanism.

        Messages can be attached to only one port at a time.  The message
        body can be of any size or form.  Because messages are not copied,
        cooperating tasks share the same message memory.  The sender task
        must not recycle the message until it has been replied by the
        receiver.  Of course this depends on the message handling conventions
        setup by the involved tasks.  If the ReplyPort field is non-zero,
        when the message is replied by the receiver, it will be sent back to
        that port.

        Any one of the following actions can be set to occur when a message
        is put:

                1. no special action
                2. signal a given task (specified by MP_SIGTASK)
                3. cause a software interrupt (specified by MP_SIGTASK)

        The action is selected depending on the value found in the MP_FLAGS
        of the destination port.@{b}

   IMPLEMENTATION@{ub}
        1.  Sets the LN_TYPE field to "@{"NT_MESSAGE" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 48}".
        2.  Attaches the message to the destination port.
        3.  Performs the specified arrival action at the destination.@{b}

   INPUT@{ub}
        port - pointer to a message port
        message - pointer to a message@{b}

   SEE ALSO@{ub}
        @{"GetMsg" LINK "GetMsg"}, @{"ReplyMsg" LINK "ReplyMsg"}, @{"exec/ports.h" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File"}

@ENDNODE
@NODE "RawDoFmt" "exec.library/RawDoFmt()"
@{b}

   NAME@{ub}
        @{"RawDoFmt" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 333} -- format data into a character stream.@{b}

   SYNOPSIS@{ub}
        NextData = @{"RawDoFmt" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 333}(@{"FormatString" LINK "gg:doc/NDK/Guide/locale/FormatString"}, DataStream, PutChProc, PutChData);
       d0                  a0            a1          a2         a3

        @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} @{"RawDoFmt" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 333}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49},void (*)(),@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        perform "C"-language-like formatting of a data stream, outputting
        the result a character at a time.  Where % formatting commands are
        found in the @{"FormatString" LINK "gg:doc/NDK/Guide/locale/FormatString"}, they will be replaced with the
        corresponding element in the DataStream.  %% must be used in the
        string if a % is desired in the output.

        Under V36, @{"RawDoFmt" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 333}() returns a pointer to the end of the DataStream
        (The next argument that would have been processed).  This allows
        multiple formatting passes to be made using the same data.@{b}

   INPUTS@{ub}
        @{"FormatString" LINK "gg:doc/NDK/Guide/locale/FormatString"} - a "C"-language-like @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} terminated format string,
        with the following supported % options:

         %[flags][width.limit][length]type

        flags  - only one allowed. '-' specifies left justification.
        width  - field width.  If the first character is a '0', the
                 field will be padded with leading 0's.
          .    - must follow the field width, if specified
        limit  - maximum number of characters to output from a string.
                 (only valid for %s).
        length - size of input data defaults to @{"WORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 54} for types d, x,
                 and c, 'l' changes this to long (32-bit).
        type   - supported types are:
                        b - @{"BSTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 131}, data is 32-bit @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} to byte count followed
                            by a byte string, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} terminated byte string.
                            A @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} is treated as an empty string.
                            (Added in V36 exec)
                        d - decimal
                        u - unsigned decimal (Added in V37 exec)
                        x - hexadecimal
                        s - string, a 32-bit pointer to a @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} terminated
                            byte string.  In V36, a @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} pointer is treated
                            as an empty string
                        c - character

        DataStream - a stream of data that is interpreted according to
                 the format string.  Often this is a pointer into
                 the task's stack.
        PutChProc  - the procedure to call with each character to be
                 output, called as:

        PutChProc(Char,  PutChData);
                  D0-0:8 A3

                the procedure is called with a @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} Char at the end of
                the format string.
                Starting with V45.1, this pointer may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}. In that
                case, the default "stuffChar" procedure shown below is
                used.

        PutChData - a value that is passed through to the PutChProc
                procedure.  This is untouched by @{"RawDoFmt" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 333}, and may be
                modified by the PutChProc.@{b}

   EXAMPLE@{ub}
        ;
        ; Simple version of the C "sprintf" function.  Assumes C-style
        ; stack-based function conventions.
        ;
        ;   long eyecount;
        ;   eyecount=2;
        ;   @{"sprintf" LINK "gg:doc/NDK/Guide/amiga_lib/sprintf"}(string,"%s have %ld eyes.","Fish",eyecount);
        ;
        ; would produce "Fish have 2 eyes." in the string buffer.
        ;
                XDEF _sprintf
                XREF _AbsExecBase
                XREF _LVORawDoFmt
        _sprintf:       ; ( ostring, format, {values} )
                movem.l a2/a3/a6,-(sp)

                move.l  4*4(sp),a3       ;Get the output string pointer
                move.l  5*4(sp),a0       ;Get the @{"FormatString" LINK "gg:doc/NDK/Guide/locale/FormatString"} pointer
                lea.l   6*4(sp),a1       ;Get the pointer to the DataStream
                lea.l   stuffChar(pc),a2
                move.l  _AbsExecBase,a6
                jsr     _LVORawDoFmt(a6)

                movem.l (sp)+,a2/a3/a6
                rts

        ;------ PutChProc function used by @{"RawDoFmt" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 333} -----------
        stuffChar:
                move.b  d0,(a3)+        ;Put data to output string
                rts@{b}

   WARNING@{ub}
        This Amiga ROM function formats word values in the data stream.  If
        your compiler defaults to longs, you must add an "l" to your
        % specifications.  This can get strange for characters, which might
        look like "%lc".

        The result of @{"RawDoFmt" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 333}() is *ONLY* valid in V36 and later releases
        of EXEC.  Pre-V36 versions of EXEC have "random" return values.@{b}

   SEE ALSO@{ub}
        Documentation on the C language "@{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"}" call in any C language
        reference book.

@ENDNODE
@NODE "ReleaseSemaphore" "exec.library/ReleaseSemaphore()"
@{b}

   NAME@{ub}
        @{"ReleaseSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 365} -- make signal semaphore available to others@{b}

   SYNOPSIS@{ub}
        @{"ReleaseSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 365}(signalSemaphore)
                         A0

        void @{"ReleaseSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 365}(@{"struct SignalSemaphore" LINK "gg:doc/NDK/Guide/Include/exec/semaphores.h/File" 40} *);@{b}

   FUNCTION@{ub}
        @{"ReleaseSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 365}() is the inverse of @{"ObtainSemaphore()" LINK "ObtainSemaphore"}. It makes
        the semaphore lockable to other users.  If tasks are waiting for
        the semaphore and this this task is done with the semaphore then
        the next waiting task is signalled.

        Each @{"ObtainSemaphore()" LINK "ObtainSemaphore"} call must be balanced by exactly one
        @{"ReleaseSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 365}() call.  This is because there is a nesting count
        maintained in the semaphore of the number of times that the current
        task has locked the semaphore. The semaphore is not released to
        other tasks until the number of releases matches the number of
        obtains.

        Needless to say, havoc breaks out if the task releases more times
        than it has obtained.@{b}

   INPUT@{ub}
       signalSemaphore -- an initialized signal semaphore structure@{b}

   BUGS@{ub}
        In V39 and V40 Kickstart, there is an error condition that bumps
        ss_NestCount twice, if multiple @{"Procure()" LINK "Procure"} SemaphoreMessages and
        a @{"ObtainSemaphore()" LINK "ObtainSemaphore"} are pending for the same task.@{b}

   NOTE@{ub}
        This call is guaranteed to preserve all registers.@{b}

   SEE ALSO@{ub}
        @{"InitSemaphore()" LINK "InitSemaphore"}, @{"ObtainSemaphore()" LINK "ObtainSemaphore"}, @{"ObtainSemaphoreShared()" LINK "ObtainSemaphoreShared"}

@ENDNODE
@NODE "ReleaseSemaphoreList" "exec.library/ReleaseSemaphoreList()"
@{b}

   NAME@{ub}
        @{"ReleaseSemaphoreList" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 377} -- make a list of semaphores available@{b}

   SYNOPSIS@{ub}
        @{"ReleaseSemaphoreList" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 377}(list)
                             A0

        void @{"ReleaseSemaphoreList" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 377}(@{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} *);@{b}

   FUNCTION@{ub}
        @{"ReleaseSemaphoreList" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 377}() is the inverse of @{"ObtainSemaphoreList()" LINK "ObtainSemaphoreList"}. It
        releases each element in the semaphore list.

        Needless to say, havoc breaks out if the task releases more times
        than it has obtained.@{b}

   INPUT@{ub}
       list -- a list of signal semaphores@{b}

   SEE ALSO@{ub}
        @{"ObtainSemaphoreList()" LINK "ObtainSemaphoreList"}

@ENDNODE
@NODE "RemDevice" "exec.library/RemDevice()"
@{b}

   NAME@{ub}
        @{"RemDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 289} -- remove a device from the system@{b}

   SYNOPSIS@{ub}
        @{"RemDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 289}(device)
                  A1

        void @{"RemDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 289}(@{"struct Device" LINK "gg:doc/NDK/Guide/Include/exec/devices.h/File" 24} *);@{b}

   FUNCTION@{ub}
        This function calls the device's EXPUNGE vector, which requests
        that a device delete itself.  The device may refuse to do this if
        it is busy or currently open. This is not typically called by user
        code.

        There are certain, limited circumstances where it may be
        appropriate to attempt to specifically flush a certain device.
        Example:

         /* Attempts to flush the named device out of memory. */
         #include <@{"exec/types.h" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File"}>
         #include <@{"exec/execbase.h" LINK "gg:doc/NDK/Guide/Include/exec/execbase.h/File"}>

         void FlushDevice(name)
         @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} name;
         {
         @{"struct Device" LINK "gg:doc/NDK/Guide/Include/exec/devices.h/File" 24} *result;

            @{"Forbid()" LINK "Forbid"};
            if(result=(@{"struct Device" LINK "gg:doc/NDK/Guide/Include/exec/devices.h/File" 24} *)@{"FindName" LINK "FindName"}(&SysBase->DeviceList,name))
                @{"RemDevice" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 289}(result);
            @{"Permit()" LINK "Permit"};
         }@{b}

   INPUTS@{ub}
        device - pointer to a device node@{b}

   SEE ALSO@{ub}
        @{"AddLibrary" LINK "AddLibrary"}

@ENDNODE
@NODE "RemHead" "exec.library/RemHead()"
@{b}

   NAME@{ub}
        @{"RemHead" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 169} -- remove the head node from a list@{b}

   SYNOPSIS@{ub}
        node = @{"RemHead" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 169}(list)
        D0             A0

        @{"struct Node" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 22} *@{"RemHead" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 169}(@{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} *);@{b}

   FUNCTION@{ub}
        Get a pointer to the head node and remove it from the list.
        Assembly programmers may prefer to use the REMHEAD macro from
        "exec/lists.i".@{b}

   WARNING@{ub}
        This function does not arbitrate for access to the list.  The
        calling task must be the owner of the involved list.@{b}

   INPUTS@{ub}
        list - a pointer to the target list header@{b}

   RESULT@{ub}
        node - the node removed or zero when empty list@{b}

   SEE ALSO@{ub}
        @{"AddHead" LINK "AddHead"}, @{"AddTail" LINK "AddTail"}, @{"Enqueue" LINK "Enqueue"}, @{"Insert" LINK "Insert"}, @{"Remove" LINK "Remove"}, @{"RemTail" LINK "RemTail"}

@ENDNODE
@NODE "RemIntServer" "exec.library/RemIntServer()"
@{b}

   NAME@{ub}
        @{"RemIntServer" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 113} -- remove an interrupt server from a server chain@{b}

   SYNOPSIS@{ub}
        @{"RemIntServer" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 113}(intNum, interrupt)
                     D0      A1

        void @{"RemIntServer" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 113}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"struct Interrupt" LINK "gg:doc/NDK/Guide/Include/exec/interrupts.h/File" 22} *);@{b}

   FUNCTION@{ub}
        This function removes an interrupt server node from the given
        server chain.

        If this server was the last one on this chain, interrupts for this
        chain are disabled.@{b}

   INPUTS@{ub}
        intNum - the Paula interrupt bit (0..14)
        interrupt - pointer to an interrupt server node@{b}

   BUGS@{ub}
        Before V36 Kickstart, the feature that disables the interrupt
        would not function.  For most server chains this does not
        cause a problem.@{b}

   SEE ALSO@{ub}
        @{"AddIntServer" LINK "AddIntServer"}, @{"hardware/intbits.h" LINK "gg:doc/NDK/Guide/Include/hardware/intbits.h/File"}

@ENDNODE
@NODE "RemLibrary" "exec.library/RemLibrary()"
@{b}

   NAME@{ub}
        @{"RemLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 265} -- remove a library from the system@{b}

   SYNOPSIS@{ub}
        @{"RemLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 265}(library)
                   A1

        void @{"RemLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 265}(@{"struct Library" LINK "gg:doc/NDK/Guide/Include/exec/libraries.h/File" 34} *);@{b}

   FUNCTION@{ub}
        This function calls the library's EXPUNGE vector, which requests
        that a library delete itself.  The library may refuse to do this if
        it is busy or currently open. This is not typically called by user
        code.

        There are certain, limited circumstances where it may be
        appropriate to attempt to specifically flush a certain Library.
        Example:

         /* Attempts to flush the named library out of memory. */
         #include <@{"exec/types.h" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File"}>
         #include <@{"exec/execbase.h" LINK "gg:doc/NDK/Guide/Include/exec/execbase.h/File"}>

         void FlushLibrary(name)
         @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} name;
         {
         @{"struct Library" LINK "gg:doc/NDK/Guide/Include/exec/libraries.h/File" 34} *result;

            @{"Forbid()" LINK "Forbid"};
            if(result=(@{"struct Library" LINK "gg:doc/NDK/Guide/Include/exec/libraries.h/File" 34} *)@{"FindName" LINK "FindName"}(&SysBase->LibList,name))
                @{"RemLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 265}(result);
            @{"Permit()" LINK "Permit"};
         }@{b}

   INPUTS@{ub}
        library - pointer to a library node structure

@ENDNODE
@NODE "RemMemHandler" "exec.library/RemMemHandler()"
@{b}

   NAME@{ub}
        @{"RemMemHandler" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 489} - Remove low memory handler from exec              (V39)@{b}

   SYNOPSIS@{ub}
        @{"RemMemHandler" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 489}(memHandler)
                      A1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"RemMemHandler" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 489}(@{"struct Interrupt" LINK "gg:doc/NDK/Guide/Include/exec/interrupts.h/File" 22} *);@{b}

   FUNCTION@{ub}
        This function removes the low memory handler from the system.
        This function can be called from within a handler.  If removing
        oneself, it is important that the handler returns @{"MEM_ALL_DONE" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 101}.@{b}

   NOTE@{ub}
        When removing a handler, the handler may be called until this
        function returns.  Thus, the handler must still be valid until
        then.@{b}

   INPUTS@{ub}
        memHandler - Pointer to a handler added with @{"AddMemHandler()" LINK "AddMemHandler"}@{b}

   SEE ALSO@{ub}
        @{"AddMemHandler" LINK "AddMemHandler"}, exec/interrupts.i

@ENDNODE
@NODE "Remove" "exec.library/Remove()"
@{b}

   NAME@{ub}
        Remove -- remove a node from a list@{b}

   SYNOPSIS@{ub}
        Remove(node)
               A1

        void Remove(@{"struct Node" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 22} *);@{b}

   FUNCTION@{ub}
        Unlink a node from whatever list it is in.  Nodes that are not part
        of a list must not be passed to this function!  Assembly programmers
        may prefer to use the REMOVE macro from "exec/lists.i".@{b}

   WARNING@{ub}
        This function does not arbitrate for access to the list.  The
        calling task must be the owner of the involved list.@{b}

   INPUTS@{ub}
        node - the node to remove@{b}

   SEE ALSO@{ub}
        @{"AddHead" LINK "AddHead"}, @{"AddTail" LINK "AddTail"}, @{"Enqueue" LINK "Enqueue"}, @{"Insert" LINK "Insert"}, @{"RemHead" LINK "RemHead"}, @{"RemTail" LINK "RemTail"}

@ENDNODE
@NODE "RemPort" "exec.library/RemPort()"
@{b}

   NAME@{ub}
        @{"RemPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 237} -- remove a message port from the system@{b}

   SYNOPSIS@{ub}
        @{"RemPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 237}(port)
                A1

        void @{"RemPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 237}(@{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *);@{b}

   FUNCTION@{ub}
        This function removes a message port structure from the system's
        message port list.  Subsequent attempts to rendezvous by name with
        this port will fail.@{b}

   INPUTS@{ub}
        port - pointer to a message port@{b}

   SEE ALSO@{ub}
        @{"AddPort" LINK "AddPort"}, @{"FindPort" LINK "FindPort"}

@ENDNODE
@NODE "RemResource" "exec.library/RemResource()"
@{b}

   NAME@{ub}
        @{"RemResource" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 325} -- remove a resource from the system@{b}

   SYNOPSIS@{ub}
        @{"RemResource" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 325}(resource)
                   A1

        void @{"RemResource" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 325}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        This function removes an existing resource from the system resource
        list.  There must be no outstanding users of the resource.@{b}

   INPUTS@{ub}
        resource - pointer to a resource node@{b}

   SEE ALSO@{ub}
        @{"AddResource" LINK "AddResource"}

@ENDNODE
@NODE "RemSemaphore" "exec.library/RemSemaphore()"
@{b}

   NAME@{ub}
        @{"RemSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 389} -- remove a signal semaphore from the system@{b}

   SYNOPSIS@{ub}
        @{"RemSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 389}(signalSemaphore)
                     A1

        void @{"RemSemaphore" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 389}(@{"struct SignalSemaphore" LINK "gg:doc/NDK/Guide/Include/exec/semaphores.h/File" 40} *);@{b}

   FUNCTION@{ub}
        This function removes a signal semaphore structure from the
        system's signal semaphore list.  Subsequent attempts to
        rendezvous by name with this semaphore will fail.@{b}

   INPUTS@{ub}
       signalSemaphore -- an initialized signal semaphore structure@{b}

   SEE ALSO@{ub}
        @{"AddSemaphore" LINK "AddSemaphore"}, @{"FindSemaphore" LINK "FindSemaphore"}

@ENDNODE
@NODE "RemTail" "exec.library/RemTail()"
@{b}

   NAME@{ub}
        @{"RemTail" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 173} -- remove the tail node from a list@{b}

   SYNOPSIS@{ub}
        node = @{"RemTail" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 173}(list)
        D0             A0

        @{"struct Node" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 22} *@{"RemTail" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 173}(@{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} *);@{b}

   FUNCTION@{ub}
        Remove the last node from a list, and return a pointer to it. If
        the list is empty, return zero. Assembly programmers may prefer to
        use the REMTAIL macro from "exec/lists.i".@{b}

   WARNING@{ub}
        This function does not arbitrate for access to the list.  The
        calling task must be the owner of the involved list.@{b}

   INPUTS@{ub}
        list - a pointer to the target list header@{b}

   RESULT@{ub}
        node - the node removed or zero when empty list@{b}

   SEE ALSO@{ub}
        @{"AddHead" LINK "AddHead"}, @{"AddTail" LINK "AddTail"}, @{"Enqueue" LINK "Enqueue"}, @{"Insert" LINK "Insert"}, @{"Remove" LINK "Remove"}, @{"RemHead" LINK "RemHead"}, @{"RemTail" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 173}

@ENDNODE
@NODE "RemTask" "exec.library/RemTask()"
@{b}

   NAME@{ub}
        @{"RemTask" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 189} -- remove a task from the system@{b}

   SYNOPSIS@{ub}
        @{"RemTask" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 189}(task)
                A1

        void @{"RemTask" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 189}(@{"struct Task" LINK "gg:doc/NDK/Guide/Include/exec/tasks.h/File" 24} *);@{b}

   FUNCTION@{ub}
        This function removes a task from the system.  Deallocation of
        resources should have been performed prior to calling this
        function.  Removing some other task is very dangerous.  Generally
        is is best to arrange for tasks to call @{"RemTask" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 189}(0L) on themselves.

        @{"RemTask" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 189} will automagically free any memory lists attached to the
        task's TC_MEMENTRY list.@{b}

   INPUTS@{ub}
        task - pointer to the task node representing the task to be
               removed.  A zero value indicates self removal, and will
               cause the next ready task to begin execution.@{b}

   BUGS@{ub}
        Before V36 if @{"RemTask" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 189}() was called on a task other than the current
        task, and that task was created with @{"amiga.lib/CreateTask" LINK "gg:doc/NDK/Guide/amiga_lib/CreateTask"}, there was
        a slight chance of a crash.  The problem can be hidden by bracketing
        @{"RemTask" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 189}() with @{"Forbid()" LINK "Forbid"}/@{"Permit()" LINK "Permit"}.@{b}

   SEE ALSO@{ub}
        @{"AddTask" LINK "AddTask"}, exec/@{"AllocEntry" LINK "AllocEntry"}, @{"amiga.lib/DeleteTask" LINK "gg:doc/NDK/Guide/amiga_lib/DeleteTask"}

@ENDNODE
@NODE "ReplyMsg" "exec.library/ReplyMsg()"
@{b}

   NAME@{ub}
        @{"ReplyMsg" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 249} -- put a message to its reply port@{b}

   SYNOPSIS@{ub}
        @{"ReplyMsg" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 249}(message)
                 A1

        void @{"ReplyMsg" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 249}(@{"struct Message" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 47} *);@{b}

   FUNCTION@{ub}
        This function sends a message to its reply port.  This is usually
        done when the receiver of a message has finished and wants to
        return it to the sender (so that it can be re-used or deallocated,
        whatever).

        This call may be made from interrupts.@{b}

   INPUT@{ub}
        message - a pointer to the message@{b}

   IMPLEMENTATION@{ub}
        1> Places "@{"NT_REPLYMSG" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 50}" into LN_TYPE.
        2> Puts the message to the port specified by MN_REPLYPORT
           If there is no replyport, sets LN_TYPE to "@{"NT_FREEMSG" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 49}" (use this
           feature only with extreme care).@{b}

   SEE ALSO@{ub}
        @{"GetMsg" LINK "GetMsg"}, @{"PutMsg" LINK "PutMsg"}, @{"exec/ports.h" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File"}

@ENDNODE
@NODE "SendIO" "exec.library/SendIO()"
@{b}

   NAME@{ub}
        @{"SendIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 305} -- initiate an I/O command@{b}

   SYNOPSIS@{ub}
        @{"SendIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 305}(iORequest)
               A1

        void @{"SendIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 305}(@{"struct IORequest" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 18} *);@{b}

   FUNCTION@{ub}
        This function requests the device driver start processing the given
        I/O request.  The device will return control without waiting for
        the I/O to complete.

        The io_Flags field of the IORequest will be set to zero before the
        request is sent.  See @{"BeginIO()" LINK "gg:doc/NDK/Guide/amiga_lib/BeginIO"} for more details.@{b}

   INPUTS@{ub}
        iORequest - pointer to an I/O request, or a device specific
                    extended IORequest.@{b}

   SEE ALSO@{ub}
        @{"DoIO" LINK "DoIO"}, @{"CheckIO" LINK "CheckIO"}, @{"WaitIO" LINK "WaitIO"}, @{"AbortIO" LINK "AbortIO"}

@ENDNODE
@NODE "SetExcept" "exec.library/SetExcept()"
@{b}

   NAME@{ub}
        @{"SetExcept" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 205} -- define certain signals to cause exceptions@{b}

   SYNOPSIS@{ub}
        oldSignals = @{"SetExcept" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 205}(newSignals, signalMask)
        D0                     D0          D1

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"SetExcept" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 205}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This function defines which of the task's signals will cause a
        private task exception.  When any of the signals occurs the task's
        exception handler will be dispatched.  If the signal occurred prior
        to calling @{"SetExcept" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 205}, the exception will happen immediately.

        The user function pointed to by the task's tc_ExceptCode gets
        called as:

            newExcptSet = <exceptCode>(signals, exceptData),SysBase
            D0                         D0       A1          A6

            signals - The set of signals that caused this exception.  These
                Signals have been disabled from the current set of signals
                that can cause an exception.

            exceptData - A copy of the task structure tc_ExceptData field.

            newExcptSet - The set of signals in NewExceptSet will be re-
                enabled for exception generation.  Usually this will be the
                same as the Signals that caused the exception.@{b}

   INPUTS@{ub}
        newSignals - the new values for the signals specified in
                signalMask.
        signalMask - the set of signals to be effected@{b}

   RESULTS@{ub}
        oldSignals - the prior exception signals@{b}

   EXAMPLE@{ub}
        Get the current state of all exception signals:
            @{"SetExcept" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 205}(0,0)
        Change a few exception signals:
            @{"SetExcept" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 205}($1374,$1074)@{b}

   SEE ALSO@{ub}
        @{"Signal" LINK "Signal"}, @{"SetSignal" LINK "SetSignal"}

@ENDNODE
@NODE "SetFunction" "exec.library/SetFunction()"
@{b}

   NAME@{ub}
        @{"SetFunction" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 277} -- change a function vector in a library@{b}

   SYNOPSIS@{ub}
        oldFunc = @{"SetFunction" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 277}(library, funcOffset, funcEntry)
        D0                    A1       A0.W        D0

        @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} @{"SetFunction" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 277}(@{"struct Library" LINK "gg:doc/NDK/Guide/Include/exec/libraries.h/File" 34} *,@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51},@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        @{"SetFunction" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 277} is a functional way of changing where vectors in a
        library point.  They are changed in such a way that the
        checksumming process will never falsely declare a library to be
        invalid.@{b}

   WARNING@{ub}
        If you use @{"SetFunction" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 277} on a function that can be called from
        interrupts, you are obligated to provide your own arbitration.@{b}

   NOTE@{ub}
        @{"SetFunction" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 277} cannot be used on non-standard libraries like pre-V36
        @{"dos.library" LINK "gg:doc/NDK/Guide/dos/MAIN"}.  Here you must manually @{"Forbid()" LINK "Forbid"}, preserve all 6
        original bytes, set the new vector, @{"SumLibrary()" LINK "SumLibrary"}, then @{"Permit()" LINK "Permit"}.@{b}

   INPUTS@{ub}
        library    - a pointer to the library to be changed
        funcOffset - the offset of the function to be replaced
        funcEntry  - pointer to new function@{b}

   RESULTS@{ub}
        oldFunc    - pointer to the old function that was just replaced

@ENDNODE
@NODE "SetIntVector" "exec.library/SetIntVector()"
@{b}

   NAME@{ub}
        @{"SetIntVector" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 105} -- set a new handler for a system interrupt vector@{b}

   SYNOPSIS@{ub}
        oldInterrupt = @{"SetIntVector" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 105}(intNumber, interrupt)
        D0                          D0         A1

        @{"struct Interrupt" LINK "gg:doc/NDK/Guide/Include/exec/interrupts.h/File" 22} *@{"SetIntVector" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 105}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"struct Interrupt" LINK "gg:doc/NDK/Guide/Include/exec/interrupts.h/File" 22} *);@{b}

   FUNCTION@{ub}
        This function provides a mechanism for setting the system interrupt
        vectors.  These are non-sharable; setting a new interrupt handler
        disconnects the old one.  Installed handlers are responsible for
        processing, enabling and clearing the interrupt.  Note that interrupts
        may have been left in any state by the previous code.

        The IS_CODE and IS_DATA pointers of the Interrupt structure will
        be copied into a private place by Exec.  A pointer to the previously
        installed Interrupt structure is returned.

        When the system calls the specified interrupt code, the registers are
        setup as follows:

            D0 - scratch
            D1 - scratch (on entry: active
                          interrupts -> equals INTENA & INTREQ)

            A0 - scratch (on entry: pointer to base of custom chips
                          for fast indexing)
            A1 - scratch (on entry: Interrupt's IS_DATA pointer)

            A5 - jump vector register (scratch on call)
            A6 - Exec library base pointer (scratch on call)

            all other registers must be preserved@{b}

   INPUTS@{ub}
        intNum - the Paula interrupt bit number (0..14).  Only non-chained
                 interrupts should be set.  Use @{"AddIntServer()" LINK "AddIntServer"} for server
                 chains.
        interrupt - a pointer to an Interrupt structure containing the
                 handler's entry point and data segment pointer.  A @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                 interrupt pointer will remove the current interrupt and
                 set illegal values for IS_CODE and IS_DATA.

                 By convention, the LN_NAME of the interrupt structure must
                 point a descriptive string so that other users may
                 identify who currently has control of the interrupt.@{b}

   RESULT@{ub}
        A pointer to the prior interrupt structure which had control
        of this interrupt.@{b}

   SEE ALSO@{ub}
        @{"AddIntServer()" LINK "AddIntServer"},exec/interrupts.i,hardware/intbits.i

@ENDNODE
@NODE "SetSignal" "exec.library/SetSignal()"
@{b}

   NAME@{ub}
        @{"SetSignal" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 201} -- define the state of this task's signals@{b}

   SYNOPSIS@{ub}
        oldSignals = @{"SetSignal" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 201}(newSignals, signalMask)
        D0                     D0          D1

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"SetSignal" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 201}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This function can query or modify the state of the current task's
        received signal mask.  Setting the state of signals is considered
        dangerous.  Reading the state of signals is safe.@{b}

   INPUTS@{ub}
        newSignals - the new values for the signals specified in
                     signalSet.
        signalMask - the set of signals to be affected.@{b}

   RESULTS@{ub}
        oldSignals - the prior values for all signals@{b}

   EXAMPLES@{ub}
        Get the current state of all signals:
            @{"SetSignal" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 201}(0L,0L);
        Clear the CTRL-C signal:
            @{"SetSignal" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 201}(0L,@{"SIGBREAKF_CTRL_C" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 245});


        Check if the CTRL-C signal was pressed:

            #include <@{"libraries/dos.h" LINK "gg:doc/NDK/Guide/Include/libraries/dos.h/File"}>

            /* Check & clear CTRL_C signal */
            if(@{"SetSignal" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 201}(0L,@{"SIGBREAKF_CTRL_C" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 245}) & @{"SIGBREAKF_CTRL_C" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 245})
                {
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"}("CTRL-C pressed!\\n");
                }@{b}

   SEE ALSO@{ub}
        @{"Signal" LINK "Signal"}, @{"Wait" LINK "Wait"}

@ENDNODE
@NODE "SetSR" "exec.library/SetSR()"
@{b}

   NAME@{ub}
        @{"SetSR" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 93} -- get and/or set processor status register@{b}

   SYNOPSIS@{ub}
        oldSR = @{"SetSR" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 93}(newSR, mask)
        D0            D0     D1

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"SetSR" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 93}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This function provides a means of modifying the CPU status register
        in a "safe" way (well, how safe can a function like this be
        anyway?).  This function will only affect the status register bits
        specified in the mask parameter.  The prior content of the entire
        status register is returned.@{b}

   INPUTS@{ub}
        newSR - new values for bits specified in the mask.
            All other bits are not effected.
        mask - bits to be changed@{b}

   RESULTS@{ub}
        oldSR - the entire status register before new bits@{b}

   EXAMPLES@{ub}
        To get the current SR:
            currentSR = @{"SetSR" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 93}(0,0);
        To change the processor interrupt level to 3:
            oldSR = @{"SetSR" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 93}($0300,$0700);
        Set processor interrupts back to prior level:
            @{"SetSR" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 93}(oldSR,$0700);

@ENDNODE
@NODE "SetTaskPri" "exec.library/SetTaskPri()"
@{b}

   NAME@{ub}
        @{"SetTaskPri" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 197} -- get and set the priority of a task@{b}

   SYNOPSIS@{ub}
        oldPriority = @{"SetTaskPri" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 197}(task, priority)
        D0-0:8                   A1    D0-0:8

        @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} @{"SetTaskPri" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 197}(@{"struct Task" LINK "gg:doc/NDK/Guide/Include/exec/tasks.h/File" 24} *,@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        This function changes the priority of a task regardless of its
        state.  The old priority of the task is returned.  A reschedule is
        performed, and a context switch may result.

        To change the priority of the currently running task, pass the
        result of @{"FindTask" LINK "FindTask"}(0); as the task pointer.@{b}

   INPUTS@{ub}
        task - task to be affected
        priority - the new priority for the task@{b}

   RESULT@{ub}
        oldPriority - the tasks previous priority

@ENDNODE
@NODE "Signal" "exec.library/Signal()"
@{b}

   NAME@{ub}
        Signal -- signal a task@{b}

   SYNOPSIS@{ub}
        Signal(task, signals)
               A1    D0

        void Signal(@{"struct Task" LINK "gg:doc/NDK/Guide/Include/exec/tasks.h/File" 24} *,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This function signals a task with the given signals.  If the task
        is currently waiting for one or more of these signals, it will be
        made ready and a reschedule will occur. If the task is not waiting
        for any of these signals, the signals will be posted to the task
        for possible later use. A signal may be sent to a task regardless
        of whether it is running, ready, or waiting.

        This function is considered "low level".  Its main purpose is to
        support multiple higher level functions like @{"PutMsg" LINK "PutMsg"}.

        This function is safe to call from interrupts.@{b}

   INPUT@{ub}
        task - the task to be signalled
        signals - the signals to be sent@{b}

   SEE ALSO@{ub}
        @{"Wait" LINK "Wait"}, @{"SetSignal" LINK "SetSignal"}

@ENDNODE
@NODE "StackSwap" "exec.library/StackSwap()"
@{b}

   NAME@{ub}
        @{"StackSwap" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 473} - EXEC supported method of replacing task's stack      (V37)@{b}

   SYNOPSIS@{ub}
        @{"StackSwap" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 473}(newStack)
                  A0

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"StackSwap" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 473}(@{"struct StackSwapStruct" LINK "gg:doc/NDK/Guide/Include/exec/tasks.h/File" 52} *);@{b}

   FUNCTION@{ub}
        This function will, in an EXEC supported manner, swap the
        stack of your task with the given values in @{"StackSwap" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 473}.
        The StackSwapStruct structure will then contain the values
        of the old stack such that the old stack can be restored.
        This function is new in V37.@{b}

   NOTE@{ub}
        If you do a stack swap, only the new stack is set up.
        This function does not copy the stack or do anything else
        other than set up the new stack for the task.  It is
        generally required that you restore your stack before
        exiting.@{b}

   INPUTS@{ub}
        newStack - A structure that contains the values for the
                new upper and lower stack bounds and the new stack
                pointer.  This structure will have its values
                replaced by those in you task such that you can
                restore the stack later.@{b}

   RESULTS@{ub}
        newStack - The structure will now contain the old stack.
                This means that @{"StackSwap" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 473}(foo); @{"StackSwap" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 473}(foo);
                will effectively do nothing.@{b}

   SEE ALSO@{ub}
        @{"AddTask" LINK "AddTask"}, @{"RemTask" LINK "RemTask"}, @{"exec/tasks.h" LINK "gg:doc/NDK/Guide/Include/exec/tasks.h/File"}

@ENDNODE
@NODE "SumKickData" "exec.library/SumKickData()"
@{b}

   NAME@{ub}
        @{"SumKickData" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 393} -- compute the checksum for the Kickstart delta list@{b}

   SYNOPSIS@{ub}
        checksum = @{"SumKickData" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 393}()
        D0

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"SumKickData" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 393}(void);@{b}

   FUNCTION@{ub}
        The Amiga system has some ROM (or Kickstart) resident code that
        provides the basic functions for the machine.  This code is
        unchangeable by the system software.  This function is part of a
        support system to modify parts of the ROM.

        The ROM code is linked together at run time via ROMTags (also known
        as Resident structures, defined in @{"exec/resident.h" LINK "gg:doc/NDK/Guide/Include/exec/resident.h/File"}).  These tags tell
        Exec's low level boot code what subsystems exist in which regions of
        memory.  The current list of ROMTags is contained in the ResModules
        field of ExecBase.  By default this list contains any ROMTags found
        in the address ranges $F80000-$FFFFFF and $F00000-$F7FFFF.

        There is also a facility to selectively add or replace modules to the
        ROMTag list.  These modules can exist in RAM, and the memory they
        occupy will be deleted from the memory free list during the boot
        process.  @{"SumKickData" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 393}() plays an important role in this run-time
        modification of the ROMTag array.

        Three variables in ExecBase are used in changing the ROMTag array:
        KickMemPtr, KickTagPtr, and KickCheckSum. KickMemPtr points to a
        linked list of MemEntry structures. The memory that these MemEntry
        structures reference will be allocated (via @{"AllocAbs" LINK "AllocAbs"}) at boot time.
        The MemEntry structure itself must also be in the list.

        KickTagPtr points to a long-word array of the same format as the
        ResModules array.  The array has a series of pointers to ROMTag
        structures.  The array is either @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} terminated, or will have an
        entry with the most significant bit (bit 31) set.  The most
        significant bit being set says that this is a link to another
        long-word array of ROMTag entries.  This new array's address can be
        found by clearing bit 31.

        KickCheckSum has the result of @{"SumKickData" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 393}().  It is the checksum of
        both the KickMemPtr structure and the KickTagPtr arrays.  If the
        checksum does not compute correctly then both KickMemPtr and
        KickTagPtr will be ignored.

        If all the memory referenced by KickMemPtr can't be allocated then
        KickTagPtr will be ignored.

        There is one more important caveat about adding ROMTags. All this
        ROMTag magic is run very early on in the system -- before expansion
        memory is added to the system. Therefore any memory in this
        additional ROMTag area must be addressable at this time. This means
        that your ROMTag code, MemEntry structures, and resident arrays
        cannot be in expansion memory.  There are two regions of memory that
        are acceptable:  one is chip memory, and the other is "Ranger" memory
        (memory in the range between $C00000-$D80000).

        Remember that changing an existing ROMTag entry falls into the
        "heavy magic" category -- be very careful when doing it.  The odd are
        that you will blow yourself out of the water.@{b}

   NOTE@{ub}
        @{"SumKickData" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 393} was introduced in the 1.2 release@{b}

   RESULT@{ub}
        Value to be stuffed into ExecBase->KickCheckSum.@{b}

   WARNING@{ub}
        After writing to KickCheckSum, you should push the data cache.
        This prevents potential problems with large copyback style caches.
        A call to @{"CacheClearU" LINK "CacheClearU"} will do fine.@{b}

   SEE ALSO@{ub}
        @{"InitResident" LINK "InitResident"}, @{"FindResident" LINK "FindResident"}

@ENDNODE
@NODE "SumLibrary" "exec.library/SumLibrary()"
@{b}

   NAME@{ub}
        @{"SumLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 281} -- compute and check the checksum on a library@{b}

   SYNOPSIS@{ub}
        @{"SumLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 281}(library)
                   A1

        void @{"SumLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 281}(@{"struct Library" LINK "gg:doc/NDK/Guide/Include/exec/libraries.h/File" 34} *);@{b}

   FUNCTION@{ub}
        @{"SumLibrary" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 281} computes a new checksum on a library.  It can also be
        used to check an old checksum.  If an old checksum does not match,
        and the library has not been marked as changed, then the system
        will call @{"Alert()" LINK "Alert"}.

        This call could also be periodically made by some future
        system-checking task.@{b}

   INPUTS@{ub}
        library - a pointer to the library to be changed@{b}

   NOTE@{ub}
        An alert will occur if the checksum fails.@{b}

   SEE ALSO@{ub}
        @{"SetFunction" LINK "SetFunction"}

@ENDNODE
@NODE "SuperState" "exec.library/SuperState()"
@{b}

   NAME@{ub}
        @{"SuperState" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 97} -- enter supervisor state with user stack@{b}

   SYNOPSIS@{ub}
        oldSysStack = @{"SuperState" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 97}()
        D0

        @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} @{"SuperState" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 97}(void);@{b}

   FUNCTION@{ub}
        Enter supervisor mode while running on the user's stack. The user
        still has access to user stack variables.  Be careful though, the
        user stack must be large enough to accommodate space for all
        interrupt data -- this includes all possible nesting of interrupts.
        This function does nothing when called from supervisor state.@{b}

   RESULTS@{ub}
        oldSysStack - system stack pointer; save this.  It will come in
                      handy when you return to user state.  If the system
                      is already in supervisor mode, oldSysStack is zero.@{b}

   SEE ALSO@{ub}
        @{"UserState" LINK "UserState"}/@{"Supervisor" LINK "Supervisor"}

@ENDNODE
@NODE "Supervisor" "exec.library/Supervisor()"
@{b}

   NAME@{ub}
        Supervisor -- trap to a short supervisor mode function@{b}

   SYNOPSIS@{ub}
        result = Supervisor(userFunc)
        Rx                   A5

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} Supervisor(void *);@{b}

   FUNCTION@{ub}
        Allow a normal user-mode program to execute a short assembly language
        function in the supervisor mode of the processor.  Supervisor() does
        not modify or save registers; the user function has full access to the
        register set.   All rules that apply to interrupt code must be
        followed.  In addition, no system calls are permitted.  The function
        must end with an RTE instruction.@{b}

   EXAMPLE@{ub}
                ;Obtain the Exception Vector base.  68010 or greater only!
                MOVECtrap:      movec.l VBR,d0  ;$4e7a,$0801
                                rte@{b}

   INPUTS@{ub}
        userFunc - A pointer to a short assembly language function ending
                   in RTE.  The function has full access to the register set.@{b}

   RESULTS@{ub}
        result   - Whatever values the userFunc left in the registers.@{b}

   SEE ALSO@{ub}
        @{"SuperState" LINK "SuperState"},@{"UserState" LINK "UserState"}

@ENDNODE
@NODE "TypeOfMem" "exec.library/TypeOfMem()"
@{b}

   NAME@{ub}
        @{"TypeOfMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 341} -- determine attributes of a given memory address@{b}

   SYNOPSIS@{ub}
        attributes = @{"TypeOfMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 341}(address)
        D0                     A1

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"TypeOfMem" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 341}(void *);@{b}

   FUNCTION@{ub}
        Given a RAM memory address, search the system memory lists and
        return its memory attributes.  The memory attributes are similar to
        those specified when the memory was first allocated: (eg. @{"MEMF_CHIP" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 70}
        and @{"MEMF_FAST" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File" 71}).

        This function is usually used to determine if a particular block of
        memory is within CHIP space.

        If the address is not in known-space, a zero will be returned.
        (Anything that is not RAM, like the ROM or expansion area, will
        return zero.  Also the first few bytes of a memory area are used up
        by the MemHeader.)@{b}

   INPUT@{ub}
        address - a memory address@{b}

   RESULT@{ub}
        attributes - a long word of memory attribute flags.
        If the address is not in known RAM, zero is returned.@{b}

   SEE ALSO@{ub}
        @{"AllocMem()" LINK "AllocMem"}

@ENDNODE
@NODE "UserState" "exec.library/UserState()"
@{b}

   NAME@{ub}
        @{"UserState" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 101} -- return to user state with user stack@{b}

   SYNOPSIS@{ub}
        @{"UserState" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 101}(sysStack)
                  D0

        void @{"UserState" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 101}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        Return to user state with user stack, from supervisor state with
        user stack.  This function is normally used in conjunction with the
        @{"SuperState" LINK "SuperState"} function above.

        This function must not be called from the user state.@{b}

   INPUT@{ub}
        sysStack - supervisor stack pointer@{b}

   BUGS@{ub}
        This function is broken in V33/34 Kickstart.  Fixed in V1.31 setpatch.@{b}

   SEE ALSO@{ub}
        @{"SuperState" LINK "SuperState"}/@{"Supervisor" LINK "Supervisor"}

@ENDNODE
@NODE "Vacate" "exec.library/Vacate()"
@{b}

   NAME@{ub}
        Vacate -- release a bitMessage from @{"Procure()" LINK "Procure"}                    (V39)@{b}

   SYNOPSIS@{ub}
        Vacate(semaphore, bidMessage)
               A0         A1

        void Vacate(@{"struct SignalSemaphore" LINK "gg:doc/NDK/Guide/Include/exec/semaphores.h/File" 40} *,@{"struct SemaphoreMessage" LINK "gg:doc/NDK/Guide/Include/exec/semaphores.h/File" 51} *);@{b}

   FUNCTION@{ub}
        This function can be used to release a semaphore obtained via
        @{"Procure()" LINK "Procure"}.  However, the main purpose for this call is to be
        able to remove a bid for a semaphore that has not yet responded.
        This is required when a @{"Procure()" LINK "Procure"} was issued and the program
        no longer needs to get the semaphore and wishes to cancel the
        @{"Procure()" LINK "Procure"} request.  The canceled request will be replied with
        the ssm_Semaphore field set to @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.  If you own the semaphore,
        the message was already replied and only the ssm_Semaphore field
        will be cleared.

        NOTE:  Pre-V39, @{"Procure()" LINK "Procure"} and Vacate() did not work correctly.
        They also did not operate on SignalSemaphore semaphores.
        Old (and broken) MessageSemaphore use as of V39 will no longer work.@{b}

   INPUT@{ub}
        semaphore - The SignalSemaphore that you wish to Vacate()
        bidMessage- The SemaphoreMessage that you wish to abort.
                The message's ssm_Semaphore field will be cleared.
                The message will be replied if it is still on the waiting
                list.  If it is not on the waiting list, it is assumed
                that the semaphore is owned and it will be released.@{b}

   BUGS@{ub}
        Before V39, @{"Procure()" LINK "Procure"} and Vacate() used a different semaphore
        system that was very broken.  This new system is only available
        as of V39 even though the LVOs are the same.@{b}

   SEE ALSO@{ub}
        @{"ObtainSemaphoreShared()" LINK "ObtainSemaphoreShared"}, @{"InitSemaphore()" LINK "InitSemaphore"}, @{"ReleaseSemaphore()" LINK "ReleaseSemaphore"},
        @{"AttemptSemaphore()" LINK "AttemptSemaphore"}, @{"ObtainSemaphoreList()" LINK "ObtainSemaphoreList"}, @{"Procure()" LINK "Procure"}, @{"ObtainSemaphore()" LINK "ObtainSemaphore"}

@ENDNODE
@NODE "Wait" "exec.library/Wait()"
@{b}

   NAME@{ub}
        Wait -- wait for one or more signals@{b}

   SYNOPSIS@{ub}
        signals = Wait(signalSet)
        D0             D0

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} Wait(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This function will cause the current task to suspend waiting for
        one or more signals.  When one or more of the specified signals
        occurs, the task will return to the ready state, and those signals
        will be cleared.

        If a signal occurred prior to calling Wait(), the wait condition will
        be immediately satisfied, and the task will continue to run without
        delay.@{b}

   CAUTION@{ub}
        This function cannot be called while in supervisor mode or
        interrupts!  This function will break the action of a @{"Forbid()" LINK "Forbid"} or
        @{"Disable()" LINK "Disable"} call.@{b}

   INPUT@{ub}
        signalSet - The set of signals for which to wait.
                    Each bit represents a particular signal.@{b}

   RESULTS@{ub}
        signals - the set of signals that were active

@ENDNODE
@NODE "WaitIO" "exec.library/WaitIO()"
@{b}

   NAME@{ub}
        @{"WaitIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 313} -- wait for completion of an I/O request@{b}

   SYNOPSIS@{ub}
        error = @{"WaitIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 313}(iORequest)
        D0             A1

        @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} @{"WaitIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 313}(@{"struct IORequest" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 18} *);@{b}

   FUNCTION@{ub}
        This function waits for the specified I/O request to complete, then
        removes it from the replyport.  If the I/O has already completed,
        this function will return immediately.

        This function should be used with care, as it does not return until
        the I/O request completes; if the I/O never completes, this
        function will never return, and your task will hang.  If this
        situation is a possibility, it is safer to use the @{"Wait()" LINK "Wait"} function.
        @{"Wait()" LINK "Wait"} will return return when any of a specified set of signal is
        received.  This is how I/O timeouts can be properly handled.@{b}

   WARNING@{ub}
        If this IORequest was "Quick" or otherwise finished BEFORE this
        call, this function drops though immediately, with no call to
        @{"Wait()" LINK "Wait"}.  A side effect is that the signal bit related the port may
        remain set.  Expect this.

        When removing a known complete IORequest from a port, @{"WaitIO" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 313}() is the
        preferred method.  A simple @{"Remove()" LINK "Remove"} would require a Disable/Enable
        pair!@{b}

   INPUTS@{ub}
        iORequest - pointer to an I/O request block@{b}

   RESULTS@{ub}
        error - zero if successful, else an error is returned
                (a sign extended copy of io_Error).@{b}

   SEE ALSO@{ub}
        @{"DoIO" LINK "DoIO"}, @{"SendIO" LINK "SendIO"}, @{"CheckIO" LINK "CheckIO"}, @{"AbortIO" LINK "AbortIO"}

@ENDNODE
@NODE "WaitPort" "exec.library/WaitPort()"
@{b}

   NAME@{ub}
        @{"WaitPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 253} -- wait for a given port to be non-empty@{b}

   SYNOPSIS@{ub}
        message = @{"WaitPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 253}(port)
        D0                 A0

        @{"struct Message" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 47} *@{"WaitPort" LINK "gg:doc/NDK/Guide/Include/inline/exec.h/File" 253}(@{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *);@{b}

   FUNCTION@{ub}
        This function waits for the given port to become non-empty.  If
        necessary, the @{"Wait()" LINK "Wait"} function will be called to wait for the port
        signal.  If a message is already present at the port, this function
        will return immediately.  The return value is always a pointer to
        the first message queued (but it is not removed from the queue).@{b}

   CAUTION@{ub}
        More than one message may be at the port when this returns.  It is
        proper to call the @{"GetMsg()" LINK "GetMsg"} function in a loop until all messages
        have been handled, then wait for more to arrive.

        To wait for more than one port, combine the signal bits from each
        port into one call to the @{"Wait()" LINK "Wait"} function, then use a @{"GetMsg()" LINK "GetMsg"} loop
        to collect any and all messages.  It is possible to get a signal
        for a port WITHOUT a message showing up.  Plan for this.@{b}

   INPUT@{ub}
        port - a pointer to the message port@{b}

   RETURN@{ub}
        message - a pointer to the first available message@{b}

   SEE ALSO@{ub}
        @{"GetMsg" LINK "GetMsg"}

@ENDNODE
@NODE "Overview" "SAD/Overview (information)"


        Simple Amiga Debugging Kernel, known as "SAD"
        It is in EXEC starting in V39


                -- General description --

 The Simple Amiga Debugging Kernel (SAD) is a set of very simple control
 routines stored in the Kickstart ROM that would let debuggers control the
 Amiga's development enviroment from the outside.  These tools would make
 it possible to do remote machine development/debugging via just the
 on-board serial port.

 This set of control routines is very simple and yet completely flexible,
 thus making it possible to control the whole machine.


                -- Technical Issues --

 SAD will make use of the motherboard serial port that exists in all
 Amiga systems.  The connection via the serial port lets the system be
 able to execute SAD without needing any of the system software up and
 running. (SAD will play with the serial port directly)

 With some minor changes to the Amiga hardware, an NMI-like line could
 be hooked up to a pin on the serial port.  This would let external
 control of the machine and would let the external controller stop the
 machine no matter what state it is in.  (NMI is that way)

 In order to function correctly, SAD requires the some of the EXEC
 CPU control functions work and that ExecBase be valid.  Beyond that,
 SAD does not require the OS to be running.


                -- Command Overview --

 The basic commands needed to operate SAD are as follows:

 Read and Write memory as byte, word, and longword.
 Get the register frame address (contains all registers)
 JSR to Address
 Return to system operation  (return from interrupt)

 These basic routines will let the system do whatever is needed.
 Since the JSR to address and memory read/write routines can be used
 to download small sections of code that could be used to do more
 complex things, this basic command set is thus flexible enough
 to even replace itself.

 Caches will automatically be flushed as needed after each write.
 (A call to @{"CacheClearU()" LINK "gg:doc/NDK/Guide/exec/CacheClearU"} will be made after the write and before
 the command done sequence)


                -- Technical Command Descriptions --

 Since the communications with SAD is via a serial port, data formats
 have been defined for minimum overhead while still giving reasonable data
 reliability.  SAD will use the serial port at default 9600 baud but the
 external tools can change the serial port's data rate if it wishes.  It
 would need to make sure that it will be able to reconnect.  SAD sets
 the baud rate to 9600 each time it is entered.  However, while within
 SAD, a simple command to write a @{"WORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 54} to the SERPER register would
 change the baud rate.  This will remain in effect until you exit and
 re-enter SAD or until you change the register again.  (This can be usefull
 if you need to transfer a large amount of data)

 All commands have a basic format that they will follow.  All commands have
 both an ACK and a completion message.

 Basic command format is:

 SENDER:        $AF <command byte> [<data bytes as needed by command>]

 Receive:
 Command ACK:  $00 <command byte>

 Command Done: $1F <command byte> [<data if needed>]

 Waiting: $53 $41 $44 $BF

 Waiting when called from @{"Debug()" LINK "gg:doc/NDK/Guide/exec/Debug"}:      $53 $41 $44 $3F

 Waiting when in dead-end crash:        $53 $41 $44 $21

 The data sequence will be that SAD will emit a $BF and then wait for a
 command. If no command is received within <2> seconds, it will emit $BF
 again and loop back.  (This is the "heart beat" of SAD)  When called from
 @{"Debug()" LINK "gg:doc/NDK/Guide/exec/Debug"} and not the NMI hook, SAD will use $3F as the "heart beat"

 If SAD does not get a responce after <10> heartbeats, it will return to
 the system.  (Execute an RTS or RTE as needed)  This is to prevent a full
 hang.  The debugger at the other end can keep SAD happy by sending a
 NO-OP command.

 All I/O in SAD times out.  During the transmition of a command, if
 more than 2 seconds pass between bytes of data SAD will time out
 and return to the prompt.  This is mainly to help make sure that
 SAD can never get into an i-loop situation.


                -- Data Structure Issues --

 While executing in SAD, you may have full access to machine from the CPU
 standpoint.  However, this could also be a problem.  It is important to
 understand that when entered via NMI that many system lists may be in
 unstable state.  (NMI can happen in the middle of the @{"AllocMem" LINK "gg:doc/NDK/Guide/exec/AllocMem"} routine
 or task switch, etc)

 Also, since you are doing debugging, it is up to you to determin what
 operations can be done and what can not be done.  A good example is
 that if you want to write a @{"WORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 54} or @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} that the address will need to
 be even on 68000 processors.  Also, if you read or write memory that does
 not exist, you may get a bus error.  Following system structures may
 require that you check the pointers at each step.

 When entered via @{"Debug()" LINK "gg:doc/NDK/Guide/exec/Debug"}, you are now running as a "task" so you will
 be able to assume some things about system structures.  This means that
 you are in supervisor state and that you can assume that the
 system is at least not between states.  However, remember that since
 you are debugging the system, some bad code could cause data structures
 to be invalid.  Again, standard debugging issues are in play.  SAD just
 gives you the hooks to do whatever you need.

 Note:  When SAD prompts with $BF you will be in full disable/forbid
 state.  When $3F prompting, SAD will only do a @{"Forbid()" LINK "gg:doc/NDK/Guide/exec/Forbid"}.  It is possible
 for you to then disable interrupts as needed.  This is done such that it
 is possible to "run" the system from SAD when called with @{"Debug()" LINK "gg:doc/NDK/Guide/exec/Debug"}.


                -- Data Frames and the Registers --

 SAD generates a special data frame that can be used to read what
 registers contain and to change the contents of the registers.
 See the entry for @{"GET_CONTEXT_FRAME" LINK "gg:doc/NDK/Guide/exec/GET_CONTEXT_FRAME"} for more details

 ----------------------------------------------------------------------------
-

 BUGS
        In V39 EXEC, the @{"WRITE_BYTE" LINK "gg:doc/NDK/Guide/exec/WRITE_BYTE"} command was not connected and this
        caused all of the command numbers to be off-by-one.  For example,
        the @{"READ_WORD" LINK "gg:doc/NDK/Guide/exec/READ_WORD"} command is listed as command $05 but in V39 is $04.
        However, the ACK of the commands are still correct.

        Also, in V39 EXEC, the @{"READ_WORD" LINK "gg:doc/NDK/Guide/exec/READ_WORD"} command would return the wrong
        data.

        To determin if you are in V39 or V40 SAD, you can issue a simple
        SAD command at the start of the session.  By sending a @{"READ_WORD" LINK "gg:doc/NDK/Guide/exec/READ_WORD"}
        command, you may either get a @{"READ_WORD" LINK "gg:doc/NDK/Guide/exec/READ_WORD"} (V40) or a @{"READ_LONG" LINK "gg:doc/NDK/Guide/exec/READ_LONG"} (V39)
        ACK'ed back.  So the data stream for a safe test would be:

        Send: $AF $05 $00 $F8 $00 $00               ; Read start of ROM...
        Recv: $00 $05 ....   You have V40 SAD
        Recv: $00 $06 ....   You have V39 SAD

        Note that you should be ready to read either 2 or 4 bytes of
        result depending on the ACK sent by the system.

@ENDNODE
@NODE "ALLOCATE_MEMORY" "SAD/ALLOCATE_MEMORY"


 ALLOCATE MEMORY

 Command:       $AF $0A
 Data:          $qq $rr $ss $tt $hh $ii $jj $kk

 Allocate a chunk of memory that is <$qqrrsstt> bytes in size.  Note
 that this call is only safe when SAD is in $3F prompting mode (called
 from @{"Debug()" LINK "Debug"}) and even then may be unsafe if the system is in bad shape.
 (You are debugging after all)  The returned address will be available to
 you until you release it.  (It is obtained via a call to @{"AllocVec()" LINK "AllocVec"})  The
 type of memory allocated is <$hhiijjkk>.  Note that the allocation may
 fail. In that case, the address returned will be $00000000.

 Command ACK:   $00 $0A
 Command DONE:  $1F $0A $ww $xx $yy $zz

@ENDNODE
@NODE "CALL_ADDRESS" "SAD/CALL_ADDRESS"


 CALL ADDRESS - JSR to the given address.

 Command:       $AF $07
 Data:          $ww $xx $yy $zz

 Call the following address as a subroutine.  No registers will be
 set up but the context frame will exist.  Standard calling
 conventions apply (d0/d1/a0/a1 are available, rest must be saved)
 The command will be ACK'ed when received.
 Command ACK:   $00 $07
 Command DONE:  $1F $07

@ENDNODE
@NODE "FREE_MEMORY" "SAD/FREE_MEMORY"


 FREE MEMORY

 Command:       $AF $0B
 Data:          $ww $xx $yy $zz

 Free the memory allocated with the ALLOCATE MEMORY command.  This command
 has the same restrictions as ALLOCATE MEMORY.  Memory is released by
 calling @{"FreeVec()" LINK "FreeVec"} on the address <$wwxxyyzz>

 Command ACK:   $00 $0B
 Command DONE:  $1F $0B

@ENDNODE
@NODE "GET_CONTEXT_FRAME" "SAD/GET_CONTEXT_FRAME"


 GET CONTEXT FRAME

 Command:       $AF $09
 Data:          <none>

 This command will return a pointer to the saved context.  This will be
 a pointer to all of the registers that were saved on the stack along
 with some other details.  Returns frame address <$wwxxyyzz>

 The pointer returned is to the following structure:

 STRUCTURE      SAD_FRAME,0
        ; The first three are READ-ONLY...  Mainly used to make it
        ; easier to understand what is going on in the system.
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_VBR         ; Current VBR (always 0 on 68000 CPUs)
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_AttnFlags   ; @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} copy of the flags (UPPER @{"WORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 54}==0)
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_ExecBase    ; ExecBase
        ; These fields are the user registers...  The registers are
        ; restored from these fields on exit from SAD...
        ; Note that USP is only valid if SR was *@{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500}* supervisor...
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_USP         ; User stack pointer
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_D0          ; User register d0
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_D1          ; User register d1
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_D2          ; User register d2
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_D3          ; User register d3
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_D4          ; User register d4
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_D5          ; User register d5
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_D6          ; User register d6
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_D7          ; User register d7
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_A0          ; User register a0
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_A1          ; User register a1
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_A2          ; User register a2
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_A3          ; User register a3
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_A4          ; User register a4
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_A5          ; User register a5
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_A6          ; User register a6
        ; This is for SAD internal use...  It is the prompt that
        ; SAD is using...  Changing this will have no effect on SAD.
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_PROMPT      ; SAD Prompt Longword...  (internal use)
        ; From here on down is the standard exception frame
        ; The first two entries (SR and PC) are standard on all 680x0 CPUs
        @{"UWORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 55}   SAD_SR          ; Status register (part of exception frame)
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   SAD_PC          ; Return address (part of exception frame)


 Command ACK:   $00 $09
 Command DONE:  $1F $09 $ww $xx $yy $zz

@ENDNODE
@NODE "NOP" "SAD/NOP"


 NO-OP - Do nothing other than tell SAD you are still there...

 Command:       $AF $00
 Data:          <none>

 This just tells SAD you are still there.  Required so that timeouts do
 not exit SAD while you are not doing anything.

 This command will *@{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500}* be ACK'ed.  It will just cause the timeout to
 be restarted.

@ENDNODE
@NODE "READ_ARRAY" "SAD/READ_ARRAY"


 READ ARRAY - Read a range of bytes

 Command:       $AF $0F
 Data:          $ww $xx $yy $zz $qq $rr $ss $tt

 Read a range of bytes from address <$wwxxyyzz> for <$qqrrsstt> bytes
 Will return that number of bytes...

 Command will be ACK'ed when received.
 Command ACK:   $00 $0F
 Command DONE:  $1F $0F $uu [$uu ...]

@ENDNODE
@NODE "READ_BYTE" "SAD/READ_BYTE"


 READ @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} - Read a byte from the given address

 Command:       $AF $04
 Data:          $ww $xx $yy $zz

 Read a byte from address <$wwxxyyzz>  Returns <$qq> as result

 Command will be ACK'ed when received.
 Command ACK:   $00 $04
 Command DONE:  $1F $04 $qq

@ENDNODE
@NODE "READ_LONG" "SAD/READ_LONG"


 READ @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} - Read a long from the given address

 Command:       $AF $06
 Data:          $ww $xx $yy $zz

 Read a long from address <$wwxxyyzz>  Returns <$qqrrsstt> as result

 Command will be ACK'ed when received.
 Command ACK:   $00 $06
 Command DONE:  $1F $06 $qq $rr $ss $tt

@ENDNODE
@NODE "READ_WORD" "SAD/READ_WORD"


 READ @{"WORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 54} - Read a word from the given address         (V40 SAD)

 Command:       $AF $05
 Data:          $ww $xx $yy $zz

 Read a word from address <$wwxxyyzz>  Returns <$qqrr> as result

 Command will be ACK'ed when received.
 Command ACK:   $00 $05
 Command DONE:  $1F $05 $qq $rr

 BUGS
        This command does not return correct values in pre-V40 EXEC.

@ENDNODE
@NODE "RESET" "SAD/RESET"


 RESET - Reset the computer...

 Command:       $AF $10
 Data:          $FF $FF $FF $FF

 This command will reset the computer.  the $FFFFFFFF value is there
 mainly to prevent false reset.  This command will only be ACK'ed as
 the computer will be reset afterwards...

 Command will be ACK'ed when received.
 Command ACK:   $00 $10

@ENDNODE
@NODE "RETURN_TO_SYSTEM" "SAD/RETURN_TO_SYSTEM"


 RETURN TO SYSTEM

 Command:       $AF $08
 Data:          $00 $00 $00 $00

 This command will return <exit> from SAD back to whatever started it.
 The 4 $00 are required as a "safty" to this command.  The command
 will be ACK'ed only as it will have lost control of the system.

 Command ACK:   $00 $08

@ENDNODE
@NODE "TURN_OFF_SINGLE" "SAD/TURN_OFF_SINGLE"


 TURN OFF @{"SINGLE" LINK "gg:doc/NDK/Guide/Include/intuition/preferences.h/File" 175} STEPPING

 Command:       $AF $0D
 Data:          $ww $xx $yy $zz

 This command will turn off SAD single stepping mode.  You need to pass
 to it the address returned from the call to turn on single stepping mode.

 Command ACK:   $00 $0D
 Command DONE:  $1F $0D

@ENDNODE
@NODE "TURN_ON_SINGLE" "SAD/TURN_ON_SINGLE"


 TURN ON @{"SINGLE" LINK "gg:doc/NDK/Guide/Include/intuition/preferences.h/File" 175} STEPPING

 Command:       $AF $0C
 Data:          <none>

 This command will turn on SAD single stepping mode.  This means that SAD
 will single step (via 68000 trace mode) the system.  SAD will take over
 the TRACE exception vector during this time.  This command will return
 the contents of the vector such that you can return this value when
 you wish to turn off single stepping mode.  Note that turning on single
 stepping mode while in $BF prompting will cause the step to be taken
 and then SAD will execute in $3F mode (non-NMI)
 The command returns <$wwxxyyzz> which you must use when turning off
 the single-step mode.

 Command ACK:   $00 $0C
 Command DONE:  $1F $0C $ww $xx $yy $zz

@ENDNODE
@NODE "WRITE_ARRAY" "SAD/WRITE_ARRAY"


 WRITE ARRAY - Write a range of bytes

 Command:       $AF $0E
 Data:          $ww $xx $yy $zz $qq $rr $ss $tt

 Write a range of bytes to address <$wwxxyyzz> for <$qqrrsstt> bytes
 After the computer sends the ACK, you must then send the byte stream...

 Command will be ACK'ed when received.
 Command ACK:   $00 $0E
 Command DONE:  $1F $0E

@ENDNODE
@NODE "WRITE_BYTE" "SAD/WRITE_BYTE"


 WRITE @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} - Write the given data to the address given (V40 SAD)

 Command:       $AF $01
 Data:          $ww $xx $yy $zz $qq

 Write the byte <$qq> to address <$wwxxyyzz>

 Command will be ACK'ed when received.
 Command ACK:   $00 $01
 Command DONE:  $1F $01

 BUGS
        This command does not exists in pre-V40 EXEC.
        This command can be emulated with the @{"WRITE_ARRAY" LINK "WRITE_ARRAY"} command with
        a length of 1.

@ENDNODE
@NODE "WRITE_LONG" "SAD/WRITE_LONG"


 WRITE @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} - Write the given data to the address given

 Command:       $AF $03
 Data:          $ww $xx $yy $zz $qq $rr $ss $tt

 Write the long <$qqrrsstt> to address <$wwxxyyzz>

 Command will be ACK'ed when received.
 Command ACK:   $00 $03
 Command DONE:  $1F $03

@ENDNODE
@NODE "WRITE_WORD" "SAD/WRITE_WORD"


 WRITE @{"WORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 54} - Write the given data to the address given

 Command:       $AF $02
 Data:          $ww $xx $yy $zz $qq $rr

 Write the word <$qqrr> to address <$wwxxyyzz>

 Command will be ACK'ed when received.
 Command ACK:   $00 $02
 Command DONE:  $1F $02

@ENDNODE
