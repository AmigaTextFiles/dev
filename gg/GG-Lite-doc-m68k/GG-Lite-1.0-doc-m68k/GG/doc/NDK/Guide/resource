@DATABASE "gg:doc/NDK/Guide/resource"
@MASTER   "gg:doc/NDK/AutoDocs/resource.doc"
@REMARK   This file was created by ADtoHT 2.1 on 06-Jan-13 19:24:59
@REMARK   Do not edit
@REMARK   ADtoHT is © 1993-1995 Christian Stieber

@NODE MAIN "resource.doc"
@TOC "gg:doc/NDK/Guide/TOC/MAIN"

                              @{b}resource.library@{ub}

@{"background" LINK "background"}

@{"RL_CloseResource()" LINK "RL_CloseResource"}   @{"RL_DisposeGroup()" LINK "RL_DisposeGroup"}       @{"RL_DisposeObject()" LINK "RL_DisposeObject"}
@{"RL_GetObjectArray()" LINK "RL_GetObjectArray"}  @{"RL_NewGroupA()" LINK "RL_NewGroupA"}          @{"RL_NewObjectA()" LINK "RL_NewObjectA"}
@{"RL_OpenResource()" LINK "RL_OpenResource"}    @{"RL_SetResourceScreen()" LINK "RL_SetResourceScreen"}  

@ENDNODE
@NODE "background" "resource.library/background (information)"


   NAME
        @{"resource.library" LINK "gg:doc/NDK/Guide/resource/MAIN"} -- resource handling for BOOPSI classes

   DESCRIPTION
        The @{"resource.library" LINK "gg:doc/NDK/Guide/resource/MAIN"} offers an API to handle resource objects
        (an object file created from ReActor or similar BOOPSI creator
        tools). One can create BOOPSI objects and groups of BOOPSI
        objects and resource tracking is completly done by
        @{"resource.library" LINK "gg:doc/NDK/Guide/resource/MAIN"}.

        A resource object ist an AmigaDOS hunk object file that contains
        data structures with all necessary informations for creating BOOPSI
        objects. Special class informations allows to handle intuition
        BOOPSI objects.

        Strings are automatically localized if needed. The resource
        objects contains references to labels (for the locale string IDs)
        and strings (for the default strings) which has to be linked with
        symbol definitions from the application (a new catcomp version is
        available to create assembler source files for those definitions).

        The default label for the resource object is _RCTResource (defined
        by ReActor). Use a statement like

                extern char RCTResource[];

        to access the resource object. The variable RCTResource has to be
        used as the first argument to @{"RL_OpenResource" LINK "gg:doc/NDK/Guide/resource/RL_OpenResource"}.

@ENDNODE
@NODE "RL_CloseResource" "resource.library/RL_CloseResource()"
@{b}

   NAME@{ub}
        @{"RL_CloseResource" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 36} - close and free a resource object (V44)@{b}

   SYNOPSIS@{ub}
        @{"RL_CloseResource" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 36}(resource)
                           A0

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"RL_CloseResource" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 36}(@{"RESOURCEFILE" LINK "gg:doc/NDK/Guide/Include/libraries/resource.h/File" 17});@{b}

   FUNCTION@{ub}
        This routine closes a resource object that was previously opened with
        @{"RL_OpenResource" LINK "RL_OpenResource"}. It frees all objects and object groups.@{b}

   INPUTS@{ub}
        resource -- a pointer to a resource. A value of @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} is acceptable
                    which means a no-op.@{b}

   RESULTS@{ub}@{b}


   SEE ALSO@{ub}
        @{"resource.library/RL_OpenResource" LINK "RL_OpenResource"}

@ENDNODE
@NODE "RL_DisposeGroup" "resource.library/RL_DisposeGroup()"
@{b}

   NAME@{ub}
        @{"RL_DisposeGroup" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 62} - dispose a group of objects (V44)@{b}

   SYNOPSIS@{ub}
        @{"RL_DisposeGroup" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 62}(resource, group)
                         A0        A1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"RL_DisposeGroup" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 62}(@{"RESOURCEFILE" LINK "gg:doc/NDK/Guide/Include/libraries/resource.h/File" 17}, Object **);@{b}

   FUNCTION@{ub}
        Disposes a group of objects that was allocated with @{"RL_NewGroupA" LINK "RL_NewGroupA"}.
        Never dispose a object from the group with @{"RL_DisposeObject" LINK "RL_DisposeObject"},
        @{"DisposeObject" LINK "gg:doc/NDK/Guide/intuition/DisposeObject"} or @{"DisposeDTObject" LINK "gg:doc/NDK/Guide/datatypes/DisposeDTObject"}.@{b}

   INPUTS@{ub}
        resource -- a pointer to a resource
        group -- a pointer to an array of pointers to Object. A value of
                 @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} is acceptable which means a no-op.@{b}

   RESULTS@{ub}@{b}


   SEE ALSO@{ub}
        @{"resource.library/RL_NewGroupA" LINK "RL_NewGroupA"}

@ENDNODE
@NODE "RL_DisposeObject" "resource.library/RL_DisposeObject()"
@{b}

   NAME@{ub}
        @{"RL_DisposeObject" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 49} - dispose an object (V44)@{b}

   SYNOPSIS@{ub}
        @{"RL_DisposeObject" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 49}(resource, object)
                          A0        A1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"RL_DisposeObject" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 49}(@{"RESOURCEFILE" LINK "gg:doc/NDK/Guide/Include/libraries/resource.h/File" 17}, Object *);@{b}

   FUNCTION@{ub}
        Dispose an object that was allocated with @{"RL_NewObjectA" LINK "RL_NewObjectA"}.@{b}

   INPUTS@{ub}
        resource -- a pointer to a resource
        object -- a pointer to an Object. A value of @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} is acceptable which
                  means a no-op.@{b}

   RESULTS@{ub}@{b}


   SEE ALSO@{ub}
        @{"resource.library/RL_NewObjectA" LINK "RL_NewObjectA"}

@ENDNODE
@NODE "RL_GetObjectArray" "resource.library/RL_GetObjectArray()"
@{b}

   NAME@{ub}
        @{"RL_GetObjectArray" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 66} - get a pointer to a group of objects (V44)@{b}

   SYNOPSIS@{ub}
        group = @{"RL_GetObjectArray" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 66}(resource,object,id)
         D0                        A0       A1    D0

        Object **@{"RL_GetObjectArray" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 66}(@{"RESOURCEFILE" LINK "gg:doc/NDK/Guide/Include/libraries/resource.h/File" 17}, Object *, @{"RESOURCEID" LINK "gg:doc/NDK/Guide/Include/libraries/resource.h/File" 18});@{b}

   FUNCTION@{ub}
        If you allocated an Object using @{"RL_NewObjectA" LINK "RL_NewObjectA"} a lot of additional
        Objects and group of Objects may be allocated automatically. This
        functions returns a pointer to a group of objects with a given group
        ID.

        Never release the group with RL_DisposeGroupA. The group is released
        automatically if the object is released@{b}

   INPUTS@{ub}
        resource -- a pointer to a resource
        object -- a pointer to an Object
        id -- a numeric id of a object group@{b}

   RESULTS@{ub}
        group -- a pointer to an array of pointers to Object@{b}

   SEE ALSO@{ub}
        @{"resource.library/RL_NewObjectA" LINK "RL_NewObjectA"}
        @{"resource.library/RL_NewGroupA" LINK "RL_NewGroupA"}

@ENDNODE
@NODE "RL_NewGroupA" "resource.library/RL_NewGroupA()"
@{b}

   NAME@{ub}
        @{"RL_NewGroupA" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 53} - allocate a group of objects (V44)@{b}

   SYNOPSIS@{ub}
        group = @{"RL_NewGroupA" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 53}(resource,id,taglist)
         D0                   A0      D0  A1

        Object **@{"RL_NewGroupA" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 53}(@{"RESOURCEFILE" LINK "gg:doc/NDK/Guide/Include/libraries/resource.h/File" 17}, @{"RESOURCEID" LINK "gg:doc/NDK/Guide/Include/libraries/resource.h/File" 18}, @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *);@{b}

   FUNCTION@{ub}
        The routine allocates a group of objects with a given numeric id.@{b}

   INPUTS@{ub}
        resource -- a pointer to a resource
        id -- a numeric id
        taglist -- a pointer to an array of TagItem. Currently no tags are
                   defined.@{b}

   RESULTS@{ub}
        group -- a pointer to an array of pointers to Object or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"resource.library/RL_DisposeGroup" LINK "RL_DisposeGroup"}
        @{"resource.library/RL_GetObjectArray" LINK "RL_GetObjectArray"}

@ENDNODE
@NODE "RL_NewObjectA" "resource.library/RL_NewObjectA()"
@{b}

   NAME@{ub}
        @{"RL_NewObjectA" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 40} - create a new object (V44)@{b}

   SYNOPSIS@{ub}
        object = @{"RL_NewObjectA" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 40}(resource,id,taglist)
         D0                     A0      D0  A1

        Object *@{"RL_NewObjectA" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 40}(@{"RESOURCEFILE" LINK "gg:doc/NDK/Guide/Include/libraries/resource.h/File" 17}, @{"RESOURCEID" LINK "gg:doc/NDK/Guide/Include/libraries/resource.h/File" 18}, @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *);;@{b}

   FUNCTION@{ub}
        The routine creates a new object with a given numeric id.@{b}

   INPUTS@{ub}
        resource -- a pointer to a resource
        id -- a numeric id
        taglist -- a pointer to an array of TagItem. The tags are moved
                   forward to the call of @{"NewObjectA" LINK "gg:doc/NDK/Guide/intuition/NewObject"}, @{"NewDTObjectA" LINK "gg:doc/NDK/Guide/datatypes/NewDTObjectA"} or
                   whatever is called to create the object@{b}

   RESULTS@{ub}
        object -- a pointer to an Object or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"intuition.library/NewObjectA" LINK "gg:doc/NDK/Guide/intuition/NewObject"}
        @{"datatypes.library/NewDTObjectA" LINK "gg:doc/NDK/Guide/datatypes/NewDTObjectA"}
        @{"resource.library/RL_DisposeObject" LINK "RL_DisposeObject"}

@ENDNODE
@NODE "RL_OpenResource" "resource.library/RL_OpenResource()"
@{b}

   NAME@{ub}
        @{"RL_OpenResource" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 32} - open a resource (V44)@{b}

   SYNOPSIS@{ub}
        resource = @{"RL_OpenResource" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 32}(resobject, screen, catalog)
         D0                         A0         A1      A2

        @{"RESOURCEFILE" LINK "gg:doc/NDK/Guide/Include/libraries/resource.h/File" 17} @{"RL_OpenResource" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 32}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49}, @{"struct Screen" LINK "gg:doc/NDK/Guide/Include/intuition/screens.h/File" 133} *, @{"struct Catalog" LINK "gg:doc/NDK/Guide/Include/libraries/locale.h/File" 246} *);@{b}

   FUNCTION@{ub}
        This routine opens a resource object.

        If you give a @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for the parameter screen do not call @{"RL_NewObjectA" LINK "RL_NewObjectA"}
        or @{"RL_NewGroupA" LINK "RL_NewGroupA"}. You must first set a screen with
        @{"RL_SetResourceScreen" LINK "RL_SetResourceScreen"}.@{b}

   INPUTS@{ub}
        resobject -- a pointer to a resource object
        screen -- a pointer to a Screen. This may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
        catalog -- a pointer to a Catalog. This may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}@{b}

   RESULTS@{ub}
        resource -- a pointer to a resource or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}@{b}

   EXAMPLE@{ub}

        extern char RCTResource[];
        @{"struct Screen" LINK "gg:doc/NDK/Guide/Include/intuition/screens.h/File" 133} *screen;

        screen = @{"LockPubScreen" LINK "gg:doc/NDK/Guide/intuition/LockPubScreen"}(@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101});
        @{"RESOURCEFILE" LINK "gg:doc/NDK/Guide/Include/libraries/resource.h/File" 17} resource = @{"RL_OpenResource" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 32}(RCTResource, screen, @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101});
        if (resource)
        {
                /* create your objects here */
        }
        @{"RL_CloseResource" LINK "RL_CloseResource"}(resource);
        @{"UnlockPubScreen" LINK "gg:doc/NDK/Guide/intuition/UnlockPubScreen"}(@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101},screen);@{b}

   SEE ALSO@{ub}
        @{"intuition.library/LockPubScreen" LINK "gg:doc/NDK/Guide/intuition/LockPubScreen"}
        @{"intuition.library/OpenScreenTagList" LINK "gg:doc/NDK/Guide/intuition/OpenScreenTagList"}
        @{"locale.library/OpenCatalogA" LINK "gg:doc/NDK/Guide/locale/OpenCatalog"}
        @{"resource.library/RL_CloseResource" LINK "RL_CloseResource"}
        @{"resource.library/RL_SetResourceScreen" LINK "RL_SetResourceScreen"}

@ENDNODE
@NODE "RL_SetResourceScreen" "resource.library/RL_SetResourceScreen()"
@{b}

   NAME@{ub}
        @{"RL_SetResourceScreen" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 70} - sets or clears the screen (V44)@{b}

   SYNOPSIS@{ub}
        success = @{"RL_SetResourceScreen" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 70}(resource, screen)
         D0                             A0        A1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"RL_SetResourceScreen" LINK "gg:doc/NDK/Guide/Include/inline/resource.h/File" 70}(@{"RESOURCEFILE" LINK "gg:doc/NDK/Guide/Include/libraries/resource.h/File" 17}, @{"struct Screen" LINK "gg:doc/NDK/Guide/Include/intuition/screens.h/File" 133} *);@{b}

   FUNCTION@{ub}
        This routine sets or clears the screen of the resource. You must clear
        the screen before you close or unlock it. You must set a valid screen
        before you call @{"NewObjectA" LINK "gg:doc/NDK/Guide/intuition/NewObject"} or NewGroupA.

        Setting a new screen does not mean that the allocated objects are
        automatically adapt to the new screen. This function only controls
        the internal housekeeping of the screen (and related structures). If
        you cannot adapt the allocated objects to a new screen (like setting
        an attribute with the new screen value) you must dispose and
        recreate them.

        If you set the same screen pointer as was before this function does
        nothing but returns @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95}.@{b}

   INPUTS@{ub}
        resource -- a pointer to a resource
        screen --  a pointer to a Screen or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}@{b}

   RESULTS@{ub}
        success -- @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if the screen is successfully set or cleared.@{b}

   SEE ALSO@{ub}
        @{"resource.library/RL_OpenResource" LINK "RL_OpenResource"}

@ENDNODE
