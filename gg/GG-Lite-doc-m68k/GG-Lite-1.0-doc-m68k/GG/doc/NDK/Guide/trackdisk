@DATABASE "gg:doc/NDK/Guide/trackdisk"
@MASTER   "gg:doc/NDK/AutoDocs/trackdisk.doc"
@REMARK   This file was created by ADtoHT 2.1 on 06-Jan-13 19:25:17
@REMARK   Do not edit
@REMARK   ADtoHT is © 1993-1995 Christian Stieber

@NODE MAIN "trackdisk.doc"
@TOC "gg:doc/NDK/Guide/TOC/MAIN"

                              @{b}trackdisk.device@{ub}

@{"CMD_CLEAR" LINK "CMD_CLEAR"}        @{"CMD_READ" LINK "CMD_READ"}         @{"CMD_UPDATE" LINK "CMD_UPDATE"}      @{"CMD_WRITE" LINK "CMD_WRITE"}
@{"TD_ADDCHANGEINT" LINK "TD_ADDCHANGEINT"}  @{"TD_CHANGENUM" LINK "TD_CHANGENUM"}     @{"TD_CHANGESTATE" LINK "TD_CHANGESTATE"}  @{"TD_EJECT" LINK "TD_EJECT"}
@{"TD_FORMAT" LINK "TD_FORMAT"}        @{"TD_GETDRIVETYPE" LINK "TD_GETDRIVETYPE"}  @{"TD_GETGEOMETRY" LINK "TD_GETGEOMETRY"}  @{"TD_GETNUMTRACKS" LINK "TD_GETNUMTRACKS"}
@{"TD_MOTOR" LINK "TD_MOTOR"}         @{"TD_PROTSTATUS" LINK "TD_PROTSTATUS"}    @{"TD_RAWREAD" LINK "TD_RAWREAD"}      @{"TD_RAWWRITE" LINK "TD_RAWWRITE"}
@{"TD_REMCHANGEINT" LINK "TD_REMCHANGEINT"}  @{"TD_SEEK" LINK "TD_SEEK"}          

@ENDNODE
@NODE "CMD_CLEAR" "trackdisk.device/CMD_CLEAR"
@{b}

   NAME@{ub}
        @{"CMD_CLEAR" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 54}/@{"ETD_CLEAR" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 107} -- mark the track buffer as containing invalid
                               data.@{b}

   FUNCTION@{ub}
        These commands mark the track buffer as invalid, forcing a
        reread of the disk on the next operation. @{"ETD_UPDATE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 106} or @{"CMD_UPDATE" LINK "CMD_UPDATE"}
        would be used to force data out to the disk before turning the motor
        off. @{"ETD_CLEAR" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 107} or @{"CMD_CLEAR" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 54} are usually used after having locked out
        the trackdisk.device via the use of the disk resource, when you
        wish to prevent the track from being updated, or when you wish to
        force the track to be re-read. @{"ETD_CLEAR" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 107} or @{"CMD_CLEAR" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 54} will not do an
        update, nor will an update command do a clear.@{b}

   IO REQUEST INPUT@{ub}
        io_Device       preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Unit         preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Command      @{"CMD_CLEAR" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 54} or @{"ETD_CLEAR" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 107}
        io_Flags        0 or @{"IOF_QUICK" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 46}
        iotd_Count      (@{"ETD_CLEAR" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 107} only) maximum allowable change counter
                        value.@{b}

   IO REQUEST RESULT@{ub}
        io_Error - 0 for success, or an error code as defined in
                   <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>@{b}

   SEE ALSO@{ub}
        @{"CMD_WRITE" LINK "CMD_WRITE"}, @{"CMD_UPDATE" LINK "CMD_UPDATE"}

@ENDNODE
@NODE "CMD_READ" "trackdisk.device/CMD_READ"
@{b}

   NAME@{ub}
        @{"CMD_READ" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 51}/@{"ETD_READ" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 102} -- read sectors of data from a disk.@{b}

   FUNCTION@{ub}
        These commands transfer data from the track buffer to a supplied
        buffer. If the desired sector is already in the track buffer, no disk
        activity is initiated. If the desired sector is not in the buffer, the
        track containing that sector is automatically read in. If the data in
        the current track buffer has been modified, it is written out to the
        disk before a new track is read. @{"ETD_READ" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 102} will read the sector label
        area if the iotd_SecLabel is non-@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   IO REQUEST INPUT@{ub}
        io_Device       preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Unit         preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Command      @{"CMD_READ" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 51} or @{"ETD_READ" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 102}
        io_Flags        0 or @{"IOF_QUICK" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 46}
        io_Data         pointer to the buffer where the data should be put
        io_Length       number of bytes to read, must be a multiple of
                        @{"TD_SECTOR" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 50}.
        io_Offset       byte offset from the start of the disk describing
                        where to read data from, must be a multiple of
                        @{"TD_SECTOR" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 50}.
        iotd_Count      (@{"ETD_READ" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 102} only) maximum allowable change counter
                        value.
        iotd_SecLabel   (@{"ETD_READ" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 102} only) @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} or sector label buffer pointer.
                        If provided, the buffer must be a multiple of
                        @{"TD_LABELSIZE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 183}.@{b}

   IO REQUEST RESULT@{ub}
        io_Error - 0 for success, or an error code as defined in
                   <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>@{b}
   NOTES@{ub}
        Under versions of Kickstart earlier than V36, the io_Data had to
        point to a buffer in chip memory. This restriction is no longer
        present as of Kickstart V36 and beyond.@{b}

   SEE ALSO@{ub}
        @{"CMD_WRITE" LINK "CMD_WRITE"}

@ENDNODE
@NODE "CMD_UPDATE" "trackdisk.device/CMD_UPDATE"
@{b}

   NAME@{ub}
        @{"CMD_UPDATE" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 53}/@{"ETD_UPDATE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 106} -- write out the track buffer if it is dirty.@{b}

   FUNCTION@{ub}
        The trackdisk device does not write data sectors unless it is
        necessary (you request that a different track be used) or until the
        user requests that an update be performed. This improves system speed
        by caching disk operations. These commands ensure that any
        buffered data is flushed out to the disk. If the track buffer has not
        been changed since the track was read in, these commands do nothing.
        @{"ETD_UPDATE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 106} command checks for diskchange.@{b}

   IO REQUEST INPUT@{ub}
        io_Device       preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Unit         preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Command      @{"CMD_UPDATE" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 53} or @{"ETD_UPDATE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 106}
        io_Flags        0 or @{"IOF_QUICK" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 46}
        iotd_Count      (@{"ETD_UPDATE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 106} only) maximum allowable change counter
                        value.@{b}

   IO REQUEST RESULT@{ub}
        io_Error - 0 for success, or an error code as defined in
                   <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>@{b}

   SEE ALSO@{ub}
        @{"CMD_WRITE" LINK "CMD_WRITE"}

@ENDNODE
@NODE "CMD_WRITE" "trackdisk.device/CMD_WRITE"
@{b}

   NAME@{ub}
        @{"CMD_WRITE" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 52}/@{"ETD_WRITE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 101} -- write sectors of data to a disk.@{b}

   FUNCTION@{ub}
        These commands transfer data from a supplied buffer to the track
        buffer. If the track that contains this sector is already in the track
        buffer, no disk activity is initiated. If the desired sector is not in
        the buffer, the track containing that sector is automatically read in.
        If the data in the current track buffer has been modified, it is
        written out to the disk before the new track is read in for
        modification. @{"ETD_WRITE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 101} will write the sector label area if
        iotd_SecLabel is non-@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   IO REQUEST INPUT@{ub}
        io_Device       preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Unit         preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Command      @{"CMD_WRITE" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 52} or @{"ETD_WRITE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 101}
        io_Flags        0 or @{"IOF_QUICK" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 46}
        io_Data         pointer to the buffer where the data should be put
        io_Length       number of bytes to write, must be a multiple of
                        @{"TD_SECTOR" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 50}.
        io_Offset       byte offset from the start of the disk describing
                        where to write data to, must be a multiple of
                        @{"TD_SECTOR" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 50}.
        iotd_Count      (@{"ETD_WRITE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 101} only) maximum allowable change counter
                        value.
        iotd_SecLabel   (@{"ETD_WRITE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 101} only) @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} or sector label buffer pointer.
                        If provided, the buffer must be a multiple of
                        @{"TD_LABELSIZE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 183}.@{b}

   IO REQUEST RESULT@{ub}
        io_Error - 0 for success, or an error code as defined in
                   <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>@{b}

   NOTES@{ub}
        Under versions of Kickstart earlier than V36, the io_Data had to
        point to a buffer in chip memory. This restriction is no longer
        present as of Kickstart V36 and beyond.@{b}

   SEE ALSO@{ub}
        @{"CMD_READ" LINK "CMD_READ"}, @{"TD_FORMAT" LINK "TD_FORMAT"}

@ENDNODE
@NODE "TD_ADDCHANGEINT" "trackdisk.device/TD_ADDCHANGEINT"
@{b}

   NAME@{ub}
        @{"TD_ADDCHANGEINT" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 88} -- add a disk change software interrupt handler.@{b}

   FUNCTION@{ub}
        This command lets you add a software interrupt handler to the
        disk device that gets invoked whenever a disk insertion or removal
        occurs.

        You must pass in a properly initialized Exec Interrupt structure
        and be prepared to deal with disk insertions/removals
        immediately. From within the interrupt handler, you may only call the
        status commands that can use @{"IOF_QUICK" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 46}.

        To set up the handler, an Interrupt structure must be initialized.
        This structure is supplied as the io_Data to the @{"TD_ADDCHANGEINT" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 88}
        command. The handler then gets linked into the handler chain and
        gets invoked whenever a disk change happens. You must eventually
        remove the handler before you exit.

        This command only returns when the handler is removed. That is,
        the device holds onto the IO request until the @{"TD_REMCHANGEINT" LINK "TD_REMCHANGEINT"} command
        is executed with that same IO request. Hence, you must use @{"SendIO()" LINK "gg:doc/NDK/Guide/exec/SendIO"}
        with this command.@{b}

   IO REQUEST INPUT@{ub}
        io_Device       preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Unit         preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Command      @{"TD_ADDCHANGEINT" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 88}
        io_Flags        0
        io_Length       sizeof(@{"struct Interrupt" LINK "gg:doc/NDK/Guide/Include/exec/interrupts.h/File" 22})
        io_Data         pointer to Interrupt structure@{b}

   IO REQUEST RESULT@{ub}
        io_Error - 0 for success, or an error code as defined in
                   <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>@{b}

   SEE ALSO@{ub}
        @{"TD_REMCHANGEINT" LINK "TD_REMCHANGEINT"}, <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>, <@{"exec/interrupts.h" LINK "gg:doc/NDK/Guide/Include/exec/interrupts.h/File"}>,
        @{"exec.library/Cause()" LINK "gg:doc/NDK/Guide/exec/Cause"}

@ENDNODE
@NODE "TD_CHANGENUM" "trackdisk.device/TD_CHANGENUM"
@{b}

   NAME@{ub}
        @{"TD_CHANGENUM" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 81} -- return the current value of the disk-change counter.@{b}

   FUNCTION@{ub}
        This command returns the current value of the disk-change counter (as
        used by the enhanced commands). The disk change counter is incremented
        each time a disk is inserted or removed from the trackdisk unit.@{b}

   IO REQUEST INPUT@{ub}
        io_Device       preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Unit         preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Command      @{"TD_CHANGENUM" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 81}
        io_Flags        0 or @{"IOF_QUICK" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 46}@{b}

   IO REQUEST RESULT@{ub}
        io_Error - 0 for success, or an error code as defined in
                   <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>
        io_Actual - if io_Error is 0, this contains the current value of the
                    disk-change counter.

@ENDNODE
@NODE "TD_CHANGESTATE" "trackdisk.device/TD_CHANGESTATE"
@{b}

   NAME@{ub}
        @{"TD_CHANGESTATE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 82} -- check if a disk is currently in a drive.@{b}

   FUNCTION@{ub}
        This command checks to see if there is currently a disk in a drive.@{b}

   IO REQUEST INPUT@{ub}
        io_Device       preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Unit         preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Command      @{"TD_CHANGESTATE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 82}
        io_Flags        0 or @{"IOF_QUICK" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 46}@{b}

   IO REQUEST RESULT@{ub}
        io_Error - 0 for success, or an error code as defined in
                   <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>
        io_Actual - if io_Error is 0, this tells you whether a disk is in
                    the drive. 0 means there is a disk, while anything else
                    indicates there is no disk.

@ENDNODE
@NODE "TD_EJECT" "trackdisk.device/TD_EJECT"
@{b}

   NAME@{ub}
       @{"TD_EJECT" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 91} -- eject (or load) the disk in the drive, if possible.@{b}

   FUNCTION@{ub}
        This command causes the drive to attempt to eject the disk in
        it, if any.  Note that the current trackdisk.device does not
        implement this command, but it might in the future, and other
        trackdisk-compatible drivers may implement this command.  Some
        devices may be able to load disks on command also.@{b}

   IO REQUEST INPUT@{ub}
        io_Device       preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Unit         preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Command      @{"TD_EJECT" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 91}
        io_Flags        0 or @{"IOF_QUICK" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 46}
        io_Length       0 (load, if supported) or 1 (eject)@{b}

   IO REQUEST RESULT@{ub}
        io_Error - 0 for success, or an error code as defined in
                   <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>@{b}

   BUGS@{ub}
        The pre-V40 autodoc didn't mention io_Length.  Because of this, for
        devices that can never support load, a driver might want to eject if
        io_Length is 0.

@ENDNODE
@NODE "TD_FORMAT" "trackdisk.device/TD_FORMAT"
@{b}

   NAME@{ub}
        @{"TD_FORMAT" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 79}/@{"ETD_FORMAT" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 105} -- format a track on a disk.@{b}

   FUNCTION@{ub}
        These commands are used to write data to a track that either
        has not yet been formatted or has had a hard error on a standard write
        command. @{"TD_FORMAT" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 79} completely ignores all data currently on a track and
        does not check for disk change before performing the command. The
        io_Data field must point to at least one track worth of data. The
        io_Offset field must be track aligned, and the io_Length field must be
        in units of track length (that is, NUMSEC*@{"TD_SECTOR" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 50}).

        The device will format the requested tracks, filling each sector with
        the contents of the buffer pointed to by io_Data. You
        should do a read pass to verify the data.

        If you have a hard write error during a normal write, you may find it
        possible to use the @{"TD_FORMAT" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 79} command to reformat the track as part of
        your error recovery process. @{"ETD_FORMAT" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 105} will write the sector label
        area if iotd_SecLabel is non-@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   IO REQUEST INPUT@{ub}
        io_Device       preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Unit         preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Command      @{"TD_FORMAT" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 79} or @{"ETD_FORMAT" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 105}
        io_Flags        0 or @{"IOF_QUICK" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 46}
        io_Data         points to a buffer containing the data to write to the
                        track, must be at least as large as io_Length.
        io_Length       number of bytes to format, must be a multiple of
                        (TD_SECTORS * NUMSEC).
        io_Offset       byte offset from the start of the disk for the track to
                        format, must be a multiple of (TD_SECTORS * NUMSEC).
        iotd_Count      (@{"ETD_FORMAT" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 105} only) maximum allowable change counter
                        value.
        iotd_SecLabel   (@{"ETD_FORMAT" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 105} only) @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} or sector label buffer pointer.
                        If provided, the buffer must be a multiple of
                        (@{"TD_LABELSIZE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 183} * NUMSEC).@{b}

   IO REQUEST RESULT@{ub}
        io_Error - 0 for success, or an error code as defined in
                   <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>@{b}

   NOTES@{ub}
        Under versions of Kickstart earlier than V36, the io_Data had to
        point to a buffer in chip memory. This restriction is no longer
        present as of Kickstart V36 and beyond.@{b}

   SEE ALSO@{ub}
        @{"CMD_WRITE" LINK "CMD_WRITE"}, @{"TD_RAWWRITE" LINK "TD_RAWWRITE"}

@ENDNODE
@NODE "TD_GETDRIVETYPE" "trackdisk.device/TD_GETDRIVETYPE"
@{b}

   NAME@{ub}
        @{"TD_GETDRIVETYPE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 86} -- return the type of disk drive for the unit that was
                           opened.@{b}

   FUNCTION@{ub}
        This command returns the type of the disk drive to the user.
        This number will be a small integer and will come from the set of
        DRIVEXXX constants defined in <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>.

        The only way you can actually use this command is if the trackdisk
        device understands the drive type of the hardware that is plugged in.
        This is because the @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"} call will fail if the trackdisk device
        does not understand the drive type. To find raw drive identifiers see
        the @{"disk.resource" LINK "gg:doc/NDK/Guide/disk/MAIN"}'s @{"DR_GETUNITID" LINK "gg:doc/NDK/Guide/Include/resources/disk.h/File" 107} entry point.@{b}

   IO REQUEST INPUT@{ub}
        io_Device       preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Unit         preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Command      @{"TD_GETDRIVETYPE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 86}
        io_Flags        0 or @{"IOF_QUICK" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 46}@{b}

   IO REQUEST RESULT@{ub}
        io_Error - 0 for success, or an error code as defined in
                   <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>
        io_Actual - if io_Error is 0 this contains the drive type connected to
                    this unit.@{b}

   SEE ALSO@{ub}
        @{"TD_GETNUMTRACKS" LINK "TD_GETNUMTRACKS"}, <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>

@ENDNODE
@NODE "TD_GETGEOMETRY" "trackdisk.device/TD_GETGEOMETRY"
@{b}

   NAME@{ub}
       @{"TD_GETGEOMETRY" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 90} -- return the geometry of the drive.@{b}

   FUNCTION@{ub}
        This command returns a full set of information about the
        layout of the drive. The information is returned in the
        DriveGeometry structure pointed to by io_Data.@{b}

   IO REQUEST INPUT@{ub}
        io_Device       preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Unit         preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Command      @{"TD_GETGEOMETRY" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 90}
        io_Flags        0 or @{"IOF_QUICK" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 46}
        io_Data         Pointer to a DriveGeometry structure
        io_Length       sizeof(@{"struct DriveGeometry" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 135})@{b}

   IO REQUEST RESULT@{ub}
        io_Error - 0 for success, or an error code as defined in
                   <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>@{b}

   NOTE@{ub}
        This information may change when a disk in inserted when
        certain hardware is present.@{b}

   SEE ALSO@{ub}
        @{"TD_GETDRIVETYPE" LINK "TD_GETDRIVETYPE"}, @{"TD_GETNUMTRACKS" LINK "TD_GETNUMTRACKS"}

@ENDNODE
@NODE "TD_GETNUMTRACKS" "trackdisk.device/TD_GETNUMTRACKS"
@{b}

   NAME@{ub}
        @{"TD_GETNUMTRACKS" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 87} -- return the number of tracks for the type of disk
                           drive for the unit that was opened.@{b}

   FUNCTION@{ub}
        This command returns the number of tracks that are available
        on the disk unit.@{b}

   IO REQUEST INPUT@{ub}
        io_Device       preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Unit         preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Command      @{"TD_GETNUMTRACKS" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 87}
        io_Flags        0 or @{"IOF_QUICK" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 46}@{b}

   IO REQUEST RESULT@{ub}
        io_Error - 0 for success, or an error code as defined in
                   <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>
        io_Actual - if io_Error is 0 this contains the drive type connected to
                    this unit.@{b}

   SEE ALSO@{ub}
        @{"TD_GETDRIVETYPE" LINK "TD_GETDRIVETYPE"}

@ENDNODE
@NODE "TD_MOTOR" "trackdisk.device/TD_MOTOR"
@{b}

   NAME@{ub}
        @{"TD_MOTOR" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 77}/@{"ETD_MOTOR" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 103} -- control the on/off state of a drive motor.@{b}

   FUNCTION@{ub}
        This command gives control over the disk motor. The motor may be
        turned on or off. When it is on, the drive light automatically turns
        on as well.

        If the motor is just being turned on, the device will delay the
        proper amount of time to allow the drive to come up to speed. Normally,
        turning the drive on is not necessary, the device does this
        automatically if it receives a request when the motor is off. However,
        turning the motor off is the programmer's responsibility.

        In addition, the standard instructions to the user are that it is safe
        to remove a disk from a drive if and only if the motor is off (that is,
        if the disk light is off).@{b}

   IO REQUEST INPUT@{ub}
        io_Device       preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Unit         preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Command      @{"TD_MOTOR" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 77} or @{"ETD_MOTOR" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 103}
        io_Flags        0 or @{"IOF_QUICK" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 46}
        io_Length       the requested state of the motor, 0 to turn the motor
                        off, and 1 to turn the motor on.
        iotd_Count      (@{"ETD_MOTOR" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 103} only) maximum allowable change counter
                        value.@{b}

   IO REQUEST RESULT@{ub}
        io_Error - 0 for success, or an error code as defined in
                   <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>
        io_Actual - if io_Error is 0 this contains the previous state of the
                    drive motor.

@ENDNODE
@NODE "TD_PROTSTATUS" "trackdisk.device/TD_PROTSTATUS"
@{b}

   NAME@{ub}
        @{"TD_PROTSTATUS" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 83} -- return whether the current disk is write-protected.@{b}

   FUNCTION@{ub}
        This command is used to determine whether the current disk is
        write-protected.@{b}

   IO REQUEST INPUT@{ub}
        io_Device       preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Unit         preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Command      @{"TD_PROTSTATUS" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 83}
        io_Flags        0 or @{"IOF_QUICK" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 46}@{b}

   IO REQUEST RESULT@{ub}
        io_Error - 0 for success, or an error code as defined in
                   <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>
        io_Actual - if io_Error is 0, this tells you whether the disk in the
                    drive is write-protected. 0 means the disk is @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} write-
                    protected, while any other value indicates it is.

@ENDNODE
@NODE "TD_RAWREAD" "trackdisk.device/TD_RAWREAD"
@{b}

   NAME@{ub}
        @{"TD_RAWREAD" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 84}/@{"ETD_RAWREAD" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 108} -- read raw data from the disk.@{b}

   FUNCTION@{ub}
        These commands read a track of raw data from disk and deposits it in
        the provided buffer. The data is taken straight from the disk with
        no processing done on it. It will appear exactly as the bits come out
        off the disk, hopefully in some legal MFM format.

        This interface is intended for sophisticated programmers only.
        Amiga reserves the right to make enhancements to the disk
        format in the future. We will provide compatibility via the
        @{"CMD_READ" LINK "CMD_READ"} and @{"ETD_READ" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 102} commands, anyone using @{"TD_RAWREAD" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 84} is
        bypassing this upwards compatibility, and may thus stop working.@{b}

   IO REQUEST INPUT@{ub}
        io_Device       preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Unit         preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Command      @{"TD_RAWREAD" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 84} or @{"ETD_RAWREAD" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 108}.
        io_Flags        if the @{"IOTDB_INDEXSYNC" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 171} bit is set then the driver
                        will make a best effort attempt to start reading
                        from the index mark.  Note that there will be at
                        least some delay, and perhaps a great deal of delay
                        (for example if interrupts have been disabled).
        io_Length       Length of buffer in bytes, with a maximum of 32768
                        bytes.
        io_Data         Pointer to CHIP memory buffer where raw track data is
                        to be deposited.
        io_Offset       The number of the track to read in.
        iotd_Count      (@{"ETD_RAWREAD" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 108} only) maximum allowable change counter
                        value.@{b}

   IO REQUEST RESULT@{ub}
        io_Error - 0 for success, or an error code as defined in
                   <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>@{b}

   NOTES@{ub}
        The track buffer provided MUST be in CHIP memory

        There is a delay between the index pulse and the start of bits
        coming in from the drive (e.g. dma started). This delay
        is in the range of 135-200 microseconds. This delay breaks
        down as follows: 55 microsecs is software interrupt overhead
        (this is the time from interrupt to the write of the DSKLEN
        register). 66 microsecs is one horizontal line delay (remember
        that disk IO is synchronized with agnus' display fetches).
        The last variable (0-65 microsecs) is an additional scan line
        since DSKLEN is poked anywhere in the horizontal line. This leaves
        15 microsecs unaccounted for...  Sigh.

        In short, You will almost never get bits within the first 135
        microseconds of the index pulse, and may not get it until 200
        microseconds. At 4 microsecs/bit, this works out to be between
        4 and 7 bytes of user data of delay.@{b}

   BUGS@{ub}
        This command does not work reliably under versions of Kickstart
        earlier than V36, especially on systems with 1 floppy drive.@{b}

   SEE ALSO@{ub}
        @{"TD_RAWWRITE" LINK "TD_RAWWRITE"}

@ENDNODE
@NODE "TD_RAWWRITE" "trackdisk.device/TD_RAWWRITE"
@{b}

   NAME@{ub}
        @{"TD_RAWWRITE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 85}/@{"ETD_RAWWRITE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 109} -- write raw data to the disk.@{b}

   FUNCTION@{ub}
        This command writes a track of raw data from the provided buffer to
        the specified track on disk. The data is copied straight to the disk
        with no processing done on it. It will appear exactly on the disk as
        it is in the memory buffer, hopefully in a legal MFM format.

        This interface is intended for sophisticated programmers only.
        Amiga reserves the right to make enhancements to the disk
        format in the future. We will provide compatibility via the
        @{"CMD_WRITE" LINK "CMD_WRITE"} and @{"ETD_WRITE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 101} commands, anyone using @{"TD_RAWWRITE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 85} is
        bypassing this upwards compatibility, and may thus stop working.@{b}

   IO REQUEST INPUT@{ub}
        io_Device       preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Unit         preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Command      @{"TD_RAWWRITE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 85} or @{"ETD_RAWWRITE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 109}.
        io_Flags        if the @{"IOTDB_INDEXSYNC" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 171} bit is set then the driver
                        will make a best effort attempt to start writing
                        from the index mark.  Note that there will be at
                        least some delay, and perhaps a great deal of delay
                        (for example if interrupts have been disabled).
        io_Length       Length of buffer in bytes, with a maximum of 32768
                        bytes.
        io_Data         Pointer to CHIP memory buffer where raw track data is
                        to be taken.
        io_Offset       The number of the track to write to.
        iotd_Count      (@{"ETD_RAWWRITE" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 109} only) maximum allowable change counter
                        value.@{b}

   IO REQUEST RESULT@{ub}
        io_Error - 0 for success, or an error code as defined in
                   <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>@{b}

   NOTES@{ub}
        The track buffer provided MUST be in CHIP memory

        There is a delay between the index pulse and the start of bits
        going out to the driver (e.g. write gate enabled). This delay
        is in the range of 135-200 microseconds. This delay breaks
        down as follows: 55 microsecs is software interrupt overhead
        (this is the time from interrupt to the write of the DSKLEN
        register). 66 microsecs is one horizontal line delay (remember
        that disk IO is synchronized with agnus' display fetches).
        The last variable (0-65 microsecs) is an additional scan line
        since DSKLEN is poked anywhere in the horizontal line. This leaves
        15 microsecs unaccounted for...  Sigh.

        In short, You will almost never get bits within the first 135
        microseconds of the index pulse, and may not get it until 200
        microseconds. At 4 microsecs/bit, this works out to be between
        4 and 7 bytes of user data of delay.@{b}

   BUGS@{ub}
        This command does not work reliably under versions of Kickstart
        earlier than V36, especially on systems with 1 floppy drive.@{b}

   SEE ALSO@{ub}
        @{"TD_RAWREAD" LINK "TD_RAWREAD"}

@ENDNODE
@NODE "TD_REMCHANGEINT" "trackdisk.device/TD_REMCHANGEINT"
@{b}

   NAME@{ub}
        @{"TD_REMCHANGEINT" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 89} -- remove a disk change software interrupt handler.@{b}

   FUNCTION@{ub}
        This command removes a disk change software interrupt added
        by a previous use of @{"TD_ADDCHANGEINT" LINK "TD_ADDCHANGEINT"}.@{b}

   IO REQUEST INPUT@{ub}
        The same IO request used for @{"TD_ADDCHANGEINT" LINK "TD_ADDCHANGEINT"}.

        io_Device       preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Unit         preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Command      @{"TD_REMCHANGEINT" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 89}
        io_Flags        0
        io_Length       sizeof(@{"struct Interrupt" LINK "gg:doc/NDK/Guide/Include/exec/interrupts.h/File" 22})
        io_Data         pointer to Interrupt structure@{b}

   IO REQUEST RESULT@{ub}
        io_Error - 0 for success, or an error code as defined in
                   <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>@{b}

   BUGS@{ub}
        This command did not function properly under versions of Kickstart
        earlier than V36. A valid workaround under these older versions of
        Kickstart is:

                @{"Forbid()" LINK "gg:doc/NDK/Guide/exec/Forbid"};
                @{"Remove" LINK "gg:doc/NDK/Guide/exec/Remove"}(ioRequest);
                @{"Permit()" LINK "gg:doc/NDK/Guide/exec/Permit"};

        Do not use this workaround in versions of Kickstart >= V36, use
        @{"TD_REMCHANGEINT" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 89} instead (for future compatibility with V38+).@{b}

   SEE ALSO@{ub}
        @{"TD_ADDCHANGEINT" LINK "TD_ADDCHANGEINT"}, <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>

@ENDNODE
@NODE "TD_SEEK" "trackdisk.device/TD_SEEK"
@{b}

   NAME@{ub}
        @{"TD_SEEK" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 78}/@{"ETD_SEEK" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 104} -- control positioning of the drive heads.@{b}

   FUNCTION@{ub}
        These commands are currently provided for internal diagnostics,
        disk repair, and head cleaning only.

        @{"TD_SEEK" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 78} and @{"ETD_SEEK" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 104} move the drive heads to the track specified. The
        io_Offset field should be set to the (byte) offset to which the seek is
        to occur. @{"TD_SEEK" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 78} and @{"ETD_SEEK" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 104} do not verify their position until the
        next read. That is, they only move the heads; they do not actually read
        any data.@{b}

   IO REQUEST INPUT@{ub}
        io_Device       preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Unit         preset by the call to @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"}
        io_Command      @{"TD_SEEK" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 78} or @{"ETD_SEEK" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 104}
        io_Flags        0 or @{"IOF_QUICK" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 46}
        io_Offset       byte offset from the start of the disk describing
                        where to move the head to.
        iotd_Count      (@{"ETD_SEEK" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 104} only) maximum allowable change counter
                        value.@{b}

   IO REQUEST RESULT@{ub}
        io_Error - 0 for success, or an error code as defined in
                   <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>

@ENDNODE
