@DATABASE "gg:doc/NDK/Guide/iffparse"
@MASTER   "gg:doc/NDK/AutoDocs/iffparse.doc"
@REMARK   This file was created by ADtoHT 2.1 on 06-Jan-13 19:22:50
@REMARK   Do not edit
@REMARK   ADtoHT is © 1993-1995 Christian Stieber

@NODE MAIN "iffparse.doc"
@TOC "gg:doc/NDK/Guide/TOC/MAIN"

                              @{b}iffparse.library@{ub}

@{"AllocIFF()" LINK "AllocIFF"}            @{"AllocLocalItem()" LINK "AllocLocalItem"}    @{"CloseClipboard()" LINK "CloseClipboard"}
@{"CloseIFF()" LINK "CloseIFF"}            @{"CollectionChunk()" LINK "CollectionChunk"}   @{"CollectionChunks()" LINK "CollectionChunks"}
@{"CurrentChunk()" LINK "CurrentChunk"}        @{"EntryHandler()" LINK "EntryHandler"}      @{"ExitHandler()" LINK "ExitHandler"}
@{"FindCollection()" LINK "FindCollection"}      @{"FindLocalItem()" LINK "FindLocalItem"}     @{"FindProp()" LINK "FindProp"}
@{"FindPropContext()" LINK "FindPropContext"}     @{"FreeIFF()" LINK "FreeIFF"}           @{"FreeLocalItem()" LINK "FreeLocalItem"}
@{"GoodID()" LINK "GoodID"}              @{"GoodType()" LINK "GoodType"}          @{"IDtoStr()" LINK "IDtoStr"}
@{"InitIFF()" LINK "InitIFF"}             @{"InitIFFasClip()" LINK "InitIFFasClip"}     @{"InitIFFasDOS()" LINK "InitIFFasDOS"}
@{"LocalItemData()" LINK "LocalItemData"}       @{"OpenClipboard()" LINK "OpenClipboard"}     @{"OpenIFF()" LINK "OpenIFF"}
@{"ParentChunk()" LINK "ParentChunk"}         @{"ParseIFF()" LINK "ParseIFF"}          @{"PopChunk()" LINK "PopChunk"}
@{"PropChunk()" LINK "PropChunk"}           @{"PropChunks()" LINK "PropChunks"}        @{"PushChunk()" LINK "PushChunk"}
@{"ReadChunkBytes()" LINK "ReadChunkBytes"}      @{"ReadChunkRecords()" LINK "ReadChunkRecords"}  @{"SetLocalItemPurge()" LINK "SetLocalItemPurge"}
@{"StopChunk()" LINK "StopChunk"}           @{"StopChunks()" LINK "StopChunks"}        @{"StopOnExit()" LINK "StopOnExit"}
@{"StoreItemInContext()" LINK "StoreItemInContext"}  @{"StoreLocalItem()" LINK "StoreLocalItem"}    @{"WriteChunkBytes()" LINK "WriteChunkBytes"}
@{"WriteChunkRecords()" LINK "WriteChunkRecords"}   

@ENDNODE
@NODE "AllocIFF" "iffparse.library/AllocIFF()"
@{b}

   NAME@{ub}
        @{"AllocIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 26} -- create a new IFFHandle structure. (V36)@{b}

   SYNOPSIS@{ub}
        iff = @{"AllocIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 26}()
        D0

        @{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *@{"AllocIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 26}(@{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24});@{b}

   FUNCTION@{ub}
        Allocates and initializes a new IFFHandle structure.
        This function is the only supported way to create an IFFHandle
        structure since there are private fields that need to be initialized.@{b}

   RESULT@{ub}
        iff - pointer to IFFHandle structure or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if the allocation failed.@{b}

   SEE ALSO@{ub}
        @{"FreeIFF()" LINK "FreeIFF"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "AllocLocalItem" "iffparse.library/AllocLocalItem()"
@{b}

   NAME@{ub}
        @{"AllocLocalItem" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 126} -- create a local context item structure. (V36)@{b}

   SYNOPSIS@{ub}
        item = @{"AllocLocalItem" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 126}(type, id, ident, dataSize);
        D0                    D0    D1  D2     D3

        @{"struct LocalContextItem" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 104} *@{"AllocLocalItem" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 126}(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Allocates and initializes a LocalContextItem structure with "dataSize"
        bytes of associated user data. This is the only supported way to
        create such an item. The user data can be accessed with the
        @{"LocalItemData()" LINK "LocalItemData"} function. An item created with this function
        automatically has its purge vectors set up correctly to dispose of
        itself and its associated user data area. Any additional cleanup
        should be done with a user-supplied purge vector.@{b}

   INPUTS@{ub}
        type,id - additional longword identification values
        ident - longword identifier for class of context item
        dataSize - number of bytes of user data to allocate for this item@{b}

   RESULT@{ub}
        item - pointer to initialized LocalContextItem or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if the
               allocation failed.@{b}

   SEE ALSO@{ub}
        @{"FreeLocalItem()" LINK "FreeLocalItem"}, @{"LocalItemData()" LINK "LocalItemData"}, @{"StoreLocalItem()" LINK "StoreLocalItem"},
        @{"StoreItemInContext()" LINK "StoreItemInContext"}, @{"SetLocalItemPurge()" LINK "SetLocalItemPurge"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "CloseClipboard" "iffparse.library/CloseClipboard()"
@{b}

   NAME@{ub}
        @{"CloseClipboard" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 170} -- close and free an open ClipboardHandle. (V36)@{b}

   SYNOPSIS@{ub}
        @{"CloseClipboard" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 170}(clipHandle);
                       A0

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"CloseClipboard" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 170}(@{"struct ClipboardHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 148} *);@{b}

   FUNCTION@{ub}
        Closes the @{"clipboard.device" LINK "gg:doc/NDK/Guide/clipboard/MAIN"} and frees the ClipboardHandle structure.@{b}

   INPUTS@{ub}
        clipHandle - pointer to ClipboardHandle struct created with
                     @{"OpenClipboard()" LINK "OpenClipboard"}. Starting with V39, this may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"OpenClipboard()" LINK "OpenClipboard"}, @{"InitIFFasClip()" LINK "InitIFFasClip"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "CloseIFF" "iffparse.library/CloseIFF()"
@{b}

   NAME@{ub}
        @{"CloseIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 38} -- close an IFF context. (V36)@{b}

   SYNOPSIS@{ub}
        @{"CloseIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 38}(iff);
                 A0

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"CloseIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 38}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *);@{b}

   FUNCTION@{ub}
        Completes an IFF read or write operation by closing the IFF context
        established for this IFFHandle structure. The IFFHandle structure
        itself is left ready for re-use and a new context can be opened with
        @{"OpenIFF()" LINK "OpenIFF"}. This function can be used for cleanup if a read or write
        fails partway through.

        As part of its cleanup operation, @{"CloseIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 38}() calls the client-
        supplied stream hook vector. The IFFStreamCmd packet will be set
        as follows:

                sc_Command:     @{"IFFCMD_CLEANUP" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 233}
                sc_Buf:         (Not applicable)
                sc_NBytes:      (Not applicable)

        This operation is @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} permitted to fail;  any error code returned
        will be ignored (best to return 0, though). DO @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} write to this
        structure.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure previously opened with
              @{"OpenIFF()" LINK "OpenIFF"}. Starting with V39, this may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"OpenIFF()" LINK "OpenIFF"}, @{"InitIFF()" LINK "InitIFF"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "CollectionChunk" "iffparse.library/CollectionChunk()"
@{b}

   NAME@{ub}
        @{"CollectionChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 94} -- declare a chunk type for collection. (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"CollectionChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 94}(iff, type, id);
        D0                      A0   D0    D1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"CollectionChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 94}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Installs an entry handler for chunks with the given type and id so
        that the contents of those chunks will be stored as they are
        encountered. This is like @{"PropChunk()" LINK "PropChunk"} except that more than one
        chunk of this type can be stored in lists which can be returned by
        @{"FindCollection()" LINK "FindCollection"}. The storage of these chunks still follows the
        property chunk scoping rules for IFF files so that at any given
        point, stored collection chunks will be valid in the current context.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure (does not need to be open)
        type - type code for the chunk to declare (ex. "ILBM")
        id - identifier for the chunk to declare (ex. "CRNG")@{b}

   RESULT@{ub}
        error - 0 if successful or an IFFERR_#? error code if unsuccessful.@{b}

   SEE ALSO@{ub}
        @{"CollectionChunks()" LINK "CollectionChunks"}, @{"FindCollection()" LINK "FindCollection"}, @{"PropChunk()" LINK "PropChunk"},
        <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "CollectionChunks" "iffparse.library/CollectionChunks()"
@{b}

   NAME@{ub}
        @{"CollectionChunks" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 98} -- declare many collection chunks at once. (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"CollectionChunks" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 98}(iff, propArray, numPairs);
        D0                       A0   A1         D0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"CollectionChunks" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 98}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Declares multiple collection chunks from a list. The propArray argument
        is a pointer to an array of longwords arranged in pairs. The format
        for the list is as follows:

                TYPE1, ID1, TYPE2, ID2, ..., TYPEn, IDn

        The argument numPairs is the number of pairs. @{"CollectionChunks" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 98}() just calls
        @{"CollectionChunk()" LINK "CollectionChunk"} numPairs times.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure (does not need to be open)
        propArray - pointer to array of longword chunk types and identifiers
        numPairs - number of pairs in array.@{b}

   RESULT@{ub}
        error - 0 if successful or an IFFERR_#? error code if unsuccessful@{b}

   SEE ALSO@{ub}
        @{"CollectionChunk()" LINK "CollectionChunk"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "CurrentChunk" "iffparse.library/CurrentChunk()"
@{b}

   NAME@{ub}
        @{"CurrentChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 118} -- get context node for current chunk. (V36)@{b}

   SYNOPSIS@{ub}
        top = @{"CurrentChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 118}(iff);
        D0                 A0

        @{"struct ContextNode" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 85} *@{"CurrentChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 118}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *);@{b}

   FUNCTION@{ub}
        Returns the top context node for the given IFFHandle structure. The top
        context node corresponds to the chunk most recently pushed on the
        stack, which is the chunk where the stream is currently positioned.
        The ContextNode structure contains information on the type of chunk
        currently being parsed (or written), its size and the current
        position within the chunk.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure@{b}

   RESULT@{ub}
        top - pointer to top context node or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if none@{b}

   SEE ALSO@{ub}
        @{"PushChunk()" LINK "PushChunk"}, @{"PopChunk()" LINK "PopChunk"}, @{"ParseIFF()" LINK "ParseIFF"}, @{"ParentChunk()" LINK "ParentChunk"},
        <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "EntryHandler" "iffparse.library/EntryHandler()"
@{b}

   NAME@{ub}
        @{"EntryHandler" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 70} -- add an entry handler to the IFFHandle context. (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"EntryHandler" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 70}(iff, type, id, position, handler, object);
        D0                   A0   D0    D1  D2        A1       A2

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"EntryHandler" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 70}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51},
                          @{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        Installs an entry handler vector for a specific type of chunk into
        the context for the given IFFHandle structure. Type and id are the
        longword identifiers for the chunk to handle. The handler is a client-
        supplied standard Hook structure, properly initialized. position
        tells where to put the handler in the context. The handler will be
        called whenever the parser enters a chunk of the given type, so the
        IFF stream will be positioned to read the first data byte in the
        chunk. The handler will execute in the same context as whoever
        called @{"ParseIFF()" LINK "ParseIFF"}. The handler will be called (through the hook)
        with the following arguments:

                A0:     the Hook pointer you passed.
                A2:     the 'object' pointer you passed.
                A1:     pointer to a @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} containing the value
                        @{"IFFCMD_ENTRY" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 237}.

        The error code your call-back routine returns will affect the parser
        in three different ways:

        Return value            Result
        ------------            ------
        0:                      Normal success;  @{"ParseIFF()" LINK "ParseIFF"} will continue
                                through the file.
        @{"IFF_RETURN2CLIENT" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 176}:      @{"ParseIFF()" LINK "ParseIFF"} will stop and return the value 0.
                                (@{"StopChunk()" LINK "StopChunk"} is internally implemented using
                                this return value.)
        Any other value:        @{"ParseIFF()" LINK "ParseIFF"} will stop and return the value
                                you supplied. This is how errors should be
                                returned.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure.
        type - type code for chunk to handle (ex. "ILBM").
        id - ID code for chunk to handle (ex. "CMAP").
        position- local context item position. One of the IFFSLI_#? codes.
        handler - pointer to Hook structure.
        object - a client-defined pointer which is passed in A2 during call-
                 back.@{b}

   RESULT@{ub}
        error - 0 if successful or an IFFERR_#? error code if unsuccessful.@{b}

   BUGS@{ub}
        Returning the values @{"IFFERR_EOF" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 165} or @{"IFFERR_EOC" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 166} from the call-back
        routine *may* confuse the parser.

        There is no way to explicitly remove a handler once installed.
        However, by installing a do-nothing handler using @{"IFFSLI_TOP" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 213},
        previous handlers will be overridden until the context expires.@{b}

   SEE ALSO@{ub}
        @{"ExitHandler()" LINK "ExitHandler"}, @{"StoreLocalItem()" LINK "StoreLocalItem"}, @{"StoreItemInContext()" LINK "StoreItemInContext"},
        <@{"utility/hooks.h" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File"}>, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "ExitHandler" "iffparse.library/ExitHandler()"
@{b}

   NAME@{ub}
        @{"ExitHandler" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 74} -- add an exit handler to the IFFHandle context. (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"ExitHandler" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 74}(iff, type, id, position, handler, object);
        D0                  A0   D0    D1  D2        A1       A2

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"ExitHandler" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 74}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51},
                         @{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} object(;@{b}

   FUNCTION@{ub}
        Installs an exit handler vector for a specific type of chunk into the
        context for the given IFFHandle structure. Type and id are the longword
        identifiers for the chunk to handle. The handler is a client-supplied
        standard Hook structure, properly initialized. Position tells
        where to put the handler in the context. The handler will be called
        just before the parser exits the given chunk in the "pause" parse
        state. The IFF stream may not be positioned predictably within the
        chunk. The handler will execute in the same context as whoever
        called @{"ParseIFF()" LINK "ParseIFF"}. The handler will be called (through the hook)
        with the following arguments:

                A0:     the Hook pointer you passed.
                A2:     the 'object' pointer you passed.
                A1:     pointer to a @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} containing the value
                        @{"IFFCMD_EXIT" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 238}.

        The error code your call-back routine returns will affect the parser
        in three different ways:

        Return value            Result
        ------------            ------
        0:                      Normal success;  @{"ParseIFF()" LINK "ParseIFF"} will continue
                                through the file.
        @{"IFF_RETURN2CLIENT" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 176}:      @{"ParseIFF()" LINK "ParseIFF"} will stop and return the value 0.
                                (@{"StopChunk()" LINK "StopChunk"} is internally implemented using
                                this return value.)
        Any other value:        @{"ParseIFF()" LINK "ParseIFF"} will stop and return the value
                                you supplied. This is how errors should be
                                returned.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure.
        type - type code for chunk to handle (ex. "ILBM").
        id - identifier code for chunk to handle (ex. "CMAP").
        position - local context item position. One of the IFFSLI_#? codes.
        handler - pointer to Hook structure.
        object - a client-defined pointer which is passed in A2 during call-
                 back.@{b}

   RESULT@{ub}
        error - 0 if successful or an IFFERR_#? error code if unsuccessful.@{b}

   BUGS@{ub}
        Returning the values @{"IFFERR_EOF" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 165} or @{"IFFERR_EOC" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 166} from the call-back
        routine *may* confuse the parser.

        There is no way to explicitly remove a handler once installed.
        However, by installing a do-nothing handler using @{"IFFSLI_TOP" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 213},
        previous handlers will be overridden until the context expires.@{b}

   SEE ALSO@{ub}
        @{"EntryHandler()" LINK "EntryHandler"}, @{"StoreLocalItem()" LINK "StoreLocalItem"}, @{"StoreItemInContext()" LINK "StoreItemInContext"},
        <@{"utility/hooks.h" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File"}>, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "FindCollection" "iffparse.library/FindCollection()"
@{b}

   NAME@{ub}
        @{"FindCollection" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 110} -- get a pointer to the current list of collection
                          items. (V36)@{b}

   SYNOPSIS@{ub}
        ci = @{"FindCollection" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 110}(iff, type, id);
        D0                  A0   D0    D1

        @{"struct CollectionItem" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 133} *@{"FindCollection" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 110}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Returns a pointer to a list of CollectionItem structures for each of
        the collection chunks of the given type encountered so far in the
        course of parsing this IFF file. The items appearing first in the
        list will be the ones encountered most recently.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure.
        type - type code to search for.
        id - identifier code to search for.@{b}

   RESULT@{ub}
        ci - pointer to last collection chunk encountered with
             links to previous ones.@{b}

   SEE ALSO@{ub}
        @{"CollectionChunk()" LINK "CollectionChunk"}, @{"CollectionChunks()" LINK "CollectionChunks"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "FindLocalItem" "iffparse.library/FindLocalItem()"
@{b}

   NAME@{ub}
        @{"FindLocalItem" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 142} -- return a local context item from the context stack.
                         (V36)@{b}

   SYNOPSIS@{ub}
        lci = @{"FindLocalItem" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 142}(iff, type, id, ident);
        D0                  A0   D0    D1  D2

        @{"struct LocalContextItem" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 104} *@{"FindLocalItem" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 142}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *,
                                               @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Searches the context stack of the given IFFHandle structure for a
        local context item which matches the given ident, type and id. This
        function searches the context stack from the most current context
        backwards, so that the item found (if any) will be the one with
        greatest precedence in the context stack.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure.
        type - type code to search for.
        id - ID code to search for.
        ident - ident code for the class of context item to search for
                (ex. "exhd" -- exit handler).@{b}

   RESULT@{ub}
        lci - pointer to local context item, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if nothing matched.@{b}

   SEE ALSO@{ub}
        @{"StoreLocalItem()" LINK "StoreLocalItem"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "FindProp" "iffparse.library/FindProp()"
@{b}

   NAME@{ub}
        @{"FindProp" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 106} -- search for a stored property chunk. (V36)@{b}

   SYNOPSIS@{ub}
        sp = @{"FindProp" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 106}(iff, type, id);
        D0            A0   D0    D1

        @{"struct StoredProperty" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 119} *@{"FindProp" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 106}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Searches for the stored property which is valid in the given context.
        Property chunks are automatically stored by @{"ParseIFF()" LINK "ParseIFF"} when
        pre-declared by @{"PropChunk()" LINK "PropChunk"} or @{"PropChunks()" LINK "PropChunks"}. The StoredProperty
        struct, if found, contains a pointer to a data buffer containing the
        contents of the stored property.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure.
        type - type code for chunk to search for (ex. "ILBM").
        id - identifier code for chunk to search for (ex. "CMAP").@{b}

   RESULT@{ub}
        sp - pointer to stored property, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if none found.@{b}

   SEE ALSO@{ub}
        @{"PropChunk()" LINK "PropChunk"}, @{"PropChunks()" LINK "PropChunks"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "FindPropContext" "iffparse.library/FindPropContext()"
@{b}

   NAME@{ub}
        @{"FindPropContext" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 114} -- get the property context for the current state.
                           (V36)@{b}

   SYNOPSIS@{ub}
        cn = @{"FindPropContext" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 114}(iff);
        D0                   A0

        @{"struct ContextNode" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 85} *@{"FindPropContext" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 114}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *);@{b}

   FUNCTION@{ub}
        Locates the context node which would be the scoping chunk for
        properties in the current parsing state. (Huh?)  This is used for
        locating the proper scoping context for property chunks i.e. the
        scope from which a property would apply. This is usually the FORM
        or LIST with the highest precedence in the context stack.

        If you don't understand this, read the IFF spec a couple more times.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure.@{b}

   RESULT@{ub}
        cn - ContextNode of property scoping chunk.@{b}

   SEE ALSO@{ub}
        @{"CurrentChunk()" LINK "CurrentChunk"}, @{"ParentChunk()" LINK "ParentChunk"}, @{"StoreItemInContext()" LINK "StoreItemInContext"},
        <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "FreeIFF" "iffparse.library/FreeIFF()"
@{b}

   NAME@{ub}
        @{"FreeIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 42} -- deallocate an IFFHandle structure. (V36)@{b}

   SYNOPSIS@{ub}
        @{"FreeIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 42}(iff);
                A0

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"FreeIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 42}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *);@{b}

   FUNCTION@{ub}
        Deallocates all resources associated with this IFFHandle structure.
        The structure MUST have already been closed with @{"CloseIFF()" LINK "CloseIFF"}.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure to free. Starting with V39,
              this may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"AllocIFF()" LINK "AllocIFF"}, @{"CloseIFF()" LINK "CloseIFF"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "FreeLocalItem" "iffparse.library/FreeLocalItem()"
@{b}

   NAME@{ub}
        @{"FreeLocalItem" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 138} -- deallocate a local context item structure. (V36)@{b}

   SYNOPSIS@{ub}
        @{"FreeLocalItem" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 138}(localItem);
                      A0

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"FreeLocalItem" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 138}(@{"struct LocalContextItem" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 104} *);@{b}

   FUNCTION@{ub}
        Frees the memory for the local context item and any associated user
        memory as allocated with @{"AllocLocalItem()" LINK "AllocLocalItem"}. User purge vectors should
        call this function after they have freed any other resources
        associated with this item.

        Note that @{"FreeLocalItem" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 138}() does @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} call the custom purge vector set
        up through @{"SetLocalItemPurge()" LINK "SetLocalItemPurge"}; all it does is free the local context
        item. (This implies that your custom purge vector would want to call
        this to ultimately free the LocalContextItem.)@{b}

   INPUTS@{ub}
        localItem - pointer to LocalContextItem created with @{"AllocLocalItem" LINK "AllocLocalItem"}.
                    Starting with V39, this may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"AllocLocalItem()" LINK "AllocLocalItem"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "GoodID" "iffparse.library/GoodID()"
@{b}

   NAME@{ub}
        @{"GoodID" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 174} -- test if an identifier follows the IFF 85 specification. (V36)@{b}

   SYNOPSIS@{ub}
        isok = @{"GoodID" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 174}(id);
        D0            D0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"GoodID" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 174}(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Tests the given longword identifier to see if it meets all the EA IFF
        85 specifications for a chunk ID. If so, it returns non-zero,
        otherwise 0.@{b}

   INPUTS@{ub}
        id - potential 32 bit identifier.@{b}

   RESULT@{ub}
        isok - non-zero if this is a valid ID, 0 otherwise.@{b}

   SEE ALSO@{ub}
        @{"GoodType()" LINK "GoodType"}

@ENDNODE
@NODE "GoodType" "iffparse.library/GoodType()"
@{b}

   NAME@{ub}
        @{"GoodType" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 178} -- test if a type follows the IFF 85 specification. (V36)@{b}

   SYNOPSIS@{ub}
        isok = @{"GoodType" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 178}(type)
        D0              D0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"GoodType" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 178}(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Tests the given longword type identifier to see if it meets all the
        EA IFF 85 specifications for a FORM type (requirements for a FORM
        type are more stringent than those for a simple chunk ID). If it
        complies, @{"GoodType" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 178}() returns non-zero, otherwise 0.@{b}

   INPUTS@{ub}
        type - potential 32 bit format type identifier.@{b}

   RESULT@{ub}
        isok - non-zero if this is a valid type id, 0 otherwise.@{b}

   SEE ALSO@{ub}
        @{"GoodID()" LINK "GoodID"}

@ENDNODE
@NODE "IDtoStr" "iffparse.library/IDtoStr()"
@{b}

   NAME@{ub}
        @{"IDtoStr" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 182} -- convert a longword identifier to a null-terminated string.
                   (V36)@{b}

   SYNOPSIS@{ub}
        str = @{"IDtoStr" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 182}(id, buf);
        D0            D0  A0

        @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} @{"IDtoStr" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 182}(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67});@{b}

   FUNCTION@{ub}
        Writes the ASCII equivalent of the given longword ID into buf as a
        null-terminated string.@{b}

   INPUTS@{ub}
        id - longword ID.
        buf - character buffer to accept string (at least 5 chars).@{b}

   RESULT@{ub}
        str - the value of 'buf'.

@ENDNODE
@NODE "InitIFF" "iffparse.library/InitIFF()"
@{b}

   NAME@{ub}
        @{"InitIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 154} -- initialize an IFFHandle structure as a user stream. (V36)@{b}

   SYNOPSIS@{ub}
        @{"InitIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 154}(iff, flags, streamHook);
                A0   D0     A1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"InitIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 154}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *);@{b}

   FUNCTION@{ub}
        Initializes an IFFHandle as a general user-defined stream by
        allowing the user to declare a hook that the library will call to
        accomplish the low-level reading, writing, and seeking of the stream.
        Flags are the stream I/O flags for the specified stream; typically a
        combination of the IFFF_?SEEK flags.

        The stream vector is called with the following arguments:

                A0:     pointer to streamhook.
                A2:     pointer to IFFHandle structure.
                A1:     pointer to IFFStreamCmd structure.

        The IFFStreamCmd packet appears as follows:

                sc_Command:     Contains an IFFCMD_#? value
                sc_Buf:         Pointer to memory buffer
                sc_NBytes:      Number of bytes involved in operation

        The values taken on by sc_Command, and their meaning, are as follows:

        @{"IFFCMD_INIT" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 232}:
                Prepare your stream for reading. This is used for certain
                streams that can't be read immediately upon opening, and need
                further preparation. (The @{"clipboard.device" LINK "gg:doc/NDK/Guide/clipboard/MAIN"} is an example of
                such a stream.)  This operation is allowed to fail;  any
                error code will be returned directly to the client. sc_Buf
                and sc_NBytes have no meaning here.
        @{"IFFCMD_CLEANUP" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 233}:
                Terminate the transaction with the associated stream. This
                is used with streams that can't simply be closed. (Again,
                the clipboard is an example of such a stream.)  This
                operation is not permitted to fail;  any error returned will
                be ignored (best to return 0, though). sc_Buf and sc_NBytes
                have no meaning here.
        @{"IFFCMD_READ" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 234}:
                Read from the stream. You are to read sc_NBytes from the
                stream and place them in the buffer pointed to by sc_Buf.
                Any (non-zero) error returned will be remapped by the parser
                into @{"IFFERR_READ" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 169}.
        @{"IFFCMD_WRITE" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 235}:
                Write to the stream. You are to write sc_NBytes to the
                stream from the buffer pointed to by sc_Buf. Any (non-zero)
                error returned will be remapped by the parser into
                @{"IFFERR_WRITE" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 170}.
        @{"IFFCMD_SEEK" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 236}:
                Seek on the stream. You are to perform a seek on the stream
                relative to the current position. sc_NBytes is signed;
                negative values mean seek backward, positive values mean seek
                forward. sc_Buf has no meaning here. Any (non-zero) error
                returned will be remapped by the parser into @{"IFFERR_SEEK" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 171}.

        All errors are returned in D0. A return of 0 indicates success.
        UNDER NO CIRCUMSTANCES are you permitted to write to the IFFStreamCmd
        structure.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure to initialize.
        flags - stream I/O flags for the IFFHandle.
        streamHook - pointer to Hook structure.@{b}

   SEE ALSO@{ub}
        <@{"utility/hooks.h" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File"}>, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "InitIFFasClip" "iffparse.library/InitIFFasClip()"
@{b}

   NAME@{ub}
        @{"InitIFFasClip" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 162} -- initialize an IFFHandle as a clipboard stream. (V36)@{b}

   SYNOPSIS@{ub}
        @{"InitIFFasClip" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 162}(iff);
                      A0

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"InitIFFasClip" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 162}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *);@{b}

   FUNCTION@{ub}
        Initializes the given IFFHandle to be a clipboard stream. The
        function initializes the stream processing vectors to operate on
        streams of the ClipboardHandle type. The iff_Stream field will still
        need to be initialized to point to a ClipboardHandle as returned from
        @{"OpenClipboard()" LINK "OpenClipboard"}.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure.@{b}

   SEE ALSO@{ub}
        @{"InitIFF()" LINK "InitIFF"}, @{"OpenClipboard()" LINK "OpenClipboard"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "InitIFFasDOS" "iffparse.library/InitIFFasDOS()"
@{b}

   NAME@{ub}
        @{"InitIFFasDOS" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 158} -- initialize an IFFHandle as a DOS stream. (V36)@{b}

   SYNOPSIS@{ub}
        @{"InitIFFasDOS" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 158}(iff)
                     A0

        @{"InitIFFasDOS" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 158}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *);@{b}

   FUNCTION@{ub}
        The function initializes the given IFFHandle to operate on DOS
        streams. The iff_Stream field will need to be initialized as a @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}
        returned from the DOS function @{"Open()" LINK "gg:doc/NDK/Guide/dos/Open"}.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure.@{b}

   SEE ALSO@{ub}
        @{"InitIFF()" LINK "InitIFF"}

@ENDNODE
@NODE "LocalItemData" "iffparse.library/LocalItemData()"
@{b}

   NAME@{ub}
        @{"LocalItemData" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 130} -- get pointer to user data for local context item. (V36)@{b}

   SYNOPSIS@{ub}
        data = @{"LocalItemData" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 130}(localItem);
        D0                   A0

        @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} @{"LocalItemData" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 130}(@{"struct LocalContextItem" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 104} *);@{b}

   FUNCTION@{ub}
        Returns pointer to the user data associated with the given local
        context item. The size of the data area depends on the "dataSize"
        argument used when allocating this item. If the pointer to the item
        given (localItem) is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, this function returns @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   INPUTS@{ub}
        localItem - pointer to local context item or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   RESULT@{ub}
        data - pointer to user data area or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if localItem is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   BUGS@{ub}
        Currently, there is no way to determine the size of the user data
        area; you have to 'know'.@{b}

   SEE ALSO@{ub}
        @{"AllocLocalItem()" LINK "AllocLocalItem"}, @{"FreeLocalItem()" LINK "FreeLocalItem"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "OpenClipboard" "iffparse.library/OpenClipboard()"
@{b}

   NAME@{ub}
        @{"OpenClipboard" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 166} -- create a handle on a clipboard unit. (V36)@{b}

   SYNOPSIS@{ub}
        ch = @{"OpenClipboard" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 166}(unitNumber)
        D0                 D0

        @{"struct ClipboardHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 148} *@{"OpenClipboard" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 166}(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Opens the @{"clipboard.device" LINK "gg:doc/NDK/Guide/clipboard/MAIN"} and opens a stream for the specified unit
        (usually @{"PRIMARY_CLIP" LINK "gg:doc/NDK/Guide/Include/devices/clipboard.h/File" 55}). This handle structure will be used as the
        clipboard stream for IFFHandles initialized as clipboard streams by
        @{"InitIFFasClip()" LINK "InitIFFasClip"}.@{b}

   INPUTS@{ub}
        unitNumber - clipboard unit number (usually @{"PRIMARY_CLIP" LINK "gg:doc/NDK/Guide/Include/devices/clipboard.h/File" 55}).@{b}

   RESULT@{ub}
        ch - pointer to ClipboardHandle structure or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if unsuccessful.@{b}

   BUGS@{ub}
        This function had several bugs prior to V39.

       First bug was that if the @{"clipboard.device" LINK "gg:doc/NDK/Guide/clipboard/MAIN"} couldn't open, two calls
        to @{"FreeSignal()" LINK "gg:doc/NDK/Guide/exec/FreeSignal"} were made with uninitialized values as parameters.
        The result of this was a corrupt signal mask in the Task field.

        Second bug was that @{"OpenDevice()" LINK "gg:doc/NDK/Guide/exec/OpenDevice"} was called with an IO request that
        didn't have a valid MsgPort pointer in it.

        Third bug was that the two message ports allocated by the function
        (ClipboardHandle->cbh_CBport and ClipboardHandle->cbh_SatisfyPort)
        were not being initialized correctly and would cause a system crash
        if a message ever got to either of them.@{b}

   SEE ALSO@{ub}
        @{"InitIFFasClip()" LINK "InitIFFasClip"}, @{"CloseClipboard()" LINK "CloseClipboard"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "OpenIFF" "iffparse.library/OpenIFF()"
@{b}

   NAME@{ub}
        @{"OpenIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 30} -- prepare an IFFHandle to read or write a new IFF stream.
                   (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"OpenIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 30}(iff, rwMode);
        D0              A0   D0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"OpenIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 30}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Initializes an IFFHandle structure for a new read or write. The
        direction of the I/O is given by the value of rwMode, which can be
        either @{"IFFF_READ" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 52} or @{"IFFF_WRITE" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 53}.

        As part of its initialization procedure, @{"OpenIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 30}() calls the client-
        supplied stream hook vector. The IFFStreamCmd packet will contain
        the following:

                sc_Command:     @{"IFFCMD_INIT" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 232}
                sc_Buf:         (Not applicable)
                sc_NBytes:      (Not applicable)

        This operation is permitted to fail. DO @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} write to this structure.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure. Starting with V39, this may be
              @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, in which case @{"IFFERR_NOMEM" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 168} is returned.
        rwMode - @{"IFFF_READ" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 52} or @{"IFFF_WRITE" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 53}@{b}

   RESULT@{ub}
        error - contains an error code or 0 if successful@{b}

   SEE ALSO@{ub}
        @{"CloseIFF()" LINK "CloseIFF"}, @{"InitIFF()" LINK "InitIFF"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "ParentChunk" "iffparse.library/ParentChunk()"
@{b}

   NAME@{ub}
        @{"ParentChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 122} -- get the nesting context node for the given chunk. (V36)@{b}

   SYNOPSIS@{ub}
        parent = @{"ParentChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 122}(contextNode);
        D0                   A0

        @{"struct ContextNode" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 85} *@{"ParentChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 122}(@{"struct ContextNode" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 85} *);@{b}

   FUNCTION@{ub}
        Returns a context node for the chunk containing the chunk for the
        given context node. This function effectively moves down the context
        stack into previously pushed contexts. For example, to get a
        ContextNode pointer for the enclosing FORM chunk while reading a data
        chunk, use: @{"ParentChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 122}(@{"CurrentChunk" LINK "CurrentChunk"}(iff)) to find this pointer.
        The ContextNode structure contains information on the type of chunk
        and its size.@{b}

   INPUTS@{ub}
        contextNode - pointer to a context node.@{b}

   RESULT@{ub}
        parent - pointer to the enclosing context node or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if none.@{b}

   SEE ALSO@{ub}
        @{"CurrentChunk()" LINK "CurrentChunk"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "ParseIFF" "iffparse.library/ParseIFF()"
@{b}

   NAME@{ub}
        @{"ParseIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 34} -- parse an IFF file from an IFFHandle structure stream. (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"ParseIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 34}(iff, control);
        D0               A0   D0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"ParseIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 34}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        This is the biggie.

        Traverses a file opened for read by pushing chunks onto the context
        stack and popping them off directed by the generic syntax of IFF
        files. As it pushes each new chunk, it searches the context stack
        for handlers to apply to chunks of that type. If it finds an entry
        handler it will invoke it just after entering the chunk. If it finds
        an exit handler it will invoke it just before leaving the chunk.
        Standard handlers include entry handlers for pre-declared
        property chunks and collection chunks and entry and exit handlers for
        for stop chunks - that is, chunks which will cause the @{"ParseIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 34}()
        function to return control to the client. Client programs can also
        provide their own custom handlers.

        The control flag can have three values:

        @{"IFFPARSE_SCAN" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 203}:
                In this normal mode, @{"ParseIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 34}() will only return control to
                the caller when either:
                        1) an error is encountered,
                        2) a stop chunk is encountered, or a user handler
                           returns the special @{"IFF_RETURN2CLIENT" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 176} code, or
                        3) the end of the logical file is reached, in which
                           case @{"IFFERR_EOF" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 165} is returned.

                @{"ParseIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 34}() will continue pushing and popping chunks until one
                of these conditions occurs. If @{"ParseIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 34}() is called again
                after returning, it will continue to parse the file where it
                left off.

        @{"IFFPARSE_STEP" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 204} and _RAWSTEP:
                In these two modes, @{"ParseIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 34}() will return control to the
                caller after every step in the parse, specifically, after
                each push of a context node and just before each pop. If
                returning just before a pop, @{"ParseIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 34}() will return
                @{"IFFERR_EOC" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 166}, which is not an error, per se, but is just an
                indication that the most recent context is ending. In STEP
                mode, @{"ParseIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 34}() will invoke the handlers for chunks, if
                any, before returning. In RAWSTEP mode, @{"ParseIFF" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 34}() will not
                invoke any handlers and will return right away. In both
                cases the function can be called multiple times to step
                through the parsing of the IFF file.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure.
        control - control code (@{"IFFPARSE_SCAN" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 203}, _STEP or _RAWSTEP).@{b}

   RESULT@{ub}
        error - 0 or IFFERR_#? value or return value from user handler.@{b}

   SEE ALSO@{ub}
        @{"PushChunk()" LINK "PushChunk"}, @{"PopChunk()" LINK "PopChunk"}, @{"EntryHandler()" LINK "EntryHandler"}, @{"ExitHandler()" LINK "ExitHandler"},
        @{"PropChunk()" LINK "PropChunk"}, @{"CollectionChunk()" LINK "CollectionChunk"}, @{"StopChunk()" LINK "StopChunk"}, @{"StopOnExit()" LINK "StopOnExit"},
        <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "PopChunk" "iffparse.library/PopChunk()"
@{b}

   NAME@{ub}
        @{"PopChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 66} -- pop top context node off context stack. (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"PopChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 66}(iff);
        D0               A0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"PopChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 66}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *);@{b}

   FUNCTION@{ub}
        Pops top context chunk and frees all associated local context items.
        The function is normally called only for writing files and signals
        the end of a chunk.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure.@{b}

   RESULT@{ub}
        error - 0 if successful or an IFFERR_#? error code if unsuccessful.@{b}

   SEE ALSO@{ub}
        @{"PushChunk()" LINK "PushChunk"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "PropChunk" "iffparse.library/PropChunk()"
@{b}

   NAME@{ub}
        @{"PropChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 78} -- specify a property chunk to store. (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"PropChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 78}(iff, type, id);
        D0                A0   D0    D1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"PropChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 78}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Installs an entry handler for chunks with the given type and ID so
        that the contents of those chunks will be stored as they are
        encountered. The storage of these chunks follows the property chunk
        scoping rules for IFF files so that at any given point, a stored
        property chunk returned by @{"FindProp()" LINK "FindProp"} will be the valid property for
        the current context.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure (does not need to be open).
        type - type code for the chunk to declare (ex. "ILBM").
        id - identifier for the chunk to declare (ex. "CMAP").@{b}

   RESULT@{ub}
        error - 0 if successful or an IFFERR_#? error code if unsuccessful.@{b}

   SEE ALSO@{ub}
        @{"PropChunks()" LINK "PropChunks"}, @{"FindProp()" LINK "FindProp"}, @{"CollectionChunk()" LINK "CollectionChunk"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "PropChunks" "iffparse.library/PropChunks()"
@{b}

   NAME@{ub}
        @{"PropChunks" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 82} -- declare many property chunks at once. (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"PropChunks" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 82}(iff, propArray, numPairs);
        D0                 A0   A1         D0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"PropChunks" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 82}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Declares multiple property chunks from a list. The propArray argument
        if a pointer to an array of longwords arranged in pairs, and has the
        following format:

                TYPE1, ID1, TYPE2, ID2, ..., TYPEn, IDn

        The argument numPairs is the number of pairs. @{"PropChunks" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 82}() just calls
        @{"PropChunk()" LINK "PropChunk"} numPairs times.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure.
        propArray - pointer to array of longword chunk types and identifiers.
        numPairs - number of pairs in the array.@{b}

   RESULT@{ub}
        error - 0 if successful or an IFFERR_#? error code if unsuccessful.@{b}

   SEE ALSO@{ub}
        @{"PropChunk()" LINK "PropChunk"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "PushChunk" "iffparse.library/PushChunk()"
@{b}

   NAME@{ub}
        @{"PushChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 62} -- push a new context node on the context stack. (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"PushChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 62}(iff, type, id, size);
        D0                A0   D0    D1  D2

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"PushChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 62}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Pushes a new context node on the context stack by reading it from the
        stream if this is a read file, or by creating it from the passed
        parameters if this is a write file. Normally this function is only
        called in write mode, where the type and id codes specify the new
        chunk to create. If this is a leaf chunk, i.e. a local chunk inside
        a FORM or PROP chunk, then the type argument is ignored. If the size
        is specified then the chunk writing functions will enforce this size.
        If the size is given as @{"IFFSIZE_UNKNOWN" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 225}, the chunk will expand to
        accommodate whatever is written into it.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure.
        type - chunk type specifier (ex. ILBM) (ignored for read mode or
               leaf chunks).
        id - chunk id specifier (ex. CMAP) (ignored for read mode).
        size - size of the chunk to create or @{"IFFSIZE_UNKNOWN" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 225} (ignored for
               read mode).@{b}

   RESULT@{ub}
        error - 0 if successful or an IFFERR_#? error code if not unsuccessful.@{b}

   SEE ALSO@{ub}
        @{"PopChunk()" LINK "PopChunk"}, @{"WriteChunkRecords()" LINK "WriteChunkRecords"}, @{"WriteChunkBytes()" LINK "WriteChunkBytes"},
        <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "ReadChunkBytes" "iffparse.library/ReadChunkBytes()"
@{b}

   NAME@{ub}
        @{"ReadChunkBytes" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 46} -- read bytes from the current chunk into a buffer.
                          (V36)@{b}

   SYNOPSIS@{ub}
        actual = @{"ReadChunkBytes" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 46}(iff, buf, numBytes);
        D0                      A0   A1   D0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"ReadChunkBytes" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 46}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} buf, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Reads the IFFHandle stream into the buffer for the specified number
        of bytes. Reads are limited to the size of the current chunk and
        attempts to read past the end of the chunk will truncate. This
        function returns positive number of bytes read or a negative error
        code.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure.
        buf - pointer to buffer area to receive data.
        numBytes - number of bytes to read.@{b}

   RESULT@{ub}
        actual - (positive) number of bytes read if successful or a
                 (negative) IFFERR_#? error code if unsuccessful.@{b}

   SEE ALSO@{ub}
        @{"ReadChunkRecords()" LINK "ReadChunkRecords"}, @{"ParseIFF()" LINK "ParseIFF"}, @{"WriteChunkBytes()" LINK "WriteChunkBytes"},
        <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "ReadChunkRecords" "iffparse.library/ReadChunkRecords()"
@{b}

   NAME@{ub}
        @{"ReadChunkRecords" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 54} -- read record elements from the current chunk into
                            a buffer. (V36)@{b}

   SYNOPSIS@{ub}
        actual = @{"ReadChunkRecords" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 54}(iff, buf, bytesPerRecord, numRecords);
        D0                        A0   A1   D0              D1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"ReadChunkRecords" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 54}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Reads records from the current chunk into buffer. Truncates attempts
        to read past end of chunk (only whole records are read; remaining
        bytes that are not of a whole record size are left unread and
        available for @{"ReadChunkBytes()" LINK "ReadChunkBytes"}).@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure.
        buf - pointer to buffer area to receive data.
        bytesPerRecord  - size of data records to read.
        numRecords - number of data records to read.@{b}

   RESULT@{ub}
        actual - (positive) number of whole records read if successful or a
                 (negative) IFFERR_#? error code if unsuccessful.@{b}

   SEE ALSO@{ub}
        @{"ReadChunkBytes()" LINK "ReadChunkBytes"}, @{"ParseIFF()" LINK "ParseIFF"}, @{"WriteChunkRecords()" LINK "WriteChunkRecords"},
        <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "SetLocalItemPurge" "iffparse.library/SetLocalItemPurge()"
@{b}

   NAME@{ub}
        @{"SetLocalItemPurge" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 134} -- set purge vector for a local context item. (V36)@{b}

   SYNOPSIS@{ub}
        @{"SetLocalItemPurge" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 134}(localItem, purgeHook);
                          A0         A1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"SetLocalItemPurge" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 134}(@{"struct LocalContextItem" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 104} *, @{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *);@{b}

   FUNCTION@{ub}
        Sets a local context item to use a client-supplied cleanup (purge)
        vector for disposal when its context is popped. The purge vector
        will be called when the ContextNode containing this local item is
        popped off the context stack and is about to be deleted itself. If
        the purge vector has not been set, the parser will use @{"FreeLocalItem()" LINK "FreeLocalItem"}
        to delete the item, but if this function is used to set the purge
        vector, the supplied vector will be called with the following
        arguments:

                A0:     pointer to purgeHook.
                A2:     pointer to LocalContextItem to be freed.
                A1:     pointer to a @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} containing the value
                        @{"IFFCMD_PURGELCI" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 239}.

        The user purge vector is then responsible for calling @{"FreeLocalItem()" LINK "FreeLocalItem"}
        as part of its own cleanup. Although the purge vector can return a
        value, it will be ignored -- purge vectors must always work (best to
        return 0, though).@{b}

   INPUTS@{ub}
        localItem - pointer to a local context item.
        purgeHook - pointer to a Hook structure.@{b}

   SEE ALSO@{ub}
        @{"AllocLocalItem()" LINK "AllocLocalItem"}, @{"FreeLocalItem()" LINK "FreeLocalItem"}, <@{"utility/hooks.h" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File"}>
        <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "StopChunk" "iffparse.library/StopChunk()"
@{b}

   NAME@{ub}
        @{"StopChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 86} -- declare a chunk which should cause @{"ParseIFF" LINK "ParseIFF"} to return.
                     (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"StopChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 86}(iff, type, id);
        D0                A0   D0    D1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"StopChunk" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 86}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});          type;@{b}

   FUNCTION@{ub}
        Installs an entry handler for the specified chunk which will cause
        the @{"ParseIFF()" LINK "ParseIFF"} function to return control to the caller when this
        chunk is encountered. This is only of value when @{"ParseIFF()" LINK "ParseIFF"} is
        called with the @{"IFFPARSE_SCAN" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 203} control code.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure (need not be open).
        type - type code for chunk to declare (ex. "ILBM").
        id - identifier for chunk to declare (ex. "BODY").@{b}

   RESULT@{ub}
        error - 0 if successful or an IFFERR_#? error code if unsuccessful.@{b}

   SEE ALSO@{ub}
        @{"StopChunks()" LINK "StopChunks"}, @{"ParseIFF()" LINK "ParseIFF"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "StopChunks" "iffparse.library/StopChunks()"
@{b}

   NAME@{ub}
        @{"StopChunks" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 90} -- declare many stop chunks at once. (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"StopChunks" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 90}(iff, propArray, numPairs);
        D0                 A0   A1         D0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"StopChunks" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 90}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        (is to @{"StopChunk()" LINK "StopChunk"} as @{"PropChunks()" LINK "PropChunks"} is to @{"PropChunk()" LINK "PropChunk"}.)@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure.
        propArray - pointer to array of longword chunk types and identifiers.
        numPairs - number of pairs in the array.@{b}

   RESULT@{ub}
        error - 0 if successful or an IFFERR_#? error code if unsuccessful.@{b}

   SEE ALSO@{ub}
        @{"StopChunk()" LINK "StopChunk"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "StopOnExit" "iffparse.library/StopOnExit()"
@{b}

   NAME@{ub}
        @{"StopOnExit" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 102} -- declare a stop condition for exiting a chunk. (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"StopOnExit" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 102}(iff, type, id);
        D0                 A0   D0    D1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"StopOnExit" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 102}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Installs an exit handler for the specified chunk which will cause the
        @{"ParseIFF()" LINK "ParseIFF"} function to return control to the caller when this chunk
        is exhausted. @{"ParseIFF()" LINK "ParseIFF"} will return @{"IFFERR_EOC" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 166} when the declared
        chunk is about to be popped. This is only of value when @{"ParseIFF()" LINK "ParseIFF"}
        is called with the @{"IFFPARSE_SCAN" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 203} control code.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure (need not be open).
        type - type code for chunk to declare (ex. "ILBM").
        id - identifier for chunk to declare (ex. "BODY").@{b}

   RESULT@{ub}
        error - 0 if successful or an IFFERR_#? error code if unsuccessful.@{b}

   SEE ALSO@{ub}
        @{"ParseIFF()" LINK "ParseIFF"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "StoreItemInContext" "iffparse.library/StoreItemInContext()"
@{b}

   NAME@{ub}
        @{"StoreItemInContext" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 150} -- store local context item in given context node.
                              (V36)@{b}

   SYNOPSIS@{ub}
        @{"StoreItemInContext" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 150}(iff, localItem, contextNode);
                           A0   A1         A2

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"StoreItemInContext" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 150}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"struct LocalContextItem" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 104} *,
                               @{"struct ContextNode" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 85} *);@{b}

   FUNCTION@{ub}
        Adds the LocalContextItem to the list of items for the given context
        node. If an LCI with the same Type, ID, and Ident is already
        present in the ContextNode, it will be purged and replaced with the
        new one. This is a raw form of @{"StoreLocalItem()" LINK "StoreLocalItem"}.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure for this context.
        localItem - pointer to a LocalContextItem to be stored.
        contextNode - pointer to context node in which to store item.@{b}

   SEE ALSO@{ub}
        @{"StoreLocalItem()" LINK "StoreLocalItem"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "StoreLocalItem" "iffparse.library/StoreLocalItem()"
@{b}

   NAME@{ub}
        @{"StoreLocalItem" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 146} -- insert a local context item into the context stack.
                          (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"StoreLocalItem" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 146}(iff, localItem, position);
        D0                     A0   A1         D0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"StoreLocalItem" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 146}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"struct LocalContextItem" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 104} *,
                            @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Adds the local context item to the list of items for one of the
        context nodes on the context stack and purges any other item in the
        same context with the same ident, type and id. The position argument
        determines where in the stack to add the item:

        @{"IFFSLI_ROOT" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 212}:
                Add item to list at root (default) stack position.
        @{"IFFSLI_TOP" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 213}:
                Add item to the top (current) context node.
        @{"IFFSLI_PROP" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 214}:
                Add element in top property context. Top property context is
                either the top FORM chunk, or the top LIST chunk, whichever
                is closer to the top of the stack.

        Items added to the root context, or added to the top context before
        the IFFHandle has been opened or after it has been closed, are put in
        the default context. That is, they will be the local items found
        only after all other context nodes have been searched. Items in the
        default context are also immune to being purged until the IFFHandle
        structure itself is deleted with @{"FreeIFF()" LINK "FreeIFF"}. This means that handlers
        installed in the root context will still be there after an IFFHandle
        structure has been opened and closed. (Note that this implies that
        items stored in a higher context will be deleted when that context
        ends.)@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure.
        localItem - pointer to LocalContextItem struct to insert.
        position - where to store the item (@{"IFFSLI_ROOT" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 212}, _TOP or _PROP).@{b}

   RESULT@{ub}
        error - 0 if successful or an IFFERR_#? error code if unsuccessful.@{b}

   SEE ALSO@{ub}
        @{"FindLocalItem()" LINK "FindLocalItem"}, @{"StoreItemInContext()" LINK "StoreItemInContext"}, @{"EntryHandler()" LINK "EntryHandler"}, @{"ExitHandler()" LINK "ExitHandler"},
        <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "WriteChunkBytes" "iffparse.library/WriteChunkBytes()"
@{b}

   NAME@{ub}
        @{"WriteChunkBytes" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 50} -- write data from a buffer into the current chunk.
                           (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"WriteChunkBytes" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 50}(iff, buf, numBytes);
        D0                      A0   A1   D0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"WriteChunkBytes" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 50}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Writes "numBytes" bytes from the specified buffer into the current
        chunk. If the current chunk was pushed with @{"IFFSIZE_UNKNOWN" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 225}, the size
        of the chunk gets increased by the size of the buffer written. If
        the size was specified for this chunk, attempts to write past the end
        of the chunk will be truncated.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure.
        buf - pointer to buffer area with bytes to be written.
        numBytes - number of bytes to write.@{b}

   RESULT@{ub}
        error - (positive) number of bytes written if successful or a
                (negative) IFFERR_#? error code if unsuccessful.@{b}

   SEE ALSO@{ub}
        @{"PushChunk()" LINK "PushChunk"}, @{"PopChunk()" LINK "PopChunk"}, @{"WriteChunkRecords()" LINK "WriteChunkRecords"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
@NODE "WriteChunkRecords" "iffparse.library/WriteChunkRecords()"
@{b}

   NAME@{ub}
        @{"WriteChunkRecords" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 58} -- write records from a buffer to the current
                             chunk. (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"WriteChunkRecords" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 58}(iff, buf, recsize, numrec);
        D0                        A0   A1   D0       D1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"WriteChunkRecords" LINK "gg:doc/NDK/Guide/Include/inline/iffparse.h/File" 58}(@{"struct IFFHandle" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File" 44} *, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Writes record elements from the buffer into the top chunk. This
        function operates much like @{"ReadChunkBytes()" LINK "ReadChunkBytes"}.@{b}

   INPUTS@{ub}
        iff - pointer to IFFHandle structure.
        buf - pointer to buffer area containing data.
        recsize - size of data records to write.
        numrec - number of data records to write.@{b}

   RESULT@{ub}
        error - (positive) number of whole records written if successful
                or a (negative) IFFERR_#? error code if unsuccessful.@{b}

   SEE ALSO@{ub}
        @{"WriteChunkBytes()" LINK "WriteChunkBytes"}, <@{"libraries/iffparse.h" LINK "gg:doc/NDK/Guide/Include/libraries/iffparse.h/File"}>

@ENDNODE
