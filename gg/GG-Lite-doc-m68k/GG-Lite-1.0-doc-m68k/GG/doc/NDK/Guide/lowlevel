@DATABASE "gg:doc/NDK/Guide/lowlevel"
@MASTER   "gg:doc/NDK/AutoDocs/lowlevel.doc"
@REMARK   This file was created by ADtoHT 2.1 on 06-Jan-13 19:24:13
@REMARK   Do not edit
@REMARK   ADtoHT is © 1993-1995 Christian Stieber

@NODE MAIN "lowlevel.doc"
@TOC "gg:doc/NDK/Guide/TOC/MAIN"

                              @{b}lowlevel.library@{ub}

@{"AddKBInt()" LINK "AddKBInt"}          @{"AddTimerInt()" LINK "AddTimerInt"}     @{"AddVBlankInt()" LINK "AddVBlankInt"}
@{"ElapsedTime()" LINK "ElapsedTime"}       @{"GetKey()" LINK "GetKey"}          @{"GetLanguageSelection()" LINK "GetLanguageSelection"}
@{"QueryKeys()" LINK "QueryKeys"}         @{"ReadJoyPort()" LINK "ReadJoyPort"}     @{"RemKBInt()" LINK "RemKBInt"}
@{"RemTimerInt()" LINK "RemTimerInt"}       @{"RemVBlankInt()" LINK "RemVBlankInt"}    @{"SetJoyPortAttrs()" LINK "SetJoyPortAttrsA"}
@{"SetJoyPortAttrsA()" LINK "SetJoyPortAttrsA"}  @{"StartTimerInt()" LINK "StartTimerInt"}   @{"StopTimerInt()" LINK "StopTimerInt"}
@{"SystemControl()" LINK "SystemControlA"}     @{"SystemControlA()" LINK "SystemControlA"}  

@ENDNODE
@NODE "AddKBInt" "lowlevel.library/AddKBInt()"
@{b}

   NAME@{ub}
        @{"AddKBInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 48} -- adds a routine to the keyboard interrupt. (V40)@{b}

   SYNOPSIS@{ub}
        intHandle = @{"AddKBInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 48}(intRoutine, intData);
        D0                   A0          A1

        @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} @{"AddKBInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 48}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49}, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        This routine extends the functionality of the keyboard interrupt to
        include intRoutine. Since this is an extention of the normal
        keyboard interrupt all of the keyboard handshaking is handled. The
        keyboard error codes are filtered out and not passed to intRoutine.

        The routine is called whenever the user enters a key on the
        keyboard.

        The routine is called from within an interrupt, so normal
        restrictions apply. The routine must preserve the following
        registers: A2, A3, A4, A7, D2-D7. Other registers are
        scratch, except for D0, which MUST BE SET TO 0 upon
        exit. On entry to the routine, A1 holds 'intData' and A5
        holds 'intRoutine', and D0 contains the rawkey code read
        from the keyboard.

        The routine is not called when a reset is received from the
        keyboard.

        This is a low level function that does not fit the normal Amiga
        multitasking model. The interrupt installed will have no knowledge
        of which window/screen currently has input focus.

        If your program is to exit without reboot, you MUST call @{"RemKBInt()" LINK "RemKBInt"}
        before exiting.

        Only one interrupt routine may be added to the system.  ALWAYS
        check the return value in case some other task has previously
        used this function.@{b}

   INPUTS@{ub}
        intRoutine - the routine to invoke every vblank. This routine should
                     be as short as possible to minimize its effect on overall
                     system performance.
        intData - data passed to the routine in register A1. If more than one
                  long word of data is required this should be a pointer to
                  a structure that contains the required data.@{b}

   RESULT@{ub}
        intHandle - a handle used to manipulate the interrupt, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                    if it was not possible to attach the routine.@{b}

   SEE ALSO@{ub}
        @{"RemKBInt()" LINK "RemKBInt"}

@ENDNODE
@NODE "AddTimerInt" "lowlevel.library/AddTimerInt()"
@{b}

   NAME@{ub}
        @{"AddTimerInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 65} -- adds an interrupt that is executed at regular
                       intervals. (V40)@{b}

   SYNOPSIS@{ub}
        intHandle = @{"AddTimerInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 65}(intRoutine, intData);
        D0                      A0          A1

        @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} @{"AddTimerInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 65}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49}, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        Calling this routine causes the system to allocate a CIA timer
        and set up 'intRoutine' to service any interrupts caused by the timer.
        Although the timer is allocated it is neither running, nor enabled.
        StartIntTimer() must be called to establish the time interval and
        start the timer.

        The routine is called from within an interrupt, so normal
        restrictions apply. The routine must preserve the following
        registers: A2, A3, A4, A7, D2-D7. Other registers are
        scratch, except for D0, which MUST BE SET TO 0 upon
        exit. On entry to the routine, A1 holds 'intData' and A5
        holds 'intRoutine'.

        Only a single CIA timer will be allocated by this routine. So this
        routine may only be called once without an intervening call to
        @{"RemTimerInt()" LINK "RemTimerInt"}.

        The CIA timer used by this routine is not guaranteed to always be
        the same. This routine utilizes the CIA resource and uses an
        unallocated CIA timer.

        If your program is to exit without reboot, you MUST match all
        calls to this function with calls to @{"RemTimerInt()" LINK "RemTimerInt"} before exiting.

        Even if you only use the function once in your program; checking
        the return value will make your program more tolerant for
        mulititasking on the Amiga computer platforms.@{b}

   INPUTS@{ub}
        intRoutine - the routine to invoke upon timer interrupts. This routine
                     should be as short as possible to minimize its effect on
                     overall system performance.
        intData - data passed to the routine in register A1. If more than one
                  long word of data is required this should be a pointer to
                  a structure that contains the required data.@{b}

   RESULT@{ub}
        intHandle - a handle used to manipulate the interrupt, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                    if it was not possible to attach the routine.@{b}

   SEE ALSO@{ub}
        @{"RemTimerInt()" LINK "RemTimerInt"}, @{"StopTimerInt()" LINK "StopTimerInt"}, @{"StartTimerInt()" LINK "StartTimerInt"}

@ENDNODE
@NODE "AddVBlankInt" "lowlevel.library/AddVBlankInt()"
@{b}

   NAME@{ub}
        @{"AddVBlankInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 85} -- adds a routine executed every vertical blank. (V40)@{b}

   SYNOPSIS@{ub}
        intHandle = @{"AddVBlankInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 85}(intRoutine, intData);
        D0                       a0       a1

        @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} @{"AddVBlankInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 85}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49}, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        Lets you attach a routine to the system which will get called
        everytime a vertical blanking interrupt occurs.

        The routine is called from within an interrupt, so normal
        restrictions apply. The routine must preserve the following
        registers: A2, A3, A4, A7, D2-D7. Other registers are
        scratch, except for D0, which MUST BE SET TO 0 upon
        exit. On entry to the routine, A1 holds 'intData' and A5
        holds 'intRoutine'.

        If your program is to exit without reboot, you MUST call
        @{"RemVBlankInt()" LINK "RemVBlankInt"} before exiting.

        Only one interrupt routine may be added to the system.  ALWAYS check
        the return value in case some other task has previously used this
        function.@{b}

   INPUTS@{ub}
        intRoutine - the routine to invoke every vblank. This routine should
                     be as short as possible to minimize its effect on overall
                     system performance.
        intData - data passed to the routine in register A1. If more than one
                  long word of data is required this should be a pointer to
                  a structure that contains the required data.@{b}

   RESULT@{ub}
        intHandle - a handle used to manipulate the interrupt, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                    if it was not possible to attach the routine.@{b}

   SEE ALSO@{ub}
        @{"RemVBlankInt()" LINK "RemVBlankInt"}

@ENDNODE
@NODE "ElapsedTime" "lowlevel.library/ElapsedTime()"
@{b}

   NAME@{ub}
        @{"ElapsedTime" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 81} -- returns the time elapsed since it was last called. (V40)@{b}

   SYNOPSIS@{ub}
        fractionalSeconds = @{"ElapsedTime" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 81}(context);
        D0                              A0

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"ElapsedTime" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 81}(@{"struct EClockVal" LINK "gg:doc/NDK/Guide/Include/devices/timer.h/File" 35} *);@{b}

   FUNCTION@{ub}
        This function utilizes the @{"timer.device/ReadEClock()" LINK "gg:doc/NDK/Guide/timer/ReadEClock"} function to get
        an accurate elapsed time value. Since the context needs to be
        established the first call to this routine will return a nonsense
        value.

        The return value for this function only allows for sixteen bits
        worth for the integer number of seconds and sixteen bits for the
        factional number of seconds.

        With sixteen bits worth of integer seconds this function can be
        used to timer an interval up to about 16 hours. If the actual time
        interval is larger this function will return this maximum value.

        The sixteen bits for fractional seconds gives a resolution of
        approximately 20 microseconds. However, it is not recomended
        to expect this function to be accurate for a time interval of
        less than 200 microseconds.@{b}

   INPUTS@{ub}
        context - pointer to an EClockVal structure. The first time you
                  call this function, you should initialize the structure
                  to 0s. You should then reuse the same structure for
                  subsequent calls to this function, as this is how the
                  elapsed time is calculated.@{b}

   RESULT@{ub}
        fractionalSeconds - The elapsed time as a fixed point 32-bit
                            number with the point fixed in the middle.
                            That is, the upper order sixteen bits represent
                            the number of seconds elapsed. The low order
                            sixteen bit represent the fractional number of
                            seconds elapsed. This value is limited to about
                            sixteen hours. Although this value is precise
                            to nearly 20 microseconds it is only accurate to
                            within 200 microseconds.@{b}

   WARNING@{ub}
        The first call to this function will return a non-sense value. Only
        rely on its result starting with the second call.@{b}

   SEE ALSO@{ub}
        @{"timer.device/ReadEClock()" LINK "gg:doc/NDK/Guide/timer/ReadEClock"}

@ENDNODE
@NODE "GetKey" "lowlevel.library/GetKey()"
@{b}

   NAME@{ub}
        @{"GetKey" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 40} -- returns the currently pressed rawkey code and qualifiers.
                  (V40)@{b}

   SYNOPSIS@{ub}
        key = @{"GetKey" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 40}();
        D0

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"GetKey" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 40}(@{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24});@{b}

   FUNCTION@{ub}
        This function returns the currently pressed non-qualifier key and
        all pressed qualifiers.

        This function is safe within an interrupt.

        This is a low level function that does not fit the normal Amiga
        multitasking model. The values returned by this function are
        not modified by which window/screen currently has input focus.@{b}

   RESULT@{ub}
        key - key code for the last non-qualifier key pressed in the low
              order word. If no key is pressed this word will be FF. The
              upper order word contains the qualifiers which can be found
              within the long word as follows:
                        Qualifier               Key
                        @{"LLKB_LSHIFT" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 41}             Left Shift
                        @{"LLKB_RSHIFT" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 42}             Rigt Shift
                        @{"LLKB_CAPSLOCK" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 43}           Caps Lock
                        @{"LLKB_CONTROL" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 44}            Control
                        @{"LLKB_LALT" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 45}               Left Alt
                        @{"LLKB_RALT" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 46}               Right Alt
                        @{"LLKB_LAMIGA" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 47}             Left Amiga
                        @{"LLKB_RAMIGA" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 48}             Right Amiga@{b}

   SEE ALSO@{ub}
        <@{"libraries/lowlevel.h" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File"}>

@ENDNODE
@NODE "GetLanguageSelection" "lowlevel.library/GetLanguageSelection()"
@{b}

   NAME@{ub}
        @{"GetLanguageSelection" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 36} -- returns the current language selection. (V40)@{b}

   SYNOPSIS@{ub}
        language = @{"GetLanguageSelection" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 36}();
        D0

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"GetLanguageSelection" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 36} (@{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24});@{b}

   FUNCTION@{ub}
        Determine what the user has specified as a language.@{b}

   RESULT@{ub}
        language - user specified language, or zero if none has yet been
                   specified. See <@{"libraries/lowlevel.h" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File"}> for a definition
                   of the currently supported language.@{b}

   SEE ALSO@{ub}
        <@{"libraries/lowlevel.h" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File"}>, locale.doc

@ENDNODE
@NODE "QueryKeys" "lowlevel.library/QueryKeys()"
@{b}

   NAME@{ub}
        @{"QueryKeys" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 44} -- return the states for a set of keys. (V40)@{b}

   SYNOPSIS@{ub}
        @{"QueryKeys" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 44}(queryArray, arraySize);
                  A0          D1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"QueryKeys" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 44}(@{"struct KeyQuery" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 30} *, @{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62});@{b}

   FUNCTION@{ub}
        Scans the keyboard to determine which of the rawkey codes
        listed in the QueryArray are currently pressed. The state for each
        key is returned in the array.

        This function may be invoked from within an interrupt, but the size
        of QueryArray should be kept as small as possible.

        This is a low level function that does not fit the normal Amiga
        multitasking model. The values returned have no knowledge
        of which window/screen currently has input focus.@{b}

   INPUTS@{ub}
        queryArray - an array of KeyQuery structures. The kq_KeyCode fields
                     of these structures should be filled with the rawkey
                     codes you wish to query about. Upon return from this
                     function, the kq_Pressed field of these structures
                     will be set to @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if the associated key is down,
                     and @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if not.
        arraySize - number of key code entries in queryArray@{b}

   SEE ALSO@{ub}
        <@{"libraries/lowlevel.h" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File"}>

@ENDNODE
@NODE "ReadJoyPort" "lowlevel.library/ReadJoyPort()"
@{b}

   NAME@{ub}
        @{"ReadJoyPort" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 32} -- return the state of the selected joy/mouse port. (V40)@{b}

   SYNOPSIS@{ub}
        portState = @{"ReadJoyPort" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 32}(portNumber);
        D0                      D0

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"ReadJoyPort" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 32}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This function is used to determine what device is attached to the
        joy port and the current position/button state. The user may attach
        a mouse, game controller, or joystick to the port and this function
        will dynamically detect which device is attached and return the
        appropriatly formatted portState.

        To determine the type of controller that is attached, this function
        clocks the game controller and/or interprets changes in the joy
        port data. Valid clocked data from the game controller is immediately
        detected. However, to accuratly determine if a mouse or joystick is
        attached, several calls to this function are required along with some
        movement at the joy port by the user.

        This function always executes immediatly.

        This is a low level single threaded function that does not fit the
        normal Amiga multitasking model. Only one task can be executing
        this routine at any time. All others will return immediately with
        @{"JP_TYPE_NOTAVAIL" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 81}.

        The nature of this routine is not meant to encourage non-multitasking
        friendly programming practices like polling loops. If your task
        is waiting for a transition to be returned use a @{"WaitTOF()" LINK "gg:doc/NDK/Guide/graphics/WaitTOF"} between
        calls to minimize the total system impact.

        When called the first time, for each port, this function attempts to
        acquire certain system resources. In order to aquire these resources
        this function MUST be called from a task, or a DOS process. If this
        function fails to aquire the necessary resources, it will
        return with @{"JP_TYPE_NOTAVAIL" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 81}. Once the resources are aquired (return
        value other than @{"JP_TYPE_NOTAVAIL" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 81}) this function may be used in
        interrupts.@{b}

   INPUTS@{ub}
        portNumber - port to read, in the range 0 to 3.@{b}

   RESULT@{ub}
        portState - bit map that identifies the device and the current
                    state of that device. The format of the bit map is
                    dependant on the type of device attached.

                    The following constants from <@{"libraries/lowlevel.h" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File"}>
                    are used to determine which device is attached and
                    the state of that device.

                    The type of device can be determined by applying
                    the mask @{"JP_TYPE_MASK" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 86} to the return value and comparing
                    the resultant value with the following:

                        @{"JP_TYPE_NOTAVAIL" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 81}        port data unavailable
                        @{"JP_TYPE_GAMECTLR" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 82}        game controller
                        @{"JP_TYPE_MOUSE" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 83}           mouse
                        @{"JP_TYPE_JOYSTK" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 84}          joystick
                        @{"JP_TYPE_UNKNOWN" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 85}         unknown device

                    If type = @{"JP_TYPE_GAMECTLR" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 82} the bit map of portState is:
                        @{"JPF_BUTTON_BLUE" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 96}         Blue - Stop
                        @{"JPF_BUTTON_RED" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 97}          Red - Select
                        @{"JPF_BUTTON_YELLOW" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 98}       Yellow - Repeat
                        @{"JPF_BUTTON_GREEN" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 99}        Green - Shuffle
                        @{"JPF_BUTTON_FORWARD" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 100}      Charcoal - Forward
                        @{"JPF_BUTTON_REVERSE" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 101}      Charcoal - Reverse
                        @{"JPF_BUTTON_PLAY" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 102}         Grey - Play/Pause
                        @{"JPF_JOY_UP" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 110}              Up
                        @{"JPF_JOY_DOWN" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 111}            Down
                        @{"JPF_JOY_LEFT" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 112}            Left
                        @{"JPF_JOY_RIGHT" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 113}           Right

                    If type = @{"JP_TYPE_JOYSTK" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 84} the bit map of portState is:
                        @{"JPF_BUTTON_BLUE" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 96}         Right
                        @{"JPF_BUTTON_RED" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 97}          Fire
                        @{"JPF_JOY_UP" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 110}              Up
                        @{"JPF_JOY_DOWN" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 111}            Down
                        @{"JPF_JOY_LEFT" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 112}            Left
                        @{"JPF_JOY_RIGHT" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 113}           Right

                    If type = @{"JP_TYPE_MOUSE" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 83} the bit map of portState is:
                        @{"JPF_BUTTON_BLUE" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 96}         Right mouse
                        @{"JPF_BUTTON_RED" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 97}          Left mouse
                        @{"JPF_BUTTON_PLAY" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 102}         Middle mouse
                        @{"JP_MVERT_MASK" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 118}           Mask for vertical counter
                        @{"JP_MHORZ_MASK" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 117}           Mask for horizontal counter@{b}

   SEE ALSO@{ub}
        @{"SetJoyPortAttrs()" LINK "SetJoyPortAttrsA"}

@ENDNODE
@NODE "RemKBInt" "lowlevel.library/RemKBInt()"
@{b}

  NAME@{ub}
        @{"RemKBInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 52} -- remove a previously installed keyboard interrupt. (V40)@{b}

  SYNOPSIS@{ub}
        @{"RemKBInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 52}(intHandle);
                 A1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"RemKBInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 52}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

  FUNCTION@{ub}
        Remove a keyboard interrupt routine previously added with @{"AddKBInt()" LINK "AddKBInt"}.@{b}

  INPUTS@{ub}
        intHandle - handle obtained from @{"AddKBInt()" LINK "AddKBInt"}. This may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101},
                    in which case this function does nothing.@{b}

  SEE ALSO@{ub}
        @{"AddKBInt()" LINK "AddKBInt"}

@ENDNODE
@NODE "RemTimerInt" "lowlevel.library/RemTimerInt()"
@{b}

   NAME@{ub}
        @{"RemTimerInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 69} -- remove a previously installed timer interrupt. (V40)@{b}

   SYNOPSIS@{ub}
        @{"RemTimerInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 69}(intHandle);
                    A1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"RemTimerInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 69}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        Removes a timer interrupt routine previously installed with
        @{"AddTimerInt" LINK "AddTimerInt"}.@{b}

   INPUTS@{ub}
        intHandle - handle obtained from @{"AddTimerInt()" LINK "AddTimerInt"}. This may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101},
                    in which case this function does nothing.@{b}

   SEE ALSO@{ub}
        @{"AddTimerInt()" LINK "AddTimerInt"}, @{"StopTimerInt()" LINK "StopTimerInt"}, @{"StartTimerInt()" LINK "StartTimerInt"}

@ENDNODE
@NODE "RemVBlankInt" "lowlevel.library/RemVBlankInt()"
@{b}

   NAME@{ub}
        @{"RemVBlankInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 89} -- remove a previously installed vertical blank routine.
                        (V40)@{b}

   SYNOPSIS@{ub}
        @{"RemVBlankInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 89}(intHandle);
                     A1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"RemVBlankInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 89}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        Removes a vertical blank interrupt routine previously added with
        @{"AddVBlankInt()" LINK "AddVBlankInt"}.@{b}

   INPUTS@{ub}
        intHandle - handle obtained from @{"AddVBlankInt()" LINK "AddVBlankInt"}. This may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101},
                    in which case this function does nothing.@{b}

   SEE ALSO@{ub}
        @{"AddVBlankInt()" LINK "AddVBlankInt"}

@ENDNODE
@NODE "SetJoyPortAttrsA" "lowlevel.library/SetJoyPortAttrsA()"
@{b}

   NAME@{ub}
        @{"SetJoyPortAttrsA" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 93} -- change the attributes of a port.  (V40.27)
        @{"SetJoyPortAttrs" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 98} -- varargs stub for @{"SetJoyPortAttrsA" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 93}().  (V40.27)@{b}

   SYNOPSIS@{ub}
        success = @{"SetJoyPortAttrsA" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 93}(portNumber, tagList);
        D0                         D0          A1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"SetJoyPortAttrsA" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 93}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *);

        Success = @{"SetJoyPortAttrs" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 98}(portNumber, firstTag, ...);

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"SetJoyPortAttrs" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 98}(Tag, ...);@{b}


   FUNCTION@{ub}
        This function allows modification of several attributes held by
        @{"ReadJoyPort()" LINK "ReadJoyPort"} about both it's operation and the type of controller
        currently plugged into the port.

        @{"ReadJoyPort()" LINK "ReadJoyPort"}'s default behavior is to attempt to automatically
        sense the type of controller plugged into any given port, when
        asked to read that port. This behavior is beneficial, to allow
        simple detection of the type of controller plugged into the port.
        Unfortunately, rare cases are possible where extremely fine
        mouse movements appear to be real joystick movements. Also, this
        ability to auto-sense the controller type causes most reads to
        take longer than if there were no auto-sensing.

        @{"SetJoyPortAttrs" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 98}() is intended to provide for both of these cases.
        It allows the programmer to notify @{"ReadJoyPort()" LINK "ReadJoyPort"} to stop spending
        time attempting to sense which type of controller is in use -- and,
        optionally, to force @{"ReadJoyPort()" LINK "ReadJoyPort"} into utilizing a certain
        controller type.@{b}

   INPUTS@{ub}
        portNumber - the joyport in question (0-3).
        tagList - a pointer to an array of tags providing parameters
                  to @{"SetJoyPortAttrs" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 98}(); if @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, the function
                  will return @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95}, but do nothing.@{b}

   TAGS@{ub}
        @{"SJA_Type" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 65} (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) - Sets the current controller type to the mouse,
                        joystick, or game controller. Supply one of
                        @{"SJA_TYPE_GAMECTLR" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 70}, @{"SJA_TYPE_MOUSE" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 71}, @{"SJA_TYPE_JOYSTK" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 72},
                        or @{"SJA_TYPE_AUTOSENSE" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 69}. If @{"SJA_TYPE_AUTOSENSE" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 69} is used,
                        @{"ReadJoyPort()" LINK "ReadJoyPort"} will attempt to determine the type of
                        controller plugged into the given port automatically.
                        If one of the other types is used, @{"ReadJoyPort()" LINK "ReadJoyPort"} will
                        make no attempt to read the given controller as
                        anything other than the type specified. The default
                        type is SJA_AUTOSENSE.

                        Note -- if you set the type to anything other than
                        auto-sense, it's your responsibility to return it
                        to auto-sense mode before exiting.

        @{"SJA_Reinitialize" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 66} (@{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24}) - Return a given port to it's initial state,
                        forcing a port to deallocate any allocated resources;
                        return the implied type to @{"SJA_TYPE_AUTOSENSE" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 69}.@{b}

   RESULT@{ub}
        success - @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if everything went according to plan, or @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} upon
                  failure@{b}

   SEE ALSO@{ub}
        @{"ReadJoyPort()" LINK "ReadJoyPort"}, <@{"libraries/lowlevel.h" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File"}>

@ENDNODE
@NODE "StartTimerInt" "lowlevel.library/StartTimerInt()"
@{b}

   NAME@{ub}
        @{"StartTimerInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 77} -- start the timer associated with the timer interrupt.
                         (V40)@{b}

   SYNOPSIS@{ub}
        @{"StartTimerInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 77}(intHandle, timeInterval, continuous);
                      A1         D0            D1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"StartTimerInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 77}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91});@{b}

   FUNCTION@{ub}
        This routine starts a stopped timer that is assocatied with a
        timer interrupt created by @{"AddTimerInt()" LINK "AddTimerInt"}.@{b}

   INPUTS@{ub}
        intHandle - handle obtained from @{"AddTimerInt()" LINK "AddTimerInt"}.
        timeInterval - number of micoseconds between interrupts. The
                       maximum value allowed is 90,000. If higher values
                       are passed there will be unexpected results.
        continuous - @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} for a one shot interrupt. @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} for multiple
                     interrupts.@{b}

   SEE ALSO@{ub}
        @{"AddTimerInt()" LINK "AddTimerInt"}, @{"RemTimerInt()" LINK "RemTimerInt"}, @{"StopTimerInt()" LINK "StopTimerInt"}

@ENDNODE
@NODE "StopTimerInt" "lowlevel.library/StopTimerInt()"
@{b}

   NAME@{ub}
        @{"StopTimerInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 73} -- stop the timer associated with the timer interrupt.
                        (V40)@{b}

   SYNOPSIS@{ub}
        @{"StopTimerInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 73}(intHandle);
                     A1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"StopTimerInt" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 73}(@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        Stops the timer associated with the timer interrupt handle passed.
        This is used to stop a continuous timer started by
        @{"StartTimerInt()" LINK "StartTimerInt"}.@{b}

   INPUTS@{ub}
        intHandle - handle obtained from @{"AddTimerInt()" LINK "AddTimerInt"}.@{b}

   SEE ALSO@{ub}
        @{"AddTimerInt()" LINK "AddTimerInt"}, @{"RemTimerInt()" LINK "RemTimerInt"}, @{"StartTimerInt()" LINK "StartTimerInt"}

@ENDNODE
@NODE "SystemControlA" "lowlevel.library/SystemControlA()"
@{b}

   NAME@{ub}
        @{"SystemControlA" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 56} - Method for selectively disabling OS features. (V40)
        @{"SystemControl" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 61} - varargs stub for @{"SystemControlA" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 56}().@{b}

   SYNOPSIS@{ub}
        failTag = @{"SystemControlA" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 56}(tagList);
        D0                       A1

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"SystemControlA" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 56}(@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *);

        failTag = @{"SystemControl" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 61}(firstTag, ...);

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"SystemControl" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 61}(Tag, ...);@{b}

   FUNCTION@{ub}
        This function is used to alter the operation of the system. Some of
        the alterations involve controlling what are normally regarded as
        system resources. In order to minimize confusion only one task is
        allowed to control any part of the system resources. This prevents
        the possiblity of two tasks fighting, each controlling a part of the
        system. If a tag is identified as task exclusive, it means that
        only one task can hold (set to @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95}) that tag. If
        another task attempts to set the same tag to @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95}, the call to
        @{"SystemControl" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 61}() will fail.

        It is important to remember that @{"SystemControl" LINK "gg:doc/NDK/Guide/Include/inline/lowlevel.h/File" 61}() can fail.

        This is a low level function and certain tags do not fit the normal
        Amiga multitasking model.@{b}

   INPUTS@{ub}
        tagList - pointer to an array of tags listing the features of the
                  system to be enabled/disabled.@{b}

   TAGS@{ub}
        @{"SCON_TakeOverSys" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 153} (@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91})
                @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} -  Takes over the CPU to ensure that a program gets every
                        ounce of CPU time (with the exception of crucial
                        interrupts). When in this mode, the CPU will belong
                        completely to the program. Task switching will be
                        disabled and the program will get all CPU cycles. This
                        means any calls to the OS that involve multitasking in
                        some way will not execute correctly. Other tasks will
                        not run until this tag is used with @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}. However,
                        during a @{"Wait()" LINK "gg:doc/NDK/Guide/exec/Wait"} on a signal, multitasking will
                        automatically be turned back on until the signal is
                        received. Once received, multitasking will again be
                        disabled and the CPU will be exclusive to the owning
                        program.
                @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} - Relinquishes the CPU and reenables multitasking.
                        This tag is task exculsive. This tag nests. A task may
                        take over the CPU several times before relinquishing
                        it.

        @{"SCON_KillReq" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 154} (@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91})
               @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} -   Disables system requesters.  These are the reasons for
                        @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} disabling system requesters:

                            1- No calls in the program will cause a system
                               requester.
                            2- The only thing that could cause a requester
                               to appear is the lack of a CD in the drive and
                               @{"SCON_CDReboot" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 155} is set to @{"CDReboot_On" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 161}, therefore a
                               requester can't appear.
                            3- The only disk I/O is via a CD with @{"SCON_CDReboot" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 155}
                               set to @{"CDReboot_On" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 161} and/or @{"nonvolatile.library" LINK "gg:doc/NDK/Guide/nonvolatile/MAIN"}.

                        When requesters should not be disabled.
                        GAME PROGRAMS:
                        No DOS calls are used after loading; or @{"SCON_CDReboot" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 155}
                        is @{"CDReboot_On" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 161}; and @{"nonvolatile.library" LINK "gg:doc/NDK/Guide/nonvolatile/MAIN"} is used for
                        loading and saving user data.

                        This fits the above case since; After loading either
                        DOS calls are not used fitting reason 1, or the game
                        is accessing the CD and has @{"SCON_CDReboot" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 155} set to
                        @{"CDReboot_On" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 161} fitting reason 2. The game accesses high
                        scores, game position, etc through @{"nonvolatile.library" LINK "gg:doc/NDK/Guide/nonvolatile/MAIN"},
                        fitting reason 3.

                @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} - Enables requesters for the program.

            This tag nests. Tasks may disable requesters several times before
            enabling them.  However, there must be a matching number of calls.

        @{"SCON_CDReboot" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 155} (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})
                @{"CDReboot_On" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 161} - Ejecting the CD will cause a reboot of the
                        system. Use this only if the program cannot deal with
                        error conditions.
                @{"CDReboot_Off" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 162} - Ejecting the CD will not cause a reboot of the
                        system. Use this if the program needs to insert CDs
                        while running.
                @{"CDReboot_Default" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 163} - Restore the default reboot behavior for this
                        system. This should be used upon exit, if this tag had
                        been used to change the reboot behaviour. For the CD32
                        this value is synonomous with @{"CDReboot_On" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 161}. For Amiga
                        computers this value is synonomous with @{"CDReboot_Off" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 162}.

            Note that the default reboot behavior differs depending on the
            platform. If a program requires a specific behavior it must
            use this function to set the behavior. For example, a CD audio
            mixer would use this tag with the data @{"CDReboot_Off" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 162}. This will
            allow the changing of audio CDs on the game machine as well as
            Amiga computers.

            If, however, there is no error detection code at all this tag
            should be used with the data @{"CDReboot_On" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 161}.

            It is hoped that no program will require @{"CDReboot_On" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 161}. If all
            programs check for error condition and recover gracefully such a
            call should never be necessary. With the default behavior the
            CD32 will always reset on disk ejects, and programs
            run from Amiga computers will not reset. Thus, leaving the
            default will increase the market for a program to include both
            types of platforms.

            This tag does not nest.

        @{"SCON_StopInput" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 156} (@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}) - When @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95}, stops @{"input.device" LINK "gg:doc/NDK/Guide/input/MAIN"} from using any
            CPU cycles. Also prevents @{"input.device" LINK "gg:doc/NDK/Guide/input/MAIN"} from passing along any
            events from either the keyboard and/or port 0.

            This tag is task exclusive. This tag is @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} reversible.
            Attempting to reverse will result in confused/garbled input
            events.

        @{"SCON_AddCreateKeys" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 157} (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) - Starts creating rawkey codes for the
            joystick/game controller on the given unit. The unit value is
            checked for validity and must be either 0 or 1. Each different unit
            used results in some code added to the VBlank interrupt chain.
            This tag nests. The tag @{"SCON_RemCreateKeys" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 158} is used to undo this
            tag. Tasks may create rawkey codes several times before stopping
            them.

            Note that when operating in an Intuition window, the controller's
            blue button is the equivilent of the mouse menu button. Therefore,
            Intuition will be capturing most blue button events. If
            notificiation of these events is important, review the
            documentation for @{"WFLG_RMBTRAP" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1049} in the
            @{"intuition.library/OpenWindow()" LINK "gg:doc/NDK/Guide/intuition/OpenWindow"} autodoc.

        @{"SCON_RemCreateKeys" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File" 158} (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) - stops rawkey codes for the joystick/game
            controller on the given unit. The unit value is checked for
            validity and must be either 0 or 1.@{b}

   RESULT@{ub}
        failTag - zero if all tags succeeded. A non-zero return indicates a
                  tag that has failed. It is possible that other tags may
                  fail as well.

                  If any tag fails there will be no change in the system due
                  to other tags.@{b}

   SEE ALSO@{ub}
        <@{"libraries/lowlevel.h" LINK "gg:doc/NDK/Guide/Include/libraries/lowlevel.h/File"}>

@ENDNODE
