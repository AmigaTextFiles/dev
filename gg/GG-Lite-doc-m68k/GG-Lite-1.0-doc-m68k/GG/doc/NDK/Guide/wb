@DATABASE "gg:doc/NDK/Guide/wb"
@MASTER   "gg:doc/NDK/AutoDocs/wb.doc"
@REMARK   This file was created by ADtoHT 2.1 on 06-Jan-13 19:25:29
@REMARK   Do not edit
@REMARK   ADtoHT is © 1993-1995 Christian Stieber

@NODE MAIN "wb.doc"
@TOC "gg:doc/NDK/Guide/TOC/MAIN"

                              @{b}workbench.library@{ub}

@{"AddAppIcon()" LINK "AddAppIconA"}                  @{"AddAppIconA()" LINK "AddAppIconA"}
@{"AddAppMenuItem()" LINK "AddAppMenuItemA"}              @{"AddAppMenuItemA()" LINK "AddAppMenuItemA"}
@{"AddAppWindow()" LINK "AddAppWindowA"}                @{"AddAppWindowA()" LINK "AddAppWindowA"}
@{"AddAppWindowDropZone()" LINK "AddAppWindowDropZoneA"}        @{"AddAppWindowDropZoneA()" LINK "AddAppWindowDropZoneA"}
@{"ChangeWorkbenchSelection()" LINK "ChangeWorkbenchSelectionA"}    @{"ChangeWorkbenchSelectionA()" LINK "ChangeWorkbenchSelectionA"}
@{"CloseWorkbenchObject()" LINK "CloseWorkbenchObjectA"}        @{"CloseWorkbenchObjectA()" LINK "CloseWorkbenchObjectA"}
@{"MakeWorkbenchObjectVisible()" LINK "MakeWorkbenchObjectVisibleA"}  @{"MakeWorkbenchObjectVisibleA()" LINK "MakeWorkbenchObjectVisibleA"}
@{"OpenWorkbenchObject()" LINK "OpenWorkbenchObjectA"}         @{"OpenWorkbenchObjectA()" LINK "OpenWorkbenchObjectA"}
@{"RemoveAppIcon()" LINK "RemoveAppIcon"}               @{"RemoveAppMenuItem()" LINK "RemoveAppMenuItem"}
@{"RemoveAppWindow()" LINK "RemoveAppWindow"}             @{"RemoveAppWindowDropZone()" LINK "RemoveAppWindowDropZone"}
@{"UpdateWorkbench()" LINK "UpdateWorkbench"}             @{"WBInfo()" LINK "WBInfo"}
@{"WorkbenchControl()" LINK "WorkbenchControlA"}            @{"WorkbenchControlA()" LINK "WorkbenchControlA"}

@ENDNODE
@NODE "AddAppIconA" "workbench.library/AddAppIconA()"
@{b}

   NAME@{ub}
        @{"AddAppIconA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 45} - add an icon to Workbench's list of AppIcons.       (V36)@{b}

   SYNOPSIS@{ub}
        AppIcon = @{"AddAppIconA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 45}(id, userdata, text, msgport,
           D0                 D0     D1      A0     A1

                              lock, diskobj, taglist)
                              A2      A3      A4

        @{"struct AppIcon" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 163} *@{"AddAppIconA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 45}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, char *,
                @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *, @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"struct DiskObject" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 65} *,
                @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *);

        Alternate, varargs version:
        @{"struct AppIcon" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 163} *@{"AddAppIcon" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 50}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, char *,
                                   @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *, @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130},
                                   @{"struct DiskObject" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 65} *,
                                   tag1, data1,
                                   tag2, data2,
                                   ...
                                   @{"TAG_END" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 40} );@{b}

   FUNCTION@{ub}
        Attempt to add an icon to Workbench's list of AppIcons.  If
        successful, the icon is displayed on the Workbench backdrop (the
        same place disk icons are displayed).

        This call is provided to allow applications to be notified when
        a graphical object (not neccessarely associated with a file)
        gets 'manipulated'.

        The notification consists of an AppMessage (found in workbench.h/i)
        of type 'MTYPE_APPICON' arriving at the message port you specified.

        The types of 'manipulation' that can occur are:

        1. Double-clicking on the icon.  am_NumArgs will be zero and
           am_ArgList will be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.
        2. Dropping an icon or icons on your AppIcon.  am_NumArgs will
           be the number of icons dropped on your AppIcon plus one.
           am_ArgList will be an array of pointers to WBArg structures.
           Refer to the 'WBStartup Message' section of the RKM for more info.
        3. Dropping your AppIcon on another icon.  @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} SUPPORTED.
        4. Invoking an "Icons" menu item with your icon selected. (V44)
           You have to tell Workbench which menu items your icon
           responds to using the tag item list you provide to @{"AddAppIconA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 45}().
           When one of the supported menu items is invoked, you
           will receive an AppMessage with the am_Class entry set to
           a value out of @{"AMCLASSICON_Open" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 139}..@{"AMCLASSICON_EmptyTrash" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 152},
           corresponding to the menu item used.@{b}

   INPUTS@{ub}
        id - this variable is strictly for your own use and is ignored by
             Workbench.  Typical uses in C are in switch and case statements,
             and in assembly language table lookup.
        userdata - this variable is strictly for your own use and is ignored
                   by Workbench.
        text - name of icon (char *)
        lock - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}    (Currently unused)
        msgport - pointer to message port Workbench will use to send you an
                  AppMessage message of type 'MTYPE_APPICON' when your icon
                  gets 'manipulated' (explained above).
        diskobj - pointer to a DiskObject structure filled in as follows:
            do_Magic - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
            do_Version - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
            do_Gadget - a gadget structure filled in as follows:
                NextGadget - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                LeftEdge - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                TopEdge - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                Width - width of icon hit-box
                Height - height of icon hit-box
                Flags - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} or @{"GADGHIMAGE" LINK "gg:doc/NDK/Guide/Include/intuition/iobsolete.h/File" 47}
                Activation - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                GadgetType - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                GadgetRender - pointer to Image structure filled in as follows:
                    LeftEdge - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                    TopEdge - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                    Width - width of image (must be <= Width of hit box)
                    Height - height of image (must be <= Height of hit box)
                    Depth - # of bit-planes in image
                    ImageData - pointer to actual word aligned bits (CHIP MEM)
                    PlanePick - Plane mask ((1 << depth) - 1)
                    PlaneOnOff - 0
                    NextImage - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                SelectRender - pointer to alternate Image struct or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                GadgetText - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                MutualExclude - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                SpecialInfo - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                GadgetID - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                UserData - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
            do_Type - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
            do_DefaultTool - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
            do_ToolTypes - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
            do_CurrentX - @{"NO_ICON_POSITION" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 104} (recommended)
            do_CurrentY - @{"NO_ICON_POSITION" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 104} (recommended)
            do_DrawerData - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
            do_ToolWindow - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
            do_StackSize - @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}

        (an easy way to create one of these (a DiskObject) is to create an icon
         with the V2.0 icon editor and save it out.  Your application can then
         call @{"GetDiskObject" LINK "gg:doc/NDK/Guide/icon/GetDiskObject"} on it and pass that to @{"AddAppIcon" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 50}.)

        taglist - ptr to a list of tag items.  Must be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for V2.0.@{b}

   TAGS@{ub}
        @{"WBAPPICONA_SupportsOpen" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 176} (@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}) -- Set this to @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if your
            AppIcon should respond to the "Open" menu, to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}
            otherwise. Note that with this attribute set to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98},
            users will still be able to double-click on your AppIcon
            and drop icons on it. This attribute solely controls
            whether the "Open" menu item will be available.

            This tag defaults to @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95}. (V44)

        @{"WBAPPICONA_SupportsCopy" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 179} (@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}) -- Set this to @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if your
            AppIcon should respond to the "Copy" menu, to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}
            otherwise.

            This tag defaults to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}. (V44)

        @{"WBAPPICONA_SupportsRename" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 182} (@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}) -- Set this to @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if your
            AppIcon should respond to the "Rename" menu, to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}
            otherwise.

            This tag defaults to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}. (V44)

        @{"WBAPPICONA_SupportsInformation" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 185} (@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}) -- Set this to @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if your
            AppIcon should respond to the "Information" menu, to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}
            otherwise.

            This tag defaults to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}. (V44)

        @{"WBAPPICONA_SupportsSnapshot" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 188} (@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}) -- Set this to @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if your
            AppIcon should respond to the "Snapshot" menu, to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}
            otherwise.

            This tag defaults to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}. (V44)

        @{"WBAPPICONA_SupportsUnSnapshot" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 191} (@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}) -- Set this to @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if your
            AppIcon should respond to the "UnSnapshot" menu, to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}
            otherwise.

            This tag defaults to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}. (V44)

        @{"WBAPPICONA_SupportsLeaveOut" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 194} (@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}) -- Set this to @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if your
            AppIcon should respond to the "Leave Out" menu, to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}
            otherwise.

            This tag defaults to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}. (V44)

        @{"WBAPPICONA_SupportsPutAway" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 197} (@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}) -- Set this to @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if your
            AppIcon should respond to the "Put Away" menu, to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}
            otherwise.

            This tag defaults to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}. (V44)

        @{"WBAPPICONA_SupportsDelete" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 200} (@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}) -- Set this to @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if your
            AppIcon should respond to the "Delete" menu, to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}
            otherwise.

            This tag defaults to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}. (V44)

        @{"WBAPPICONA_SupportsFormatDisk" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 203} (@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}) -- Set this to @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if your
            AppIcon should respond to the "Format Disk" menu, to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}
            otherwise.

            This tag defaults to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}. (V44)

        @{"WBAPPICONA_SupportsEmptyTrash" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 206} (@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}) -- Set this to @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if your
            AppIcon should respond to the "Empty Trash" menu, to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}
            otherwise.

            This tag defaults to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}. (V44)

        @{"WBAPPICONA_PropagatePosition" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 209} (@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}) -- Set this to @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if you
            want the AppIcon's position to be propagated back to the
            original DiskObject you passed to this function. By
            default, Workbench will make a copy of that DiskObject's
            icon imagery, allowing you to free the DiskObject.
            But if you specify "@{"WBAPPICONA_PropagatePosition" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 209},@{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95},"
            Workbench will assume that you will not free it and
            that the AppIcon's current position should be stored
            in its do_CurrentX/do_CurrentY members.

            This tag defaults to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}. (V44)

        @{"WBAPPICONA_RenderHook" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 212} (@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *) -- Pointer to a hook that
            will be invoked when rendering your AppIcon. With this hook
            and @{"WorkbenchControlA()" LINK "WorkbenchControlA"} you can create dynamic or animated
            AppIcons. Your hook will be called with the following
            parameters and has to return a result value:

            result = hookFunc(hook,reserved,arm)
              D0               A0     A2     A1

            @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} hookFunc(@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *hook,@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} reserved,
                          @{"struct AppIconRenderMsg" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 454} *arm);

            The reserved parameter will be set to @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} (V44).

            If your hook code returns @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95}, the AppIcon's regular image
            will be drawn. If your code returns @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}, the regular image
            will not be drawn; this allows you to do all the icon's on-screen
            rendering with the exception of the icon image used when dragging
            the icon on the screen.

            The render message contents are as follows:

                arm_RastPort
                    A pointer to the RastPort to render into.

                arm_Icon
                    A pointer to the Icon to be rendered.

                arm_Label
                    A pointer to the label text to be printed
                    below the icon.

                arm_Tags
                    Further control tags which you should pass on
                    to @{"icon.library/DrawIconStateA" LINK "gg:doc/NDK/Guide/icon/DrawIconStateA"}, should you
                    call this routine.

                arm_Left
                arm_Top
                    Rendering origin; note that these coordinates
                    DO @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} take the embossing border sizes into
                    account.

                arm_Width
                arm_Height
                    Size of the Icon's image area; you should limit
                    your drawing to this area.

                arm_State
                    An icon drawing state, such as used by
                    @{"icon.library/DrawIconStateA" LINK "gg:doc/NDK/Guide/icon/DrawIconStateA"}.

            Note that all the data in the render message is read-only.


            This tag defaults to @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}. (V44)

        @{"WBAPPICONA_NotifySelectState" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 215} (@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}) -- Set this tag to @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95}
            if you want to be be notified whenever the AppIcon becomes
            selected or unselected. You will hear only state transitions,
            i.e. changes from selected to unselected state and the other
            way round. On a state transition you will receive AppMessages
            with the AppMessage->am_Class member set to @{"AMCLASSICON_Selected" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 154}
            or @{"AMCLASSICON_Unselected" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 155}, respectively.

            This tag defaults to @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}. (V44)@{b}

   RESULTS@{ub}
        AppIcon - a pointer to an AppIcon structure which you pass to
                  @{"RemoveAppIcon" LINK "RemoveAppIcon"} when you want to remove the icon
                  from Workbench's list of AppIcons.  @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                  if Workbench was unable to add your icon; typically
                  happens when Workbench is not running or under low
                  memory conditions.@{b}

   EXAMPLE@{ub}
        You could design a print-spooler icon and add it to the Workbench.
        Any file dropped on the print spooler would be printed.  If the
        user double-clicked (opened) your printer-spooler icon, you could
        open a window showing the status of the print spool, allow changes
        to print priorities, allow deletions, etc.  If you registered this
        window as an 'AppWindow' (explained in @{"workbench.library/AddAppWindow" LINK "AddAppWindowA"})
        files could also be dropped in the window and added to the spool.@{b}

   NOTES@{ub}
        For this function call to succeed, Workbench must be open. This
        means that the LoadWB command was executed and the Workbench
        screen has been opened.@{b}

   SEE ALSO@{ub}
        @{"workbench.library/RemoveAppIcon" LINK "RemoveAppIcon"}
        @{"workbench.library/WorkbenchControlA" LINK "WorkbenchControlA"}
        @{"icon.library/DrawIconStateA" LINK "gg:doc/NDK/Guide/icon/DrawIconStateA"}@{b}

   BUGS@{ub}
        In workbench.library versions 36 through 40 Info cannot be obtained
        on appicons.

@ENDNODE
@NODE "AddAppMenuItemA" "workbench.library/AddAppMenuItemA()"
@{b}

   NAME@{ub}
        @{"AddAppMenuItemA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 58} - add a menu item to Workbench's list            (V36)
                         of AppMenuItems.@{b}

   SYNOPSIS@{ub}
        AppMenuItem = @{"AddAppMenuItemA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 58}(id, userdata, text, msgport, taglist)
        D0                            D0     D1      A0     A1       A2

        @{"struct AppMenuItem" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 164} *@{"AddAppMenuItemA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 58}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, char *,
                                            @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *,
                                            @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *);

        Alternate, varargs version:
        @{"struct AppMenuItem" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 164} *@{"AddAppMenuItem" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 63}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, char *,
                                           @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *,
                                           tag1, data1,
                                           tag2, data2,
                                           ...
                                           @{"TAG_END" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 40} );@{b}

   FUNCTION@{ub}
        Attempt to add the text as a menu item to Workbench's list
        of AppMenuItems (the 'Tools' menu strip).@{b}

   INPUTS@{ub}
        id - this variable is strictly for your own use and is ignored by
             Workbench.  Typical uses in C are in switch and case statements,
             and in assembly language table lookup.
        userdata - this variable is strictly for your own use and is ignored
                   by Workbench.
        text - text for the menu item (char *); starting with V44, any menu
               label consisting entirely of '-', '_' or '~' characters will
               result in a separator bar to be added in place of a textual
               item.
        msgport - pointer to message port Workbench will use to send you an
                  AppMessage message of type 'MTYPE_APPMENUITEM' when your
                  menuitem gets selected.
        taglist - ptr to a list of tag items.  Must be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for V2.0.@{b}

   TAGS@{ub}
        @{"WBAPPMENUA_CommandKeyString" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 222} (@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}) -- Command key to assign to
            this AppMenu. This must be a NUL-terminated string. If the
            string is empty, it will be ignored. Also, if the command key
            is already in use by a different menu item it will be ignored,
            too. In any case, only the first character of the string will
            be used (V44).

            This tag defaults to @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.

        @{"WBAPPMENUA_GetKey" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 227} (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} *) -- To add menus with sub menu items,
            you need to add a menu item first which the sub items will
            be added to later. In order to do this, add the item the sub items
            should be attached to and use the @{"WBAPPMENUA_GetKey" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 227} tag to
            obtain a key value. This key value is to be used later with the
            @{"WBAPPMENUA_UseKey" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 232} tag (V44).

            This feature was introduced in workbench.library 44.1511, it
            does not work in any of the older Workbench releases.

            This tag defaults to @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.

        @{"WBAPPMENUA_GetTitleKey" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 237} (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} *) -- To add new entries to the Workbench
            menu strip you first need to create a new title to which the new
            menu items can be attached later. To do this, first create a new
            menu entry and use the @{"WBAPPMENUA_GetTitleKey" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 237} tag to obtain a key
            value. This key value is to be used later with the
            @{"WBAPPMENUA_UseKey" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 232} tag (V45).

            This tag defaults to @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.

        @{"WBAPPMENUA_UseKey" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 232} (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -- When adding a menu item with the
            @{"WBAPPMENUA_UseKey" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 232} tag, using a key value obtained by a previous
            invocation of @{"AddAppMenuItemA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 58}(), the new menu item will be
            added as a sub item (V44).

            If the key you provide was obtained via the @{"WBAPPMENUA_GetTitleKey" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 237}
            tag, then the item you add will be attached to the respective
            menu entry (V45).

            This tag defaults to @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   RESULTS@{ub}
        AppMenuItem - a pointer to an appmenuitem structure which you pass to
                      @{"RemoveAppMenuItem" LINK "RemoveAppMenuItem"} when you want to remove the menuitem
                      from Workbench's list of AppMenuItems.  @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if
                      workbench was unable to add your menu item; typically
                      happens when Workbench is not running or under low
                      memory conditions.

                  Starting with V44 @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} will be returned if you attempt to
                  add an AppMenu item to a menu which already contains 63
                  menu items.@{b}

   NOTES@{ub}
        For this function call to succeed, Workbench must be open. This
        means that the LoadWB command was executed and the Workbench
        screen has been opened.

        You can add only a maximum of 62 menu items to the "Tools" menu.
        Only a maximum of 15 sub items can be added to a menu item.

        When you add a new menu item which sub items should be attached
        to, the new menu item will not appear until after the first sub
        item has been attached. The same is true when adding new menu
        entries to the Workbench menu strip; titles will not appear
        until you add the first menu item.

        You can add only a maximum of 27 menu entries to the Workbench
        menu strip. Only a maximum of 63 menu items can be added to
        a menu entry.@{b}

   EXAMPLE@{ub}
        Here is how you create a menu item with two sub items attached:

        @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} * port;
        @{"struct AppMenuItem" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 164} * item;
        @{"struct AppMenuItem" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 164} * sub1;
        @{"struct AppMenuItem" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 164} * sub2;
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} key;

        /* IMPORTANT: you *must* initialize the key to zero
         *            for backwards compatibility!
         */
        key = 0;
        item = @{"AddAppMenuItem" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 63}(0,0,"AppMenu item with two sub items",port,
            @{"WBAPPMENUA_GetKey" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 227},&key,
        @{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39});

        /* IMPORTANT: always check for the key value to be non-zero! */
        if(key != 0 && item != @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101})
        {
            sub1 = @{"AddAppMenuItem" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 63}(0,0,"Sub item #1",port,
                @{"WBAPPMENUA_UseKey" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 232},key,
            @{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39});

            sub2 = @{"AddAppMenuItem" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 63}(0,0,"Sub item #2",port,
                @{"WBAPPMENUA_UseKey" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 232},key,
            @{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39});

            /* ... do something useful with the menus ... */

            @{"RemoveAppMenuItem" LINK "RemoveAppMenuItem"}(sub1);
            @{"RemoveAppMenuItem" LINK "RemoveAppMenuItem"}(sub2);
        }

        @{"RemoveAppMenuItem" LINK "RemoveAppMenuItem"}(item);@{b}

   SEE ALSO@{ub}
        @{"workbench.library/RemoveAppMenuItem" LINK "RemoveAppMenuItem"}@{b}

   BUGS@{ub}
        workbench.library V37 through V40 does not limit the number of menu
        items to 63. Any menu items after the 63rd will not be selectable.
        This bug was fixed in V44.

@ENDNODE
@NODE "AddAppWindowA" "workbench.library/AddAppWindowA()"
@{b}

   NAME@{ub}
        @{"AddAppWindowA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 32} - add a window to Workbench's list of AppWindows.  (V36)@{b}

   SYNOPSIS@{ub}
        AppWindow = @{"AddAppWindowA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 32}(id, userdata, window, msgport, taglist)
        D0                        D0     D1       A0      A1       A2

        @{"struct AppWindow" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 161} *@{"AddAppWindowA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 32}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"struct Window" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 909} *,
                                        @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *, @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *);

        Alternate, varargs version:
        @{"struct AppWindow" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 161} *@{"AddAppWindow" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 37}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"struct Window" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 909} *,
                                       @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *
                                       tag1, data1,
                                       tag2, data2,
                                       ...
                                       @{"TAG_END" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 40} );@{b}

   FUNCTION@{ub}
        Attempt to add the window to Workbench's list of AppWindows.
        Normally non-Workbench windows (those not opened by Workbench)
        cannot have icons dropped in them.  This call is provided to
        allow applications to be notified when an icon or icons get
        dropped inside a window that they have registered with Workbench.
        The notification consists of an AppMessage (found in workbench.h/i)
        of type 'MTYPE_APPWINDOW' arriving at the message port you specified.
        What you do with the list of icons (pointed to by am_ArgList) is
        up to you, but generally you would want to call @{"GetDiskObjectNew" LINK "gg:doc/NDK/Guide/icon/GetDiskObjectNew"} on
        them.@{b}

   INPUTS@{ub}
        id - this variable is strictly for your own use and is ignored by
             Workbench.  Typical uses in C are in switch and case statements,
             and in assembly language table lookup.
        userdata - this variable is strictly for your own use and is ignored
                   by Workbench.
        window - pointer to window to add.
        msgport - pointer to message port Workbench will use to send you an
                  AppMessage message of type 'MTYPE_APPWINDOW' when your
                  window gets an icon or icons dropped in it.
        taglist - ptr to a list of tag items.  Must be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for V2.0.@{b}

   RESULTS@{ub}
        AppWindow - a pointer to an AppWindow structure which you pass to
                    @{"RemoveAppWindow" LINK "RemoveAppWindow"} when you want to remove the window
                    from Workbench's list of AppWindows.  @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                    if Workbench was unable to add your window; typically
                    happens when Workbench is not running or under low
                    memory conditions.@{b}

   SEE ALSO@{ub}
        @{"workbench.library/AddAppWindowDropZoneA" LINK "AddAppWindowDropZoneA"}
        @{"workbench.library/RemoveAppWindow" LINK "RemoveAppWindow"}@{b}

   NOTES@{ub}
        The V2.0 icon editor is an example of an AppWindow.  Note that app
        window applications generally want to call @{"GetDiskObjectNew" LINK "gg:doc/NDK/Guide/icon/GetDiskObjectNew"}
        (as opposed to @{"GetDiskObject" LINK "gg:doc/NDK/Guide/icon/GetDiskObject"}) to get the disk object for the icon
        dropped in the window.

        For this function call to succeed, Workbench must be open. This
        means that the LoadWB command was executed and the Workbench
        screen has been opened.

        When removing an AppWindow, all its drop zones will be automatically
        removed.

@ENDNODE
@NODE "AddAppWindowDropZoneA" "workbench.library/AddAppWindowDropZoneA()"
@{b}

   NAME@{ub}
        @{"AddAppWindowDropZoneA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 102} -- Designate an AppWindow area as suitable for
            dropping icons on. (V44)@{b}

   SYNOPSIS@{ub}
        dropZone = @{"AddAppWindowDropZoneA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 102}(appWindow,id,userData,tags)
           D0                               A0    D0    D1     A1

        @{"struct AppWindowDropZone" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 162} * @{"AddAppWindowDropZoneA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 102}(@{"struct AppWindow" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 161} *aw,
                                   @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} id,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} userData,
                                   @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} * tags);

        dropZone = @{"AddAppWindowDropZone" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 107}(appWindow,id,userData,zone,...)

        @{"struct AppWindowDropZone" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 162} * @{"AddAppWindowDropZone" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 107}(@{"struct AppWindow" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 161} *aw,
                                   @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} id,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} userData,...);@{b}

   FUNCTION@{ub}
        Once it is created, Workbench will allow the user to drop an
        icon anywhere inside an AppWindow, regardless of whether the
        icon was dropped on an area designated for dropping icons on
        or not. With @{"AddAppWindowDropZoneA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 102}() you can tell Workbench
        which AppWindow areas are suitable for dropping icons on.@{b}

   INPUTS@{ub}
        aw -- An AppWindow data structure, as returned by
            @{"workbench.library/AddAppWindowA" LINK "AddAppWindowA"}.
        id -- This variable is strictly for your own use and is ignored by
            Workbench. Typical uses in C are in switch and case statements,
            and in assembly language table lookup. Later, when an icon is
            dropped on the designated area, the AppMessage sent to your
            port will have the am_ID member set to this value.
        userData -- this variable is strictly for your own use and is ignored
            by Workbench. Later, when an icon is dropped on the designated area,
            the AppMessage sent to your port will have the am_UserData member
            set to this value.
        tags -- List of attributes to control the position and size
            of the drop zone.@{b}

   TAGS@{ub}
        @{"WBDZA_Left" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 393} (@{"WORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 54}) -- Left edge of the drop zone; a value of
            0 would create a zone located at the left corner of the
            window.

        @{"WBDZA_RelRight" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 396} (@{"WORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 54}) -- Left edge of the drop zone, relative
            to the window width; a value of -10 would create a zone located
            10 pixels left of the window right edge.

        @{"WBDZA_Top" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 399} (@{"WORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 54}) -- Top edge of the drop zone; a value of
            0 would create a zone located at the top corner of the
            window.

        @{"WBDZA_RelBottom" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 402} (@{"WORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 54}) -- Top edge of the drop zone, relative
            to the window height; a value of -10 would create a zone located
            10 pixels above the window bottom edge.

        @{"WBDZA_Width" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 405} (@{"WORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 54}) -- Width of the drop zone.

        @{"WBDZA_RelWidth" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 408} (@{"WORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 54}) -- Width of the drop zone, relative to the
            width of the window; a value of -20 would create a zone that
            is by 20 pixels narrower than the window.

        @{"WBDZA_Height" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 411} (@{"WORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 54}) -- Height of the drop zone.

        @{"WBDZA_RelHeight" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 414} (@{"WORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 54}) -- Height of the drop zone, relative to the
            height of the window; a value of -20 would create a zone that
            is by 20 pixels smaller than the window.

        @{"WBDZA_Box" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 417} (@{"struct IBox" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 896} *) -- Position and size of the drop zone.

        @{"WBDZA_Hook" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 420} (@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *) -- Pointer to a hook that will be
            invoked whenever the mouse enters or leaves your drop zone
            area. Your hook will be called with the following parameters:

            result = hookFunc(hook,reserved,arm)
              D0               A0     A2     A1

            @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} hookFunc(@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *hook,@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} reserved,
                          @{"struct AppWindowDropZoneMsg" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 475} *adzm);

            The reserved parameter will be set to @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} (V44).
            For future enhancement, make sure that your hook
            function always returns @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} (V44).

            The drop zone message contents are as follows:

                adzm_RastPort
                    A pointer to the RastPort to render into.
                    Typically, this is the RastPort of the window
                    the drop zone is attached to.

                adzm_DropZoneBox
                    This member describes the position and size
                    of the drop zone. The zone is guaranteed to
                    be a valid area, i.e. the Width and Height
                    will both be greater than 0 and the Left/Top
                    will be well within the bounds of the window
                    containing the drop zone.

                adzm_ID
                adzm_UserData
                    These two come straight from the values you passed
                    as the id and userData parameters to
                    @{"AddAppWindowDropZoneA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 102}().

                adzm_Action
                    Depending upon whether the mouse has just entered
                    or left the drop zone area, this variable will be
                    set to @{"ADZMACTION_Enter" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 484} or to @{"ADZMACTION_Leave" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 485}.
                    Any other values for adzm_Action should be ignored.

                    When the mouse enters the drop zone, do your drop
                    zone area highlighting. When the mouse leaves the
                    drop zone, remove any highlighting done in the
                    previous @{"ADZMACTION_Enter" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 484} pass.

                    Note that the mouse leaving your drop zone box
                    does not imply that no icons will be dropped on it.
                    You may still receive a notification lateron, telling
                    you that your drop zone had icons dropped on it.
                    The hook function is solely for highlighting and
                    unhighlighting the drop zone area.

            A final word of warning: when your hook code is called, you
            must limit your rendering to simple drawing operations
            from @{"graphics.library" LINK "gg:doc/NDK/Guide/graphics/MAIN"}; if you do anything complex that
            involves Intuition locking and unlocking the display,
            such as refreshing gadgets or locking IntuitionBase,
            you will deadlock the operating system. You have been
            warned!@{b}

   RESULT@{ub}
        dropZone -- A newly created drop zone identifier, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if
            it could not be created; use @{"dos.library/IoErr" LINK "gg:doc/NDK/Guide/dos/IoErr"} to find out
            what caused it to fail.@{b}

   NOTES@{ub}
        Once an AppWindow has a drop zone installed, Workbench will send
        a new type of AppMessage to your port if icons are dropped on
        a drop zone. Instead of @{"AMTYPE_APPWINDOW" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 133} type messages you
        will receive @{"AMTYPE_APPWINDOWZONE" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 136} messages. In fact, you will
        no longer hear any @{"AMTYPE_APPWINDOW" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 133} type messages since Workbench
        will allow users to drop icons only on drop zones. Be prepared
        to handle this.

        Adding a drop zone to an AppWindow does not guarantee that only
        @{"AMTYPE_APPWINDOWZONE" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 136} type messages will arrive at your message
        port. In fact, the user may be able to drop an icon on the window
        before the first drop zone is installed. Be prepared to handle
        this.

        Workbench checks drop zones in the order in which they were added
        to the AppWindow. Thus, if two zones overlap, the zone that was
        added first will be reported as hit.

        An AppWindow starts out with its entire area available for dropping
        icons on. Thus, you may receive AppMessages for icons dropped upon
        your AppWindow before you have added the first drop zone to it.
        Be prepared to handle this.

        Drop zones must be created with a position and a size. If you omit
        either one, this routine will fail.

        When an icon is dropped on a drop zone, the AppMessage am_MouseX and
        am_MouseY members will be relative to the window top left corner;
        they WILL @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} be relative to the left/top edge of the drop zone.@{b}

   SEE ALSO@{ub}
        @{"dos.library/IoErr" LINK "gg:doc/NDK/Guide/dos/IoErr"}
        @{"workbench.library/AddAppWindowA" LINK "AddAppWindowA"}

@ENDNODE
@NODE "ChangeWorkbenchSelectionA" "workbench.library/ChangeWorkbenchSelectionA()"
@{b}

   NAME@{ub}
        @{"ChangeWorkbenchSelectionA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 115} -- Change the selection states of icons
            displayed by Workbench. (V44)@{b}

   SYNOPSIS@{ub}
        success = @{"ChangeWorkbenchSelectionA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 115}(name,hook,tags)
           D0                                A0   A1   A2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"ChangeWorkbenchSelectionA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 115}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} name,@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *hook,
                                       @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *tags);

        success = @{"ChangeWorkbenchSelection" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 120}(name,hook,...);

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"ChangeWorkbenchSelection" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 120}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} name,@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *hook,...);@{b}

   FUNCTION@{ub}
        The icons displayed inside each Workbench window can be in selected
        or in unselected state. This routine allows you to change this state
        for every icon found in a particular window.@{b}

   INPUTS@{ub}
        name -- Name of the drawer whose icons should be submitted to the
            callback hook for testing; pass @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} as the name to have the
            icons in the Workbench backdrop (where disks and AppIcons live)
            passed through the hook. Note that the drawer whose icons you
            want to change must be open before you can make any changes.

        hook -- Hook to be invoked for each icon in the window.

            The hook code will be invoked with the following parameters

            action = hookFunc(hook,reserved,ism)
               D0                A0     A2    A1

            @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} hookFunc(@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *hook,@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} reserved,
                           @{"struct IconSelectMsg" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 490} *ism);

            The reserved parameter will be set to @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} (V44).

            The IconSelectMsg contents are as follows:

                ism_Length
                    Size of the IconSelectMsg data structure (in bytes).
                    Since this message may need to grow in the future,
                    always compare this value against the message size
                    you expect. For V44, ism_Length is guaranteed to
                    contain a value of 36. Expect this value to become
                    larger in the future.

                ism_Drawer
                    A lock on the drawer the object in question resides
                    in. This may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for the Workbench backdrop (where
                    disks and AppIcons live).

                ism_Name
                    Name of the object in question; please note that for
                    disk icons the name does not end with a colon character
                    (":").

                ism_Type
                    This is one of @{"WBDISK" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 25}, @{"WBDRAWER" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 26}, @{"WBTOOL" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 27}, @{"WBPROJECT" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 28},
                    @{"WBGARBAGE" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 29}, @{"WBDEVICE" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 30}, @{"WBKICK" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 31} or @{"WBAPPICON" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 32}.

                ism_Selected
                    @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if the object in question is currently selected,
                    @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} otherwise.

                ism_Tags
                    The list of tag items passed to @{"ChangeWorkbenchSelectionA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 115}().

                ism_DrawerWindow
                    If the object in question is a drawer or disk and its
                    associated window is currently open, then you will find
                    a pointer to it here.

                ism_ParentWindow
                    This is a pointer to the window the object resides in.

                ism_Left
                ism_Top
                ism_Width
                ism_Height
                    These denote the position and size of the object in
                    question, relative to the top left edge of the window
                    it resides in.

            With the exception of the ism_Left and ism_Top members, the
            IconSelectMsg is read-only. The ism_Left/ism_Top members can
            be used to change the position of the icon.

            You hook code must return one of the following values:

                @{"ISMACTION_Unselect" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 535}
                    Unselect the icon

                @{"ISMACTION_Select" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 536}
                    Select the icon

                @{"ISMACTION_Ignore" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 537}
                    Do not change the selection state of the icon.

                @{"ISMACTION_Stop" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 538}
                    Do not change the selection state of the icon. Do not
                    invoke the hook function again.

        tags -- Additional options.@{b}

   TAGS@{ub}
        No tags are defined yet (V44).@{b}

   RESULTS@{ub}
        result -- @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if the drawer in question could not be found,
            @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} otherwise. If @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} is returned, you can query the error
            code using @{"dos.library/IoErr()" LINK "gg:doc/NDK/Guide/dos/IoErr"}.@{b}

   EXAMPLE@{ub}
        /* Select the icon labeled "Prefs" in the drawer "SYS:". */
        @{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} hook;

        /* This hook code is responsible for selecting the icon. */
        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}
        SelectPrefs(@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *hook,@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} reserved,@{"struct IconSelectMsg" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 490} *ism)
        {
            /* Remember the old icon select status; if the icon name
             * does not match "Prefs", this is what we will return,
             * not changing anything.
             */
            @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} selected = ism->ism_Selected;

            /* If the name matches, select it. Otherwise, leave its
             * select state alone.
             */
            if(@{"Stricmp" LINK "gg:doc/NDK/Guide/utility/Stricmp"}(ism->ism_Name,"Prefs") == 0)
                selected = @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95};

            return(selected);
        }

        .
        .
        .

        /* Set up the hook data structure. */
        hook.h_Entry = @{"HookEntry" LINK "gg:doc/NDK/Guide/amiga_lib/HookEntry"};
        hook.h_SubEntry = (@{"HOOKFUNC" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 39})SelectPrefs;

        /* And finally change the selection. */
        @{"ChangeWorkbenchSelection" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 120}("SYS:",&hook,@{"TAG_END" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 40});@{b}

   NOTES@{ub}
        The name of the drawer to work on is interpreted relative
        to the current directory of the program to call
        @{"ChangeWorkbenchSelectionA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 115}().

        For this function call to succeed, Workbench must be open. This
        means that the LoadWB command was executed and the Workbench
        screen has been opened.

        While the user is dragging icons, no on-screen rendering may
        take place. In this state Workbench may refuse to execute the
        @{"ChangeWorkbenchSelection" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 120}() call and return an error code instead
        (@{"ERROR_OBJECT_IN_USE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 193}).@{b}

   BUGS@{ub}
        This function must be considered unsafe for workbench.library
        version 44 due to unexpected side-effects triggered
        by changing the state of selection. This bug was fixed in
        version 45.@{b}

   SEE ALSO@{ub}
        @{"dos.library/IoErr" LINK "gg:doc/NDK/Guide/dos/IoErr"}

@ENDNODE
@NODE "CloseWorkbenchObjectA" "workbench.library/CloseWorkbenchObjectA()"
@{b}

   NAME@{ub}
        @{"CloseWorkbenchObjectA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 84} -- Close a drawer as if the user had clicked
            on the window close gadget. (V44)@{b}

   SYNOPSIS@{ub}
        success = @{"CloseWorkbenchObjectA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 84}(name,tags)
           D0                            A0   A1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"CloseWorkbenchObjectA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 84}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} name,@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *tags);

        success = @{"CloseWorkbenchObject" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 89}(name,...);

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"CloseWorkbenchObject" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 89}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} name,...);@{b}

   FUNCTION@{ub}
        This routine attempts to close the named object as if the user
        had clicked on its drawer window close gadget.@{b}

   INPUTS@{ub}
        name -- Name of the drawer to be closed.

        tags -- Additional options.@{b}

   TAGS@{ub}
        No tags are defined yet (V44).@{b}

   RESULTS@{ub}
        result -- @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if the object in question could not be closed,
            @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} otherwise. If @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} is returned, you can query the error
            code using @{"dos.library/IoErr()" LINK "gg:doc/NDK/Guide/dos/IoErr"}.@{b}

   EXAMPLE@{ub}
        /* Close the drawer "SYS:" */
        @{"CloseWorkbenchObjectA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 84}("SYS:",@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101});@{b}

   NOTES@{ub}
        The name of the drawer to be closed is interpreted relative
        to the current directory of the program to call
        @{"CloseWorkbenchObjectA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 84}().

        For this function call to succeed, Workbench must be open. This
        means that the LoadWB command was executed and the Workbench
        screen has been opened.

        While the user is dragging icons, no on-screen rendering may
        take place. In this state Workbench may refuse to execute the
        @{"CloseWorkbenchObject" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 89}() call and return an error code instead
        (@{"ERROR_OBJECT_IN_USE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 193}).@{b}

   SEE ALSO@{ub}
        @{"dos.library/IoErr" LINK "gg:doc/NDK/Guide/dos/IoErr"}
        @{"workbench.library/OpenWorkbenchObjectA" LINK "OpenWorkbenchObjectA"}

@ENDNODE
@NODE "MakeWorkbenchObjectVisibleA" "workbench.library/MakeWorkbenchObjectVisibleA()"
@{b}

   NAME@{ub}
        @{"MakeWorkbenchObjectVisibleA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 124} -- Change a Workbench window in such a
            way as to make a particular icon visible. (V44)@{b}

   SYNOPSIS@{ub}
        success = @{"MakeWorkbenchObjectVisibleA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 124}(name,tags)
           D0                                  A0   A1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"MakeWorkbenchObjectVisibleA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 124}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} name,@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *tags);

        success = @{"MakeWorkbenchObjectVisible" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 129}(name,...);

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"MakeWorkbenchObjectVisible" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 129}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} name,...);@{b}

   FUNCTION@{ub}
        Due to how the scrollers of a Workbench window affect the positions
        of the icons inside that window, some icons may not be drawn inside
        the bounds of the window. By using @{"MakeWorkbenchObjectVisibleA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 124}()
        the window scrollers can be made to scroll such a "hidden" icon
        into view.@{b}

   INPUTS@{ub}
        name -- Name of the icon to make visible. Note that the window
            the icon resides in must already be open.

        tags -- Additional options.@{b}

   TAGS@{ub}
        No tags are defined yet (V44).@{b}

   RESULTS@{ub}
        result -- @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if the icon in question could not be found,
            @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} otherwise. If @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} is returned, you can query the error
            code using @{"dos.library/IoErr()" LINK "gg:doc/NDK/Guide/dos/IoErr"}.@{b}

   EXAMPLE@{ub}
        /* Make the icon for the drawer "SYS:" visible. */
        @{"MakeWorkbenchObjectVisible" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 129}("SYS:",@{"TAG_END" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 40});@{b}

   NOTES@{ub}
        The name of the icon to make visible is interpreted relative
        to the current directory of the program to call
        @{"MakeWorkbenchObjectVisibleA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 124}().

        For this function call to succeed, Workbench must be open. This
        means that the LoadWB command was executed and the Workbench
        screen has been opened.

        While the user is dragging icons, no on-screen rendering may
        take place. In this state Workbench may refuse to execute the
        @{"MakeWorkbenchObjectVisible" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 129}() call and return an error code instead
        (@{"ERROR_OBJECT_IN_USE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 193}).@{b}

   SEE ALSO@{ub}
        @{"dos.library/IoErr" LINK "gg:doc/NDK/Guide/dos/IoErr"}

@ENDNODE
@NODE "OpenWorkbenchObjectA" "workbench.library/OpenWorkbenchObjectA()"
@{b}

   NAME@{ub}
        @{"OpenWorkbenchObjectA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 75} -- Open a drawer or launch a program as if
            the user had double-clicked on an icon. (V44)@{b}

   SYNOPSIS@{ub}
        success = @{"OpenWorkbenchObjectA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 75}(name,tags)
           D0                           A0   A1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"OpenWorkbenchObjectA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 75}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} name,@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *tags);

        success = @{"OpenWorkbenchObject" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 80}(name,...);

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"OpenWorkbenchObject" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 80}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} name,...);@{b}

   FUNCTION@{ub}
        This routine attempts to open the named object as if the user
        had double-clicked on its icon. This allows you to open drawers
        under program control or to have Workbench launch your programs.@{b}

   INPUTS@{ub}
        name -- Name of the object to be opened; this can be a drawer
            name, a tool name or a project name.

        tags -- Additional options.@{b}

   TAGS@{ub}
        @{"WBOPENA_ArgLock" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 244} (@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}) -- Corresponds to the WBArg->wa_Lock
            entry of a WBStartup message, to be sent to a program
            to be launched. The lock you provide will be duplicated
            when it is put into a WBArg list.

            The @{"WBOPENA_ArgLock" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 244} determines the lock parameters
            to be associated with all following @{"WBOPENA_ArgName" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 247} tags.

            This tag defaults to @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.

        @{"WBOPENA_ArgName" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 247} (@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}) -- Corresponds to the WBArg->wa_Name
            entry of a WBStartup message to be sent to a program
            to be launched. This tag can be used to construct a list
            of parameters to pass to the tool/project to be launched.
            It works in conjunction with the @{"WBOPENA_ArgLock" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 244} tag.
            The name you provide will be duplicated when it is put
            into a WBArg list.

        @{"WBOPENA_Show" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 253} (@{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62}) -- If opening a drawer, change its
            show mode. You can either have the drawer show all
            files (@{"DDFLAGS_SHOWALL" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 63}) or only icons (@{"DDFLAGS_SHOWICONS" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 62}).
            If the drawer in question is already open, its show
            mode will be changed, too. This may result in the drawer's
            contents getting reread. Note that if you specify
            a show mode that is not among @{"DDFLAGS_SHOWALL" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 63}..SHOWICONS
            no change will occur; (V45)

        @{"WBOPENA_ViewBy" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 260} (@{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62}) -- If opening a drawer, change its
            view mode. You can view the contents as icons (@{"DDVM_BYICON" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 54}),
            sorted by name (@{"DDVM_BYNAME" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 55}), sorted by date (@{"DDVM_BYDATE" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 56}),
            sorted by size (@{"DDVM_BYSIZE" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 57}) or by type (@{"DDVM_BYTYPE" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 58}).
            If the drawer in question is already open, its view mode
            will be changed, too. Note that if you specify a view mode
            that is not among @{"DDVM_BYICON" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 54}..BYTYPE no change will
            occur; (V45)@{b}

   RESULTS@{ub}
        result -- @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if the object in question could not be opened,
            @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} otherwise. Note that @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} may be returned even if
            the program the object represents could not be launched;
            this is due to limitations in the current (V44) Workbench
            design. If @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} is returned, you can query the error
            code using @{"dos.library/IoErr()" LINK "gg:doc/NDK/Guide/dos/IoErr"}.@{b}

   EXAMPLE@{ub}
        /* Launch Multiview with S:Startup-Sequence as its parameter. */
        @{"OpenWorkbenchObject" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 80}("MultiView",
            @{"WBOPENA_ArgLock" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 244}, @{"Lock" LINK "gg:doc/NDK/Guide/dos/Lock"}("S:",@{"SHARED_LOCK" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 47}),
            @{"WBOPENA_ArgName" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 247}, "Startup-Sequence",
        @{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39});

        /* Launch the application "Paint" with the project files "Image1"
         * and "Image2", which are both found in the drawer "Paint:Pictures".
         */
        @{"OpenWorkbenchObject" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 80}("Paint",
            @{"WBOPENA_ArgLock" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 244}, @{"Lock" LINK "gg:doc/NDK/Guide/dos/Lock"}("Paint:Pictures",@{"SHARED_LOCK" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 47}),
            @{"WBOPENA_ArgName" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 247}, "Image1",
            @{"WBOPENA_ArgName" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 247}, "Image2",
        @{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39});

        /* Launch the application "Paint" with the project files "Image1"
         * and "Anim1", which are both found in the drawers "Paint:Pictures"
         * and "Paint:Animations", respectively.
         */
        @{"OpenWorkbenchObject" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 80}("Paint",
            @{"WBOPENA_ArgLock" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 244}, @{"Lock" LINK "gg:doc/NDK/Guide/dos/Lock"}("Paint:Pictures",@{"SHARED_LOCK" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 47}),
            @{"WBOPENA_ArgName" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 247}, "Image1",
            @{"WBOPENA_ArgLock" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 244}, @{"Lock" LINK "gg:doc/NDK/Guide/dos/Lock"}("Paint:Animations",@{"SHARED_LOCK" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 47}),
            @{"WBOPENA_ArgName" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 247}, "Anim1",
        @{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39});@{b}

   NOTES@{ub}
        You need not specify fully qualified path names for programs to
        be launched. Workbench will look for files without fully
        qualified path names along its default Shell search path.
        In any case, Workbench will look for the tool to be launched
        in the current directory of the program that called
        @{"OpenWorkbenchObjectA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 75}(). The same holds true for drawers.

        When launching a program, Workbench will automatically figure
        out which tool to use if the object in question is actually a
        project file with a project icon. Note that if the project
        icon's default tool cannot be found, you will not see any
        error message.

        Workbench transparently supports launching of Shell programs,
        but this is not recommended. You should always launch Shell
        programs from your own process.

        If you open a drawer, all WBOPENA_Arg[..] parameters you may
        have provided will be ignored.

        For this function call to succeed, Workbench must be open. This
        means that the LoadWB command was executed and the Workbench
        screen has been opened.

        While the user is dragging icons, no on-screen rendering may
        take place. In this state Workbench may refuse to execute the
        @{"OpenWorkbenchObject" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 80}() call and return an error code instead
        (@{"ERROR_OBJECT_IN_USE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 193}).@{b}

   BUGS@{ub}
        Up to and including version 45.38 this function was unsafe
        and could not be used to reliably launch Workbench programs
        without causing memory to be trashed. The only functionality
        considered safe involved opening drawer windows.

        Up to and including version 45.2 it was not possible to open
        project icons that did not have files associated with them.
        This was fixed with version 45.38 which, if necessary, will
        resort to reading the project icon associated with the file
        name given rather than returning an error for the missing file.@{b}

   SEE ALSO@{ub}
        @{"dos.library/IoErr" LINK "gg:doc/NDK/Guide/dos/IoErr"}
        @{"workbench.library/CloseWorkbenchObjectA" LINK "CloseWorkbenchObjectA"}
        <@{"workbench/startup.h" LINK "gg:doc/NDK/Guide/Include/workbench/startup.h/File"}>

@ENDNODE
@NODE "RemoveAppIcon" "workbench.library/RemoveAppIcon()"
@{b}

   NAME@{ub}
        @{"RemoveAppIcon" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 54} - remove an icon from Workbench's list            (V36)
                         of AppIcons.@{b}

   SYNOPSIS@{ub}
        success = @{"RemoveAppIcon" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 54}(AppIcon)
         D0                      A0

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"RemoveAppIcon" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 54}(@{"struct AppIcon" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 163} *);@{b}

   FUNCTION@{ub}
        Attempt to remove an AppIcon from Workbench's list of AppIcons.@{b}

   INPUTS@{ub}
        AppIcon - pointer to an AppIcon structure returned by @{"AddAppIcon" LINK "AddAppIconA"}.@{b}

   RESULTS@{ub}
        success - @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if the icon could be removed, @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} otherwise.@{b}

   NOTES@{ub}
        As with anything that deals with asynchronous operation, you will need
        to do a final check for messages on your AppMessage port for messages
        that may have come in between the last time you checked and the
        call to remove the AppIcon.@{b}

   SEE ALSO@{ub}
        @{"workbench.library/AddAppIconA" LINK "AddAppIconA"}

@ENDNODE
@NODE "RemoveAppMenuItem" "workbench.library/RemoveAppMenuItem()"
@{b}

   NAME@{ub}
        @{"RemoveAppMenuItem" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 67} - remove a menu item from Workbench's list     (V36)
                            of AppMenuItems.@{b}

   SYNOPSIS@{ub}
        success = @{"RemoveAppMenuItem" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 67}(AppMenuItem)
         D0                            A0

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"RemoveAppMenuItem" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 67}(@{"struct AppMenuItem" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 164} *);@{b}

   FUNCTION@{ub}
        Attempt to remove an AppMenuItem from Workbench's list
        of AppMenuItems.@{b}

   INPUTS@{ub}
        AppMenuItem - pointer to an AppMenuItem structure returned by
                      @{"AddAppMenuItem" LINK "AddAppMenuItemA"}.@{b}

   RESULTS@{ub}
        success - @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if the menu could be removed, @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} otherwise.@{b}

   NOTES@{ub}
        As with anything that deals with asynchronous operation, you will need
        to do a final check for messages on your AppMessage port for messages
        that may have come in between the last time you checked and the
        call to removed the AppMenuItem.@{b}

   SEE ALSO@{ub}
        @{"workbench.library/AddAppMenuItemA" LINK "AddAppMenuItemA"}

@ENDNODE
@NODE "RemoveAppWindow" "workbench.library/RemoveAppWindow()"
@{b}

   NAME@{ub}
        @{"RemoveAppWindow" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 41} - remove a window from Workbench's list         (V36)
                          of AppWindows.@{b}

   SYNOPSIS@{ub}
        success = @{"RemoveAppWindow" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 41}(AppWindow)
         D0                        A0

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"RemoveAppWindow" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 41}(@{"struct AppWindow" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 161} *);@{b}

   FUNCTION@{ub}
        Attempt to remove an appwindow from Workbench's list of AppWindows.@{b}

   INPUTS@{ub}
        AppWindow - pointer to an AppWindow structure returned by
                    @{"AddAppWindow" LINK "AddAppWindowA"}.@{b}

   RESULTS@{ub}
        success - @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if the window could be removed, @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} otherwise.@{b}

   NOTES@{ub}
        As with anything that deals with asynchronous operation, you will need
        to do a final check for messages on your AppMessage port for messages
        that may have come in between the last time you checked and the
        call to removed the AppWindow.

        Before the AppWindow is removed, all its drop zones will be removed
        first. There is no need for you to call @{"RemoveAppWindowDropZone()" LINK "RemoveAppWindowDropZone"}
        for every single one.@{b}

   SEE ALSO@{ub}
        @{"workbench.library/AddAppWindowA" LINK "AddAppWindowA"}
        @{"workbench.library/RemoveAppWindowDropZone" LINK "RemoveAppWindowDropZone"}

@ENDNODE
@NODE "RemoveAppWindowDropZone" "workbench.library/RemoveAppWindowDropZone()"
@{b}

   NAME@{ub}
        @{"RemoveAppWindowDropZone" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 111} -- Remove a drop zone from an AppWindow.@{b}

   SYNOPSIS@{ub}
        success = @{"RemoveAppWindowDropZone" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 111}(appWindow,dropZone)
          D0                                 A0        A1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"RemoveAppWindowDropZone" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 111}(@{"struct AppWindow" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 161} *,
                                     @{"struct AppWindowDropZone" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 162} *);@{b}

   FUNCTION@{ub}
        Attempt to remove a drop zone from an AppWindow.@{b}

   INPUTS@{ub}
        appWindow -- pointer to an AppWindow structure returned by
            @{"workbench.library/AddAppWindowA" LINK "AddAppWindowA"}. A value of @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} will be
            ignored.
        dropZone -- pointer to an AppWindowDropZone returned by
            @{"workbench.library/AddAppWindowDropZoneA" LINK "AddAppWindowDropZoneA"}. A value of @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} will
            be ignored.@{b}

   RESULTS@{ub}
        success - @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if the drop zone could be removed, @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} otherwise.
            The reason for the failure can be obtained using
            @{"dos.library/IoErr" LINK "gg:doc/NDK/Guide/dos/IoErr"}. This routine may fail if the specified drop
            zone is not registered with the AppWindow.@{b}

   NOTES@{ub}
        Due to the asynchronous nature of Workbench/user interaction, you
        may receive AppIcon drop zone messages for zones that you have
        just removed. These messages may arrive in the time between your
        code calling @{"RemoveAppWindowDropZone" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 111}() and Workbench responding
        to the drop zone removal request. Be prepared to handle this. Once
        a drop zone is removed, it will generate no new AppMessages.@{b}

   SEE ALSO@{ub}
        @{"workbench.library/AddAppWindowDropZoneA" LINK "AddAppWindowDropZoneA"}

@ENDNODE
@NODE "UpdateWorkbench" "workbench.library/UpdateWorkbench()"
@{b}

   NAME@{ub}
        UpdateWorkbench - Tell Workbench of a new or deleted icon.       (V37)@{b}

   SYNOPSIS@{ub}
        UpdateWorkbench(name, parentlock, action)
                        A0    A1          D0

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} UpdateWorkbench(char *, @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        This function does the "magic" of letting Workbench know that
        an object has been added, changed, or removed. The name is
        the name of the object, the lock is a lock on the directory that
        contains the object. The action determines what has happened.
        If @{"UPDATEWB_ObjectAdded" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 692}, the object is either NEW or has CHANGED.
        If @{"UPDATEWB_ObjectRemoved" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 691}, the object has been deleted.@{b}

   INPUTS@{ub}
        name - Name of the object (without the .info)

        parentlock - Lock on the object's parent directory.

        action - @{"UPDATEWB_ObjectAdded" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 692} for a new or changed object
                 @{"UPDATEWB_ObjectRemoved" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 691} for a deleted object@{b}

   RESULTS@{ub}
        Workbench will update its display, if needed. An object that has
        been deleted will be removed from the display. An object that is
        new will be added to the respective display if it is not already
        there; if it is already there, its appearance will be changed if
        necessary.@{b}

   EXAMPLE@{ub}
        /* Remove the object named "Prefs" from the SYS: drawer display;
         * note that this will affect only the display, the drawer will
         * still remain on the file system, and telling Workbench to
         * rescan the drawer will reveal it again.
         */
        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} lock,old_dir;

        lock = @{"Lock" LINK "gg:doc/NDK/Guide/dos/Lock"}("SYS:",@{"SHARED_LOCK" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 47});
        UpdateWorkbench("Prefs",lock,@{"UPDATEWB_ObjectRemoved" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 691});
        @{"UnLock" LINK "gg:doc/NDK/Guide/dos/UnLock"}(lock);

        /* Change the name of the file "RAM:Thursday"
         * to "Friday"; this works by first removing the
         * object from the display, renaming the object
         * and then telling Workbench that the object has
         * changed.
         */
        lock = @{"Lock" LINK "gg:doc/NDK/Guide/dos/Lock"}("RAM:",@{"SHARED_LOCK" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 47});
        UpdateWorkbench("Thursday",lock,@{"UPDATEWB_ObjectRemoved" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 691});
        old_dir = @{"CurrentDir" LINK "gg:doc/NDK/Guide/dos/CurrentDir"}(lock);
        @{"Rename" LINK "gg:doc/NDK/Guide/dos/Rename"}("Thursday","Friday");
        @{"CurrentDir" LINK "gg:doc/NDK/Guide/dos/CurrentDir"}(old_dir);
        UpdateWorkbench("Friday",lock,@{"UPDATEWB_ObjectAdded" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 692});
        @{"UnLock" LINK "gg:doc/NDK/Guide/dos/UnLock"}(lock);@{b}

   NOTES@{ub}
        Note that saying that a DISK icon has been deleted will not do
        much as disk icons must continue to be visible. Thus, this
        is currently a NO-OP. At some future date (maybe) it will change
        the disk icon to the default.@{b}

   SEE ALSO@{ub}
        @{"icon.library/PutDiskObject" LINK "gg:doc/NDK/Guide/icon/PutDiskObject"}
        @{"icon.library/DeleteDiskObject" LINK "gg:doc/NDK/Guide/icon/DeleteDiskObject"}

@ENDNODE
@NODE "WBInfo" "workbench.library/WBInfo()"
@{b}

   NAME@{ub}
        @{"WBInfo" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 71} - Bring up the Information requester                     (V39)@{b}

   SYNOPSIS@{ub}
        worked = @{"WBInfo" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 71}(lock, name, screen)
        d0              a0    a1    a2

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"WBInfo" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 71}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"struct Screen" LINK "gg:doc/NDK/Guide/Include/intuition/screens.h/File" 133} *);@{b}

   FUNCTION@{ub}
        This is the LVO that Workbench calls to bring up the Icon Information
        requester.  External applications may also call this requester.
        In addition, if someone were to wish to replace this requester
        with another one, they could do so via a @{"SetFunction" LINK "gg:doc/NDK/Guide/exec/SetFunction"}.@{b}

   INPUTS@{ub}
        lock   - A lock on the parent directory
        name   - The name of the icon contained within above directory
        screen - A screen pointer on which the requester is to show up@{b}

   RESULTS@{ub}
        worked - Returns @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if the requester came up, @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if it did not.@{b}

   NOTE@{ub}
        Note that this LVO may be called many times by different tasks
        before other calls return.  Thus, the code must be 100% re-entrant.@{b}

   SEE ALSO@{ub}
        @{"icon.library" LINK "gg:doc/NDK/Guide/icon/MAIN"}

@ENDNODE
@NODE "WorkbenchControlA" "workbench.library/WorkbenchControlA()"
@{b}

   NAME@{ub}
        @{"WorkbenchControlA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 93} -- Query or modify Workbench and icon
            options. (V44)@{b}

   SYNOPSIS@{ub}
        success = @{"WorkbenchControlA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 93}(name,tags)
           D0                       A0   A1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"WorkbenchControlA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 93}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} name,@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *tags);

        success = @{"WorkbenchControl" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 98}(name,...);

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"WorkbenchControl" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 98}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} name,...);@{b}

   FUNCTION@{ub}
        With this function you can query or modify global Workbench
        parameters or local icon options.@{b}

   INPUTS@{ub}
        name -- Name of an object to query or modify.

        tags -- Additional options.@{b}

   TAGS@{ub}
        @{"WBCTRLA_IsOpen" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 267} (@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} *) -- Check if the named object is
            currently open. In this case, the function "name"
            parameter refers to the drawer that should be
            tested; the result value will be set to @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if
            the named drawer is currently open, @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} otherwise.

        @{"WBCTRLA_DuplicateSearchPath" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 270} (@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} *) -- This is a safe way
            to obtain a copy of the Workbench search path list.
            You will receive a @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} to a path list, such as can
            be stored in the cli_CommandDir pointer of a
            CommandLineInterface structure. Note that this is really
            a copy of the Workbench search path list and not a reference
            to the data associated with the Workbench process. Thus,
            it can be freed by @{"FreeDosObject" LINK "gg:doc/NDK/Guide/dos/FreeDosObject"}(@{"DOS_CLI" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 277},..), if part of
            a CommandLineInterface structure.

        @{"WBCTRLA_FreeSearchPath" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 273} (@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}) -- If you did not attach the
            data returned by the @{"WBCTRLA_DuplicateSearchPath" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 270}
            to a CLI, to be freed automatically later, you can
            pass it back to @{"WorkbenchControlA" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 93}() to be released.

        @{"WBCTRLA_GetDefaultStackSize" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 276} (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} *) -- Get the default stack
            size used by Workbench when launching Shell programs
            or programs without a valid stack size number.

            The default stack size is 4096 bytes.

        @{"WBCTRLA_SetDefaultStackSize" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 279} (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -- Set the default stack
            size used by Workbench when launching Shell programs
            or programs without a valid stack size number. You cannot
            set a stack size number smaller than 4096 bytes

        @{"WBCTRLA_RedrawAppIcon" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 282} (@{"struct AppIcon" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 163} *) -- This tag will cause
            Workbench to redraw an AppIcon. Note that due to which state
            the Workbench is currently in, it may refuse to redraw the
            icon.

        @{"WBCTRLA_GetProgramList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 285} (@{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} **) -- You can obtain a list
            of currently running Workbench programs; every entry of this
            list will have the complete path to the program and the
            program name in its Node->ln_Name. When you no longer need
            the list, don't forget to free it again using the tag
            @{"WBCTRLA_FreeProgramList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 288}.

            Note that the list you will receive may be empty. Be
            prepared to handle this.

        @{"WBCTRLA_FreeProgramList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 288} (@{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} *) -- With this tag you can
            free the list allocated by the @{"WBCTRLA_GetProgramList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 285} tag.

        @{"WBCTRLA_GetSelectedIconList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 291} (@{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} **) -- You can obtain a
            list of currently selected icons; every entry of this
            list will have the complete path to the icon and the
            icon name in its Node->ln_Name. Some icons do not enter the
            list, such as AppIcons. When you no longer need the list,
            don't forget to free it again using the tag
            @{"WBCTRLA_FreeSelectedIconList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 294}.

            Note that the list you will receive may be empty. Be
            prepared to handle this.

        @{"WBCTRLA_FreeSelectedIconList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 294} (@{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} *) -- With this tag
            you can free the list allocated by the
            @{"WBCTRLA_GetSelectedIconList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 291} tag.

        @{"WBCTRLA_GetOpenDrawerList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 297} (@{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} **) -- You can obtain a
            list of currently open drawers and volumes; every entry of this
            list will have the complete drawer path name in its Node->ln_Name.
            When you no longer need the list, don't forget to free it
            again using the tag @{"WBCTRLA_FreeOpenDrawerList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 300}.

            Note that the list you will receive may be empty. Be
            prepared to handle this.

        @{"WBCTRLA_FreeOpenDrawerList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 300} (@{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} *) -- With this tag
            you can free the list allocated by the
            @{"WBCTRLA_GetOpenDrawerList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 297} tag.

        @{"WBCTRLA_AddHiddenDeviceName" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 311} (@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}) -- Name of a device which
            Workbench should not display a disk or device icon for.
            Any such device will be effectively hidden from the Workbench
            backdrop. The name must include a terminating colon character,
            such as in "DF0:".

            Note that adding new entries to this list may not immediately
            take effect.

        @{"WBCTRLA_RemoveHiddenDeviceName" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 314} (@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}) -- Name of a device on
            the list of devices to be hidden which should be removed.
            The name must include a terminating colon character,
            such as in "DF0:". Trying to remove an entry from the list
            that is not on it will have no effect.

            Note that removing entries from this list may not immediately
            take effect.

        @{"WBCTRLA_GetHiddenDeviceList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 303} (@{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} **) -- This will obtain
            the list of devices whose contents which Workbench will not
            display.

            Note that the list you will receive may be empty. Be
            prepared to handle this.

        @{"WBCTRLA_FreeHiddenDeviceList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 306} (@{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} *) -- With this tag
            you can free the list allocated by the
            @{"WBCTRLA_GetHiddenDeviceList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 303} tag.

        @{"WBCTRLA_GetTypeRestartTime" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 320} (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} *) -- Get the number of seconds
            that have to pass before typing the next character in a drawer
            window will restart with a new file name.

        @{"WBCTRLA_SetTypeRestartTime" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 326} (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -- Set the number of seconds
            that have to pass before typing the next character in a drawer
            window will restart with a new file name. You must specify a
            number greater than 0. Default type restart time is 3 seconds.

        @{"WBCTRLA_GetCopyHook" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 331} (@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} **) -- Obtain the hook that will be
            invoked when Workbench starts to copy files and data; this
            may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} which means that Workbench will use the built-in
            copy/move code (V45).

        @{"WBCTRLA_SetCopyHook" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 336} (@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *) -- Install the hook that will be
            invoked when Workbench starts to copy files and data.
            To make Workbench use the built-in copy code, use a @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
            hook pointer. Note: the hook cannot be replaced if Workbench is
            currently copying data; @{"WorkbenchControl" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 98}() will stop and
            return with an error code of @{"ERROR_OBJECT_IN_USE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 193} set (V45).

            The hook will be invoked with three kinds of messages: exactly
            one CopyBeginMsg, one CopyDataMsg for each file or drawer to
            be copied and exactly one CopyEndMsg after all files and drawers
            have been copied.

            NOTE: you may examine the contents of the message your hook
                  code receives, but they may not be changed!

            The hook will be invoked with the following parameters:

            error = hookFunc(hook,reserved,message)
              D0              A0     A2      A1

            @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} hookFunc(@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *hook,@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} reserved,
                          @{"struct CopyBeginMsg" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 545} *message);

            -- or --

            @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} hookFunc(@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *hook,@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} reserved,
                          @{"struct CopyDataMsg" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 553} *message);

            -- or --

            @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} hookFunc(@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *hook,@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} reserved,
                          @{"struct CopyEndMsg" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 585} *message);

            The reserved parameter will always be set to @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} (V45).

            The copying process starts by invoking the hook with a
            CopyBeginMsg whose contents look like this:

                cbm_Length

                    Size of the CopyBeginMsg in bytes; this may grow
                    in future Workbench releases.

                cbm_Action

                    For a CopyBeginMsg this will always be set to
                    @{"CPACTION_Begin" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 591}.

                cbm_SourceDrawer

                    This will be a Lock on the source drawer.

                cbm_DestinationDrawer

                    This will be a Lock on the destination drawer.

            You will receive exactly one CopyBeginMsg before copying
            starts. You will need to set up all the information and data
            you need for copying and return an error code in case your
            initialization failed; this should be an error code from
            <@{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"}>, e.g. @{"ERROR_NO_FREE_STORE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 181}. If your initialization
            could be completed successfully, a value of 0 should be returned.


            Once the initialization has been completed successfully, your
            hook code will receive a CopyDataMsg for every file or drawer
            that needs to be copied. Your code will have to figure out for
            itself whether the source is a file, a directory or even a
            volume. Directories and volumes need to be copied recursively
            by copying files and directories located at deeper levels of
            the file system.

            The contents of a CopyDataMsg look like this:

                cdm_Length

                    Size of the CopyDataMsg in bytes; this may grow
                    in future Workbench releases.

                cdm_Action

                    For a CopyDataMsg this will always be set to
                    @{"CPACTION_Copy" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 594}.

                cdm_SourceLock

                    A lock on the source file/drawer's parent directory; this
                    may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} in case an entire volume is to be copied.

                cdm_SourceName

                    Name of the source file/drawer to be copied, relative
                    to the parent drawer it is located in and to which you
                    will find a Lock supplied in the cdm_SourceLock member.
                    For volumes that Lock may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.

                cdm_DestinationLock

                    A lock on the drawer in which the destination file or
                    drawer is to be created.

                cdm_DestinationName

                    Name of the file or drawer the source data should be
                    copied to. In most cases this name matches the source
                    name, but if data is to be duplicated (such as through
                    the Workbench "Copy" command), then the name will be
                    different.

                cdm_DestinationX
                cdm_DestinationY

                    After the copy process has successfully completed and the
                    copied drawer/file icon has to be written, it should be
                    placed at this position when it is written to disk.

            Your copy code is responsible for notifying Workbench of any
            icons newly created as a result of the copying process. If an error
            crops up during copying or the process is aborted, your code must
            return a non-zero error code (as listed in <@{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"}> or in
            <@{"dos/dosasl.h" LINK "gg:doc/NDK/Guide/Include/dos/dosasl.h/File"}>). A return code of 0 indicates success; Workbench
            will proceed to invoke your code again with another file/drawer
            name.


            When the copy process has completed, either successfully or due
            to an error, your hook code will be invoked exactly once with
            a CopyEndMsg. This allows you to perform any cleanup operations
            that may be necessary. The contents of a CopyEndMsg look like
            this:

                cem_Length

                    Size of the CopyEndMsg in bytes; this may grow
                    in future Workbench releases.

                cem_Action

                    For a CopyEndMsg this will always be set to
                    @{"CPACTION_End" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 597}.


            Note that Workbench will not recurse into directories,
            supplying you with the names of all files and directories
            to be copied; it will generally only supply the names of
            the files and drawers that are currently selected. You will
            have to handle all the necessary recursion by yourself.

        @{"WBCTRLA_GetDeleteHook" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 342} (@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} **) -- Obtain the hook that will
            be invoked when Workbench discards files and drawers or empties
            the trashcan. This may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} which means that Workbench will
            use the built-in deletion code (V45).

        @{"WBCTRLA_SetDeleteHook" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 348} (@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *) -- Install the hook that will
            be invoked when Workbench discards files and drawers or empties
            the trash can. To make Workbench use the built-in deletion code,
            use a @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} hook pointer. Note: the hook cannot be replaced if
            Workbench is currently deleting files and drawers or the trashcan
            is being emptied; @{"WorkbenchControl" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 98}() will stop and return with an
            error code of @{"ERROR_OBJECT_IN_USE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 193} set (V45).

            The hook will be invoked with six different kinds of messages,
            depending upon what operation is to be performed. If the files
            and drawers are to be discarded you will receive exactly one
            DeleteBeginMsg with its dbm_Action member set to
            @{"DLACTION_BeginDiscard" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 633}, followed by a DeleteDataMsg for each
            file or drawer to be deleted and eventually exactly one
            DeleteEndMsg when the deletion process is finished. If the
            trashcan is to be emptied you will receive exactly one
            DeleteBeginMsg with its dbm_Action member set to
            @{"DLACTION_BeginEmptyTrash" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 640}, followed by exactly one DeleteDataMsg
            and eventually exactly one DeleteEndMsg.

            NOTE: you may examine the contents of the message your hook
                  code receives, but they may not be changed!

            The hook will be invoked with the following parameters:

            error = hookFunc(hook,reserved,message)
              D0              A0     A2      A1

            @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} hookFunc(@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *hook,@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} reserved,
                          @{"struct DeleteBeginMsg" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 604} *message);

            -- or --

            @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} hookFunc(@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *hook,@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} reserved,
                          @{"struct DeleteDataMsg" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 612} *message);

            -- or --

            @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} hookFunc(@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *hook,@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} reserved,
                          @{"struct DeleteEndMsg" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 627} *message);

            The reserved parameter will always be set to @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} (V45).

            The deletion process starts by invoking the hook with a
            DeleteBeginMsg whose contents look like this:

                dbm_Length

                    Size of the DeleteBeginMsg in bytes; this may grow
                    in future Workbench releases.

                dbm_Action

                    For a DeleteBeginMsg this will either be set to
                    @{"DLACTION_BeginDiscard" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 633} or to @{"DLACTION_BeginEmptyTrash" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 640}.
                    @{"DLACTION_BeginDiscard" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 633} is sent if the "Delete" menu
                    item was invoked, and @{"DLACTION_BeginEmptyTrash" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 640} will
                    be sent if the "Empty Trash" menu item was invoked.

            You will receive exactly one DeleteBeginMsg before deletion
            starts. You will need to set up all the information and data
            you need for deleting and return an error code in case your
            initialization failed; this should be an error code from
            <@{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"}>, e.g. @{"ERROR_NO_FREE_STORE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 181}. If your initialization
            could be completed successfully, a value of 0 should be returned.

            NOTE: if you return a value of -1, then Workbench will drop
                  right into the original deletion code. However, this only
                  works for the actions @{"DLACTION_BeginDiscard" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 633} and
                  @{"DLACTION_BeginEmptyTrash" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 640}. This means you can skip the
                  deletion process when it begins, but you cannot skip
                  it while it is running.

            Once the initialization has been completed successfully, your
            hook code will receive a DeleteDataMsg for every file or drawer
            that needs to be deleted. Its contents look like this:

                ddm_Length

                    Size of the DeleteDataMsg in bytes; this may grow
                    in future Workbench releases.

                ddm_Action

                    This may be either @{"DLACTION_DeleteContents" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 644} or
                    @{"DLACTION_DeleteObject" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 650}, depending on exactly what
                    should be deleted.

                    If @{"DLACTION_DeleteContents" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 644} is received it means
                    that the object described by lock and name is a
                    directory: the contents of the directory are to
                    be deleted, but the empty directory itself
                    *MUST @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500}* be deleted.

                    If @{"DLACTION_DeleteObject" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 650} is received it means that
                    the object described by lock and name is either a
                    file or an empty directory which should be deleted.

                    Typically, if the trash can is to be emptied you will
                    receive exactly one @{"DLACTION_DeleteContents" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 644} type
                    message. If drawers are to be deleted, you will first
                    receive a @{"DLACTION_DeleteContents" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 644} type message, followed
                    by a @{"DLACTION_DeleteObject" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 650} message to delete the then
                    empty directory.

                ddm_Lock

                    A lock on the parent directory of the object whose
                    contents or which itself should be deleted.

                ddm_Name

                    The name of the object whose contents or which itself
                    should be deleted.

            Your deletion code is responsible for notifying Workbench of any
            icons removed as a result of the deletion process. If an error
            crops up during deletion or the process is aborted, your code must
            return a non-zero error code (as listed in <@{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"}> or in
            <@{"dos/dosasl.h" LINK "gg:doc/NDK/Guide/Include/dos/dosasl.h/File"}>). A return code of 0 indicates success; Workbench
            will proceed to invoke your code again with another file/drawer
            name.


            When the deletion process has completed, either successfully or due
            to an error, your hook code will be invoked exactly once with
            a DeleteEndMsg. This allows you to perform any cleanup operations
            that may be necessary. The contents of a DeleteEndMsg look like
            this:

                dem_Length

                    Size of the DeleteEndMsg in bytes; this may grow
                    in future Workbench releases.

                dem_Action

                    For a DeleteEndMsg this will always be set to
                    @{"DLACTION_End" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 655}.


            Note that Workbench will not recurse into directories,
            supplying you with the names of all files and directories
            to be deleted; it will generally only supply the names of
            the files and drawers that are currently selected. You will
            have to handle all the necessary recursion by yourself.

        @{"WBCTRLA_GetTextInputHook" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 354} (@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} **) -- Obtain the hook that will
            be invoked when Workbench requests that the user enters text,
            such as when a file is to be renamed or a new drawer is to be
            created. This may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} which means that Workbench will
            use the built-in text input code (V45).

        @{"WBCTRLA_SetTextInputHook" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 360} (@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *) -- Install the hook that will
            be invoked when Workbench requests that the user enters text,
            such as when a file is to be renamed or a new drawer is to be
            created. To make Workbench use the built-in text input code,
            use a @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} hook pointer. Note: the hook cannot be replaced if
            Workbench is currently requesting text to be entered;
            @{"WorkbenchControl" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 98}() will stop and return with an error code of
            @{"ERROR_OBJECT_IN_USE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 193} set.

            The hook will be invoked with the following parameters:

            error = hookFunc(hook,reserved,message)
             D0               A0     A2      A1

            @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} hookFunc(@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *hook,@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} reserved,
                          @{"struct TextInputMsg" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 662} *message);

            You should return a value of 0 when your hook code has
            done its job. If a value of -1 is returned, then Workbench
            will drop right back into the original text input code.

            The reserved parameter will always be set to @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} (V45).

            NOTE: you may examine the contents of the message your hook
                  code receives, but they may not be changed!

            The contents of the TextInputMsg look like this:

                tim_Length

                    Size of the TextInputMsg in bytes; this may grow
                    in future Workbench releases.

                tim_Action

                    This can be one the following values:

                        @{"TIACTION_Rename" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 678}

                            You will find the name of the file or drawer
                            to be renamed in tim_Prompt; you must ask the
                            user to change the name and then rename the
                            file or drawer in question, including the
                            corresponding icon, if there is one.

                            Note that the current directory of the process
                            on whose context your hook code is invoked will
                            be the directory in which the file/drawer to be
                            renamed is located.

                        @{"TIACTION_RelabelVolume" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 681}

                            You will find the name of the volume to be
                            relabled in tim_Prompt (the name does not
                            include a trailing colon); you must ask the
                            user to change the name and the relabel the
                            volume.

                            Note that the current directory of the process
                            on whose context your hook code is invoked will
                            be the root directory of the volume to be
                            relabeled.

                        @{"TIACTION_NewDrawer" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 682}

                            You will find the name of a new drawer to be
                            created in tim_Prompt; Workbench will have
                            provided a name that is not yet used by any
                            drawer or file in the current directory of
                            the process on whose context your hook code
                            is invoked. You must ask the user to change
                            the name of the drawer and then create it,
                            including the corresponding icon.

                        @{"TIACTION_Execute" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 683}

                            You will have to ask the user to supply the
                            name and parameters of a program or ARexx
                            to be executed, and then execute that program.
                            The tim_Prompt member is set to @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} and has
                            no meaning for this type of message.

                tim_Prompt

                    See the descriptions for the individual actions.


            Note that your code will have to perform exactly the same
            duties as the built-in Workbench code. It does not merely
            replace the text entry code, it replaces the entire process
            associated with the respective function. (V45)

        @{"WBCTRLA_AddSetupCleanupHook" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 366} (@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *) -- Add a hook which
            will be invoked before Workbench shuts down and after
            Workbench has initialized itself.

            The hook will be invoked with the following parameters:

            error = hookFunc(hook,reserved,message)
              D0               A0     A2      A1

            @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} hookFunc(@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *hook,@{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} reserved,
                          @{"struct SetupCleanupHookMsg" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 376} *message);

            The 'error' return code is used only for a special
            case of message sent (see below) and will otherwise
            be ignored. The reserved parameter will always be set
            to @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} (V45).

            NOTE: You may examine the contents of the message your hook
                  code receives, but they may not be changed!

            The contents of the SetupCleanupHookMsg look like this:

                schm_Length

                    Size of the SetupCleanupHookMsg in bytes; this may grow
                    in future Workbench releases.

                schm_State

                    This can be one the following values:

                        @{"SCHMSTATE_TryCleanup" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 382}

                            Workbench is attempting to shut down, but there
                            may still be windows open on the Workbench screen
                            which cannot be closed. You are given the
                            opportunity to close any windows you may have open
                            before Workbench checks its own resources and verifies
                            that the Workbench screen can in fact be closed. If
                            your code requires that Workbench stays open, return
                            a non-zero value as the error result code (e.g.
                            @{"ERROR_OBJECT_IN_USE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 193}); otherwise, return a value of 0.

                            NOTE: Since any of the installed hooks may signal
                                  Workbench that it cannot be closed just yet,
                                  it may happen that your hook will never see
                                  a @{"SCHMSTATE_TryCleanup" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 382} message.

                                  If one of the hooks reported that Workbench
                                  should not be closed yet, be prepared to
                                  receiver another message, but this time of
                                  type @{"SCHMSTATE_Setup" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 384}; in case you let go of
                                  all resources upon receiving the previous
                                  @{"SCHMSTATE_TryCleanup" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 382} message, this gives
                                  you the opportunity to reclaim them. Note
                                  too that *all* hooks will receive this
                                  @{"SCHMSTATE_TryCleanup" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 382} message, regardless
                                  of whether they previously received a
                                  @{"SCHMSTATE_TryCleanup" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 382} message or not.

                        @{"SCHMSTATE_Cleanup" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 383}

                            Workbench is about to shut down; your hook
                            is invoked directly before Workbench closes
                            all its windows and disposes of any other
                            resources it may have allocated. Do not delay
                            this process, whatever you need to do in your
                            hook code, do it quickly!

                            NOTE: The result your hook code returns will
                                  be ignored.

                                  Your hook may receive a @{"SCHMSTATE_Cleanup" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 383}
                                  message without seeing a @{"SCHMSTATE_TryCleanup" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 382}
                                  message first. This will be the case if
                                  Workbench resets its internal state
                                  variables; it does not indicate a Workbench
                                  shutdown. A complete Workbench shutdown is
                                  indicated by receiving the following messages
                                  in exactly the order given:

                                      @{"SCHMSTATE_TryCleanup" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 382}
                                      @{"SCHMSTATE_Cleanup" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 383}

                                  In other words, there will be no message of
                                  the type @{"SCHMSTATE_Setup" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 384} to directly follow
                                  the @{"SCHMSTATE_TryCleanup" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 382} message.

                        @{"SCHMSTATE_Setup" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 384}

                            Workbench is (again) in operational state.
                            Your hook is invoked right after the initialization
                            has completed successfully. This is your chance
                            to claim any resources you might need.

                            NOTE: The result your hook code returns will be
                                  ignored.

                                  You may receive any number of messages of
                                  this type. Workbench *does not* keep track
                                  of which hook previously received one of
                                  the messages telling it to shut down.

            Workbench will check the list of hooks already installed and
            return an error in case an attempt is made to add the same
            hook twice (V45).

        @{"WBCTRLA_RemSetupCleanupHook" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 371} (@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *) -- Remove a hook
            previously installed using the @{"WBCTRLA_AddSetupCleanupHook" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 366}
            tag. Workbench will verify that the hook was in fact installed
            before and return an error in case the hook was never ever
            installed (V45).@{b}

   RESULTS@{ub}
        result -- @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if the requested action could not be performed,
            @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} otherwise. If @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} is returned, you can query the error
            code using @{"dos.library/IoErr()" LINK "gg:doc/NDK/Guide/dos/IoErr"}.@{b}

   NOTES@{ub}
        If this function returns @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}, the expected result is undefined.
        For example, if you tried to obtain the list of currently running
        programs via the @{"WBCTRLA_GetProgramList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 285} tag and @{"WorkbenchControl" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 98}()
        failed with an error code, do not expect the List pointer you
        passed in to be initialized.

        This function may only be called by a Process.

        This function may not process all tags if the Workbench is not
        currently open. For V44, the following tags are support if
        Workbench is closed:

            @{"WBCTRLA_SetDefaultStackSize" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 279}
            @{"WBCTRLA_GetDefaultStackSize" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 276}
            @{"WBCTRLA_FreeHiddenDeviceList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 306}
            @{"WBCTRLA_GetHiddenDeviceList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 303}
            @{"WBCTRLA_AddHiddenDeviceName" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 311}
            @{"WBCTRLA_RemoveHiddenDeviceName" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 314}
            @{"WBCTRLA_SetTypeRestartTime" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 326}
            @{"WBCTRLA_GetTypeRestartTime" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 320}

        For V45 the following additional tags are supported while Workbench
        is closed:

            @{"WBCTRLA_GetCopyHook" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 331}
            @{"WBCTRLA_SetCopyHook" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 336}
            @{"WBCTRLA_GetDeleteHook" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 342}
            @{"WBCTRLA_SetDeleteHook" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 348}
            @{"WBCTRLA_GetTextInputHook" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 354}
            @{"WBCTRLA_SetTextInputHook" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 360}

        It should be noted that the copy hook code will never be
        invoked if data can be moved on the file system just by
        renaming it. Likewise, if an entire volume is to be copied
        to a different volume by means of the DiskCopy program,
        the copy hook code will not be invoked either.@{b}

   EXAMPLE@{ub}
        /* Obtain a copy of the Workbench search path list, then
         * release it again.
         */
        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} pathList;

        if(@{"WorkbenchControl" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 98}(@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101},
            @{"WBCTRLA_DuplicateSearchPath" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 270},&pathList,
        @{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39}))
        {
            @{"WorkbenchControl" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 98}(@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101},
                @{"WBCTRLA_FreeSearchPath" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 273},pathList,
            @{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39});
        }

        /* Check if the drawer "SYS:" is open. */
        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} isOpen;

        if(@{"WorkbenchControl" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 98}("SYS:",
            @{"WBCTRLA_IsOpen" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 267},&isOpen,
        @{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39}))
        {
            @{"Printf" LINK "gg:doc/NDK/Guide/dos/VPrintf"}("Drawer \\"SYS:\\" is %s.\\n",
                isOpen ? "open" : "closed");
        }

        /* Print the list of all currently running
         * Workbench programs, then free the list again.
         */
        @{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} * list;

        if(@{"WorkbenchControl" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 98}(@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101},
            @{"WBCTRLA_GetProgramList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 285},&list,
        @{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39}))
        {
            @{"struct Node" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 22} * node;

            for(node = list->lh_Head ;
                node->ln_Succ != @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} ;
                node = node->ln_Succ)
            {
                @{"Printf" LINK "gg:doc/NDK/Guide/dos/VPrintf"}("%s\\n",node->ln_Name);
            }

            @{"WorkbenchControl" LINK "gg:doc/NDK/Guide/Include/inline/wb.h/File" 98}(@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101},
                @{"WBCTRLA_FreeProgramList" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File" 288},list,
            @{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39});
        }@{b}

   SEE ALSO@{ub}
        @{"dos.library/FreeDosObject" LINK "gg:doc/NDK/Guide/dos/FreeDosObject"}
        @{"dos.library/IoErr" LINK "gg:doc/NDK/Guide/dos/IoErr"}
        <@{"dos/dosextens.h" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File"}>

@ENDNODE
