@DATABASE "gg:doc/NDK/Guide/disk"
@MASTER   "gg:doc/NDK/AutoDocs/disk.doc"
@REMARK   This file was created by ADtoHT 2.1 on 06-Jan-13 19:20:12
@REMARK   Do not edit
@REMARK   ADtoHT is © 1993-1995 Christian Stieber

@NODE MAIN "disk.doc"
@TOC "gg:doc/NDK/Guide/TOC/MAIN"

                                @{b}disk.resource@{ub}

@{"AllocUnit()" LINK "AllocUnit"}   @{"FreeUnit()" LINK "FreeUnit"}  @{"GetUnit()" LINK "GetUnit"}  @{"GetUnitID()" LINK "GetUnitID"}  @{"GiveUnit()" LINK "GiveUnit"}
@{"ReadUnitID()" LINK "ReadUnitID"}  

@ENDNODE
@NODE "AllocUnit" "disk.resource/AllocUnit()"
@{b}

   NAME@{ub}
       @{"AllocUnit" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 20} - allocate a unit of the disk@{b}

   SYNOPSIS@{ub}
       Success = @{"AllocUnit" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 20}( unitNum ), DRResource
        D0                   D0         A6

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"AllocUnit" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 20}(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        This routine allocates one of the units of the disk.  It should
        be called before trying to use the disk (via @{"GetUnit" LINK "GetUnit"}).

        In reality, it is perfectly fine to use @{"GetUnit" LINK "GetUnit"}/@{"GiveUnit" LINK "GiveUnit"} if @{"AllocUnit" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 20}
        fails.  Do @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} call @{"FreeUnit" LINK "FreeUnit"} if @{"AllocUnit" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 20} did not succeed.  This
        has been the case for all revisions of disk.resource.@{b}

   INPUTS@{ub}
        unitNum -- a legal unit number (zero through three)@{b}

   RESULTS@{ub}
        Success -- nonzero if successful.  zero on failure.@{b}

   EXCEPTIONS@{ub}@{b}

   SEE ALSO@{ub}@{b}

   BUGS@{ub}

@ENDNODE
@NODE "FreeUnit" "disk.resource/FreeUnit()"
@{b}

   NAME@{ub}
       @{"FreeUnit" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 24} - deallocate the disk@{b}

   SYNOPSIS@{ub}
       @{"FreeUnit" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 24}( unitNum ), DRResource
                  D0         A6

        void @{"FreeUnit" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 24}(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        This routine deallocates one of the units of the disk.  It should
        be called when done with the disk.  Do not call it if you did
        no successfully allocate the disk (there is no protection -- you
        will probably crash the disk system).@{b}

   INPUTS@{ub}
        unitNum -- a legal unit number (zero through three)@{b}

   RESULTS@{ub}@{b}

   EXCEPTIONS@{ub}@{b}

   SEE ALSO@{ub}
        @{"FreeUnit" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 24}()@{b}

   BUGS@{ub}
        Doesn't check if you own the unit, or even if anyone owns it.

@ENDNODE
@NODE "GetUnit" "disk.resource/GetUnit()"
@{b}

   NAME@{ub}
       @{"GetUnit" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 28} - allocate the disk for a driver@{b}

   SYNOPSIS@{ub}
       lastDriver = @{"GetUnit" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 28}( unitPointer ), DRResource
       D0                     A1             A6

        @{"struct DiscResourceUnit" LINK "gg:doc/NDK/Guide/Include/resources/disk.h/File" 41} *@{"GetUnit" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 28}(@{"struct DiscResourceUnit" LINK "gg:doc/NDK/Guide/Include/resources/disk.h/File" 41} *);@{b}

   FUNCTION@{ub}
        This routine allocates the disk to a driver.  It is either
        immediately available, or the request is saved until the disk
        is available.  When it is available, your unitPointer is
        sent back to you (via @{"ReplyMsg" LINK "gg:doc/NDK/Guide/exec/ReplyMsg"}).  You may then reattempt the
        @{"GetUnit" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 28}.

        Allocating the disk allows you to use the disk's resources.
        Remember however that there are four units to the disk; you are
        only one of them.  Please be polite to the other units (by never
        selecting them, and by not leaving interrupts enabled, etc.).

        When you are done, please leave the disk in the following state:
            dmacon dma bit ON
            dsklen dma bit OFF (write a #@{"DSKDMAOFF" LINK "gg:doc/NDK/Guide/Include/resources/disk.h/File" 85} to dsklen)
            adkcon disk bits -- any way you want
            intena:disk sync and disk block interrupts -- Both DISABLED
            CIA resource index interrupt -- DISABLED
            8520 outputs -- doesn't matter, because all bits will be
                set to inactive by the resource.
            8520 data direction regs -- restore to original state.

        NOTE: @{"GetUnit" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 28}() does @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} turn on the interrupts for you.
              You must use @{"AbleICR" LINK "gg:doc/NDK/Guide/cia/AbleICR"} (for the index interrupt) or intena
              (for the diskbyte and diskblock interrupts) to turn them
              on.  You should turn them off before calling @{"GiveUnit" LINK "GiveUnit"},
              as stated above.@{b}

   INPUTS@{ub}
        unitPtr - a pointer you your disk resource unit structure.
                Note that the message filed of the structure MUST
                be a valid message, ready to be replied to.  Make sure
                ln_Name points to a null-terminated string, preferably
                one that identifies your program.

                You need to set up the three interrupt structures,
                in particular the IS_DATA and IS_CODE fields.  Set them
                to @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if you don't need that interrupt.  Also, set
                the ln_Type of the interrupt structure to @{"NT_INTERRUPT" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File" 45}.
                WARNING: don't turn on a disk resource interrupt unless
                the IS_CODE for that interrupt points to executable code!

                IS_CODE will be called with IS_DATA in A1 when the
                interrupt occurs.  Preserve all regs but D0/D1/A0/A1.
                Do not make assumptions about A0.@{b}

   RESULTS@{ub}
        lastDriver - if the disk is not busy, then the last unit
                to use the disk is returned.  This may be used to
                see if a driver needs to reset device registers.
                (If you were the last user, then no one has changed
                any of the registers.  If someone else has used it,
                then any allowable changes may have been made).  If the
                disk is busy, then a null is returned.@{b}

   EXCEPTIONS@{ub}@{b}

   SEE ALSO@{ub}
        @{"GiveUnit()" LINK "GiveUnit"}@{b}

   BUGS@{ub}

@ENDNODE
@NODE "GetUnitID" "disk.resource/GetUnitID()"
@{b}

   NAME@{ub}
       @{"GetUnitID" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 36} - find out what type of disk is out there@{b}

   SYNOPSIS@{ub}
       idtype = @{"GetUnitID" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 36}( unitNum ), DRResource
        D0                  D0         A6

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"GetUnitID" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 36}(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Gets the drive ID for a given unit.  Note that this value may
        change if someone calls @{"ReadUnitID" LINK "ReadUnitID"}, and the drive id changes.@{b}

   INPUTS@{ub}
        unitNum -- a legal unit number (zero through three)@{b}

   RESULTS@{ub}
        idtype -- the type of the disk drive.  Standard types are
                defined in the resource include file.@{b}

   EXCEPTIONS@{ub}@{b}

   SEE ALSO@{ub}
        @{"ReadUnitID()" LINK "ReadUnitID"}@{b}

   BUGS@{ub}

@ENDNODE
@NODE "GiveUnit" "disk.resource/GiveUnit()"
@{b}

   NAME@{ub}
       @{"GiveUnit" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 32} - Free the disk back up@{b}

   SYNOPSIS@{ub}
       @{"GiveUnit" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 32}(), DRResource
                    A6

        void @{"GiveUnit" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 32}();@{b}

   FUNCTION@{ub}
        This routine frees the disk after a driver is done with it.
        If others are waiting, it will notify them.@{b}

   INPUTS@{ub}@{b}

   RESULTS@{ub}@{b}

   EXCEPTIONS@{ub}@{b}

   SEE ALSO@{ub}
        @{"GetUnit()" LINK "GetUnit"}@{b}

   BUGS@{ub}
        In pre-V36, @{"GiveUnit" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 32} didn't check if you owned the unit.  A patch
        for this was part of 1.3.1 SetPatch.  Fixed in V36.

@ENDNODE
@NODE "ReadUnitID" "disk.resource/ReadUnitID()"
@{b}

   NAME@{ub}
       @{"ReadUnitID" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 40} - reread and return the type of drive (V37)@{b}

   SYNOPSIS@{ub}
       idtype = @{"ReadUnitID" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 40}( unitNum ), DRResource
        D0                     D0         A6

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"ReadUnitID" LINK "gg:doc/NDK/Guide/Include/inline/disk.h/File" 40}(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Rereads the drive id for a specific unit (for handling drives
        that change ID according to what sort of disk is in them.  You
        MUST have done a @{"GetUnit" LINK "GetUnit"} before calling this function!@{b}

   INPUTS@{ub}
        unitNum -- a legal unit number (zero through three)@{b}

   RESULTS@{ub}
        idtype -- the type of the disk drive.  Standard types are
                defined in the resource include file.@{b}

   EXCEPTIONS@{ub}@{b}

   SEE ALSO@{ub}
        @{"GetUnitID()" LINK "GetUnitID"}@{b}

   BUGS@{ub}

@ENDNODE
