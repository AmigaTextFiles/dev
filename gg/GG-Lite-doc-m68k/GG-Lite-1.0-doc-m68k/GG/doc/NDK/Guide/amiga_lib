@DATABASE "gg:doc/NDK/Guide/amiga_lib"
@MASTER   "gg:doc/NDK/AutoDocs/amiga_lib.doc"
@REMARK   This file was created by ADtoHT 2.1 on 06-Jan-13 19:18:45
@REMARK   Do not edit
@REMARK   ADtoHT is © 1993-1995 Christian Stieber

@NODE MAIN "amiga_lib.doc"
@TOC "gg:doc/NDK/Guide/TOC/MAIN"

                                  @{b}amiga.lib@{ub}

@{"ACrypt()" LINK "ACrypt"}          @{"AddTOF()" LINK "AddTOF"}          @{"afp()" LINK "afp"}            @{"ArgArrayDone()" LINK "ArgArrayDone"}
@{"ArgArrayInit()" LINK "ArgArrayInit"}    @{"ArgInt()" LINK "ArgInt"}          @{"ArgString()" LINK "ArgString"}      @{"arnd()" LINK "arnd"}
@{"BeginIO()" LINK "BeginIO"}         @{"CallHook()" LINK "CallHook"}        @{"CallHookA()" LINK "CallHookA"}      @{"CheckRexxMsg()" LINK "CheckRexxMsg"}
@{"CoerceMethod()" LINK "CoerceMethod"}    @{"CoerceMethodA()" LINK "CoerceMethodA"}   @{"CreateExtIO()" LINK "CreateExtIO"}    @{"CreatePort()" LINK "CreatePort"}
@{"CreateStdIO()" LINK "CreateStdIO"}     @{"CreateTask()" LINK "CreateTask"}      @{"CxCustom()" LINK "CxCustom"}       @{"CxDebug()" LINK "CxDebug"}
@{"CxFilter()" LINK "CxFilter"}        @{"CxSender()" LINK "CxSender"}        @{"CxSignal()" LINK "CxSignal"}       @{"CxTranslate()" LINK "CxTranslate"}
@{"dbf()" LINK "dbf"}             @{"DeleteExtIO()" LINK "DeleteExtIO"}     @{"DeletePort()" LINK "DeletePort"}     @{"DeleteStdIO()" LINK "DeleteStdIO"}
@{"DeleteTask()" LINK "DeleteTask"}      @{"DoMethod()" LINK "DoMethod"}        @{"DoMethodA()" LINK "DoMethodA"}      @{"DoSuperMethod()" LINK "DoSuperMethod"}
@{"DoSuperMethodA()" LINK "DoSuperMethodA"}  @{"FastRand()" LINK "FastRand"}        @{"fpa()" LINK "fpa"}            @{"FreeIEvents()" LINK "FreeIEvents"}
@{"GetRexxVar()" LINK "GetRexxVar"}      @{"HookEntry()" LINK "HookEntry"}       @{"HotKey()" LINK "HotKey"}         @{"Hotkey()" LINK "HotKey"}
@{"InvertString()" LINK "InvertString"}    @{"LibAllocPooled()" LINK "LibAllocPooled"}  @{"LibCreatePool()" LINK "LibCreatePool"}  @{"LibDeletePool()" LINK "LibDeletePool"}
@{"LibFreePooled()" LINK "LibFreePooled"}   @{"NewList()" LINK "NewList"}         @{"printf()" LINK "printf"}         @{"RangeRand()" LINK "RangeRand"}
@{"RemTOF()" LINK "RemTOF"}          @{"SetRexxVar()" LINK "SetRexxVar"}      @{"SetSuperAttrs()" LINK "SetSuperAttrs"}  @{"sprintf()" LINK "sprintf"}
@{"stdio()" LINK "stdio"}           @{"TimeDelay()" LINK "TimeDelay"}       

@ENDNODE
@NODE "ACrypt" "amiga.lib/ACrypt()"
@{b}

   NAME@{ub}
        ACrypt -- Encrypt a password@{b}

   SYNOPSIS@{ub}
        newpass = ACrypt( buffer, password, username )

        @{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62} *ACrypt( @{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62} *, @{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62} *, @{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62} *) ;@{b}

   FUNCTION@{ub}
        This function takes a buffer of at least 12 characters in length,
        an unencrypted password and the user's name (as known to the host
        system) and returns an encrypted password in the passed buffer.
        This is a one-way encryption. Normally, the user's encrypted
        password is stored in a file for future password comparison.@{b}

   INPUTS@{ub}
        buffer     - a pointer to a buffer at least 12 bytes in length.
        password   - a pointer to an unencrypted password string.
        username   - a pointer to the user's name.@{b}

   RESULT@{ub}
        newpass    - a pointer to the passed buffer if successful, @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
                     upon failure. The encrypted password placed in the
                     buffer will be be eleven (11) characters in length
                     and will be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}-terminated.@{b}

   EXAMPLE@{ub}

        @{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62} *pw, *getpassword() ;
        @{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62} *user = "alf"
        @{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62} *newpass ;
        @{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62} buffer[16] ;         /* size >= 12 */

        pw = getpassword() ;   /* your own function */

        if((newpass = ACrypt(buffer, pw, user)) != @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101})
        {
                @{"printf" LINK "printf"}("pw = %s\\n", newpass) ; /* newpass = &buffer[0] */
        }
        else
        {
                @{"printf" LINK "printf"}("ACrypt failed\\n") ;
        }

@ENDNODE
@NODE "AddTOF" "amiga.lib/AddTOF()"
@{b}

   NAME@{ub}
        AddTOF - add a task to the VBlank interrupt server chain.@{b}

   SYNOPSIS@{ub}
        AddTOF(i,p,a);

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} AddTOF(@{"struct Isrvstr" LINK "gg:doc/NDK/Guide/Include/graphics/graphint.h/File" 16} *, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49}, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49});@{b}

   FUNCTION@{ub}
        Adds a task to the vertical-blanking interval interrupt server
        chain. This prevents C programmers from needing to write an
        assembly language stub to do this function.@{b}

   INPUTS@{ub}
        i - pointer to an initialized Isrvstr structure
        p - pointer to the C-code routine that this server is to call each
            time TOF happens
        a - pointer to the first longword in an array of longwords that
            is to be used as the arguments passed to your routine
            pointed to by p.@{b}

   SEE ALSO@{ub}
        @{"RemTOF()" LINK "RemTOF"}, <@{"graphics/graphint.h" LINK "gg:doc/NDK/Guide/Include/graphics/graphint.h/File"}>

@ENDNODE
@NODE "afp" "amiga.lib/afp()"
@{b}

   NAME@{ub}
        afp - Convert ASCII string variable into fast floating point@{b}

   SYNOPSIS@{ub}
        ffp_value = afp(string);@{b}

    FUNCTION@{ub}
        Accepts the address of the ASCII string in C format that is
        converted into an FFP floating point number.

        The string is expected in this Format:
        {S}{digits}{'.'}{digits}{'E'}{S}{digits}
        <*******MANTISSA*******><***EXPONENT***>


        Syntax rules:
        Both signs are optional and are '+' or '-'. The mantissa must be
        present. The exponent need not be present. The mantissa may lead
        with a decimal point. The mantissa need not have a decimal point.
        Examples: All of these values represent the number fourty-two.
                     42            .042e3
                     42.          +.042e+03
                    +42.          0.000042e6
                0000042.00       420000e-4
                             420000.00e-0004

        Floating point range:
        Fast floating point supports the value zero and non-zero values
        within the following bounds -
                        18                             20
         9.22337177 x 10   > +number >  5.42101070 x 10
                        18                             -20
        -9.22337177 x 10   > -number > -2.71050535 x 10

        Precision:
        This conversion results in a 24 bit precision with guaranteed
        error less than or equal to one-half least significant bit.

        INPUTS
        string - Pointer to the ASCII string to be converted.


        OUTPUTS
        string - points to the character which terminated the scan
        equ - fast floating point equivalent

@ENDNODE
@NODE "ArgArrayDone" "amiga.lib/ArgArrayDone()"
@{b}

   NAME@{ub}
        ArgArrayDone -- release the memory allocated by a previous call
                        to @{"ArgArrayInit()" LINK "ArgArrayInit"}. (V36)@{b}

   SYNOPSIS@{ub}
        ArgArrayDone();

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} ArgArrayDone(@{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24});@{b}

   FUNCTION@{ub}
        This function frees memory and does cleanup required after a
        call to @{"ArgArrayInit()" LINK "ArgArrayInit"}. Don't call this until you are done using
        the ToolTypes argument strings.@{b}

   SEE ALSO@{ub}
        @{"ArgArrayInit()" LINK "ArgArrayInit"}

@ENDNODE
@NODE "ArgArrayInit" "amiga.lib/ArgArrayInit()"
@{b}

   NAME@{ub}
        ArgArrayInit -- allocate and initialize a tooltype array. (V36)@{b}

   SYNOPSIS@{ub}
        ttypes = ArgArrayInit(argc,argv);

        @{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62} **ArgArrayInit(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51},@{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62} **);@{b}

   FUNCTION@{ub}
        This function returns a null-terminated array of strings
        suitable for sending to @{"icon.library/FindToolType()" LINK "gg:doc/NDK/Guide/icon/FindToolType"}. This array will
        be the ToolTypes array of the program's icon, if it was started from
        Workbench. It will just be 'argv' if the program was started from
        a shell.

        Pass ArgArrayInit() your startup arguments received by main().

        ArgArrayInit() requires that @{"icon.library" LINK "gg:doc/NDK/Guide/icon/MAIN"} be open (even if the caller
        was started from a shell, so that the function @{"FindToolType()" LINK "gg:doc/NDK/Guide/icon/FindToolType"} can be
        used) and may call @{"GetDiskObject()" LINK "gg:doc/NDK/Guide/icon/GetDiskObject"}, so clean up is necessary when
        the strings are no longer needed. The function @{"ArgArrayDone()" LINK "ArgArrayDone"} does
        just that.@{b}

   INPUTS@{ub}
        argc - the number of arguments in argv, 0 when started from Workbench
        argv - an array of pointers to the program's arguments, or the
               Workbench startup message when started from WB.@{b}

   RESULTS@{ub}
        ttypes - the initialized argument array or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if it could not be
                 allocated@{b}

   EXAMPLE@{ub}
        Use of these routines facilitates the use of ToolTypes or command-
        line arguments to control end-user parameters in Commodities
        applications. For example, a filter used to trap a keystroke for
        popping up a window might be created by something like this:

                char   *ttypes  = ArgArrayInit(argc, argv);
                @{"CxObj" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 75}   *filter = UserFilter(ttypes, "POPWINDOW", "alt f1");

               ... with ...

               @{"CxObj" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 75} *UserFilter(char **tt, char *action_name,
                                  char *default_descr)
                {
                char *desc;

                    desc = @{"FindToolType" LINK "gg:doc/NDK/Guide/icon/FindToolType"}(tt,action_name);

                    return(@{"CxFilter" LINK "CxFilter"}((@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})(desc? desc: default_descr)));
                }

        In this way the user can assign "alt f2" to the action by
        entering a tooltype in the program's icon of the form:

                POPWINDOW=alt f2

        or by starting the program from the CLI like so:

                myprogram "POPWINDOW=alt f2"@{b}

   NOTE@{ub}
        Your program must open @{"icon.library" LINK "gg:doc/NDK/Guide/icon/MAIN"} and set up IconBase before calling
        this routine. In addition IconBase must remain valid until after
        @{"ArgArrayDone()" LINK "ArgArrayDone"} has been called!@{b}

   SEE ALSO@{ub}
        @{"ArgArrayDone()" LINK "ArgArrayDone"}, @{"ArgString()" LINK "ArgString"}, @{"ArgInt()" LINK "ArgInt"}, @{"icon.library/FindToolType()" LINK "gg:doc/NDK/Guide/icon/FindToolType"}

@ENDNODE
@NODE "ArgInt" "amiga.lib/ArgInt()"
@{b}

   NAME@{ub}
        ArgInt -- return an integer value from a ToolTypes array. (V36)@{b}

   SYNOPSIS@{ub}
        value = ArgInt(tt,entry,defaultval)

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} ArgInt(@{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62} **,@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        This function looks in the ToolTypes array 'tt' returned
        by @{"ArgArrayInit()" LINK "ArgArrayInit"} for 'entry' and returns the value associated
        with it. 'tt' is in standard ToolTypes format such as:

                ENTRY=Value

        The Value string is passed to atoi() and the result is returned by
        this function.

        If 'entry' is not found, the integer 'defaultval' is returned.@{b}

   INPUTS@{ub}
        tt - a ToolTypes array as returned by @{"ArgArrayInit()" LINK "ArgArrayInit"}
        entry - the entry in the ToolTypes array to search for
        defaultval - the value to return in case 'entry' is not found within
                     the ToolTypes array@{b}

   RESULTS@{ub}
        value - the value associated with 'entry', or defaultval if 'entry'
                is not in the ToolTypes array@{b}

   NOTES@{ub}
        This function requires that @{"dos.library" LINK "gg:doc/NDK/Guide/dos/MAIN"} V36 or higher be opened.@{b}

   SEE ALSO@{ub}
        @{"ArgArrayInit()" LINK "ArgArrayInit"}

@ENDNODE
@NODE "ArgString" "amiga.lib/ArgString()"
@{b}

   NAME@{ub}
        ArgString -- return a string pointer from a ToolTypes array. (V36)@{b}

   SYNOPSIS@{ub}
        string = ArgString(tt,entry,defaultstring)

        @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} ArgString(@{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62} **,@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67});@{b}

   FUNCTION@{ub}
        This function looks in the ToolTypes array 'tt' returned
        by @{"ArgArrayInit()" LINK "ArgArrayInit"} for 'entry' and returns the value associated
        with it. 'tt' is in standard ToolTypes format such as:

                ENTRY=Value

        This function returns a pointer to the Value string.

        If 'entry' is not found, 'defaultstring' is returned.@{b}

   INPUTS@{ub}
        tt - a ToolTypes array as returned by @{"ArgArrayInit()" LINK "ArgArrayInit"}
        entry - the entry in the ToolTypes array to search for
        defaultstring - the value to return in case 'entry' is not found within
                        the ToolTypes array@{b}

   RESULTS@{ub}
        value - the value associated with 'entry', or defaultstring if 'entry'
                is not in the ToolTypes array@{b}

   SEE ALSO@{ub}
        @{"ArgArrayInit()" LINK "ArgArrayInit"}

@ENDNODE
@NODE "arnd" "amiga.lib/arnd()"
@{b}

  NAME@{ub}
        arnd - ASCII round of the provided floating point string@{b}

   SYNOPSIS@{ub}
        arnd(place, exp, &string[0]);@{b}

   FUNCTION@{ub}
        Accepts an ASCII string representing an FFP floating point
        number, the binary representation of the exponent of said
        floating point number and the number of places to round to.
        A rounding process is initiated, either to the left or right
        of the decimal place and the result placed back at the
        input address defined by &string[0].@{b}

   INPUTS@{ub}
        place - integer representing number of decimal places to round to
        exp - integer representing exponent value of the ASCII string
        &string[0] - address where rounded ASCII string is to be placed
                     (16 bytes)@{b}

   RESULT@{ub}
        &string[0] - rounded ASCII string@{b}

   BUGS@{ub}
        None

@ENDNODE
@NODE "BeginIO" "amiga.lib/BeginIO()"
@{b}

   NAME@{ub}
        @{"BeginIO" LINK "gg:doc/NDK/Guide/audio/BeginIO"} -- initiate asynchronous device I/O@{b}

   SYNOPSIS@{ub}
        @{"BeginIO" LINK "gg:doc/NDK/Guide/audio/BeginIO"}(ioReq)

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"BeginIO" LINK "gg:doc/NDK/Guide/audio/BeginIO"}(@{"struct IORequest" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 18} *);@{b}

   FUNCTION@{ub}
        This function takes an IORequest, and passes it directly to the
        "@{"BeginIO" LINK "gg:doc/NDK/Guide/audio/BeginIO"}" vector of the proper device.  This is equivalent to
        @{"SendIO()" LINK "gg:doc/NDK/Guide/exec/SendIO"}, except that io_Flags is not cleared. A good understanding
        of Exec device I/O is required to properly use this function.

        This function does not wait for the I/O to complete.@{b}

   INPUTS@{ub}
        ioReq - an initialized and opened IORequest structure with the
                io_Flags field set to a reasonable value (set to 0 if you do
                not require io_Flags).@{b}

   SEE ALSO@{ub}
        @{"exec.library/DoIO()" LINK "gg:doc/NDK/Guide/exec/DoIO"}, @{"exec.library/SendIO()" LINK "gg:doc/NDK/Guide/exec/SendIO"}, @{"exec.library/WaitIO()" LINK "gg:doc/NDK/Guide/exec/WaitIO"}

@ENDNODE
@NODE "CallHook" "amiga.lib/CallHook()"
@{b}

   NAME@{ub}
        CallHook -- Invoke a hook given a message on the stack.@{b}

   SYNOPSIS@{ub}
        result = CallHook( hookPtr, obj, ... )

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} CallHook( @{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *, Object *, ... );@{b}

   FUNCTION@{ub}
        Like @{"CallHookA()" LINK "CallHookA"}, CallHook() invoke a hook on the supplied
        hook-specific data (an "object") and a parameter packet ("message").
        However, CallHook() allows you to build the message on your stack.@{b}

   INPUTS@{ub}
        hookPtr - A system-standard hook
        obj - hook-specific data object
        ... - The hook-specific message you wish to send.  The hook is
            expecting a pointer to the message, so a pointer into your
            stack will be sent.@{b}

   RESULT@{ub}
        result - a hook-specific result.@{b}

   NOTES@{ub}
        This function first appeared in the V37 release of amiga.lib.
        However, it does not depend on any particular version of the OS,
        and works fine even in V34.@{b}

   EXAMPLE@{ub}
        If your hook's message was

            struct myMessage
            {
                @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} mm_FirstGuy;
                @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} mm_SecondGuy;
                @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} mm_ThirdGuy;
            };

        You could write:

            result = CallHook( hook, obj, firstguy, secondguy, thirdguy );

        as a shorthand for:

            struct myMessage msg;

            msg.mm_FirstGuy = firstguy;
            msg.mm_SecondGuy = secondguy;
            msg.mm_ThirdGuy = thirdguy;

            result = @{"CallHookA" LINK "CallHookA"}( hook, obj, &msg );@{b}

   SEE ALSO@{ub}
        @{"CallHookA()" LINK "CallHookA"}, @{"utility.library/CallHookPkt()" LINK "gg:doc/NDK/Guide/utility/CallHookPkt"}, <@{"utility/hooks.h" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File"}>

@ENDNODE
@NODE "CallHookA" "amiga.lib/CallHookA()"
@{b}

   NAME@{ub}
        CallHookA -- Invoke a hook given a pointer to a message.@{b}

   SYNOPSIS@{ub}
        result = CallHookA( hookPtr, obj, message )

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"CallHook" LINK "CallHook"}( @{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *, Object *, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} );@{b}

   FUNCTION@{ub}
        Invoke a hook on the supplied hook-specific data (an "object")
        and a parameter packet ("message").  This function is equivalent
        to @{"utility.library/CallHookPkt()" LINK "gg:doc/NDK/Guide/utility/CallHookPkt"}.@{b}

   INPUTS@{ub}
        hookPtr - A system-standard hook
        obj - hook-specific data object
        message - The hook-specific message you wish to send@{b}

   RESULT@{ub}
        result - a hook-specific result.@{b}

   NOTES@{ub}
        This function first appeared in the V37 release of amiga.lib.
        However, it does not depend on any particular version of the OS,
        and works fine even in V34.@{b}

   SEE ALSO@{ub}
        @{"CallHook()" LINK "CallHook"}, @{"utility.library/CallHookPkt()" LINK "gg:doc/NDK/Guide/utility/CallHookPkt"}, <@{"utility/hooks.h" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File"}>

@ENDNODE
@NODE "CheckRexxMsg" "amiga.lib/CheckRexxMsg()"
@{b}

   NAME@{ub}
        CheckRexxMsg - Check if a RexxMsg is from ARexx@{b}

   SYNOPSIS@{ub}
        result = CheckRexxMsg(message)
        D0                    A0

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} CheckRexxMsg(@{"struct RexxMsg" LINK "gg:doc/NDK/Guide/Include/rexx/storage.h/File" 98} *);@{b}

   FUNCTION@{ub}
        This function checks to make sure that the message is from ARexx
        directly.  It is required when using the Rexx Variable Interface
        routines (RVI) that the message be from ARexx.

        While this function is new in the V37 amiga.lib, it is safe to
        call it in all versions of the operating system.  It is also
        PURE code, thus usable in resident/pure executables.@{b}

   NOTE@{ub}
        This is a stub in amiga.lib.  It is only available via amiga.lib.
        The stub has two labels.  One, _CheckRexxMsg, takes the arguments
        from the stack.  The other, CheckRexxMsg, takes the arguments in
        registers.@{b}

   EXAMPLE@{ub}
        if (CheckRexxMsg(rxmsg))
        {
                /* Message is one from ARexx */
        }@{b}

   INPUTS@{ub}
        message         A pointer to the RexxMsg in question@{b}

   RESULTS@{ub}
        result          A boolean - @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if message is from ARexx.@{b}

   SEE ALSO@{ub}
        @{"GetRexxVar()" LINK "GetRexxVar"}, @{"SetRexxVar()" LINK "SetRexxVar"}

@ENDNODE
@NODE "CoerceMethod" "amiga.lib/CoerceMethod()"
@{b}

   NAME@{ub}
        CoerceMethod -- Perform method on coerced object.@{b}

   SYNOPSIS@{ub}
        result = CoerceMethod( cl, obj, MethodID, ... )

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} CoerceMethod( @{"struct IClass" LINK "gg:doc/NDK/Guide/Include/intuition/classes.h/File" 36} *, Object *, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, ... );@{b}

   FUNCTION@{ub}
        Boopsi support function that invokes the supplied message
        on the specified object, as though it were the specified
        class.  Equivalent to @{"CoerceMethodA()" LINK "CoerceMethodA"}, but allows you to
        build the message on the stack.@{b}

   INPUTS@{ub}
        cl - pointer to boopsi class to receive the message
        obj - pointer to boopsi object
        ... - method-specific message built on the stack@{b}

   RESULT@{ub}
        result - class and message-specific result.@{b}

   NOTES@{ub}
        This function first appears in the V37 release of amiga.lib.
        While it intrinsically does not require any particular release
        of the system software to operate, it is designed to work with
        the boopsi subsystem of Intuition, which was only introduced
        in V36.@{b}

   SEE ALSO@{ub}
        @{"CoerceMethodA()" LINK "CoerceMethodA"}, @{"DoMethodA()" LINK "DoMethodA"}, @{"DoSuperMethodA()" LINK "DoSuperMethodA"}, <@{"intuition/classusr.h" LINK "gg:doc/NDK/Guide/Include/intuition/classusr.h/File"}>
        ROM Kernel Manual boopsi section

@ENDNODE
@NODE "CoerceMethodA" "amiga.lib/CoerceMethodA()"
@{b}

   NAME@{ub}
        CoerceMethodA -- Perform method on coerced object.@{b}

   SYNOPSIS@{ub}
        result = CoerceMethodA( cl, obj, msg )

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} CoerceMethodA( @{"struct IClass" LINK "gg:doc/NDK/Guide/Include/intuition/classes.h/File" 36} *, Object *, Msg );@{b}

   FUNCTION@{ub}
        Boopsi support function that invokes the supplied message
        on the specified object, as though it were the specified
        class.@{b}

   INPUTS@{ub}
        cl - pointer to boopsi class to receive the message
        obj - pointer to boopsi object
        msg - pointer to method-specific message to send@{b}

   RESULT@{ub}
        result - class and message-specific result.@{b}

   NOTES@{ub}
        This function first appears in the V37 release of amiga.lib.
        While it intrinsically does not require any particular release
        of the system software to operate, it is designed to work with
        the boopsi subsystem of Intuition, which was only introduced
        in V36.
        Some early example code may refer to this function as CM().@{b}

   SEE ALSO@{ub}
        @{"CoerceMethod()" LINK "CoerceMethod"}, @{"DoMethodA()" LINK "DoMethodA"}, @{"DoSuperMethodA()" LINK "DoSuperMethodA"}, <@{"intuition/classusr.h" LINK "gg:doc/NDK/Guide/Include/intuition/classusr.h/File"}>
        ROM Kernel Manual boopsi section

@ENDNODE
@NODE "CreateExtIO" "amiga.lib/CreateExtIO()"
@{b}

   NAME@{ub}
        CreateExtIO -- create an IORequest structure@{b}

   SYNOPSIS@{ub}
        ioReq = CreateExtIO(port,ioSize);

        @{"struct IORequest" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 18} *CreateExtIO(@{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        Allocates memory for and initializes a new IO request block
        of a user-specified number of bytes. The number of bytes
        MUST be the size of a legal IORequest (or extended IORequest)
        or very nasty things will happen.@{b}

   INPUTS@{ub}
        port - an already initialized message port to be used for this IO
               request's reply port. If this is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} this function fails.
        ioSize - the size of the IO request to be created.@{b}

   RESULT@{ub}
        ioReq - a new IO Request block, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if there was not enough memory@{b}

   EXAMPLE@{ub}
        if (ioReq = CreateExtIO(@{"CreatePort" LINK "CreatePort"}(@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101},0),sizeof(@{"struct IOExtTD" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File" 117})))@{b}

   SEE ALSO@{ub}
        @{"DeleteExtIO()" LINK "DeleteExtIO"}, @{"CreatePort()" LINK "CreatePort"}, @{"exec.library/CreateMsgPort()" LINK "gg:doc/NDK/Guide/exec/CreateMsgPort"}

@ENDNODE
@NODE "CreatePort" "amiga.lib/CreatePort()"
@{b}

   NAME@{ub}
        CreatePort - Allocate and initialize a new message port@{b}

   SYNOPSIS@{ub}
        port = CreatePort(name,pri)

        @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *CreatePort(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        Allocates and initializes a new message port. The message list
        of the new port will be prepared for use (via @{"NewList" LINK "NewList"}).  A signal
        bit will be allocated, and the port will be set to signal your
        task when a message arrives (@{"PA_SIGNAL" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 40}).

        You *must* use @{"DeletePort()" LINK "DeletePort"} to delete ports created with
        CreatePort()!@{b}

   INPUTS@{ub}
        name - public name of the port, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if the port is not named.
               The name string is not copied. Most ports do not need names,
               see notes below on this.
        pri  - Priority used for insertion into the public port list,
               normally 0.@{b}

   RESULT@{ub}
        port - a new MsgPort structure ready for use, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if the port
               could not be created due to not enough memory or no available
               signal bit.@{b}

   NOTE@{ub}
        In most cases, ports should not be named. Named ports are used for
        rendez-vous between tasks. Everytime a named port needs to be located,
        the list of all named ports must be traversed. The more named
        ports there are, the longer this list traversal takes. Thus, unless
        you really need to, do not name your ports, which will keep them off
        of the named port list and improve system performance.@{b}

   BUGS@{ub}
        With versions of amiga.lib prior to V37.14, this function would
        not fail even though it couldn't allocate a signal bit. The port
        would be returned with no signal allocated.@{b}

   SEE ALSO@{ub}
        @{"DeletePort()" LINK "DeletePort"}, @{"exec.library/FindPort()" LINK "gg:doc/NDK/Guide/exec/FindPort"}, <@{"exec/ports.h" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File"}>,
        @{"exec.library/CreateMsgPort()" LINK "gg:doc/NDK/Guide/exec/CreateMsgPort"}

@ENDNODE
@NODE "CreateStdIO" "amiga.lib/CreateStdIO()"
@{b}

   NAME@{ub}
        CreateStdIO -- create an IOStdReq structure@{b}

   SYNOPSIS@{ub}
        ioReq = CreateStdIO(port);

        @{"struct IOStdReq" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 27} *CreateStdIO(@{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *)@{b}

   FUNCTION@{ub}
        Allocates memory for and initializes a new IOStdReq structure.@{b}

   INPUTS@{ub}
        port - an already initialized message port to be used for this IO
               request's reply port. If this is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} this function fails.@{b}

   RESULT@{ub}
        ioReq - a new IOStdReq structure, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if there was not enough
                memory@{b}

   SEE ALSO@{ub}
        @{"DeleteStdIO()" LINK "DeleteStdIO"}, @{"CreateExtIO()" LINK "CreateExtIO"}, @{"exec.library/CreateIORequest()" LINK "gg:doc/NDK/Guide/exec/CreateIORequest"}

@ENDNODE
@NODE "CreateTask" "amiga.lib/CreateTask()"
@{b}

   NAME@{ub}
        CreateTask -- Create task with given name, priority, stacksize@{b}

   SYNOPSIS@{ub}
        task = CreateTask(name,pri,initPC,stackSize)

        @{"struct Task" LINK "gg:doc/NDK/Guide/Include/exec/tasks.h/File" 24} *CreateTask(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51},funcEntry,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This function simplifies program creation of sub-tasks by
        dynamically allocating and initializing required structures
        and stack space, and adding the task to Exec's task list
        with the given name and priority. A tc_MemEntry list is provided
        so that all stack and structure memory allocated by CreateTask()
        is automatically deallocated when the task is removed.

        An Exec task may not call @{"dos.library" LINK "gg:doc/NDK/Guide/dos/MAIN"} functions or any function
        which might cause the loading of a disk-resident library, device,
        or file (since such functions are indirectly calls to @{"dos.library" LINK "gg:doc/NDK/Guide/dos/MAIN"}).
        Only AmigaDOS Processes may call AmigaDOS; see the
        @{"dos.library/CreateProc()" LINK "gg:doc/NDK/Guide/dos/CreateProc"} or the @{"dos.library/CreateNewProc()" LINK "gg:doc/NDK/Guide/dos/CreateNewProc"}
        functions for more information.

        If other tasks or processes will need to find this task by name,
        provide a complex and unique name to avoid conflicts.

        If your compiler provides automatic insertion of stack-checking
        code, you may need to disable this feature when compiling sub-task
        code since the stack for the subtask is at a dynamically allocated
        location.  If your compiler requires 68000 registers to contain
        particular values for base relative addressing, you may need to
        save these registers from your main process, and restore them
        in your initial subtask code.

        The function entry initPC is generally provided as follows:

        In C:
        extern void functionName();
        char *tname = "unique name";
        task = CreateTask(tname, 0L, functionName, 4000L);

        In assembler:
                PEA     startLabel@{b}

   INPUTS@{ub}
        name - a null-terminated name string
        pri - an Exec task priority between -128 and 127, normally 0
        funcEntry - the address of the first executable instruction
                    of the subtask code
        stackSize - size in bytes of stack for the subtask. Don't cut it
                    too close - system function stack usage may change.@{b}

   RESULT@{ub}
        task - a pointer to the newly created task, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if there was not
               enough memory.@{b}

   BUGS@{ub}
        Under @{"exec.library" LINK "gg:doc/NDK/Guide/exec/MAIN"} V37 or beyond, the @{"AddTask()" LINK "gg:doc/NDK/Guide/exec/AddTask"} function used
        internally by CreateTask() can fail whereas it couldn't fail in
        previous versions of Exec. Prior to amiga.lib V37.14, this function
        did not check for failure of @{"AddTask()" LINK "gg:doc/NDK/Guide/exec/AddTask"} and thus might return a
        pointer to a task structure even though the task was not actually
        added to the system.

        Prior to amiga.lib V40.20 low memory conditions could cause
        CreateTask() to malfunction. The implementation checked whether the
        initial @{"AllocEntry()" LINK "gg:doc/NDK/Guide/exec/AllocEntry"} call would fail, but would use an inappropriate
        test condition.@{b}

   SEE ALSO@{ub}
        @{"DeleteTask()" LINK "DeleteTask"}, exec/@{"FindTask()" LINK "gg:doc/NDK/Guide/exec/FindTask"}

@ENDNODE
@NODE "CxCustom" "amiga.lib/CxCustom()"
@{b}

   NAME@{ub}
        @{"CxCustom" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 34} -- create a custom commodity object. (V36)@{b}

   SYNOPSIS@{ub}
        customObj = @{"CxCustom" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 34}(action,id);

        @{"CxObj" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 75} *@{"CxCustom" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 34}(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}(*)(),@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        This function creates a custom commodity object. The action
        of this object on receiving a commodity message is to call a
        function of the application programmer's choice.

        The function provided ('action') will be passed a pointer to
        the actual commodities message (in commodities private data
        space), and will actually execute as part of the input handler
        system task. Among other things, the value of 'id' can be
        recovered from the message by using the function @{"CxMsgID()" LINK "gg:doc/NDK/Guide/commodities/CxMsgID"}.

        The purpose of this function is two-fold. First, it allows
        programmers to create Commodities Exchange objects with
        functionality that was not imagined or chosen for inclusion
        by the designers. Secondly, this is the only way to act
        synchronously with Commodities.

        This function is a C-language macro for @{"CreateCxObj()" LINK "gg:doc/NDK/Guide/commodities/CreateCxObj"}, defined
        in <@{"libraries/commodities.h" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File"}>.@{b}

   INPUTS@{ub}
        action - a function to call whenever a message reaches the object
        id - a message id to assign to the object@{b}

   RESULTS@{ub}
        customObj - a pointer to the new custom object, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if it could
                    not be created.@{b}

  SEE ALSO@{ub}
        @{"commodities.library/CreateCxObj()" LINK "gg:doc/NDK/Guide/commodities/CreateCxObj"}, @{"commodities.library/CxMsgID()" LINK "gg:doc/NDK/Guide/commodities/CxMsgID"}

@ENDNODE
@NODE "CxDebug" "amiga.lib/CxDebug()"
@{b}

   NAME@{ub}
        @{"CxDebug" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 33} -- create a commodity debug object. (V36)@{b}

   SYNOPSIS@{ub}
        debugObj = @{"CxDebug" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 33}(id);

        @{"CxObj" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 75} *@{"CxDebug" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 33}(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        This function creates a Commodities debug object. The action of this
        object on receiving a Commodities message is to print out information
        about the Commodities message through the serial port (using the
        kprintf() routine). The value of 'id' will also be displayed.

        Note that this is a synchronous occurrence (the printing is done by
        the input device task). If screen or file output is desired, using a
        sender object instead of a debug object is necessary, since such
        output is best done by your application process.

        This function is a C-language macro for @{"CreateCxObj()" LINK "gg:doc/NDK/Guide/commodities/CreateCxObj"}, defined
        in <@{"libraries/commodities.h" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File"}>.@{b}

   INPUTS@{ub}
        id - the id to assign to the debug object, this value is output
             whenever the debug object sends data to the serial port.@{b}

   RESULTS@{ub}
        debugObj - a pointer to the debug object, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if it could
                   not be created.@{b}

   SEE ALSO@{ub}
        @{"commodities.library/CreateCxObj()" LINK "gg:doc/NDK/Guide/commodities/CreateCxObj"}, @{"CxSender()" LINK "CxSender"}, @{"debug.lib" LINK "gg:doc/NDK/Guide/debug_lib/MAIN"}/kprintf()

@ENDNODE
@NODE "CxFilter" "amiga.lib/CxFilter()"
@{b}

   NAME@{ub}
        @{"CxFilter" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 29} -- create a commodity filter object. (V36)@{b}

   SYNOPSIS@{ub}
        filterObj = @{"CxFilter" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 29}(description);

        @{"CxObj" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 75} *@{"CxFilter" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 29}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

   FUNCTION@{ub}
        Creates an input event filter object that matches the
        'description' string. If 'description' is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, the filter will not
        match any messages.

        A filter may be modified by the functions @{"SetFilter()" LINK "gg:doc/NDK/Guide/commodities/SetFilter"}, using
        a description string, and @{"SetFilterIX()" LINK "gg:doc/NDK/Guide/commodities/SetFilterIX"}, which takes a
        binary Input Expression as a parameter.

        This function is a C-language macro for @{"CreateCxObj()" LINK "gg:doc/NDK/Guide/commodities/CreateCxObj"}, defined
        in <@{"libraries/commodities.h" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File"}>.@{b}

   INPUTS@{ub}
        description - the description string in the same format as strings
                      expected by @{"commodities.library/SetFilter()" LINK "gg:doc/NDK/Guide/commodities/SetFilter"}@{b}

   RESULTS@{ub}
        filterObj - a pointer to the filter object, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if there
                    was not enough memory. If there is a problem in the
                    description string, the internal error code of the filter
                    object will be set to so indicate. This error code may be
                    interrogated using the function @{"CxObjError()" LINK "gg:doc/NDK/Guide/commodities/CxObjError"}.@{b}

   SEE ALSO@{ub}
        @{"commodities.library/CreateCxObj()" LINK "gg:doc/NDK/Guide/commodities/CreateCxObj"}, @{"commodities.library/SetFilter()" LINK "gg:doc/NDK/Guide/commodities/SetFilter"},
        @{"commodities.library/SetFilterIX()" LINK "gg:doc/NDK/Guide/commodities/SetFilterIX"}, @{"commodities.library/CxObjError()" LINK "gg:doc/NDK/Guide/commodities/CxObjError"}

@ENDNODE
@NODE "CxSender" "amiga.lib/CxSender()"
@{b}

   NAME@{ub}
        @{"CxSender" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 30} -- create a commodity sender object. (V36)@{b}

   SYNOPSIS@{ub}
        senderObj = @{"CxSender" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 30}(port,id)

        @{"CxObj" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 75} *@{"CxSender" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 30}(@{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *,@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        This function creates a Commodities sender object. The action
        of this object on receiving a Commodities message is to copy the
        Commodities message into a standard Exec Message, to put the value
        'id' in the message as well, and to send the message off to the
        message port 'port'.

        The value 'id' is used so that an application can monitor
        messages from several senders at a single port. It can be retrieved
        from the Exec message by using the function @{"CxMsgID()" LINK "gg:doc/NDK/Guide/commodities/CxMsgID"}. The value can
        be a simple integer ID, or a pointer to some application data
        structure.

        Note that Exec messages sent by sender objects arrive
        asynchronously at the destination port. Do not assume anything about
        the status of the Commodities message which was copied into the Exec
        message you received.

        All Exec messages sent to your ports must be replied. Messages may be
        replied after the sender object has been deleted.

        This function is a C-language macro for @{"CreateCxObj()" LINK "gg:doc/NDK/Guide/commodities/CreateCxObj"}, defined
        in <@{"libraries/commodities.h" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File"}>.@{b}

   INPUTS@{ub}
        port - the port for the sender to send messages to
        id - the id of the messages sent by the sender@{b}

   RESULTS@{ub}
        senderObj - a pointer to the sender object, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if it could
                    not be created.@{b}

   SEE ALSO@{ub}
        @{"commodities.library/CreateCxObj()" LINK "gg:doc/NDK/Guide/commodities/CreateCxObj"}, @{"commodities.library/CxMsgID()" LINK "gg:doc/NDK/Guide/commodities/CxMsgID"},
        @{"exec.library/PutMsg()" LINK "gg:doc/NDK/Guide/exec/PutMsg"}, @{"exec.library/ReplyMsg()" LINK "gg:doc/NDK/Guide/exec/ReplyMsg"}

@ENDNODE
@NODE "CxSignal" "amiga.lib/CxSignal()"
@{b}

   NAME@{ub}
        @{"CxSignal" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 31} -- create a commodity signaller object. (V36)@{b}

   SYNOPSIS@{ub}
        signalerObj = @{"CxSignal" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 31}(task,signal);

        @{"CxObj" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 75} *@{"CxSignal" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 31}(@{"struct Task" LINK "gg:doc/NDK/Guide/Include/exec/tasks.h/File" 24} *,@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        This function creates a Commodities signal object. The action
        of this object on receiving a Commodities message is to
        send the 'signal' to the 'task'. The caller is responsible
        for allocating the signal and determining the proper task ID.

        Note that 'signal' is the signal value as returned by @{"AllocSignal()" LINK "gg:doc/NDK/Guide/exec/AllocSignal"},
        not the mask made from that value.

        This function is a C-language macro for @{"CreateCxObj()" LINK "gg:doc/NDK/Guide/commodities/CreateCxObj"}, defined
        in <@{"libraries/commodities.h" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File"}>.@{b}

   INPUTS@{ub}
        task - the task for the signaller to signal
        signal - the signal bit number for the signaller to send@{b}

   RESULTS@{ub}
        signallerObj - a pointer to the signaller object, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if it could
                       not be created.@{b}

   SEE ALSO@{ub}
        @{"commodities.library/CreateCxObj()" LINK "gg:doc/NDK/Guide/commodities/CreateCxObj"}, @{"exec.library/FindTask()" LINK "gg:doc/NDK/Guide/exec/FindTask"}
        @{"exec.library/Signal()" LINK "gg:doc/NDK/Guide/exec/Signal"}, @{"exec.library/AllocSignal()" LINK "gg:doc/NDK/Guide/exec/AllocSignal"},

@ENDNODE
@NODE "CxTranslate" "amiga.lib/CxTranslate()"
@{b}

   NAME@{ub}
        @{"CxTranslate" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 32} -- create a commodity translator object. (V36)@{b}

   SYNOPSIS@{ub}
        translatorObj = @{"CxTranslate" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 32}(ie);

        @{"CxObj" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 75} *@{"CxTranslate" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 32}(@{"struct InputEvent" LINK "gg:doc/NDK/Guide/Include/devices/inputevent.h/File" 257} *);@{b}

   FUNCTION@{ub}
        This function creates a Commodities 'translator' object.
        The action of this object on receiving a Commodities message is to
        replace that message in the commodities network with a chain of
        Commodities input messages.

        There is one new Commodities input message generated for each input
        event in the linked list starting at 'ie' (and @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} terminated). The
        routing information of the new input messages is copied from the input
        message they replace.

        The linked list of input events associated with a translator object
        can be changed using the @{"SetTranslate()" LINK "gg:doc/NDK/Guide/commodities/SetTranslate"} function.

        If 'ie' is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, the null translation occurs: that is, the original
        commodities input message is disposed, and no others are created to
        take its place.

        This function is a C-language macro for @{"CreateCxObj()" LINK "gg:doc/NDK/Guide/commodities/CreateCxObj"}, defined
        in <@{"libraries/commodities.h" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File"}>.@{b}

   INPUTS@{ub}
        ie - the input event list used as replacement by the translator@{b}

   RESULTS@{ub}
        translatorObj - a pointer to the translator object, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if it could
                        not be created.@{b}

   SEE ALSO@{ub}
        @{"commodities.library/CreateCxObj()" LINK "gg:doc/NDK/Guide/commodities/CreateCxObj"}, @{"commodities.library/SetTranslate()" LINK "gg:doc/NDK/Guide/commodities/SetTranslate"}

@ENDNODE
@NODE "dbf" "amiga.lib/dbf()"
@{b}

   NAME@{ub}
        dbf - convert FFP dual-binary number to FFP format@{b}

   SYNOPSIS@{ub}
        fnum = dbf(exp, mant);@{b}

   FUNCTION@{ub}
        Accepts a dual-binary format (described below) floating point
        number and converts it to an FFP format floating point number.
        The dual-binary format is defined as:

                exp bit  16     = sign (0=>positive, 1=>negative)
                exp bits 15-0   = binary integer representing the base
                                          ten (10) exponent
                man             = binary integer mantissa@{b}

   INPUTS@{ub}
        exp - binary integer representing sign and exponent
        mant - binary integer representing the mantissa@{b}

   RESULT@{ub}
        fnum - converted FFP floating point format number@{b}

   BUGS@{ub}
        None

@ENDNODE
@NODE "DeleteExtIO" "amiga.lib/DeleteExtIO()"
@{b}

   NAME@{ub}
        DeleteExtIO - return memory allocated for extended IO request@{b}

   SYNOPSIS@{ub}
        DeleteExtIO(ioReq);

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} DeleteExtIO(@{"struct IORequest" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 18} *);@{b}

   FUNCTION@{ub}
        Frees up an IO request as allocated by @{"CreateExtIO()" LINK "CreateExtIO"}.@{b}

   INPUTS@{ub}
        ioReq - the IORequest block to be freed, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"CreateExtIO()" LINK "CreateExtIO"}

@ENDNODE
@NODE "DeletePort" "amiga.lib/DeletePort()"
@{b}

   NAME@{ub}
        DeletePort - free a message port created by @{"CreatePort()" LINK "CreatePort"}@{b}

   SYNOPSIS@{ub}
        DeletePort(port)

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} DeletePort(@{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *);@{b}

   FUNCTION@{ub}
        Frees a message port created by @{"CreatePort" LINK "CreatePort"}. All messages that
        may have been attached to this port must have already been
        replied before this function is called.@{b}

   INPUTS@{ub}
        port - message port to delete@{b}

   SEE ALSO@{ub}
        @{"CreatePort()" LINK "CreatePort"}

@ENDNODE
@NODE "DeleteStdIO" "amiga.lib/DeleteStdIO()"
@{b}

   NAME@{ub}
        DeleteStdIO - return memory allocated for IOStdReq@{b}

   SYNOPSIS@{ub}
        DeleteStdIO(ioReq);

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} DeleteStdIO(@{"struct IOStdReq" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File" 27} *);@{b}

   FUNCTION@{ub}
        Frees up an IOStdReq as allocated by @{"CreateStdIO()" LINK "CreateStdIO"}.@{b}

   INPUTS@{ub}
        ioReq - the IORequest block to be freed, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"CreateStdIO()" LINK "CreateStdIO"}, @{"DeleteExtIO()" LINK "DeleteExtIO"}, @{"exec.library/CreateIORequest()" LINK "gg:doc/NDK/Guide/exec/CreateIORequest"}

@ENDNODE
@NODE "DeleteTask" "amiga.lib/DeleteTask()"
@{b}

   NAME@{ub}
        DeleteTask -- delete a task created with @{"CreateTask()" LINK "CreateTask"}@{b}

   SYNOPSIS@{ub}
        DeleteTask(task)

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} DeleteTask(@{"struct Task" LINK "gg:doc/NDK/Guide/Include/exec/tasks.h/File" 24} *);@{b}

   FUNCTION@{ub}
        This function simply calls @{"exec.library/RemTask()" LINK "gg:doc/NDK/Guide/exec/RemTask"}, deleting a task
        from the Exec task lists and automatically freeing any stack and
        structure memory allocated for it by @{"CreateTask()" LINK "CreateTask"}.

        Before deleting a task, you must first make sure that the task is
        not currently executing any system code which might try to signal
        the task after it is gone.

        This can be accomplished by stopping all sources that might reference
        the doomed task, then causing the subtask to execute a @{"Wait" LINK "gg:doc/NDK/Guide/exec/Wait"}(0L).
        Another option is to have the task call DeleteTask()/@{"RemTask()" LINK "gg:doc/NDK/Guide/exec/RemTask"} on
        itself.@{b}

   INPUTS@{ub}
        task - task to remove from the system@{b}

   NOTE@{ub}
        This function simply calls @{"exec.library/RemTask()" LINK "gg:doc/NDK/Guide/exec/RemTask"}, so you can call
        @{"RemTask()" LINK "gg:doc/NDK/Guide/exec/RemTask"} directly instead of calling this function.@{b}

   SEE ALSO@{ub}
        @{"CreateTask()" LINK "CreateTask"}, @{"exec.library/RemTask()" LINK "gg:doc/NDK/Guide/exec/RemTask"}

@ENDNODE
@NODE "DoMethod" "amiga.lib/DoMethod()"
@{b}

   NAME@{ub}
        DoMethod -- Perform method on object.@{b}

   SYNOPSIS@{ub}
        result = DoMethod( obj, MethodID, ... )

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} DoMethod( Object *, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, ... );@{b}

   FUNCTION@{ub}
        Boopsi support function that invokes the supplied message
        on the specified object.  The message is invoked on the
        object's true class.  Equivalent to @{"DoMethodA()" LINK "DoMethodA"}, but allows
        you to build the message on the stack.@{b}

   INPUTS@{ub}
        obj - pointer to boopsi object
        MethodID - which method to send (see <@{"intuition/classusr.h" LINK "gg:doc/NDK/Guide/Include/intuition/classusr.h/File"}>)
        ... - method-specific message built on the stack@{b}

   RESULT@{ub}
        result - specific to the message and the object's class.@{b}

   NOTES@{ub}
        This function first appears in the V37 release of amiga.lib.
        While it intrinsically does not require any particular release
        of the system software to operate, it is designed to work with
        the boopsi subsystem of Intuition, which was only introduced
        in V36.@{b}

   SEE ALSO@{ub}
        @{"DoMethodA()" LINK "DoMethodA"}, @{"CoerceMethodA()" LINK "CoerceMethodA"}, @{"DoSuperMethodA()" LINK "DoSuperMethodA"}, <@{"intuition/classusr.h" LINK "gg:doc/NDK/Guide/Include/intuition/classusr.h/File"}>
        ROM Kernel Manual boopsi section

@ENDNODE
@NODE "DoMethodA" "amiga.lib/DoMethodA()"
@{b}

   NAME@{ub}
        DoMethodA -- Perform method on object.@{b}

   SYNOPSIS@{ub}
        result = DoMethodA( obj, msg )

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} DoMethodA( Object *, Msg );@{b}

   FUNCTION@{ub}
        Boopsi support function that invokes the supplied message
        on the specified object.  The message is invoked on the
        object's true class.@{b}

   INPUTS@{ub}
        obj - pointer to boopsi object
        msg - pointer to method-specific message to send@{b}

   RESULT@{ub}
        result - specific to the message and the object's class.@{b}

   NOTES@{ub}
        This function first appears in the V37 release of amiga.lib.
        While it intrinsically does not require any particular release
        of the system software to operate, it is designed to work with
        the boopsi subsystem of Intuition, which was only introduced
        in V36.
        Some early example code may refer to this function as DM().@{b}

   SEE ALSO@{ub}
        @{"DoMethod()" LINK "DoMethod"}, @{"CoerceMethodA()" LINK "CoerceMethodA"}, @{"DoSuperMethodA()" LINK "DoSuperMethodA"}, <@{"intuition/classusr.h" LINK "gg:doc/NDK/Guide/Include/intuition/classusr.h/File"}>
        ROM Kernel Manual boopsi section

@ENDNODE
@NODE "DoSuperMethod" "amiga.lib/DoSuperMethod()"
@{b}

   NAME@{ub}
        DoSuperMethod -- Perform method on object coerced to superclass.@{b}

   SYNOPSIS@{ub}
        result = DoSuperMethod( cl, obj, MethodID, ... )

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} DoSuperMethod( @{"struct IClass" LINK "gg:doc/NDK/Guide/Include/intuition/classes.h/File" 36} *, Object *, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, ... );@{b}

   FUNCTION@{ub}
        Boopsi support function that invokes the supplied message
        on the specified object, as though it were the superclass
        of the specified class.  Equivalent to @{"DoSuperMethodA()" LINK "DoSuperMethodA"},
        but allows you to build the message on the stack.@{b}

   INPUTS@{ub}
        cl - pointer to boopsi class whose superclass is to
            receive the message
        obj - pointer to boopsi object
        ... - method-specific message built on the stack@{b}

   RESULT@{ub}
        result - class and message-specific result.@{b}

   NOTES@{ub}
        This function first appears in the V37 release of amiga.lib.
        While it intrinsically does not require any particular release
        of the system software to operate, it is designed to work with
        the boopsi subsystem of Intuition, which was only introduced
        in V36.@{b}

   SEE ALSO@{ub}
        @{"CoerceMethodA()" LINK "CoerceMethodA"}, @{"DoMethodA()" LINK "DoMethodA"}, @{"DoSuperMethodA()" LINK "DoSuperMethodA"}, <@{"intuition/classusr.h" LINK "gg:doc/NDK/Guide/Include/intuition/classusr.h/File"}>
        ROM Kernel Manual boopsi section

@ENDNODE
@NODE "DoSuperMethodA" "amiga.lib/DoSuperMethodA()"
@{b}

   NAME@{ub}
        DoSuperMethodA -- Perform method on object coerced to superclass.@{b}

   SYNOPSIS@{ub}
        result = DoSuperMethodA( cl, obj, msg )

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} DoSuperMethodA( @{"struct IClass" LINK "gg:doc/NDK/Guide/Include/intuition/classes.h/File" 36} *, Object *, Msg );@{b}

   FUNCTION@{ub}
        Boopsi support function that invokes the supplied message
        on the specified object, as though it were the superclass
        of the specified class.@{b}

   INPUTS@{ub}
        cl - pointer to boopsi class whose superclass is to
            receive the message
        obj - pointer to boopsi object
        msg - pointer to method-specific message to send@{b}

   RESULT@{ub}
        result - class and message-specific result.@{b}

   NOTES@{ub}
        This function first appears in the V37 release of amiga.lib.
        While it intrinsically does not require any particular release
        of the system software to operate, it is designed to work with
        the boopsi subsystem of Intuition, which was only introduced
        in V36.
        Some early example code may refer to this function as DSM().@{b}

   SEE ALSO@{ub}
        @{"CoerceMethodA()" LINK "CoerceMethodA"}, @{"DoMethodA()" LINK "DoMethodA"}, @{"DoSuperMethod()" LINK "DoSuperMethod"}, <@{"intuition/classusr.h" LINK "gg:doc/NDK/Guide/Include/intuition/classusr.h/File"}>
        ROM Kernel Manual boopsi section

@ENDNODE
@NODE "FastRand" "amiga.lib/FastRand()"
@{b}

   NAME@{ub}
        FastRand - quickly generate a somewhat random integer@{b}

   SYNOPSIS@{ub}
        number = FastRand(seed);

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} FastRand(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        Seed value is taken from stack, shifted left one position,
        exclusive-or'ed with hex value $1D872B41 and returned.@{b}

   INPUTS@{ub}
        seed - a 32-bit integer@{b}

   RESULT@{ub}
        number - new random seed, a 32-bit value@{b}

   SEE ALSO@{ub}
        @{"RangeRand()" LINK "RangeRand"}

@ENDNODE
@NODE "fpa" "amiga.lib/fpa()"
@{b}

   NAME@{ub}
        fpa - convert fast floating point into ASCII string equivalent@{b}

   SYNOPSIS@{ub}
        exp = fpa(fnum, &string[0]);@{b}

   FUNCTION@{ub}
        Accepts an FFP number and the address of the ASCII string where it's
        converted output is to be stored.  The number is converted to a @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
        terminated ASCII string in and stored at the address provided.
        Additionally, the base ten (10) exponent in binary form is returned.@{b}

   INPUTS@{ub}
        fnum       - Motorola Fast Floating Point number
        &string[0] - address for output of converted ASCII character string
                     (16 bytes)@{b}

   RESULT@{ub}
        &string[0] - converted ASCII character string
        exp        - integer exponent value in binary form@{b}

   BUGS@{ub}
        None

@ENDNODE
@NODE "FreeIEvents" "amiga.lib/FreeIEvents()"
@{b}

   NAME@{ub}
        FreeIEvents -- free a chain of input events allocated by
                       @{"InvertString()" LINK "InvertString"}. (V36)@{b}

   SYNOPSIS@{ub}
        FreeIEvents(events)

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} FreeIEvents(@{"struct InputEvent" LINK "gg:doc/NDK/Guide/Include/devices/inputevent.h/File" 257} *);@{b}

   FUNCTION@{ub}
        This function frees a linked list of input events as obtained from
        @{"InvertString()" LINK "InvertString"}.@{b}

   INPUTS@{ub}
       events - the list of input events to free, may be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"InvertString()" LINK "InvertString"}

@ENDNODE
@NODE "GetRexxVar" "amiga.lib/GetRexxVar()"
@{b}

   NAME@{ub}
        GetRexxVar - Gets the value of a variable from a running ARexx program@{b}

   SYNOPSIS@{ub}
        error = GetRexxVar(message,varname,bufpointer)
        D0,A1              A0      A1      (C-only)

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} GetRexxVar(@{"struct RexxMsg" LINK "gg:doc/NDK/Guide/Include/rexx/storage.h/File" 98} *,char *,char **);@{b}

   FUNCTION@{ub}
        This function will attempt to extract the value of the symbol
        varname from the ARexx script that sent the message.  When called
        from C, a pointer to the extracted value will be placed in the
        pointer pointed to by bufpointer.  (*bufpointer will be the pointer
        to the value)

        When called from assembly, the pointer will be returned in A1.

        The value string returned *MUST* *@{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500}* be modified.

        While this function is new in the V37 amiga.lib, it is safe to
        call it in all versions of the operating system.  It is also
        PURE code, thus usable in resident/pure executables.@{b}

   NOTE@{ub}
        This is a stub in amiga.lib.  It is only available via amiga.lib.
        The stub has two labels.  One, _GetRexxVar, takes the arguments
        from the stack.  The other, GetRexxVar, takes the arguments in
        registers.

        This routine does a @{"CheckRexxMsg()" LINK "CheckRexxMsg"} on the message.@{b}

   EXAMPLE@{ub}

        char    *value;

        /* Message is one from ARexx */
        if (!GetRexxVar(rxmsg,"TheVar",&value))
        {
                /* The value was gotten and now is pointed to by value */
                @{"printf" LINK "printf"}("Value of TheVar is %s\\n",value);
        }@{b}

   INPUTS@{ub}
        message         A message gotten from an ARexx script
        varname         The name of the variable to extract
        bufpointer      (For C only) A pointer to a string pointer.@{b}

   RESULTS@{ub}
        error           0 for success, otherwise an error code.
                        (Other codes may exists, these are documented)
                        3  == Insufficient Storage
                        9  == String too long
                        10 == invalid message

        A1              (Assembly only)  Pointer to the string.@{b}

   SEE ALSO@{ub}
        @{"SetRexxVar()" LINK "SetRexxVar"}, @{"CheckRexxMsg()" LINK "CheckRexxMsg"}

@ENDNODE
@NODE "HookEntry" "amiga.lib/HookEntry()"
@{b}

   NAME@{ub}
        HookEntry -- Assembler to HLL conversion stub for hook entry.@{b}

   SYNOPSIS@{ub}
        result = HookEntry( @{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *, Object *, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} )
        D0                  A0             A2        A1@{b}

   FUNCTION@{ub}
        By definition, a standard hook entry-point must receive the
        hook in A0, the object in A2, and the message in A1.  If your
        hook entry-point is written in a high-level language and is
        expecting its parameters on the stack, then HookEntry() will
        put the three parameters on the stack and invoke the function
        stored in the hook h_SubEntry field.

        This function is only useful to hook implementers, and is
        never called from C.@{b}

   INPUTS@{ub}
        hook - pointer to hook being invoked
        object - pointer to hook-specific data
        msg - pointer to hook-specific message@{b}

   RESULT@{ub}
        result - a hook-specific result.@{b}

   NOTES@{ub}
        This function first appeared in the V37 release of amiga.lib.
        However, it does not depend on any particular version of the OS,
        and works fine even in V34.@{b}

   EXAMPLE@{ub}
        If your hook dispatcher is this:

        dispatch( @{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *hookPtr, Object *obj, @{"APTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 49} msg )
        {
            ...
        }

        Then when you initialize your hook, you would say:

        myhook.h_Entry = HookEntry;     /* amiga.lib stub */
        myhook.h_SubEntry = dispatch;   /* HLL entry */@{b}

   SEE ALSO@{ub}
        @{"CallHook()" LINK "CallHook"}, @{"CallHookA()" LINK "CallHookA"}, <@{"utility/hooks.h" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File"}>

@ENDNODE
@NODE "HotKey" "amiga.lib/HotKey()"
@{b}

   NAME@{ub}
        HotKey -- create a commodity triad. (V36)@{b}

   SYNOPSIS@{ub}
        filterObj = Hotkey(description,port,id);

        @{"CxObj" LINK "gg:doc/NDK/Guide/Include/libraries/commodities.h/File" 75} *HotKey(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *,@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        This function creates a triad of commodity objects to accomplish a
        high-level function.

        The three objects are a filter, which is created to match by the call
        @{"CxFilter" LINK "CxFilter"}(description), a sender created by the call @{"CxSender" LINK "CxSender"}(port,id),
        and a translator which is created by @{"CxTranslate" LINK "CxTranslate"}(@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}), so that it
        swallows any commodity input event messages that are passed down by
        the filter.

        This is the simple way to get a message sent to your program when the
        user performs a particular input action.

        It is strongly recommended that the ToolTypes environment be used to
        allow the user to specify the input descriptions for your application's
        hotkeys.@{b}

   INPUTS@{ub}
        description - the description string to use for the filter in the same
                      format as accepted by @{"commodities.library/SetFilter()" LINK "gg:doc/NDK/Guide/commodities/SetFilter"}
        port - port for the sender to send messages to.
        id - id of the messages sent by the sender@{b}

   RESULTS@{ub}
        filterObj - a pointer to a filter object, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if it could
                    not be created.@{b}

   SEE ALSO@{ub}
        @{"CxFilter()" LINK "CxFilter"}, @{"CxSender()" LINK "CxSender"}, @{"CxTranslate()" LINK "CxTranslate"},
        @{"commodities.library/CxObjError()" LINK "gg:doc/NDK/Guide/commodities/CxObjError"}, @{"commodities.library/SetFilter()" LINK "gg:doc/NDK/Guide/commodities/SetFilter"}

@ENDNODE
@NODE "InvertString" "amiga.lib/InvertString()"
@{b}

   NAME@{ub}
        InvertString -- produce input events that would generate the
                        given string. (V36)@{b}

   SYNOPSIS@{ub}
        events = InvertString(str,km)

        @{"struct InputEvent" LINK "gg:doc/NDK/Guide/Include/devices/inputevent.h/File" 257} *InvertString(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"struct KeyMap" LINK "gg:doc/NDK/Guide/Include/devices/keymap.h/File" 21} *);@{b}

   FUNCTION@{ub}
        This function returns a linked list of input events which would
        translate into the string using the supplied keymap (or the system
        default keymap if 'km' is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}).

        'str' is null-terminated and may contain:
           - ANSI character codes
           - backslash escaped characters:
                \\n   -   CR
                \\r   -   CR
                \\t   -   TAB
                \\0   -   illegal, do not use!
                \\\\   -   backslash
           - a text description of an input event as used by @{"ParseIX()" LINK "gg:doc/NDK/Guide/commodities/ParseIX"},
             enclosed in angle brackets.

        An example is:
          abc<alt f1>\\nhi there.@{b}

   INPUTS@{ub}
        str - null-terminated string to convert to input events
        km - keymap to use for the conversion, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} to use the default
             keymap.@{b}

   RESULTS@{ub}
        events - a chain of input events, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if there was a problem. The
                 most likely cause of failure is an illegal description
                 enclosed in angled brackets.

                 This chain should eventually be freed using @{"FreeIEvents()" LINK "FreeIEvents"}.@{b}

   SEE ALSO@{ub}
        @{"commodities.library/ParseIX()" LINK "gg:doc/NDK/Guide/commodities/ParseIX"}, @{"FreeIEvents()" LINK "FreeIEvents"}

@ENDNODE
@NODE "LibAllocPooled" "amiga.lib/LibAllocPooled()"
@{b}

    NAME@{ub}
        LibAllocPooled -- Allocate memory with the pool manager (V33)@{b}

    SYNOPSIS@{ub}
        memory=LibAllocPooled(poolHeader,memSize)
        d0                    a0         d0

        void *LibAllocPooled(void *,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

    FUNCTION@{ub}
        This function is a copy of the pool functions in V39 and up of
        EXEC.  In fact, if you are running in V39, this function will
        notice and call the EXEC function.  This function works in
        V33 and up (1.2) Amiga system.

        The C code interface is _LibAllocPooled() and takes its arguments
        from the stack just like the C code interface for @{"AllocPooled()" LINK "gg:doc/NDK/Guide/exec/AllocPooled"}
        in amiga.lib.  The assembly code interface is with the symbol
        _AsmAllocPooled: and takes the parameters in registers with the
        additional parameter of ExecBase being in a6 which can be used
        from SAS/C 6 by a prototype of:

        void * __asm AsmAllocPooled(register __a0 void *,
                                    register __d0 @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},
                                    register __a6 @{"struct ExecBase" LINK "gg:doc/NDK/Guide/Include/exec/execbase.h/File" 34} *);

        Allocate memSize bytes of memory, and return a pointer. @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} is
        returned if the allocation fails.

        Doing a @{"LibDeletePool()" LINK "LibDeletePool"} on the pool will free all of the puddles
        and thus all of the allocations done with LibAllocPooled() in that
        pool.  (No need to @{"LibFreePooled()" LINK "LibFreePooled"} each allocation)@{b}

    INPUTS@{ub}
        memSize - the number of bytes to allocate
        poolHeader - a specific private pool header.@{b}

    RESULT@{ub}
        A pointer to the memory, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.
        The memory block returned is long word aligned.@{b}

    NOTES@{ub}
        The pool function do not protect an individual pool from
        multiple accesses.  The reason is that in most cases the pools
        will be used by a single task.  If your pool is going to
        be used by more than one task you must Semaphore protect
        the pool from having more than one task trying to allocate
        within the same pool at the same time.  Warning:  @{"Forbid()" LINK "gg:doc/NDK/Guide/exec/Forbid"}
        protection *will not work* in the future.  *Do @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500}* assume
        that we will be able to make it work in the future.  LibAllocPooled()
        may well break a @{"Forbid()" LINK "gg:doc/NDK/Guide/exec/Forbid"} and as such can only be protected
        by a semaphore.

        To track sizes yourself, the following code can be used:
        *Assumes a6=ExecBase*

        ;
        ; Function to do AllocVecPooled(Pool,memSize)
        ;
        AllocVecPooled: addq.l  #4,d0           ; Get space for tracking
                        move.l  d0,-(sp)        ; Save the size
                        jsr     LibAllocPooled  ; Call pool...
                        move.l  (sp)+,d1        ; Get size back...
                        tst.l   d0              ; Check for error
                        beq.s   avp_fail        ; If @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, failed!
                        move.l  d0,a0           ; Get pointer...
                        move.l  d1,(a0)+        ; Store size
                        move.l  a0,d0           ; Get result
        avp_fail:       rts                     ; return

        ;
        ; Function to do LibFreeVecPooled(pool,memory)
        ;
        FreeVecPooled:  move.l  -(a1),d0        ; Get size / ajust pointer
                        jmp     @{"LibFreePooled" LINK "LibFreePooled"}@{b}

    SEE ALSO@{ub}
        @{"FreePooled()" LINK "gg:doc/NDK/Guide/exec/FreePooled"}, @{"CreatePool()" LINK "gg:doc/NDK/Guide/exec/CreatePool"}, @{"DeletePool()" LINK "gg:doc/NDK/Guide/exec/DeletePool"},
        @{"LibFreePooled()" LINK "LibFreePooled"}, @{"LibCreatePool()" LINK "LibCreatePool"}, @{"LibDeletePool()" LINK "LibDeletePool"}

@ENDNODE
@NODE "LibCreatePool" "amiga.lib/LibCreatePool()"
@{b}

    NAME@{ub}
        LibCreatePool -- Generate a private memory pool header (V33)@{b}

    SYNOPSIS@{ub}
        newPool=LibCreatePool(memFlags,puddleSize,threshSize)
        a0                    d0       d1         d2

        void *LibCreatePool(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

    FUNCTION@{ub}
        This function is a copy of the pool functions in V39 and up of
        EXEC.  In fact, if you are running in V39, this function will
        notice and call the EXEC function.  This function works in
        V33 and up (1.2) Amiga system.

        The C code interface is _LibCreatePool() and takes its arguments
        from the stack just like the C code interface for @{"CreatePool()" LINK "gg:doc/NDK/Guide/exec/CreatePool"}
        in amiga.lib.  The assembly code interface is with the symbol
        _AsmCreatePool: and takes the parameters in registers with the
        additional parameter of ExecBase being in a6 which can be used
        from SAS/C 6 by a prototype of:

        void * __asm AsmCreatePool(register __d0 @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},
                                   register __d1 @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},
                                   register __d2 @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},
                                   register __a6 @{"struct ExecBase" LINK "gg:doc/NDK/Guide/Include/exec/execbase.h/File" 34} *);

        Allocate and prepare a new memory pool header.  Each pool is a
        separate tracking system for memory of a specific type.  Any number
        of pools may exist in the system.

        Pools automatically expand and shrink based on demand.  Fixed sized
        "puddles" are allocated by the pool manager when more total memory
        is needed.  Many small allocations can fit in a single puddle.
        Allocations larger than the threshSize are allocation in their own
        puddles.

        At any time individual allocations may be freed.  Or, the entire
        pool may be removed in a single step.@{b}

    INPUTS@{ub}
        memFlags - a memory flags specifier, as taken by @{"AllocMem" LINK "gg:doc/NDK/Guide/exec/AllocMem"}.
        puddleSize - the size of Puddles...
        threshSize - the largest allocation that goes into normal puddles
                     This *MUST* be less than or equal to puddleSize
                     (LibCreatePool() will fail if it is not)@{b}

    RESULT@{ub}
        The address of a new pool header, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for error.@{b}

    SEE ALSO@{ub}
        @{"DeletePool()" LINK "gg:doc/NDK/Guide/exec/DeletePool"}, @{"AllocPooled()" LINK "gg:doc/NDK/Guide/exec/AllocPooled"}, @{"FreePooled()" LINK "gg:doc/NDK/Guide/exec/FreePooled"}, exec/memory.i,
        @{"LibDeletePool()" LINK "LibDeletePool"}, @{"LibAllocPooled()" LINK "LibAllocPooled"}, @{"LibFreePooled()" LINK "LibFreePooled"}

@ENDNODE
@NODE "LibDeletePool" "amiga.lib/LibDeletePool()"
@{b}

    NAME@{ub}
        LibDeletePool --  Drain an entire memory pool (V33)@{b}

    SYNOPSIS@{ub}
        LibDeletePool(poolHeader)
                      a0

        void LibDeletePool(void *);@{b}

    FUNCTION@{ub}
        This function is a copy of the pool functions in V39 and up of
        EXEC.  In fact, if you are running in V39, this function will
        notice and call the EXEC function.  This function works in
        V33 and up (1.2) Amiga system.

        The C code interface is _LibDeletePool() and takes its arguments
        from the stack just like the C code interface for @{"DeletePool()" LINK "gg:doc/NDK/Guide/exec/DeletePool"}
        in amiga.lib.  The assembly code interface is with the symbol
        _AsmDeletePool: and takes the parameters in registers with the
        additional parameter of ExecBase being in a6 which can be used
        from SAS/C 6 by a prototype of:

        void __asm AsmDeletePool(register __a0 void *,
                                 register __a6 @{"struct ExecBase" LINK "gg:doc/NDK/Guide/Include/exec/execbase.h/File" 34} *);

        Frees all memory in all puddles of the specified pool header, then
        deletes the pool header.  Individual free calls are not needed.@{b}

    INPUTS@{ub}
        poolHeader - as returned by @{"LibCreatePool()" LINK "LibCreatePool"}.@{b}

    SEE ALSO@{ub}
        @{"CreatePool()" LINK "gg:doc/NDK/Guide/exec/CreatePool"}, @{"AllocPooled()" LINK "gg:doc/NDK/Guide/exec/AllocPooled"}, @{"FreePooled()" LINK "gg:doc/NDK/Guide/exec/FreePooled"},
        @{"LibCreatePool()" LINK "LibCreatePool"}, @{"LibAllocPooled()" LINK "LibAllocPooled"}, @{"LibFreePooled()" LINK "LibFreePooled"}

@ENDNODE
@NODE "LibFreePooled" "amiga.lib/LibFreePooled()"
@{b}

    NAME@{ub}
        LibFreePooled -- Free pooled memory  (V33)@{b}

    SYNOPSIS@{ub}
        LibFreePooled(poolHeader,memory,memSize)
                      a0         a1     d0

        void LibFreePooled(void *,void *,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

    FUNCTION@{ub}
        This function is a copy of the pool functions in V39 and up of
        EXEC.  In fact, if you are running in V39, this function will
        notice and call the EXEC function.  This function works in
        V33 and up (1.2) Amiga system.

        The C code interface is _LibFreePooled() and takes its arguments
        from the stack just like the C code interface for @{"FreePooled()" LINK "gg:doc/NDK/Guide/exec/FreePooled"}
        in amiga.lib.  The assembly code interface is with the symbol
        _AsmFreePooled: and takes the parameters in registers with the
        additional parameter of ExecBase being in a6 which can be used
        from SAS/C 6 by a prototype of:

        void __asm AsmFreePooled(register __a0 void *,
                                 register __a1 void *,
                                 register __d0 @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},
                                 register __a6 @{"struct ExecBase" LINK "gg:doc/NDK/Guide/Include/exec/execbase.h/File" 34} *);

        Deallocates memory allocated by @{"LibAllocPooled()" LINK "LibAllocPooled"}.  The size of the
        allocation *MUST* match the size given to @{"LibAllocPooled()" LINK "LibAllocPooled"}.
        The reason the pool functions do not track individual allocation
        sizes is because many of the uses of pools have small allocation
        sizes and the tracking of the size would be a large overhead.

        Only memory allocated by @{"LibAllocPooled()" LINK "LibAllocPooled"} may be freed with this
        function!

        Doing a @{"LibDeletePool()" LINK "LibDeletePool"} on the pool will free all of the puddles
        and thus all of the allocations done with @{"LibAllocPooled()" LINK "LibAllocPooled"} in that
        pool.  (No need to LibFreePooled() each allocation)@{b}

    INPUTS@{ub}
        memory - pointer to memory allocated by @{"AllocPooled" LINK "gg:doc/NDK/Guide/exec/AllocPooled"}.
        poolHeader - a specific private pool header.@{b}

    NOTES@{ub}
        The pool function do not protect an individual pool from
        multiple accesses.  The reason is that in most cases the pools
        will be used by a single task.  If your pool is going to
        be used by more than one task you must Semaphore protect
        the pool from having more than one task trying to allocate
        within the same pool at the same time.  Warning:  @{"Forbid()" LINK "gg:doc/NDK/Guide/exec/Forbid"}
        protection *will not work* in the future.  *Do @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500}* assume
        that we will be able to make it work in the future.  LibFreePooled()
        may well break a @{"Forbid()" LINK "gg:doc/NDK/Guide/exec/Forbid"} and as such can only be protected
        by a semaphore.

        To track sizes yourself, the following code can be used:
        *Assumes a6=ExecBase*

        ;
        ; Function to do AllocVecPooled(Pool,memSize)
        ;
        AllocVecPooled: addq.l  #4,d0           ; Get space for tracking
                        move.l  d0,-(sp)        ; Save the size
                        jsr     @{"LibAllocPooled" LINK "LibAllocPooled"}  ; Call pool...
                        move.l  (sp)+,d1        ; Get size back...
                        tst.l   d0              ; Check for error
                        beq.s   avp_fail        ; If @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, failed!
                        move.l  d0,a0           ; Get pointer...
                        move.l  d1,(a0)+        ; Store size
                        move.l  a0,d0           ; Get result
        avp_fail:       rts                     ; return

        ;
        ; Function to do LibFreeVecPooled(pool,memory)
        ;
        FreeVecPooled:  move.l  -(a1),d0        ; Get size / ajust pointer
                        jmp     LibFreePooled@{b}

    SEE ALSO@{ub}
        @{"AllocPooled()" LINK "gg:doc/NDK/Guide/exec/AllocPooled"}, @{"CreatePool()" LINK "gg:doc/NDK/Guide/exec/CreatePool"}, @{"DeletePool()" LINK "gg:doc/NDK/Guide/exec/DeletePool"},
        @{"LibAllocPooled()" LINK "LibAllocPooled"}, @{"LibCreatePool()" LINK "LibCreatePool"}, @{"LibDeletePool()" LINK "LibDeletePool"}

@ENDNODE
@NODE "NewList" "amiga.lib/NewList()"
@{b}

   NAME@{ub}
        @{"NewList" LINK "gg:doc/NDK/Guide/Include/inline/alib.h/File" 15} -- prepare a list structure for use@{b}

   SYNOPSIS@{ub}
        @{"NewList" LINK "gg:doc/NDK/Guide/Include/inline/alib.h/File" 15}(list)

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"NewList" LINK "gg:doc/NDK/Guide/Include/inline/alib.h/File" 15}(@{"struct List" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 20} *);
        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"NewList" LINK "gg:doc/NDK/Guide/Include/inline/alib.h/File" 15}(@{"struct MinList" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File" 31} *);@{b}

   FUNCTION@{ub}
        Perform the magic needed to prepare a List header structure for
        use; the list will be empty and ready to use.  (If the list is the
        full featured type, you may need to initialize lh_Type afterwards)

        Assembly programmers may want to use the NEWLIST macro instead.@{b}

   INPUTS@{ub}
        list - pointer to a List or MinList.@{b}

   SEE ALSO@{ub}
        <@{"exec/lists.h" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File"}>

@ENDNODE
@NODE "printf" "amiga.lib/printf()"
@{b}

   NAME@{ub}
        printf - print a formatted output line to the standard output.@{b}

   SYNOPSIS@{ub}
        printf(formatstring [,value [,values] ] );@{b}

   FUNCTION@{ub}
        Format the output in accordance with specifications in the format
        string.@{b}

   INPUTS@{ub}
        formatString - a C-language-like @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}-terminated format string,
                       with the following supported % options:

          %[flags][width][.limit][length]type

            $     - must follow the arg_pos value, if specified
          flags   - only one allowed. '-' specifies left justification.
          width   - field width. If the first character is a '0', the
                    field is padded with leading 0s.
            .     - must precede the field width value, if specified
          limit   - maximum number of characters to output from a string.
                    (only valid for %s or %b).
          length  - size of input data defaults to word (16-bit) for types c,
                    d, u and x, 'l' changes this to long (32-bit).
          type    - supported types are:
                          b - @{"BSTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 131}, data is 32-bit @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} to byte count followed
                              by a byte string. A @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} is treated as an
                              empty string. (V36)
                          d - signed decimal
                          u - unsigned decimal
                          x - hexadecimal with hex digits in uppercase
                          X - hexadecimal with hex digits in lowercase
                          s - string, a 32-bit pointer to a @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}-terminated
                              byte string. A @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} pointer is treated
                              as an empty string.
                          c - character

        value(s) - numeric variables or addresses of null-terminated strings
                   to be added to the format information.@{b}

   NOTE@{ub}
        The global "_stdout" must be defined, and contain a pointer to
        a legal AmigaDOS file handle. Using the standard Amiga startup
        module sets this up. In other cases you will need to define
        stdout, and assign it to some reasonable value (like what the
        @{"dos.library/Output()" LINK "gg:doc/NDK/Guide/dos/Output"} call returns). This code would set it up:

                @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} stdout;
                stdout=@{"Output()" LINK "gg:doc/NDK/Guide/dos/Output"};@{b}

   BUGS@{ub}
        This function will crash if the resulting stream after
        parameter substitution is longer than 140 bytes.

@ENDNODE
@NODE "RangeRand" "amiga.lib/RangeRand()"
@{b}

   NAME@{ub}
        RangeRand - generate a random number within a specific integer range@{b}

   SYNOPSIS@{ub}
        number = RangeRand(maxValue);

        @{"UWORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 55} RangeRand(@{"UWORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 55});@{b}

   FUNCTION@{ub}
        RangeRand() accepts a value from 0 to 65535, and returns a value
        within that range.

        maxValue is passed on stack as a 32-bit integer but used as though
        it is only a 16-bit integer. Variable named RangeSeed is available
        beginning with V33 that contains the global seed value passed from
        call to call and thus can be changed in a program by declaring:

          extern @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} RangeSeed;@{b}

   INPUTS@{ub}
        maxValue - the returned random number will be in the range
                   [0..maxValue-1]@{b}

   RESULT@{ub}
        number - pseudo random number in the range of [0..maxValue-1].@{b}

   SEE ALSO@{ub}
        @{"FastRand()" LINK "FastRand"}

@ENDNODE
@NODE "RemTOF" "amiga.lib/RemTOF()"
@{b}

   NAME@{ub}
        RemTOF - remove a task from the VBlank interrupt server chain.@{b}

   SYNOPSIS@{ub}
        RemTOF(i);

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} RemTOF(@{"struct Isrvstr" LINK "gg:doc/NDK/Guide/Include/graphics/graphint.h/File" 16} *);@{b}

   FUNCTION@{ub}
        Removes a task from the vertical-blanking interval interrupt server
        chain.@{b}

   INPUTS@{ub}
        i - pointer to an Isrvstr structure@{b}

   SEE ALSO@{ub}
        @{"AddTOF()" LINK "AddTOF"}, <@{"graphics/graphint.h" LINK "gg:doc/NDK/Guide/Include/graphics/graphint.h/File"}>

@ENDNODE
@NODE "SetRexxVar" "amiga.lib/SetRexxVar()"
@{b}

   NAME@{ub}
        SetRexxVar - Sets the value of a variable of a running ARexx program@{b}

   SYNOPSIS@{ub}
        error = SetRexxVar(message,varname,value,length)
        D0                 A0      A1      D0    D1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} SetRexxVar(@{"struct RexxMsg" LINK "gg:doc/NDK/Guide/Include/rexx/storage.h/File" 98} *,char *,char *,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52});@{b}

   FUNCTION@{ub}
        This function will attempt to the the value of the symbol
        varname in the ARexx script that sent the message.

        While this function is new in the V37 amiga.lib, it is safe to
        call it in all versions of the operating system.  It is also
        PURE code, thus usable in resident/pure executables.@{b}

   NOTE@{ub}
        This is a stub in amiga.lib.  It is only available via amiga.lib.
        The stub has two labels.  One, _SetRexxVar, takes the arguments
        from the stack.  The other, SetRexxVar, takes the arguments in
        registers.

        This routine does a @{"CheckRexxMsg()" LINK "CheckRexxMsg"} on the message.@{b}

   EXAMPLE@{ub}

        char    *value;

        /* Message is one from ARexx */
        if (!SetRexxVar(rxmsg,"TheVar","25 Dollars",10))
        {
                /* The value of TheVar will now be "25 Dollars" */
        }@{b}

   INPUTS@{ub}
        message         A message gotten from an ARexx script
        varname         The name of the variable to set
        value           A string that will be the new value of the variable
        length          The length of the value string@{b}


   RESULTS@{ub}
        error           0 for success, otherwise an error code.
                        (Other codes may exists, these are documented)
                        3  == Insufficient Storage
                        9  == String too long
                        10 == invalid message@{b}

   SEE ALSO@{ub}
        SetRexxVar(), @{"CheckRexxMsg()" LINK "CheckRexxMsg"}

@ENDNODE
@NODE "SetSuperAttrs" "amiga.lib/SetSuperAttrs()"
@{b}

   NAME@{ub}
        SetSuperAttrs -- Invoke @{"OM_SET" LINK "gg:doc/NDK/Guide/Include/intuition/classusr.h/File" 65} method on superclass with varargs.@{b}

   SYNOPSIS@{ub}
        result = SetSuperAttrs( cl, obj, tag, ... )

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} SetSuperAttrs( @{"struct IClass" LINK "gg:doc/NDK/Guide/Include/intuition/classes.h/File" 36} *, Object *, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, ... );@{b}

   FUNCTION@{ub}
        Boopsi support function which invokes the @{"OM_SET" LINK "gg:doc/NDK/Guide/Include/intuition/classusr.h/File" 65} method on the
        superclass of the supplied class for the supplied object.  Allows
        the ops_AttrList to be supplied on the stack (i.e. in a varargs
        way).  The equivalent non-varargs function would simply be

            @{"DoSuperMethod" LINK "DoSuperMethod"}( cl, obj, @{"OM_SET" LINK "gg:doc/NDK/Guide/Include/intuition/classusr.h/File" 65}, taglist, @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} );@{b}

   INPUTS@{ub}
        cl - pointer to boopsi class whose superclass is to
            receive the @{"OM_SET" LINK "gg:doc/NDK/Guide/Include/intuition/classusr.h/File" 65} message
        obj - pointer to boopsi object
        tag - list of tag-attribute pairs, ending in @{"TAG_DONE" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 39}@{b}

   RESULT@{ub}
        result - class and message-specific result.@{b}

   NOTES@{ub}
        This function first appears in the V37 release of amiga.lib.
        While it intrinsically does not require any particular release
        of the system software to operate, it is designed to work with
        the boopsi subsystem of Intuition, which was only introduced
        in V36.@{b}

   SEE ALSO@{ub}
        @{"CoerceMethodA()" LINK "CoerceMethodA"}, @{"DoMethodA()" LINK "DoMethodA"}, @{"DoSuperMethodA()" LINK "DoSuperMethodA"}, <@{"intuition/classusr.h" LINK "gg:doc/NDK/Guide/Include/intuition/classusr.h/File"}>
        ROM Kernel Manual boopsi section

@ENDNODE
@NODE "sprintf" "amiga.lib/sprintf()"
@{b}

   NAME@{ub}
        sprintf - format a C-like string into a string buffer.@{b}

   SYNOPSIS@{ub}
        sprintf(destination formatstring [,value [, values] ] );@{b}

   FUNCTION@{ub}
        Performs string formatting identical to printf, but directs the output
        into a specific destination in memory. This uses the ROM version
        of @{"printf" LINK "printf"} (@{"exec.library/RawDoFmt()" LINK "gg:doc/NDK/Guide/exec/RawDoFmt"}), so it is very small.

        Assembly programmers can call this by placing values on the
        stack, followed by a pointer to the formatstring, followed
        by a pointer to the destination string.@{b}

   INPUTS@{ub}
        destination - the address of an area in memory into which the
                      formatted output is to be placed.
        formatstring - pointer to a null terminated string describing the
                       desired output formatting (see @{"printf()" LINK "printf"} for a
                       description of this string).
        value(s) - numeric information to be formatted into the output
                   stream.@{b}

   SEE ALSO@{ub}
         @{"printf()" LINK "printf"}, @{"exec.library/RawDoFmt()" LINK "gg:doc/NDK/Guide/exec/RawDoFmt"}

@ENDNODE
@NODE "stdio" "amiga.lib/stdio()"
@{b}

   NAMES@{ub}
        fclose  - close a file
        fgetc   - get a character from a file
        fprintf - format data to file (see @{"printf()" LINK "printf"})
        fputc   - put character to file
        fputs   - write string to file
        getchar - get a character from stdin
        printf  - put format data to stdout (see @{"exec.library/RawDoFmt" LINK "gg:doc/NDK/Guide/exec/RawDoFmt"})
        putchar - put character to stdout
        puts    - put string to stdout, followed by newline@{b}

   FUNCTION@{ub}
        These functions work much like the standard C functions of the same
        names. The file I/O functions all use non-buffered AmigaDOS
        files, and must not be mixed with the file I/O of any C
        compiler. The names of these functions match those found in many
        standard C libraries, when a name conflict occurs, the function is
        generally taken from the FIRST library that was specified on the
        linker's command line.  Thus to use these functions, specify
        the amiga.lib library first.

        To get a suitable AmigaDOS FileHandle, the @{"dos.library/Open()" LINK "gg:doc/NDK/Guide/dos/Open"} or
        @{"dos.library/Output()" LINK "gg:doc/NDK/Guide/dos/Output"} functions must be used.

        All of the functions that write to stdout expect an appropriate
        FileHandle to have been set up ahead of time. Depending on
        your C compiler and options, this may have been done by the
        startup code.  Or it can be done manually

        From C:
                extern @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} stdout;
                /* Remove the extern if startup code did not define stdout */
                stdout=@{"Output()" LINK "gg:doc/NDK/Guide/dos/Output"};

        From assembly:
                XDEF    _stdout
                DC.L    _stdout ;<- Place result of @{"dos.library/Output()" LINK "gg:doc/NDK/Guide/dos/Output"} here.

@ENDNODE
@NODE "TimeDelay" "amiga.lib/TimeDelay()"
@{b}

   NAME@{ub}
        TimeDelay -- Return after a period of time has elapsed.@{b}

   SYNOPSIS@{ub}
        Error = TimeDelay( Unit, Seconds, MicroSeconds )
        D0                 D0    D1       D2

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} TimeDelay( @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} );@{b}

   FUNCTION@{ub}
        Waits for the period of time specified before returning to the
        the caller.@{b}

   INPUTS@{ub}
        Unit -- @{"timer.device" LINK "gg:doc/NDK/Guide/timer/MAIN"} unit to open for this command.
        Seconds -- The seconds field of a timerequest is filled with
            this value. Check the documentation for what a particular
            @{"timer.device" LINK "gg:doc/NDK/Guide/timer/MAIN"} unit expects there.
        MicroSeconds -- The microseconds field of a timerequest is
            filled with this value. Check the documentation for what
            a particular @{"timer.device" LINK "gg:doc/NDK/Guide/timer/MAIN"} units expects there.@{b}

   RESULTS@{ub}
        Error -- will be zero if all went well; otherwise, non-zero.@{b}

   NOTES@{ub}
        Two likely reasons for failures are invalid unit numbers or
        no more free signal bits for this task.

        While this function first appears in V37 amiga.lib, it works
        on Kickstart V33 and higher.@{b}

   SEE ALSO@{ub}
        @{"timer.device/TR_ADDREQUEST" LINK "gg:doc/NDK/Guide/timer/TR_ADDREQUEST"},
        @{"timer.device" LINK "gg:doc/NDK/Guide/timer/MAIN"}/TR_WAITUNTIL,
        @{"timer.device" LINK "gg:doc/NDK/Guide/timer/MAIN"}/WaitUnitl()@{b}

   BUGS@{ub}

@ENDNODE
