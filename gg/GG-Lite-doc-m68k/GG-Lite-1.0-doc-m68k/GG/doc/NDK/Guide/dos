@DATABASE "gg:doc/NDK/Guide/dos"
@MASTER   "gg:doc/NDK/AutoDocs/dos.doc"
@REMARK   This file was created by ADtoHT 2.1 on 06-Jan-13 19:20:15
@REMARK   Do not edit
@REMARK   ADtoHT is © 1993-1995 Christian Stieber

@NODE MAIN "dos.doc"
@TOC "gg:doc/NDK/Guide/TOC/MAIN"

                                 @{b}dos.library@{ub}

@{"AbortPkt()" LINK "AbortPkt"}               @{"AddBuffers()" LINK "AddBuffers"}            @{"AddDosEntry()" LINK "AddDosEntry"}
@{"AddPart()" LINK "AddPart"}                @{"AddSegment()" LINK "AddSegment"}            @{"AllocDosObject()" LINK "AllocDosObject"}
@{"AllocDosObjectTagList()" LINK "AllocDosObject"}  @{"AllocDosObjectTags()" LINK "AllocDosObject"}    @{"AssignAdd()" LINK "AssignAdd"}
@{"AssignLate()" LINK "AssignLate"}             @{"AssignLock()" LINK "AssignLock"}            @{"AssignPath()" LINK "AssignPath"}
@{"AttemptLockDosList()" LINK "AttemptLockDosList"}     @{"ChangeMode()" LINK "ChangeMode"}            @{"CheckSignal()" LINK "CheckSignal"}
@{"Cli()" LINK "Cli"}                    @{"CliInitNewcli()" LINK "CliInitNewcli"}         @{"CliInitRun()" LINK "CliInitRun"}
@{"Close()" LINK "Close"}                  @{"CompareDates()" LINK "CompareDates"}          @{"CreateDir()" LINK "CreateDir"}
@{"CreateNewProc()" LINK "CreateNewProc"}          @{"CreateNewProcTagList()" LINK "CreateNewProc"}  @{"CreateNewProcTags()" LINK "CreateNewProc"}
@{"CreateProc()" LINK "CreateProc"}             @{"CurrentDir()" LINK "CurrentDir"}            @{"DateStamp()" LINK "DateStamp"}
@{"DateToStr()" LINK "DateToStr"}              @{"Delay()" LINK "Delay"}                 @{"DeleteFile()" LINK "DeleteFile"}
@{"DeleteVar()" LINK "DeleteVar"}              @{"DeviceProc()" LINK "DeviceProc"}            @{"DoPkt()" LINK "DoPkt"}
@{"DupLock()" LINK "DupLock"}                @{"DupLockFromFH()" LINK "DupLockFromFH"}         @{"EndNotify()" LINK "EndNotify"}
@{"ErrorReport()" LINK "ErrorReport"}            @{"ExAll()" LINK "ExAll"}                 @{"ExAllEnd()" LINK "ExAllEnd"}
@{"Examine()" LINK "Examine"}                @{"ExamineFH()" LINK "ExamineFH"}             @{"Execute()" LINK "Execute"}
@{"Exit()" LINK "Exit"}                   @{"ExNext()" LINK "ExNext"}                @{"Fault()" LINK "Fault"}
@{"FGetC()" LINK "FGetC"}                  @{"FGets()" LINK "FGets"}                 @{"FilePart()" LINK "FilePart"}
@{"FindArg()" LINK "FindArg"}                @{"FindCliProc()" LINK "FindCliProc"}           @{"FindDosEntry()" LINK "FindDosEntry"}
@{"FindSegment()" LINK "FindSegment"}            @{"FindVar()" LINK "FindVar"}               @{"Flush()" LINK "Flush"}
@{"Format()" LINK "Format"}                 @{"FPrintf()" LINK "VFPrintf"}               @{"FPutC()" LINK "FPutC"}
@{"FPuts()" LINK "FPuts"}                  @{"FRead()" LINK "FRead"}                 @{"FreeArgs()" LINK "FreeArgs"}
@{"FreeDeviceProc()" LINK "FreeDeviceProc"}         @{"FreeDosEntry()" LINK "FreeDosEntry"}          @{"FreeDosObject()" LINK "FreeDosObject"}
@{"FWrite()" LINK "FWrite"}                 @{"FWritef()" LINK "VFWritef"}               @{"GetArgStr()" LINK "GetArgStr"}
@{"GetConsoleTask()" LINK "GetConsoleTask"}         @{"GetCurrentDirName()" LINK "GetCurrentDirName"}     @{"GetDeviceProc()" LINK "GetDeviceProc"}
@{"GetFileSysTask()" LINK "GetFileSysTask"}         @{"GetProgramDir()" LINK "GetProgramDir"}         @{"GetProgramName()" LINK "GetProgramName"}
@{"GetPrompt()" LINK "GetPrompt"}              @{"GetVar()" LINK "GetVar"}                @{"Info()" LINK "Info"}
@{"Inhibit()" LINK "Inhibit"}                @{"Input()" LINK "Input"}                 @{"InternalLoadSeg()" LINK "InternalLoadSeg"}
@{"InternalUnLoadSeg()" LINK "InternalUnLoadSeg"}      @{"IoErr()" LINK "IoErr"}                 @{"IsFileSystem()" LINK "IsFileSystem"}
@{"IsInteractive()" LINK "IsInteractive"}          @{"LoadSeg()" LINK "LoadSeg"}               @{"Lock()" LINK "Lock"}
@{"LockDosList()" LINK "LockDosList"}            @{"LockRecord()" LINK "LockRecord"}            @{"LockRecords()" LINK "LockRecords"}
@{"MakeDosEntry()" LINK "MakeDosEntry"}           @{"MakeLink()" LINK "MakeLink"}              @{"MatchEnd()" LINK "MatchEnd"}
@{"MatchFirst()" LINK "MatchFirst"}             @{"MatchNext()" LINK "MatchNext"}             @{"MatchPattern()" LINK "MatchPattern"}
@{"MatchPatternNoCase()" LINK "MatchPatternNoCase"}     @{"MaxCli()" LINK "MaxCli"}                @{"NameFromFH()" LINK "NameFromFH"}
@{"NameFromLock()" LINK "NameFromLock"}           @{"NewLoadSeg()" LINK "NewLoadSeg"}            @{"NewLoadSegTagList()" LINK "NewLoadSeg"}
@{"NewLoadSegTags()" LINK "NewLoadSeg"}         @{"NextDosEntry()" LINK "NextDosEntry"}          @{"Open()" LINK "Open"}
@{"OpenFromLock()" LINK "OpenFromLock"}           @{"Output()" LINK "Output"}                @{"ParentDir()" LINK "ParentDir"}
@{"ParentOfFH()" LINK "ParentOfFH"}             @{"ParsePattern()" LINK "ParsePattern"}          @{"ParsePatternNoCase()" LINK "ParsePatternNoCase"}
@{"PathPart()" LINK "PathPart"}               @{"Printf()" LINK "VPrintf"}                @{"PrintFault()" LINK "PrintFault"}
@{"PutStr()" LINK "PutStr"}                 @{"Read()" LINK "Read"}                  @{"ReadArgs()" LINK "ReadArgs"}
@{"ReadItem()" LINK "ReadItem"}               @{"ReadLink()" LINK "ReadLink"}              @{"Relabel()" LINK "Relabel"}
@{"RemAssignList()" LINK "RemAssignList"}          @{"RemDosEntry()" LINK "RemDosEntry"}           @{"RemSegment()" LINK "RemSegment"}
@{"Rename()" LINK "Rename"}                 @{"ReplyPkt()" LINK "ReplyPkt"}              @{"RunCommand()" LINK "RunCommand"}
@{"SameDevice()" LINK "SameDevice"}             @{"SameLock()" LINK "SameLock"}              @{"Seek()" LINK "Seek"}
@{"SelectInput()" LINK "SelectInput"}            @{"SelectOutput()" LINK "SelectOutput"}          @{"SendPkt()" LINK "SendPkt"}
@{"SetArgStr()" LINK "SetArgStr"}              @{"SetComment()" LINK "SetComment"}            @{"SetConsoleTask()" LINK "SetConsoleTask"}
@{"SetCurrentDirName()" LINK "SetCurrentDirName"}      @{"SetFileDate()" LINK "SetFileDate"}           @{"SetFileSize()" LINK "SetFileSize"}
@{"SetFileSysTask()" LINK "SetFileSysTask"}         @{"SetIoErr()" LINK "SetIoErr"}              @{"SetMode()" LINK "SetMode"}
@{"SetOwner()" LINK "SetOwner"}               @{"SetProgramDir()" LINK "SetProgramDir"}         @{"SetProgramName()" LINK "SetProgramName"}
@{"SetPrompt()" LINK "SetPrompt"}              @{"SetProtection()" LINK "SetProtection"}         @{"SetVar()" LINK "SetVar"}
@{"SetVBuf()" LINK "SetVBuf"}                @{"SplitName()" LINK "SplitName"}             @{"StartNotify()" LINK "StartNotify"}
@{"StrToDate()" LINK "StrToDate"}              @{"StrToLong()" LINK "StrToLong"}             @{"System()" LINK "SystemTagList"}
@{"SystemTagList()" LINK "SystemTagList"}          @{"SystemTags()" LINK "SystemTagList"}            @{"UnGetC()" LINK "UnGetC"}
@{"UnLoadSeg()" LINK "UnLoadSeg"}              @{"UnLock()" LINK "UnLock"}                @{"UnLockDosList()" LINK "UnLockDosList"}
@{"UnLockRecord()" LINK "UnLockRecord"}           @{"UnLockRecords()" LINK "UnLockRecords"}         @{"VFPrintf()" LINK "VFPrintf"}
@{"VFWritef()" LINK "VFWritef"}               @{"VPrintf()" LINK "VPrintf"}               @{"WaitForChar()" LINK "WaitForChar"}
@{"WaitPkt()" LINK "WaitPkt"}                @{"Write()" LINK "Write"}                 @{"WriteChars()" LINK "WriteChars"}

@ENDNODE
@NODE "AbortPkt" "dos.library/AbortPkt()"
@{b}

   NAME@{ub}
        @{"AbortPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 222} -- Aborts an asynchronous packet, if possible. (V36)@{b}

   SYNOPSIS@{ub}
        @{"AbortPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 222}(port, pkt)
                  D1    D2

        void @{"AbortPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 222}(@{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *, @{"struct DosPacket" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 108} *)@{b}

   FUNCTION@{ub}
        This attempts to abort a packet sent earlier with @{"SendPkt" LINK "SendPkt"} to a
        handler.  There is no guarantee that any given handler will allow
        a packet to be aborted, or if it is aborted whether function
        requested completed first or completely.  After calling @{"AbortPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 222}(),
        you must wait for the packet to return before reusing it or
        deallocating it.@{b}

   INPUTS@{ub}
        port - port the packet was sent to
        pkt  - the packet you wish aborted@{b}

   BUGS@{ub}
        As of V37, this function does nothing.@{b}

   SEE ALSO@{ub}
        @{"SendPkt()" LINK "SendPkt"}, @{"DoPkt()" LINK "DoPkt"}, @{"WaitPkt()" LINK "WaitPkt"}

@ENDNODE
@NODE "AddBuffers" "dos.library/AddBuffers()"
@{b}

   NAME@{ub}
        @{"AddBuffers" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 554} -- Changes the number of buffers for a filesystem (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"AddBuffers" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 554}(filesystem, number)
        D0                     D1          D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"AddBuffers" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 554}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        Adds buffers to a filesystem.  If it succeeds, the number of current
        buffers is returned in @{"IoErr()" LINK "IoErr"}.  Note that "number" may be negative.
        The amount of memory used per buffer, and any limits on the number of
        buffers, are dependant on the filesystem in question.
        If the call succeeds, the number of buffers in use on the filesystem
        will be returned by @{"IoErr()" LINK "IoErr"}.@{b}

   INPUTS@{ub}
        filesystem - Name of device to add buffers to (with ':').
        number     - Number of buffers to add.  May be negative.@{b}

   RESULT@{ub}
        success    - Success or failure of command.@{b}

   BUGS@{ub}
        The V36 ROM filesystem (FFS/OFS) doesn't return the right number of
        buffers unless preceded by an @{"AddBuffers" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 554}(fs,-1) (in-use buffers aren't
        counted).  This is fixed in V37.

        The V37 and before ROM filesystem doesn't return success, it returns
        the number of buffers.  The best way to test for this is to consider
        0 (@{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}) failure, -1 (@{"DOSTRUE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 22}) to mean that @{"IoErr()" LINK "IoErr"} will have the
        number of buffers, and any other positive value to be the number of
        buffers.  It may be fixed in some future ROM revision.@{b}

   SEE ALSO@{ub}
        @{"IoErr()" LINK "IoErr"}

@ENDNODE
@NODE "AddDosEntry" "dos.library/AddDosEntry()"
@{b}

   NAME@{ub}
        @{"AddDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 518} -- Add a Dos List entry to the lists (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"AddDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 518}(dlist)
        D0                     D1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"AddDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 518}(@{"struct DosList" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 372} *)@{b}

   FUNCTION@{ub}
        Adds a device, volume or assign to the dos devicelist.  Can fail if it
        conflicts with an existing entry (such as another assign to the same
        name or another device of the same name).  Volume nodes with different
        dates and the same name CAN be added, or with names that conflict with
        devices or assigns.  Note: the dos list does @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} have to be locked to
        call this.  Do not access dlist after adding unless you have locked the
        Dos Device list.

        An additional note concerning calling this from within a handler:
        in order to avoid deadlocks, your handler must either be multi-
        threaded, or it must attempt to lock the list before calling this
        function.  The code would look something like this:

        if (@{"AttemptLockDosList" LINK "AttemptLockDosList"}(LDF_xxx|@{"LDF_WRITE" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 450}))
        {
                rc = @{"AddDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 518}(...);
                @{"UnLockDosList" LINK "UnLockDosList"}(LDF_xxx|@{"LDF_WRITE" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 450});
        }

        If @{"AttemptLockDosList()" LINK "AttemptLockDosList"} fails (i.e. it's locked already), check for
        messages at your filesystem port (don't wait!) and try the
        @{"AttemptLockDosList()" LINK "AttemptLockDosList"} again.@{b}

   INPUTS@{ub}
        dlist   - Device list entry to be added.@{b}

   RESULT@{ub}
        success - Success/Failure indicator@{b}

   SEE ALSO@{ub}
        @{"RemDosEntry()" LINK "RemDosEntry"}, @{"FindDosEntry()" LINK "FindDosEntry"}, @{"NextDosEntry()" LINK "NextDosEntry"}, @{"LockDosList()" LINK "LockDosList"},
        @{"MakeDosEntry()" LINK "MakeDosEntry"}, @{"FreeDosEntry()" LINK "FreeDosEntry"}, @{"AttemptLockDosList()" LINK "AttemptLockDosList"}

@ENDNODE
@NODE "AddPart" "dos.library/AddPart()"
@{b}

   NAME@{ub}
        @{"AddPart" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 653} -- Appends a file/dir to the end of a path (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"AddPart" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 653}( dirname, filename, size )
        D0                   D1        D2      D3

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"AddPart" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 653}( @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} )@{b}

   FUNCTION@{ub}
        This function adds a file, directory, or subpath name to a directory
        path name taking into account any required separator characters.  If
        filename is a fully-qualified path it will totally replace the current
        value of dirname.@{b}

   INPUTS@{ub}
        dirname  - the path to add a file/directory name to.
        filename - the filename or directory name to add.  May be a relative
                   pathname from the current directory (example: foo/bar).
                   Can deal with leading '/'(s), indicating one directory up
                   per '/', or with a ':', indicating it's relative to the
                   root of the appropriate volume.
        size     - size in bytes of the space allocated for dirname.  Must
                   not be 0.@{b}

   RESULT@{ub}
        success - non-zero for ok, @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if the buffer would have overflowed.
                  If an overflow would have occured, dirname will not be
                  changed.@{b}

   BUGS@{ub}
        Doesn't check if a subpath is legal (i.e. doesn't check for ':'s) and
        doesn't handle leading '/'s in 2.0 through 2.02 (V36).  V37 fixes
        this, allowing filename to be any path, including absolute.@{b}

   SEE ALSO@{ub}
        @{"FilePart()" LINK "FilePart"}, @{"PathPart()" LINK "PathPart"}

@ENDNODE
@NODE "AddSegment" "dos.library/AddSegment()"
@{b}

   NAME@{ub}
        @{"AddSegment" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 589} - Adds a resident segment to the resident list (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"AddSegment" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 589}(name, seglist, type)
        D0                    D1     D2      D3

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"AddSegment" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 589}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        Adds a segment to the Dos resident list, with the specified Seglist
        and type (stored in seg_UC - normally 0).  NOTE: currently unused
        types may cause it to interpret other registers (d4-?) as additional
        parameters in the future.

        Do @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} build Segment structures yourself!@{b}

   INPUTS@{ub}
        name    - name for the segment
        seglist - Dos seglist of code for segment
        type    - initial usecount, normally 0@{b}

   RESULT@{ub}
        success - success or failure@{b}

   SEE ALSO@{ub}
        @{"FindSegment()" LINK "FindSegment"}, @{"RemSegment()" LINK "RemSegment"}, @{"LoadSeg()" LINK "LoadSeg"}

@ENDNODE
@NODE "AllocDosObject" "dos.library/AllocDosObject()"
@{b}

   NAME@{ub}
        @{"AllocDosObject" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 171} -- Creates a dos object (V36)@{b}

   SYNOPSIS@{ub}
        ptr = @{"AllocDosObject" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 171}(type, tags)
        D0                    D1    D2

        void *@{"AllocDosObject" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 171}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *)

        ptr = @{"AllocDosObjectTagList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 175}(type, tags)
        D0                           D1    D2

        void *@{"AllocDosObjectTagList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 175}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *)

        ptr = @{"AllocDosObjectTags" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 178}(type, Tag1, ...)

        void *@{"AllocDosObjectTags" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 178}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, ...)@{b}

   FUNCTION@{ub}
        Create one of several dos objects, initializes it, and returns it
        to you.  Note the @{"DOS_STDPKT" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 276} returns a pointer to the sp_Pkt of the
        structure.

        This function may be called by a task for all types and tags defined
        in the V37 includes (@{"DOS_FILEHANDLE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 273} through @{"DOS_RDARGS" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 278} and @{"ADO_FH_Mode" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 113}
        through @{"ADO_PromptLen" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 131}, respectively).  Any future types or tags
        will be documented as to whether a task may use them.@{b}

   INPUTS@{ub}
        type - type of object requested
        tags - pointer to taglist with additional information@{b}

   RESULT@{ub}
        packet - pointer to the object or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}@{b}

   BUGS@{ub}
        Before V39, @{"DOS_CLI" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 277} should be used with care since @{"FreeDosObject()" LINK "FreeDosObject"}
        can't free it.@{b}

   SEE ALSO@{ub}
        @{"FreeDosObject()" LINK "FreeDosObject"}, <@{"dos/dostags.h" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File"}>, <@{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"}>

@ENDNODE
@NODE "AssignAdd" "dos.library/AssignAdd()"
@{b}

   NAME@{ub}
        @{"AssignAdd" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 486} -- Adds a lock to an assign for multi-directory assigns (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"AssignAdd" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 486}(name,lock)
        D0                   D1   D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"AssignAdd" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 486}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

   FUNCTION@{ub}
        Adds a lock to an assign, making or adding to a multi-directory
        assign.  Note that this only will succeed on an assign created with
        @{"AssignLock()" LINK "AssignLock"}, or an assign created with @{"AssignLate()" LINK "AssignLate"} which has been
        resolved (converted into a @{"AssignLock()" LINK "AssignLock"}-assign).

        NOTE: you should not use the lock in any way after making this call
        successfully.  It becomes the part of the assign, and will be unlocked
        by the system when the assign is removed.  If you need to keep the
        lock, pass a lock from @{"DupLock()" LINK "DupLock"} to @{"AssignLock()" LINK "AssignLock"}.@{b}

   INPUTS@{ub}
        name - Name of device to assign lock to (without trailing ':')
        lock - Lock associated with the assigned name@{b}

   RESULT@{ub}
        success - Success/failure indicator.  On failure, the lock is not
                  unlocked.@{b}

   SEE ALSO@{ub}
        @{"Lock()" LINK "Lock"}, @{"AssignLock()" LINK "AssignLock"}, @{"AssignPath()" LINK "AssignPath"}, @{"AssignLate()" LINK "AssignLate"}, @{"DupLock()" LINK "DupLock"},
        @{"RemAssignList()" LINK "RemAssignList"}

@ENDNODE
@NODE "AssignLate" "dos.library/AssignLate()"
@{b}

   NAME@{ub}
        @{"AssignLate" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 478} -- Creates an assignment to a specified path later (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"AssignLate" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 478}(name,path)
        D0                    D1   D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"AssignLate" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 478}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

   FUNCTION@{ub}
        Sets up a assignment that is expanded upon the FIRST reference to the
        name.  The path (a string) would be attached to the node.  When
        the name is referenced (@{"Open" LINK "Open"}("FOO:xyzzy"...), the string will be used
        to determine where to set the assign to, and if the directory can be
        locked, the assign will act from that point on as if it had been
        created by @{"AssignLock()" LINK "AssignLock"}.

        A major advantage is assigning things to unmounted volumes, which
        will be requested upon access (useful in startup sequences).@{b}

   INPUTS@{ub}
        name - Name of device to be assigned (without trailing ':')
        path - Name of late assignment to be resolved on the first reference.@{b}

   RESULT@{ub}
        success - Success/failure indicator of the operation@{b}

   SEE ALSO@{ub}
        @{"Lock()" LINK "Lock"}, @{"AssignAdd()" LINK "AssignAdd"}, @{"AssignPath()" LINK "AssignPath"}, @{"AssignLock()" LINK "AssignLock"},

@ENDNODE
@NODE "AssignLock" "dos.library/AssignLock()"
@{b}

   NAME@{ub}
        @{"AssignLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 474} -- Creates an assignment to a locked object (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"AssignLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 474}(name,lock)
        D0                    D1   D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"AssignLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 474}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

   FUNCTION@{ub}
        Sets up an assign of a name to a given lock.  Passing @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for a lock
        cancels any outstanding assign to that name.  If an assign entry of
        that name is already on the list, this routine replaces that entry.  If
        an entry is on the list that conflicts with the new assign, then a
        failure code is returned.

        NOTE: you should not use the lock in any way after making this call
        successfully.  It becomes the assign, and will be unlocked by the
        system when the assign is removed.  If you need to keep the lock,
        pass a lock from @{"DupLock()" LINK "DupLock"} to @{"AssignLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 474}().@{b}

   INPUTS@{ub}
        name - Name of device to assign lock to (without trailing ':')
        lock - Lock associated with the assigned name@{b}

   RESULT@{ub}
        success - Success/failure indicator.  On failure, the lock is not
                  unlocked.@{b}

   SEE ALSO@{ub}
        @{"Lock()" LINK "Lock"}, @{"AssignAdd()" LINK "AssignAdd"}, @{"AssignPath()" LINK "AssignPath"}, @{"AssignLate()" LINK "AssignLate"}, @{"DupLock()" LINK "DupLock"},
        @{"RemAssignList()" LINK "RemAssignList"}

@ENDNODE
@NODE "AssignPath" "dos.library/AssignPath()"
@{b}

   NAME@{ub}
        @{"AssignPath" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 482} -- Creates an assignment to a specified path (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"AssignPath" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 482}(name,path)
        D0                    D1   D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"AssignPath" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 482}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

   FUNCTION@{ub}
        Sets up a assignment that is expanded upon EACH reference to the name.
        This is implemented through a new device list type (DLT_ASSIGNPATH, or
        some such).  The path (a string) would be attached to the node.  When
        the name is referenced (@{"Open" LINK "Open"}("FOO:xyzzy"...), the string will be used
        to determine where to do the open.  No permanent lock will be part of
        it.  For example, you could @{"AssignPath" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 482}() c2: to df2:c, and references
        to c2: would go to df2:c, even if you change disks.

        The other major advantage is assigning things to unmounted volumes,
        which will be requested upon access (useful in startup sequences).@{b}

   INPUTS@{ub}
        name - Name of device to be assigned (without trailing ':')
        path - Name of late assignment to be resolved at each reference@{b}

   RESULT@{ub}
        success - Success/failure indicator of the operation@{b}

   SEE ALSO@{ub}
        @{"AssignAdd()" LINK "AssignAdd"}, @{"AssignLock()" LINK "AssignLock"}, @{"AssignLate()" LINK "AssignLate"}, @{"Open()" LINK "Open"}

@ENDNODE
@NODE "AttemptLockDosList" "dos.library/AttemptLockDosList()"
@{b}

   NAME@{ub}
        @{"AttemptLockDosList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 510} -- Attempt to lock the Dos Lists for use (V36)@{b}

   SYNOPSIS@{ub}
        dlist = @{"AttemptLockDosList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 510}(flags)
        D0                          D1

        @{"struct DosList" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 372} *@{"AttemptLockDosList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 510}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{b}

   FUNCTION@{ub}
        Locks the dos device list in preparation to walk the list.  If the
        list is 'busy' then this routine will return @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.  See @{"LockDosList()" LINK "LockDosList"}
        for more information.@{b}

   INPUTS@{ub}
        flags - Flags stating which types of nodes you want to lock.@{b}

   RESULT@{ub}
        dlist - Pointer to the beginning of the list or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.  Not a valid
                node!@{b}

   BUGS@{ub}
        In V36 through V39.23 dos, this would return @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} or 0x00000001 for
        failure.  Fixed in V39.24 dos (after kickstart 39.106).@{b}

   SEE ALSO@{ub}
        @{"LockDosList()" LINK "LockDosList"}, @{"UnLockDosList()" LINK "UnLockDosList"}, @{"Forbid()" LINK "gg:doc/NDK/Guide/exec/Forbid"}, @{"NextDosEntry()" LINK "NextDosEntry"}

@ENDNODE
@NODE "ChangeMode" "dos.library/ChangeMode()"
@{b}

   NAME@{ub}
        @{"ChangeMode" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 356} - Change the current mode of a lock or filehandle (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"ChangeMode" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 356}(type, object, newmode)
        D0                    D1     D2      D3

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"ChangeMode" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 356}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{b}

   FUNCTION@{ub}
        This allows you to attempt to change the mode in use by a lock or
        filehandle.  For example, you could attempt to turn a shared lock
        into an exclusive lock.  The handler may well reject this request.
        Warning: if you use the wrong type for the object, the system may
        crash.@{b}

   INPUTS@{ub}
        type    - Either @{"CHANGE_FH" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 259} or @{"CHANGE_LOCK" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 258}
        object  - A lock or filehandle
        newmode - The new mode you want@{b}

   RESULT@{ub}
        success - Boolean@{b}

   BUGS@{ub}
        Did not work in 2.02 or before (V36).  Works in V37.  In the
        earlier versions, it can crash the machine.@{b}

   SEE ALSO@{ub}
        @{"Lock()" LINK "Lock"}, @{"Open()" LINK "Open"}

@ENDNODE
@NODE "CheckSignal" "dos.library/CheckSignal()"
@{b}

   NAME@{ub}
        @{"CheckSignal" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 601} -- Checks for break signals (V36)@{b}

   SYNOPSIS@{ub}
        signals = @{"CheckSignal" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 601}(mask)
        D0                    D1

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"CheckSignal" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 601}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{b}

   FUNCTION@{ub}
        This function checks to see if any signals specified in the mask have
        been set and if so, returns them.  Otherwise it returns @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}.
        All signals specified in mask will be cleared.@{b}

   INPUTS@{ub}
        mask    - Signals to check for.@{b}

   RESULT@{ub}
        signals - Signals specified in mask that were set.@{b}

   SEE ALSO@{ub}

@ENDNODE
@NODE "Cli" "dos.library/Cli()"
@{b}

   NAME@{ub}
        Cli -- Returns a pointer to the CLI structure of the process (V36)@{b}

   SYNOPSIS@{ub}
        cli_ptr = Cli()
        D0

        @{"struct CommandLineInterface" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 314} *Cli(void)@{b}

   FUNCTION@{ub}
        Returns a pointer to the CLI structure of the current process, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
        if the process has no CLI structure.@{b}

   RESULT@{ub}
        cli_ptr - pointer to the CLI structure, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}

@ENDNODE
@NODE "CliInitNewcli" "dos.library/CliInitNewcli()"
@{b}

   NAME@{ub}
        @{"CliInitNewcli" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 681} -- Set up a process to be a shell from initial packet@{b}

   SYNOPSIS@{ub}
        flags = @{"CliInitNewcli" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 681}( packet )
        D0                       A0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"CliInitNewcli" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 681}( @{"struct DosPacket" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 108} * )@{b}

   FUNCTION@{ub}
        This function initializes a process and CLI structure for a new
        shell, from parameters in an initial packet passed by the system
        (NewShell or NewCLI, etc).  The format of the data in the packet
        is purposely not defined.  The setup includes all the normal fields
        in the structures that are required for proper operation (current
        directory, paths, input streams, etc).

        It returns a set of flags containing information about what type
        of shell invocation this is.

        Definitions for the values of fn:
                Bit 31     Set to indicate flags are valid
                Bit  3     Set to indicate asynch system call
                Bit  2     Set if this is a @{"System()" LINK "SystemTagList"} call
                Bit  1     Set if user provided input stream
                Bit  0     Set if RUN provided output stream

        If Bit 31 is 0, then you must check @{"IoErr()" LINK "IoErr"} to determine if an error
        occurred.  If @{"IoErr()" LINK "IoErr"} returns a pointer to your process, there has
        been an error, and you should clean up and exit.  The packet will
        have already been returned by @{"CliInitNewcli" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 681}().  If it isn't a pointer
        to your process and Bit 31 is 0, reply the packet immediately.
        (Note: this is different from what you do for @{"CliInitRun()" LINK "CliInitRun"}.)

        This function is very similar to @{"CliInitRun()" LINK "CliInitRun"}.@{b}

   INPUTS@{ub}
        packet - the initial packet sent to your process MsgPort@{b}

   RESULT@{ub}
        fn - flags or a pointer@{b}

   SEE ALSO@{ub}
        @{"CliInitRun()" LINK "CliInitRun"}, @{"ReplyPkt()" LINK "ReplyPkt"}, @{"WaitPkt()" LINK "WaitPkt"}, @{"IoErr()" LINK "IoErr"}

@ENDNODE
@NODE "CliInitRun" "dos.library/CliInitRun()"
@{b}

   NAME@{ub}
        @{"CliInitRun" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 685} -- Set up a process to be a shell from initial packet@{b}

   SYNOPSIS@{ub}
        flags = @{"CliInitRun" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 685}( packet )
        D0                    A0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"CliInitRun" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 685}( @{"struct DosPacket" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 108} * )@{b}

   FUNCTION@{ub}
        This function initializes a process and CLI structure for a new
        shell, from parameters in an initial packet passed by the system
        (Run, @{"System()" LINK "SystemTagList"}, @{"Execute()" LINK "Execute"}).  The format of the data in the packet
        is purposely not defined.  The setup includes all the normal fields
        in the structures that are required for proper operation (current
        directory, paths, input streams, etc).

        It returns a set of flags containing information about what type
        of shell invocation this is.

        Definitions for the values of fn:
                Bit 31     Set to indicate flags are valid
                Bit  3     Set to indicate asynch system call
                Bit  2     Set if this is a @{"System()" LINK "SystemTagList"} call
                Bit  1     Set if user provided input stream
                Bit  0     Set if RUN provided output stream

        If Bit 31 is 0, then you must check @{"IoErr()" LINK "IoErr"} to determine if an error
        occurred.  If @{"IoErr()" LINK "IoErr"} returns a pointer to your process, there has
        been an error, and you should clean up and exit.  The packet will
        have already been returned by @{"CliInitNewcli()" LINK "CliInitNewcli"}.  If it isn't a pointer
        to your process and Bit 31 is 0, you should wait before replying
        the packet until after you've loaded the first command (or when you
        exit).  This helps avoid disk "gronking" with the Run command.
        (Note: this is different from what you do for @{"CliInitNewcli()" LINK "CliInitNewcli"}.)

        If Bit 31 is 1, then if Bit 3 is one, @{"ReplyPkt()" LINK "ReplyPkt"} the packet
        immediately (Asynch @{"System()" LINK "SystemTagList"}), otherwise wait until your shell exits
        (Sync @{"System()" LINK "SystemTagList"}, @{"Execute()" LINK "Execute"}).
        (Note: this is different from what you do for @{"CliInitNewcli()" LINK "CliInitNewcli"}.)

        This function is very similar to @{"CliInitNewcli()" LINK "CliInitNewcli"}.@{b}

   INPUTS@{ub}
        packet - the initial packet sent to your process MsgPort@{b}

   RESULT@{ub}
        fn - flags or a pointer@{b}

   SEE ALSO@{ub}
        @{"CliInitNewcli()" LINK "CliInitNewcli"}, @{"ReplyPkt()" LINK "ReplyPkt"}, @{"WaitPkt()" LINK "WaitPkt"}, @{"System()" LINK "SystemTagList"}, @{"Execute()" LINK "Execute"}, @{"IoErr()" LINK "IoErr"}

@ENDNODE
@NODE "Close" "dos.library/Close()"
@{b}

    NAME@{ub}
        Close -- Close an open file@{b}

    SYNOPSIS@{ub}
        success = Close( file )
           D0             D1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} Close(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

    FUNCTION@{ub}
        The file specified by the file handle is closed. You must close all
        files you explicitly opened, but you must not close inherited file
        handles that are passed to you (each filehandle must be closed once
        and ONLY once).  If Close() fails, the file handle is still
        deallocated and should not be used.@{b}

    INPUTS@{ub}
        file - BCPL pointer to a file handle@{b}

    RESULTS@{ub}
        success - returns if Close() succeeded.  Note that it might fail
                  depending on buffering and whatever IO must be done to
                  close a file being written to.  NOTE: this return value
                  did not exist before V36!@{b}

    SEE ALSO@{ub}
        @{"Open()" LINK "Open"}, @{"OpenFromLock()" LINK "OpenFromLock"}

@ENDNODE
@NODE "CompareDates" "dos.library/CompareDates()"
@{b}

   NAME@{ub}
        @{"CompareDates" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 558} -- Compares two datestamps (V36)@{b}

   SYNOPSIS@{ub}
        result = @{"CompareDates" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 558}(date1,date2)
        D0                     D1     D2

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"CompareDates" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 558}(@{"struct DateStamp" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 52} *,@{"struct DateStamp" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 52} *)@{b}

   FUNCTION@{ub}
        Compares two times for relative magnitide.  <0 is returned if date1 is
        later than date2, 0 if they are equal, or >0 if date2 is later than
        date1.  NOTE: this is @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} the same ordering as strcmp!@{b}

   INPUTS@{ub}
        date1, date2 - DateStamps to compare@{b}

   RESULT@{ub}
        result -  <0, 0, or >0 based on comparison of two date stamps@{b}

   SEE ALSO@{ub}
        @{"DateStamp()" LINK "DateStamp"}, @{"DateToStr()" LINK "DateToStr"}, @{"StrToDate()" LINK "StrToDate"}

@ENDNODE
@NODE "CreateDir" "dos.library/CreateDir()"
@{b}

    NAME@{ub}
        @{"CreateDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 107} -- Create a new directory@{b}

    SYNOPSIS@{ub}
        lock = @{"CreateDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 107}( name )
        D0                D1

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} @{"CreateDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 107}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

    FUNCTION@{ub}
        @{"CreateDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 107} creates a new directory with the specified name. An error
        is returned if it fails.  Directories can only be created on
        devices which support them, e.g. disks.  @{"CreateDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 107} returns an
        exclusive lock on the new directory if it succeeds.@{b}

    INPUTS@{ub}
        name - pointer to a null-terminated string@{b}

    RESULTS@{ub}
        lock - BCPL pointer to a lock or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for failure.@{b}

    SEE ALSO@{ub}
        @{"Lock()" LINK "Lock"}, @{"UnLock()" LINK "UnLock"}

@ENDNODE
@NODE "CreateNewProc" "dos.library/CreateNewProc()"
@{b}

   NAME@{ub}
        @{"CreateNewProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 384} -- Create a new process (V36)@{b}

   SYNOPSIS@{ub}
        process = @{"CreateNewProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 384}(tags)
        D0                       D1

        @{"struct Process" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 37} *@{"CreateNewProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 384}(@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *)

        process = @{"CreateNewProcTagList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 388}(tags)
        D0                              D1

        @{"struct Process" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 37} *@{"CreateNewProcTagList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 388}(@{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *)

        process = @{"CreateNewProcTags" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 391}(Tag1, ...)

        @{"struct Process" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 37} *@{"CreateNewProcTags" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 391}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, ...)@{b}

   FUNCTION@{ub}
        This creates a new process according to the tags passed in.  See
        @{"dos/dostags.h" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File"} for the tags.

        You must specify one of @{"NP_Seglist" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 41} or @{"NP_Entry" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 46}.  @{"NP_Seglist" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 41} takes a
        seglist (as returned by @{"LoadSeg()" LINK "LoadSeg"}).  @{"NP_Entry" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 46} takes a function
        pointer for the routine to call.

        There are many options, as you can see by examining @{"dos/dostags.h" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File"}.
        The defaults are for a non-CLI process, with copies of your
        @{"CurrentDir" LINK "CurrentDir"}, HomeDir (used for PROGDIR:), priority, consoletask,
        windowptr, and variables.  The input and output filehandles default
        to opens of NIL:, stack to 4000, and others as shown in dostags.h.
        This is a fairly reasonable default setting for creating threads,
        though you may wish to modify it (for example, to give a descriptive
        name to the process.)

        @{"CreateNewProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 384}() is callable from a task, though any actions that
        require doing Dos I/O (@{"DupLock()" LINK "DupLock"} of currentdir, for example) will not
        occur.

        NOTE: if you call @{"CreateNewProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 384}() with both @{"NP_Arguments" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 87}, you must
        not specify an @{"NP_Input" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 49} of @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.  When @{"NP_Arguments" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 87} is specified, it
        needs to modify the input filehandle to make @{"ReadArgs()" LINK "ReadArgs"} work properly.@{b}

   INPUTS@{ub}
        tags - a pointer to a TagItem array.@{b}

   RESULT@{ub}
        process - The created process, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.  Note that if it returns
                  @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, you must free any items that were passed in via
                  tags, such as if you passed in a new current directory
                  with @{"NP_CurrentDir" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 64}.@{b}

   BUGS@{ub}
        In V36, @{"NP_Arguments" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 87} was broken in a number of ways, and probably
        should be avoided (instead you should start a small piece of your
        own code, which calls @{"RunCommand()" LINK "RunCommand"} to run the actual code you wish
        to run).  In V37, @{"NP_Arguments" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 87} works, though see the note above.@{b}

   SEE ALSO@{ub}
        @{"LoadSeg()" LINK "LoadSeg"}, @{"CreateProc()" LINK "CreateProc"}, @{"ReadArgs()" LINK "ReadArgs"}, @{"RunCommand()" LINK "RunCommand"}, <@{"dos/dostags.h" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File"}>

@ENDNODE
@NODE "CreateProc" "dos.library/CreateProc()"
@{b}

    NAME@{ub}

        @{"CreateProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 119} -- Create a new process@{b}

    SYNOPSIS@{ub}
        process = @{"CreateProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 119}( name, pri, seglist, stackSize )
        D0                    D1    D2   D3       D4

        @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *@{"CreateProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 119}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

    FUNCTION@{ub}
        @{"CreateProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 119}() creates a new AmigaDOS process of name 'name'.  AmigaDOS
        processes are a superset of exec tasks.

        A seglist, as returned by @{"LoadSeg()" LINK "LoadSeg"}, is passed as 'seglist'.
        This represents a section of code which is to be run as a new
        process. The code is entered at the first hunk in the segment list,
        which should contain suitable initialization code or a jump to
        such.  A process control structure is allocated from memory and
        initialized.  If you wish to fake a seglist (that will never
        have DOS @{"UnLoadSeg()" LINK "UnLoadSeg"} called on it), use this code:

                    DS.L    0   ;Align to longword
                    DC.L    16  ;Segment "length" (faked)
                    DC.L    0   ;Pointer to next segment
                    ...start of code...

        The size of the root stack upon activation is passed as
        'stackSize'.  'pri' specifies the required priority of the new
        process.  The result will be the process msgport address of the new
        process, or zero if the routine failed.  The argument 'name'
        specifies the new process name.  A zero return code indicates
        error.

        The seglist passed to @{"CreateProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 119}() is not freed when it exits; it
        is up to the parent process to free it, or for the code to unload
        itself.

        Under V36 and later, you probably should use @{"CreateNewProc()" LINK "CreateNewProc"} instead.@{b}

    INPUTS@{ub}
        name      - pointer to a null-terminated string
        pri       - signed long (range -128 to +127)
        seglist   - BCPL pointer to a seglist
        stackSize - integer (must be a multiple of 4 bytes)@{b}

    RESULTS@{ub}
        process   - pointer to new process msgport@{b}

    SEE ALSO@{ub}
        @{"CreateNewProc()" LINK "CreateNewProc"}, @{"LoadSeg()" LINK "LoadSeg"}, @{"UnLoadSeg()" LINK "UnLoadSeg"}

@ENDNODE
@NODE "CurrentDir" "dos.library/CurrentDir()"
@{b}

    NAME@{ub}
        @{"CurrentDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 111} -- Make a directory lock the current directory@{b}

    SYNOPSIS@{ub}
        oldLock = @{"CurrentDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 111}( lock )
        D0                    D1

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} @{"CurrentDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 111}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

    FUNCTION@{ub}
        @{"CurrentDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 111}() causes a directory associated with a lock to be made
        the current directory.  The old current directory lock is returned.

        A value of zero is a valid result here, this 0 lock represents the
        root of file system that you booted from.

        Any call that has to @{"Open()" LINK "Open"} or @{"Lock()" LINK "Lock"} files (etc) requires that
        the current directory be a valid lock or 0.@{b}

    INPUTS@{ub}
        lock - BCPL pointer to a lock@{b}

    RESULTS@{ub}
        oldLock - BCPL pointer to a lock@{b}

    SEE ALSO@{ub}
        @{"Lock()" LINK "Lock"}, @{"UnLock()" LINK "UnLock"}, @{"Open()" LINK "Open"}, @{"DupLock()" LINK "DupLock"}

@ENDNODE
@NODE "DateStamp" "dos.library/DateStamp()"
@{b}

    NAME@{ub}
        @{"DateStamp" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 147} -- Obtain the date and time in internal format@{b}

    SYNOPSIS@{ub}
        ds = @{"DateStamp" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 147}( ds );
        D0              D1

        @{"struct DateStamp" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 52} *@{"DateStamp" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 147}(@{"struct DateStamp" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 52} *)@{b}

    FUNCTION@{ub}
        @{"DateStamp" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 147}() takes a structure of three longwords that is set to the
        current time.  The first element in the vector is a count of the
        number of days.  The second element is the number of minutes elapsed
        in the day.  The third is the number of ticks elapsed in the current
        minute.  A tick happens 50 times a second.  @{"DateStamp" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 147}() ensures that
        the day and minute are consistent.  All three elements are zero if
        the date is unset. @{"DateStamp" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 147}() currently only returns even
        multiples of 50 ticks.  Therefore the time you get is always an even
        number of ticks.

        Time is measured from Jan 1, 1978.@{b}

    INPUTS@{ub}
        ds - pointer a @{"struct DateStamp" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 52}@{b}

    RESULTS@{ub}
        The array is filled as described and returned (for pre-V36
        compabability).@{b}

    SEE ALSO@{ub}
        @{"DateToStr()" LINK "DateToStr"}, @{"StrToDate()" LINK "StrToDate"}, @{"SetFileDate()" LINK "SetFileDate"}, @{"CompareDates()" LINK "CompareDates"}

@ENDNODE
@NODE "DateToStr" "dos.library/DateToStr()"
@{b}

   NAME@{ub}
        @{"DateToStr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 562} -- Converts a @{"DateStamp" LINK "DateStamp"} to a string (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"DateToStr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 562}( datetime )
        D0                      D1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"DateToStr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 562}(@{"struct DateTime" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 25} *)@{b}

   FUNCTION@{ub}
        @{"DateToStr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 562} converts an AmigaDOS @{"DateStamp" LINK "DateStamp"} to a human
        readable ASCII string as requested by your settings in the
        DateTime structure.@{b}

   INPUTS@{ub}
        DateTime - a pointer to an initialized DateTime structure.

        The DateTime structure should be initialized as follows:

        dat_Stamp - a copy of the datestamp you wish to convert to
                  ascii.

        dat_Format - a format   byte which specifies the format of the
                  dat_StrDate.  This can be any of the following
                  (note: If value used is something other than those
                  below, the default of @{"FORMAT_DOS" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 48} is used):

                  @{"FORMAT_DOS" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 48}:     AmigaDOS format (dd-mmm-yy).

                  @{"FORMAT_INT" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 49}:     International format (yy-mmm-dd).

                  @{"FORMAT_USA" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 50}:     American format (mm-dd-yy).

                  @{"FORMAT_CDN" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 51}:     Canadian format (dd-mm-yy).

                  @{"FORMAT_DEF" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 53}:     default format for locale.

        dat_Flags - a   flags byte.  The only flag which affects this
                  function is:

                  @{"DTF_SUBST" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 40}:      If set, a string such as Today,
                                  Monday, etc., will be used instead
                                  of the dat_Format specification if
                                  possible.
                  @{"DTF_FUTURE" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 42}:     Ignored by this function.

        dat_StrDay - pointer to a buffer to receive the day of the
                  week string.  (Monday, Tuesday, etc.). If null, this
                  string will not be generated.

        dat_StrDate -   pointer to a buffer to receive the date
                  string, in the format requested by dat_Format,
                  subject to possible modifications by @{"DTF_SUBST" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 40}.  If
                  null, this string will not be generated.

        dat_StrTime -   pointer to a buffer to receive the time of day
                  string. If @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, this will not be generated.@{b}

   RESULT@{ub}
        success - a zero return indicates that the @{"DateStamp" LINK "DateStamp"} was
                  invalid, and could not be converted.  Non-zero
                  indicates that the call succeeded.@{b}

   SEE ALSO@{ub}
        @{"DateStamp()" LINK "DateStamp"}, StrtoDate(), <@{"dos/datetime.h" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File"}>

@ENDNODE
@NODE "Delay" "dos.library/Delay()"
@{b}

    NAME@{ub}
        Delay -- Delay a process for a specified time@{b}

    SYNOPSIS@{ub}
        Delay( ticks )
               D1

        void Delay(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{b}

    FUNCTION@{ub}
        The argument 'ticks' specifies how many ticks (50 per second) to
        wait before returning control.@{b}

    INPUTS@{ub}
        ticks - integer@{b}

    BUGS@{ub}
        Due to a bug in the @{"timer.device" LINK "gg:doc/NDK/Guide/timer/MAIN"} in V1.2/V1.3, specifying a timeout
        of zero for Delay() can cause the unreliable timer & floppy disk
        operation.  This is fixed in V36 and later.@{b}

    SEE ALSO@{ub}

@ENDNODE
@NODE "DeleteFile" "dos.library/DeleteFile()"
@{b}

    NAME@{ub}
        @{"DeleteFile" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 75} -- Delete a file or directory@{b}

    SYNOPSIS@{ub}
        success = @{"DeleteFile" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 75}( name )
        D0                    D1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"DeleteFile" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 75}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

    FUNCTION@{ub}
        This attempts to delete the file or directory specified by 'name'.
        An error is returned if the deletion fails. Note that all the files
        within a directory must be deleted before the directory itself can
        be deleted.@{b}

    INPUTS@{ub}
        name - pointer to a null-terminated string@{b}

    RESULTS@{ub}
        success - boolean@{b}

    SEE ALSO@{ub}

@ENDNODE
@NODE "DeleteVar" "dos.library/DeleteVar()"
@{b}

   NAME@{ub}
        @{"DeleteVar" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 673} -- Deletes a local or environment variable (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"DeleteVar" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 673}( name, flags )
        D0                    D1    D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"DeleteVar" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 673}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} )@{b}

   FUNCTION@{ub}
        Deletes a local or environment variable.@{b}

   INPUTS@{ub}
        name   - pointer to an variable name.  Note variable names follow
                 filesystem syntax and semantics.
        flags  - combination of type of var to delete (low 8 bits), and
                 flags to control the behavior of this routine.  Currently
                 defined flags include:

                 @{"GVF_LOCAL_ONLY" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File" 50}  - delete a local (to your process) variable.
                 @{"GVF_GLOBAL_ONLY" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File" 48} - delete a global environment variable.

                 The default is to delete a local variable if found, otherwise
                 a global environment variable if found (only for @{"LV_VAR" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File" 38}).@{b}

   RESULT@{ub}
        success - If non-zero, the variable was sucessfully deleted, @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}
                  indicates failure.@{b}

   BUGS@{ub}
        @{"LV_VAR" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File" 38} is the only type that can be global@{b}

   SEE ALSO@{ub}
        @{"GetVar()" LINK "GetVar"}, @{"SetVar()" LINK "SetVar"}, @{"FindVar()" LINK "FindVar"}, @{"DeleteFile()" LINK "DeleteFile"}, <@{"dos/var.h" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File"}>

@ENDNODE
@NODE "DeviceProc" "dos.library/DeviceProc()"
@{b}

    NAME@{ub}
        @{"DeviceProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 135} -- Return the process MsgPort of specific I/O handler@{b}

    SYNOPSIS@{ub}
        process = @{"DeviceProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 135}( name )
        D0                    D1

        @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *@{"DeviceProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 135} (@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

    FUNCTION@{ub}
        @{"DeviceProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 135}() returns the process identifier of the process which
        handles the device associated with the specified name. If no
        process handler can be found then the result is zero. If the name
        refers to an assign then a directory lock is returned in @{"IoErr()" LINK "IoErr"}.
        This lock should not be @{"UnLock()" LINK "UnLock"}ed or @{"Examine()" LINK "Examine"}ed (if you wish to do
        so, @{"DupLock()" LINK "DupLock"} it first).@{b}

    BUGS@{ub}
        In V36, if you try to @{"DeviceProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 135}() something relative to an assign
        made with @{"AssignPath()" LINK "AssignPath"}, it will fail.  This is because there's no
        way to know when to unlock the lock.  If you're writing code for
        V36 or later, it is highly advised you use @{"GetDeviceProc()" LINK "GetDeviceProc"} instead,
        or make your code conditional on V36 to use @{"GetDeviceProc()" LINK "GetDeviceProc"}/
        @{"FreeDeviceProc()" LINK "FreeDeviceProc"}.@{b}

    SEE ALSO@{ub}
        @{"GetDeviceProc()" LINK "GetDeviceProc"}, @{"FreeDeviceProc()" LINK "FreeDeviceProc"}, @{"DupLock()" LINK "DupLock"}, @{"UnLock()" LINK "UnLock"}, @{"Examine()" LINK "Examine"}

@ENDNODE
@NODE "DoPkt" "dos.library/DoPkt()"
@{b}

   NAME@{ub}
        @{"DoPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 186} -- Send a dos packet and wait for reply (V36)@{b}

   SYNOPSIS@{ub}
        result1 = @{"DoPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 186}(port,action,arg1,arg2,arg3,arg4,arg5)
        D0               D1    D2    D3   D4   D5   D6   D7

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"DoPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 186}(@{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *,@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        Sends a packet to a handler and waits for it to return.  Any secondary
        return will be available in D1 AND from @{"IoErr()" LINK "IoErr"}.  @{"DoPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 186}() will work
        even if the caller is an exec task and not a process; however it will
        be slower, and may fail for some additional reasons, such as being
        unable to allocate a signal.  @{"DoPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 186}() uses your pr_MsgPort for the
        reply, and will call pr_PktWait.  (See BUGS regarding tasks, though).

        Only allows 5 arguments to be specified.  For more arguments (packets
        support a maximum of 7) create a packet and use @{"SendPkt()" LINK "SendPkt"}/@{"WaitPkt()" LINK "WaitPkt"}.@{b}

   INPUTS@{ub}
        port    - pr_MsgPort of the handler process to send to.
        action  - the action requested of the filesystem/handler
        arg1, arg2, arg3, arg4,arg5 - arguments, depend on the action, may not
                   be required.@{b}

   RESULT@{ub}
        result1 - the value returned in dp_Res1, or @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if there was some
                  problem in sending the packet or recieving it.
        result2 - Available from @{"IoErr()" LINK "IoErr"} AND in register D1.@{b}

   BUGS@{ub}
        Using @{"DoPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 186}() from tasks doesn't work in V36. Use @{"AllocDosObject()" LINK "AllocDosObject"},
        @{"PutMsg()" LINK "gg:doc/NDK/Guide/exec/PutMsg"}, and @{"WaitPort()" LINK "gg:doc/NDK/Guide/exec/WaitPort"}/@{"GetMsg()" LINK "gg:doc/NDK/Guide/exec/GetMsg"} for a workaround, or you can call
        @{"CreateNewProc()" LINK "CreateNewProc"} to start a process to do Dos I/O for you.  In V37,
        @{"DoPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 186}() will allocate, use, and free the MsgPort required.@{b}

   NOTES@{ub}
        Callable from a task (under V37 and above).@{b}

   SEE ALSO@{ub}
        @{"AllocDosObject()" LINK "AllocDosObject"}, @{"FreeDosObject()" LINK "FreeDosObject"}, @{"SendPkt()" LINK "SendPkt"}, @{"WaitPkt()" LINK "WaitPkt"},
        @{"CreateNewProc()" LINK "CreateNewProc"}, @{"AbortPkt()" LINK "AbortPkt"}

@ENDNODE
@NODE "DupLock" "dos.library/DupLock()"
@{b}

    NAME@{ub}
        @{"DupLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 91} -- Duplicate a lock@{b}

    SYNOPSIS@{ub}
        lock = @{"DupLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 91}( lock )
        D0              D1

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} @{"DupLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 91}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

    FUNCTION@{ub}
        @{"DupLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 91}() is passed a shared filing system lock.  This is the ONLY
        way to obtain a duplicate of a lock... simply copying is not
        allowed.

        Another lock to the same object is then returned.  It is not
        possible to create a copy of a exclusive lock.

        A zero return indicates failure.@{b}

    INPUTS@{ub}
        lock - BCPL pointer to a lock@{b}

    RESULTS@{ub}
        newLock - BCPL pointer to a lock@{b}

    SEE ALSO@{ub}
        @{"Lock()" LINK "Lock"}, @{"UnLock()" LINK "UnLock"}, @{"DupLockFromFH()" LINK "DupLockFromFH"}, @{"ParentOfFH()" LINK "ParentOfFH"}

@ENDNODE
@NODE "DupLockFromFH" "dos.library/DupLockFromFH()"
@{b}

   NAME@{ub}
        @{"DupLockFromFH" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 304} -- Gets a lock on an open file (V36)@{b}

   SYNOPSIS@{ub}
        lock = @{"DupLockFromFH" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 304}(fh)
        D0                   D1

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} @{"DupLockFromFH" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 304}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

   FUNCTION@{ub}
        Obtain a lock on the object associated with fh.  Only works if the
        file was opened using a non-exclusive mode.  Other restrictions may be
        placed on success by the filesystem.@{b}

   INPUTS@{ub}
        fh   - Opened file for which to obtain the lock@{b}

   RESULT@{ub}
        lock - Obtained lock or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for failure@{b}

   SEE ALSO@{ub}
        @{"DupLock()" LINK "DupLock"}, @{"Lock()" LINK "Lock"}, @{"UnLock()" LINK "UnLock"}

@ENDNODE
@NODE "EndNotify" "dos.library/EndNotify()"
@{b}

   NAME@{ub}
        @{"EndNotify" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 661} -- Ends a notification request (V36)@{b}

   SYNOPSIS@{ub}
        @{"EndNotify" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 661}(notifystructure)
                        D1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"EndNotify" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 661}(@{"struct NotifyRequest" LINK "gg:doc/NDK/Guide/Include/dos/notify.h/File" 51} *)@{b}

   FUNCTION@{ub}
        Removes a notification request.  Safe to call even if @{"StartNotify()" LINK "StartNotify"}
        failed.  For @{"NRF_SEND_MESSAGE" LINK "gg:doc/NDK/Guide/Include/dos/notify.h/File" 78}, it searches your port for any messages
        about the object in question and removes and replies them before
        returning.@{b}

   INPUTS@{ub}
        notifystructure - a structure passed to @{"StartNotify()" LINK "StartNotify"}@{b}

   SEE ALSO@{ub}
        @{"StartNotify()" LINK "StartNotify"}, <@{"dos/notify.h" LINK "gg:doc/NDK/Guide/Include/dos/notify.h/File"}>

@ENDNODE
@NODE "ErrorReport" "dos.library/ErrorReport()"
@{b}

   NAME@{ub}
        @{"ErrorReport" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 376} -- Displays a Retry/Cancel requester for an error (V36)@{b}

   SYNOPSIS@{ub}
        status = @{"ErrorReport" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 376}(code, type, arg1, device)
        D0                    D1    D2    D3     D4

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"ErrorReport" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 376}(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *)@{b}

   FUNCTION@{ub}
        Based on the request type, this routine formats the appropriate
        requester to be displayed.  If the code is not understood, it returns
        DOS_TRUE immediately.  Returns DOS_TRUE if the user selects CANCEL or
        if the attempt to put up the requester fails, or if the process
        pr_WindowPtr is -1.  Returns @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if the user selects Retry.  The
        routine will retry on @{"DISKINSERTED" LINK "gg:doc/NDK/Guide/Include/intuition/iobsolete.h/File" 124} for appropriate error codes.
        These return values are the opposite of what @{"AutoRequest" LINK "gg:doc/NDK/Guide/intuition/AutoRequest"} returns.

        Note: this routine sets @{"IoErr()" LINK "IoErr"} to code before returning.@{b}

   INPUTS@{ub}
        code   - Error code to put a requester up for.
           Current valid error codes are:
                @{"ERROR_DISK_NOT_VALIDATED" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 203}
                @{"ERROR_DISK_WRITE_PROTECTED" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 204}
                @{"ERROR_DISK_FULL" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 211}
                @{"ERROR_DEVICE_NOT_MOUNTED" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 208}
                @{"ERROR_NOT_A_DOS_DISK" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 215}
                @{"ERROR_NO_DISK" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 216}
                @{"ABORT_DISK_ERROR" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 472}        /* read/write error */
                @{"ABORT_BUSY" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 473}              /* you MUST replace... */
        type   - Request type:
                       @{"REPORT_LOCK" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 467}   - arg1 is a lock (@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}).
                       REPORT_FH     - arg1 is a filehandle (@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}).
                        @{"REPORT_VOLUME" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 468} - arg1 is a volumenode (C pointer).
                        @{"REPORT_INSERT" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 469} - arg1 is the string for the volumename
                                        (will be split on a ':').
                                        With @{"ERROR_DEVICE_NOT_MOUNTED" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 208} puts
                                        up the "Please insert..." requester.
        arg1   - variable parameter (see type)
        device - (Optional) Address of handler task for which report is to be
                made.  Only required for @{"REPORT_LOCK" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 467}, and only if arg1==@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   RESULT@{ub}
        status - Cancel/Retry indicator (0 means Retry)@{b}

   SEE ALSO@{ub}
        @{"Fault()" LINK "Fault"}, @{"IoErr()" LINK "IoErr"}

@ENDNODE
@NODE "ExAll" "dos.library/ExAll()"
@{b}

   NAME@{ub}
        @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344} -- Examine an entire directory (V36)@{b}

   SYNOPSIS@{ub}
        continue = @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344}(lock, buffer, size, type, control)
        D0               D1     D2     D3    D4     D5

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130},@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51},@{"struct ExAllControl" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 70} *)@{b}

   FUNCTION@{ub}
        Examines an entire directory.

        Lock must be on a directory.  Size is the size of the buffer supplied.
        The buffer will be filled with (partial) ExAllData structures, as
        specified by the type field.

        Type is a value from those shown below that determines which information is
        to be stored in the buffer.  Each higher value adds a new thing to the list
        as described in the table below:-

               @{"ED_NAME" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 32}         FileName
               @{"ED_TYPE" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 33}         Type
               @{"ED_SIZE" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 34}         Size in bytes
               @{"ED_PROTECTION" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 35}   Protection bits
               @{"ED_DATE" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 36}         3 longwords of date
               @{"ED_COMMENT" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 37}      Comment (will be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if no comment)
                               Note: the V37 ROM/disk filesystem returns this
                               incorrectly as a @{"BSTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 131}.  See BUGS for a workaround.
               @{"ED_OWNER" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 38}        owner user-id and group-id (if supported)  (V39)

        Thus, @{"ED_NAME" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 32} gives only filenames, and @{"ED_OWNER" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 38} gives everything.

        NOTE: V37 dos.library, when doing @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344}() emulation, and RAM: filesystem
        will return an error if passed @{"ED_OWNER" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 38}.  If you get @{"ERROR_BAD_NUMBER" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 184},
        retry with @{"ED_COMMENT" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 37} to get everything but owner info.  All filesystems
        supporting @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344}() must support through @{"ED_COMMENT" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 37}, and must check Type
        and return @{"ERROR_BAD_NUMBER" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 184} if they don't support the type.

        The V37 ROM/disk filesystem doesn't fill in the comment field correctly
        if you specify @{"ED_OWNER" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 38}.  See BUGS for a workaround if you need to use
        @{"ED_OWNER" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 38}.

        The ead_Next entry gives a pointer to the next entry in the buffer.  The
        last entry will have @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} in ead_Next.

        The control structure is required so that FFS can keep track if more than
        one call to @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344} is required.  This happens when there are more names in
        a directory than will fit into the buffer.  The format of the control
        structure is as follows:-

        NOTE: the control structure MUST be allocated by @{"AllocDosObject" LINK "AllocDosObject"}!!!

        Entries:  This field tells the calling application how many entries are
                   in the buffer after calling @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344}.  Note: make sure your code
                   handles the 0 entries case, including 0 entries with continue
                   non-zero.

        LastKey:  This field ABSOLUTELY MUST be initialised to 0 before calling
                   @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344} for the first time.  Any other value will cause nasty
                   things to happen.  If @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344} returns non-zero, then this field
                   should not be touched before making the second and subsequent
                   calls to @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344}.  Whenever @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344} returns non-zero, there are more
                   calls required before all names have been received.

                   As soon as a @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} return is received then @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344} has completed
                   (if @{"IoErr()" LINK "IoErr"} returns @{"ERROR_NO_MORE_ENTRIES" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 217} - otherwise it returns
                   the error that occured, similar to @{"ExNext" LINK "ExNext"}.)

        MatchString
                   If this field is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} then all filenames will be returned.  If
                   this field is non-null then it is interpreted as a pointer to
                   a string that is used to pattern match all file names before
                   accepting them and putting them into the buffer.  The default
                   AmigaDOS caseless pattern match routine is used.  This string
                   MUST have been parsed by @{"ParsePatternNoCase()" LINK "ParsePatternNoCase"}!

        MatchFunc:
                   Contains a pointer to a hook for a routine to decide if the entry
                   will be included in the returned list of entries.  The entry is
                   filled out first, and then passed to the hook.  If no MatchFunc is
                   to be called then this entry should be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.  The hook is
                   called with the following parameters (as is standard for hooks):

                   @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} = MatchFunc( hookptr, data, typeptr )
                                       a0      a1      a2
                   (a0 = ptr to hook, a1 = ptr to filled in ExAllData, a2 = ptr
                    to longword of type).

                   MatchFunc should return @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if the entry is not to be
                   accepted, otherwise return @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95}.

               Note that Dos will emulate @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344}() using @{"Examine()" LINK "Examine"} and @{"ExNext()" LINK "ExNext"}
               if the handler in question doesn't support the @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344}() packet.@{b}

   INPUTS@{ub}
        lock    - Lock on directory to be examined.
        buffer  - Buffer for data returned (MUST be at least word-aligned,
                  preferably long-word aligned).
        size    - Size in bytes of 'buffer'.
        type    - Type of data to be returned.
        control - Control data structure (see notes above).  MUST have been
                  allocated by @{"AllocDosObject" LINK "AllocDosObject"}!@{b}

   RESULT@{ub}
        continue - Whether or not @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344} is done.  If @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} is returned, either
                   @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344} has completed (@{"IoErr()" LINK "IoErr"} == @{"ERROR_NO_MORE_ENTRIES" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 217}), or
                   an error occurred (check @{"IoErr()" LINK "IoErr"}).  If non-zero is returned,
                   you MUST call @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344} again until it returns @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}.@{b}

   EXAMPLE@{ub}

        eac = @{"AllocDosObject" LINK "AllocDosObject"}(@{"DOS_EXALLCONTROL" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 274},@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101});
        if (!eac) ...
        ...
        eac->eac_LastKey = 0;
        do {
            more = @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344}(lock, EAData, sizeof(EAData), ED_FOO, eac);
            if ((!more) && (@{"IoErr()" LINK "IoErr"} != @{"ERROR_NO_MORE_ENTRIES" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 217})) {
                \\* @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344} failed abnormally *\\
                break;
            }
            if (eac->eac_Entries == 0) {
                \\* @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344} failed normally with no entries *\\
                continue;                   \\* ("more" is *usually* zero) *\\
            }
            ead = (@{"struct ExAllData" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 45} *) EAData;
            do {
                \\* use ead here *\\
                ...
                \\* get next ead *\\
                ead = ead->ed_Next;
            } while (ead);

        } while (more);
        ...
        @{"FreeDosObject" LINK "FreeDosObject"}(@{"DOS_EXALLCONTROL" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 274},eac);@{b}

   BUGS@{ub}
        In V36, there were problems with @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344} (particularily with
        eac_MatchString, and ed_Next with the ramdisk and the emulation
        of it in Dos for handlers that do not support the packet.  It is
        advised you only use this under V37 and later.

        The V37 ROM/disk filesystem incorrectly returned comments as @{"BSTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 131}'s
        (length plus characters) instead of CSTR's (null-terminated).  See
        the next bug for a way to determine if the filesystem is a V37
        ROM/disk filesystem.  Fixed in V39.

        The V37 ROM/disk filesystem incorrectly handled values greater than
        @{"ED_COMMENT" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 37}.  Because of this, @{"ExAll" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 344}() information is trashed if
        @{"ED_OWNER" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 38} is passed to it.  Fixed in V39.  To work around this, use
        the following code to identify if a filesystem is a V37 ROM/disk
        filesystem:

        // return @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if this is a V37 ROM filesystem, which doesn't (really)
        // support @{"ED_OWNER" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 38} safely

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} CheckV37(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} lock)
        {
               @{"struct FileLock" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 456} *l = @{"BADDR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 135}(lock);
               @{"struct Resident" LINK "gg:doc/NDK/Guide/Include/exec/resident.h/File" 18} *resident;
               @{"struct DosList" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 372} *dl;
               @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} result = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};

               dl = @{"LockDosList" LINK "LockDosList"}(@{"LDF_READ" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 448}|@{"LDF_DEVICES" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 436});

               // if the lock has a volume and no device, we won't find it,
               // so we know it's not a V37 ROM/disk filesystem
               do {
                   dl = @{"NextDosEntry" LINK "NextDosEntry"}(dl,@{"LDF_READ" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 448}|@{"LDF_DEVICES" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 436});
                   if (dl && (dl->dol_Task == l->fl_Task))
                   {
                       // found the filesystem - test isn't actually required,
                       // but we know the filesystem we're looking for will always
                       // have a startup msg.  If we needed to examine the message,
                       // we would need a _bunch_ of checks to make sure it's not
                       // either a small value (like @{"port-handler" LINK "gg:doc/NDK/Guide/port-handler/MAIN"} uses) or a @{"BSTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 131}.
                       if (dl->dol_misc.dol_handler.dol_Startup)
                       {
                               // try to make sure it's the ROM fs or l:FastFileSystem
                               if (resident =
                                   FindRomTag(dl->dol_misc.dol_handler.dol_SegList))
                               {
                                       if (resident->rt_Version < 39 &&
                                           (strncmp(resident->rt_IdString,"fs 37.",
                                                    strlen("fs 37.")) == 0 ||
                                            strncmp(resident->rt_Name,"ffs 37.",
                                                    strlen("ffs 37.")) == 0))
                                       {
                                               result = @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95};
                                       }
                               }
                       }
                       break;
                   }
               } while (dl);

               @{"UnLockDosList" LINK "UnLockDosList"}(@{"LDF_READ" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 448}|@{"LDF_DEVICES" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 436});

               return result;
        }@{b}


   SEE ALSO@{ub}
        @{"Examine()" LINK "Examine"}, @{"ExNext()" LINK "ExNext"}, @{"ExamineFH()" LINK "ExamineFH"}, @{"MatchPatternNoCase()" LINK "MatchPatternNoCase"},
        @{"ParsePatternNoCase()" LINK "ParsePatternNoCase"}, @{"AllocDosObject()" LINK "AllocDosObject"}, @{"ExAllEnd()" LINK "ExAllEnd"}

@ENDNODE
@NODE "ExAllEnd" "dos.library/ExAllEnd()"
@{b}

   NAME@{ub}
        @{"ExAllEnd" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 718} -- Stop an @{"ExAll()" LINK "ExAll"} (V39)@{b}

   SYNOPSIS@{ub}
        @{"ExAllEnd" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 718}(lock, buffer, size, type, control)
                  D1     D2     D3    D4     D5

        @{"ExAllEnd" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 718}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130},@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51},@{"struct ExAllControl" LINK "gg:doc/NDK/Guide/Include/dos/exall.h/File" 70} *)@{b}

   FUNCTION@{ub}
        Stops an @{"ExAll()" LINK "ExAll"} on a directory before it hits NO_MORE_ENTRIES.
        The full set of arguments that had been passed to @{"ExAll()" LINK "ExAll"} must be
        passed to @{"ExAllEnd" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 718}(), so it can handle filesystems that can't abort
        an @{"ExAll()" LINK "ExAll"} directly.@{b}

   INPUTS@{ub}
        lock    - Lock on directory to be examined.
        buffer  - Buffer for data returned (MUST be at least word-aligned,
                  preferably long-word aligned).
        size    - Size in bytes of 'buffer'.
        type    - Type of data to be returned.
        control - Control data structure (see notes above).  MUST have been
                  allocated by @{"AllocDosObject" LINK "AllocDosObject"}!@{b}

   SEE ALSO@{ub}
        @{"ExAll()" LINK "ExAll"}, @{"AllocDosObject()" LINK "AllocDosObject"}

@ENDNODE
@NODE "Examine" "dos.library/Examine()"
@{b}

    NAME@{ub}
        Examine -- Examine a directory or file associated with a lock@{b}

    SYNOPSIS@{ub}
        success = Examine( lock, FileInfoBlock )
        D0                  D1        D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} Examine(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130},@{"struct FileInfoBlock" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 61} *)@{b}

    FUNCTION@{ub}
        Examine() fills in information in the FileInfoBlock concerning the
        file or directory associated with the lock. This information
        includes the name, size, creation date and whether it is a file or
        directory.  FileInfoBlock must be longword aligned.  Examine() gives
        a return code of zero if it fails.

        You may make a local copy of the FileInfoBlock, as long as it is
        never passed to @{"ExNext()" LINK "ExNext"}.@{b}

    INPUTS@{ub}
        lock      - BCPL pointer to a lock
        infoBlock - pointer to a FileInfoBlock (MUST be longword aligned)@{b}

    RESULTS@{ub}
        success - boolean@{b}

    SPECIAL NOTE@{ub}
        FileInfoBlock must be longword-aligned.  @{"AllocDosObject()" LINK "AllocDosObject"} will
        allocate them correctly for you.@{b}

    SEE ALSO@{ub}
        @{"Lock()" LINK "Lock"}, @{"UnLock()" LINK "UnLock"}, @{"ExNext()" LINK "ExNext"}, @{"ExamineFH()" LINK "ExamineFH"}, <@{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"}>, @{"AllocDosObject()" LINK "AllocDosObject"},
        @{"ExAll()" LINK "ExAll"}

@ENDNODE
@NODE "ExamineFH" "dos.library/ExamineFH()"
@{b}

   NAME@{ub}
        @{"ExamineFH" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 316} -- Gets information on an open file (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"ExamineFH" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 316}(fh, fib)
        D0                  D1  D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"ExamineFH" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 316}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"struct FileInfoBlock" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 61} *)@{b}

   FUNCTION@{ub}
        Examines a filehandle and returns information about the file in the
        FileInfoBlock.  There are no guarantees as to whether the fib_Size
        field will reflect any changes made to the file size it was opened,
        though filesystems should attempt to provide up-to-date information
        for it.@{b}

   INPUTS@{ub}
        fh  - Filehandle you wish to examine
        fib - FileInfoBlock, must be longword aligned.@{b}

   RESULT@{ub}
        success - Success/failure indication@{b}

   SEE ALSO@{ub}
        @{"Examine()" LINK "Examine"}, @{"ExNext()" LINK "ExNext"}, @{"ExAll()" LINK "ExAll"}, @{"Open()" LINK "Open"}, @{"AllocDosObject()" LINK "AllocDosObject"}

@ENDNODE
@NODE "Execute" "dos.library/Execute()"
@{b}

    NAME@{ub}
        Execute -- Execute a CLI command@{b}

    SYNOPSIS@{ub}
        success = Execute( commandString, input, output )
        D0                 D1             D2     D3

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} Execute(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

    FUNCTION@{ub}
        This function attempts to execute the string commandString as a
        Shell command and arguments. The string can contain any valid input
        that you could type directly in a Shell, including input and output
        redirection using < and >.  Note that Execute() doesn't return until
        the command(s) in commandstring have returned.

        The input file handle will normally be zero, and in this case
        Execute() will perform whatever was requested in the commandString
        and then return. If the input file handle is nonzero then after the
        (possibly empty) commandString is performed subsequent input is read
        from the specified input file handle until end of that file is
        reached.

        In most cases the output file handle must be provided, and is used
        by the Shell commands as their output stream unless output
        redirection was specified. If the output file handle is set to zero
        then the current window, normally specified as *, is used. Note
        that programs running under the Workbench do not normally have a
        current window.

        Execute() may also be used to create a new interactive Shell process
        just like those created with the NewShell command. In order to do
        this you would call Execute() with an empty commandString, and pass
        a file handle relating to a new window as the input file handle.
        The output file handle would be set to zero. The Shell will read
        commands from the new window, and will use the same window for
        output. This new Shell window can only be terminated by using the
        EndCLI command.

        Under V37, if an input filehandle is passed, and it's either
        interactive or a NIL: filehandle, the pr_ConsoleTask of the new
        process will be set to that filehandle's process (the same applies
        to @{"SystemTagList()" LINK "SystemTagList"}).

        For this command to work the program Run must be present in C: in
        versions before V36 (except that in 1.3.2 and any later 1.3 versions,
        the system first checks the resident list for Run).@{b}

    INPUTS@{ub}
        commandString - pointer to a null-terminated string
        input         - BCPL pointer to a file handle
        output        - BCPL pointer to a file handle@{b}

    RESULTS@{ub}
        success - BOOLEAN indicating whether Execute was successful
                  in finding and starting the specified program.  Note this
                  is @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} the return code of the command(s).@{b}
    SEE ALSO@{ub}
        @{"SystemTagList()" LINK "SystemTagList"}, NewShell, EndCLI, Run

@ENDNODE
@NODE "Exit" "dos.library/Exit()"
@{b}

    NAME@{ub}
        Exit -- Exit from a program@{b}

    SYNOPSIS@{ub}
        Exit( returnCode )
              D1

        void Exit(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

    FUNCTION@{ub}
        Exit() is currently for use with programs written as if they
        were BCPL programs.  This function is not normally useful for
        other purposes.

        In general, therefore, please DO @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} CALL THIS FUNCTION!

        In order to exit, C programs should use the C language exit()
        function (note the lower case letter "e").  Assembly programs should
        place a return code in D0, and execute an RTS instruction with
        their original stack ptr.@{b}

    IMPLEMENTATION@{ub}
        The action of Exit() depends on whether the program which called it
        is running as a command under a CLI or not. If the program is
        running under the CLI the command finishes and control reverts to
        the CLI. In this case, returnCode is interpreted as the return code
        from the program.

        If the program is running as a distinct process, Exit() deletes the
        process and release the space associated with the stack, segment
        list and process structure.@{b}

    INPUTS@{ub}
        returnCode - integer@{b}

    SEE ALSO@{ub}
        @{"CreateProc()" LINK "CreateProc"}, @{"CreateNewProc()" LINK "CreateNewProc"}

@ENDNODE
@NODE "ExNext" "dos.library/ExNext()"
@{b}

    NAME@{ub}
        @{"ExNext" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 99} -- Examine the next entry in a directory@{b}

    SYNOPSIS@{ub}
        success = @{"ExNext" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 99}( lock, FileInfoBlock )
        D0                 D1        D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"ExNext" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 99}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"struct FileInfoBlock" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 61} *)@{b}

    FUNCTION@{ub}
        This routine is passed a directory lock and a FileInfoBlock that
        have been initialized by a previous call to @{"Examine()" LINK "Examine"}, or updated
        by a previous call to @{"ExNext" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 99}().  @{"ExNext" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 99}() gives a return code of zero
        on failure.  The most common cause of failure is reaching the end
        of the list of files in the owning directory.  In this case, @{"IoErr" LINK "IoErr"}
        will return @{"ERROR_NO_MORE_ENTRIES" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 217} and a good exit is appropriate.

        So, follow these steps to examine a directory:
        1) Pass a Lock and a FileInfoBlock to @{"Examine()" LINK "Examine"}.  The lock must
           be on the directory you wish to examine.
        2) Pass @{"ExNext" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 99}() the same lock and FileInfoBlock.
        3) Do something with the information returned in the FileInfoBlock.
           Note that the fib_DirEntryType field is positive for directories,
           negative for files.
        4) Keep calling @{"ExNext" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 99}() until it returns @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}.  Check @{"IoErr()" LINK "IoErr"}
           to ensure that the reason for failure was @{"ERROR_NO_MORE_ENTRIES" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 217}.

        Note: if you wish to recursively scan the file tree and you find
        another directory while @{"ExNext" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 99}()ing you must Lock that directory and
        @{"Examine()" LINK "Examine"} it using a new FileInfoBlock.  Use of the same
        FileInfoBlock to enter a directory would lose important state
        information such that it will be impossible to continue scanning
        the parent directory.  While it is permissible to @{"UnLock()" LINK "UnLock"} and @{"Lock()" LINK "Lock"}
        the parent directory between @{"ExNext" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 99}() calls, this is @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} recommended.
        Important state information is associated with the parent lock, so
        if it is freed between @{"ExNext" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 99}() calls this information has to be
        rebuilt on each new @{"ExNext" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 99}() call, and will significantly slow down
        directory scanning.

        It is @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} legal to @{"Examine()" LINK "Examine"} a file, and then to @{"ExNext" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 99}() from that
        FileInfoBlock.  You may make a local copy of the FileInfoBlock, as
        long as it is never passed back to the operating system.@{b}

    INPUTS@{ub}
        lock - BCPL pointer to a lock originally used for the @{"Examine()" LINK "Examine"} call
        infoBlock - pointer to a FileInfoBlock used on the previous @{"Examine()" LINK "Examine"}
                    or @{"ExNext" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 99}() call.@{b}

    RESULTS@{ub}
        success - boolean@{b}

    SPECIAL NOTE@{ub}
        FileInfoBlock must be longword-aligned.  @{"AllocDosObject()" LINK "AllocDosObject"} will
        allocate them correctly for you.@{b}

    SEE ALSO@{ub}
        @{"Examine()" LINK "Examine"}, @{"Lock()" LINK "Lock"}, @{"UnLock()" LINK "UnLock"}, @{"IoErr()" LINK "IoErr"}, @{"ExamineFH()" LINK "ExamineFH"}, @{"AllocDosObject()" LINK "AllocDosObject"},
        @{"ExAll()" LINK "ExAll"}

@ENDNODE
@NODE "Fault" "dos.library/Fault()"
@{b}

   NAME@{ub}
        Fault -- Returns the text associated with a DOS error code (V36)@{b}

   SYNOPSIS@{ub}
        len = Fault(code, header, buffer, len)
        D0           D1     D2      D3    D4

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} Fault(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        This routine obtains the error message text for the given error code.
        The header is prepended to the text of the error message, followed
        by a colon.  Puts a null-terminated string for the error message into
        the buffer.  By convention, error messages should be no longer than 80
        characters (+1 for termination), and preferably no more than 60.
        The value returned by @{"IoErr()" LINK "IoErr"} is set to the code passed in.  If there
        is no message for the error code, the message will be "Error code
        <number>\\n".

        The number of characters put into the buffer is returned, which will
        be 0 if the code passed in was 0.@{b}

   INPUTS@{ub}
        code   - Error code
        header - header to output before error text
        buffer - Buffer to receive error message.
        len    - Length of the buffer.@{b}

   RESULT@{ub}
        len    - number of characters put into buffer (may be 0)@{b}

   SEE ALSO@{ub}
        @{"IoErr()" LINK "IoErr"}, @{"SetIoErr()" LINK "SetIoErr"}, @{"PrintFault()" LINK "PrintFault"}@{b}

   BUGS@{ub}
        In older documentation, the return was shown as @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} success.  This
        was incorrect, it has always returned the length.

@ENDNODE
@NODE "FGetC" "dos.library/FGetC()"
@{b}

   NAME@{ub}
        @{"FGetC" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 250} -- Read a character from the specified input (buffered) (V36)@{b}

   SYNOPSIS@{ub}
        char = @{"FGetC" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 250}(fh)
        D0           D1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"FGetC" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 250}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

   FUNCTION@{ub}
        Reads the next character from the input stream.  A -1 is
        returned when EOF or an error is encountered.  This call is buffered.
        Use @{"Flush()" LINK "Flush"} between buffered and unbuffered I/O on a filehandle.@{b}

   INPUTS@{ub}
        fh - filehandle to use for buffered I/O@{b}

   RESULT@{ub}
        char - character read (0-255) or -1@{b}

   BUGS@{ub}
        In V36, after an EOF was read, EOF would always be returned from
        @{"FGetC" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 250}() from then on.  Starting in V37, it tries to read from the
        handler again each time (unless @{"UnGetC" LINK "UnGetC"}(fh,-1) was called).@{b}

   SEE ALSO@{ub}
        @{"FPutC()" LINK "FPutC"}, @{"UnGetC()" LINK "UnGetC"}, @{"Flush()" LINK "Flush"}

@ENDNODE
@NODE "FGets" "dos.library/FGets()"
@{b}

   NAME@{ub}
        @{"FGets" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 270} -- Reads a line from the specified input (buffered) (V36)@{b}

   SYNOPSIS@{ub}
        buffer = @{"FGets" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 270}(fh, buf, len)
        D0             D1  D2   D3

        @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} @{"FGets" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 270}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{b}

   FUNCTION@{ub}
        This routine reads in a single line from the specified input stopping
        at a NEWLINE character or EOF.  In either event, UP TO the number of
        len specified bytes minus 1 will be copied into the buffer.  Hence if
        a length of 50 is passed and the input line is longer than 49 bytes,
        it will return 49 characters.  It returns the buffer pointer normally,
        or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if EOF is the first thing read.

        If terminated by a newline, the newline WILL be the last character in
        the buffer.  This is a buffered read routine.  The string read in IS
        null-terminated.@{b}

   INPUTS@{ub}
        fh  - filehandle to use for buffered I/O
        buf - Area to read bytes into.
        len - Number of bytes to read, must be > 0.@{b}

   RESULT@{ub}
        buffer - Pointer to buffer passed in, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for immediate EOF or for
                 an error.  If @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} is returnd for an EOF, @{"IoErr()" LINK "IoErr"} will return
                 0.@{b}

   BUGS@{ub}
        In V36 and V37, it copies one more byte than it should if it doesn't
        hit an EOF or newline.  In the example above, it would copy 50 bytes
        and put a null in the 51st.  This is fixed in dos V39.  Workaround
        for V36/V37: pass in buffersize-1.@{b}

   SEE ALSO@{ub}
        @{"FRead()" LINK "FRead"}, @{"FPuts()" LINK "FPuts"}, @{"FGetC()" LINK "FGetC"}

@ENDNODE
@NODE "FilePart" "dos.library/FilePart()"
@{b}

   NAME@{ub}
        @{"FilePart" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 645} -- Returns the last component of a path (V36)@{b}

   SYNOPSIS@{ub}
        fileptr = @{"FilePart" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 645}( path )
        D0                   D1

        @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} @{"FilePart" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 645}( @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} )@{b}

   FUNCTION@{ub}
        This function returns a pointer to the last component of a string path
        specification, which will normally be the file name.  If there is only
        one component, it returns a pointer to the beginning of the string.@{b}

   INPUTS@{ub}
        path - pointer to an path string.  May be relative to the current
               directory or the current disk.@{b}

   RESULT@{ub}
        fileptr - pointer to the last component of the path.@{b}

   EXAMPLE@{ub}
        @{"FilePart" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 645}("xxx:yyy/zzz/qqq") would return a pointer to the first 'q'.
        @{"FilePart" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 645}("xxx:yyy") would return a pointer to the first 'y').@{b}

   SEE ALSO@{ub}
        @{"PathPart()" LINK "PathPart"}, @{"AddPart()" LINK "AddPart"}

@ENDNODE
@NODE "FindArg" "dos.library/FindArg()"
@{b}

   NAME@{ub}
        @{"FindArg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 609} - find a keyword in a template (V36)@{b}

   SYNOPSIS@{ub}
        index = @{"FindArg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 609}(template, keyword)
        D0                D1        D2

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"FindArg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 609}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

   FUNCTION@{ub}
        Returns the argument number of the keyword, or -1 if it is not a
        keyword for the template.  Abbreviations are handled.@{b}

   INPUTS@{ub}
        keyword  - keyword to search for in template
        template - template string to search@{b}

   RESULT@{ub}
        index - number of entry in template, or -1 if not found@{b}

   BUGS@{ub}
        In earlier published versions of the autodoc, keyword and template
        were backwards.@{b}

   SEE ALSO@{ub}
        @{"ReadArgs()" LINK "ReadArgs"}, @{"ReadItem()" LINK "ReadItem"}, @{"FreeArgs()" LINK "FreeArgs"}

@ENDNODE
@NODE "FindCliProc" "dos.library/FindCliProc()"
@{b}

   NAME@{ub}
        @{"FindCliProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 423} -- returns a pointer to the requested CLI process (V36)@{b}

   SYNOPSIS@{ub}
        proc = @{"FindCliProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 423}(num)
        D0             D1

        @{"struct Process" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 37} *@{"FindCliProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 423}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{b}

   FUNCTION@{ub}
        This routine returns a pointer to the CLI process associated with the
        given CLI number.  If the process isn't an active CLI process, @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} is
        returned.  NOTE: should normally be called inside a @{"Forbid()" LINK "gg:doc/NDK/Guide/exec/Forbid"}, if you
        must use this function at all.@{b}

   INPUTS@{ub}
        num  - Task number of CLI process (range 1-N)@{b}

   RESULT@{ub}
        proc - Pointer to given CLI process@{b}

   SEE ALSO@{ub}
        @{"Cli()" LINK "Cli"}, @{"Forbid()" LINK "gg:doc/NDK/Guide/exec/Forbid"}, @{"MaxCli()" LINK "MaxCli"}

@ENDNODE
@NODE "FindDosEntry" "dos.library/FindDosEntry()"
@{b}

   NAME@{ub}
        @{"FindDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 522} -- Finds a specific Dos List entry (V36)@{b}

   SYNOPSIS@{ub}
        newdlist = @{"FindDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 522}(dlist,name,flags)
        D0                       D1    D2   D3

        @{"struct DosList" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 372} *@{"FindDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 522}(@{"struct DosList" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 372} *,@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{b}

   FUNCTION@{ub}
        Locates an entry on the device list.  Starts with the entry dlist.
        NOTE: must be called with the device list locked, no references may be
        made to dlist after unlocking.@{b}

   INPUTS@{ub}
        dlist    - The device entry to start with.
        name     - Name of device entry (without ':') to locate.
        flags    - Search control flags.  Use the flags you passed to
                   @{"LockDosList" LINK "LockDosList"}, or a subset of them.  @{"LDF_READ" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 448}/@{"LDF_WRITE" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 450} are
                   not required for this call.@{b}

   RESULT@{ub}
        newdlist - The device entry or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}@{b}

   SEE ALSO@{ub}
        @{"AddDosEntry()" LINK "AddDosEntry"}, @{"RemDosEntry()" LINK "RemDosEntry"}, @{"NextDosEntry()" LINK "NextDosEntry"}, @{"LockDosList()" LINK "LockDosList"},
        @{"MakeDosEntry()" LINK "MakeDosEntry"}, @{"FreeDosEntry()" LINK "FreeDosEntry"}

@ENDNODE
@NODE "FindSegment" "dos.library/FindSegment()"
@{b}

   NAME@{ub}
        @{"FindSegment" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 593} - Finds a segment on the resident list (V36)@{b}

   SYNOPSIS@{ub}
        segment = @{"FindSegment" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 593}(name, start, system)
        D0                     D1     D2     D3

        @{"struct Segment" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 299} *@{"FindSegment" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 593}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"struct Segment" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 299} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        Finds a segment on the Dos resident list by name and type, starting
        at the segment AFTER 'start', or at the beginning if start is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.
        If system is zero, it will only return nodes with a seg_UC of 0
        or more.  It does @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} increment the seg_UC, and it does @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} do any
        locking of the list.  You must @{"Forbid()" LINK "gg:doc/NDK/Guide/exec/Forbid"} lock the list to use this
        call.

        To use an entry you have found, you must: if the seg_UC is 0 or more,
        increment it, and decrement it (under @{"Forbid()" LINK "gg:doc/NDK/Guide/exec/Forbid"}!) when you're done
        the the seglist.

        The other values for seg_UC are:
                -1   - system module, such as a filesystem or shell
                -2   - resident shell command
                -999 - disabled internal command, ignore
        Negative values should never be modified.  All other negative
        values between 0 and -32767 are reserved to AmigaDos and should not
        be used.@{b}

   INPUTS@{ub}
        name   - name of segment to find
        start  - segment to start the search after
        system - true for system segment, false for normal segments@{b}

   RESULT@{ub}
        segment - the segment found or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}@{b}

   SEE ALSO@{ub}
        @{"AddSegment()" LINK "AddSegment"}, @{"RemSegment()" LINK "RemSegment"}, @{"Forbid()" LINK "gg:doc/NDK/Guide/exec/Forbid"}

@ENDNODE
@NODE "FindVar" "dos.library/FindVar()"
@{b}

   NAME@{ub}
        @{"FindVar" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 677} -- Finds a local variable (V36)@{b}

   SYNOPSIS@{ub}
        var = @{"FindVar" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 677}( name, type )
        D0              D1    D2

        @{"struct LocalVar" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File" 25} * @{"FindVar" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 677}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} )@{b}

   FUNCTION@{ub}
        Finds a local variable structure.@{b}

   INPUTS@{ub}
        name - pointer to an variable name.  Note variable names follow
               filesystem syntax and semantics.

        type - type of variable to be found (see <@{"dos/var.h" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File"}>)@{b}

   RESULT@{ub}

        var  - pointer to a LocalVar structure or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}@{b}

   SEE ALSO@{ub}
        @{"GetVar()" LINK "GetVar"}, @{"SetVar()" LINK "SetVar"}, @{"DeleteVar()" LINK "DeleteVar"}, <@{"dos/var.h" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File"}>

@ENDNODE
@NODE "Flush" "dos.library/Flush()"
@{b}

   NAME@{ub}
        Flush -- Flushes buffers for a buffered filehandle (V36)@{b}

   SYNOPSIS@{ub}
        success = Flush(fh)
        D0              D1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} Flush(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

   FUNCTION@{ub}
        Flushes any pending buffered writes to the filehandle.  All buffered
        writes will also be flushed on @{"Close()" LINK "Close"}.  If the filehandle was being
        used for input, it drops the buffer, and tries to @{"Seek()" LINK "Seek"} back to the
        last read position  (so subsequent reads or writes will occur at the
        expected position in the file).@{b}

   INPUTS@{ub}
        fh      - Filehandle to flush.@{b}

   RESULT@{ub}
        success - Success or failure.@{b}

   BUGS@{ub}
        Before V37 release, Flush() returned a random value.  As of V37,
        it always returns success (this will be fixed in some future
        release).

        The V36 and V37 releases didn't properly flush filehandles which
        have never had a buffered IO done on them.  This commonly occurs
        on redirection of input of a command, or when opening a file for
        input and then calling @{"CreateNewProc()" LINK "CreateNewProc"} with @{"NP_Arguments" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 87}, or when
        using a new filehandle with @{"SelectInput()" LINK "SelectInput"} and then calling
        @{"RunCommand()" LINK "RunCommand"}.  This is fixed in V39.  A workaround would be to
        do @{"FGetC()" LINK "FGetC"}, then @{"UnGetC()" LINK "UnGetC"}, then Flush().@{b}

   SEE ALSO@{ub}
        FputC(), @{"FGetC()" LINK "FGetC"}, @{"UnGetC()" LINK "UnGetC"}, @{"Seek()" LINK "Seek"}, @{"Close()" LINK "Close"}, @{"CreateNewProc()" LINK "CreateNewProc"},
        @{"SelectInput()" LINK "SelectInput"}, @{"RunCommand()" LINK "RunCommand"}

@ENDNODE
@NODE "Format" "dos.library/Format()"
@{b}

   NAME@{ub}
        Format -- Causes a filesystem to initialize itself (V36)@{b}

   SYNOPSIS@{ub}
        success = Format(filesystem, volumename, dostype)
        D0                   D1          D2         D3

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} Format(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{b}

   FUNCTION@{ub}
        Interface for initializing new media on a device.  This causes the
        filesystem to write out an empty disk structure to the media, which
        should then be ready for use.  This assumes the media has been low-
        level formatted and verified already.

        The filesystem should be inhibited before calling Format() to make
        sure you don't get an @{"ERROR_OBJECT_IN_USE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 193}.@{b}

   INPUTS@{ub}
        filesystem - Name of device to be formatted.  ':' must be supplied.
        volumename - Name for volume (if supported).  No ':'.
        dostype    - Type of format, if filesystem supports multiple types.@{b}

   RESULT@{ub}
        success - Success/failure indicator.@{b}

   BUGS@{ub}
        Existed, but was non-functional in V36 dos.  (The volumename wasn't
        converted to a @{"BSTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 131}.)  Workaround: require V37, or under V36
        convert volumename to a @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} to a @{"BSTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 131} before calling Format().
        Note: a number of printed packet docs for @{"ACTION_FORMAT" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 192} are wrong
        as to the arguments.@{b}

   SEE ALSO@{ub}

@ENDNODE
@NODE "FPutC" "dos.library/FPutC()"
@{b}

   NAME@{ub}
        @{"FPutC" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 254} -- Write a character to the specified output (buffered) (V36)@{b}

   SYNOPSIS@{ub}
        char = @{"FPutC" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 254}(fh, char)
        D0           D1   D2

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"FPutC" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 254}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        Writes a single character to the output stream.  This call is
        buffered.  Use @{"Flush()" LINK "Flush"} between buffered and unbuffered I/O on a
        filehandle.  Interactive filehandles are flushed automatically
        on a newline, return, '\\0', or line feed.@{b}

   INPUTS@{ub}
        fh   - filehandle to use for buffered I/O
        char - character to write@{b}

   RESULT@{ub}
        char - either the character written, or EOF for an error.@{b}

   BUGS@{ub}
        Older autodocs indicated that you should pass a @{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62}.  The
        correct usage is to pass a @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} in the range 0-255.@{b}

   SEE ALSO@{ub}
        @{"FGetC()" LINK "FGetC"}, @{"UnGetC()" LINK "UnGetC"}, @{"Flush()" LINK "Flush"}

@ENDNODE
@NODE "FPuts" "dos.library/FPuts()"
@{b}

   NAME@{ub}
        @{"FPuts" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 274} -- Writes a string the the specified output (buffered) (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"FPuts" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 274}(fh, str)
        D0            D1  D2

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"FPuts" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 274}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

   FUNCTION@{ub}
        This routine writes an unformatted string to the filehandle.  No
        newline is appended to the string.  This routine is buffered.@{b}

   INPUTS@{ub}
        fh    - filehandle to use for buffered I/O
        str   - Null-terminated string to be written to default output@{b}

   RESULT@{ub}
        error - 0 normally, otherwise -1.  Note that this is opposite of
                most other Dos functions, which return success.@{b}

   SEE ALSO@{ub}
        @{"FGets()" LINK "FGets"}, @{"FPutC()" LINK "FPutC"}, @{"FWrite()" LINK "FWrite"}, @{"PutStr()" LINK "PutStr"}

@ENDNODE
@NODE "FRead" "dos.library/FRead()"
@{b}

   NAME@{ub}
        @{"FRead" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 262} -- Reads a number of blocks from an input (buffered) (V36)@{b}

   SYNOPSIS@{ub}
        count = @{"FRead" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 262}(fh, buf, blocklen, blocks)
        D0            D1  D2     D3        D4

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"FRead" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 262}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{b}

   FUNCTION@{ub}
        Attempts to read a number of blocks, each blocklen long, into the
        specified buffer from the input stream.  May return less than
        the number of blocks requested, either due to EOF or read errors.
        This call is buffered.@{b}

   INPUTS@{ub}
        fh       - filehandle to use for buffered I/O
        buf      - Area to read bytes into.
        blocklen - number of bytes per block.  Must be > 0.
        blocks   - number of blocks to read.  Must be > 0.@{b}

   RESULT@{ub}
        count - Number of _blocks_ read, or 0 for EOF.  On an error, the
                number of blocks actually read is returned.@{b}

   BUGS@{ub}
        Doesn't clear @{"IoErr()" LINK "IoErr"} before starting.  If you want to find out
        about errors, use @{"SetIoErr" LINK "SetIoErr"}(0L) before calling.@{b}

   SEE ALSO@{ub}
        @{"FGetC()" LINK "FGetC"}, @{"FWrite()" LINK "FWrite"}, @{"FGets()" LINK "FGets"}

@ENDNODE
@NODE "FreeArgs" "dos.library/FreeArgs()"
@{b}

   NAME@{ub}
        @{"FreeArgs" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 641} - Free allocated memory after @{"ReadArgs()" LINK "ReadArgs"} (V36)@{b}

   SYNOPSIS@{ub}
        @{"FreeArgs" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 641}(rdargs)
                   D1

        void @{"FreeArgs" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 641}(@{"struct RDArgs" LINK "gg:doc/NDK/Guide/Include/dos/rdargs.h/File" 95} *)@{b}

   FUNCTION@{ub}
        Frees memory allocated to return arguments in from @{"ReadArgs()" LINK "ReadArgs"}.  If
        @{"ReadArgs" LINK "ReadArgs"} allocated the RDArgs structure it will be freed.  If @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
        is passed in this function does nothing.@{b}

   INPUTS@{ub}
        rdargs - structure returned from @{"ReadArgs()" LINK "ReadArgs"} or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"ReadArgs()" LINK "ReadArgs"}, @{"ReadItem()" LINK "ReadItem"}, @{"FindArg()" LINK "FindArg"}

@ENDNODE
@NODE "FreeDeviceProc" "dos.library/FreeDeviceProc()"
@{b}

   NAME@{ub}
        @{"FreeDeviceProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 498} -- Releases port returned by @{"GetDeviceProc()" LINK "GetDeviceProc"} (V36)@{b}

   SYNOPSIS@{ub}
        @{"FreeDeviceProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 498}(devproc)
                         D1

        void @{"FreeDeviceProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 498}(@{"struct DevProc" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 421} *)@{b}

   FUNCTION@{ub}
        Frees up the structure created by @{"GetDeviceProc()" LINK "GetDeviceProc"}, and any associated
        temporary locks.

        Decrements the counter incremented by @{"GetDeviceProc()" LINK "GetDeviceProc"}.  The counter
        is in an extension to the 1.3 process structure.  After calling
        @{"FreeDeviceProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 498}(), do not use the port or lock again!  It is safe to
        call @{"FreeDeviceProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 498}(@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}).@{b}

   INPUTS@{ub}
        devproc - A value returned by @{"GetDeviceProc()" LINK "GetDeviceProc"}@{b}

   BUGS@{ub}
        Counter not currently active in 2.0.@{b}

   SEE ALSO@{ub}
        @{"GetDeviceProc()" LINK "GetDeviceProc"}, @{"DeviceProc()" LINK "DeviceProc"}, @{"AssignLock()" LINK "AssignLock"}, @{"AssignLate()" LINK "AssignLate"},
        @{"AssignPath()" LINK "AssignPath"}

@ENDNODE
@NODE "FreeDosEntry" "dos.library/FreeDosEntry()"
@{b}

   NAME@{ub}
        @{"FreeDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 534} -- Frees an entry created by @{"MakeDosEntry" LINK "MakeDosEntry"} (V36)@{b}

   SYNOPSIS@{ub}
        @{"FreeDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 534}(dlist)
                       D1

        void @{"FreeDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 534}(@{"struct DosList" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 372} *)@{b}

   FUNCTION@{ub}
        Frees an entry created by @{"MakeDosEntry()" LINK "MakeDosEntry"}.  This routine should be
        eliminated and replaced by a value passed to @{"FreeDosObject()" LINK "FreeDosObject"}!@{b}

   INPUTS@{ub}
        dlist - DosList to free.@{b}

   SEE ALSO@{ub}
        @{"AddDosEntry()" LINK "AddDosEntry"}, @{"RemDosEntry()" LINK "RemDosEntry"}, @{"FindDosEntry()" LINK "FindDosEntry"}, @{"LockDosList()" LINK "LockDosList"},
        @{"NextDosEntry()" LINK "NextDosEntry"}, @{"MakeDosEntry()" LINK "MakeDosEntry"}

@ENDNODE
@NODE "FreeDosObject" "dos.library/FreeDosObject()"
@{b}

   NAME@{ub}
        @{"FreeDosObject" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 182} -- Frees an object allocated by @{"AllocDosObject()" LINK "AllocDosObject"} (V36)@{b}

   SYNOPSIS@{ub}
        @{"FreeDosObject" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 182}(type, ptr)
                       D1   D2

        void @{"FreeDosObject" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 182}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, void *)@{b}

   FUNCTION@{ub}
        Frees an object allocated by @{"AllocDosObject()" LINK "AllocDosObject"}.  Do @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} call for
        objects allocated in any other way.@{b}

   INPUTS@{ub}
        type - type passed to @{"AllocDosObject()" LINK "AllocDosObject"}
        ptr  - ptr returned by @{"AllocDosObject()" LINK "AllocDosObject"}@{b}

   BUGS@{ub}
        Before V39, @{"DOS_CLI" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 277} objects will only have the struct
        @{"CommandLineInterface" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 314} freed, not the strings it points to.  This
        is fixed in V39 dos.  Before V39, you can workaround this bug by
        using @{"FreeVec()" LINK "gg:doc/NDK/Guide/exec/FreeVec"} on cli_SetName, cli_CommandFile, cli_CommandName,
        and cli_Prompt, and then setting them all to @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.  In V39 or
        above, do @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} use the workaround.@{b}

   SEE ALSO@{ub}
        @{"AllocDosObject()" LINK "AllocDosObject"}, @{"FreeVec()" LINK "gg:doc/NDK/Guide/exec/FreeVec"}, <@{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"}>

@ENDNODE
@NODE "FWrite" "dos.library/FWrite()"
@{b}

   NAME@{ub}
        @{"FWrite" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 266} -- Writes a number of blocks to an output (buffered) (V36)@{b}

   SYNOPSIS@{ub}
        count = @{"FWrite" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 266}(fh, buf, blocklen, blocks)
        D0             D1  D2     D3        D4

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"FWrite" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 266}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{b}

   FUNCTION@{ub}
        Attempts to write a number of blocks, each blocklen long, from the
        specified buffer to the output stream.  May return less than the
        number of blocks requested, if there is some error such as a full
        disk or r/w error.  This call is buffered.@{b}

   INPUTS@{ub}
        fh       - filehandle to use for buffered I/O
        buf      - Area to write bytes from.
        blocklen - number of bytes per block.  Must be > 0.
        blocks   - number of blocks to write.  Must be > 0.@{b}

   RESULT@{ub}
        count - Number of _blocks_ written.  On an error, the number of
                blocks actually written is returned.@{b}

   BUGS@{ub}
        Doesn't clear @{"IoErr()" LINK "IoErr"} before starting.  If you want to find out
        about errors, use @{"SetIoErr" LINK "SetIoErr"}(0L) before calling.@{b}

   SEE ALSO@{ub}
        @{"FPutC()" LINK "FPutC"}, @{"FRead()" LINK "FRead"}, @{"FPuts()" LINK "FPuts"}

@ENDNODE
@NODE "GetArgStr" "dos.library/GetArgStr()"
@{b}

   NAME@{ub}
        @{"GetArgStr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 415} -- Returns the arguments for the process (V36)@{b}

   SYNOPSIS@{ub}
        ptr = @{"GetArgStr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 415}()
        D0

        @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} @{"GetArgStr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 415}(void)@{b}

   FUNCTION@{ub}
        Returns a pointer to the (null-terminated) arguments for the program
        (process).  This is the same string passed in a0 on startup from CLI.@{b}

   RESULT@{ub}
        ptr - pointer to arguments@{b}

   SEE ALSO@{ub}
        @{"SetArgStr()" LINK "SetArgStr"}, @{"RunCommand()" LINK "RunCommand"}

@ENDNODE
@NODE "GetConsoleTask" "dos.library/GetConsoleTask()"
@{b}

   NAME@{ub}
        @{"GetConsoleTask" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 399} -- Returns the default console for the process (V36)@{b}

   SYNOPSIS@{ub}
        port = @{"GetConsoleTask" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 399}()
        D0

        @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *@{"GetConsoleTask" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 399}(void)@{b}

   FUNCTION@{ub}
        Returns the default console task's port (pr_ConsoleTask) for the
        current process.@{b}

   RESULT@{ub}
        port - The pr_MsgPort of the console handler, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"SetConsoleTask()" LINK "SetConsoleTask"}, @{"Open()" LINK "Open"}

@ENDNODE
@NODE "GetCurrentDirName" "dos.library/GetCurrentDirName()"
@{b}

   NAME@{ub}
        @{"GetCurrentDirName" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 435} -- returns the current directory name (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"GetCurrentDirName" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 435}(buf, len)
        D0                          D1   D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"GetCurrentDirName" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 435}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        Extracts the current directory name from the CLI structure and puts it
        into the buffer.  If the buffer is too small, the name is truncated
        appropriately and a failure code returned.  If no CLI structure is
        present, a null string is returned in the buffer, and failure from
        the call (with @{"IoErr()" LINK "IoErr"} == @{"ERROR_OBJECT_WRONG_TYPE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 202});@{b}

   INPUTS@{ub}
        buf     - Buffer to hold extracted name
        len     - Number of bytes of space in buffer@{b}

   RESULT@{ub}
        success - Success/failure indicator@{b}

   BUGS@{ub}
        In V36, this routine didn't handle 0-length buffers correctly.@{b}

   SEE ALSO@{ub}
        @{"SetCurrentDirName()" LINK "SetCurrentDirName"}

@ENDNODE
@NODE "GetDeviceProc" "dos.library/GetDeviceProc()"
@{b}

   NAME@{ub}
        @{"GetDeviceProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 494} -- Finds a handler to send a message to (V36)@{b}

   SYNOPSIS@{ub}
        devproc = @{"GetDeviceProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 494}(name, devproc)
          D0                     D1     D2

        @{"struct DevProc" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 421} *@{"GetDeviceProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 494}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"struct DevProc" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 421} *)@{b}

   FUNCTION@{ub}
        Finds the handler/filesystem to send packets regarding 'name' to.
        This may involve getting temporary locks.  It returns a structure
        that includes a lock and msgport to send to to attempt your operation.
        It also includes information on how to handle multiple-directory
        assigns (by passing the DevProc back to @{"GetDeviceProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 494}() until it
        returns @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}).

        The initial call to @{"GetDeviceProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 494}() should pass @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for devproc.  If
        after using the returned DevProc, you get an @{"ERROR_OBJECT_NOT_FOUND" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 196},
        and (devproc->dvp_Flags & @{"DVPF_ASSIGN" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 432}) is true, you should call
        @{"GetDeviceProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 494}() again, passing it the devproc structure.  It will
        either return a modified devproc structure, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} (with
        @{"ERROR_NO_MORE_ENTRIES" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 217} in @{"IoErr()" LINK "IoErr"}).  Continue until it returns @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.

        This call also increments the counter that locks a handler/fs into
        memory.  After calling @{"FreeDeviceProc()" LINK "FreeDeviceProc"}, do not use the port or lock
        again!@{b}

   INPUTS@{ub}
        name    - name of the object you wish to access.  This can be a
                  relative path ("foo/bar"), relative to the current volume
                  (":foo/bar"), or relative to a device/volume/assign
                  ("foo:bar").
        devproc - A value returned by @{"GetDeviceProc" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 494}() before, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}@{b}

   RESULT@{ub}
        devproc - a pointer to a DevProc structure or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}@{b}

   BUGS@{ub}
        Counter not currently active in 2.0.
        In 2.0 and 2.01, you HAD to check @{"DVPF_ASSIGN" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 432} before calling it again.
        This was fixed for the 2.02 release of V36.@{b}

   SEE ALSO@{ub}
        @{"FreeDeviceProc()" LINK "FreeDeviceProc"}, @{"DeviceProc()" LINK "DeviceProc"}, @{"AssignLock()" LINK "AssignLock"}, @{"AssignLate()" LINK "AssignLate"},
        @{"AssignPath()" LINK "AssignPath"}

@ENDNODE
@NODE "GetFileSysTask" "dos.library/GetFileSysTask()"
@{b}

   NAME@{ub}
        @{"GetFileSysTask" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 407} -- Returns the default filesystem for the process (V36)@{b}

   SYNOPSIS@{ub}
        port = @{"GetFileSysTask" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 407}()
        D0

        @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *@{"GetFileSysTask" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 407}(void)@{b}

   FUNCTION@{ub}
        Returns the default filesystem task's port (pr_FileSystemTask) for the
        current process.@{b}

   RESULT@{ub}
        port - The pr_MsgPort of the filesystem, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"SetFileSysTask()" LINK "SetFileSysTask"}, @{"Open()" LINK "Open"}

@ENDNODE
@NODE "GetProgramDir" "dos.library/GetProgramDir()"
@{b}

   NAME@{ub}
        @{"GetProgramDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 459} -- Returns a lock on the directory the program was loaded
                         from (V36)@{b}

   SYNOPSIS@{ub}
        lock = @{"GetProgramDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 459}()
        D0

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} @{"GetProgramDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 459}(void)@{b}

   FUNCTION@{ub}
        Returns a shared lock on the directory the program was loaded from.
        This can be used for a program to find data files, etc, that are stored
        with the program, or to find the program file itself.  @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} returns are
        valid, and may occur, for example, when running a program from the
        resident list.  You should @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} unlock the lock.@{b}

   RESULT@{ub}
        lock - A lock on the directory the current program was loaded from,
               or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if loaded from resident list, etc.@{b}

   BUGS@{ub}
        Should return a lock for things loaded via resident.  Perhaps should
        return currentdir if @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"SetProgramDir()" LINK "SetProgramDir"}, @{"Open()" LINK "Open"}

@ENDNODE
@NODE "GetProgramName" "dos.library/GetProgramName()"
@{b}

   NAME@{ub}
        @{"GetProgramName" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 443} -- Returns the current program name (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"GetProgramName" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 443}(buf, len)
        D0                       D1   D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"GetProgramName" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 443}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        Extracts the program name from the CLI structure and puts it
        into the buffer.  If the buffer is too small, the name is truncated.
        If no CLI structure is present, a null string is returned in the
        buffer, and failure from the call (with @{"IoErr()" LINK "IoErr"} ==
        @{"ERROR_OBJECT_WRONG_TYPE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 202});@{b}

   INPUTS@{ub}
        buf     - Buffer to hold extracted name
        len     - Number of bytes of space in buffer@{b}

   RESULT@{ub}
        success - Success/failure indicator@{b}

   SEE ALSO@{ub}
        @{"SetProgramName()" LINK "SetProgramName"}

@ENDNODE
@NODE "GetPrompt" "dos.library/GetPrompt()"
@{b}

   NAME@{ub}
        @{"GetPrompt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 451} -- Returns the prompt for the current process (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"GetPrompt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 451}(buf, len)
        D0                  D1   D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"GetPrompt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 451}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        Extracts the prompt string from the CLI structure and puts it
        into the buffer.  If the buffer is too small, the string is truncated
        appropriately and a failure code returned.  If no CLI structure is
        present, a null string is returned in the buffer, and failure from
        the call (with @{"IoErr()" LINK "IoErr"} == @{"ERROR_OBJECT_WRONG_TYPE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 202});@{b}

   INPUTS@{ub}
        buf     - Buffer to hold extracted prompt
        len     - Number of bytes of space in buffer@{b}

   RESULT@{ub}
        success - Success/failure indicator@{b}

   SEE ALSO@{ub}
        @{"SetPrompt()" LINK "SetPrompt"}

@ENDNODE
@NODE "GetVar" "dos.library/GetVar()"
@{b}

   NAME@{ub}
        @{"GetVar" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 669} -- Returns the value of a local or global variable (V36)@{b}

   SYNOPSIS@{ub}
        len = @{"GetVar" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 669}( name, buffer, size, flags )
        D0             D1     D2     D3    D4

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"GetVar" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 669}( @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} )@{b}

   FUNCTION@{ub}
        Gets the value of a local or environment variable.  It is advised to
        only use ASCII strings inside variables, but not required.  This stops
        putting characters into the destination when a \\n is hit, unless
        @{"GVF_BINARY_VAR" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File" 52} is specified.  (The \\n is not stored in the buffer.)@{b}

   INPUTS@{ub}
        name   - pointer to a variable name.
        buffer - a user allocated area which will be used to store
                 the value associated with the variable.
        size   - length of the buffer region in bytes.
        flags  - combination of type of var to get value of (low 8 bits), and
                 flags to control the behavior of this routine.  Currently
                 defined flags include:

                        @{"GVF_GLOBAL_ONLY" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File" 48} - tries to get a global env variable.
                        @{"GVF_LOCAL_ONLY" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File" 50}  - tries to get a local variable.
                        @{"GVF_BINARY_VAR" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File" 52}  - don't stop at \\n
                        @{"GVF_DONT_NULL_TERM" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File" 54} - no null termination (only valid
                                          for binary variables). (V37)

                 The default is to try to get a local variable first, then
                 to try to get a global environment variable.@{b}

   RESULT@{ub}
        len -   Size of environment variable.  -1 indicates that the
                variable was not defined (if @{"IoErr()" LINK "IoErr"} returns
                @{"ERROR_OBJECT_NOT_FOUND" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 196} - it returns @{"ERROR_BAD_NUMBER" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 184} if
                you specify a size of 0).  If the value would overflow
                the user buffer, the buffer is truncated.  The buffer
                returned is null-terminated (even if @{"GVF_BINARY_VAR" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File" 52} is
                used, unless @{"GVF_DONT_NULL_TERM" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File" 54} is in effect).  If it
                succeeds, len is the number of characters put in the buffer
                (not including null termination), and @{"IoErr()" LINK "IoErr"} will return the
                the size of the variable (regardless of buffer size).@{b}

   BUGS@{ub}
        @{"LV_VAR" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File" 38} is the only type that can be global.
        Under V36, we documented (and it returned) the size of the variable,
        not the number of characters transferred.  For V37 this was changed
        to the number of characters put in the buffer, and the total size
        of the variable is put in @{"IoErr()" LINK "IoErr"}.
        @{"GVF_DONT_NULL_TERM" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File" 54} only works for local variables under V37.  For
        V39, it also works for globals.@{b}

   SEE ALSO@{ub}
        @{"SetVar()" LINK "SetVar"}, @{"DeleteVar()" LINK "DeleteVar"}, @{"FindVar()" LINK "FindVar"}, <@{"dos/var.h" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File"}>

@ENDNODE
@NODE "Info" "dos.library/Info()"
@{b}

    NAME@{ub}
        Info -- Returns information about the disk@{b}

    SYNOPSIS@{ub}
        success = Info( lock, parameterBlock )
        D0              D1    D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} Info(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"struct InfoData" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 147} *)@{b}

    FUNCTION@{ub}
        Info() can be used to find information about any disk in use.
        'lock' refers to the disk, or any file on the disk. The parameter
        block is returned with information about the size of the disk,
        number of free blocks and any soft errors.@{b}

    INPUTS@{ub}
        lock           - BCPL pointer to a lock
        parameterBlock - pointer to an InfoData structure
                         (longword aligned)@{b}

    RESULTS@{ub}
        success - boolean

        SPECIAL NOTE:
            Note that InfoData structure must be longword aligned.

@ENDNODE
@NODE "Inhibit" "dos.library/Inhibit()"
@{b}

   NAME@{ub}
        Inhibit -- Inhibits access to a filesystem (V36)@{b}

   SYNOPSIS@{ub}
        success = Inhibit(filesystem, flag)
        D0                    D1       D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} Inhibit(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        Sends an @{"ACTION_INHIBIT" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 172} packet to the indicated handler.  This stops
        all activity by the handler until uninhibited.  When uninhibited,
        anything may have happened to the disk in the drive, or there may no
        longer be one.@{b}

   INPUTS@{ub}
        filesystem - Name of device to inhibit (with ':')
        flag       - New status.  @{"DOSTRUE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 22} = inhibited, @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} = uninhibited@{b}

   RESULT@{ub}
        success    - Success/failure indicator@{b}

   SEE ALSO@{ub}

@ENDNODE
@NODE "Input" "dos.library/Input()"
@{b}

    NAME@{ub}
        Input -- Identify the program's initial input file handle@{b}

    SYNOPSIS@{ub}
        file = Input()
        D0

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} Input(void)@{b}

    FUNCTION@{ub}
        Input() is used to identify the initial input stream allocated when
        the program was initiated.  Never close the filehandle returned by
        Input!@{b}

    RESULTS@{ub}
        file - BCPL pointer to a file handle@{b}

    SEE ALSO@{ub}
        @{"Output()" LINK "Output"}, @{"SelectInput()" LINK "SelectInput"}

@ENDNODE
@NODE "InternalLoadSeg" "dos.library/InternalLoadSeg()"
@{b}

   NAME@{ub}
        @{"InternalLoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 570} -- Low-level load routine (V36)@{b}

   SYNOPSIS@{ub}
        seglist = @{"InternalLoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 570}(fh,table,functionarray,stack)
        D0                        D0  A0        A1        A2

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} @{"InternalLoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 570}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130},@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130},@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} *,@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} *)@{b}

   FUNCTION@{ub}
        Loads from fh.  Table is used when loading an overlay, otherwise
        should be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.  Functionarray is a pointer to an array of functions.
        Note that the current Seek position after loading may be at any point
        after the last hunk loaded.  The filehandle will not be closed.  If a
        stacksize is encoded in the file, the size will be stuffed in the
        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} pointed to by stack.  This @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} should be initialized to your
        default value: @{"InternalLoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 570}() will not change it if no stacksize
        is found. Clears unused portions of Code and Data hunks (as well as
        BSS hunks).  (This also applies to @{"LoadSeg()" LINK "LoadSeg"} and @{"NewLoadSeg()" LINK "NewLoadSeg"}).

        If the file being loaded is an overlaid file, this will return
        -(seglist).  All other results will be positive.

        NOTE to overlay users: @{"InternalLoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 570}() does @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} return seglist in
        both D0 and D1, as @{"LoadSeg" LINK "LoadSeg"} does.  The current ovs.asm uses @{"LoadSeg()" LINK "LoadSeg"},
        and assumes returns are in D1.  We will support this for @{"LoadSeg()" LINK "LoadSeg"}
        ONLY.@{b}

   INPUTS@{ub}
        fh            - Filehandle to load from.
        table         - When loading an overlay, otherwise ignored.
        functionarray - Array of function to be used for read, alloc, and free.
           FuncTable[0] ->  Actual = ReadFunc(readhandle,buffer,length),DOSBase
                            D0                D1         D2     D3      A6
           FuncTable[1] ->  Memory = AllocFunc(size,flags), Execbase
                            D0                 D0   D1      a6
           FuncTable[2] ->  FreeFunc(memory,size), Execbase
                                     A1     D0     A6
        stack         - Pointer to storage (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) for stacksize.@{b}

   RESULT@{ub}
        seglist       - Seglist loaded or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.  @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} returned in D1!@{b}

   BUGS@{ub}
        Really should use tags.@{b}

   SEE ALSO@{ub}
        @{"LoadSeg()" LINK "LoadSeg"}, @{"UnLoadSeg()" LINK "UnLoadSeg"}, @{"NewLoadSeg()" LINK "NewLoadSeg"}, @{"InternalUnLoadSeg()" LINK "InternalUnLoadSeg"}

@ENDNODE
@NODE "InternalUnLoadSeg" "dos.library/InternalUnLoadSeg()"
@{b}

   NAME@{ub}
        @{"InternalUnLoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 574} -- Unloads a seglist loaded with @{"InternalLoadSeg()" LINK "InternalLoadSeg"} (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"InternalUnLoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 574}(seglist,FreeFunc)
          D0                          D1       A1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"InternalUnLoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 574}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130},void (*)(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}))@{b}

   FUNCTION@{ub}
        Unloads a seglist using freefunc to free segments.  Freefunc is called
        as for @{"InternalLoadSeg" LINK "InternalLoadSeg"}.  NOTE: will call @{"Close()" LINK "Close"} for overlaid
        seglists.@{b}

   INPUTS@{ub}
        seglist  - Seglist to be unloaded
        FreeFunc - Function called to free memory@{b}

   RESULT@{ub}
        success - returns whether everything went OK (since this may close
                  files).  Also returns @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if seglist was @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   BUGS@{ub}
        Really should use tags@{b}

   SEE ALSO@{ub}
        @{"LoadSeg()" LINK "LoadSeg"}, @{"UnLoadSeg()" LINK "UnLoadSeg"}, @{"InternalLoadSeg()" LINK "InternalLoadSeg"}, NewUnLoadSeg(), @{"Close()" LINK "Close"}

@ENDNODE
@NODE "IoErr" "dos.library/IoErr()"
@{b}

    NAME@{ub}
        @{"IoErr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 115} -- Return extra information from the system@{b}

    SYNOPSIS@{ub}
        error = @{"IoErr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 115}()
          D0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"IoErr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 115}(void)@{b}

    FUNCTION@{ub}
        Most I/O routines return zero to indicate an error. When this
        happens (or whatever the defined error return for the routine)
        this routine may be called to determine more information. It is
        also used in some routines to pass back a secondary result.

        Note: there is no guarantee as to the value returned from @{"IoErr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 115}()
        after a successful operation, unless to specified by the routine.@{b}

    RESULTS@{ub}
        error - integer@{b}

    SEE ALSO@{ub}
        @{"Fault()" LINK "Fault"}, @{"PrintFault()" LINK "PrintFault"}, @{"SetIoErr()" LINK "SetIoErr"}

@ENDNODE
@NODE "IsFileSystem" "dos.library/IsFileSystem()"
@{b}

   NAME@{ub}
        @{"IsFileSystem" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 538} -- returns whether a Dos handler is a filesystem (V36)@{b}

   SYNOPSIS@{ub}
        result = @{"IsFileSystem" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 538}(name)
        D0                     D1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"IsFileSystem" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 538}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

   FUNCTION@{ub}
        Returns whether the device is a filesystem or not.  A filesystem
        supports seperate files storing information.  It may also support
        sub-directories, but is not required to.  If the filesystem doesn't
        support this new packet, @{"IsFileSystem" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 538}() will use @{"Lock" LINK "Lock"}(":",...) as
        an indicator.@{b}

   INPUTS@{ub}
        name   - Name of device in question, with trailing ':'.@{b}

   RESULT@{ub}
        result - Flag to indicate if device is a file system@{b}

   SEE ALSO@{ub}
        @{"Lock()" LINK "Lock"}

@ENDNODE
@NODE "IsInteractive" "dos.library/IsInteractive()"
@{b}

    NAME@{ub}
        @{"IsInteractive" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 163} -- Discover whether a file is "interactive"@{b}

    SYNOPSIS@{ub}
        status = @{"IsInteractive" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 163}( file )
        D0                      D1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"IsInteractive" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 163}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

    FUNCTION@{ub}
        The return value 'status' indicates whether the file associated
        with the file handle 'file' is connected to a virtual terminal.@{b}

    INPUTS@{ub}
        file - BCPL pointer to a file handle@{b}

    RESULTS@{ub}
        status - boolean@{b}

    SEE ALSO@{ub}

@ENDNODE
@NODE "LoadSeg" "dos.library/LoadSeg()"
@{b}

    NAME@{ub}
        @{"LoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 127} -- Scatterload a loadable file into memory@{b}

    SYNOPSIS@{ub}
        seglist = @{"LoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 127}( name )
        D0                 D1

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} @{"LoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 127}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

    FUNCTION@{ub}
        The file 'name' should be a load module produced by the linker.
        @{"LoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 127}() scatterloads the CODE, DATA and BSS segments into memory,
        chaining together the segments with @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}'s on their first words.
        The end of the chain is indicated by a zero.  There can be any number
        of segments in a file.  All necessary relocation is handled by
        @{"LoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 127}().

        In the event of an error any blocks loaded will be unloaded and a
        @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} result returned.

        If the module is correctly loaded then the output will be a pointer
        at the beginning of the list of blocks. Loaded code is unloaded via
        a call to @{"UnLoadSeg()" LINK "UnLoadSeg"}.@{b}

    INPUTS@{ub}
        name - pointer to a null-terminated string@{b}

    RESULTS@{ub}
        seglist - BCPL pointer to a seglist@{b}

    SEE ALSO@{ub}
        @{"UnLoadSeg()" LINK "UnLoadSeg"}, @{"InternalLoadSeg()" LINK "InternalLoadSeg"}, @{"InternalUnLoadSeg()" LINK "InternalUnLoadSeg"}, @{"CreateProc()" LINK "CreateProc"},
        @{"CreateNewProc()" LINK "CreateNewProc"}, @{"NewLoadSeg()" LINK "NewLoadSeg"}.

@ENDNODE
@NODE "Lock" "dos.library/Lock()"
@{b}

    NAME@{ub}
        Lock -- Lock a directory or file@{b}

    SYNOPSIS@{ub}
        lock  = Lock( name, accessMode )
        D0            D1        D2

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} Lock(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

    FUNCTION@{ub}
        A filing system lock on the file or directory 'name' is returned if
        possible.

        If the accessMode is @{"ACCESS_READ" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 48}, the lock is a shared read lock;
        if the accessMode is @{"ACCESS_WRITE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 50} then it is an exclusive write
        lock.  Do not use random values for mode.

        If Lock() fails (that is, if it cannot obtain a filing system lock
        on the file or directory) it returns a zero.

        Tricky assumptions about the internal format of a lock are unwise,
        as are any attempts to use the fl_Link or fl_Access fields.@{b}

    INPUTS@{ub}
        name       - pointer to a null-terminated string
        accessMode - integer@{b}

    RESULTS@{ub}
        lock - BCPL pointer to a lock@{b}

    SEE ALSO@{ub}
        @{"UnLock()" LINK "UnLock"}, @{"DupLock()" LINK "DupLock"}, @{"ChangeMode()" LINK "ChangeMode"}, @{"NameFromLock()" LINK "NameFromLock"}, @{"DupLockFromFH()" LINK "DupLockFromFH"}

@ENDNODE
@NODE "LockDosList" "dos.library/LockDosList()"
@{b}

   NAME@{ub}
        @{"LockDosList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 502} -- Locks the specified Dos Lists for use (V36)@{b}

   SYNOPSIS@{ub}
        dlist = @{"LockDosList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 502}(flags)
        D0                   D1

        @{"struct DosList" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 372} *@{"LockDosList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 502}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{b}

   FUNCTION@{ub}
        Locks the dos device list in preparation to walk the list.
        If the list is 'busy' then this routine will not return until it is
        available.  This routine "nests": you can call it multiple times, and
        then must unlock it the same number of times.  The dlist
        returned is @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} a valid entry: it is a special value.  Note that
        for 1.3 compatibility, it also does a @{"Forbid()" LINK "gg:doc/NDK/Guide/exec/Forbid"} - this will probably
        be removed at some future time.  The 1.3 @{"Forbid()" LINK "gg:doc/NDK/Guide/exec/Forbid"} locking of this
        list had some race conditions.  The pointer returned by this is @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500}
        an actual DosList pointer - you should use on of the other DosEntry
        calls to get actual pointers to DosList structures (such as
        @{"NextDosEntry()" LINK "NextDosEntry"}), passing the value returned by @{"LockDosList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 502}()
        as the dlist value.

        Note for handler writers: you should never call this function with
        @{"LDF_WRITE" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 450}, since it can deadlock you (if someone has it read-locked
        and they're trying to send you a packet).  Use @{"AttemptLockDosList()" LINK "AttemptLockDosList"}
        instead, and effectively busy-wait with delays for the list to be
        available.  The other option is that you can spawn a process to
        add the entry safely.

        As an example, here's how you can search for all volumes of a specific
        name and do something with them:

        2.0 way:

                dl = @{"LockDosList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 502}(@{"LDF_VOLUMES" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 438}|@{"LDF_READ" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 448});
                while (dl = @{"FindDosEntry" LINK "FindDosEntry"}(dl,name,@{"LDF_VOLUMES" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 438}))
                {
                        Add to list of volumes to process or break out of
                        the while loop.
                        (You could try using it here, but I advise
                        against it for compatability reasons if you
                        are planning on continuing to examine the list.)
                }

                process list of volumes saved above, or current entry if
                you're only interested in the first one of that name.

                @{"UnLockDosList" LINK "UnLockDosList"}(@{"LDF_VOLUMES" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 438}|@{"LDF_READ" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 448});
                                  \\* must not use dl after this! *\\

        1.3/2.0 way:

                if (version >= 36)
                        dl = @{"LockDosList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 502}(@{"LDF_VOLUMES" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 438}|@{"LDF_READ" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 448});
                else {
                        @{"Forbid()" LINK "gg:doc/NDK/Guide/exec/Forbid"};
                        /* tricky! note dol_Next is at offset 0! */
                        dl = &(...->di_DeviceList);
                }

                while (version >= 36 ?
                                dl = @{"FindDosEntry" LINK "FindDosEntry"}(dl,name,@{"LDF_VOLUMES" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 438}) :
                                dl = yourfindentry(dl,name,@{"DLT_VOLUME" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 415}))
                {
                        Add to list of volumes to process, or break out of
                        the while loop.
                        Do @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} lock foo1/foo2 here if you will continue
                        to examine the list - it breaks the forbid
                        and the list may change on you.
                }

                process list of volumes saved above, or current entry if
                you're only interested in the first one of that name.

                if (version >= 36)
                        @{"UnLockDosList" LINK "UnLockDosList"}(@{"LDF_VOLUMES" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 438}|@{"LDF_READ" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 448});
                else
                        @{"Permit()" LINK "gg:doc/NDK/Guide/exec/Permit"};
                \\* must not use dl after this! *\\
                ...

                @{"struct DosList" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 372} *
                yourfindentry (@{"struct DosList" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 372} *dl, STRPTRname, type)
                {
                \\* tricky - depends on dol_Next being at offset 0,
                   and the initial ptr being a ptr to di_DeviceList! *\\
                        while (dl = dl->dol_Next)
                        {
                            if (dl->dol_Type == type &&
                                stricmp(name,@{"BADDR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 135}(dl->dol_Name)+1) == 0)
                            {
                                break;
                            }
                        }
                        return dl;
                }@{b}

   INPUTS@{ub}
        flags - Flags stating which types of nodes you want to lock.@{b}

   RESULT@{ub}
        dlist - Pointer to the head of the list.  @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} a valid node!@{b}

   SEE ALSO@{ub}
        @{"AttemptLockDosList()" LINK "AttemptLockDosList"}, @{"UnLockDosList()" LINK "UnLockDosList"}, @{"Forbid()" LINK "gg:doc/NDK/Guide/exec/Forbid"}, @{"NextDosEntry()" LINK "NextDosEntry"}

@ENDNODE
@NODE "LockRecord" "dos.library/LockRecord()"
@{b}

   NAME@{ub}
        @{"LockRecord" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 226} -- Locks a portion of a file (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"LockRecord" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 226}(fh,offset,length,mode,timeout)
        D0                   D1   D2     D3    D4    D5

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"LockRecord" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 226}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{b}

   FUNCTION@{ub}
        This locks a portion of a file for exclusive access.  Timeout is how
        long to wait in ticks (1/50 sec) for the record to be available.

        Valid modes are:
                @{"REC_EXCLUSIVE" LINK "gg:doc/NDK/Guide/Include/dos/record.h/File" 20}
                @{"REC_EXCLUSIVE_IMMED" LINK "gg:doc/NDK/Guide/Include/dos/record.h/File" 21}
                @{"REC_SHARED" LINK "gg:doc/NDK/Guide/Include/dos/record.h/File" 22}
                @{"REC_SHARED_IMMED" LINK "gg:doc/NDK/Guide/Include/dos/record.h/File" 23}
        For the IMMED modes, the timeout is ignored.

        Record locks are tied to the filehandle used to create them.  The
        same filehandle can get any number of exclusive locks on the same
        record, for example.  These are cooperative locks, they only
        affect other people calling @{"LockRecord" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 226}().@{b}

   INPUTS@{ub}
        fh      - File handle for which to lock the record
        offset  - Record start position
        length  - Length of record in bytes
        mode    - Type of lock requester
        timeout - Timeout interval in ticks.  0 is legal.@{b}

   RESULT@{ub}
        success - Success or failure@{b}

   BUGS@{ub}
        In 2.0 through 2.02 (V36), @{"LockRecord" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 226}() only worked in the ramdisk.
        Attempting to lock records on the disk filesystem causes a crash.
        This was fixed for V37.@{b}

   SEE ALSO@{ub}
        @{"LockRecords()" LINK "LockRecords"}, @{"UnLockRecord()" LINK "UnLockRecord"}, @{"UnLockRecords()" LINK "UnLockRecords"}

@ENDNODE
@NODE "LockRecords" "dos.library/LockRecords()"
@{b}

   NAME@{ub}
        @{"LockRecords" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 230} -- Lock a series of records (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"LockRecords" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 230}(record_array,timeout)
        D0                       D1           D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"LockRecords" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 230}(@{"struct RecordLock" LINK "gg:doc/NDK/Guide/Include/dos/record.h/File" 27} *,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{b}

   FUNCTION@{ub}
        This locks several records within a file for exclusive access.
        Timeout is how long to wait in ticks for the records to be available.
        The wait is applied to each attempt to lock each record in the list.
        It is recommended that you always lock a set of records in the same
        order to reduce possibilities of deadlock.

        The array of RecordLock structures is terminated by an entry with
        rec_FH of @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   INPUTS@{ub}
        record_array - List of records to be locked
        timeout      - Timeout interval.  0 is legal@{b}

   RESULT@{ub}
        success      - Success or failure@{b}

   BUGS@{ub}
        See @{"LockRecord()" LINK "LockRecord"}@{b}

   SEE ALSO@{ub}
        @{"LockRecord()" LINK "LockRecord"}, @{"UnLockRecord()" LINK "UnLockRecord"}, @{"UnLockRecords()" LINK "UnLockRecords"}

@ENDNODE
@NODE "MakeDosEntry" "dos.library/MakeDosEntry()"
@{b}

   NAME@{ub}
        @{"MakeDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 530} -- Creates a DosList structure (V36)@{b}

   SYNOPSIS@{ub}
        newdlist = @{"MakeDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 530}(name, type)
        D0                       D1    D2

        @{"struct DosList" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 372} *@{"MakeDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 530}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        Create a DosList structure, including allocating a name and correctly
        null-terminating the @{"BSTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 131}.  It also sets the dol_Type field, and sets
        all other fields to 0.  This routine should be eliminated and replaced
        by a value passed to @{"AllocDosObject()" LINK "AllocDosObject"}!@{b}

   INPUTS@{ub}
        name - name for the device/volume/assign node.
        type - type of node.@{b}

   RESULT@{ub}
        newdlist - The new device entry or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"AddDosEntry()" LINK "AddDosEntry"}, @{"RemDosEntry()" LINK "RemDosEntry"}, @{"FindDosEntry()" LINK "FindDosEntry"}, @{"LockDosList()" LINK "LockDosList"},
        @{"NextDosEntry()" LINK "NextDosEntry"}, @{"FreeDosEntry()" LINK "FreeDosEntry"}

@ENDNODE
@NODE "MakeLink" "dos.library/MakeLink()"
@{b}

   NAME@{ub}
        @{"MakeLink" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 352} -- Creates a filesystem link (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"MakeLink" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 352}( name, dest, soft )
        D0                   D1    D2    D3

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"MakeLink" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 352}( @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} )@{b}

   FUNCTION@{ub}
        Create a filesystem link from 'name' to dest.  For "soft-links",
        dest is a pointer to a null-terminated path string.  For "hard-
        links", dest is a lock (@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}).  'soft' is @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} for hard-links,
        non-zero otherwise.

        Soft-links are resolved at access time by a combination of the
        filesystem (by returning @{"ERROR_IS_SOFT_LINK" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 219} to dos), and by
        Dos (using @{"ReadLink()" LINK "ReadLink"} to resolve any links that are hit).

        Hard-links are resolved by the filesystem in question.  A series
        of hard-links to a file are all equivalent to the file itself.
        If one of the links (or the original entry for the file) is
        deleted, the data remains until there are no links left.@{b}

   INPUTS@{ub}
        name - Name of the link to create
        dest - @{"CPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 85} to path string, or @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} lock
        soft - @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} for hard-links, non-zero for soft-links@{b}

   RESULT@{ub}
        Success - boolean@{b}

   BUGS@{ub}
        In V36, soft-links didn't work in the ROM filesystem.  This was
        fixed for V37.@{b}

   SEE ALSO@{ub}
        @{"ReadLink()" LINK "ReadLink"}, @{"Open()" LINK "Open"}, @{"Lock()" LINK "Lock"}

@ENDNODE
@NODE "MatchEnd" "dos.library/MatchEnd()"
@{b}

   NAME@{ub}
        @{"MatchEnd" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 629} -- Free storage allocated for @{"MatchFirst()" LINK "MatchFirst"}/@{"MatchNext()" LINK "MatchNext"} (V36)@{b}

   SYNOPSIS@{ub}
        @{"MatchEnd" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 629}(AnchorPath)
                     D1

        @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24} @{"MatchEnd" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 629}(@{"struct AnchorPath" LINK "gg:doc/NDK/Guide/Include/dos/dosasl.h/File" 52} *)@{b}

   FUNCTION@{ub}
        Return all storage associated with a given search.@{b}

   INPUTS@{ub}
        AnchorPath - Anchor used for @{"MatchFirst()" LINK "MatchFirst"}/@{"MatchNext()" LINK "MatchNext"}
                     MUST be longword aligned!@{b}

   SEE ALSO@{ub}
        @{"MatchFirst()" LINK "MatchFirst"}, @{"ParsePattern()" LINK "ParsePattern"}, @{"Examine()" LINK "Examine"}, @{"CurrentDir()" LINK "CurrentDir"}, @{"Examine()" LINK "Examine"},
        @{"MatchNext()" LINK "MatchNext"}, @{"ExNext()" LINK "ExNext"}, <@{"dos/dosasl.h" LINK "gg:doc/NDK/Guide/Include/dos/dosasl.h/File"}>

@ENDNODE
@NODE "MatchFirst" "dos.library/MatchFirst()"
@{b}

   NAME@{ub}
        @{"MatchFirst" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 621} -- Finds file that matches pattern (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"MatchFirst" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 621}(pat, AnchorPath)
        D0                 D1       D2

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"MatchFirst" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 621}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"struct AnchorPath" LINK "gg:doc/NDK/Guide/Include/dos/dosasl.h/File" 52} *)@{b}

   FUNCTION@{ub}
        Locates the first file or directory that matches a given pattern.
        @{"MatchFirst" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 621}() is passed your pattern (you do not pass it through
        @{"ParsePattern()" LINK "ParsePattern"} - @{"MatchFirst" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 621}() does that for you), and the control
        structure.  @{"MatchFirst" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 621}() normally initializes your AnchorPath
        structure for you, and returns the first file that matched your
        pattern, or an error.  Note that @{"MatchFirst" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 621}()/@{"MatchNext()" LINK "MatchNext"} are unusual
        for Dos in that they return 0 for success, or the error code (see
        <@{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"}>), instead of the application getting the error code
        from @{"IoErr()" LINK "IoErr"}.

        When looking at the result of @{"MatchFirst" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 621}()/@{"MatchNext()" LINK "MatchNext"}, the ap_Info
        field of your AnchorPath has the results of an @{"Examine()" LINK "Examine"} of the object.
        You normally get the name of the object from fib_FileName, and the
        directory it's in from ap_Current->an_Lock.  To access this object,
        normally you would temporarily @{"CurrentDir()" LINK "CurrentDir"} to the lock, do an action
        to the file/dir, and then @{"CurrentDir()" LINK "CurrentDir"} back to your original directory.
        This makes certain you affect the right object even when two volumes
        of the same name are in the system.  You can use ap_Buf (with
        ap_Strlen) to get a name to report to the user.

        To initialize the AnchorPath structure (particularily when reusing
        it), set ap_BreakBits to the signal bits (CDEF) that you want to take
        a break on, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, if you don't want to convenience the user.
        ap_Flags should be set to any flags you need or all 0's otherwise.
        ap_FoundBreak should be cleared if you'll be using breaks.

        If you want to have the FULL PATH NAME of the files you found,
        allocate a buffer at the END of this structure, and put the size of
        it into ap_Strlen.  If you don't want the full path name, make sure
        you set ap_Strlen to zero.  In this case, the name of the file, and
        stats are available in the ap_Info, as per usual.

        Then call @{"MatchFirst" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 621}() and then afterwards, @{"MatchNext()" LINK "MatchNext"} with this
        structure.  You should check the return value each time (see below)
        and take the appropriate action, ultimately calling @{"MatchEnd()" LINK "MatchEnd"} when
        there are no more files or you are done.  You can tell when you are
        done by checking for the normal AmigaDOS return code
        @{"ERROR_NO_MORE_ENTRIES" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 217}.

        Note: patterns with trailing slashes may cause @{"MatchFirst" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 621}()/@{"MatchNext()" LINK "MatchNext"}
        to return with an ap_Current->an_Lock on the object, and a filename
        of the empty string ("").

        See @{"ParsePattern()" LINK "ParsePattern"} for more information on the patterns.@{b}

   INPUTS@{ub}
        pat        - Pattern to search for
        AnchorPath - Place holder for search.  MUST be longword aligned!@{b}

   RESULT@{ub}
        error - 0 for success or error code.  (Opposite of most Dos calls!)@{b}

   BUGS@{ub}
        In V36, there were a number of bugs with @{"MatchFirst" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 621}()/@{"MatchNext()" LINK "MatchNext"}.
        One was that if you entered a directory with a name like "df0:l"
        using DODIR, it would re-lock the full string "df0:l", which can
        cause problems if the disk has changed.  It also had problems
        with patterns such as #?/abc/def - the ap_Current->an_Lock would
        not be on the directory def is found in.  ap_Buf would be correct,
        however.  It had similar problems with patterns with trailing
        slashes.  These have been fixed for V37 and later.

        A bug that has not been fixed for V37 concerns a pattern of a
        single directory name (such as "l").  If you enter such a directory
        via DODIR, it re-locks l relative to the current directory.  Thus
        you must not change the current directory before calling @{"MatchNext()" LINK "MatchNext"}
        with DODIR in that situation.  If you aren't using DODIR to enter
        directories you can ignore this.  This may be fixed in some upcoming
        release.@{b}

   SEE ALSO@{ub}
        @{"MatchNext()" LINK "MatchNext"}, @{"ParsePattern()" LINK "ParsePattern"}, @{"Examine()" LINK "Examine"}, @{"CurrentDir()" LINK "CurrentDir"}, @{"Examine()" LINK "Examine"},
        @{"MatchEnd()" LINK "MatchEnd"}, @{"ExNext()" LINK "ExNext"}, <@{"dos/dosasl.h" LINK "gg:doc/NDK/Guide/Include/dos/dosasl.h/File"}>

@ENDNODE
@NODE "MatchNext" "dos.library/MatchNext()"
@{b}

   NAME@{ub}
        @{"MatchNext" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 625} - Finds the next file or directory that matches pattern (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"MatchNext" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 625}(AnchorPath)
        D0                    D1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"MatchNext" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 625}(@{"struct AnchorPath" LINK "gg:doc/NDK/Guide/Include/dos/dosasl.h/File" 52} *)@{b}

   FUNCTION@{ub}
        Locates the next file or directory that matches a given pattern.
        See <@{"dos/dosasl.h" LINK "gg:doc/NDK/Guide/Include/dos/dosasl.h/File"}> for more information.  Various bits in the flags
        allow the application to control the operation of @{"MatchNext" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 625}().

        See @{"MatchFirst()" LINK "MatchFirst"} for other notes.@{b}

   INPUTS@{ub}
        AnchorPath - Place holder for search.  MUST be longword aligned!@{b}

   RESULT@{ub}
        error - 0 for success or error code.  (Opposite of most Dos calls)@{b}

   BUGS@{ub}
        See @{"MatchFirst()" LINK "MatchFirst"}.@{b}

   SEE ALSO@{ub}
        @{"MatchFirst()" LINK "MatchFirst"}, @{"ParsePattern()" LINK "ParsePattern"}, @{"Examine()" LINK "Examine"}, @{"CurrentDir()" LINK "CurrentDir"}, @{"Examine()" LINK "Examine"},
        @{"MatchEnd()" LINK "MatchEnd"}, @{"ExNext()" LINK "ExNext"}, <@{"dos/dosasl.h" LINK "gg:doc/NDK/Guide/Include/dos/dosasl.h/File"}>

@ENDNODE
@NODE "MatchPattern" "dos.library/MatchPattern()"
@{b}

   NAME@{ub}
        @{"MatchPattern" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 637} --  Checks for a pattern match with a string (V36)@{b}

   SYNOPSIS@{ub}
        match = @{"MatchPattern" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 637}(pat, str)
        D0                   D1   D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"MatchPattern" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 637}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

   FUNCTION@{ub}
        Checks for a pattern match with a string.  The pattern must be a
        tokenized string output by @{"ParsePattern()" LINK "ParsePattern"}.  This routine is
        case-sensitive.

        NOTE: this routine is highly recursive.  You must have at least
        1500 free bytes of stack to call this (it will cut off it's
        recursion before going any deeper than that and return failure).
        That's _currently_ enough for about 100 levels deep of #, (, ~, etc.@{b}

   INPUTS@{ub}
        pat - Special pattern string to match as returned by @{"ParsePattern()" LINK "ParsePattern"}
        str - String to match against given pattern@{b}

   RESULT@{ub}
        match - success or failure of pattern match.  On failure,
                @{"IoErr()" LINK "IoErr"} will return 0 or @{"ERROR_TOO_MANY_LEVELS" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 207} (starting
                with V37 - before that there was no stack checking).@{b}

   SEE ALSO@{ub}
        @{"ParsePattern()" LINK "ParsePattern"}, @{"MatchPatternNoCase()" LINK "MatchPatternNoCase"}, @{"MatchFirst()" LINK "MatchFirst"}, @{"MatchNext()" LINK "MatchNext"}

@ENDNODE
@NODE "MatchPatternNoCase" "dos.library/MatchPatternNoCase()"
@{b}

   NAME@{ub}
        @{"MatchPatternNoCase" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 710} --  Checks for a pattern match with a string (V37)@{b}

   SYNOPSIS@{ub}
        match = @{"MatchPatternNoCase" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 710}(pat, str)
        D0                         D1   D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"MatchPatternNoCase" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 710}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

   FUNCTION@{ub}
        Checks for a pattern match with a string.  The pattern must be a
        tokenized string output by @{"ParsePatternNoCase()" LINK "ParsePatternNoCase"}.  This routine is
        case-insensitive.

        NOTE: this routine is highly recursive.  You must have at least
        1500 free bytes of stack to call this (it will cut off it's
        recursion before going any deeper than that and return failure).
        That's _currently_ enough for about 100 levels deep of #, (, ~, etc.@{b}

   INPUTS@{ub}
        pat - Special pattern string to match as returned by @{"ParsePatternNoCase()" LINK "ParsePatternNoCase"}
        str - String to match against given pattern@{b}

   RESULT@{ub}
        match - success or failure of pattern match.  On failure,
                @{"IoErr()" LINK "IoErr"} will return 0 or @{"ERROR_TOO_MANY_LEVELS" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 207} (starting
                with V37 - before that there was no stack checking).@{b}

   BUGS@{ub}
        See @{"ParsePatternNoCase()" LINK "ParsePatternNoCase"}.@{b}

   SEE ALSO@{ub}
        @{"ParsePatternNoCase()" LINK "ParsePatternNoCase"}, @{"MatchPattern()" LINK "MatchPattern"}, @{"MatchFirst()" LINK "MatchFirst"}, @{"MatchNext()" LINK "MatchNext"}

@ENDNODE
@NODE "MaxCli" "dos.library/MaxCli()"
@{b}

   NAME@{ub}
        @{"MaxCli" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 427} -- returns the highest CLI process number possibly in use (V36)@{b}

   SYNOPSIS@{ub}
        number = @{"MaxCli" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 427}()
        D0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"MaxCli" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 427}(void)@{b}

   FUNCTION@{ub}
        Returns the highest CLI number that may be in use.  CLI numbers are
        reused, and are usually as small as possible.  To find all CLIs, scan
        using @{"FindCliProc()" LINK "FindCliProc"} from 1 to MaxCLI().  The number returned by
        @{"MaxCli" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 427}() may change as processes are created and destroyed.@{b}

   RESULT@{ub}
        number - The highest CLI number that _may_ be in use.@{b}

   SEE ALSO@{ub}
        @{"FindCliProc()" LINK "FindCliProc"}, @{"Cli()" LINK "Cli"}

@ENDNODE
@NODE "NameFromFH" "dos.library/NameFromFH()"
@{b}

   NAME@{ub}
        @{"NameFromFH" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 328} -- Get the name of an open filehandle (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"NameFromFH" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 328}(fh, buffer, len)
        D0                   D1    D2    D3

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"NameFromFH" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 328}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        Returns a fully qualified path for the filehandle.  This routine is
        guaranteed not to write more than len characters into the buffer.  The
        name will be null-terminated.  See @{"NameFromLock()" LINK "NameFromLock"} for more information.

        Note: Older filesystems that don't support @{"ExamineFH()" LINK "ExamineFH"} will cause
        @{"NameFromFH" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 328}() to fail with ERROR_ACTION_NOT_SUPPORTED.@{b}

   INPUTS@{ub}
        fh     - Lock of object to be examined.
        buffer - Buffer to store name.
        len    - Length of buffer.@{b}

   RESULT@{ub}
        success - Success/failure indicator.@{b}

   SEE ALSO@{ub}
        @{"NameFromLock()" LINK "NameFromLock"}, @{"ExamineFH()" LINK "ExamineFH"}

@ENDNODE
@NODE "NameFromLock" "dos.library/NameFromLock()"
@{b}

   NAME@{ub}
        @{"NameFromLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 324} -- Returns the name of a locked object (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"NameFromLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 324}(lock, buffer, len)
        D0                      D1     D2    D3

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"NameFromLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 324}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        Returns a fully qualified path for the lock.  This routine is
        guaranteed not to write more than len characters into the buffer.  The
        name will be null-terminated.  NOTE: if the volume is not mounted,
        the system will request it (unless of course you set pr_WindowPtr to
        -1).  If the volume is not mounted or inserted, it will return an
        error.  If the lock passed in is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, "SYS:" will be returned. If
        the buffer is too short, an error will be returned, and @{"IoErr()" LINK "IoErr"} will
        return @{"ERROR_LINE_TOO_LONG" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 189}.@{b}

   INPUTS@{ub}
        lock   - Lock of object to be examined.
        buffer - Buffer to store name.
        len    - Length of buffer.@{b}

   RESULT@{ub}
        success - Success/failure indicator.@{b}

   BUGS@{ub}
        Should return the name of the boot volume instead of SYS: for a @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
        lock.@{b}

   SEE ALSO@{ub}
        @{"NameFromFH()" LINK "NameFromFH"}, @{"Lock()" LINK "Lock"}

@ENDNODE
@NODE "NewLoadSeg" "dos.library/NewLoadSeg()"
@{b}

   NAME@{ub}
        @{"NewLoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 578} -- Improved version of @{"LoadSeg" LINK "LoadSeg"} for stacksizes (V36)@{b}

   SYNOPSIS@{ub}
        seglist = @{"NewLoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 578}(file, tags)
        D0                    D1    D2

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} @{"NewLoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 578}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *)

        seglist = @{"NewLoadSegTagList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 582}(file, tags)
        D0                           D1    D2

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} @{"NewLoadSegTagList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 582}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *)

        seglist = @{"NewLoadSegTags" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 585}(file, ...)

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} @{"NewLoadSegTags" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 585}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, ...)@{b}

   FUNCTION@{ub}
        Does a @{"LoadSeg" LINK "LoadSeg"} on a file, and takes additional actions based on the
        tags supplied.

        Clears unused portions of Code and Data hunks (as well as BSS hunks).
        (This also applies to @{"InternalLoadSeg()" LINK "InternalLoadSeg"} and @{"LoadSeg()" LINK "LoadSeg"}).

        NOTE to overlay users: @{"NewLoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 578}() does @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} return seglist in
        both D0 and D1, as @{"LoadSeg" LINK "LoadSeg"} does.  The current ovs.asm uses @{"LoadSeg()" LINK "LoadSeg"},
        and assumes returns are in D1.  We will support this for @{"LoadSeg()" LINK "LoadSeg"}
        ONLY.@{b}

   INPUTS@{ub}
        file - Filename of file to load
        tags - pointer to tagitem array@{b}

   RESULT@{ub}
        seglist - Seglist loaded, or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}@{b}

   BUGS@{ub}
        No tags are currently defined.@{b}

   SEE ALSO@{ub}
        @{"LoadSeg()" LINK "LoadSeg"}, @{"UnLoadSeg()" LINK "UnLoadSeg"}, @{"InternalLoadSeg()" LINK "InternalLoadSeg"}, @{"InternalUnLoadSeg()" LINK "InternalUnLoadSeg"}

@ENDNODE
@NODE "NextDosEntry" "dos.library/NextDosEntry()"
@{b}

   NAME@{ub}
        @{"NextDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 526} -- Get the next Dos List entry (V36)@{b}

   SYNOPSIS@{ub}
        newdlist = @{"NextDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 526}(dlist,flags)
        D0                       D1    D2

        @{"struct DosList" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 372} *@{"NextDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 526}(@{"struct DosList" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 372} *,@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{b}

   FUNCTION@{ub}
        Find the next Dos List entry of the right type.  You MUST have locked
        the types you're looking for.  Returns @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if there are no more of
        that type in the list.@{b}

   INPUTS@{ub}
        dlist    - The current device entry.
        flags    - What type of entries to look for.@{b}

   RESULT@{ub}
        newdlist - The next device entry of the right type or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.@{b}

   SEE ALSO@{ub}
        @{"AddDosEntry()" LINK "AddDosEntry"}, @{"RemDosEntry()" LINK "RemDosEntry"}, @{"FindDosEntry()" LINK "FindDosEntry"}, @{"LockDosList()" LINK "LockDosList"},
        @{"MakeDosEntry()" LINK "MakeDosEntry"}, @{"FreeDosEntry()" LINK "FreeDosEntry"}

@ENDNODE
@NODE "Open" "dos.library/Open()"
@{b}

    NAME@{ub}
        Open -- Open a file for input or output@{b}

    SYNOPSIS@{ub}
        file = Open( name, accessMode )
        D0           D1    D2

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} Open(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

    FUNCTION@{ub}
        The named file is opened and a file handle returned.  If the
        accessMode is @{"MODE_OLDFILE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 26}, an existing file is opened for reading
        or writing. If the value is @{"MODE_NEWFILE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 28}, a new file is created for
        writing. @{"MODE_READWRITE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 30} opens a file with an shared lock, but
        creates it if it didn't exist.  Open types are documented in the
        <@{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"}> or <@{"libraries/dos.h" LINK "gg:doc/NDK/Guide/Include/libraries/dos.h/File"}> include file.

        The 'name' can be a filename (optionally prefaced by a device
        name), a simple device such as NIL:, a window specification such as
        CON: or RAW: followed by window parameters, or "*", representing the
        current window.  Note that as of V36, "*" is obsolete, and CONSOLE:
        should be used instead.

        If the file cannot be opened for any reason, the value returned
        will be zero, and a secondary error code will be available by
        calling the routine @{"IoErr()" LINK "IoErr"}.@{b}

    INPUTS@{ub}
        name       - pointer to a null-terminated string
        accessMode - integer@{b}

    RESULTS@{ub}
        file - BCPL pointer to a file handle@{b}

    SEE ALSO@{ub}
        @{"Close()" LINK "Close"}, @{"ChangeMode()" LINK "ChangeMode"}, @{"NameFromFH()" LINK "NameFromFH"}, @{"ParentOfFH()" LINK "ParentOfFH"}, @{"ExamineFH()" LINK "ExamineFH"}

@ENDNODE
@NODE "OpenFromLock" "dos.library/OpenFromLock()"
@{b}

   NAME@{ub}
        @{"OpenFromLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 308} -- Opens a file you have a lock on (V36)@{b}

   SYNOPSIS@{ub}
        fh = @{"OpenFromLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 308}(lock)
        D0                 D1

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} @{"OpenFromLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 308}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

   FUNCTION@{ub}
        Given a lock, this routine performs an open on that lock.  If the open
        succeeds, the lock is (effectively) relinquished, and should not be
        @{"UnLock()" LINK "UnLock"}ed or used.  If the open fails, the lock is still usable.
        The lock associated with the file internally is of the same access
        mode as the lock you gave up - shared is similar to @{"MODE_OLDFILE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 26},
        exclusive is similar to @{"MODE_NEWFILE" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 28}.@{b}

   INPUTS@{ub}
        lock - Lock on object to be opened.@{b}

   RESULT@{ub}
        fh   - Newly opened file handle or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for failure@{b}

   BUGS@{ub}
        In the original V36 autodocs, this was shown (incorrectly) as
        taking a Mode parameter as well.  The prototypes and pragmas were
        also wrong.@{b}

   SEE ALSO@{ub}
        @{"Open()" LINK "Open"}, @{"Close()" LINK "Close"}, @{"Lock()" LINK "Lock"}, @{"UnLock()" LINK "UnLock"}

@ENDNODE
@NODE "Output" "dos.library/Output()"
@{b}

    NAME@{ub}
        Output -- Identify the programs' initial output file handle@{b}

    SYNOPSIS@{ub}
        file = Output()
        D0

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} Output(void)@{b}

    FUNCTION@{ub}
        Output() is used to identify the initial output stream allocated
        when the program was initiated.  Never close the filehandle returned
        by Output().@{b}

    RESULTS@{ub}
        file - BCPL pointer to a file handle@{b}

    SEE ALSO@{ub}
        @{"Input()" LINK "Input"}

@ENDNODE
@NODE "ParentDir" "dos.library/ParentDir()"
@{b}

    NAME@{ub}
        @{"ParentDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 159} -- Obtain the parent of a directory or file@{b}

    SYNOPSIS@{ub}
        newlock = @{"ParentDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 159}( lock )
        D0                   D1

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} @{"ParentDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 159}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

    FUNCTION@{ub}
        The argument 'lock' is associated with a given file or directory.
        @{"ParentDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 159}() returns 'newlock' which is associated the parent
        directory of 'lock'.

        Taking the @{"ParentDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 159}() of the root of the current filing system
        returns a @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} (0) lock.  Note this 0 lock represents the root of
        file system that you booted from (which is, in effect, the parent
        of all other file system roots.)@{b}

    INPUTS@{ub}
        lock - BCPL pointer to a lock@{b}

    RESULTS@{ub}
        newlock - BCPL pointer to a lock@{b}

    SEE ALSO@{ub}
        @{"Lock()" LINK "Lock"}, @{"DupLock()" LINK "DupLock"}, @{"UnLock()" LINK "UnLock"}, @{"ParentOfFH()" LINK "ParentOfFH"}, @{"DupLockFromFH()" LINK "DupLockFromFH"}

@ENDNODE
@NODE "ParentOfFH" "dos.library/ParentOfFH()"
@{b}

   NAME@{ub}
        @{"ParentOfFH" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 312} -- returns a lock on the parent directory of a file (V36)@{b}

   SYNOPSIS@{ub}
        lock = @{"ParentOfFH" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 312}(fh)
        D0               D1

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} @{"ParentOfFH" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 312}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

   FUNCTION@{ub}
        Returns a shared lock on the parent directory of the filehandle.@{b}

   INPUTS@{ub}
        fh   - Filehandle you want the parent of.@{b}

   RESULT@{ub}
        lock - Lock on parent directory of the filehandle or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for failure.@{b}

   SEE ALSO@{ub}
        Parent(), @{"Lock()" LINK "Lock"}, @{"UnLock()" LINK "UnLock"} @{"DupLockFromFH()" LINK "DupLockFromFH"}

@ENDNODE
@NODE "ParsePattern" "dos.library/ParsePattern()"
@{b}

   NAME@{ub}
        @{"ParsePattern" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 633} -- Create a tokenized string for @{"MatchPattern()" LINK "MatchPattern"} (V36)@{b}

   SYNOPSIS@{ub}
        IsWild = @{"ParsePattern" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 633}(Source, Dest, DestLength)
        d0                      D1     D2      D3

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"ParsePattern" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 633}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        Tokenizes a pattern, for use by @{"MatchPattern()" LINK "MatchPattern"}.  Also indicates if
        there are any wildcards in the pattern (i.e. whether it might match
        more than one item).  Note that Dest must be at least 2 times as
        large as Source plus bytes to be (almost) 100% certain of no
        buffer overflow.  This is because each input character can currently
        expand to 2 tokens (with one exception that can expand to 3, but
        only once per string).  Note: this implementation may change in
        the future, so you should handle error returns in all cases, but
        the size above should still be a reasonable upper bound for a buffer
        allocation.

        The patterns are fairly extensive, and approximate some of the ability
        of Unix/grep "regular expression" patterns.  Here are the available
        tokens:

        ?       Matches a single character.
        #       Matches the following expression 0 or more times.
        (ab|cd) Matches any one of the items seperated by '|'.
        ~       Negates the following expression.  It matches all strings
                that do not match the expression (aka ~(foo) matches all
                strings that are not exactly "foo").
        [abc]   Character class: matches any of the characters in the class.
        [~bc]   Character class: matches any of the characters not in the
                class.
        a-z     Character range (only within character classes).
        %       Matches 0 characters always (useful in "(foo|bar|%)").
        *       Synonym for "#?", not available by default in 2.0.  Available
                as an option that can be turned on.

        "Expression" in the above table means either a single character
        (ex: "#?"), or an alternation (ex: "#(ab|cd|ef)"), or a character
        class (ex: "#[a-zA-Z]").@{b}

   INPUTS@{ub}
        source     - unparsed wildcard string to search for.
       dest       - output string, gets tokenized version of input.
        DestLength - length available in destination (should be at least as
                     twice as large as source + 2 bytes).@{b}

   RESULT@{ub}
        IsWild - 1 means there were wildcards in the pattern,
                 0 means there were no wildcards in the pattern,
                -1 means there was a buffer overflow or other error@{b}

   BUGS@{ub}
        In V37 this call didn't always set @{"IoErr()" LINK "IoErr"} to something useful on an
        error.  Fixed in V39.@{b}

   SEE ALSO@{ub}
        @{"ParsePatternNoCase()" LINK "ParsePatternNoCase"}, @{"MatchPattern()" LINK "MatchPattern"}, @{"MatchFirst()" LINK "MatchFirst"}, @{"MatchNext()" LINK "MatchNext"}

@ENDNODE
@NODE "ParsePatternNoCase" "dos.library/ParsePatternNoCase()"
@{b}

   NAME@{ub}
        @{"ParsePatternNoCase" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 706} -- Create a tokenized string for
                                                @{"MatchPatternNoCase()" LINK "MatchPatternNoCase"} (V37)@{b}

   SYNOPSIS@{ub}
        IsWild = @{"ParsePatternNoCase" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 706}(Source, Dest, DestLength)
        d0                            D1     D2      D3

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"ParsePatternNoCase" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 706}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        Tokenizes a pattern, for use by @{"MatchPatternNoCase()" LINK "MatchPatternNoCase"}.  Also indicates
        if there are any wildcards in the pattern (i.e. whether it might match
        more than one item).  Note that Dest must be at least 2 times as
        large as Source plus 2 bytes.

        For a description of the wildcards, see @{"ParsePattern()" LINK "ParsePattern"}.@{b}

   INPUTS@{ub}
        source     - unparsed wildcard string to search for.
       dest       - output string, gets tokenized version of input.
        DestLength - length available in destination (should be at least as
                     twice as large as source + 2 bytes).@{b}

   RESULT@{ub}
        IsWild - 1 means there were wildcards in the pattern,
                 0 means there were no wildcards in the pattern,
                -1 means there was a buffer overflow or other error@{b}

   BUGS@{ub}
        In V37 this call didn't always set @{"IoErr()" LINK "IoErr"} to something useful on an
        error.  Fixed in V39.
        In V37, it didn't properly convert character-classes ([x-y]) to
        upper case.  Workaround: convert the input pattern to upper case
        using @{"ToUpper()" LINK "gg:doc/NDK/Guide/utility/ToUpper"} from @{"utility.library" LINK "gg:doc/NDK/Guide/utility/MAIN"} before calling
        @{"ParsePatternNoCase" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 706}().  Fixed in V39 dos.@{b}

   SEE ALSO@{ub}
        @{"ParsePattern()" LINK "ParsePattern"}, @{"MatchPatternNoCase()" LINK "MatchPatternNoCase"}, @{"MatchFirst()" LINK "MatchFirst"}, @{"MatchNext()" LINK "MatchNext"},
        @{"utility.library/ToUpper()" LINK "gg:doc/NDK/Guide/utility/ToUpper"}

@ENDNODE
@NODE "PathPart" "dos.library/PathPart()"
@{b}

   NAME@{ub}
        @{"PathPart" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 649} -- Returns a pointer to the end of the next-to-last (V36)
                    component of a path.@{b}

   SYNOPSIS@{ub}
        fileptr = @{"PathPart" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 649}( path )
        D0                   D1

        @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} @{"PathPart" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 649}( @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} )@{b}

   FUNCTION@{ub}
        This function returns a pointer to the character after the next-to-last
        component of a path specification, which will normally be the directory
        name.  If there is only one component, it returns a pointer to the
        beginning of the string.  The only real difference between this and
        @{"FilePart()" LINK "FilePart"} is the handling of '/'.@{b}

   INPUTS@{ub}
        path - pointer to an path string.  May be relative to the current
               directory or the current disk.@{b}

   RESULT@{ub}
        fileptr - pointer to the end of the next-to-last component of the path.@{b}

   EXAMPLE@{ub}
        @{"PathPart" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 649}("xxx:yyy/zzz/qqq") would return a pointer to the last '/'.
        @{"PathPart" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 649}("xxx:yyy") would return a pointer to the first 'y').@{b}

   SEE ALSO@{ub}
        @{"FilePart()" LINK "FilePart"}, @{"AddPart()" LINK "AddPart"}

@ENDNODE
@NODE "PrintFault" "dos.library/PrintFault()"
@{b}

   NAME@{ub}
        @{"PrintFault" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 372} -- Returns the text associated with a DOS error code (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"PrintFault" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 372}(code, header)
        D0                    D1     D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"PrintFault" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 372}(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

   FUNCTION@{ub}
        This routine obtains the error message text for the given error code.
        This is similar to the @{"Fault()" LINK "Fault"} function, except that the output is
        written to the default output channel with buffered output.
        The value returned by @{"IoErr()" LINK "IoErr"} is set to the code passed in.@{b}

   INPUTS@{ub}
        code   - Error code
        header - header to output before error text@{b}

   RESULT@{ub}
        success - Success/failure code.@{b}

   SEE ALSO@{ub}
        @{"IoErr()" LINK "IoErr"}, @{"Fault()" LINK "Fault"}, @{"SetIoErr()" LINK "SetIoErr"}, @{"Output()" LINK "Output"}, @{"FPuts()" LINK "FPuts"}

@ENDNODE
@NODE "PutStr" "dos.library/PutStr()"
@{b}

   NAME@{ub}
        @{"PutStr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 693} -- Writes a string the the default output (buffered) (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"PutStr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 693}(str)
        D0             D1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"PutStr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 693}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

   FUNCTION@{ub}
        This routine writes an unformatted string to the default output.  No
        newline is appended to the string and any error is returned.  This
        routine is buffered.@{b}

   INPUTS@{ub}
        str   - Null-terminated string to be written to default output@{b}

   RESULT@{ub}
        error - 0 for success, -1 for any error.  NOTE: this is opposite
                most Dos function returns!@{b}

   SEE ALSO@{ub}
        @{"FPuts()" LINK "FPuts"}, @{"FPutC()" LINK "FPutC"}, @{"FWrite()" LINK "FWrite"}, @{"WriteChars()" LINK "WriteChars"}

@ENDNODE
@NODE "Read" "dos.library/Read()"
@{b}

    NAME@{ub}
        Read -- Read bytes of data from a file@{b}

    SYNOPSIS@{ub}
        actualLength = Read( file, buffer, length )
        D0                   D1    D2      D3

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} Read(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, void *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

    FUNCTION@{ub}
        Data can be copied using a combination of Read() and @{"Write()" LINK "Write"}.
        Read() reads bytes of information from an opened file (represented
        here by the argument 'file') into the buffer given. The argument
        'length' is the length of the buffer given.

        The value returned is the length of the information actually read.
        So, when 'actualLength' is greater than zero, the value of
        'actualLength' is the the number of characters read. Usually Read
        will try to fill up your buffer before returning. A value of zero
        means that end-of-file has been reached. Errors are indicated by a
        value of -1.

        Note: this is an unbuffered routine (the request is passed directly
        to the filesystem.)  Buffered I/O is more efficient for small
        reads and writes; see @{"FGetC()" LINK "FGetC"}.@{b}

    INPUTS@{ub}
        file - BCPL pointer to a file handle
        buffer - pointer to buffer
        length - integer@{b}

    RESULTS@{ub}
        actualLength - integer@{b}

    SEE ALSO@{ub}
        @{"Open()" LINK "Open"}, @{"Close()" LINK "Close"}, @{"Write()" LINK "Write"}, @{"Seek()" LINK "Seek"}, @{"FGetC()" LINK "FGetC"}

@ENDNODE
@NODE "ReadArgs" "dos.library/ReadArgs()"
@{b}

   NAME@{ub}
        @{"ReadArgs" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 605} - Parse the command line input (V36)@{b}

   SYNOPSIS@{ub}
        result = @{"ReadArgs" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 605}(template, array, rdargs)
        D0                   D1      D2      D3

        @{"struct RDArgs" LINK "gg:doc/NDK/Guide/Include/dos/rdargs.h/File" 95} * @{"ReadArgs" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 605}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} *, @{"struct RDArgs" LINK "gg:doc/NDK/Guide/Include/dos/rdargs.h/File" 95} *)@{b}

   FUNCTION@{ub}
        Parses and argument string according to a template.  Normally gets
        the arguments by reading buffered IO from @{"Input()" LINK "Input"}, but also can be
        made to parse a string.  MUST be matched by a call to @{"FreeArgs()" LINK "FreeArgs"}.

        @{"ReadArgs" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 605}() parses the commandline according to a template that is
        passed to it.  This specifies the different command-line options and
        their types.  A template consists of a list of options.  Options are
        named in "full" names where possible (for example, "Quick" instead of
        "Q").  Abbreviations can also be specified by using "abbrev=option"
        (for example, "Q=Quick").

        Options in the template are separated by commas.  To get the results
        of @{"ReadArgs" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 605}(), you examine the array of longwords you passed to it
        (one entry per option in the template).  This array should be cleared
        (or initialized to your default values) before passing to @{"ReadArgs" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 605}().
        Exactly what is put in a given entry by @{"ReadArgs" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 605}() depends on the type
        of option.  The default is a string (a sequence of non-whitespace
        characters, or delimited by quotes, which will be stripped by
        @{"ReadArgs" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 605}()), in which case the entry will be a pointer.

        Options can be followed by modifiers, which specify things such as
        the type of the option.  Modifiers are specified by following the
        option with a '/' and a single character modifier.  Multiple modifiers
        can be specified by using multiple '/'s.  Valid modifiers are:

        /S - Switch.  This is considered a boolean variable, and will be
             set if the option name appears in the command-line.  The entry
             is the boolean (0 for not set, non-zero for set).

        /K - Keyword.  This means that the option will not be filled unless
             the keyword appears.  For example if the template is "Name/K",
             then unless "Name=<string>" or "Name <string>" appears in the
             command line, Name will not be filled.

        /N - Number.  This parameter is considered a decimal number, and will
             be converted by @{"ReadArgs" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 605}.  If an invalid number is specified,
             an error will be returned.  The entry will be a pointer to the
             longword number (this is how you know if a number was specified).

        /T - Toggle.  This is similar to a switch, but when specified causes
             the boolean value to "toggle".  Similar to /S.

        /A - Required.  This keyword must be given a value during command-line
             processing, or an error is returned.

        /F - Rest of line.  If this is specified, the entire rest of the line
             is taken as the parameter for the option, even if other option
             keywords appear in it.

        /M - Multiple strings.  This means the argument will take any number
             of strings, returning them as an array of strings.  Any arguments
             not considered to be part of another option will be added to this
             option.  Only one /M should be specified in a template.  Example:
             for a template "Dir/M,All/S" the command-line "foo bar all qwe"
             will set the boolean "all", and return an array consisting of
             "foo", "bar", and "qwe".  The entry in the array will be a pointer
             to an array of string pointers, the last of which will be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.

             There is an interaction between /M parameters and /A parameters.
             If there are unfilled /A parameters after parsing, it will grab
             strings from the end of a previous /M parameter list to fill the
             /A's.  This is used for things like Copy ("From/A/M,To/A").

        @{"ReadArgs" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 605}() returns a @{"struct RDArgs" LINK "gg:doc/NDK/Guide/Include/dos/rdargs.h/File" 95} if it succeeds.  This serves as an
        "anchor" to allow @{"FreeArgs()" LINK "FreeArgs"} to free the associated memory.  You can
        also pass in a @{"struct RDArgs" LINK "gg:doc/NDK/Guide/Include/dos/rdargs.h/File" 95} to control the operation of @{"ReadArgs" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 605}()
        (normally you pass @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for the parameter, and @{"ReadArgs" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 605}() allocates
        one for you).  This allows providing different sources for the
        arguments, providing your own string buffer space for temporary
        storage, and extended help text.  See <@{"dos/rdargs.h" LINK "gg:doc/NDK/Guide/Include/dos/rdargs.h/File"}> for more
        information on this.  Note: if you pass in a @{"struct RDArgs" LINK "gg:doc/NDK/Guide/Include/dos/rdargs.h/File" 95}, you must
        still call @{"FreeArgs()" LINK "FreeArgs"} to release storage that gets attached to it,
        but you are responsible for freeing the RDArgs yourself.

        If you pass in a RDArgs structure, you MUST reset (clear or set)
        RDA_Buffer for each new call to RDArgs.  The exact behavior if you
        don't do this varies from release to release and case to case; don't
        count on the behavior!

        See BUGS regarding passing in strings.@{b}

   INPUTS@{ub}
        template - formatting string
        array    - array of longwords for results, 1 per template entry
        rdargs   - optional rdargs structure for options.  @{"AllocDosObject" LINK "AllocDosObject"}
                   should be used for allocating them if you pass one in.@{b}

   RESULT@{ub}
        result   - a @{"struct RDArgs" LINK "gg:doc/NDK/Guide/Include/dos/rdargs.h/File" 95} or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} for failure.@{b}

   BUGS@{ub}
        In V36, there were a couple of minor bugs with certain argument
        combinations (/M/N returned strings, /T didn't work, and /K and
        /F interacted).  Also, a template with a /K before any non-switch
        parameter will require the argument name to be given in order for
        line to be accepted (i.e. "parm/K,xyzzy/A" would require
        "xyzzy=xxxxx" in order to work - "xxxxx" would not work).  If you
        need to avoid this for V36, put /K parameters after all non-switch
        parameters.  These problems should be fixed for V37.

        Currently (V37 and before) it requires any strings passed in to have
        newlines at the end of the string.  This may or may not be fixed in
        the future.@{b}

   SEE ALSO@{ub}
        @{"FindArg()" LINK "FindArg"}, @{"ReadItem()" LINK "ReadItem"}, @{"FreeArgs()" LINK "FreeArgs"}, @{"AllocDosObject()" LINK "AllocDosObject"}

@ENDNODE
@NODE "ReadItem" "dos.library/ReadItem()"
@{b}

   NAME@{ub}
        @{"ReadItem" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 613} - reads a single argument/name from command line (V36)@{b}

   SYNOPSIS@{ub}
        value = @{"ReadItem" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 613}(buffer, maxchars, input)
        D0                D1        D2      D3

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"ReadItem" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 613}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"struct CSource" LINK "gg:doc/NDK/Guide/Include/dos/rdargs.h/File" 61} *)@{b}

   FUNCTION@{ub}
        Reads a "word" from either @{"Input()" LINK "Input"} (buffered), or via CSource, if it
        is non-@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} (see <@{"dos/rdargs.h" LINK "gg:doc/NDK/Guide/Include/dos/rdargs.h/File"}> for more information).  Handles
        quoting and some '*' substitutions (*e and *n) inside quotes (only).
        See @{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"} for a listing of values returned by @{"ReadItem" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 613}()
        (ITEM_XXXX).  A "word" is delimited by whitespace, quotes, '=', or
        an EOF.

        @{"ReadItem" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 613} always unreads the last thing read (@{"UnGetC" LINK "UnGetC"}(fh,-1)) so the
        caller can find out what the terminator was.@{b}

   INPUTS@{ub}
        buffer   - buffer to store word in.
        maxchars - size of the buffer
        input    - CSource input or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} (uses @{"FGetC" LINK "FGetC"}(@{"Input()" LINK "Input"}))@{b}

   RESULT@{ub}
        value - See <@{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"}> for return values.@{b}

   BUGS@{ub}
        Doesn't actually unread the terminator.@{b}

   SEE ALSO@{ub}
        @{"ReadArgs()" LINK "ReadArgs"}, @{"FindArg()" LINK "FindArg"}, @{"UnGetC()" LINK "UnGetC"}, @{"FGetC()" LINK "FGetC"}, @{"Input()" LINK "Input"}, <@{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"}>,
        <@{"dos/rdargs.h" LINK "gg:doc/NDK/Guide/Include/dos/rdargs.h/File"}>, @{"FreeArgs()" LINK "FreeArgs"}

@ENDNODE
@NODE "ReadLink" "dos.library/ReadLink()"
@{b}

   NAME@{ub}
        @{"ReadLink" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 348} -- Reads the path for a soft filesystem link (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"ReadLink" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 348}( port, lock, path, buffer, size)
        D0                   D1    D2    D3     D4     D5

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"ReadLink" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 348}( @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *, @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{b}

   FUNCTION@{ub}
        @{"ReadLink" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 348}() takes a lock/name pair (usually from a failed attempt
        to use them to access an object with packets), and asks the
        filesystem to find the softlink and fill buffer with the modified
        path string.  You then start the resolution process again by
        calling @{"GetDeviceProc()" LINK "GetDeviceProc"} with the new string from @{"ReadLink" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 348}().

        Soft-links are resolved at access time by a combination of the
        filesystem (by returning @{"ERROR_IS_SOFT_LINK" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 219} to dos), and by
        Dos (using @{"ReadLink" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 348}() to resolve any links that are hit).@{b}

   INPUTS@{ub}
        port - msgport of the filesystem
        lock - lock this path is relative to on the filesystem
        path - path that caused the @{"ERROR_IS_SOFT_LINK" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 219}
        buffer - pointer to buffer for new path from handler.
        size - size of buffer.@{b}

   RESULT@{ub}
        Success - boolean@{b}

   BUGS@{ub}
        In V36, soft-links didn't work in the ROM filesystem.  This was
        fixed for V37.@{b}

   SEE ALSO@{ub}
        @{"MakeLink()" LINK "MakeLink"}, @{"Open()" LINK "Open"}, @{"Lock()" LINK "Lock"}, @{"GetDeviceProc()" LINK "GetDeviceProc"}

@ENDNODE
@NODE "Relabel" "dos.library/Relabel()"
@{b}

   NAME@{ub}
        Relabel -- Change the volume name of a volume (V36)@{b}

   SYNOPSIS@{ub}
        success = Relabel(volumename,name)
        D0                    D1      D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} Relabel(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

   FUNCTION@{ub}
        Changes the volumename of a volume, if supported by the filesystem.@{b}

   INPUTS@{ub}
        volumename - Full name of device to rename (with ':')
        newname    - New name to apply to device (without ':')@{b}

   RESULT@{ub}
        success    - Success/failure indicator@{b}

   SEE ALSO@{ub}

@ENDNODE
@NODE "RemAssignList" "dos.library/RemAssignList()"
@{b}

   NAME@{ub}
        @{"RemAssignList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 490} -- Remove an entry from a multi-dir assign (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"RemAssignList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 490}(name,lock)
        D0                       D1   D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"RemAssignList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 490}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67},@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

   FUNCTION@{ub}
        Removes an entry from a multi-directory assign.  The entry removed is
        the first one for which @{"SameLock" LINK "SameLock"} with 'lock' returns that they are on
        the same object.  The lock for the entry in the list is unlocked (not
        the entry passed in).@{b}

   INPUTS@{ub}
        name - Name of device to remove lock from (without trailing ':')
        lock - Lock associated with the object to remove from the list@{b}

   RESULT@{ub}
        success - Success/failure indicator.@{b}

   BUGS@{ub}
        In V36 through V39.23 dos, it would fail to remove the first lock
        in the assign.  Fixed in V39.24 dos (after the V39.106 kickstart).@{b}

   SEE ALSO@{ub}
        @{"Lock()" LINK "Lock"}, @{"AssignLock()" LINK "AssignLock"}, @{"AssignPath()" LINK "AssignPath"}, @{"AssignLate()" LINK "AssignLate"}, @{"DupLock()" LINK "DupLock"},
        @{"AssignAdd()" LINK "AssignAdd"}, @{"UnLock()" LINK "UnLock"}

@ENDNODE
@NODE "RemDosEntry" "dos.library/RemDosEntry()"
@{b}

   NAME@{ub}
        @{"RemDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 514} -- Removes a Dos List entry from it's list (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"RemDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 514}(dlist)
        D0                     D1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"RemDosEntry" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 514}(@{"struct DosList" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 372} *)@{b}

   FUNCTION@{ub}
        This removes an entry from the Dos Device list.  The memory associated
        with the entry is @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} freed.  NOTE: you must have locked the Dos List
        with the appropriate flags before calling this routine.  Handler
        writers should see the @{"AddDosEntry()" LINK "AddDosEntry"} caveats about locking and use
        a similar workaround to avoid deadlocks.@{b}

   INPUTS@{ub}
        dlist   - Device list entry to be removed.@{b}

   RESULT@{ub}
        success - Success/failure indicator@{b}

   SEE ALSO@{ub}
        @{"AddDosEntry()" LINK "AddDosEntry"}, @{"FindDosEntry()" LINK "FindDosEntry"}, @{"NextDosEntry()" LINK "NextDosEntry"}, @{"LockDosList()" LINK "LockDosList"},
        @{"MakeDosEntry()" LINK "MakeDosEntry"}, @{"FreeDosEntry()" LINK "FreeDosEntry"}

@ENDNODE
@NODE "RemSegment" "dos.library/RemSegment()"
@{b}

   NAME@{ub}
        @{"RemSegment" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 597} - Removes a resident segment from the resident list (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"RemSegment" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 597}(segment)
        D0                      D1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"RemSegment" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 597}(@{"struct Segment" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 299} *)@{b}

   FUNCTION@{ub}
        Removes a resident segment from the Dos resident segment list,
        unloads it, and does any other cleanup required.  Will only succeed
        if the seg_UC (usecount) is 0.@{b}

   INPUTS@{ub}
        segment - the segment to be removed@{b}

   RESULT@{ub}
        success - success or failure.@{b}

   SEE ALSO@{ub}
        @{"FindSegment()" LINK "FindSegment"}, @{"AddSegment()" LINK "AddSegment"}

@ENDNODE
@NODE "Rename" "dos.library/Rename()"
@{b}

    NAME@{ub}
        Rename -- Rename a directory or file@{b}

    SYNOPSIS@{ub}
        success = Rename( oldName, newName )
        D0                D1       D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} Rename(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

    FUNCTION@{ub}
        Rename() attempts to rename the file or directory specified as
        'oldName' with the name 'newName'. If the file or directory
        'newName' exists, Rename() fails and returns an error. Both
        'oldName' and the 'newName' can contain a directory specification.
        In this case, the file will be moved from one directory to another.

        Note: it is impossible to Rename() a file from one volume to
        another.@{b}

    INPUTS@{ub}
        oldName - pointer to a null-terminated string
        newName - pointer to a null-terminated string@{b}

    RESULTS@{ub}
        success - boolean@{b}

    SEE ALSO@{ub}
        @{"Relabel()" LINK "Relabel"}

@ENDNODE
@NODE "ReplyPkt" "dos.library/ReplyPkt()"
@{b}

   NAME@{ub}
        @{"ReplyPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 218} -- replies a packet to the person who sent it to you (V36)@{b}

   SYNOPSIS@{ub}
        @{"ReplyPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 218}(packet, result1, result2)
                   D1      D2       D3

        void @{"ReplyPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 218}(@{"struct DosPacket" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 108} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        This returns a packet to the process which sent it to you.  In
        addition, puts your pr_MsgPort address in dp_Port, so using @{"ReplyPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 218}()
        again will send the message to you.  (This is used in "ping-ponging"
        packets between two processes).  It uses result 1 & 2 to set the
        dp_Res1 and dp_Res2 fields of the packet.@{b}

   INPUTS@{ub}
        packet  - packet to reply, assumed to set up correctly.
        result1 - first result
        result2 - secondary result@{b}

   SEE ALSO@{ub}
        @{"DoPkt()" LINK "DoPkt"}, @{"SendPkt()" LINK "SendPkt"}, @{"WaitPkt()" LINK "WaitPkt"}, @{"IoErr()" LINK "IoErr"}

@ENDNODE
@NODE "RunCommand" "dos.library/RunCommand()"
@{b}

   NAME@{ub}
        @{"RunCommand" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 395} -- Runs a program using the current process (V36)@{b}

   SYNOPSIS@{ub}
        rc = @{"RunCommand" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 395}(seglist, stacksize, argptr, argsize)
        D0                D1         D2       D3      D4

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"RunCommand" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 395}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{b}

   FUNCTION@{ub}
        Runs a command on your process/cli.  Seglist may be any language,
        including BCPL programs.  Stacksize is in bytes.  argptr is a null-
        terminated string, argsize is its length.  Returns the returncode the
        program exited with in d0. Returns -1 if the stack couldn't be
        allocated.

        NOTE: the argument string MUST be terminated with a newline to work
        properly with @{"ReadArgs()" LINK "ReadArgs"} and other argument parsers.

        @{"RunCommand" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 395} also takes care of setting up the current input filehandle
        in such a way that @{"ReadArgs()" LINK "ReadArgs"} can be used in the program, and restores
        the state of the buffering before returning.  It also sets the value
        returned by @{"GetArgStr()" LINK "GetArgStr"}, and restores it before returning.  NOTE:
        the setting of the argument string in the filehandle was added in V37.

        It's usually appropriate to set the command name (via
        @{"SetProgramName()" LINK "SetProgramName"}) before calling @{"RunCommand" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 395}().  @{"RunCommand" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 395}() sets
        the value returned by @{"GetArgStr()" LINK "GetArgStr"} while the command is running.@{b}

   INPUTS@{ub}
        seglist   - Seglist of command to run.
        stacksize - Number of bytes to allocate for stack space
        argptr    - Pointer to argument command string.
        argsize   - Number of bytes in argument command.@{b}

   RESULT@{ub}
        rc        - Return code from executed command. -1 indicates failure@{b}

   SEE ALSO@{ub}
        @{"CreateNewProc()" LINK "CreateNewProc"}, @{"SystemTagList()" LINK "SystemTagList"}, @{"Execute()" LINK "Execute"}, @{"GetArgStr()" LINK "GetArgStr"},
        @{"SetProgramName()" LINK "SetProgramName"}, @{"ReadArgs()" LINK "ReadArgs"}

@ENDNODE
@NODE "SameDevice" "dos.library/SameDevice()"
@{b}

   NAME@{ub}
        @{"SameDevice" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 714} -- Are two locks are on partitions of the device? (V37)@{b}

   SYNOPSIS@{ub}
        same = @{"SameDevice" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 714}(lock1, lock2)
        D0                 D1     D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"SameDevice" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 714}( @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} )@{b}

   FUNCTION@{ub}
        @{"SameDevice" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 714}() returns whether two locks refer to partitions that
        are on the same physical device (if it can figure it out).  This
        may be useful in writing copy routines to take advantage of
        asynchronous multi-device copies.

        Entry existed in V36 and always returned 0.@{b}

   INPUTS@{ub}
        lock1,lock2 - locks@{b}

   RESULT@{ub}
        same - whether they're on the same device as far as Dos can determine.

@ENDNODE
@NODE "SameLock" "dos.library/SameLock()"
@{b}

   NAME@{ub}
        @{"SameLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 336} -- returns whether two locks are on the same object (V36)@{b}

   SYNOPSIS@{ub}
        value = @{"SameLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 336}(lock1, lock2)
        D0                D1     D2

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"SameLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 336}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

   FUNCTION@{ub}
        Compares two locks.  Returns @{"LOCK_SAME" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 252} if they are on the same object,
        @{"LOCK_SAME_VOLUME" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 253} if on different objects on the same volume, and
        @{"LOCK_DIFFERENT" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 251} if they are on different volumes.  Always compare
        for equality or non-equality with the results, in case new return
        values are added.@{b}

   INPUTS@{ub}
        lock1 - 1st lock for comparison
        lock2 - 2nd lock for comparison@{b}

   RESULT@{ub}
        value - @{"LOCK_SAME" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 252}, @{"LOCK_SAME_VOLUME" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 253}, or @{"LOCK_DIFFERENT" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 251}@{b}

   BUGS@{ub}
        Should do more extensive checks for @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} against a real lock, checking
        to see if the real lock is a lock on the root of the boot volume.

        In V36, it would return @{"LOCK_SAME_VOLUME" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 253} for different volumes on the
        same handler.  Also, @{"LOCK_SAME_VOLUME" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 253} was @{"LOCK_SAME_HANDLER" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 254} (now
        an obsolete define, see <@{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"}>).@{b}

   SEE ALSO@{ub}
        <@{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"}>

@ENDNODE
@NODE "Seek" "dos.library/Seek()"
@{b}

    NAME@{ub}
        Seek -- Set the current position for reading and writing@{b}

    SYNOPSIS@{ub}
        oldPosition = Seek( file, position, mode )
        D0                  D1    D2        D3

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} Seek(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

    FUNCTION@{ub}
        Seek() sets the read/write cursor for the file 'file' to the
        position 'position'. This position is used by both @{"Read()" LINK "Read"} and
        @{"Write()" LINK "Write"} as a place to start reading or writing. The result is the
        current absolute position in the file, or -1 if an error occurs, in
        which case @{"IoErr()" LINK "IoErr"} can be used to find more information. 'mode' can
        be @{"OFFSET_BEGINNING" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 34}, @{"OFFSET_CURRENT" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 35} or @{"OFFSET_END" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 36}. It is used to
        specify the relative start position. For example, 20 from current
        is a position 20 bytes forward from current, -20 is 20 bytes back
        from current.

        So that to find out where you are, seek zero from current. The end
        of the file is a Seek() positioned by zero from end. You cannot
        Seek() beyond the end of a file.@{b}

    INPUTS@{ub}
        file - BCPL pointer to a file handle
        position - integer
        mode - integer@{b}

    RESULTS@{ub}
        oldPosition - integer@{b}

    BUGS@{ub}
        The V36 and V37 ROM filesystem (and V36/V37 l:fastfilesystem)
        returns the current position instead of -1 on an error.  It sets
        @{"IoErr()" LINK "IoErr"} to 0 on success, and an error code on an error.  This bug
        was fixed in the V39 filesystem.@{b}

    SEE ALSO@{ub}
        @{"Read()" LINK "Read"}, @{"Write()" LINK "Write"}, @{"SetFileSize()" LINK "SetFileSize"}

@ENDNODE
@NODE "SelectInput" "dos.library/SelectInput()"
@{b}

   NAME@{ub}
        @{"SelectInput" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 242} -- Select a filehandle as the default input channel (V36)@{b}

   SYNOPSIS@{ub}
        old_fh = @{"SelectInput" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 242}(fh)
        D0                   D1

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} @{"SelectInput" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 242}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

   FUNCTION@{ub}
        Set the current input as the default input for the process.
        This changes the value returned by @{"Input()" LINK "Input"}.  old_fh should
        be closed or saved as needed.@{b}

   INPUTS@{ub}
        fh     - Newly default input handle@{b}

   RESULT@{ub}
        old_fh - Previous default input filehandle@{b}

   SEE ALSO@{ub}
        @{"Input()" LINK "Input"}, @{"SelectOutput()" LINK "SelectOutput"}, @{"Output()" LINK "Output"}

@ENDNODE
@NODE "SelectOutput" "dos.library/SelectOutput()"
@{b}

   NAME@{ub}
        @{"SelectOutput" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 246} -- Select a filehandle as the default output channel (V36)@{b}

   SYNOPSIS@{ub}
        old_fh = @{"SelectOutput" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 246}(fh)
        D0                    D1

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} @{"SelectOutput" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 246}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

   FUNCTION@{ub}
        Set the current output as the default output for the process.
        This changes the value returned by @{"Output()" LINK "Output"}.  old_fh should
        be closed or saved as needed.@{b}

   INPUTS@{ub}
        fh     - Newly desired output handle@{b}

   RESULT@{ub}
        old_fh - Previous current output@{b}

   SEE ALSO@{ub}
        @{"Output()" LINK "Output"}, @{"SelectInput()" LINK "SelectInput"}, @{"Input()" LINK "Input"}

@ENDNODE
@NODE "SendPkt" "dos.library/SendPkt()"
@{b}

   NAME@{ub}
        @{"SendPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 210} -- Sends a packet to a handler (V36)@{b}

   SYNOPSIS@{ub}
        @{"SendPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 210}(packet, port, replyport)
                 D1     D2      D3

        void @{"SendPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 210}(@{"struct DosPacket" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 108} *,@{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *,@{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *)@{b}

   FUNCTION@{ub}
        Sends a packet to a handler and does not wait.  All fields in the
        packet must be initialized before calling this routine.  The packet
        will be returned to replyport.  If you wish to use this with
        @{"WaitPkt()" LINK "WaitPkt"}, use the address of your pr_MsgPort for replyport.@{b}

   INPUTS@{ub}
        packet - packet to send, must be initialized and have a message.
        port   - pr_MsgPort of handler process to send to.
        replyport - MsgPort for the packet to come back to.@{b}

   NOTES@{ub}
        Callable from a task.@{b}

   SEE ALSO@{ub}
        @{"DoPkt()" LINK "DoPkt"}, @{"WaitPkt()" LINK "WaitPkt"}, @{"AllocDosObject()" LINK "AllocDosObject"}, @{"FreeDosObject()" LINK "FreeDosObject"}, @{"AbortPkt()" LINK "AbortPkt"}

@ENDNODE
@NODE "SetArgStr" "dos.library/SetArgStr()"
@{b}

   NAME@{ub}
        @{"SetArgStr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 419} -- Sets the arguments for the current process (V36)@{b}

   SYNOPSIS@{ub}
        oldptr = @{"SetArgStr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 419}(ptr)
        D0                 D1

        @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67} @{"SetArgStr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 419}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

   FUNCTION@{ub}
        Sets the arguments for the current program.  The ptr MUST be reset
        to it's original value before process exit.@{b}

   INPUTS@{ub}
        ptr - pointer to new argument string.@{b}

   RESULT@{ub}
        oldptr - the previous argument string@{b}

   SEE ALSO@{ub}
        @{"GetArgStr()" LINK "GetArgStr"}, @{"RunCommand()" LINK "RunCommand"}

@ENDNODE
@NODE "SetComment" "dos.library/SetComment()"
@{b}

    NAME@{ub}
        @{"SetComment" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 139} -- Change a files' comment string@{b}

    SYNOPSIS@{ub}
        success = @{"SetComment" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 139}( name, comment )
        D0                    D1    D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"SetComment" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 139}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

    FUNCTION@{ub}
        @{"SetComment" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 139}() sets a comment on a file or directory. The comment is
        a pointer to a null-terminated string of up to 80 characters in the
        current ROM filesystem (and RAM:).  Note that not all filesystems
        will support comments (for example, NFS usually will not), or the
        size of comment supported may vary.@{b}

    INPUTS@{ub}
        name    - pointer to a null-terminated string
        comment - pointer to a null-terminated string@{b}

    RESULTS@{ub}
        success - boolean@{b}

    SEE ALSO@{ub}
        @{"Examine()" LINK "Examine"}, @{"ExNext()" LINK "ExNext"}, @{"SetProtection()" LINK "SetProtection"}

@ENDNODE
@NODE "SetConsoleTask" "dos.library/SetConsoleTask()"
@{b}

   NAME@{ub}
        @{"SetConsoleTask" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 403} -- Sets the default console for the process (V36)@{b}

   SYNOPSIS@{ub}
        oldport = @{"SetConsoleTask" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 403}(port)
        D0                        D1

        @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *@{"SetConsoleTask" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 403}(@{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *)@{b}

   FUNCTION@{ub}
        Sets the default console task's port (pr_ConsoleTask) for the
        current process.@{b}

   INPUTS@{ub}
        port - The pr_MsgPort of the default console handler for the process@{b}

   RESULT@{ub}
        oldport - The previous ConsoleTask value.@{b}

   SEE ALSO@{ub}
        @{"GetConsoleTask()" LINK "GetConsoleTask"}, @{"Open()" LINK "Open"}

@ENDNODE
@NODE "SetCurrentDirName" "dos.library/SetCurrentDirName()"
@{b}

   NAME@{ub}
        @{"SetCurrentDirName" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 431} -- Sets the directory name for the process (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"SetCurrentDirName" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 431}(name)
        D0                        D1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"SetCurrentDirName" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 431}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

   FUNCTION@{ub}
        Sets the name for the current dir in the cli structure.  If the name
        is too long to fit, a failure is returned, and the old value is left
        intact.  It is advised that you inform the user of this condition.
        This routine is safe to call even if there is no CLI structure.@{b}

   INPUTS@{ub}
        name    - Name of directory to be set.@{b}

   RESULT@{ub}
        success - Success/failure indicator@{b}

   BUGS@{ub}
        This clips to a fixed (1.3 compatible) size.@{b}

   SEE ALSO@{ub}
        @{"GetCurrentDirName()" LINK "GetCurrentDirName"}

@ENDNODE
@NODE "SetFileDate" "dos.library/SetFileDate()"
@{b}

   NAME@{ub}
        @{"SetFileDate" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 320} -- Sets the modification date for a file or dir (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"SetFileDate" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 320}(name, date)
        D0                     D1    D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"SetFileDate" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 320}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"struct DateStamp" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 52} *)@{b}

   FUNCTION@{ub}
        Sets the file date for a file or directory.  Note that for the Old
        File System and the Fast File System, the date of the root directory
        cannot be set.  Other filesystems may not support setting the date
        for all files/directories.@{b}

   INPUTS@{ub}
        name - Name of object
        date - New modification date@{b}

   RESULT@{ub}
        success - Success/failure indication@{b}

   SEE ALSO@{ub}
        @{"DateStamp()" LINK "DateStamp"}, @{"Examine()" LINK "Examine"}, @{"ExNext()" LINK "ExNext"}, @{"ExAll()" LINK "ExAll"}

@ENDNODE
@NODE "SetFileSize" "dos.library/SetFileSize()"
@{b}

   NAME@{ub}
        @{"SetFileSize" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 360} -- Sets the size of a file (V36)@{b}

   SYNOPSIS@{ub}
        newsize = @{"SetFileSize" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 360}(fh, offset, mode)
        D0                    D1    D2     D3

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"SetFileSize" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 360}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        Changes the file size, truncating or extending as needed.  Not all
        handlers may support this; be careful and check the return code.  If
        the file is extended, no values should be assumed for the new bytes.
        If the new position would be before the filehandle's current position
        in the file, the filehandle will end with a position at the
        end-of-file.  If there are other filehandles open onto the file, the
        new size will not leave any filehandle pointing past the end-of-file.
        You can check for this by looking at the new size (which would be
        different than what you requested).

        The seek position should not be changed unless the file is made
        smaller than the current seek position.  However, see BUGS.

        Do @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} count on any specific values to be in any extended area.@{b}

   INPUTS@{ub}
        fh     - File to be truncated/extended.
        offset - Offset from position determined by mode.
        mode   - One of @{"OFFSET_BEGINNING" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 34}, @{"OFFSET_CURRENT" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 35}, or @{"OFFSET_END" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 36}.@{b}

   RESULT@{ub}
        newsize - position of new end-of-file or -1 for error.@{b}

   BUGS@{ub}
        The RAM: filesystem and the normal Amiga filesystem act differently
        in where the file position is left after @{"SetFileSize" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 360}().  RAM: leaves
        you at the new end of the file (incorrectly), while the Amiga ROM
        filesystem leaves the seek position alone, unless the new position
        is less than the current position, in which case you're left at the
        new EOF.

        The best workaround is to not make any assumptions about the seek
        position after @{"SetFileSize" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 360}().@{b}

   SEE ALSO@{ub}
        @{"Seek()" LINK "Seek"}

@ENDNODE
@NODE "SetFileSysTask" "dos.library/SetFileSysTask()"
@{b}

   NAME@{ub}
        @{"SetFileSysTask" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 411} -- Sets the default filesystem for the process (V36)@{b}

   SYNOPSIS@{ub}
        oldport = @{"SetFileSysTask" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 411}(port)
        D0                        D1

        @{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *@{"SetFileSysTask" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 411}(@{"struct MsgPort" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File" 28} *)@{b}

   FUNCTION@{ub}
        Sets the default filesystem task's port (pr_FileSystemTask) for the
        current process.@{b}

   INPUTS@{ub}
        port - The pr_MsgPort of the default filesystem for the process@{b}

   RESULT@{ub}
        oldport - The previous FileSysTask value@{b}

   SEE ALSO@{ub}
        @{"GetFileSysTask()" LINK "GetFileSysTask"}, @{"Open()" LINK "Open"}

@ENDNODE
@NODE "SetIoErr" "dos.library/SetIoErr()"
@{b}

   NAME@{ub}
        @{"SetIoErr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 364} -- Sets the value returned by @{"IoErr()" LINK "IoErr"} (V36)@{b}

   SYNOPSIS@{ub}
        oldcode = @{"SetIoErr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 364}(code)
        D0                  D1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"SetIoErr" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 364}(@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

   FUNCTION@{ub}
        This routine sets up the secondary result (pr_Result2) return code
        (returned by the @{"IoErr()" LINK "IoErr"} function).@{b}

   INPUTS@{ub}
        code - Code to be returned by a call to @{"IoErr" LINK "IoErr"}.@{b}

   RESULT@{ub}
        oldcode - The previous error code.@{b}

   SEE ALSO@{ub}
        @{"IoErr()" LINK "IoErr"}, @{"Fault()" LINK "Fault"}, @{"PrintFault()" LINK "PrintFault"}

@ENDNODE
@NODE "SetMode" "dos.library/SetMode()"
@{b}

   NAME@{ub}
        @{"SetMode" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 340} - Set the current behavior of a handler (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"SetMode" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 340}(fh, mode)
        D0                D1  D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"SetMode" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 340}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        @{"SetMode" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 340}() sends an @{"ACTION_SCREEN_MODE" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 177} packet to the handler in
        question, normally for changing a CON: handler to raw mode or
        vice-versa.  For CON:, use 1 to go to RAW: mode, 0 for CON: mode.@{b}

   INPUTS@{ub}
        fh   - filehandle
        mode - The new mode you want@{b}

   RESULT@{ub}
        success - Boolean@{b}

   SEE ALSO@{ub}

@ENDNODE
@NODE "SetOwner" "dos.library/SetOwner()"
@{b}

    NAME@{ub}
        @{"SetOwner" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 722} -- Set owner information for a file or directory (V39)@{b}

    SYNOPSIS@{ub}
        success = @{"SetOwner" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 722}( name, owner_info )
        D0                   D1       D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"SetOwner" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 722} (@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

    FUNCTION@{ub}
        @{"SetOwner" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 722}() sets the owner information for the file or directory.
        This value is a 32-bit value that is normally split into 16 bits
        of owner user id (bits 31-16), and 16 bits of owner group id (bits
        15-0).  However, other than returning them as shown by @{"Examine()" LINK "Examine"}/
        @{"ExNext()" LINK "ExNext"}/@{"ExAll()" LINK "ExAll"}, the filesystem take no interest in the values.
        These are primarily for use by networking software (clients and
        hosts), in conjunction with the FIBF_OTR_xxx and FIBF_GRP_xxx
        protection bits.

        This entrypoint did not exist in V36, so you must open at least V37
        dos.library to use it.  V37 dos.library will return @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} to this
        call.@{b}

    INPUTS@{ub}
        name       - pointer to a null-terminated string
        owner_info - owner uid (31:16) and group id (15:0)@{b}

    RESULTS@{ub}
        success - boolean@{b}

    SEE ALSO@{ub}
        SetProtect(), @{"Examine()" LINK "Examine"}, @{"ExNext()" LINK "ExNext"}, @{"ExAll()" LINK "ExAll"}, <@{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"}>

@ENDNODE
@NODE "SetProgramDir" "dos.library/SetProgramDir()"
@{b}

   NAME@{ub}
        @{"SetProgramDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 455} -- Sets the directory returned by @{"GetProgramDir" LINK "GetProgramDir"} (V36)@{b}

   SYNOPSIS@{ub}
        oldlock = @{"SetProgramDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 455}(lock)
        D0                       D1

        @{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130} @{"SetProgramDir" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 455}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

   FUNCTION@{ub}
        Sets a shared lock on the directory the program was loaded from.
        This can be used for a program to find data files, etc, that are
        stored with the program, or to find the program file itself.  @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
        is a valid input.  This can be accessed via @{"GetProgramDir()" LINK "GetProgramDir"} or
        by using paths relative to PROGDIR:.@{b}

   INPUTS@{ub}
        lock - A lock on the directory the current program was loaded from@{b}

   RESULT@{ub}
        oldlock - The previous ProgramDir.@{b}

   SEE ALSO@{ub}
        @{"GetProgramDir()" LINK "GetProgramDir"}, @{"Open()" LINK "Open"}

@ENDNODE
@NODE "SetProgramName" "dos.library/SetProgramName()"
@{b}

   NAME@{ub}
        @{"SetProgramName" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 439} -- Sets the name of the program being run (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"SetProgramName" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 439}(name)
        D0                        D1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"SetProgramName" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 439}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

   FUNCTION@{ub}
        Sets the name for the program in the cli structure.  If the name is
        too long to fit, a failure is returned, and the old value is left
        intact.  It is advised that you inform the user if possible of this
        condition, and/or set the program name to an empty string.
        This routine is safe to call even if there is no CLI structure.@{b}

   INPUTS@{ub}
        name    - Name of program to use.@{b}

   RESULT@{ub}
        success - Success/failure indicator.@{b}

   BUGS@{ub}
        This clips to a fixed (1.3 compatible) size.@{b}

   SEE ALSO@{ub}
        @{"GetProgramName()" LINK "GetProgramName"}

@ENDNODE
@NODE "SetPrompt" "dos.library/SetPrompt()"
@{b}

   NAME@{ub}
        @{"SetPrompt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 447} -- Sets the CLI/shell prompt for the current process (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"SetPrompt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 447}(name)
        D0                D1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"SetPrompt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 447}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67})@{b}

   FUNCTION@{ub}
        Sets the text for the prompt in the cli structure.  If the prompt is
        too long to fit, a failure is returned, and the old value is left
        intact.  It is advised that you inform the user of this condition.
        This routine is safe to call even if there is no CLI structure.@{b}

   INPUTS@{ub}
        name    - Name of prompt to be set.@{b}

   RESULT@{ub}
        success - Success/failure indicator.@{b}

   BUGS@{ub}
        This clips to a fixed (1.3 compatible) size.@{b}

   SEE ALSO@{ub}
        @{"GetPrompt()" LINK "GetPrompt"}

@ENDNODE
@NODE "SetProtection" "dos.library/SetProtection()"
@{b}

    NAME@{ub}
        @{"SetProtection" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 143} -- Set protection for a file or directory@{b}

    SYNOPSIS@{ub}
        success = @{"SetProtection" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 143}( name, mask )
        D0                       D1    D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"SetProtection" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 143} (@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

    FUNCTION@{ub}
        @{"SetProtection" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 143}() sets the protection attributes on a file or
        directory.  See <@{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"}> for a listing of protection bits.

        Before V36, the ROM filesystem didn't respect the Read and Write
        bits.  In V36 or later and in the FFS, the Read and Write
        bits are respected.

        The archive bit should be cleared by the filesystem whenever the file
        is changed.  Backup utilities will generally set the bit after
        backing up each file.

        The V36 Shell looks at the execute bit, and will refuse to execute
        a file if it is set.

        Other bits will be defined in the <@{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"}> include files.  Rather
        than referring to bits by number you should use the definitions in
        <@{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"}>.@{b}

    INPUTS@{ub}
        name - pointer to a null-terminated string
        mask - the protection mask required@{b}

    RESULTS@{ub}
        success - boolean@{b}

    SEE ALSO@{ub}
        @{"SetComment()" LINK "SetComment"}, @{"Examine()" LINK "Examine"}, @{"ExNext()" LINK "ExNext"}, <@{"dos/dos.h" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File"}>

@ENDNODE
@NODE "SetVar" "dos.library/SetVar()"
@{b}

   NAME@{ub}
        @{"SetVar" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 665} -- Sets a local or environment variable (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"SetVar" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 665}( name, buffer, size, flags )
        D0                 D1     D2     D3    D4

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"SetVar" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 665}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} )@{b}

   FUNCTION@{ub}
        Sets a local or environment variable.  It is advised to only use
        ASCII strings inside variables, but not required.@{b}

   INPUTS@{ub}
        name   - pointer to an variable name.  Note variable names follow
                 filesystem syntax and semantics.
        buffer - a user allocated area which contains a string that is the
                 value to be associated with this variable.
        size   - length of the buffer region in bytes.  -1 means buffer
                 contains a null-terminated string.
        flags  - combination of type of var to set (low 8 bits), and
                 flags to control the behavior of this routine.  Currently
                 defined flags include:

                @{"GVF_LOCAL_ONLY" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File" 50} - set a local (to your process) variable.
                @{"GVF_GLOBAL_ONLY" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File" 48} - set a global environment variable.

                The default is to set a local environment variable.@{b}

   RESULT@{ub}
        success - If non-zero, the variable was sucessfully set, @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}
                  indicates failure.@{b}

   BUGS@{ub}
        @{"LV_VAR" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File" 38} is the only type that can be global@{b}

   SEE ALSO@{ub}
        @{"GetVar()" LINK "GetVar"}, @{"DeleteVar()" LINK "DeleteVar"}, @{"FindVar()" LINK "FindVar"}, <@{"dos/var.h" LINK "gg:doc/NDK/Guide/Include/dos/var.h/File"}>

@ENDNODE
@NODE "SetVBuf" "dos.library/SetVBuf()"
@{b}

   NAME@{ub}
        @{"SetVBuf" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 300} -- set buffering modes and size (V39)@{b}

   SYNOPSIS@{ub}
        error = @{"SetVBuf" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 300}(fh, buff, type, size)
        D0              D1   D2    D3    D4

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"SetVBuf" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 300}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        Changes the buffering modes and buffer size for a filehandle.
        With buff == @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, the current buffer will be deallocated and a
        new one of (approximately) size will be allocated.  If buffer is
        non-@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, it will be used for buffering and must be at least
        max(size,208) bytes long, and MUST be longword aligned.  If size
        is -1, then only the buffering mode will be changed.

        Note that a user-supplied buffer will not be freed if it is later
        replaced by another @{"SetVBuf" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 300}() call, nor will it be freed if the
        filehandle is closed.

        Has no effect on the buffersize of filehandles that were not created
        by @{"AllocDosObject()" LINK "AllocDosObject"}.@{b}

   INPUTS@{ub}
        fh   - Filehandle
        buff - buffer pointer for buffered I/O or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.  MUST be @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}-aligned!
        type - buffering mode (see <@{"dos/stdio.h" LINK "gg:doc/NDK/Guide/Include/dos/stdio.h/File"}>)
        size - size of buffer for buffered I/O (sizes less than 208 bytes
               will be rounded up to 208), or -1.@{b}

   RESULT@{ub}
        error - 0 if successful.  NOTE: opposite of most dos functions!
                NOTE: fails if someone has replaced the buffer without
                using @{"SetVBuf" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 300}() - @{"RunCommand()" LINK "RunCommand"} does this.  Remember to
                check error before freeing user-supplied buffers!@{b}

   BUGS@{ub}
        Not implemented until after V39.  From V36 up to V39, always
        returned 0.@{b}

   SEE ALSO@{ub}
        FputC(), @{"FGetC()" LINK "FGetC"}, @{"UnGetC()" LINK "UnGetC"}, @{"Flush()" LINK "Flush"}, @{"FRead()" LINK "FRead"}, @{"FWrite()" LINK "FWrite"}, @{"FGets()" LINK "FGets"},
        @{"FPuts()" LINK "FPuts"}, @{"AllocDosObject()" LINK "AllocDosObject"}

@ENDNODE
@NODE "SplitName" "dos.library/SplitName()"
@{b}

   NAME@{ub}
        @{"SplitName" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 332} -- splits out a component of a pathname into a buffer (V36)@{b}

   SYNOPSIS@{ub}
        newpos = @{"SplitName" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 332}(name, separator, buf, oldpos, size)
        D0                  D1      D2      D3     D4     D5

        @{"WORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 54} @{"SplitName" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 332}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"WORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 54}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        This routine splits out the next piece of a name from a given file
        name.  Each piece is copied into the buffer, truncating at size-1
        characters.  The new position is then returned so that it may be
        passed in to the next call to splitname.  If the separator is not
        found within 'size' characters, then size-1 characters plus a null will
        be put into the buffer, and the position of the next separator will
        be returned.

        If a a separator cannot be found, -1 is returned (but the characters
        from the old position to the end of the string are copied into the
        buffer, up to a maximum of size-1 characters).  Both strings are
        null-terminated.

        This function is mainly intended to support handlers.@{b}

   INPUTS@{ub}
        name      - Filename being parsed.
        separator - Separator charactor to split by.
        buf       - Buffer to hold separated name.
        oldpos    - Current position in the file.
        size      - Size of buf in bytes (including null termination).@{b}

   RESULT@{ub}
        newpos    - New position for next call to splitname.  -1 for last one.@{b}

   BUGS@{ub}
        In V36 and V37, path portions greater than or equal to 'size' caused
        the last character of the portion to be lost when followed by a
        separator.  Fixed for V39 dos.  For V36 and V37, the suggested work-
        around is to call @{"SplitName" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 332}() with a buffer one larger than normal
        (for example, 32 bytes), and then set buf[size-2] to '0' (for example,
        buf[30] = '\\0';).@{b}

   SEE ALSO@{ub}
        @{"FilePart()" LINK "FilePart"}, @{"PathPart()" LINK "PathPart"}, @{"AddPart()" LINK "AddPart"}

@ENDNODE
@NODE "StartNotify" "dos.library/StartNotify()"
@{b}

   NAME@{ub}
        @{"StartNotify" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 657} -- Starts notification on a file or directory (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"StartNotify" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 657}(notifystructure)
        D0                          D1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"StartNotify" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 657}(@{"struct NotifyRequest" LINK "gg:doc/NDK/Guide/Include/dos/notify.h/File" 51} *)@{b}

   FUNCTION@{ub}
        Posts a notification request.  Do not modify the notify structure while
        it is active.  You will be notified when the file or directory changes.
        For files, you will be notified after the file is closed.  Not all
        filesystems will support this: applications should @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} require it.  In
        particular, most network filesystems won't support it.@{b}

   INPUTS@{ub}
        notifystructure - A filled-in NotifyRequest structure@{b}

   RESULT@{ub}
        success - Success/failure of request@{b}

   BUGS@{ub}
        The V36 floppy/HD filesystem doesn't actually send notifications.  The
        V36 ram handler (ram:) does.  This has been fixed for V37.@{b}

   SEE ALSO@{ub}
        @{"EndNotify()" LINK "EndNotify"}, <@{"dos/notify.h" LINK "gg:doc/NDK/Guide/Include/dos/notify.h/File"}>

@ENDNODE
@NODE "StrToDate" "dos.library/StrToDate()"
@{b}

   NAME@{ub}
        @{"StrToDate" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 566} -- Converts a string to a @{"DateStamp" LINK "DateStamp"} (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"StrToDate" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 566}( datetime )
        D0                      D1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"StrToDate" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 566}( @{"struct DateTime" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 25} * )@{b}

   FUNCTION@{ub}
        Converts a human readable ASCII string into an AmigaDOS
        @{"DateStamp" LINK "DateStamp"}.@{b}

   INPUTS@{ub}
        DateTime - a pointer to an initialized DateTime structure.

        The DateTime structure should   be initialized as follows:

        dat_Stamp  - ignored on input.

        dat_Format - a format   byte which specifies the format of the
                dat_StrDat.  This can   be any of the following (note:
                If value used   is something other than those below,
                the default of @{"FORMAT_DOS" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 48} is used):

                @{"FORMAT_DOS" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 48}:       AmigaDOS format (dd-mmm-yy).

                @{"FORMAT_INT" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 49}:       International format (yy-mmm-dd).

                @{"FORMAT_USA" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 50}:       American format (mm-dd-yy).

                @{"FORMAT_CDN" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 51}:       Canadian format (dd-mm-yy).

                @{"FORMAT_DEF" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 53}:       default format for locale.

        dat_Flags - a flags byte.  The only flag which affects this
                  function is:

                @{"DTF_SUBST" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 40}:      ignored by this function
                @{"DTF_FUTURE" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 42}:       If set, indicates that strings such
                                  as (stored in dat_StrDate) "Monday"
                                  refer to "next" monday. Otherwise,
                                  if clear, strings like "Monday"
                                  refer to "last" monday.

        dat_StrDay - ignored bythis function.

        dat_StrDate -   pointer to valid string representing the date.
                  This can be a "@{"DTF_SUBST" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File" 40}" style string such as
                  "Today" "Tomorrow" "Monday", or it may be a string
                  as specified by the dat_Format byte.  This will be
                  converted to the ds_Days portion of the @{"DateStamp" LINK "DateStamp"}.
                  If this pointer is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, @{"DateStamp" LINK "DateStamp"}->ds_Days will not
                  be affected.

        dat_StrTime -   Pointer to a buffer which contains the time in
                  the ASCII format hh:mm:ss.  This will be converted
                  to the ds_Minutes and ds_Ticks portions of the
                  @{"DateStamp" LINK "DateStamp"}.  If this pointer is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, ds_Minutes and
                  ds_Ticks will be unchanged.@{b}

   RESULT@{ub}
        success - a zero return indicates that a conversion could
                not be performed. A non-zero return indicates that the
                DateTime.dat_Stamp variable contains the converted
                values.@{b}

   SEE ALSO@{ub}
        @{"DateStamp()" LINK "DateStamp"}, @{"DateToStr()" LINK "DateToStr"}, <@{"dos/datetime.h" LINK "gg:doc/NDK/Guide/Include/dos/datetime.h/File"}>

@ENDNODE
@NODE "StrToLong" "dos.library/StrToLong()"
@{b}

   NAME@{ub}
        @{"StrToLong" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 617} -- string to long value (decimal) (V36)@{b}

   SYNOPSIS@{ub}
        characters = @{"StrToLong" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 617}(string,value)
        D0                       D1    D2

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"StrToLong" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 617}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} *)@{b}

   FUNCTION@{ub}
        Converts decimal string into @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} value.  Returns number of characters
        converted.  Skips over leading spaces & tabs (included in count).  If
        no decimal digits are found (after skipping leading spaces & tabs),
        @{"StrToLong" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 617} returns -1 for characters converted, and puts 0 into value.@{b}

   INPUTS@{ub}
        string - Input string.
        value  - Pointer to long value.  Set to 0 if no digits are converted.@{b}

   RESULT@{ub}
        result - Number of characters converted or -1.@{b}

   BUGS@{ub}
        Before V39, if there were no convertible characters it returned the
        number of leading white-space characters (space and tab in this case).

@ENDNODE
@NODE "SystemTagList" "dos.library/SystemTagList()"
@{b}

   NAME@{ub}
        @{"SystemTagList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 463} -- Have a shell execute a command line (V36)@{b}

   SYNOPSIS@{ub}
        error = @{"SystemTagList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 463}(command, tags)
        D0                      D1      D2

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"SystemTagList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 463}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *)

        error = System(command, tags)
        D0               D1      D2

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} System(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"struct TagItem" LINK "gg:doc/NDK/Guide/Include/utility/tagitem.h/File" 32} *)

        error = @{"SystemTags" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 470}(command, Tag1, ...)

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"SystemTags" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 470}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}, ...)@{b}

   FUNCTION@{ub}
        Similar to @{"Execute()" LINK "Execute"}, but does not read commands from the input
        filehandle.  Spawns a Shell process to execute the command, and
        returns the returncode the command produced, or -1 if the command
        could not be run for any reason.  The input and output filehandles
        will not be closed by System, you must close them (if needed) after
        System returns, if you specified them via @{"SYS_Input" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 23} or @{"SYS_Output" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 25}.

        By default the new process will use your current @{"Input()" LINK "Input"} and @{"Output()" LINK "Output"}
        filehandles.  Normal Shell command-line parsing will be done
        including redirection on 'command'.  The current directory and path
        will be inherited from your process.  Your path will be used to find
        the command (if no path is specified).

        Note that you may @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} pass the same filehandle for both @{"SYS_Input" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 23}
        and @{"SYS_Output" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 25}.  If you want input and output to both be to the same
        CON: window, pass a @{"SYS_Input" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 23} of a filehandle on the CON: window,
        and pass a @{"SYS_Output" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 25} of @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}.  The shell will automatically set
        the default @{"Output()" LINK "Output"} stream to the window you passed via @{"SYS_Input" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 23},
        by opening "*" on that handler.

        If used with the @{"SYS_Asynch" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 27} flag, it WILL close both it's input and
        output filehandles after running the command (even if these were
        your @{"Input()" LINK "Input"} and @{"Output()" LINK "Output"}!)

        Normally uses the boot (ROM) shell, but other shells can be specified
        via @{"SYS_UserShell" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 29} and @{"SYS_CustomShell" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 31}.  Normally, you should send
        things written by the user to the UserShell.  The UserShell defaults
        to the same shell as the boot shell.

        The tags are passed through to @{"CreateNewProc()" LINK "CreateNewProc"} (tags that conflict
        with @{"SystemTagList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 463}() will be filtered out).  This allows setting
        things like priority, etc for the new process.  The tags that are
        currently filtered out are:

                @{"NP_Seglist" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 41}
                @{"NP_FreeSeglist" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 43}
                @{"NP_Entry" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 46}
                @{"NP_Input" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 49}
                @{"NP_Output" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 51}
                @{"NP_CloseInput" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 53}
                @{"NP_CloseOutput" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 56}
                @{"NP_HomeDir" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 76}
                @{"NP_Cli" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File" 80}@{b}

   INPUTS@{ub}
        command - Program and arguments
        tags    - see <@{"dos/dostags.h" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File"}>.  Note that both @{"SystemTagList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 463}()-
                  specific tags and tags from @{"CreateNewProc()" LINK "CreateNewProc"} may be passed.@{b}

   RESULT@{ub}
        error   - 0 for success, result from command, or -1.  Note that on
                  error, the caller is responsible for any filehandles or other
                  things passed in via tags.  -1 will only be returned if
                  dos could not create the new shell.  If the command is not
                  found the shell will return an error value, normally
                  @{"RETURN_ERROR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 234}.@{b}

   SEE ALSO@{ub}
        @{"Execute()" LINK "Execute"}, @{"CreateNewProc()" LINK "CreateNewProc"}, <@{"dos/dostags.h" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File"}>, @{"Input()" LINK "Input"}, @{"Output()" LINK "Output"}

@ENDNODE
@NODE "UnGetC" "dos.library/UnGetC()"
@{b}

   NAME@{ub}
        @{"UnGetC" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 258} -- Makes a char available for reading again. (buffered) (V36)@{b}

   SYNOPSIS@{ub}
        value = @{"UnGetC" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 258}(fh, character)
        D0             D1      D2

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"UnGetC" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 258}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        Pushes the character specified back into the input buffer.  Every
        time you use a buffered read routine, you can always push back 1
        character.  You may be able to push back more, though it is not
        recommended, since there is no guarantee on how many can be
        pushed back at a given moment.

        Passing -1 for the character will cause the last character read to
        be pushed back.  If the last character read was an EOF, the next
        character read will be an EOF.

        Note: @{"UnGetC" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 258} can be used to make sure that a filehandle is set up
        as a read filehandle.  This is only of importance if you are writing
        a shell, and must manipulate the filehandle's buffer.@{b}

   INPUTS@{ub}
        fh        - filehandle to use for buffered I/O
        character - character to push back or -1@{b}

   RESULT@{ub}
        value     - character pushed back, or @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if the character cannot
                    be pushed back.@{b}

   BUGS@{ub}
        In V36, @{"UnGetC" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 258}(fh,-1) after an EOF would not cause the next character
        read to be an EOF.  This was fixed for V37.@{b}

   SEE ALSO@{ub}
        @{"FGetC()" LINK "FGetC"}, @{"FPutC()" LINK "FPutC"}, @{"Flush()" LINK "Flush"}

@ENDNODE
@NODE "UnLoadSeg" "dos.library/UnLoadSeg()"
@{b}

    NAME@{ub}
        @{"UnLoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 131} -- Unload a seglist previously loaded by @{"LoadSeg()" LINK "LoadSeg"}@{b}

    SYNOPSIS@{ub}
        success = @{"UnLoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 131}( seglist )
        D0                     D1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"UnLoadSeg" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 131}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

    FUNCTION@{ub}
        Unload a seglist loaded by @{"LoadSeg()" LINK "LoadSeg"}.  'seglist' may be zero.
        Overlaid segments will have all needed cleanup done, including
        closing files.@{b}

    INPUTS@{ub}
        seglist - BCPL pointer to a segment identifier@{b}

    RESULTS@{ub}
        success - returns 0 if a @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} seglist was passed or if it failed
                  to close an overlay file.  NOTE: this function returned
                  a random value before V36!@{b}

    SEE ALSO@{ub}
        @{"LoadSeg()" LINK "LoadSeg"}, @{"InternalLoadSeg()" LINK "InternalLoadSeg"}, @{"InternalUnLoadSeg()" LINK "InternalUnLoadSeg"}

@ENDNODE
@NODE "UnLock" "dos.library/UnLock()"
@{b}

    NAME@{ub}
        @{"UnLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 87} -- Unlock a directory or file@{b}

    SYNOPSIS@{ub}
        @{"UnLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 87}( lock )
                D1

        void @{"UnLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 87}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130})@{b}

    FUNCTION@{ub}
        The filing system lock (obtained from @{"Lock()" LINK "Lock"}, @{"DupLock()" LINK "DupLock"}, or
        @{"CreateDir()" LINK "CreateDir"}) is removed and deallocated.@{b}

    INPUTS@{ub}
        lock - BCPL pointer to a lock@{b}

    NOTE@{ub}
        passing zero to @{"UnLock" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 87}() is harmless@{b}

    SEE ALSO@{ub}
        @{"Lock()" LINK "Lock"}, @{"DupLock()" LINK "DupLock"}, @{"ParentOfFH()" LINK "ParentOfFH"}, @{"DupLockFromFH()" LINK "DupLockFromFH"}

@ENDNODE
@NODE "UnLockDosList" "dos.library/UnLockDosList()"
@{b}

   NAME@{ub}
        @{"UnLockDosList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 506} -- Unlocks the Dos List (V36)@{b}

   SYNOPSIS@{ub}
        @{"UnLockDosList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 506}(flags)
                        D1

        void @{"UnLockDosList" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 506}(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{b}

   FUNCTION@{ub}
        Unlocks the access on the Dos Device List.  You MUST pass the same
        flags you used to lock the list.@{b}

   INPUTS@{ub}
        flags - MUST be the same flags passed to (Attempt)@{"LockDosList()" LINK "LockDosList"}@{b}

   SEE ALSO@{ub}
        @{"AttemptLockDosList()" LINK "AttemptLockDosList"}, @{"LockDosList()" LINK "LockDosList"}, @{"Permit()" LINK "gg:doc/NDK/Guide/exec/Permit"}

@ENDNODE
@NODE "UnLockRecord" "dos.library/UnLockRecord()"
@{b}

   NAME@{ub}
        @{"UnLockRecord" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 234} -- Unlock a record (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"UnLockRecord" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 234}(fh,offset,length)
        D0                     D1   D2     D3

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"UnLockRecord" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 234}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52},@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})@{b}

   FUNCTION@{ub}
        This releases the specified lock on a file.  Note that you must use
        the same filehandle you used to lock the record, and offset and length
        must be the same values used to lock it.  Every @{"LockRecord()" LINK "LockRecord"} call must
        be balanced with an @{"UnLockRecord" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 234}() call.@{b}

   INPUTS@{ub}
        fh      - File handle of locked file
        offset  - Record start position
        length  - Length of record in bytes@{b}

   RESULT@{ub}
        success - Success or failure.@{b}

   BUGS@{ub}
        See @{"LockRecord()" LINK "LockRecord"}@{b}

   SEE ALSO@{ub}
        @{"LockRecords()" LINK "LockRecords"}, @{"LockRecord()" LINK "LockRecord"}, @{"UnLockRecords()" LINK "UnLockRecords"}

@ENDNODE
@NODE "UnLockRecords" "dos.library/UnLockRecords()"
@{b}

   NAME@{ub}
        @{"UnLockRecords" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 238} -- Unlock a list of records (V36)@{b}

   SYNOPSIS@{ub}
        success = @{"UnLockRecords" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 238}(record_array)
        D0                           D1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"UnLockRecords" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 238}(@{"struct RecordLock" LINK "gg:doc/NDK/Guide/Include/dos/record.h/File" 27} *)@{b}

   FUNCTION@{ub}
        This releases an array of record locks obtained using @{"LockRecords" LINK "LockRecords"}.
        You should @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} modify the record_array while you have the records
        locked.  Every @{"LockRecords()" LINK "LockRecords"} call must be balanced with an
        @{"UnLockRecords" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 238}() call.@{b}

   INPUTS@{ub}
        record_array - List of records to be unlocked@{b}

   RESULT@{ub}
        success      - Success or failure.@{b}

   BUGS@{ub}
        See @{"LockRecord()" LINK "LockRecord"}@{b}

   SEE ALSO@{ub}
        @{"LockRecords()" LINK "LockRecords"}, @{"LockRecord()" LINK "LockRecord"}, @{"UnLockRecord()" LINK "UnLockRecord"}

@ENDNODE
@NODE "VFPrintf" "dos.library/VFPrintf()"
@{b}

   NAME@{ub}
        @{"VFPrintf" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 287} -- format and print a string to a file (buffered) (V36)@{b}

   SYNOPSIS@{ub}
        count = @{"VFPrintf" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 287}(fh, fmt, argv)
        D0               D1  D2    D3

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"VFPrintf" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 287}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} *)

        count = @{"FPrintf" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 292}(fh, fmt, ...)

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"FPrintf" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 292}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, ...)@{b}

   FUNCTION@{ub}
        Writes the formatted string and values to the given file.  This
        routine is assumed to handle all internal buffering so that the
        formatting string and resultant formatted values can be arbitrarily
        long.  Any secondary error code is returned in @{"IoErr()" LINK "IoErr"}.  This routine
        is buffered.@{b}

   INPUTS@{ub}
        fh    - Filehandle to write to
        fmt   - @{"RawDoFmt()" LINK "gg:doc/NDK/Guide/exec/RawDoFmt"} style formatting string
        argv  - Pointer to array of formatting values@{b}

   RESULT@{ub}
        count - Number of bytes written or -1 (EOF) for an error@{b}

   BUGS@{ub}
        The prototype for @{"FPrintf" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 292}() currently forces you to cast the first
        varargs parameter to @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} due to a deficiency in the program
        that generates fds, prototypes, and @{"amiga.lib" LINK "gg:doc/NDK/Guide/amiga_lib/MAIN"} stubs.@{b}

   SEE ALSO@{ub}
        @{"VPrintf()" LINK "VPrintf"}, @{"VFWritef()" LINK "VFWritef"}, @{"RawDoFmt()" LINK "gg:doc/NDK/Guide/exec/RawDoFmt"}, @{"FPutC()" LINK "FPutC"}

@ENDNODE
@NODE "VFWritef" "dos.library/VFWritef()"
@{b}

   NAME@{ub}
        @{"VFWritef" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 278} - write a BCPL formatted string to a file (buffered) (V36)@{b}

   SYNOPSIS@{ub}
        count = @{"VFWritef" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 278}(fh, fmt, argv)
        D0               D1  D2    D3

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"VFWritef" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 278}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} *)

        count = @{"FWritef" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 283}(fh, fmt, ...)

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"FWritef" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 283}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, ...)@{b}

   FUNCTION@{ub}
        Writes the formatted string and values to the specified file.  This
        routine is assumed to handle all internal buffering so that the
        formatting string and resultant formatted values can be arbitrarily
        long.  The formats are in BCPL form.  This routine is buffered.

        Supported formats are:  (Note x is in base 36!)
                %S  - string (CSTR)
                %Tx - writes a left-justified string in a field at least
                      x bytes long.
                %C  - writes a single character
                %Ox - writes a number in octal, maximum x characters wide
                %Xx - writes a number in hex, maximum x characters wide
                %Ix - writes a number in decimal, maximum x characters wide
                %N  - writes a number in decimal, any length
                %Ux - writes an unsigned number, maximum x characters wide
                %$  - ignore parameter

        Note: 'x' above is actually the character value - '0'.@{b}

   INPUTS@{ub}
        fh    - filehandle to write to
        fmt   - BCPL style formatting string
        argv  - Pointer to array of formatting values@{b}

   RESULT@{ub}
        count - Number of bytes written or -1 for error@{b}

   BUGS@{ub}
        As of V37, @{"VFWritef" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 278}() does @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} return a valid return value.  In
        order to reduce possible errors, the prototypes supplied for the
        system as of V37 have it typed as @{"VOID" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 24}.@{b}

   SEE ALSO@{ub}
        @{"VFPrintf()" LINK "VFPrintf"}, @{"VFPrintf()" LINK "VFPrintf"}, @{"FPutC()" LINK "FPutC"}

@ENDNODE
@NODE "VPrintf" "dos.library/VPrintf()"
@{b}

   NAME@{ub}
        @{"VPrintf" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 697} -- format and print string (buffered) (V36)@{b}

   SYNOPSIS@{ub}
        count = @{"VPrintf" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 697}(fmt, argv)
          D0            D1   D2

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"VPrintf" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 697}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} *)

        count = Printf(fmt, ...)

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} Printf(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, ...)@{b}

   FUNCTION@{ub}
        Writes the formatted string and values to @{"Output()" LINK "Output"}.  This routine is
        assumed to handle all internal buffering so that the formatting string
        and resultant formatted values can be arbitrarily long.  Any secondary
        error code is returned in @{"IoErr()" LINK "IoErr"}.  This routine is buffered.

        Note: @{"RawDoFmt" LINK "gg:doc/NDK/Guide/exec/RawDoFmt"} assumes 16 bit ints, so you will usually need 'l's in
        your formats (ex: %ld versus %d).@{b}

   INPUTS@{ub}
        fmt   - @{"exec.library" LINK "gg:doc/NDK/Guide/exec/MAIN"} @{"RawDoFmt()" LINK "gg:doc/NDK/Guide/exec/RawDoFmt"} style formatting string
        argv  - Pointer to array of formatting values@{b}

   RESULT@{ub}
        count - Number of bytes written or -1 (EOF) for an error@{b}

   BUGS@{ub}
        The prototype for Printf() currently forces you to cast the first
        varargs parameter to @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} due to a deficiency in the program
        that generates fds, prototypes, and @{"amiga.lib" LINK "gg:doc/NDK/Guide/amiga_lib/MAIN"} stubs.@{b}

   SEE ALSO@{ub}
        @{"VFPrintf()" LINK "VFPrintf"}, @{"VFWritef()" LINK "VFWritef"}, @{"RawDoFmt()" LINK "gg:doc/NDK/Guide/exec/RawDoFmt"}, @{"FPutC()" LINK "FPutC"}

@ENDNODE
@NODE "WaitForChar" "dos.library/WaitForChar()"
@{b}

    NAME@{ub}
        @{"WaitForChar" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 155} -- Determine if chars arrive within a time limit@{b}

    SYNOPSIS@{ub}
        status = @{"WaitForChar" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 155}( file, timeout )
        D0                    D1    D2

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} @{"WaitForChar" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 155}(@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

    FUNCTION@{ub}
        If a character is available to be read from 'file' within the
        time (in microseconds) indicated by 'timeout', @{"WaitForChar" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 155}()
        returns -1 (@{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95}). If a character is available, you can use @{"Read()" LINK "Read"}
        to read it.  Note that @{"WaitForChar" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 155}() is only valid when the I/O
        stream is connected to a virtual terminal device. If a character is
        not available within 'timeout', a 0 (@{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}) is returned.@{b}

    BUGS@{ub}
        Due to a bug in the @{"timer.device" LINK "gg:doc/NDK/Guide/timer/MAIN"} in V1.2/V1.3, specifying a timeout
        of zero for @{"WaitForChar" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 155}() can cause the unreliable timer & floppy
        disk operation.@{b}

    INPUTS@{ub}
        file - BCPL pointer to a file handle
        timeout - integer@{b}

    RESULTS@{ub}
        status - boolean@{b}

    SEE ALSO@{ub}
        @{"Read()" LINK "Read"}, @{"FGetC()" LINK "FGetC"}

@ENDNODE
@NODE "WaitPkt" "dos.library/WaitPkt()"
@{b}

   NAME@{ub}
        @{"WaitPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 214} -- Waits for a packet to arrive at your pr_MsgPort (V36)@{b}

   SYNOPSIS@{ub}
        packet = @{"WaitPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 214}()
        D0

        @{"struct DosPacket" LINK "gg:doc/NDK/Guide/Include/dos/dosextens.h/File" 108} *@{"WaitPkt" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 214}(void);@{b}

   FUNCTION@{ub}
        Waits for a packet to arrive at your pr_MsgPort.  If anyone has
        installed a packet wait function in pr_PktWait, it will be called.
        The message will be automatically @{"GetMsg()" LINK "gg:doc/NDK/Guide/exec/GetMsg"}ed so that it is no longer
        on the port.  It assumes the message is a dos packet.  It is @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500}
        guaranteed to clear the signal for the port.@{b}

   RESULT@{ub}
        packet - the packet that arrived at the port (from ln_Name of message).@{b}

   SEE ALSO@{ub}
        @{"SendPkt()" LINK "SendPkt"}, @{"DoPkt()" LINK "DoPkt"}, @{"AbortPkt()" LINK "AbortPkt"}

@ENDNODE
@NODE "Write" "dos.library/Write()"
@{b}

    NAME@{ub}
        Write -- Write bytes of data to a file@{b}

    SYNOPSIS@{ub}
        returnedLength =  Write( file, buffer, length )
        D0                       D1    D2      D3

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} Write (@{"BPTR" LINK "gg:doc/NDK/Guide/Include/dos/dos.h/File" 130}, void *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

    FUNCTION@{ub}
        Write() writes bytes of data to the opened file 'file'. 'length'
        indicates the length of data to be transferred; 'buffer' is a
        pointer to the buffer. The value returned is the length of
        information actually written. So, when 'length' is greater than
        zero, the value of 'length' is the number of characters written.
        Errors are indicated by a value of -1.

        Note: this is an unbuffered routine (the request is passed directly
        to the filesystem.)  Buffered I/O is more efficient for small
        reads and writes; see @{"FPutC()" LINK "FPutC"}.@{b}

    INPUTS@{ub}
        file - BCPL pointer to a file handle
        buffer - pointer to the buffer
        length - integer@{b}

    RESULTS@{ub}
        returnedLength - integer@{b}

    SEE ALSO@{ub}
        @{"Read()" LINK "Read"}, @{"Seek()" LINK "Seek"}, @{"Open()" LINK "Open"}, @{"Close()" LINK "Close"}, @{"FPutC" LINK "FPutC"}

@ENDNODE
@NODE "WriteChars" "dos.library/WriteChars()"
@{b}

   NAME@{ub}
        @{"WriteChars" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 689} -- Writes bytes to the the default output (buffered) (V36)@{b}

   SYNOPSIS@{ub}
        count = @{"WriteChars" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 689}(buf, buflen)
        D0                 D1   D2

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"WriteChars" LINK "gg:doc/NDK/Guide/Include/inline/dos.h/File" 689}(@{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51})@{b}

   FUNCTION@{ub}
        This routine writes a number of bytes to the default output.  The
        length is returned.  This routine is buffered.@{b}

   INPUTS@{ub}
        buf    - buffer of characters to write
        buflen - number of characters to write@{b}

   RESULT@{ub}
        count - Number of bytes written.  -1 (EOF) indicates an error@{b}

   SEE ALSO@{ub}
        @{"FPuts()" LINK "FPuts"}, @{"FPutC()" LINK "FPutC"}, @{"FWrite()" LINK "FWrite"}, @{"PutStr()" LINK "PutStr"}

@ENDNODE
