@DATABASE "gg:doc/NDK/Guide/hdwrench"
@MASTER   "gg:doc/NDK/AutoDocs/hdwrench.doc"
@REMARK   This file was created by ADtoHT 2.1 on 06-Jan-13 19:22:06
@REMARK   Do not edit
@REMARK   ADtoHT is © 1993-1995 Christian Stieber

@NODE MAIN "hdwrench.doc"
@TOC "gg:doc/NDK/Guide/TOC/MAIN"

                              @{b}hdwrench.library@{ub}

@{"description()" LINK "description"}     @{"FindControllerID()" LINK "FindControllerID"}  @{"FindDefaults()" LINK "FindDefaults"}
@{"FindDiskName()" LINK "FindDiskName"}    @{"FindLastSector()" LINK "FindLastSector"}    @{"HDWCloseDevice()" LINK "HDWCloseDevice"}
@{"HDWOpenDevice()" LINK "HDWOpenDevice"}   @{"InMemMountfile()" LINK "InMemMountfile"}    @{"InMemRDBStructs()" LINK "InMemRDBStructs"}
@{"LowlevelFormat()" LINK "LowlevelFormat"}  @{"OutMemMountfile()" LINK "OutMemMountfile"}   @{"OutMemRDBStructs()" LINK "OutMemRDBStructs"}
@{"QueryCapacity()" LINK "QueryCapacity"}   @{"QueryFindValid()" LINK "QueryFindValid"}    @{"QueryInquiry()" LINK "QueryInquiry"}
@{"QueryModeSense()" LINK "QueryModeSense"}  @{"QueryReady()" LINK "QueryReady"}        @{"RawRead()" LINK "RawRead"}
@{"RawWrite()" LINK "RawWrite"}        @{"ReadMountfile()" LINK "ReadMountfile"}     @{"ReadRDBs()" LINK "ReadRDBs"}
@{"ReadRDBStructs()" LINK "ReadRDBStructs"}  @{"VerifyDrive()" LINK "VerifyDrive"}       @{"WriteBlock()" LINK "WriteBlock"}
@{"WriteMountfile()" LINK "WriteMountfile"}  @{"WriteRDBs()" LINK "WriteRDBs"}         @{"WriteRDBStructs()" LINK "WriteRDBStructs"}
@{"ZZexample()" LINK "ZZexample"}       

@ENDNODE
@NODE "description" "hdwrench.library/description()"
@{b}

   INTENDED USE@{ub}
        hdwrench.library is intended to be used as a low level tool for preparing
        and installing RigidDiskBlocks, RDBs. It can also materially assist in
        diagnosing many common ailments within RDB structures or determining
        details about the devices attached to the SCSI controller.@{b}

   USAGE@{ub}
        hdwrench.library builds a separate internal database for each opener. This
        database can service one unit number at a time. The internal database is
        partially created by the @{"OpenLibrary" LINK "gg:doc/NDK/Guide/exec/OpenLibrary"} call, partially created by the
        @{"HDWOpenDevice" LINK "HDWOpenDevice"} call, and mostly created by the @{"ReadMountfile" LINK "ReadMountfile"}, @{"ReadRDBs" LINK "ReadRDBs"},
        and @{"ReadRDBStructs" LINK "ReadRDBStructs"} commands.

            hdwrench.library performs its own @{"OpenDevice" LINK "gg:doc/NDK/Guide/exec/OpenDevice"} actions that last either
            until the library is closed or until an @{"HDWCloseDevice" LINK "HDWCloseDevice"} is issued. The
            @{"HDWCloseDevice" LINK "HDWCloseDevice"} call also clears the internal database. It may be issued
            even when no device is opened for this purpose.

            hdwrench.library makes no big deal over whether or not the data presented
            to it is appropriate in any way for the device to which it is written. It
            does support the calling process's efforts to determine appropriate
            parameters with its various Find and Query functions.

        Typical usage would involve a call to open the library. @{"QueryFindValid" LINK "QueryFindValid"}
        will then determine which devices if any are present to be configured on
        the device and board given. Then a series of calls to @{"QueryInquiry" LINK "QueryInquiry"} could
        obtain the device names for each of the discovered devices.

        The user would then select a device to be partitioned from the presented
        list. Upon selection the program would issue a @{"ReadRDBs" LINK "ReadRDBs"} command to read
        data from the device, if any, and a call to ReadCapacity to determine the
        device's actual last block as a check for "reasonableness" on the RDBs
        read.

        If the RDBs read are deemed "good" they are presented to the user for
        information or modification. If they are deemed "bad" the user should be
        informed and if requested the program should write the bad mountfile
        data to a file for diagnosis. If no RDBs are found a call to @{"FindDefaults" LINK "FindDefaults"}
        will very agressively determine the last block on the drive and then,
        according some flags, present the program with a set of suggested disk
        parameters for the standard "ST-506" related heads, blocks/track, and
        cylinders nonsense. At this time the drive can be partitioned as normal.

        Once a set of partitioning data is determined the program can present
        this data to hdwrench.library in two different formats from two different
        sources. The data may be presented either as a mountfile or as actual
        RDBs correctly linked as if for placing on the disk. The mountfile format
        is suggested. It contains slightly more check data and is very useful to
        have around if some accident requires mounting the drive's partitions
        using the standard "C:Mount" command. This data can be presented to
        hdwrench.library either through a file or through a block of memory with
        the same contents as would appear in the file.

        hdwrench.library will read the presented data and then when requested
        write that data to the disk RDBs. It can also convert the RDB based data
        in its internal structures into a "C:Mount" compatible mountfile or a
        file containing the RDB data.

        Tester.c is the program used to confirm the functionality of the library
        and can be considered as crude examples of the use for each function. It
        may be used and modified as long as proper attribution is made to the
        copyright holder(s).

        The following commands require a device already be opened before they can
        proceed:
          @{"FindDefaults" LINK "FindDefaults"}
          @{"FindDiskName" LINK "FindDiskName"}
          @{"FindLastSector" LINK "FindLastSector"}
          @{"QueryCapacity" LINK "QueryCapacity"}
          @{"QueryInquiry" LINK "QueryInquiry"}
          @{"QueryModeSense" LINK "QueryModeSense"}
          @{"QueryReady" LINK "QueryReady"}
          @{"RawRead" LINK "RawRead"}
          @{"RawWrite" LINK "RawWrite"}
          @{"ReadRDBs" LINK "ReadRDBs"}
          @{"WriteBlock" LINK "WriteBlock"}
          @{"WriteRDBs" LINK "WriteRDBs"}

        The following commands require that no device be already opened:
          @{"FindControllerID" LINK "FindControllerID"}
          @{"HDWOpenDevice" LINK "HDWOpenDevice"}
          @{"QueryFindValid" LINK "QueryFindValid"}

        The following functions do not care:
          @{"HDWCloseDevice" LINK "HDWCloseDevice"}
          @{"InMemMountfile" LINK "InMemMountfile"}
          @{"InMemRDBStructs" LINK "InMemRDBStructs"}
          @{"OutMemRDBStructs" LINK "OutMemRDBStructs"}
          @{"ReadMountfile" LINK "ReadMountfile"}
          @{"ReadRDBStructs" LINK "ReadRDBStructs"}
          @{"WriteMountfile" LINK "WriteMountfile"}
          @{"WriteRDBStructs" LINK "WriteRDBStructs"}

@ENDNODE
@NODE "FindControllerID" "hdwrench.library/FindControllerID()"
@{b}

   NAME@{ub}
        FindControllerID@{b}

   SYNOPSIS@{ub}
        success = FindControllerID ( devname, selfid )
        D0                           A0       A1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} FindControllerID ( char *devname, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} *selfid );@{b}

   FUNCTION@{ub}
        Test open devices until find SelfID error
        ( Of course, this does not work on Commododo "scsi.device" and most
        other implementations. )@{b}

   INPUTS@{ub}
        devname Pointer to C string device name for device to be searched.
        selfid  Pointer to a @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} for storing result. Preload it with a
                value within the expected range of results. (Used to determine
                the board to search.) Note this *MUST* be a @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} value.@{b}

   RESULT@{ub}
        success @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}, @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} means value returned in selfid has meaning.
        selfid  Filled with the discovered HostID for the controller card.@{b}

   NOTES@{ub}
        Note that the library must @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} have a device open for this test
        to succeed.@{b}

   BUGS@{ub}
        This tool searches only the "legal" first 8 SCSI IDs, 0..7, for a
        HFERR_SELFID error return from opening and attempting to issue a
        command to the opened unit. Most controllers do not support this.@{b}

   SEE ALSO@{ub}

@ENDNODE
@NODE "FindDefaults" "hdwrench.library/FindDefaults()"
@{b}

   NAME@{ub}
        FindDefaults@{b}

   SYNOPSIS@{ub}
        error = FindDefaults ( Optimize, Return )
        D0                     D0        A0

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} FindDefaults ( @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} Optimize, @{"struct DefaultsArray" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 156} *Return )@{b}

   FUNCTION@{ub}
        Determine last useable block on the drive. From this information
        derive standard partitioning data according to three algorithms.
        1) Use standard 1 megabyte per cylinder values. Fall back to 100k
           per cylinder if waste space for 1 megabyte per cylinder is
           greater than 0.1% of the drive. (Exact values: 1045876 and 106496
           bytes respectively.
        2) Attempt to optimize the disk per standard algorithm.
        3) Attempt to optimize the disk per the old HardFrame algorithm.
           (deprecated)@{b}

   INPUTS@{ub}
        Optimize    @{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} Flag bits to set optimization method
        Return      Pointer to @{"struct DefaultsArray" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 156} to contain return values

        Optimize Flag bits:
         @{"DA_OPTIMIZE" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 177}  Attempt to optimize usage of the drive.
         @{"DA_HUGE" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 178}      Allow full usage of drives larger than 4 gigabytes.
                      (Otherwise default to 4 gigabytes on large drives.)
         @{"DA_HF_WAY" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 179}    Attempt to optimize with the old HF algorithm. This
                      flag preempts @{"DA_OPTIMIZE" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 177} and @{"DA_HUGE" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 178} if set. It's
                      use is deprecated.@{b}
   NOTE@{ub}
        This function requires the library already have a device open for the
        evaluation process.@{b}

   RESULT@{ub}
        Error   @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} error indication per following:
                 @{"DA_NOERRORS" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 167}            Good results returned
                 @{"DA_NO_CAPACITY_REPORT" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 168}  No capacity report received. (not fatal)
                 @{"DA_NO_OPTIMIZE" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 169}         Could not optimize the drive. (not fatal)
                 @{"DA_BAD_MODESENSE_4" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 170}     No Format Device page mode sense returned
                 @{"DA_BAD_MODESENSE_3" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 171}     No Geometery page mode sense returned
                 @{"DA_NO_DRIVE_OPEN" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 173}       Fatal: No drive open to evaluate.
                 @{"DA_RIDICULOUS_VALUES" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 174}   Fatal: Values obtained are ridiculous*

                * This means ridiculous as in contains zeros.@{b}

   BUGS@{ub}
        This function no longer considers the old Adaptec ST-506 to SCSI converter
        boards. In fact it no longer considers ST-506 drives of any sort.@{b}

   SEE ALSO@{ub}

@ENDNODE
@NODE "FindDiskName" "hdwrench.library/FindDiskName()"
@{b}

   NAME@{ub}
        FindDiskName@{b}

   SYNOPSIS@{ub}
        success = FindDiskName ( diskname )
        D0                       A0

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} FindDiskName ( char *diskname );@{b}

   FUNCTION@{ub}
        Return the drive name information obtained from a SCSI Inquiry command.@{b}

   INPUTS@{ub}
        diskname    pointer to @{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62} storage space for result data 28 bytes long.@{b}

   RESULT@{ub}
        success   @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} with @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} indicating valid data returned in diskname.@{b}

   BUGS@{ub}
        Some SCSI drives and some IDE "psuedo-SCSI Direct" implementations
        include illegal characters in the three fields returned. Specificly
        the A1200 IDE device returns zeros rather than blanks for unfilled
        or unused portions of the fields. Some old drives had the revision
        code in binary rather than alphanumeric.@{b}

   SEE ALSO@{ub}

@ENDNODE
@NODE "FindLastSector" "hdwrench.library/FindLastSector()"
@{b}

   NAME@{ub}
        FindLastSector@{b}

   SYNOPSIS@{ub}
        result = FindLastSector ( void )
        D0

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} FindLastSector ( void )@{b}

   FUNCTION@{ub}
        Determine the last useable sector on the disk. If this value differs
        materially from a ReadCapacity return value consider that the drive
        should be formatted before use. This function performs a binary search
        for the highest readable block starting at the block returned by the
        ReadCapacity command. (Every once and awhile you will find a drive that
        was not formatted completely escaping the drive manufacturers. This
        function will discover this and other interesting effects such as off
        by one errors.)@{b}

   INPUTS@{ub}
        none@{b}

   RESULT@{ub}
        result  @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} 0 on failure otherwise the value of the highest readable
                block on the drive PLUS 1.@{b}

   NOTE@{ub}
        This command requires the library have a device open to proceed.@{b}

   BUGS@{ub}
        This is @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} a test for bad blocks. If it hits a bad block in its test
        near the end of the drive it may get confused. I am unable to test this
        condition. If the emulated SCSI device for an IDE drive does not
        correctly report a read failure on attempting to read the disk outside
        the address range possible this command could loop to ridiculous values.
        Code to hopefully prevent this exists but is untested.@{b}

   SEE ALSO@{ub}
        hdwrench.library/ReadCapacity

@ENDNODE
@NODE "HDWCloseDevice" "hdwrench.library/HDWCloseDevice()"
@{b}

   NAME@{ub}
        HDWCloseDevice@{b}

   SYNOPSIS@{ub}
        HDWCloseDevice (  )

        HDWCloseDevice ( void )@{b}

   FUNCTION@{ub}
        HDWCloseDevice closes any open devices within the hdwrench.library
        context.@{b}

   INPUTS@{ub}
        none@{b}

   RESULT@{ub}
        Any open device is closed and any RDBs loaded are cleared.@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        hdwrench.library/HDWCloseDevice

@ENDNODE
@NODE "HDWOpenDevice" "hdwrench.library/HDWOpenDevice()"
@{b}

   NAME@{ub}
        HDWOpenDevice@{b}

   SYNOPSIS@{ub}
        success = HDWOpenDevice ( TheDevName, unit )
        D0                        A0          D0

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} = HDWOpenDevice ( char *TheDevName, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} unit )@{b}

   FUNCTION@{ub}
        HDWOpenDevice is called to open a SCSI Direct responding device within
        the hdwrench.library environment. It must be used before any of the
        other entry points that require a device be open such as @{"QueryCapacity()" LINK "QueryCapacity"}.
        Conversely it must not be used unless followed by a @{"HDWCloseDevice()" LINK "HDWCloseDevice"} for
        the entry points that require no device be opened for their successful
        function.@{b}

   INPUTS@{ub}
        TheDevName  Pointer to a C String containing the device name.
        unit        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} containing the unit number to open.@{b}

   RESULT@{ub}
        success     @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} success or failure. @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} means a device was opened.@{b}

   NOTE@{ub}
        Please see the unit number discussion in the header comments for
        "include:@{"devices/scsidisk.h" LINK "gg:doc/NDK/Guide/Include/devices/scsidisk.h/File"}".

        Note that a successful return does not necessarily mean this is a device
        that listens to SCSI Direct commands. A "@{"QueryReady()" LINK "QueryReady"}" command should
        be used to determine if the device is ready to respond to commands.@{b}

   BUGS@{ub}
        Does not (yet) respond to any possible NSDPatch indications of device
        driver type. Be careful with it.@{b}

   SEE ALSO@{ub}
        hdwrench.library/HDWOpenDevice

@ENDNODE
@NODE "InMemMountfile" "hdwrench.library/InMemMountfile()"
@{b}

   NAME@{ub}
        InMemMountfile@{b}

   SYNOPSIS@{ub}
        error = InMemMountfile ( unit, mfdata, controller )
        D0                       D0    A0      A1

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} InMemMountfile ( @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} unit, char *mfdata, char *controller );@{b}

   FUNCTION@{ub}
        Load internal RDB structures from the data in mountfile format within
        memory.@{b}

   INPUTS@{ub}
        unit       @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} unit number per discussion in the scsidisk.h header
        mfdate     Pointer to C string containing the mountfile format data.
        controller Pointer to C string containing controller ID information.@{b}

   RESULT@{ub}
        error      @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} value according to the E_ error codes within hdwrench.h.
                   If successful the internal RDB structures are filled according
                   to the data within the mountfile.@{b}

   NOTE@{ub}
        Note that no consistency checks are performed. What you send is to this
        entry is what you get, data errors and all.@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"hdwrench.library/OutMemMountfile" LINK "OutMemMountfile"}
        hdwrench.library/ReadMountFile
        @{"hdwrench.library/WriteMountfile" LINK "WriteMountfile"}
        @{"hdwrench.library/InMemRDBStructs" LINK "InMemRDBStructs"}
        @{"hdwrench.library/ReadRDBStructs" LINK "ReadRDBStructs"}
        @{"hdwrench.library/OutMemRDBStructs" LINK "OutMemRDBStructs"}
        @{"hdwrench.library/WriteRDBStructs" LINK "WriteRDBStructs"}
        @{"hdwrench.library/ReadRDBs" LINK "ReadRDBs"}
        @{"hdwrench.library/WriteRDBs" LINK "WriteRDBs"}

@ENDNODE
@NODE "InMemRDBStructs" "hdwrench.library/InMemRDBStructs()"
@{b}

   NAME@{ub}
        InMemRDBStructs@{b}

   SYNOPSIS@{ub}
        error = InMemRDBStructs ( rdbp, sizerdb, unit )
        D0                        A0    D0       D1

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} InMemRDBStructs ( char *rdbp, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} sizerdb, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} unit );@{b}

   FUNCTION@{ub}
        Read RDB data directly from memory as it should appear on disk and
        place it within the internal RDB Structures.@{b}

   INPUTS@{ub}
        rdbp     Pointer to an array of characters containing the RDB data.
        sizerdb  The size of this memory image.
        unit     The device unit number for which this image is intended.@{b}

   RESULT@{ub}@{b}
   RESULT@{ub}
        error      @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} value according to the E_ error codes within hdwrench.h.
                   if success the RDB Data is incorporated within the internal
                   RDB structures.@{b}
   NOTE@{ub}
        Note that no consistency checks are performed. What you send is to this
        entry is what you get, data errors and all.

        Some renumbering of blocks may take place in any writing process.@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"hdwrench.library/InMemMountfile" LINK "InMemMountfile"}
        @{"hdwrench.library/OutMemMountfile" LINK "OutMemMountfile"}
        hdwrench.library/ReadMountFile
        @{"hdwrench.library/WriteMountfile" LINK "WriteMountfile"}
        @{"hdwrench.library/ReadRDBStructs" LINK "ReadRDBStructs"}
        @{"hdwrench.library/OutMemRDBStructs" LINK "OutMemRDBStructs"}
        @{"hdwrench.library/WriteRDBStructs" LINK "WriteRDBStructs"}
        @{"hdwrench.library/ReadRDBs" LINK "ReadRDBs"}
        @{"hdwrench.library/WriteRDBs" LINK "WriteRDBs"}

@ENDNODE
@NODE "LowlevelFormat" "hdwrench.library/LowlevelFormat()"
@{b}

   NAME@{ub}
        LowlevelFormat@{b}

   SYNOPSIS@{ub}
        error = LowlevelFormat (  CallBack )
        D0                           A0

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} LowlevelFormat (  long ( *CallBack)( @{"HDWCallbackMsg" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 305} *msg ))@{b}


   FUNCTION@{ub}
        Format the currently opened drive.@{b}

   INPUTS@{ub}
        CallBack        A function to accept a @{"HDWCallbackMsg" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 305} and interact with the
                                user.@{b}

   RESULT@{ub}
        error    per rw_success_val in hdwrench.h

        If CallBack is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} it returns the value no_callback_hook.
        If no device is open it returns the value io_device_not_open.

        If the user confirms the format drive callback request via CallBack
                if the selected device is the system drive
                        return opration_not_permitted.
                else
                if the selected device is mounted
                        if the user requests abort via CallBack
                                return user_aborted
                        endif
                endif

                if format is successful
                        inform the user of success via CallBack
                        return success
                else
                        inform the user of the sad event via CallBack
                        return io_command_failure
                endif
        else
                inform the user his drive is safe via CallBack
                return user_aborted
        endif@{b}

   BUGS@{ub}

@ENDNODE
@NODE "OutMemMountfile" "hdwrench.library/OutMemMountfile()"
@{b}

   NAME@{ub}
        OutMemMountFile@{b}

   SYNOPSIS@{ub}
        error = OutMemMountfile ( mfp, sizew, sizeb, unit )
        D0                         A0    A1     D0    D1

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} @{"OutMemRDBStructs" LINK "OutMemRDBStructs"} ( char *rdbp, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} *sizew, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} sizeb );@{b}

   FUNCTION@{ub}
        Convert internal RDB structures into RDBs in memory as if written to a
        disk.@{b}

   INPUTS@{ub}
        mfp     Pointer to a character array to receive the mountfile string.
        sizew   Pointer to buffer to receive size of the data actually written.
        sizeb   Size of the buffer pointed to by memp.
        unit    Unit number being dealt with for a reality check.@{b}

   RESULT@{ub}
        error    @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} containing an error code per E_ list in hdwrench.h.

        If the mfp entry is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} the error code will be E_NO_ERROR and sizew
        will contain the size buffer required to hold the data irrespective
        of the value of sizeb.

        If the sizeb is insufficient to contain the entire data set an
        E_INSUFFICIENT_MEMORY error code will be returned and sizew will contain
        the required buffer size.

        If a buffer was passed in and is of sufficient size the mountfile is
        written to the memory image as if to a disk based mountfile.

        nb. This call does not provide for saving any files to disk such as
        filesystems or device init code. Use of @{"WriteMountfile()" LINK "WriteMountfile"} is highly
        recommended for capturing filesystem code and driveinit code from
        the RDBs before writing to the RDBs.@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"hdwrench.library/InMemMountfile" LINK "InMemMountfile"}
        @{"hdwrench.library/InMemRDBStructs" LINK "InMemRDBStructs"}
        @{"hdwrench.library/OutMemRDBStructs" LINK "OutMemRDBStructs"}
        hdwrench.library/ReadMountFile
        @{"hdwrench.library/ReadRDBStructs" LINK "ReadRDBStructs"}
        @{"hdwrench.library/ReadRDBs" LINK "ReadRDBs"}
        @{"hdwrench.library/WriteRDBStructs" LINK "WriteRDBStructs"}
        @{"hdwrench.library/WriteMountfile" LINK "WriteMountfile"}
        @{"hdwrench.library/WriteRDBs" LINK "WriteRDBs"}

@ENDNODE
@NODE "OutMemRDBStructs" "hdwrench.library/OutMemRDBStructs()"
@{b}

   NAME@{ub}
        OutMemRDBStructs@{b}

   SYNOPSIS@{ub}
        error = OutMemRDBStructs ( rdbp, sizew, sizeb )
        D0                         A0    A1     D0

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} OutMemRDBStructs ( char *rdbp, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} *sizew, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} sizeb );@{b}

   FUNCTION@{ub}
        Convert internal RDB structures into RDBs in memory as if written to a
        disk.@{b}

   INPUTS@{ub}
        rdbp    Pointer to a @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} array to contain the RDB data.
        sizew   Size of the data actually written.
        sizeb   Size of the buffer pointed to by rdbp.@{b}

   RESULT@{ub}
        error    @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} containing an error code per E_ list in hdwrench.h.

        If the rdbp entry is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} the error code will be E_NO_ERROR and sizew
        will contain the size buffer required to hold the data.

        If the sizeb is insufficient to contain the entire data set an
        E_INSUFFICIENT_MEMORY error code will be returned and sizew will contain
        the required buffer size.

        If a buffer was passed in and is of sufficient size the RDBs are written
        to the memory image as if to disk. Note that the "RDSK" block will appear
        first and it will be "logically offset" with regards to internal RDB
        forward links by the value in the rdb_RDBBlocksLo field of the RDSK data.@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"hdwrench.library/InMemMountfile" LINK "InMemMountfile"}
        @{"hdwrench.library/InMemRDBStructs" LINK "InMemRDBStructs"}
        @{"hdwrench.library/OutMemMountfile" LINK "OutMemMountfile"}
        hdwrench.library/ReadMountFile
        @{"hdwrench.library/ReadRDBStructs" LINK "ReadRDBStructs"}
        @{"hdwrench.library/ReadRDBs" LINK "ReadRDBs"}
        @{"hdwrench.library/WriteRDBStructs" LINK "WriteRDBStructs"}
        @{"hdwrench.library/WriteMountfile" LINK "WriteMountfile"}
        @{"hdwrench.library/WriteRDBs" LINK "WriteRDBs"}

@ENDNODE
@NODE "QueryCapacity" "hdwrench.library/QueryCapacity()"
@{b}

   NAME@{ub}
        QueryCapacity@{b}

   SYNOPSIS@{ub}
        success = QueryCapacity( totalblocks, blocksize )
        D0                       A0           A1

        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} QueryCapacity( @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} *totalblocks, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} *blocksize );@{b}

   FUNCTION@{ub}
        Determine the total capacity of the drive in blocks and the individual
        block size. Their product is the drive capacity in bytes.@{b}

   INPUTS@{ub}
        totalblocks  Pointer to a @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} that will contain the totalblocks value.
        blocksize    Pointer to a @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} that will contain the blocksize value.@{b}

   RESULT@{ub}
        success will be @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if that values in totalblocks and blocksize are
        valid.@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"hdwrench.library/FindLastSector" LINK "FindLastSector"}
        @{"hdwrench.library/QueryFindValid" LINK "QueryFindValid"}
        @{"hdwrench.library/QueryInquiry" LINK "QueryInquiry"}
        @{"hdwrench.library/QueryModeSense" LINK "QueryModeSense"}
        @{"hdwrench.library/QueryReady" LINK "QueryReady"}

@ENDNODE
@NODE "QueryFindValid" "hdwrench.library/QueryFindValid()"
@{b}

   NAME@{ub}
        QueryFindValid@{b}

    SYNOPSIS@{ub}
     QueryFindValid ( ValidIDs, devicename, board, types, wide_scsi, CallBack )
                      A0        A1          D0     D1     D2         A2

     QueryFindValid ( @{"ValidIDstruct" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 39} *ValidIDs,
                      char *devicename,
                      int board,
                      @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} types,
                      @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} wide_scsi,
                      long ( * __asm CallBack)( @{"HDWCallbackMsg" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 305} *msg ))@{b}

   FUNCTION@{ub}
        Fills an bitmap array with flag bits indicating valid devices on an
        exhaustive test of legal SCSI Devices for a given "board".@{b}

   INPUTS@{ub}
        ValidIDs    Pointer to ValidIDStruct
        devicename  Name of the device to search
        board       A base unit ID for the board to be searched/
        types       A @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} bitmap of acceptable types to report, type 0 == bit 0.
        wide_scsi   A boolean flag indicating whether the device is a wide scsi
                    controller.
        CallBack    Pointer to a display function for values in @{"HDWCallbackMsg" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 305}.
                    (If @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} no attempt to callback is performed.)@{b}

   RESULT@{ub}
        ValidIDs filled with a bitmap of valid drives according to the entry
        criteria. ValidIDs->there are drives which respond to an Inquiry to
        indicate their device type. ValidIDs->ready also test as ready and
        test readable. A failure is indicated by all zeros. No further
        indication is appropriate as this is a test for opening all legal
        unit numbers on the device indicated.@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"hdwrench.library/QueryCapacity" LINK "QueryCapacity"}
        @{"hdwrench.library/QueryInquiry" LINK "QueryInquiry"}
        @{"hdwrench.library/QueryModeSense" LINK "QueryModeSense"}
        @{"hdwrench.library/QueryReady" LINK "QueryReady"}

@ENDNODE
@NODE "QueryInquiry" "hdwrench.library/QueryInquiry()"
@{b}

   NAME@{ub}
        QueryInquiry@{b}

    SYNOPSIS@{ub}
     success = QueryInquiry ( inqbuf, errorcode )
                              A0      A1

     @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} QueryInquiry ( @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} *inqbuf, int *errorcode );@{b}

   FUNCTION@{ub}
        Perform a SCSI Inquiry on an open device. Generally this is used to
        determine the device type and its manufacturer, type, and version.@{b}

   INPUTS@{ub}
        inqbuf    Pointer to an @{"INQBUFSIZE" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 390} @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} buffer to receive the inquiry
                  data.
        errorcode Pointer to an integer error code which will contain the
                  @{"DoIO" LINK "gg:doc/NDK/Guide/exec/DoIO"} error return.@{b}

   RESULT@{ub}
        success   @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} with @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} indicating valid data in inqbuf.

        inqbuf    filled with the first 36 bytes (through mfg data) of the
                  inquiry return@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"hdwrench.library/QueryCapacity" LINK "QueryCapacity"}
        @{"hdwrench.library/QueryFindValid" LINK "QueryFindValid"}
        @{"hdwrench.library/QueryModeSense" LINK "QueryModeSense"}
        @{"hdwrench.library/QueryReady" LINK "QueryReady"}

@ENDNODE
@NODE "QueryModeSense" "hdwrench.library/QueryModeSense()"
@{b}

   NAME@{ub}
        QueryModeSense@{b}

    SYNOPSIS@{ub}
     success = QueryModeSense ( page, msbsize, msbuf, errorcode )
     D0                         D0    D1       A0     A1

     @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} QueryModeSense ( int page, int  msbsize, @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} *msbuf, int *errorcode )@{b}

   FUNCTION@{ub}
        Read Mode Sense pages from the currently opened device. This can be used
        to determine special characteristics about the device.@{b}

   INPUTS@{ub}
        page       int containing the "PC" and "page" code for the page(s)
                   requested.
        msbsize    int containing the size of the buffer passed to the function.
        msbuf      Pointer to a @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} array of msbsize BYTEs or more.
        errorcode  Poinmter to an integer error code containing the @{"DoIO" LINK "gg:doc/NDK/Guide/exec/DoIO"} command
                   results.@{b}

   RESULT@{ub}
        success    @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} set @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if data contained within msbuf is valid.

        msbuf filled with data to msbsize requested from drive.@{b}

   NOTE@{ub}
        Refer to the appropriate version of the SCSI specification to determine
        the value for the value in page.@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"hdwrench.library/QueryCapacity" LINK "QueryCapacity"}
        @{"hdwrench.library/QueryFindValid" LINK "QueryFindValid"}
        @{"hdwrench.library/QueryInquiry" LINK "QueryInquiry"}
        @{"hdwrench.library/QueryReady" LINK "QueryReady"}

@ENDNODE
@NODE "QueryReady" "hdwrench.library/QueryReady()"
@{b}

   NAME@{ub}
        QueryReady@{b}

    SYNOPSIS@{ub}
     ready = QueryReady ( errorcode )
     D0                   A0

     @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} QueryReady ( int *errorcode )@{b}

   FUNCTION@{ub}
        Performs a SCSI Direct "Test Unit Ready" SCSI command.@{b}

   INPUTS@{ub}
        errorcode   A pointer to an integer error code value.@{b}

   RESULT@{ub}
        ready       @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} set @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if the device indicates a READY state.
        errorcode   Filled with the @{"DoIO" LINK "gg:doc/NDK/Guide/exec/DoIO"} errorcode@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"hdwrench.library/QueryCapacity" LINK "QueryCapacity"}
        @{"hdwrench.library/QueryFindValid" LINK "QueryFindValid"}
        @{"hdwrench.library/QueryInquiry" LINK "QueryInquiry"}
        @{"hdwrench.library/QueryModeSense" LINK "QueryModeSense"}

@ENDNODE
@NODE "RawRead" "hdwrench.library/RawRead()"
@{b}

   NAME@{ub}
        RawRead@{b}

    SYNOPSIS@{ub}
     error = RawRead ( bbk, size )
     D0                A0   D0

     @{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} RawRead ( @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} *bbk, @{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} size );@{b}

   FUNCTION@{ub}
        Perform a "Raw" unprocessed read on the opened device and return the
        value read within the data portion of the @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} passed in. The
        block number to read is passed into the function through the @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79}'s
        bb_BlockNum value.@{b}

   INPUTS@{ub}
        bbk     A pointer to a @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} structure large enough to contain one
                block of data from the device.
        size    @{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} containing the blocksize of the device (from @{"QueryCapacity" LINK "QueryCapacity"})
                or 0 to use current internal default block size.@{b}

   RESULT@{ub}
        error   @{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} containing the "success" field of an RWError structure.
        bbk     Filled with data if successful or even partially successful
                command completion is indicated.@{b}

   NOTES@{ub}
        This command is best used with a default blocksize assumption of 16384
        for its first use. Subsequently one can use smaller blocks if one is
        clever in using the fill data within the bbk structure for diagnosing
        actual block size. This is a recommended technique as I have discovered
        drives, chiefly when formatted for old UniSys machines, that report
        incorrect block size data. (The most egregious example was a drive that
        reported 2048k blocks and returned 180 bytes, the UniSys format. At least
        one "unnamed" drive has returned more data than a "ReadCapacity" command
        had indicated was the appropriate blocksize.)

        Hdwrench.library defaults to using the above technique for diagnosing
        actual block sizes under default conditions. If one has a "csascsi.device"
        to contend with the best technique is to open the device within the
        hdwrench.library aegis, perform a @{"QueryCapacity" LINK "QueryCapacity"}, and then a RawRead on
        any block on the disk. The library sets the default assumed blocksize to
        the actual read block size on the first read command issued.@{b}

   BUGS@{ub}
        This function will get very unhappy with blocksizes over 16384. This
        library buffers all reads and writes through a 16384 @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} chip ram buffer.@{b}

   SEE ALSO@{ub}
        @{"hdwrench.library/RawWrite" LINK "RawWrite"}
        @{"hdwrench.library/WriteBlock" LINK "WriteBlock"}

@ENDNODE
@NODE "RawWrite" "hdwrench.library/RawWrite()"
@{b}

   NAME@{ub}
        RawWrite@{b}

   SYNOPSIS@{ub}
        error = RawWrite ( bb )
        D0                 A0

        @{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} RawWrite ( @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} *bb );@{b}

   FUNCTION@{ub}
        Write the data section of a @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} to the disk at the block number
        stored within the @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} structure.@{b}

   INPUTS@{ub}
        bb      Pointer to "@{"struct BootBlock" LINK "gg:doc/NDK/Guide/Include/devices/bootblock.h/File" 17}" containing the data to be written
                and other important data for the write operation.@{b}

   RESULT@{ub}
        error   @{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} containing the same value as the RWError.success field.

        The bb->bb_RWErrors.block_written will be updated.

        Data will be written to disk with this function. Please be careful.@{b}

   NOTE@{ub}
        This function is intentionally limited writing only to the lower block
        numbers on large drives. RDBs do not appear "Way Out There."@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"hdwrench.library/RawRead" LINK "RawRead"}
        @{"hdwrench.library/WriteBlock" LINK "WriteBlock"}

@ENDNODE
@NODE "ReadMountfile" "hdwrench.library/ReadMountfile()"
@{b}

   NAME@{ub}
        ReadMountfile()@{b}

   SYNOPSIS@{ub}
        error = ReadMountfile ( unit, filename, controller )
        D0                      D0    A0        A1

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} ReadMountfile ( @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} unit, char *filename, char *controller );@{b}

   FUNCTION@{ub}
        Parse a mounfile into internal RDB structures.@{b}

   INPUTS@{ub}
        unit       Unit number for the parsed mountfile. (It MUST agree with the
                   UNIT declarations within the mountfile.)
        filename   Pointer to a C string containing the filename
        controller Pointer to a 28 @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} long @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} array containing controller ID.@{b}

   RESULT@{ub}
        error      @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} containing the error from the E_* codes in hdwrench.h.
                   If successful the internal RDB structures are filled according
                   to the data within the mountfile.@{b}

   NOTE@{ub}
        Note that no consistency checks are performed. What you send is to this
        entry is what you get, data errors and all.@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"hdwrench.library/InMemMountfile" LINK "InMemMountfile"}
        @{"hdwrench.library/OutMemMountfile" LINK "OutMemMountfile"}
        @{"hdwrench.library/WriteMountfile" LINK "WriteMountfile"}
        @{"hdwrench.library/InMemRDBStructs" LINK "InMemRDBStructs"}
        @{"hdwrench.library/ReadRDBStructs" LINK "ReadRDBStructs"}
        @{"hdwrench.library/OutMemRDBStructs" LINK "OutMemRDBStructs"}
        @{"hdwrench.library/WriteRDBStructs" LINK "WriteRDBStructs"}
        @{"hdwrench.library/ReadRDBs" LINK "ReadRDBs"}
        @{"hdwrench.library/WriteRDBs" LINK "WriteRDBs"}

@ENDNODE
@NODE "ReadRDBs" "hdwrench.library/ReadRDBs()"
@{b}

   NAME@{ub}
        ReadRDBs@{b}

   SYNOPSIS@{ub}
        error = ReadRDBs ( void )
        D0

        error = ReadRDBs ( void )@{b}

   FUNCTION@{ub}
        Read the entire RDB structure into RAM from disk paying NO attention to
        most internal values.@{b}

   INPUTS@{ub}
        none@{b}

   RESULT@{ub}
        error      @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} containing the error from the E_* codes in hdwrench.h.
                   If successful the internal RDB structures are filled according
                   to the data within the Disk RDBs.@{b}

   NOTE@{ub}
        Note that no consistency checks are performed. What you send is to this
        entry is what you get, data errors and all.@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"hdwrench.library/InMemMountfile" LINK "InMemMountfile"}
        @{"hdwrench.library/OutMemMountfile" LINK "OutMemMountfile"}
        hdwrench.library/ReadMountFile
        @{"hdwrench.library/WriteMountfile" LINK "WriteMountfile"}
        @{"hdwrench.library/InMemRDBStructs" LINK "InMemRDBStructs"}
        @{"hdwrench.library/ReadRDBStructs" LINK "ReadRDBStructs"}
        @{"hdwrench.library/OutMemRDBStructs" LINK "OutMemRDBStructs"}
        @{"hdwrench.library/WriteRDBStructs" LINK "WriteRDBStructs"}
        @{"hdwrench.library/WriteRDBs" LINK "WriteRDBs"}

@ENDNODE
@NODE "ReadRDBStructs" "hdwrench.library/ReadRDBStructs()"
@{b}

   NAME@{ub}
        ReadRDBStructs()@{b}

   SYNOPSIS@{ub}
        error = ReadRDBStructs ( char *filename, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} unit )
        D0                             A0              D0

        error = ReadRDBStructs ( char *filename, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} unit )@{b}

   FUNCTION@{ub}
        Read RDBs from a file containing the image of the RDB disk blocks. Start
        with the RDSK block and include ALL blocks until the last block in the
        RDBs. The RDSK block must be the first one. An appropriate offset will
        be generated from its internal linkage information.@{b}

   INPUTS@{ub}@{b}

   RESULT@{ub}
        error      @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} containing the error from the E_* codes in hdwrench.h.
                   If successful the internal RDB structures are filled according
                   to the data within the RDB file.@{b}

   NOTE@{ub}
        Note that no consistency checks are performed. What you send is to this
        entry is what you get, data errors and all.@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"hdwrench.library/InMemMountfile" LINK "InMemMountfile"}
        @{"hdwrench.library/OutMemMountfile" LINK "OutMemMountfile"}
        hdwrench.library/ReadMountFile
        @{"hdwrench.library/WriteMountfile" LINK "WriteMountfile"}
        @{"hdwrench.library/InMemRDBStructs" LINK "InMemRDBStructs"}
        @{"hdwrench.library/OutMemRDBStructs" LINK "OutMemRDBStructs"}
        @{"hdwrench.library/WriteRDBStructs" LINK "WriteRDBStructs"}
        @{"hdwrench.library/ReadRDBs" LINK "ReadRDBs"}
        @{"hdwrench.library/WriteRDBs" LINK "WriteRDBs"}

@ENDNODE
@NODE "VerifyDrive" "hdwrench.library/VerifyDrive()"
@{b}

   NAME@{ub}
        VerifyDrive@{b}

   SYNOPSIS@{ub}
        error = VerifyDrive (  CallBack )
        D0                        A0

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} VerifyDrive (  long ( *CallBack)( @{"HDWCallbackMsg" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 305} *msg ))@{b}


   FUNCTION@{ub}
        Verify blocks on currently opened device and give the user the opportunity
        to reassign bad blocks via the SCSI Reassign command.@{b}

   INPUTS@{ub}
        CallBack        A function to accept a @{"HDWCallbackMsg" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 305} and interact with the
                                user.@{b}

   RESULT@{ub}
        error    per rw_success_val in hdwrench.h

        If CallBack is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} it returns the value no_callback_hook.
            If no device is open it returns the value io_device_not_open.

            Inform the user that this is a safe operation, it will take a long time,
            and he will be able to abort the operation.

            If the user selects abort return user_aborted
            else verify the drive 65535 blocks at a time until completed.
            If a bad block is found give the user an opportunity to reassign the
            bad block.
            If the user elects to reassign the block attempt the reassign.
            Inform the user of any serious errors. Abort operations if the
            user elects abort or if a serious enough error occurs. (That is to
            say one from which any continuation of the verify is undefined.)@{b}

   BUGS@{ub}

@ENDNODE
@NODE "WriteBlock" "hdwrench.library/WriteBlock()"
@{b}

   NAME@{ub}
        WriteBlock@{b}

   SYNOPSIS@{ub}
        error = WriteBlock( bb )
        D0                  A0

        @{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} WriteBlock( @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} *bb );@{b}

   FUNCTION@{ub}
        Write a block to disk after filling in its RDB correct checksum and a
        reread for write verification. This function also performs a read to
        block 1000 before the reread with the hope that this will tend to flush
        drive buffers before the reread test.@{b}

   INPUTS@{ub}
        bb      Pointer to a @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} structure containing all data necessary
                for performing the write including the bb_BlockNum field.@{b}

   RESULT@{ub}
        error           The same value as returned in bb->bb_RWErrors.success.
        bb->bb_RWerrors will have all fields filled in with the failed_word filled
        with the number of the first byte that fails on the reread compare.@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"hdwrench.library/RawRead" LINK "RawRead"}
        @{"hdwrench.library/RawWrite" LINK "RawWrite"}

@ENDNODE
@NODE "WriteMountfile" "hdwrench.library/WriteMountfile()"
@{b}

   NAME@{ub}
        WriteMountfile()@{b}

   SYNOPSIS@{ub}
        error = WriteMountfile ( char *filename, char *ldir, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} flags, @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} unit )
        d0                             A0              A1         D0           D1@{b}

   FUNCTION@{ub}
        Write a "C:Mount" compatible mountfile to the indicated file. Check for
        files matching any DriveInit or FileSystem LSEGs within the RDBs and use
        them for the mountfile generated. If ldir is not @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} these LSEGs are
        stored to appropriate files on disk if no matching file already exists.

        nb. If the ldir value of "Sys:" exists files are saved to l: (filesystems)
        and devs: (devinit files.) If the ldir value "nil:" is given no files are
        saved. If ldir is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} the function call fails.@{b}

   INPUTS@{ub}
        filename    Pointer to C string containing filename
        ldir        Pointer to C string containing the directory for storing LSEGs.
        unit        Unit number for the write. Must correspond with the opened
                    device unit number.@{b}

   RESULT@{ub}
        error      @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} containing the error from the E_* codes in hdwrench.h.
                   If successful the internal RDB structures are filled according
                   to the data within the mountfile.@{b}

   NOTE@{ub}
        Note that no consistency checks are performed. What you send is to this
        entry is what you get, data errors and all.@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"hdwrench.library/InMemMountfile" LINK "InMemMountfile"}
        @{"hdwrench.library/OutMemMountfile" LINK "OutMemMountfile"}
        hdwrench.library/ReadMountFile
        @{"hdwrench.library/InMemRDBStructs" LINK "InMemRDBStructs"}
        @{"hdwrench.library/ReadRDBStructs" LINK "ReadRDBStructs"}
        @{"hdwrench.library/OutMemRDBStructs" LINK "OutMemRDBStructs"}
        @{"hdwrench.library/WriteRDBStructs" LINK "WriteRDBStructs"}
        @{"hdwrench.library/ReadRDBs" LINK "ReadRDBs"}
        @{"hdwrench.library/WriteRDBs" LINK "WriteRDBs"}

@ENDNODE
@NODE "WriteRDBs" "hdwrench.library/WriteRDBs()"
@{b}

   NAME@{ub}
        WriteRDBs@{b}

   SYNOPSIS@{ub}
        error = WriteRDBs ( void )
        D0

        @{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} WriteRDBs ( void )@{b}

   FUNCTION@{ub}
        Write data contained in internal RDB structures to the DISK as RDBs. Start
        at rdb_RDBBlocksLo as the first block to be written.@{b}

   INPUTS@{ub}
        none    (Although a set of RDB structures must have already been loaded
                before anything can be written.)@{b}

   RESULT@{ub}
        error   @{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} containing the bb_RWErrors.success value for the worst
                error code encountered during the write.@{b}

   NOTE@{ub}
        Note that no consistency checks are performed. What you send is to this
        entry is what you get, data errors and all.@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"hdwrench.library/InMemMountfile" LINK "InMemMountfile"}
        @{"hdwrench.library/OutMemMountfile" LINK "OutMemMountfile"}
        hdwrench.library/ReadMountFile
        @{"hdwrench.library/WriteMountfile" LINK "WriteMountfile"}
        @{"hdwrench.library/InMemRDBStructs" LINK "InMemRDBStructs"}
        @{"hdwrench.library/ReadRDBStructs" LINK "ReadRDBStructs"}
        @{"hdwrench.library/OutMemRDBStructs" LINK "OutMemRDBStructs"}
        @{"hdwrench.library/WriteRDBStructs" LINK "WriteRDBStructs"}
        @{"hdwrench.library/ReadRDBs" LINK "ReadRDBs"}

@ENDNODE
@NODE "WriteRDBStructs" "hdwrench.library/WriteRDBStructs()"
@{b}

   NAME@{ub}
        WriteRDBStructs()@{b}

   SYNOPSIS@{ub}
        error = WriteRDBStructs ( char *filename )
        D0                              A0

        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} WriteRDBStructs ( char *filename )@{b}

   FUNCTION@{ub}
        Write RDBs to a file rather than to the RDB locations on disk. The first
        block written will be the RDSK block with all the others following in
        order. Given internal renumbering systems this means they should all be
        contiguous blocks.@{b}

   INPUTS@{ub}@{b}

   RESULT@{ub}
        error      @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} containing the error from the E_* codes in hdwrench.h.
                   If successful the internal RDB structures are filled according
                   to the data within the mountfile.@{b}

   NOTE@{ub}
        Note that no consistency checks are performed. What you send is to this
        entry is what you get, data errors and all.@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
            @{"hdwrench.library/InMemMountfile" LINK "InMemMountfile"}
            @{"hdwrench.library/OutMemMountfile" LINK "OutMemMountfile"}
            hdwrench.library/ReadMountFile
            @{"hdwrench.library/WriteMountfile" LINK "WriteMountfile"}
            @{"hdwrench.library/InMemRDBStructs" LINK "InMemRDBStructs"}
            @{"hdwrench.library/ReadRDBStructs" LINK "ReadRDBStructs"}
            @{"hdwrench.library/OutMemRDBStructs" LINK "OutMemRDBStructs"}
            @{"hdwrench.library/ReadRDBs" LINK "ReadRDBs"}
            @{"hdwrench.library/WriteRDBs" LINK "WriteRDBs"}

@ENDNODE
@NODE "ZZexample" "hdwrench.library/ZZexample()"

        /*      tester.c        test hdwrench.library for some basic functions.
         *              $VER: Tester.c 44.3 (29.7.99) © Wizardess Designs and Joanne Dow 1999 All rights reserved
         *
         *              © Copyright 1999 by Joanne Dow, Wizardess Designs
         *              All Rights Reserved
         *
         *      Tester.c can be taken both as a test program and as an example of usage,
         *      in spite of its cut and paste, overblown and ugly coding style, of usage
         *      for each of the "hdwrench.library" API entry points.
         *
         *      Functions:
         *              Support:
         *              1) Open device and close device
         *                      BU baseunit.
         *              Translations:
         *
         *              2) Read RDB from <file>.list and write as mountfile to <file>..list.
         *              3) Read RDB from <file>.list and write as RDBs to <file>..rdb.
         *              4) Read RDB from <file>.rdb and write as mountfile to <file>..list.
         *              5) Read RDB from <file>.rdb and write as RDBs to <file>..rdb.
         *              6) Read Mountfile from memory and write as Mountfile to memory.
         *                      (uses 000.list for input and writes to "foo" and screen.)
         *              7) Read Mountfile from memory and write as RDB Structs to memory.
         *                      (uses 000.list for input and writes to "foo".)
         *              8)  Read RDBStructs memory and write as RDB Structs to memory.
         *                      (uses 000..rdb for input and writes to "bar".)
         *
         *              Basic Disk acccesses:
         *              9) Read RDB from disk and write as mountfile to <file>...list.
         *              10) Perform SCSI Inquiry and report results up to 40 bytes.
         *              11) Perform SCSI ModeSense  and report results up to 255 bytes.
         *              12) Perform SCSI Read Capacity and report disk size.
         *              13) Perform SCSI Test Unit Ready and report device readiness.
         *
         *              Complex Disk Accesses...
         *              14) Find Disk Name returning in string variable.
         *              15) Find Controller self-ID returning in @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} (which Commododo fails!).
         *              16) Report last available block on the drive.
         *              17) Generate default drive parameters.
         *              18) Read and report raw sector 'MS'.    (Not really complex but...)
         *              19) Find all valid disks on a given controller
         *
         *              Dangerous disk accesses:
         *              20) Raw write to a block of low disk. (Safe write - I hope!)
         *              21) Write with checksum to a block of low disk. (Safe write - I hope!)
         *              22) Read RDBs from <file.list> and write to disk. (The biggie!)
         *              23) Read RDBs from disk and write to RDBStructs to <file>.rdb.
         *              24) Read RDBStructs from <file>.rdb and write to <file>...rdb.
         *              25) Verify data on disk.
         *              26) Read RDBStructs from <file>...rdb and write to Disk.
         *              27) Read RDBs from disk and write RDB Structs memory thence to file
         *                       and console as hex.
         *              100) Format Drive - VERY DANGEROUS!
         *
         *              Presumes "scsi.device" else enter "DEVICE devicename".
         */
        #include        <stdio.h>
        #include        <stdarg.h>
        #include        <string.h>
        #include        <ctype.h>
        #include        <stdlib.h>
        #include        <math.h>
        #include        <dos.h>
        #include        <@{"exec/types.h" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File"}>
        #include        <@{"exec/ports.h" LINK "gg:doc/NDK/Guide/Include/exec/ports.h/File"}>
        #include        <@{"exec/libraries.h" LINK "gg:doc/NDK/Guide/Include/exec/libraries.h/File"}>
        #include        <@{"exec/io.h" LINK "gg:doc/NDK/Guide/Include/exec/io.h/File"}>
        #include        <@{"exec/nodes.h" LINK "gg:doc/NDK/Guide/Include/exec/nodes.h/File"}>
        #include        <@{"exec/lists.h" LINK "gg:doc/NDK/Guide/Include/exec/lists.h/File"}>
        #include        <@{"exec/tasks.h" LINK "gg:doc/NDK/Guide/Include/exec/tasks.h/File"}>
        #include        <@{"exec/memory.h" LINK "gg:doc/NDK/Guide/Include/exec/memory.h/File"}>
        #include        <@{"exec/execbase.h" LINK "gg:doc/NDK/Guide/Include/exec/execbase.h/File"}>
        #include        <@{"devices/trackdisk.h" LINK "gg:doc/NDK/Guide/Include/devices/trackdisk.h/File"}>
        #include        <@{"libraries/dos.h" LINK "gg:doc/NDK/Guide/Include/libraries/dos.h/File"}>
        #include        <@{"libraries/dosextens.h" LINK "gg:doc/NDK/Guide/Include/libraries/dosextens.h/File"}>
        #include        <@{"dos/filehandler.h" LINK "gg:doc/NDK/Guide/Include/dos/filehandler.h/File"}>
        #include        <@{"devices/hardblocks.h" LINK "gg:doc/NDK/Guide/Include/devices/hardblocks.h/File"}>
        #include        <@{"devices/scsidisk.h" LINK "gg:doc/NDK/Guide/Include/devices/scsidisk.h/File"}>
        #include        <@{"intuition/intuition.h" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File"}>
        #include        <@{"workbench/workbench.h" LINK "gg:doc/NDK/Guide/Include/workbench/workbench.h/File"}>
        #include        <@{"workbench/icon.h" LINK "gg:doc/NDK/Guide/Include/workbench/icon.h/File"}>
        #include        <@{"workbench/startup.h" LINK "gg:doc/NDK/Guide/Include/workbench/startup.h/File"}>
        #include        <@{"dos/rdargs.h" LINK "gg:doc/NDK/Guide/Include/dos/rdargs.h/File"}>
        #include        <@{"dos/dostags.h" LINK "gg:doc/NDK/Guide/Include/dos/dostags.h/File"}>

        #include        <@{"proto/dos.h" LINK "gg:doc/NDK/Guide/Include/proto/dos.h/File"}>
        #include        <@{"proto/exec.h" LINK "gg:doc/NDK/Guide/Include/proto/exec.h/File"}>
        #include        <@{"pragmas/exec_pragmas.h" LINK "gg:doc/NDK/Guide/Include/pragmas/exec_pragmas.h/File"}>
        #include        <@{"pragmas/disk_pragmas.h" LINK "gg:doc/NDK/Guide/Include/pragmas/disk_pragmas.h/File"}>
        #include        <@{"pragmas/dos_pragmas.h" LINK "gg:doc/NDK/Guide/Include/pragmas/dos_pragmas.h/File"}>

        #include        "HDWrench.h"
        #include        "HDWrench_pragmas.h"
        #define         USE_SUGGESTED_MESSAGES
        #include        "HDW_CallbackMsgs.h"

        @{"struct HDWLibrary" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 14}       *HDWBase = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};

        #define TEMPLATE "TEST/N/A,BU/N/K,FILE/K,MS/N/K,DEVICE/K"
        #define NUM_ARGS 5

        char hexits [] = "0123456789abcdef";
        char spaces [] = "                                                ";

        enum { ARG_TEST, ARG_BU, ARG_FILE, ARG_MS, ARG_DEVICE };

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}                     ArgArray [ NUM_ARGS ];

        char                    *inmembuffer    = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};
        char                    *outmembuffer   = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};
        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}                     deviceopen             = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
        @{"struct RDArgs" LINK "gg:doc/NDK/Guide/Include/dos/rdargs.h/File" 95}   *Args                   = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};
        @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91}                     aborted                = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}                    testnum;

        long __stdargs __saveds __asm CallBack ( register __a0 @{"HDWCallbackMsg" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 305} *msg );

        void usage ( void )
        {
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "tester %s\\n", TEMPLATE );
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Gotta have a test number!\\n" );
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "1)  Basic Open and Close Device\\n" );
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "2)  Read RDB from <file>.list and write as mountfile to <file>..list.\\n");
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "3)  Read RDB from <file>.list and write as RDBs to <file>..rdb.\\n" );
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "4)  Read RDBs from <file>..rdb and write Mountfile to <file>...list.\\n" );
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "5)  Read Mountfile from disk and write as mountfile to memory.\\n");
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "6)  Read Mountfile from memory and write as Mountfile to memory.\\n");
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "7)  Read Mountfile from memory and write as RDB Structs to memory.\\n");
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "8)  Read RDBStructs memory and write as RDB Structs to memory.\\n");
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "9)  Read RDB from disk and write as mountfile to <file>...list.\\n");
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "10) Perform SCSI Inquiry and report results up to 40 bytes.\\n");
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "11) Perform SCSI ModeSense  and report results up to 256 bytes.\\n");
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "12) Perform SCSI Read Capacity and report disk size.\\n");
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "13) Perform SCSI Test Unit Ready and report device readiness.\\n");
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "14) Find Disk Name returning in string variable.\\n" );
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "15) Find Controller self-ID returning in @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} (which Commododo fails!).\\n" );
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "16) Report last available block on the drive.\\n");
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "17) Generate default drive parameters.\\n" );
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "18) Read and report raw sector 'MS'.\\n");
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "19) Find all valid disks on a given controller.\\n");
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "20) Raw write to a block of low disk. (Safe write - I hope!)\\n");
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "21) Write with checksum to a block of low disk. (Safe write - I hope!)\\n");
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "22) Read RDBs from <file.list> and write to disk. (The biggie!)\\n" );
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "23) Read RDBs from disk and write to file <file>.rdb\\n");
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "24) Read RDBStructs from <file>.rdb and write to <file>...rdb.\\n");
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "25) Verify data on disk.\\n" );
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "26) Read RDBStructs from <file>...rdb and write to Disk.\\n");
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "27) Read RDBs from disk. Write RDB Structs to memory thence to file and console as hex.\\n\\n" );
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "100) Format Drive - VERY DANGEROUS!\\n" );
        }

        int btrap ( void )
        {
                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "\\n***BREAK***\\n" );
                if (( testnum != 25 ) && ( testnum != 100 ))
                        exit(20);
                aborted = @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95};
                return 0;
        }

        void gone ( void )
        {
                if ( deviceopen )
                {
                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                        @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                        deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                }

                if ( outmembuffer )
                {
                        free ( outmembuffer );
                        outmembuffer = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};
                }

                if ( inmembuffer )
                {
                        free ( inmembuffer );
                        inmembuffer = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};
                }

                if ( Args )
                        @{"FreeArgs" LINK "gg:doc/NDK/Guide/dos/FreeArgs"} ( Args );

                if ( HDWBase )
                        @{"CloseLibrary" LINK "gg:doc/NDK/Guide/exec/CloseLibrary"} ( ( @{"struct Library" LINK "gg:doc/NDK/Guide/Include/exec/libraries.h/File" 34} *) HDWBase );
                HDWBase = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};

                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ("Aw gone!\\n");
        }

        void printhex ( @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} * buf, int size )
        {
                int i;
                int j;
                char c;

                for ( i=0, j = 0; i < size; i++)
                {
                        if (( i & 0x0f ) == 0 )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "%c%c%c%c: ",
                                                 hexits [( i >> 12 ) & 0xf ],
                                                 hexits [( i >> 8  ) & 0xf ],
                                                 hexits [( i >> 4  ) & 0xf ],
                                                 hexits [  i         & 0xf ] );
                        c = buf [ i ];
                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "%c%c ", hexits [( c>>4 ) & 0xf], hexits [ c & 0xf ]);
                        if ( ( i & 0x7 )  == 7 )
                        {
                                if ( ( i & 0xf ) == 15 )
                                {
                                        for ( ; j <= i; j++ )
                                        {
                                                c = buf [ j ];
                                                if ( isalnum ( c ) || c == ' ' )
                                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "%c ", c );
                                                else
                                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( ". " );

        //                                      if ( ( j & 0x7 )  == 7 )
        //                                              @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( " " );
                                        }
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "\\n" );
                                }
        //                      else
        //                              @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( " " );
                        }
                }
                if ( j != i )
                {
                        int k = (( i - 1 ) & 0xf ) + 1;

                        k = k * 3 + ( k > 8 );
                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "%s", &spaces [ k ] );

                        for ( ; j < i; j++ )
                        {
                                c = buf [ j ];
                                if ( isalnum ( c ) )
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "%c ", c );
                                else
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( ". " );

        //                      if ( ( j & 0x7 )  == 7 )
        //                              @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "  " );
                        }
                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "\\n" );
                }
        }

        int
        main ( int argc, char **argv)
        {
                char                     *filename;
                char                      devicename[60];
                FILE                     *workfile;
                @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}                     baseunit;
                @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}                     mspage;
                @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}                     sizeb;
                @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}                     sizememneeded;

                char                      realfilename[256];
                @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}                     rsuccess;
                @{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82}                    rwsuccess;

                ArgArray [ 0 ] =
                ArgArray [ 1 ] =
                ArgArray [ 2 ] =
                ArgArray [ 3 ] =
                ArgArray [ 4 ] = 0;

                puts( "Tester, the HDWrench test program.\\n" );

                atexit( gone );
                if ( onbreak ( &btrap ))
                {
                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Break trap not installed!" );
                        exit ( 20 );
                }

                Args = @{"ReadArgs" LINK "gg:doc/NDK/Guide/dos/ReadArgs"}( TEMPLATE, ArgArray, @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} );
                if ( Args )
                {
                        //      ARG_TEST, ARG_BU, ARG_FILE, ARG_MS, ARG_DEVICE
                        testnum         = (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})       ArgArray [ ARG_TEST ];
                        baseunit        = (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})       ArgArray [ ARG_BU ];
                        filename        = (char *)      ArgArray [ ARG_FILE ];
                        mspage          = (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52})       ArgArray [ ARG_MS ];
                        memset ( devicename, 0, 60 );
                        if ( ArgArray [ ARG_DEVICE ] != @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} )
                                strncpy ( devicename, (char *)  ArgArray [ ARG_DEVICE ], 59 );
                        else
                                strncpy ( devicename, "scsi.device", 59 );

                        if ( testnum )
                                testnum = *(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}*) testnum;
                        else
                                testnum = 0;

                        if ( baseunit)
                                baseunit = *(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}*) baseunit;
                        else
                                baseunit = (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L;

                        if ( mspage )
                                mspage = *(@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}*) mspage;

                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Test Num      = %ld\\n", testnum );
                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Base Unit     = %ld\\n", baseunit );
                        if ( filename )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Filename      = %s\\n", filename );
                        else
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Filename      = <none>\\n" );
                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "MS Page               = %ld\\n", mspage);
                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Devicename    = %s\\n\\n\\n", devicename);

                        if (( HDWBase = ( @{"struct HDWLibrary" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 14} *) @{"OpenLibrary" LINK "gg:doc/NDK/Guide/exec/OpenLibrary"} ( HDWBaseName, 0)) == @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} )
                        {
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"}( "Failed to open HDWBase!\\n");
                                exit ( 10 );
                        }

                        switch ( testnum )
                        {
                        case 0:         /* No test! */
                        default:
                                usage();
                                break;

        /******************************************
         *
         *      1
         *              BASIC OPENDEVICE/CLOSEDEVICE TEST
         *
         *****************************************/
                        case 1: // Basic Open and Close Device
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "1) Basic Open and Close Device\\n\\n" );
        //      @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} __saveds __asm              @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( register __a0 char *DevName,
        //                                                                                       register __d0 @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} unit );
        //      void __saveds __asm              @{"HDWCloseDevice" LINK "HDWCloseDevice"} ( void );
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "You must enter a BU, Base Unit, number\\n");
                                        break;
                                }
                                // Open device here.
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s:%d\\n", devicename, baseunit );
                                deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                if ( deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                                        @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                                        deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                }
                                else
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "No device was opened!\\n");
                                break;

        /******************************************
         *
         *      2-4
         *              BASIC READ/WRITE FILE TESTS
         *
         *****************************************/
                        case 2: // Read RDB from <file>.list and write as mountfile to <file>..list.
        //      @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} __saveds __asm
        //      @{"ReadMountfile" LINK "ReadMountfile"} ( register __d0 @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} unit,
        //                                      register __a0 char * filename,
        //                                      register __a1 char *controller )
        /* HDW_ReadMountfile()
         *      Description:
         *              Parse a mounfile into internal RDB structures.
         *
         *      Direct Inputs:
         *              filename                Pointer to mountfile in memory null terminated
         *              unit                    Unit number to masquarade as.
         *
         *      Indirect Inputs:
         *
         *      Direct Outputs:
         *              ret                     error 0 if success else error indication
         *
         *      Indirect Outputs:
         *              RDB structures built in memory
         *
         *      Local Calls:
         *              parse ()
         *
         *      OS Calls:
         *              fclose ()
         *              fopen ()
         *
         *      Algorithm:
         *              If RDBs open then fail
         *              If file open close it.
         *              @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} memp
         *              if filename null then fail
         *              if Open filename fails then fail
         *              parse data as it comes until null character.
         *              return errors encountered in parse
         *
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        /* HDW_WriteMountfile()
         *      Description:
         *              Write to filename given from internal RDB structures in mountfile
         *              format. Check for matching files if filename entry is present in
         *              RDB structures and write appropriate FS and DriveInit code files.
         *
         *      Direct Inputs:
         *              filename        pointer to the name of the file to be written.
         *              flags           Flag what should be written to files.
         *              ldir            L: directory path to use or @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}. (Use "L:" if null.)
         *
         *      Indirect Inputs:
         *              Mountfile and any filesystem files or device init files written.
         *
         *      Direct Outputs:
         *              ret                     error 0 if success else error indication
         *
         *      Indirect Outputs:
         *              Internal file structures written to disk in mountfile format.
         *
         *      Local Calls:
         *              print ()
         *
         *      OS Calls:
         *              fclose ()
         *              fopen ()
         *
         *      Algorithm:
         *              If no RDBs stored or file open fails exit with error
         *              print () mountfile to file.
         *              return accumulated error
         *
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //      @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} __saveds __asm
        //      @{"WriteMountfile" LINK "WriteMountfile"} ( register __a0 char *filename,
        //                                       register __a1 char *ldir,
        //                                       register __d0 @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} unit )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "2) Read RDB from <file>.list and write as mountfile to <file>..list.\\n\\n");
                                if ( !filename )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a filename\\n" );
                                        break;
                                }
                                if ( strlen( filename ) > 248 )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Filename: %s is too long!\\n", filename );
                                        break;
                                }
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }
                                @{"sprintf" LINK "gg:doc/NDK/Guide/amiga_lib/sprintf"} ( realfilename, "%s%s", filename, ".list" );
                                rsuccess = @{"ReadMountfile" LINK "ReadMountfile"} ( baseunit, realfilename, devicename );
                                if ( rsuccess == 0 )
                                {
        //                              system( "copy l:fastfilesystem43.19 sys:l/fastfilesystem");
                                        @{"sprintf" LINK "gg:doc/NDK/Guide/amiga_lib/sprintf"} ( realfilename, "%s%s", filename, "..list" );
                                        rsuccess = @{"WriteMountfile" LINK "WriteMountfile"} ( realfilename, "jdow:hdwrench", baseunit );
                                        if ( rsuccess == 0 )
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "You should have a new %s waiting.\\n", realfilename );
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Mountfile write failed: %d\\n", rsuccess );
        //                              system( "copy l:fastfilesystem_fixed_43.19 sys:l/fastfilesystem");
                                }
                                else
                                {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Mountfile read failed: %d\\n", rsuccess );
                                                break;
                                }
                                break;

                        case 3:
        //      @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} __saveds __asm
        //      @{"ReadMountfile" LINK "ReadMountfile"} ( register __d0 @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} unit,
        //                                      register __a0 char * filename,
        //                                      register __a1 char *controller )
        /* HDW_WriteRDBStructs()
         *      Description:
         *              (Write RDBs to file instead of RDB area of disk.)
         *              Write the internal RDB structures to disk exactly as in memory.
         *
         *      Direct Inputs:
         *              Filename                Name of file to write. NB: This will clobber duplicates
         *
         *      Indirect Inputs:
         *              RDB structures in memory
         *
         *      Direct Outputs:
         *              ret                     error 0 if success else error indication
         *
         *      Indirect Outputs:
         *              File written
         *
         *      Local Calls:
         *
         *      OS Calls:
         *              fclose ()
         *              fopen ()
         *              fwrite ()
         *
         *      Algorithm:
         *              if no RDBs in memory of file open fails exit with error
         *              else
         *                      pointer = Basepointer->next
         *                      while pointer
         *                              translate and write block to disk file
         *                              pointer = pointer->next
         *                      endwhile
         *              endif
         *
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //      @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} __saveds __asm
        //      @{"WriteRDBStructs" LINK "WriteRDBStructs"} ( register __a0 char *filename )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "3)  Read RDB from <file>.list and write as RDBs to <file>..rdb.\\n\\n" );
                                if ( !filename )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a filename\\n" );
                                        break;
                                }
                                if ( strlen( filename ) > 248 )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Filename: %s is too long!\\n", filename );
                                        break;
                                }
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }
                                @{"sprintf" LINK "gg:doc/NDK/Guide/amiga_lib/sprintf"} ( realfilename, "%s%s", filename, ".list" );
                                rsuccess = @{"ReadMountfile" LINK "ReadMountfile"} ( baseunit, realfilename, devicename );
                                if ( rsuccess == 0 )
                                {
                                        @{"sprintf" LINK "gg:doc/NDK/Guide/amiga_lib/sprintf"} ( realfilename, "%s%s", filename, "..rdb" );

                                        rsuccess = @{"WriteRDBStructs" LINK "WriteRDBStructs"} ( realfilename );
                                        if ( rsuccess == 0 )
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "You should have a new %s waiting.\\n", realfilename );
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "RDBfile write failed: %d\\n", rsuccess );
                                }
                                else
                                {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Mountfile read failed: %d\\n", rsuccess );
                                                break;
                                }
                                break;

                        case 4:
        /* HDW_ReadRDBStructs()
         *      Description
         *              (Read RDBs from file instead of RDB area of disk.)
         *              Read the dumped RDB file structures from the file into internal
         *              memory. (NB: Only actual declared RDB areas are included in the
         *              structures as written.)
         *              NB: The RDB structures read MUST have their relative block numbers
         *              written correctly.  They are used when writing to disk, even if
         *              changed in writing.
         *
         *      Direct Inputs:
         *              filename        pointer to the name of the file to be written. This
         *                                      file will be unconditionally overwritten if present.
         *
         *      Indirect Inputs:
         *              Internal RDB structures as loaded.
         *
         *      Direct Outputs:
         *              ret                     error 0 if success else error indication
         *
         *      Indirect Outputs:
         *              Internal RDB structures written to the filename indicated.
         *
         *      Local Calls:
         *              ClearBlockList ()
         *              ScanList ()
         *
         *      OS Calls:
         *              fclose ()
         *              fopen ()
         *              fread ()
         *
         *      Algorithm:
         *              If RDBs in memory or file open fails return error code
         *              else
         *                      while ( not end of file )
         *                              allocate block
         *                              block read the block from disk file
         *                              switch type
         *                                case RDSK             Add to front of list
         *                                case PART             Add after RDSK entry and other PART entries
         *                                                              if any else front of list
         *                                case BADB             Add just after RDSK if any.
         *                                case FSHD             Add after last PART entries if any
         *                                case LSEG             Add to end of list in order encountered
         *                                otherwise             Ignore!!!!
         *                              endswitch
         *                      endwhile
         *              endif
         *
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} __saveds __asm
        //HDW_ReadRDBStructs ( register __a0 char *filename, register __d0 unit )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "4)  Read RDBs from <file>..rdb and write Mountfile to <file>...list.\\n\\n" );
                                if ( !filename )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a filename\\n" );
                                        break;
                                }
                                if ( strlen( filename ) > 248 )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Filename: %s is too long!\\n", filename );
                                        break;
                                }
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }
                                @{"sprintf" LINK "gg:doc/NDK/Guide/amiga_lib/sprintf"} ( realfilename, "%s%s", filename, "..rdb" );
                                rsuccess = @{"ReadRDBStructs" LINK "ReadRDBStructs"} ( realfilename, baseunit );
                                if ( rsuccess == 0 )
                                {
                                        @{"sprintf" LINK "gg:doc/NDK/Guide/amiga_lib/sprintf"} ( realfilename, "%s%s", filename, "...list" );

                                        rsuccess = @{"WriteMountfile" LINK "WriteMountfile"} ( realfilename, "jdow:hdwrench", baseunit );
                                        if ( rsuccess == 0 )
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "You should have a new %s waiting.\\n", realfilename );
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "MountFile write failed: %d\\n", rsuccess );
                                }
                                else
                                {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "RDB file read failed: %d\\n", rsuccess );
                                                break;
                                }
                                break;


        /******************************************
         *
         *      5-8
         *              BASIC INMEMORY READ/WRITE TESTS
         *
         *****************************************/
                        case 5:
        /*
         * HDW_OutMemMountfile()
         *      Description:
         *              Write RDBs into a block of memory as null terminated mountfile text.
         *              If block supplied is too small fail. If memp = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} return size needed
         *              but no written data.
         *
         *      Direct Inputs:
         *              memp            Pointer to block of memory
         *              sizeb           size of block of memory
         *              sizew           Pointer to size written
         *
         *      Indirect Inputs:
         *              RDB structures in memory
         *
         *      Direct Outputs:
         *              ret                     error code
         *              sizew           size written
         *
         *      Indirect Outputs:
         *              Block of memory written
         *
         *      Local Calls:
         *              print ()
         *
         *      OS Calls:
         *              fclose ()
         *
         *      Algorithm:
         *              if file open then close it.
         *              if memory open then null it.
         *              if RDBs not open then fail
         *              set memp to input vector (@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} is legitimate for returning size)
         *              Set maximum sze value per passed in value or "huge" of memp == @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}
         *              Call print() to generate the RDBs into the memory block
         *              set size written value
         *              return accumulated errors.
         *
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} __saveds __asm
        //HDW_OutMemMountfile ( register __a0 char *mfp,
        //                                        register __a1 @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} *sizew,
        //                                        register __d0 @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} sizeb,            // Size of buffer
        //                                        register __d1 @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} unit )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "5) Read Mountfile from disk and write as mountfile to memory.\\n\\n");
                                /* More specifically read Mountfile from disk and write as mountfile to
                                 * printing results to stdout.
                                 */
                                if ( !filename )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a filename\\n" );
                                        break;
                                }
                                if ( strlen( filename ) > 248 )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Filename: %s is too long!\\n", filename );
                                        break;
                                }
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }
                                @{"sprintf" LINK "gg:doc/NDK/Guide/amiga_lib/sprintf"} ( realfilename, "%s%s", filename, ".list" );
                                rsuccess = @{"ReadMountfile" LINK "ReadMountfile"} ( baseunit, realfilename, devicename );
                                if ( rsuccess == 0 )
                                {
                                        rsuccess = @{"OutMemMountfile" LINK "OutMemMountfile"} ( @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, &sizememneeded, 0, baseunit );

                                        if ( rsuccess == 0 )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "5) Need %ld bytes of buffer for mountfile.\\n", sizememneeded );
                                                outmembuffer = malloc ( sizememneeded + 256 );
                                                if ( outmembuffer )
                                                {
                                                        rsuccess = @{"OutMemMountfile" LINK "OutMemMountfile"} ( outmembuffer, &sizememneeded, sizememneeded + 255, baseunit );
                                                        if ( rsuccess == 0 )
                                                        {
                                                                FILE *foofile = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};

                                                                outmembuffer [ sizememneeded + 255 ] = 0;
                                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Actual use = %d\\n", strlen( outmembuffer ));
                                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( outmembuffer );

                                                                foofile = fopen ( "foo", "wb" );
                                                                if ( foofile )
                                                                {
                                                                        fwrite ( outmembuffer, sizememneeded, 1, foofile );
                                                                        fclose ( foofile );
                                                                        foofile = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};
                                                                }
                                                        }
                                                        else
                                                        {
                                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Could not write the file: %d\\n", rsuccess );
                                                        }
                                                }
                                        }
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Mountfile size write failed: %d\\n", rsuccess );
                                }
                                else
                                {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Mountfile read failed: %d\\n", rsuccess );
                                                break;
                                }
                                break;

                        case 6:
        /* HDW_InMemMountfile()
         *      Description:
         *              Parse a block of memory as if it were a disk file feeding through
         *              HDW_ReadMountfile().
         *
         *      Direct Inputs:
         *      unit        unit number of device for which this is intended
         *              mfdata          Pointer to mountfile in memory null terminated
         *              controller  Pointer to "controller ID" information
         *
         *      Indirect Inputs:
         *              BootBlocks      rdb list
         *
         *      Direct Outputs:
         *              ret                     error 0 if success else error indication
         *
         *      Indirect Outputs:
         *              RDB structures built in memory
         *
         *      Local Calls:
         *              parse ()
         *
         *      OS Calls:
         *              fclose ()
         *
         *      Algorithm:
         *              If file open close it.
         *              @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} memp.
         *              if data pointer is real use it.
         *              If RDBs not already open
         *                      parse data as it comes until null character.
         *
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} __saveds __asm
        //HDW_InMemMountfile ( register __d0 @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} unit,
        //                                       register __a0 char *mfdata,
        //                                       register __a1 char *controller )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "6) Read Mountfile from memory and write as Mountfile to memory.\\n\\n");
                                /* More specifically read Mountfile from disk and write as mountfile to
                                 * printing results to stdout.
                                 */
                                if ( !filename )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a filename\\n" );
                                        break;
                                }
                                if ( strlen( filename ) > 248 )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Filename: %s is too long!\\n", filename );
                                        break;
                                }
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }
                                @{"sprintf" LINK "gg:doc/NDK/Guide/amiga_lib/sprintf"} ( realfilename, "%s%s", filename, ".list" );
                                workfile = fopen ( realfilename, "rb" );
                                if ( !workfile )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Failed to open %s\\n", realfilename );
                                        goto cleanup;
                                }
                                fseek ( workfile, 0, SEEK_END );
                                sizeb = ftell ( workfile );
                                fseek ( workfile, 0, 0 );
                                inmembuffer = malloc ( sizeb + 1 );
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Read %d blocks of %d bytes\\n", fread ( inmembuffer, sizeb, 1, workfile ), sizeb);
                                fclose ( workfile );
                                inmembuffer [ sizeb ] = 0;
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( inmembuffer ); // For reference

                                rsuccess = @{"InMemMountfile" LINK "InMemMountfile"} ( baseunit, inmembuffer, devicename );
                                if ( rsuccess == 0 )
                                {
                                        rsuccess = @{"OutMemMountfile" LINK "OutMemMountfile"} ( @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, &sizememneeded, 0, baseunit );

                                        if ( rsuccess == 0 )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "6) Need %ld bytes of buffer for mountfile.\\n", sizememneeded );
                                                outmembuffer = malloc ( sizememneeded + 256 );
                                                if ( outmembuffer )
                                                {
                                                        rsuccess = @{"OutMemMountfile" LINK "OutMemMountfile"} ( outmembuffer, &sizememneeded, sizememneeded + 255, baseunit );
                                                        if ( rsuccess == 0 )
                                                        {
                                                                FILE *foofile = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};

                                                                outmembuffer [ sizememneeded + 255 ] = 0;
                                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Actual use = %d\\n", strlen( outmembuffer ));
                                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( outmembuffer );

                                                                foofile = fopen ( "foo", "wb" );
                                                                if ( foofile )
                                                                {
                                                                        fwrite ( outmembuffer, sizememneeded, 1, foofile );
                                                                        fclose ( foofile );
                                                                        foofile = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};
                                                                }
                                                        }
                                                        else
                                                        {
                                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Could not write the file: %d\\n", rsuccess );
                                                        }
                                                }
                                        }
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Mountfile size write failed: %d\\n", rsuccess );
                                }
                                else
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"InMemMountfile" LINK "InMemMountfile"} failed, %ld\\n", rsuccess );

                                break;

                        case 7:
        /* HDW_OutMemRDBStructs()
         *      Description:
         *              (Write RDBs to memory area instead of RDB area of disk.)
         *              Write RDB structs into external memory if large enough as if
         *              writing to disk. If size = 4L return number of bytes required in
         *              *memp.
         *
         *      Direct Inputs:
         *              memp            Pointer to block of memory to be written
         *              sizeb           Size of each block to be written
         *              sizew           pointer to returned number of BLOCKS written
         *
         *      Indirect Inputs:
         *
         *      Direct Outputs:
         *              ret                     error 0 if success else error indication
         *              sizew           zeroed then incremented by one for each block written
         *
         *      Indirect Outputs:
         *              RDBs written to memory as if to disk
         *
         *      Local Calls:
         *              none
         *
         *      OS Calls:
         *              fclose ()
         *              memcpy ()
         *
         *      Algorithm:
         *              if file open then close it.
         *              @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} memp.
         *              if RDBs not loaded then fail
         *              Figure out block size from existing RDB structures.
         *              Walk the list to determine total size needed using "sizew" variable.
         *              if rdbp entered is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} then
         *                      do not write anything and return size calculated.
         *              Walk the list again writing RDBs to memory using memcpy.
         *              return 0;
         *
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} __saveds __asm
        //HDW_OutMemRDBStructs ( register __a0 char *rdbp,
        //                                         register __a1 @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} *sizew,           // Size written
        //                                         register __d0 @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} sizeb )           // Size of buffer
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "7) Read Mountfile from memory and write as RDB Structs to memory.\\n\\n");
                                /* More specifically read Mountfile from disk and write from memory
                                 * to "foo" as one block of RDB Structs.
                                 */
                                if ( !filename )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a filename\\n" );
                                        break;
                                }
                                if ( strlen( filename ) > 248 )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Filename: %s is too long!\\n", filename );
                                        break;
                                }
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }
                                @{"sprintf" LINK "gg:doc/NDK/Guide/amiga_lib/sprintf"} ( realfilename, "%s%s", filename, ".list" );
                                workfile = fopen ( realfilename, "rb" );
                                if ( !workfile )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Failed to open %s\\n", realfilename );
                                        goto cleanup;
                                }
                                fseek ( workfile, 0, SEEK_END );
                                sizeb = ftell ( workfile );
                                fseek ( workfile, 0, 0 );
                                inmembuffer = malloc ( sizeb + 1 );
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Read %d blocks of %d bytes\\n", fread ( inmembuffer, sizeb, 1, workfile ), sizeb);
                                fclose ( workfile );
                                inmembuffer [ sizeb ] = 0;

                                rsuccess = @{"InMemMountfile" LINK "InMemMountfile"} ( baseunit, inmembuffer, devicename );
                                if ( rsuccess == 0 )
                                {
                                        sizememneeded = 0;
                                        rsuccess = @{"OutMemRDBStructs" LINK "OutMemRDBStructs"} ( @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, &sizememneeded, 0 );

                                        if ( rsuccess == 0 )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "7) Need %ld bytes of buffer for mountfile.\\n", sizememneeded );
                                                outmembuffer = malloc ( sizememneeded + 256 );
                                                if ( outmembuffer )
                                                {
        //                                              int i;
        //                                              for ( i = sizememneeded; i < sizememneeded + 256; i++)
        //                                                      outmembuffer[i] = 'A';
                                                        rsuccess = @{"OutMemRDBStructs" LINK "OutMemRDBStructs"} ( outmembuffer, &sizememneeded, sizememneeded + 255 );
                                                        if ( rsuccess == 0 )
                                                        {
                                                                FILE *foofile = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};

                                                                outmembuffer [ sizememneeded + 255 ] = 0;
                                                                printhex ( &outmembuffer[sizememneeded-16], 256 );

                                                                foofile = fopen ( "foo", "wb" );
                                                                if ( foofile )
                                                                {
                                                                        fwrite ( outmembuffer, sizememneeded, 1, foofile );
                                                                        fclose ( foofile );
                                                                        foofile = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};
                                                                }
                                                        }
                                                        else
                                                        {
                                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Could not write the file: %d\\n", rsuccess );
                                                        }
                                                }
                                        }
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Mountfile size write failed: %d\\n", rsuccess );
                                }
                                else
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"InMemMountfile" LINK "InMemMountfile"} failed, %ld\\n", rsuccess );

                                break;

                        case 8:
        /* HDW_InMemRDBStructs()
         *      Description:
         *              (Read RDBs from memory instead of RDB area of disk.)
         *              Read the dumped RDB structure format into internal memory as if from
         *              disk from an external memory block.
         *
         *      Direct Inputs:
         *              rdbp            Pointer to RDBs in memory
         *              sizeb           Block size
         *              startb          start block number
         *              endp            end memory pointer
         *      Indirect Inputs:
         *
         *      Direct Outputs:
         *              ret                     error 0 if success else error indication
         *
         *      Indirect Outputs:
         *              @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} list filled
         *
         *      Local Calls:
         *              none
         *
         *      OS Calls:
         *              fclose ()
         *              memcpy ()
         *
         *      Algorithm:
         *              if RDBs already open then fail
         *              if file open then close it
         *              If memory pointer open then close it.
         *              if pointer not valid then fail
         *              set memory base to memory pointer
         *              Set memory end pointer to memory pointer plus input size.
         *              If fails simple consitency checks then fail
         *              // Note - RDSK block *MUST* be first
         *              Determine "blocksize" from first RDB in list as RDSK.
         *              Set base block number to rdb_RDBBlocksLo
         *              While ( still in passed memory block )
         *                      if not a legitimate RDB block then fail
         *                      Allocate a block for the list
         *                      Setup overhead data and increment bnum
         *                      Directly copy block data into allocated block
         *                      Increment memory pointer by block size discovered
         *              return no error
         *
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}  __saveds __asm
        //HDW_InMemRDBStructs ( register __a0 char *rdbp,                       // Start of RDB buffer
        //                                        register __d0 @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} sizerdb,          // Size of source buffer
        //                                        register __d1 @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} unit )            // Presumed unit
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "8) Read RDBStructs memory and write as RDB Structs to memory.\\n\\n");
                                /* More specifically read Mountfile from disk and write from memory
                                 * to "foo" as one block of RDB Structs.
                                 */
                                if ( !filename )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a filename\\n" );
                                        break;
                                }
                                if ( strlen( filename ) > 248 )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Filename: %s is too long!\\n", filename );
                                        break;
                                }
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }
                                @{"sprintf" LINK "gg:doc/NDK/Guide/amiga_lib/sprintf"} ( realfilename, "%s%s", filename, "..rdb" );
                                workfile = fopen ( realfilename, "rb" );
                                if ( !workfile )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Failed to open %s\\n", realfilename );
                                        goto cleanup;
                                }
                                fseek ( workfile, 0, SEEK_END );
                                sizeb = ftell ( workfile );
                                fseek ( workfile, 0, 0 );
                                inmembuffer = malloc ( sizeb + 1 );
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Read %d blocks of %d bytes\\n", fread ( inmembuffer, sizeb, 1, workfile ), sizeb);
                                fclose ( workfile );

                                rsuccess = @{"InMemRDBStructs" LINK "InMemRDBStructs"} ( inmembuffer,       // Start of RDB buffer
                                                                                         sizeb,                 // Size of source buffer
                                                                                         baseunit );    // Presumed unit
                                if ( rsuccess == 0 )
                                {
                                        sizememneeded = 0;
                                        rsuccess = @{"OutMemRDBStructs" LINK "OutMemRDBStructs"} ( @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, &sizememneeded, 0 );

                                        if ( rsuccess == 0 )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "8) Need %ld bytes of buffer for mountfile.\\n", sizememneeded );
                                                outmembuffer = malloc ( sizememneeded + 256 );
                                                if ( outmembuffer )
                                                {
                                                        rsuccess = @{"OutMemRDBStructs" LINK "OutMemRDBStructs"} ( outmembuffer, &sizememneeded, sizememneeded + 255 );
                                                        if ( rsuccess == 0 )
                                                        {
                                                                FILE *foofile = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};

                                                                outmembuffer [ sizememneeded + 255 ] = 0;

                                                                foofile = fopen ( "bar", "wb" );
                                                                if ( foofile )
                                                                {
                                                                        fwrite ( outmembuffer, sizememneeded, 1, foofile );
                                                                        fclose ( foofile );
                                                                        foofile = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};
                                                                }
                                                        }
                                                        else
                                                        {
                                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Could not write the file: %d\\n", rsuccess );
                                                        }
                                                }
                                        }
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Mountfile size write failed: %d\\n", rsuccess );
                                }
                                else
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"InMemMountfile" LINK "InMemMountfile"} failed, %ld\\n", rsuccess );

                                break;



        /******************************************
         *
         *      9
         *              BASIC RDB READ TEST
         *
         *****************************************/
                        case 9:
        /* HDW_ReadRDBs
         *      Description:
         *              Read the entire RDB structure into RAM. Pay NO attention to decodes.
         *
         *      Direct Inputs:
         *              none
         *
         *      Indirect Inputs:
         *              none except in functions called
         *
         *      Direct Outputs:
         *              @{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} with the "worst" success or fail value
         *
         *      Indirect Outputs:
         *              Completely loaded image of the disk's RDBs in a traceable structure
         *
         *      Local Calls:
         *              ClearBlockList ()
         *              AllocBlock ()
         *              HDW_RawRead ()
         *              ScanList ()
         *
         *      OS Calls:
         *              none
         *
         *      Algorithm:
         *              scan blocks 0 through 16 until we have found an RDSK block.
         *              mark AllocLimitLo = RDSK block number;  ??
         *              ScanList ( RDSK_block->bb_Longs [ 6 ]); /* BadBlocks */
         *              ScanList ( RDSK_block->bb_Longs [ 7 ]); /* Partitions */
         *              ScanList ( RDSK_block->bb_Longs [ 8 ]); /* FileSystems */
         *              ScanList ( RDSK_block->bb_Longs [ 9 ]); /* DriveInits */
         *              Then can scanlist for any others that may appear from 6 reserved.
         *
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //@{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} __saveds __asm
        //HDW_ReadRDBs ( void )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "9) Read RDB from disk and write as mountfile to <file>...list.\\n\\n");
                                if ( !filename )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a filename\\n" );
                                        break;
                                }
                                if ( strlen( filename ) > 248 )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Filename: %s is too long!\\n", filename );
                                        break;
                                }
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }


                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s:%d\\n", devicename, baseunit );
                                deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                if ( !deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "No device was opened!\\n");
                                        break;
                                }

                                rwsuccess = @{"ReadRDBs ( )" LINK "ReadRDBs"};


                                if ( rwsuccess == success )
                                {
                                        @{"sprintf" LINK "gg:doc/NDK/Guide/amiga_lib/sprintf"} ( realfilename, "%s%s", filename, "...list" );
                                        rwsuccess = @{"WriteMountfile" LINK "WriteMountfile"} ( realfilename, "jdow:hdwrench", baseunit );
                                        if ( rwsuccess == 0 )
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "You should have a new %s waiting.\\n", realfilename );
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Mountfile write failed: %d\\n", rwsuccess );
                                }
                                else
                                {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "RDB read failed: %d\\n", rwsuccess );
                                                break;
                                }

                                if ( deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                                        @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                                        deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                }

                                break;


                        case 10:
        /* HDW_QueryInquiry
         *      Description:
         *              Issue a SCSI "INQUIRY" command and return results
         *      Direct Inputs:
         *              errorcode               Pointer to error code storage
         *      Indirect Inputs:
         *              none
         *      Direct Outputs:
         *              returns result codes lightly massaged
         *      Indirect Outputs:
         *              SC data field filled with inquiry data.
         *      Local Calls:
         *              none
         *      OS Calls:
         *              @{"DoIO ()" LINK "gg:doc/NDK/Guide/exec/DoIO"}
         *      Algorithm:
         *              Fill out SCMD for an INQUIRY command
         *              Issue the command
         *              return lightly massaged results
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} __saveds __asm
        //HDW_QueryInquiry ( register __a0 @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} *inqbuf, register __a1 int *errorcode )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "10) Perform SCSI Inquiry and report results up to 40 bytes.\\n\\n");
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }

                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s:%d\\n", devicename, baseunit );
                                deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                if ( !deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "No device was opened!\\n");
                                        break;
                                }

                                {
                                        @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} inqbuf [ @{"INQBUFSIZE" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 390} ];
                                        int      errorcode;

                                        memset ( inqbuf, 0xff, @{"INQBUFSIZE" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 390} );
                                        if ( @{"QueryInquiry" LINK "QueryInquiry"} ( inqbuf, &errorcode ))
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "SCSI inquiry returns:\\n" );
                                                printhex ( inqbuf, @{"INQBUFSIZE" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 390} );
                                        }
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "SCSI inquiry failed: %d\\n", errorcode );
                                }

                                if ( deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                                        @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                                        deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                }
                                break;

                        case 11:
        /* HDW_QueryModeSense ()
         *      Description:
         *
         *      Direct Inputs:
         *              page                    mode sense page requested
         *
         *      Indirect Inputs:
         *
         *      Direct Outputs:
         *
         *      Indirect Outputs:
         *
         *      Local Calls:
         *
         *      OS Calls:
         *              @{"DoIO ()" LINK "gg:doc/NDK/Guide/exec/DoIO"}
         *      Algorithm:
         *
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} __saveds __asm
        //HDW_QueryModeSense ( register __d0 int                 page,
        //                                       register __d1 int               msbsize,
        //                                       register __a0 @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58}             *msbuf,
        //                                       register __a1 int              *errorcode )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "11) Perform SCSI ModeSense  and report results up to 256 bytes.\\n\\n");
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }

                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s:%d\\n", devicename, baseunit );
                                deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                if ( !deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "No device was opened!\\n");
                                        break;
                                }

                                {
                                        @{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} msbuf [ 256 ];
                                        int      errorcode;

                                        memset ( msbuf, 0xff, 256 );
                                        if ( @{"QueryModeSense" LINK "QueryModeSense"} ( (@{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58}) mspage, 256, msbuf, &errorcode ))  // All sets page 0
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "SCSI ModeSense returns:\\n" );
                                                printhex ( msbuf, 256 );
                                        }
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "SCSI ModeSense failed: %d\\n", errorcode );
                                }

                                if ( deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                                        @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                                        deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                }
                                break;

                        case 12:

        /* HDW_QueryCapacity
         *      Description:
         *
         *      Direct Inputs:
         *              none
         *      Indirect Inputs:
         *
         *      Direct Outputs:
         *
         *      Indirect Outputs:
         *
         *      Local Calls:
         *
         *      OS Calls:
         *              @{"DoIO ()" LINK "gg:doc/NDK/Guide/exec/DoIO"}
         *      Algorithm:
         *
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} __saveds __asm
        //HDW_QueryCapacity( register __a0 @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} *capacity )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "12) Perform SCSI Read Capacity and report disk size.\\n\\n");
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }

                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s:%d\\n", devicename, baseunit );
                                deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                if ( !deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "No device was opened!\\n");
                                        break;
                                }

                                {
                                        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} capacity;
                                        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} blocksize;

                                        if ( @{"QueryCapacity" LINK "QueryCapacity"} ( &capacity, &blocksize ))   // All sets page 0
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "SCSI Read Capacity returns: %ld blocks of %ld bytes.\\n",
                                                                 capacity,
                                                                 blocksize );
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "SCSI Read Capacity failed\\n" );
                                }

                                if ( deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                                        @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                                        deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                }
                        break;

                        case 13:
        /* HDW_QueryReady
         *      Description:
         *              Issue a SCSI "TEST UNIT READY" command and return results
         *      Direct Inputs:
         *              errorcode               pointer to an error code return
         *
         *      Indirect Inputs:
         *
         *      Direct Outputs:
         *              returns @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} for ready and @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} for not ready
         *      Indirect Outputs:
         *              errorcode               contains the (massaged) IO error codes on return
         *      Local Calls:
         *              none
         *      OS Calls:
         *              @{"DoIO ()" LINK "gg:doc/NDK/Guide/exec/DoIO"}
         *      Algorithm:
         *              Fill out SCMD for a TEST UNIT READY command
         *              Issue the command
         *              fill out errorcode
         *              return Ready or not ready
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} __saveds __asm
        //HDW_QueryReady ( register __a0 int * errorcode )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "13) Perform SCSI Test Unit Ready and report device readiness.\\n\\n");
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }

                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s:%d\\n", devicename, baseunit );
                                deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                if ( !deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "No device was opened!\\n");
                                        break;
                                }

                                {
                                        int errorcode;

                                        if ( @{"QueryReady" LINK "QueryReady"} ( &errorcode )) // All sets page 0
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "SCSI Test Unit Ready indicates ready.\\n" );
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "SCSI Test Unit Ready indicates not ready: %ld\\n", errorcode );
                                }

                                if ( deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                                        @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                                        deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                }
                        break;

                        case 14:
        /* HDW_FindDiskName ()
         *      Description:
         *              Reads manufacturer data from Inquiry command and installs in supplied
         *              string space. Should be a valid device.
         *
         *      Direct Inputs:
         *              diskname                A pointer to a disk name storage array
         *
         *      Indirect Inputs:
         *              Already opened device
         *
         *      Direct Outputs:
         *
         *      Indirect Outputs:
         *
         *      Local Calls:
         *              Calls global @{"QueryInquiry" LINK "QueryInquiry"} function
         *
         *      OS Calls:
         *
         *      Algorithm:
         *              if device not open or diskname is null return failure
         *              call HDW_QueryInquiry
         *              Copy disk name into provided storage for exactly 28 bytes using memcpy.
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //@{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} __saveds __asm /* error */
        //HDW_FindDiskName ( register __a0 *diskname )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "14) Find Disk Name returning in string variable.\\n\\n" );
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }

                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s:%d\\n", devicename, baseunit );
                                deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                if ( !deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "No device was opened!\\n");
                                        break;
                                }

                                {
                                        char diskname[32];

                                        memset ( diskname, 0xff, 32 );
                                        if ( @{"FindDiskName" LINK "FindDiskName"} ( diskname ))
                                                printhex ( diskname, 32 );
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"FindDiskName" LINK "FindDiskName"} failed!\\n" );
                                }

                                if ( deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                                        @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                                        deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                }
                        break;

                        case 15:
        /* HDW_FindControllerID()
         *      Description:
         *              Test open devices until find SelfID error
         *              ( Of course, this does not work on Commododo "scsi.device". <bleah!> )
         *
         *      Direct Inputs:
         *              @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   *selfid pointer to selfid result field. Contains a Unit number
         *                                              with a valid board number field.
         *
         *      Indirect Inputs:
         *
         *      Direct Outputs:
         *              Unit number for controller's SCSI ID.
         *
         *      Indirect Outputs:
         *
         *      Local Calls:
         *
         *      OS Calls:
         *
         *      Algorithm:
         *
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //BOOL16 Apr 1999 __saveds __asm /* error */
        //HDW_FindControllerID ( register __a0 char *devname, register __a1 @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} *selfid )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "15) Find Controller self-ID returning in @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}.\\n\\n" );
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }

                                {
                                        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} selfid = baseunit;

                                        if ( @{"FindControllerID" LINK "FindControllerID"} ( devicename, &selfid ))
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Controller ID is %ld.\\n", selfid );
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"FindControllerID" LINK "FindControllerID"} failed!\\n" );
                                }
                                break;

                        case 16:
        /* HDW_FindLastSector() ( Made available chiefly for diagnostic purposes.)
         *      Description:
         *              Determine last available sector on disk WITH tests.
         *
         *      Direct Inputs:
         *
         *      Indirect Inputs:
         *
         *      Direct Outputs:
         *              Last block on the disk numbered 1 through n. (This was done so that
         *              the TotalBlocks report and the @{"FindLastSector" LINK "FindLastSector"} report are congruent.)
         *
         *      Indirect Outputs:
         *
         *      Local Calls:
         *
         *      OS Calls:
         *
         *      Algorithm:
         *              HDW_QueryCapacity
         *              Test what should be last block.
         *              If ( Read the rated last block is OK )
         *                      if ( Read the block past rated last block is bad )
         *                              return no error and last sector number confirmed.
         *                      else
         *                              Search upwards binary search until find real last bad
         *                              sector. Return error "Last Sector to low" and found top block.
         *              else
         *                      Step downwards one block then two then four until read one OK.
         *                      Then step upwards binary search for actual top block.
         *                      Return error "Last sector too high" and found top block.
         *              endif
         *              exit
         *
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} __saveds __asm /* error */
        //HDW_FindLastSector ( void )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "16) Report last available block on the drive.\\n\\n");
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }

                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s:%d\\n", devicename, baseunit );
                                deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                if ( !deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "No device was opened!\\n");
                                        break;
                                }

                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Find Last Sector returns: %ld\\n", @{"FindLastSector()" LINK "FindLastSector"});

                                if ( deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                                        @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                                        deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                }
                        break;

                        case 17:
        /* HDW_FindDefaults ()
         *      Description:
         *              Determine default blocking for device.
         *
         *      Direct Inputs:
         *              Optimize                A flag array for optimization values
         *              Return                  Pointer to a DefaultsArray structure for return values
         *
         *      Indirect Inputs:
         *              Opened IO device
         *
         *      Direct Outputs:
         *              Error return value passing back informational and fatal errors.
         *              The DefaultsArray passed in is filled in
         *
         *      Indirect Outputs:
         *              Many internal values are filled in which will be overridden when
         *              reading RDBs or Mountfiles.
         *
         *      Local Calls:
         *              HDW_FindLastSector ()
         *              HDW_QueryInquiry ()
         *              HDW_QueryModeSense ()
         *
         *      OS Calls:
         *
         *      Algorithm:
         *              HDW_QueryCapacity
         *              HDW_FindLastBlock () // Test what should be last block.
         *              Division routines....
         *              exit
         *
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} __saveds __asm
        //HDW_FindDefaults ( register __d0 @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} Optimize,
        //                                 register __a0 @{"struct DefaultsArray" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 156} Return )
        /*@{"struct DefaultsArray" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 156}
         *{
         *      @{"UWORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 55}   BytesPerBlock;
         *      @{"UWORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 55}   BlocksPerSurface;
         *      @{"UWORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 55}   Surfaces;
         *      @{"UWORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 55}   Cylinders;                              // note: MaxCyl = Cylinders - 1;
         *};
         */
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "17) Generate default drive parameters.\\n\\n" );
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }

                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s:%d\\n", devicename, baseunit );
                                deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                if ( !deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "No device was opened!\\n");
                                        break;
                                }

                                {
                                        @{"struct  DefaultsArray" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 156} defaults;
                                        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}   errorcode;

                                        memset ( &defaults, 0, sizeof ( @{"struct DefaultsArray" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 156}) );
                                        errorcode = @{"FindDefaults" LINK "FindDefaults"} ( 0, &defaults );      // No optimize
                                        if ( errorcode == 0 )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "TotalBlocks:         %d\\n", defaults.TotalBlocks );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "BytesPerBlock:       %d\\n", defaults.BytesPerBlock );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "BlocksPerSurface:    %d\\n", defaults.BlocksPerSurface );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Surfaces:            %d\\n", defaults.Surfaces );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Cylinders:           %d\\n", defaults.Cylinders );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Unused Blocks:       %d\\n", defaults.UnusedBlocks );
                                        }
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"FindDefaults" LINK "FindDefaults"} failed!\\n" );

                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "\\nAttempting Optimized Defaults.\\n" );
                                        memset ( &defaults, 0, sizeof ( @{"struct DefaultsArray" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 156}) );
                                        errorcode = @{"FindDefaults" LINK "FindDefaults"} ( @{"DA_OPTIMIZE" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 177}, &defaults );
                                        if ( errorcode == 0 )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "TotalBlocks:         %d\\n", defaults.TotalBlocks );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "BytesPerBlock:       %d\\n", defaults.BytesPerBlock );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "BlocksPerSurface:    %d\\n", defaults.BlocksPerSurface );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Surfaces:            %d\\n", defaults.Surfaces );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Cylinders:           %d\\n", defaults.Cylinders );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Unused Blocks:       %d\\n", defaults.UnusedBlocks );
                                        }
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"FindDefaults" LINK "FindDefaults"} failed!\\n" );

                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "\\nAttempting HardFrame Defaults.\\n" );
                                        memset ( &defaults, 0, sizeof ( @{"struct DefaultsArray" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 156}) );
                                        errorcode = @{"FindDefaults" LINK "FindDefaults"} ( @{"DA_HF_WAY" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 179}, &defaults );
                                        if ( errorcode == 0 )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "TotalBlocks:         %d\\n", defaults.TotalBlocks );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "BytesPerBlock:       %d\\n", defaults.BytesPerBlock );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "BlocksPerSurface:    %d\\n", defaults.BlocksPerSurface );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Surfaces:            %d\\n", defaults.Surfaces );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Cylinders:           %d\\n", defaults.Cylinders );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Unused Blocks:       %d\\n", defaults.UnusedBlocks );
                                        }
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"FindDefaults" LINK "FindDefaults"} failed!\\n" );

                                        // Note this is a "hidden flag" used for debugging.
                                        // It is otherwise pointless to use.
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "\\nAttempting 1Meg Cylinder size Defaults.\\n" );
                                        memset ( &defaults, 0, sizeof ( @{"struct DefaultsArray" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 156}) );
                                        errorcode = @{"FindDefaults" LINK "FindDefaults"} ( 8, &defaults );
                                        if ( errorcode == 0 )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "TotalBlocks:         %d\\n", defaults.TotalBlocks );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "BytesPerBlock:       %d\\n", defaults.BytesPerBlock );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "BlocksPerSurface:    %d\\n", defaults.BlocksPerSurface );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Surfaces:            %d\\n", defaults.Surfaces );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Cylinders:           %d\\n", defaults.Cylinders );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Unused Blocks:       %d\\n", defaults.UnusedBlocks );
                                        }
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"FindDefaults" LINK "FindDefaults"} failed!\\n" );

                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "\\nAttempting Optimized Defaults with a huge disk.\\n" );
                                        memset ( &defaults, 0, sizeof ( @{"struct DefaultsArray" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 156}) );
                                        errorcode = @{"FindDefaults" LINK "FindDefaults"} ( @{"DA_OPTIMIZE" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 177} | @{"DA_HUGE" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 178}, &defaults );
                                        if ( errorcode == 0 )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "TotalBlocks:         %d\\n", defaults.TotalBlocks );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "BytesPerBlock:       %d\\n", defaults.BytesPerBlock );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "BlocksPerSurface:    %d\\n", defaults.BlocksPerSurface );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Surfaces:            %d\\n", defaults.Surfaces );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Cylinders:           %d\\n", defaults.Cylinders );
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Unused Blocks:       %d\\n", defaults.UnusedBlocks );
                                        }
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"FindDefaults" LINK "FindDefaults"} failed!\\n" );
                                }

                                if ( deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                                        @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                                        deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                }
                        break;

                        case 18:
        /* HDW_RawRead
         *      Description:
         *              Read a block from the disk into the provided @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} structure at
         *              the block number stored in the @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} structure.
         *
         *      Direct Inputs:
         *              bb                              pointer to an array of @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} of indefinate size.
         *              blocknum                The number of the block to read.
         *
         *      Indirect Inputs:
         *              SC                      Global utility SCSI direct command field
         *              SCCmd           Global utility SCSI command field
         *              IOR                     IO Request block for a presumed opened device
         *              ddBlockBytes    Block size as determined from the first (good) disk read
         *                                              On first read use 16384. On success this is updated from
         *                                              SCSI.actual.
         *      Direct Output:
         *              @{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} Success or failure per enum...
         *
         *      Indirect Output:
         *              bb                              filled with data and errorcode from the read.
         *              ddBlockBytes    updated as appropriate for size of actual read.
         *
         *      Local Calls:
         *              None
         *
         *      OS Calls:
         *              @{"DoIO ()" LINK "gg:doc/NDK/Guide/exec/DoIO"}
         *
         *      Algorithm:
         *              If block less than 2097152, 2^21, use the 6 byte command sequence,
         *              else use the 10 byte read command sequence. (This is an arbitrary choice.)
         *
         *              Ascertain device is open
         *              allocate temporary read block per size of ddBlockBytes
         *              Build the command
         *              issue the command
         *              If command good
         *                      if ddBlockBytes == 16384 set ddBlockBytes to actual xfersize
         *                      copy actual transfer size bytes into bb
         *              if blocksize not power of two >= 512L <= 16384L
         *                      errorcode = invalid_block_size
         *              return error codes as appropriate.
         *
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //@{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} __saveds __asm
        //HDW_RawRead ( register __a0 @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} *bbk, register __d0 @{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} size )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "18) Read and report raw sector 'MS'.\\n\\n");
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }

                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s:%d\\n", devicename, baseunit );
                                deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                if ( !deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "No device was opened!\\n");
                                        break;
                                }


                                {
                                        @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79}       *bb;
                                        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}            capacity;
                                        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}            blocksize;
                                        @{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82}           ecode;

                                        if ( @{"QueryCapacity" LINK "QueryCapacity"} ( &capacity, &blocksize ))   // All sets page 0
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "SCSI Read Capacity returns: %ld blocks of %ld bytes.\\n",
                                                                 capacity,
                                                                 blocksize );
                                        else
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "SCSI Read Capacity failed\\n" );
                                                blocksize = 16384L;                     // Better use a safe blocksize!
                                        }

                                        bb = malloc ( sizeof ( @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} ) - 512 + blocksize );
                                        if ( bb == @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} allocation failed!\\n" );
                                                break;
                                        }

                                        bb->bb_BlockNum = mspage;       // Only value really needed
                                        ecode = @{"RawRead" LINK "RawRead"} ( bb, blocksize );
                                        if ( ecode == success )
                                                printhex ( bb->bb_Data.bd_Bytes, blocksize );
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"RawRead" LINK "RawRead"} failed %d!", ecode );

                                }


                                if ( deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                                        @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                                        deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                }
                        break;

                        case 19:
        /* HDW_QueryFindValid
         *      Description:
         *              Attempt to determine all valid configureable units on devicename
         *              according to an acceptable types bitmap supplied on entry. Data is
         *              filled into a 16 word of 16 bits each bitmap with pointer supplied
         *              on entry. "BoardNumber" to be tested is supplied by the calling
         *              routine.
         *      Direct Inputs:
         *              ValidIDs                        Pointer @{"ValidIDstruct" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 39}
         *              devicename                      device name for testing
         *              board                           Board ID to test
         *              types                           @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} bitmap of valid device typese
         *              widescsi                        BOOLEAN set @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if wide scsi used.
         *              CallBack                        Pointer to callback handler
         *
         *      Indirect Inputs:
         *
         *      Direct Outputs:
         *
         *      Indirect Outputs:
         *
         *      Local Calls:
         *
         *      OS Calls:
         *
         *      Algorithm:
         *              Clear the supplied bitmap array
         *              For all IDs on the SCSI bus
         *                      For all LUNs on each ID
         *                              HW_OpenDevice ( Board, ID, LUN, devicename )
         *                              TestUnitReady()
         *                              Inquiry()
         *                              if in valid types
         *                                      Mark as valid
         *                              if LUN 0 fails to open
         *                                      break - skipping remaining LUNs
         *                              if self-id for controller
         *                                      break - skipping controller
         *              return completion status
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //void __saveds __asm
        //HDW_QueryFindValid ( register __a0 @{"ValidIDstruct" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 39} *ValidIDs,
        //                                         register __a1 char * devicename,
        //                                         register __d0 int board,
        //                                         register __d1 @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} types,
        //                                         register __d2 @{"BOOL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 91} wide_scsi,
        //                                         register __a2 long ( *__asm CallBack)
        //                                                                                 ( register __a0 @{"HDWCallbackMsg" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 305} msg ));
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "19) Find all valid disks on a given controller.\\n\\n");
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }

                                {
                                        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}                    types;
                                        int                              board = baseunit;
                                        @{"ValidIDstruct" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 39}    ValidIDs;

                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Trying for hard disks only.\\n" );
                                        types = 1;      // Only disk drives!
                                        @{"QueryFindValid" LINK "QueryFindValid"} ( &ValidIDs, devicename, board, types, @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}, @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} );
                                        printhex ( (@{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} *) ValidIDs.there, 16 * sizeof (@{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} ));
                                        printhex ( (@{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} *) ValidIDs.ready, 16 * sizeof (@{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} ));

                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "\\nTrying for ALL drive types.\\n" );
                                        types = (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L;    // All devices!
                                        @{"QueryFindValid" LINK "QueryFindValid"} ( &ValidIDs, devicename, board, types, @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}, CallBack );
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ("\\n\\n");
                                        printhex ( (@{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} *) ValidIDs.there, 16 * sizeof (@{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} ));
                                        printhex ( (@{"BYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 58} *) ValidIDs.ready, 16 * sizeof (@{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} ));
                                }
                        break;

                        case 20:
        /* HDW_RawWrite
         *      Description:
         *              Write the data section of a @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} to the disk at the block number
         *              stored within the @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} structure.
         *
         *      Direct Inputs:
         *              bb                              pointer to a @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} structure of indefinate size.
         *                                              Note that bb includes the block ID
         *
         *      Indirect Inputs:
         *              SC                      Global utility SCSI direct command field
         *              SCCmd           Global utility SCSI command field
         *              IOR                     IO Request block for a presumed opened device
         *              ddBlockBytes    Block size as determined from the first (good) disk read
         *                                              On first read use 16384. On success this is updated from
         *                                              SCSI.actual.
         *
         *      Direct Output:
         *              UHSORT Success or failure per enum...
         *
         *      Indirect Output:
         *              bb                              data field written to disk.
         *
         *      Local Calls:
         *              None
         *
         *      OS Calls:
         *              @{"DoIO ()" LINK "gg:doc/NDK/Guide/exec/DoIO"}
         *
         *      Algorithm:
         *              Make sure IOR is legitimately opened
         *              blocknum = bb->bb_BlockNum
         *              if blocknum = -1
         *                      find in bitmap first unassigned block and assign it
         *                      repair bb->BlockNum and blocknum to reflect this
         *              Build the SCSI command
         *              Issue IO command
         *              return massaged error code.
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //@{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} __saveds __asm
        //HDW_RawWrite ( register __a0 @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} *bb )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "20) Raw write to a block of low disk. (Safe write - I hope!)\\n\\n");
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }

                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s:%d\\n", devicename, baseunit );
                                deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                if ( !deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "No device was opened!\\n");
                                        break;
                                }


                                {
                                        @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79}       *bb;
                                        @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79}       *bbt;
                                        @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79}       *bbtr;
                                        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}            capacity;
                                        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}            blocksize;
                                        @{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82}           ecode;

                                        if ( @{"QueryCapacity" LINK "QueryCapacity"} ( &capacity, &blocksize ))   // All sets page 0
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "SCSI Read Capacity returns: %ld blocks of %ld bytes.\\n",
                                                                 capacity,
                                                                 blocksize );
                                        else
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "SCSI Read Capacity failed\\n" );
                                                blocksize = 16384L;                     // Better use a safe blocksize!
                                        }

                                        bb   = malloc ( sizeof ( @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} ) - 512 + blocksize );
                                        bbt  = malloc ( sizeof ( @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} ) - 512 + blocksize );
                                        bbtr = malloc ( sizeof ( @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} ) - 512 + blocksize );
                                        if (( bb == @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} ) || ( bbt == @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} ) || ( bbtr == @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} ))
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} allocation failed!\\n" );
                                                if ( bb )
                                                        free ( bb );
                                                if ( bbt )
                                                        free ( bbt );
                                                if ( bbtr )
                                                        free ( bbtr );
                                                break;
                                        }

                                        bb->bb_BlockNum   = mspage;     // Only value really needed
                                        bbt->bb_BlockNum  = mspage;     // Only value really needed
                                        bbtr->bb_BlockNum = mspage;     // Only value really needed

                                        ecode = @{"RawRead" LINK "RawRead"} ( bb, blocksize );
                                        if ( ecode == success )
                                                printhex ( bb->bb_Data.bd_Bytes, 32 );
                                        else
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"RawRead" LINK "RawRead"} failed %d!", ecode );
                                                if ( bb )
                                                        free ( bb );
                                                if ( bbt )
                                                        free ( bbt );
                                                if ( bbtr )
                                                        free ( bbtr );
                                                break;
                                        }
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "This IS dangerous. Continue? ");
                                        gets ( bbt->bb_Data.bd_Bytes );
                                        if ( bbt->bb_Data.bd_Bytes [ 0 ] != 'Y' )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "OK, I'm GONE Kemosabe!\\n" );
                                                if ( bb )
                                                        free ( bb );
                                                if ( bbt )
                                                        free ( bbt );
                                                if ( bbtr )
                                                        free ( bbtr );
                                                break;
                                        }

                                        // OK guys - this is the BIG doodoo if we get it wrong!
                                        // Write exactly the same data back....
                                        ecode = @{"RawWrite" LINK "RawWrite"} ( bb );
                                        if ( ecode != success )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"RawWrite" LINK "RawWrite"} failed, %d\\n", ecode );
                                                if ( bb )
                                                        free ( bb );
                                                if ( bbt )
                                                        free ( bbt );
                                                if ( bbtr )
                                                        free ( bbtr );
                                                break;
                                        }
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Block written = %d\\n", bb->bb_RWErrors.block_written );

                                        // Now fill the data block with OTHER data!
                                        //
                                        for ( ecode = 0; ecode < blocksize; ecode++ )
                                                bbt->bb_Data.bd_Bytes [ ecode ] = (@{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62}) (ecode & 0xff);

                                        // OK guys - this is the REAL BIG doodoo if we get it wrong!
                                        // Write exactly the same data back....
                                        ecode = @{"RawWrite" LINK "RawWrite"} ( bbt );
                                        if ( ecode != success )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"RawWrite" LINK "RawWrite"} failed, %d\\n", ecode );
                                                if ( bb )
                                                        free ( bb );
                                                if ( bbt )
                                                        free ( bbt );
                                                if ( bbtr )
                                                        free ( bbtr );
                                                break;
                                        }
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Block written = %d\\n", bbt->bb_RWErrors.block_written );

                                        // Reread it for confirmation it was written
                                        ecode = @{"RawRead" LINK "RawRead"} ( bbtr, blocksize );
                                        if ( ecode == success )
                                                printhex ( bbtr->bb_Data.bd_Bytes, 32 );
                                        else
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"RawRead" LINK "RawRead"} failed %d!", ecode );
                                                if ( bb )
                                                        free ( bb );
                                                if ( bbt )
                                                        free ( bbt );
                                                if ( bbtr )
                                                        free ( bbtr );
                                                break;
                                        }

                                        // IMMEDIATELY restore the original block!
                                        ecode = @{"RawWrite" LINK "RawWrite"} ( bb );
                                        if ( ecode != success )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"RawWrite" LINK "RawWrite"} failed, %d\\n", ecode );
                                                if ( bb )
                                                        free ( bb );
                                                if ( bbt )
                                                        free ( bbt );
                                                if ( bbtr )
                                                        free ( bbtr );
                                                break;
                                        }
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Block written = %d\\n", bb->bb_RWErrors.block_written );

                                        for ( ecode = 0; ecode < blocksize; ecode++ )
                                        {
                                                if ( bbt->bb_Data.bd_Bytes [ ecode ] != bbtr->bb_Data.bd_Bytes [ ecode ] )
                                                {
                                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Compare error at %d: %x vs %x\\n",
                                                                         ecode,
                                                                         bbt->bb_Data.bd_Bytes [ ecode ],
                                                                         bbtr->bb_Data.bd_Bytes [ ecode ] );
                                                        break;
                                                }
                                        }
                                        if ( ecode == blocksize )
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Completely successful compare here, too.\\n" );

                                        if ( bb )
                                                free ( bb );
                                        if ( bbt )
                                                free ( bbt );
                                        if ( bbtr )
                                                free ( bbtr );
                                }


                                if ( deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                                        @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                                        deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                }
                        break;

                        case 21:
        /* HDW_WriteBlock
         *      Description:
         *              Write a @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79}'s data to the disk at the block number stored in the
         *              structure. Readback to verify the written data. Repeat a few times on
         *              initial failure.
         *
         *      Direct Inputs:
         *              bb                              pointer to a @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} structure of indefinate size.
         *                                              Note that bb includes the block ID
         *      Indirect Inputs:
         *              SC                      Global utility SCSI direct command field
         *              SCCmd           Global utility SCSI command field
         *              IOR                     IO Request block for a presumed opened device
         *              ddBlockBytes    Block size as determined from the first (good) disk read
         *                                              On first read use 16384. On success this is updated from
         *                                              SCSI.actual.
         *
         *      Direct Output:
         *              @{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} Success or failure per enum...
         *
         *      Indirect Output:
         *              bb                              data field written to disk.
         *
         *      Local Calls:
         *              HDW_RawWrite ()
         *              HDW_RawRead ()
         *
         *      OS Calls:
         *              none
         *
         *      Algorithm:
         *              Allocate temporary @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} structure
         *              repeat several tries:
         *                      Write block
         *                      Read block 1000 to try to flush disk caches slightly
         *                      Read back written block to a scratchpad
         *                      Compare block to scratchpad
         *                      if error repeat
         *              Free temporary bootblock structure
         *              massage error codes.
         *              return massaged error code.
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //@{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} __saveds __asm
        //HDW_WriteBlock( register __a0 @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} *bb )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "21) Write with checksum to a block of low disk. (Safe write - I hope!)\\n\\n");
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }

                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s:%d\\n", devicename, baseunit );
                                deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                if ( !deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "No device was opened!\\n");
                                        break;
                                }

                                {
                                        @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79}       *bb;
                                        @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79}       *bbt;
                                        @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79}       *bbtr;
                                        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}            capacity;
                                        @{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}            blocksize;
                                        @{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82}           ecode;

                                        if ( @{"QueryCapacity" LINK "QueryCapacity"} ( &capacity, &blocksize ))   // All sets page 0
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "SCSI Read Capacity returns: %ld blocks of %ld bytes.\\n",
                                                                 capacity,
                                                                 blocksize );
                                        else
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "SCSI Read Capacity failed\\n" );
                                                blocksize = 16384L;                     // Better use a safe blocksize!
                                        }

                                        bb   = malloc ( sizeof ( @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} ) - 512 + blocksize );
                                        bbt  = malloc ( sizeof ( @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} ) - 512 + blocksize );
                                        bbtr = malloc ( sizeof ( @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} ) - 512 + blocksize );
                                        if (( bb == @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} ) || ( bbt == @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} ) || ( bbtr == @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} ))
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} allocation failed!\\n" );
                                                if ( bb )
                                                        free ( bb );
                                                if ( bbt )
                                                        free ( bbt );
                                                if ( bbtr )
                                                        free ( bbtr );
                                                break;
                                        }

                                        bb->bb_BlockNum   = mspage;     // Only value really needed
                                        bbt->bb_BlockNum  = mspage;     // Only value really needed
                                        bbtr->bb_BlockNum = mspage;     // Only value really needed

                                        ecode = @{"RawRead" LINK "RawRead"} ( bb, blocksize );
                                        if ( ecode == success )
                                                printhex ( bb->bb_Data.bd_Bytes, 32 );
                                        else
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"RawRead" LINK "RawRead"} failed %d!", ecode );
                                                if ( bb )
                                                        free ( bb );
                                                if ( bbt )
                                                        free ( bbt );
                                                if ( bbtr )
                                                        free ( bbtr );
                                                break;
                                        }
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "This IS dangerous. Continue? ");
                                        gets ( bbt->bb_Data.bd_Bytes );
                                        if ( bbt->bb_Data.bd_Bytes [ 0 ] != 'Y' )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "OK, I'm GONE Kemosabe!\\n" );
                                                if ( bb )
                                                        free ( bb );
                                                if ( bbt )
                                                        free ( bbt );
                                                if ( bbtr )
                                                        free ( bbtr );
                                                break;
                                        }

                                        // Now fill the data block with OTHER data!
                                        //
                                        for ( ecode = 0; ecode < blocksize; ecode++ )
                                                bbt->bb_Data.bd_Bytes [ ecode ] = (@{"UBYTE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 62}) (ecode & 0xff);

                                        bbt->bb_Data.bd_RDB.rdb_SummedLongs = blocksize >> 2;
                                        bbt->bb_Data.bd_RDB.rdb_ID = 0x57495045;
                                        // OK guys - this is the REAL BIG doodoo if we get it wrong!
                                        // Write exactly the same data back....
                                        ecode = @{"WriteBlock" LINK "WriteBlock"} ( bbt );
                                        if ( ecode != success )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"WriteBlock" LINK "WriteBlock"} failed, %d\\n", ecode );
                                                if ( bb )
                                                        free ( bb );
                                                if ( bbt )
                                                        free ( bbt );
                                                if ( bbtr )
                                                        free ( bbtr );
                                                break;
                                        }
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Block written = %d\\n", bbt->bb_RWErrors.block_written );

                                        // Reread it for confirmation it was written
                                        ecode = @{"RawRead" LINK "RawRead"} ( bbtr, blocksize );
                                        if ( ecode == success )
                                                printhex ( bbtr->bb_Data.bd_Bytes, 32 );
                                        else
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"RawRead" LINK "RawRead"} failed %d!", ecode );
                                                if ( bb )
                                                        free ( bb );
                                                if ( bbt )
                                                        free ( bbt );
                                                if ( bbtr )
                                                        free ( bbtr );
                                                break;
                                        }

                                        // IMMEDIATELY restore the original block!
                                        ecode = @{"RawWrite" LINK "RawWrite"} ( bb );
                                        if ( ecode != success )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"RawWrite" LINK "RawWrite"} failed, %d\\n", ecode );
                                                if ( bb )
                                                        free ( bb );
                                                if ( bbt )
                                                        free ( bbt );
                                                if ( bbtr )
                                                        free ( bbtr );
                                                break;
                                        }
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Block written = %d\\n", bb->bb_RWErrors.block_written );

                                        for ( ecode = 0; ecode < blocksize; ecode++ )
                                        {
                                                if ( bbt->bb_Data.bd_Bytes [ ecode ] != bbtr->bb_Data.bd_Bytes [ ecode ] )
                                                {
                                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Compare error at %d: %x vs %x\\n",
                                                                         ecode,
                                                                         bbt->bb_Data.bd_Bytes [ ecode ],
                                                                         bbtr->bb_Data.bd_Bytes [ ecode ] );
                                                        break;
                                                }
                                        }
                                        if ( ecode == blocksize )
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Completely successful compare here, too.\\n" );

                                        if ( bb )
                                                free ( bb );
                                        if ( bbt )
                                                free ( bbt );
                                        if ( bbtr )
                                                free ( bbtr );
                                }

                                if ( deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                                        @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                                        deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                }
                        break;

                        case 22:
        /* HDW_WriteRDBs
         *      Description:
         *              Traverse "BootBlocks" RDB structures given.
         *              Write them to disk in the order the structures exist in the structure
         *              linked list.
         *
         *      Direct Inputs:
         *              none
         *
         *      Indirect Inputs:
         *              BlockLists              List head for the RDB blocklists to be written
         *
         *      Direct Outputs:
         *              Cumulative error code
         *
         *      Indirect Outputs:
         *              RDBs written to disk as RDBs.
         *
         *      Local Calls:
         *              HDW_BlockWrite ()
         *
         *      OS Calls:
         *              None
         *
         *      Algorithm:
         *              Trace the blocklist via the .Succ nodes writing the data segment
         *              of every @{"BootBlock" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 79} encountered to disk.
         *                      If complete failure
         *                              return
         *                      if error worse than prior errors
         *                              set new return value.
         *
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
        //@{"USHORT" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 82} __saveds __asm
        //HDW_WriteRDBs ( void )
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "22) Read RDBs from <file.list> and write to disk. (The biggie!)\\n\\n" );
                                if ( !filename )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a filename\\n" );
                                        break;
                                }
                                if ( strlen( filename ) > 248 )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Filename: %s is too long!\\n", filename );
                                        break;
                                }
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }
                                @{"sprintf" LINK "gg:doc/NDK/Guide/amiga_lib/sprintf"} ( realfilename, "%s%s", filename, ".list" );
                                rsuccess = @{"ReadMountfile" LINK "ReadMountfile"} ( baseunit, realfilename, devicename );
                                if ( rsuccess != 0 )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Mountfile read failed: %d\\n", rsuccess );
                                        break;
                                }

                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s:%d\\n", devicename, baseunit );
                                deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                if ( !deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "No device was opened!\\n");
                                        break;
                                }

                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Beginning to write RDBs.\\n" );

        //                      system( "copy l:fastfilesystem43.19 sys:l/fastfilesystem");
                                rwsuccess = @{"WriteRDBs (  )" LINK "WriteRDBs"};
                                if ( rwsuccess == 0 )
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "You should have a new RDBs waiting on the disk.\\n" );
                                else
                                        if ( rwsuccess != 0xffff )
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "DOODOO CITY! RDB Write failed: %d\\n", rwsuccess );
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "RDB Write failed because this version does not have it supported.\\n" );
        //                      system( "copy l:fastfilesystem_fixed_43.19 sys:l/fastfilesystem");

                                if ( deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                                        @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                                        deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                }
                                break;

        /* HDW_WriteRDBStructs()
         *      Description:
         *              (Write RDBs to file instead of RDB area of disk.)
         *              Write the internal RDB structures to disk exactly as in memory.
         *
         *      Direct Inputs:
         *              Filename                Name of file to write. NB: This will clobber duplicates
         *
         *      Indirect Inputs:
         *              RDB structures in memory
         *
         *      Direct Outputs:
         *              ret                     error 0 if success else error indication
         *
         *      Indirect Outputs:
         *              File written
         *
         *      Local Calls:
         *
         *      OS Calls:
         *              fclose ()
         *              fopen ()
         *              fwrite ()
         *
         *      Algorithm:
         *              if no RDBs in memory of file open fails exit with error
         *              else
         *                      pointer = Basepointer->next
         *                      while pointer
         *                              translate and write block to disk file
         *                              pointer = pointer->next
         *                      endwhile
         *              endif
         *
         *      Code:
         *              Joanne Dow, Wizardess Designs, Jan 1999
         */
                        case 23:
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "23) Read RDBs from disk and write RDB Structs to file.\\n\\n" );
                                if ( !filename )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a filename\\n" );
                                        break;
                                }
                                if ( strlen( filename ) > 248 )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Filename: %s is too long!\\n", filename );
                                        break;
                                }
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }

                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s:%d\\n", devicename, baseunit );
                                deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                if ( !deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "No device was opened!\\n");
                                        break;
                                }
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to read RDBs into library.\\n");

                                rwsuccess = @{"ReadRDBs ( )" LINK "ReadRDBs"};

                                if ( rwsuccess == success )
                                {
                                        @{"sprintf" LINK "gg:doc/NDK/Guide/amiga_lib/sprintf"} ( realfilename, "%s%s", filename, ".rdb" );
                                        rwsuccess = @{"WriteRDBStructs" LINK "WriteRDBStructs"} ( realfilename );
                                        if ( rwsuccess == 0 )
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "You should have a new %s waiting.\\n", realfilename );
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Mountfile write failed: %d\\n", rwsuccess );
                                }
                                else
                                {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "RDB read failed: %d\\n", rwsuccess );
                                                break;
                                }

                                if ( deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                                        @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                                        deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                }
                                break;


                        case 24:
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "24) Read RDB Structs from file and write RDB Structs to file.\\n\\n" );
                                if ( !filename )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a filename\\n" );
                                        break;
                                }
                                if ( strlen( filename ) > 248 )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Filename: %s is too long!\\n", filename );
                                        break;
                                }
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }

                                @{"sprintf" LINK "gg:doc/NDK/Guide/amiga_lib/sprintf"} ( realfilename, "%s%s", filename, ".rdb" );
                                rsuccess = @{"ReadRDBStructs" LINK "ReadRDBStructs"} ( realfilename, baseunit );

                                if ( rsuccess == 0 )
                                {
                                        @{"sprintf" LINK "gg:doc/NDK/Guide/amiga_lib/sprintf"} ( realfilename, "%s%s", filename, "...rdb" );
                                        rwsuccess = @{"WriteRDBStructs" LINK "WriteRDBStructs"} ( realfilename );
                                        if ( rwsuccess == 0 )
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "You should have a new %s waiting.\\n", realfilename );
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "RDBfile write failed: %d\\n", rwsuccess );
                                }
                                else
                                {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "RDB read failed: %d\\n", rwsuccess );
                                                break;
                                }

                                break;

                        case 25:        // Verify Data On Drive
                                {
                                        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} ok;

                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "25) Verify data on disk.\\n\\n" );
                                        if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "You must enter a BU, Base Unit, number\\n");
                                                break;
                                        }
                                        // Open device here.
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s\\n", devicename );
                                        deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                        if ( !deviceopen )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ("%s unit %ld failed to open\\n", devicename, baseunit );
                                                break;
                                        }

                                        ok = @{"VerifyDrive" LINK "VerifyDrive"} ( CallBack );
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "ok = %d\\n", ok );

                                        if ( deviceopen )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                                                @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                                                deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                        }
                                }
                                break;

                        case 26:
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "26) Read RDBStructs from <file>...rdb and write to Disk.\\n");
                                if ( !filename )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a filename\\n" );
                                        break;
                                }
                                if ( strlen( filename ) > 248 )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Filename: %s is too long!\\n", filename );
                                        break;
                                }
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }

                                @{"sprintf" LINK "gg:doc/NDK/Guide/amiga_lib/sprintf"} ( realfilename, "%s%s", filename, ".rdb" );
                                rsuccess = @{"ReadRDBStructs" LINK "ReadRDBStructs"} ( realfilename, baseunit );

                                if ( rsuccess == 0 )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s:%d\\n", devicename, baseunit );
                                        deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                        if ( !deviceopen )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "No device was opened!\\n");
                                                break;
                                        }

                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Beginning to write RDBs.\\n" );

        //                              system( "copy l:fastfilesystem43.19 sys:l/fastfilesystem");
                                        rwsuccess = @{"WriteRDBs (  )" LINK "WriteRDBs"};
                                        if ( rwsuccess == 0 )
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "You should have a new RDBs waiting on the disk.\\n" );
                                        else
                                                if ( rwsuccess != 0xffff )
                                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "DOODOO CITY! RDB Write failed: %d\\n", rwsuccess );
                                                else
                                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "RDB Write failed because this version does not have it supported.\\n" );
        //                              system( "copy l:fastfilesystem_fixed_43.19 sys:l/fastfilesystem");

                                        if ( deviceopen )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                                                @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                                                deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                        }
                                }
                                break;

                        case 27:
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "27) Read RDBs from disk and write RDB Structs memory thence to file and console as hex.\\n\\n" );
                                if ( !filename )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a filename\\n" );
                                        break;
                                }
                                if ( strlen( filename ) > 248 )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Filename: %s is too long!\\n", filename );
                                        break;
                                }
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Need a base unit for this command.\\n" );
                                        break;
                                }

                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s:%d\\n", devicename, baseunit );
                                deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                if ( !deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "No device was opened!\\n");
                                        break;
                                }
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to read RDBs into library.\\n");

                                rwsuccess = @{"ReadRDBs ( )" LINK "ReadRDBs"};

                                if ( rwsuccess == 0 )
                                {
                                        sizememneeded = 0;
                                        rsuccess = @{"OutMemRDBStructs" LINK "OutMemRDBStructs"} ( @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, &sizememneeded, 0 );

                                        if ( rsuccess == 0 )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "7) Need %ld bytes of buffer for mountfile.\\n", sizememneeded );
                                                outmembuffer = malloc ( sizememneeded + 256 );
                                                if ( outmembuffer )
                                                {
        //                                              int i;
        //                                              for ( i = sizememneeded; i < sizememneeded + 256; i++)
        //                                                      outmembuffer[i] = 'A';
                                                        rsuccess = @{"OutMemRDBStructs" LINK "OutMemRDBStructs"} ( outmembuffer, &sizememneeded, sizememneeded + 255 );
                                                        if ( rsuccess == 0 )
                                                        {
                                                                FILE *foofile = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};

                                                                outmembuffer [ sizememneeded + 255 ] = 0;
                                                                printhex ( outmembuffer, sizememneeded );
        //                                                      printhex ( &outmembuffer[sizememneeded-16], 256 );

                                                                foofile = fopen ( filename, "wb" );
                                                                if ( foofile )
                                                                {
                                                                        fwrite ( outmembuffer, sizememneeded, 1, foofile );
                                                                        fclose ( foofile );
                                                                        foofile = @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101};
                                                                }
                                                        }
                                                        else
                                                        {
                                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Could not write the file: %d\\n", rsuccess );
                                                        }
                                                }
                                        }
                                        else
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Mountfile size write failed: %d\\n", rsuccess );
                                }
                                else
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "@{"InMemMountfile" LINK "InMemMountfile"} failed, %ld\\n", rsuccess );

                                if ( deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                                        @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                                        deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                }
                                break;

                        case 28:
        #if 0
                                if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "You must enter a BU, Base Unit, number\\n");
                                        break;
                                }
                                // Open device here.
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s\\n", devicename );
                                deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                if ( !deviceopen )
                                {
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ("%s unit %ld failed to open\\n", devicename, baseunit );
                                        break;
                                }
        #endif
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Not implemented yet!\\n" );
                                break;

                        case 100:
        //@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52} __saveds __asm @{"LowlevelFormat" LINK "LowlevelFormat"} ( register __a0 long ( * __asm CallBack)
        //                                                                        ( register __a0 @{"HDWCallbackMsg" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 305} *msg ))
                                {
                                        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} ok;

                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "100) Format Drive - VERY DANGEROUS!\\n\\n" );
                                        if ( baseunit == (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) -1L )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "You must enter a BU, Base Unit, number\\n");
                                                break;
                                        }
                                        // Open device here.
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Attempting to open: %s\\n", devicename );
                                        deviceopen = @{"HDWOpenDevice" LINK "HDWOpenDevice"} ( devicename, baseunit );
                                        if ( !deviceopen )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ("%s unit %ld failed to open\\n", devicename, baseunit );
                                                break;
                                        }

                                        ok = @{"LowlevelFormat" LINK "LowlevelFormat"} ( CallBack );
                                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "ok = %d\\n", ok );

                                        if ( deviceopen )
                                        {
                                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Closing opened device\\n" );
                                                @{"HDWCloseDevice()" LINK "HDWCloseDevice"};
                                                deviceopen = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                        }
                                }
                                break;
                        }
                }
                else
                {
                        usage ();
                }

        cleanup:

                exit ( 0 );
        }

        /*
        typedef struct
        {
                @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}  devicename;
                @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}    board;
                @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}    address;
                @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}    lun;
                @{"STRPTR" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 67}  messagestring;
                @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}    extra;
        } @{"HDWCallbackMsg" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 305};
        */
        long __stdargs __saveds __asm CallBack ( register __a0 @{"HDWCallbackMsg" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 305} *msg )
        {
                char      str[80];
                char      och = *msg->messagestring;
                char      ch = och;
                char     *string;

                if (( ch < MIN_MESSAGE )
                 || ( ch > @{"MAX_MESSAGE" LINK "gg:doc/NDK/Guide/Include/libraries/HDW_CallBackMsgs.h/File" 150} ))
                        ch = 'c';
                string = callback_messages [ ch - 'A' ];

                switch ( msg->extra )
                {
                  case @{"EXTRA_BEFORE_TEST" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 318}:       // before scan
                        @{"sprintf" LINK "gg:doc/NDK/Guide/amiga_lib/sprintf"} ( str,
                                          callback_messages[0],         // Always "Scanning: " or equivalent
                                          msg->devicename,
                                          msg->board,
                                          msg->lun,
                                          msg->address );
                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "%s[%dD", str, strlen( str ) );
                        flushall();
                        break;

                  case @{"EXTRA_AFTER_TEST" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 319}:
                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "[%d%d%d] ", msg->board, msg->lun, msg->address );
                        flushall();
                        break;

                  case @{"EXTRA_BEFORE_VERIFY" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 321}:             // Validate Drive
                        // Print messagestring plus other data.
                        // Perform an ARE YOU SURE function.
                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( callback_messages[2],
                                         msg->lun, msg->address, msg->board );
                        str[0] = 0;
                        while ( 1 )
                        {
                                fgets ( str, 79, stdin);
                                ch = tolower( str[0] );
                                if ( ch == 'y' )
                                        break;
                                if ( ch == 'n' )
                                        return @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Do you wish to continue?" );
                        }
                        break;

                  case @{"EXTRA_BEFORE_FORMAT" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 320}:             // Format Drive
                        // Print messagestring plus other data.
                        // Perform an *BIG* ARE YOU SURE function.
                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( callback_messages[1],
                                         msg->lun,
                                         msg->address,
                                         msg->board );
                        str[0] = 0;
                        while ( 1 )
                        {
                                fgets ( str, 79, stdin);
                                ch = tolower( str[0] );
                                if ( ch == 'y' )
                                        break;
                                if ( ch == 'n' )
                                        return @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Are you VERY sure you want to do this?\\n" );
                        }
                        while ( 1 )
                        {
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "Let's try again, do you really want to destroy all your data?\\n" );
                                fgets ( str, 79, stdin);
                                ch = str [ 0 ];
                                if ( ch == 'y' )
                                        break;
                                if ( ch == 'n' )
                                        return @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                        }
                        break;

                  case @{"EXTRA_UPDATE_VERIFY" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 323}:             // 4
                        chkabort();
                        if ( aborted )                  // Note we do @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} clear the aborted flag.
                                return @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "LUN %d on drive %d on board %d: ",
                                         msg->lun, msg->address, msg->board );

                        switch ( ch )
                        {
                          case 'E':
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( string, &msg->messagestring [ 2 ] );
                                break;

                          case 'O':
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( string, msg->param1, msg->param2, msg->param3 );
                                break;

                          case 'R':
                          case 'U':
                          case 'X':
                          case 'Y':
                          case 'Z':
                          case '[':
                          case '\\\\':
                          case ']':
                          case '^':
                          case '_':
                          case '`':
                          case 'b':
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( string );
                                break;

                          case 'S':
                          case 'T':
                          case 'V':
                          case 'a':
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( string, msg->param1 );
                                break;

                          case 'W':
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( string, msg->param1, msg->param2 );
                                break;

                          default:
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( string, och );
                                break;
                        }
                        flushall();
                        break;

                  case @{"EXTRA_VERIFY_REASSIGN" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 325}:
                        while ( 1 )
                        {
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( string, msg->param1 );
                                fgets ( str, 79, stdin);
                                ch = str [ 0 ];
                                if ( ch == 'y' )
                                        break;
                                if ( ch == 'n' )
                                        return @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98};
                        }
                        break;

                  case @{"EXTRA_VERIFY_FINISHED" LINK "gg:doc/NDK/Guide/Include/libraries/hdwrench.h/File" 326}:
                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "LUN %d on Drive %d on board %d:\\n",
                                         msg->lun, msg->address, msg->board );
                        switch ( ch )
                        {
                          case 'D':
                          case 'H':
                          case 'I':
                          case 'J':
                          case 'K':
                          case 'L':
                          case 'M':
                          case 'N':
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( string );
                                break;

                          case 'F':
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( string, &msg->messagestring [ 2 ] );
                                break;

                          case 'G':
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( string, msg->param1 );
                                break;

                          case 'Q':
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( string, msg->param1, msg->param2, msg->param3 );
                                break;

                          default:
                                @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( string, och );
                                break;
                        }

                        @{"printf" LINK "gg:doc/NDK/Guide/amiga_lib/printf"} ( "OK\\n" );
                        fgets ( str, 79, stdin);
                        break;

                  default:
                        break;
                }

                return @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95};
        }

@ENDNODE
