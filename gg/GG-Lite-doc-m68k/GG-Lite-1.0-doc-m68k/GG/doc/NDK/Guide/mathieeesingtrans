@DATABASE "gg:doc/NDK/Guide/mathieeesingtrans"
@MASTER   "gg:doc/NDK/AutoDocs/mathieeesingtrans.doc"
@REMARK   This file was created by ADtoHT 2.1 on 06-Jan-13 19:24:25
@REMARK   Do not edit
@REMARK   ADtoHT is © 1993-1995 Christian Stieber

@NODE MAIN "mathieeesingtrans.doc"
@TOC "gg:doc/NDK/Guide/TOC/MAIN"

                          @{b}mathieeesingtrans.library@{ub}

@{"Background" LINK "Background"}

@{"IEEESPAcos()" LINK "IEEESPAcos"}   @{"IEEESPAsin()" LINK "IEEESPAsin"}  @{"IEEESPAtan()" LINK "IEEESPAtan"}   @{"IEEESPCos()" LINK "IEEESPCos"}
@{"IEEESPCosh()" LINK "IEEESPCosh"}   @{"IEEESPExp()" LINK "IEEESPExp"}   @{"IEEESPFieee()" LINK "IEEESPFieee"}  @{"IEEESPLog()" LINK "IEEESPLog"}
@{"IEEESPLog10()" LINK "IEEESPLog10"}  @{"IEEESPPow()" LINK "IEEESPPow"}   @{"IEEESPSin()" LINK "IEEESPSin"}    @{"IEEESPSincos()" LINK "IEEESPSincos"}
@{"IEEESPSinh()" LINK "IEEESPSinh"}   @{"IEEESPSqrt()" LINK "IEEESPSqrt"}  @{"IEEESPTan()" LINK "IEEESPTan"}    @{"IEEESPTanh()" LINK "IEEESPTanh"}
@{"IEEESPTieee()" LINK "IEEESPTieee"}  

@ENDNODE
@NODE "Background" "mathieeesingtrans.library/Background (information)"


   PURPOSE

        The @{"mathieeesingtrans.library" LINK "gg:doc/NDK/Guide/mathieeesingtrans/MAIN"} provides basic transzendental functions
        for handling double precision IEEE numbers. If a FPU is found present
        in the system, this library uses the FPU for calculations. Otherwise,
        the CPU will provide a suitable emulation.

        The 68040 and 68060 built-in FPUs do not provide all instructions
        that the 68881/882 FPUs implement, and hence some of their
        instructions have to be emulated in software. This works either
        by the FPU specific trap vectors that have been installed by the
        68040 or 68060.library on boot-up, or - if available - by the
        fpsp.resource which is optionally linked into the system by the
        680?0 libraries.

        The advantage of the resource solution is that it does not require
        the overhead caused by the exception processing.
        All this - complete CPU usage, FPU usage plus optional fpsp.resource
        support - is completely transparent to the user of this library.

        As of V45 of this library, the mathieee.resources are no longer
        supported. It was felt that this solution was never very popular,
        neither very fast compared to a coprocessor interface, and highly
        obsolete.


   CAVEATS

        The library base of the @{"mathieeesingtrans.library" LINK "gg:doc/NDK/Guide/mathieeesingtrans/MAIN"} MUST @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} be shared
        among tasks. The reason for this restriction is that the library
        open vector requires to initialize the FPU properly for the caller's
        task context.
        Hence, you may not open this library in one task, pass the library
        base over and use it from another task as the FPU initialization
        would not be run for the second task. You must re-open the library
        again from the second task.

        This restriction has some implications in using the math IEEE
        libraries from within other libraries. The first implication is that
        opening the @{"mathieeesingtrans.library" LINK "gg:doc/NDK/Guide/mathieeesingtrans/MAIN"} in the LibInit() function IS @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500}
        ENOUGH to ensure proper operation as it will initialize the FPU in
        the context of the ramlib process loading the library, but not in
        the context of the caller. This is obviously of no use for the task
        that wants to use IEEE math.

        Instead, it is recommended to (re-)open the @{"mathieeesingtrans.library" LINK "gg:doc/NDK/Guide/mathieeesingtrans/MAIN"}
        once for each LibOpen() within your library, and to close it once
        for each LibClose() call.

        As a special rule that is hereby documented, the result code of
        subsequent @{"OpenLibrary()" LINK "gg:doc/NDK/Guide/exec/OpenLibrary"} calls once the library is open will be
        either @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} on error, or the same library base you received by the
        initial @{"OpenLibrary()" LINK "gg:doc/NDK/Guide/exec/OpenLibrary"}, i.e. in LibInit().

        Even though this releases you from the obligation to keep a private
        copy of the math library base once for each LibOpen(), it does not
        release you from re-opening the library again for each caller.
        It is enough to check wether the library opened successfully, and to
        throw the library base away afterwards, though. It will not deliver
        task-dependent library bases if it opens successfully.

        The second implication is that the same, or more restrictions apply
        to your library then as well, and, in fact, to its full tree of
        callers. Its library base may not be shared among tasks and must be
        re-openend for each potential caller.

        Note that you should document these requirements!

        The reason is again that the mathieee FPU init code must be run for
        each task that wants to use your, and hence this math library.
        Whether you deliver a per-task allocated library base, or one and
        the same library base is, of course, up to you.

        To overcome this limitation, your library might want to launch a
        side task that runs all the mathematical computations such that
        all callers of your library never enter a single function of the
        IEEE libs. Then, of course, the IEEE libs should not be opened
        in LibInit() or LibOpen(), but in the startup code of the side task,
        and should be closed by its shutdown code.


        Since the FPU initialization performed by the library depends on
        the selected precision, i.e. IEEE double vs. IEEE single precision,
        the third implication is that you must not mix the double and single
        precision math libraries within the same task. Either, you decide for
        double precision and stay with it, or you decide for single precision
        once and for all. You may not perform some calculations in double,
        and others in single precision as both kinds of libraries require the
        same hardware - namely the FPU - but with different settings.

        This goes of course, too, to the full caller tree of a library that
        runs IEEE functions in the context of its callers.



        Not following these rules may cause slightly wrong results in the
        sense that they might not be rounded properly to the selected
        precision. It may also cause other strange and wonderful side effects
        that are not mentioned here, and will make the library unreliable
        from a numerical point of view.



   BUGS
        Pre V45 releases could have forgotten to re-initialize the FPU
        properly if re-opened; in fact, pre-V45 might have even crashed if
        something in the startup went wrong.

@ENDNODE
@NODE "IEEESPAcos" "mathieeesingtrans.library/IEEESPAcos()"
@{b}

   NAME@{ub}
        IEEESPAcos -- compute the arc cosine of a number@{b}

   SYNOPSIS@{ub}
          x   = IEEESPAcos(  y  );
        d0                 d0

        float   x,y;@{b}

   FUNCTION@{ub}
        Compute arc cosine of y in IEEE single precision@{b}

   INPUTS@{ub}
        y - IEEE single precision floating point value@{b}

   RESULT@{ub}
        x - IEEE single precision floating point value@{b}

   BUGS@{ub}
        Might have returned bare nonsense if the argument was out of range
        for pre-V45 releases. Returns NAN for V45 in these cases.@{b}

   SEE ALSO@{ub}
        @{"IEEESPCos()" LINK "IEEESPCos"}, @{"IEEESPAtan()" LINK "IEEESPAtan"}, @{"IEEESPAsin()" LINK "IEEESPAsin"}

@ENDNODE
@NODE "IEEESPAsin" "mathieeesingtrans.library/IEEESPAsin()"
@{b}

   NAME@{ub}
        IEEESPAsin -- compute the arcsine of a number@{b}

   SYNOPSIS@{ub}
          x   = IEEESPAsin(  y  );
        d0                 d0

        float   x,y;@{b}

   FUNCTION@{ub}
        Compute the arc sine of y in IEEE single precision@{b}

   INPUTS@{ub}
        y - IEEE single precision floating point value@{b}

   RESULT@{ub}
        x - IEEE single precision floating point value@{b}

   BUGS@{ub}
        Might have returned bare nonsense if the argument was out of range
        for pre-V45 releases. Returns NAN for V45 in these cases.@{b}

   SEE ALSO@{ub}
        @{"IEEESPSin()" LINK "IEEESPSin"}, @{"IEEESPAtan()" LINK "IEEESPAtan"}, @{"IEEESPAcos()" LINK "IEEESPAcos"}

@ENDNODE
@NODE "IEEESPAtan" "mathieeesingtrans.library/IEEESPAtan()"
@{b}

   NAME@{ub}
        IEEESPAtan -- compute the arc tangent of number@{b}

   SYNOPSIS@{ub}
          x   = IEEESPAtan(  y  );
        d0                 d0

        single  x,y;@{b}

   FUNCTION@{ub}
        Compute arctangent of y in IEEE single precision@{b}

   INPUTS@{ub}
        y - IEEE single precision floating point value@{b}

   RESULT@{ub}
        x - IEEE single precision floating point value@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}

@ENDNODE
@NODE "IEEESPCos" "mathieeesingtrans.library/IEEESPCos()"
@{b}

   NAME@{ub}
        IEEESPCos -- compute the cosine of a floating point number@{b}

   SYNOPSIS@{ub}
          x   = IEEESPCos(  y  );
        d0                 d0

        float   x,y;@{b}

   FUNCTION@{ub}
        Compute cosine of y in IEEE single precision@{b}

   INPUTS@{ub}
        y - IEEE single precision floating point value@{b}

   RESULT@{ub}
        x - IEEE single precision floating point value@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"IEEESPAcos()" LINK "IEEESPAcos"}, @{"IEEESPSin()" LINK "IEEESPSin"}, @{"IEEESPTan()" LINK "IEEESPTan"}

@ENDNODE
@NODE "IEEESPCosh" "mathieeesingtrans.library/IEEESPCosh()"
@{b}

   NAME@{ub}
        IEEESPCosh -- compute the hyperbolic cosine of a floating point number@{b}

   SYNOPSIS@{ub}
          x   = IEEESPCosh(  y  );
        d0                 d0

        float   x,y;@{b}

   FUNCTION@{ub}
        Compute hyperbolic cosine of y in IEEE single precision@{b}

   INPUTS@{ub}
        y - IEEE single precision floating point value@{b}

   RESULT@{ub}
        x - IEEE single precision floating point value@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"IEEESPSinh()" LINK "IEEESPSinh"}, @{"IEEESPTanh()" LINK "IEEESPTanh"}

@ENDNODE
@NODE "IEEESPExp" "mathieeesingtrans.library/IEEESPExp()"
@{b}

   NAME@{ub}
        IEEESPExp -- compute the exponential of e@{b}

   SYNOPSIS@{ub}
          x   = IEEESPExp(  y  );
        d0                d0

        float   x,y;@{b}

   FUNCTION@{ub}
        Compute e^y in IEEE single precision@{b}

   INPUTS@{ub}
        y - IEEE single precision floating point value@{b}

   RESULT@{ub}
        x - IEEE single precision floating point value@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"IEEESPLog()" LINK "IEEESPLog"}

@ENDNODE
@NODE "IEEESPFieee" "mathieeesingtrans.library/IEEESPFieee()"
@{b}

   NAME@{ub}
        IEEESPFieee -- convert IEEE single to IEEE single@{b}

   SYNOPSIS@{ub}
          x   = IEEESPFieee(  y  );
        d0                    d0

        float   y;
        float  x;@{b}

   FUNCTION@{ub}
        Convert IEEE single precision number to IEEE single precision.
        These are included for completeness although they just
        return the input parameter. A good way to remember how these
        functions work is: They convert to and from the local format
        to Single Precision IEEE. The local format for this library
        happens to also be Single Precision IEEE.@{b}

   INPUTS@{ub}
        y - IEEE single precision floating point value@{b}

   RESULT@{ub}
        x - IEEE single precision floating point value@{b}

   BUGS@{ub}
        Note that the conversion functions are of limited usefulness
        as IEEE double and single math must not be mixed.@{b}

   SEE ALSO@{ub}
        @{"IEEESPTieee()" LINK "IEEESPTieee"}

@ENDNODE
@NODE "IEEESPLog" "mathieeesingtrans.library/IEEESPLog()"
@{b}

   NAME@{ub}
        IEEESPLog -- compute the natural logarithm of a floating point number@{b}

   SYNOPSIS@{ub}
          x   = IEEESPLog(  y  );
        d0                d0

        float   x,y;@{b}

   FUNCTION@{ub}
        Compute ln(y) in IEEE single precision@{b}

   INPUTS@{ub}
        y - IEEE single precision floating point value@{b}

   RESULT@{ub}
        x - IEEE single precision floating point value@{b}

   BUGS@{ub}
        Might have returned bare nonsense if the argument was out of range
        for pre-V45 releases. Returns NAN for negative arguments or -INF for
        an argument of zero.@{b}

   SEE ALSO@{ub}
        @{"IEEESPExp()" LINK "IEEESPExp"}

@ENDNODE
@NODE "IEEESPLog10" "mathieeesingtrans.library/IEEESPLog10()"
@{b}

   NAME@{ub}
        IEEESPLog10 -- compute logarithm base 10 of a number@{b}

   SYNOPSIS@{ub}
          x   = IEEESPLog10(  y  );
        d0                  d0

        float   x,y;@{b}

   FUNCTION@{ub}
        Compute the logarithm base 10 of y in IEEE single precision@{b}

   INPUTS@{ub}
        y - IEEE single precision floating point value@{b}

   RESULT@{ub}
        x - IEEE single precision floating point value@{b}

   BUGS@{ub}
        Might have returned bare nonsense if the argument was out of range
        for pre-V45 releases. Returns NAN for negative arguments or -INF for
        an argument of zero.@{b}

   SEE ALSO@{ub}
        @{"IEEESPLog()" LINK "IEEESPLog"}

@ENDNODE
@NODE "IEEESPPow" "mathieeesingtrans.library/IEEESPPow()"
@{b}

   NAME@{ub}
        IEEESPPow -- raise a number to another number power@{b}

   SYNOPSIS@{ub}
          z   = IEEESPPow(  x  ,  y  );
        d0                d1 d0

        float   x,y,z;@{b}

   FUNCTION@{ub}
        Compute y^x in IEEE single precision@{b}

   INPUTS@{ub}
        x - IEEE single precision floating point value
        y - IEEE single precision floating point value@{b}

   RESULT@{ub}
        z - IEEE single precision floating point value@{b}

   BUGS@{ub}
        Might have returned bare nonsense if the argument was out of range
        for pre-V45 releases, and was not very precise or smart breaking
        large arguments down into a suitable range. The computational
        precision of this function left a lot to be deserved. All this
        was fixed in V45.@{b}

   SEE ALSO@{ub}

@ENDNODE
@NODE "IEEESPSin" "mathieeesingtrans.library/IEEESPSin()"
@{b}

   NAME@{ub}
        IEEESPSin -- compute the sine of a floating point number@{b}

   SYNOPSIS@{ub}
          x   = IEEESPSin(  y  );
        d0                d0

        float   x,y;@{b}

   FUNCTION@{ub}
        Compute sine of y in IEEE single precision@{b}

   INPUTS@{ub}
        y - IEEE single precision floating point value@{b}

   RESULT@{ub}
        x - IEEE single precision floating point value@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"IEEESPAsin()" LINK "IEEESPAsin"}, @{"IEEESPTan()" LINK "IEEESPTan"}, @{"IEEESPCos()" LINK "IEEESPCos"}

@ENDNODE
@NODE "IEEESPSincos" "mathieeesingtrans.library/IEEESPSincos()"
@{b}

   NAME@{ub}
        IEEESPSincos -- compute the arc tangent of a floating point number@{b}

   SYNOPSIS@{ub}
          x   = IEEESPSincos( z ,  y  );
        d0                   a0  d0

        float   x,y,*z;@{b}

   FUNCTION@{ub}
        Compute sin and cosine of y in IEEE single precision.
        Store the cosine in *z. Return the sine of y.@{b}

   INPUTS@{ub}
        y - IEEE single precision floating point value
        z - pointer to IEEE single precision floating point number@{b}

   RESULT@{ub}
        x - IEEE single precision floating point value@{b}

   BUGS@{ub}
        Not very fast if no FPU is available. Otherwise, it might be
        faster than calling @{"IEEEDPSin()" LINK "gg:doc/NDK/Guide/mathieeedoubtrans/IEEEDPSin"} and @{"IEEEDPCos()" LINK "gg:doc/NDK/Guide/mathieeedoubtrans/IEEEDPCos"} separately.@{b}

   SEE ALSO@{ub}
        @{"IEEESPSin()" LINK "IEEESPSin"}, @{"IEEESPCos()" LINK "IEEESPCos"}

@ENDNODE
@NODE "IEEESPSinh" "mathieeesingtrans.library/IEEESPSinh()"
@{b}

   NAME@{ub}
        IEEESPSinh -- compute the hyperbolic sine of a floating point number@{b}

   SYNOPSIS@{ub}
          x   = IEEESPSinh(  y  );
        d0                 d0

        float   x,y;@{b}

   FUNCTION@{ub}
        Compute hyperbolic sine of y in IEEE single precision@{b}

   INPUTS@{ub}
        y - IEEE single precision floating point value@{b}

   RESULT@{ub}
        x - IEEE single precision floating point value@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"IEEESPCosh()" LINK "IEEESPCosh"}, @{"IEEESPTanh()" LINK "IEEESPTanh"}

@ENDNODE
@NODE "IEEESPSqrt" "mathieeesingtrans.library/IEEESPSqrt()"
@{b}

   NAME@{ub}
        IEEESPSqrt -- compute the square root of a number@{b}

   SYNOPSIS@{ub}
          x   = IEEESPSqrt(  y  );
         d0                  d0

        float   x,y;@{b}

   FUNCTION@{ub}
        Compute square root of y in IEEE single precision@{b}

   INPUTS@{ub}
        y - IEEE single precision floating point value@{b}

   RESULT@{ub}
        x - IEEE single precision floating point value@{b}

   BUGS@{ub}
        Might have returned bare nonsense if the argument was out of range
        for pre-V45 releases. Returns NAN for V45 in these cases.@{b}

   SEE ALSO@{ub}

@ENDNODE
@NODE "IEEESPTan" "mathieeesingtrans.library/IEEESPTan()"
@{b}

   NAME@{ub}
        IEEESPTan -- compute the tangent of a floating point number@{b}

   SYNOPSIS@{ub}
          x   = IEEESPTan(  y  );
        d0                d0

        float   x,y;@{b}

   FUNCTION@{ub}
        Compute tangent of y in IEEE single precision@{b}

   INPUTS@{ub}
        y - IEEE single precision floating point value@{b}

   RESULT@{ub}
        x - IEEE single precision floating point value@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"IEEESPAtan()" LINK "IEEESPAtan"}, @{"IEEESPSin()" LINK "IEEESPSin"}, @{"IEEESPCos()" LINK "IEEESPCos"}

@ENDNODE
@NODE "IEEESPTanh" "mathieeesingtrans.library/IEEESPTanh()"
@{b}

   NAME@{ub}
        IEEESPTanh -- compute the hyperbolic tangent of a floating point number@{b}

   SYNOPSIS@{ub}
          x   = IEEESPTanh(  y  );
        d0                 d0

        float   x,y;@{b}

   FUNCTION@{ub}
        Compute hyperbolic tangent of y in IEEE single precision@{b}

   INPUTS@{ub}
        y - IEEE single precision floating point value@{b}

   RESULT@{ub}
        x - IEEE single precision floating point value@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"IEEESPSinh()" LINK "IEEESPSinh"}, @{"IEEESPCosh()" LINK "IEEESPCosh"}

@ENDNODE
@NODE "IEEESPTieee" "mathieeesingtrans.library/IEEESPTieee()"
@{b}

   NAME@{ub}
        IEEESPTieee -- convert IEEE single to IEEE single@{b}

   SYNOPSIS@{ub}
          x   = IEEESPTieee(  y  );
         d0                 d0

        float   y;
        float   x;@{b}

   FUNCTION@{ub}
        Convert IEEE single precision number to IEEE single precision.
        These are included for completeness although they just
        return the input parameter. A good way to remember how these
        functions work is: They convert to and from the local format
        to Single Precision IEEE. The local format for this library
        happens to also be Single Precision IEEE.@{b}

   INPUTS@{ub}
        y - IEEE single precision floating point value@{b}

   RESULT@{ub}
        x - IEEE single precision floating point value@{b}

   BUGS@{ub}@{b}

   SEE ALSO@{ub}
        @{"IEEESPFieee()" LINK "IEEESPFieee"}

@ENDNODE
