@DATABASE "gg:doc/NDK/Guide/layers"
@MASTER   "gg:doc/NDK/AutoDocs/layers.doc"
@REMARK   This file was created by ADtoHT 2.1 on 06-Jan-13 19:23:49
@REMARK   Do not edit
@REMARK   ADtoHT is © 1993-1995 Christian Stieber

@NODE MAIN "layers.doc"
@TOC "gg:doc/NDK/Guide/TOC/MAIN"

                               @{b}layers.library@{ub}

@{"BeginUpdate()" LINK "BeginUpdate"}               @{"BehindLayer()" LINK "BehindLayer"}
@{"CreateBehindHookLayer()" LINK "CreateBehindHookLayer"}     @{"CreateBehindLayer()" LINK "CreateBehindLayer"}
@{"CreateUpfrontHookLayer()" LINK "CreateUpfrontHookLayer"}    @{"CreateUpfrontLayer()" LINK "CreateUpfrontLayer"}
@{"DeleteLayer()" LINK "DeleteLayer"}               @{"DisposeLayerInfo()" LINK "DisposeLayerInfo"}
@{"DoHookClipRects()" LINK "DoHookClipRects"}           @{"EndUpdate()" LINK "EndUpdate"}
@{"FattenLayerInfo()" LINK "FattenLayerInfo"}           @{"InitLayers()" LINK "InitLayers"}
@{"InstallClipRegion()" LINK "InstallClipRegion"}         @{"InstallLayerHook()" LINK "InstallLayerHook"}
@{"InstallLayerInfoHook()" LINK "InstallLayerInfoHook"}      @{"LockLayer()" LINK "LockLayer"}
@{"LockLayerInfo()" LINK "LockLayerInfo"}             @{"LockLayers()" LINK "LockLayers"}
@{"MoveLayer()" LINK "MoveLayer"}                 @{"MoveLayerInFrontOf()" LINK "MoveLayerInFrontOf"}
@{"MoveSizeLayer()" LINK "MoveSizeLayer"}             @{"NewLayerInfo()" LINK "NewLayerInfo"}
@{"ScrollLayer()" LINK "ScrollLayer"}               @{"SizeLayer()" LINK "SizeLayer"}
@{"SwapBitsRastPortClipRect()" LINK "SwapBitsRastPortClipRect"}  @{"ThinLayerInfo()" LINK "ThinLayerInfo"}
@{"UnlockLayer()" LINK "UnlockLayer"}               @{"UnlockLayerInfo()" LINK "UnlockLayerInfo"}
@{"UnlockLayers()" LINK "UnlockLayers"}              @{"UpfrontLayer()" LINK "UpfrontLayer"}
@{"WhichLayer()" LINK "WhichLayer"}                

@ENDNODE
@NODE "BeginUpdate" "layers.library/BeginUpdate()"
@{b}

    NAME@{ub}
        @{"BeginUpdate" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 64} -- Prepare to repair damaged layer.@{b}

    SYNOPSIS@{ub}
        result = @{"BeginUpdate" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 64}( l )
        d0                    a0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"BeginUpdate" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 64}( @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *);@{b}

    FUNCTION@{ub}
        Convert damage list to ClipRect list and swap in for
        programmer to redraw through. This routine simulates
        the ROM library environment. The idea is to only render in the
        "damaged" areas, saving time over redrawing all of the layer.
        The layer is locked against changes made by the layer library.@{b}

    INPUTS@{ub}
        l - pointer to a layer@{b}

    RESULTS@{ub}
        result - @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if damage list converted to ClipRect list successfully.
                 @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if list conversion aborted. (probably out of memory)@{b}

    BUGS@{ub}
        If @{"BeginUpdate" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 64} returns @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}, programmer must abort the attempt to
        refresh this layer and instead call @{"EndUpdate" LINK "EndUpdate"}( l, @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} ) to restore
        original ClipRect and damage list.@{b}

    SEE ALSO@{ub}
        @{"EndUpdate()" LINK "EndUpdate"}, @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}, @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"}

@ENDNODE
@NODE "BehindLayer" "layers.library/BehindLayer()"
@{b}

    NAME@{ub}
        @{"BehindLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 48} -- Put layer behind other layers.@{b}

    SYNOPSIS@{ub}
        result = @{"BehindLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 48}( dummy, l )
        d0                    a0     a1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"BehindLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 48}( @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *);@{b}

    FUNCTION@{ub}
        Move this layer to the most behind position swapping bits
        in and out of the display with other layers.
        If other layers are REFRESH then collect their damage lists and
        set the @{"LAYERREFRESH" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 24} bit in the Flags fields of those layers that
        may be revealed.  If this layer is a backdrop layer then
        put this layer behind all other backdrop layers.
        If this layer is @{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500} a backdrop layer then put in front of the
        top backdrop layer and behind all other layers.

        Note: this operation may generate refresh events in other layers
           associated with this layer's Layer_Info structure.@{b}

    INPUTS@{ub}
        dummy - unused
        l - pointer to a layer@{b}

    RESULTS@{ub}
        result - @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95}    if operation successful
                 @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}   if operation unsuccessful (probably out of memory)@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
       @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}, @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"}

@ENDNODE
@NODE "CreateBehindHookLayer" "layers.library/CreateBehindHookLayer()"


        NAME                                                              (V36)
            @{"CreateBehindHookLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 140} -- Create a new layer behind all existing layers,
                                     using supplied callback BackFill hook.@{b}

    SYNOPSIS@{ub}
        result = @{"CreateBehindHookLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 140}(li,bm,x0,y0,x1,y1,flags,hook,[,bm2])
        d0                             a0 a1 d0 d1 d2 d3 d4    a3   [ a2 ]

        @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *@{"CreateBehindHookLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 140}(@{"struct Layer_Info" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 31} *, @{"struct BitMap" LINK "gg:doc/NDK/Guide/Include/graphics/gfx.h/File" 46} *,
            @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *, ... );@{b}

    FUNCTION@{ub}
        Create a new Layer of position and size (x0,y0)->(x1,y1)
        Make this layer of type found in flags.
        Install Layer->BackFill callback Hook.
        If SuperBitMap, use bm2 as pointer to real SuperBitMap,
        and copy contents of Superbitmap into display layer.
        If this layer is a backdrop layer then place it behind all
        other layers including other backdrop layers. If this is
        not a backdrop layer then place it behind all nonbackdrop
        layers.

        Note: when using SUPERBITMAP, you should also set @{"LAYERSMART" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 20} flag.@{b}

    INPUTS@{ub}
        li - pointer to LayerInfo structure
        bm - pointer to common BitMap used by all Layers
        x0,y0 - upper left hand corner of layer
        x1,y1 - lower right hand corner of layer
        flags - various types of layers supported as bit sets.
                (for bit definitions, see @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"} )
        hook -  Layer->BackFill callback Hook (see @{"InstallLayerHook()" LINK "InstallLayerHook"})

                If hook is @{"LAYERS_BACKFILL" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 58}, the default backfill is
                used for the layer.  (Same as pre-2.0)

                As of V39:
                If hook is @{"LAYERS_NOBACKFILL" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 57}, the layer will not be
                backfilled (NO-OP).

        bm2 - pointer to optional Super BitMap@{b}

    RESULTS@{ub}
        result - pointer to Layer structure if successful
                 @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if not successful@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"InstallLayerHook()" LINK "InstallLayerHook"}, @{"DeleteLayer()" LINK "DeleteLayer"}, @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}, @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"},
        @{"graphics/gfx.h" LINK "gg:doc/NDK/Guide/Include/graphics/gfx.h/File"}, @{"utility/hooks.h" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File"}

@ENDNODE
@NODE "CreateBehindLayer" "layers.library/CreateBehindLayer()"
@{b}

    NAME@{ub}
        @{"CreateBehindLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 40} -- Create a new layer behind all existing layers.@{b}

    SYNOPSIS@{ub}
        result = @{"CreateBehindLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 40}(li,bm,x0,y0,x1,y1,flags [,bm2])
        d0                         a0 a1 d0 d1 d2 d3   d4  [ a2 ]

        @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *@{"CreateBehindLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 40}(@{"struct Layer_Info" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 31} *, @{"struct BitMap" LINK "gg:doc/NDK/Guide/Include/graphics/gfx.h/File" 46} *,
            @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, ... );@{b}

    FUNCTION@{ub}
        Create a new Layer of position and size (x0,y0)->(x1,y1)
        Make this layer of type found in flags.
        If SuperBitMap, use bm2 as pointer to real SuperBitMap,
        and copy contents of Superbitmap into display layer.
        If this layer is a backdrop layer then place it behind all
        other layers including other backdrop layers. If this is
        not a backdrop layer then place it behind all nonbackdrop
        layers.

        Note: when using SUPERBITMAP, you should also set @{"LAYERSMART" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 20} flag.@{b}

    INPUTS@{ub}
        li - pointer to LayerInfo structure
        bm - pointer to common BitMap used by all Layers
        x0,y0 - upper left hand corner of layer
        x1,y1 - lower right hand corner of layer
        flags - various types of layers supported as bit sets.
                (for bit definitions, see @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"} )
        bm2 - pointer to optional Super BitMap@{b}

    RESULTS@{ub}
        result - pointer to Layer structure if successful
                 @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if not successful@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"DeleteLayer()" LINK "DeleteLayer"}, @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}, @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"}, @{"graphics/gfx.h" LINK "gg:doc/NDK/Guide/Include/graphics/gfx.h/File"}

@ENDNODE
@NODE "CreateUpfrontHookLayer" "layers.library/CreateUpfrontHookLayer()"


        NAME                                                              (V36)
            @{"CreateUpfrontHookLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 136} -- Create a new layer on top of existing layers,
                                      using supplied callback BackFill hook.@{b}

    SYNOPSIS@{ub}
        result = @{"CreateUpfrontHookLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 136}(li,bm,x0,y0,x1,y1,flags,hook,[,bm2])
        d0                              a0 a1 d0 d1 d2 d3   d4  a3   [ a2 ]

        @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *@{"CreateUpfrontHookLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 136}(@{"struct Layer_Info" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 31} *, @{"struct BitMap" LINK "gg:doc/NDK/Guide/Include/graphics/gfx.h/File" 46} *,
            @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *, ... );@{b}

    FUNCTION@{ub}
        Create a new Layer of position and size (x0,y0)->(x1,y1)
        and place it on top of all other layers.
        Make this layer of type found in flags
        Install Layer->BackFill callback hook.
        if SuperBitMap, use bm2 as pointer to real SuperBitMap.
        and copy contents of Superbitmap into display layer.

        Note: when using SUPERBITMAP, you should also set @{"LAYERSMART" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 20} flag.@{b}

    INPUTS@{ub}
        li - pointer to LayerInfo structure
        bm - pointer to common BitMap used by all Layers
        x0,y0 - upper left hand corner of layer
        x1,y1 - lower right hand corner of layer
        flags - various types of layers supported as bit sets.
        hook -  Layer->BackFill callback Hook (see @{"InstallLayerHook()" LINK "InstallLayerHook"})

                If hook is @{"LAYERS_BACKFILL" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 58}, the default backfill is
                used for the layer.  (Same as pre-2.0)

                As of V39:
                If hook is @{"LAYERS_NOBACKFILL" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 57}, the layer will not be
                backfilled (NO-OP).

        bm2 - pointer to optional Super BitMap@{b}

    RESULTS@{ub}
        result - pointer to Layer structure if successful
                 @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if not successful@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"InstallLayerHook()" LINK "InstallLayerHook"}, @{"DeleteLayer()" LINK "DeleteLayer"}, @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}, @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"},
        @{"graphics/gfx.h" LINK "gg:doc/NDK/Guide/Include/graphics/gfx.h/File"}, @{"utility/hooks.h" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File"}

@ENDNODE
@NODE "CreateUpfrontLayer" "layers.library/CreateUpfrontLayer()"
@{b}

    NAME@{ub}
        @{"CreateUpfrontLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 36} -- Create a new layer on top of existing layers.@{b}

    SYNOPSIS@{ub}
        result = @{"CreateUpfrontLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 36}(li,bm,x0,y0,x1,y1,flags [,bm2])
        d0                          a0 a1 d0 d1 d2 d3   d4  [ a2 ]

        @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *@{"CreateUpfrontLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 36}(@{"struct Layer_Info" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 31} *, @{"struct BitMap" LINK "gg:doc/NDK/Guide/Include/graphics/gfx.h/File" 46} *,
            @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, ... );@{b}

    FUNCTION@{ub}
        Create a new Layer of position and size (x0,y0)->(x1,y1)
        and place it on top of all other layers.
        Make this layer of type found in flags
        if SuperBitMap, use bm2 as pointer to real SuperBitMap.
        and copy contents of Superbitmap into display layer.

        Note: when using SUPERBITMAP, you should also set @{"LAYERSMART" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 20} flag.@{b}

    INPUTS@{ub}
        li - pointer to LayerInfo structure
        bm - pointer to common BitMap used by all Layers
        x0,y0 - upper left hand corner of layer
        x1,y1 - lower right hand corner of layer
        flags - various types of layers supported as bit sets.
        bm2 - pointer to optional Super BitMap@{b}

    RESULTS@{ub}
        result - pointer to Layer structure if successful
                 @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if not successful@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
       @{"DeleteLayer()" LINK "DeleteLayer"}, @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}, @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"}, @{"graphics/gfx.h" LINK "gg:doc/NDK/Guide/Include/graphics/gfx.h/File"}

@ENDNODE
@NODE "DeleteLayer" "layers.library/DeleteLayer()"
@{b}

    NAME@{ub}
        @{"DeleteLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 72} -- delete layer from layer list.@{b}

    SYNOPSIS@{ub}
        result = @{"DeleteLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 72}( dummy, l )
        d0                    a0,    a1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"DeleteLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 72}( @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *);@{b}

    FUNCTION@{ub}
        Remove this layer from the list of layers.  Release memory
        associated with it.  Restore other layers that may have been
        obscured by it.  Trigger refresh in those that may need it.
        If this is a superbitmap layer make sure SuperBitMap is current.
        The SuperBitMap is not removed from the system but is available
        for program use even though the rest of the layer information has
        been deallocated.@{b}

    INPUTS@{ub}
        dummy - unused
        l - pointer to a layer@{b}

    RESULTS@{ub}
        result - @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if this layer successfully deleted from the system
                 @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if layer not deleted. (probably out of memory )@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}, @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"}

@ENDNODE
@NODE "DisposeLayerInfo" "layers.library/DisposeLayerInfo()"
@{b}

    NAME@{ub}
        @{"DisposeLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 112} -- Return all memory for LayerInfo to memory pool@{b}

    SYNOPSIS@{ub}
        @{"DisposeLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 112}( li )
                          a0

        void @{"DisposeLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 112}( @{"struct Layer_Info" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 31} *);@{b}

    FUNCTION@{ub}
        return LayerInfo and any other memory attached to this LayerInfo
        to memory allocator.

        Note: if you wish to delete the layers associated with this Layer_Info
            structure, remember to call @{"DeleteLayer()" LINK "DeleteLayer"} for each of the layers
            before calling @{"DisposeLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 112}().@{b}

    INPUTS@{ub}
        li - pointer to LayerInfo structure@{b}

    EXAMPLE@{ub}

        -- delete the layers associated this Layer_Info structure --

        @{"DeleteLayer" LINK "DeleteLayer"}(li,simple_layer);
        @{"DeleteLayer" LINK "DeleteLayer"}(li,smart_layer);

        -- see documentation on @{"DeleteLayer" LINK "DeleteLayer"} about deleting SuperBitMap layers --
        my_super_bitmap_ptr = super_layer->SuperBitMap;
        @{"DeleteLayer" LINK "DeleteLayer"}(li,super_layer);

        -- now dispose of the Layer_Info structure itself --
        @{"DisposeLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 112}(li);@{b}


    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"DeleteLayer()" LINK "DeleteLayer"}, @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}

@ENDNODE
@NODE "DoHookClipRects" "layers.library/DoHookClipRects()"
@{b}

    NAME@{ub}
        @{"DoHookClipRects" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 156} - Do the given hook for each of the ClipRects    (V39)@{b}

    SYNOPSIS@{ub}
        @{"DoHookClipRects" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 156}(hook,rport,rect)
                        a0   a1    a2

        void @{"DoHookClipRects" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 156}(@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *,@{"struct RastPort" LINK "gg:doc/NDK/Guide/Include/graphics/rastport.h/File" 52} *,@{"struct Rectangle" LINK "gg:doc/NDK/Guide/Include/graphics/gfx.h/File" 27} *);@{b}

    FUNCTION@{ub}
        This function will call the given hook for each cliprect in the
        layer that can be rendered into.  This is how the backfill hook
        in Layers is implemented.  This means that hidden simple-refresh
        cliprects will be ignored.  It will call the SuperBitMap cliprects,
        smart refresh off-screen cliprects, and all on screen cliprects.
        If the rect parameter is not @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, the cliprects are bounded to
        the rectangle given.@{b}

    INPUTS@{ub}
        hook - pointer to layer callback Hook which will be called
               with object == (@{"struct RastPort" LINK "gg:doc/NDK/Guide/Include/graphics/rastport.h/File" 52} *) result->RastPort
               and message == [ (Layer *) layer, (@{"struct Rectangle" LINK "gg:doc/NDK/Guide/Include/graphics/gfx.h/File" 27}) bounds,
                                (@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}) offsetx, (@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}) offsety ]

               This hook should fill the Rectangle in the RastPort
               with the BackFill pattern appropriate for offset x/y.

               If hook is @{"LAYERS_BACKFILL" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 58}, the default backfill is
               used for the layer.

               If hook is @{"LAYERS_NOBACKFILL" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 57}, the layer will not be
               backfilled (NO-OP).

        rport- A pointer to the RastPort that is to be operated on.
               This function will lock the layer if the RastPort is
               layered...
               If the rport is non-layered your hook will be called with
               the rectangle as passed, the RastPort, and a @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} layer...

        rect - The bounding rectangle that should be used on the layer.
               This rectangle "clips" the cliprects to the bound given.
               If this is @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}, no bounding will take place.
               *MUST* not be @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if the RastPort is non-layered!@{b}

    NOTES@{ub}
        The RastPort you are passed back is the same one passed to the
        function.  You should *not* use "layered" rendering functions
        on this RastPort.  Generally, you will wish to do BitMap operations
        such as @{"BltBitMap()" LINK "gg:doc/NDK/Guide/graphics/BltBitMap"}.  The callback is a raw, low-level rendering
        call-back.  If you need to call a rendering operation with a
        RastPort, make sure you use a copy of the RastPort and @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} the
        Layer pointer.@{b}

    SEE ALSO@{ub}
        @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"} @{"utility/hooks.h" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File"}

@ENDNODE
@NODE "EndUpdate" "layers.library/EndUpdate()"
@{b}

    NAME@{ub}
        @{"EndUpdate" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 68} -- remove damage list and restore state of layer to normal.@{b}

    SYNOPSIS@{ub}
        @{"EndUpdate" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 68}( l, flag )
                   a0  d0

        void @{"EndUpdate" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 68}( @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *, @{"UWORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 55});@{b}

    FUNCTION@{ub}
        After the programmer has redrawn his picture he calls this
        routine to restore the ClipRects to point to his standard
        layer tiling. The layer is then unlocked for access by the
        layer library.

        Note: use flag = @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if you are only making a partial update.
            You may use the other region functions (graphics functions such as
            @{"OrRectRegion" LINK "gg:doc/NDK/Guide/graphics/OrRectRegion"}, @{"AndRectRegion" LINK "gg:doc/NDK/Guide/graphics/AndRectRegion"}, and @{"XorRectRegion" LINK "gg:doc/NDK/Guide/graphics/XorRectRegion"} ) to clip adjust
            the DamageList to reflect a partial update.@{b}

    INPUTS@{ub}
        l - pointer to a layer
        flag - use @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if update was completed. The damage list is cleared.
               use @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if update not complete. The damage list is retained.@{b}

    EXAMPLE@{ub}

        -- begin update for first part of two-part refresh --
        @{"BeginUpdate" LINK "BeginUpdate"}(my_layer);

        -- do some refresh, but not all --
        my_partial_refresh_routine(my_layer);

        -- end update, false (not completely done refreshing yet) --
        @{"EndUpdate" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 68}(my_layer, @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98});

        -- begin update for last part of refresh --
        @{"BeginUpdate" LINK "BeginUpdate"}(my_layer);

        -- do rest of refresh --
        my_complete_refresh_routine(my_layer);

        -- end update, true (completely done refreshing now) --
        @{"EndUpdate" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 68}(my_layer, @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95});@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"BeginUpdate()" LINK "BeginUpdate"}, @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}, @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"}

@ENDNODE
@NODE "FattenLayerInfo" "layers.library/FattenLayerInfo()"
@{b}

    NAME@{ub}
        @{"FattenLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 116} -- convert 1.0 LayerInfo to 1.1 LayerInfo
        OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE@{b}

    SYNOPSIS@{ub}
        OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE
        @{"FattenLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 116}( li )
                         a0

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"FattenLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 116}( @{"struct Layer_Info" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 31} *);
        OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE@{b}

    FUNCTION@{ub}
        V1.1 software and any later releases need to have more info in the
        Layer_Info structure. To do this in a 1.0 supportable manner requires
        allocation and deallocation of the memory whenever most
        layer library functions are called.  To prevent unnecessary
        allocation/deallocation @{"FattenLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 116} will preallocate the
        necessary data structures and fake out the layer library into
        thinking it has a LayerInfo gotten from @{"NewLayerInfo" LINK "NewLayerInfo"}.
        @{"NewLayerInfo" LINK "NewLayerInfo"} is the approved method for getting this structure.
        When a program needs to give up the LayerInfo structure it
        must call @{"ThinLayerInfo" LINK "ThinLayerInfo"} before freeing the memory. @{"ThinLayerInfo" LINK "ThinLayerInfo"}
        is not necessary if New/@{"DisposeLayerInfo" LINK "DisposeLayerInfo"} are used however.@{b}

    INPUTS@{ub}
        li - pointer to LayerInfo structure@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}

        @{"NewLayerInfo()" LINK "NewLayerInfo"}, @{"ThinLayerInfo()" LINK "ThinLayerInfo"}, @{"DisposeLayerInfo()" LINK "DisposeLayerInfo"}, @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}

@ENDNODE
@NODE "InitLayers" "layers.library/InitLayers()"
@{b}

    NAME@{ub}
        @{"InitLayers" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 32} -- Initialize Layer_Info structure
        OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE@{b}

    SYNOPSIS@{ub}
        OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE
        @{"InitLayers" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 32}( li )
                    a0

        void @{"InitLayers" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 32}( @{"struct Layer_Info" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 31} *);
        OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE@{b}

    FUNCTION@{ub}
        Initialize Layer_Info structure in preparation to use
        other layer operations on this list of layers.
        Make the Layers unlocked (open), available to layer operations.@{b}

    INPUTS@{ub}
        li - pointer to LayerInfo structure@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"NewLayerInfo()" LINK "NewLayerInfo"}, @{"DisposeLayerInfo()" LINK "DisposeLayerInfo"}, @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}

@ENDNODE
@NODE "InstallClipRegion" "layers.library/InstallClipRegion()"
@{b}

    NAME@{ub}
        @{"InstallClipRegion" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 128} -- Install clip region in layer@{b}

    SYNOPSIS@{ub}
        oldclipregion = @{"InstallClipRegion" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 128}( l,  region )
        d0                                 a0  a1

        @{"struct Region" LINK "gg:doc/NDK/Guide/Include/graphics/regions.h/File" 25} *@{"InstallClipRegion" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 128}( @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *, @{"struct Region" LINK "gg:doc/NDK/Guide/Include/graphics/regions.h/File" 25} *);@{b}

    FUNCTION@{ub}
        Installs a transparent Clip region in the layer. All
        subsequent graphics calls will be clipped to this region.
        You MUST remember to call @{"InstallClipRegion" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 128}(l,@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101}) before
        calling @{"DeleteLayer" LINK "DeleteLayer"}(l) or the Intuition function @{"CloseWindow()" LINK "gg:doc/NDK/Guide/intuition/CloseWindow"}
        if you have installed a non-@{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} ClipRegion in l.@{b}

    INPUTS@{ub}
        l - pointer to a layer
        region - pointer to a region@{b}

    RESULTS@{ub}
        oldclipregion - The pointer to the previous ClipRegion that
            was installed. Returns @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if no previous ClipRegion installed.

            Note: If the system runs out of memory while computing the
                resulting ClipRects the LAYERS_CLIPRECTS_LOST bit will
                be set in l->Flags.@{b}

    BUGS@{ub}
        If the system runs out of memory during normal layer operations,
        the ClipRect list may get swept away and not restored.
        As soon as there is enough memory and the layer library
        gets called again the ClipRect list will be rebuilt.@{b}

    SEE ALSO@{ub}
        @{"BeginUpdate()" LINK "BeginUpdate"} @{"EndUpdate()" LINK "EndUpdate"},
        @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}, @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"}, @{"graphics/regions.h" LINK "gg:doc/NDK/Guide/Include/graphics/regions.h/File"}

@ENDNODE
@NODE "InstallLayerHook" "layers.library/InstallLayerHook()"
@{b}

    NAME@{ub}
        @{"InstallLayerHook" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 144} -- safely install a new Layer->BackFill hook.    (V36)@{b}

    SYNOPSIS@{ub}
        oldhook = @{"InstallLayerHook" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 144}( layer, hook )
        d0                          a0     a1

        @{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *@{"InstallLayerHook" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 144}( @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *, @{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *);@{b}

    FUNCTION@{ub}
        Installs a new Layer->Backfill Hook, waiting until it is safe to do
        so. Locks the layer while substituting the new Hook and removing the
        old one. If a new Hook is not provided, will install the default layer
        BackFill Hook.@{b}

    INPUTS@{ub}
        layer - pointer to the layer in which to install the Backfill Hook.
        hook -  pointer to layer callback Hook which will be called
                with object == (@{"struct RastPort" LINK "gg:doc/NDK/Guide/Include/graphics/rastport.h/File" 52} *) result->RastPort
                and message == [ (Layer *) layer, (@{"struct Rectangle" LINK "gg:doc/NDK/Guide/Include/graphics/gfx.h/File" 27}) bounds,
                                 (@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}) offsetx, (@{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}) offsety ]

                This hook should fill the Rectangle in the RastPort
                with the BackFill pattern appropriate for offset x/y.

                If hook is @{"LAYERS_BACKFILL" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 58}, the default backfill is
                used for the layer.  (Same as pre-2.0)

                As of V39:
                If hook is @{"LAYERS_NOBACKFILL" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 57}, the layer will not be
                backfilled (NO-OP).@{b}

    RESULTS@{ub}
        oldhook - pointer to the Layer->BackFill Hook that was previously
                  active.  Returns @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if it was the default hook.
                  In V39, it could return 1 if there was no hook.@{b}

    EXAMPLE@{ub}
        The following hook is a very simple example that does rather little
        but gives the basis idea of what is going on.

        *
        * This is the code called by the layer hook...
        * Note that some other setup is required for this to work, including
        * the definition of the PrivateData structure (pd_...) and the
        * definition of the BitMapPattern structure (bmp_...)
        *
        CoolHook:       xdef    CoolHook
                        movem.l d2-d7/a3-a6,-(sp)       ; Save these...
                        move.l  h_SubEntry(a0),a4       ; (my private data #1 here)
                        move.l  h_Data(a0),a5           ; Put data into address reg
        *
        * Now, we do the rendering...
        * Note that the layer may not be important...  But it is here...
        *
                        move.l  (a1)+,a0                ; Get the layer...
        *
        * a1 now points at the rectangle...
        *
                        move.l  pd_GfxBase(a4),a6       ; Point at GfxBase
                        move.l  bmp_Pattern(a5),d0      ; Get PatternBitMap
                        beq     SimpleCase              ; None?  Simple (0) case
        *
        * Now do the complex case of a pattern...
        *
                        move.l  a1,a3                   ; Pointer to rectangle
                        addq.l  #8,a1                   ; Get past rectangle
                        move.l  (a1)+,d2                ; X Offset (For pattern)
                        move.l  (a1)+,d3                ; Y Offset
                ;
                ; Whatever complex blitting you would do in the complex case
                ; goes here
                ;
        *
        * No bitmap, so just do the simple (0) minterm case...
        *
        SimpleCase:     moveq.l #0,d2                   ; Clear d2
                        move.w  ra_MinX(a1),d2          ; Get X pos
        *
                        moveq.l #0,d3
                        move.w  ra_MinY(a1),d3          ; Get Y pos
        *
                        moveq.l #0,d4
                        move.w  ra_MaxX(a1),d4
                        sub.l   d2,d4
                        addq.l  #1,d4                   ; Get X size
        *
                        moveq.l #0,d5
                        move.w  ra_MaxY(a1),d5
                        sub.l   d3,d5
                        addq.l  #1,d5                   ; Get Y size
        *
                        move.l  d2,d0                   ; X Source
                        move.l  d3,d1                   ; Y Source
                        moveq.l #0,d6                   ; @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} minterm
                        moveq.l #-1,d7                  ; FF mask
        *
                        move.l  rp_BitMap(a2),a1        ; Get bitmap
                        move.l  a1,a0
                        CALLSYS @{"BltBitMap" LINK "gg:doc/NDK/Guide/graphics/BltBitMap"}               ; Do the backfill-0
        *
        HookDone:       movem.l (sp)+,d2-d7/a3-a6       ; Restore
                        rts@{b}

    NOTES@{ub}
        The RastPort you are passed back is the same one passed to the
        function.  You should *not* use "layered" rendering functions
        on this RastPort.  Generally, you will wish to do BitMap operations
        such as @{"BltBitMap()" LINK "gg:doc/NDK/Guide/graphics/BltBitMap"}.  The callback is a raw, low-level rendering
        call-back.  If you need to call a rendering operation with a
        RastPort, make sure you use a copy of the RastPort and @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} the
        Layer pointer.@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"} @{"utility/hooks.h" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File"}

@ENDNODE
@NODE "InstallLayerInfoHook" "layers.library/InstallLayerInfoHook()"
@{b}

    NAME@{ub}
        @{"InstallLayerInfoHook" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 148} - Install a backfill hook for non-layer      (V39)@{b}

    SYNOPSIS@{ub}
        oldhook=@{"InstallLayerInfoHook" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 148}(li,hook)
        d0                           a0 a1

        @{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *@{"InstallLayerInfoHook" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 148}(@{"struct Layer_Info" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 31} *,@{"struct Hook" LINK "gg:doc/NDK/Guide/Include/utility/hooks.h/File" 28} *);@{b}

    FUNCTION@{ub}
        This function will install a backfill hook for the Layer_Info
        structure passed.  This backfill hook will be used to clear the
        background area where no layer exists.  The hook function is
        passed the RastPort and the bounds just like the layer backfill
        hook.  Note that this hook could be called for any layer.@{b}

    INPUTS@{ub}
        li - pointer to LayerInfo structure

        hook -  pointer to layer callback Hook which will be called
                with object == (@{"struct RastPort" LINK "gg:doc/NDK/Guide/Include/graphics/rastport.h/File" 52} *) result->RastPort
                and message == [ (@{"ULONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 52}) undefined, (@{"struct Rectangle" LINK "gg:doc/NDK/Guide/Include/graphics/gfx.h/File" 27}) bounds ]

                This hook should fill the Rectangle in the RastPort
                with the BackFill pattern appropriate for rectangle given.

                If hook is @{"LAYERS_BACKFILL" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 58}, the default backfill is
                used.  (Same as pre-2.0)

                If hook is @{"LAYERS_NOBACKFILL" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 57}, there will be no
                backfill.  (NO-OP).@{b}

    RESULTS@{ub}
        oldhook - Returns the backfill hook that was in the Layer_Info.
                  Returns @{"LAYERS_BACKFILL" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 58} if the default was installed.
                  Returns @{"LAYERS_NOBACKFILL" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 57} if there was a NO-OP hook.
                  Returns -1 if there was some failure.@{b}

    EXAMPLE@{ub}
        See the example in @{"InstallLayerHook" LINK "InstallLayerHook"}.  Note that both the Layer
        pointer and the OffsetX/Y values are not available in the
        LayerInfo backfill hook.@{b}

    NOTES@{ub}
        When the hook is first installed, it is *@{"NOT" LINK "gg:doc/NDK/Guide/Include/intuition/intuition.h/File" 1500}* called.  It is up
        to the application to know if it is safe to fill in the area.
        Since the hook will be called when a layer is deleted, the easiest
        way to have layers call this hook is to create and delete a backdrop
        layer that is the size of the area.

        Also, note that currently the first long word of the hook message
        contains an undefined value.  This value may look like a layer pointer.
        It is *not* a layer pointer.

        The RastPort you are passed back is the same one passed to the
        function.  You should *not* use "layered" rendering functions
        on this RastPort.  Generally, you will wish to do BitMap operations
        such as @{"BltBitMap()" LINK "gg:doc/NDK/Guide/graphics/BltBitMap"}.  The callback is a raw, low-level rendering
        call-back.  If you need to call a rendering operation with a
        RastPort, make sure you use a copy of the RastPort and @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} the
        Layer pointer.@{b}

    SEE ALSO@{ub}
        @{"InstallLayerHook()" LINK "InstallLayerHook"}

@ENDNODE
@NODE "LockLayer" "layers.library/LockLayer()"
@{b}

    NAME@{ub}
        @{"LockLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 76} -- Lock layer to make changes to ClipRects.@{b}

    SYNOPSIS@{ub}
        @{"LockLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 76}( dummy, l )
                   a0     a1

        void @{"LockLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 76}( @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *);@{b}

    FUNCTION@{ub}
        Make this layer unavailable for other tasks to use.
        If another task is already using this layer then wait for
        it to complete and then reserve the layer for your own use.
        (this function does the same thing as @{"graphics.library/LockLayerRom" LINK "gg:doc/NDK/Guide/graphics/LockLayerRom"})

        Note: if you wish to lock MORE THAN ONE layer at a time, you
            must call @{"LockLayerInfo()" LINK "LockLayerInfo"} before locking those layers and
            then call @{"UnlockLayerInfo()" LINK "UnlockLayerInfo"} when you have finished. This
            is to prevent system "deadlocks".

        Further Note: while you hold the lock on a layer, Intuition will block
            on operations such as windowsizing, dragging, menus, and depth
            arranging windows in this layer's screen.  It is recommended that
            YOU do not make Intuition function calls while the layer is locked.@{b}

    INPUTS@{ub}
        dummy - unused
        l - pointer to a layer@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"UnlockLayer()" LINK "UnlockLayer"}, @{"LockLayerInfo()" LINK "LockLayerInfo"}, @{"UnlockLayerInfo()" LINK "UnlockLayerInfo"},
        @{"graphics.library/LockLayerRom()" LINK "gg:doc/NDK/Guide/graphics/LockLayerRom"}, @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}, @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"}

@ENDNODE
@NODE "LockLayerInfo" "layers.library/LockLayerInfo()"
@{b}

    NAME@{ub}
        @{"LockLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 92} -- Lock the LayerInfo structure.@{b}

    SYNOPSIS@{ub}
        @{"LockLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 92}( li )
                       a0

        void @{"LockLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 92}( @{"struct Layer_Info" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 31} *);@{b}

    FUNCTION@{ub}
        Before doing an operation that requires the LayerInfo
        structure, make sure that no other task is also using the
        LayerInfo structure.  @{"LockLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 92}() returns when the
        LayerInfo belongs to this task.  There should be
        an @{"UnlockLayerInfo" LINK "UnlockLayerInfo"} for every @{"LockLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 92}.

        Note: All layer routines presently @{"LockLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 92}() when they
        start up and @{"UnlockLayerInfo()" LINK "UnlockLayerInfo"} as they exit.  Programmers
        will need to use these Lock/Unlock routines if they wish
        to do something with the LayerStructure that is not
        supported by the layer library.@{b}

    INPUTS@{ub}
        li - pointer to Layer_Info structure@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"UnlockLayerInfo()" LINK "UnlockLayerInfo"}, @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}

@ENDNODE
@NODE "LockLayers" "layers.library/LockLayers()"
@{b}

    NAME@{ub}
        @{"LockLayers" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 84} -- lock all layers from graphics output.@{b}

    SYNOPSIS@{ub}
        @{"LockLayers" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 84}( li )
                    a0

        void @{"LockLayers" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 84}( @{"struct Layer_Info" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 31} *);@{b}

    FUNCTION@{ub}
        First calls @{"LockLayerInfo()" LINK "LockLayerInfo"}
        Make all layers in this layer list locked.@{b}

    INPUTS@{ub}
        li - pointer to Layer_Info structure@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"LockLayer()" LINK "LockLayer"}, @{"LockLayerInfo()" LINK "LockLayerInfo"}, @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}

@ENDNODE
@NODE "MoveLayer" "layers.library/MoveLayer()"
@{b}

    NAME@{ub}
        @{"MoveLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 52} -- Move layer to new position in BitMap.@{b}

    SYNOPSIS@{ub}
        result = @{"MoveLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 52}( dummy, l, dx, dy )
        d0                  a0     a1 d0  d1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"MoveLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 52}( @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

    FUNCTION@{ub}
        Move this layer to new position in shared BitMap.
        If any refresh layers become revealed, collect damage and
        set REFRESH bit in layer Flags.@{b}

    INPUTS@{ub}
        dummy - unused
        l - pointer to a nonbackdrop layer
        dx - delta to add to current x position
        dy - delta to add to current y position@{b}

    RETURNS@{ub}
        result - @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if operation successful
                 @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if failed (out of memory)@{b}

    BUGS@{ub}
        May not handle (dx,dy) which attempts to move the layer outside the
        layer's RastPort->BitMap bounds .@{b}

    SEE ALSO@{ub}
        @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}, @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"}

@ENDNODE
@NODE "MoveLayerInFrontOf" "layers.library/MoveLayerInFrontOf()"
@{b}

    NAME@{ub}
        @{"MoveLayerInFrontOf" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 124} -- Put layer in front of another layer.@{b}

    SYNOPSIS@{ub}
        result = @{"MoveLayerInFrontOf" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 124}( layertomove, targetlayer )
                                    a0           a1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"MoveLayerInFrontOf" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 124}( @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *, @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *);@{b}

    FUNCTION@{ub}
        Move this layer in front of target layer, swapping bits
        in and out of the display with other layers.
        If this is a refresh layer then collect damage list and
        set the @{"LAYERREFRESH" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 24} bit in layer->Flags if redraw required.

        Note: this operation may generate refresh events in other layers
            associated with this layer's Layer_Info structure.@{b}

    INPUTS@{ub}
        layertomove - pointer to layer which should be moved
        targetlayer - pointer to target layer in front of which to move layer@{b}

    RESULTS@{ub}
        result = @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95}    if operation successful
                 @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}   if operation unsuccessful (probably out of memory)@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}

@ENDNODE
@NODE "MoveSizeLayer" "layers.library/MoveSizeLayer()"


        NAME                                                              (V36)
            @{"MoveSizeLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 132} -- Position/Size layer@{b}

    SYNOPSIS@{ub}
        result = @{"MoveSizeLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 132}( layer, dx, dy, dw, dh )
        d0                      a0     d0  d1  d2  d3

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"MoveSizeLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 132}( @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

    FUNCTION@{ub}
        Change upperleft and lower right position of Layer.@{b}

    INPUTS@{ub}
        dummy - unused
        l - pointer to a nonbackdrop layer
        dx,dy - change upper left corner by (dx,dy)
        dw,dy - change size by (dw,dh)@{b}

    RETURNS@{ub}
        result - @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if operation successful
                 @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if failed (due to out of memory)
                 @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if failed (due to illegal layer->bounds)@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}, @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"}

@ENDNODE
@NODE "NewLayerInfo" "layers.library/NewLayerInfo()"
@{b}

    NAME@{ub}
        @{"NewLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 108} -- Allocate and Initialize full Layer_Info structure.@{b}

    SYNOPSIS@{ub}
        result = @{"NewLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 108}()
        d0

        @{"struct Layer_Info" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 31} *@{"NewLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 108}( void );@{b}

    FUNCTION@{ub}
        Allocate memory required for full Layer_Info structure.
        Initialize Layer_Info structure in preparation to use
        other layer operations on this list of layers.
        Make the Layer_Info unlocked (open).@{b}

    INPUTS@{ub}
        None@{b}

    RESULT@{ub}
        result- pointer to Layer_Info structure if successful
                @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if not enough memory@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}

@ENDNODE
@NODE "ScrollLayer" "layers.library/ScrollLayer()"
@{b}

    NAME@{ub}
        @{"ScrollLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 60} -- Scroll around in a superbitmap, translate coordinates
                      in non-superbitmap layer.@{b}

    SYNOPSIS@{ub}
        @{"ScrollLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 60}( dummy, l, dx, dy )
                     a0     a1 d0  d1

        void @{"ScrollLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 60}( @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

    FUNCTION@{ub}
        For a SuperBitMap Layer:
        Update the SuperBitMap from the layer display, then copy bits
        between Layer and SuperBitMap to reposition layer over different
        portion of SuperBitMap.
        For nonSuperBitMap layers, all (x,y) pairs are adjusted by
        the scroll(x,y) value in the layer.  To cause (0,0) to actually
        be drawn at (3,10) use @{"ScrollLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 60}(-3,-10). This can be useful
        along with @{"InstallClipRegion" LINK "InstallClipRegion"} to simulate Intuition GZZWindows
        without the overhead of an extra layer.@{b}

    INPUTS@{ub}
        dummy - unused
        l - pointer to a layer
        dx - delta to add to current x scroll value
        dy - delta to add to current y scroll value@{b}

    BUGS@{ub}
        May not handle (dx,dy) which attempts to move the layer outside the
        layer's SuperBitMap bounds.@{b}

    SEE ALSO@{ub}
        @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}

@ENDNODE
@NODE "SizeLayer" "layers.library/SizeLayer()"
@{b}

    NAME@{ub}
        @{"SizeLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 56} -- Change the size of this nonbackdrop layer.@{b}

    SYNOPSIS@{ub}
        result = @{"SizeLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 56}( dummy, l, dx, dy )
        d0                  a0     a1 d0  d1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"SizeLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 56}( @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51});@{b}

    FUNCTION@{ub}
        Change the size of this layer by (dx,dy). The lower right hand
        corner is extended to make room for the larger layer.
        If there is SuperBitMap for this layer then copy pixels into
        or out of the layer depending on whether the layer increases or
        decreases in size.  Collect damage list for those layers that may
        need to be refreshed if damage occurred.@{b}

    INPUTS@{ub}
        dummy - unused
        l - pointer to a nonbackdrop layer
        dx - delta to add to current x size
        dy - delta to add to current y size@{b}

    RESULTS@{ub}
        result - @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95} if operation successful
                 @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98} if failed (out of memory)@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}, @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"}

@ENDNODE
@NODE "SwapBitsRastPortClipRect" "layers.library/SwapBitsRastPortClipRect()"
@{b}

    NAME@{ub}
        @{"SwapBitsRastPortClipRect" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 96} -- Swap bits between common bitmap
                                    and obscured ClipRect@{b}

    SYNOPSIS@{ub}
        @{"SwapBitsRastPortClipRect" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 96}( rp, cr )
                                  a0  a1

        void @{"SwapBitsRastPortClipRect" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 96}( @{"struct RastPort" LINK "gg:doc/NDK/Guide/Include/graphics/rastport.h/File" 52} *, @{"struct ClipRect" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 57} *);@{b}

    FUNCTION@{ub}
        Support routine useful for those that need to do some
        operations not done by the layer library.  Allows programmer
        to swap the contents of a small BitMap with a subsection of
        the display. This is accomplished without using extra memory.
        The bits in the display RastPort are exchanged with the
        bits in the ClipRect's BitMap.

        Note: the ClipRect structures which the layer library allocates are
        actually a little bigger than those described in the @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"}
        include file.  So be warned that it is not a good idea to have
        instances of cliprects in your code.@{b}

    INPUTS@{ub}
        rp - pointer to rastport
        cr - pointer to cliprect to swap bits with@{b}

    NOTE@{ub}
        Because the blit operation started by this function is done asynchronously,
        it is imperative that a @{"WaitBlit()" LINK "gg:doc/NDK/Guide/graphics/WaitBlit"} be performed before releasing or using
        the processor to modify any of the associated structures.@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"}, @{"graphics/rastport.h" LINK "gg:doc/NDK/Guide/Include/graphics/rastport.h/File"}, @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"}

@ENDNODE
@NODE "ThinLayerInfo" "layers.library/ThinLayerInfo()"
@{b}

    NAME@{ub}
        @{"ThinLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 120} -- convert 1.1 LayerInfo to 1.0 LayerInfo.
        OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE@{b}

    SYNOPSIS@{ub}
        OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE
        @{"ThinLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 120}( li )
                       a0

        void @{"ThinLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 120}( @{"struct Layer_Info" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 31} *);
        OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE@{b}

    FUNCTION@{ub}
        return the extra memory needed that was allocated with
        @{"FattenLayerInfo" LINK "FattenLayerInfo"}. This is must be done prior to freeing
        the Layer_Info structure itself. V1.1 software should be
        using @{"DisposeLayerInfo" LINK "DisposeLayerInfo"}.@{b}

    INPUTS@{ub}
        li - pointer to LayerInfo structure@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"DisposeLayerInfo()" LINK "DisposeLayerInfo"}, @{"FattenLayerInfo()" LINK "FattenLayerInfo"}, @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}

@ENDNODE
@NODE "UnlockLayer" "layers.library/UnlockLayer()"
@{b}

    NAME@{ub}
        @{"UnlockLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 80} -- Unlock layer and allow graphics routines to use it.@{b}

    SYNOPSIS@{ub}
        @{"UnlockLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 80}( l )
                     a0

        void @{"UnlockLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 80}( @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *);@{b}

    FUNCTION@{ub}
        When finished changing the ClipRects or whatever you were
        doing with this layer you must call @{"UnlockLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 80}() to allow
        other tasks to proceed with graphic output to the layer.@{b}

    INPUTS@{ub}
        l - pointer to a layer@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}, @{"graphics/clip.h" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File"}

@ENDNODE
@NODE "UnlockLayerInfo" "layers.library/UnlockLayerInfo()"
@{b}

    NAME@{ub}
        @{"UnlockLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 104} -- Unlock the LayerInfo structure.@{b}

    SYNOPSIS@{ub}
        @{"UnlockLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 104}( li )
                         a0

        void @{"UnlockLayerInfo" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 104}( @{"struct Layer_Info" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 31} *);@{b}

    FUNCTION@{ub}
        After the operation is complete that required a @{"LockLayerInfo" LINK "LockLayerInfo"},
        unlock the LayerInfo structure so that  other tasks may
        affect the layers.@{b}

    INPUTS@{ub}
        li - pointer to the Layer_Info structure

     BUGS

     SEE ALSO
        @{"LockLayerInfo()" LINK "LockLayerInfo"}, @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}

@ENDNODE
@NODE "UnlockLayers" "layers.library/UnlockLayers()"
@{b}

    NAME@{ub}
        @{"UnlockLayers" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 88} -- Unlock all layers from graphics output.
                        Restart graphics output to layers that have been waiting@{b}

    SYNOPSIS@{ub}
        @{"UnlockLayers" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 88}( li )
                      a0

        void @{"UnlockLayers" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 88}( @{"struct Layer_Info" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 31} *);@{b}

    FUNCTION@{ub}
        Make all layers in this layer list unlocked.
        Then call @{"UnlockLayerInfo" LINK "UnlockLayerInfo"}@{b}

    INPUTS@{ub}
        li - pointer to the Layer_Info structure@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"LockLayers()" LINK "LockLayers"}, @{"UnlockLayer()" LINK "UnlockLayer"}, @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}

@ENDNODE
@NODE "UpfrontLayer" "layers.library/UpfrontLayer()"
@{b}

    NAME@{ub}
        @{"UpfrontLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 44} -- Put layer in front of all other layers.@{b}

    SYNOPSIS@{ub}
        result = @{"UpfrontLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 44}( dummy, l )
        d0                     a0     a1

        @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51} @{"UpfrontLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 44}( @{"LONG" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 51}, @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *);@{b}

    FUNCTION@{ub}
        Move this layer to the most upfront position swapping bits
        in and out of the display with other layers.
        If this is a refresh layer then collect damage list and
        set the @{"LAYERREFRESH" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 24} bit in layer->Flags if redraw required.
        By clearing the @{"BACKDROP" LINK "gg:doc/NDK/Guide/Include/intuition/iobsolete.h/File" 151} bit in the layers Flags you may
        bring a Backdrop layer up to the front of all other layers.

        Note: this operation may generate refresh events in other layers
           associated with this layer's Layer_Info structure.@{b}

    INPUTS@{ub}
        dummy - unused
        l - pointer to a nonbackdrop layer@{b}

    RESULTS@{ub}
        result - @{"TRUE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 95}   if operation successful
                 @{"FALSE" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 98}  if operation unsuccessful (probably out of memory)@{b}

    BUGS@{ub}@{b}

    SEE ALSO@{ub}
        @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}

@ENDNODE
@NODE "WhichLayer" "layers.library/WhichLayer()"
@{b}

    NAME@{ub}
        @{"WhichLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 100} -- Which Layer is this point in?@{b}

    SYNOPSIS@{ub}
        layer = @{"WhichLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 100}( li, x, y )
        d0                  a0  d0 d1

        @{"struct Layer" LINK "gg:doc/NDK/Guide/Include/graphics/clip.h/File" 27} *@{"WhichLayer" LINK "gg:doc/NDK/Guide/Include/inline/layers.h/File" 100}(@{"struct Layer_Info" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File" 31}*, @{"WORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 54}, @{"WORD" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 54});@{b}

    FUNCTION@{ub}
        Starting at the topmost layer check to see if this point (x,y)
            occurs in this layer.  If it does return the pointer to this
            layer. Return @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if there is no layer at this point.@{b}

    INPUTS@{ub}
        li  = pointer to LayerInfo structure
        (x,y) = coordinate in the BitMap@{b}

    RESULTS@{ub}
        layer - pointer to the topmost layer that this point is in
                @{"NULL" LINK "gg:doc/NDK/Guide/Include/exec/types.h/File" 101} if this point is not in a layer@{b}

    SEE ALSO@{ub}
        @{"graphics/layers.h" LINK "gg:doc/NDK/Guide/Include/graphics/layers.h/File"}

@ENDNODE
