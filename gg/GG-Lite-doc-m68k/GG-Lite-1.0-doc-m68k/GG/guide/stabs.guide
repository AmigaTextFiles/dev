@database stabs.guide

@Master /gg-src/gg/fsf/gdb/gdb/doc/stabs.texinfo

@Width 72


This is the AmigaGuide®  file stabs.guide, produced by Makeinfo-1.68 from 
the input file /gg-src/gg/fsf/gdb/gdb/doc/stabs.texinfo.

START-INFO-DIR-ENTRY
* Stabs: (stabs).                 The "stabs" debugging information format.
END-INFO-DIR-ENTRY

   This document describes the stabs debugging symbol tables.

   Copyright 1992, 1993 Free Software Foundation, Inc.  Contributed by
Cygnus Support.  Written by Julia Menapace, Jim Kingdon, and David
MacKenzie.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy or distribute modified versions of this
manual under the terms of the GPL (for which purpose this text may be
regarded as a program in the language TeX).

@node Main "stabs.guide"
@next "Overview"

The "stabs" representation of debugging information
***************************************************

   This document describes the stabs debugging format.


 @{" Overview        " link "Overview"}  Overview of stabs
 @{" Program Structure " link "Program Structure"}  Encoding of the structure of the program
 @{" Constants       " link "Constants"}  Constants
 @{" Variables       " link "Variables"}  
 @{" Types           " link "Types"}  Type definitions
 @{" Symbol Tables   " link "Symbol Tables"}  Symbol information in symbol tables
 @{" Cplusplus       " link "Cplusplus"}  Stabs specific to C++
 @{" Stab Types      " link "Stab Types"}  Symbol types in a.out files
 @{" Symbol Descriptors " link "Symbol Descriptors"}  Table of symbol descriptors
 @{" Type Descriptors " link "Type Descriptors"}  Table of type descriptors
 @{" Expanded Reference " link "Expanded Reference"}  Reference information by stab type
 @{" Questions       " link "Questions"}  Questions and anomolies
 @{" Sun Differences " link "Sun Differences"}  Differences between GNU stabs and Sun
                                native stabs
 @{" Stab Sections   " link "Stab Sections"}  In some object file formats, stabs are
                                in sections.
 @{" Symbol Types Index " link "Symbol Types Index"}  Index of symbolic stab symbol type names.


@endnode

@node "Overview" "stabs.guide/Overview"
@next "Program Structure"
@prev "Main"
@toc "Main"

Overview of Stabs
*****************

@{i}   Stabs@{ui} refers to a format for information that describes a program to
a debugger.  This format was apparently invented by Peter Kessler at
the University of California at Berkeley, for the @{b}pdx@{ub} Pascal debugger;
the format has spread widely since then.

   This document is one of the few published sources of documentation on
stabs.  It is believed to be comprehensive for stabs used by C.  The
lists of symbol descriptors (see @{"Symbol Descriptors" link "Symbol Descriptors"}) and type
descriptors (see @{"Type Descriptors" link "Type Descriptors"}) are believed to be completely
comprehensive.  Stabs for COBOL-specific features and for variant
records (used by Pascal and Modula-2) are poorly documented here.

   Other sources of information on stabs are `Dbx and Dbxtool
Interfaces', 2nd edition, by Sun, 1988, and `AIX Version 3.2 Files
Reference', Fourth Edition, September 1992, "dbx Stabstring Grammar" in
the a.out section, page 2-31.  This document is believed to incorporate
the information from those two sources except where it explicitly
directs you to them for more information.


 @{" Flow                    " link "Flow"}  Overview of debugging information flow
 @{" Stabs Format            " link "Stabs Format"}  Overview of stab format
 @{" String Field            " link "String Field"}  The string field
 @{" C Example               " link "C Example"}  A simple example in C source
 @{" Assembly Code           " link "Assembly Code"}  The simple example at the assembly level


@endnode

@node "Flow" "stabs.guide/Flow"
@next "Stabs Format"
@toc "Overview"

Overview of Debugging Information Flow
======================================

   The GNU C compiler compiles C source in a @{b}.c@{ub} file into assembly
language in a @{b}.s@{ub} file, which the assembler translates into a @{b}.o@{ub} file,
which the linker combines with other @{b}.o@{ub} files and libraries to produce
an executable file.

   With the @{b}-g@{ub} option, GCC puts in the @{b}.s@{ub} file additional debugging
information, which is slightly transformed by the assembler and linker,
and carried through into the final executable.  This debugging
information describes features of the source file like line numbers,
the types and scopes of variables, and function names, parameters, and
scopes.

   For some object file formats, the debugging information is
encapsulated in assembler directives known collectively as @{i}stab@{ui} (symbol
table) directives, which are interspersed with the generated code.
Stabs are the native format for debugging information in the a.out and
XCOFF object file formats.  The GNU tools can also emit stabs in the
COFF and ECOFF object file formats.

   The assembler adds the information from stabs to the symbol
information it places by default in the symbol table and the string
table of the @{b}.o@{ub} file it is building.  The linker consolidates the @{b}.o@{ub}
files into one executable file, with one symbol table and one string
table.  Debuggers use the symbol and string tables in the executable as
a source of debugging information about the program.


@endnode

@node "Stabs Format" "stabs.guide/Stabs Format"
@next "String Field"
@prev "Flow"
@toc "Overview"

Overview of Stab Format
=======================

   There are three overall formats for stab assembler directives,
differentiated by the first word of the stab.  The name of the directive
describes which combination of four possible data fields follows.  It is
either @{b}.stabs@{ub} (string), @{b}.stabn@{ub} (number), or @{b}.stabd@{ub} (dot).  IBM's XCOFF
assembler uses @{b}.stabx@{ub} (and some other directives such as @{b}.file@{ub} and @{b}.bi@{ub})
instead of @{b}.stabs@{ub}, @{b}.stabn@{ub} or @{b}.stabd@{ub}.

   The overall format of each class of stab is:

     .stabs "STRING",TYPE,OTHER,DESC,VALUE
     .stabn TYPE,OTHER,DESC,VALUE
     .stabd TYPE,OTHER,DESC
     .stabx "STRING",VALUE,TYPE,SDB-TYPE

   For @{b}.stabn@{ub} and @{b}.stabd@{ub}, there is no STRING (the @{b}n_strx@{ub} field is zero;
see @{"Symbol Tables" link "Symbol Tables"}).  For @{b}.stabd@{ub}, the VALUE field is implicit and has
the value of the current file location.  For @{b}.stabx@{ub}, the SDB-TYPE field
is unused for stabs and can always be set to zero.  The OTHER field is
almost always unused and can be set to zero.

   The number in the TYPE field gives some basic information about
which type of stab this is (or whether it @{i}is@{ui} a stab, as opposed to an
ordinary symbol).  Each valid type number defines a different stab
type; further, the stab type defines the exact interpretation of, and
possible values for, any remaining STRING, DESC, or VALUE fields
present in the stab.  See @{"Stab Types" link "Stab Types"}, for a list in numeric order of
the valid TYPE field values for stab directives.


@endnode

@node "String Field" "stabs.guide/String Field"
@next "C Example"
@prev "Stabs Format"
@toc "Overview"

The String Field
================

   For most stabs the string field holds the meat of the debugging
information.  The flexible nature of this field is what makes stabs
extensible.  For some stab types the string field contains only a name.
For other stab types the contents can be a great deal more complex.

   The overall format of the string field for most stab types is:

     "NAME:SYMBOL-DESCRIPTOR TYPE-INFORMATION"

   NAME is the name of the symbol represented by the stab; it can
contain a pair of colons (see @{"Nested Symbols" link "Nested Symbols"}).  NAME can be omitted,
which means the stab represents an unnamed object.  For example,
@{b}:t10=*2@{ub} defines type 10 as a pointer to type 2, but does not give the
type a name.  Omitting the NAME field is supported by AIX dbx and GDB
after about version 4.8, but not other debuggers.  GCC sometimes uses a
single space as the name instead of omitting the name altogether;
apparently that is supported by most debuggers.

   The SYMBOL-DESCRIPTOR following the @{b}:@{ub} is an alphabetic character
that tells more specifically what kind of symbol the stab represents.
If the SYMBOL-DESCRIPTOR is omitted, but type information follows, then
the stab represents a local variable.  For a list of symbol
descriptors, see @{"Symbol Descriptors" link "Symbol Descriptors"}.  The @{b}c@{ub} symbol descriptor is an
exception in that it is not followed by type information.  See
@{"Constants" link "Constants"}.

   TYPE-INFORMATION is either a TYPE-NUMBER, or @{b}TYPE-NUMBER=@{ub}.  A
TYPE-NUMBER alone is a type reference, referring directly to a type
that has already been defined.

   The @{b}TYPE-NUMBER=@{ub} form is a type definition, where the number
represents a new type which is about to be defined.  The type
definition may refer to other types by number, and those type numbers
may be followed by @{b}=@{ub} and nested definitions.  Also, the Lucid compiler
will repeat @{b}TYPE-NUMBER=@{ub} more than once if it wants to define several
type numbers at once.

   In a type definition, if the character that follows the equals sign
is non-numeric then it is a TYPE-DESCRIPTOR, and tells what kind of
type is about to be defined.  Any other values following the
TYPE-DESCRIPTOR vary, depending on the TYPE-DESCRIPTOR.  See
@{"Type Descriptors" link "Type Descriptors"}, for a list of TYPE-DESCRIPTOR values.  If a number
follows the @{b}=@{ub} then the number is a TYPE-REFERENCE.  For a full
description of types, @{"Types" link "Types"}.

   There is an AIX extension for type attributes.  Following the @{b}=@{ub} are
any number of type attributes.  Each one starts with @{b}\@@{ub} and ends with @{b};@{ub}.
Debuggers, including AIX's dbx and GDB 4.10, skip any type attributes
they do not recognize.  GDB 4.9 and other versions of dbx may not do
this.  Because of a conflict with C++ (see @{"Cplusplus" link "Cplusplus"}), new attributes
should not be defined which begin with a digit, @{b}(@{ub}, or @{b}-@{ub}; GDB may be
unable to distinguish those from the C++ type descriptor @{b}\@@{ub}.  The
attributes are:

@{b}aBOUNDARY@{ub}
     BOUNDARY is an integer specifying the alignment.  I assume it
     applies to all variables of this type.

@{b}pINTEGER@{ub}
     Pointer class (for checking).  Not sure what this means, or how
     INTEGER is interpreted.

@{b}P@{ub}
     Indicate this is a packed type, meaning that structure fields or
     array elements are placed more closely in memory, to save memory
     at the expense of speed.

@{b}sSIZE@{ub}
     Size in bits of a variable of this type.  This is fully supported
     by GDB 4.11 and later.

@{b}S@{ub}
     Indicate that this type is a string instead of an array of
     characters, or a bitstring instead of a set.  It doesn't change
     the layout of the data being represented, but does enable the
     debugger to know which type it is.

   All of this can make the string field quite long.  All versions of
GDB, and some versions of dbx, can handle arbitrarily long strings.
But many versions of dbx (or assemblers or linkers, I'm not sure which)
cretinously limit the strings to about 80 characters, so compilers which
must work with such systems need to split the @{b}.stabs@{ub} directive into
several @{b}.stabs@{ub} directives.  Each stab duplicates every field except the
string field.  The string field of every stab except the last is marked
as continued with a backslash at the end (in the assembly code this may
be written as a double backslash, depending on the assembler).
Removing the backslashes and concatenating the string fields of each
stab produces the original, long string.  Just to be incompatible (or so
they don't have to worry about what the assembler does with
backslashes), AIX can use @{b}?@{ub} instead of backslash.


@endnode

@node "C Example" "stabs.guide/C Example"
@next "Assembly Code"
@prev "String Field"
@toc "Overview"

A Simple Example in C Source
============================

   To get the flavor of how stabs describe source information for a C
program, let's look at the simple program:

     main()
     {
             printf("Hello world");
     }

   When compiled with @{b}-g@{ub}, the program above yields the following @{b}.s@{ub}
file.  Line numbers have been added to make it easier to refer to parts
of the @{b}.s@{ub} file in the description of the stabs that follows.


@endnode

@node "Assembly Code" "stabs.guide/Assembly Code"
@prev "C Example"
@toc "Overview"

The Simple Example at the Assembly Level
========================================

   This simple "hello world" example demonstrates several of the stab
types used to describe C language source files.

     1  gcc2_compiled.:
     2  .stabs "/cygint/s1/users/jcm/play/",100,0,0,Ltext0
     3  .stabs "hello.c",100,0,0,Ltext0
     4  .text
     5  Ltext0:
     6  .stabs "int:t1=r1;-2147483648;2147483647;",128,0,0,0
     7  .stabs "char:t2=r2;0;127;",128,0,0,0
     8  .stabs "long int:t3=r1;-2147483648;2147483647;",128,0,0,0
     9  .stabs "unsigned int:t4=r1;0;-1;",128,0,0,0
     10 .stabs "long unsigned int:t5=r1;0;-1;",128,0,0,0
     11 .stabs "short int:t6=r1;-32768;32767;",128,0,0,0
     12 .stabs "long long int:t7=r1;0;-1;",128,0,0,0
     13 .stabs "short unsigned int:t8=r1;0;65535;",128,0,0,0
     14 .stabs "long long unsigned int:t9=r1;0;-1;",128,0,0,0
     15 .stabs "signed char:t10=r1;-128;127;",128,0,0,0
     16 .stabs "unsigned char:t11=r1;0;255;",128,0,0,0
     17 .stabs "float:t12=r1;4;0;",128,0,0,0
     18 .stabs "double:t13=r1;8;0;",128,0,0,0
     19 .stabs "long double:t14=r1;8;0;",128,0,0,0
     20 .stabs "void:t15=15",128,0,0,0
     21      .align 4
     22 LC0:
     23      .ascii "Hello, world!\\12\\0"
     24      .align 4
     25      .global _main
     26      .proc 1
     27 _main:
     28 .stabn 68,0,4,LM1
     29 LM1:
     30      !#PROLOGUE# 0
     31      save %sp,-136,%sp
     32      !#PROLOGUE# 1
     33      call ___main,0
     34      nop
     35 .stabn 68,0,5,LM2
     36 LM2:
     37 LBB2:
     38      sethi %hi(LC0),%o1
     39      or %o1,%lo(LC0),%o0
     40      call _printf,0
     41      nop
     42 .stabn 68,0,6,LM3
     43 LM3:
     44 LBE2:
     45 .stabn 68,0,6,LM4
     46 LM4:
     47 L1:
     48      ret
     49      restore
     50 .stabs "main:F1",36,0,0,_main
     51 .stabn 192,0,0,LBB2
     52 .stabn 224,0,0,LBE2


@endnode

@node "Program Structure" "stabs.guide/Program Structure"
@next "Constants"
@prev "Overview"
@toc "Main"

Encoding the Structure of the Program
*************************************

   The elements of the program structure that stabs encode include the
name of the main function, the names of the source and include files,
the line numbers, procedure names and types, and the beginnings and
ends of blocks of code.


 @{" Main Program              " link "Main Program"}  Indicate what the main program is
 @{" Source Files              " link "Source Files"}  The path and name of the source file
 @{" Include Files             " link "Include Files"}  Names of include files
 @{" Line Numbers              " link "Line Numbers"}  
 @{" Procedures                " link "Procedures"}  
 @{" Nested Procedures         " link "Nested Procedures"}  
 @{" Block Structure           " link "Block Structure"}  
 @{" Alternate Entry Points    " link "Alternate Entry Points"}  Entering procedures except at the beginning.


@endnode

@node "Main Program" "stabs.guide/Main Program"
@next "Source Files"
@toc "Program Structure"

Main Program
============

   Most languages allow the main program to have any name.  The @{b}N_MAIN@{ub}
stab type tells the debugger the name that is used in this program.
Only the string field is significant; it is the name of a function
which is the main program.  Most C compilers do not use this stab (they
expect the debugger to assume that the name is @{b}main@{ub}), but some C
compilers emit an @{b}N_MAIN@{ub} stab for the @{b}main@{ub} function.  I'm not sure how
XCOFF handles this.


@endnode

@node "Source Files" "stabs.guide/Source Files"
@next "Include Files"
@prev "Main Program"
@toc "Program Structure"

Paths and Names of the Source Files
===================================

   Before any other stabs occur, there must be a stab specifying the
source file.  This information is contained in a symbol of stab type
@{b}N_SO@{ub}; the string field contains the name of the file.  The value of the
symbol is the start address of the portion of the text section
corresponding to that file.

   With the Sun Solaris2 compiler, the desc field contains a
source-language code.

   Some compilers (for example, GCC2 and SunOS4 @{b}/bin/cc@{ub}) also include
the directory in which the source was compiled, in a second @{b}N_SO@{ub} symbol
preceding the one containing the file name.  This symbol can be
distinguished by the fact that it ends in a slash.  Code from the
@{b}cfront@{ub} C++ compiler can have additional @{b}N_SO@{ub} symbols for nonexistent
source files after the @{b}N_SO@{ub} for the real source file; these are
believed to contain no useful information.

   For example:

     .stabs "/cygint/s1/users/jcm/play/",100,0,0,Ltext0     # 100 is N_SO
     .stabs "hello.c",100,0,0,Ltext0
             .text
     Ltext0:

   Instead of @{b}N_SO@{ub} symbols, XCOFF uses a @{b}.file@{ub} assembler directive
which assembles to a @{b}C_FILE@{ub} symbol; explaining this in detail is
outside the scope of this document.

   If it is useful to indicate the end of a source file, this is done
with an @{b}N_SO@{ub} symbol with an empty string for the name.  The value is
the address of the end of the text section for the file.  For some
systems, there is no indication of the end of a source file, and you
just need to figure it ended when you see an @{b}N_SO@{ub} for a different
source file, or a symbol ending in @{b}.o@{ub} (which at least some linkers
insert to mark the start of a new @{b}.o@{ub} file).


@endnode

@node "Include Files" "stabs.guide/Include Files"
@next "Line Numbers"
@prev "Source Files"
@toc "Program Structure"

Names of Include Files
======================

   There are several schemes for dealing with include files: the
traditional @{b}N_SOL@{ub} approach, Sun's @{b}N_BINCL@{ub} approach, and the XCOFF
@{b}C_BINCL@{ub} approach (which despite the similar name has little in common
with @{b}N_BINCL@{ub}).

   An @{b}N_SOL@{ub} symbol specifies which include file subsequent symbols
refer to.  The string field is the name of the file and the value is the
text address corresponding to the end of the previous include file and
the start of this one.  To specify the main source file again, use an
@{b}N_SOL@{ub} symbol with the name of the main source file.

   The @{b}N_BINCL@{ub} approach works as follows.  An @{b}N_BINCL@{ub} symbol specifies
the start of an include file.  In an object file, only the string is
significant; the Sun linker puts data into some of the other fields.
The end of the include file is marked by an @{b}N_EINCL@{ub} symbol (which has
no string field).  In an object file, there is no significant data in
the @{b}N_EINCL@{ub} symbol.  @{b}N_BINCL@{ub} and @{b}N_EINCL@{ub} can be nested.

   If the linker detects that two source files have identical stabs
between an @{b}N_BINCL@{ub} and @{b}N_EINCL@{ub} pair (as will generally be the case for
a header file), then it only puts out the stabs once.  Each additional
occurance is replaced by an @{b}N_EXCL@{ub} symbol.  I believe the Sun (SunOS4,
not sure about Solaris) linker is the only one which supports this
feature.

   The SunOS4 linker sets the value of a @{b}N_BINCL@{ub} symbol to the total of
all the characters in the stabs strings included in the header file,
omitting the file number.  The value of an @{b}N_EXCL@{ub} symbol is the same as
the value of the @{b}N_BINCL@{ub} symbol it replaces.  I do not know if this
information is used by anything.  The @{b}N_EINCL@{ub} value, and the values of
the other and description fields for all three, appear to always be
zero.

   For the start of an include file in XCOFF, use the @{b}.bi@{ub} assembler
directive, which generates a @{b}C_BINCL@{ub} symbol.  A @{b}.ei@{ub} directive, which
generates a @{b}C_EINCL@{ub} symbol, denotes the end of the include file.  Both
directives are followed by the name of the source file in quotes, which
becomes the string for the symbol.  The value of each symbol, produced
automatically by the assembler and linker, is the offset into the
executable of the beginning (inclusive, as you'd expect) or end
(inclusive, as you would not expect) of the portion of the COFF line
table that corresponds to this include file.  @{b}C_BINCL@{ub} and @{b}C_EINCL@{ub} do
not nest.


@endnode

@node "Line Numbers" "stabs.guide/Line Numbers"
@next "Procedures"
@prev "Include Files"
@toc "Program Structure"

Line Numbers
============

   An @{b}N_SLINE@{ub} symbol represents the start of a source line.  The desc
field contains the line number and the value contains the code address
for the start of that source line.  On most machines the address is
absolute; for stabs in sections (see @{"Stab Sections" link "Stab Sections"}), it is relative to
the function in which the @{b}N_SLINE@{ub} symbol occurs.

   GNU documents @{b}N_DSLINE@{ub} and @{b}N_BSLINE@{ub} symbols for line numbers in the
data or bss segments, respectively.  They are identical to @{b}N_SLINE@{ub} but
are relocated differently by the linker.  They were intended to be used
to describe the source location of a variable declaration, but I
believe that GCC2 actually puts the line number in the desc field of
the stab for the variable itself.  GDB has been ignoring these symbols
(unless they contain a string field) since at least GDB 3.5.

   For single source lines that generate discontiguous code, such as
flow of control statements, there may be more than one line number
entry for the same source line.  In this case there is a line number
entry at the start of each code range, each with the same line number.

   XCOFF does not use stabs for line numbers.  Instead, it uses COFF
line numbers (which are outside the scope of this document).  Standard
COFF line numbers cannot deal with include files, but in XCOFF this is
fixed with the @{b}C_BINCL@{ub} method of marking include files (see
@{"Include Files" link "Include Files"}).


@endnode

@node "Procedures" "stabs.guide/Procedures"
@next "Nested Procedures"
@prev "Line Numbers"
@toc "Program Structure"

Procedures
==========

   All of the following stabs normally use the @{b}N_FUN@{ub} symbol type.
However, Sun's @{b}acc@{ub} compiler on SunOS4 uses @{b}N_GSYM@{ub} and @{b}N_STSYM@{ub}, which
means that the value of the stab for the function is useless and the
debugger must get the address of the function from the non-stab symbols
instead.  On systems where non-stab symbols have leading underscores,
the stabs will lack underscores and the debugger needs to know about
the leading underscore to match up the stab and the non-stab symbol.
BSD Fortran is said to use @{b}N_FNAME@{ub} with the same restriction; the value
of the symbol is not useful (I'm not sure it really does use this,
because GDB doesn't handle this and no one has complained).

   A function is represented by an @{b}F@{ub} symbol descriptor for a global
(extern) function, and @{b}f@{ub} for a static (local) function.  For a.out, the
value of the symbol is the address of the start of the function; it is
already relocated.  For stabs in ELF, the SunPRO compiler version 2.0.1
and GCC put out an address which gets relocated by the linker.  In a
future release SunPRO is planning to put out zero, in which case the
address can be found from the ELF (non-stab) symbol.  Because looking
things up in the ELF symbols would probably be slow, I'm not sure how
to find which symbol of that name is the right one, and this doesn't
provide any way to deal with nested functions, it would probably be
better to make the value of the stab an address relative to the start
of the file, or just absolute.  See @{"ELF Linker Relocation" link "ELF Linker Relocation"} for more
information on linker relocation of stabs in ELF files.  For XCOFF, the
stab uses the @{b}C_FUN@{ub} storage class and the value of the stab is
meaningless; the address of the function can be found from the csect
symbol (XTY_LD/XMC_PR).

   The type information of the stab represents the return type of the
function; thus @{b}foo:f5@{ub} means that foo is a function returning type 5.
There is no need to try to get the line number of the start of the
function from the stab for the function; it is in the next @{b}N_SLINE@{ub}
symbol.

   Some compilers (such as Sun's Solaris compiler) support an extension
for specifying the types of the arguments.  I suspect this extension is
not used for old (non-prototyped) function definitions in C.  If the
extension is in use, the type information of the stab for the function
is followed by type information for each argument, with each argument
preceded by @{b};@{ub}.  An argument type of 0 means that additional arguments
are being passed, whose types and number may vary (@{b}...@{ub} in ANSI C).  GDB
has tolerated this extension (parsed the syntax, if not necessarily
used the information) since at least version 4.8; I don't know whether
all versions of dbx tolerate it.  The argument types given here are not
redundant with the symbols for the formal parameters (see @{"Parameters" link "Parameters"});
they are the types of the arguments as they are passed, before any
conversions might take place.  For example, if a C function which is
declared without a prototype takes a @{b}float@{ub} argument, the value is
passed as a @{b}double@{ub} but then converted to a @{b}float@{ub}.  Debuggers need to
use the types given in the arguments when printing values, but when
calling the function they need to use the types given in the symbol
defining the function.

   If the return type and types of arguments of a function which is
defined in another source file are specified (i.e., a function
prototype in ANSI C), traditionally compilers emit no stab; the only
way for the debugger to find the information is if the source file
where the function is defined was also compiled with debugging symbols.
As an extension the Solaris compiler uses symbol descriptor @{b}P@{ub} followed
by the return type of the function, followed by the arguments, each
preceded by @{b};@{ub}, as in a stab with symbol descriptor @{b}f@{ub} or @{b}F@{ub}.  This use of
symbol descriptor @{b}P@{ub} can be distinguished from its use for register
parameters (see @{"Register Parameters" link "Register Parameters"}) by the fact that it has symbol
type @{b}N_FUN@{ub}.

   The AIX documentation also defines symbol descriptor @{b}J@{ub} as an
internal function.  I assume this means a function nested within another
function.  It also says symbol descriptor @{b}m@{ub} is a module in Modula-2 or
extended Pascal.

   Procedures (functions which do not return values) are represented as
functions returning the @{b}void@{ub} type in C.  I don't see why this couldn't
be used for all languages (inventing a @{b}void@{ub} type for this purpose if
necessary), but the AIX documentation defines @{b}I@{ub}, @{b}P@{ub}, and @{b}Q@{ub} for internal,
global, and static procedures, respectively.  These symbol descriptors
are unusual in that they are not followed by type information.

   The following example shows a stab for a function @{b}main@{ub} which returns
type number @{b}1@{ub}.  The @{b}_main@{ub} specified for the value is a reference to an
assembler label which is used to fill in the start address of the
function.

     .stabs "main:F1",36,0,0,_main      # 36 is N_FUN

   The stab representing a procedure is located immediately following
the code of the procedure.  This stab is in turn directly followed by a
group of other stabs describing elements of the procedure.  These other
stabs describe the procedure's parameters, its block local variables,
and its block structure.


@endnode

@node "Nested Procedures" "stabs.guide/Nested Procedures"
@next "Block Structure"
@prev "Procedures"
@toc "Program Structure"

Nested Procedures
=================

   For any of the symbol descriptors representing procedures, after the
symbol descriptor and the type information is optionally a scope
specifier.  This consists of a comma, the name of the procedure, another
comma, and the name of the enclosing procedure.  The first name is local
to the scope specified, and seems to be redundant with the name of the
symbol (before the @{b}:@{ub}).  This feature is used by GCC, and presumably
Pascal, Modula-2, etc., compilers, for nested functions.

   If procedures are nested more than one level deep, only the
immediately containing scope is specified.  For example, this code:

     int
     foo (int x)
     {
       int bar (int y)
         {
           int baz (int z)
             {
               return x + y + z;
             }
           return baz (x + 2 * y);
         }
       return x + bar (3 * x);
     }

produces the stabs:

     .stabs "baz:f1,baz,bar",36,0,0,_baz.15         # 36 is N_FUN
     .stabs "bar:f1,bar,foo",36,0,0,_bar.12
     .stabs "foo:F1",36,0,0,_foo


@endnode

@node "Block Structure" "stabs.guide/Block Structure"
@next "Alternate Entry Points"
@prev "Nested Procedures"
@toc "Program Structure"

Block Structure
===============

   The program's block structure is represented by the @{b}N_LBRAC@{ub} (left
brace) and the @{b}N_RBRAC@{ub} (right brace) stab types.  The variables defined
inside a block precede the @{b}N_LBRAC@{ub} symbol for most compilers, including
GCC.  Other compilers, such as the Convex, Acorn RISC machine, and Sun
@{b}acc@{ub} compilers, put the variables after the @{b}N_LBRAC@{ub} symbol.  The values
of the @{b}N_LBRAC@{ub} and @{b}N_RBRAC@{ub} symbols are the start and end addresses of
the code of the block, respectively.  For most machines, they are
relative to the starting address of this source file.  For the Gould
NP1, they are absolute.  For stabs in sections (see @{"Stab Sections" link "Stab Sections"}),
they are relative to the function in which they occur.

   The @{b}N_LBRAC@{ub} and @{b}N_RBRAC@{ub} stabs that describe the block scope of a
procedure are located after the @{b}N_FUN@{ub} stab that represents the
procedure itself.

   Sun documents the desc field of @{b}N_LBRAC@{ub} and @{b}N_RBRAC@{ub} symbols as
containing the nesting level of the block.  However, dbx seems to not
care, and GCC always sets desc to zero.

   For XCOFF, block scope is indicated with @{b}C_BLOCK@{ub} symbols.  If the
name of the symbol is @{b}.bb@{ub}, then it is the beginning of the block; if
the name of the symbol is @{b}.be@{ub}; it is the end of the block.


@endnode

@node "Alternate Entry Points" "stabs.guide/Alternate Entry Points"
@prev "Block Structure"
@toc "Program Structure"

Alternate Entry Points
======================

   Some languages, like Fortran, have the ability to enter procedures at
some place other than the beginning.  One can declare an alternate entry
point.  The @{b}N_ENTRY@{ub} stab is for this; however, the Sun FORTRAN compiler
doesn't use it.  According to AIX documentation, only the name of a
@{b}C_ENTRY@{ub} stab is significant; the address of the alternate entry point
comes from the corresponding external symbol.  A previous revision of
this document said that the value of an @{b}N_ENTRY@{ub} stab was the address of
the alternate entry point, but I don't know the source for that
information.


@endnode

@node "Constants" "stabs.guide/Constants"
@next "Variables"
@prev "Program Structure"
@toc "Main"

Constants
*********

   The @{b}c@{ub} symbol descriptor indicates that this stab represents a
constant.  This symbol descriptor is an exception to the general rule
that symbol descriptors are followed by type information.  Instead, it
is followed by @{b}=@{ub} and one of the following:

@{b}b VALUE@{ub}
     Boolean constant.  VALUE is a numeric value; I assume it is 0 for
     false or 1 for true.

@{b}c VALUE@{ub}
     Character constant.  VALUE is the numeric value of the constant.

@{b}e TYPE-INFORMATION , VALUE@{ub}
     Constant whose value can be represented as integral.
     TYPE-INFORMATION is the type of the constant, as it would appear
     after a symbol descriptor (see @{"String Field" link "String Field"}).  VALUE is the
     numeric value of the constant.  GDB 4.9 does not actually get the
     right value if VALUE does not fit in a host @{b}int@{ub}, but it does not
     do anything violent, and future debuggers could be extended to
     accept integers of any size (whether unsigned or not).  This
     constant type is usually documented as being only for enumeration
     constants, but GDB has never imposed that restriction; I don't
     know about other debuggers.

@{b}i VALUE@{ub}
     Integer constant.  VALUE is the numeric value.  The type is some
     sort of generic integer type (for GDB, a host @{b}int@{ub}); to specify the
     type explicitly, use @{b}e@{ub} instead.

@{b}r VALUE@{ub}
     Real constant.  VALUE is the real value, which can be @{b}INF@{ub}
     (optionally preceded by a sign) for infinity, @{b}QNAN@{ub} for a quiet NaN
     (not-a-number), or @{b}SNAN@{ub} for a signalling NaN.  If it is a normal
     number the format is that accepted by the C library function @{b}atof@{ub}.

@{b}s STRING@{ub}
     String constant.  STRING is a string enclosed in either @{b}'@{ub} (in
     which case @{b}'@{ub} characters within the string are represented as @{b}\\'@{ub}
     or @{b}"@{ub} (in which case @{b}"@{ub} characters within the string are represented
     as @{b}\\"@{ub}).

@{b}S TYPE-INFORMATION , ELEMENTS , BITS , PATTERN@{ub}
     Set constant.  TYPE-INFORMATION is the type of the constant, as it
     would appear after a symbol descriptor (see @{"String Field" link "String Field"}).
     ELEMENTS is the number of elements in the set (does this means how
     many bits of PATTERN are actually used, which would be redundant
     with the type, or perhaps the number of bits set in PATTERN?  I
     don't get it), BITS is the number of bits in the constant (meaning
     it specifies the length of PATTERN, I think), and PATTERN is a
     hexadecimal representation of the set.  AIX documentation refers
     to a limit of 32 bytes, but I see no reason why this limit should
     exist.  This form could probably be used for arbitrary constants,
     not just sets; the only catch is that PATTERN should be understood
     to be target, not host, byte order and format.

   The boolean, character, string, and set constants are not supported
by GDB 4.9, but it ignores them.  GDB 4.8 and earlier gave an error
message and refused to read symbols from the file containing the
constants.

   The above information is followed by @{b};@{ub}.


@endnode

@node "Variables" "stabs.guide/Variables"
@next "Types"
@prev "Constants"
@toc "Main"

Variables
*********

   Different types of stabs describe the various ways that variables
can be allocated: on the stack, globally, in registers, in common
blocks, statically, or as arguments to a function.


 @{" Stack Variables        " link "Stack Variables"}  Variables allocated on the stack.
 @{" Global Variables       " link "Global Variables"}  Variables used by more than one source file.
 @{" Register Variables     " link "Register Variables"}  Variables in registers.
 @{" Common Blocks          " link "Common Blocks"}  Variables statically allocated together.
 @{" Statics                " link "Statics"}  Variables local to one source file.
 @{" Based Variables        " link "Based Variables"}  Fortran pointer based variables.
 @{" Parameters             " link "Parameters"}  Variables for arguments to functions.


@endnode

@node "Stack Variables" "stabs.guide/Stack Variables"
@next "Global Variables"
@toc "Variables"

Automatic Variables Allocated on the Stack
==========================================

   If a variable's scope is local to a function and its lifetime is
only as long as that function executes (C calls such variables
@{i}automatic@{ui}), it can be allocated in a register (see @{"Register Variables" link "Register Variables"})
or on the stack.

   Each variable allocated on the stack has a stab with the symbol
descriptor omitted.  Since type information should begin with a digit,
@{b}-@{ub}, or @{b}(@{ub}, only those characters precluded from being used for symbol
descriptors.  However, the Acorn RISC machine (ARM) is said to get this
wrong: it puts out a mere type definition here, without the preceding
@{b}TYPE-NUMBER=@{ub}.  This is a bad idea; there is no guarantee that type
descriptors are distinct from symbol descriptors.  Stabs for stack
variables use the @{b}N_LSYM@{ub} stab type, or @{b}C_LSYM@{ub} for XCOFF.

   The value of the stab is the offset of the variable within the local
variables.  On most machines this is an offset from the frame pointer
and is negative.  The location of the stab specifies which block it is
defined in; see @{"Block Structure" link "Block Structure"}.

   For example, the following C code:

     int
     main ()
     {
       int x;
     }

   produces the following stabs:

     .stabs "main:F1",36,0,0,_main   # 36 is N_FUN
     .stabs "x:1",128,0,0,-12        # 128 is N_LSYM
     .stabn 192,0,0,LBB2             # 192 is N_LBRAC
     .stabn 224,0,0,LBE2             # 224 is N_RBRAC

   See @{"Procedures" link "Procedures"}, for more information on the @{b}N_FUN@{ub} stab, and
@{"Block Structure" link "Block Structure"} for more information on the @{b}N_LBRAC@{ub} and @{b}N_RBRAC@{ub} stabs.


@endnode

@node "Global Variables" "stabs.guide/Global Variables"
@next "Register Variables"
@prev "Stack Variables"
@toc "Variables"

Global Variables
================

   A variable whose scope is not specific to just one source file is
represented by the @{b}G@{ub} symbol descriptor.  These stabs use the @{b}N_GSYM@{ub}
stab type (C_GSYM for XCOFF).  The type information for the stab (see
@{"String Field" link "String Field"}) gives the type of the variable.

   For example, the following source code:

     char g_foo = 'c';

yields the following assembly code:

     .stabs "g_foo:G2",32,0,0,0     # 32 is N_GSYM
          .global _g_foo
          .data
     _g_foo:
          .byte 99

   The address of the variable represented by the @{b}N_GSYM@{ub} is not
contained in the @{b}N_GSYM@{ub} stab.  The debugger gets this information from
the external symbol for the global variable.  In the example above, the
@{b}.global _g_foo@{ub} and @{b}_g_foo:@{ub} lines tell the assembler to produce an
external symbol.

   Some compilers, like GCC, output @{b}N_GSYM@{ub} stabs only once, where the
variable is defined.  Other compilers, like SunOS4 /bin/cc, output a
@{b}N_GSYM@{ub} stab for each compilation unit which references the variable.


@endnode

@node "Register Variables" "stabs.guide/Register Variables"
@next "Common Blocks"
@prev "Global Variables"
@toc "Variables"

Register Variables
==================

   Register variables have their own stab type, @{b}N_RSYM@{ub} (@{b}C_RSYM@{ub} for
XCOFF), and their own symbol descriptor, @{b}r@{ub}.  The stab's value is the
number of the register where the variable data will be stored.

   AIX defines a separate symbol descriptor @{b}d@{ub} for floating point
registers.  This seems unnecessary; why not just just give floating
point registers different register numbers?  I have not verified whether
the compiler actually uses @{b}d@{ub}.

   If the register is explicitly allocated to a global variable, but not
initialized, as in:

     register int g_bar asm ("%g5");

then the stab may be emitted at the end of the object file, with the
other bss symbols.


@endnode

@node "Common Blocks" "stabs.guide/Common Blocks"
@next "Statics"
@prev "Register Variables"
@toc "Variables"

Common Blocks
=============

   A common block is a statically allocated section of memory which can
be referred to by several source files.  It may contain several
variables.  I believe Fortran is the only language with this feature.

   A @{b}N_BCOMM@{ub} stab begins a common block and an @{b}N_ECOMM@{ub} stab ends it.
The only field that is significant in these two stabs is the string,
which names a normal (non-debugging) symbol that gives the address of
the common block.  According to IBM documentation, only the @{b}N_BCOMM@{ub} has
the name of the common block (even though their compiler actually puts
it both places).

   The stabs for the members of the common block are between the
@{b}N_BCOMM@{ub} and the @{b}N_ECOMM@{ub}; the value of each stab is the offset within
the common block of that variable.  IBM uses the @{b}C_ECOML@{ub} stab type, and
there is a corresponding @{b}N_ECOML@{ub} stab type, but Sun's Fortran compiler
uses @{b}N_GSYM@{ub} instead.  The variables within a common block use the @{b}V@{ub}
symbol descriptor (I believe this is true of all Fortran variables).
Other stabs (at least type declarations using @{b}C_DECL@{ub}) can also be
between the @{b}N_BCOMM@{ub} and the @{b}N_ECOMM@{ub}.


@endnode

@node "Statics" "stabs.guide/Statics"
@next "Based Variables"
@prev "Common Blocks"
@toc "Variables"

Static Variables
================

   Initialized static variables are represented by the @{b}S@{ub} and @{b}V@{ub} symbol
descriptors.  @{b}S@{ub} means file scope static, and @{b}V@{ub} means procedure scope
static.  One exception: in XCOFF, IBM's xlc compiler always uses @{b}V@{ub}, and
whether it is file scope or not is distinguished by whether the stab is
located within a function.

   In a.out files, @{b}N_STSYM@{ub} means the data section, @{b}N_FUN@{ub} means the text
section, and @{b}N_LCSYM@{ub} means the bss section.  For those systems with a
read-only data section separate from the text section (Solaris),
@{b}N_ROSYM@{ub} means the read-only data section.

   For example, the source lines:

     static const int var_const = 5;
     static int var_init = 2;
     static int var_noinit;

yield the following stabs:

     .stabs "var_const:S1",36,0,0,_var_const      # 36 is N_FUN
     ...
     .stabs "var_init:S1",38,0,0,_var_init        # 38 is N_STSYM
     ...
     .stabs "var_noinit:S1",40,0,0,_var_noinit    # 40 is N_LCSYM

   In XCOFF files, the stab type need not indicate the section; @{b}C_STSYM@{ub}
can be used for all statics.  Also, each static variable is enclosed in
a static block.  A @{b}C_BSTAT@{ub} (emitted with a @{b}.bs@{ub} assembler directive)
symbol begins the static block; its value is the symbol number of the
csect symbol whose value is the address of the static block, its
section is the section of the variables in that static block, and its
name is @{b}.bs@{ub}.  A @{b}C_ESTAT@{ub} (emitted with a @{b}.es@{ub} assembler directive) symbol
ends the static block; its name is @{b}.es@{ub} and its value and section are
ignored.

   In ECOFF files, the storage class is used to specify the section, so
the stab type need not indicate the section.

   In ELF files, for the SunPRO compiler version 2.0.1, symbol
descriptor @{b}S@{ub} means that the address is absolute (the linker relocates
it) and symbol descriptor @{b}V@{ub} means that the address is relative to the
start of the relevant section for that compilation unit.  SunPRO has
plans to have the linker stop relocating stabs; I suspect that their the
debugger gets the address from the corresponding ELF (not stab) symbol.
I'm not sure how to find which symbol of that name is the right one.
The clean way to do all this would be to have a the value of a symbol
descriptor @{b}S@{ub} symbol be an offset relative to the start of the file,
just like everything else, but that introduces obvious compatibility
problems.  For more information on linker stab relocation, See
@{"ELF Linker Relocation" link "ELF Linker Relocation"}.


@endnode

@node "Based Variables" "stabs.guide/Based Variables"
@next "Parameters"
@prev "Statics"
@toc "Variables"

Fortran Based Variables
=======================

   Fortran (at least, the Sun and SGI dialects of FORTRAN-77) has a
feature which allows allocating arrays with @{b}malloc@{ub}, but which avoids
blurring the line between arrays and pointers the way that C does.  In
stabs such a variable uses the @{b}b@{ub} symbol descriptor.

   For example, the Fortran declarations

     real foo, foo10(10), foo10_5(10,5)
     pointer (foop, foo)
     pointer (foo10p, foo10)
     pointer (foo105p, foo10_5)

   produce the stabs

     foo:b6
     foo10:bar3;1;10;6
     foo10_5:bar3;1;5;ar3;1;10;6

   In this example, @{b}real@{ub} is type 6 and type 3 is an integral type which
is the type of the subscripts of the array (probably @{b}integer@{ub}).

   The @{b}b@{ub} symbol descriptor is like @{b}V@{ub} in that it denotes a statically
allocated symbol whose scope is local to a function; see See @{"Statics" link "Statics"}.
The value of the symbol, instead of being the address of the variable
itself, is the address of a pointer to that variable.  So in the above
example, the value of the @{b}foo@{ub} stab is the address of a pointer to a
real, the value of the @{b}foo10@{ub} stab is the address of a pointer to a
10-element array of reals, and the value of the @{b}foo10_5@{ub} stab is the
address of a pointer to a 5-element array of 10-element arrays of reals.


@endnode

@node "Parameters" "stabs.guide/Parameters"
@prev "Based Variables"
@toc "Variables"

Parameters
==========

   Formal parameters to a function are represented by a stab (or
sometimes two; see below) for each parameter.  The stabs are in the
order in which the debugger should print the parameters (i.e., the
order in which the parameters are declared in the source file).  The
exact form of the stab depends on how the parameter is being passed.

   Parameters passed on the stack use the symbol descriptor @{b}p@{ub} and the
@{b}N_PSYM@{ub} symbol type (or @{b}C_PSYM@{ub} for XCOFF).  The value of the symbol is
an offset used to locate the parameter on the stack; its exact meaning
is machine-dependent, but on most machines it is an offset from the
frame pointer.

   As a simple example, the code:

     main (argc, argv)
          int argc;
          char **argv;

   produces the stabs:

     .stabs "main:F1",36,0,0,_main                 # 36 is N_FUN
     .stabs "argc:p1",160,0,0,68                   # 160 is N_PSYM
     .stabs "argv:p20=*21=*2",160,0,0,72

   The type definition of @{b}argv@{ub} is interesting because it contains
several type definitions.  Type 21 is pointer to type 2 (char) and @{b}argv@{ub}
(type 20) is pointer to type 21.

   The following symbol descriptors are also said to go with @{b}N_PSYM@{ub}.
The value of the symbol is said to be an offset from the argument
pointer (I'm not sure whether this is true or not).

     pP (<<??>>)
     pF Fortran function parameter
     X  (function result variable)


 @{" Register Parameters " link "Register Parameters"}  
 @{" Local Variable Parameters " link "Local Variable Parameters"}  
 @{" Reference Parameters " link "Reference Parameters"}  
 @{" Conformant Arrays " link "Conformant Arrays"}


@endnode

@node "Register Parameters" "stabs.guide/Register Parameters"
@next "Local Variable Parameters"
@toc "Parameters"

Passing Parameters in Registers
-------------------------------

   If the parameter is passed in a register, then traditionally there
are two symbols for each argument:

     .stabs "arg:p1" . . .       ; N_PSYM
     .stabs "arg:r1" . . .       ; N_RSYM

   Debuggers use the second one to find the value, and the first one to
know that it is an argument.

   Because that approach is kind of ugly, some compilers use symbol
descriptor @{b}P@{ub} or @{b}R@{ub} to indicate an argument which is in a register.
Symbol type @{b}C_RPSYM@{ub} is used in XCOFF and @{b}N_RSYM@{ub} is used otherwise.  The
symbol's value is the register number.  @{b}P@{ub} and @{b}R@{ub} mean the same thing;
the difference is that @{b}P@{ub} is a GNU invention and @{b}R@{ub} is an IBM (XCOFF)
invention.  As of version 4.9, GDB should handle either one.

   There is at least one case where GCC uses a @{b}p@{ub} and @{b}r@{ub} pair rather than
@{b}P@{ub}; this is where the argument is passed in the argument list and then
loaded into a register.

   According to the AIX documentation, symbol descriptor @{b}D@{ub} is for a
parameter passed in a floating point register.  This seems
unnecessary--why not just use @{b}R@{ub} with a register number which indicates
that it's a floating point register?  I haven't verified whether the
system actually does what the documentation indicates.

   On the sparc and hppa, for a @{b}P@{ub} symbol whose type is a structure or
union, the register contains the address of the structure.  On the
sparc, this is also true of a @{b}p@{ub} and @{b}r@{ub} pair (using Sun @{b}cc@{ub}) or a @{b}p@{ub}
symbol.  However, if a (small) structure is really in a register, @{b}r@{ub} is
used.  And, to top it all off, on the hppa it might be a structure
which was passed on the stack and loaded into a register and for which
there is a @{b}p@{ub} and @{b}r@{ub} pair!  I believe that symbol descriptor @{b}i@{ub} is
supposed to deal with this case (it is said to mean "value parameter by
reference, indirect access"; I don't know the source for this
information), but I don't know details or what compilers or debuggers
use it, if any (not GDB or GCC).  It is not clear to me whether this
case needs to be dealt with differently than parameters passed by
reference (see @{"Reference Parameters" link "Reference Parameters"}).


@endnode

@node "Local Variable Parameters" "stabs.guide/Local Variable Parameters"
@next "Reference Parameters"
@prev "Register Parameters"
@toc "Parameters"

Storing Parameters as Local Variables
-------------------------------------

   There is a case similar to an argument in a register, which is an
argument that is actually stored as a local variable.  Sometimes this
happens when the argument was passed in a register and then the compiler
stores it as a local variable.  If possible, the compiler should claim
that it's in a register, but this isn't always done.

   If a parameter is passed as one type and converted to a smaller type
by the prologue (for example, the parameter is declared as a @{b}float@{ub}, but
the calling conventions specify that it is passed as a @{b}double@{ub}), then
GCC2 (sometimes) uses a pair of symbols.  The first symbol uses symbol
descriptor @{b}p@{ub} and the type which is passed.  The second symbol has the
type and location which the parameter actually has after the prologue.
For example, suppose the following C code appears with no prototypes
involved:

     void
     subr (f)
          float f;
     {

   if @{b}f@{ub} is passed as a double at stack offset 8, and the prologue
converts it to a float in register number 0, then the stabs look like:

     .stabs "f:p13",160,0,3,8   # 160 is @{b}N_PSYM@{ub}, here 13 is @{b}double@{ub}
     .stabs "f:r12",64,0,3,0    # 64 is @{b}N_RSYM@{ub}, here 12 is @{b}float@{ub}

   In both stabs 3 is the line number where @{b}f@{ub} is declared (see
@{"Line Numbers" link "Line Numbers"}).

   GCC, at least on the 960, has another solution to the same problem.
It uses a single @{b}p@{ub} symbol descriptor for an argument which is stored as
a local variable but uses @{b}N_LSYM@{ub} instead of @{b}N_PSYM@{ub}.  In this case, the
value of the symbol is an offset relative to the local variables for
that function, not relative to the arguments; on some machines those
are the same thing, but not on all.

   On the VAX or on other machines in which the calling convention
includes the number of words of arguments actually passed, the debugger
(GDB at least) uses the parameter symbols to keep track of whether it
needs to print nameless arguments in addition to the formal parameters
which it has printed because each one has a stab.  For example, in

     extern int fprintf (FILE *stream, char *format, ...);
     ...
     fprintf (stdout, "%d\\n", x);

   there are stabs for @{b}stream@{ub} and @{b}format@{ub}.  On most machines, the
debugger can only print those two arguments (because it has no way of
knowing that additional arguments were passed), but on the VAX or other
machines with a calling convention which indicates the number of words
of arguments, the debugger can print all three arguments.  To do so,
the parameter symbol (symbol descriptor @{b}p@{ub}) (not necessarily @{b}r@{ub} or symbol
descriptor omitted symbols) needs to contain the actual type as passed
(for example, @{b}double@{ub} not @{b}float@{ub} if it is passed as a double and
converted to a float).


@endnode

@node "Reference Parameters" "stabs.guide/Reference Parameters"
@next "Conformant Arrays"
@prev "Local Variable Parameters"
@toc "Parameters"

Passing Parameters by Reference
-------------------------------

   If the parameter is passed by reference (e.g., Pascal @{b}VAR@{ub}
parameters), then the symbol descriptor is @{b}v@{ub} if it is in the argument
list, or @{b}a@{ub} if it in a register.  Other than the fact that these contain
the address of the parameter rather than the parameter itself, they are
identical to @{b}p@{ub} and @{b}R@{ub}, respectively.  I believe @{b}a@{ub} is an AIX invention; @{b}v@{ub}
is supported by all stabs-using systems as far as I know.


@endnode

@node "Conformant Arrays" "stabs.guide/Conformant Arrays"
@prev "Reference Parameters"
@toc "Parameters"

Passing Conformant Array Parameters
-----------------------------------

   Conformant arrays are a feature of Modula-2, and perhaps other
languages, in which the size of an array parameter is not known to the
called function until run-time.  Such parameters have two stabs: a @{b}x@{ub}
for the array itself, and a @{b}C@{ub}, which represents the size of the array.
The value of the @{b}x@{ub} stab is the offset in the argument list where the
address of the array is stored (it this right?  it is a guess); the
value of the @{b}C@{ub} stab is the offset in the argument list where the size
of the array (in elements? in bytes?) is stored.


@endnode

@node "Types" "stabs.guide/Types"
@next "Symbol Tables"
@prev "Variables"
@toc "Main"

Defining Types
**************

   The examples so far have described types as references to previously
defined types, or defined in terms of subranges of or pointers to
previously defined types.  This chapter describes the other type
descriptors that may follow the @{b}=@{ub} in a type definition.


 @{" Builtin Types            " link "Builtin Types"}  Integers, floating point, void, etc.
 @{" Miscellaneous Types      " link "Miscellaneous Types"}  Pointers, sets, files, etc.
 @{" Cross-References         " link "Cross-References"}  Referring to a type not yet defined.
 @{" Subranges                " link "Subranges"}  A type with a specific range.
 @{" Arrays                   " link "Arrays"}  An aggregate type of same-typed elements.
 @{" Strings                  " link "Strings"}  Like an array but also has a length.
 @{" Enumerations             " link "Enumerations"}  Like an integer but the values have names.
 @{" Structures               " link "Structures"}  An aggregate type of different-typed elements.
 @{" Typedefs                 " link "Typedefs"}  Giving a type a name.
 @{" Unions                   " link "Unions"}  Different types sharing storage.
 @{" Function Types           " link "Function Types"}


@endnode

@node "Builtin Types" "stabs.guide/Builtin Types"
@next "Miscellaneous Types"
@toc "Types"

Builtin Types
=============

   Certain types are built in (@{b}int@{ub}, @{b}short@{ub}, @{b}void@{ub}, @{b}float@{ub}, etc.); the
debugger recognizes these types and knows how to handle them.  Thus,
don't be surprised if some of the following ways of specifying builtin
types do not specify everything that a debugger would need to know
about the type--in some cases they merely specify enough information to
distinguish the type from other types.

   The traditional way to define builtin types is convolunted, so new
ways have been invented to describe them.  Sun's @{b}acc@{ub} uses special
builtin type descriptors (@{b}b@{ub} and @{b}R@{ub}), and IBM uses negative type numbers.
GDB accepts all three ways, as of version 4.8; dbx just accepts the
traditional builtin types and perhaps one of the other two formats.
The following sections describe each of these formats.


 @{" Traditional Builtin Types  " link "Traditional Builtin Types"}  Put on your seatbelts and prepare for kludgery
 @{" Builtin Type Descriptors   " link "Builtin Type Descriptors"}  Builtin types with special type descriptors
 @{" Negative Type Numbers      " link "Negative Type Numbers"}  Builtin types using negative type numbers


@endnode

@node "Traditional Builtin Types" "stabs.guide/Traditional Builtin Types"
@next "Builtin Type Descriptors"
@toc "Builtin Types"

Traditional Builtin Types
-------------------------

   This is the traditional, convoluted method for defining builtin
types.  There are several classes of such type definitions: integer,
floating point, and @{b}void@{ub}.


 @{" Traditional Integer Types " link "Traditional Integer Types"}  
 @{" Traditional Other Types " link "Traditional Other Types"}


@endnode

@node "Traditional Integer Types" "stabs.guide/Traditional Integer Types"
@next "Traditional Other Types"
@toc "Traditional Builtin Types"

Traditional Integer Types
.........................

   Often types are defined as subranges of themselves.  If the bounding
values fit within an @{b}int@{ub}, then they are given normally.  For example:

     .stabs "int:t1=r1;-2147483648;2147483647;",128,0,0,0    # 128 is N_LSYM
     .stabs "char:t2=r2;0;127;",128,0,0,0

   Builtin types can also be described as subranges of @{b}int@{ub}:

     .stabs "unsigned short:t6=r1;0;65535;",128,0,0,0

   If the lower bound of a subrange is 0 and the upper bound is -1, the
type is an unsigned integral type whose bounds are too big to describe
in an @{b}int@{ub}.  Traditionally this is only used for @{b}unsigned int@{ub} and
@{b}unsigned long@{ub}:

     .stabs "unsigned int:t4=r1;0;-1;",128,0,0,0

   For larger types, GCC 2.4.5 puts out bounds in octal, with one or
more leading zeroes.  In this case a negative bound consists of a number
which is a 1 bit (for the sign bit) followed by a 0 bit for each bit in
the number (except the sign bit), and a positive bound is one which is a
1 bit for each bit in the number (except possibly the sign bit).  All
known versions of dbx and GDB version 4 accept this (at least in the
sense of not refusing to process the file), but GDB 3.5 refuses to read
the whole file containing such symbols.  So GCC 2.3.3 did not output the
proper size for these types.  As an example of octal bounds, the string
fields of the stabs for 64 bit integer types look like:

     long int:t3=r1;001000000000000000000000;000777777777777777777777;
     long unsigned int:t5=r1;000000000000000000000000;001777777777777777777777;

   If the lower bound of a subrange is 0 and the upper bound is
negative, the type is an unsigned integral type whose size in bytes is
the absolute value of the upper bound.  I believe this is a Convex
convention for @{b}unsigned long long@{ub}.

   If the lower bound of a subrange is negative and the upper bound is
0, the type is a signed integral type whose size in bytes is the
absolute value of the lower bound.  I believe this is a Convex
convention for @{b}long long@{ub}.  To distinguish this from a legitimate
subrange, the type should be a subrange of itself.  I'm not sure whether
this is the case for Convex.


@endnode

@node "Traditional Other Types" "stabs.guide/Traditional Other Types"
@prev "Traditional Integer Types"
@toc "Traditional Builtin Types"

Traditional Other Types
.......................

   If the upper bound of a subrange is 0 and the lower bound is
positive, the type is a floating point type, and the lower bound of the
subrange indicates the number of bytes in the type:

     .stabs "float:t12=r1;4;0;",128,0,0,0
     .stabs "double:t13=r1;8;0;",128,0,0,0

   However, GCC writes @{b}long double@{ub} the same way it writes @{b}double@{ub}, so
there is no way to distinguish.

     .stabs "long double:t14=r1;8;0;",128,0,0,0

   Complex types are defined the same way as floating-point types;
there is no way to distinguish a single-precision complex from a
double-precision floating-point type.

   The C @{b}void@{ub} type is defined as itself:

     .stabs "void:t15=15",128,0,0,0

   I'm not sure how a boolean type is represented.


@endnode

@node "Builtin Type Descriptors" "stabs.guide/Builtin Type Descriptors"
@next "Negative Type Numbers"
@prev "Traditional Builtin Types"
@toc "Builtin Types"

Defining Builtin Types Using Builtin Type Descriptors
-----------------------------------------------------

   This is the method used by Sun's @{b}acc@{ub} for defining builtin types.
These are the type descriptors to define builtin types:

@{b}b SIGNED CHAR-FLAG WIDTH ; OFFSET ; NBITS ;@{ub}
     Define an integral type.  SIGNED is @{b}u@{ub} for unsigned or @{b}s@{ub} for
     signed.  CHAR-FLAG is @{b}c@{ub} which indicates this is a character type,
     or is omitted.  I assume this is to distinguish an integral type
     from a character type of the same size, for example it might make
     sense to set it for the C type @{b}wchar_t@{ub} so the debugger can print
     such variables differently (Solaris does not do this).  Sun sets
     it on the C types @{b}signed char@{ub} and @{b}unsigned char@{ub} which arguably is
     wrong.  WIDTH and OFFSET appear to be for small objects stored in
     larger ones, for example a @{b}short@{ub} in an @{b}int@{ub} register.  WIDTH is
     normally the number of bytes in the type.  OFFSET seems to always
     be zero.  NBITS is the number of bits in the type.

     Note that type descriptor @{b}b@{ub} used for builtin types conflicts with
     its use for Pascal space types (see @{"Miscellaneous Types" link "Miscellaneous Types"}); they can
     be distinguished because the character following the type
     descriptor will be a digit, @{b}(@{ub}, or @{b}-@{ub} for a Pascal space type, or @{b}u@{ub}
     or @{b}s@{ub} for a builtin type.

@{b}w@{ub}
     Documented by AIX to define a wide character type, but their
     compiler actually uses negative type numbers (see
     @{"Negative Type Numbers" link "Negative Type Numbers"}).

@{b}R FP-TYPE ; BYTES ;@{ub}
     Define a floating point type.  FP-TYPE has one of the following
     values:

    @{b}1 (NF_SINGLE)@{ub}
          IEEE 32-bit (single precision) floating point format.

    @{b}2 (NF_DOUBLE)@{ub}
          IEEE 64-bit (double precision) floating point format.

    @{b}3 (NF_COMPLEX)@{ub}

    @{b}4 (NF_COMPLEX16)@{ub}

    @{b}5 (NF_COMPLEX32)@{ub}
          These are for complex numbers.  A comment in the GDB source
          describes them as Fortran @{b}complex@{ub}, @{b}double complex@{ub}, and
          @{b}complex*16@{ub}, respectively, but what does that mean?  (i.e.,
          Single precision?  Double precison?).

    @{b}6 (NF_LDOUBLE)@{ub}
          Long double.  This should probably only be used for Sun format
          @{b}long double@{ub}, and new codes should be used for other floating
          point formats (@{b}NF_DOUBLE@{ub} can be used if a @{b}long double@{ub} is
          really just an IEEE double, of course).

     BYTES is the number of bytes occupied by the type.  This allows a
     debugger to perform some operations with the type even if it
     doesn't understand FP-TYPE.

@{b}g TYPE-INFORMATION ; NBITS@{ub}
     Documented by AIX to define a floating type, but their compiler
     actually uses negative type numbers (see @{"Negative Type Numbers" link "Negative Type Numbers"}).

@{b}c TYPE-INFORMATION ; NBITS@{ub}
     Documented by AIX to define a complex type, but their compiler
     actually uses negative type numbers (see @{"Negative Type Numbers" link "Negative Type Numbers"}).

   The C @{b}void@{ub} type is defined as a signed integral type 0 bits long:
     .stabs "void:t19=bs0;0;0",128,0,0,0
   The Solaris compiler seems to omit the trailing semicolon in this
case.  Getting sloppy in this way is not a swift move because if a type
is embedded in a more complex expression it is necessary to be able to
tell where it ends.

   I'm not sure how a boolean type is represented.


@endnode

@node "Negative Type Numbers" "stabs.guide/Negative Type Numbers"
@prev "Builtin Type Descriptors"
@toc "Builtin Types"

Negative Type Numbers
---------------------

   This is the method used in XCOFF for defining builtin types.  Since
the debugger knows about the builtin types anyway, the idea of negative
type numbers is simply to give a special type number which indicates
the builtin type.  There is no stab defining these types.

   There are several subtle issues with negative type numbers.

   One is the size of the type.  A builtin type (for example the C types
@{b}int@{ub} or @{b}long@{ub}) might have different sizes depending on compiler options,
the target architecture, the ABI, etc.  This issue doesn't come up for
IBM tools since (so far) they just target the RS/6000; the sizes
indicated below for each size are what the IBM RS/6000 tools use.  To
deal with differing sizes, either define separate negative type numbers
for each size (which works but requires changing the debugger, and,
unless you get both AIX dbx and GDB to accept the change, introduces an
incompatibility), or use a type attribute (see @{"String Field" link "String Field"}) to define
a new type with the appropriate size (which merely requires a debugger
which understands type attributes, like AIX dbx or GDB).  For example,

     .stabs "boolean:t10=@s8;-16",128,0,0,0

   defines an 8-bit boolean type, and

     .stabs "boolean:t10=@s64;-16",128,0,0,0

   defines a 64-bit boolean type.

   A similar issue is the format of the type.  This comes up most often
for floating-point types, which could have various formats (particularly
extended doubles, which vary quite a bit even among IEEE systems).
Again, it is best to define a new negative type number for each
different format; changing the format based on the target system has
various problems.  One such problem is that the Alpha has both VAX and
IEEE floating types.  One can easily imagine one library using the VAX
types and another library in the same executable using the IEEE types.
Another example is that the interpretation of whether a boolean is true
or false can be based on the least significant bit, most significant
bit, whether it is zero, etc., and different compilers (or different
options to the same compiler) might provide different kinds of boolean.

   The last major issue is the names of the types.  The name of a given
type depends @{i}only@{ui} on the negative type number given; these do not vary
depending on the language, the target system, or anything else.  One
can always define separate type numbers--in the following list you will
see for example separate @{b}int@{ub} and @{b}integer*4@{ub} types which are identical
except for the name.  But compatibility can be maintained by not
inventing new negative type numbers and instead just defining a new
type with a new name.  For example:

     .stabs "CARDINAL:t10=-8",128,0,0,0

   Here is the list of negative type numbers.  The phrase @{i}integral type@{ui}
is used to mean twos-complement (I strongly suspect that all machines
which use stabs use twos-complement; most machines use twos-complement
these days).

@{b}-1@{ub}
@{b}     int@{ub}, 32 bit signed integral type.

@{b}-2@{ub}
@{b}     char@{ub}, 8 bit type holding a character.   Both GDB and dbx on AIX
     treat this as signed.  GCC uses this type whether @{b}char@{ub} is signed
     or not, which seems like a bad idea.  The AIX compiler (@{b}xlc@{ub}) seems
     to avoid this type; it uses -5 instead for @{b}char@{ub}.

@{b}-3@{ub}
@{b}     short@{ub}, 16 bit signed integral type.

@{b}-4@{ub}
@{b}     long@{ub}, 32 bit signed integral type.

@{b}-5@{ub}
@{b}     unsigned char@{ub}, 8 bit unsigned integral type.

@{b}-6@{ub}
@{b}     signed char@{ub}, 8 bit signed integral type.

@{b}-7@{ub}
@{b}     unsigned short@{ub}, 16 bit unsigned integral type.

@{b}-8@{ub}
@{b}     unsigned int@{ub}, 32 bit unsigned integral type.

@{b}-9@{ub}
@{b}     unsigned@{ub}, 32 bit unsigned integral type.

@{b}-10@{ub}
@{b}     unsigned long@{ub}, 32 bit unsigned integral type.

@{b}-11@{ub}
@{b}     void@{ub}, type indicating the lack of a value.

@{b}-12@{ub}
@{b}     float@{ub}, IEEE single precision.

@{b}-13@{ub}
@{b}     double@{ub}, IEEE double precision.

@{b}-14@{ub}
@{b}     long double@{ub}, IEEE double precision.  The compiler claims the size
     will increase in a future release, and for binary compatibility
     you have to avoid using @{b}long double@{ub}.  I hope when they increase it
     they use a new negative type number.

@{b}-15@{ub}
@{b}     integer@{ub}.  32 bit signed integral type.

@{b}-16@{ub}
@{b}     boolean@{ub}.  32 bit type.  GDB and GCC assume that zero is false, one
     is true, and other values have unspecified meaning.  I hope this
     agrees with how the IBM tools use the type.

@{b}-17@{ub}
@{b}     short real@{ub}.  IEEE single precision.

@{b}-18@{ub}
@{b}     real@{ub}.  IEEE double precision.

@{b}-19@{ub}
@{b}     stringptr@{ub}.  See @{"Strings" link "Strings"}.

@{b}-20@{ub}
@{b}     character@{ub}, 8 bit unsigned character type.

@{b}-21@{ub}
@{b}     logical*1@{ub}, 8 bit type.  This Fortran type has a split personality
     in that it is used for boolean variables, but can also be used for
     unsigned integers.  0 is false, 1 is true, and other values are
     non-boolean.

@{b}-22@{ub}
@{b}     logical*2@{ub}, 16 bit type.  This Fortran type has a split personality
     in that it is used for boolean variables, but can also be used for
     unsigned integers.  0 is false, 1 is true, and other values are
     non-boolean.

@{b}-23@{ub}
@{b}     logical*4@{ub}, 32 bit type.  This Fortran type has a split personality
     in that it is used for boolean variables, but can also be used for
     unsigned integers.  0 is false, 1 is true, and other values are
     non-boolean.

@{b}-24@{ub}
@{b}     logical@{ub}, 32 bit type.  This Fortran type has a split personality
     in that it is used for boolean variables, but can also be used for
     unsigned integers.  0 is false, 1 is true, and other values are
     non-boolean.

@{b}-25@{ub}
@{b}     complex@{ub}.  A complex type consisting of two IEEE single-precision
     floating point values.

@{b}-26@{ub}
@{b}     complex@{ub}.  A complex type consisting of two IEEE double-precision
     floating point values.

@{b}-27@{ub}
@{b}     integer*1@{ub}, 8 bit signed integral type.

@{b}-28@{ub}
@{b}     integer*2@{ub}, 16 bit signed integral type.

@{b}-29@{ub}
@{b}     integer*4@{ub}, 32 bit signed integral type.

@{b}-30@{ub}
@{b}     wchar@{ub}.  Wide character, 16 bits wide, unsigned (what format?
     Unicode?).

@{b}-31@{ub}
@{b}     long long@{ub}, 64 bit signed integral type.

@{b}-32@{ub}
@{b}     unsigned long long@{ub}, 64 bit unsigned integral type.

@{b}-33@{ub}
@{b}     logical*8@{ub}, 64 bit unsigned integral type.

@{b}-34@{ub}
@{b}     integer*8@{ub}, 64 bit signed integral type.


@endnode

@node "Miscellaneous Types" "stabs.guide/Miscellaneous Types"
@next "Cross-References"
@prev "Builtin Types"
@toc "Types"

Miscellaneous Types
===================

@{b}b TYPE-INFORMATION ; BYTES@{ub}
     Pascal space type.  This is documented by IBM; what does it mean?

     This use of the @{b}b@{ub} type descriptor can be distinguished from its
     use for builtin integral types (see @{"Builtin Type Descriptors" link "Builtin Type Descriptors"})
     because the character following the type descriptor is always a
     digit, @{b}(@{ub}, or @{b}-@{ub}.

@{b}B TYPE-INFORMATION@{ub}
     A volatile-qualified version of TYPE-INFORMATION.  This is a Sun
     extension.  References and stores to a variable with a
     volatile-qualified type must not be optimized or cached; they must
     occur as the user specifies them.

@{b}d TYPE-INFORMATION@{ub}
     File of type TYPE-INFORMATION.  As far as I know this is only used
     by Pascal.

@{b}k TYPE-INFORMATION@{ub}
     A const-qualified version of TYPE-INFORMATION.  This is a Sun
     extension.  A variable with a const-qualified type cannot be
     modified.

@{b}M TYPE-INFORMATION ; LENGTH@{ub}
     Multiple instance type.  The type seems to composed of LENGTH
     repetitions of TYPE-INFORMATION, for example @{b}character*3@{ub} is
     represented by @{b}M-2;3@{ub}, where @{b}-2@{ub} is a reference to a character type
     (see @{"Negative Type Numbers" link "Negative Type Numbers"}).  I'm not sure how this differs from
     an array.  This appears to be a Fortran feature.  LENGTH is a
     bound, like those in range types; see @{"Subranges" link "Subranges"}.

@{b}S TYPE-INFORMATION@{ub}
     Pascal set type.  TYPE-INFORMATION must be a small type such as an
     enumeration or a subrange, and the type is a bitmask whose length
     is specified by the number of elements in TYPE-INFORMATION.

     In CHILL, if it is a bitstring instead of a set, also use the @{b}S@{ub}
     type attribute (see @{"String Field" link "String Field"}).

@{b}* TYPE-INFORMATION@{ub}
     Pointer to TYPE-INFORMATION.


@endnode

@node "Cross-References" "stabs.guide/Cross-References"
@next "Subranges"
@prev "Miscellaneous Types"
@toc "Types"

Cross-References to Other Types
===============================

   A type can be used before it is defined; one common way to deal with
that situation is just to use a type reference to a type which has not
yet been defined.

   Another way is with the @{b}x@{ub} type descriptor, which is followed by @{b}s@{ub}
for a structure tag, @{b}u@{ub} for a union tag, or @{b}e@{ub} for a enumerator tag,
followed by the name of the tag, followed by @{b}:@{ub}.  If the name contains
@{b}::@{ub} between a @{b}<@{ub} and @{b}>@{ub} pair (for C++ templates), such a @{b}::@{ub} does not end
the name--only a single @{b}:@{ub} ends the name; see @{"Nested Symbols" link "Nested Symbols"}.

   For example, the following C declarations:

     struct foo;
     struct foo *bar;

produce:

     .stabs "bar:G16=*17=xsfoo:",32,0,0,0

   Not all debuggers support the @{b}x@{ub} type descriptor, so on some machines
GCC does not use it.  I believe that for the above example it would
just emit a reference to type 17 and never define it, but I haven't
verified that.

   Modula-2 imported types, at least on AIX, use the @{b}i@{ub} type descriptor,
which is followed by the name of the module from which the type is
imported, followed by @{b}:@{ub}, followed by the name of the type.  There is
then optionally a comma followed by type information for the type.
This differs from merely naming the type (see @{"Typedefs" link "Typedefs"}) in that it
identifies the module; I don't understand whether the name of the type
given here is always just the same as the name we are giving it, or
whether this type descriptor is used with a nameless stab (see
@{"String Field" link "String Field"}), or what.  The symbol ends with @{b};@{ub}.


@endnode

@node "Subranges" "stabs.guide/Subranges"
@next "Arrays"
@prev "Cross-References"
@toc "Types"

Subrange Types
==============

   The @{b}r@{ub} type descriptor defines a type as a subrange of another type.
It is followed by type information for the type of which it is a
subrange, a semicolon, an integral lower bound, a semicolon, an
integral upper bound, and a semicolon.  The AIX documentation does not
specify the trailing semicolon, in an effort to specify array indexes
more cleanly, but a subrange which is not an array index has always
included a trailing semicolon (see @{"Arrays" link "Arrays"}).

   Instead of an integer, either bound can be one of the following:

@{b}A OFFSET@{ub}
     The bound is passed by reference on the stack at offset OFFSET
     from the argument list.  See @{"Parameters" link "Parameters"}, for more information on
     such offsets.

@{b}T OFFSET@{ub}
     The bound is passed by value on the stack at offset OFFSET from
     the argument list.

@{b}a REGISTER-NUMBER@{ub}
     The bound is pased by reference in register number REGISTER-NUMBER.

@{b}t REGISTER-NUMBER@{ub}
     The bound is passed by value in register number REGISTER-NUMBER.

@{b}J@{ub}
     There is no bound.

   Subranges are also used for builtin types; see
@{"Traditional Builtin Types" link "Traditional Builtin Types"}.


@endnode

@node "Arrays" "stabs.guide/Arrays"
@next "Strings"
@prev "Subranges"
@toc "Types"

Array Types
===========

   Arrays use the @{b}a@{ub} type descriptor.  Following the type descriptor is
the type of the index and the type of the array elements.  If the index
type is a range type, it ends in a semicolon; otherwise (for example,
if it is a type reference), there does not appear to be any way to tell
where the types are separated.  In an effort to clean up this mess, IBM
documents the two types as being separated by a semicolon, and a range
type as not ending in a semicolon (but this is not right for range
types which are not array indexes, see @{"Subranges" link "Subranges"}).  I think probably
the best solution is to specify that a semicolon ends a range type, and
that the index type and element type of an array are separated by a
semicolon, but that if the index type is a range type, the extra
semicolon can be omitted.  GDB (at least through version 4.9) doesn't
support any kind of index type other than a range anyway; I'm not sure
about dbx.

   It is well established, and widely used, that the type of the index,
unlike most types found in the stabs, is merely a type definition, not
type information (see @{"String Field" link "String Field"}) (that is, it need not start with
@{b}TYPE-NUMBER=@{ub} if it is defining a new type).  According to a comment in
GDB, this is also true of the type of the array elements; it gives
@{b}ar1;1;10;ar1;1;10;4@{ub} as a legitimate way to express a two dimensional
array.  According to AIX documentation, the element type must be type
information.  GDB accepts either.

   The type of the index is often a range type, expressed as the type
descriptor @{b}r@{ub} and some parameters.  It defines the size of the array.
In the example below, the range @{b}r1;0;2;@{ub} defines an index type which is
a subrange of type 1 (integer), with a lower bound of 0 and an upper
bound of 2.  This defines the valid range of subscripts of a
three-element C array.

   For example, the definition:

     char char_vec[3] = {'a','b','c'};

produces the output:

     .stabs "char_vec:G19=ar1;0;2;2",32,0,0,0
          .global _char_vec
          .align 4
     _char_vec:
          .byte 97
          .byte 98
          .byte 99

   If an array is @{i}packed@{ui}, the elements are spaced more closely than
normal, saving memory at the expense of speed.  For example, an array
of 3-byte objects might, if unpacked, have each element aligned on a
4-byte boundary, but if packed, have no padding.  One way to specify
that something is packed is with type attributes (see @{"String Field" link "String Field"}).
In the case of arrays, another is to use the @{b}P@{ub} type descriptor instead
of @{b}a@{ub}.  Other than specifying a packed array, @{b}P@{ub} is identical to @{b}a@{ub}.

   An open array is represented by the @{b}A@{ub} type descriptor followed by
type information specifying the type of the array elements.

   An N-dimensional dynamic array is represented by

     D DIMENSIONS ; TYPE-INFORMATION

   DIMENSIONS is the number of dimensions; TYPE-INFORMATION specifies
the type of the array elements.

   A subarray of an N-dimensional array is represented by

     E DIMENSIONS ; TYPE-INFORMATION

   DIMENSIONS is the number of dimensions; TYPE-INFORMATION specifies
the type of the array elements.


@endnode

@node "Strings" "stabs.guide/Strings"
@next "Enumerations"
@prev "Arrays"
@toc "Types"

Strings
=======

   Some languages, like C or the original Pascal, do not have string
types, they just have related things like arrays of characters.  But
most Pascals and various other languages have string types, which are
indicated as follows:

@{b}n TYPE-INFORMATION ; BYTES@{ub}
     BYTES is the maximum length.  I'm not sure what TYPE-INFORMATION
     is; I suspect that it means that this is a string of
     TYPE-INFORMATION (thus allowing a string of integers, a string of
     wide characters, etc., as well as a string of characters).  Not
     sure what the format of this type is.  This is an AIX feature.

@{b}z TYPE-INFORMATION ; BYTES@{ub}
     Just like @{b}n@{ub} except that this is a gstring, not an ordinary string.
     I don't know the difference.

@{b}N@{ub}
     Pascal Stringptr.  What is this?  This is an AIX feature.

   Languages, such as CHILL which have a string type which is basically
just an array of characters use the @{b}S@{ub} type attribute (see
@{"String Field" link "String Field"}).


@endnode

@node "Enumerations" "stabs.guide/Enumerations"
@next "Structures"
@prev "Strings"
@toc "Types"

Enumerations
============

   Enumerations are defined with the @{b}e@{ub} type descriptor.

   The source line below declares an enumeration type at file scope.
The type definition is located after the @{b}N_RBRAC@{ub} that marks the end of
the previous procedure's block scope, and before the @{b}N_FUN@{ub} that marks
the beginning of the next procedure's block scope.  Therefore it does
not describe a block local symbol, but a file local one.

   The source line:

     enum e_places {first,second=3,last};

generates the following stab:

     .stabs "e_places:T22=efirst:0,second:3,last:4,;",128,0,0,0

   The symbol descriptor (@{b}T@{ub}) says that the stab describes a structure,
enumeration, or union tag.  The type descriptor @{b}e@{ub}, following the @{b}22=@{ub} of
the type definition narrows it down to an enumeration type.  Following
the @{b}e@{ub} is a list of the elements of the enumeration.  The format is
@{b}NAME:VALUE,@{ub}.  The list of elements ends with @{b};@{ub}.  The fact that VALUE is
specified as an integer can cause problems if the value is large.  GCC
2.5.2 tries to output it in octal in that case with a leading zero,
which is probably a good thing, although GDB 4.11 supports octal only in
cases where decimal is perfectly good.  Negative decimal values are
supported by both GDB and dbx.

   There is no standard way to specify the size of an enumeration type;
it is determined by the architecture (normally all enumerations types
are 32 bits).  Type attributes can be used to specify an enumeration
type of another size for debuggers which support them; see
@{"String Field" link "String Field"}.

   Enumeration types are unusual in that they define symbols for the
enumeration values (@{b}first@{ub}, @{b}second@{ub}, and @{b}third@{ub} in the above example), and
even though these symbols are visible in the file as a whole (rather
than being in a more local namespace like structure member names), they
are defined in the type definition for the enumeration type rather than
each having their own symbol.  In order to be fast, GDB will only get
symbols from such types (in its initial scan of the stabs) if the type
is the first thing defined after a @{b}T@{ub} or @{b}t@{ub} symbol descriptor (the above
example fulfills this requirement).  If the type does not have a name,
the compiler should emit it in a nameless stab (see @{"String Field" link "String Field"}); GCC
does this.


@endnode

@node "Structures" "stabs.guide/Structures"
@next "Typedefs"
@prev "Enumerations"
@toc "Types"

Structures
==========

   The encoding of structures in stabs can be shown with an example.

   The following source code declares a structure tag and defines an
instance of the structure in global scope. Then a @{b}typedef@{ub} equates the
structure tag with a new type.  Seperate stabs are generated for the
structure tag, the structure @{b}typedef@{ub}, and the structure instance.  The
stabs for the tag and the @{b}typedef@{ub} are emited when the definitions are
encountered.  Since the structure elements are not initialized, the
stab and code for the structure variable itself is located at the end
of the program in the bss section.

     struct s_tag {
       int   s_int;
       float s_float;
       char  s_char_vec[8];
       struct s_tag* s_next;
     } g_an_s;
     
     typedef struct s_tag s_typedef;

   The structure tag has an @{b}N_LSYM@{ub} stab type because, like the
enumeration, the symbol has file scope.  Like the enumeration, the
symbol descriptor is @{b}T@{ub}, for enumeration, structure, or tag type.  The
type descriptor @{b}s@{ub} following the @{b}16=@{ub} of the type definition narrows the
symbol type to structure.

   Following the @{b}s@{ub} type descriptor is the number of bytes the structure
occupies, followed by a description of each structure element.  The
structure element descriptions are of the form NAME:TYPE, BIT OFFSET
FROM THE START OF THE STRUCT, NUMBER OF BITS IN THE ELEMENT.

     # 128 is N_LSYM
     .stabs "s_tag:T16=s20s_int:1,0,32;s_float:12,32,32;
             s_char_vec:17=ar1;0;7;2,64,64;s_next:18=*16,128,32;;",128,0,0,0

   In this example, the first two structure elements are previously
defined types.  For these, the type following the @{b}NAME:@{ub} part of the
element description is a simple type reference.  The other two structure
elements are new types.  In this case there is a type definition
embedded after the @{b}NAME:@{ub}.  The type definition for the array element
looks just like a type definition for a standalone array.  The @{b}s_next@{ub}
field is a pointer to the same kind of structure that the field is an
element of.  So the definition of structure type 16 contains a type
definition for an element which is a pointer to type 16.

   If a field is a static member (this is a C++ feature in which a
single variable appears to be a field of every structure of a given
type) it still starts out with the field name, a colon, and the type,
but then instead of a comma, bit position, comma, and bit size, there
is a colon followed by the name of the variable which each such field
refers to.

   If the structure has methods (a C++ feature), they follow the
non-method fields; see @{"Cplusplus" link "Cplusplus"}.


@endnode

@node "Typedefs" "stabs.guide/Typedefs"
@next "Unions"
@prev "Structures"
@toc "Types"

Giving a Type a Name
====================

   To give a type a name, use the @{b}t@{ub} symbol descriptor.  The type is
specified by the type information (see @{"String Field" link "String Field"}) for the stab.
For example,

     .stabs "s_typedef:t16",128,0,0,0     # 128 is N_LSYM

   specifies that @{b}s_typedef@{ub} refers to type number 16.  Such stabs have
symbol type @{b}N_LSYM@{ub} (or @{b}C_DECL@{ub} for XCOFF).

   If you are specifying the tag name for a structure, union, or
enumeration, use the @{b}T@{ub} symbol descriptor instead.  I believe C is the
only language with this feature.

   If the type is an opaque type (I believe this is a Modula-2 feature),
AIX provides a type descriptor to specify it.  The type descriptor is @{b}o@{ub}
and is followed by a name.  I don't know what the name means--is it
always the same as the name of the type, or is this type descriptor
used with a nameless stab (see @{"String Field" link "String Field"})?  There optionally
follows a comma followed by type information which defines the type of
this type.  If omitted, a semicolon is used in place of the comma and
the type information, and the type is much like a generic pointer
type--it has a known size but little else about it is specified.


@endnode

@node "Unions" "stabs.guide/Unions"
@next "Function Types"
@prev "Typedefs"
@toc "Types"

Unions
======

     union u_tag {
       int  u_int;
       float u_float;
       char* u_char;
     } an_u;

   This code generates a stab for a union tag and a stab for a union
variable.  Both use the @{b}N_LSYM@{ub} stab type.  If a union variable is
scoped locally to the procedure in which it is defined, its stab is
located immediately preceding the @{b}N_LBRAC@{ub} for the procedure's block
start.

   The stab for the union tag, however, is located preceding the code
for the procedure in which it is defined.  The stab type is @{b}N_LSYM@{ub}.
This would seem to imply that the union type is file scope, like the
struct type @{b}s_tag@{ub}.  This is not true.  The contents and position of the
stab for @{b}u_type@{ub} do not convey any infomation about its procedure local
scope.

     # 128 is N_LSYM
     .stabs "u_tag:T23=u4u_int:1,0,32;u_float:12,0,32;u_char:21,0,32;;",
            128,0,0,0

   The symbol descriptor @{b}T@{ub}, following the @{b}name:@{ub} means that the stab
describes an enumeration, structure, or union tag.  The type descriptor
@{b}u@{ub}, following the @{b}23=@{ub} of the type definition, narrows it down to a union
type definition.  Following the @{b}u@{ub} is the number of bytes in the union.
After that is a list of union element descriptions.  Their format is
NAME:TYPE, BIT OFFSET INTO THE UNION, NUMBER OF BYTES FOR THE ELEMENT;.

   The stab for the union variable is:

     .stabs "an_u:23",128,0,0,-20     # 128 is N_LSYM

@{b}   -20@{ub} specifies where the variable is stored (see @{"Stack Variables" link "Stack Variables"}).


@endnode

@node "Function Types" "stabs.guide/Function Types"
@prev "Unions"
@toc "Types"

Function Types
==============

   Various types can be defined for function variables.  These types are
not used in defining functions (see @{"Procedures" link "Procedures"}); they are used for
things like pointers to functions.

   The simple, traditional, type is type descriptor @{b}f@{ub} is followed by
type information for the return type of the function, followed by a
semicolon.

   This does not deal with functions for which the number and types of
the parameters are part of the type, as in Modula-2 or ANSI C.  AIX
provides extensions to specify these, using the @{b}f@{ub}, @{b}F@{ub}, @{b}p@{ub}, and @{b}R@{ub} type
descriptors.

   First comes the type descriptor.  If it is @{b}f@{ub} or @{b}F@{ub}, this type
involves a function rather than a procedure, and the type information
for the return type of the function follows, followed by a comma.  Then
comes the number of parameters to the function and a semicolon.  Then,
for each parameter, there is the name of the parameter followed by a
colon (this is only present for type descriptors @{b}R@{ub} and @{b}F@{ub} which
represent Pascal function or procedure parameters), type information
for the parameter, a comma, 0 if passed by reference or 1 if passed by
value, and a semicolon.  The type definition ends with a semicolon.

   For example, this variable definition:

     int (*g_pf)();

generates the following code:

     .stabs "g_pf:G24=*25=f1",32,0,0,0
         .common _g_pf,4,"bss"

   The variable defines a new type, 24, which is a pointer to another
new type, 25, which is a function returning @{b}int@{ub}.


@endnode

@node "Symbol Tables" "stabs.guide/Symbol Tables"
@next "Cplusplus"
@prev "Types"
@toc "Main"

Symbol Information in Symbol Tables
***********************************

   This chapter describes the format of symbol table entries and how
stab assembler directives map to them.  It also describes the
transformations that the assembler and linker make on data from stabs.


 @{" Symbol Table Format " link "Symbol Table Format"}  
 @{" Transformations On Symbol Tables " link "Transformations On Symbol Tables"}


@endnode

@node "Symbol Table Format" "stabs.guide/Symbol Table Format"
@next "Transformations On Symbol Tables"
@toc "Symbol Tables"

Symbol Table Format
===================

   Each time the assembler encounters a stab directive, it puts each
field of the stab into a corresponding field in a symbol table entry of
its output file.  If the stab contains a string field, the symbol table
entry for that stab points to a string table entry containing the
string data from the stab.  Assembler labels become relocatable
addresses.  Symbol table entries in a.out have the format:

     struct internal_nlist {
       unsigned long n_strx;         /* index into string table of name */
       unsigned char n_type;         /* type of symbol */
       unsigned char n_other;        /* misc info (usually empty) */
       unsigned short n_desc;        /* description field */
       bfd_vma n_value;              /* value of symbol */
     };

   If the stab has a string, the @{b}n_strx@{ub} field holds the offset in bytes
of the string within the string table.  The string is terminated by a
NUL character.  If the stab lacks a string (for example, it was
produced by a @{b}.stabn@{ub} or @{b}.stabd@{ub} directive), the @{b}n_strx@{ub} field is zero.

   Symbol table entries with @{b}n_type@{ub} field values greater than 0x1f
originated as stabs generated by the compiler (with one random
exception).  The other entries were placed in the symbol table of the
executable by the assembler or the linker.


@endnode

@node "Transformations On Symbol Tables" "stabs.guide/Transformations On Symbol Tables"
@prev "Symbol Table Format"
@toc "Symbol Tables"

Transformations on Symbol Tables
================================

   The linker concatenates object files and does fixups of externally
defined symbols.

   You can see the transformations made on stab data by the assembler
and linker by examining the symbol table after each pass of the build.
To do this, use @{b}nm -ap@{ub}, which dumps the symbol table, including
debugging information, unsorted.  For stab entries the columns are:
VALUE, OTHER, DESC, TYPE, STRING.  For assembler and linker symbols,
the columns are: VALUE, TYPE, STRING.

   The low 5 bits of the stab type tell the linker how to relocate the
value of the stab.  Thus for stab types like @{b}N_RSYM@{ub} and @{b}N_LSYM@{ub}, where
the value is an offset or a register number, the low 5 bits are @{b}N_ABS@{ub},
which tells the linker not to relocate the value.

   Where the value of a stab contains an assembly language label, it is
transformed by each build step.  The assembler turns it into a
relocatable address and the linker turns it into an absolute address.


 @{" Transformations On Static Variables " link "Transformations On Static Variables"}  
 @{" Transformations On Global Variables " link "Transformations On Global Variables"}  
 @{" Stab Section Transformations      " link "Stab Section Transformations"}  For some object file formats,
                                           things are a bit different.


@endnode

@node "Transformations On Static Variables" "stabs.guide/Transformations On Static Variables"
@next "Transformations On Global Variables"
@toc "Transformations On Symbol Tables"

Transformations on Static Variables
-----------------------------------

   This source line defines a static variable at file scope:

     static int s_g_repeat

The following stab describes the symbol:

     .stabs "s_g_repeat:S1",38,0,0,_s_g_repeat

The assembler transforms the stab into this symbol table entry in the
@{b}.o@{ub} file.  The location is expressed as a data segment offset.

     00000084 - 00 0000 STSYM s_g_repeat:S1

In the symbol table entry from the executable, the linker has made the
relocatable address absolute.

     0000e00c - 00 0000 STSYM s_g_repeat:S1


@endnode

@node "Transformations On Global Variables" "stabs.guide/Transformations On Global Variables"
@next "Stab Section Transformations"
@prev "Transformations On Static Variables"
@toc "Transformations On Symbol Tables"

Transformations on Global Variables
-----------------------------------

   Stabs for global variables do not contain location information. In
this case, the debugger finds location information in the assembler or
linker symbol table entry describing the variable.  The source line:

     char g_foo = 'c';

generates the stab:

     .stabs "g_foo:G2",32,0,0,0

   The variable is represented by two symbol table entries in the object
file (see below).  The first one originated as a stab.  The second one
is an external symbol.  The upper case @{b}D@{ub} signifies that the @{b}n_type@{ub}
field of the symbol table contains 7, @{b}N_DATA@{ub} with local linkage.  The
stab's value is zero since the value is not used for @{b}N_GSYM@{ub} stabs.  The
value of the linker symbol is the relocatable address corresponding to
the variable.

     00000000 - 00 0000  GSYM g_foo:G2
     00000080 D _g_foo

These entries as transformed by the linker.  The linker symbol table
entry now holds an absolute address:

     00000000 - 00 0000  GSYM g_foo:G2
     ...
     0000e008 D _g_foo


@endnode

@node "Stab Section Transformations" "stabs.guide/Stab Section Transformations"
@prev "Transformations On Global Variables"
@toc "Transformations On Symbol Tables"

Transformations of Stabs in separate sections
---------------------------------------------

   For object file formats using stabs in separate sections (see
@{"Stab Sections" link "Stab Sections"}), use @{b}objdump --stabs@{ub} instead of @{b}nm@{ub} to show the stabs
in an object or executable file.  @{b}objdump@{ub} is a GNU utility; Sun does
not provide any equivalent.

   The following example is for a stab whose value is an address is
relative to the compilation unit (see @{"ELF Linker Relocation" link "ELF Linker Relocation"}).  For
example, if the source line

     static int ld = 5;

   appears within a function, then the assembly language output from the
compiler contains:

     .Ddata.data:
     ...
             .stabs "ld:V(0,3)",0x26,0,4,.L18-Ddata.data    # 0x26 is N_STSYM
     ...
     .L18:
             .align 4
             .word 0x5

   Because the value is formed by subtracting one symbol from another,
the value is absolute, not relocatable, and so the object file contains

     Symnum n_type n_othr n_desc n_value  n_strx String
     31     STSYM  0      4      00000004 680    ld:V(0,3)

   without any relocations, and the executable file also contains

     Symnum n_type n_othr n_desc n_value  n_strx String
     31     STSYM  0      4      00000004 680    ld:V(0,3)


@endnode

@node "Cplusplus" "stabs.guide/Cplusplus"
@next "Stab Types"
@prev "Symbol Tables"
@toc "Main"

GNU C++ Stabs
*************


 @{" Class Names               " link "Class Names"}  C++ class names are both tags and typedefs.
 @{" Nested Symbols            " link "Nested Symbols"}  C++ symbol names can be within other types.
 @{" Basic Cplusplus Types     " link "Basic Cplusplus Types"}  
 @{" Simple Classes            " link "Simple Classes"}  
 @{" Class Instance            " link "Class Instance"}  
 @{" Methods                   " link "Methods"}  Method definition
 @{" Method Type Descriptor    " link "Method Type Descriptor"}  The @{b}#@{ub} type descriptor
 @{" Member Type Descriptor    " link "Member Type Descriptor"}  The @{b}\@@{ub} type descriptor
 @{" Protections               " link "Protections"}  
 @{" Method Modifiers          " link "Method Modifiers"}  
 @{" Virtual Methods           " link "Virtual Methods"}  
 @{" Inheritence               " link "Inheritence"}  
 @{" Virtual Base Classes      " link "Virtual Base Classes"}  
 @{" Static Members            " link "Static Members"}


@endnode

@node "Class Names" "stabs.guide/Class Names"
@next "Nested Symbols"
@toc "Cplusplus"

C++ Class Names
===============

   In C++, a class name which is declared with @{b}class@{ub}, @{b}struct@{ub}, or @{b}union@{ub},
is not only a tag, as in C, but also a type name.  Thus there should be
stabs with both @{b}t@{ub} and @{b}T@{ub} symbol descriptors (see @{"Typedefs" link "Typedefs"}).

   To save space, there is a special abbreviation for this case.  If the
@{b}T@{ub} symbol descriptor is followed by @{b}t@{ub}, then the stab defines both a type
name and a tag.

   For example, the C++ code

     struct foo {int x;};

   can be represented as either

     .stabs "foo:T19=s4x:1,0,32;;",128,0,0,0       # 128 is N_LSYM
     .stabs "foo:t19",128,0,0,0

   or

     .stabs "foo:Tt19=s4x:1,0,32;;",128,0,0,0


@endnode

@node "Nested Symbols" "stabs.guide/Nested Symbols"
@next "Basic Cplusplus Types"
@prev "Class Names"
@toc "Cplusplus"

Defining a Symbol Within Another Type
=====================================

   In C++, a symbol (such as a type name) can be defined within another
type.

   In stabs, this is sometimes represented by making the name of a
symbol which contains @{b}::@{ub}.  Such a pair of colons does not end the name
of the symbol, the way a single colon would (see @{"String Field" link "String Field"}).  I'm
not sure how consistently used or well thought out this mechanism is.
So that a pair of colons in this position always has this meaning, @{b}:@{ub}
cannot be used as a symbol descriptor.

   For example, if the string for a stab is @{b}foo::bar::baz:t5=*6@{ub}, then
@{b}foo::bar::baz@{ub} is the name of the symbol, @{b}t@{ub} is the symbol descriptor,
and @{b}5=*6@{ub} is the type information.


@endnode

@node "Basic Cplusplus Types" "stabs.guide/Basic Cplusplus Types"
@next "Simple Classes"
@prev "Nested Symbols"
@toc "Cplusplus"

Basic Types For C++
===================

   << the examples that follow are based on a01.C >>

   C++ adds two more builtin types to the set defined for C.  These are
the unknown type and the vtable record type.  The unknown type, type
16, is defined in terms of itself like the void type.

   The vtable record type, type 17, is defined as a structure type and
then as a structure tag.  The structure has four fields: delta, index,
pfn, and delta2.  pfn is the function pointer.

   << In boilerplate $vtbl_ptr_type, what are the fields delta, index,
and delta2 used for? >>

   This basic type is present in all C++ programs even if there are no
virtual methods defined.

     .stabs "struct_name:sym_desc(type)type_def(17)=type_desc(struct)struct_bytes(8)
             elem_name(delta):type_ref(short int),bit_offset(0),field_bits(16);
             elem_name(index):type_ref(short int),bit_offset(16),field_bits(16);
             elem_name(pfn):type_def(18)=type_desc(ptr to)type_ref(void),
                                         bit_offset(32),field_bits(32);
             elem_name(delta2):type_def(short int);bit_offset(32),field_bits(16);;"
             N_LSYM, NIL, NIL

     .stabs "$vtbl_ptr_type:t17=s8
             delta:6,0,16;index:6,16,16;pfn:18=*15,32,32;delta2:6,32,16;;"
             ,128,0,0,0

     .stabs "name:sym_dec(struct tag)type_ref($vtbl_ptr_type)",N_LSYM,NIL,NIL,NIL

     .stabs "$vtbl_ptr_type:T17",128,0,0,0


@endnode

@node "Simple Classes" "stabs.guide/Simple Classes"
@next "Class Instance"
@prev "Basic Cplusplus Types"
@toc "Cplusplus"

Simple Class Definition
=======================

   The stabs describing C++ language features are an extension of the
stabs describing C.  Stabs representing C++ class types elaborate
extensively on the stab format used to describe structure types in C.
Stabs representing class type variables look just like stabs
representing C language variables.

   Consider the following very simple class definition.

     class baseA {
     public:
             int Adat;
             int Ameth(int in, char other);
     };

   The class @{b}baseA@{ub} is represented by two stabs.  The first stab
describes the class as a structure type.  The second stab describes a
structure tag of the class type.  Both stabs are of stab type @{b}N_LSYM@{ub}.
Since the stab is not located between an @{b}N_FUN@{ub} and an @{b}N_LBRAC@{ub} stab this
indicates that the class is defined at file scope.  If it were, then
the @{b}N_LSYM@{ub} would signify a local variable.

   A stab describing a C++ class type is similar in format to a stab
describing a C struct, with each class member shown as a field in the
structure.  The part of the struct format describing fields is expanded
to include extra information relevent to C++ class members.  In
addition, if the class has multiple base classes or virtual functions
the struct format outside of the field parts is also augmented.

   In this simple example the field part of the C++ class stab
representing member data looks just like the field part of a C struct
stab.  The section on protections describes how its format is sometimes
extended for member data.

   The field part of a C++ class stab representing a member function
differs substantially from the field part of a C struct stab.  It still
begins with @{b}name:@{ub} but then goes on to define a new type number for the
member function, describe its return type, its argument types, its
protection level, any qualifiers applied to the method definition, and
whether the method is virtual or not.  If the method is virtual then
the method description goes on to give the vtable index of the method,
and the type number of the first base class defining the method.

   When the field name is a method name it is followed by two colons
rather than one.  This is followed by a new type definition for the
method.  This is a number followed by an equal sign and the type of the
method.  Normally this will be a type declared using the @{b}#@{ub} type
descriptor; see @{"Method Type Descriptor" link "Method Type Descriptor"}; static member functions are
declared using the @{b}f@{ub} type descriptor instead; see @{"Function Types" link "Function Types"}.

   The format of an overloaded operator method name differs from that of
other methods.  It is @{b}op$::OPERATOR-NAME.@{ub} where OPERATOR-NAME is the
operator name such as @{b}+@{ub} or @{b}+=@{ub}.  The name ends with a period, and any
characters except the period can occur in the OPERATOR-NAME string.

   The next part of the method description represents the arguments to
the method, preceeded by a colon and ending with a semi-colon.  The
types of the arguments are expressed in the same way argument types are
expressed in C++ name mangling.  In this example an @{b}int@{ub} and a @{b}char@{ub} map
to @{b}ic@{ub}.

   This is followed by a number, a letter, and an asterisk or period,
followed by another semicolon.  The number indicates the protections
that apply to the member function.  Here the 2 means public.  The
letter encodes any qualifier applied to the method definition.  In this
case, @{b}A@{ub} means that it is a normal function definition.  The dot shows
that the method is not virtual.  The sections that follow elaborate
further on these fields and describe the additional information present
for virtual methods.

     .stabs "class_name:sym_desc(type)type_def(20)=type_desc(struct)struct_bytes(4)
             field_name(Adat):type(int),bit_offset(0),field_bits(32);
     
             method_name(Ameth)::type_def(21)=type_desc(method)return_type(int);
             :arg_types(int char);
             protection(public)qualifier(normal)virtual(no);;"
             N_LSYM,NIL,NIL,NIL

     .stabs "baseA:t20=s4Adat:1,0,32;Ameth::21=##1;:ic;2A.;;",128,0,0,0
     
     .stabs "class_name:sym_desc(struct tag)",N_LSYM,NIL,NIL,NIL
     
     .stabs "baseA:T20",128,0,0,0


@endnode

@node "Class Instance" "stabs.guide/Class Instance"
@next "Methods"
@prev "Simple Classes"
@toc "Cplusplus"

Class Instance
==============

   As shown above, describing even a simple C++ class definition is
accomplished by massively extending the stab format used in C to
describe structure types.  However, once the class is defined, C stabs
with no modifications can be used to describe class instances.  The
following source:

     main () {
             baseA AbaseA;
     }

yields the following stab describing the class instance.  It looks no
different from a standard C stab describing a local variable.

     .stabs "name:type_ref(baseA)", N_LSYM, NIL, NIL, frame_ptr_offset

     .stabs "AbaseA:20",128,0,0,-20


@endnode

@node "Methods" "stabs.guide/Methods"
@next "Method Type Descriptor"
@prev "Class Instance"
@toc "Cplusplus"

Method Definition
=================

   The class definition shown above declares Ameth.  The C++ source
below defines Ameth:

     int
     baseA::Ameth(int in, char other)
     {
             return in;
     };

   This method definition yields three stabs following the code of the
method.  One stab describes the method itself and following two describe
its parameters.  Although there is only one formal argument all methods
have an implicit argument which is the @{b}this@{ub} pointer.  The @{b}this@{ub} pointer
is a pointer to the object on which the method was called.  Note that
the method name is mangled to encode the class name and argument types.
Name mangling is described in the ARM (`The Annotated C++ Reference
Manual', by Ellis and Stroustrup, ISBN 0-201-51459-1); @{b}gpcompare.texi@{ub}
in Cygnus GCC distributions describes the differences between GNU
mangling and ARM mangling.

     .stabs "name:symbol_desriptor(global function)return_type(int)",
             N_FUN, NIL, NIL, code_addr_of_method_start
     
     .stabs "Ameth__5baseAic:F1",36,0,0,_Ameth__5baseAic

   Here is the stab for the @{b}this@{ub} pointer implicit argument.  The name
of the @{b}this@{ub} pointer is always @{b}this@{ub}.  Type 19, the @{b}this@{ub} pointer is
defined as a pointer to type 20, @{b}baseA@{ub}, but a stab defining @{b}baseA@{ub} has
not yet been emited.  Since the compiler knows it will be emited
shortly, here it just outputs a cross reference to the undefined
symbol, by prefixing the symbol name with @{b}xs@{ub}.

     .stabs "name:sym_desc(register param)type_def(19)=
             type_desc(ptr to)type_ref(baseA)=
             type_desc(cross-reference to)baseA:",N_RSYM,NIL,NIL,register_number
     
     .stabs "this:P19=*20=xsbaseA:",64,0,0,8

   The stab for the explicit integer argument looks just like a
parameter to a C function.  The last field of the stab is the offset
from the argument pointer, which in most systems is the same as the
frame pointer.

     .stabs "name:sym_desc(value parameter)type_ref(int)",
             N_PSYM,NIL,NIL,offset_from_arg_ptr
     
     .stabs "in:p1",160,0,0,72

   << The examples that follow are based on A1.C >>


@endnode

@node "Method Type Descriptor" "stabs.guide/Method Type Descriptor"
@next "Member Type Descriptor"
@prev "Methods"
@toc "Cplusplus"

The @{b}#@{ub} Type Descriptor
=====================

   This is like the @{b}f@{ub} type descriptor for functions (see
@{"Function Types" link "Function Types"}), except that a function which uses the @{b}#@{ub} type
descriptor takes an extra argument as its first argument, for the @{b}this@{ub}
pointer.  The @{b}#@{ub} type descriptor is optionally followed by the types of
the arguments, then another @{b}#@{ub}.  If the types of the arguments are
omitted, so that the second @{b}#@{ub} immediately follows the @{b}#@{ub} which is the
type descriptor, the arguments are being omitted (to save space) and
can be deduced from the mangled name of the method.  After the second @{b}#@{ub}
there is type information for the return type of the method and a
semicolon.

   Note that although such a type will normally be used to describe
fields in structures, unions, or classes, for at least some versions of
the compiler it can also be used in other contexts.


@endnode

@node "Member Type Descriptor" "stabs.guide/Member Type Descriptor"
@next "Protections"
@prev "Method Type Descriptor"
@toc "Cplusplus"

The @{b}\@@{ub} Type Descriptor
=====================

   The @{b}\@@{ub} type descriptor is for a member (class and variable) type.  It
is followed by type information for the offset basetype, a comma, and
type information for the type of the field being pointed to.  (FIXME:
this is acknowledged to be gibberish.  Can anyone say what really goes
here?).

   Note that there is a conflict between this and type attributes (see
@{"String Field" link "String Field"}); both use type descriptor @{b}\@@{ub}.  Fortunately, the @{b}\@@{ub} type
descriptor used in this C++ sense always will be followed by a digit,
@{b}(@{ub}, or @{b}-@{ub}, and type attributes never start with those things.


@endnode

@node "Protections" "stabs.guide/Protections"
@next "Method Modifiers"
@prev "Member Type Descriptor"
@toc "Cplusplus"

Protections
===========

   In the simple class definition shown above all member data and
functions were publicly accessable.  The example that follows contrasts
public, protected and privately accessable fields and shows how these
protections are encoded in C++ stabs.

   If the character following the @{b}FIELD-NAME:@{ub} part of the string is @{b}/@{ub},
then the next character is the visibility.  @{b}0@{ub} means private, @{b}1@{ub} means
protected, and @{b}2@{ub} means public.  Debuggers should ignore visibility
characters they do not recognize, and assume a reasonable default (such
as public) (GDB 4.11 does not, but this should be fixed in the next GDB
release).  If no visibility is specified the field is public.  The
visibility @{b}9@{ub} means that the field has been optimized out and is public
(there is no way to specify an optimized out field with a private or
protected visibility).  Visibility @{b}9@{ub} is not supported by GDB 4.11; this
should be fixed in the next GDB release.

   The following C++ source:

     class vis {
     private:
             int   priv;
     protected:
             char  prot;
     public:
             float pub;
     };

generates the following stab:

     # 128 is N_LSYM
     .stabs "vis:T19=s12priv:/01,0,32;prot:/12,32,8;pub:12,64,32;;",128,0,0,0

@{b}   vis:T19=s12@{ub} indicates that type number 19 is a 12 byte structure
named @{b}vis@{ub} The @{b}priv@{ub} field has public visibility (@{b}/0@{ub}), type int (@{b}1@{ub}), and
offset and size @{b},0,32;@{ub}.  The @{b}prot@{ub} field has protected visibility (@{b}/1@{ub}),
type char (@{b}2@{ub}) and offset and size @{b},32,8;@{ub}.  The @{b}pub@{ub} field has type float
(@{b}12@{ub}), and offset and size @{b},64,32;@{ub}.

   Protections for member functions are signified by one digit embeded
in the field part of the stab describing the method.  The digit is 0 if
private, 1 if protected and 2 if public.  Consider the C++ class
definition below:

     class all_methods {
     private:
             int   priv_meth(int in){return in;};
     protected:
             char  protMeth(char in){return in;};
     public:
             float pubMeth(float in){return in;};
     };

   It generates the following stab.  The digit in question is to the
left of an @{b}A@{ub} in each case.  Notice also that in this case two symbol
descriptors apply to the class name struct tag and struct type.

     .stabs "class_name:sym_desc(struct tag&type)type_def(21)=
             sym_desc(struct)struct_bytes(1)
             meth_name::type_def(22)=sym_desc(method)returning(int);
             :args(int);protection(private)modifier(normal)virtual(no);
             meth_name::type_def(23)=sym_desc(method)returning(char);
             :args(char);protection(protected)modifier(normal)virual(no);
             meth_name::type_def(24)=sym_desc(method)returning(float);
             :args(float);protection(public)modifier(normal)virtual(no);;",
             N_LSYM,NIL,NIL,NIL

     .stabs "all_methods:Tt21=s1priv_meth::22=##1;:i;0A.;protMeth::23=##2;:c;1A.;
             pubMeth::24=##12;:f;2A.;;",128,0,0,0


@endnode

@node "Method Modifiers" "stabs.guide/Method Modifiers"
@next "Virtual Methods"
@prev "Protections"
@toc "Cplusplus"

Method Modifiers (@{b}const@{ub}, @{b}volatile@{ub}, @{b}const volatile@{ub})
==================================================

   << based on a6.C >>

   In the class example described above all the methods have the normal
modifier.  This method modifier information is located just after the
protection information for the method.  This field has four possible
character values.  Normal methods use @{b}A@{ub}, const methods use @{b}B@{ub}, volatile
methods use @{b}C@{ub}, and const volatile methods use @{b}D@{ub}.  Consider the class
definition below:

     class A {
     public:
             int ConstMeth (int arg) const { return arg; };
             char VolatileMeth (char arg) volatile { return arg; };
             float ConstVolMeth (float arg) const volatile {return arg; };
     };

   This class is described by the following stab:

     .stabs "class(A):sym_desc(struct)type_def(20)=type_desc(struct)struct_bytes(1)
             meth_name(ConstMeth)::type_def(21)sym_desc(method)
             returning(int);:arg(int);protection(public)modifier(const)virtual(no);
             meth_name(VolatileMeth)::type_def(22)=sym_desc(method)
             returning(char);:arg(char);protection(public)modifier(volatile)virt(no)
             meth_name(ConstVolMeth)::type_def(23)=sym_desc(method)
             returning(float);:arg(float);protection(public)modifer(const volatile)
             virtual(no);;", ...

     .stabs "A:T20=s1ConstMeth::21=##1;:i;2B.;VolatileMeth::22=##2;:c;2C.;
                  ConstVolMeth::23=##12;:f;2D.;;",128,0,0,0


@endnode

@node "Virtual Methods" "stabs.guide/Virtual Methods"
@next "Inheritence"
@prev "Method Modifiers"
@toc "Cplusplus"

Virtual Methods
===============

   << The following examples are based on a4.C >>

   The presence of virtual methods in a class definition adds additional
data to the class description.  The extra data is appended to the
description of the virtual method and to the end of the class
description.  Consider the class definition below:

     class A {
     public:
             int Adat;
             virtual int A_virt (int arg) { return arg; };
     };

   This results in the stab below describing class A.  It defines a new
type (20) which is an 8 byte structure.  The first field of the class
struct is @{b}Adat@{ub}, an integer, starting at structure offset 0 and
occupying 32 bits.

   The second field in the class struct is not explicitly defined by the
C++ class definition but is implied by the fact that the class contains
a virtual method.  This field is the vtable pointer.  The name of the
vtable pointer field starts with @{b}$vf@{ub} and continues with a type
reference to the class it is part of.  In this example the type
reference for class A is 20 so the name of its vtable pointer field is
@{b}$vf20@{ub}, followed by the usual colon.

   Next there is a type definition for the vtable pointer type (21).
This is in turn defined as a pointer to another new type (22).

   Type 22 is the vtable itself, which is defined as an array, indexed
by a range of integers between 0 and 1, and whose elements are of type
17.  Type 17 was the vtable record type defined by the boilerplate C++
type definitions, as shown earlier.

   The bit offset of the vtable pointer field is 32.  The number of bits
in the field are not specified when the field is a vtable pointer.

   Next is the method definition for the virtual member function @{b}A_virt@{ub}.
Its description starts out using the same format as the non-virtual
member functions described above, except instead of a dot after the @{b}A@{ub}
there is an asterisk, indicating that the function is virtual.  Since
is is virtual some addition information is appended to the end of the
method description.

   The first number represents the vtable index of the method.  This is
a 32 bit unsigned number with the high bit set, followed by a
semi-colon.

   The second number is a type reference to the first base class in the
inheritence hierarchy defining the virtual member function.  In this
case the class stab describes a base class so the virtual function is
not overriding any other definition of the method.  Therefore the
reference is to the type number of the class that the stab is
describing (20).

   This is followed by three semi-colons.  One marks the end of the
current sub-section, one marks the end of the method field, and the
third marks the end of the struct definition.

   For classes containing virtual functions the very last section of the
string part of the stab holds a type reference to the first base class.
This is preceeded by @{b}~%@{ub} and followed by a final semi-colon.

     .stabs "class_name(A):type_def(20)=sym_desc(struct)struct_bytes(8)
             field_name(Adat):type_ref(int),bit_offset(0),field_bits(32);
             field_name(A virt func ptr):type_def(21)=type_desc(ptr to)type_def(22)=
             sym_desc(array)index_type_ref(range of int from 0 to 1);
             elem_type_ref(vtbl elem type),
             bit_offset(32);
             meth_name(A_virt)::typedef(23)=sym_desc(method)returning(int);
             :arg_type(int),protection(public)normal(yes)virtual(yes)
             vtable_index(1);class_first_defining(A);;;~%first_base(A);",
             N_LSYM,NIL,NIL,NIL

     .stabs "A:t20=s8Adat:1,0,32;$vf20:21=*22=ar1;0;1;17,32;
             A_virt::23=##1;:i;2A*-2147483647;20;;;~%20;",128,0,0,0


@endnode

@node "Inheritence" "stabs.guide/Inheritence"
@next "Virtual Base Classes"
@prev "Virtual Methods"
@toc "Cplusplus"

Inheritence
===========

   Stabs describing C++ derived classes include additional sections that
describe the inheritence hierarchy of the class.  A derived class stab
also encodes the number of base classes.  For each base class it tells
if the base class is virtual or not, and if the inheritence is private
or public.  It also gives the offset into the object of the portion of
the object corresponding to each base class.

   This additional information is embeded in the class stab following
the number of bytes in the struct.  First the number of base classes
appears bracketed by an exclamation point and a comma.

   Then for each base type there repeats a series: a virtual character,
a visibilty character, a number, a comma, another number, and a
semi-colon.

   The virtual character is @{b}1@{ub} if the base class is virtual and @{b}0@{ub} if
not.  The visibility character is @{b}2@{ub} if the derivation is public, @{b}1@{ub} if
it is protected, and @{b}0@{ub} if it is private.  Debuggers should ignore
virtual or visibility characters they do not recognize, and assume a
reasonable default (such as public and non-virtual) (GDB 4.11 does not,
but this should be fixed in the next GDB release).

   The number following the virtual and visibility characters is the
offset from the start of the object to the part of the object
pertaining to the base class.

   After the comma, the second number is a type_descriptor for the base
type.  Finally a semi-colon ends the series, which repeats for each
base class.

   The source below defines three base classes @{b}A@{ub}, @{b}B@{ub}, and @{b}C@{ub} and the
derived class @{b}D@{ub}.

     class A {
     public:
             int Adat;
             virtual int A_virt (int arg) { return arg; };
     };
     
     class B {
     public:
             int B_dat;
             virtual int B_virt (int arg) {return arg; };
     };
     
     class C {
     public:
             int Cdat;
             virtual int C_virt (int arg) {return arg; };
     };
     
     class D : A, virtual B, public C {
     public:
             int Ddat;
             virtual int A_virt (int arg ) { return arg+1; };
             virtual int B_virt (int arg)  { return arg+2; };
             virtual int C_virt (int arg)  { return arg+3; };
             virtual int D_virt (int arg)  { return arg; };
     };

   Class stabs similar to the ones described earlier are generated for
each base class.

     .stabs "A:T20=s8Adat:1,0,32;$vf20:21=*22=ar1;0;1;17,32;
             A_virt::23=##1;:i;2A*-2147483647;20;;;~%20;",128,0,0,0
     
     .stabs "B:Tt25=s8Bdat:1,0,32;$vf25:21,32;B_virt::26=##1;
             :i;2A*-2147483647;25;;;~%25;",128,0,0,0
     
     .stabs "C:Tt28=s8Cdat:1,0,32;$vf28:21,32;C_virt::29=##1;
             :i;2A*-2147483647;28;;;~%28;",128,0,0,0

   In the stab describing derived class @{b}D@{ub} below, the information about
the derivation of this class is encoded as follows.

     .stabs "derived_class_name:symbol_descriptors(struct tag&type)=
             type_descriptor(struct)struct_bytes(32)!num_bases(3),
             base_virtual(no)inheritence_public(no)base_offset(0),
             base_class_type_ref(A);
             base_virtual(yes)inheritence_public(no)base_offset(NIL),
             base_class_type_ref(B);
             base_virtual(no)inheritence_public(yes)base_offset(64),
             base_class_type_ref(C); ...

     .stabs "D:Tt31=s32!3,000,20;100,25;0264,28;$vb25:24,128;Ddat:
             1,160,32;A_virt::32=##1;:i;2A*-2147483647;20;;B_virt:
             :32:i;2A*-2147483647;25;;C_virt::32:i;2A*-2147483647;
             28;;D_virt::32:i;2A*-2147483646;31;;;~%20;",128,0,0,0


@endnode

@node "Virtual Base Classes" "stabs.guide/Virtual Base Classes"
@next "Static Members"
@prev "Inheritence"
@toc "Cplusplus"

Virtual Base Classes
====================

   A derived class object consists of a concatination in memory of the
data areas defined by each base class, starting with the leftmost and
ending with the rightmost in the list of base classes.  The exception
to this rule is for virtual inheritence.  In the example above, class @{b}D@{ub}
inherits virtually from base class @{b}B@{ub}.  This means that an instance of a
@{b}D@{ub} object will not contain its own @{b}B@{ub} part but merely a pointer to a @{b}B@{ub}
part, known as a virtual base pointer.

   In a derived class stab, the base offset part of the derivation
information, described above, shows how the base class parts are
ordered.  The base offset for a virtual base class is always given as 0.
Notice that the base offset for @{b}B@{ub} is given as 0 even though @{b}B@{ub} is not
the first base class.  The first base class @{b}A@{ub} starts at offset 0.

   The field information part of the stab for class @{b}D@{ub} describes the
field which is the pointer to the virtual base class @{b}B@{ub}. The vbase
pointer name is @{b}$vb@{ub} followed by a type reference to the virtual base
class.  Since the type id for @{b}B@{ub} in this example is 25, the vbase
pointer name is @{b}$vb25@{ub}.

     .stabs "D:Tt31=s32!3,000,20;100,25;0264,28;$vb25:24,128;Ddat:1,
            160,32;A_virt::32=##1;:i;2A*-2147483647;20;;B_virt::32:i;
            2A*-2147483647;25;;C_virt::32:i;2A*-2147483647;28;;D_virt:
            :32:i;2A*-2147483646;31;;;~%20;",128,0,0,0

   Following the name and a semicolon is a type reference describing the
type of the virtual base class pointer, in this case 24.  Type 24 was
defined earlier as the type of the @{b}B@{ub} class @{b}this@{ub} pointer.  The @{b}this@{ub}
pointer for a class is a pointer to the class type.

     .stabs "this:P24=*25=xsB:",64,0,0,8

   Finally the field offset part of the vbase pointer field description
shows that the vbase pointer is the first field in the @{b}D@{ub} object, before
any data fields defined by the class.  The layout of a @{b}D@{ub} class object
is a follows, @{b}Adat@{ub} at 0, the vtable pointer for @{b}A@{ub} at 32, @{b}Cdat@{ub} at 64,
the vtable pointer for C at 96, the virtual base pointer for @{b}B@{ub} at 128,
and @{b}Ddat@{ub} at 160.


@endnode

@node "Static Members" "stabs.guide/Static Members"
@prev "Virtual Base Classes"
@toc "Cplusplus"

Static Members
==============

   The data area for a class is a concatenation of the space used by the
data members of the class.  If the class has virtual methods, a vtable
pointer follows the class data.  The field offset part of each field
description in the class stab shows this ordering.

   << How is this reflected in stabs?  See Cygnus bug #677 for some
info.  >>


@endnode

@node "Stab Types" "stabs.guide/Stab Types"
@next "Symbol Descriptors"
@prev "Cplusplus"
@toc "Main"

Table of Stab Types
*******************

   The following are all the possible values for the stab type field,
for a.out files, in numeric order.  This does not apply to XCOFF, but
it does apply to stabs in sections (see @{"Stab Sections" link "Stab Sections"}).  Stabs in
ECOFF use these values but add 0x8f300 to distinguish them from non-stab
symbols.

   The symbolic names are defined in the file @{b}include/aout/stabs.def@{ub}.


 @{" Non-Stab Symbol Types      " link "Non-Stab Symbol Types"}  Types from 0 to 0x1f
 @{" Stab Symbol Types          " link "Stab Symbol Types"}  Types from 0x20 to 0xff


@endnode

@node "Non-Stab Symbol Types" "stabs.guide/Non-Stab Symbol Types"
@next "Stab Symbol Types"
@toc "Stab Types"

Non-Stab Symbol Types
=====================

   The following types are used by the linker and assembler, not by stab
directives.  Since this document does not attempt to describe aspects of
object file format other than the debugging format, no details are
given.

@{b}0x0     N_UNDF@{ub}
     Undefined symbol

@{b}0x2     N_ABS@{ub}
     File scope absolute symbol

@{b}0x3     N_ABS | N_EXT@{ub}
     External absolute symbol

@{b}0x4     N_TEXT@{ub}
     File scope text symbol

@{b}0x5     N_TEXT | N_EXT@{ub}
     External text symbol

@{b}0x6     N_DATA@{ub}
     File scope data symbol

@{b}0x7     N_DATA | N_EXT@{ub}
     External data symbol

@{b}0x8     N_BSS@{ub}
     File scope BSS symbol

@{b}0x9     N_BSS | N_EXT@{ub}
     External BSS symbol

@{b}0x0c    N_FN_SEQ@{ub}
     Same as @{b}N_FN@{ub}, for Sequent compilers

@{b}0x0a    N_INDR@{ub}
     Symbol is indirected to another symbol

@{b}0x12    N_COMM@{ub}
     Common--visible after shared library dynamic link

@{b}0x14 N_SETA@{ub}
@{b}0x15 N_SETA | N_EXT@{ub}
     Absolute set element

@{b}0x16 N_SETT@{ub}
@{b}0x17 N_SETT | N_EXT@{ub}
     Text segment set element

@{b}0x18 N_SETD@{ub}
@{b}0x19 N_SETD | N_EXT@{ub}
     Data segment set element

@{b}0x1a N_SETB@{ub}
@{b}0x1b N_SETB | N_EXT@{ub}
     BSS segment set element

@{b}0x1c N_SETV@{ub}
@{b}0x1d N_SETV | N_EXT@{ub}
     Pointer to set vector

@{b}0x1e N_WARNING@{ub}
     Print a warning message during linking

@{b}0x1f    N_FN@{ub}
     File name of a @{b}.o@{ub} file


@endnode

@node "Stab Symbol Types" "stabs.guide/Stab Symbol Types"
@prev "Non-Stab Symbol Types"
@toc "Stab Types"

Stab Symbol Types
=================

   The following symbol types indicate that this is a stab.  This is the
full list of stab numbers, including stab types that are used in
languages other than C.

@{b}0x20     N_GSYM@{ub}
     Global symbol; see @{"Global Variables" link "Global Variables"}.

@{b}0x22     N_FNAME@{ub}
     Function name (for BSD Fortran); see @{"Procedures" link "Procedures"}.

@{b}0x24     N_FUN@{ub}
     Function name (see @{"Procedures" link "Procedures"}) or text segment variable (see
     @{"Statics" link "Statics"}).

@{b}0x26 N_STSYM@{ub}
     Data segment file-scope variable; see @{"Statics" link "Statics"}.

@{b}0x28 N_LCSYM@{ub}
     BSS segment file-scope variable; see @{"Statics" link "Statics"}.

@{b}0x2a N_MAIN@{ub}
     Name of main routine; see @{"Main Program" link "Main Program"}.

@{b}0x2c N_ROSYM@{ub}
     Variable in @{b}.rodata@{ub} section; see @{"Statics" link "Statics"}.

@{b}0x30     N_PC@{ub}
     Global symbol (for Pascal); see @{"N_PC" link "N_PC"}.

@{b}0x32     N_NSYMS@{ub}
     Number of symbols (according to Ultrix V4.0); see @{"N_NSYMS" link "N_NSYMS"}.

@{b}0x34     N_NOMAP@{ub}
     No DST map; see @{"N_NOMAP" link "N_NOMAP"}.

@{b}0x38 N_OBJ@{ub}
     Object file (Solaris2).

@{b}0x3c N_OPT@{ub}
     Debugger options (Solaris2).

@{b}0x40     N_RSYM@{ub}
     Register variable; see @{"Register Variables" link "Register Variables"}.

@{b}0x42     N_M2C@{ub}
     Modula-2 compilation unit; see @{"N_M2C" link "N_M2C"}.

@{b}0x44     N_SLINE@{ub}
     Line number in text segment; see @{"Line Numbers" link "Line Numbers"}.

@{b}0x46     N_DSLINE@{ub}
     Line number in data segment; see @{"Line Numbers" link "Line Numbers"}.

@{b}0x48     N_BSLINE@{ub}
     Line number in bss segment; see @{"Line Numbers" link "Line Numbers"}.

@{b}0x48     N_BROWS@{ub}
     Sun source code browser, path to @{b}.cb@{ub} file; see @{"N_BROWS" link "N_BROWS"}.

@{b}0x4a     N_DEFD@{ub}
     GNU Modula2 definition module dependency; see @{"N_DEFD" link "N_DEFD"}.

@{b}0x4c N_FLINE@{ub}
     Function start/body/end line numbers (Solaris2).

@{b}0x50     N_EHDECL@{ub}
     GNU C++ exception variable; see @{"N_EHDECL" link "N_EHDECL"}.

@{b}0x50     N_MOD2@{ub}
     Modula2 info "for imc" (according to Ultrix V4.0); see @{"N_MOD2" link "N_MOD2"}.

@{b}0x54     N_CATCH@{ub}
     GNU C++ @{b}catch@{ub} clause; see @{"N_CATCH" link "N_CATCH"}.

@{b}0x60     N_SSYM@{ub}
     Structure of union element; see @{"N_SSYM" link "N_SSYM"}.

@{b}0x62 N_ENDM@{ub}
     Last stab for module (Solaris2).

@{b}0x64     N_SO@{ub}
     Path and name of source file; see @{"Source Files" link "Source Files"}.

@{b}0x80 N_LSYM@{ub}
     Stack variable (see @{"Stack Variables" link "Stack Variables"}) or type (see @{"Typedefs" link "Typedefs"}).

@{b}0x82     N_BINCL@{ub}
     Beginning of an include file (Sun only); see @{"Include Files" link "Include Files"}.

@{b}0x84     N_SOL@{ub}
     Name of include file; see @{"Include Files" link "Include Files"}.

@{b}0xa0     N_PSYM@{ub}
     Parameter variable; see @{"Parameters" link "Parameters"}.

@{b}0xa2     N_EINCL@{ub}
     End of an include file; see @{"Include Files" link "Include Files"}.

@{b}0xa4     N_ENTRY@{ub}
     Alternate entry point; see @{"Alternate Entry Points" link "Alternate Entry Points"}.

@{b}0xc0     N_LBRAC@{ub}
     Beginning of a lexical block; see @{"Block Structure" link "Block Structure"}.

@{b}0xc2     N_EXCL@{ub}
     Place holder for a deleted include file; see @{"Include Files" link "Include Files"}.

@{b}0xc4     N_SCOPE@{ub}
     Modula2 scope information (Sun linker); see @{"N_SCOPE" link "N_SCOPE"}.

@{b}0xe0     N_RBRAC@{ub}
     End of a lexical block; see @{"Block Structure" link "Block Structure"}.

@{b}0xe2     N_BCOMM@{ub}
     Begin named common block; see @{"Common Blocks" link "Common Blocks"}.

@{b}0xe4     N_ECOMM@{ub}
     End named common block; see @{"Common Blocks" link "Common Blocks"}.

@{b}0xe8     N_ECOML@{ub}
     Member of a common block; see @{"Common Blocks" link "Common Blocks"}.

@{b}0xea N_WITH@{ub}
     Pascal @{b}with@{ub} statement: type,,0,0,offset (Solaris2).

@{b}0xf0     N_NBTEXT@{ub}
     Gould non-base registers; see @{"Gould" link "Gould"}.

@{b}0xf2     N_NBDATA@{ub}
     Gould non-base registers; see @{"Gould" link "Gould"}.

@{b}0xf4     N_NBBSS@{ub}
     Gould non-base registers; see @{"Gould" link "Gould"}.

@{b}0xf6     N_NBSTS@{ub}
     Gould non-base registers; see @{"Gould" link "Gould"}.

@{b}0xf8     N_NBLCS@{ub}
     Gould non-base registers; see @{"Gould" link "Gould"}.


@endnode

@node "Symbol Descriptors" "stabs.guide/Symbol Descriptors"
@next "Type Descriptors"
@prev "Stab Types"
@toc "Main"

Table of Symbol Descriptors
***************************

   The symbol descriptor is the character which follows the colon in
many stabs, and which tells what kind of stab it is.  See @{"String Field" link "String Field"},
for more information about their use.

@{b}DIGIT@{ub}
@{b}(@{ub}
@{b}-@{ub}
     Variable on the stack; see @{"Stack Variables" link "Stack Variables"}.

@{b}:@{ub}
     C++ nested symbol; see See @{"Nested Symbols" link "Nested Symbols"}.

@{b}a@{ub}
     Parameter passed by reference in register; see
     @{"Reference Parameters" link "Reference Parameters"}.

@{b}b@{ub}
     Based variable; see @{"Based Variables" link "Based Variables"}.

@{b}c@{ub}
     Constant; see @{"Constants" link "Constants"}.

@{b}C@{ub}
     Conformant array bound (Pascal, maybe other languages);
     @{"Conformant Arrays" link "Conformant Arrays"}.  Name of a caught exception (GNU C++).  These
     can be distinguished because the latter uses @{b}N_CATCH@{ub} and the
     former uses another symbol type.

@{b}d@{ub}
     Floating point register variable; see @{"Register Variables" link "Register Variables"}.

@{b}D@{ub}
     Parameter in floating point register; see @{"Register Parameters" link "Register Parameters"}.

@{b}f@{ub}
     File scope function; see @{"Procedures" link "Procedures"}.

@{b}F@{ub}
     Global function; see @{"Procedures" link "Procedures"}.

@{b}G@{ub}
     Global variable; see @{"Global Variables" link "Global Variables"}.

@{b}i@{ub}
     See @{"Register Parameters" link "Register Parameters"}.

@{b}I@{ub}
     Internal (nested) procedure; see @{"Nested Procedures" link "Nested Procedures"}.

@{b}J@{ub}
     Internal (nested) function; see @{"Nested Procedures" link "Nested Procedures"}.

@{b}L@{ub}
     Label name (documented by AIX, no further information known).

@{b}m@{ub}
     Module; see @{"Procedures" link "Procedures"}.

@{b}p@{ub}
     Argument list parameter; see @{"Parameters" link "Parameters"}.

@{b}pP@{ub}
     See @{"Parameters" link "Parameters"}.

@{b}pF@{ub}
     Fortran Function parameter; see @{"Parameters" link "Parameters"}.

@{b}P@{ub}
     Unfortunately, three separate meanings have been independently
     invented for this symbol descriptor.  At least the GNU and Sun
     uses can be distinguished by the symbol type.  Global Procedure
     (AIX) (symbol type used unknown); see @{"Procedures" link "Procedures"}.  Register
     parameter (GNU) (symbol type @{b}N_PSYM@{ub}); see @{"Parameters" link "Parameters"}.  Prototype
     of function referenced by this file (Sun @{b}acc@{ub}) (symbol type @{b}N_FUN@{ub}).

@{b}Q@{ub}
     Static Procedure; see @{"Procedures" link "Procedures"}.

@{b}R@{ub}
     Register parameter; see @{"Register Parameters" link "Register Parameters"}.

@{b}r@{ub}
     Register variable; see @{"Register Variables" link "Register Variables"}.

@{b}S@{ub}
     File scope variable; see @{"Statics" link "Statics"}.

@{b}s@{ub}
     Local variable (OS9000).

@{b}t@{ub}
     Type name; see @{"Typedefs" link "Typedefs"}.

@{b}T@{ub}
     Enumeration, structure, or union tag; see @{"Typedefs" link "Typedefs"}.

@{b}v@{ub}
     Parameter passed by reference; see @{"Reference Parameters" link "Reference Parameters"}.

@{b}V@{ub}
     Procedure scope static variable; see @{"Statics" link "Statics"}.

@{b}x@{ub}
     Conformant array; see @{"Conformant Arrays" link "Conformant Arrays"}.

@{b}X@{ub}
     Function return variable; see @{"Parameters" link "Parameters"}.


@endnode

@node "Type Descriptors" "stabs.guide/Type Descriptors"
@next "Expanded Reference"
@prev "Symbol Descriptors"
@toc "Main"

Table of Type Descriptors
*************************

   The type descriptor is the character which follows the type number
and an equals sign.  It specifies what kind of type is being defined.
See @{"String Field" link "String Field"}, for more information about their use.

@{b}DIGIT@{ub}
@{b}(@{ub}
     Type reference; see @{"String Field" link "String Field"}.

@{b}-@{ub}
     Reference to builtin type; see @{"Negative Type Numbers" link "Negative Type Numbers"}.

@{b}#@{ub}
     Method (C++); see @{"Method Type Descriptor" link "Method Type Descriptor"}.

@{b}*@{ub}
     Pointer; see @{"Miscellaneous Types" link "Miscellaneous Types"}.

@{b}&@{ub}
     Reference (C++).

@{b}@@{ub}
     Type Attributes (AIX); see @{"String Field" link "String Field"}.  Member (class and
     variable) type (GNU C++); see @{"Member Type Descriptor" link "Member Type Descriptor"}.

@{b}a@{ub}
     Array; see @{"Arrays" link "Arrays"}.

@{b}A@{ub}
     Open array; see @{"Arrays" link "Arrays"}.

@{b}b@{ub}
     Pascal space type (AIX); see @{"Miscellaneous Types" link "Miscellaneous Types"}.  Builtin integer
     type (Sun); see @{"Builtin Type Descriptors" link "Builtin Type Descriptors"}.  Const and volatile
     qualfied type (OS9000).

@{b}B@{ub}
     Volatile-qualified type; see @{"Miscellaneous Types" link "Miscellaneous Types"}.

@{b}c@{ub}
     Complex builtin type (AIX); see @{"Builtin Type Descriptors" link "Builtin Type Descriptors"}.
     Const-qualified type (OS9000).

@{b}C@{ub}
     COBOL Picture type.  See AIX documentation for details.

@{b}d@{ub}
     File type; see @{"Miscellaneous Types" link "Miscellaneous Types"}.

@{b}D@{ub}
     N-dimensional dynamic array; see @{"Arrays" link "Arrays"}.

@{b}e@{ub}
     Enumeration type; see @{"Enumerations" link "Enumerations"}.

@{b}E@{ub}
     N-dimensional subarray; see @{"Arrays" link "Arrays"}.

@{b}f@{ub}
     Function type; see @{"Function Types" link "Function Types"}.

@{b}F@{ub}
     Pascal function parameter; see @{"Function Types" link "Function Types"}

@{b}g@{ub}
     Builtin floating point type; see @{"Builtin Type Descriptors" link "Builtin Type Descriptors"}.

@{b}G@{ub}
     COBOL Group.  See AIX documentation for details.

@{b}i@{ub}
     Imported type (AIX); see @{"Cross-References" link "Cross-References"}.  Volatile-qualified
     type (OS9000).

@{b}k@{ub}
     Const-qualified type; see @{"Miscellaneous Types" link "Miscellaneous Types"}.

@{b}K@{ub}
     COBOL File Descriptor.  See AIX documentation for details.

@{b}M@{ub}
     Multiple instance type; see @{"Miscellaneous Types" link "Miscellaneous Types"}.

@{b}n@{ub}
     String type; see @{"Strings" link "Strings"}.

@{b}N@{ub}
     Stringptr; see @{"Strings" link "Strings"}.

@{b}o@{ub}
     Opaque type; see @{"Typedefs" link "Typedefs"}.

@{b}p@{ub}
     Procedure; see @{"Function Types" link "Function Types"}.

@{b}P@{ub}
     Packed array; see @{"Arrays" link "Arrays"}.

@{b}r@{ub}
     Range type; see @{"Subranges" link "Subranges"}.

@{b}R@{ub}
     Builtin floating type; see @{"Builtin Type Descriptors" link "Builtin Type Descriptors"} (Sun).  Pascal
     subroutine parameter; see @{"Function Types" link "Function Types"} (AIX).  Detecting this
     conflict is possible with careful parsing (hint: a Pascal
     subroutine parameter type will always contain a comma, and a
     builtin type descriptor never will).

@{b}s@{ub}
     Structure type; see @{"Structures" link "Structures"}.

@{b}S@{ub}
     Set type; see @{"Miscellaneous Types" link "Miscellaneous Types"}.

@{b}u@{ub}
     Union; see @{"Unions" link "Unions"}.

@{b}v@{ub}
     Variant record.  This is a Pascal and Modula-2 feature which is
     like a union within a struct in C.  See AIX documentation for
     details.

@{b}w@{ub}
     Wide character; see @{"Builtin Type Descriptors" link "Builtin Type Descriptors"}.

@{b}x@{ub}
     Cross-reference; see @{"Cross-References" link "Cross-References"}.

@{b}Y@{ub}
     Used by IBM's xlC C++ compiler (for structures, I think).

@{b}z@{ub}
     gstring; see @{"Strings" link "Strings"}.


@endnode

@node "Expanded Reference" "stabs.guide/Expanded Reference"
@next "Questions"
@prev "Type Descriptors"
@toc "Main"

Expanded Reference by Stab Type
*******************************

   For a full list of stab types, and cross-references to where they are
described, see @{"Stab Types" link "Stab Types"}.  This appendix just covers certain stabs
which are not yet described in the main body of this document;
eventually the information will all be in one place.

   Format of an entry:

   The first line is the symbol type (see @{b}include/aout/stab.def@{ub}).

   The second line describes the language constructs the symbol type
represents.

   The third line is the stab format with the significant stab fields
named and the rest NIL.

   Subsequent lines expand upon the meaning and possible values for each
significant stab field.

   Finally, any further information.


 @{" N_PC                    " link "N_PC"}  Pascal global symbol
 @{" N_NSYMS                 " link "N_NSYMS"}  Number of symbols
 @{" N_NOMAP                 " link "N_NOMAP"}  No DST map
 @{" N_M2C                   " link "N_M2C"}  Modula-2 compilation unit
 @{" N_BROWS                 " link "N_BROWS"}  Path to .cb file for Sun source code browser
 @{" N_DEFD                  " link "N_DEFD"}  GNU Modula2 definition module dependency
 @{" N_EHDECL                " link "N_EHDECL"}  GNU C++ exception variable
 @{" N_MOD2                  " link "N_MOD2"}  Modula2 information "for imc"
 @{" N_CATCH                 " link "N_CATCH"}  GNU C++ "catch" clause
 @{" N_SSYM                  " link "N_SSYM"}  Structure or union element
 @{" N_SCOPE                 " link "N_SCOPE"}  Modula2 scope information (Sun only)
 @{" Gould                   " link "Gould"}  non-base register symbols used on Gould systems
 @{" N_LENG                  " link "N_LENG"}  Length of preceding entry


@endnode

@node "N_PC" "stabs.guide/N_PC"
@next "N_NSYMS"
@toc "Expanded Reference"

N_PC
====

 - @{b}.stabs@{ub}: N_PC
     Global symbol (for Pascal).

          "name" -> "symbol_name"  <<?>>
          value  -> supposedly the line number (stab.def is skeptical)

@{b}          stabdump.c@{ub} says:
          
          global pascal symbol: name,,0,subtype,line
          << subtype? >>


@endnode

@node "N_NSYMS" "stabs.guide/N_NSYMS"
@next "N_NOMAP"
@prev "N_PC"
@toc "Expanded Reference"

N_NSYMS
=======

 - @{b}.stabn@{ub}: N_NSYMS
     Number of symbols (according to Ultrix V4.0).

                  0, files,,funcs,lines (stab.def)


@endnode

@node "N_NOMAP" "stabs.guide/N_NOMAP"
@next "N_M2C"
@prev "N_NSYMS"
@toc "Expanded Reference"

N_NOMAP
=======

 - @{b}.stabs@{ub}: N_NOMAP
     No DST map for symbol (according to Ultrix V4.0).  I think this
     means a variable has been optimized out.

                  name, ,0,type,ignored (stab.def)


@endnode

@node "N_M2C" "stabs.guide/N_M2C"
@next "N_BROWS"
@prev "N_NOMAP"
@toc "Expanded Reference"

N_M2C
=====

 - @{b}.stabs@{ub}: N_M2C
     Modula-2 compilation unit.

          "string" -> "unit_name,unit_time_stamp[,code_time_stamp]"
          desc   -> unit_number
          value  -> 0 (main unit)
                    1 (any other unit)

     See `Dbx and Dbxtool Interfaces', 2nd edition, by Sun, 1988, for
     more information.



@endnode

@node "N_BROWS" "stabs.guide/N_BROWS"
@next "N_DEFD"
@prev "N_M2C"
@toc "Expanded Reference"

N_BROWS
=======

 - @{b}.stabs@{ub}: N_BROWS
     Sun source code browser, path to @{b}.cb@{ub} file

     <<?>> "path to associated @{b}.cb@{ub} file"

     Note: N_BROWS has the same value as N_BSLINE.


@endnode

@node "N_DEFD" "stabs.guide/N_DEFD"
@next "N_EHDECL"
@prev "N_BROWS"
@toc "Expanded Reference"

N_DEFD
======

 - @{b}.stabn@{ub}: N_DEFD
     GNU Modula2 definition module dependency.

     GNU Modula-2 definition module dependency.  The value is the
     modification time of the definition file.  The other field is
     non-zero if it is imported with the GNU M2 keyword @{b}%INITIALIZE@{ub}.
     Perhaps @{b}N_M2C@{ub} can be used if there are enough empty fields?


@endnode

@node "N_EHDECL" "stabs.guide/N_EHDECL"
@next "N_MOD2"
@prev "N_DEFD"
@toc "Expanded Reference"

N_EHDECL
========

 - @{b}.stabs@{ub}: N_EHDECL
     GNU C++ exception variable <<?>>.

     "STRING is variable name"

     Note: conflicts with @{b}N_MOD2@{ub}.


@endnode

@node "N_MOD2" "stabs.guide/N_MOD2"
@next "N_CATCH"
@prev "N_EHDECL"
@toc "Expanded Reference"

N_MOD2
======

 - @{b}.stab?@{ub}: N_MOD2
     Modula2 info "for imc" (according to Ultrix V4.0)

     Note: conflicts with @{b}N_EHDECL@{ub}  <<?>>


@endnode

@node "N_CATCH" "stabs.guide/N_CATCH"
@next "N_SSYM"
@prev "N_MOD2"
@toc "Expanded Reference"

N_CATCH
=======

 - @{b}.stabn@{ub}: N_CATCH
     GNU C++ @{b}catch@{ub} clause

     GNU C++ @{b}catch@{ub} clause.  The value is its address.  The desc field
     is nonzero if this entry is immediately followed by a @{b}CAUGHT@{ub} stab
     saying what exception was caught.  Multiple @{b}CAUGHT@{ub} stabs means
     that multiple exceptions can be caught here.  If desc is 0, it
     means all exceptions are caught here.


@endnode

@node "N_SSYM" "stabs.guide/N_SSYM"
@next "N_SCOPE"
@prev "N_CATCH"
@toc "Expanded Reference"

N_SSYM
======

 - @{b}.stabn@{ub}: N_SSYM
     Structure or union element.

     The value is the offset in the structure.

     <<?looking at structs and unions in C I didn't see these>>


@endnode

@node "N_SCOPE" "stabs.guide/N_SCOPE"
@next "Gould"
@prev "N_SSYM"
@toc "Expanded Reference"

N_SCOPE
=======

 - @{b}.stab?@{ub}: N_SCOPE
     Modula2 scope information (Sun linker) <<?>>


@endnode

@node "Gould" "stabs.guide/Gould"
@next "N_LENG"
@prev "N_SCOPE"
@toc "Expanded Reference"

Non-base registers on Gould systems
===================================

 - @{b}.stab?@{ub}: N_NBTEXT
 - @{b}.stab?@{ub}: N_NBDATA
 - @{b}.stab?@{ub}: N_NBBSS
 - @{b}.stab?@{ub}: N_NBSTS
 - @{b}.stab?@{ub}: N_NBLCS
     These are used on Gould systems for non-base registers syms.

     However, the following values are not the values used by Gould;
     they are the values which GNU has been documenting for these
     values for a long time, without actually checking what Gould uses.
     I include these values only because perhaps some someone actually
     did something with the GNU information (I hope not, why GNU
     knowingly assigned wrong values to these in the header file is a
     complete mystery to me).

          240    0xf0     N_NBTEXT  ??
          242    0xf2     N_NBDATA  ??
          244    0xf4     N_NBBSS   ??
          246    0xf6     N_NBSTS   ??
          248    0xf8     N_NBLCS   ??


@endnode

@node "N_LENG" "stabs.guide/N_LENG"
@prev "Gould"
@toc "Expanded Reference"

N_LENG
======

 - @{b}.stabn@{ub}: N_LENG
     Second symbol entry containing a length-value for the preceding
     entry.  The value is the length.


@endnode

@node "Questions" "stabs.guide/Questions"
@next "Sun Differences"
@prev "Expanded Reference"
@toc "Main"

Questions and Anomalies
***********************

   * For GNU C stabs defining local and global variables (@{b}N_LSYM@{ub} and
     @{b}N_GSYM@{ub}), the desc field is supposed to contain the source line
     number on which the variable is defined.  In reality the desc
     field is always 0.  (This behavior is defined in @{b}dbxout.c@{ub} and
     putting a line number in desc is controlled by @{b}#ifdef WINNING_GDB@{ub},
     which defaults to false). GDB supposedly uses this information if
     you say @{b}list VAR@{ub}.  In reality, VAR can be a variable defined in
     the program and GDB says @{b}function VAR not defined@{ub}.

   * In GNU C stabs, there seems to be no way to differentiate tag
     types: structures, unions, and enums (symbol descriptor @{b}T@{ub}) and
     typedefs (symbol descriptor @{b}t@{ub}) defined at file scope from types
     defined locally to a procedure or other more local scope.  They
     all use the @{b}N_LSYM@{ub} stab type.  Types defined at procedure scope
     are emited after the @{b}N_RBRAC@{ub} of the preceding function and before
     the code of the procedure in which they are defined.  This is
     exactly the same as types defined in the source file between the
     two procedure bodies.  GDB overcompensates by placing all types in
     block #1, the block for symbols of file scope.  This is true for
     default, @{b}-ansi@{ub} and @{b}-traditional@{ub} compiler options. (Bugs gcc/1063,
     gdb/1066.)

   * What ends the procedure scope?  Is it the proc block's @{b}N_RBRAC@{ub} or
     the next @{b}N_FUN@{ub}?  (I believe its the first.)


@endnode

@node "Sun Differences" "stabs.guide/Sun Differences"
@next "Stab Sections"
@prev "Questions"
@toc "Main"

Differences Between GNU Stabs and Sun Native Stabs
**************************************************

   * GNU C stabs define @{i}all@{ui} types, file or procedure scope, as @{b}N_LSYM@{ub}.
     Sun doc talks about using @{b}N_GSYM@{ub} too.

   * Sun C stabs use type number pairs in the format
     (FILE-NUMBER,TYPE-NUMBER) where FILE-NUMBER is a number starting
     with 1 and incremented for each sub-source file in the
     compilation.  TYPE-NUMBER is a number starting with 1 and
     incremented for each new type defined in the compilation.  GNU C
     stabs use the type number alone, with no source file number.


@endnode

@node "Stab Sections" "stabs.guide/Stab Sections"
@next "Symbol Types Index"
@prev "Sun Differences"
@toc "Main"

Using Stabs in Their Own Sections
*********************************

   Many object file formats allow tools to create object files with
custom sections containing any arbitrary data.  For any such object file
format, stabs can be embedded in special sections.  This is how stabs
are used with ELF and SOM, and aside from ECOFF and XCOFF, is how stabs
are used with COFF.


 @{" Stab Section Basics   " link "Stab Section Basics"}  How to embed stabs in sections
 @{" ELF Linker Relocation " link "ELF Linker Relocation"}  Sun ELF hacks


@endnode

@node "Stab Section Basics" "stabs.guide/Stab Section Basics"
@next "ELF Linker Relocation"
@toc "Stab Sections"

How to Embed Stabs in Sections
==============================

   The assembler creates two custom sections, a section named @{b}.stab@{ub}
which contains an array of fixed length structures, one struct per stab,
and a section named @{b}.stabstr@{ub} containing all the variable length strings
that are referenced by stabs in the @{b}.stab@{ub} section.  The byte order of
the stabs binary data depends on the object file format.  For ELF, it
matches the byte order of the ELF file itself, as determined from the
@{b}EI_DATA@{ub} field in the @{b}e_ident@{ub} member of the ELF header.  For SOM, it is
always big-endian (is this true??? FIXME).  For COFF, it matches the
byte order of the COFF headers.  The meaning of the fields is the same
as for a.out (see @{"Symbol Table Format" link "Symbol Table Format"}), except that the @{b}n_strx@{ub} field
is relative to the strings for the current compilation unit (which can
be found using the synthetic N_UNDF stab described below), rather than
the entire string table.

   The first stab in the @{b}.stab@{ub} section for each compilation unit is
synthetic, generated entirely by the assembler, with no corresponding
@{b}.stab@{ub} directive as input to the assembler.  This stab contains the
following fields:

@{b}n_strx@{ub}
     Offset in the @{b}.stabstr@{ub} section to the source filename.

@{b}n_type@{ub}
@{b}     N_UNDF@{ub}.

@{b}n_other@{ub}
     Unused field, always zero.  This may eventually be used to hold
     overflows from the count in the @{b}n_desc@{ub} field.

@{b}n_desc@{ub}
     Count of upcoming symbols, i.e., the number of remaining stabs for
     this source file.

@{b}n_value@{ub}
     Size of the string table fragment associated with this source
     file, in bytes.

   The @{b}.stabstr@{ub} section always starts with a null byte (so that string
offsets of zero reference a null string), followed by random length
strings, each of which is null byte terminated.

   The ELF section header for the @{b}.stab@{ub} section has its @{b}sh_link@{ub} member
set to the section number of the @{b}.stabstr@{ub} section, and the @{b}.stabstr@{ub}
section has its ELF section header @{b}sh_type@{ub} member set to @{b}SHT_STRTAB@{ub} to
mark it as a string table.  SOM and COFF have no way of linking the
sections together or marking them as string tables.

   For COFF, the @{b}.stab@{ub} and @{b}.stabstr@{ub} sections are simply concatenated by
the linker.  GDB then uses the @{b}n_desc@{ub} fields to figure out the extent
of the original sections.  Similarly, the @{b}n_value@{ub} fields of the header
symbols are added together in order to get the actual position of the
strings in a desired @{b}.stabstr@{ub} section.  Although this design obviates
any need for the linker to relocate or otherwise manipulate @{b}.stab@{ub} and
@{b}.stabstr@{ub} sections, it also requires some care to ensure that the
offsets are calculated correctly.  For instance, if the linker were to
pad in between the @{b}.stabstr@{ub} sections before concatenating, then the
offsets to strings in the middle of the executable's @{b}.stabstr@{ub} section
would be wrong.


@endnode

@node "ELF Linker Relocation" "stabs.guide/ELF Linker Relocation"
@prev "Stab Section Basics"
@toc "Stab Sections"

Having the Linker Relocate Stabs in ELF
=======================================

   This section describes some Sun hacks for Stabs in ELF; it does not
apply to COFF or SOM.

   To keep linking fast, you don't want the linker to have to relocate
very many stabs.  Making sure this is done for @{b}N_SLINE@{ub}, @{b}N_RBRAC@{ub}, and
@{b}N_LBRAC@{ub} stabs is the most important thing (see the descriptions of
those stabs for more information).  But Sun's stabs in ELF has taken
this further, to make all addresses in the @{b}n_value@{ub} field (functions and
static variables) relative to the source file.  For the @{b}N_SO@{ub} symbol
itself, Sun simply omits the address.  To find the address of each
section corresponding to a given source file, the compiler puts out
symbols giving the address of each section for a given source file.
Since these are ELF (not stab) symbols, the linker relocates them
correctly without having to touch the stabs section.  They are named
@{b}Bbss.bss@{ub} for the bss section, @{b}Ddata.data@{ub} for the data section, and
@{b}Drodata.rodata@{ub} for the rodata section.  For the text section, there is
no such symbol (but there should be, see below).  For an example of how
these symbols work, See @{"Stab Section Transformations" link "Stab Section Transformations"}.  GCC does not
provide these symbols; it instead relies on the stabs getting
relocated.  Thus addresses which would normally be relative to
@{b}Bbss.bss@{ub}, etc., are already relocated.  The Sun linker provided with
Solaris 2.2 and earlier relocates stabs using normal ELF relocation
information, as it would do for any section.  Sun has been threatening
to kludge their linker to not do this (to speed up linking), even
though the correct way to avoid having the linker do these relocations
is to have the compiler no longer output relocatable values.  Last I
heard they had been talked out of the linker kludge.  See Sun point
patch 101052-01 and Sun bug 1142109.  With the Sun compiler this
affects @{b}S@{ub} symbol descriptor stabs (see @{"Statics" link "Statics"}) and functions (see
@{"Procedures" link "Procedures"}).  In the latter case, to adopt the clean solution (making
the value of the stab relative to the start of the compilation unit),
it would be necessary to invent a @{b}Ttext.text@{ub} symbol, analogous to the
@{b}Bbss.bss@{ub}, etc., symbols.  I recommend this rather than using a zero
value and getting the address from the ELF symbols.

   Finding the correct @{b}Bbss.bss@{ub}, etc., symbol is difficult, because the
linker simply concatenates the @{b}.stab@{ub} sections from each @{b}.o@{ub} file without
including any information about which part of a @{b}.stab@{ub} section comes
from which @{b}.o@{ub} file.  The way GDB does this is to look for an ELF
@{b}STT_FILE@{ub} symbol which has the same name as the last component of the
file name from the @{b}N_SO@{ub} symbol in the stabs (for example, if the file
name is @{b}../../gdb/main.c@{ub}, it looks for an ELF @{b}STT_FILE@{ub} symbol named
@{b}main.c@{ub}).  This loses if different files have the same name (they could
be in different directories, a library could have been copied from one
system to another, etc.).  It would be much cleaner to have the @{b}Bbss.bss@{ub}
symbols in the stabs themselves.  Having the linker relocate them there
is no more work than having the linker relocate ELF symbols, and it
solves the problem of having to associate the ELF and stab symbols.
However, no one has yet designed or implemented such a scheme.


@endnode

@node "Symbol Types Index" "stabs.guide/Symbol Types Index"
@prev "Stab Sections"
@toc "Main"

Symbol Types Index
******************



 @{" .bb                                      " link "Block Structure"}   Block Structure
 @{" .be                                      " link "Block Structure"}   Block Structure
 @{" C_BCOMM                                  " link "Common Blocks"}   Common Blocks
 @{" C_BINCL                                  " link "Include Files"}   Include Files
 @{" C_BLOCK                                  " link "Block Structure"}   Block Structure
 @{" C_BSTAT                                  " link "Statics"}   Statics
 @{" C_DECL, for types                        " link "Typedefs"}   Typedefs
 @{" C_ECOML                                  " link "Common Blocks"}   Common Blocks
 @{" C_ECOMM                                  " link "Common Blocks"}   Common Blocks
 @{" C_EINCL                                  " link "Include Files"}   Include Files
 @{" C_ENTRY                                  " link "Alternate Entry Points"}   Alternate Entry Points
 @{" C_ESTAT                                  " link "Statics"}   Statics
 @{" C_FILE                                   " link "Source Files"}   Source Files
 @{" C_FUN                                    " link "Procedures"}   Procedures
 @{" C_GSYM                                   " link "Global Variables"}   Global Variables
 @{" C_LSYM                                   " link "Stack Variables"}   Stack Variables
 @{" C_PSYM                                   " link "Parameters"}   Parameters
 @{" C_RPSYM                                  " link "Register Parameters"}   Register Parameters
 @{" C_RSYM                                   " link "Register Variables"}   Register Variables
 @{" C_STSYM                                  " link "Statics"}   Statics
 @{" N_BCOMM                                  " link "Common Blocks"}   Common Blocks
 @{" N_BINCL                                  " link "Include Files"}   Include Files
 @{" N_BROWS                                  " link "N_BROWS"}   N_BROWS
 @{" N_BSLINE                                 " link "Line Numbers"}   Line Numbers
 @{" N_CATCH                                  " link "N_CATCH"}   N_CATCH
 @{" N_DEFD                                   " link "N_DEFD"}   N_DEFD
 @{" N_DSLINE                                 " link "Line Numbers"}   Line Numbers
 @{" N_ECOML                                  " link "Common Blocks"}   Common Blocks
 @{" N_ECOMM                                  " link "Common Blocks"}   Common Blocks
 @{" N_EHDECL                                 " link "N_EHDECL"}   N_EHDECL
 @{" N_EINCL                                  " link "Include Files"}   Include Files
 @{" N_ENTRY                                  " link "Alternate Entry Points"}   Alternate Entry Points
 @{" N_EXCL                                   " link "Include Files"}   Include Files
 @{" N_FNAME                                  " link "Procedures"}   Procedures
 @{" N_FUN, for functions                     " link "Procedures"}   Procedures
 @{" N_FUN, for variables                     " link "Statics"}   Statics
 @{" N_GSYM                                   " link "Global Variables"}   Global Variables
 @{" N_GSYM, for functions (Sun acc)          " link "Procedures"}   Procedures
 @{" N_LBRAC                                  " link "Block Structure"}   Block Structure
 @{" N_LCSYM                                  " link "Statics"}   Statics
 @{" N_LENG                                   " link "N_LENG"}   N_LENG
 @{" N_LSYM, for parameter                    " link "Local Variable Parameters"}   Local Variable Parameters
 @{" N_LSYM, for stack variables              " link "Stack Variables"}   Stack Variables
 @{" N_LSYM, for types                        " link "Typedefs"}   Typedefs
 @{" N_M2C                                    " link "N_M2C"}   N_M2C
 @{" N_MAIN                                   " link "Main Program"}   Main Program
 @{" N_MOD2                                   " link "N_MOD2"}   N_MOD2
 @{" N_NBBSS                                  " link "Gould"}   Gould
 @{" N_NBDATA                                 " link "Gould"}   Gould
 @{" N_NBLCS                                  " link "Gould"}   Gould
 @{" N_NBSTS                                  " link "Gould"}   Gould
 @{" N_NBTEXT                                 " link "Gould"}   Gould
 @{" N_NOMAP                                  " link "N_NOMAP"}   N_NOMAP
 @{" N_NSYMS                                  " link "N_NSYMS"}   N_NSYMS
 @{" N_PC                                     " link "N_PC"}   N_PC
 @{" N_PSYM                                   " link "Parameters"}   Parameters
 @{" N_RBRAC                                  " link "Block Structure"}   Block Structure
 @{" N_ROSYM                                  " link "Statics"}   Statics
 @{" N_RSYM                                   " link "Register Variables"}   Register Variables
 @{" N_RSYM, for parameters                   " link "Register Parameters"}   Register Parameters
 @{" N_SCOPE                                  " link "N_SCOPE"}   N_SCOPE
 @{" N_SLINE                                  " link "Line Numbers"}   Line Numbers
 @{" N_SO                                     " link "Source Files"}   Source Files
 @{" N_SOL                                    " link "Include Files"}   Include Files
 @{" N_SSYM                                   " link "N_SSYM"}   N_SSYM
 @{" N_STSYM                                  " link "Statics"}   Statics
 @{" N_STSYM, for functions (Sun acc)         " link "Procedures"}   Procedures

@endnode

