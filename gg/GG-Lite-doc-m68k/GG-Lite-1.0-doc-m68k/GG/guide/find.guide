@database find.guide

@Master /gg-src/gg/fsf/findutils/doc/find.texi

@Width 72


This is the AmigaGuide®  file find.guide, produced by Makeinfo-1.68 from 
the input file /gg-src/gg/fsf/findutils/doc/find.texi.

START-INFO-DIR-ENTRY
* Finding Files: (find).        Listing and operating on files
                                that match certain criteria.
END-INFO-DIR-ENTRY

   This file documents the GNU utilities for finding files that match
certain criteria and performing various operations on them.

   Copyright (C) 1994 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

@node Main "find.guide"
@next "Introduction"

   This file documents the GNU utilities for finding files that match
certain criteria and performing various actions on them.  This is
edition 1.1, for @{b}find@{ub} version 4.1.


 @{" Introduction               " link "Introduction"}  Summary of the tasks this manual describes.
 @{" Finding Files              " link "Finding Files"}  Finding files that match certain criteria.
 @{" Actions                    " link "Actions"}  Doing things to files you have found.
 @{" Common Tasks               " link "Common Tasks"}  Solutions to common real-world problems.
 @{" Databases                  " link "Databases"}  Maintaining file name databases.
 @{" File Permissions           " link "File Permissions"}  How to control access to files.
 @{" Reference                  " link "Reference"}  Summary of how to invoke the programs.
 @{" Primary Index              " link "Primary Index"}  The components of @{b}find@{ub} expressions.


@endnode

@node "Introduction" "find.guide/Introduction"
@next "Finding Files"
@prev "Main"
@toc "Main"

Introduction
************

   This manual shows how to find files that meet criteria you specify,
and how to perform various actions on the files that you find.  The
principal programs that you use to perform these tasks are @{b}find@{ub},
@{b}locate@{ub}, and @{b}xargs@{ub}.  Some of the examples in this manual use
capabilities specific to the GNU versions of those programs.

   GNU @{b}find@{ub} was originally written by Eric Decker, with enhancements by
David MacKenzie, Jay Plett, and Tim Wood.  GNU @{b}xargs@{ub} was originally
written by Mike Rendell, with enhancements by David MacKenzie.  GNU
@{b}locate@{ub} and its associated utilities were originally written by James
Woods, with enhancements by David MacKenzie.  The idea for @{b}find -print0@{ub}
and @{b}xargs -0@{ub} came from Dan Bernstein.  Many other people have
contributed bug fixes, small improvements, and helpful suggestions.
Thanks!

   Mail suggestions and bug reports for these programs to
@{b}bug-gnu-utils@prep.ai.mit.edu@{ub}.  Please include the version number,
which you can get by running @{b}find --version@{ub}.


 @{" Scope " link "Scope"}  
 @{" Overview " link "Overview"}  
 @{" find Expressions " link "find Expressions"}


@endnode

@node "Scope" "find.guide/Scope"
@next "Overview"
@toc "Introduction"

Scope
=====

   For brevity, the word @{i}file@{ui} in this manual means a regular file, a
directory, a symbolic link, or any other kind of node that has a
directory entry.  A directory entry is also called a @{i}file name@{ui}.  A file
name may contain some, all, or none of the directories in a path that
leads to the file.  These are all examples of what this manual calls
"file names":

     parser.c
     README
     ./budget/may-94.sc
     fred/.cshrc
     /usr/local/include/termcap.h

   A @{i}directory tree@{ui} is a directory and the files it contains, all of
its subdirectories and the files they contain, etc.  It can also be a
single non-directory file.

   These programs enable you to find the files in one or more directory
trees that:

   * have names that contain certain text or match a certain pattern;

   * are links to certain files;

   * were last used during a certain period of time;

   * are within a certain size range;

   * are of a certain type (regular file, directory, symbolic link,
     etc.);

   * are owned by a certain user or group;

   * have certain access permissions;

   * contain text that matches a certain pattern;

   * are within a certain depth in the directory tree;

   * or some combination of the above.

   Once you have found the files you're looking for (or files that are
potentially the ones you're looking for), you can do more to them than
simply list their names.  You can get any combination of the files'
attributes, or process the files in many ways, either individually or in
groups of various sizes.  Actions that you might want to perform on the
files you have found include, but are not limited to:

   * view or edit

   * store in an archive

   * remove or rename

   * change access permissions

   * classify into groups

   This manual describes how to perform each of those tasks, and more.


@endnode

@node "Overview" "find.guide/Overview"
@next "find Expressions"
@prev "Scope"
@toc "Introduction"

Overview
========

   The principal programs used for making lists of files that match
given criteria and running commands on them are @{b}find@{ub}, @{b}locate@{ub}, and
@{b}xargs@{ub}.  An additional command, @{b}updatedb@{ub}, is used by system
administrators to create databases for @{b}locate@{ub} to use.

@{b}   find@{ub} searches for files in a directory hierarchy and prints
information about the files it found.  It is run like this:

     find [FILE...] [EXPRESSION]

Here is a typical use of @{b}find@{ub}.  This example prints the names of all
files in the directory tree rooted in @{b}/usr/src@{ub} whose name ends with @{b}.c@{ub}
and that are larger than 100 Kilobytes.
     find /usr/src -name '*.c' -size +100k -print

@{b}   locate@{ub} searches special file name databases for file names that
match patterns.  The system administrator runs the @{b}updatedb@{ub} program to
create the databases.  @{b}locate@{ub} is run like this:

     locate [OPTION...] PATTERN...

This example prints the names of all files in the default file name
database whose name ends with @{b}Makefile@{ub} or @{b}makefile@{ub}.  Which file names
are stored in the database depends on how the system administrator ran
@{b}updatedb@{ub}.
     locate '*[Mm]akefile'

   The name @{b}xargs@{ub}, pronounced EX-args, means "combine arguments."
@{b}xargs@{ub} builds and executes command lines by gathering together arguments
it reads on the standard input.  Most often, these arguments are lists
of file names generated by @{b}find@{ub}.  @{b}xargs@{ub} is run like this:

     xargs [OPTION...] [COMMAND [INITIAL-ARGUMENTS]]

The following command searches the files listed in the file @{b}file-list@{ub}
and prints all of the lines in them that contain the word @{b}typedef@{ub}.
     xargs grep typedef < file-list


@endnode

@node "find Expressions" "find.guide/find Expressions"
@prev "Overview"
@toc "Introduction"

@{b}find@{ub} Expressions
================

   The expression that @{b}find@{ub} uses to select files consists of one or
more @{i}primaries@{ui}, each of which is a separate command line argument to
@{b}find@{ub}.  @{b}find@{ub} evaluates the expression each time it processes a file.  An
expression can contain any of the following types of primaries:

@{i}options@{ui}
     affect overall operation rather than the processing of a specific
     file;

@{i}tests@{ui}
     return a true or false value, depending on the file's attributes;

@{i}actions@{ui}
     have side effects and return a true or false value; and

@{i}operators@{ui}
     connect the other arguments and affect when and whether they are
     evaluated.

   You can omit the operator between two primaries; it defaults to
@{b}-and@{ub}.  See @{"Combining Primaries With Operators" link "Combining Primaries With Operators"}, for ways to connect
primaries into more complex expressions.  If the expression contains no
actions other than @{b}-prune@{ub}, @{b}-print@{ub} is performed on all files for which
the entire expression is true (see @{"Print File Name" link "Print File Name"}).

   Options take effect immediately, rather than being evaluated for each
file when their place in the expression is reached.  Therefore, for
clarity, it is best to place them at the beginning of the expression.

   Many of the primaries take arguments, which immediately follow them
in the next command line argument to @{b}find@{ub}.  Some arguments are file
names, patterns, or other strings; others are numbers.  Numeric
arguments can be specified as

@{b}+N@{ub}
     for greater than N,

@{b}-N@{ub}
     for less than N,

@{b}N@{ub}
     for exactly N.


@endnode

@node "Finding Files" "find.guide/Finding Files"
@next "Actions"
@prev "Introduction"
@toc "Main"

Finding Files
*************

   By default, @{b}find@{ub} prints to the standard output the names of the
files that match the given criteria.  See @{"Actions" link "Actions"}, for how to get more
information about the matching files.


 @{" Name " link "Name"}  
 @{" Links " link "Links"}  
 @{" Time " link "Time"}  
 @{" Size " link "Size"}  
 @{" Type " link "Type"}  
 @{" Owner " link "Owner"}  
 @{" Permissions " link "Permissions"}  
 @{" Contents " link "Contents"}  
 @{" Directories " link "Directories"}  
 @{" Filesystems " link "Filesystems"}  
 @{" Combining Primaries With Operators " link "Combining Primaries With Operators"}


@endnode

@node "Name" "find.guide/Name"
@next "Links"
@toc "Finding Files"

Name
====

   Here are ways to search for files whose name matches a certain
pattern.  See @{"Shell Pattern Matching" link "Shell Pattern Matching"}, for a description of the PATTERN
arguments to these tests.

   Each of these tests has a case-sensitive version and a
case-insensitive version, whose name begins with @{b}i@{ub}.  In a
case-insensitive comparison, the patterns @{b}fo*@{ub} and @{b}F??@{ub} match the file
names @{b}Foo@{ub}, @{b}FOO@{ub}, @{b}foo@{ub}, @{b}fOo@{ub}, etc.


 @{" Base Name Patterns " link "Base Name Patterns"}  
 @{" Full Name Patterns " link "Full Name Patterns"}  
 @{" Fast Full Name Search " link "Fast Full Name Search"}  
 @{" Shell Pattern Matching " link "Shell Pattern Matching"}  Wildcards used by these programs.


@endnode

@node "Base Name Patterns" "find.guide/Base Name Patterns"
@next "Full Name Patterns"
@toc "Name"

Base Name Patterns
------------------

 - Test: -name PATTERN
 - Test: -iname PATTERN
     True if the base of the file name (the path with the leading
     directories removed) matches shell pattern PATTERN.  For @{b}-iname@{ub},
     the match is case-insensitive.  To ignore a whole directory tree,
     use @{b}-prune@{ub} (see @{"Directories" link "Directories"}).  As an example, to find Texinfo
     source files in @{b}/usr/local/doc@{ub}:

          find /usr/local/doc -name '*.texi'


@endnode

@node "Full Name Patterns" "find.guide/Full Name Patterns"
@next "Fast Full Name Search"
@prev "Base Name Patterns"
@toc "Name"

Full Name Patterns
------------------

 - Test: -path PATTERN
 - Test: -ipath PATTERN
     True if the entire file name, starting with the command line
     argument under which the file was found, matches shell pattern
     PATTERN.  For @{b}-ipath@{ub}, the match is case-insensitive.  To ignore a
     whole directory tree, use @{b}-prune@{ub} rather than checking every file
     in the tree (see @{"Directories" link "Directories"}).

 - Test: -regex EXPR
 - Test: -iregex EXPR
     True if the entire file name matches regular expression EXPR.
     This is a match on the whole path, not a search.  For example, to
     match a file named @{b}./fubar3@{ub}, you can use the regular expression
     @{b}.*bar.@{ub} or @{b}.*b.*3@{ub}, but not @{b}b.*r3@{ub}.  See
     @{"Syntax of Regular Expressions" link "emacs.guide/Regexps"}, for a description of the syntax
     of regular expressions.  For @{b}-iregex@{ub}, the match is
     case-insensitive.


@endnode

@node "Fast Full Name Search" "find.guide/Fast Full Name Search"
@next "Shell Pattern Matching"
@prev "Full Name Patterns"
@toc "Name"

Fast Full Name Search
---------------------

   To search for files by name without having to actually scan the
directories on the disk (which can be slow), you can use the @{b}locate@{ub}
program.  For each shell pattern you give it, @{b}locate@{ub} searches one or
more databases of file names and displays the file names that contain
the pattern.  See @{"Shell Pattern Matching" link "Shell Pattern Matching"}, for details about shell
patterns.

   If a pattern is a plain string--it contains no
metacharacters--@{b}locate@{ub} displays all file names in the database that
contain that string.  If a pattern contains metacharacters, @{b}locate@{ub} only
displays file names that match the pattern exactly.  As a result,
patterns that contain metacharacters should usually begin with a @{b}*@{ub}, and
will most often end with one as well.  The exceptions are patterns that
are intended to explicitly match the beginning or end of a file name.

   The command
     locate PATTERN

   is almost equivalent to
     find DIRECTORIES -name PATTERN

   where DIRECTORIES are the directories for which the file name
databases contain information.  The differences are that the @{b}locate@{ub}
information might be out of date, and that @{b}locate@{ub} handles wildcards in
the pattern slightly differently than @{b}find@{ub} (see
@{"Shell Pattern Matching" link "Shell Pattern Matching"}).

   The file name databases contain lists of files that were on the
system when the databases were last updated.  The system administrator
can choose the file name of the default database, the frequency with
which the databases are updated, and the directories for which they
contain entries.

   Here is how to select which file name databases @{b}locate@{ub} searches.
The default is system-dependent.

@{b}--database=PATH@{ub}
@{b}-d PATH@{ub}
     Instead of searching the default file name database, search the
     file name databases in PATH, which is a colon-separated list of
     database file names.  You can also use the environment variable
     @{b}LOCATE_PATH@{ub} to set the list of database files to search.  The
     option overrides the environment variable if both are used.


@endnode

@node "Shell Pattern Matching" "find.guide/Shell Pattern Matching"
@prev "Fast Full Name Search"
@toc "Name"

Shell Pattern Matching
----------------------

@{b}   find@{ub} and @{b}locate@{ub} can compare file names, or parts of file names, to
shell patterns.  A @{i}shell pattern@{ui} is a string that may contain the
following special characters, which are known as @{i}wildcards@{ui} or
@{i}metacharacters@{ui}.

   You must quote patterns that contain metacharacters to prevent the
shell from expanding them itself.  Double and single quotes both work;
so does escaping with a backslash.

@{b}*@{ub}
     Matches any zero or more characters.

@{b}?@{ub}
     Matches any one character.

@{b}[STRING]@{ub}
     Matches exactly one character that is a member of the string
     STRING.  This is called a @{i}character class@{ui}.  As a shorthand, STRING
     may contain ranges, which consist of two characters with a dash
     between them.  For example, the class @{b}[a-z0-9_]@{ub} matches a
     lowercase letter, a number, or an underscore.  You can negate a
     class by placing a @{b}!@{ub} or @{b}^@{ub} immediately after the opening bracket.
     Thus, @{b}[^A-Z@]@{ub} matches any character except an uppercase letter or
     an at sign.

@{b}\ @{ub}
     Removes the special meaning of the character that follows it.  This
     works even in character classes.

   In the @{b}find@{ub} tests that do shell pattern matching (@{b}-name@{ub}, @{b}-path@{ub},
etc.), wildcards in the pattern do not match a @{b}.@{ub} at the beginning of a
file name.  This is not the case for @{b}locate@{ub}.  Thus, @{b}find -name '*macs'@{ub}
does not match a file named @{b}.emacs@{ub}, but @{b}locate '*macs'@{ub} does.

   Slash characters have no special significance in the shell pattern
matching that @{b}find@{ub} and @{b}locate@{ub} do, unlike in the shell, in which
wildcards do not match them.  Therefore, a pattern @{b}foo*bar@{ub} can match a
file name @{b}foo3/bar@{ub}, and a pattern @{b}./sr*sc@{ub} can match a file name
@{b}./src/misc@{ub}.


@endnode

@node "Links" "find.guide/Links"
@next "Time"
@prev "Name"
@toc "Finding Files"

Links
=====

   There are two ways that files can be linked together.  @{i}Symbolic
links@{ui} are a special type of file whose contents are a portion of the
name of another file.  @{i}Hard links@{ui} are multiple directory entries for
one file; the file names all have the same index node (@{i}inode@{ui}) number on
the disk.


 @{" Symbolic Links " link "Symbolic Links"}  
 @{" Hard Links   " link "Hard Links"}


@endnode

@node "Symbolic Links" "find.guide/Symbolic Links"
@next "Hard Links"
@toc "Links"

Symbolic Links
--------------

 - Test: -lname PATTERN
 - Test: -ilname PATTERN
     True if the file is a symbolic link whose contents match shell
     pattern PATTERN.  For @{b}-ilname@{ub}, the match is case-insensitive.  See
     @{"Shell Pattern Matching" link "Shell Pattern Matching"}, for details about the PATTERN argument.
     So, to list any symbolic links to @{b}sysdep.c@{ub} in the current
     directory and its subdirectories, you can do:

          find . -lname '*sysdep.c'

 - Option: -follow
     Dereference symbolic links.  The following differences in behavior
     occur when this option is given:

        * @{b}find@{ub} follows symbolic links to directories when searching
          directory trees.

        * @{b}-lname@{ub} and @{b}-ilname@{ub} always return false.

        * @{b}-type@{ub} reports the types of the files that symbolic links point
          to.

        * Implies @{b}-noleaf@{ub} (see @{"Directories" link "Directories"}).


@endnode

@node "Hard Links" "find.guide/Hard Links"
@prev "Symbolic Links"
@toc "Links"

Hard Links
----------

   To find hard links, first get the inode number of the file whose
links you want to find.  You can learn a file's inode number and the
number of links to it by running @{b}ls -i@{ub} or @{b}find -ls@{ub}.  If the file has
more than one link, you can search for the other links by passing that
inode number to @{b}-inum@{ub}.  Add the @{b}-xdev@{ub} option if you are starting the
search at a directory that has other filesystems mounted on it, such as
@{b}/usr@{ub} on many systems.  Doing this saves needless searching, since hard
links to a file must be on the same filesystem.  See @{"Filesystems" link "Filesystems"}.

 - Test: -inum N
     File has inode number N.

   You can also search for files that have a certain number of links,
with @{b}-links@{ub}.  Directories normally have at least two hard links; their
@{b}.@{ub} entry is the second one.  If they have subdirectories, each of those
also has a hard link called @{b}..@{ub} to its parent directory.

 - Test: -links N
     File has N hard links.


@endnode

@node "Time" "find.guide/Time"
@next "Size"
@prev "Links"
@toc "Finding Files"

Time
====

   Each file has three time stamps, which record the last time that
certain operations were performed on the file:

  1. access (read the file's contents)

  2. change the status (modify the file or its attributes)

  3. modify (change the file's contents)

   You can search for files whose time stamps are within a certain age
range, or compare them to other time stamps.


 @{" Age Ranges " link "Age Ranges"}  
 @{" Comparing Timestamps " link "Comparing Timestamps"}


@endnode

@node "Age Ranges" "find.guide/Age Ranges"
@next "Comparing Timestamps"
@toc "Time"

Age Ranges
----------

   These tests are mainly useful with ranges (@{b}+N@{ub} and @{b}-N@{ub}).

 - Test: -atime N
 - Test: -ctime N
 - Test: -mtime N
     True if the file was last accessed (or its status changed, or it
     was modified) N*24 hours ago.

 - Test: -amin N
 - Test: -cmin N
 - Test: -mmin N
     True if the file was last accessed (or its status changed, or it
     was modified) N minutes ago.  These tests provide finer
     granularity of measurement than @{b}-atime@{ub} et al.  For example, to
     list files in @{b}/u/bill@{ub} that were last read from 2 to 6 hours ago:

          find /u/bill -amin +2 -amin -6

 - Option: -daystart
     Measure times from the beginning of today rather than from 24
     hours ago.  So, to list the regular files in your home directory
     that were modified yesterday, do

          find ~ -daystart -type f -mtime 1


@endnode

@node "Comparing Timestamps" "find.guide/Comparing Timestamps"
@prev "Age Ranges"
@toc "Time"

Comparing Timestamps
--------------------

   As an alternative to comparing timestamps to the current time, you
can compare them to another file's timestamp.  That file's timestamp
could be updated by another program when some event occurs.  Or you
could set it to a particular fixed date using the @{b}touch@{ub} command.  For
example, to list files in @{b}/usr@{ub} modified after February 1 of the current
year:

     touch -t 02010000 /tmp/stamp$$
     find /usr -newer /tmp/stamp$$
     rm -f /tmp/stamp$$

 - Test: -anewer FILE
 - Test: -cnewer FILE
 - Test: -newer FILE
     True if the file was last accessed (or its status changed, or it
     was modified) more recently than FILE was modified.  These tests
     are affected by @{b}-follow@{ub} only if @{b}-follow@{ub} comes before them on the
     command line.  See @{"Symbolic Links" link "Symbolic Links"}, for more information on
     @{b}-follow@{ub}.  As an example, to list any files modified since @{b}/bin/sh@{ub}
     was last modified:

          find . -newer /bin/sh

 - Test: -used N
     True if the file was last accessed N days after its status was
     last changed.  Useful for finding files that are not being used,
     and could perhaps be archived or removed to save disk space.


@endnode

@node "Size" "find.guide/Size"
@next "Type"
@prev "Time"
@toc "Finding Files"

Size
====

 - Test: -size N[BCKW]
     True if the file uses N units of space, rounding up.  The units
     are 512-byte blocks by default, but they can be changed by adding a
     one-character suffix to N:

    @{b}b@{ub}
          512-byte blocks

    @{b}c@{ub}
          bytes

    @{b}k@{ub}
          kilobytes (1024 bytes)

    @{b}w@{ub}
          2-byte words

     The size does not count indirect blocks, but it does count blocks
     in sparse files that are not actually allocated.

 - Test: -empty
     True if the file is empty and is either a regular file or a
     directory.  This might make it a good candidate for deletion.
     This test is useful with @{b}-depth@{ub} (see @{"Directories" link "Directories"}) and @{b}-exec rm
     -rf '{}' ';'@{ub} (see @{"Single File" link "Single File"}).


@endnode

@node "Type" "find.guide/Type"
@next "Owner"
@prev "Size"
@toc "Finding Files"

Type
====

 - Test: -type C
     True if the file is of type C:

    @{b}b@{ub}
          block (buffered) special

    @{b}c@{ub}
          character (unbuffered) special

    @{b}d@{ub}
          directory

    @{b}p@{ub}
          named pipe (FIFO)

    @{b}f@{ub}
          regular file

    @{b}l@{ub}
          symbolic link

    @{b}s@{ub}
          socket

 - Test: -xtype C
     The same as @{b}-type@{ub} unless the file is a symbolic link.  For
     symbolic links: if @{b}-follow@{ub} has not been given, true if the file is
     a link to a file of type C; if @{b}-follow@{ub} has been given, true if C
     is @{b}l@{ub}.  In other words, for symbolic links, @{b}-xtype@{ub} checks the type
     of the file that @{b}-type@{ub} does not check.  See @{"Symbolic Links" link "Symbolic Links"}, for
     more information on @{b}-follow@{ub}.


@endnode

@node "Owner" "find.guide/Owner"
@next "Permissions"
@prev "Type"
@toc "Finding Files"

Owner
=====

 - Test: -user UNAME
 - Test: -group GNAME
     True if the file is owned by user UNAME (belongs to group GNAME).
     A numeric ID is allowed.

 - Test: -uid N
 - Test: -gid N
     True if the file's numeric user ID (group ID) is N.  These tests
     support ranges (@{b}+N@{ub} and @{b}-N@{ub}), unlike @{b}-user@{ub} and @{b}-group@{ub}.

 - Test: -nouser
 - Test: -nogroup
     True if no user corresponds to the file's numeric user ID (no group
     corresponds to the numeric group ID).  These cases usually mean
     that the files belonged to users who have since been removed from
     the system.  You probably should change the ownership of such
     files to an existing user or group, using the @{b}chown@{ub} or @{b}chgrp@{ub}
     program.


@endnode

@node "Permissions" "find.guide/Permissions"
@next "Contents"
@prev "Owner"
@toc "Finding Files"

Permissions
===========

   See @{"File Permissions" link "File Permissions"}, for information on how file permissions are
structured and how to specify them.

 - Test: -perm MODE
     True if the file's permissions are exactly MODE (which can be
     numeric or symbolic).  Symbolic modes use mode 0 as a point of
     departure.  If MODE starts with @{b}-@{ub}, true if @{i}all@{ui} of the permissions
     set in MODE are set for the file; permissions not set in MODE are
     ignored.  If MODE starts with @{b}+@{ub}, true if @{i}any@{ui} of the permissions
     set in MODE are set for the file; permissions not set in MODE are
     ignored.


@endnode

@node "Contents" "find.guide/Contents"
@next "Directories"
@prev "Permissions"
@toc "Finding Files"

Contents
========

   To search for files based on their contents, you can use the @{b}grep@{ub}
program.  For example, to find out which C source files in the current
directory contain the string @{b}thing@{ub}, you can do:

     grep -l thing *.[ch]

   If you also want to search for the string in files in subdirectories,
you can combine @{b}grep@{ub} with @{b}find@{ub} and @{b}xargs@{ub}, like this:

     find . -name '*.[ch]' | xargs grep -l thing

   The @{b}-l@{ub} option causes @{b}grep@{ub} to print only the names of files that
contain the string, rather than the lines that contain it.  The string
argument (@{b}thing@{ub}) is actually a regular expression, so it can contain
metacharacters.  This method can be refined a little by using the @{b}-r@{ub}
option to make @{b}xargs@{ub} not run @{b}grep@{ub} if @{b}find@{ub} produces no output, and using
the @{b}find@{ub} action @{b}-print0@{ub} and the @{b}xargs@{ub} option @{b}-0@{ub} to avoid
misinterpreting files whose names contain spaces:

     find . -name '*.[ch]' -print0 | xargs -r -0 grep -l thing

   For a fuller treatment of finding files whose contents match a
pattern, see the manual page for @{b}grep@{ub}.


@endnode

@node "Directories" "find.guide/Directories"
@next "Filesystems"
@prev "Contents"
@toc "Finding Files"

Directories
===========

   Here is how to control which directories @{b}find@{ub} searches, and how it
searches them.  These two options allow you to process a horizontal
slice of a directory tree.

 - Option: -maxdepth LEVELS
     Descend at most LEVELS (a non-negative integer) levels of
     directories below the command line arguments.  @{b}-maxdepth 0@{ub} means
     only apply the tests and actions to the command line arguments.

 - Option: -mindepth LEVELS
     Do not apply any tests or actions at levels less than LEVELS (a
     non-negative integer).  @{b}-mindepth 1@{ub} means process all files except
     the command line arguments.

 - Option: -depth
     Process each directory's contents before the directory itself.
     Doing this is a good idea when producing lists of files to archive
     with @{b}cpio@{ub} or @{b}tar@{ub}.  If a directory does not have write permission
     for its owner, its contents can still be restored from the archive
     since the directory's permissions are restored after its contents.

 - Action: -prune
     If @{b}-depth@{ub} is not given, true; do not descend the current
     directory.  If @{b}-depth@{ub} is given, false; no effect.  @{b}-prune@{ub} only
     affects tests and actions that come after it in the expression, not
     those that come before.

     For example, to skip the directory @{b}src/emacs@{ub} and all files and
     directories under it, and print the names of the other files found:

          find . -path './src/emacs' -prune -o -print

 - Option: -noleaf
     Do not optimize by assuming that directories contain 2 fewer
     subdirectories than their hard link count.  This option is needed
     when searching filesystems that do not follow the Unix
     directory-link convention, such as CD-ROM or MS-DOS filesystems or
     AFS volume mount points.  Each directory on a normal Unix
     filesystem has at least 2 hard links: its name and its @{b}.@{ub}  entry.
     Additionally, its subdirectories (if any) each have a @{b}..@{ub}  entry
     linked to that directory.  When @{b}find@{ub} is examining a directory,
     after it has statted 2 fewer subdirectories than the directory's
     link count, it knows that the rest of the entries in the directory
     are non-directories (@{i}leaf@{ui} files in the directory tree).  If only
     the files' names need to be examined, there is no need to stat
     them; this gives a significant increase in search speed.


@endnode

@node "Filesystems" "find.guide/Filesystems"
@next "Combining Primaries With Operators"
@prev "Directories"
@toc "Finding Files"

Filesystems
===========

   A @{i}filesystem@{ui} is a section of a disk, either on the local host or
mounted from a remote host over a network.  Searching network
filesystems can be slow, so it is common to make @{b}find@{ub} avoid them.

   There are two ways to avoid searching certain filesystems.  One way
is to tell @{b}find@{ub} to only search one filesystem:

 - Option: -xdev
 - Option: -mount
     Don't descend directories on other filesystems.  These options are
     synonyms.

   The other way is to check the type of filesystem each file is on, and
not descend directories that are on undesirable filesystem types:

 - Test: -fstype TYPE
     True if the file is on a filesystem of type TYPE.  The valid
     filesystem types vary among different versions of Unix; an
     incomplete list of filesystem types that are accepted on some
     version of Unix or another is:
          ufs 4.2 4.3 nfs tmp mfs S51K S52K
     You can use @{b}-printf@{ub} with the @{b}%F@{ub} directive to see the types of your
     filesystems.  See @{"Print File Information" link "Print File Information"}.  @{b}-fstype@{ub} is usually
     used with @{b}-prune@{ub} to avoid searching remote filesystems (see
     @{"Directories" link "Directories"}).


@endnode

@node "Combining Primaries With Operators" "find.guide/Combining Primaries With Operators"
@prev "Filesystems"
@toc "Finding Files"

Combining Primaries With Operators
==================================

   Operators build a complex expression from tests and actions.  The
operators are, in order of decreasing precedence:

@{b}( EXPR )@{ub}
     Force precedence.  True if EXPR is true.

@{b}! EXPR@{ub}
@{b}-not EXPR@{ub}
     True if EXPR is false.

@{b}EXPR1 EXPR2@{ub}
@{b}EXPR1 -a EXPR2@{ub}
@{b}EXPR1 -and EXPR2@{ub}
     And; EXPR2 is not evaluated if EXPR1 is false.

@{b}EXPR1 -o EXPR2@{ub}
@{b}EXPR1 -or EXPR2@{ub}
     Or; EXPR2 is not evaluated if EXPR1 is true.

@{b}EXPR1 , EXPR2@{ub}
     List; both EXPR1 and EXPR2 are always evaluated.  True if EXPR2 is
     true.  The value of EXPR1 is discarded.  This operator lets you do
     multiple independent operations on one traversal, without
     depending on whether other operations succeeded.

@{b}   find@{ub} searches the directory tree rooted at each file name by
evaluating the expression from left to right, according to the rules of
precedence, until the outcome is known (the left hand side is false for
@{b}-and@{ub}, true for @{b}-or@{ub}), at which point @{b}find@{ub} moves on to the next file name.

   There are two other tests that can be useful in complex expressions:

 - Test: -true
     Always true.

 - Test: -false
     Always false.


@endnode

@node "Actions" "find.guide/Actions"
@next "Common Tasks"
@prev "Finding Files"
@toc "Main"

Actions
*******

   There are several ways you can print information about the files that
match the criteria you gave in the @{b}find@{ub} expression.  You can print the
information either to the standard output or to a file that you name.
You can also execute commands that have the file names as arguments.
You can use those commands as further filters to select files.


 @{" Print File Name " link "Print File Name"}  
 @{" Print File Information " link "Print File Information"}  
 @{" Run Commands  " link "Run Commands"}  
 @{" Adding Tests  " link "Adding Tests"}


@endnode

@node "Print File Name" "find.guide/Print File Name"
@next "Print File Information"
@toc "Actions"

Print File Name
===============

 - Action: -print
     True; print the full file name on the standard output, followed by
     a newline.

 - Action: -fprint FILE
     True; print the full file name into file FILE, followed by a
     newline.  If FILE does not exist when @{b}find@{ub} is run, it is created;
     if it does exist, it is truncated to 0 bytes.  The file names
     @{b}/dev/stdout@{ub} and @{b}/dev/stderr@{ub} are handled specially; they refer to
     the standard output and standard error output, respectively.


@endnode

@node "Print File Information" "find.guide/Print File Information"
@next "Run Commands"
@prev "Print File Name"
@toc "Actions"

Print File Information
======================

 - Action: -ls
     True; list the current file in @{b}ls -dils@{ub} format on the standard
     output.  The output looks like this:

          204744   17 -rw-r--r--   1 djm      staff       17337 Nov  2  1992 ./lwall-quotes

     The fields are:

       1. The inode number of the file.  See @{"Hard Links" link "Hard Links"}, for how to
          find files based on their inode number.

       2. the number of blocks in the file.  The block counts are of 1K
          blocks, unless the environment variable @{b}POSIXLY_CORRECT@{ub} is
          set, in which case 512-byte blocks are used.  See @{"Size" link "Size"}, for
          how to find files based on their size.

       3. The file's type and permissions.  The type is shown as a dash
          for a regular file; for other file types, a letter like for
          @{b}-type@{ub} is used (see @{"Type" link "Type"}).  The permissions are read, write,
          and execute for the file's owner, its group, and other users,
          respectively; a dash means the permission is not granted.
          See @{"File Permissions" link "File Permissions"}, for more details about file
          permissions.  See @{"Permissions" link "Permissions"}, for how to find files based
          on their permissions.

       4. The number of hard links to the file.

       5. The user who owns the file.

       6. The file's group.

       7. The file's size in bytes.

       8. The date the file was last modified.

       9. The file's name.  @{b}-ls@{ub} quotes non-printable characters in the
          file names using C-like backslash escapes.

 - Action: -fls FILE
     True; like @{b}-ls@{ub} but write to FILE like @{b}-fprint@{ub} (see
     @{"Print File Name" link "Print File Name"}).

 - Action: -printf FORMAT
     True; print FORMAT on the standard output, interpreting @{b}\ @{ub} escapes
     and @{b}%@{ub} directives.  Field widths and precisions can be specified as
     with the @{b}printf@{ub} C function.  Unlike @{b}-print@{ub}, @{b}-printf@{ub} does not add a
     newline at the end of the string.

 - Action: -fprintf FILE FORMAT
     True; like @{b}-printf@{ub} but write to FILE like @{b}-fprint@{ub} (see
     @{"Print File Name" link "Print File Name"}).


 @{" Escapes " link "Escapes"}  
 @{" Format Directives " link "Format Directives"}  
 @{" Time Formats " link "Time Formats"}


@endnode

@node "Escapes" "find.guide/Escapes"
@next "Format Directives"
@toc "Print File Information"

Escapes
-------

   The escapes that @{b}-printf@{ub} and @{b}-fprintf@{ub} recognize are:

@{b}\a@{ub}
     Alarm bell.

@{b}\b@{ub}
     Backspace.

@{b}\c@{ub}
     Stop printing from this format immediately and flush the output.

@{b}\f@{ub}
     Form feed.

@{b}\n@{ub}
     Newline.

@{b}\r@{ub}
     Carriage return.

@{b}\t@{ub}
     Horizontal tab.

@{b}\v@{ub}
     Vertical tab.

@{b}\\ @{ub}
     A literal backslash (@{b}\ @{ub}).

   A @{b}\ @{ub} character followed by any other character is treated as an
ordinary character, so they both are printed, and a warning message is
printed to the standard error output (because it was probably a typo).


@endnode

@node "Format Directives" "find.guide/Format Directives"
@next "Time Formats"
@prev "Escapes"
@toc "Print File Information"

Format Directives
-----------------

@{b}   -printf@{ub} and @{b}-fprintf@{ub} support the following format directives to
print information about the file being processed.  Unlike the C @{b}printf@{ub}
function, they do not support field width specifiers.

@{b}   %%@{ub} is a literal percent sign.  A @{b}%@{ub} character followed by any other
character is discarded (but the other character is printed), and a
warning message is printed to the standard error output (because it was
probably a typo).


 @{" Name Directives " link "Name Directives"}  
 @{" Ownership Directives " link "Ownership Directives"}  
 @{" Size Directives " link "Size Directives"}  
 @{" Location Directives " link "Location Directives"}  
 @{" Time Directives " link "Time Directives"}


@endnode

@node "Name Directives" "find.guide/Name Directives"
@next "Ownership Directives"
@toc "Format Directives"

Name Directives
...............

@{b}%p@{ub}
     File's name.

@{b}%f@{ub}
     File's name with any leading directories removed (only the last
     element).

@{b}%h@{ub}
     Leading directories of file's name (all but the last element and
     the slash before it).

@{b}%P@{ub}
     File's name with the name of the command line argument under which
     it was found removed from the beginning.

@{b}%H@{ub}
     Command line argument under which file was found.


@endnode

@node "Ownership Directives" "find.guide/Ownership Directives"
@next "Size Directives"
@prev "Name Directives"
@toc "Format Directives"

Ownership Directives
....................

@{b}%g@{ub}
     File's group name, or numeric group ID if the group has no name.

@{b}%G@{ub}
     File's numeric group ID.

@{b}%u@{ub}
     File's user name, or numeric user ID if the user has no name.

@{b}%U@{ub}
     File's numeric user ID.

@{b}%m@{ub}
     File's permissions (in octal).


@endnode

@node "Size Directives" "find.guide/Size Directives"
@next "Location Directives"
@prev "Ownership Directives"
@toc "Format Directives"

Size Directives
...............

@{b}%k@{ub}
     File's size in 1K blocks (rounded up).

@{b}%b@{ub}
     File's size in 512-byte blocks (rounded up).

@{b}%s@{ub}
     File's size in bytes.


@endnode

@node "Location Directives" "find.guide/Location Directives"
@next "Time Directives"
@prev "Size Directives"
@toc "Format Directives"

Location Directives
...................

@{b}%d@{ub}
     File's depth in the directory tree; files named on the command line
     have a depth of 0.

@{b}%F@{ub}
     Type of the filesystem the file is on; this value can be used for
     @{b}-fstype@{ub} (see @{"Directories" link "Directories"}).

@{b}%l@{ub}
     Object of symbolic link (empty string if file is not a symbolic
     link).

@{b}%i@{ub}
     File's inode number (in decimal).

@{b}%n@{ub}
     Number of hard links to file.


@endnode

@node "Time Directives" "find.guide/Time Directives"
@prev "Location Directives"
@toc "Format Directives"

Time Directives
...............

   Some of these directives use the C @{b}ctime@{ub} function.  Its output
depends on the current locale, but it typically looks like

     Wed Nov  2 00:42:36 1994

@{b}%a@{ub}
     File's last access time in the format returned by the C @{b}ctime@{ub}
     function.

@{b}%AK@{ub}
     File's last access time in the format specified by K (see
     @{"Time Formats" link "Time Formats"}).

@{b}%c@{ub}
     File's last status change time in the format returned by the C
     @{b}ctime@{ub} function.

@{b}%CK@{ub}
     File's last status change time in the format specified by K (see
     @{"Time Formats" link "Time Formats"}).

@{b}%t@{ub}
     File's last modification time in the format returned by the C @{b}ctime@{ub}
     function.

@{b}%TK@{ub}
     File's last modification time in the format specified by K (see
     @{"Time Formats" link "Time Formats"}).


@endnode

@node "Time Formats" "find.guide/Time Formats"
@prev "Format Directives"
@toc "Print File Information"

Time Formats
------------

   Below are the formats for the directives @{b}%A@{ub}, @{b}%C@{ub}, and @{b}%T@{ub}, which print
the file's timestamps.  Some of these formats might not be available on
all systems, due to differences in the C @{b}strftime@{ub} function between
systems.


 @{" Time Components " link "Time Components"}  
 @{" Date Components " link "Date Components"}  
 @{" Combined Time Formats " link "Combined Time Formats"}


@endnode

@node "Time Components" "find.guide/Time Components"
@next "Date Components"
@toc "Time Formats"

Time Components
...............

   The following format directives print single components of the time.

@{b}H@{ub}
     hour (00..23)

@{b}I@{ub}
     hour (01..12)

@{b}k@{ub}
     hour ( 0..23)

@{b}l@{ub}
     hour ( 1..12)

@{b}p@{ub}
     locale's AM or PM

@{b}Z@{ub}
     time zone (e.g., EDT), or nothing if no time zone is determinable

@{b}M@{ub}
     minute (00..59)

@{b}S@{ub}
     second (00..61)

@{b}@@{ub}
     seconds since Jan. 1, 1970, 00:00 GMT.


@endnode

@node "Date Components" "find.guide/Date Components"
@next "Combined Time Formats"
@prev "Time Components"
@toc "Time Formats"

Date Components
...............

   The following format directives print single components of the date.

@{b}a@{ub}
     locale's abbreviated weekday name (Sun..Sat)

@{b}A@{ub}
     locale's full weekday name, variable length (Sunday..Saturday)

@{b}b@{ub}
@{b}h@{ub}
     locale's abbreviated month name (Jan..Dec)

@{b}B@{ub}
     locale's full month name, variable length (January..December)

@{b}m@{ub}
     month (01..12)

@{b}d@{ub}
     day of month (01..31)

@{b}w@{ub}
     day of week (0..6)

@{b}j@{ub}
     day of year (001..366)

@{b}U@{ub}
     week number of year with Sunday as first day of week (00..53)

@{b}W@{ub}
     week number of year with Monday as first day of week (00..53)

@{b}Y@{ub}
     year (1970...)

@{b}y@{ub}
     last two digits of year (00..99)


@endnode

@node "Combined Time Formats" "find.guide/Combined Time Formats"
@prev "Date Components"
@toc "Time Formats"

Combined Time Formats
.....................

   The following format directives print combinations of time and date
components.

@{b}r@{ub}
     time, 12-hour (hh:mm:ss [AP]M)

@{b}T@{ub}
     time, 24-hour (hh:mm:ss)

@{b}X@{ub}
     locale's time representation (H:M:S)

@{b}c@{ub}
     locale's date and time (Sat Nov 04 12:02:33 EST 1989)

@{b}D@{ub}
     date (mm/dd/yy)

@{b}x@{ub}
     locale's date representation (mm/dd/yy)


@endnode

@node "Run Commands" "find.guide/Run Commands"
@next "Adding Tests"
@prev "Print File Information"
@toc "Actions"

Run Commands
============

   You can use the list of file names created by @{b}find@{ub} or @{b}locate@{ub} as
arguments to other commands.  In this way you can perform arbitrary
actions on the files.


 @{" Single File " link "Single File"}  
 @{" Multiple Files " link "Multiple Files"}  
 @{" Querying  " link "Querying"}


@endnode

@node "Single File" "find.guide/Single File"
@next "Multiple Files"
@toc "Run Commands"

Single File
-----------

   Here is how to run a command on one file at a time.

 - Action: -exec COMMAND ;
     Execute COMMAND; true if 0 status is returned.  @{b}find@{ub} takes all
     arguments after @{b}-exec@{ub} to be part of the command until an argument
     consisting of @{b};@{ub} is reached.  It replaces the string @{b}{}@{ub} by the
     current file name being processed everywhere it occurs in the
     command.  Both of these constructions need to be escaped (with a @{b}\
     @{ub}) or quoted to protect them from expansion by the shell.  The
     command is executed in the directory in which @{b}find@{ub} was run.

     For example, to compare each C header file in the current
     directory with the file @{b}/tmp/master@{ub}:

          find . -name '*.h' -exec diff -u '{}' /tmp/master ';'


@endnode

@node "Multiple Files" "find.guide/Multiple Files"
@next "Querying"
@prev "Single File"
@toc "Run Commands"

Multiple Files
--------------

   Sometimes you need to process files alone.  But when you don't, it
is faster to run a command on as many files as possible at a time,
rather than once per file.  Doing this saves on the time it takes to
start up the command each time.

   To run a command on more than one file at once, use the @{b}xargs@{ub}
command, which is invoked like this:

     xargs [OPTION...] [COMMAND [INITIAL-ARGUMENTS]]

@{b}   xargs@{ub} reads arguments from the standard input, delimited by blanks
(which can be protected with double or single quotes or a backslash) or
newlines.  It executes the COMMAND (default is @{b}/bin/echo@{ub}) one or more
times with any INITIAL-ARGUMENTS followed by arguments read from
standard input.  Blank lines on the standard input are ignored.

   Instead of blank-delimited names, it is safer to use @{b}find -print0@{ub} or
@{b}find -fprint0@{ub} and process the output by giving the @{b}-0@{ub} or @{b}--null@{ub} option
to GNU @{b}xargs@{ub}, GNU @{b}tar@{ub}, GNU @{b}cpio@{ub}, or @{b}perl@{ub}.

   You can use shell command substitution (backquotes) to process a
list of arguments, like this:

     grep -l sprintf `find $HOME -name '*.c' -print`

   However, that method produces an error if the length of the @{b}.c@{ub} file
names exceeds the operating system's command-line length limit.  @{b}xargs@{ub}
avoids that problem by running the command as many times as necessary
without exceeding the limit:

     find $HOME -name '*.c' -print | grep -l sprintf

   However, if the command needs to have its standard input be a
terminal (@{b}less@{ub}, for example), you have to use the shell command
substitution method.


 @{" Unsafe File Name Handling " link "Unsafe File Name Handling"}  
 @{" Safe File Name Handling " link "Safe File Name Handling"}  
 @{" Limiting Command Size   " link "Limiting Command Size"}  
 @{" Interspersing File Names " link "Interspersing File Names"}


@endnode

@node "Unsafe File Name Handling" "find.guide/Unsafe File Name Handling"
@next "Safe File Name Handling"
@toc "Multiple Files"

Unsafe File Name Handling
.........................

   Because file names can contain quotes, backslashes, blank characters,
and even newlines, it is not safe to process them using @{b}xargs@{ub} in its
default mode of operation.  But since most files' names do not contain
blanks, this problem occurs only infrequently.  If you are only
searching through files that you know have safe names, then you need not
be concerned about it.

   In many applications, if @{b}xargs@{ub} botches processing a file because its
name contains special characters, some data might be lost.  The
importance of this problem depends on the importance of the data and
whether anyone notices the loss soon enough to correct it.  However,
here is an extreme example of the problems that using blank-delimited
names can cause.  If the following command is run daily from @{b}cron@{ub}, then
any user can remove any file on the system:

     find / -name '#*' -atime +7 -print | xargs rm

   For example, you could do something like this:

     eg$ echo > '#
     vmunix'

and then @{b}cron@{ub} would delete @{b}/vmunix@{ub}, if it ran @{b}xargs@{ub} with @{b}/@{ub} as its
current directory.

   To delete other files, for example @{b}/u/joeuser/.plan@{ub}, you could do
this:

     eg$ mkdir '#
     '
     eg$ cd '#
     '
     eg$ mkdir u u/joeuser u/joeuser/.plan'
     '
     eg$ echo > u/joeuser/.plan'
     /#foo'
     eg$ cd ..
     eg$ find . -name '#*' -print | xargs echo
     ./# ./# /u/joeuser/.plan /#foo


@endnode

@node "Safe File Name Handling" "find.guide/Safe File Name Handling"
@next "Limiting Command Size"
@prev "Unsafe File Name Handling"
@toc "Multiple Files"

Safe File Name Handling
.......................

   Here is how to make @{b}find@{ub} output file names so that they can be used
by other programs without being mangled or misinterpreted.  You can
process file names generated this way by giving the @{b}-0@{ub} or @{b}--null@{ub} option
to GNU @{b}xargs@{ub}, GNU @{b}tar@{ub}, GNU @{b}cpio@{ub}, or @{b}perl@{ub}.

 - Action: -print0
     True; print the full file name on the standard output, followed by
     a null character.

 - Action: -fprint0 FILE
     True; like @{b}-print0@{ub} but write to FILE like @{b}-fprint@{ub} (see
     @{"Print File Name" link "Print File Name"}).


@endnode

@node "Limiting Command Size" "find.guide/Limiting Command Size"
@next "Interspersing File Names"
@prev "Safe File Name Handling"
@toc "Multiple Files"

Limiting Command Size
.....................

@{b}   xargs@{ub} gives you control over how many arguments it passes to the
command each time it executes it.  By default, it uses up to @{b}ARG_MAX@{ub} -
2k, or 20k, whichever is smaller, characters per command.  It uses as
many lines and arguments as fit within that limit.  The following
options modify those values.

@{b}--no-run-if-empty@{ub}
@{b}-r@{ub}
     If the standard input does not contain any nonblanks, do not run
     the command.  By default, the command is run once even if there is
     no input.

@{b}--max-lines[=MAX-LINES]@{ub}
@{b}-l[MAX-LINES]@{ub}
     Use at most MAX-LINES nonblank input lines per command line;
     MAX-LINES defaults to 1 if omitted.  Trailing blanks cause an
     input line to be logically continued on the next input line, for
     the purpose of counting the lines.  Implies @{b}-x@{ub}.

@{b}--max-args=MAX-ARGS@{ub}
@{b}-n MAX-ARGS@{ub}
     Use at most MAX-ARGS arguments per command line.  Fewer than
     MAX-ARGS arguments will be used if the size (see the @{b}-s@{ub} option) is
     exceeded, unless the @{b}-x@{ub} option is given, in which case @{b}xargs@{ub} will
     exit.

@{b}--max-chars=MAX-CHARS@{ub}
@{b}-s MAX-CHARS@{ub}
     Use at most MAX-CHARS characters per command line, including the
     command and initial arguments and the terminating nulls at the
     ends of the argument strings.

@{b}--max-procs=MAX-PROCS@{ub}
@{b}-P MAX-PROCS@{ub}
     Run up to MAX-PROCS processes at a time; the default is 1.  If
     MAX-PROCS is 0, @{b}xargs@{ub} will run as many processes as possible at a
     time.  Use the @{b}-n@{ub}, @{b}-s@{ub}, or @{b}-l@{ub} option with @{b}-P@{ub}; otherwise chances are
     that the command will be run only once.


@endnode

@node "Interspersing File Names" "find.guide/Interspersing File Names"
@prev "Limiting Command Size"
@toc "Multiple Files"

Interspersing File Names
........................

@{b}   xargs@{ub} can insert the name of the file it is processing between
arguments you give for the command.  Unless you also give options to
limit the command size (see @{"Limiting Command Size" link "Limiting Command Size"}), this mode of
operation is equivalent to @{b}find -exec@{ub} (see @{"Single File" link "Single File"}).

@{b}--replace[=REPLACE-STR]@{ub}
@{b}-i[REPLACE-STR]@{ub}
     Replace occurences of REPLACE-STR in the initial arguments with
     names read from standard input.  Also, unquoted blanks do not
     terminate arguments.  If REPLACE-STR is omitted, it defaults to @{b}{}@{ub}
     (like for @{b}find -exec@{ub}).  Implies @{b}-x@{ub} and @{b}-l 1@{ub}.  As an example, to
     sort each file the @{b}bills@{ub} directory, leaving the output in that
     file name with @{b}.sorted@{ub} appended, you could do:

          find bills -type f | xargs -iXX sort -o XX.sorted XX

     The equivalent command using @{b}find -exec@{ub} is:

          find bills -type f -exec sort -o '{}.sorted' '{}' ';'


@endnode

@node "Querying" "find.guide/Querying"
@prev "Multiple Files"
@toc "Run Commands"

Querying
--------

   To ask the user whether to execute a command on a single file, you
can use the @{b}find@{ub} primary @{b}-ok@{ub} instead of @{b}-exec@{ub}:

 - Action: -ok COMMAND ;
     Like @{b}-exec@{ub} (see @{"Single File" link "Single File"}), but ask the user first (on the
     standard input); if the response does not start with @{b}y@{ub} or @{b}Y@{ub}, do
     not run the command, and return false.

   When processing multiple files with a single command, to query the
user you give @{b}xargs@{ub} the following option.  When using this option, you
might find it useful to control the number of files processed per
invocation of the command (see @{"Limiting Command Size" link "Limiting Command Size"}).

@{b}--interactive@{ub}
@{b}-p@{ub}
     Prompt the user about whether to run each command line and read a
     line from the terminal.  Only run the command line if the response
     starts with @{b}y@{ub} or @{b}Y@{ub}.  Implies @{b}-t@{ub}.


@endnode

@node "Adding Tests" "find.guide/Adding Tests"
@prev "Run Commands"
@toc "Actions"

Adding Tests
============

   You can test for file attributes that none of the @{b}find@{ub} builtin tests
check.  To do this, use @{b}xargs@{ub} to run a program that filters a list of
files printed by @{b}find@{ub}.  If possible, use @{b}find@{ub} builtin tests to pare
down the list, so the program run by @{b}xargs@{ub} has less work to do.  The
tests builtin to @{b}find@{ub} will likely run faster than tests that other
programs perform.

   For example, here is a way to print the names of all of the
unstripped binaries in the @{b}/usr/local@{ub} directory tree.  Builtin tests
avoid running @{b}file@{ub} on files that are not regular files or are not
executable.

     find /usr/local -type f -perm +a=x | xargs file |
       grep 'not stripped' | cut -d: -f1

The @{b}cut@{ub} program removes everything after the file name from the output
of @{b}file@{ub}.

   If you want to place a special test somewhere in the middle of a
@{b}find@{ub} expression, you can use @{b}-exec@{ub} to run a program that performs the
test.  Because @{b}-exec@{ub} evaluates to the exit status of the executed
program, you can write a program (which can be a shell script) that
tests for a special attribute and make it exit with a true (zero) or
false (non-zero) status.  It is a good idea to place such a special
test @{i}after@{ui} the builtin tests, because it starts a new process which
could be avoided if a builtin test evaluates to false.  Use this method
only when @{b}xargs@{ub} is not flexible enough, because starting one or more
new processes to test each file is slower than using @{b}xargs@{ub} to start one
process that tests many files.

   Here is a shell script called @{b}unstripped@{ub} that checks whether its
argument is an unstripped binary file:

     #!/bin/sh
     file $1 | grep 'not stripped' > /dev/null

   This script relies on the fact that the shell exits with the status
of the last program it executed, in this case @{b}grep@{ub}.  @{b}grep@{ub} exits with a
true status if it found any matches, false if not.  Here is an example
of using the script (assuming it is in your search path).  It lists the
stripped executables in the file @{b}sbins@{ub} and the unstripped ones in @{b}ubins@{ub}.

     find /usr/local -type f -perm +a=x \
       \( -exec unstripped '{}' \; -fprint ubins -o -fprint sbins \)


@endnode

@node "Common Tasks" "find.guide/Common Tasks"
@next "Databases"
@prev "Actions"
@toc "Main"

Common Tasks
************

   The sections that follow contain some extended examples that both
give a good idea of the power of these programs, and show you how to
solve common real-world problems.


 @{" Viewing And Editing " link "Viewing And Editing"}  
 @{" Archiving         " link "Archiving"}  
 @{" Cleaning Up       " link "Cleaning Up"}  
 @{" Strange File Names " link "Strange File Names"}  
 @{" Fixing Permissions " link "Fixing Permissions"}  
 @{" Classifying Files " link "Classifying Files"}


@endnode

@node "Viewing And Editing" "find.guide/Viewing And Editing"
@next "Archiving"
@toc "Common Tasks"

Viewing And Editing
===================

   To view a list of files that meet certain criteria, simply run your
file viewing program with the file names as arguments.  Shells
substitute a command enclosed in backquotes with its output, so the
whole command looks like this:

     less `find /usr/include -name '*.h' | xargs grep -l mode_t`

You can edit those files by giving an editor name instead of a file
viewing program.


@endnode

@node "Archiving" "find.guide/Archiving"
@next "Cleaning Up"
@prev "Viewing And Editing"
@toc "Common Tasks"

Archiving
=========

   You can pass a list of files produced by @{b}find@{ub} to a file archiving
program.  GNU @{b}tar@{ub} and @{b}cpio@{ub} can both read lists of file names from the
standard input--either delimited by nulls (the safe way) or by blanks
(the lazy, risky default way).  To use null-delimited names, give them
the @{b}--null@{ub} option.  You can store a file archive in a file, write it on
a tape, or send it over a network to extract on another machine.

   One common use of @{b}find@{ub} to archive files is to send a list of the
files in a directory tree to @{b}cpio@{ub}.  Use @{b}-depth@{ub} so if a directory does
not have write permission for its owner, its contents can still be
restored from the archive since the directory's permissions are
restored after its contents.  Here is an example of doing this using
@{b}cpio@{ub}; you could use a more complex @{b}find@{ub} expression to archive only
certain files.

     find . -depth -print0 |
       cpio --create --null --format=crc --file=/dev/nrst0

   You could restore that archive using this command:

     cpio --extract --null --make-dir --unconditional \
       --preserve --file=/dev/nrst0

   Here are the commands to do the same things using @{b}tar@{ub}:

     find . -depth -print0 |
       tar --create --null --files-from=- --file=/dev/nrst0
     
     tar --extract --null --preserve-perm --same-owner \
       --file=/dev/nrst0

   Here is an example of copying a directory from one machine to
another:

     find . -depth -print0 | cpio -0o -Hnewc |
       rsh OTHER-MACHINE "cd `pwd` && cpio -i0dum"


@endnode

@node "Cleaning Up" "find.guide/Cleaning Up"
@next "Strange File Names"
@prev "Archiving"
@toc "Common Tasks"

Cleaning Up
===========

   This section gives examples of removing unwanted files in various
situations.  Here is a command to remove the CVS backup files created
when an update requires a merge:

     find . -name '.#*' -print0 | xargs -0r rm -f

   You can run this command to clean out your clutter in @{b}/tmp@{ub}.  You
might place it in the file your shell runs when you log out
(@{b}.bash_logout@{ub}, @{b}.logout@{ub}, or @{b}.zlogout@{ub}, depending on which shell you use).

     find /tmp -user $LOGNAME -type f -print0 | xargs -0 -r rm -f

   To remove old Emacs backup and auto-save files, you can use a command
like the following.  It is especially important in this case to use
null-terminated file names because Emacs packages like the VM mailer
often create temporary file names with spaces in them, like @{b}#reply to
David J. MacKenzie<1>#@{ub}.

     find ~ \( -name '*~' -o -name '#*#' \) -print0 |
       xargs --no-run-if-empty --null rm -vf

   Removing old files from @{b}/tmp@{ub} is commonly done from @{b}cron@{ub}:

     find /tmp /var/tmp -not -type d -mtime +3 -print0 |
       xargs --null --no-run-if-empty rm -f
     
     find /tmp /var/tmp -depth -mindepth 1 -type d -empty -print0 |
       xargs --null --no-run-if-empty rmdir

   The second @{b}find@{ub} command above uses @{b}-depth@{ub} so it cleans out empty
directories depth-first, hoping that the parents become empty and can
be removed too.  It uses @{b}-mindepth@{ub} to avoid removing @{b}/tmp@{ub} itself if it
becomes totally empty.


@endnode

@node "Strange File Names" "find.guide/Strange File Names"
@next "Fixing Permissions"
@prev "Cleaning Up"
@toc "Common Tasks"

Strange File Names
==================

@{b}   find@{ub} can help you remove or rename a file with strange characters in
its name.  People are sometimes stymied by files whose names contain
characters such as spaces, tabs, control characters, or characters with
the high bit set.  The simplest way to remove such files is:

     rm -i SOME*PATTERN*THAT*MATCHES*THE*PROBLEM*FILE

@{b}   rm@{ub} asks you whether to remove each file matching the given pattern.
If you are using an old shell, this approach might not work if the file
name contains a character with the high bit set; the shell may strip it
off.  A more reliable way is:

     find . -maxdepth 1 TESTS -ok rm '{}' \;

where TESTS uniquely identify the file.  The @{b}-maxdepth 1@{ub} option
prevents @{b}find@{ub} from wasting time searching for the file in any
subdirectories; if there are no subdirectories, you may omit it.  A
good way to uniquely identify the problem file is to figure out its
inode number; use

     ls -i

   Suppose you have a file whose name contains control characters, and
you have found that its inode number is 12345.  This command prompts
you for whether to remove it:

     find . -maxdepth 1 -inum 12345 -ok rm -f '{}' \;

   If you don't want to be asked, perhaps because the file name may
contain a strange character sequence that will mess up your screen when
printed, then use @{b}-exec@{ub} instead of @{b}-ok@{ub}.

   If you want to rename the file instead, you can use @{b}mv@{ub} instead of @{b}rm@{ub}:

     find . -maxdepth 1 -inum 12345 -ok mv '{}' NEW-FILE-NAME \;


@endnode

@node "Fixing Permissions" "find.guide/Fixing Permissions"
@next "Classifying Files"
@prev "Strange File Names"
@toc "Common Tasks"

Fixing Permissions
==================

   Suppose you want to make sure that everyone can write to the
directories in a certain directory tree.  Here is a way to find
directories lacking either user or group write permission (or both),
and fix their permissions:

     find . -type d -not -perm -ug=w | xargs chmod ug+w

You could also reverse the operations, if you want to make sure that
directories do @{i}not@{ui} have world write permission.


@endnode

@node "Classifying Files" "find.guide/Classifying Files"
@prev "Fixing Permissions"
@toc "Common Tasks"

Classifying Files
=================

   If you want to classify a set of files into several groups based on
different criteria, you can use the comma operator to perform multiple
independent tests on the files.  Here is an example:

     find / -type d \( -perm -o=w -fprint allwrite , \
       -perm -o=x -fprint allexec \)
     
     echo "Directories that can be written to by everyone:"
     cat allwrite
     echo ""
     echo "Directories with search permissions for everyone:"
     cat allexec

@{b}   find@{ub} has only to make one scan through the directory tree (which is
one of the most time consuming parts of its work).


@endnode

@node "Databases" "find.guide/Databases"
@next "File Permissions"
@prev "Common Tasks"
@toc "Main"

File Name Databases
*******************

   The file name databases used by @{b}locate@{ub} contain lists of files that
were in particular directory trees when the databases were last
updated.  The file name of the default database is determined when
@{b}locate@{ub} and @{b}updatedb@{ub} are configured and installed.  The frequency with
which the databases are updated and the directories for which they
contain entries depend on how often @{b}updatedb@{ub} is run, and with which
arguments.


 @{" Database Locations " link "Database Locations"}  
 @{" Database Formats " link "Database Formats"}


@endnode

@node "Database Locations" "find.guide/Database Locations"
@next "Database Formats"
@toc "Databases"

Database Locations
==================

   There can be multiple file name databases.  Users can select which
databases @{b}locate@{ub} searches using an environment variable or a command
line option.  The system administrator can choose the file name of the
default database, the frequency with which the databases are updated,
and the directories for which they contain entries.  File name
databases are updated by running the @{b}updatedb@{ub} program, typically
nightly.

   In networked environments, it often makes sense to build a database
at the root of each filesystem, containing the entries for that
filesystem.  @{b}updatedb@{ub} is then run for each filesystem on the fileserver
where that filesystem is on a local disk, to prevent thrashing the
network.  Here are the options to @{b}updatedb@{ub} to select which directories
each database contains entries for:

@{b}--localpaths='PATH...'@{ub}
     Non-network directories to put in the database.  Default is @{b}/@{ub}.

@{b}--netpaths='PATH...'@{ub}
     Network (NFS, AFS, RFS, etc.) directories to put in the database.
     Default is none.

@{b}--prunepaths='PATH...'@{ub}
     Directories to not put in the database, which would otherwise be.
     Default is @{b}/tmp /usr/tmp /var/tmp /afs@{ub}.

@{b}--output=DBFILE@{ub}
     The database file to build.  Default is system-dependent, but
     typically @{b}/usr/local/var/locatedb@{ub}.

@{b}--netuser=USER@{ub}
     The user to search network directories as, using @{b}su@{ub}.  Default is
     @{b}daemon@{ub}.


@endnode

@node "Database Formats" "find.guide/Database Formats"
@prev "Database Locations"
@toc "Databases"

Database Formats
================

   The file name databases contain lists of files that were in
particular directory trees when the databases were last updated.  The
file name database format changed starting with GNU @{b}locate@{ub} version 4.0
to allow machines with diffent byte orderings to share the databases.
The new GNU @{b}locate@{ub} can read both the old and new database formats.
However, old versions of @{b}locate@{ub} and @{b}find@{ub} produce incorrect results if
given a new-format database.


 @{" New Database Format " link "New Database Format"}  
 @{" Sample Database   " link "Sample Database"}  
 @{" Old Database Format " link "Old Database Format"}


@endnode

@node "New Database Format" "find.guide/New Database Format"
@next "Sample Database"
@toc "Database Formats"

New Database Format
-------------------

@{b}   updatedb@{ub} runs a program called @{b}frcode@{ub} to @{i}front-compress@{ui} the list of
file names, which reduces the database size by a factor of 4 to 5.
Front-compression (also known as incremental encoding) works as follows.

   The database entries are a sorted list (case-insensitively, for
users' convenience).  Since the list is sorted, each entry is likely to
share a prefix (initial string) with the previous entry.  Each database
entry begins with an offset-differential count byte, which is the
additional number of characters of prefix of the preceding entry to use
beyond the number that the preceding entry is using of its predecessor.
(The counts can be negative.)  Following the count is a
null-terminated ASCII remainder--the part of the name that follows the
shared prefix.

   If the offset-differential count is larger than can be stored in a
byte (+/-127), the byte has the value 0x80 and the count follows in a
2-byte word, with the high byte first (network byte order).

   Every database begins with a dummy entry for a file called @{b}LOCATE02@{ub},
which @{b}locate@{ub} checks for to ensure that the database file has the
correct format; it ignores the entry in doing the search.

   Databases can not be concatenated together, even if the first (dummy)
entry is trimmed from all but the first database.  This is because the
offset-differential count in the first entry of the second and following
databases will be wrong.


@endnode

@node "Sample Database" "find.guide/Sample Database"
@next "Old Database Format"
@prev "New Database Format"
@toc "Database Formats"

Sample Database
---------------

   Sample input to @{b}frcode@{ub}:

     /usr/src
     /usr/src/cmd/aardvark.c
     /usr/src/cmd/armadillo.c
     /usr/tmp/zoo

   Length of the longest prefix of the preceding entry to share:

     0 /usr/src
     8 /cmd/aardvark.c
     14 rmadillo.c
     5 tmp/zoo

   Output from @{b}frcode@{ub}, with trailing nulls changed to newlines and
count bytes made printable:

     0 LOCATE02
     0 /usr/src
     8 /cmd/aardvark.c
     6 rmadillo.c
     -9 tmp/zoo

   (6 = 14 - 8, and -9 = 5 - 14)


@endnode

@node "Old Database Format" "find.guide/Old Database Format"
@prev "Sample Database"
@toc "Database Formats"

Old Database Format
-------------------

   The old database format is used by Unix @{b}locate@{ub} and @{b}find@{ub} programs and
earlier releases of the GNU ones.  @{b}updatedb@{ub} produces this format if
given the @{b}--old-format@{ub} option.

@{b}   updatedb@{ub} runs programs called @{b}bigram@{ub} and @{b}code@{ub} to produce old-format
databases.  The old format differs from the new one in the following
ways.  Instead of each entry starting with an offset-differential count
byte and ending with a null, byte values from 0 through 28 indicate
offset-differential counts from -14 through 14.  The byte value
indicating that a long offset-differential count follows is 0x1e (30),
not 0x80.  The long counts are stored in host byte order, which is not
necessarily network byte order, and host integer word size, which is
usually 4 bytes.  They also represent a count 14 less than their value.
The database lines have no termination byte; the start of the next
line is indicated by its first byte having a value <= 30.

   In addition, instead of starting with a dummy entry, the old database
format starts with a 256 byte table containing the 128 most common
bigrams in the file list.  A bigram is a pair of adjacent bytes.  Bytes
in the database that have the high bit set are indexes (with the high
bit cleared) into the bigram table.  The bigram and offset-differential
count coding makes these databases 20-25% smaller than the new format,
but makes them not 8-bit clean.  Any byte in a file name that is in the
ranges used for the special codes is replaced in the database by a
question mark, which not coincidentally is the shell wildcard to match a
single character.


@endnode

@node "File Permissions" "find.guide/File Permissions"
@next "Reference"
@prev "Databases"
@toc "Main"

File Permissions
****************

   Each file has a set of @{i}permissions@{ui} that control the kinds of access
that users have to that file.  The permissions for a file are also
called its @{i}access mode@{ui}.  They can be represented either in symbolic
form or as an octal number.


 @{" Mode Structure             " link "Mode Structure"}  Structure of file permissions.
 @{" Symbolic Modes             " link "Symbolic Modes"}  Mnemonic permissions representation.
 @{" Numeric Modes              " link "Numeric Modes"}  Permissions as octal numbers.


@endnode

@node "Mode Structure" "find.guide/Mode Structure"
@next "Symbolic Modes"
@toc "File Permissions"

Structure of File Permissions
=============================

   There are three kinds of permissions that a user can have for a file:

  1. permission to read the file.  For directories, this means
     permission to list the contents of the directory.

  2. permission to write to (change) the file.  For directories, this
     means permission to create and remove files in the directory.

  3. permission to execute the file (run it as a program).  For
     directories, this means permission to access files in the
     directory.

   There are three categories of users who may have different
permissions to perform any of the above operations on a file:

  1. the file's owner;

  2. other users who are in the file's group;

  3. everyone else.

   Files are given an owner and group when they are created.  Usually
the owner is the current user and the group is the group of the
directory the file is in, but this varies with the operating system, the
filesystem the file is created on, and the way the file is created.  You
can change the owner and group of a file by using the @{b}chown@{ub} and @{b}chgrp@{ub}
commands.

   In addition to the three sets of three permissions listed above, a
file's permissions have three special components, which affect only
executable files (programs) and, on some systems, directories:

  1. set the process's effective user ID to that of the file upon
     execution (called the @{i}setuid bit@{ui}).  No effect on directories.

  2. set the process's effective group ID to that of the file upon
     execution (called the @{i}setgid bit@{ui}).  For directories on some
     systems, put files created in the directory into the same group as
     the directory, no matter what group the user who creates them is
     in.

  3. save the program's text image on the swap device so it will load
     more quickly when run (called the @{i}sticky bit@{ui}).  For directories on
     some systems, prevent users from removing files that they do not
     own in the directory; this is called making the directory
     @{i}append-only@{ui}.


@endnode

@node "Symbolic Modes" "find.guide/Symbolic Modes"
@next "Numeric Modes"
@prev "Mode Structure"
@toc "File Permissions"

Symbolic Modes
==============

@{i}   Symbolic modes@{ui} represent changes to files' permissions as operations
on single-character symbols.  They allow you to modify either all or
selected parts of files' permissions, optionally based on their
previous values, and perhaps on the current @{b}umask@{ub} as well (see
@{"Umask and Protection" link "Umask and Protection"}).

   The format of symbolic modes is:

     [ugoa...][[+-=][rwxXstugo...]...][,...]

   The following sections describe the operators and other details of
symbolic modes.


 @{" Setting Permissions         " link "Setting Permissions"}  Basic operations on permissions.
 @{" Copying Permissions         " link "Copying Permissions"}  Copying existing permissions.
 @{" Changing Special Permissions " link "Changing Special Permissions"}  Special permissions.
 @{" Conditional Executability   " link "Conditional Executability"}  Conditionally affecting executability.
 @{" Multiple Changes            " link "Multiple Changes"}  Making multiple changes.
 @{" Umask and Protection        " link "Umask and Protection"}  The effect of the umask.


@endnode

@node "Setting Permissions" "find.guide/Setting Permissions"
@next "Copying Permissions"
@toc "Symbolic Modes"

Setting Permissions
-------------------

   The basic symbolic operations on a file's permissions are adding,
removing, and setting the permission that certain users have to read,
write, and execute the file.  These operations have the following
format:

     USERS OPERATION PERMISSIONS

The spaces between the three parts above are shown for readability only;
symbolic modes can not contain spaces.

   The USERS part tells which users' access to the file is changed.  It
consists of one or more of the following letters (or it can be empty;
see @{"Umask and Protection" link "Umask and Protection"}, for a description of what happens then).
When more than one of these letters is given, the order that they are
in does not matter.

@{b}u@{ub}
     the user who owns the file;

@{b}g@{ub}
     other users who are in the file's group;

@{b}o@{ub}
     all other users;

@{b}a@{ub}
     all users; the same as @{b}ugo@{ub}.

   The OPERATION part tells how to change the affected users' access to
the file, and is one of the following symbols:

@{b}+@{ub}
     to add the PERMISSIONS to whatever permissions the USERS already
     have for the file;

@{b}-@{ub}
     to remove the PERMISSIONS from whatever permissions the USERS
     already have for the file;

@{b}=@{ub}
     to make the PERMISSIONS the only permissions that the USERS have
     for the file.

   The PERMISSIONS part tells what kind of access to the file should be
changed; it is zero or more of the following letters.  As with the
USERS part, the order does not matter when more than one letter is
given.  Omitting the PERMISSIONS part is useful only with the @{b}=@{ub}
operation, where it gives the specified USERS no access at all to the
file.

@{b}r@{ub}
     the permission the USERS have to read the file;

@{b}w@{ub}
     the permission the USERS have to write to the file;

@{b}x@{ub}
     the permission the USERS have to execute the file.

   For example, to give everyone permission to read and write a file,
but not to execute it, use:

     a=rw

   To remove write permission for from all users other than the file's
owner, use:

     go-w

The above command does not affect the access that the owner of the file
has to it, nor does it affect whether other users can read or execute
the file.

   To give everyone except a file's owner no permission to do anything
with that file, use the mode below.  Other users could still remove the
file, if they have write permission on the directory it is in.

     go=

Another way to specify the same thing is:

     og-rxw


@endnode

@node "Copying Permissions" "find.guide/Copying Permissions"
@next "Changing Special Permissions"
@prev "Setting Permissions"
@toc "Symbolic Modes"

Copying Existing Permissions
----------------------------

   You can base part of a file's permissions on part of its existing
permissions.  To do this, instead of using @{b}r@{ub}, @{b}w@{ub}, or @{b}x@{ub} after the
operator, you use the letter @{b}u@{ub}, @{b}g@{ub}, or @{b}o@{ub}.  For example, the mode

     o+g

adds the permissions for users who are in a file's group to the
permissions that other users have for the file.  Thus, if the file
started out as mode 664 (@{b}rw-rw-r--@{ub}), the above mode would change it to
mode 666 (@{b}rw-rw-rw-@{ub}).  If the file had started out as mode 741
(@{b}rwxr----x@{ub}), the above mode would change it to mode 745 (@{b}rwxr--r-x@{ub}).
The @{b}-@{ub} and @{b}=@{ub} operations work analogously.


@endnode

@node "Changing Special Permissions" "find.guide/Changing Special Permissions"
@next "Conditional Executability"
@prev "Copying Permissions"
@toc "Symbolic Modes"

Changing Special Permissions
----------------------------

   In addition to changing a file's read, write, and execute
permissions, you can change its special permissions.  See
@{"Mode Structure" link "Mode Structure"}, for a summary of these permissions.

   To change a file's permission to set the user ID on execution, use @{b}u@{ub}
in the USERS part of the symbolic mode and @{b}s@{ub} in the PERMISSIONS part.

   To change a file's permission to set the group ID on execution, use
@{b}g@{ub} in the USERS part of the symbolic mode and @{b}s@{ub} in the PERMISSIONS part.

   To change a file's permission to stay permanently on the swap device,
use @{b}o@{ub} in the USERS part of the symbolic mode and @{b}t@{ub} in the PERMISSIONS
part.

   For example, to add set user ID permission to a program, you can use
the mode:

     u+s

   To remove both set user ID and set group ID permission from it, you
can use the mode:

     ug-s

   To cause a program to be saved on the swap device, you can use the
mode:

     o+t

   Remember that the special permissions only affect files that are
executable, plus, on some systems, directories (on which they have
different meanings; see @{"Mode Structure" link "Mode Structure"}).  Using @{b}a@{ub} in the USERS part of
a symbolic mode does not cause the special permissions to be affected;
thus,

     a+s

has @{i}no effect@{ui}.  You must use @{b}u@{ub}, @{b}g@{ub}, and @{b}o@{ub} explicitly to affect the
special permissions.  Also, the combinations @{b}u+t@{ub}, @{b}g+t@{ub}, and @{b}o+s@{ub} have no
effect.

   The @{b}=@{ub} operator is not very useful with special permissions; for
example, the mode:

     o=t

does cause the file to be saved on the swap device, but it also removes
all read, write, and execute permissions that users not in the file's
group might have had for it.


@endnode

@node "Conditional Executability" "find.guide/Conditional Executability"
@next "Multiple Changes"
@prev "Changing Special Permissions"
@toc "Symbolic Modes"

Conditional Executability
-------------------------

   There is one more special type of symbolic permission: if you use @{b}X@{ub}
instead of @{b}x@{ub}, execute permission is affected only if the file already
had execute permission or is a directory.  It affects directories'
execute permission even if they did not initially have any execute
permissions set.

   For example, this mode:

     a+X

gives all users permission to execute files (or search directories) if
anyone could before.


@endnode

@node "Multiple Changes" "find.guide/Multiple Changes"
@next "Umask and Protection"
@prev "Conditional Executability"
@toc "Symbolic Modes"

Making Multiple Changes
-----------------------

   The format of symbolic modes is actually more complex than described
above (see @{"Setting Permissions" link "Setting Permissions"}).  It provides two ways to make
multiple changes to files' permissions.

   The first way is to specify multiple OPERATION and PERMISSIONS parts
after a USERS part in the symbolic mode.

   For example, the mode:

     og+rX-w

gives users other than the owner of the file read permission and, if it
is a directory or if someone already had execute permission to it,
gives them execute permission; and it also denies them write permission
to it file.  It does not affect the permission that the owner of the
file has for it.  The above mode is equivalent to the two modes:

     og+rX
     og-w

   The second way to make multiple changes is to specify more than one
simple symbolic mode, separated by commas.  For example, the mode:

     a+r,go-w

gives everyone permission to read the file and removes write permission
on it for all users except its owner.  Another example:

     u=rwx,g=rx,o=

sets all of the non-special permissions for the file explicitly.  (It
gives users who are not in the file's group no permission at all for
it.)

   The two methods can be combined.  The mode:

     a+r,g+x-w

gives all users permission to read the file, and gives users who are in
the file's group permission to execute it, as well, but not permission
to write to it.  The above mode could be written in several different
ways; another is:

     u+r,g+rx,o+r,g-w


@endnode

@node "Umask and Protection" "find.guide/Umask and Protection"
@prev "Multiple Changes"
@toc "Symbolic Modes"

The Umask and Protection
------------------------

   If the USERS part of a symbolic mode is omitted, it defaults to @{b}a@{ub}
(affect all users), except that any permissions that are @{i}set@{ui} in the
system variable @{b}umask@{ub} are @{i}not affected@{ui}.  The value of @{b}umask@{ub} can be set
using the @{b}umask@{ub} command.  Its default value varies from system to
system.

   Omitting the USERS part of a symbolic mode is generally not useful
with operations other than @{b}+@{ub}.  It is useful with @{b}+@{ub} because it allows
you to use @{b}umask@{ub} as an easily customizable protection against giving
away more permission to files than you intended to.

   As an example, if @{b}umask@{ub} has the value 2, which removes write
permission for users who are not in the file's group, then the mode:

     +w

adds permission to write to the file to its owner and to other users who
are in the file's group, but @{i}not@{ui} to other users.  In contrast, the mode:

     a+w

ignores @{b}umask@{ub}, and @{i}does@{ui} give write permission for the file to all users.


@endnode

@node "Numeric Modes" "find.guide/Numeric Modes"
@prev "Symbolic Modes"
@toc "File Permissions"

Numeric Modes
=============

   File permissions are stored internally as 16 bit integers.  As an
alternative to giving a symbolic mode, you can give an octal (base 8)
number that corresponds to the internal representation of the new mode.
This number is always interpreted in octal; you do not have to add a
leading 0, as you do in C.  Mode 0055 is the same as mode 55.

   A numeric mode is usually shorter than the corresponding symbolic
mode, but it is limited in that it can not take into account a file's
previous permissions; it can only set them absolutely.

   The permissions granted to the user, to other users in the file's
group, and to other users not in the file's group are each stored as
three bits, which are represented as one octal digit.  The three special
permissions are also each stored as one bit, and they are as a group
represented as another octal digit.  Here is how the bits are arranged
in the 16 bit integer, starting with the lowest valued bit:

     Value in  Corresponding
     Mode      Permission
     
               Other users not in the file's group:
        1      Execute
        2      Write
        4      Read
     
               Other users in the file's group:
       10      Execute
       20      Write
       40      Read
     
               The file's owner:
      100      Execute
      200      Write
      400      Read
     
               Special permissions:
     1000      Save text image on swap device
     2000      Set group ID on execution
     4000      Set user ID on execution

   For example, numeric mode 4755 corresponds to symbolic mode
@{b}u=rwxs,go=rx@{ub}, and numeric mode 664 corresponds to symbolic mode
@{b}ug=rw,o=r@{ub}.  Numeric mode 0 corresponds to symbolic mode @{b}ugo=@{ub}.


@endnode

@node "Reference" "find.guide/Reference"
@next "Primary Index"
@prev "File Permissions"
@toc "Main"

Reference
*********

   Below are summaries of the command line syntax for the programs
discussed in this manual.


 @{" Invoking find " link "Invoking find"}  
 @{" Invoking locate " link "Invoking locate"}  
 @{" Invoking updatedb " link "Invoking updatedb"}  
 @{" Invoking xargs " link "Invoking xargs"}


@endnode

@node "Invoking find" "find.guide/Invoking find"
@next "Invoking locate"
@toc "Reference"

Invoking @{b}find@{ub}
=============

     find [FILE...] [EXPRESSION]

@{b}   find@{ub} searches the directory tree rooted at each file name FILE by
evaluating the EXPRESSION on each file it finds in the tree.

@{b}   find@{ub} considers the first argument that begins with @{b}-@{ub}, @{b}(@{ub}, @{b})@{ub}, @{b},@{ub}, or @{b}!@{ub}
to be the beginning of the expression; any arguments before it are
paths to search, and any arguments after it are the rest of the
expression.  If no paths are given, the current directory is used.  If
no expression is given, the expression @{b}-print@{ub} is used.

@{b}   find@{ub} exits with status 0 if all files are processed successfully,
greater than 0 if errors occur.

   See @{"Primary Index" link "Primary Index"}, for a summary of all of the tests, actions, and
options that the expression can contain.

@{b}   find@{ub} also recognizes two options for administrative use:

@{b}--help@{ub}
     Print a summary of the command-line argument format and exit.

@{b}--version@{ub}
     Print the version number of @{b}find@{ub} and exit.


@endnode

@node "Invoking locate" "find.guide/Invoking locate"
@next "Invoking updatedb"
@prev "Invoking find"
@toc "Reference"

Invoking @{b}locate@{ub}
===============

     locate [OPTION...] PATTERN...

@{b}--database=PATH@{ub}
@{b}-d PATH@{ub}
     Instead of searching the default file name database, search the
     file name databases in PATH, which is a colon-separated list of
     database file names.  You can also use the environment variable
     @{b}LOCATE_PATH@{ub} to set the list of database files to search.  The
     option overrides the environment variable if both are used.

@{b}--help@{ub}
     Print a summary of the options to @{b}locate@{ub} and exit.

@{b}--version@{ub}
     Print the version number of @{b}locate@{ub} and exit.


@endnode

@node "Invoking updatedb" "find.guide/Invoking updatedb"
@next "Invoking xargs"
@prev "Invoking locate"
@toc "Reference"

Invoking @{b}updatedb@{ub}
=================

     updatedb [OPTION...]

@{b}--localpaths='PATH...'@{ub}
     Non-network directories to put in the database.  Default is @{b}/@{ub}.

@{b}--netpaths='PATH...'@{ub}
     Network (NFS, AFS, RFS, etc.) directories to put in the database.
     Default is none.

@{b}--prunepaths='PATH...'@{ub}
     Directories to not put in the database, which would otherwise be.
     Default is @{b}/tmp /usr/tmp /var/tmp /afs@{ub}.

@{b}--output=DBFILE@{ub}
     The database file to build.  Default is system-dependent, but
     typically @{b}/usr/local/var/locatedb@{ub}.

@{b}--netuser=USER@{ub}
     The user to search network directories as, using @{b}su@{ub}(1).  Default
     is @{b}daemon@{ub}.


@endnode

@node "Invoking xargs" "find.guide/Invoking xargs"
@prev "Invoking updatedb"
@toc "Reference"

Invoking @{b}xargs@{ub}
==============

     xargs [OPTION...] [COMMAND [INITIAL-ARGUMENTS]]

@{b}   xargs@{ub} exits with the following status:

0
     if it succeeds

123
     if any invocation of the command exited with status 1-125

124
     if the command exited with status 255

125
     if the command is killed by a signal

126
     if the command cannot be run

127
     if the command is not found

1
     if some other error occurred.

@{b}--null@{ub}
@{b}-0@{ub}
     Input filenames are terminated by a null character instead of by
     whitespace, and the quotes and backslash are not special (every
     character is taken literally).  Disables the end of file string,
     which is treated like any other argument.

@{b}--eof[=EOF-STR]@{ub}
@{b}-e[EOF-STR]@{ub}
     Set the end of file string to EOF-STR.  If the end of file string
     occurs as a line of input, the rest of the input is ignored.  If
     EOF-STR is omitted, there is no end of file string.  If this
     option is not given, the end of file string defaults to @{b}_@{ub}.

@{b}--help@{ub}
     Print a summary of the options to @{b}xargs@{ub} and exit.

@{b}--replace[=REPLACE-STR]@{ub}
@{b}-i[REPLACE-STR]@{ub}
     Replace occurences of REPLACE-STR in the initial arguments with
     names read from standard input.  Also, unquoted blanks do not
     terminate arguments.  If REPLACE-STR is omitted, it defaults to @{b}{}@{ub}
     (like for @{b}find -exec@{ub}).  Implies @{b}-x@{ub} and @{b}-l 1@{ub}.

@{b}--max-lines[=MAX-LINES]@{ub}
@{b}-l[MAX-LINES]@{ub}
     Use at most MAX-LINES nonblank input lines per command line;
     MAX-LINES defaults to 1 if omitted.  Trailing blanks cause an
     input line to be logically continued on the next input line, for
     the purpose of counting the lines.  Implies @{b}-x@{ub}.

@{b}--max-args=MAX-ARGS@{ub}
@{b}-n MAX-ARGS@{ub}
     Use at most MAX-ARGS arguments per command line.  Fewer than
     MAX-ARGS arguments will be used if the size (see the @{b}-s@{ub} option) is
     exceeded, unless the @{b}-x@{ub} option is given, in which case @{b}xargs@{ub} will
     exit.

@{b}--interactive@{ub}
@{b}-p@{ub}
     Prompt the user about whether to run each command line and read a
     line from the terminal.  Only run the command line if the response
     starts with @{b}y@{ub} or @{b}Y@{ub}.  Implies @{b}-t@{ub}.

@{b}--no-run-if-empty@{ub}
@{b}-r@{ub}
     If the standard input does not contain any nonblanks, do not run
     the command.  By default, the command is run once even if there is
     no input.

@{b}--max-chars=MAX-CHARS@{ub}
@{b}-s MAX-CHARS@{ub}
     Use at most MAX-CHARS characters per command line, including the
     command and initial arguments and the terminating nulls at the
     ends of the argument strings.

@{b}--verbose@{ub}
@{b}-t@{ub}
     Print the command line on the standard error output before
     executing it.

@{b}--version@{ub}
     Print the version number of @{b}xargs@{ub} and exit.

@{b}--exit@{ub}
@{b}-x@{ub}
     Exit if the size (see the -S option) is exceeded.

@{b}--max-procs=MAX-PROCS@{ub}
@{b}-P MAX-PROCS@{ub}
     Run up to MAX-PROCS processes at a time; the default is 1.  If
     MAX-PROCS is 0, @{b}xargs@{ub} will run as many processes as possible at a
     time.


@endnode

@node "Primary Index" "find.guide/Primary Index"
@prev "Reference"
@toc "Main"

@{b}find@{ub} Primary Index
******************

   This is a list of all of the primaries (tests, actions, and options)
that make up @{b}find@{ub} expressions for selecting files.  See
@{"find Expressions" link "find Expressions"}, for more information on expressions.



 @{" -amin                                    " link "Age Ranges"}   Age Ranges
 @{" -anewer                                  " link "Comparing Timestamps"}   Comparing Timestamps
 @{" -atime                                   " link "Age Ranges"}   Age Ranges
 @{" -cmin                                    " link "Age Ranges"}   Age Ranges
 @{" -cnewer                                  " link "Comparing Timestamps"}   Comparing Timestamps
 @{" -ctime                                   " link "Age Ranges"}   Age Ranges
 @{" -daystart                                " link "Age Ranges"}   Age Ranges
 @{" -depth                                   " link "Directories"}   Directories
 @{" -empty                                   " link "Size"}   Size
 @{" -exec                                    " link "Single File"}   Single File
 @{" -false                                   " link "Combining Primaries With Operators"}   Combining Primaries With Operators
 @{" -fls                                     " link "Print File Information"}   Print File Information
 @{" -follow                                  " link "Symbolic Links"}   Symbolic Links
 @{" -fprint                                  " link "Print File Name"}   Print File Name
 @{" -fprint0                                 " link "Safe File Name Handling"}   Safe File Name Handling
 @{" -fprintf                                 " link "Print File Information"}   Print File Information
 @{" -fstype                                  " link "Filesystems"}   Filesystems
 @{" -gid                                     " link "Owner"}   Owner
 @{" -group                                   " link "Owner"}   Owner
 @{" -ilname                                  " link "Symbolic Links"}   Symbolic Links
 @{" -iname                                   " link "Base Name Patterns"}   Base Name Patterns
 @{" -inum                                    " link "Hard Links"}   Hard Links
 @{" -ipath                                   " link "Full Name Patterns"}   Full Name Patterns
 @{" -iregex                                  " link "Full Name Patterns"}   Full Name Patterns
 @{" -links                                   " link "Hard Links"}   Hard Links
 @{" -lname                                   " link "Symbolic Links"}   Symbolic Links
 @{" -ls                                      " link "Print File Information"}   Print File Information
 @{" -maxdepth                                " link "Directories"}   Directories
 @{" -mindepth                                " link "Directories"}   Directories
 @{" -mmin                                    " link "Age Ranges"}   Age Ranges
 @{" -mount                                   " link "Filesystems"}   Filesystems
 @{" -mtime                                   " link "Age Ranges"}   Age Ranges
 @{" -name                                    " link "Base Name Patterns"}   Base Name Patterns
 @{" -newer                                   " link "Comparing Timestamps"}   Comparing Timestamps
 @{" -nogroup                                 " link "Owner"}   Owner
 @{" -noleaf                                  " link "Directories"}   Directories
 @{" -nouser                                  " link "Owner"}   Owner
 @{" -ok                                      " link "Querying"}   Querying
 @{" -path                                    " link "Full Name Patterns"}   Full Name Patterns
 @{" -perm                                    " link "Permissions"}   Permissions
 @{" -print                                   " link "Print File Name"}   Print File Name
 @{" -print0                                  " link "Safe File Name Handling"}   Safe File Name Handling
 @{" -printf                                  " link "Print File Information"}   Print File Information
 @{" -prune                                   " link "Directories"}   Directories
 @{" -regex                                   " link "Full Name Patterns"}   Full Name Patterns
 @{" -size                                    " link "Size"}   Size
 @{" -true                                    " link "Combining Primaries With Operators"}   Combining Primaries With Operators
 @{" -type                                    " link "Type"}   Type
 @{" -uid                                     " link "Owner"}   Owner
 @{" -used                                    " link "Comparing Timestamps"}   Comparing Timestamps
 @{" -user                                    " link "Owner"}   Owner
 @{" -xdev                                    " link "Filesystems"}   Filesystems
 @{" -xtype                                   " link "Type"}   Type

@endnode

