@database Profyler.guide
@$VER: Profyler.guide 1.1 (05.03.22)
@author "Mike Steed"
@(c) "2022 Mike Steed"
@width 77
@remark Created with Heddley v1.20ß © Edd Dumbill 1994-5

@node "Main" "Table of Contents"

----------------------------------------------------------------------------

                                @{b}@{fg highlight}Profyler@{ub}@{fg text}

                         @{b}Version 1.1  5-Mar-2022@{ub}

              @{b}A software performance profiler for AmigaOS 4@{ub} 

----------------------------------------------------------------------------

Profyler is freely distributable, open-source software, copyright (c) 2022 by
@{"Mike Steed" link "Author" 0}. It is distributed WITHOUT WARRANTY, under the terms of the GNU
@{"General Public License (GPL)" link "Prog:Work/Profyler/Docs/COPYING-GPL/main" 0} for the Profyler program, and the GNU @{"Lesser" link "Prog:Work/Profyler/Docs/COPYING-LGPL/main" 0}
@{"General Public License (LGPL)" link "Prog:Work/Profyler/Docs/COPYING-LGPL/main" 0} for the LibProfyle linkable library. See the
licenses for details. The source code for Profyler and LibProfyle are
included in the program archive.

----------------------------------------------------------------------------

@{fg highlight}Note: Profyler is a tool for programmers only. You have to be able to compile
a program in order to use Profyler with it, so it is not useful for ordinary
users.@{fg text} 

----------------------------------------------------------------------------

 @{" Introduction    " link "Introduction" 0} - Profyler at a glance
 @{" Quick Start     " link "Quick Start" 0} - For those who hate to read manuals
 @{" Components      " link "Components" 0} - What makes up Profyler
 @{" Requirements    " link "Requirements" 0} - What you need to use Profyler
 @{" Installation    " link "Installation" 0} - How to install Profyler
 @{" How To Use      " link "How To Use" 0} - How to add profiling to your project
 @{" Profyler        " link "Profyler" 0} - Using the user interface
 @{" Limitations     " link "Limitations" 0} - What Profyler can and can't do
 @{" Profilers 101   " link "Profilers" 0} - A brief introduction
 @{" Operation       " link "Operation" 0} - How Profyler works
 @{" Test Programs   " link "Test Programs" 0} - What they do and how to build them
 @{" Credits         " link "Credits" 0} - Whodunit and who helped
 @{" The Author      " link "Author" 0} - And Profyler's inspiration
 @{" Version History " link "History" 0} - What came before

@endnode

@node "Introduction" "Introduction"

@{b}@{fg shine}Introduction - Profyler at a glance@{ub}@{fg text}

Profyler is a software performance profiler -- or @{i}profiler@{ui} for short -- for
AmigaOS 4. It allows the execution speed of the various functions that make
up a program to be measured, facilitating optimization of the program to
improve its performance.

More specifically, Profyler is a @{i}deterministic profiler@{ui}, which adds code to
the program being profiled in order to implement the profiling functionality.
It uses the @{b}-finstrument-functions@{ub} feature of the GCC compiler, which means
that it only works with C and C++ programs compiled with GCC. It also means
that a program must be compiled and then linked with LibProfyle in order to
be profiled; you can't profile a program that you can't compile.

There are two parts to Profyler: the Profyler program itself, which serves as
the user interface; and LibProfyle, a linkable library that provides the
profiling functionality. To profile a program you compile it and link it with
LibProfyle, then run it to generate the profile data in memory. You then run
Profyler to access the profile data and display it in a useful format.


@{b}Profyler features:@{ub}

@{b}o@{ub} Measures the following parameters for every executed function in a
  program, displaying them in a list browser:

  @{b}-@{ub} The function's name (C++ names are demangled)
  @{b}-@{ub} The source file and line number where the function is defined
  @{b}-@{ub} The number of times the function has been executed
  @{b}-@{ub} The total execution time of all calls to the function, @{i}including@{ui} any
    other functions it calls
  @{b}-@{ub} The above as a percentage of the total execution time of the program
  @{b}-@{ub} The average execution time of the function per call, @{i}including@{ui} any other
    functions it calls
  @{b}-@{ub} The total execution time of all calls to the function, @{i}excluding@{ui} any
    other functions it calls
  @{b}-@{ub} The above as a percentage of the total execution time of the program
  @{b}-@{ub} The average execution time of the function per call, @{i}excluding@{ui} any other
    functions it calls

@{b}o@{ub} Can sort the function list by any of the above parameters, in ascending or
  descending order

@{b}o@{ub} Can hide any of the above parameters if they are not of interest

@{b}o@{ub} Can rearrange the columns in the list browser to group the parameters as
  desired

@{b}o@{ub} Can profile up to nine different programs, with a different tab and list
  browser for each; allows profiling of programs that interact with each
  other

@{b}o@{ub} Can save the profile data to a text file (or send it to a printer) for
  record keeping or for further review; the sort order, column arrangement
  and visibility match that of the list browser

@{b}o@{ub} Can save the profile data to a CSV file for import to a spreadsheet or
  other program for additional processing

@{b}o@{ub} Can disable profiling of parts of a function (including OS calls) that
  involve user interaction, so user response time doesn't affect profiling

@{b}o@{ub} Can avoid profiling of specific functions; useful for very brief functions
  that get called a lot, where the overhead of the profiler can greatly slow
  the program

@{b}o@{ub} Doesn't depend on any particular PowerPC variant or hardware, so should
  work with any Amiga model that supports OS4

@{b}o@{ub} Automatically adapts to the EClock speed of the machine it's running on;
  the faster the EClock the finer the measurement resolution

@{b}o@{ub} The profiling code is optimized to be as quick as possible; for many
  applications the slowdown due to profiling is barely noticeable

@{b}o@{ub} Can profile single-threaded programs, linked libraries, and shared objects;
  in many cases no modification to the source code is required


@{b}Profyler limitations:@{ub}

@{b}o@{ub} Can profile only the main thread of multi-threaded programs

@{b}o@{ub} Cannot profile functions that are called from a different context, such
  as a callback hook or custom BOOPSI gadget (MUI's custom classes and
  notification hooks are fine, as they are called from the program's
  context)

@{b}o@{ub} Cannot profile shared (Amiga-style) libraries or devices

@{b}o@{ub} Some compiler optimizations -- such as inlined functions -- cause problems
  with profiling and need to be disabled

@{b}o@{ub} Some program constructs -- such as longjmp() and exit() -- bypass the
  normal return from a function, and so also cause problems with profiling

@{b}o@{ub} The profiling code noticeably increases the size of a program being
  profiled, and can significantly slow speed-sensitive programs


@{b}Why the 'Y'?@{ub}

Besides the cleverness factor, it's called @{i}Profyler@{ui} rather than @{i}Profiler@{ui} to
distinguish it from any other Amiga profilers that might be out there. In
particular, libprofyle.a won't be confused with clib2's libprofile.a.

@endnode

@node "Quick Start" "Quick Start"

@{b}@{fg shine}Quick Start - For those who hate to read manuals@{ub}@{fg text}

If you want to use Profyler but hate to read manuals, you're out of luck-
Profyler is a sophisticated programming tool, and it requires some effort
and familiarization in order to make use of it.

However, it is possible to get a quick look at what Profyler does without
needing to install it or study the documentation in detail. Profyler comes
with a set of test programs that are already set up for profiling, and which
may be used for a quick introduction to Profyler.

Unlike the rest of this document, this section is written with non-
programmers in mind, with the expectation that some non-programmers might
be curious as to what Profyler does.


@{b}Profiling a test program@{ub}

Start by double-clicking on Profyler to start it running. It will open a
small window that lets you know that there are no target programs (ones that
are set up for profiling) currently running.

Open the @{i}Test@{ui} drawer. Double-click the program called @{i}Simple@{ui}. Because it's
a shell-only program, Workbench opens an "Execute a file" requester for it.
Click the @{b}Execute@{ub} button to run the program.

As soon as the program starts running Profyler detects it and opens a tab
with the program's name and a list browser. The list is empty, as the program
hasn't done anything yet. An instant later, the program opens an output
window and prints "Hello World!" to it. It then pauses, waiting for a break
signal.

Now that the program has done something, click on the Profyler window to
activate it, then select @{b}Update@{ub} from the @{b}Target@{ub} menu. Some data appears in
the list browser. Enlarge the Profyler window in order to see it all.

The list contains the current profile data generated by the Simple program.
The leftmost column is a list of program functions that have executed. The
other columns represent the data associated with each of the functions. See
the @{"Profyler section" link "Profyler" 0} for more on what each column represents. The data for
the function 'main' is blank because that function has not yet completed.

As with any MUI list browser, you can sort the data by any of the columns by
clicking on the column's title. Click again to sort in the other direction.
You can drag any of the columns to a different location using its title, show
or hide any column by right-clicking on any of the titles, and adjust the
column widths by dragging the column title separators.


@{b}Profiling a second test program@{ub}

While Simple is still waiting for a break, double-click the program called
@{i}StructorPlus@{ui}, and then click the @{b}Execute@{ub} button to run it. The program opens
an output window of its own, prints some messages to it, and then terminates,
leaving the output window open. Close the window.

Profyler detects that a second profiled program has begun running, and adds
a new tab and list browser for it. When the program ends, Profyler
automatically updates the list with the profile data the program generated.

StructorPlus is a C++ program, so the function names include the class name
and parameter types, since these are significant to a C++ program. Double-
click on one of the rows, and a requester opens that displays the data for
that function in a different format. Close the requester.

Select the tab for Simple to show its data. Activate the program's output
window, and press CTRL-C to send a break to the program. Nothing visible
happens in the window, but the program has now quit. Note that the list
browser updates when this happens, to display the final data for the program.
Data is now present for 'main'. Close the output window.

If you want, try saving the data for the active tab to a text file or to a
CSV file using the @{b}Target@{ub} menu. You can use a text editor or MultiView to see
what those files look like. You can print the data by saving a text file to
PRT:.


@{b}Wrapping up@{ub}

Click the close button on either of Profyler's tabs to close that tab. When
the last tab is closed a blank tab is opened to replace it. Close that tab to
quit Profyler, or use the window's close box.

That's it; that's what Profyler does. The power of the program is in what the
data it gathers means, and what a programmer can do with that knowledge.

@endnode

@node "Components" "Components"

@{b}@{fg shine}Components - What makes up Profyler@{ub}@{fg text}

There are two components to Profyler, the Profyler program itself, and
LibProfyle, a linkable library that provides the profiling functionality.


@{b}LibProfyle@{ub}

LibProfyle (libprofyle.a) is a linker library that provides the profiling
functionality. It consists of a @{i}prolog@{ui} function that gets called at the
beginning of every function to be profiled, and an @{i}epilog@{ui} function that gets
called at the end. Calls to these functions are automatically inserted by GCC
when the @{b}-finstrument-functions@{ub} option is invoked.

Also present is a GCC constructor function that initializes profiling when
the program starts up, and a GCC destructor function that cleans up when the
program ends. GCC automatically links these into the program when linking
with LibProfyle. All this occurs without any changes required to the source
code of the program, making it easy to add and remove profiling.

Finally, there are a couple of functions, invoked via macros, that allow
profiling to be paused and then resumed, and a macro to prevent a function
from being profiled. To use these the LibProfyle header (profyle.h) must be
included. The macros are defined to do nothing if not profiling, so they may
be left in the source.

Since you need to be able to compile a program to use it with LibProfyle
anyway, LibProfyle is provided in source code form only, rather than as a
bunch of library files built for every possible set of compiler options that
might be used. Just build it with whatever compiler options are appropriate
for the program being profiled. LibProfyle works with both newlib and clib2,
so either may be used.


@{b}Profyler@{ub}

Profyler is a standalone MUI-based program that provides the user interface
to the profile data. It locates any running programs with profiling enabled,
and extracts the profile data from them and displays it in a convenient list
browser format.

Each row in the list browser corresponds to a function, and displays the
function's name and associated profile data, one parameter per column. The
columns of data may be hidden or rearranged in whatever way makes them the
most useful, and the rows may be sorted by any column.

The profile data can be saved to a text file (or to a printer) to generate a
permanent record, or may be saved to a @{i}comma separated value@{ui} (CSV) file for
import into a spreadsheet or other program for further analysis.

Profyler can interface with more than one program at a time (up to nine), so
you can even profile multiple programs that interact with one another.

@endnode

@node "Requirements" "Requirements"

@{b}@{fg shine}Requirements - What you need to use Profyler@{ub}@{fg text}

Profyler and LibProfyle use functionality specific to AmigaOS 4.1 and newer,
so they may be used only with that platform. They also use functionality
specific to GCC, so they may be used only with that compiler. Finally, the
Profyler program is a MUI application, and requires MUI 5 or newer.

Profyler and LibProfyle do not use any hardware-specific features such as
the PowerPC performance monitor, and so should run on any Amiga model that
supports OS4.

The requirements in more detail:

@{b}o AmigaOS 4.1.6 or newer.@{ub} Profyler uses the @{i}ObtainDebugSymbol@{ui} function of
  Exec's debug interface that was added in Exec version 53.41 (one of the
  online updates to OS 4.1.6), so it requires that version as a minimum.

  Profyler and LibProfyle have been tested under OS 4.1.6 and OS 4.1.FE.2
  on an X1000.

@{b}o MUI 5 or newer.@{ub} Profyler uses features that are not present in older
  versions of MUI, so MUI 5 is required as a minimum.

  Profyler has been tested with recent versions of MUI 5.

@{b}o GCC.@{ub} LibProfyle should work with any version of GCC that supports the
  @{b}-finstrument-functions@{ub} feature.

  LibProfyle has been tested with GCC 4.2.4 and GCC 8.3.0, with both C and
  C++ code, and with both newlib and clib2. It has been reported by users to
  work with GCC 11 as well.

@endnode

@node "Installation" "Installation"

@{b}@{fg shine}Installation - How to install Profyler@{ub}@{fg text}

No installer or specific installation instructions are provided for Profyler,
since the installation will likely vary with the specifics of your SDK setup
and how you intend to use Profyler. General guidelines are provided below;
modify these to match your SDK layout.


@{b}LibProfyle@{ub}

The linkable profiler library (libprofyle.a) is furnished only in source code
form. Since the program to be profiled must be compiled in order to use the
library with it, you might as well compile the library, too. That way it can
be built by the same version of the compiler, and with whatever compiler
options and for whatever standard C library the main program uses.

The profiler library source code lives in the @{i}LibProfyle@{ui} directory, and the
provided makefile puts the generated library in this directory as well. The
LibProfyle directory will likely need to be located wherever you put projects
to be built. Once the library has been built it can be copied to the SDK's
standard location for linkable libraries, or you can modify your project's
makefiles to access the library in the LibProfyle directory.

The header file @{i}profyle.h@{ui} is also furnished in the LibProfyle directory. In
many cases profiling may be added to a program without needing to include the
header, but in some cases it does need to be included, and so should be
copied to the SDK's standard location for library header files. Note that the
LibProfyle source itself does not use the header file, so it doesn't need to
remain in the LibProfyle directory.

See @{"How to Use" link "How To Use" 0} for more details on building and using LibProfyle.


@{b}Profyler@{ub}

The Profyler program and its associated icon may be placed wherever you put
development-related programs. This guide and its associated icon may be
placed wherever you put development program documentation.

The @{i}Source@{ui} directory contains the source code for the Profyler program. The
source code is not needed in order to use Profyler, but is provided in
accordance with the recognized benefits of open-source software. Note that
the LibProfyle header file @{i}ProfyleData.h@{ui} is required in order to build
Profyler, so you'll need to adjust the makefile to point to wherever you
put the LibProfyle directory, or you can copy the header into the Source
directory. The makefile may also need to be adjusted to point to your MUI
include directory.


@{b}Test/Example Programs@{ub}

The @{i}Test@{ui} directory contains a number of small programs and their source code,
along with a makefile to build them all. These programs were used during the
development and testing of LibProfyle to test particular aspects of profiling
and what would and would not work. They can also serve as simple examples of
how to use Profyler, and provide a way to play with Profyler without first
needing to adapt some other code to add profiling. This directory may be
placed inside or alongside the Source directory. The makefile may need to
be adjusted to allow the compiler to find the profyle.h header file and
libprofyle.a.

See @{"Test Programs" link "Test Programs" 0} for more details on what the programs do and how to build
them if you want to experiment with building them in different ways.

@endnode

@node "How To Use" "How To Use"

@{b}@{fg shine}How To Use - How to add profiling to your project@{ub}@{fg text}

@{b}Compiling@{ub}

In order to use LibProfyle to profile a program, that program must be
compiled using the @{b}-finstrument-functions@{ub} option of the GCC or G++ compilers.
Doing so causes the compiler to add calls to the profiler functions to the
beginning and end of every function it compiles.

Because inlined functions @{"cause problems" link "Limitations" 71} when profiling, the @{b}-fno-inline@{ub}
option should also be specified (newer versions of GCC automatically disable
inlining when instrumented functions are used, but it doesn't hurt to add
this option anyway). Debug information is necessary in order to display the
function names, so the program must be compiled with @{b}-gstabs@{ub}. For basic
profiling, that's all that needs to be done- no changes to the source code
are required.

However, if it is desired to use the Profyler macros that pause and resume
profiling or that disable profiling for specific functions, the source code
will need to be modified to include the Profyler header file @{i}profyle.h@{ui}, and
@{b}-DPROFILING@{ub} will need to be added to the compiler command line to enable the
macros. (If PROFILING is not defined then the macros do nothing, so they may
be left in the source even when not profiling.)


@{b}Linking@{ub}

The profiling functions are found in LibProfyle, so the program must be
linked with @{i}libprofyle.a@{ui}. The library also contains GCC constructor and
destructor functions that set up profiling when the program starts, and clean
up when the program ends. These functions are brought in automatically when
the program is linked with libprofyle.a; no changes to the program source are
required.

The @{"test programs" link "Test Programs" 0} supplied with Profyler provide simple examples of how to
add profiling to a program, including use of the macros.

If a program is composed of multiple modules (object files), it is not
necessary to use profiling with every module; individual modules may be
compiled with or without profiling as desired. If profiling a linker library
it is not necessary to profile the program that calls the library at all,
though the program must still be linked with libprofyle.a in order for the
profiling code to be present for the linker library to use. The same applies
to shared objects.


@{b}Releasing@{ub}

Of course, once the program has been profiled and optimized it should be
rebuilt without profiling before being released to end users. The makefile
for the test programs provides an example of how to easily disable profiling-
just comment out a few lines in the makefile and rebuild the program.

If your program is open source and its source code needs to be distibuted
publically, the LibProfyle directory includes the header file @{i}noprofile.h@{ui},
which defines all of the Profyler macros to do nothing. This header may be
distributed with the program's source so it can be compiled even by those who
don't have Profyler. Either change the source files to include this file
instead of profyle.h, or just rename this file to profyle.h. noprofile.h is
public domain, so it may be included with source code without incurring any
GPL obligations.


@{b}The Profyler macros@{ub}

When the symbol PROFILING is defined prior to including the header file
@{i}profyle.h@{ui}, the following macros are activated to provide some control over
the profiling process. If PROFILING is not defined the macros do nothing,
so they may be left in the source even when not profiling.


@{b}PROFILE_PAUSE@{ub}
@{b}PROFILE_RESUME@{ub}

These macros turn profiling off and back on. The profiling code still runs,
but it will not count the time that occurs between the two macros as part of
the execution time of the function in which the macros are used, or of any
higher-level functions that call that function.

The purpose of the macros is to prevent calls to external (non-profiled)
functions that wait for a long or indefinite period of time -- such as
interaction with a user -- from inflating the run time of the program so much
that all the other functions in the program end up taking only a small
percentage of the time, making them hard to profile.

The most common usage of the macros would be around any calls to Wait(),
WaitPort(), or other OS functions that wait indefinitely for an external
event:

    PROFILE_PAUSE;
    IExec->Wait(WaitMask);
    PROFILE_RESUME;

The macros may also be used around other OS calls that call Wait() at some
point, such as requesters:

    PROFILE_PAUSE;
    IIntuition->EasyRequest(NULL, Message, NULL);
    PROFILE_RESUME;

The macros may also be used around intentional delays:

    PROFILE_PAUSE;
    IDOS->Delay(50);
    PROFILE_RESUME;

The macros are intended to be used only around calls to external functions
that are not being profiled. Don't use them around a program function that is
being profiled. They won't blow up if misused, but the result is probably not
going to be useful.


@{b}PROFILE_OFF@{ub}
@{b}PROFILE_ON@{ub}

These are alternate names for the above macros that are provided for
compatibility with SAS/C's @{i}SPROF@{ui} and @{i}GUIProf@{ui} profilers. They make it possible
for the same source code to be used for both OS3 and OS4 development.


@{b}DONT_PROFILE@{ub}

This macro is used when defining a function:

    static DONT_PROFILE int32 my_func(int32 parm1, int32 parm2)
    {
        Function definition...
    }

It is used to tell the compiler to not profile the function to which it is
applied. It may be used to avoid profiling very short and fast functions that
are called a lot; such functions are likely already optimized, and the
overhead of the profiler on such functions can greatly slow the program while
providing little benefit.

Note that a bug in the G++ compiler version 4.2.4 that's distributed with the
official OS 4.1 SDK causes compilation to fail if this macro is used. It
works properly with GCC and with later versions of G++.


@{b}Building LibProfyle@{ub}

Since LibProfyle is distributed only in source code form, it needs to be
built before it can be linked into a program. A makefile is provided to
accomplish this. The makefile allows the use of either newlib or clib2 as the
standard library; select whichever one the program to be profiled is using.

LibProfyle is built with position-independent code; this allows it to be used
with shared objects as well as with programs and linker libraries.

The makefile has one other build option that may be modified, the definition
of the value @{b}CALL_STACK_QUANTUM@{ub}. This controls the size of the call stack
that LibProfyle uses to track function calls being profiled. The default
value is 100, which accommodates function calls that nest up to 100 levels
deep. This should be plenty for any program that doesn't use recursive
functions.

If LibProfyle runs out of stack, it enlarges the stack by CALL_STACK_QUANTUM
entries and continues. It will do this as many times as required. This allows
it to accommodate recursive functions with only an occasional tiny slowdown
when the stack is enlarged. This slowdown is counted as part of the compiler
overhead and so does not affect profiling, but it might make the program take
a little longer to run. Once enlarged the call stack is never reduced in
size.

To avoid this bit of overhead when profiling a program that is known to be
heavily recursive, the value of CALL_STACK_QUANTUM may be enlarged in order
to provide a larger call stack to begin with, reducing or eliminating the
need to enlarge the stack. Each call stack record is only 44 bytes, so a
large call stack does not have much effect on memory usage.

With versions of GCC that support prioritization of constructors and
destructors, LibProfyle sets its constructor and destructor to the highest
priority, so that the constructor runs before any others, and the destructor
runs after any others. This allows other constructors and destructors to be
profiled.

If for some reason another constructor needs to run before LibProfyle's, the
LibProfyle priority may be set to a lower value (higher number). The other
constructor would then be set to the highest priority.

@endnode

@node "Profyler" "Profyler"

@{b}@{fg shine}Profyler - Using the user interface@{ub}@{fg text}

The Profyler application provides the user interface to the profile data
gathered by LibProfyle, making the data available to the developer in a form
that makes it useful for studying and optimizing the performance of the
profiled program. Profyler uses the term @{i}target@{ui} to refer to a profiled
program.

Profyler may be run from the shell or from Workbench. It has no command line
options or Workbench tooltypes. When first started, Profyler checks to see if
any target programs are running. If it finds any, it will open a tab for each
one, titled with the target program's name. If no targets are located it will
open an empty tab. If any target program is started while Profyler is already
running, it will open a tab for that target, or will reuse an existing tab if
that tab's target program is no longer running. Tabs may be closed by
clicking on their close box. If the last (empty) tab is closed then Profyler
quits, or it may be quit at any time by clicking the window's close box.

Each target tab contains a list browser that has one line for each profiled
function that has run (functions that haven't run aren't shown), and one
column for each profile data value associated with the function. Functions
(and their source file locations) are added to the list when they are first
called, but the remainder of the data is updated only when the function
returns. So main(), for instance, will always have blank data until the
program has quit.

The columns are as follows:

@{b}o Function@{ub}

  The name of the profiled function. The names of C++ functions are
  demangled, and include the class they are part of (if any) and the
  parameter types associated with the function (since each combination of
  class and parameter types is a different function, even if the name is the
  same).

  The names of regular C functions are passed through the demangler as well,
  since Profyler doesn't know whether the program source is C or C++. On
  rare occasions the demangler may mistakenly corrupt a C function name.

  Function names are limited to 31 characters, so names that are longer are
  truncated (this is most likely to occur with C++ code, where the class
  names and parameter types can add substantially to the length of the
  name).

  If the profiled program has no debug information then the function name is
  not available, and the memory address of the function in hexadecimal is
  shown instead.

@{b}o Location@{ub}

  The source file name and line number where the function is defined. This
  column is hidden by default, since the information takes up a lot of
  window space and is not typically used.

  If the profiled program has no debug information then the source location
  is not available, and this column remains blank.

@{b}o Calls@{ub}

  The number of times the function has been called and returned. The count
  is incremented only when the function returns, and not when it is called.@{b}

o Inclusive@{ub}

  The total execution time of all calls to the function so far, including
  the time taken by any other functions that the function calls. The units
  of time vary, depending on the magnitude of the time accumulated.

@{b}o % Incl.@{ub}

  The percentage of the total run time* of the program so far that has been
  taken by this function and any other functions that it calls.

  Any single function should never have a value greater than 100% (though
  @{"recursive functions" link "Limitations" 126} can be an exception), but there is no limit on the sum
  of all of the function percentages.

@{b}o Avg. Incl.@{ub}

  The average execution time of all calls to the function so far, including
  the time taken by any other functions that the function calls. The units
  of time vary, depending on the magnitude of the time accumulated. This
  number is simply the inclusive time divided by the number of calls.

@{b}o Exclusive@{ub}

  The total execution time of all calls to the function so far, excluding
  the time taken by any other profiled functions that the function calls.
  The units of time vary, depending on the magnitude of the time
  accumulated. Calls to functions that are not profiled (including any
  external or library functions) are not excluded.

@{b}o % Excl.@{ub}

  The percentage of the total run time* of the program so far that has been
  taken by this function, excluding any other profiled functions that it
  calls.

  The sum of all of the function percentages should equal 100% (plus or
  minus, due to rounding of the displayed percentages).

@{b}o Avg. Excl.@{ub}

  The average execution time of all calls to the function so far, excluding
  the time taken by any other profiled functions that the function calls.
  The units of time vary, depending on the magnitude of the time
  accumulated. This number is simply the exclusive time divided by the number
  of calls.

  * For the purpose of calculating the percentages, the total run time is
    the sum of all of the exclusive run times in the list. This represents
    the total run time of the program so far, minus the profiler overhead,
    and minus any periods where profiling is disabled via the PROFILE_PAUSE
    macro.

The arrangement of the columns may be adjusted by grabbing any of the column
titles with the mouse and dragging the column to a new location. Columns may
be hidden or revealed by right-clicking the mouse over any of the column
titles and using the menu that pops up. The width of the columns is set
automatically based on their contents, but the width may also be set manually
by using the mouse to drag the dividers between the column titles.

The list may be sorted according to the contents of any of the columns by
clicking the mouse on the column title. Clicking again will sort the column
in the opposite direction. When a list is first displayed the rows are sorted
in alphabetic order by function name. Note that the sort order of entries
having the same sort value is indeterminate, and tends to change every time
the display is updated- that's just the way the MUI list browser works.

Double-clicking the mouse on any row in the list (or pressing RETURN if
using keyboard control) opens a requester that displays the same information
as the row, except in a page-oriented rather than columnar format. Its main
purpose is providing a way to see information that might be hidden in the
list browser without having to manually turn the hidden columns back on.

This requester is modal, so the Profyler window is put to sleep while the
requester is open. If any profiled programs start up or end while the
requester is open they will hang until the requester is closed and Profyler
is able to interact with the program.

As with any MUI application, you can iconify and restore Profyler while it's
running, and the window's size and location may be snapshotted.

Profyler is controlled using a small set of menus:

@{b}@{u}Profyler Menu@{ub}@{uu}

@{b}o About...@{ub}

  Opens a requester with information about the program, its author, and its
  license.

@{b}o About MUI...@{ub}

  Opens the standard MUI 'About' requester.

@{b}o MUI Settings...@{ub}

  Opens the standard MUI settings window. Any settings made here will apply
  only to Profyler, and not to any other MUI application. The settings may
  be saved, so Profyler will automatically use them in the future.

@{b}o Quit@{ub}

  Quits Profyler. Any profile data being displayed is lost. Profyler assumes
  you know what you're doing, and does not ask for confirmation before
  quitting.

@{b}@{u}Contact Menu@{ub}@{uu}

@{b}o Scan For Targets@{ub}

  Instructs Profyler to look for any profiled programs that are running, and
  to add new target tabs for any that are found. Any programs found that
  already have a target tab are ignored.

  There's normally no need to use this menu, as Profyler automatically scans
  for targets when it's first run, and any target program that's started
  while Profyler is already running will automatically trigger a new tab to
  be opened.

  If a target tab is closed, but not Profyler itself, then this menu may be
  used to reopen the tab, as long as the target program is still running.

@{b}@{u}Target Menu@{ub}@{uu}

@{b}o Update@{ub}

  Tells Profyler to read the latest profile data from the current target
  program (the one whose tab is displayed) and to update the display. This
  may be done repeatedly as long as the target program continues to run. It
  can take some time to read and process all the data from a large program
  the first time; subsequent updates are much faster since only data that
  has changed needs to be processed.

  Profyler does not automatically update the display when a target program
  is first started, because at that point no profiled functions have yet
  run, and so no data is available to display. If a target program is
  already running when Profyler is started, the display is updated with
  whatever data is available at that point.

  The display is updated automatically when the target program quits, to
  reflect the final data. The data gathered by the target program itself is
  discarded when the target program quits, but Profyler will continue to
  display its copy of the data until the target tab is closed (or reused by
  another target that starts up).

@{b}o Save As Text...@{ub}

  Saves the current target's data to a text file for future reference. The
  saved data mimics the display, so the column order is the same as the
  display, and columns that are hidden are not present (except the function
  name is always present, even if hidden on the display). The sort order of
  the rows is the same as the display.

  The name of the target program appears at the top of the text file,
  followed by a header that identifies the columns. The rows of function
  data follow, one per line. The file assumes that a monospaced font is
  used to display (or print) it; if a proportional font is used the column
  alignment will be off.

  A requester allows the name and location of the text file to be specified.
  The file may be printed by saving it to PRT:, so there is no separate
  Print menu. If printing, set the printer to use a (monospaced) condensed
  font to keep the lines from being too wide to fit the page.

@{b}o Save As CSV...@{ub}

  Saves the current target's data to a @{i}comma separated value@{ui} (CSV) file for
  import into a spreadsheet, database, or other program for further
  processing. The sort order of the rows is the same as the display, but the
  columns are written in a fixed order, to make it easier for an application
  to import. For the same reason, all columns are written, even if they're
  hidden on the display.

  The name of the target program appears on the first line of the CSV file,
  followed by a header that identifies the columns and units of measure on
  the second line. The rows of function data follow, one per line. As you'd
  expect, commas separate the data fields on each line (the data fields will
  never contain a comma themselves). Two adjacent commas indicate a missing
  (blank) data point. The data fields are not quoted, even if they are text
  strings; this worked best with the Amiga spreadsheets that were tested,
  but might require additional effort to import into other applications.

  To make the timing data easier to process, the run times are always in
  units of nanoseconds, regardless of what units appear in the display, The
  percentages are in tenths of a percent.

  A requester allows the name and location of the CSV file to be specified.

As noted above, the MUI list browser that Profyler uses has its own popup
menu that appears when the menu button is pressed while the mouse is over
the title row of the list. It allows the individual columns to be hidden or
revealed, and allows the column widths to be returned to their defaults if
they've been altered.

@endnode

@node "Limitations" "Limitations"

@{b}@{fg shine}Limitations - What Profyler can and can't do@{ub}@{fg text}

Profyler is able to profile ordinary single-threaded, standalone programs
written in C or C++ -- just compile with the appropriate options, and link
with LibProfyle.

Profyler can also profile linked libraries and shared objects. You'll need to
provide a program that calls the library and/or shared object. That program
need not be profiled itself (though it can be, if desired), but it must be
linked with LibProfyle in order to provide the profiling functionality.

GCC constructor and destructor functions -- which run before and after
main(), respectively -- may also be profiled, at least with most versions of
GCC. LibProfyle's constructor and destructor are given the highest priority,
so that profiling should be operational by the time any other constructors
run, and remain operational until after any other destructors run. Older GCC
versions, such as version 4.2.4 that's included with the official OS4.1 SDK,
don't support priorities and so may not allow this profiling.

There are some types of code that Profyler cannot profile. And there are some
program constructs that affect profiling even in a program that's otherwise
okay. These limitations are described below.

Profyler has been designed to not crash or do anything dire when encountering
code that it can't profile properly, but the data it gathers may be somewhat
incorrect. These errors may not be apparent from simply looking at the
profile data, so it's worth being familiar with them in order to recognize
when they may be subtly affecting your results.

Note that the @{"test programs" link "Test Programs" 0} provided with Profyler demonstrate a number of
these limitations, in programs simple enough that the errors are more readily
apparent.


@{b}Code that can't be profiled:@{ub}

@{b}o Multi-threaded code@{ub}

  LibProfyle cannot fully profile a multi-threaded program. It will profile
  the main thread, but not any other threads. It won't crash or misbehave;
  it just won't record any profile data for the additional threads. This
  limitation is because the LibProfyle code and data structures are not
  multi-thread safe, so the prolog and epilog do nothing if called from a
  different task than the one that called the LibProfyle constructor.

  This limitation also affects profiling of callback hooks and other code
  that is called from some other context than that of the program being
  profiled. This includes BOOPSI gadgets and classes such as used by
  ReAction. MUI's notification callbacks and custom classes are called from
  the program's context, and so are not a problem.

@{b}o Amiga libraries and devices@{ub}

  LibProfyle cannot be used to profile standard Amiga shared libraries or
  devices. This is in part because such objects are inherently multi-
  threaded, and in part because they typically run without startup code
  and so do not have initialized global data and would not run the
  constructor and destructor functions.

@{b}o Profyler@{ub}

  If you're wondering- no, you can't profile Profyler itself. Because of the
  way that Profyler interacts with a program being profiled, it will hang
  when it tries to profile itself. See @{"Operation" link "Operation" 0} for more details on why
  this is so. It should go without saying that LibProfyle can't be profiled,
  either.


@{b}Constructs that cause errors:@{ub}

@{b}o Inlined functions@{ub}

  Functions that are inlined still call the LibProfyle prolog and epilog, so
  the inlined function will be profiled. However, the inlined function does
  not have an entry in the debug symbol table, so when Profyler looks up the
  function's name, it gets the name of the function into which it was
  inlined, instead. The result is that the inlined function is treated as if
  it was the parent function, causing errors in that function's data.

  As an example, if main() called three functions that were inlined into
  main(), then Profyler would show main() as having executed four times. The
  execution timing would also be in error, because it's actually timing four
  different functions.

  The solution is to add the @{b}-fno-inline@{ub} compiler option when profiling.
  This will have some effect on the speed of the program, especially if the
  inlined functions are heavily used, but has much less of an effect than
  disabling optimization completely.

  Newer versions of GCC automatically disable inlining when @{b}-finstrument-@{ub}
  @{b}functions@{ub} is used, so there's no need to disable it manually (though
  there's no harm in doing so, to be compatible with older GCC versions).
  Newer versions of GCC may require inline functions to also be declared
  @{i}static@{ui} in order to avoid compiler errors when instrumented functions
  are used.

@{b}o setjmp and longjmp@{ub}

  These two standard library functions will not affect profiling as long as
  they are used only within a single program function. However, if they are
  used to jump out of a lower-level function and back into a higher-level
  function then the epilog of the lower-level function(s) will not execute,
  causing LibProfyle's call stack to become misaligned.

  LibProfyle will detect this and discard the skipped functions from the
  call stack, but in doing so the data logged for those functions is lost.
  Instead, the execution time of those functions is counted as part of the
  inclusive run time of the function containing the setjmp call.

  Note that this fixup of the call stack only happens when the epilog of the
  function with setjmp executes. As a result, the run time of any functions
  called between the return from longjmp and the end of the function with
  setjmp will not be counted in determining the exclusive run time of that
  function.

  The test program @{i}SetJump@{ui} demonstrates this limitation.

@{b}o Abnormal exits@{ub}

  Exiting from a program using exit() or any of the other ways of
  terminating a program other than simply returning from main() will skip
  the epilogs of any functions that do not run to completion, causing those
  functions to not be profiled.


@{b}Recursion@{ub}

Recursive function calls are handled properly by LibProfyle and Profyler,
though the results may not always be what one expects. This includes cases
where the function directly calls itself, and where it calls other functions
that end up calling the function again.

The call count reflects the total number of times the function was called,
including recursive calls. This will be higher than the actual number of
calls by the parent program. The inclusive and exclusive run times work just
as they would with a non-recursive function.

The inclusive time as a percentage of total run time, however, may end up
greater than 100%, something that's not normally possible. That's because the
inclusive run time includes the run time of any recursive calls to that same
function, which themselves include the run time of any recursive calls that
they make. As a result, the run time ends up getting counted more than once.

The test program @{i}Recursion@{ui} demonstrates this issue.


@{b}Interference from other code@{ub}

The Amiga OS is multi-tasking, and LibProfyle has no way to know if another,
higher-priority (or even the same priority) program preempts the program
being profiled. If this happens, the time during which the other program is
running will be counted as part of the execution time of the function it
preempted, which will result in a falsely inflated execution time.

To minimize this problem, avoid using any other programs while performing
profiling. This includes Profyler. It needs to be running along with the
target program in order to capture the profile data, but for least
interference avoid using the list browser while profiling is in progress.
The program being profiled may also be given a higher priority, to reduce
preemption by other, lower priority programs.

Interrupts are another potential source of falsely inflated function
execution times. There's little that can be done to shield against
interrupts, however interrupts are by their nature brief, and so should
have minimal effect on profiling.

The faster a function is the less likely it is to be interrupted or
preempted, and the more times a function is called the less likely it becomes
that any given call is going to be interrupted or preempted. This tends to
dilute the effect of any such errors. Since functions that are most in need
of optimization (and thus of profiling) tend to be those that are short and
get called a lot, it works out well that those functions are also least
affected by interference.


@{b}Timing variations@{ub}

The execution time of many functions can vary considerably depending on the
parameters passed to the function by its caller. Searching and sorting
functions are examples of this. When Profyler displays the average execution
time of a function, it is the average across all calls to the function to
that point. Any given individual call may take more or less time (sometimes
much more or less) than the average.

LibProfyle does not try to keep track of the minimum and maximum execution
times of each function, as a task switch or an interrupt that occured while
the function is running would inflate the maximum run time, making it
meaningless. Such an interruption generally has little effect on the average
execution time, assuming that the function is short enough and is called
enough times.


@{b}Timing errors@{ub}

There are limits to how accurately LibProfyle can measure the run time and
profiler overhead time of a function. It takes many EClock ticks just to read
the EClock after all, and there is some other code that has to run before the
EClock can be read. This can cause the profiler overhead to be greater than
what LibProfyle measures, making the function seem to take less time to run
than it actually does.

On the other hand, it takes a certain amount of time for a function being
profiled to construct a stack frame, gather the required parameters such
as the function's address, and then call the prolog or epilog before the
LibProfyle code even begins to run. This can make the function's actual run
time longer than what LibProfyle measures.

These errors may cancel each other out to some degree, but it's impossible --
without way more effort than it's worth -- to say by how much, and which if
any has the greater effect.

It can be observed that there's effectively a lower limit to the execution
time that LibProfyle can measure. Even a null function, which does nothing
but immediately return, shows as taking some amount of time to run. On an
X1000, the minimum time reported by Profyler for any function to run is
around one microsecond; on an X5000 it's around 400 nanoseconds. This figure
may be different on other Amiga models.

The @{"test program" link "Test Programs" 29} @{i}Simple@{ui} contains a couple of null functions, allowing this
to easily be tested to determine the effect on your platform of choice. Any
profiled function whose execution time approaches this lower limit is as fast
as it's going to get.


@{b}More?@{ub}

It's not feasible to test Profyler with every possible combination of
compiler version, standard library version, compiler options, type of source
code, and style of project organization. So there are no doubt other
limitations and compiler quirks as yet undiscovered. Let @{"the author" link "Author" 0} know if
you come across one, so it can be documented in future versions of this
manual.

@endnode

@node "Profilers" "Profilers 101"

@{b}@{fg shine}Profilers 101 - A brief introduction@{ub}@{fg text}

As a high-powered Amiga programmer you may know this already, but just in
case, here's a bit of background information on profilers.

The purpose of a software performance profiler -- or just @{i}profiler@{ui} for short
-- is to measure the execution time and speed of a program, to allow the
program to be optimized for best performance.

There are two different types of software performance profilers- @{i}statistical
@{ui}profilers, and @{i}deterministic@{ui} profilers. Both have the same purpose, but they
go about this task in notably different ways. Each type of profiler has
advantages and disadvantages; neither type is "the best".


@{b}Statistical Profilers@{ub}

A statistical profiler works by interrupting the processor at regular
intervals -- typically around 100 times per second -- and looking to see
which program is running, and if possible what code within that program is
executing. Over time the percentage of the total execution time that a given
program or function within a program takes up can be built up, giving a
measure of the relative load on the processor that program or function
represents.

The term "statistical" refers to the fact that since the profiler only
samples what is happening periodically, it does not give a complete picture
of performance, but rather only a statistical sample, something like a poll
of a limited number of people that tries to measure the opinions of a much
larger group. Like a poll there can be sampling errors that affect the
results.

Statistical profilers for OS4 include @{i}Hieronymus@{ui} and @{i}Tequila@{ui}, and to some
extent the GCC profiler.

Advantages:

@{b}o@{ub} Is non-invasive- no modifications to the program being profiled are needed
  (though to be very useful, the executable must contain debugging
  information)

@{b}o@{ub} Is fairly efficient, with relatively little impact on application or
  system performance (though the faster it samples, the more impact there
  is)

@{b}o@{ub} Can profile the operating system and shared libraries as well as
  applications (though without debugging information the result may not be
  very meaningful)

@{b}o@{ub} Can in principle profile with a resolution down to individual lines of
  code (though most only resolve to the level of functions)

@{b}o@{ub} Can be used by any user that is curious, though only programmers can
  actually take action based on the result

Disadvantages:

@{b}o@{ub} Can only measure the percentage of time that a program or function takes,
  not the actual amount of time

@{b}o@{ub} Because it only samples what is happening, its accuracy is limited- short
  functions or those that seldom run may be missed entirely (though it can
  be argued that such functions have little impact on the program's
  performance)

@{b}o@{ub} If a program spends most of its time waiting for the user to do something,
  that time can swamp the time that the program actually spends doing
  anything in response, making the latter time hard to measure

@{b}o@{ub} The need to generate interrupts can make profiling somewhat hardware
  dependent


@{b}Deterministic Profilers@{ub}

A deterministic profiler adds code -- known as @{i}instrumentation@{ui} -- to the
program being profiled. This code runs at the beginning and end of every
function in the program, and notes that the function has been called, and
records the system time at the beginning and end of the function, allowing
the actual duration of the function to be measured. From this data the
percentage of the total runtime of the program that each function has
consumed can be calculated.

The term "deterministic" refers to the fact that every execution of every
function is logged, so there is no sampling error. That doesn't mean that
the result is going to be exactly the same every time, since things like
interrupts, pre-emption by higher priority tasks, and I/O latency can affect
the result. But there will be much less variation than with a statistical
profiler.

Deterministic profilers for OS4 include Profyler, and to some extent the GCC
profiler.

Advantages:

@{b}o@{ub} Measures the actual execution time of each profiled function; can
  calculate the total run time of all calls to the function, as well as the
  average time per call

@{b}o@{ub} Records the number of times each function is called, which is also
  valuable when optimizing a program

@{b}o@{ub} Every function that executes is profiled, no matter how long or short it
  is, and no matter how many or how few times it is called

@{b}o@{ub} Profiles only the desired program, so there is no need to wade through
  data from other applications or the operating system

@{b}o@{ub} Profiling can be disabled for portions of the program, so functions that
  involve interaction with the user are not counted and do not swamp out the
  actual functionality of the program

@{b}o@{ub} Can measure both the inclusive execution time of a function, which
  includes the time taken by all the other functions it calls, and the
  exclusive execution time, which excludes the time required by the
  functions it calls; this helps to identify functions that are slow only
  because they call other functions that are slow

@{b}o@{ub} Can generate call graphs that show which functions call which others
  (though Profyler does not do this)

Disadvantages:

@{b}o@{ub} A special version of the program must be built to enable profiling, so the
  program must be compilable

@{b}o@{ub} Is quite invasive, as it adds code to every function, thus increasing the
  size of the program, which might in turn affect code caching efficiency

@{b}o@{ub} Has a relatively high overhead, due to the need to execute the profiling
  code every time a function begins and ends; this overhead is excluded from
  the measured execution time, but still makes the program run more slowly

@{b}o@{ub} The data generated by the profiling code adds to the RAM required by the
  program, which might in turn affect data caching efficiency

@{b}o@{ub} Can only profile to the function level; cannot measure timing within
  functions

@{b}o@{ub} Limitations of the profiling code can restrict the number of places where
  it can be used, potentially preventing profiling of shared libraries and
  multithreaded programs


@{b}The GCC Profiler (gprof)@{ub}

The GCC profiler is a weird combination of both statistical and deterministic
profiling. It adds code to the beginning of every function, but not to the
end. This allows it to deterministically count the number of times each
function is called, and to build call graphs of which functions call which
others.

But the actual performance profiling is done statistically, with an interrupt
that samples to see which code is running. Any code that doesn't belong to
the program being profiled is ignored, so the measured percentages are
relative only to that program, and not to the system as a whole.

The result is a profiler that has some of the advantages and some of the
disadvantages of both types of profiling. Whether this is the best of both
worlds or the worst is up to the user to decide.

Current Amiga implementations of the GCC profiler depend on the PowerPC
performance monitor hardware, which is not supported in all Amiga models;
this limits the number of systems where it may be used.

@endnode

@node "Operation" "Operation"

@{b}@{fg shine}Operation - How Profyler works@{ub}@{fg text}

It's not necessary to know how Profyler and LibProfyle work in order to use
them, but a basic understanding can be helpful in understanding Profyler's
limitations. The explanation that follows is simplified, and does not attempt
to cover every detail. If you want the real nitty gritty, the source code is
extensively commented.


@{b}Function Timing@{ub}

When GCC is given the @{b}-finstrument-functions@{ub} argument, it places a call to an
external function called @{i}__cyg_profile_func_enter@{ui} at the beginning of every
function it compiles, and a call to @{i}__cyg_profile_func_exit@{ui} at the end.
LibProfyle provides these functions. LibProfyle uses the much easier to say
and type terms @{i}prolog@{ui} to refer to __cyg_profile_func_enter, and @{i}epilog@{ui} to
refer to __cyg_profile_func_exit. 

LibProfyle uses the Amiga's EClock to keep track of elapsed time. The speed
of the EClock varies from one Amiga model to the next, but Profyler adjusts
for this to display elapsed times in the correct units regardless of the
EClock speed. However, the resolution of the time measurement varies with the
EClock speed; the faster the speed, the finer the resolution. An X1000 has an
EClock speed of 66.666667 MHz, giving a resolution of 15 ns, An NTSC classic
Amiga has an EClock speed of 3.579545 MHz, giving a resolution of 279 ns.

Put most simply, the prolog notes the EClock value at the beginning of the
profiled function, and the epilog notes the EClock value at the end.
Subtracting the first value from the second gives the duration of the
function in EClock ticks, which can then be converted into time units based
on the EClock speed. The epilog also increments the call count for the
function.

Of course, in reality it's a little more complicated than that. LibProfyle
has to be able to deal with nested function calls, where a second function
can begin executing before the first one completes. It also has to be able to
exclude the execution times of these lower level functions from that of the
calling function. And of course, it takes some time for the prolog and epilog
themselves to run; this time must be excluded from the function execution
time, not only of the current function, but also of any higher-level
functions.


@{b}Data Logging@{ub}

LibProfyle uses two main data structures to keep track of all this. First, it
implements a @{i}call stack@{ui} to keep track of each individual function call. The
prolog creates a new stack entry to keep track of the current function call,
and the epilog removes the entry when the function completes. The stack thus
has an entry for each function that has been called, but has not yet
returned. Each call stack entry contains information related to the current
execution of that function.

Second, there is a @{i}function database@{ui} of functions that have been profiled so
far, which contains the information across all executions of the function.
This database is built on top of Exec's AVL trees, which are optimized for
lookups at the expense of less common operations such as adding or removing
entries. This nicely matches LibProfyle's needs, since it has to search the
database at the start of every function call.

A function database entry contains information for all calls of that function
so far. The function epilog extracts the data for that individual call to the
function from the call stack and adds it to the database; this includes
creating a new database entry the first time a given function is called.

Naturally, it takes some time for the prolog and epilog to do all this, and
we don't want to count that time (known as @{i}overhead@{ui}) as part of the execution
time of the function. So both the prolog and the epilog actually read the
EClock twice, once at the beginning, and once at the end. Subtracting these
two readings gives the overhead time. This overhead time is added to a global
overhead accumulator, which keeps track of all overhead added by the
profiling process since the program began. This allows the overhead to be
subtracted not only from the current function's execution time, but also from
that of all higher-level functions (worst case, main() has to subtract the
overhead from every other function call made by the entire program).

Each function call also subtracts its execution time (adjusted for overhead)
from the execution time of the function that called it (the next function up
on the call stack), which gives the exclusive run time of that function (that
is, the execution time minus the run time of any lower-level functions).

And finally, the macros PROFILE_PAUSE and PROFILE_RESUME turn into calls to
the LibProfyle functions @{i}ProfilePause@{ui} and @{i}ProfileResume@{ui}. These functions
maintain another global accumulator that keeps track of the number of EClock
ticks that elapse between all uses of the two macros, so that this time may
be subtracted from the execution time of all functions on the call stack.
main() is again the worst case; it has to account for all pauses that occur
during the execution of the entire program.

For speed, LibProfyle does as little processing of the data it records as
possible. It only records EClock counts, for example, and depends on Profyler
to convert the counts to actual times. And it records only the address of the
function that is being profiled, and depends on Profyler (via Exec's
@{i}ObtainDebugSymbol@{ui}) to convert the address into the function's name.


@{b}Communication and Data Transfer@{ub}

Profyler needs to be able to access the profile data that LibProfyle has
collected in order to display it to the user, and it has to be able to do
this as the target program runs, without interfering with the profiling. To
facilitate this, LibProfyle stores the profile data in a block of Exec's
@{i}named memory@{ui}. Named memory is memory that appears on a public list that may
be searched by other programs, and which is semaphore protected so it may be
shared cooperatively between different programs without risk of corruption.
This is exactly what LibProfyle and Profyler need to do.

LibProfyle and Profyler use a memory namespace called "Profyle Targets" to
store the profile data from target programs that are running. Profyler knows
to check this namespace when looking for target programs to display. When a
profiled program is first started, LibProfyle's constructor creates a block
of named memory within the namespace called "Target.#", where '#' is a digit
between 1 and 9 that is sequentially assigned. Profyler knows to look for
these names, and will open a tab for each such name found.

Profyler opens a public message port called "Profyler Port". When
LibProfyle's constructor runs, it searches for this port. If found, it sends
a message to the port to let Profyler know that a new target program is
starting up. Profyler responds by checking named memory for the new target,
and opening a tab to display it (though there's no data to display yet, as
the target program hasn't yet executed any code). If the port can't be found
(because Profyler isn't running) then LibProfyle skips sending the startup
message, but will still gather profile data.

When a profiled program ends, the LibProfyle destructor again locates and
sends a message to Profyler's public port, to give Profyler a last chance to
look at the profile data before it is discarded. Profyler responds by reading
the data and updating its display, after which the target program is free to
delete the block of named memory and terminate. If the port can't be found
then the target program terminates anyway, and the profile data is lost.

Whenever LibProfyle needs to update the profile data, it locks the named
memory block first. This insures that Profyler will not be able to look at
the data while it is being updated and is possibly inconsistent. Once the
update is complete the memory is unlocked. When Profyler wants to access the
profile data, it also locks the named memory block. This insures that
LibProfyle will not try to update the data while Profyler is reading it.

When either LibProfyle or Profyler try to lock the named memory while it is
already locked by the other, the program attempting the lock is put to sleep
by Exec until the memory is unlocked. So if Profyler tries to lock the memory
to refresh its display while LibProfyle has it locked in order to update it,
Profyler will be put to sleep. When the update is complete (which we try hard
to make as fast as possible) then Profyler will wake up and be able to lock
the memory itself.

Conversely, if Profyler has the memory locked while reading it to update its
display, then LibProfyle (and thus the target program) will be put to sleep
until Profyler is done and unlocks the memory. Since LibProfyle only locks
the memory from within the prolog and epilog, the period of time during which
the target program is asleep is counted as part of the overhead, and so does
not affect the profile times.

(If you're following closely, you'll understand now why it's not possible to
profile Profyler- a deadlock would occur as both Profyler and LibProfyle --
which is part of Profyler, in this case -- try to lock the named memory.)


@{b}Presentation@{ub}

Profyler maintains its own version of the function database which -- like the
one that LibProfyle uses -- keeps track of the profile data across all calls
to each function since the target program began. It also is built on Exec's
AVL trees. Unlike the LibProfyle database, Profyler's database contains
values that are oriented towards display to the user. Durations are in units
of time, rather than EClock counts. The function's address is converted into
its name, and the name is demangled. Percentages of the total run time are
calculated. And finally, the data is converted into string form for use by
the list browser.

When Profyler reads the profile data that LibProfyle has put into the named
memory block, it converts the raw data into the user-oriented form noted
above, and stores it in its database. For speed, the list browser strings are
only updated when the data they correspond to changes. The list browser is
then given pointers to the database records, which it will reference as
required to obtain the corresponding strings for display as the user scrolls
the list. The database keeps track of which records (functions) have been
sent to the list browser for display, so that only new entries (functions
that have just been added to the database) need to be sent to the browser.

Profyler does all of this data fetching, conversion, and list updating while
the named memory is locked and the target program is asleep. That way, the
time required to do all this processing is not counted as part of the
target's execution time. Other operations within Profyler, such as scrolling
or sorting the list once it's been displayed, can still alter the timing of
the target program, since the target doesn't know when it's been preempted so
another program like Profyler can run, and so can't exclude that time.

@endnode

@node "Test Programs" "Test Programs"

@{b}@{fg shine}Test Programs - What they do and how to build them@{ub}@{fg text}

Profyler comes with a collection of small test programs, located in the @{i}Test@{ui}
directory. These programs were written during the development of LibProfyle
in order to test different aspects of profiling, including what works and
what doesn't work. The programs are provided as simple examples of profiling,
and to demonstrate some of the things that do and don't work.

The programs all do basically the same thing: print a simple "Hello World!"
or "I'm doing this" type of message to stdout, which is normally the shell
window from which they were run (if run from Workbench they open a console of
their own to write to). The programs aren't meant to be great examples of
coding prowess; they're quick and dirty but also very simple, such that the
point isn't lost in a lot of fancy code.

The programs may be run from a shell directly (by typing the program's name)
or indirectly (by typing 'run' and then the program's name). They may also
be run from Workbench by double-clicking on the program and then clicking
@{b}Execute@{ub} from the resulting requester. Note that the method by which a program
is run can make a considerable difference in the speed of printing text,
which is just the sort of thing you can discover using a profiler.

Run the Profyler program first, before running any of the test programs. When
each test program is started Profyler will detect it and display a tab with
no data. When the test program ends Profyler will gather the profile data
from it and display it in the tab.


@{b}Simple@{ub}

As the name suggests, this is a very simple example of profiling, which
nonetheless demonstrates much of what Profyler can do. When run it prints
"Hello, World!" to the console, then waits for a break signal. If run from
Workbench or directly from a shell, press CTRL-C in the console to generate
the break and terminate the program. If run indirectly (via @{i}run@{ui}) this won't
work, and you'll need to use the @{i}status@{ui} command to find the program's process
number and then use the @{i}break@{ui} command on that process.

Simple demonstrates how to profile a library routine that can't be profiled
directly (because the source isn't available), by wrapping it with another
function that can be profiled (@{i}MyPrintf@{ui}, though because this is a very basic
example it doesn't try to deal with passing varargs to @{i}printf@{ui}). It also
demonstrates how to use the PROFILE_PAUSE and PROFILE_RESUME macros to
disable profiling of the call to @{i}Wait@{ui}, so that the time spent waiting doesn't
swamp the actual run time of the program.

Finally, Simple contains a couple of null functions, ones that don't do
anything but immediately return. In theory these should have a run time of
zero, but because there are limitations to how accurately LibProfyle can
measure the execution time of a function there's a certain amount of overhead
that cannot be compensated for, resulting in a lower limit to the execution
time that can be measured. This will vary with the speed of the system; for
an X1000 it's around one microsecond, and for an X5000 it's around 400
nanoseconds.


@{b}SimplePlus@{ub}

This program does exactly the same thing that @{i}Simple@{ui} does, except it's built
as a C++ program (it even uses @{i}printf@{ui} rather than @{i}cout@{ui} for printing). It
demonstrates that profiling works with C++ programs (including properly
demangling the function names), as well as providing a good example of C++
code bloat (with debugging information, the executable is almost ten times
the size of @{i}Simple@{ui}; using cout instead of printf would make the program
larger still).


@{b}SetJump@{ub}

This program demonstrates how using @{i}setjmp@{ui} and @{i}longjmp@{ui} across functions
interferes with profiling. Because longjmp skips the normal return code of
any functions it jumps out of, the profiling epilog for those functions does
not execute. This leaves orphaned entries on the call stack that LibProfyle
uses to record function execution times.

LibProfyle will clean up the stack when this occurs, but profiling data for
those functions is lost. This shows up in Profyler as function names with
no associated data, which in turn throws off the displayed execution time
percentages.

The effect is obvious in a simple program like @{i}SetJump@{ui}, where the aborted
functions are only called once. In a more complex program, where functions
are only occasionally aborted, it may not be obvious that the profile data
is incomplete.


@{b}Exception@{ub}

This program is the C++ equivalent of @{i}SetJump@{ui}, which uses C++ exception
handling to abort a function, rather than @{i}setjmp@{ui} and @{i}longjmp@{ui}. Even though
@{i}throw@{ui} also skips any code following it in an aborted function, the C++ stack
unwinding process does execute the epilog of the aborted function, which
allows profiling to work properly. Score one for C++.


@{b}Recursion@{ub}

This program demonstrates profiling of a recursive function, one that calls
itself. Profyler handles this correctly but, @{"as explained elsewhere" link "Limitations" 126}, the
results may not be what you'd expect. Specifically, the percentage of the
total inclusive run time taken up by the recursive function is more than
100%, something which should not be possible. (Because printing to a console
opened by Workbench is so much slower than printing to a shell console, the
problem is not apparent when the program is run from Workbench.)

Again, the effect is obvious in such a simple program in which the recursive
function is almost the only one. In a more complex program the inflated run
time percentage of the recursive function may not be obvious.


@{b}MultiThread@{ub}

This program demonstrates that profiling is not fully functional in a multi-
threaded program; specifically, only the main thread is profiled. The program
prints a message to the console, then creates a second thread and goes to
sleep until the second thread terminates. The second thread prints a message
to the console, delays for a second, then terminates. The main thread wakes
up, prints a message, and then terminates as well.

Profiling data is displayed only for the main program; function calls in the
second thread are not profiled. This includes calls to @{i}MyPrintf@{ui}; only the two
calls to that function by the main thread are logged, and not the call by the
second thread.


@{b}Structor@{ub}

This program prints a message to the console from the main program, and from
GCC constructor and destructor functions that run before and after the main
program, respectively. It demonstrates that LibProfyle can profile both GCC
constructor and destructor functions.

Note that this is only guaranteed true if the version of GCC used to compile
the program supports prioritization of constructors and destructors. For
older versions of GCC -- such as the one included with the official OS4.1
SDK -- profiling may or may not work, depending on whether LibProfyle's
constructor runs before or after the one that's to be profiled.


@{b}StructorPlus@{ub}

This program is similar to @{i}Structor@{ui}, except it demonstrates profiling of C++
constructors and destructors (which, despite the identical names, are not the
same thing as GCC constructors and destructors). The program defines a simple
class that has a constructor and a destructor, but nothing else. The
constructor and destructor output a message to the console when they run.

The main program creates an instance of the class, outputs a "Hello!"
message, then deletes the class instance. But the program also defines a
global instance of the class, which exists outside of the main program. The
constructor for this instance runs prior to entering main(), and the
destructor runs after exiting main().

The goal of the program is to see whether Profyler is able to profile the
global constructor and destructor calls, which is only true if they run at a
lower priority than LibProfyle's constructor and destructor. This does seem
to be the case, at least when compiling with versions of GCC that support
prioritization of GCC constructors and destructors.


@{b}LinkLibTest@{ub}
@{b}LinkLibTest2@{ub}

These two programs both use the linker library @{i}MyLib.a@{ui}, which is built with
profiling enabled. @{i}LinkLibTest@{ui} enables profiling for the main program as
well, while @{i}LinkLibTest2@{ui} does not. Both programs use functions in the library
to print "Hello World!" to the console.

This demonstrates that linked libraries can be profiled, and that this
profiling is possible whether or not the main program is also being profiled
(note that both programs must be linked with @{i}libprofyle.a@{ui}).


@{b}SOLibTest@{ub}

This program does the same thing as @{i}LinkLibTest@{ui} (and in fact uses the same
source code), except that it uses a shared object (@{i}MyLib.so@{ui}), which is linked
to the program at run time instead of at compile time. It demonstrates that
shared objects may be profiled (LibProfyle is built with position independent
code so it can be linked with either a linked library or a shared object).


@{b}Building the test programs@{ub}

The test programs come with a makefile that builds all of the programs at
once. The makefile is set up so it can easily be modified to enable or
disable profiling, link the test programs with either newlib or clib2, and
to allow compiling with or without newer versions of G++ that require the
@{b}-athread@{ub} option. This makes it easy to experiment with profiling of the test
programs under a variety of test conditions.

The makefile also serves as an example of how to modify the makefiles of
other projects in order to add the ability to build that project with or
without profiling.

The makefile may need to be adjusted, depending on where you decide to put
@{i}libprofyle.a@{ui} and its header file @{i}profyle.h@{ui}.

The precompiled test programs provided with Profyler were built using GCC
8.3.0 and newlib, and (of course) with profiling enabled.

@endnode

@node "Credits" "Credits"

@{b}@{fg shine}Credits - Whodunit@{ub}@{fg text}

Profyler is a copyrighted original work by the author, @{"Mike Steed" link "Author" 0}, and
contains no code from other sources. The author has chosen to release the
Profyler program under the @{"GPL version 2" link "Prog:Work/Profyler/Docs/COPYING-GPL/main" 0}, and the LibProfyle linkable library
under the @{"LGPL version 2.1" link "Prog:Work/Profyler/Docs/COPYING-LGPL/main" 0}. The test/example programs included with Profyler
are released to the public domain, and are free for use by anyone with no
restrictions.

Although it uses no code from other open-source programs, Profyler and
LibProfyle -- like any code, open-source or otherwise -- build on and make
use of the work of others. Here are some of the tools and examples that
helped make Profyler possible.

@{b}o MUI (Stefan Stuntz, Thore Bockelmann, Jens Maus)@{ub}: Although Profyler is an
AmigaOS-only application, MUI was chosen over ReAction because the MUI list
browser is much more powerful and easy to use (for the programmer) than the
ReAction list browser. Since the list browser is the heart of the Profyler
user interface, this was no small advantage.

@{b}o CodeBench (Simon Archer)@{ub}: Used to write and organize the Profyler and
LibProfyle source code. Though quite usable as is, it's hoped that someday
it will become the final product it has the potential to be.

@{b}o SDK Browser (Jamie Krueger)@{ub}: An invaluable reference when coding. Preferred
by the author to the browser that comes with CodeBench.

@{b}o Heddley (Edd Dumbill)@{ub}: After a quarter century, still the best way to put
together an AmigaGuide database, though some manual tweaking is required
afterwards.

@{b}o Compilers@{ub}: Profyler, LibProfyle, and the test programs were compiled with
both GCC 4.2.4 from the official OS4 SDK, and with GCC 8.3.0. The latter was
used to create the released version of Profyler and the test programs.

@{b}o Profyler's cute bunny icon@{ub} was derived from a clipart image found at
@{i}www.clipartkey.com/mpngs/b/89-894583_rabbits-clipart.png@{ui}. The original image
was modified to serve as an icon image by the author.

Finally, the author recognizes the value of other open-source Amiga projects
in providing code that could be studied to learn how best to do things. It's
not practical to list every example, but two that must be mentioned include
the MUI example code, and the YAM source code (a comprehensive and nicely
done project that serves as an excellent example of MUI programming -- and
programming in general -- on a large scale).

@endnode

@node "Author" "Author"

@{b}@{fg shine}The Author@{ub}@{fg text}

Profyler's author is @{b}Mike Steed@{ub}. He may be reached by email at
@{b}72207.463@compuserve.com@{ub}. He lives in Santa Cruz, on the central coast of
California, where can be found both palm trees and redwoods. He's been
programming the Amiga for more than 30 years; his past work includes
@{i}PassPocket@{ui} (available on @{i}Aminet@{ui} and @{i}OS4Depot@{ui}) and @{i}FlashPlayer@{ui} and
@{i}WeatherStation@{ui} (both available on @{i}Aminet@{ui}).


@{b}@{fg shine}Profyler's Inspiration@{ub}@{fg text}

Profyler and LibProfyle were inspired by the @{i}SPROF@{ui} and @{i}GUIProf@{ui} deterministic
profilers provided with SAS/C version 6.50/6.55. They were quite helpful in
the author's work on @{i}FlashPlayer@{ui} and the SWF library that it uses, although
they were also painfully slow on a 68K machine, even with a 50 MHz 68060.

Although the source code for those programs -- and for the profiler's prolog
and epilog functions -- was provided with the SAS/C compiler, none of it was
used in Profyler. Though LibProfyle uses the same basic concept of a function
prolog and epilog that make use of the Amiga's EClock, LibProfyle's prolog
and epilog do much more of the work than SAS/C's ones did. That makes
LibProfyle much larger and more complex, but also much faster.

@endnode

@node "History" "History"

@{b}@{fg shine}Version History - What came before@{ub}@{fg text}

@{b}Version 1.1     5-Mar-22@{ub}

@{b}o@{ub} The lack of source file location information for profiled functions
  in Profyler 1.0 turned out to be due to a bug in Exec library's
  @{i}ObtainDebugSymbol@{ui} call. A workaround has been added to allow the
  information to appear. The Location column is still hidden by default,
  since it takes up a lot of space and isn't typically used.

@{b}o@{ub} Now that source file location information is present, a flaw in sorting
  the information became apparent: the information was sorted entirely
  alphabetically, so line 9 would come after line 1000, for instance. It's
  now sorted alphabetically by file name, and then numerically by line
  number.

@{b}o@{ub} Added the file @{i}MyLib.so@{ui} to the @{i}Test@{ui} directory. It was inadvertently left
  out of the version 1.0 release, preventing the @{i}SOLibTest@{ui} program from
  working.

@{b}o@{ub} Tweaked the guide a bit to reflect testing done by users on Amigans.net.


@{b}Version 1.0     15-Jan-22@{ub}

The first release of Profyler.

@endnode

