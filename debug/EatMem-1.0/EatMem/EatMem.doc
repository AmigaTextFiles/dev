
                                   EatMem 1.0

                       Copyright © 1994 T.O. Karjalainen

                            This program is FREEWARE
       You may freely distribute it IN ITS ORIGINAL, UNMODIFIED ARCHIVE.
            Conversion into another archive formats allowed but
                   ALL FILES MUST BE PRESENT AND INTACT!

                Any comments, bug reports, suggestions etc. to:

                                  Paper mail:
                                Timo Karjalainen
                                Laavakiventie 12
                                FIN-90240 OULU
                                FINLAND, EUROPE

                                    E-Mail:
                            tikarjal@freenet.hut.fi

                         If you make any modifications,
               please send your enhanced versions to me directly.

CONTENTS

	Introduction
	Inside the Archive...
	System Requirements
	Installation
	Using EatMem
	Debugging Techniques
	The Examples 
	Notes
	About the Sources
	Final Word
	License
	Disclaimer
	History
	Copyrights And Trademarks Plus Other Legalities
	Credits

INTRODUCTION

	At the first sight a program whose sole purpose is to eat your free RAM
	doesn't seem very useful, does it? Well, have another guess...

	When developing applications it is extremely important that the code 
	will back out safely if it runs out of memory. If your developing
	environment has a lot of memory, maybe some tens of megabytes, and you
	don't have a smaller machine at hand, you can only assure yourself that
	all your memory allocations, indirect as well as direct, are checked to
	make sure you got what you wanted. However, the reality might as well be
	the other way round, causing your code to crash if it doesn't get what
	it asks for. This is were EatMem comes in. It will temporarily allocate
	memory of requested type and release it later. Between allocating and
	releasing memory, you can test your application to see how it manages
	without free storage. (Boy, what cruelty... Imagine an innocent, nice
	little application, only asking for some crusts of memory to survive,
	coldly refused its honest request in need... Snif :-D)

INSIDE THE ARCHIVE...

	Inside the archive you should have found:

	EatMem/DMakefile	  - DMake script to compile the sources
	EatMem/EatMem		  - the executable
	EatMem/EatMem.c		  - C source code (DICE V.2.06.35)
	EatMem/EatMem.doc	  - this file
	EatMem/ExampleBadAlloc	  - an example that does bad allocations
	EatMem/ExampleBadAlloc.c  - its source code (DICE V.2.06.35)
	EatMem/ExampleGoodAlloc   - an example that does good allocations
	EatMem/ExampleGoodAlloc.c - its source code (DICE V.2.06.35)

	...plus icons for the EatMem/ directory, EatMem.doc and every source
	file.

	If any file(s) is/are missing, please contact me at one of the addresses
	above to get it/them. Please do NOT spread incomplete archives. 

SYSTEM REQUIREMENTS

	11 kB of free memory (7 kB + stack size, normally 4 kB)
	AmigaDOS 1.2 or higher	(Release 2 supported)

INSTALLATION

	EatMem, being an extremely simple program, requires no special instal-
	lation procedures. Just put it anywhere you want. However, I suggest
	that, in order to keep your disk structure logical, you should place it
	where you keep Enforcer, MungWall and other such debugging tools. You
	will find it useful to have this directory, whatever it is, in your
	path. 

USING EATMEM

	Using EatMem is very simple. Run it (probably with the LEAVE option,
	described later) from a Shell and test your code (must be already loaded
	or executed from WB or another Shell) in the low memory situation thus
	created. After that, press <RETURN> in the Shell you ran EatMem from so
	that the allocated memory is freed and ready for some real use. That's 
	it, if your computer didn't crash (and you used EatMem LEAVE with a
	small parameter) your code is fine. If not... well, take a look at the
	source of your code.

	For syntactical usage text, type "EatMem" without any options. For
	AmigaDOS template and argument prompt, type "EatMem ?".

	The command line options are rather simple. You give an amount of mem-
	ory, in bytes, either to allocate or to leave free a largest block of
	that many bytes, and may specify some memory types for the allo-
	cation(s). In AmigaDOS terms:

	LEAVE/S, BYTES/A/N, CHIP/S, FAST/S, PUBLIC/S, LOCAL/S, 24BITDMA/S

	where

	LEAVE		Leave BYTES of the requested type of memory free,
			instead of absolutely allocating that number of bytes.
			This is optional; if not specified, BYTES is the number
			of bytes to allocate, no matter how many will remain
			free. NOTE: BYTES will be the LARGEST block available,
			which may not be the same as total free space. 

	BYTES		How many bytes to "eat", or, when the LEAVE option is
			used, how many bytes to leave free. You *MUST* specify
			this!

	CHIP		Allocate CHIP RAM, leave FAST as it is.

	FAST		Allocate FAST RAM, leave CHIP as it is.

	PUBLIC		Allocate physical memory, leave virtual memory as it is.

	LOCAL		Allocate LOCAL memory (memory on the motherboard of the
			Amiga), leaving expansion RAM as it is.

	24BITDMA	Allocate memory within the first 16 megabytes of address
			space, leaving other areas as they were.

	NOTE: to leave a largest block of 10 kB physical memory free, use
	
	1.SYS:> EatMem LEAVE 10240 PUBLIC	; Correct

	and _NOT_

	1.SYS:> EatMem LEAVE 10240 CHIP FAST	; WRONG!!!
	
	which would try to allocate blocks of memory which are BOTH CHIP and
	FAST, obviously impossible (the definition of FAST is "not CHIP"!). 

	You should TAKE EXTREME CARE when using EatMem LEAVE with a small byte
	count. Something happening (a background task does something etc.) can
	crash or at least deadlock your computer. With only a few bytes memory
	available you perhaps won't be able to free any! (Unable to close any
	windows or quit applications)

DEBUGGING TECHNIQUES

	Testing for startup allocations:

	1) Open a Shell, plus a second one, and a third one if you will start
	   the program under testing from the command line. Arrange windows so
	   that everything is visible, the two or three Shells and the WB drawer
	   where your program is, if needed.
	2) In the first Shell, type
	   1.SYS> Avail TOTAL
	   and write down the amount.
	3) In another Shell, type 
	   2.SYS:> EatMem 0
	   and be careful to press <RETURN> ONLY ONCE! If the program seems to
	   "hang", that's the way it should be. No prompt, no output. 
	4) Now execute your program, from WB or the third Shell you have
	   started. IMPORTANT: DO NOT RESIZE OR MOVE ANY WINDOWS IN BETWEEN
	   THESE STEPS! Doing so might cause the OS to allocate or free memory,
	   which is not tolerated.
	5) After your program has loaded and is running, still without moving
	   or resizing any windows re-enter the "Avail TOTAL" command in the
	   same Shell you ran it the first time. Subtract this value from the
	   previous one. This is the amount of memory your program needs to get
	   running, plus EatMem's memory usage. 
	6) Exit the program you loaded, it is no longer needed. Also press
	   <RETURN> in the EatMem's Shell. 
	7) Type in the EatMem's Shell
	   2.SYS:> EatMem LEAVE <value-n>
	   where value is the calculated memory usage and n is some number. 
	8) Now re-execute your program in the same way you did before. It won't
	   have enough memory to start up, so at least some of its allocations
	   will fail. You will see whether or not your code can handle failed
	   allocations. You should try many different values for n, ranging from
	   2 to above the calculated memory usage minus the size of your execut-
	   able, so that all of your code's allocations will fail in turn, and
	   finally DOS won't be able to load it at all. After seeing how your
	   code managed, either consult the source (if your code failed to
	   manage properly) or repeat from step six with a different n. To be
	   *SURE*, you'd have to try every "(multiple of the size of your
	   smallest allocation) minus two" value for n. This would mean a lot of
	   tests, so in practice you could try starting with n = 2 and
	   incrementing n every time with the last of the allocations that suc-
	   ceeded the last time. 

	Testing for in-the-middle-of-the-run allocations (for example subwindows
	opened, subtasks launched etc.):
	
	1) Calculate required startup memory as shown above in steps 1 to 4. The
	   term "startup" means "to get to the state where you can immediately
	   execute the subroutine under test". Do not quit the program.
	2) Enter the subroutine.
	3) While in that routine, in the Shell used for Avail commands, type
	   "Avail TOTAL". Subtract this value from the one you got after
	   starting your code. This is how much the subroutine takes memory.
	4) Exit from the subroutine (NOT the whole application!)
	4) Now use "EatMem LEAVE" so that you have less memory available than
	   the subroutine needs and try it.

	And finally, remember to test for failures to FREE memory... I.e memory
	loss. See Amiga ROM Kernel Manual: Libraries (page 919 in the Third
	Edition) for more information on memory loss, how to detect it and how
	to fight it. Every serious Amiga programmer has to own this book anyway,
	so go and get one if you don't have it yet. There are quite sophisti-
	cated for ensuring that memory loss doesn't take place. The methods are, 
	however, quite long to type so I won't write them here.

	I recommend using Enforcer with EatMem. The latter will provide you with
	failed allocations, and the former will tell you about them (data writes
	and/or reads of low memory) without letting the machine crash. It won't
	give you any idea about the bug's location if you just see that your
	Amiga crashes. Enforcer is very good in that, it will give you very
	specific data on the conflict. 

THE EXAMPLES

	There are two example programs provided. The first, ExampleGoodAlloc,
	demonstrates correct programming by checking whether or not it really
	got the memory. If it didn't, it will not try to use the memory it
	didn't get. The second on the other hand is very careless about its 
	allocations. 

	Both programs will try to allocate 100 kB's of both CHIP and FAST RAM.
	They will show the address of their allocations and prompt for RETURN in
	order to start utilizing the memory. They will simply fill the bytes
	with their position offsets inside the allocation.

	Try running "EatMem LEAVE 50000" in another Shell and then
	ExampleGoodAlloc while EatMem is running. You will see how it cannot
	allocate CHIP. Now retry with "EatMem LEAVE 50000 FAST" and it will be
	able to get CHIP, but not FAST.

	Now close all background programs and save any work you may have done.
	Use "EatMem LEAVE 50000" and try running ExampleBadAlloc. It won't get
	the memory, so it will use a NULL pointer - and trash your ExecBase,
	crashing the machine. If there WERE 100 kb of CHIP RAM free, you didn't
	have a problem. But EatMem was there, and you saw that it made errors
	visible.

	You can also try "EatMem LEAVE 10000 CHIP" or similar constructions with
	both programs. ExampleBadAlloc will then show CHIP address 0x00000000
	and FAST address of the successful allocation, provided you have enough
	free FAST of course.
	
NOTES

	When using the LEAVE option, EatMem will, in a loop, allocate from the
	requested type of memory an area that is <bytes> smaller than the
	largest free block of that type until the largest block remaining is
	equal to (or smaller than) BYTES specified on the command line. This
	means that you will probably end up having numerous blocks exactly
	<bytes> in size, plus a number of blocks smaller than <bytes>. The
	higher the fragmentation of the memory, the more the total free will
	be. However, there won't be a contiguous block larger than <bytes> left.
	So if you want to test an allocation of 20480 bytes, using "EatMem
	LEAVE 20000" will generate a situation where that allocation fails,
	even if there were half a megabyte still free. Such is the difference
	between _TOTAL_ and _LARGEST_ free...

	The allocated memory is	remembered using an Exec List with 16-byte
	nodes, containing linkage info (two pointers), a pointer to the allo-
	cation and its size. Since these nodes must be allocated as well as the
	eaten memory itself, there are bound to be some incorrect results when
	using LEAVE with small values. This problem could be solved in some 
	cases (you are eating CHIP or FAST) by allocating the nodes from another
	type (the opposite) of memory than the one we are eating. It would, how-
	ever, require that your machine has both CHIP and FAST memory, or some
	additional logics... I'll get that over with in the next version, okay?

	I personally don't find a limit of 16 bytes a limit at all, since allo-
	cating that much memory won't get you anywhere. If you need <16 bytes,
	declare that space as a variable in your code (and use recursive code if
	required). 

	(The reason why EatMem uses AllocMem() and not AllocVec even under V36 
	or higher Exec is simply that AllocVec() also has to record the size of
	the block somewhere. By taking care of this ourselves we will have finer
	control when using LEAVE with small values. Well, we might just allocate
	the memory and INSIDE it record the size, but... It won't help, it would
	still take 16 bytes to allocate 12 bytes since AllocMem() rounds the
	size upwards into the nearest multiple of 8 bytes. Hmm, stripping the
	other pointer from the list part would make the required extra 4 byte
	save.  In the next version, okay?) 

ABOUT THE SOURCES

	The source codes supplied are written for unregistered DICE C 2.06.35.
	They should port easily into other compilers. They have no comments, but
	I bet you will understand them by just reading it through. My C isn't
	THAT cryptic... Just some simple AllocMem()/wait for RETURN/FreeMem()
	programs.

	The source is intentedly not optimized for portability nor clarity,
	because it is NOT meant as a programming example. They only demonstrate
	that EatMem and its examples will free everything they allocate and
	don't do anything nasty. For those timid "is that another trojan horse?"
	people. And, of course, for those of you who want to improve the code,
	too.

FINAL WORD

	The importance of testing developed code can never be overestimated. You
	must test it again and again, over and over to seek and destroy even the
	last hiding place of programming errors. And yes, there WILL be MANY
	errors in every single program anyone writes. Every routine that may 
	fail must be checked for success. When freeing/closing things, make sure
	that you really HAVE allocated/opened whatever you are going about. You
	really must suspect every single line of your code. Inadequate software
	is such a sick sight that I'm getting depressed even at the thought of
	some application "forgetting" to check some AllocMem's.. "Okay", you may
	say, "it is possible that the computer runs out of memory, but it
	wouldn't stay running that way for long anyway - so why not crash it
	myself?" Because when everybody checks for what they get and what not
	the computer will NOT crash. And THAT is the reason - to keep the system
	running, no matter what happens - THAT is why you have read this text.
	So get going and kill every bug you see - and never stop hunting them!

	The song "Seek & Destroy" by Metallica really has an atmosphere that
	every debugging coder needs surrounding him/her. I strongly recommend
	hearing it, or at least reading the lyrics. It can be found on
	Metallica's first LP, called "Kill'Em All", 1984. You should indeed have
	such a raving-mad-attitude towards programming errors. Kill'em all!

LICENSE

	The terms "EatMem", "the archive" and "the program" used herein refer
	to the files "EatMem", "eatmem.c", "EatMem.doc", "ExampleBadAlloc", 
	"examplebadalloc.c", "ExampleGoodAlloc" and "examplegoodalloc.c" which
	are all Copyright © 1994 T.O. Karjalainen.

	You, the licensee, are given permission to:

	1) Distribute the original, unmodified archive freely. You can also make
	   it part of other distribution packages _IF_THEY_ARE_FREE_. 
	2) Convert the archive into another formats to reduce its size or ease
	   distribution. All files and the directory structure must be present
	   and intact. 

	You are NOT allowed to:

	1) Charge any fees other than the copying and/or media costs for 
	   distributing the archive. 
	2) Distribute modified versions. If you make any modifications please
	   send them over to me instead. I will give you credit for your
	   enhancements.
	3) Include EatMem in commercial or shareware software packages or PD
	   libraries without my written permission, except for the Fred Fish 
	   library. Fred Fish is expressly given permission to include EatMem
	   in his Amiga library. 

	Since EatMem is FreeWare, you don't have to pay anything to use it.
	However, I would like some kind of response from you if you use EatMem
	and/or like it. A postcard or a letter (paper or email) will do just
	fine. You can also send money if you absolutely *WANT* to do so. I never
	have too much money, but I won't die of starvation without your
	donations. It's up to you.

DISCLAIMER

	THE AUTHOR MAKES NO WARRANTIES, EITHER EXPRESSED OR IMPLIED, WITH
	RESPECT TO THE INFORMATION PROVIDED IN THIS ARCHIVE. ALL SUCH INFOR-
	MATION IS PROVIDED ON AN "AS IS" BASIS AND SUBJECT TO CHANGE WITHOUT 
	NOTICE. IN NO EVENT WILL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
	INCIDENTAL, OR CONSEQUENTIAL DAMAGES RESULTING FROM ANY CLAIM ARISING
	OUT OF USING THE PROGRAMS OR INFORMATION HEREIN, EVEN IF HE HAS BEEN
	ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. YOU USE THE INFORMATION AND
	PROGRAMS IN THIS ARCHIVE AT YOUR OWN RISK. YOU ASSUME THE COSTS OF ANY
	POSSIBLE REPAIRS, LOSS OF DATA OR PRODUCTIVITY, OR ANY OTHER SETBACKS
	CAUSED BY, PROPER OR IMPROPER, USE OF THE INFORMATION OR PROGRAMS
	HEREIN.

HISTORY

	You can check the version number and date of your executable by typing

	1.SYS:> Version EatMem FULL

	at the Shell prompt. Both should equal the ones first mentioned below.
	If they don't, please contact me to get up-to-date executable (or docs).

	Version 1.0, released 25-Feb-1994:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		- First release.
		+ LEAVE mode added.
		+ memory flags PUBLIC, LOCAL and 24BITDMA added.

	Version 0.01, not released
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		- The original idea and the basics.

COPYRIGHTS AND TRADEMARKS PLUS OTHER LEGALITIES

	Amiga is a registered trademark of Commodore-Amiga, Inc.
	AmigaDOS is Copyright © Commodore-Amiga, Inc.
	AmigaDOS is a trademark of Commodore-Amiga, Inc.
	EatMem is Copyright © T.O. Karjalainen. 
	Enforcer is Copyright © Michael Sinz.
	MungWall is Copyright © Commodore-Amiga, Inc.
	Seek & Destroy is written by Metallica in 1984.

CREDITS

	CMX and Convicted	for background music while coding.
	Commodore-Amiga		for this excellent computer family.
	Matthew Dillon		for his DICE C compiler.
	Metallica		for Seek & Destroy.
