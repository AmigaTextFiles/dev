                         The THOR-Software Licence (v2, 24th June 1998)


This License applies to the computer programs known as "MemSniff" and
the "MemSniff.doc". The "Program", below, refers to such program. The
"Archive" refers to the package of distribution, as prepared by the author
of the Program, Thomas Richter. Each licensee is addressed as "you".



The Program and the data in the archive are freely distributable
under the restrictions stated below, but are also Copyright (c)
Thomas Richter.

Distribution of the Program, the Archive and the data in the Archive by a
commercial organization without written permission from the author to any
third party is prohibited if any payment is made in connection with such
distribution, whether directly (as in payment for a copy of the Program) or
indirectly (as in payment for some service related to the Program, or
payment for some product or service that includes a copy of the Program
"without charge"; these are only examples, and not an exhaustive enumeration
of prohibited activities).


However, the following methods of distribution
involving payment shall not in and of themselves be a violation of this
restriction:


(i) Posting the Program on a public access information storage and
retrieval service for which a fee is received for retrieving information
(such as an on-line service), provided that the fee is not
content-dependent (i.e., the fee would be the same for retrieving the same
volume of information consisting of random data).


(ii) Distributing the Program on a CD-ROM, provided that

a) the Archive is reproduced entirely and verbatim on such CD-ROM, including
especially this licence agreement;

b) the CD-ROM is made available to the public for a nominal fee only,

c) a copy of the CD is made available to the author for free except for
shipment costs, and

d) provided further that all information on such CD-ROM is redistributable
for non-commercial purposes without charge.


Redistribution of a modified version of the Archive, the Program or the
contents of the Archive is prohibited in any way, by any organization,
regardless whether commercial or non-commercial. Everything must be kept
together, in original and unmodified form.




Limitations.


THE PROGRAM IS PROVIDED TO YOU "AS IS", WITHOUT WARRANTY. THERE IS NO
WARRANTY FOR THE PROGRAM, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. THE ENTIRE
RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD
THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
SERVICING, REPAIR OR CORRECTION.


IF YOU DO NOT ACCEPT THIS LICENCE, YOU MUST DELETE THE PROGRAM, THE ARCHIVE
AND ALL DATA OF THIS ARCHIVE FROM YOUR STORAGE SYSTEM. YOU ACCEPT THIS
LICENCE BY USING OR REDISTRIBUTING THE PROGRAM.


                                                        Thomas Richter


_____________________________________________________________________________

Purpose of this program:

This program detects illegal memory changes by continously checking the free
memory. It also protects the memory allocation functions in a mungwall like
way. An exteral terminal or a interal low-level-debugger (like COP from the
same author) is recommended, but not needed.
MemSniff is not a Enforcer-replacement because you can't replace the full
functionality of a MMU, but it does everything possible to find memory 
violations.

It does not protect memory already allocated, since this is not possible 
without a true MMU.

Since this memory checking is a bit tricky, there ARE KNOWN incompatibilities.
DO NOT RUN MemSniff permanently, it slows down your system considerably and 
reduces the size of the available memory up to the half!

Known incompatibilities:

-Does not work well with memory defraction utilities, like PoolMem from
the same author.
-Does not work well with the SaferPatches utility of the same author, unless
you install SaferPatches with a special option.
-Must be installed behind "SetPatch" and "Enforcer" and "Cyberguard", the 
setup code of these programs won't work correctly with MemSniff.
-Is not compatible to the P5 ppc.library.

_____________________________________________________________________________


Theory of operation:

On memory allocation, if the memory is allocated without asking to clear it,
the addresses will be filled with a non-zero bit pattern. An additional wall
of memory around the allocated memory will be allocated as well, and it is
watched if this wall changes. This part of the operation is similar to the
well-known mungwall tool.

It keeps the names of the allocating tasks on request, to be able to check
for memory holes. It remembers on request the exact # of bytes when memory 
gets allocated and complains if a different size gets released.

It checks for stack overflow on request. However, this may cause unnecessary
warnings with the multi-threaded FFS.

It checks for consistency of the memory lists.

It splits on request the total available memory in two parts, continously
giving one half to the system and checking the other for illegal changes. 
Free memory is filled with a special pattern which is checked. Thus MemSniff
will find invalid memory changes in the free memory, but does neither
catch changes in allocated memory nor catches reads of invalid addresses.
This is not possible without a MMU or changeing the source code of the
program to debug. Special debug libraries are available for this purpose 
on the aminet.
_____________________________________________________________________________

Installing MemSniff:

Run MemSniff in your startup-sequence, whereever you want to start the
checking. It should be run AFTER the Enforcer or Cyberguard, and SetPatch.

_____________________________________________________________________________

Synopsis:

MemSniff TASK=CLIENT,PRI/N,STACK/S,CON=CONSISTENCE/S,DEBUG/S,PICKY/S,
		 PRE=PRESIZE/N,POST=POSTSIZE/N,FC=FILLCHAR/N,NT=NAMETAG/S,
		 SHOWFAIL/S,SERIAL/S,MEMLIST/S,VECTORS/S,MIN/N,MAX/N,HELP/S


TASK:
If you want to check a special task, give the name of it here. If the task 
is not running, MemSniff will stop checking the memory to reduce the needed
CPU time.

PRI:
Priority of the checking supervisor task. This should be 0 or below, DO NOT
CHOOSE HIGHER PRIORITIES WITHOUT GOOD REASON. Since the supervisor is
continously running, high priorities will block other tasks from running.

STACK:
Check if the stackpointer of all tasks are within the ranges given in the
task structure.

Caveats:
-This cannot catch short stack overflows, since not every instruction will
be watched.
-The filing system uses mutliple stacks for multiple threads it supports.
It does not setup the stack ranges in the task structure and will cause
MemSniff warnings. This is normal!


CON:
Continously check the consistency of the memory lists.


DEBUG:
Run the system debugger on failure. This will usually be the RomWack or
(starting with 3.0) SAD. If you installed COP, this debugger will be started.


PICKY:
If the size given to FreeMem does not exactly match the size of AllocMem,
MemSniff will be picky and complain. Usually this checking is done only up 
to a multiple of eight bytes.

Caveats:
The layers.library illegaly frees memory chunks in a different size than
allocated. This is known to MemSniff, and it does disable the check for
layers.library calls.


PRESIZE:
Specify the size of the mungwall zone prior to the allocated memory chunk.
This will protect memory from illegaly modifying addresses smaller than
the allocated. Defaults to 32 bytes.


POSTSIZE:
Select the size of the mungwall behind allocated memory. This will protect
overflows of data into nonallocated mem.


FILLCHAR:
Specify the byte which is used to build the wall. -1, which is the default,
will modify this byte from allocation to allocation.


NAMETAG:
Keep the names of all tasks that allocated memory, together with their names.

Caveats:
This costs a lot of additional memory.



SHOWFAIL:
Print warning if a memory allocation failed.


SERIAL:
Do not print MemSniff messages to the console it has been started from, but
send them to a terminal connected to the serial port. The setting is
9600 baud, 8 bit, 1 stop bit, usual ascii will be used. Terminal programs
are available on the net, the tiny Terminal program in the COP package
will suffer, but you also need a second computer (Amiga prefered) and a null
modem connector to run it.



MEMLIST:
Print the position and size of each allocated memory block known to MemSniff,
together with the name of the task it allocated. To make this working, 
another copy of MemSniff must be running, and this copy must have been 
started with the option NAMETAG. If an argument is supplied, only the
memory allocated by this task is shown.

Caveats:
This list is usally VERY LONG. It is recommended that you specify a task
argument or the MIN and MAX arguments.


MIN:
Set the upper boundary (inclusive) of all memory allocations to be printed
out with MEMLIST. Defaults to 0.


MAX:
Sets the upper boundary (inclusive) of the allocates to be printed. Defaults
to 0xffffffff. Both MIN and MAX *must* be decimal numbers.


TO STOP MEMSNIFF:
Send a break-C signal to the memsniff task. Can be done with Ctrl-C if
MemSniff has been started within a console window, or with the break
command in C:. Can also be done with the COP command TASK.S


VECTORS:
Check the low memory size for spurious changes. This option is automatically
disabled if an Enforcer like tool is running in the system because the
enforcer is doing a better job here and MemSniff would interact.

_____________________________________________________________________________

Example calls:


Here is how I run MemSniff in my startup-sequence:


run <>NIL: MemSniff picky serial con nt pri=0


This means: "Be picky about memory allocations, print debug information
over the serial line, check memory lists for consistency, keep name tags
of the tasks that allocated memory and set my priority to 0".

Because this runs MemSniff at a rather "high" priority, you should be 
prepared to slow down your system rather dramatically.


To print the list of allocated memory at a later time, I call MemSniff
like this:

MemSniff MEMLIST


To show only large allocations, e.g. to find programs causing huge memory
holes, I'd recomment:


MemSniff MEMLIST MIN 8192


This prints all allocations larger than 8K.

_____________________________________________________________________________

For more fine THOR-Software programs, 
"Wisit the Web" at: http://www.math.tu-berlin.de/~thor/thor/index.html


Greetings, happy debugging,

	Thomas,		January 1999


Warning: Debugging after 3 a.m. may cnsiderdfd trn dwn hl&/*@#

