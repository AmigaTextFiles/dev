@Database "Functions.hyper"
@master "pv:docs/Functions.guide"

@Node Main "Function Reference (Wed Jul 15 13:59:22 1992)"
Contents:
	@{" Introduction " Link "Introduction"}

Functions:
	@{" alloc() " Link "Alloc"}	(allocate memory)
	@{" apeek() " Link "Apeek"}	(peek address in structure)
	@{" base() " Link "Base"}	(give first element in list)
	@{" botpc() " Link "Botpc"}	(give program counter at bottom of debug log window)
	@{" cols() " Link "Cols"}	(max number of columns in logical window)
	@{" curlist() " Link "Curlist"}	(pointer to current list string)
	@{" eval() " Link "Eval"}	(evaluate argument string)
	@{" free() " Link "Free"}	(free allocated memory)
	@{" getactive() " Link "Getactive"}	(get active logical window)
	@{" getchar() " Link "Getchar"}	(get character on current position)
	@{" getcol() " Link "Getcol"}	(get logical column width)
	@{" getdebug() " Link "Getdebug"}	(get current debug task)
	@{" geterror() " Link "Geterror"}	(get error of routine)
	@{" getlwin() " Link "Getlwin"}	(get current logical window)
	@{" getrow() " Link "Getrow"}	(get logical row height)
	@{" getsize() " Link "Getsize"}	(get size of allocated memory)
	@{" getstack() " Link "Getstack"}	(get maximum stack usage)
	@{" getx() " Link "Getx"}	(get current x position in logical window)
	@{" gety() " Link "Gety"}	(get current y position in logical window)
	@{" if() " Link "If"}		(conditional evaluation)
	@{" isalloc() " Link "Isalloc"}	(say if memory is allocated with alloc())
	@{" isbreak() " Link "Isbreak"}	(is there a breakpoint on this address?)
	@{" key() " Link "Key"}		(wait for key and return keycode)
	@{" lastbytes() " Link "Lastbytes"}	(last number of bytes for memory and view)
	@{" lastfound() " Link "Lastfound"}	(last search address)
	@{" lastlines() " Link "Lastlines"}	(last number of lines for unasm)
	@{" lastmem() " Link "Lastmem"}	(address to continue view, memory or unasm listing)
	@{" lines() " Link "Lines"}	(get max number of lines in logical window)
	@{" peek() " Link "Peek"}	(get value from structure)
	@{" qual() " Link "Qual"}	(get qualifier from last pressed key)
	@{" realloc() " Link "Realloc"}	(reallocate memory)
	@{" rfrate() " Link "Rfrate"}	(return refresh rate)
	@{" rfcmd() " Link "Rfcmd"}	(return pointer to refresh command string)
	@{" stsize() " Link "Stsize"}	(get size of structure)
	@{" taglist() " Link "Taglist"}	(get current tag list number)
	@{" toppc() " Link "Toppc"}	(give program counter at top of debug log window)

Various:
	@{" Back to main contents " Link "pv:docs/PowerVisor.guide/Main"}
@EndNode

@Node Introduction "Function Reference : Introduction"
This reference file contains all functions. Commands are not in this file.
Note that you can use these functions from ARexx. Simply use the same
format as for normal commands :

   A function call in PowerVisor : res=if(a>b,1,2)
   How you must do this in ARexx : 'if a>b 1 2'
                                   res=result
@EndNode

@Node Alloc "Function Reference : alloc()"
   <memory> = ALLOC( ('n',<size>) | ('c',<size>) | ('s',<string>) )


Use this function for easy memory allocation.
Use the @{" free() " Link "Free"} function to free this memory, use the @{" getsize() " Link "Getsize"} function
to get the size of this memory and use the @{" realloc() " Link "Realloc"} function to
reallocate the memory.

The memory allocated with this function is guaranteed to contain
only 0 (except if the first argument is equal to 's').

Note that memory allocated with this command is automatically freed
when PowerVisor quits.

When the blocksize is smaller than 65533 bytes the result from this
function is a pointer after a word containing the size. This pointer is
thus word alligned but not longword alligned.
When the blocksize is bigger the result is a pointer after a longword
containing the size. This pointer is longword alligned.
Using word or longword allignment you can determine the size of a memory
block. An easier way to do this is to use the @{" getsize() " Link "Getsize"} function.


Example :


To allocate 1000 bytes :

< a=alloc(n,1000) <enter>


To allocate 11 bytes and copy the string 'PowerVisor' to this memory use :

< a=alloc(s,'PowerVisor') <enter>


To allocate 1000 bytes in chip ram use :

< a=alloc(c,1000) <enter>



Related commands: @{" cleanup " Link "pv:docs/CommandRef.guide/Cleanup"} @{" showalloc " Link "pv:docs/CommandRef.guide/Showalloc"}

Related functions: @{" free() " Link "Free"} @{" realloc() " Link "Realloc"} @{" getsize() " Link "Getsize"} @{" isalloc() " Link "Isalloc"}
@EndNode

@Node Apeek "Function Reference : apeek()"
   <address> = APEEK( <structure pointer>,<struct def pointer>,
               <field name> )


Returns the address of <structure>.<field name>. <struct def pointer>
must be a pointer to a previously loaded structure definition. <structure
pointer> is the pointer to the structure itself. <field name> must be
defined in the structure definition.

'apeek' uses autodefault to the 'stru' list for the second argument.


Related commands: @{" addstruct " Link "pv:docs/CommandRef.guide/Addstruct"} @{" interprete " Link "pv:docs/CommandRef.guide/Interprete"}

Related functions: @{" peek() " Link "Peek"} @{" stsize() " Link "Stsize"}

Related lists: @{" stru " Link "pv:docs/Lists.guide/Stru"}

Related tutor chapters: @{" Looking at things " Link "pv:docs/LookingAtThings.guide/Main"}
@EndNode

@Node Base "Function Reference : base()"
   <pointer> = BASE( )


This function returns the pointer to the first element in the current list.


Example :

Go to the task list :
< task <enter>

< list <enter>
> Task node name      : Node     Pri StackPtr  StackS Stat Command        Acc
> ---------------------------------------------------------------------------
> RAM                 : 00C20C68 00  00C2117A    1200 Rdy            PROC -
> golem.device        : 00C05C8A 05  00C064B6    2048 Wait           TASK -
> NEWCON              : 00C2CAA8 05  00C2DAA2    4000 Wait           PROC -
> ARP Shell Process   : 00C26180 00  00C270F2    4000 Wait           (03) -
> PowerVisor1.0.task  : 00C31C28 00  00C76132    1024 Wait           TASK -
> File System         : 00C16758 0A  00C16AF6     840 Wait           PROC -
> File System         : 00C172E8 0A  00C17686     840 Wait           PROC -
> trackdisk.device    : 00C068DE 05  00C09F2E     512 Wait           TASK -
> trackdisk.device    : 00C17846 05  00C17A5E     512 Wait           TASK -
> DH0                 : 00C0DF08 0A  00C0E356    1000 Wait           PROC -
> input.device        : 00C03BFA 14  00C04C00    4096 Wait           TASK -
> ARP Background She  : 00C66EB8 00  00C75CD2    4000 Run  pv        (01) -

< d base() <enter>
> 00C20C68 , 12717160


Related commands: @{" list " Link "pv:docs/CommandRef.guide/List"}
@EndNode
@Node Botpc "Function Reference : botpc()"
   <programcounter> = BOTPC( )


This function returns the program counter visible at the bottom of the
'Debug' logical window.
You can set this program counter using the @{" dstart " Link "pv:docs/CommandRef.guide/Dstart"} or @{" dscroll " Link "pv:docs/CommandRef.guide/Dscroll"} commands.


Related commands: @{" debug " Link "pv:docs/CommandRef.guide/Debug"} @{" dwin " Link "pv:docs/CommandRef.guide/Dwin"} @{" dscroll " Link "pv:docs/CommandRef.guide/Dscroll"} @{" dstart " Link "pv:docs/CommandRef.guide/Dstart"}

Related functions: @{" toppc() " Link "Toppc"} @{" isbreak() " Link "Isbreak"} @{" getdebug() " Link "Getdebug"}

Related lists: @{" dbug " Link "pv:docs/Lists.guide/Dbug"}

Related tutor chapters: @{" Debugging " Link "pv:docs/Debug.guide/Main"}
@EndNode

@Node Cols "Function Reference : cols()"
   <cols> = COLS( <logwin> )


This function returns the maximum number of columns available on the
logical window.

'cols' uses autodefault to the 'lwin' list for the first argument.


Example :

< disp cols(main) <enter>
> 00000056 , 86


Related commands: @{" colrow " Link "pv:docs/CommandRef.guide/Colrow"} @{" fit " Link "pv:docs/CommandRef.guide/Fit"}

Related functions: @{" lines() " Link "Lines"} @{" getcols() " Link "Getcols"} @{" getrows() " Link "Getrows"} @{" getlwin() " Link "Getlwin"} @{" getx() " Link "Getx"}
                   @{" gety() " Link "Gety"}

Related lists: @{" lwin " Link "pv:docs/Lists.guide/Lwin"}

Related tutor chapters: @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
@EndNode

@Node Curlist "Function Reference : curlist()"
   <pointer to string> = CURLIST( )


Return a pointer to the name of the current list.
This function returns a string if used from ARexx.

Note for experienced users only !
   The pointer to the string is actually a pointer into the infoblock
   for the current list. curlist()-24 points to the start of the infoblock.
   See @{" The wizard corner " Link "pv:docs/pv:docs/TheWizCorner.guide/Main"} for more information about infoblocks (in the
   'info base').
   Note that if you want to use this feature in ARexx you have to call
   this function using @{" void " Link "pv:docs/CommandRef.guide/Void"} or @{" assign " Link "pv:docs/CommandRef.guide/Assign"}. If you call it directly you
   will get a string and not a pointer in ARexx


Related tutor chapters: @{" Getting Started " Link "pv:docs/GettingStarted.guide/Main"} @{" The wizard corner " Link "pv:docs/pv:docs/TheWizCorner.guide/Main"}
@EndNode

@Node Eval "Function Reference : eval()"
   <result> = EVAL( <string pointer> )


Evaluate the string at <string pointer> and return the result.
'eval' returns 0 if <string pointer> is 0.


Example :

< disp eval("1+2") <enter>
> 00000003 , 3

< scan <enter>
????< 4+4 <enter>
< disp eval(input) <enter>
> 00000008 , 8


Related commands: @{" disp " Link "pv:docs/CommandRef.guide/Disp"} @{" void " Link "pv:docs/CommandRef.guide/Void"}

Related functions: @{" if() " Link "If"}

Related tutor chapters: @{" Expressions " Link "pv:docs/Expressions.guide/Main"}
@EndNode

@Node Free "Function Reference : free()"
   FREE( <pointer> )


Free a block previously allocated with @{" alloc() " Link "Alloc"}.
Note that all memory allocated with 'alloc' is automatically freed when
PowerVisor quits or when you use @{" cleanup " Link "pv:docs/CommandRef.guide/Cleanup"}.


Related commands: @{" cleanup " Link "pv:docs/CommandRef.guide/Cleanup"} @{" showalloc " Link "pv:docs/CommandRef.guide/Showalloc"}

Related functions: @{" alloc() " Link "Alloc"} @{" realloc() " Link "Realloc"} @{" getsize() " Link "Getsize"} @{" isalloc() " Link "Isalloc"}
@EndNode

@Node Getactive "Function Reference : getactive()"
   <logwin> = GETACTIVE( )


This function returns a pointer to the active logical window. This
is the logical window where you can scroll with the keyboard.
You can change the active logical window with the @{" active " Link "pv:docs/CommandRef.guide/Active"} command or with
the <tab> key.


Related commands: @{" active " Link "pv:docs/CommandRef.guide/Active"} @{" on " Link "pv:docs/CommandRef.guide/On"} @{" current " Link "pv:docs/CommandRef.guide/Current"}

Related functions: @{" getlwin() " Link "Getlwin"}

Related lists: @{" lwin " Link "pv:docs/Lists.guide/Lwin"}

Related tutor chapters: @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
@EndNode

@Node Getchar "Function Reference : getchar()"
   <char> = GETCHAR( )


Get the character at the current screenposition in the
current logical window.


Example :

< {locate 10,10;a=getchar()} <enter>


Related commands: @{" locate " Link "pv:docs/CommandRef.guide/Locate"} @{" home " Link "pv:docs/CommandRef.guide/Home"} @{" cls " Link "pv:docs/CommandRef.guide/Cls"} @{" current " Link "pv:docs/CommandRef.guide/Current"}

Related functions: @{" getx() " Link "Getx"} @{" gety() " Link "Gety"} @{" getcols() " Link "Getcols"} @{" getrows() " Link "Getrows"} @{" cols() " Link "Cols"}
                   @{" lines() " Link "Lines"} @{" getlwin() " Link "Getlwin"}

Related lists: @{" lwin " Link "pv:docs/Lists.guide/Lwin"}

Related tutor chapters: @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
@EndNode

@Node Getcol "Function Reference : getcol()"
   <columns> = GETCOL( <logical window> )


Get the real number of columns (or -1) for the logical window. Note that
this is not always equal to the visible number of columns. If <columns>
is not equal to -1 it is the total number of columns. If <columns> is equal
to -1 it means that the logical window is autoscalable in horizontal
direction. To get the real number of columns (after scaling) you can use
the @{" cols() " Link "Cols"} function.

'getcol' uses autodefault to the 'lwin' list for the first argument.


Related commands: @{" colrow " Link "pv:docs/CommandRef.guide/Colrow"} @{" fit " Link "pv:docs/CommandRef.guide/Fit"}

Related functions: @{" getrow() " Link "Getrow"} @{" cols() " Link "Cols"} @{" lines() " Link "Lines"} @{" getlwin() " Link "Getlwin"} @{" getx() " Link "Getx"}
                   @{" gety() " Link "Gety"}

Related lists: @{" lwin " Link "pv:docs/Lists.guide/Lwin"}

Related tutor chapters: @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
@EndNode

@Node Getdebug "Function Reference : getdebug()"
   <debug node> = GETDEBUG( )


Return the current debug node. You can set the current debug node with
@{" duse " Link "pv:docs/CommandRef.guide/Duse"} and @{" with " Link "pv:docs/CommandRef.guide/With"}.


Related commands: @{" duse " Link "pv:docs/CommandRef.guide/Duse"} @{" with " Link "pv:docs/CommandRef.guide/With"} @{" debug " Link "pv:docs/CommandRef.guide/Debug"}

Related functions: @{" isbreak() " Link "Isbreak"} @{" toppc() " Link "Toppc"} @{" botpc() " Link "Botpc"}

Related lists: @{" dbug " Link "pv:docs/Lists.guide/Dbug"}

Related tutor chapters: @{" Debugging " Link "pv:docs/Debug.guide/Main"}
@EndNode

@Node Geterror "Function Reference : geterror()"
   <error> = GETERROR( <expression string> )


Evaluate an expression and return the error. If there was no error, 0
is returned.


Example :

< disp geterror("7") <enter>
> 00000000 , 0

0 since 7 is a valid expression.

< disp geterror("7+") <enter>
> 00000010 , 16

returns 16 since there is a missing operand.

The following errors are defined (Note ! Some of these are obsolete and
will never appear) (Note ! you can change the errorstrings since this file
is called PowerVisor-errors (you can find this file in the program
directory where the PowerVisor executable is or in the S: directory)) :

-6   Stack overflow !!!
-5   A program has crashed !!!
-4   A stack overflow was getting close !
-3   Quiting PowerVisor !
-2   PowerVisor has crashed !
-1   Break...
0    No error
1    Not enough memory !
2    Syntax Error !
3    This is not a device created with OpenDev !
4    Bad list element type !
5    Variable is a constant !
6    Only <B>yte, <W>ord or <L>ong !
7    Odd address error !
8    Could not Lock!
9    Bracket '(' expected !
10   To many arguments for library function !
11   Missing operand !
12   Lock is not a subdirectory !
13   Error while opening device !
14   Unknown list element !
15   Not implemented yet !
16   Unknown mode argument !
17   Unknown AddFunc argument !
18   This is not a process !
19   Node is not a task or process !
20   This task is not freezed !
21   This task is already freezed !
22   Node type is wrong !
23   Addressed element not found !
24   Window is not sizeable !
25   This is no supported library function !
26   No help available for this subject !
27   Error while opening file !
28   Error while reading file !
29   Not a resident module !
30   Not a lock !
31   Bad History value (2..1000)
32   Error opening trackdisk device !
33   DoIO returned with a non zero value !
34   There is no task to debug !
35   Unknown argument for trace !
36   Unknown argument for debug !
37   Address is in ROM ! Can't set breakpoint !
38   Not a debug node !
39   Bad '@' argument
40   LoadSeg error !
41   Unknown argument for dmode !
42   There is no current debug task !
43   Unknown argument for break !
44   Breakpoint does not exist !
45   There are no symbol hunks !
46   Symbol not found !
47   You can only remove variables !
48   You can not assign to a function !
49   You must use brackets with functions !
50   Unknown argument for symbol !
51   There are no symbols !
52   You can only realloc blocks smaller than 64K !
53   Your brackets are really out of order !
54   The debug task is busy, please try again later !
55   The task is not tracing !
56   File does not have the right format !
57   This is not a structure definition !
58   Bad argument value !
59   No colorchange allowed when PowerVisor is on a window !
60   Could not open font !
61   Can't execute script file in script file !
62   Refresh window is not open !
63   Unknown tag type !
64   No output allowed on debug logical window !
65   Error writing file !
66   Not a Tag file !
67   Bad tag list value (0 .. 15) !
68   Unknown or invalid register !
69   There is a more recent patch then this one installed !
70   There is no fd file loaded for this library !
71   Unknown logical window !
72   Resulting commandline too long after converting from alias string !
73   Missing left bracket '(' in fd file !
74   Missing right bracket ')' in fd file !
75   Bad '##bias' statement in fd file !
76   You can't close the 'Main' physical window !
77   You can't close the 'Main' logical window !
78   Bad argument for 'openlw' ! Arg must be one of 'r','l','d' or 'u' !
79   Brother logical window must be on same physical window !
80   Window is not movable !
81   There is no father for this box !
82   Unknown preferences argument !
83   Please close visitor windows first !
84   Divide by zero !
85   No group operators allowed for the debug task !
86   Error opening screen !
87   You can't remove the 'rc' and 'error' variables. These are private !
88   'LoadSeg' failed !
89   Variable names must start with a letter or an underscore !
90   Error opening physical window !
91   Error opening logical window !
92   Bracket ')' expected !
93   Bracket '}' expected !
94   Bus error !
95   Address error !
96   Illegal instruction !
97   Division by zero !
98   CHK instruction !
99   TRAPV instruction !
100  Privilege Violation !
101  Trace error !
102  Unimplemented 1010 opcode !
103  Unimplemented 1111 opcode !
104  Unknown argument for track !
105  PowerVisor is allready tracking for a task !
106  PowerVisor is not tracking !
107  Unknown argument for source !
108  There are no debug hunks in this executable file !
109  There is no source loaded for this debug node !
110  This address is not in the source !
111  This command only works on the 68030 or 68040 !
112  You need a MMU for this command !
113  Not a valid executable file!


Related commands: @{" error " Link "pv:docs/CommandRef.guide/Error"}

Related tutor chapters: @{" The wizard corner " Link "pv:docs/pv:docs/TheWizCorner.guide/Main"}
@EndNode

@Node Getlwin "Function Reference : getlwin()"
   <logwin> = GETLWIN( )


This function returns a pointer to the current logical window.
The current logical window is not the same as the active logical window.
The current logical window is the one that shows all output. The active
logical window is the one where you can scroll with the keyboard.


Related commands: @{" current " Link "pv:docs/CommandRef.guide/Current"} @{" on " Link "pv:docs/CommandRef.guide/On"} @{" active " Link "pv:docs/CommandRef.guide/Active"}

Related functions: @{" getactive() " Link "Getactive"}

Related lists: @{" lwin " Link "pv:docs/Lists.guide/Lwin"}

Related tutor chapters: @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
@EndNode

@Node Getrow "Function Reference : getrow()"
   <rows> = GETROW( <logical window> )


Get the real number of rows (or -1) for the logical window. See the
explanation for @{" getcol() " Link "Getcol"} to see what the -1 really means.

'getrow' uses autodefault to the 'lwin' list for the first argument.


Related commands: @{" colrow " Link "pv:docs/CommandRef.guide/Colrow"} @{" fit " Link "pv:docs/CommandRef.guide/Fit"}

Related functions: @{" getcol() " Link "Getcol"} @{" cols() " Link "Cols"} @{" lines() " Link "Lines"} @{" getlwin() " Link "Getlwin"} @{" getx() " Link "Getx"}
                   @{" gety() " Link "Gety"}

Related lists: @{" lwin " Link "pv:docs/Lists.guide/Lwin"}

Related tutor chapters: @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
@EndNode

@Node Getsize "Function Reference : getsize()"
   <size> = GETSIZE( <memoryblock> )


This function determines the size of a memoryblock allocated with the
@{" alloc() " Link "Alloc"} function or some other PowerVisor commands.


Related commands: @{" cleanup " Link "pv:docs/CommandRef.guide/Cleanup"} @{" showalloc " Link "pv:docs/CommandRef.guide/Showalloc"}

Related functions: @{" alloc() " Link "Alloc"} @{" free() " Link "Free"} @{" isalloc() " Link "Isalloc"} @{" realloc() " Link "Realloc"}
@EndNode

@Node Getstack "Function Reference : getstack()"
   <max stack> = GETSTACK( )


This function shows the maximum stack usage for the last task monitored
with the @{" stack " Link "pv:docs/CommandRef.guide/Stack"} command.


Related commands: @{" stack " Link "pv:docs/CommandRef.guide/Stack"}
@EndNode

@Node Getx "Function Reference : getx()"
   <current x position> = GETX( )


Get the current x coordinate on the current logical window (in columns).


Related commands: @{" locate " Link "pv:docs/CommandRef.guide/Locate"} @{" home " Link "pv:docs/CommandRef.guide/Home"} @{" cls " Link "pv:docs/CommandRef.guide/Cls"} @{" current " Link "pv:docs/CommandRef.guide/Current"}

Related functions: @{" gety() " Link "Gety"} @{" getcols() " Link "Getcols"} @{" getrows() " Link "Getrows"} @{" cols() " Link "Cols"} @{" lines() " Link "Lines"}
                   @{" getlwin() " Link "Getlwin"} @{" getchar() " Link "Getchar"}

Related lists: @{" lwin " Link "pv:docs/Lists.guide/Lwin"}

Related tutor chapters: @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
@EndNode

@Node Gety "Function Reference : gety()"
   <current y position> = GETY( )


Get the current y coordinate on the current logical window (in lines).


Related commands: @{" locate " Link "pv:docs/CommandRef.guide/Locate"} @{" home " Link "pv:docs/CommandRef.guide/Home"} @{" cls " Link "pv:docs/CommandRef.guide/Cls"} @{" current " Link "pv:docs/CommandRef.guide/Current"}

Related functions: @{" getx() " Link "Getx"} @{" getcols() " Link "Getcols"} @{" getrows() " Link "Getrows"} @{" cols() " Link "Cols"} @{" lines() " Link "Lines"}
                   @{" getlwin() " Link "Getlwin"} @{" getchar() " Link "Getchar"}

Related lists: @{" lwin " Link "pv:docs/Lists.guide/Lwin"}

Related tutor chapters: @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
@EndNode

@Node If "Function Reference : if()"
   <result> = IF( <condition>,<expression 1>,<expression 2> )


If <condition> is true, evaluate <expression 1>, else evaluate
<expression 2>.


Example :

< d if(1,2,3) <enter>
> 00000002 , 2

< d if(0,2,3) <enter>
> 00000003 , 3

< a=1 <enter>
< b=2 <enter>
< c=3 <enter>
< d=4 <enter>
< e=5 <enter>
< d if(a,if(b,c,d),e) <enter>
> 00000003 , 3

< void if(a==1,{help functions},{help commands}) <enter>
> ...


Related commands: @{" disp " Link "pv:docs/CommandRef.guide/Disp"} @{" void " Link "pv:docs/CommandRef.guide/Void"}

Related functions: @{" eval() " Link "Eval"}

Related tutor chapters: @{" Expressions " Link "pv:docs/Expressions.guide/Main"}
@EndNode

@Node Isalloc "Function Reference : isalloc()"
   <pointer to pointer> = ISALLOC( <pointer> )


This function checks if <pointer> points to a memoryblock allocated
with the @{" alloc() " Link "Alloc"} function. If it is, 'isalloc' returns a pointer to
the pointer, otherwise 0.


Related commands: @{" cleanup " Link "pv:docs/CommandRef.guide/Cleanup"} @{" showalloc " Link "pv:docs/CommandRef.guide/Showalloc"}

Related functions: @{" alloc() " Link "Alloc"} @{" free() " Link "Free"} @{" realloc() " Link "Realloc"} @{" getsize() " Link "Getsize"}
@EndNode

@Node Isbreak "Function Reference : isbreak()"
   <result> = ISBREAK( <address> )


Test if there is a breakpoint in the current debug task on <address>.
If true this function returns the breakpoint number and the
breakpoint type in one longword, else it returns 0.

   <result> has the following format :

      NNNNTTTT

   with NNNN a word containing the breakpoint number
   and TTTT containing the breakpoint type

   The following types are supported :
      'T'   temporary breakpoint
      'N'   normal breakpoint
      'P'   profile breakpoint
      'C'   conditional breakpoint
      'A'   after breakpoint (timeout)
      's'   breakpoint used to skip a BSR or JSR (private breakpoint)


Related commands: @{" debug " Link "pv:docs/CommandRef.guide/Debug"} @{" break " Link "pv:docs/CommandRef.guide/Break"} @{" trace " Link "pv:docs/CommandRef.guide/Trace"}

Related functions: @{" getdebug() " Link "Getdebug"} @{" toppc() " Link "Toppc"} @{" botpc() " Link "Botpc"}

Related lists: @{" dbug " Link "pv:docs/Lists.guide/Dbug"}

Related tutor chapters: @{" Debugging " Link "pv:docs/Debug.guide/Main"}
@EndNode

@Node Key "Function Reference : key()"
   <vanillakey> = KEY( )


Wait for a key and return the ascii value.
This is especially useful in scripts.


Related commands: @{" scan " Link "pv:docs/CommandRef.guide/Scan"} @{" request " Link "pv:docs/CommandRef.guide/Request"}

Related functions: @{" qual() " Link "Qual"}
@EndNode

@Node Lastbytes "Function Reference : lastbytes()"
   <last number of bytes> = LASTBYTES( )


This function returns the last number of bytes used by @{" memory " Link "pv:docs/CommandRef.guide/Memory"} or @{" view " Link "pv:docs/CommandRef.guide/View"}
(320 by default).


Related commands: @{" memory " Link "pv:docs/CommandRef.guide/Memory"} @{" view " Link "pv:docs/CommandRef.guide/View"}

Related functions: @{" lastmem() " Link "Lastmem"} @{" lastlines() " Link "Lastlines"}

Related tutor chapters: @{" Looking at things " Link "pv:docs/LookingAtThings.guide/Main"}
@EndNode

@Node Lastfound "Function Reference : lastfound()"
   <last found> = LASTFOUND( )


This function returns the address of the second byte of the string found
with @{" search " Link "pv:docs/CommandRef.guide/Search"} or @{" next " Link "pv:docs/CommandRef.guide/Next"}. This is the address where 'next' will continue
with the search.


Related commands: @{" search " Link "pv:docs/CommandRef.guide/Search"} @{" next " Link "pv:docs/CommandRef.guide/Next"}

Related functions: @{" lastmem() " Link "Lastmem"}
@EndNode

@Node Lastlines "Function Reference : lastlines()"
   <last number of lines> = LASTLINES( )


This function returns the last number of lines used by @{" unasm " Link "pv:docs/CommandRef.guide/Unasm"}
(20 by default).


Related commands: @{" unasm " Link "pv:docs/CommandRef.guide/Unasm"}

Related functions: @{" lastmem() " Link "Lastmem"} @{" lastbytes() " Link "Lastbytes"}

Related tutor chapters: @{" Looking at things " Link "pv:docs/LookingAtThings.guide/Main"}
@EndNode

@Node Lastmem "Function Reference : lastmem()"
   <memory> = LASTMEM( )


This function returns the address that @{" memory " Link "pv:docs/CommandRef.guide/Memory"}, @{" view " Link "pv:docs/CommandRef.guide/View"} and @{" unasm " Link "pv:docs/CommandRef.guide/Unasm"} will
use to continue their listing.


Related commands: @{" memory " Link "pv:docs/CommandRef.guide/Memory"} @{" view " Link "pv:docs/CommandRef.guide/View"} @{" unasm " Link "pv:docs/CommandRef.guide/Unasm"}

Related functions: @{" lastfound() " Link "Lastfound"} @{" lastbytes() " Link "Lastbytes"} @{" lastlines() " Link "Lastlines"}

Related tutor chapters: @{" Looking at things " Link "pv:docs/LookingAtThings.guide/Main"}
@EndNode

@Node Lines "Function Reference : lines()"
   <lines> = LINES( <logwin> )


This function returns the maximum number of lines available on the
logical window.

'lines' uses autodefault to the 'lwin' list for the first argument.


Example :

< disp lines(main) <enter>
> 00000033 , 51


Related commands: @{" colrow " Link "pv:docs/CommandRef.guide/Colrow"} @{" fit " Link "pv:docs/CommandRef.guide/Fit"}

Related functions: @{" cols() " Link "Cols"} @{" getcols() " Link "Getcols"} @{" getrows() " Link "Getrows"} @{" getlwin() " Link "Getlwin"} @{" getx() " Link "Getx"}
                   @{" gety() " Link "Gety"}

Related lists: @{" lwin " Link "pv:docs/Lists.guide/Lwin"}

Related tutor chapters: @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
@EndNode

@Node Peek "Function Reference : peek()"
   <value> = PEEK( <structure pointer>,<struct def pointer>,<field name> )


Returns the value of <structure>.<field name>. <struct def pointer>
must be a pointer to a previously loaded structure definition. <structure
pointer> is the pointer to the structure itself. <field name> must be
defined in the structure definition.

'peek' uses autodefault to the 'stru' list for the second argument.


Related commands: @{" addstruct " Link "pv:docs/CommandRef.guide/Addstruct"} @{" interprete " Link "pv:docs/CommandRef.guide/Interprete"}

Related functions: @{" apeek() " Link "Apeek"} @{" stsize() " Link "Stsize"}

Related lists: @{" stru " Link "pv:docs/Lists.guide/Stru"}

Related tutor chapters: @{" Looking at things " Link "pv:docs/LookingAtThings.guide/Main"}
@EndNode

@Node Qual "Function Reference : qual()"
   <qualifier> = QUAL( )


Return the qualifier for the last pressed key (with @{" key() " Link "Key"}).


Example :

< a=key() <enter>
< disp qual() <enter>


Related commands: @{" scan " Link "pv:docs/CommandRef.guide/Scan"}

Related functions: @{" key() " Link "Key"}
@EndNode

@Node Realloc "Function Reference : realloc()"
   <new pointer> = REALLOC( <memoryblock>,<new size> )


Use this function to reallocate a memoryblock allocated with the
@{" alloc() " Link "Alloc"} function. Only memoryblocks smaller than 64K are supported.


Related commands: @{" cleanup " Link "pv:docs/CommandRef.guide/Cleanup"} @{" showalloc " Link "pv:docs/CommandRef.guide/Showalloc"}

Related functions: @{" alloc() " Link "Alloc"} @{" free() " Link "Free"} @{" getsize() " Link "Getsize"} @{" isalloc() " Link "Isalloc"}
@EndNode

@Node Rfrate "Function Reference : rfrate()"
   <refresh rate> = RFRATE( )


Return the current refresh rate installed with the @{" refresh " Link "pv:docs/CommandRef.guide/Refresh"} command.


Related commands: @{" refresh " Link "pv:docs/CommandRef.guide/Refresh"} @{" rwin " Link "pv:docs/CommandRef.guide/Rwin"}

Related functions: @{" rfcmd() " Link "Rfcmd"}
@EndNode

@Node Rfcmd "Function Reference : rfcmd()"
   <pointer to refresh command> = RFCMD( )


Return a pointer to the current refresh command (or 0).
This function returns a string if used from ARexx.


Related commands: @{" refresh " Link "pv:docs/CommandRef.guide/Refresh"} @{" rwin " Link "pv:docs/CommandRef.guide/Rwin"}

Related functions: @{" rfrate() " Link "Rfrate"}
@EndNode

@Node Stsize "Function Reference : stsize()"
   <size> = STSIZE( <struct def pointer> )


Return the size of the structure represented by <struct def pointer>.
<struct def pointer> must be a structure definition loaded
with @{" addstruct " Link "pv:docs/CommandRef.guide/Addstruct"}.

'stsize' uses autodefault to the 'stru' list for the first argument.


Related commands: @{" addstruct " Link "pv:docs/CommandRef.guide/Addstruct"} @{" interprete " Link "pv:docs/CommandRef.guide/Interprete"}

Related functions: @{" peek() " Link "Peek"} @{" apeek() " Link "Apeek"}

Related lists: @{" stru " Link "pv:docs/Lists.guide/Stru"}

Related tutor chapters: @{" Looking at things " Link "pv:docs/LookingAtThings.guide/Main"}
@EndNode

@Node Taglist "Function Reference : taglist()"
   <taglist> = TAGLIST( )


Return the current tag list. This is a number between 0 and 15.
You can change the current tag list with the @{" usetag " Link "pv:docs/CommandRef.guide/Usetag"} or @{" tg " Link "pv:docs/CommandRef.guide/Tg"} commands.


Related commands: @{" usetag " Link "pv:docs/CommandRef.guide/Usetag"} @{" tg " Link "pv:docs/CommandRef.guide/Tg"}

Related tutor chapters: @{" Looking at things " Link "pv:docs/LookingAtThings.guide/Main"}
@EndNode

@Node Toppc "Function Reference : toppc()"
   <programcounter> = TOPPC( )


This function returns the program counter visible at the top of the
'Debug' logical window.
You can set this program counter using the @{" dstart " Link "pv:docs/CommandRef.guide/Dstart"} or @{" dscroll " Link "pv:docs/CommandRef.guide/Dscroll"} commands.


Related commands: @{" debug " Link "pv:docs/CommandRef.guide/Debug"} @{" dwin " Link "pv:docs/CommandRef.guide/Dwin"} @{" dscroll " Link "pv:docs/CommandRef.guide/Dscroll"} @{" dstart " Link "pv:docs/CommandRef.guide/Dstart"}

Related functions: @{" botpc() " Link "Botpc"} @{" isbreak() " Link "Isbreak"} @{" getdebug() " Link "Getdebug"}

Related lists: @{" dbug " Link "pv:docs/Lists.guide/Dbug"}

Related tutor chapters: @{" Debugging " Link "pv:docs/Debug.guide/Main"}
@EndNode
