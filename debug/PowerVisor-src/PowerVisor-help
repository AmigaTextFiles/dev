@General commands
----------------
Help        : obvious                  Quit        : quit powervisor
Void        : do nothing               HOld        : hold powervisor
Disp        : display expression       Refresh     : control refresh rate
PRint       : print string             CLEANup     : deallocate pv-memory
VArs        : show all variables       SHowalloc   : show all pv-memory
REMVar      : remove variables         LOG         : log output
ATtach      : attach macro to key      TO          : log output from command
REMAttach   : remove command from key  APpendto    : log output from command
SCAn        : ask input from user      SAVEConfig  : save config file
GEtstring   : ask input from user      PREfs       : set powervisor prefs
REQSave     : save file requester      MOde        : set preferences
REQLoad     : load file requester      ERror       : get error string
REQuest     : requester                ALias       : set an alias
LEd         : toggle powerled          UNALias     : remove an alias
WHile       : repeat command

Screen commands
---------------
CLs         : clear logical window     SCREen      : move pv to screen
LOCAte      : location in logical win  SIze        : size physical window
HOMe        : go to top location       MOVe        : move physical window
COLRow      : set logical size         SETfont     : set logical window font
FIT         : fit logical window       Xwin        : open/close Extra window
Active      : make logwin active       RWin        : open/close Refresh window
CURRent     : set current logical win  DWin        : open/close Debug window
ON          : on logical window do     AWin        : open/close Rexx window
COLor       : set rgb value for pv     OWin        : open/close PPrint window
CLOSELw     : close logical window     SWin        : open/close Source window
CLOSEPw     : close physical window    WWin        : open/close Watch window
SETFLags    : set logwin flags         OPENLw      : open logical window
SCROll      : scroll logical window    OPENPw      : open physical window

Memory commands
---------------
Search      : search string            Copy        : copy memory
Next        : continue searching       Fill        : fill memory with string
CLEar       : clear unused memory

Special commands
----------------
ACCount     : task usage, stack check  STAck       : check stack usage
Kill        : cancel a task            PROF        : control profiler
FReeze      : freeze a task            REMRes      : remove resident
UNFreeze    : unfreeze a task          REMHand     : remove input handler
TASKPri     : set task priority        REMCrash    : remove a crash node
OWNer       : show owner of memory     REMOve      : remove a node
CLOsewindow : close a window           UNLOCk      : unlock
CLOSEScreen : close a screen           PAthname    : show pathname for lock
ADdfunc     : add function to monitor  CUrdir      : set current dir
REMfunc     : remove function          LOADFd      : load an fd-file
RBlock      : read a block from disk   UNLoadfd    : unload fd-file
WBlock      : write a block to disk    LOAd        : load a file
Opendev     : open device              SAve        : save a file
CLOSEDev    : close device             SPEEk       : peek supervisor
DEVInfo     : device information       SPOke       : poke supervisor
DEVCmd      : give device command      MMURESet    : reset MMU usage
FOR         : for each element in list MMUWatch    : memory protection system
SPRint      : print on serial terminal PROtect     : protect memory
TRACK       : resource tracking        TAGType     : tag list protection type
CRAsh       : patch tasks in system    GO          : jump to memory
PVcall      : call PowerVisor          EVent       : add an input event
PVMem       : show PV memory usage

Debug commands
--------------
DEBug       : control debugtasks       DScroll     : scroll debug window
SYmbol      : control symbol table     DSTart      : set debug window start
SOurce      : control source           DNexti      : scroll to next instr
DUse        : set debug program        DPrevi      : scroll to prev instr
WITh        : with debug node do       DRefresh    : refresh debug display
Break       : control breakpoints      TRace       : trace program
WAtch       : control watches

Information commands
--------------------
MMutree     : show mmu tree            LList       : traverse list
MMURegs     : show mmu registers       List        : list items
SPecregs    : show special registers   Info        : node information
DEVInfo     : device information       Memory      : list memory
LIBInfo     : show lib function info   VIew        : show memory
LIBFunc     : show lib function info   TAGs        : show tags
Gadgets     : list window gadgets      ADDTag      : add a tag
ADDStruct   : add structure defs       REMTag      : remove a tag
REMStruct   : remove structure def     CHecktag    : check address in tag
CLEARStruct : clear structure defs     LOADTags    : load tags from file
STRUCt      : make/manage structures   SAVETags    : save tags to file
INTErprete  : interprete structure     CLEARTags   : clear tags
REGs        : show registers of task   USetag      : set current tag list
FREGs       : show floating pt regs    TG          : temporarily set tag list
FLoat       : change floating pt reg   HUnks       : show hunks for process
Unasm       : unassemble memory        MEMTask     : show memory of a task

Script commands
---------------
SCRIpt      : start script             RESIdent    : make file resident
RX          : start rexx script        UNResident  : remove resident file

ARexx commands
--------------
SYNc        : synchronize pv to ARexx  HIde        : hide output
ASYnc       : undo SYNC command        UNHide      : undo HIDE command
FROnt       : pv screen to front       CLIp        : set/get clip
ASsign      : assign to var            REMCLip     : remove clip
STRIng      : return string

List commands (type 'help syslists' for info)
-------------
Exec  INTb  Task  LIBs  DEvs  RESO  MEMR  INTR  Port  Wins  ATTC  GRaf  COnf
SCrs  FOnt  DOsd  FUnc  SEMa  RESm  FILS  LOck  IHan  FDfi  CRsh  DBug  MONi
PUbs  STru  LWin  PWin
===
@PowerVisor help (1.43)    Wed Jul 27 08:38:57 1994
----------------------
You can type one of the following for more information on a specific
item:

      help                 for this screen
      help general         for general information

      help commands        for a list of all available commands
      help functions       for a list of all available functions
      help syslists        for a list of all available lists
      help <command>_cmd   gives help for a specific command
      help <command>_tmp   gives a command template (or <command> ?)
      help <function>_func gives help for a specific function
      help <list>_list     gives help for a specific list

      help arguments       gives help for all possible argument types
      help libfuncs        information about library functions
      help bugs            for all bugs in the current version
      help debugging       for general debugging help

You can use abbreviations ('h gen' instead of 'help general')
Note that you could get the wrong help when you do this.
('help li' will probably not give what you wanted: list, libfuncs, ...)

Note that if you have AmigaGuide or MultiView (© Commodore) it is better
that you use 'mhelp' for MultiView (or 'ahelp' for AmigaGuide) instead of
'help'. This gives a better online help environment.
===
@General functions
-----------------
ALLOC       : allocate memory          LASTMEM     : give last memory
FREE        : free memory              LASTBYTES   : last number of bytes
REALLOC     : reallocate memory        LASTLINES   : last number of lines
GETSIZE     : give size of memoryblock LASTFOUND   : last search address
ISALLOC     : is memory a pv-block ?   PEEK        : peek value in structure
KEY         : returns pressed key      APEEK       : peek address
QUAL        : qualifier for last key   STSIZE      : get structure size
GETCOL      : get logical col width    RFCMD       : refresh command
GETROW      : get logical row height   RFRATE      : refresh rate
TOPPC       : get debug win top pc     GETLWIN     : current logical window
BOTPC       : get debug win bottom pc  GETACTIVE   : ask active logwin
ISBREAK     : check if breakpoint      TAGLIST     : get current tag list
GETSYMSTR   : get symbol str pointer   EVAL        : evaluate argument string
GETDEBUG    : get current debug ptr    IF          : conditional evaluation
GETX        : get the current x coord  CURLIST     : current list
GETY        : get y coord              COLS        : get max nr of cols
GETCHAR     : get the current char     LINES       : get max nr lines
GETLINE     : get pointer to line      AREXXPORT   : get ARexx port name
GETERROR    : get error of routine     PUBSCREEN   : get public screen name
BASE        : get first listelem       GETMMUENTRY : get MMU entry address
GETSTACK    : get max stack usage      CHECKSUM    : compute range checksum
===
@Help arguments
--------------
There are two basic types for command arguments:

   - integers     : The command expects an integer
   - strings      : The command expects a string

Other help: integers strings expressions
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Help integers
-------------
The following are possible integers :


decimal integers:
      567, 1920003, ...
   Integers are 32 bits.

hexadecimal integers:
      034, $98f, $FA802, ...
   These start with a zero or a '$'

expressions:
      (5+5), 1+27*(1-2)

string pointers:
      "test", "test2 \10\F4\DD end\05", ...
   Please note that these strings only exist for a limited period. PowerVisor
   only remembers the 10 last strings and string pointers.
   If you want to use a string permanently, you must allocate memory for
   it, and copy the string to this place. (type 'help permstring' for an
   example)
   When evaluating a string you get a pointer to this string.
   For example "test"+2 points to 's'. A string pointer is in fact
   just another integer.

strings and names:
      a, var, exec, output(), ...
   There are four cases where you may use a string as an integer. Note
   that PowerVisor tries each of the following steps in turn, stopping
   at one step if it could find such an item. You can make use of the
   quotes, abbreviations and case sensitivity to force certain
   interpretations. There are also some operators to force interpretation.

      - The name is a variable or function
        (no quotes, case insensitive, no abbreviations)
            a
            error
            debug()
            input

      - The name is a library function you have loaded
        (quotes possible, case insensitive, no abbreviations)
            output()
            'TypeOfMem'(10000)
            'input'()

      - the name is a symbol for the current debug task
        (quotes possible, case sensitive, no abbreviations)
            __main
            '@XCEXIT'
            'input'

      - the name is an abbreviation for an element in the current list
        (quotes possible, case insensitive, abbreviations possible)
            trackdisk
            'trackdisk.dev'
            'input'

   When you use a string as an integer, PowerVisor will first check if
   it is a variable. If it is not a variable it will check if it is
   a library function (loaded in one of the fd-files). If that is not the
   case PowerVisor will check if the name is a symbol for the current
   debug task. If that is not the case it will check if it is an
   abbreviation for an element in the current list.
   If you use single quotes for the name, PowerVisor will skip the
   variable testing and only test if it is a library function, symbol or
   a list element. If you use the ':' operator in front of the name,
   PowerVisor will only test if it is a list element.

   The 'input' string used above is a good example. 'input' is a built
   in PowerVisor variable that is always present. This means that if
   you use 'input' without quotes you will get the contents of this
   variable (the first example). If you use quotes, PowerVisor will
   skip the variable testing. If you have a loaded debug task with
   a symbol named 'input' PowerVisor will return the value of this
   symbol (the third example). If you don't have such a symbol
   PowerVisor will search the current list for the name. In the case
   of the 'task' list the will probably be the 'input.device' (the last
   example). If you also use brackets after the quoted 'input',
   PowerVisor will execute it as a library function (if you have loaded
   the dos.library fd-file).

   So, if you want the contents of a variable or PowerVisor function you
   must use the variable name without quotes. In all other cases you must
   only use quotes when there is a name conflict with a variable. Note
   that in the case of an element in the current list you can use another
   abbreviation to circumvent the name conflict problem.


You can mix all these integers whenever you want and for each command
that wants an integer as an argument. You can use them in expressions

Other help: expressions syslists libfuncs permstring strings list_op
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯
===
@Help strings
------------
A string is not the same as a string pointer. A string pointer is in fact
an integer. A string can also be an integer. This interpretation depends
on the command. Strings and names can be mixed.

You can use all characters in a string when you enclose the string in
quotes (single or double). Otherwise you are limited to alphanumeric
characters and the underscore.

You can in any case use the quote operator ('\') (even if you use
no quotes) in four ways.
   - When followed by 2 hexadecimal digits, the
     operator is replaced by the character represented by the two
     hexadecimal digits.
     Note that the following four ascii characters have a special meaning
     in PowerVisor:
         \01 normal attributes for this line. The occurence of this
             character in an output string causes the current line to have
             the normal attributes (colours)
         \02 hilight the current line. The occurence of this character
             in an output string causes the hilighting of the current line
         \03 inverse video for the current line. The occurence of this
             character in an output string causes the current line to be
             output in reverse video. Note that inverse video and hilight
             are the same if the PowerVisor screen is only one bitplane
             (nofancy mode)
         \04 hilight and inverse video together. If the PowerVisor screen
             is only one bitplane these two cancel each other, so this
             will be equivalent to \01
   - \n is equivalent to \0a or newline.
   - When followed by a left bracket '(', the character representation of
     the following expression is put in the string. After the expression
     you can close with the right bracket ')' or you can use an optional
     format string (C-style) to format the number. Using this format string
     you can even interprete the number as a character or a string.
   - When followed by another character, the character is simply copied.
     This is useful to include quotes and the quote operator in strings.

   'string'          is a string
   string            is a name
   "string pointer"  is a string pointer but can be used as a string when
                     the command expects a string
   'test\20hello'    is equal to 'test hello'
   'test\\hello'     is equal to 'test\hello'
   'test\'hello'     is equal to 'test'hello'
   'test\"hello'     is equal to 'test"hello'
   test\'            is equal to 'test'' (note that you don't need the
                     quotes)
   'Test\(3+4)hello' is equal to 'test7hello'
   '\(65,%lc)'       is equal to 'A'
   5+6               is also a string if the command expects a string

You can use the \(<number>,%s) operator if you want an integer to behave
like a string.
For example, when p points to a region of memory containing the string
'exec'. Then the command 'list \(p,%s)' will list the execbase.
You cannot only use the '\' operator if the command really expects a string.
'disp \(p,%s)' is illegal.

Other help: integers list syslists quote_op strongquote_op
            ¯¯¯¯¯¯¯¯ ¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯
===
@Help expressions
----------------
PowerVisor has a very powerfull expression evaluator. If you know C you will
probably notice the resemblance. The same priorities as used in C are used
in PowerVisor.

You can use the following binary operators. The list is from high to
low priority :

   * / %             multiply, integer divide, remainder
   + -               add, subtract
   << >>             left shift, right shift
   > < >= <=         integer comparisons
   != ==             not equal to, equal to
   &                 bitwise and
   ^                 bitwise xor
   |                 bitwise or
   &&                logical and
   ||                logical or
You can use the following unary operators:
   -                 negation
   !                 logical not
   ~                 bitwise not
   *                 contents operator
   @                 special operator (for debugging)
   #                 linenumber operator (for debugging)
   \                 quote operator (only for strings)
   :                 list operator
   &                 list address operator
And you can of course use brackets

Examples:
   1<<(6+4*(10/2))            is equal to 67108864 (or 1<<26)
   libs:'exec.library'+$10    is equal to the address of ExecBase plus 16
   *devs:audio.l              is equal to the contents of the first longword
                              pointed to at the start of the audio.device
                              node. (This is the next device node or ln_succ)
   output()                   is equal to the BPTR to your outputhandle
                              (you must have loaded dos functions to do
                              this)
   {disp 4}                   is equal to 4 ('disp' is executed)
   @d1                        is equal to the register d1 of the current
                              debug task

Note that you cannot use spaces in expressions. Spaces (and ',') are used
to separate expressions. If a command expects two arguments you can use a
space or a comma to seperate them.
When you are at the end of an expression, you need not close your brackets.
You MUST close the brackets when you want to terminate the argument list
for a library function or a normal function.

Other help: contents_op list_op special_op listaddr_op linenr_op
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
            disp_cmd debugging libfuncs integers strings variables
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
            group_op quote_op
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Help variables
--------------
PowerVisor has the capability to store an integer in a variable.
You can use variablenames of arbitrary length and as many variables as
you wish.
A variablename must start with a letter or an underscore. You can use digits
in the rest of the name.

Examples:
   a5=4
   a5=a5+1
   outputhandle=output()
   nc=write(outputhandle,"testing",7)
   _test_=00C02536

There are 6 reserved variables and constants:
   'mode'
      This variable contains the current mode settings. Changing this variable
      has more or less the same effect as using the 'mode' command
   'rc'
      This variable contains the returncode for some commands. You may use
      'rc' for your own purposes but you must remember that certain commands
      change this variable
   'version'
      The current PowerVisor version. You can not change this constant
      ($143 = 1.43)
   'error'
      The last error number
   'input'
      A pointer to the last input string entered with 'scan', 'getstring'
      'reqload' or 'reqsave'. You can't change this constant
   'pv'
      The number of the instance of PowerVisor (0 = master instance,
      1 = first slave instance, ...)

PowerVisor has four variable types.
   0 : normal variables, you can create these with the assignment operator.
   1 : constant variables, only PowerVisor can create these.
   2 : special variables, only PowerVisor can create these.
   3 : functions.

It is recommended that you use the following name convention for your
variables:
   single letter variables for temporary variables.
   multiple letter variables for more permanent uses.
   names starting with an underscore ('_') for internal script use.
This convention is especially useful in scripts. For example, you should
not use multiple letter variables in scripts except in special cases.
It is good programmer practice to always remove all used variables in
a script ('remvar').

Other help: assignment_op mode_cmd vars_cmd remvar_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Help assignment_op
------------------
The assignment operator is used to store an integer in a variable or in
memory.

Left from the assignment you can put a variable, a register or an
contents operator. The variable will be created if it does not
exist. In order to use register assignment you must have a current
debug task.

Examples:
   ad=alloc(n,100)            Allocate 100 bytes memory
   *ad=5                      Put long integer 5 at our newly allocated
                              memory
   *(ad+5).b=50*2             Put byte 100 at address ad+5
   *ad.w=*(ad+2).w            Copy the 2nd word to the first word
   @d1=4                      Assign 4 to register d1 of the current
                              debug task

Other help: variables libfuncs expressions debugging alloc_func
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Help contents_op
----------------
The contents operator is used to get the contents of an address.
You can also use this operator at the left side of an assignment.


Examples:
   *4       is the contents of address 4 as a long (this is execbase)
   *4.l     is the same
   *4.w     is the contents of address 4 as a word
   *4.b     is the contents of address 4 as a byte
   **4      is the contents of the contents of address 4 (both as long)
   *5       will give an odd address error (you will not crash)

Other help: expressions
            ¯¯¯¯¯¯¯¯¯¯¯
===
@Help list_op
------------
The list operator is used to address an element of a specific list.

Examples:
   libs:exec         is the pointer to exec library
   li:ex             is probably the same (unless you have another library
                     beginning with 'ex')
   task:'trackdisk.device'
                     is a pointer to the trackdisk device
   task:'trackdisk.d'
                     is probably the same
   :input            will give the pointer to the input.device if the
                     current list is the task list

When 'libs' is the current list (for example) you can also type the
following to obtain the pointer to the exec library.
   exec or 'exec.library'

Some command use the 'autodefault' feature.

When you want to be absolutely sure that the string evaluates to a
list element and not to a variable or such, you can use the ':' operator
without a preceding list name.
   :'trackdisk.device'

Other help: syslists expressions strings listaddr_op autodefault
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Help listaddr_op
----------------
The list address operator is used to obtain the address of an element
in a list. This list must be the execbase, grafbase or intuitionbase list.
This operator is provided as a clumsy interface to change something to
a variable in one of the library bases. In future this interface may
be cleaner.

Examples:
   &exec:vblankfreq  is the pointer to the VBlankFrequency variable in
                     the exec library
   &e:Quantum        is the pointer to the Quantum variable in the exec
                     library

Example:
   *&e:quantum.w=20  will change the quantum variable to 20.

Other help: syslists expressions strings list_op assignment contents_op
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Help libfuncs
-------------
PowerVisor gives you the ability to execute library functions.
Therefore you must first load the fd-file for the library you want to
call.

Example:
   output()       calls the dos function output (no arguments)
   'input'()      calls the dos function input. The quotes are needed
                  because there is a builtin 'input' variable in
                  PowerVisor
   write(output(),"test",4)
                  writes the string 'test' to the current output.
   a=allocmem(1000,1<<16)
                  allocates memory and put the address in the variable 'a'
   ib=openlibrary("intuition.library",0)
                  opens the intuition library

The order in which the arguments appear are the same as in C (or as specified
in the fd-file).

You must use the notation described above as an argument for a command
(because it is an expression). If you are not interrested in the result of a
library function you still have to preceed it with a command. Simply use the
'disp' command.

Example:
   disp output()

If you don't want to load the fd-file you can call library functions with:
   offs lib:exec -30 ()
You can not use arguments when using this notation

Other help: loadfd_cmd disp_cmd expressions
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Example permstring
------------------
When you use a string pointer ('"'<bytes>'"'), this string only exists during
the lifetime of the current command. This could cause problems.

Example:
   if you use

      void setwindowtitles(win:'test window',"window title",0)

   to set the window title for 'test window' it will work at first.
   But when you use another string at a later time you will notice that
   your window will get another title (mostly rubbish).
   To prevent this from happening you must allocate some memory for
   this string.

   You can do this is as follows:
      loadfd intuition fd:intuition_lib.fd
      ad=alloc(s,'window title')
      void setwindowtitles(win:'test window',ad,0)
      ...
   Later you can free this title with:
      void free(ad)

Other help: loadfd_cmd alloc_func void_cmd variables libfuncs strings
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯
===
@Help quote_op
-------------
To include integers, characters and strings in a string you can use
the quote operator.

\<x><x> is equal to a character. <x> is one hexadecimal digit

\(<expression>) is equal to the string representing the result of
                the expression

\(<expression>,<format>) is equal to the string representing the
                result of the expression formatted by <format>
                <format> is a C-style formatting string

\n is equal to newline

\01 normal attributes for this line. The occurence of this character in an
    output string causes the current line to have the normal attributes
    (colours)

\02 hilight the current line. The occurence of this character in an output
    string causes the hilighting of the current line

\03 inverse video for the current line. The occurence of this character in
    an output string causes the current line to be output in inverse video.
    Note that inverse video and hilight are the same if the PowerVisor
    screen is only one bitplane (nofancy mode)

\04 hilight and inverse video together. If the PowerVisor screen is only
    one bitplane these two cancel each other so this will be equivalent to
    \01

\<other char> is equal to <other char>


Example:

   test\0a\\\'          is equal to test<newline>\'
   test\n\\\'           is equal to test<newline>\'
   test\(5+6)hello      is equal to test11hello
   test\(65,%lc)hello   is equal to testAhello
   test\41hello         is equal to testAhello
   test\("hello",%s)    is equal to testhello
   test\(6+7,%03ld)     is equal to test013

Other help: strings strongquote_op
            ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯
===
@Help strongquote_op
-------------------
In some rare cases it is possible that you want to quote a lot of
characters without having to worry about anything at all. This is
(almost) possible with the strong quote (· = <alt>+8).

The character directly after the strong quote is the character
used to recognize the end of the strong quote operator.

·<char> All chars of all different kinds <char>

The only character you can't use is the one needed to close the
strong quote operator (<char>).


Example:

   Test·/ ('){}])' ((''\\\\'(/TheEnd

      is equal to

   Test( ('){}])' ((''\\\\'(TheEnd

Other help: strings quote_op
            ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Help syslists
-------------
PowerVisor uses lists to give the user the possibility to examine system
information.
The following lists are available:

   Exec        the listing of the ExecBase structure (no list operator
               possible)
   Intb        IntuitionBase structure (no list op possible)
   Graf        Graphics base structure (no list op possible)
   Task        The listing of the tasks in the system (default list)
   Libs        Libraries
   Devs        Exec-devices
   Reso        Resources
   Memr        Memory list
   INTR        Interrupts
   Port        Message ports
   Wins        All windows
   Scrs        Screens
   Font        Fonts currently in memory
   DOsd        Dos-devices
   FUnc        Function monitor nodes (see 'addfunc_cmd')
   SEma        Semaphores
   RESM        Resident modules
   FIls        Open files
   LOck        Locks
   IHan        Input handlers
   FDfi        All fdfiles loaded (see 'loadfd_cmd')
   Attc        All attached keys (see 'attach_cmd')
   Crsh        All crashed programs (see 'crash')
   DBug        All debug nodes (see 'debugging')
   STru        All structure defines (see 'addstruct')
   COnf        AutoConfigs
   MOni        Monitors (DOS 2.0 only)
   PUbs        Public Screens (DOS 2.0 only)
   LWin        All logical windows for PowerVisor
   PWin        All physical windows for PowerVisor

You can see in which list you are by examining your prompt.
You can change your current list by typing the new listname.
If you use 'mode autolist' you will get a list when you change the
current list.

Type 'help <list>_list' for specific help on each list.

Other help: libfuncs attach_cmd crash mode_cmd debugging list_op
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯
            addfunc_cmd loadfd_cmd <list>_list info_cmd addstruct_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: pvmem_cmd
------------------

   PVMem


This command gives some information about the internal memory management
system. This is only useful if you are debugging PowerVisor (there are not
so many people doing this :-)


Other help: pvcall_cmd
            ¯¯¯¯¯¯¯¯¯¯
===
@Command: pvcall_cmd
-------------------

   <result> <- PVcall <number> [<arguments>]


Call internal PowerVisor functions. This command is only useful for the
very experienced PowerVisor user. See the 'The Wizard Corner' chapter for
more info.

   number name
   -----------------------
   0      CreateFunction (<name>,<address of routine>)
   1      Error (<error number>)
   2      AdvanceHistory ()
   3      LowerHistory ()
   4      GetHistoryLine ()
   5      RefreshStringG ()
   6      InstallPreCmd (<commandstring>)
   7*     Evaluate (<a0 = pointer to expression>)
   8      RemVar (<name>)
   9*     ParseString (<a0 = commandline>)
   10     CopyString (<string>)
   11     AddStringToHist (<string>)
   12     GetStringGBuf ()
   13     AppendString (<string>)
   14     SkipSpaces (<string>)
   15     SetCursorPos (<position>)
   16     InstallPostCmd (<commandstring>)
   17     SetDebugMode (<debug number>)
   18     GetExecLevel ()
   19     OBSOLETE
   20     GetStringInfo ()
   21     GetSnapBuffer ()
   22     InstallSnapCmd (<commandstring>)
   23     OBSOLETE
   24     Beep (<period>,<time>)
   25     GetVarAddress (<variable name>)
   26     OBSOLETE
   27     CreateConstant (<name>,<value>)
   28     CompareStrings (<pointer string 1>,<pointer string 2>,<len>)
   29     CallMLScript (<pointer>)
   30     GetEvalBase ()
   31     GetARexxBase ()
   32     GetDebugBase ()
   33     GetFileBase ()
   34     GetGeneralBase ()
   35     GetListBase ()
   36     GetMainBase ()
   37     GetRoutines ()
   38     GetModeRoutines ()
   39     GetRexxList ()
   40     GetScreenBase ()
   41     GetMemoryBase ()
   42     OBSOLETE
   43     GetStringGadget ()
   44     OBSOLETE
   45     OBSOLETE
   46*    ErrorHandler (<a5 = pointer to routine>)
   47     InstallQuitCmd (<commandstring>)
   48     ConvertAlias (<string>)
   49*    AddAutoClear (<d0 = pointer>)
   50*    AllocPVBlock (<d0 = size>)
   51*    FreePVBlock (<a0 = pointer>)
   52     ComputeGadgetSignal ()
   53*    Print (<a0 = pointer to string>,<d3 = length>)
   54*    PrintNum (<d0 = number>)
   55*    AddGlobalAutoClear (<d0 = pointer to PV block>)
   56*    RemoveGlobalAutoClear (<a0 = pointer to PV block>)
   57*    ClosePVHandle (<d1 = pointer to PV handle>)
   58*    ReAllocPVMemoryBlock (<a0 = PV memory block>,<new size>)
   59     OBSOLETE
   60     OBSOLETE
   61*    RefreshLogWin (<a0 = pointer to logical window>)
   62*    SnapWord (<a0 = logwin>,<d0 = x>,<d1 = y>,<a1 = buffer>,<d2 = len>)
   63*    Disassemble (<a0 = string space>,<d0 = address>,<a6 = lib pointer>)
   64     CmdDisassemble (<string pointer>,<address>,<library pointer>)
   65     OBSOLETE
   66*    AllocMem (<d0 = size>,<d1 = attr>)
   67*    FreeMem (<a1 = ptr>,<d0 = size>)
   68*    ReAlloc (<a1 = ptr>,<d0 = old size>,<d1 = new size>,<d2 = attr>)


Other help: pvmem_cmd
            ¯¯¯¯¯¯¯¯¯
===
@Command: prefs_cmd
------------------

   PREfs ('history' | 'key' | 'screen' | 'stack' | 'logwin' | 'linelen' |
         'debug' | 'dmode' | 'pens' | 'font') [<arguments> ...]


You can set/get preferences with this command. <prefname> is one of
(followed by the specific argument template) :

   - history [<history value>]
   - key <key number> [<code> <qualifier>]
         0 = interrupt key
         1 = hot key
         2 = pause key
         3 = cycle active logwin
         4 = history up
         5 = history down
   - screen [<w> <h>]
   - stack [<stack fail level>]
   - logwin <full standard logwin name> [<cols> <rows> <mask> <flags>]
         supported logwins :
            Main,Extra,Refresh,Debug,Rexx,PPrint
         bits in flag :
            4   = -MORE- enabled
            32  = real-top
            64  = statusline off
            128 = interrupt off
            256 = auto snap to output
            512  = (if false) add scrollbar depending on 'mode sbar'
            1024 = always add scrollbar (if true ignore previous flag)
   - linelen [<line length>]
   - debug [<instructions> <show previous instruction>]
   - dmode 'n'|'r'|'c'|'f'
   - pens [<pen offset number> <pen color>]
   - font [<font name> <font size> <style> <flags>]

All parameters set with this command can be saved with the 'saveconfig'
command.

Other help: saveconfig_cmd mode_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: event_cmd
------------------

   EVent <class> <subclass> <code> <qualifier> <x> <y>


Send an input event to the input device. This is useful in macros.

Other help: attach_cmd
            ¯¯¯¯¯¯¯¯¯¯
===
@Command: owner_cmd
------------------

   OWNer <address>


This command tries to see who is the owner of the address you specify.
This command is not completely ready but it is safe to use.
===
@Command: speek_cmd   (only 68020 with 68851, 68030 or 68040)
------------------

   <value> <- SPEEk <address>


Peek a longword from memory. <address> is a PHYSICAL address. The MMU tree
is completely ignored.

Other help: mmutree_cmd spoke_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: saveconfig_cmd
-----------------------

   SAVEConfig


Save the current 'mode' and 'prefs' settings to the file s:PowerVisor-config.
They will automatically be loaded when you start PowerVisor.

Other help: mode_cmd prefs_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: spoke_cmd   (only 68020 with 68851, 68030 or 68040)
------------------

   SPOke <address> <value>


Poke a longword in memory. <address> is a PHYSICAL address. The MMU tree
is completely ignored.

Other help: mmutree_cmd speek_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: mmuwatch_cmd   (only 68020 with 68851 or 68030)
---------------------

   MMUWatch


Start the MMU memory protection system. This command installs a new
MMU tree so that you can later protect regions of memory with the 'protect'
command. It also moves the VBR to a safer position. At this moment this
command is not compatible with the 68040.

This command also installs a keyboard reset handler. When you reset your
Amiga, this handler will clean up the MMU tree so that you will have a
clean reset. Note that this reset handler feature does not work on Amiga
500's and on most Amiga 1000's. But these computers seldom have a MMU
so this should not be a big problem.

When you use 'mmuwatch' a second time, the MMU protection system is removed.
This command is a toggle.


Other help: mmutree_cmd protect_cmd getmmuentry_func addtag_cmd tagtype_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Command: protect_cmd   (only 68020 with 68851 or 68030)
--------------------

   PROtect


Only use this command when you have installed the memory protection system
with the 'mmuwatch' command. This command protects some memory ranges for
read or write access. This command uses all the tag lists to see which
regions should be protected. You can use the 'tagtype' command to
specify how each tag list should be used. Tag list 0 is always used for
global protection (for each task). The other tag lists can be used to
protect regions for one task only.

Note that the protections for a specific task override the global
protections. If there is no specification for a certain region for a
specific task, the global definition is used (thus the order is: first
check for specific task regions, after that check for global regions).
Also see the 'i' option with the 'addtag' command. With this option you
can cancel the global protection for a specific task.

Use the 'addtag' command to add some protected regions to the tag lists
and use 'protect' after that to update the MMU tree. Note that you can
use the 'tg' command to temporarily set another current tag list (there
are 16 tag lists).

Note that you have to use the 'protect' command again everytime you
change something to one of the tag lists or when you have changed the
protection usage of the tag lists with 'tagtype'.


Other help: mmutree_cmd mmuwatch_cmd getmmuentry_func addtag_cmd tagtype_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
            tg_cmd tagtype_cmd
            ¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Command: tagtype_cmd   (only 68020 with 68851 or 68030)
--------------------

   TAGType [<tag list number> [<task>]]


Use this command (before you use the 'protect' command) to specify the
use of each tag list in the memory protection system. By default only
tag list 0 is defined as the tag list for global protection. If you only
need global protection, you don't need this command.

Without arguments, this command lists all tag lists that have something to
do with memory protection.

With only the <tag list number> (1 to 15 because you can't change the
usage of tag list 0) you clear the memory protection usage for that
tag list. This means that all regions in that tag list are ignored
by the memory protection system.

If you also specify <task> all regions in that tag list will be used for
memory protection specific to that task. Note that specific memory
protection has precedence above global protection but if a region does
not occur in a task-specific tag list, the global protection tag list
(tag list 0) will be used. All protection parameters in a specific tag
list override the global parameters. You can also use the 'i' option
with the 'addtag' command to cancel global protection for a task.

Note that changing something with this command (and also the 'addtag'
command) requires that you run 'protect' again to update the MMU tree.

'tagtype' uses autodefault to the 'task' list for the <task> argument.


Other help: mmutree_cmd mmuwatch_cmd getmmuentry_func addtag_cmd tagtype_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
            tg_cmd protect_cmd
            ¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Function: getmmuentry_func   (only 68020 with 68851 or 68030)
--------------------------

   GETMMUENTRY( <address> )


This function returns the address of the MMU entry used to describe
the given address. It returns 0 if the address is not in the MMU tree
or if the MMU is not used.


Other help: mmutree_cmd mmuwatch_cmd protect_cmd addtag_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: mmutree_cmd   (only 68020 with 68851 or 68030 or 68040)
--------------------

   MMutree


This command shows the current MMU tree (CRP only).

FC code trees are not implemented yet.
8 byte format pages are not implemented yet.
indirect pages are not implemented yet.

Other help: mmuregs_cmd specregs_cmd mmureset_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: mmureset_cmd   (only 68020 with 68851 or 68030 or 68040)
---------------------

   MMURESet


This command resets all U and M flags in the MMU tree to false.

Other help: mmutree_cmd mmuregs_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Command: mmuregs_cmd   (only 68020 with 68851 or 68030 or 68040)
--------------------

   MMURegs


Show all special mmu registers (except MMUSR).

Other help: mmutree_cmd specregs_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: openlw_cmd
-------------------

   RC,<lwin> <- OPENLw <physical window> <logwin name> <cols> <rows>
                [<brother> <where> [<number of columns or lines>]]


Open a logical window on a physical window. If the physical window is empty
you need not specify the two last arguments. Otherwise <brother> is the
logical window which will be your brother and <where> specifies where
our new logical window should appear relative to the <brother>.
The <where> string can be like :

   u     above brother
   d     below brother
   r     right from brother
   l     left from brother
   pd    take parent from brother and appear below this box
   pppr  take parent from parent from parent and appear right from this box
   ...

If <number of columns or lines> is specified it is used as the number
of lines or columns for the new logical window (<number of columns or
lines> is interpreted as <number of columns> if the new window is positioned
left or right of <brother>, otherwise <number of columns or lines>
is interpreted as <number of lines>).


Other help: closelw_cmd openpw_cmd closepw_cmd lwin_list pwin_list
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: openpw_cmd
-------------------

   RC,<pwin> <- OPENPw <physical window name> <x> <y> <w> <y>


Open a physical window. It will be empty (no logical windows).

Other help: closelw_cmd openlw_cmd closepw_cmd lwin_list pwin_list
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: closepw_cmd
--------------------

   CLOSEPw <physical window>


Close a physical window. All logical windows on this physical window
are automatically removed.
You can't remove the 'Main' physical window.

Other help: closelw_cmd openlw_cmd openpw_cmd lwin_list pwin_list
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: closelw_cmd
--------------------

   CLOSELw <logical window>


Close a logical window.
You can't remove the 'Main' logical window.

Other help: closepw_cmd openlw_cmd openpw_cmd lwin_list pwin_list
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: setflags_cmd
---------------------

   RC,<oldflags> <- SETFLags <logical window> <mask> <flags>


Set flags for a logical window.
Bits in <mask> and <flags> :

   4    = -MORE- enabled
   32   = real-top
   64   = statusline off
   128  = interrupt off
   256  = auto snap to output
   512  = (if false) add scrollbar depending on 'mode sbar'
   1024 = always add scrollbar (if true ignore previous flag)


Other help: openlw_cmd closelw_cmd lwin_list
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Function: checksum_func
-----------------------

   CHECKSUM( <address>,<bytes> )


Returns a checksum for the given memory range. This function transforms
<address> and <bytes> to longword alligned values.
===
@Function: isbreak_func
----------------------

   ISBREAK( <address> )


Test if there is a breakpoint on this address. If true this function returns
the breakpoint number and the breakpoint type in one longword :

   NNNNTTTT
===
@Function: arexxport_func
------------------------

   AREXXPORT( )


Return the pointer to the name of the ARexx port for this instance of
PowerVisor.
This function returns a string if used from ARexx.

The name of the PowerVisor ARexx port is :

   REXX_POWERVISOR

or if you are running a slave instance (the first instance of PowerVisor
is the master. All following instances running at the same time with the
master are slaves) :

   REXX_POWERVISOR.<num>

Other help: pubscreen_func rx_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Function: pubscreen_func
------------------------

   PUBSCREEN( )


Return the pointer to the name of the public screen for this instance of
PowerVisor.
This function returns a string if used from ARexx.

The name of the PowerVisor ARexx port is :

   PowerVisorScreen

or if you are running a slave instance (the first instance of PowerVisor
is the master. All following instances running at the same time with the
master are slaves) :

   PowerVisorScreen.<num>

Other help: arexxport_func rx_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Function: getstack_func
-----------------------

   GETSTACK( )


This function returns the maximum stack usage for the last task monitored
with the 'stack' command. If the stack monitor is still active, this number
will be EXACTLY equal to the maximum stack usage. If the stack monitor
is not active any more, this number will be an approximation depending on
the last usage of 'getstack' and the number of microseconds with the
'stack' command.


Other help: stack_cmd
            ¯¯¯¯¯¯¯¯¯
===
@Command: track_cmd
------------------

   TRACK 't' <task> | 's' | 'c' | 'l'


With this command you can control the resource tracker. The following
library functions are checked:

   - AllocMem/FreeMem
   - AllocVec/FreeVec (AmigaDOS 2.0)
   - OpenLibrary/OldOpenLibrary/CloseLibrary
   - AllocSignal/FreeSignal
   - CreateMsgPort/DeleteMsgPort (AmigaDOS 2.0)
   - CreateIORequest/DeleteIORequest (AmigaDOS 2.0)
   - Lock/UnLock/DupLock/DupLockFromFH (AmigaDOS 2.0)
   - Open/Close/OpenFromLock (AmigaDOS 2.0)
   - AllocRaster/FreeRaster

(The reason functions like 'Open' and 'Lock' are only checked in the
AmigaDOS 2.0 version is that the dos.library is not a standard library
in AmigaDOS 1.3)

With this information you can see if the task (or process) cleans
everything up. Note that you can only track resources for one task
or process at a time.

Note that the 'track' command is not allowed for slave instances
of PowerVisor.

The easiest way to start resource tracking for a program is to use
'debug n', start the program, use 'track t' to get the new task from the
task list and use 'debug r' to remove the debug node and let the program
continue. You can also use 'debug q 1' (before 'debug r') so that the
program will be halted just before it quits.

'track' uses autodefault to the 'task' list for the <task> argument.

   track t     Take a task or process in the task list and start resource
               tracking for that task
   track s     Stop tracking and free all track information. Note that
               the memory that the task forgot to free is NOT freed with
               this function
   track c     Stop tracking and free all track information (like 'track s')
               In addition this function also clears all memory that is
               not freed by the program, unlocks all locks, closes all
               files, deletes all message ports and deletes all IO
               requests
   track l     List all open and allocated resources
===
@Command: specregs_cmd   (only 68020 or 68030 or 68040)
---------------------

   SPecregs


Show all special 68020 registers.

Other help: mmutree_cmd mmuregs_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Command: setfont_cmd
--------------------

   SETfont <logical window> <fontname> <fontheight>


Set a font for a logical window. The font must be either memory resident
or available in the 'fonts:' directory. Proportional fonts are not supported.

See the 'lwin' list for all available logical windows.

Other help: lwin_list
            ¯¯¯¯¯¯¯¯¯
===
@Function: geterror_func
-----------------------

   GETERROR( <expression string> )


Evaluate an expression and return the error. If there was no error, 0
is returned.

Example:
   d geterror("7")
   returns 0 since 7 is a valid expression.

   d geterror("7+")
   returns 16 since there is a missing operand.

Other help: error_cmd
            ¯¯¯¯¯¯¯¯¯
===
@Command: error_cmd
------------------

   <pointer to error string> <- ERror <error number>


This command returns a pointer to an error string corresponding with
<error number>. Note this pointer has very limited use since the space
it points to is almost immediately overwritten by PowerVisor. You can
make a copy of the string with the following construction :

   cs=alloc(s,\({error 17},%s))

17 is the error number (in this case 'Missing operand'). Alloc allocates
a string and puts the pointer to this string in 'cs'. This string is
more permanent than the one returned by 'error'.

'error' is more useful when used from ARexx. The error string is returned
in the 'result' variable.

Other help: geterror_func alloc_func
            ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: colrow_cmd
-------------------

   COLRow <logical window> <columns> <rows>


Set the number of columns and rows (in characters) for the specified
logical window. If <columns> or <rows> are equal to -1, PowerVisor
will scale them to the maximum size available.
If <colums> or <rows> are equal to -1, PowerVisor will clear the window
everytime the size changes. This is not the case when both values are
not equal to -1 but to a fixed value.
Note that you can use the 'fit' command to automatically size the number
of columns and rows to the visible size.

See the 'lwin' list for all logical windows.

Use the 'getcol' and 'getrow' functions to get the current values.

Other help: getcol_func getrow_func lwin_list fit_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯
===
@Function: getcol_func
---------------------

   GETCOL( <logical window> )


Get the current number of columns (or -1) for the logical window.

Other help: getrow_func colrow_cmd lwin_list
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Function: getrow_func
---------------------

   GETROW( <logical window> )


Get the current number of rows (or -1) for the logical window.

Other help: getcol_func colrow_cmd lwin_list
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Function: eval_func
-------------------

   EVAL( <string pointer> )


Evaluate the string at <string pointer> and return the result.
If <string pointer> is 0, 'eval' returns 0.

Example:
   disp eval("1+2")
   displays 3.

   scan    (enter 4+4)
   disp eval(input)
   displays 8.

Other help: if_func
            ¯¯¯¯¯¯¯
===
@Function: if_func
-----------------

   IF( <condition>,<expression 1>,<expression 2> )


If <condition> is true, evaluate <expression 1>, else evaluate
<expression 2>.

Example:
   d if(1,2,3)
   displays 2.

   d if(0,2,3)
   displays 3.

   a=1
   b=2
   c=3
   d=4
   e=5
   d if(a,if(b,c,d),e)
   displays 3.

Other help: eval_func
            ¯¯¯¯¯¯¯¯¯
===
@Command: view_cmd
-----------------

   VIew [<address> [<bytes>]]


View memory following certain requirements. The default format is
Long/Ascii combined view. You can change the format used to display
the memory for a specific range of memory to something else.

Use the 'addtag' command to define how a specific range of memory
should be viewed.

Other help: addtag_cmd remtag_cmd tags_cmd checktag_cmd memory_cmd
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: addtag_cmd
-------------------

   ADDTag <address> <bytes> <type> [<structure>]
          {'r' | 'w' | 'i' | 'p' | 'f'}


With this command you can define the view mode to be used for a range of
memory. The 'view' command uses these tags to determine how to dump
memory.
The <address> is the starting address for the memory range. This range
continous for <bytes> bytes. <type> can be one of the following :

   BA       byte/ascii format
   WA       word/ascii format
   LA       long/ascii format (default for all memory not in tags)
   AS       ascii only format
   CO       code format
   ST       structure format

(case is not important).
Other types can be supported in future.

If your type is 'ST' you must supply an extra argument <structure>.
This is the pointer to the structure definition you must have loaded
with the 'addstruct' command or made with the 'struct' command.
You can use the 'stsize' function to obtain the size of a structure.

The tag system is also used by the disassembler (but only for the
disassembly in the debug display). When disassembling a
(<offset>,<addres reg>) (like '($54,A0)') addressing mode, PowerVisor
will check if the contents of the address register is defined in the
current tag list as a structure. If this is the case, PowerVisor will
check if the <offset> in the addressing mode exists in this structure.
If this is also true then PowerVisor will replace the <offset> number
by the name of this offset defined in the corresponding structure.
This feature only works for the debug display (not for the 'unasm'
command) since PowerVisor needs to know the contents of the address
registers. In combination with this structure-disassembly feature
the 'struct' command is especially useful. With this command you can
make structures and add fields to structures in an interactive way. This
means that you can add names for offsets (also offsets relative to a4
and a5 for global and local variables in C) while you are debugging.
Negative offsets are also allowed.

The tag system is also used by the memory protection system. If you add
the optional 'r' (for read protect) or 'w' (for write protect)
argument you can define the protection characteristics for a certain
region of memory. Note that you don't need a 68020 with 68851 or a 68030
to use these protection arguments. But you need a 68851 or a 68030 to
use the 'mmuwatch' and 'protect' commands which make use of this protection
flags.

With the 'r' option the region will be protected for read accesses.
This means that reads will always return 0 even if the real contents is
something else. Note that you can use the 'speek' and 'spoke' commands
in PowerVisor to really read or write on protected regions.

With the 'w' option the region will be protected for write. Writes to
that memory region will simply be ignored.

Note that you can combine the 'r' and 'w' options.

The 'i' (ignore) option is only useful when you are protecting regions
for specific tasks (see the 'tagtype' command). Normally a region is
considered protected for a certain task either if it is protected for
that task specifically or if it is protected globally (tag list 0).
If you want to override the global protection for a region with other
protection characteristics you can simply use these other flags. For
example, the region can be protected for Read/Write globally but maybe
the task can be allowed to read from it. But if you want to allow all
accesses for that task you must use the 'i' option. When you use this
flag the possible global protection will be undone. That task (only
that task) can do whatever it wants with the specified region.

Note that tag list 0 (see the 'usetag' command) always contains all
regions for global memory protection (global for all tasks). You can
use the other tag lists to protect regions for specific tasks (see
the 'tagtype' command).

When some program tries to read or write from a protected region, the
powerled will blink. Except if you use the 'p' (print) option.
In this case PowerVisor will print a message with the address where the
memory fault occured, the offending task, the program counter, the
stack pointer, the value it was trying to write (only for write) and
some flags from which you can determine the size and the type of the
action. The bits are like this :
   bit 0 for write access
   bit 1 for read access
   bits 2 and 3 for the size of the action (0 = long, 1 = byte, 2 = word)
Note that the bus error message will be printed like a portprint message.
This means that the output will appear on the 'PPrint' logical window when
this window is open (see the 'owin' command).
Also note that it is possible to mis bus error messages when there are
too many. If you are lucky PowerVisor will tell this to you. But it is
also possible that even this message will be canceled by some strange
circumstances. PowerVisor has an internal buffer of 100 bus errors before
it needs to print them. If there are more than 100 bus errors and they
are still not printed, PowerVisor will ignore all following bus errors.

If you also use the 'f' option in combination with some of the previous
memory protection options, the offending task will be stopped some
instructions after the instruction causing the fault. The stop will be
caused by a crash. With this crash node you can use 'debug t' to start
debugging the offending task.

Be careful when protecting some regions. For example, never read
protect ('r') something in the first 4096 bytes of memory. You can use
write protect ('w') if you are careful with what you are write protecting.
(Note that you don't have to care about exception vectors since the VBR
will have been moved by the 'mmuwatch' command)

Note that the 68851 and 68030 MMU's only support fixed pages (PowerVisor
uses 4096 byte pages to make future compatibility with the 68040 easier).
Normally you can thus only protect regions on page boundaries. To solve
this shortcoming PowerVisor will emulate reads and writes in protected
pages which are NOT in the tag list. This means that reads and writes
will be a lot slower in those regions. Expect a large slowdown when you
have a lot of protected regions.

A summary of all protection options :

   r : read protect a region of memory (uses INVALID page MMU entries)
   w : write protect a region of memory (used WP (write protect) flag in
       MMU entries)
   i : cancel global protection for this region for this task
   p : print more information when a bus error occurs
   f : stop the offending task (note that PowerVisor will never
       stopped this way. If PowerVisor is the offending task, this option
       will simply be ignored)


Other help: view_cmd remtag_cmd tags_cmd checktag_cmd addstruct_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯
            stsize_func cleartags_cmd loadtags_cmd savetags_cmd tg_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
            taglist_func usetag_cmd mmuwatch_cmd protect_cmd speek_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
            spoke_cmd tagtype_cmd struct_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: loadtags_cmd
---------------------

   LOADTags <file> <base>


Load tags from a file. All tags in the file are added to the tags in
the current tag list. When an old tag collides with a new tag, the
old tag will be removed (two tags collide when they use the same
address).

If the tagfile contains structures (type 'ST') you must load these
structure in memory (with 'addstruct') before loading the tags. Otherwise
the type of the tag will be changed to Long/Ascii ('LA') and you will get
a warning :

   'Warning ! Unknown structure types have been changed to LA!'


<base> is an address to compare with the address saved in the tag
list. When these two are the same, the tags will remain on the
same address as when they were saved. <base> is useful if you want
to add tags to a piece of memory that may be somewhere else everytime
you use PowerVisor.


Other help: savetags_cmd cleartags_cmd addtag_cmd remtag_cmd tags_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
            taglist_func usetag_cmd addstruct_cmd struct_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: savetags_cmd
---------------------

   SAVETags <file> <base>


Save tags in current tag list to a file.
<base> is an address to include in the saved tag file. With <base> you
can relocate the tags later if the memory element is located on
another position.


Other help: loadtags_cmd cleartags_cmd addtag_cmd remtag_cmd tags_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
            taglist_func usetag_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: cleartags_cmd
----------------------

   CLEARTags


Clear all tags in the current tag list.

Other help: loadtags_cmd savetags_cmd addtag_cmd remtag_cmd tags_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
            taglist_func usetag_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: remtag_cmd
-------------------

   REMTag <address>


Remove the range in the tag list beginning with <address>.

Other help: view_cmd addtag_cmd tags_cmd checktag_cmd cleartags_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯
            taglist_func usetag_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: tags_cmd
-----------------

   TAGs


List all tags currently defined in the current tag list.

Other help: view_cmd addtag_cmd remtag_cmd checktag_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
            taglist_func usetag_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: checktag_cmd
---------------------

   <bytes remaining> <- CHecktag <address>


Check if an address resides in the current tag list. If it is, PowerVisor
will print the type of the tag list followed by the remaining number of bytes
after <address> in this tag.
If the address is not in the tag list, PowerVisor will print the number
of bytes remaining before the next tag. If there is no next tag, PowerVisor
will print $7fffffff.

Other help: view_cmd addtag_cmd remtag_cmd tags_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
            taglist_func usetag_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: usetag_cmd
-------------------

   USetag <number>


Set the current tag list to <number> (0 .. 15). The current tag list is
used by all tag commands and by 'view'.

Other help: tg_cmd addtag_cmd remtag_cmd tags_cmd taglist_func
            ¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: tg_cmd
---------------

   <result> <- TG <number> <command>


Temporarily set the current tag list to <number> and execute the command.
<result> is the result returned by <command>.


Other help: usetag_cmd addtag_cmd remtag_cmd tags_cmd taglist_func
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Function: taglist_func
----------------------

   TAGLIST( )


Return the current tag list. This is a number between 0 and 15.

Other help: usetag_cmd tg_cmd
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Command: interprete_cmd
-----------------------

   INTErprete <structure pointer> <struct def pointer>


Show the contents of a structure at <structure pointer> using the
<struct def pointer> structure definition. You can load and add
structure definitions with the 'AddStruct' command or you can make
structures in an interactive way with the 'struct' command.

Other help: addstruct_cmd stru_list struct_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: clearstruct_cmd
------------------------

   CLEARStruct


Clear all structure definitions loaded with 'addstruct' and made with
'struct'.

Other help: addstruct_cmd remstruct_cmd stru_list struct_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: addstruct_cmd
----------------------

   ADDStruct <filename>


Add the structure definitions from the file to the PowerVisor 'stru'
list. You can then use these structures with the 'interprete', 'peek'
and 'apeek' commands and also for the tag system (see 'addtag').
PowerVisor will first check in the current directory for the file and
than in the s:pv directory. This is the recommended place for scripts
and pvsd files.

You can look in the 'stru' list to see which structures are allready
in memory. At startup this list is already filled with some standard
structures. These structures are the same as used by some of the lists.
Some predefined structures are: _task, _cli, _proc, _wins, _scrs,
_font, ....

You can also make structures from within PowerVisor in an interactive
way with the 'struct' command.

You can save structures to a file with the 'struct' command or with
the 'MStruct' external utility.


Other help: remstruct_cmd stru_list interprete_cmd peek_func apeek_func
            ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
            stsize_func struct_cmd addtag_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: struct_cmd
-------------------

   STRUCt 'n' <struct name> <struct size> |
          'a' <struct pointer> <offset> <type> <field name> |
          'r' <struct pointer> <field name> |
          'l' <struct pointer> |
          'c' <struct pointer> <new struct size> |
          's' <struct pointer> |
          'w' <struct pointer> <filename> |
          'p' <struct pointer> <filename>


With this command you can make and change structure definitions. All
structure definitions can be found in the 'stru' list. You can use them
with the 'interprete', 'peek' and 'apeek' commands and also for the
tag system (see 'addtag').

You can look in the 'stru' list to see which structures are allready
in memory. At startup this list is already filled with some standard
structures. These structures are the same as used by some of the lists.
Some predefined structures are: _task, _cli, _proc, _wins, _scrs,
_font, ... .

This command is especially useful in combination with the fullscreen
debugger and the tag system (see 'addtag' for more information).

'struct' uses autodefault to the 'stru' list for the <struct pointer>
argument.

   struct n <struct name> <struct size>
               Create a new empty structure <struct name> with a given
               size (this size is only used by the 'stsize' function).
               After this you can start adding fields to the structure
               with 'struct a'. No check is made if the name of the
               structure already exists. In that case there will be
               two structures with the same name in the 'stru' list
               (not harmful but not very useful either).

   struct a <struct pointer> <offset> <type> <field name>
               Add a field <field name> to a structure. No check is
               made if the name of the field already exists in the
               structure. In that case there will be two fields with
               the same name in the structure (not harmful but not
               very useful).
               <offset> is the corresponding offset for this field
               in the structure. Note that this offset can be negative
               (very useful for defining fields for local variables if
               you are debugging a function).
               <type> is the type of the field:
                  0     byte
                  1     word
                  2     long
                  3     NULL terminated string (normal C string)
                  4     structure in structure (this means that the value
                        of this field is equal to the address of this
                        field)
                        (this type corresponds with 'struct' entries in
                        machinelanguage include files)
                  128+2 BPTR (BCPL pointer). The value of this field
                        will be automatically converted to a normal
                        pointer (with 'peek' and 'interprete')
                  128+3 BSTR (BCPL string). The value of this field
                        will be automatically converted to a normal
                        pointer (with 'peek') and printed as a normal
                        string (with 'interprete')
               All other values are undefined and should NOT be used!
               Note that you can't add fields to the built-in structures
               like _task, _cli, _proc, ... . These are read-only.

   struct r <struct pointer> <field name>
               Remove a field from a structure.
               Note that you can't remove fields from the built-in
               structures like _task, _cli, _proc, ... . These are
               read-only.

   struct l <struct pointer>
               Lists all fields in a structure with their type (like defined
               above with 'struct a') and offset.

   struct c <struct pointer> <new struct size>
               Change the size of a structure. Note that this size is only
               used by the 'stsize' funcion).
               Note that you can't change the size of a built-in structure
               like _task, _cli, _proc, ... . These are read-only.

   struct s <struct pointer>
               Sort all fields in a structure so that all offsets are in
               the right order. 'struct a' will append the new field to
               the end of the structure. When you have added some fields
               you can use this command to make the structure sorted again.
               The order of the fields in the structure is only important
               for the 'interprete' command, because this command prints
               all fields in the specified order.
               Note that you can't sort the fields of a built-in structure
               like _task, _cli, _proc, ... . These are read-only.

   struct w <struct pointer> <filename>
               Save a structure definition to a file. This file can later
               be used with the 'addstruct' command (PVSD file).

   struct p <struct pointer> <filename>
               Same as 'struct w' but the structure is appended to a
               (possibly) existing file.


Other help: remstruct_cmd stru_list interprete_cmd peek_func apeek_func
            ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
            stsize_func addstruct_cmd addtag_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: string_cmd
-------------------

   <string> <- STRIng <string pointer> [<max length>]


This command is only useful in ARexx. It returns an ARexx string containing
the string pointed to by <string pointer>.
<max length> is the optional maximum length for the returned string.


Other help: assign_cmd rx_cmd
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Command: assign_cmd
-------------------

   ASsign <assignment string>


Assign a value to a PowerVisor variable.
This command also works for memory assignments.

Example:

   The following ARexx script (type in and execute with 'rx')

      /* */
      address rexx_powervisor
      a=1
      assign 'a=2'
      disp a
      disp 'a'

   Will have as output :

      00000001 , 1
      00000002 , 2

Other help: rx_cmd clip_cmd remclip_cmd string_cmd
            ¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: rx_cmd
---------------

   RX <file name>


Execute an ARexx script. The default extension for ARexx scripts is '.pv'.
You do not need to type this extension unless you use a different one.

The name of the PowerVisor ARexx port is :

   REXX_POWERVISOR

or if you are running a slave instance (the first instance of PowerVisor
is the master. All following instances running at the same time with the
master are slaves) :

   REXX_POWERVISOR.<num>

You can get the name of the ARexx port with the 'arexxport' function.

Other help: script_cmd assign_cmd hide_cmd unhide_cmd sync_cmd async_cmd
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
            clip_cmd remclip_cmd arexxport_func
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: remstruct_cmd
----------------------

   REMStruct <struct def pointer>


Unload a structure definition previously loaded with 'addstruct' or made
with 'struct'.

Other help: addstruct_cmd stru_list struct_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Function: peek_func
-------------------

   PEEK( <structure pointer>,<struct def pointer>,<field name> )


Returns the value of <structure>.<field>.

Other help: addstruct_cmd interprete_cmd apeek_func stru_list struct_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Function: stsize_func
---------------------

   STSIZE( <structure pointer> )


Return the size of the structure represented by <structure pointer>.

Other help: addstruct_cmd stru_list struct_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Function: apeek_func
--------------------

   APEEK( <structure pointer>,<struct def pointer>,<field name> )


Returns the address of <structure>.<field>.

Other help: addstruct_cmd interprete_cmd peek_func stru_list struct_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: for_cmd
----------------

   FOR <listname> <command>


For each element in list <listname> execute <command>.
The command is executed with the pointer to the current element from the
list in the 'RC' variabele.

Example:
   for task disp rc
   display all tasks.

Other help: list_cmd <list>_list
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Command: llist_cmd
------------------

   LList <node> ['start']


Traverse a system list and prints all nodes in the list.
If 'start' is specified, 'LList' will automatically search to the
start of the list.

Other help: list_cmd
            ¯¯¯¯¯¯¯¯
===
@Command: vars_cmd
-----------------

   VArs ['all']


This command shows all variables. You will notice the variables
'rc' and 'error'.
When you use the 'all' option, PowerVisor will show all variables
including constants and functions.
Notice the 'mode' special variable and the 'version' constant.


Other help: variables mode_cmd remvar_cmd functions
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: remvar_cmd
-------------------

   REMVar {<variables>}


This command removes all variables in the commandline if they exist.
'remvar' is very useful in scripts.


Other help: variables vars_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: alias_cmd
------------------

   ALias [<alias cmd> <alias string>]


Alias without arguments lists all current aliases.
You can set a new alias <alias cmd> to <alias string> with this
command.
When you create a new alias with the same name, the old one will
be removed.
You can use [] to specify where the arguments must be positioned.
When you want to use quotes you must precede them with '\'.

Example:
   alias lfd 'loadfd [] fd:[]_lib.fd'
      When you type 'lfd exec' on the command line, the command line
      will be expanded to 'loadfd exec fd:exec_lib.fd' before
      execution.

   alias execute li[]bs
      When you type 'execute st li' on the command line,
      the command line will be expanded to 'list libs'.
      (The previous example is ofcourse completely useles).

   alias writeln 'print \'[]\\0a\''
      'writeln we are testing' will result in
      'print 'we are testing\0a''

Note:
   You can use the [] operator as many times as you wish (even in
   the command).

Note:
   You cannot use alias commands in the alias string. So the
   following will NOT create an infinite loop:
      alias disp 'list []'
      alias list 'disp []'
   This sequence of command simply swappes the two commands 'disp'
   and 'list'.

Note:
   You must type an alias in full. You can not use abbreviations for
   aliases on the command line. (If you want an abbreviation, you can
   define one with another alias).

Other help: unalias_cmd
            ¯¯¯¯¯¯¯¯¯¯¯
===
@Command: unalias_cmd
--------------------

   UNALias <alias cmd>


Remove an alias from the alias list.

Other help: alias_cmd
            ¯¯¯¯¯¯¯¯¯
===
@Command: hold_cmd
-----------------

   HOld


This command closes the PowerVisor screen and waits for the <Right-Alt>+
<Right-Shift>+? combination to reopen it again.
If a crash happens PowerVisor will reopen its screen automatically.

Other help: crash quit_cmd
            ¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: quit_cmd   (commandline and scripts only)
-----------------

   Quit


Quit PowerVisor. Everything will be cleaned up.
Frozen tasks are lost. Monitor functions will be cleaned. Crash trapping
is disabled. Stack checking is disabled. All debug tasks are frozen.
All FDFiles will be removed from memory.
If one of your debug tasks is tracing 'Quit' will print an error message.
First halt this task with 'trace h'.

Warning: Everything you allocated or opened using library functions will
         NOT be cleaned up. Remember to do it yourself.

         All crashed tasks are left in memory. They will simply wait.

         All frozen tasks are lost forever (and their memory too).
         UnFreeze or kill your tasks before you quit.

         All memory allocated with the 'alloc' function is automatically
         freed.

         All tasks you were debugging will be frozen.

         All physical windows and logical windows are closed.

If 'quit' is called from within a script, the script is stopped.
'quit' will be ignored if called from within a group operator. 'Quit' will
only work when called from the commandline.

If you are still debugging some programs, PowerVisor will first ask for
confirmation. If you confirm the 'quit', you will of course loose some
memory (I mean your Amiga :-)


Other help: hold_cmd trace_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: gadgets_cmd
--------------------

   Gadgets <window>


Lists all gadgets in the specified window.

Other help: wins_list list_cmd info_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: size_cmd
-----------------

   SIze <physical window> <w> <h>


Set the width and height (in pixels) for the physical window. This command
only works if the physical window is a non-backdrop window.

Other help: screen_cmd move_cmd pwin_list
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: move_cmd
-----------------

   MOVe <physical window> <x> <y>


Move the physical window to a specified position. This command only works
if the physical window is a non-backdrop window.

Other help: screen_cmd size_cmd pwin_list
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: screen_cmd
-------------------

   SCREen [<screen>]


Move the PowerVisor window to another screen. If you want PowerVisor on its
own screen, type 'screen' without arguments (this is default).
You can use the 'size' command to change the size for this window (or you
can use the sizinggadget).
If <screen> is 0, PowerVisor will go to its own screen but will remain
on a non-backdrop window.

Example:
   screen workbench         move PowerVisor to workbench screen

Other help: size_cmd move_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: remres_cmd
-------------------

   REMRes <resident pointer>


Remove a resident module.

Example:
   remres resm:exec

Other help: syslists
            ¯¯¯¯¯¯¯¯
===
@Command: remove_cmd
-------------------

   <node> <- REMOve <node>


Remove a node from a list. Be carefull with this command. No checking is done
if you are really removing a node. The memory for this node is not freed.

Other help: remres_cmd remhand_cmd kill_cmd
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: curdir_cmd
-------------------

   CUrdir <process> <directory name>


Set a new current directory for a process.

Example:
   curdir task:Shell ':langua/sources'

Other help: strings list_op
            ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯
===
@Command: clear_cmd
------------------

   CLEar [<value>]


Fill all unused memory with <value> (or 0 if value is not specified).
===
@Function: lines_func
--------------------

   LINES( LOGWIN )


This function gets the maximum number of lines available on the
PowerVisor logical window.

Example:
   disp lines(main)

Other help: cols_func locate_cmd lwin_list
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Function: cols_func
-------------------

   COLS( LOGWIN )


This function gets the maximum number of columns available on the
PowerVisor window.

Example:
   disp cols(main)

Other help: lines_func locate_cmd lwin_list
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Function: getlwin_func
----------------------

   GETLWIN()


This function returns a pointer to the current logical window.

Other help: lwin_list xwin_cmd current_cmd getactive_func active_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: scroll_cmd
-------------------

   SCROll <logical window> <x> <y>


Scroll the logical window. <x> and <y> is the new top-left visible
position. This command checks for illegal values.

Other help: active_cmd lwin_list
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: active_cmd
-------------------

   Active <logwin>


Make a logical window the active one. The active logical window is
the logical window where you can scroll with the keys, and where all
input is redirected to (see The 'Screen' tutorial file for more info).

Other help: list_list getactive_func current_cmd getlwin_func
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Function: getactive_func
------------------------

   GETACTIVE()


This function returns a pointer to the active logical window. This
is the logical window where you can scroll with the keyboard.

Other help: lwin_list xwin_cmd current_cmd active_cmd getlwin_func
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Function: getx_func
-------------------

   GETX()


Get the current x coordinate on the current logical window (in columns).

Example:
   a=getx()

Other help: gety_func locate_cmd getchar_func variables current_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
            getlwin_func getline_func
            ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Function: gety_func
-------------------

   GETY()


Get the current y coordinate on the current logical window (in lines).

Other help: getx_func locate_cmd getchar_func variables current_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
            getlwin_func getline_func
            ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Function: getchar_func
----------------------

   GETCHAR()


Get the character at the current screenposition in the current logical
window.

Example:
   locate 10,10
   a=getchar()

Other help: getx_func gety_func locate_cmd variables current_cmd getlwin_func
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
            getline_func
            ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Function: getline_func
----------------------

   GETLINE()


Get the pointer to the line at the current screenposition in the current
logical window. This pointer points just after the attribute for that
line.

Other help: getx_func gety_func locate_cmd variables current_cmd getlwin_func
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
            getchar_func
            ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: current_cmd
--------------------

   CURRent <logical window>


Set the current logical window. Only 'extra' and 'main' are allowed.
Before you can use the 'extra' logical window you must open it with
the 'xwin' command.

Other help: xwin_cmd lwin_list getlwin_func on_cmd active_cmd getactive_func
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: on_cmd
---------------

   <result> <- ON <logical window> <command>


With this command you can execute an other command, so that it's output
appears on the logical window of your choice (except 'debug').
This command temporary sets the current window to <logical window>.
<result> is the result returned by <command>.

Example:

   open 'extra' logical window :
      xwin

   execute a list on that window :
      on xwin list task

Other help: xwin_cmd lwin_list getlwin_func current_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Command: cls_cmd
----------------

   CLs


This command clears the current logical window.

Other help: current_cmd getlwin_func
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: led_cmd
----------------

   LEd


Use this command to toggle the powerled on or off. This is useful when
a program is crashed or when you are using the led monitor.

Other help: addfunc_cmd
            ¯¯¯¯¯¯¯¯¯¯¯
===
@Command: load_cmd
-----------------

   <bytes loaded> <- LOAd <filename> <start> [<max bytes>]


Load a file into memory. Only <max bytes> are read in if specified.
Please allocate the memory you use.

Example:
   pointer=alloc(n,10000)
   load file pointer 10000
   disp pointer

Don't forget to free you memory later (with 'free').

Other help: save_cmd free_func
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: save_cmd
-----------------

   <bytes written> <- SAve <filename> <start> <bytes>


Save memory to disk.

Other help: load_cmd
            ¯¯¯¯¯¯¯¯
===
@Command: fregs_cmd
------------------

   FREGs <task>|<debug node>


Show the floating point registers for a task.
Each floating point register (fp0..fp7) is shown in the internal
Exec stackframe format (12 bytes).


Other help: regs_cmd float_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: float_cmd
------------------

   FLoat <task>|<debug node> <register number> <register value>


Change the value of a floating point register.

<register number> may be 0 to 7 for fp0 to fp7 respectively.


Other help: fregs_cmd
            ¯¯¯¯¯¯¯¯¯
===
@Command: regs_cmd
-----------------

   REGs <task>|<crash node>|<debug node>


Show the registers for a task.
When a task is crashed use the crash node pointer instead. If you don't
do this, some registers may contain wrong information.

Other help: debugging crash special_op fregs_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: print_cmd
------------------

   PRint <string>


Print a string on the current logical window. (Useful for script and ARexx
programs)

Example:
   print 'testing'
   print test

To print a newline after the string, use:

   print 'testing\n'
   print testing\n

Other help: disp_cmd locate_cmd strings current_cmd getlwin_func
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: sprint_cmd
-------------------

   SPRint <string>


Print a string on a serial terminal or printer (Useful for 'addfunc'
for example).

Other help: addfunc_cmd
            ¯¯¯¯¯¯¯¯¯¯¯
===
@Command: locate_cmd
-------------------

   LOCAte <x> [<y>]


Adjust the current location on the current logical window.

Other help: getx_func gety_func getchar_func lines_func cols_func  print_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯  ¯¯¯¯¯¯¯¯¯
            current_cmd getlwin_func home_cmd getline_func
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: home_cmd
-----------------

   HOMe


Adjust the current location on the current logical window to the top location
visible. Note that this is not always the same as 'locate 0,0'.

Other help: getx_func gety_func getchar_func lines_func cols_func  print_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯  ¯¯¯¯¯¯¯¯¯
            current_cmd getlwin_func locate_cmd getline_func
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Function: lastmem_func
----------------------

   LASTMEM()


This function returns the address that 'memory' and 'unasm' will use
to continue their listing.

Other help: memory_cmd unasm_cmd lastbytes_func lastlines_func lastfound_func
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯
===
@Function: lastlines_func
------------------------

   LASTLINES()


This function returns the last number of lines used with the 'unasm'
command (default is 20).

Other help: unasm_cmd lastbytes_func
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯
===
@Function: lastbytes_func
------------------------

   LASTBYTES()


This function returns the last number of bytes used with the 'view'
or 'memory' commands (default is 320).

Other help: memory_cmd view_cmd lastlines_func
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯
===
@Function: lastfound_func
------------------------

   LASTFOUND()


This function returns the address of the second byte of the string found
with 'search' or 'next'. This is the address where 'next' will continue
with the search.

Other help: search_cmd next_cmd
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Function: alloc_func
--------------------

   ALLOC( ('n',<size>) | ('c',<size>) | ('s',<string>) )


Use this function for easy memory allocation.

Example:
   a=alloc(n,1000)
   allocates 1000 bytes and stores the pointer to this memoryblock in 'a'.

   a=alloc(c,1000)
   allocates 1000 bytes and stores the pointer to this memoryblock in 'a'.
   The memory will be allocated in chip ram.

   a=alloc(s,'PowerVisor')
   allocates 11 bytes and copies the string 'PowerVisor' to this
   memory region. 'a' is the pointer to this memoryblock.

Use the 'free' function to free this memory.
Note that memory allocated with this command is automatically freed
when PowerVisor quits.
Also note that this memory is not guaranteed to be in chip ram.

When the blocksize is smaller than 65533 bytes the result from this function
is a pointer after a word containing the size. This pointer is thus word
alligned but not longword alligned.
When the blocksize is bigger the result is a pointer after a longword
containing the size. This pointer is longword alligned.
Using word or longword allignment you can determine the size of a memory
block. An easier way to do this is to use the 'getsize' function.

Other help: realloc_func free_func strings variables getsize_func cleanup_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
            showalloc_cmd isalloc_func
            ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Function: realloc_func
----------------------

   REALLOC( <memoryblock>,<new size> )


Use this function to reallocate a memoryblock allocated with the
'alloc' function. Only memoryblocks smaller than 64K are supported.

Other help: alloc_func free_func strings variables getsize_func
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
            cleanup_cmd showalloc_cmd isalloc_func
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Function: free_func
-------------------

   FREE( <pointer> )


Free a block previously allocated with 'alloc' or 'getstr'.

Other help: alloc_func getstr_cmd getsize_func showalloc_cmd cleanup_cmd
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Function: getsize_func
----------------------

   GETSIZE( <memoryblock> )


This function determines the size of a memoryblock allocated with the
'alloc' function or some other PowerVisor commands.

Other help: alloc_func free_func getstr_cmd isalloc_func showalloc_cmd
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯
            cleanup_cmd realloc_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Function: isalloc_func
----------------------

   ISALLOC( <pointer> )


This function checks if <pointer> points to a memoryblock allocated
with the 'alloc' function. If it is, isalloc returns a pointer to
the pointer, otherwise 0.

Other help: alloc_func free_func getsize_func showalloc_cmd cleanup_cmd
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Command: showalloc_cmd
----------------------

   SHowalloc


This command shows all memory blocks allocated with the 'alloc'
function. All memory blocks that are in this list will be
automatically freed when PowerVisor quits.

Other help: alloc_func free_func getsize_func isalloc_func cleanup_cmd
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
            realloc_func
            ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: cleanup_cmd
--------------------

   CLEANup


This command frees all memory blocks that are allocated with the
'alloc' function. This is done automatically when PowerVisor quits.

Other help: alloc_func free_func getsize_func isalloc_func realloc_func
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
            showalloc_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: color_cmd
------------------

   COLor <col num> <red> <green> <blue>


Change the rgb value of a PowerVisor screen color.

This command gives an error when you try to use it when
PowerVisor is on a window.

Other help: screen_cmd
            ¯¯¯¯¯¯¯¯¯¯
===
@Function: rfrate_func
---------------------

   RFRATE( )


Give the current refresh rate.

Other help: refresh_cmd rfcmd_func
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Function: rfcmd_func
--------------------

   RFCMD( )


Give a pointer to the current refresh command (or 0 if no refresh).

This function returns a string if used from ARexx.

Other help: refresh_cmd rfrate_func
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Function: curlist_func
----------------------

   CURLIST( )


Give a pointer to the name of the current list.

This function returns a string if used from ARexx.

Other help: syslists
            ¯¯¯¯¯¯¯¯
===
@Command: request_cmd
--------------------

   <result> <- REQuest <body string> <gadget string> <argument>


Show a requester on the PowerVisor screen. This command uses
reqtools.library (V37 or higher) (© Nico François) is available, otherwise
this command is simulated using the 'key' function.
The result of this command is a number indicating the button that was
pressed (this number is also what you should press on the keyboard if
you don't have reqtools.library). The rightmost button is 0. All other
buttons are numbered from left to right starting with 1.

<body string> is the string for the requester title bar.
<gadget string> is the string with all the button text below.
Note that you can use one % C-formatting character (optionally) in one
of the above strings. If you do this <argument> is used for the value.
Note that <argument> is NOT an optional argument.


Other help: scan_cmd reqload_cmd reqsave_cmd getstring_cmd key_func
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: reqload_cmd
--------------------

   INPUT,<ptr to filename> <- REQLoad <title>


Ask the user for a filename with a filerequester. This command uses
reqtools.library (V37 or higher) (© Nico François) if available, otherwise
this command is equivalent to the 'scan' command.
The result of this command (in INPUT), is a pointer to the file name
(or 0 if the user pressed 'cancel'). This string is remembered until you
quit PowerVisor or until you use another input command ('scan', 'reqload',
'reqsave' or 'getstring').

This command returns a string if used from ARexx.

<title> is the title to be put in the requester window

The filerequester is a 'load' requester. This means that you can
double click on filenames.


Other help: scan_cmd request_cmd reqsave_cmd getstring_cmd key_func
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: reqsave_cmd
--------------------

   INPUT,<ptr to filename> <- REQSave <title>


Ask the user for a filename with a filerequester. This command uses
reqtools.library (V37 or higher) (© Nico François) if available, otherwise
this command is equivalent to the 'scan' command.
The result of this command (in INPUT), is a pointer to the file name
(or 0 if the user pressed 'cancel'). This string is remembered until you
quit PowerVisor or until you use another input command ('scan', 'reqload',
'reqsave' or 'getstring').

This command returns a string if used from ARexx.

<title> is the title to be put in the requester window

The filerequester is a 'save' requester. This means that you can't
double click on filenames.


Other help: scan_cmd request_cmd reqload_cmd getstring_cmd key_func
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: getstring_cmd
----------------------

   INPUT,<ptr to inputline> <- GEtstring <title> <max number of chars>


Ask the user for input. This command uses reqtools.library (V37 or
higher) (© Nico François) if available, otherwise this command is equivalent
to the 'scan' command.
The result of this command (in INPUT), is a pointer to the result string
(or 0 if the user pressed 'cancel'). This string is remembered until you
quit PowerVisor or until you use another input command ('scan', 'reqload',
'reqsave' or 'getstring').

This command returns a string if used from ARexx.

<title> is the title to be put in the requester window
<max number of chars> is the maximum number of characters that is allowed
in the requester

Both parameters are ignored if 'scan' is used

Other help: scan_cmd request_cmd reqload_cmd reqsave_cmd key_func
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: scan_cmd
-----------------

   INPUT,<pointer to inputline> <- SCAn [<number>]


Ask the user for input. This command is very useful for ARexx scripts.
The result of this command (in INPUT), is a pointer to the result string.
This string is remembered until you quit PowerVisor or until you use another
input command ('scan', 'getstring', 'reqload' or 'reqsave')

This command returns a string if used from ARexx.

Normally the prompt is '????'. If you want another 4 letter prompt you
can use <number>.

Example:
   scan *"TEST"

   will ask for a line of text (with the 'TEST' prompt) and store the
   pointer to this line in 'input'.

Other help: key_func showalloc_cmd free_func cleanup_cmd getstring_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯
            reqload_cmd reqsave_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Function: key_func
------------------

   KEY( )


Wait for a key and return the ascii value.

Example:
   a=key()

Other help: variables qual_func scan_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Function: qual_func
-------------------

   QUAL( )


Return the qualifier for the last pressed key (with 'key').

Example:
   a=key()
   disp qual()

Other help: variables key_func
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: disp_cmd
-----------------

   <value of expression> <- Disp <expression>


Use this command to display an expression.
Also use this command to execute a library function if you don't want
to put the result in a variable.

Other help: variables expressions libfuncs print_cmd void_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: refresh_cmd
--------------------

   Refresh [<refresh rate> <command>]


This command installs <command> to be executed every <refresh rate>
IntuiTick (one IntuiTick is a tenth of a second).

With no arguments 'refresh' removes the refresh command.

Note that before you can execute this command you must open the refresh
logical window with the 'rwin' command.

Other help: syslists list_cmd rfrate_func rfcmd_func rwin_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: fit_cmd
----------------

   FIT <logical window>


This command adjusts the number of columns and number of rows of a logical
window to fit exactly in the visible size. This is useful after a switch
from non-interlace to interlace for example.

You can achieve the same result with the 'colrow' command, but then you have
to compute the number of columns and rows for yourselves.

Other help: colrow_cmd lwin_list
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: awin_cmd
-----------------

   AWin [<number of lines>]


Open/close the Rexx window. This logical window is used when it is present
for Rexx output. If it is not present the current logical window is used.

If <number of lines> is specified, the logical window is opened with
<number of lines> lines (for the 'topaz 8' font).


Other help: swin_cmd dwin_cmd owin_cmd rwin_cmd xwin_cmd lwin_list wwin_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: owin_cmd
-----------------

   OWin [<number of lines>]


Open/close the PPrint window. This logical window is used when it is present
for PortPrint output. If it is not present the current logical window is
used.

If <number of lines> is specified, the logical window is opened with
<number of lines> lines (for the 'topaz 8' font).


Other help: swin_cmd dwin_cmd awin_cmd rwin_cmd xwin_cmd lwin_list wwin_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: rwin_cmd
-----------------

   RWin [<number of lines>]


Open/close the Refresh window. (required if you want to use the 'refresh'
command).

If <number of lines> is specified, the logical window is opened with
<number of lines> lines (for the 'topaz 8' font).


Other help: awin_cmd owin_cmd swin_cmd dwin_cmd xwin_cmd lwin_list wwin_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: xwin_cmd
-----------------

   Xwin [<number of lines>]


Open/close the Extra window.

If <number of lines> is specified, the logical window is opened with
<number of lines> lines (for the 'topaz 8' font).


Other help: awin_cmd owin_cmd swin_cmd dwin_cmd rwin_cmd lwin_list wwin_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: dwin_cmd
-----------------

   DWin [<number of lines>]


Open/close the Debug window. (required if you want to use fullscreen
debugging).

If <number of lines> is specified, the logical window is opened with
<number of lines> lines (for the 'topaz 8' font).


Other help: swin_cmd owin_cmd awin_cmd rwin_cmd xwin_cmd lwin_list wwin_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: swin_cmd
-----------------

   SWin [<number of lines>]


Open/close the Source window. (required if you want to use sourcelevel
debugging).

If <number of lines> is specified, the logical window is opened with
<number of lines> lines (for the 'topaz 8' font).


Other help: dwin_cmd owin_cmd awin_cmd rwin_cmd xwin_cmd lwin_list wwin_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: wwin_cmd
-----------------

   WWin [<number of lines>]


Open/close the Watch window. (for the debugger).

If <number of lines> is specified, the logical window is opened with
<number of lines> lines (for the 'topaz 8' font).


Other help: dwin_cmd owin_cmd awin_cmd rwin_cmd xwin_cmd lwin_list swin_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
            watch_cmd
            ¯¯¯¯¯¯¯¯¯
===
@Command: mode_cmd
-----------------

   MOde <mode argument> {<mode argument>...}


Install PowerVisor preferences.

The following arguments are supported :

   byte        to list memory in byte notation
   word        to list memory in word notation
   long        to list memory in long notation (default)
   ascii       to list memory in ascii notation

   lace        interlace on
   no lace     no interlace (default)

   super       superhires on (only AmigaDOS 2.0)
   no super    superhires off (only AmigaDOS 2.0) (default)

   dec         integers are displayed as decimal
   hex         integers are displayed as hex
   hexdec      both formats are displayed (default)

   more        display prompt when scrolling to much (default)
   no more     continue scrolling

   fb          feedback on screen (default)
   no fb       no command feedback

   auto        do an automatic list whenever the user uses a 'change
               current list' command.
   no auto     don't do this (default)

   default     default screen (only AmigaDOS 2.0) (default)
   pal         pal screen (only AmigaDOS 2.0)
   ntsc        ntsc screen (only AmigaDOS 2.0)
   vga         vga screen (only AmigaDOS 2.0)
   a2024       a2024 screen (only AmigaDOS 2.0)
   euro36      euro36 screen (only AmigaDOS 2.0)
   euro72      euro72 screen (only AmigaDOS 2.0)
   sup72       super72 screen (only AmigaDOS 2.0)

   shex        show hex data when disassembling memory (default)
   no shex     do not show hex data

   space       add a space after a snapped word (default)
   no space    don't add a space

   sbottom     size gadget is in bottom border (default)
   no sbottom  size gadget is in right border

   sbar        show scrollbars to scroll in logical windows (only AmigaDOS 2.0)
   no sbar     don't show scrollbars (only AmigaDOS 2.0) (default)

   fancy       use two bitplane screen. If you have AmigaDOS 2.0, a newlook 3D
               screen will be used (default)
   no fancy    normal one bitplane screen

   lonespc     snap space when user clicks on empty space in window
   no lonespc  don't do this (default)

   patch       patch the Exec AddTask function so that all new tasks will
               have full protection for PowerVisor (default)
   no patch    do not patch Exec AddTask. You must use 'mode nopatch' if you
               want to use another debugger (like CodeProbe or MonAm)
               when PowerVisor is still in memory. Otherwise the Amiga can
               crash

   dirty       use this option when you want to debug programs that use
               'trap' instructions. Don't use this option in all other
               cases since it makes debugging a little bit slower
               (especially conditional tracing) and it is not very system
               friendly (it patches some private exception vectors). Note
               that this option is a MUST if the program you are debugging
               uses 'trap' instructions
   no dirty    don't allow the debugging of programs with 'trap'
               instructions. This is slighty faster and much more system
               friendly (default)

   intui       Open a physical window when you open a standard logical window
               with one of the standard logical window commands
   no intui    Only open the logical window on the 'Main' physical window
               (default)

Example:
   mode byte lace no fancy no fb

You can set and examine the 'mode' variable.
Parameters set with this command can be saved with the 'saveconfig' command.
Note that the 'no' argument may be joined with the following argument
('mode nolace' instead of 'mode no lace' for example).


Other help: variables saveconfig_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: copy_cmd
-----------------

   Copy <source> <destination> <bytes>


Copy <bytes> bytes from <source> to <destination>.
Be cautious with this command. It can be very destructive.

Other help: fill_cmd search_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: fill_cmd
-----------------

   Fill <dest> <bytes> <with>


Fill the memory starting at <dest> with the string <with>. Do this
for <bytes> bytes.

For example:
   fill $c50000 22 'test\41'

will copy 4.4 times the string "testA" beginning at $c50000.
The memory map looks something like:
00C50000: testAtestAtestAt
00C50010: estAte

Be cautious with this command. It can be very destructive.

Other help: copy_cmd search_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: search_cmd
-------------------

   RC,<address> <- Search <start> <bytes> <string>


Search to a string in memory starting at <start>. Search until the
string is found, or until you have searched <bytes> bytes.

Example:
   search $1000 2000 'test'

Will search for the string "test" beginning at $1000. If after 2000 bytes
the string is not found, 0 is the result.

The result for this command will also be stored in the 'rc' variable.

Other help: copy_cmd fill_cmd variables next_cmd lastfound_func
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: next_cmd
-----------------

   RC,<address> <- Next


Continue searching at the last position.
This command prints 0 if not found.

The result is stored in the 'rc' variable.

Other help: search_cmd variables lastfound_func
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: prof_cmd
-----------------

   PROF 't' <debug node> <micro seconds> | 's' | 'c' | 'l'


With this command you can control the PowerVisor profiler. You can
profile only one process or task at a time. The task you want to profile
must be loaded with 'debug l', 'debug n' or 'debug t'. In other words:
it must be a debug task. The profiler is only useful when you have also
loaded some symbols for the debug task.

After you have installed the profiler for a debug task, PowerVisor will
check the task every <micro seconds> (a UNIT_MICROHZ timer device is
used). PowerVisor then searches the closest symbol (distance less than
10000 bytes) and stores that in a table (together with a usage counter).

Don't set <micro seconds> too low or the task will not get any chance
to execute (because PowerVisor has priority 4). 1000 is a good value.
10000 is better if you want less overhead.

Note that the profiler only profiles while the debug task is EXECUTING
(with 'trace g' for example). Tracing is not enough (during 'trace'
or 'trace gt' no profiling happens).

Look at the 'debug' command for a useful option to prevent the debug
task from quiting too soon ('debug q').

Note that you can also use 'prof' to control 'profile tracing' with the
'trace' command ('trace p' and 'trace pf'). Note that 'trace p' forces
the <debug node> for profiling to the current debug node at that moment.
Note! Normally it is not possible to profile more than one program at
the same time. However, this restriction is not really true for 'profile
tracing'. If you are profiling two debug nodes with 'trace p' or
'trace pf' all profiling information will be put in the same table (the
table you can look at with 'prof l'). But (!) when you type 'prof l'
you will notice that only some of the symbols are known. All other
symbol names appear as '?'. This is because the 'prof l' command only
knows how to get the name for a symbol for the debug node it THINKS
it is profiling. In this case this is the LAST debug node where the
'trace p' command was executed. If you want to look at all the other
symbols you must use 'trace p' or 'prof t' (maybe 'prof s' first to
stop the previous profiling) with the correct debug node.

'prof' uses autodefault to the 'dbug' list for the <debug node> argument.

   prof t <debug node> <micro seconds>
               Take a debug node and start profiling. Note that the
               table with profiling information is not cleared by this
               command. So you can temporarily suspend profiling (with
               'prof s') and continue later with no loss of information
   prof s
               Stop profiling. The profiling table is not cleared so you
               can still use 'prof l' to list this info
   prof c
               Clear all profiler information. Note that the profiler is
               not stopped by this command. If you use 'prof c' while the
               profiler is still busy, this command will clear the table
               and the table will immediately be filled again with new
               information
   prof l
               First show the number of hits while the process was waiting
               and ready. After that each symbol that was encountered
               during profiling is listed together with a usage counter.
               If, for one reason or another, there are no more symbols
               a '?' is printed for the symbol name (this can happen if
               the debug node is removed, or if you unload the symbols).
               The line with address 0 corresponds with all hits that were
               not close to a symbol


Other help: debug_cmd
            ¯¯¯¯¯¯¯¯¯
===
@Command: stack_cmd
------------------

   STAck [<task> <micro seconds>]


Use this command to check stack usage for a specific task. You can only
check one task at the time. With no arguments this command removes the
stack checker.

'stack' uses the UNIT_MICROHZ timer device. This means that <micro seconds>
must be greater or equal than 2. This command has a better check resolution
than 'account' (if your <micro seconds> value is low enough).

'stack' freezes the task when a stack overflow is about to occur (see the
'prefs' command for the minimum number of bytes allowed in the stack).
Note that this behaviour is different from 'account'. Stack overflows
trapped with the 'account' stack checker are put in the 'crsh' (crash)
list (This behaviour may change in future).

In addition to stack checking this command also computes the maximum stack
usage for the task. You can display this maximum with the 'getstack'
function.

The stackchecker uses the following algorithm :

   - First the unused stackspace of <task> is filled with a special value
     ($62951413)

   - Every <micro seconds> PowerVisor wakes up to update the maximum
     stack usage returned by 'getstack'. PowerVisor also checks if there
     is no stack overflow. Note that short stackusage burst (short
     recursive functions for example) can be missed by this checker.
     You can decrease <micro seconds> to solve this problem but this
     can cause other problems (your computer is suddenly running very
     very slow :-)

   - The 'getstack' function (when called) computes the maximum stack
     usage by counting the special values that are not yet overwritten
     by the task. This way you will know the real maximum stack usage

   - If the stack checker is stopped (with the 'stack' command), 'getstack'
     will simply return the last computed value. This is either the value
     computed every <micro seconds> by the stack checker (not very
     accurate) or the value computed by a call to 'getstack' while the
     stack checker was still active (very accurate)


Other help: prefs_cmd stack_cmd getstack_func
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: account_cmd
--------------------

   ACCount


This command enables stack checking and task accounting.
Note that only 64 tasks are checked. You can see the accounting
info in the 'task' list.

Note that the 'account' command is not allowed for slave instances
of PowerVisor.


Other help: prefs_cmd stack_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: kill_cmd
-----------------

   Kill <task>|<crash node>


Cancel the specified task. This command works even if the task was
frozen.

Example:
   kill arp          when the current list is 'task' and 'arp' is an
                     abbreviation of a task or process
   kill 00C05063

If the task you want to kill has crashed, PowerVisor will also remove
the corresponding crash node. You can also kill a crashed task with a
pointer to the crash node instead of the task node.
Do not kill a debug task. Remove this with the 'debug' command.

Other help: crash debug_cmd debugging freeze_cmd
            ¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: freeze_cmd
-------------------

   FReeze <task>


Freeze a task. Remember that when you quit PowerVisor all frozen tasks
are lost.

Other help: kill_cmd unfreeze_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: unfreeze_cmd
---------------------

   UNFreeze <task>


Unfreeze a task you have frozen.

Other help: freeze_cmd
            ¯¯¯¯¯¯¯¯¯¯
===
@Command: addfunc_cmd
--------------------

   RC,<func node> <- ADdfunc (<libfuncname> | 'offs' <library> <offset>)
                     ['only' <task>] [<type> [<command>]]


This is a very powerfull command which enables you to monitor library
functions. I will explain this command with examples:

   loadfd exec fd:exec_lib.fd
                                 If you had not already done this
   addfunc openlibrary           Whenever some task uses the openlibrary
                                 function call, the usage count increments
                                 and the information for the last 8 tasks
                                 using this function is updated. (See
                                 'help info' and 'help syslists')
   addfunc putmsg led            Whenever a task uses the putmsg function
                                 the powerled switches its state.
   addfunc wait only trackdisk.device full
                                 Everytime 'trackdisk.device' uses the
                                 Wait function, the usage count is
                                 incremented. The registers used to
                                 call this function are also remembered.
   addfunc offs lib:exec -30     If you don't want to load the fd-file
                                 and you know the offset, you can use this
                                 construct.

You can find the usage counter in the list 'func'. Type 'func' to set
this list to the current one and type 'list'.

Note that the 'addfunc' command is not allowed for slave instances
of PowerVisor.

The following <type>s are available :

   none     Simply remember the 8 last tasks that called this function and
            update the usagecounter.
   LED      remember the 8 last tasks, update the usagecounter and blink
            the powerled.
   FULL     remember the 8 last tasks with their registers at the moment
            they called the function and update the usagecounter.
   FULLLED  remember the 8 last tasks with their registers at the moment
            they called the function, update the usagecounter and
            blink the powerled.
   EXEC     PowerVisor will call <command> everytime the function is called.
            The variable 'rc' will point to a copy of the function node.
            Warning ! Don't use this option for the following library
            functions :
               AllocSignal
               FreeSignal
               AllocMem
               FreeMem
               FindPort
               GetMsg
               PutMsg
               WaitPort
               PP_InitPortPrint
               PP_StopPortPrint
               PP_ExecCommand
            You can find the structure of the function node in the
            'The Wizard Corner' chapter.
   SCRATCH  After the library function is executed, PowerVisor will
            destroy the contents of 'd1', 'a0' and 'a1'. (They will
            contain the following values respectively : $BADBADD1,
            $BADBADA0, $BADBADA1)


Other help: remfunc_cmd libfuncs syslists list_cmd info_cmd func_list
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: remfunc_cmd
--------------------

   REMfunc <function monitor node>


Use this function to remove a patch you installed with 'addfunc'.
This function checks if you are removing patches of the same function
in the wrong order. You should always remove the most recent patch
first.
You can find the nodes for the function monitor in the 'func' list

Example:
   addfunc putmsg only 00C23516
   addfunc putmsg only 00C036D0 led
   ...
   remfunc 00C20AB2        assuming this is the one with 'led'
   remfunc putmsg          the other one.

Other help: addfunc_cmd syslists func_list
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Help crash_cmd
--------------

   CRAsh <taskpointer>


This command patches the TrapCode in the task to the PowerVisor trapcode
routine. This means that PowerVisor will trap all exceptions for that task.
This command is useful in combination with 'mode patch'. 'mode patch' patches
all new tasks (by patching AddTask) while 'crash' patches all existing
tasks (to patch all tasks use 0 for the <taskpointer>). You should use
this command if you want to debug using resident breakpoints or if you
want to be able to debug a task after it crashes (in that case you should
have done this command BEFORE the task crashes).

Note that all these difficulties are only for tasks already running when
PowerVisor was started (provided 'mode patch' is true). All new tasks will
get the proper attention of PowerVisor.

Note that it is sometimes dangerous to patch all tasks at once since it is
possible that a program uses the TrapCode field for other purposes. If you
have such programs use 'crash' with a specific task node.

Note that the 'crash' command is not allowed for slave instances
of PowerVisor.


Other help: mode_cmd
            ¯¯¯¯¯¯¯¯
===
@Help crash
----------
PowerVisor traps crashes. These include 'task helds' and 'gurus'.

Note that a crashed task is not frozen but simply put to wait state.
Use the command 'kill' to cancel the task

You can debug a crashed task with 'debug t'.

When PowerVisor crashes, you get a warning. If this happens you should
try to find out why it happened. If this crash is reproducable and is not
caused by dangerous actions by you, you should write me a bug report.

Note that only the master instance of PowerVisor traps crashes (the master
instance is the first PowerVisor program in memory).


Other help: kill_cmd remcrash_cmd debug_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: unasm_cmd
------------------

   Unasm [<start> [<instructions>]]


This command disassembles machinelanguage beginning at <start>.
<instructions> instructions are disassembled.
This command also shows symbols and breakpoints if there are any.

With no arguments this command continues the disassembly.

<instructions> is 20 by default.

Normally you will also see the hex data corresponding with the code.
You can disable this (and thus provide for longer labels in symbolic
disassembly) with the mode command (noshex).

Other help: debugging break_cmd mode_cmd view_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: libinfo_cmd
--------------------

   LIBInfo <library function name>


This command shows you the library, the offset and the register usage
for a library function. You must have loaded the corresponding fd-file
first.

Other help: libfuncs loadfd_cmd libfunc_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Command: libfunc_cmd
--------------------

   LIBFunc <library> <offset>


This command shows you the name of the library function corresponding
with a library and an offset (offset must be negative).
You must have loaded the corresponding fd-file first.
Only the 16 least significant bits of <offset> are used.

This command is the reverse of 'libinfo'.

This command returns a string if called from ARexx.

Other help: libfuncs loadfd_cmd libinfo_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Command: list_cmd
-----------------

   List [<list>]


With arguments this command lists the current list. With an argument
'list' lists <list> :-)

Other help: syslists
            ¯¯¯¯¯¯¯¯
===
@Command: memory_cmd
-------------------

   Memory [<start> [<bytes>]]


This command shows memory beginning at <start>.
<bytes> bytes are shown.

With no arguments this command continues the memory list.

<bytes> is 20 lines for default.

Use the 'mode' command to install preferences for list memory:
   mode long         for longword grouping (default)
   mode byte         for byte grouping

Look at the 'view' command for a more powerful dump routine.

Other help: mode_cmd view_cmd lastmem_func
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: info_cmd
-----------------

   Info <object address> [<list>]


This command gives additional information about an object.
When this object is not in the current list you must specify the list
where this object belongs.
Note that the information this command gives will never be a BPTR. These
are automatically converted to APTR's.

Example:
   info task:track task
   info win:'test window' win
 or
   task
   info task:track
   info 'trackdisk.device'

Be cautious with this command. When you give wrong arguments to this
function you could crash the machine.

Other help: syslists list_cmd <list>_list
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Command: memtask_cmd
--------------------

   MEMTask <task>


Show memory for a task. This is the memory which is allocated via
AllocEntry and is attached to the task.

Other help: task_list
            ¯¯¯¯¯¯¯¯¯
===
@Command: remcrash_cmd
---------------------

   REMCrash <crash node>


When a task crashes, PowerVisor makes a crash node. You can find this
node in the Crsh list. You can remove this node with the remcrash command.
Note that this command will not remove the task. The task will simply be
left waiting for a signal that will never come.

Other help: crash
            ¯¯¯¯¯
===
@Command: loadfd_cmd
-------------------

   RC,<number of functions> <- LOADFd <library> <file-name>


This command loads a fd-file in memory. After you have loaded an fd-file
you can use the library functions defined in it.

Example:
   loadfd exec fd:exec_lib.fd

When a fd-file already exists, loadfd will do nothing.
The number of functions loaded is returned.
The pointer to the fd-file node is stored in the 'RC' variable.

Other help: libfuncs unloadfd_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: unlock_cmd
-------------------

   UNLOCk <pointer to a lock>


This command unlocks a lock. The pointer to the lock must be an APTR,
not a BPTR !

Other help: pathname_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: sync_cmd
-----------------

   SYNc


Use this command to synchronize PowerVisor with ARexx. Normally you can
execute an ARexx script (with 'rx') and while this script is executing
you can still use PowerVisor for other things. When you use this command,
PowerVisor will disable user input. Only ARexx commands are accepted.

Do not forget to 'async' in your ARexx script.

Other help: async_cmd rx_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Command: async_cmd
------------------

   ASYnc


Use this command to disable the synchronization enabled with 'sync'.

Other help: sync_cmd rx_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Command: clip_cmd
-----------------

   [RC,<Pointer to data>] <- CLIp <Clip name> [<Pointer to data> <Length>]


Install a new ARexx clip in the system or return the pointer to the
string in the RexxArg for the given clip name.

Pointer to data (when you ask a clip) is returned in 'RC'.

Other help: remclip_cmd assign_cmd rx_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Command: remclip_cmd
--------------------

   REMCLip <Clip name>


Remove an ARexx clip from the system.

Other help: clip_cmd assign_cmd rx_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Command: hide_cmd
-----------------

   HIde


Hide all output from commands issued from an ARexx script.
This is equivalent to using the '-' operator in front of a commandline
(when you are typing commands from PowerVisor).

Other help: unhide_cmd
            ¯¯¯¯¯¯¯¯¯¯
===
@Command: unhide_cmd
-------------------

   UNHide


Unhide all output from commands issued from an ARexx script.

Other help: hide_cmd
            ¯¯¯¯¯¯¯¯
===
@Command: front_cmd
------------------

   FROnt


Bring the PowerVisor screen to the front from within an ARexx script
(this is also the command to bring PowerVisor back from hold mode).
===
@Command: closewindow_cmd
------------------------

   CLOsewindow <window>


This command closes a window. The menu's are cleared. The DMRequest is
cleared. All requesters attached to this window are removed and the IDCMP
flags are set to zero.

Other help: closescreen_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: hunks_cmd
------------------

   HUnks <process>


Show all the hunks for a process
===
@Command: attach_cmd
-------------------

   <attach node> <- ATtach <command string> <code> <qualifier>
                    [('e' | 'c' | 'a')['+']]


This command attaches a command to a key. You can use this command to
initialize your functionkeys. A command attached to a key is also
called a macro.

Example:
   attach 'list' 80 0
      attaches
         list
      to the <F1> key.
   attach 'info task:\'trackdisk.device\' task' 81 2 e
      attaches
         info task:'trackdisk.device' task
      to the <F2> key with the <right-shift> pressed
      and when you press the key, PowerVisor will not add the command
      to the history buffer.

Use remattach to remove an attached key

If you do not want the command to be feedbacked on your screen if you
press the assigned key, you may want to precede the commandline with a '~'.

Example:
   attach '~list' 80 0

or you can use the 'e' option for a similar effect.

If you use the 'c' option, the command is not executed but simply put on
the commandline (on the cursor position) as if you had snapped the string.

The 'a' option is like the 'e' option except that the command is always
executed even if PowerVisor is busy doing something else. Be careful
with this option as you can crash PowerVisor with it. In general it is
best to only use simple commands with the 'a' option.

If you use '+' the original key will not be filtered out. After the default
behaviour for the key, the command is executed ('e') or the string is
copied to the commandline ('c').

Other help: remattach_cmd attc_list redirection
            ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Command: remattach_cmd
----------------------

   REMAttach <attach node>


Remove a macro.

Example:
   attc                    Goto the attachement list
   list                    To see all the keys
Node     Code Qualifier Command
-----------------------------------------------------------------------------
00C184E0   81         2 'info task:'trackdisk.device' task                  '
00C34268   80         0 'list                                               '
   remattach 00c34268      To remove the 'list' key

Other help: attach_cmd list_cmd syslists attc_list
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: closescreen_cmd
------------------------

   CLOSEScreen <screen>


This command closes a screen and all attached windows.

Other help: closewindow_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: log_cmd
----------------

   LOG [<logical window> <filename>]


This command enables or disables the logging of all output in a logical window
to a file. PowerVisor only supports one log file. If you open one for a logical
window, PV will automatically close the other log file (if there is one).

You can disable (and close) command logging if you give no arguments to
this command.

Other help: redirection to_cmd appendto_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: to_cmd
---------------

   <result> <- TO <file> <command>


Log the output of one command to a file. After the command has executed
restore the current log file.
<result> is the result returned by <command>.

Other help: log_cmd appendto_cmd
            ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: appendto_cmd
---------------------

   <result> <- APpendto <file> <command>


Log the output of one command to a file. After the command has executed
restore the current log file. The only difference with the 'to' command
is that the output is appended to a (possibly) existing file.
<result> is the result returned by <command>.

Other help: log_cmd to_cmd
            ¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Command: while_cmd
------------------

   WHile <command>


Repeatedly execute <command> until the return value of the <command>
is equal to 0
===
@Command: taskpri_cmd
--------------------

   TASKPri <task ptr> <priority>


Set the priority for a task.

Example:
   taskpri task:test -5
===
@Command: pathname_cmd
---------------------

   PAthname <lock>


This command prints the pathname for a lock. If <lock> does not point to
a lock, 'pathname' prints an error. Note that <lock> must be an APTR and
not a BPTR !

This command returns a string if used from ARexx.

Other help: unlock_cmd
            ¯¯¯¯¯¯¯¯¯¯
===
@Command: unloadfd_cmd
---------------------

   UNLoadfd <fd-file node>


Remove all functiondefinitions in a fd-file. You can find the
nodes for fd-files in the 'FDFi' list.
After this command you cannot use the library functions from this
fd-files anymore.

Other help: syslists loadfd_cmd libfuncs
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: script_cmd
-------------------

   <result> <- SCRIpt <script file> [<commandline>]


The 'script' command executes the <script file>.
PowerVisor will first search the file in the current directory and than
in the s:pv subdirectory which is the recommended place for scripts.
You can use comments in script files by preceding the line with ';'.

You can also execute machinelanguage scripts with this command.
See the 'Scripts' tutorial file for more info about ML-scripts.

Other help: go_cmd resident_cmd unresident_cmd
            ¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯¯
===
@Command: resident_cmd
---------------------

   RC,<Pointer to code> <- RESIdent [<filename>]


The 'resident' command loads a given file (with 'LoadSeg') and stores a
pointer to the start of the program in 'RC'. You can use this pointer
with the 'go' command.

You can make ML-scripts resident but you must make sure that the
routines are pure.

If you give no argument to 'resident' you will get a list with all
loaded code pointers.

This command returns the pointer to the code in 'RC'.

Other help: unresident_cmd script_cmd go_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Command: unresident_cmd
-----------------------

   UNResident <Pointer to code>


Unload a file loaded with 'resident'. All resident files are automatically
unloaded when PowerVisor quits.

Other help: resident_cmd script_cmd go_cmd
            ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Help general
------------
You can type one of the following for more information on a specific
item:

      help snap            for the screen snap feature
      help keys            for information about keys
      help input           for info about the input editing possibilities
      help redirection     for redirection to a file
      help files           for all the files PowerVisor uses
      help historybuf      the history buffer
      help portprint       for the portprint facility
      help autodefault     for the automatic default feature
      help templates       for the template feature
===
@Help templates
--------------
If you are not sure about the syntax for a command you can ask the
command template.


Examples :

   list?
   List [<list>]

   tr ?
   TRace [ 'n' <number> | 'b' | 'r' <register> | 'u'['t'] <address>
         | 'o'['t'] | 'c' <condition> | 's' | 'g'['t'] | 'h' | 'f'
         | 't' | 'j' ]

   openlw ?
   RC,<lwin> <- OPENLw <physical window> <logwin name> <cols> <rows>
                [<brother> <where> [<number of columns or lines>]]



To use this feature you must have PowerVisor-help and PowerVisor-ctrl
in your s: directory.
You can also show the template with the 'help' command :

   help list_tmp


The third example ('openlw ?') is a bit special. The '<-' arrow indicates
that the command returns something. In this case the command returns
something to the 'RC' variable and also to the command caller. If you want
to see the result of a command (without looking at the 'RC' variable) you
must use the group operator :

   result={openlw ...}
===
@Help files
----------
PowerVisor uses the following files:

      s:PowerVisor-startup
          script file with all the initialization commands you find
          useful. This file is not necessary.
      PowerVisor-menus (*)
          This file is only used by the AmigaDOS 2.0 version of
          PowerVisor. It contains the description of all menus
          used in PowerVisor. This file is not really needed, but
          you won't have any menus if you don't have this file
      PowerVisor-help (*)
          This is the help file. If this file does not exist, you have no
          online help.
          You can change the help file if you like. After you have changed
          it you must type:
              'makehelp PowerVisor-help PowerVisor-ctrl word 2'
          to update the PowerVisor-ctrl file.
      PowerVisor-ctrl (*)
          This is the control file for the help file. Without this file
          you have no online help. See the QuickHelp manual for more
          details about this help format.
      PowerVisor-errors (*)
          This file contains all errormessages. When this file is not
          available PowerVisor will print errornumbers rather than messages.
          You can change this file. Please make sure that each line in this
          file is 70 bytes long (return included).
      s:PowerVisor-config
          This file contains config information for PowerVisor. All things
          you can install with the 'mode' and 'prefs' commands are in this
          file. If this file is not present, default values are used.
      libs:powervisor.library
          This is the portprint library. PowerVisor needs this library.
      libs:reqtools.library
          This is a very powerful requester library (© Nico François).
          If this library is present PowerVisor will use it for requesters
          but this library is not strictly required
      s:pv/
          This subdirectory is the prefered subdirectory for scripts
          and structure definition files.
      pv:docs/
          This subdirectory is the directory that AmigaGuide or MultiView
          uses when reading the PowerVisor hypertext manual. If you want
          to use MultiView you must assign pv: to the root of the PowerVisor
          directory (containing the 'docs' subdirectory).

PowerVisor will search all filenames ending with (*) in the following
subdirectories :

      PROGDIR: (only for AmigaDOS 2.0) This is the subdirectory where
               the PowerVisor executable is located. If you have AmigaDOS 2.0
               this is the recommended place for the (*) files
      S:       If you have AmigaDOS 1.3 or earlier, this is the recommended
               place for the (*) files
      current  If the above failed, PowerVisor will look in the current
               directory
===
@Screen snap feature
-------------------
When you press the leftmousebutton PowerVisor will copy the word under
the mousepointer to the commandline.

Example:
   Let's say you want to list some information for a task
   You type:
      task                 to go to the current list 'task'
      list                 list all tasks
      memory input         to list the memory for the input device
                           task
   Let's say you want to continue the memory list at the second longword
   on your screen (in the memory list).
   Simply take your mouse and click on the longword you want.
   It will appear in the commandline.

Other help: mode_cmd
            ¯¯¯¯¯¯¯¯
===
@Help keys information
---------------------
You can interrupt a command at any time by pressing <Esc>.

When you want PowerVisor to appear. Simply press the hotkey
<Right-Alt>+<Right-Shift>+'/' (the key at the left of the <right-shift>)
to bring the PowerVisor screen in front of all other screens. This is
also the key to return from 'hold' mode (see the 'hold' command).

If your last command was a memory list (with 'memory' or 'view') or a
disassembly (with 'unasm') you can press <enter> to continue this listing.

Using the <Left-Alt> key in combination with the numeric keypad you can
scroll the logical window. With the <Tab> key you can select the logical
window to scroll (this is called the active logical window).

Using the <Ctrl> key in combination with the numeric keypad you can scroll
in the debug logical window.

To pause the output of PowerVisor use the <Right-Alt>+<Help> key.


Note that almost all these keys can be changed with the 'prefs' command.
For example, you could prefer <ctrl>-'C' instead of <Esc>.


Other help: hold_cmd memory_cmd unasm_cmd prefs_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Help input editing capabilities
-------------------------------
PowerVisors editing field is a stringgadget. You can use all editing
possibilities you have in any other stringgadget. In addition you
can use the 'snap' facility.
You can also use the 'history' facility.
The stringgadget is 400 chars long (default).

Other help: historybuf variables snap prefs_cmd
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Help redirection
----------------
You can redirect the output of a command to a file.

Example:
      log ram:outputfile
      list libs
      unasm $1000 50
      log

or to nil.

Example:
      -list
      (is useful when you log output to a file for example)

If you want no feedback you can use :

      ~list
      (This ~ operator is useful when you want to attach a command to
      a key for example)

Or no output and no feedback :

      ~-list      (Note ! don't change the order or it won't work)

If you only want to redirect one command you can use the 'to' command :

      to file list task

      or

      to file -list task

Other help: log_cmd attach_cmd to_cmd appendto_cmd
            ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯
===
@Help historybuf
---------------
PowerVisor has a history buffer (like ConMan or Shell).
The default number of lines for this history buffer is 20. You can specify
another number with:
   prefs history <lines>
lines must be between 2 and 1000.

Starting with PowerVisor V1.10 the history buffer behaves exactly like
the history buffer in the AmigaDOS 2.0 shell (except for the search
history feature, but this is provided in the standard s:PowerVisor-startup
file).

Use the <up> key to go to the previous command. Use the <down> key to go
back.

Other help: variables prefs_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Help portprint
--------------
Simply open the powervisor.library in your program and use the correct
functions.
Note that all output from these library function goes to the screen
(or window) of the master PowerVisor.

Look at 'pptest.asm' for an example.

   PP_InitPortPrint()
      This function initializes the msgport for you. You need only
      do this once. The result you get in d0 is the pointer to the
      replyport (or null if no success). Use this pointer in all
      following commands.
   PP_StopPortPrint(a0)
      Clear the msgports for portprint. You need only do this once.
      a0 is the pointer to the replyport (the result from InitPortPrint).
   PP_ExecCommand(a0,a1,a2,d0)
      This routine is provided for the use of the 'addfunc' command, but
      you are free to use it for your own purposes.
      a0 is the pointer to the replyport. a1 is a pointer to data (may
      be 0), a2 is a pointer to a commandstring that you want to execute.
      d0 is the size of the data (may be 0). When you call this routine
      PowerVisor will first make a copy of your data. PowerVisor will
      then execute the command (note ! PowerVisor will execute it, the
      calling task will only wait until PowerVisor is ready). The command
      that is executed will get the pointer to the copy of the data in
      the 'rc' variable. You can return a result from this command (using
      the 'void' command for example). This result will be returned in
      d0.
   PP_DumpRegs(a0)
      Dump all registers on the PowerVisor screen.
      a0 is the pointer to the replyport.
   PP_Print(a0,a1)
      Print one line of text on the PowerVisor screen.
      a0 is the pointer to the replyport.
      a1 is the pointer to the text to print.
      Note that the replyport may be null for this call. Also note that
      this means that your program will not wait for PowerVisor to answer
      the message. This means that if you use this function again soon after
      the first call you will only see the results of the last call
   PP_PrintNum(a0,d0)
      Print a number on the PowerVisor screen.
      a0 is the pointer to the replyport.
      d0 is the number to print.
      Note that the replyport may be null for this call. Also note that
      this means that your program will not wait for PowerVisor to answer
      the message. This means that if you use this function again soon after
      the first call you will only see the results of the last call
   PP_SignalPowerVisor(a0,d0)
      Internal function to signal PowerVisor. At this moment this is
      only used by the memory protection system to signal that there was
      a bus error (1 in d0) or a bus error where the offending task must
      be frozen (2 in d0, not supported yet).
      a0 is the pointer to the replyport.
      d0 is the number of the signal (only 1 or 2).
      Note that the replyport may be null for this call. Also note that
      this means that your program will not wait for PowerVisor to answer
      the message. This means that if you use this function again soon after
      the first call you will only see the results of the last call
===
@Help group_op
-------------
You can use the group operator to group several commands together for
sequential execution.

There are two possible forms:

   - As a command:
       {a=1000;b=2000;disp a*b}
     will execute a=1000, b=2000 and disp a*b in that order.

   - As an expression:
       disp {a=1000;b=2000;void a*b}+1
     will execute a=1000, b=2000 and void a*b in that order. Because
     'void' is the last command, the result from this command is taken
     as the result of the group operator. In this case this is 2000000.
     So the result on screen will be 2000001.

Other help: expressions disp_cmd void_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Help special_op
---------------
The special '@' operator is used for the registers of the current debug
task.

   When you are debugging a task you can display a register for this task
   with
      disp @d4
   or
      disp @pc
   or
      disp @sp
   or
      disp @a0

   You can also change registers
   with
      @d0=4


Other help: variables expressions debugging assignment_op linenr_op
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Help linenr_op
--------------
With the '#' linenumber operator you can ask the address for the given
linenumber for the currently loaded source. You can only use this operator
if you are debugging.

For example

   disp #20

will show the address of line number 20 (in memory) in the current loaded
source.


Other help: expressions debugging special_op
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Help autodefault
----------------
There are a lot of commands that expect arguments that quite often
reside in some list. Most of these commands only expect one type
of list. For these commands PowerVisor implements the autodefault
feature. Normally when you type a string as an integer argument,
this string will be interpretated as a member of the current list.
However, when a command uses autodefault, it can set it's own default
list. For example, the CloseWindow command should only be used
on windows. Therefore you can always use CloseWindow as if 'wins'
is the current list. Simply type closewindow with the title of
the window regardless of the current list.
If it should happen that you really want to closewindow something
else (you never know), you can always specify the list using the
list operator.

Here are some of the commands that use this feature and their current list
they use:
   RemFunc        : func
   LoadFd         : libs
   AddFunc        : libs
   UnloadFd       : fdfi
   RemCrash       : crsh
   Freeze         : task
   UnFreeze       : task
   Kill           : task
   TaskPri        : task
   Hunks          : task
   CurDir         : task
   RemStruct      : stru
   Interprete     : stru
   Peek           : stru
   APeek          : stru
   DUse           : dbug
   RemAttach      : attc
   Gadgets        : wins
   CloseWindow    : wins
   CloseScreen    : scrs
   RemHand        : ihan
   RemRes         : resm
   LINES          : lwin
   COLS           : lwin
   GETCOL         : lwin
   GETROW         : lwin
   SetFont        : lwin
   ColRow         : lwin
   ...

Other help: list_op syslists
            ¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Help debugging
--------------
PowerVisor has powerfull debugging features.
You can debug multiple tasks at the same time.

The following commands are available:

   debug          to control the debug tasks
   trace          to trace execution
   duse           to set a new debug task
   dscroll        scroll the debug logical window
   dstart         set the start address of the debug logical window
   dnexti         scroll to the next instruction
   dprevi         scroll to the previous instruction
   drefresh       refresh the debug display
   break          set breakpoints
   symbol         control symboltable
   source         control source
   watch          control watches

You can find the debug nodes in the 'dbug' list.

Also look at the 'prefs' command. You can install preferences for
the debug display.

Note: It is possible to set breakpoints in a program BEFORE PowerVisor
is started. These are not real breakpoints in the strict sense. When
you include an ILLEGAL instruction in your program PowerVisor will trap
the crash (if PowerVisor is running of course). Using 'debug t' with
the crashnode or tasknode you can then resume debugging starting at
that point. Make sure that 'mode patch' is installed to get consistent
results. If 'mode nopatch' is used PowerVisor will trap the crash too
late (before the guru in fact).

Only the master instance of PowerVisor can debug programs (the master
instance is the first running PowerVisor programs. All following
PowerVisor instances are slaves).

The disassembly in the debug display (either for the fullscreen debugger
or for the normal debugger) makes use of all loaded fd-files. That way
a JSR or a JMP to a library function will be disassembled with the name
of the library function instead of the offset.
In combination with the tag system (see 'addtag') and structures (see
'struct') PowerVisor will also print names for offsets in structures
instead of numbers.


Other help: debug_cmd trace_cmd duse_cmd syslists source_cmd watch_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
            break_cmd symbol_cmd getdebug_func dscroll_cmd dstart_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
            prefs_cmd addtag_cmd struct_cmd dnexti_cmd dprevi_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: dnexti_cmd
-------------------

   DNexti


Scroll to the next instruction in the fullscreen debugger. You can only use
this command when the 'debug' logical window is open (with 'dwin').


Other help: debug_cmd dwin_cmd dstart_cmd toppc_func botpc_func dscroll_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
            dprevi_cmd
            ¯¯¯¯¯¯¯¯¯¯
===
@Command: dprevi_cmd
-------------------

   DPrevi


Attempt to scroll to the previous instruction in the fullscreen debugger.
You can only use this command when the 'debug' logical window is open (with
'dwin').

Note that this command can fail because there is no unique way to determine
where the previous instruction is. Simply use this command again if you
see that things are not right. Chances are that everything will be
correctly disassembled the second (or third ...) time.


Other help: debug_cmd dwin_cmd dstart_cmd toppc_func botpc_func dscroll_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
            dnexti_cmd
            ¯¯¯¯¯¯¯¯¯¯
===
@Command: dscroll_cmd
--------------------

   DScroll <offset>


Scroll <offset> bytes up in the full screen debugger. You can only use this
command when the 'debug' logical window is open (with 'dwin'). <offset>
can be negative.

Other help: debug_cmd dwin_cmd dstart_cmd toppc_func botpc_func dnexti_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
            dprevi_cmd
            ¯¯¯¯¯¯¯¯¯¯
===
@Command: dstart_cmd
-------------------

   DSTart <address>


Set the start of the debug logical window. You can only use this
command when the 'debug' logical window is open (with 'dwin').

Other help: debug_cmd dwin_cmd dscroll_cmd toppc_func botpc_func dnexti_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
            dprevi_cmd
            ¯¯¯¯¯¯¯¯¯¯
===
@Function: toppc_func
--------------------

   TOPPC( )


This function returns the program counter visible at the top of the 'debug'
logical window.
You can set this program counter using the 'dstart', 'dscroll', 'dnexti'
or 'dprevi' commands.

Other help: dscroll_cmd dstart_cmd botpc_func dwin_cmd dnexti_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
            dprevi_cmd
            ¯¯¯¯¯¯¯¯¯¯
===
@Function: botpc_func
--------------------

   BOTPC( )


This function returns the program counter visible at the bottom of the
'debug' logical window.
You can set this program counter using the 'dstart', 'dscroll', 'dnexti'
or 'dprevi' commands.

Other help: dscroll_cmd dstart_cmd toppc_func dwin_cmd dnexti_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
            dprevi_cmd
            ¯¯¯¯¯¯¯¯¯¯
===
@Command: debug_cmd
------------------

   RC <- DEBug 'n' [<number>] |
               'c' [<number>] |
               'l' <filename> |
               't' <task node> |
               'r' [<debug node>] |
               'f' [<debug node>] |
               'u' [<debug node>] |
               'd' <name> |
               'q' (0 | 1) |
               's' ['s' | 'a' <path> | 'c']


Use this command to control the debug tasks.


   debug n [<number>]
               Waits for the next 'LoadSeg' and make a debugtask from that
               process.
               If <number> is specified, 'debug n' will not wait for the
               next process, but for <number> processes (only the last
               one will be made a debug node)

   debug c [<number>]
               Waits for the next 'AddTask' and make a debugtask from that
               task.
               If <number> is specified, 'debug c' will not wait for the
               next task, but for <number> tasks (only the last one
               will be made a debug node). This feature is useful if you
               want to debug a task that is started directly after a
               process starts

   debug l <filename>
               Load an executable program to debug.
               Symbols are automatically loaded if they exist.
               Warning ! If you use the AmigaDOS 1.3 version, PowerVisor
               will NOT create a CLI for the loaded program. Therefore
               it is better to use 'debug n' if possible. In AmigaDOS 2.0
               the CLI structure is properly allocated (using
               'CreateNewProc')

   debug t <task node>
               Take an existing running task to debug.
               You can also take a crash node to debug. In that case
               you can singlestep the task from where it crashed.

   debug f     Remove the current debugnode and freeze the task

   debug f <debug node>
               Remove the specified debugnode and freeze
               This command is mostly used when 'debug n' or 'debug t' was
               used to start the debugging.

   debug r     Remove the current debugnode.
               The task will simply continue executing from where it
               was interrupted.
               This command is mostly used when 'debug n', 'debug c' or
               'debug t' was used to start the debugging
               If you have AmigaDOS 2.0 you may also use 'debug r' with
               'debug l'

   debug r <debug node>
               Remove the specified debugnode.

   debug u     Remove the current debugnode.
               The task will be stopped ('RemTask') and the program will
               be unloaded (UnLoadSeg) if the debug task was loaded with
               'debug l'. This command is mostly used when 'debug l' was
               used
               If you have AmigaDOS 2.0 you may also use 'debug u' with
               'debug n'

   debug u <debug node>
               Remove the specified debugnode.

   debug d <name>
               Create dummy debugnode for symbols only.

   debug q 0   Cleanup everything when the current debug task quits. This
               is default.

   debug q 1   Prevent the current debug task from quiting. This is useful
               in combination with the profiler ('prof' command). When the
               debug task wants to quit, it will be stopped with an
               ILLEGAL exception. At that moment you can examine the
               profiling table before everything would have been cleaned
               up. If you want to continue the real quiting of the program
               you should use 'trace s' (to skip the 'illegal'
               instruction) and 'trace g' (to execute the quit routine).
               Warning!!! Don't singlestep the code after the 'illegal'
               instruction. If you do, this routine will NOT work and
               the system may crash!

   debug s     Show the path that will be used to locate the source for the
               source-level debugger. By default this only consists of the
               current directory.

   debug s s   Like 'debug s'

   debug s a <path>
               Add a new path. PowerVisor will use this extra path when trying
               to find the source during source-level debugging. Don't forget
               to terminate this path with ':' or '/'.

   debug s c   Clear the path completely.


When a new debug task is created, it is taken from the task list
and put in the 'dbug' list. The current debug task is set to the
new debug task.

Note that the 'debug' command is not allowed for slave instances
of PowerVisor.


Other help: debugging duse_cmd trace_cmd break_cmd prof_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
            symbol_cmd dbug_list watch_cmd
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: drefresh_cmd
---------------------

   DRefresh


This command refreshes the debug display.


Other help: debugging debug_cmd duse_cmd watch_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: duse_cmd
-----------------

   DUse <debug node>


Set the current debug task.
Use the debug function to determine the current debug node.


Other help: debugging debug_cmd trace_cmd watch_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
            break_cmd getdebug_func symbol_cmd drefresh_cmd with_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: with_cmd
-----------------

   <result> <- WITh <debug node> <command>


This command temporarily sets another current debug task and executes
<command>. This is useful if you want to view memory with another set
of symbols.
<result> is the result returned by <command>.


Example:

   with MyBuggyProgram memory 070540

Other help: debugging debug_cmd trace_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ 
            break_cmd getdebug_func symbol_cmd drefresh_cmd duse_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Function: getdebug_func
-----------------------

   GETDEBUG( )


Return the current debug node.

Other help: duse_cmd with_cmd dbug_list debug_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Function: getsymstr_func
------------------------

   GETSYMSTR( <address> )


Return the pointer to the string for the symbol on <address>. If there
is no symbol on <address>, this function returns 0.

This command returns a string if used from ARexx.


Other help: dbug_list debug_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: trace_cmd
------------------

   TRace [ 'n'['f'|'r'] <number> |
           'g'['t'|'f'|'r'] |
           't' |
           'o'['t'] |
           'u'['t'] <address> |
           'r'['f'|'r'] <register> |
           'c'['f'|'r'] <condition> |
           'q'['f'|'r'] <condition> |
           'j'['f'|'r'] |
           'p'['f'|'r'] |
           'z'['f'|'r'] <addr> <len> |
           'b' |
           's' |
           'i' |
           'h' |
           'f' ]


Use this command to singlestep a program (Use 'debug' first to make
a debug task).

Many trace commands can be used with some extra options. These options
control when the 'trace check' should be performed. The 'trace check' is
different for each trace command. For example 'trace r' checks if the
specified register changed.

      t     Use singlestep mode instead of execute mode. This means that
            the program is executed instruction by instruction and the
            'trace check' is examined at each instruction. This is very
            slow but very accurate. For example, if you want to trace
            until a certain register changes you get very accurate
            results with this option: the program will immediately
            stop just after the instruction that changed the register.
            'previous instruction' in the debug display will show the
            previously executed instruction. Singlestep mode is default
            for some trace commands.

      f     Use flow mode. In this case the program is halted at each
            change of programflow and the 'trace check' is only performed
            at that moment (this is just AFTER the execution of the
            instruction causing the change of flow). Flow mode is less
            accurate that singlestep mode but it is a lot faster (this
            depends on the number of branches in the program of course).
            This feature only works with the 68020 (or higher) processor.
            If you have a 68000 or 68010 processor PowerVisor will not
            complain but use singlestep mode instead. When the tracing
            stops the 'previous instruction' in the debug display will
            show the last instruction causing the change of flow. If
            you have a 68020 or higher this is often the recommended
            option because it is fast and reasonably accurate.

      r     Use routine trace mode. This mode is equivalent to singlestep
            mode. The difference is that BSR and JSR instructions are
            executed at full speed. This means that singlestepping is
            restricted to the current routine. This is useful if you want
            to restrict the 'trace check' to the current routine. Routine
            trace mode can be faster than singlestep mode if the BSR and
            JSR subroutines are very large. It is also very accurate but
            only in the current subroutine.



   trace                   Trace one instruction.

   trace n <number>        Trace <number> instructions
                           (singlestep mode).

   trace nr <number>       The same as 'tr n' but stay in the current
                           subroutine
                           (routine trace mode).

   trace nf <number>       Trace <number> successful branches. Tracing
                           is done in flow mode (only 68020 or higher)
                           (flow mode).

   trace g                 Execute until a breakpoint is encountered.
                           There is no 'trace check' for this trace command
                           (execute mode).

   trace gt                The same as 'tr g'
                           (singlestep mode).

   trace gr                The same as 'tr g'
                           (routine trace mode).

   trace gf                The same as 'tr g'
                           (flow mode).

   trace t                 Skip BSR or JSR. If not a BSR or JSR simple
                           trace is used. This command also works in ROM
                           (execute mode).

   trace o                 Trace over the current instruction. This command
                           does not work in ROM
                           (execute mode).

   trace ot                The same as 'tr o' but this command works in ROM
                           (singlestep mode).

   trace u <address>       Trace until the programcounter is equal to
                           <address>. This command does not work in ROM
                           (execute mode).

   trace ut <address>      The same as 'tr u' but this command works in ROM
                           (singlestep mode).

   trace r <register>      Trace until a specified register is changed
                           register can be d0-d7, a0-a7 or sp.
                           (singlestep mode).

   trace rr <register>     The same as 'trace r'
                           (routine trace mode).

   trace rf <register>     The same as 'trace r'
                           (flow mode).

   trace c <condition>     Trace until a condition is satisfied. This
                           condition is a string. Example :
                           trace c '@d1==@d2' will trace until register
                           d1 is equal to register d2
                           (singlestep mode).

   trace cr <condition>    The same as 'tr c'
                           (routine trace mode).

   trace cf <condition>    The same as 'tr c'
                           (flow mode).

   trace q <condition>     Also trace until a condition is satisfied (the
                           same as 'trace c'). The difference is that this
                           command traces a lot faster but the conditions
                           are more limited. Expressions must have the
                           following form : <register><operator><value>
                           with <register> one of @d0..@d7, @a0..@a7 or
                           @sp and <operator> one of <, >, <=, >=, == or !=
                           Some examples :
                              trace q '@d0<100' (trace until d0 < 100)
                              trace q '@a5==0'
                              trace q '@d0!=@d0'
                           The last example may look a little strange:
                           'trace until register d0 is different from
                           register d0' !!! However the second @d0 is
                           evaluated at the moment of the 'trace' command.
                           This means that you must read the last command
                           as :
                              trace q '@d0!=<current value of d0>'
                           (singlestep mode).

   trace qr <condition>    The same as 'tr q'
                           (routine trace mode).

   trace qf <condition>    The same as 'tr q'
                           (flow mode).

   trace j                 Trace until a library ROM function is used:
                           JSR or JMP (a6).
                           (singlestep mode).

   trace jr                The same as 'tr j'
                           (routine trace mode).

   trace jf                The same as 'tr f'
                           (flow mode).

   trace p                 Profile tracing. With this command PowerVisor
                           will remember how many times each symbol in
                           your program is passed. Because the program is
                           singlestepped these numbers are exact. Use the
                           'prof' command ('prof l') to see the list with
                           all used symbols (also see there for a more
                           detailed discussion on 'profile tracing'). Note
                           that profile tracing is rather slow and
                           probably only useful for smaller routines.
                           If you want faster profile tracing you should
                           use 'tr pf' (below).
                           (singlestep mode).

   trace pr                The same as 'tr p'
                           (routine trace mode).

   trace pf                The same as 'tr p'
                           (flow mode).

   trace z <addr> <len>    Trace until the checksum for the given memory
                           range changes. <addr> and <len> are converted
                           to longword alligned values
                           (singlestep mode).

   trace zr <addr> <len>   The same as 'tr z'
                           (routine trace mode).

   trace zf <addr> <len>   The same as 'tr z'
                           (flow mode).

   trace b                 Trace until just before the next successful branch
                           (singlestep mode).

   trace s                 Skip an instruction

   trace i                 Do not trace. Simply show the current registers
                           and instructions. Note that this disassembly is
                           smart. All references to library functions are
                           disassembled with the correct library function
                           name (if there is a fd-file loaded for that
                           library), and in combination with the tag system
                           and structures (see 'addtag') offsets in
                           structures are also disassembled with the name
                           of the offset instead of a number.
                           Warning! If you use the fullscreen debugger with
                           the 'fdebug' alias 'tr i' will do nothing. This
                           is because the 'fdebug' alias disables the
                           output from this command with the 'prefs dmode'
                           command.

   trace h                 Interrupt the tracing or executing of the
                           current debug task.

   trace f                 Interrupt the tracing or executing of the
                           current debug task as soon as this task is
                           in ready state.


Other help: debugging debug_cmd duse_cmd break_cmd addtag_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
            symbol_cmd watch_cmd
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: break_cmd
------------------

   RC <- Break 'a' <address> <timeout> |
               'c' <address> <condition> |
               'n' <address> |
               't' <address> |
               'p' <address> |
               'r' <breakpoint number>


Install a breakpoint for the current debugtask. These breakpoints are
automatically numbered starting with 1. If you remove a breakpoint this
number can be reused for new breakpoints.


   break a <address> <timeout>   Breakpoint only breaks after the <timeout>
                                 counter becomes zero.

   break c <address> <condition> Only break if the condition is true.

   break n <address>             Normal breakpoint.

   break t <address>             Temporary breakpoint.

   break p <address>             Profiler breakpoint. Does not break. Only
                                 increments a counter.

   break r <breakpoint number>   Remove a breakpoint. You can get a list of
                                 all breakpoints with the 'info' command :
                                    info getdebug() dbug <enter>


Example :
   break c 00c05320 '(@d0<@d1)&&(@pc>00c05380)'

      This breakpoint will cause a break if d0 is lower than d1 and
      the programcounter is greater than 00c05380 (a bit stupid to
      include the programcounter in such an expression because the
      breakpoint is on a fixed position :-)


Other help: debugging debug_cmd duse_cmd watch_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
            break_cmd trace_cmd symbol_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: source_cmd
-------------------

   SOurce 'l' <filename> [<hunkaddress>] |
          'w' <address> |
          's' |
          't' <tab size> |
          'r' |
          'c' |
          'g' <line> |
          'a' <address> |
          'h' <hold mode>


Control the source for the current debugtask. Note that the source
for the current debug task is always displayed in the 'Source' logical
window. You must compile or assemble your program with debug hunk
information if you want to use this feature. PowerVisor currently
understands the debug hunk format used by 'Macro68' (include the 'debug'
statement in your source) and by 'SAS/C' (compile with '-d1', do not
use any number other than 1!). This format is also compatible with the
debug hunk format used by Devpac3. The 'source' command could work for
other compilers too but this is not tested.

When you have loaded the source for a program you can use the '#' operator
(help linenr_op).

When PowerVisor can't simply load the source, it will try to locate the
source in the source path. This path can be set with the 'debug' command.


   source l <filename> [<hunkaddress>]
               Load the source for the current debug task.
               <filename> is the name of the executable file and not
               the name of the source file!
               If you give <hunkaddress>, PowerVisor will load the source
               for the given hunks. This is extremely useful when you have
               created a dummy debug task.
               Note that <hunkaddress> is 4 more than the number given in
               the hunklist with the 'hunks' command.
               Note that <hunkaddress> is not optional when you are loading
               the source for a dummy debug task

   source t <tab size>
               Set the tab size used for the source display. The default
               tab value is 8

   source s
               Show all sources for the current debug task

   source r
               Redisplay the source in the 'Source' logical window

   source c
               Clear all sources and unload them

   source w <address>
               Use this command to see in which source file and on which
               line a specific address is located

   source a <address>
               Display the right source at the right linenumber for
               <address>

   source g <line>
               Goto a line in the current loaded source. Note that you can
               also scroll in the current file with the mouse. Simply press
               the left mouse button in the first or the last line of the
               'Source' logical window

   source h <hold mode>
               If <hold mode> = 0 the source logical window will follow
               the program counter if possible (default).
               If <hold mode> = 1 the source logical window will remain
               locked on its current position (you can still scroll with
               the keys, 'source g' and 'source a', but the source logical
               window will not follow the program counter)


Other help: debugging debug_cmd trace_cmd duse_cmd watch_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
            break_cmd trace_cmd symbol_cmd linenr_op
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
===
@Command: symbol_cmd
-------------------

   SYmbol 'l' <filename> [<hunkaddress>] |
          'c' |
          'a' <symbol> <value> |
          'r' <symbol> |
          's' |
          't'


Control the symboltable for the current debugtask.


   symbol l <filename> [<hunkaddress>]
               Load the symbols for the current debug task.
               <filename> is the name of the executable file and not
               the name of the source file!
               If you give <hunkaddress>, PowerVisor will load the symbols
               for the given hunks. This is extremely useful when you have
               created a dummy debug task.
               Note that <hunkaddress> is 4 more than the number given in
               the hunklist with the 'hunks' command.
               Note that <hunkaddress> is not optional when you are loading
               symbols for a dummy debug task.

   symbol c    Clear all the symbols for the current debug task.

   symbol t    Remove all temporary symbols for the current debug task.
               Temporary symbols are all symbols starting with a dot '.'
               and all symbols containing only digits and ending with
               a '$'. This command may take some time to execute if you
               have a lot of temporary symbols.

   symbol a <symbol> <value>
               Add a symbol with a specified value the the symbol list
               for the current debug task.

   symbol r <symbol>
               Remove a symbol from the symbol list for the current
               debug task.

   symbol s    List all symbols for the current debug task.


Other help: debugging debug_cmd trace_cmd duse_cmd watch_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯
            break_cmd trace_cmd source_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: watch_cmd
------------------

   WAtch 'c' |
         'a' <value> |
         'r' <value> |
         's'


Control the watches for the current debugtask.
Watches are memory locations that are shown in a watch window.
This window is refreshed whenever a debugging action occurs.
Use the 'wwin' command to open the watch logical window.


   symbol c    Clear all watches for the current debug task.

   symbol a <value>
               Add a watch for the current debug task.

   symbol r <value>
               Remove a watch.

   symbol s    List all watches with their contents.
               If a contents changed since the previous listing
               it will be hilighted.


Other help: debugging debug_cmd trace_cmd duse_cmd wwin_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
            break_cmd trace_cmd source_cmd symbol_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: rblock_cmd
-------------------

   RC,<address> <- RBlock <Unit number> <block number> [<address>]


Read a block from a disk. This command will allocate the memory for it
if you do not specify <address>. The pointer to this memory will be
stored in RC. You can read a block in your own memory if you specify
the address. This address must be in chip ram.
You can free the memory this command allocated with 'free'.

When you let 'rblock' allocate the memory for you you can also free
this memory with 'cleanup'. It will also be cleaned up when you
quit PowerVisor.


Other help: wblock_cmd alloc_func free_func variables cleanup_cmd
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Function: base_func
-------------------

   BASE()


This function returns the ptr to the first element in the current list.

Example:
> task           ;Goto the task list
> list           ;To get the following output:
Task node name      : Node     Pri   StackU   StackS Stat Command         Acc
-----------------------------------------------------------------------------
ConClip Process     : 07E60410 00       242     4000 Wait sys:c/ConCl(02) -
RexxMaster          : 07E6AA48 04       162     2048 Wait            (00) -
« IPrefs »          : 07E59568 00       862     3500 Wait            PROC -
ClickToFront        : 07E75210 15       398     4096 Wait            PROC -
CpuBlit             : 07E7BA18 00       266     2048 Wait            PROC -
AltMenuCom          : 07E8FDC0 00       198     3000 Wait            PROC -
...
SCSI handler        : 07E0A318 0C        98     1000 Wait            TASK -
scsi.device         : 07E096E0 0B        94     1000 Wait            TASK -
PowerVisor.task     : 07E7B4F0 00        82     4096 Wait            TASK -
trackdisk.device    : 07E0E714 05        98      512 Wait            TASK -
DH2                 : 07E23770 0A       130     2400 Wait            PROC -
input.device        : 07E07F12 14        86     4096 Wait            TASK -
RAM                 : 07E31220 0A       678     1200 Wait            PROC -
pv                  : 07F62FC0 04       438    16000 Run  pv         (01) -

> d base()       ;And you get:
07E60410 , 132514832


Other help: list_cmd lists
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯
===
@Command: void_cmd
-----------------

   <result> <- Void {<argument>...}


This command does absolutely nothing except evaluating it's arguments.
You can use this command to execute library functions. It is also useful
to return a result from a command group. And finaly you can use it to
copy a PowerVisor variable to ARexx.

Other help: arguments integers expressions disp_cmd
            ¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: wblock_cmd
-------------------

   WBlock <Unit number> <block number> <address>


Write a block to disk. <address> must be in chip ram.
A block is 1024 bytes big.

Other help: rblock_cmd
            ¯¯¯¯¯¯¯¯¯¯
===
@Command: opendev_cmd
--------------------

   RC,<pvdevice> <- Opendev <device name> [<unit> [<flags>]]


Open a device for use with the 'closedev','devinfo' and 'devcmd' commands.
The result (in RC) is a pointer to a block containing the pointer to the
port and the pointer to the IORequest (256 bytes big) in that order.
Use this block as the argument to 'closedev','devinfo' and 'devcmd'.

Example:
   opendev "trackdisk.device"
   dev=rc
   devcmd dev 9 0 1              ;Put the drive motor on
   ...
   devcmd dev 9 0 0              ;Off again
   devinfo dev
   closedev dev

The first two lines in this example could also be written as:

   dev={opendev "trackdisk.device"}


Other help: closedev_cmd devcmd_cmd devinfo_cmd group_op
            ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯
===
@Command: closedev_cmd
---------------------

   CLOSEDev <device block>


Close a device opened with 'opendev'.

Other help: opendev_cmd devcmd_cmd devinfo_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Command: devinfo_cmd
--------------------

   DEVInfo <device block>


Show port and iorequest information for a device opened with 'opendev'.

Other help: opendev_cmd closedev_cmd devcmd_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Command: devcmd_cmd
-------------------

   RC <- DEVCmd <dev> <command> [<flags> [<length> [<data> [<offset>]]]]


Give a command to a device opened with 'opendev'. The parameters specified
are for the IORequest. If you do not specify these parameters ('flags',...)
the IORequest will remain unchanged.

Other help: opendev_cmd closedev_cmd devinfo_cmd
            ¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯¯
===
@Command: remhand_cmd
--------------------

   REMHand <input handler>


Remove an input handler. You can list the inputhandlers in the 'IHan' list.

Other help: syslists
            ¯¯¯¯¯¯¯¯
===
@Command: go_cmd
---------------

   <result> <- GO <address> [<commandline>]


Start executing at <address>.
You can make inline code with this command.
The register are preset to certain values (see the 'script' command).

Example:
   go "Nu"  does nothing because "Nu" is a 'RTS'.

Other help: script_cmd pvcall_cmd
            ¯¯¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Lists: exec_list
----------------

   Exec

This is the listing of the ExecBase.
You can use the listaddress operator to change values in this list.
'Info' is not possible.
There is more info in DOS 2.0.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: intb_list
----------------

   Intb

This is the listing of the IntuitionBase.
You can use the listaddress operator to change values in this list.
'Info' is not possible.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: graf_list
----------------

   Graf

This is the listing of the Graphics base.
You can use the listaddress operator to change values in this list.
'Info' is not possible.
There is more info in DOS 2.0.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: task_list
----------------

   Task

This is the listing of all the current tasks and processes.
The listaddress operator is not available.

Simple information ('list'):
   Task node name    : name for this task or process
   Node              : pointer to this node
   Pri               : task priority
   StackU            : current stackusage
   StackS            : stacksize
   Stat              : task state: (wait,rdy,run,cold,...)
   Command           : command if process is a cli followed by
                       an indication 'TASK', 'PROC' or cli number
   Acc               : accounting info if account is enabled

Expanded information ('info'):
   If task: listing of task structure
   if process: listing of task structure and process structure
   if cli: listing of task, process and cli structure

There is more info in DOS 2.0 (for Process).

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: libs_list
----------------

   Libs

This is the listing of all the available libraries.
The listaddress operator is not available.

Simple information ('list'):
   Library node name : name for this library
   Node              : pointer to this node
   Pri               : library priority
   NegSize           : negative library size
   PosSize           : postive library size
   Sum               : checksum
   OpenCnt           : library usage count

Expanded information ('info'):
   You get the idstring, version and revision of this library.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: devs_list
----------------

   Devs

This is the listing of all the available devices.
The listaddress operator is not available.

Simple information ('list'):
   Device node name  : name for this device
   Node              : pointer to this node
   Pri               : device priority
   NegSize           : negative device size
   PosSize           : postive device size
   Sum               : checksum
   OpenCnt           : device usage count

Expanded information ('info'):
   You get the idstring, version and revision of this device.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: reso_list
----------------

   Reso

This is the listing of all the available resources.
The listaddress operator is not available.

Simple information ('list'):
   Resource node name: name for this resource
   Node              : pointer to this node
   Pri               : resource priority
   NegSize           : negative resource size
   PosSize           : postive resource size
   Sum               : checksum
   OpenCnt           : resource usage count

Expanded information ('info'):
   You get the idstring, version and revision of this resource.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: memr_list
----------------

   Memr

This is the listing of all the available memory lists.
The listaddress operator is not available.

Simple information ('list'):
   Memory node name  : name for this memorylist
   Node              : pointer to this node
   Pri               : memory priority
   Attr              : attributes needed with AllocMem
   First             : first free memory chunk
   Lower             : lower memory
   Upper             : upper memory
   Free              : free memory

Expanded information ('info'):
   For each free memoryblock you get the pointer and the size.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: intr_list
----------------

   INTR

This is the listing of all the available interrupts.
The listaddress operator is not available.

Simple information ('list'):
   Interrupt node name : name for this interrupt
   Node                : pointer to this node
   Pri                 : interrupt priority
   Data                : pointer to data
   Code                : pointer to code

Expanded information ('info'):
   ?

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: port_list
----------------

   Port

This is the listing of all the available message ports.
The listaddress operator is not available.

Simple information ('list'):
   MsgPort node name : name for this MsgPort
   Node              : pointer to this node
   Pri               : port priority
   SigBit            : signal bit
   SigTask           : task to signal

Expanded information ('info'):
   No more information (in future I will list all pending messages).

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: wins_list
----------------

   Wins

This is the listing of all the available windows on all screens.
The listaddress operator is not available.

Simple information ('list'):
   Window name       : window title
   Address           : pointer to this window
   Left              : leftedge
   Top               : topedge
   Width             : width
   Height            : height
   WScreen           : window screen

Expanded information ('info'):
   A listing of the window structure.

There is more info in DOS2.0.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: scrs_list
----------------

   Scrs

This is the listing of all the available screens.
The listaddress operator is not available.

Simple information ('list'):
   Screen name       : screen title
   Address           : pointer to this screen
   Left              : leftedge
   Top               : topedge
   Width             : width
   Height            : height
   FirstWindow       : first window

Expanded information ('info'):
   A listing of the screen structure.

There is more info in DOS2.0.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: font_list
----------------

   Font

This is the listing of all the available fonts.
The listaddress operator is not available.

Simple information ('list'):
   Font node name    : font name
   Node              : pointer to this node
   Pri               : font priority
   YSize             : y size
   XSize             : x size
   Style             : style flags
   LoChar            : lowest defined character
   HiChar            : highest defined character

Expanded information ('info'):
   A listing of the font structure.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: dosd_list
----------------

   DOsd

This is the listing of all the available dos devices.
The listaddress operator is not available.

Simple information ('list'):
   Dos device name   : name for device
   Address           : pointer to this device
   Type              : device, volume or directory
   Task              : pointer to task
   Lock              : pointer to lock
   LockList          : pointer to outstanding locks
   DiskType          : disktype

Expanded information ('info'):
   No more information.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: func_list
----------------

   FUnc

This is the listing of all the available function monitor nodes.
The listaddress operator is not available.

Simple information ('list'):
   Function monitor  : function name we are monitoring
   Node              : pointer to this node
   Library           : library this function belongs to
   Offset            : offset for this function
   TrapTask          : last task using this function
   Count             : usage counter
   Type              : LED or NORM

   if Type is LED, TrapTask and Count are zero.

Expanded information ('info'):
   If type is LED: no more info
   If type is NORM: the last 8 tasks using this function.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: sema_list
----------------

   SEma

This is the listing of all the available semaphores.
The listaddress operator is not available.

Simple information ('list'):
   Semaphore name    : name for semaphore
   Node              : pointer to this node
   Pri               : semaphore priority
   NestCount         : ?
   QueueCount        : ?
   Owner             : semaphore owner

Expanded information ('info'):
   ?

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: resm_list
----------------

   RESM

This is the listing of all the available resident modules.
The listaddress operator is not available.

Simple information ('list'):
   Resident name     : name for resident structure
   Address           : pointer to this resident module
   Pri               : priority
   Version           : resident version
   Flags             : flags
   IDString          : id string

Expanded information ('info'):
   No more info.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: fils_list
----------------

   FIls

This is the listing of all open files. (note that the files listed are
in fact locks).
The listaddress operator is not available.

Simple information ('list'):
   FileName          : name for file
   Lock              : pointer to this lock
   Access            : access type (READ or WRITE)
   Size              : current file size
   Key               : disk key

Expanded information ('info'):
   No more info.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: lock_list
----------------

   LOck

This is the listing of all locks.
The listaddress operator is not available.

Simple information ('list'):
   FileName          : name for lock
   Lock              : pointer to this lock
   Access            : access type (READ or WRITE)
   Size              : current file size
   Key               : disk key

Expanded information ('info'):
   No more info.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: ihan_list
----------------

   IHan

This is the listing of all input handlers.
The listaddress operator is not available.

Simple information ('list'):
   Handler name      : name for input handler
   Node              : pointer to this node
   Pri               : input handler priority
   Data              : pointer to inputhandler data
   Code              : pointer to inputhandler code

Expanded information ('info'):
   No more info.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: fdfi_list
----------------

   FDfi

This is the listing of all loaded fdfiles.
The listaddress operator is not available.

Simple information ('list'):
   Library name      : name for this fd file
   Node              : pointer to this node
   Library           : pointer to library
   Funcs             : number of functions loaded

Expanded information ('info'):
   A list of all library functions loaded.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: attc_list
----------------

   Attc

This is the listing of all macros.
The listaddress operator is not available.

Simple information ('list'):
   Node              : pointer to this node
   Code              : key code
   Qualifier         : key qualifier
   Command           : corresponding command

Expanded information ('info'):
   No more info.

Other help: syslists info_cmd list_cmd base() attach_cmd
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯¯¯
===
@Lists: crsh_list
----------------

   Crsh

This is the listing of all crashed tasks.
The listaddress operator is not available.

Simple information ('list'):
   Node              : pointer to this node
   Task              : pointer to crashed task
   TrapNr            : trapnumber or gurunumber
   2ndInfo           : 2nd info (for guru only)
   Guru              : 0 if task held, 1 if guru

Expanded information ('info'):
   No more info.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: dbug_list
----------------

   DBug

This is the listing of all debug tasks.
The listaddress operator is not available.

Simple information ('list'):
   Debug task        : name of the task to debug
   Node              : pointer to this node
   Task              : pointer to task
   InitPC            : initial pc for task

Expanded information ('info'):
   The listing of all breakpoints:
      Node           : pointer to breakpoint node
      Number         : breakpoint number
      Where          : breakpoint address
      UsageCnt       : breakpoint usagecount
      Type           : type of breakpoint
      Condition      : break condition (if Type='C')

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: stru_list
----------------

   STru

This is the listing of all structure definitions.
The listaddress operator is not available.

Simple information ('list'):
   Structure name    : name of the structure
   Node              : pointer to this node
   Pri               : priority
   InfoBlock         : pointer to structure definition
   Strings           : pointer to field string block

Expanded information ('info'):
   None.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: conf_list
----------------

   COnf

This is the listing of all auto configs.
The listaddress operator is not available.

Simple information ('list'):
   Config name       : name of autoconfig node
   Node              : pointer to this node
   Pri               : autoconfig priority
   Flags             : autoconfig flags
   BAddr             : BoardAddress
   BSize             : BoardSize
   Driver            : Driver

Expanded information ('info'):
   The listing of the config structure.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: moni_list
----------------

   MOni

This is the listing of all available monitors (only DOS 2.0).
The listaddress operator is not available.

Simple information ('list'):
   Monitor name      : name of monitor
   Node              : pointer to this node
   Pri               : monitor priority
   SubSys            : subsystem of monitor
   SubType           : subtype of monitor
   Library           : library for monitor
   Init              : Init routine

Expanded information ('info'):
   The listing of the monitor structure.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: pubs_list
----------------

   PUbs

This is the listing of all public screens (only DOS 2.0).
The listaddress operator is not available.

Simple information ('list'):
   PubScreen name    : name of public screen
   Node              : pointer to this node
   Pri               : priority
   Screen            : pointer to screen
   Visitors          : number of visitors on public screen
   SigTask           : task to signal
   SigBit            : signal bit

Expanded information ('info'):
   The listing of the public screen structure.

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: lwin_list
----------------

   LWin

This is the list of all logical windows in PowerVisor. There is always
at least one logical window (Main) in this list. Some other possible logical
windows are: Rexx, PPrint, Refresh, Extra and Debug.

Simple information ('list'):
   Logical win name  : name of logical window
   Node              : pointer to this node
   PWin              : pointer to physical window
   width             : visible width of logical window
   height            : visible height of logical window
   col               : current column
   row               : current row
   viscol            : first visible column
   visrow            : first visible row

Expanded information ('info'):
   The complete listing of the 'LogWin' structure (see 'TheWizCorner.guide'
   for more info).

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@Lists: pwin_list
----------------

   PWin

This is the list of all physical windows in PowerVisor. There is always
at least one physical window (Main) in this list.

Simple information ('list'):
   Physical win name : name of physical window
   Node              : pointer to this node
   Window            : pointer to the Intuition window
   Code              : last code
   Qualifier         : last qualifier

Expanded information ('info'):
   The complete listing of the 'PhysWin' structure (see 'TheWizCorner.guide'
   for more info).

Other help: syslists info_cmd list_cmd base()
            ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯¯¯ ¯¯¯¯¯¯
===
@¬Error e-6
Stack overflow !!!
   PowerVisor detected a stack overflow in another program. The program
   is halted. You can find a crash node (a node or structure containing
   information about the crash) in the 'crsh' list.
===
@¬Error e-5
A program has crashed !!!
   PowerVisor detected a crash in another program. The program is
   halted. You can find a crash node (a node or structure containing
   information about the crash) in the 'crsh' list.
===
@¬Error e-4
A stack overflow was getting close !
   There could have been a stack overflow for PowerVisor. Don't worry,
   everything is nicely cleaned up.
   Stack checking occurs in the expression evaluator and in the
   command parser.
===
@¬Error e-3
You should never be able to see this line. Do you see me ? Then something
is astray.
===
@¬Error e-2
Break...
   You have interrupted some command. Nothing to worry about
===
@¬Error e-1
PowerVisor has crashed ! Normally this could not happen. Try to see what
is wrong and make a bug report if you think you have not caused the crash
yourselves.
===
@¬Error e0
There is no error !
===
@¬Error e1
Not enough memory !
   You have not enough memory to do something. Free some memory and
   try again.
===
@¬Error e2
Syntax Error !
   You typed a command that powervisor did not understand, or some
   of your arguments are badly formed.
===
@¬Error e3
This is not a device created with OpenDev !
   You can only use the 'devcmd' and 'devinfo' commands with devices
   opened with the 'opendev' command.
===
@¬Error e4
Bad list element type !
   The operation you want to do does not work for the current list.
   For example: you cannot use named shortcuts for the elements
   in the 'lock' list. You must use the node address.
===
@¬Error e5
Variable is a constant !
   You wanted to assign a value to a constant variable (eg 'version').
   This is of course not possible.
===
@¬Error e6
Only <B>yte, <W>ord or <L>ong !
   You can only use .B (byte) .W (word) or .L (long) with the contents
   operator (case is not important).
===
@¬Error e7
Odd address error !
   You tried to read a word or long from an odd address with the
   contents operator. Even though your processor (68020/30/40) may
   support this, PowerVisor won't allow you to do this to remain compatible
   with the 68000 processor.
===
@¬Error e8
Could not Lock!
   The argument you gave to 'curdir' is not a valid filename or
   subdirectory name.
===
@¬Error e9
Bracket '(' expected !
   Functions and library functions need an opening bracket for
   their argument list, even if they have no arguments. Note that
   the left bracket must IMMEDIATELY follow the function name, no
   spaces are allowed.
===
@¬Error e10
To many arguments for library function !
   The number of arguments to a library function is fixed. You
   must close the argument list with a bracket ')'.
===
@¬Error e11
Missing operand !
   The command expected another argument but you did not supply it.
===
@¬Error e12
Lock is not a subdirectory !
   The filename you gave to 'curdir' is not a subdirectory but a file.
===
@¬Error e13
Error while opening device !
   The 'opendev' command failed (or some other command opening a device
   (like 'stack')).
   Maybe because the device does not exist, or you gave illegal
   arguments to the device.
===
@¬Error e14
Unknown list element !
   PowerVisor does not know the list you gave as an argument for 'list'.
   Type 'help syslists' for a list of all available lists.
===
@¬Error e15
Not implemented yet !
   You tried something that does not work yet.
   Maybe for a future version of PowerVisor.
===
@¬Error e16
Unknown mode argument !
   The argument you gave to 'mode' is unknown to PowerVisor.
   Type 'help mode_cmd' for more info about mode.
===
@¬Error e17
Unknown AddFunc argument !
   The argument you gave to 'addfunc' is unknown to PowerVisor.
   Type 'help addfunc_cmd' for more info about addfunc.
   Try 'addfunc ?' to get the template.
===
@¬Error e18
This is not a process !
   The command needs a process, but you gave it something else.
   'curdir' needs a process and not a task as its first argument.
   'hunks' only works with a process.
   You can only load symbols for a debug process.
===
@¬Error e19
Node is not a task or process !
   The command needs a process or a task, but you gave it something else.
   Here are some of the commands that need a process or task:
      'regs', 'freeze', 'unfreeze', 'kill' and 'debug'.
===
@¬Error e20
This task is not frozen!
   You can't unfreeze a task that isn't frozen.
===
@¬Error e21
This task is already frozen!
   You can't freeze a frozen task.
===
@¬Error e22
Node type is wrong !
   You try a command that expects a specific node and it finds that
   this node is not a good one.
   This error can be caused by one of the following commands:
      'remfunc' when you give something other than a 'function' node.
      'unloadfd' when you give something other than a 'fd-file' node.
      'remcrash' when you give something other than a 'crash' node.
      'remattach' when you give something other than a 'keyattach'
         node.
===
@¬Error e23
Addressed element not found !
   PowerVisor really does not know what to do with your string or name
   you gave on the commandline. It is not a variable, not a symbol for
   the current debug task and not an abbreviation of a list element in
   the current list.
===
@¬Error e24
Window is not sizeable !
   You can't size a physical window if it is a backdrop window (like
   the PowerVisor window is by default).
===
@¬Error e25
This is no supported library function !
   You tried 'libinfo' on a library function that does not exist.
   Or 'addfunc' complains about the fact that the library function
   does not exist.
   Check all the loaded fd-files.
===
@¬Error e26
No help available for this subject !
   'help' does not know what you are talking about.
===
@¬Error e27
Error while opening file !
   PowerVisor could not open a file.
   This error can be caused by one of the following commands:
      'load', 'save', 'loadfd', 'symbol l', 'script', 'addstruct', ...
===
@¬Error e28
Error while reading file !
   PowerVisor could not read from a file.
===
@¬Error e29
Not a resident module !
   You tried to use 'remres' on something that is no resident module.
   All resident modules are in the 'resm' list.
===
@¬Error e30
Not a lock !
   You cannot unlock something that is not a lock. Also 'pathname'
   does not like unlocking tasks or something.
===
@¬Error e31
Bad History value (2..1000)
   The history value must be something between 2 and 1000.
===
@¬Error e32
Error opening trackdisk device !
   The 'wblock' or 'rblock' commands could not open the trackdisk.device.
===
@¬Error e33
DoIO returned with a non zero value !
   There was an error for DoIO. ('rblock' command).
===
@¬Error e34
There is no task to debug !
   You tried a debug command without a debug task. Load a debug task
   with 'debug'.
===
@¬Error e35
Unknown argument for 'trace'!
   The argument you gave is unknown to the mighty 'trace' command.
   Please rethink your request or type 'help trace_cmd' for more info.
   Try 'trace ?' to get the template.
===
@¬Error e36
Unknown argument for 'debug'!
   The argument you gave is unknown to the 'debug' command.
   Try 'debug ?' to get the template.
===
@¬Error e37
Address is in ROM ! Can't set breakpoint !
   You cannot put a breakpoint in ROM. You can avoid this problem by
   using one of the 'trace' commands. Some of them allow you to
   set pseudo breakpoints in ROM.
===
@¬Error e38
Not a debug node !
   When you want to do something with a debug node, you must do it
   with a debug node.
===
@¬Error e39
Bad '@' argument
   The argument you give to the '@' operator (special_op) is malformed
   or something.
   You must use a valid register specification.
   Type 'help special_op' for more info.
===
@¬Error e40
LoadSeg error !
   PowerVisor could not load the program. You probably mistyped the name.
   Or there is not enough memory to load the program.
===
@¬Error e41
Unknown argument for 'dmode'!
   The argument you gave is unknown to the 'prefs dmode' command.
===
@¬Error e42
There is no current debug task !
   You tried a debug command without a debug task.
   You must first load a debug task with 'debug' or set the
   current debug task with 'duse'.
===
@¬Error e43
Unknown argument for 'break'!
   The argument you gave is unknown to the 'break' command.
   Try 'break ?' to get the template.
===
@¬Error e44
Breakpoint does not exist !
   You try to clear a nonexisting breakpoint.
===
@¬Error e45
There are no symbol hunks !
   You try to load symbol hunks for a program without symbol hunks.
===
@¬Error e46
Symbol not found !
   You get this errormessage if you try to remove a nonexisting symbol.
===
@¬Error e47
You can only remove variables !
   You should not remove constants, functions and special variables.
===
@¬Error e48
You can not assign to a function !
   You can't assign to a function. Note that functions and variables
   are internally the same. This means that you can't have a variable
   and a function with the same name.
===
@¬Error e49
You must use brackets with functions !
   A function wants brackets, even if there are no arguments.
===
@¬Error e50
Unknown argument for 'symbol'!
   The argument you gave to 'symbol' is unknown.
   Try 'symbol ?' to get the template.
===
@¬Error e51
There are no symbols !
   There are no symbols. ('symbol s')
===
@¬Error e52
You can only realloc blocks smaller than 64K !
   Use the 'realloc' function only for memory block smaller than
   64K.
===
@¬Error e53
Your brackets are really out of order !
   You seem to have done something wrong with your brackets.
===
@¬Error e54
The debug task is busy, please try again later !
   You cannot trace when you are already tracing. Also, before you 'quit'
   or try to remove the debug task, you should stop the tracing.
===
@¬Error e55
The task is not tracing !
   You cannot stop the tracing if the task is not tracing.
===
@¬Error e56
File does not have the right format !
   You must use a 'pvsd' file for the 'addstruct' command.
   These files are made by 'mstruct' (external utility).
===
@¬Error e57
This is not a structure definition !
   You must use structure definitions (in the 'stru' list) with
   commands like 'interprete' and 'remstruct'.
===
@¬Error e58
Bad argument value !
   You must use acceptable values for the 'prefs debug' (and other) commands.
===
@¬Error e59
No colorchange allowed when PowerVisor is on a window !
   Only use the 'color' command when PowerVisor is on it's
   own screen.
===
@¬Error e60
Could not open font !
   PowerVisor could not open the font. Maybe it is not in the 'fonts:'
   directory ?
===
@¬Error e61
Can't execute script file in script file !
   Recursive script executing is not allowed.
===
@¬Error e62
Refresh window is not open !
   You tried to use the 'refresh' command before you opened the 'refresh'
   window. Use 'rwin' to do this.
===
@¬Error e63
Unknown tag type !
   The tag type you used with 'AddTag' is invalid (use ba,wa,la,st or as).
===
@¬Error e64
No output allowed on debug logical window !
   You cannot use the 'on' or 'current' commands for the 'debug' logical
   window. The 'debug' logical window only receives output from the
   full screen debugger.
===
@¬Error e65
Error writing file !
   Error while writing to file !
===
@¬Error e66
Not a Tag file !
   This file is not a tag definition file !
===
@¬Error e67
Bad tag list value (0 .. 15) !
   PowerVisor only supports 16 tag lists (0 .. 15).
===
@¬Error e68
Unknown or invalid register !
   PowerVisor does not know this register. You can only use :
   d0,...,d7,a0,...,a6 or sp (and sometimes pc).
===
@¬Error e69
There is a more recent patch then this one installed !
   You can't remove this patch. You must first remove the more recent
   one. Note that there may be other programs patching library functions.
===
@¬Error e70
There is no fd file loaded for this library !
   You can't use 'libfunc' when there is no fd file loaded for the
   library.
===
@¬Error e71
Unknown logical window !
   I don't know about this logical window. Note that you must
   give the logical window name in full for the 'prefs logwin'
   command.
===
@¬Error e72
Resulting commandline too long after converting from alias string !
   While the alias line is converted we got an overflow. Either increase
   the maximum linelength (with 'prefs linelen'), decrease what you
   type on the commandline or make the alias shorter.
===
@¬Error e73
Missing left bracket '(' in fd file !
   Where is the left bracket that should come after the function name ?
===
@¬Error e74
Missing right bracket ')' in fd file !
   Where is the right bracket that should come somewhere after the
   function name ?
===
@¬Error e75
Bad '##bias' statement in fd file !
   The ##bias statement in the fd-file is bad since it refered to a
   function entry that is already used.
===
@¬Error e76
You can't close the 'Main' physical window !
   Well, you really can't do that.
===
@¬Error e77
You can't close the 'Main' logical window !
   Sorry, but if you really want you can close another logical window
   instead.
===
@¬Error e78
Bad argument for 'openlw' ! Arg must be one of 'r','l','d' or 'u' !
   The direction argument for the new logical window is wrong. It must
   be one of u,d,r or l preceded with an arbitrarily number of p's.
===
@¬Error e79
Brother logical window must be on same physical window !
   No, you really can't open a logical window on one physical window with
   the brother on another physical window. That's like having a brother
   on Mars.
===
@¬Error e80
Window is not movable !
   The physical window is like a brick. You can't move it. This is because
   the physical window is a backdrop window.
===
@¬Error e81
There is no father for this box !
   You used the p (parent) direction argument to 'openlw' but there is
   no parent for the logical window you choose as a brother.
===
@¬Error e82
Unknown preferences argument !
   I don't know the preference argument you gave to the 'prefs' command.
   See the 'prefs' command for more info.
===
@¬Error e83
Please close visitor windows first !
   Before you can quit PowerVisor or before you can change some screen
   attributes you must make sure that there are no visitor windows
   opened on the PowerVisor public screen.
===
@¬Error e84
Divide by zero !
   You tried to divide by zero.
===
@¬Error e85
No group operators allowed for the debug task !
   You can't use group operators in expressions used for conditional
   tracing or conditional breakpoints.
===
@¬Error e86
Error opening screen !
   PowerVisor could not open the screen.
===
@¬Error e87
You can't remove the 'rc' and 'error' variables. These are private !
   This is fairly obvious.
===
@¬Error e88
'LoadSeg' failed !
   'Resident' did not succeed in loading the executable file.
===
@¬Error e89
Variable names must start with a letter or an underscore !
   You used assignment with an illegal object left of the '=' operator.
   Only variables, the contents operator ('*') and the special operator
   ('@') are allowed.
===
@¬Error e90
Error opening physical window !
   Not enough memory to open the physical window.
===
@¬Error e91
Error opening logical window !
   Not enough memory to open the logical window.
===
@¬Error e92
Bracket ')' expected !
   You must always close all brackets with expressions.
===
@¬Error e93
Bracket '}' expected !
   You must always close all curly brackets with groups.
===
@¬Error e94
Bus error !
   One of your debug tasks is halted because of a bus error.
===
@¬Error e95
Address error !
   One of your debug tasks is halted because of an address error.
===
@¬Error e96
Illegal instruction !
   One of your debug tasks is halted because it executed an illegal
   instruction.
===
@¬Error e97
Division by zero !
   One of your debug tasks is halted because it tried to divide by zero.
===
@¬Error e98
CHK instruction !
   One of your debug tasks is halted because it tried to execute a CHK
   instruction.
===
@¬Error e99
TRAPV instruction !
   One of your debug tasks is halted because it tried to execute a TRAPV
   instruction.
===
@¬Error e100
Privilege Violation !
   One of your debug tasks is halted because it tried to execute a
   priviledged instruction.
===
@¬Error e101
Trace error !
   This should never occur. One of your debug tasks is halted because
   it enable trace mode.
===
@¬Error e102
Unimplemented 1010 opcode !
   One of your debug tasks is halted because it tried to execute an
   unimplemented 1010 instruction.
===
@¬Error e103
Unimplemented 1111 opcode !
   One of your debug tasks is halted because it tried to execute an
   unimplemented 1111 instruction.
===
@¬Error e104
Unknown argument for 'track'!
   The argument you gave to 'track' is unknown.
   Try 'track ?' to get the template.
===
@¬Error e105
PowerVisor is allready tracking for a task !
   You can only track one task at a time with the 'track' command.
   Stop the tracking of the other task or do something else.
===
@¬Error e106
PowerVisor is not tracking !
   You can perfrom this operation only if PowerVisor is tracking something.
===
@¬Error e107
Unknown argument for 'source'!
   The argument you gave to 'source' is unknown.
   Try 'source ?' to get the template.
===
@¬Error e108
There are no debug hunks in this executable file !
   Use the correct compiler or assembler option to generate debug hunks.
===
@¬Error e109
There is no source loaded for this debug node !
   You are trying to do some operation on a source you have not loaded
   with the 'source' command.
===
@¬Error e110
This address is not in the source !
   The program counter does not occur in the debug hunks information.
===
@¬Error e111
This command only works on the 68030 or 68040 !
   This error can occur if you use the 'speek' and 'spoke' commands on
   a system without an 68030 or 68040. Note that the 68020 with 68851
   is not enough.
===
@¬Error e112
You need a MMU for this command !
   You need a 68851, 68030 or 68040.
===
@¬Error e113
Not a valid executable file!
   The file is not an executable file, or the file contains unsupported
   hunks (like overlay).
===
@¬Error e114
This operation is not allowed for slave instances!
   Some operations and commands are only allowed for the master instance
   of PowerVisor. The master instance is the first running PowerVisor
   program in memory. All other PowerVisor instances running at the same
   time are slaves. Only the master instance can debug programs for
   example.
===
@¬Error e115
First install memory protection system with 'mmuwatch'!
   You can't do 'protect' when you haven't installed the memory
   protection system with 'mmuwatch'.
===
@¬Error e116
You can't freeze PowerVisor!
   Well, this is obvious.
===
@¬Error e117
You can't change the protection use of tag list 0! It is global!
   Tag list 0 is used for global memory protection (for all tasks).
   If you want to protect memory for a specific task you must use
   another tag list (1..15).
===
@¬Error e118
Unknown argument for 'struct'!
   The argument you gave to 'struct' is unknown.
   Try 'struct ?' to get the template.
===
@¬Error e119
Bad internal structure format!
   You should never get this error! Please report this to the author
   if possible, and give the exact procedure to get this error (it
   should be reproducable).
===
@¬Error e120
This is a read-only structure! You can't change its fields!
   You can't change the fields or anything else for the internal structures
   like _task, _cli, _exec, ... .
===
@¬Error e121
I can't find this field in the structure!
   You must give the correct name. Note that the 'struct' command is
   case sensitive for the field names ('peek' and 'apeek' are not).
===
@¬Error e122
Unknown argument for 'prof'!
   The argument you gave to 'prof' is unknown.
   Try 'prof ?' to get the template.
===
@¬Error e123
You are not profiling!
   You want to do a command that is only possible when you are profiling.
===
@¬Error e124
You are already profiling!
   You can't start two profilers at the same time. First stop the profiler
   before you start it again.
===
@¬Error e125
Not a logical window!
   You can only use logical windows for logical window commands! Check
   your variables and debug symbols to see if there may be a name
   conflict.
===
@¬Error e126
Unknown argument for 'debug s'!
   The argument you gave is unknown to the 'debug s' command.
   Try 'debug ?' to get the template.
===
@¬Error e127
Unknown argument for 'watch'!
   The argument you gave is unknown to the 'watch' command.
   Try 'watch ?' to get the template.
===
@¬t exec_tmp
Exec
===
@¬t intb_tmp
INTb
===
@¬t task_tmp
Task
===
@¬t libs_tmp
LIBs
===
@¬t devs_tmp
DEvs
===
@¬t reso_tmp
RESO
===
@¬t memr_tmp
MEMR
===
@¬t intr_tmp
INTR
===
@¬t port_tmp
Port
===
@¬t wins_tmp
Wins
===
@¬t attc_tmp
ATTC
===
@¬t graf_tmp
GRaf
===
@¬t conf_tmp
COnf
===
@¬t scrs_tmp
SCrs
===
@¬t font_tmp
FOnt
===
@¬t dosd_tmp
DOsd
===
@¬t func_tmp
FUnc
===
@¬t sema_tmp
SEMa
===
@¬t resm_tmp
RESm
===
@¬t fils_tmp
FILS
===
@¬t lock_tmp
LOck
===
@¬t ihan_tmp
IHan
===
@¬t fdfi_tmp
FDfi
===
@¬t crsh_tmp
CRsh
===
@¬t dbug_tmp
DBug
===
@¬t moni_tmp
MONi
===
@¬t pubs_tmp
PUbs
===
@¬t stru_tmp
STru
===
@¬t lwin_tmp
LWin
===
@¬t pwin_tmp
PWin
===
@¬t help_tmp
Help [<topic>]
===
@¬t pvcall_tmp
<result> <- PVcall <number> [<arguments>]
===
@¬t pvmem_tmp
PVMem
===
@¬t prefs_tmp
PREfs ('history' | 'key' | 'screen' | 'stack' | 'logwin' | 'linelen' |
      'debug' | 'dmode' | 'pens' | 'font') [<arguments> ...]
===
@¬t event_tmp
EVent <class> <subclass> <code> <qualifier> <x> <y>
===
@¬t owner_tmp
OWNer <address>
===
@¬t speek_tmp
<value> <- SPEEk <address>
===
@¬t saveconfig_tmp
SAVEConfig
===
@¬t spoke_tmp
SPOke <address> <value>
===
@¬t protect_tmp
PROtect
===
@¬t mmuwatch_tmp
MMUWatch
===
@¬t tagtype_tmp
TAGType [<tag list number> [<task>]]
===
@¬t mmutree_tmp
MMutree
===
@¬t mmureset_tmp
MMURESet
===
@¬t mmuregs_tmp
MMURegs
===
@¬t openlw_tmp
RC,<lwin> <- OPENLw <physical window> <logwin name> <cols> <rows>
             [<brother> <where> [<number of columns or lines>]]
===
@¬t openpw_tmp
RC,<pwin> <- OPENPw <physical window name> <x> <y> <w> <y>
===
@¬t closepw_tmp
CLOSEPw <physical window>
===
@¬t closelw_tmp
CLOSELw <logical window>
===
@¬t setflags_tmp
RC,<oldflags> <- SETFLags <logical window> <mask> <flags>
===
@¬t specregs_tmp
SPecregs
===
@¬t setfont_tmp
SETfont <logical window> <fontname> <fontheight>
===
@¬t colrow_tmp
COLRow <logical window> <columns> <rows>
===
@¬t view_tmp
VIew [<address> [<bytes>]]
===
@¬t addtag_tmp
ADDTag <address> <bytes> <type> [<structure>]
       {'r' | 'w' | 'i' | 'p' | 'f'}
===
@¬t loadtags_tmp
LOADTags <file> <base>
===
@¬t savetags_tmp
SAVETags <file> <base>
===
@¬t cleartags_tmp
CLEARTags
===
@¬t remtag_tmp
REMTag <address>
===
@¬t tags_tmp
TAGs
===
@¬t checktag_tmp
<bytes remaining> <- CHecktag <address>
===
@¬t usetag_tmp
USetag <number>
===
@¬t tg_tmp
<result> <- TG <number> <command>
===
@¬t interprete_tmp
INTErprete <structure pointer> <struct def pointer>
===
@¬t clearstruct_tmp
CLEARStruct
===
@¬t addstruct_tmp
ADDStruct <filename>
===
@¬t struct_tmp
STRUCt 'n' <struct name> <struct size> |
       'a' <struct pointer> <offset> <type> <field name> |
       'r' <struct pointer> <field name> |
       'l' <struct pointer> |
       'c' <struct pointer> <new struct size> |
       's' <struct pointer> |
       'w' <struct pointer> <filename> |
       'p' <struct pointer> <filename>
===
@¬t assign_tmp
ASsign <assignment string>
===
@¬t string_tmp
<string> <- STRIng <string pointer> [<max length>]
===
@¬t rx_tmp     (Commandline and scripts only)
RX <file name>
===
@¬t remstruct_tmp
REMStruct <struct def pointer>
===
@¬t for_tmp
FOR <listname> <command>
===
@¬t llist_tmp
LList <node> ['start']
===
@¬t vars_tmp
VArs ['all']
===
@¬t remvar_tmp
REMVar {<variables>}
===
@¬t alias_tmp
ALias [<alias command> <alias string>]
===
@¬t error_tmp
<pointer to error string> <- ERror <error number>
===
@¬t unalias_tmp
UNALias <alias command>
===
@¬t hold_tmp
HOld
===
@¬t quit_tmp
Quit
===
@¬t gadgets_tmp
Gadgets <window>
===
@¬t size_tmp
SIze <physical window> <w> <h>
===
@¬t move_tmp
MOVe <physical window> <x> <y>
===
@¬t screen_tmp
SCREen [<screen>]
===
@¬t remres_tmp
REMRes <resident pointer>
===
@¬t resident_tmp
RC,<Pointer to code> <- RESIdent [<filename>]
===
@¬t unresident_tmp
UNResident <Pointer to code>
===
@¬t clip_tmp
[RC,<Pointer to data>] <- CLIp <Clip name> [<Pointer to data> <Length>]
===
@¬t remclip_tmp
REMCLip <Clip name>
===
@¬t remove_tmp
<node> <- REMOve <node>
===
@¬t curdir_tmp
CUrdir <process> <directory name>
===
@¬t crash_tmp
CRAsh <taskpointer>
===
@¬t clear_tmp
CLEar [<value>]
===
@¬t active_tmp
Active <logwin>
===
@¬t scroll_tmp
SCROll <logwin> <x> <y>
===
@¬t current_tmp
CURRent <logical window>
===
@¬t on_tmp
<result> <- ON <logical window> <command>
===
@¬t cls_tmp
CLs
===
@¬t led_tmp
LEd
===
@¬t load_tmp
<bytes loaded> <- LOAd <filename> <start> [<max bytes>]
===
@¬t save_tmp
<bytes written> <- SAve <filename> <start> <bytes>
===
@¬t fregs_tmp
FREGs <task>|<debug node>
===
@¬t float_tmp
FLoat <task>|<debug node> <register number> <register value>
===
@¬t regs_tmp
REGs <task>|<crash node>|<debug node>
===
@¬t print_tmp
PRint <string>
===
@¬t sprint_tmp
SPRint <string>
===
@¬t locate_tmp
LOCAte <x> [<y>]
===
@¬t home_tmp
HOMe
===
@¬t showalloc_tmp
SHowalloc
===
@¬t cleanup_tmp
CLEANup
===
@¬t color_tmp
COLor <col num> <red> <green> <blue>
===
@¬t request_tmp
<result> <- REQuest <body string> <gadget string> <argument>
===
@¬t reqload_tmp
INPUT,<ptr to filename> <- REQLoad <title>
===
@¬t reqsave_tmp
INPUT,<ptr to filename> <- REQSave <title>
===
@¬t getstring_tmp
INPUT,<ptr to inputline> <- GEtstring <title> <max number of chars>
===
@¬t scan_tmp
INPUT,<pointer to inputline> <- SCAn [<number>]
===
@¬t disp_tmp
<value of expression> <- Disp <expression>
===
@¬t refresh_tmp
Refresh [<refresh rate> <command>]
===
@¬t fit_tmp
FIT <logical window>
===
@¬t awin_tmp
AWin [<number of lines>]
===
@¬t owin_tmp
OWin [<number of lines>]
===
@¬t rwin_tmp
RWin [<number of lines>]
===
@¬t xwin_tmp
Xwin [<number of lines>]
===
@¬t dwin_tmp
DWin [<number of lines>]
===
@¬t swin_tmp
SWin [<number of lines>]
===
@¬t wwin_tmp
WWin [<number of lines>]
===
@¬t mode_tmp
MOde <mode argument> {<mode argument>...}
===
@¬t copy_tmp
Copy <source> <destination> <bytes>
===
@¬t fill_tmp
Fill <dest> <bytes> <with>
===
@¬t search_tmp
RC,<address> <- Search <start> <bytes> <string>
===
@¬t next_tmp
RC,<address> <- Next
===
@¬t stack_tmp
STAck [<task> <micro seconds>]
===
@¬t account_tmp
ACCount
===
@¬t kill_tmp
Kill <task>|<crash node>
===
@¬t freeze_tmp
FReeze <task>
===
@¬t unfreeze_tmp
UNFreeze <task>
===
@¬t addfunc_tmp
RC,<func node> <- ADdfunc (<libfuncname> | 'offs' <library> <offset>)
                  ['only' <task>] [<type> [<command>]]
===
@¬t remfunc_tmp
REMfunc <function monitor node>
===
@¬t unasm_tmp
Unasm [<start> [<instructions>]]
===
@¬t libinfo_tmp
LIBInfo <library function name>
===
@¬t libfunc_tmp
LIBFunc <library> <offset>
===
@¬t list_tmp
List [<list>]
===
@¬t memory_tmp
Memory [<start> [<bytes>]]
===
@¬t info_tmp
Info <object address> [<list>]
===
@¬t memtask_tmp
MEMTask <task>
===
@¬t remcrash_tmp
REMCrash <crash node>
===
@¬t loadfd_tmp
RC,<number of functions> <- LOADFd <library> <file-name>
===
@¬t unlock_tmp
UNLOCk <pointer to a lock>
===
@¬t sync_tmp
SYNc
===
@¬t async_tmp
ASYnc
===
@¬t hide_tmp
HIde
===
@¬t unhide_tmp
UNHide
===
@¬t front_tmp
FROnt
===
@¬t closewindow_tmp
CLOsewindow <window>
===
@¬t hunks_tmp
HUnks <process>
===
@¬t attach_tmp
<attach node> <- ATtach <command string> <code> <qualifier>
                 [('e' | 'c' | 'a')['+']]
===
@¬t remattach_tmp
REMAttach <attach node>
===
@¬t closescreen_tmp
CLOSEScreen <screen>
===
@¬t log_tmp
LOG [<logical window> <filename>]
===
@¬t prof_tmp
PROF 't' <debug node> <micro seconds> | 's' | 'c' | 'l'
===
@¬t track_tmp
TRACK 't' <task> | 's' | 'c' | 'l'
===
@¬t to_tmp
<result> <- TO <file> <command>
===
@¬t appendto_tmp
<result> <- APpendto <file> <command>
===
@¬t taskpri_tmp
TASKPri <task ptr> <priority>
===
@¬t pathname_tmp
PAthname <lock>
===
@¬t unloadfd_tmp
UNLoadfd <fd-file node>
===
@¬t while_tmp
WHile <command>
===
@¬t script_tmp
<result> <- SCRIpt <script file> [<commandline>]
===
@¬t dnexti_tmp
DNexti
===
@¬t dprevi_tmp
DPrevi
===
@¬t dscroll_tmp
DScroll <offset>
===
@¬t dstart_tmp
DSTart <address>
===
@¬t debug_tmp
RC <- DEBug 'n' [<number>] |
            'c' [<number>] |
            'l' <filename> |
            't' <task node> |
            'r' [<debug node>] |
            'f' [<debug node>] |
            'u' [<debug node>] |
            'd' <name> |
            'q' (0 | 1) |
            's' ['s' | 'a' <path> | 'c']
===
@¬t drefresh_tmp
DRefresh
===
@¬t duse_tmp
DUse <debug node>
===
@¬t with_tmp
<result> <- WITh <debug node> <command>
===
@¬t trace_tmp
TRace [ 'n'['f'|'r'] <number> |
        'g'['t'|'f'|'r'] |
        't' |
        'o'['t'] |
        'u'['t'] <address> |
        'r'['f'|'r'] <register> |
        'c'['f'|'r'] <condition> |
        'q'['f'|'r'] <condition> |
        'j'['f'|'r'] |
        'p'['f'|'r'] |
        'z'['f'|'r'] <addr> <len> |
        'b' |
        's' |
        'i' |
        'h' |
        'f' ]
===
@¬t break_tmp
RC <- Break 'a' <address> <timeout> |
            'c' <address> <condition> |
            'n' <address> |
            't' <address> |
            'p' <address> |
            'r' <breakpoint number>
===
@¬t source_tmp
SOurce 'l' <filename> [<hunkaddress>] |
       'w' <address> |
       's' |
       't' <tab size> |
       'r' |
       'c' |
       'g' <line> |
       'a' <address> |
       'h' <hold mode>
===
@¬t symbol_tmp
SYmbol 'l' <filename> [<hunkaddress>] |
       'c' |
       'a' <symbol> <value> |
       'r' <symbol> |
       's' |
       't'
===
@¬t watch_tmp
WAtch 'c' |
      'a' <value> |
      'r' <value> |
      's'
===
@¬t rblock_tmp
RC,<address> <- RBlock <Unit number> <block number> [<address>]
===
@¬t void_tmp
<result> <- Void {<argument>...}
===
@¬t wblock_tmp
WBlock <Unit number> <block number> <address>
===
@¬t opendev_tmp
RC,<pvdevice> <- Opendev <device name> [<unit> [<flags>]]
===
@¬t closedev_tmp
CLOSEDev <device block>
===
@¬t devinfo_tmp
DEVInfo <device block>
===
@¬t devcmd_tmp
RC <- DEVCmd <dev> <command> [<flags> [<length> [<data> [<offset>]]]]
===
@¬t remhand_tmp
REMHand <input handler>
===
@¬t go_tmp
<result> <- GO <address> [<commandline>]
===
@Help bugs
---------
Bugs

   Stack overflow There seem to be some problems with 'killing' a task
                  that has crashed because of a stack overflow
                  ('account' command). The solution is of course not to
                  kill the program :-) PowerVisor has halted the program
                  so it will do no more (!) harm
   MMU            The current MMU protection system does not work on a
                  68040 processor. This is due to lack of this processor
                  and documentation
   float          The 'float' command does not work if the task has not
                  used any floatingpoint instructions yet

Bugs for AmigaDOS 1.2/1.3 version of PowerVisor only

   debug          PowerVisor looses 24 bytes when you do 'debug l' and
                  'debug u'.
   cursor         The cursor in the stringgadget sometimes disappears in
                  the AmigaDOS 1.2/1.3 version of PowerVisor (this happens
                  the first time you use the <up> key to go in history)
   stringgadget   I know of no way to unactivate a stringgadget in AmigaDOS
                  1.3 and older. Therefore cycling through the windows
                  with <tab> is not enough to deactivate the stringgadget.
                  You will have to press <enter> first (or click next to
                  the stringgadget) before you can press the key (with
                  -MORE- or -HALT-)

Things that could be better and maybe should be supported

   mmu            'mmutree' does not support indirect pages and 8 byte
                  descriptors
                  'mmutree' does not support FC trees (function codes)
   trace u        PowerVisor may disturb other programs if you set your
                  breakpoint in shared memory
   trace          Tracing is very hazardous for multitasking. You can
                  scarcely move your mouse
   crashes        There are still some guru's PowerVisor does not trap
   fonts          We should not permit proportional fonts
   search/copy/fill
                  These routines are very sensitive to bad arguments
                  (negative for example)
   Overflows      Powervisor does not always check for overflow (especially
                  with string parsing) Make sure that your strings are
                  always smaller than the maximum line length in the
                  stringgadget (set with 'prefs linelen', default 400)

Future enhancements (note that these are NOT promises :-)

   owner          Owner should be expanded to handle more system lists
   load           Load should have an extra argument : offset to start
                  loading
   Floating pt    I plan better floating point support for PowerVisor.
   odd-address error check
                  It is very difficult to test odd address errors on 68020
                  (or higher) processors since these processors allow that
                  kind of access. Therefore you must be very careful when
                  you write 68000 compatible programs on 68020 machines
                  (like PowerVisor). To solve this problem I plan to write
                  a trace command to singlestep each instruction and check
                  all accesses to memory. This will be slow, but eventually
                  you will be able to check for odd addresses. This trace
                  command could also check for 68020 addressing modes since
                  these don't generate illegal exceptions on the 68000 (a
                  little bug in this processor)
   serial debugging
                  I also plan some support for serial debugging
===
