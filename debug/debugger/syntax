<go>		::=	g <expression>	 |
			g = <expression> |
			g

<trace>		::=	t <expression>	 |
			t = <expression> |
			t

<=>		::=	<expression>

<mod-reg>	::=	r <register> <expression> |
			r

<load>		::=	l <filename> <parameters> |
			l <filename>

<show-segs>	::=	S

<breakp>	::=	b{s|c|x|t} DEC-CONSTANT <expression> |
			b

<dissasemble>	::=	d <expression> <expression> |
			d <expression> 		    |
			d

<mem-dump>	::=	m <expression> <expression> |
			m <expression>		    |
			m

<quit>		::=	x 

<set-args>	::=	c <string>	|
			c

<initialize>	::=	i

<zip>		::=	z

<window>	::=	w

<help>		::=	?

<show-syms>	::=	s {g|d|c|b|<segment>} |
			s <symbol>

<expression>	::=	<const-term1> >> <const-exp> |
			<const-term1> << <const-exp> |
			<const-term1>

<const-term1>	::=	<const-term2> + <const_term1> |
			<const-term2> - <const_term1> |
			<const-term2>

<const-term2>	::=	<const-element> * <const-term2> |
			<const-element> / <const-term2> |
			<const-element>

<const-element>	::=	<constant>	|
			<reg-exp>	|
			IDENTIFIER	|
			<segment> 	|
			'CHAR'

<segment>	::=	s DEC-CONSTANT

<register>	::=	<address-reg> | 
			<data-reg>

<address-reg>	::=     a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7 |
			sp | pc


<data-reg>	::=	d0 | d1 | d2 | d3 | d4 | d5 | d6 | d7 |
			sr | C | O | X | Z | N 

<reg-exp>	::=	<constant>(register,register)	|
			<constant>(register)		|
			(register,register)		|
			(register)
			
<constant>	::=	%BIN-CONSTANT	|
			$HEX-CONSTANT	|
			+DEC-CONSTANT	|
			-DEC-CONSTANT	|
			HEX-CONSTANT




Notes:

	A sub-command must be followed by whitespace to avoid confusion. Thus
	we type: ps 1, not ps1. Otherwise the parser would either return the
	value for segment 1, or try to find the symbol 's1'.


Example Parsing:

<go>:
	if ( GetEqual() )		; Test for equal sign
		{
		GetExpression()
		go-at-expression-result
		}
	else
		{
		GetExpression()
		go-to-expression-result
		}
