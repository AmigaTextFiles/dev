
S.I.M. Version 1.72 Command Overview

Single sheet command overview. To be printed with 20CPI.

-CUT HERE-

---------------------------------------------------------------------------------------------------------------------------------------
 a  (s)(e)           :show memory as ascii (from s (to e))                       Monitor Function Key Overview
 b                   :list all breakpoints                                      -------------------------------------------
 bj [s]              :set JSR-breakpoint at s                                    <CURSOR>            :move cursor one step
 bs [s]              :set stack breakpoint                                       <SHIFT+CURSOR>      :move cursor to limit
 b  [s](j)           :set illegal breakpoint at s (with jokers, see below)       <ALT+CURSOR UP>     :command history back
       *             :make breakpoint resident                                   <ALT+CURSOR DOWN>   :command history foreward
       [n]           :make counter breakpoint                                    <DEL>               :delete char in line
       ? [n]         :make condition breakpoint                                  <SHIFT+DEL>         :insert space in line
       j|l|r         :make button breakpoint                                     <ALT+DEL>           :clear screen
 b  [s]              :kill any breakpoint at s                                   <BACKSPACE>         :backspace
 bk                  :kill all breakpoints                                       <SHIFT+BACKSPACE>   :real backspace
 c  [s][e][t](j)     :compare from s to e with t (with jokers, see below)        <ALT+BACKSPACE>     :clear line
       +/- [n]       :compare every nth byte, as- (s<e) or descending (s>e)      <ESC>               :toggle debugger on/off
       *             :report the equal bytes, not the differing ones             <TAB>               :switch between windows
       @             :execute F9 when reporting (m0=source,m1=target)            <SHIFT+ESC>         :insert commandline
       !o|m|n        :all reports to matchbuffer. (o=old ones stay, m=same       <ALT+ESC>           :copy commandline
                     :ones stay, n=new ones stay when finished)                  <HELP>              :first helppage
 c  (s)(t)           :(set source (and target) new and) continue compare         <SHIFT+HELP>        :second helppage
 d  (s)(e)           :show disassembly of memory (from s (to e))                -------------------------------------------
 e  [s][d]           :edit memory directly at s                                  Graphic Searcher Function Key Overview
 e  (s)              :start to edit in loopmode (at s)                          -------------------------------------------
 e> [s](d)           :edit in loopmode                                           <CURSOR UP>         :one line up
 f  [s][e](j)[d](m)  :find data d (with jokers, see 'compare')                   <CURSOR DOWN>       :one line down
                     :from s to e (with mask m)                                  <CURSOR RIGHT>      :plane one word down
 f  (s)(e)           :(set start (and end) new and) continue find                <CURSOR LEFT>       :plane one word up
 f  [s][e](j) i [i]  :find disassembly (with jokers, see compare)                <SHIFT+UP>          :plane one page down
 g  [s]              :go to subroutine at s                                      <SHIFT+DOWN>        :plane one page up
 gw [s]              :prepare 'go to subroutine' to s                            <DEL>               :subtract 2 from modulo
 h  (n)              :show (nth last) history                                    <HELP>              :add 2 to modulo
 i  (n)              :leave out (n) instructions                                 <SHIFT+DEL>         :subtract 16 from modulo
 k  [s][e]           :define matchbuffer from s to e                             <SHIFT+HELP>        :add 16 to modulo
 k?                  :give matchbuffer measurements                              <BACKSPACE>         :clear modulo
 k*                  :init matchbuffer again                                     <CR>                :switch hires/lores
 k  {@}[s]           :show entries higher than s (report using F9)              -------------------------------------------
 k                   :show next entry                                            Debugger Function Key Overview
 l  (s)(e)           :disassemble copperlist (from s (to e))                    -------------------------------------------
 l*                  :activate actual copperlist                                 <AMIGA+UP>          :one line up
 l? (s)(e)           :search for active copperlist (from s (to e))               <AMIGA+DOWN>        :one line down
 l= (n)              :find quick copperlist (one or two)                         <AMIGA+RIGHT>       :one byte/word up
 m  (s)(e)           :show memory as hex/ascii (from s (to e))                   <AMIGA+LEFT>        :one byte/word down
 n  [s][i]           :assemble instructions directly at s                        <AMIGA+SHIFT+UP>    :one page up
 n  (s)              :start to assemble in loopmode (at s)                       <AMIGA+SHIFT+DOWN>  :one page down
 n> [s][i]           :assemble in loopmode                                       <AMIGA+ALT+UP>      :decrease actual window
 o  [s][e][d]        :occupy memory from s to e with data d                      <AMIGA+ALT+DOWN>    :increase actual window
 p  (s)(e)           :print text (from s (to e))                                 <AMIGA+S+A+UP>      :dec. window 0, inc. window 1
 q                   :return to debug server, confirm before quit                <AMIGA+S+A+DOWN>    :inc. window 0, dec. window 1
 r  {?}              :show all registers (all memories)                          <AMIGA+a>           :select asciidump
 r  [r]{=}[x]        :set register r with value x                                <AMIGA+b>           :set/clear breakpoint at top
 s  (p)(b)(s)        :set display (and backup (and transfer S.I.M.))             <AMIGA+c>           :compare next
 t  [s][e][t]        :transfer memory from s to e at t                           <AMIGA+d>           :select disassembly
 u                   :do next step, don't follow jst and bsr                     <AMIGA+e>           :edit at startaddr of window
 v                   :push exception frame back on stack                         <AMIGA+f>           :find next
 w                   :show state of all traps                                    <AMIGA+g>           :leave subroutine
 w  [x]              :set or clear trap x                                        <AMIGA+i>           :leave out instruction
 wk                  :kill all traps                                             <AMIGA+j>           :jump to startaddr of window
 x                   :continue program, confirm before exit                      <AMIGA+k>           :select swiss/american keymap
 z  (j)              :tracestep (with jokers, see below)                         <AMIGA+l>           :select copperlist disassembly
    [n]              :do n tracesteps                                            <AMIGA+m>           :select hexdump
    * [x]            :trace till pc=x                                            <AMIGA+n>           :assemble at startaddr of window
    ? [n]            :trace till result of formula not zero                      <AMIGA+p>           :select text
    j|l|r            :trace till fire, left or right button pressed              <AMIGA+q>           :quit to debug server
    c                :68020 trace emulation                                      <AMIGA+r>           :recalculate linkterms
 A  [n]              :set startaddress of active window                          <AMIGA+s>           :split/unsplit window
 B  [s]              :calculate and set bootchecksum                             <AMIGA+u>           :next step
 D  (n)              :show (set) active drive for trackoperations                <AMIGA+v>           :set/clear resident breakpoint
 D? (n)              :find track of actual drive (drive n)                       <AMIGA+x>           :exit
 F                   :list definitions of function keys                          <AMIGA+z>           :trace step
 F  [n](c){@}        :set function key n with macro c (execute directly)         <AMIGA+B>           :set/clear JSR-breakpoint
 K  [s]              :calculate and set blockchecksum                            <AMIGA+H>           :hardcopy of screen
 L  [f][s](n)(s)     :load file f to mem at s (n bytes (with seek value s))      <AMIGA+N>           :replace top instruction by NOPs
 P  (s)(m)           :show plane (start at s (init modulo with m))               <AMIGA+P>           :toggle printer
 Q                   :return directly to debug server                            <AMIGA+!>           :flush keystatefield
 S  [f][s][e]        :save memory from s to e as file f                          <AMIGA+?>           :toggle keyboardbuffer killer
 T  [n]{@}           :set (smart) linkterm of active window                      <AMIGA+\>           :toggle Auto Unmodify Traps
 V  (path)           :list directory (press <SPACE> for more)                    <AMIGA++>           :toggle fully printable charset
 X                   :continue program directly                                  <AMIGA+[>           :indirect (windowaddr=[windowaddr])
 ?  [n]{,}(n)        :calculate result of formula(s)                             <AMIGA+]>           :exdirect
 <s [s][b](n)        :read (n) sectors (starting with) b at s                    <AMIGA+{>           :BCPL indirect
 >s [s][b](n)        :write (n) sectors  (starting with) b from s                <AMIGA+}>           :enter last indirect
 <t [s][t](n)        :read (n) logical tracks (starting with) t at s             <AMIGA+F1-F10>      :toggle F-keys on/off
 >t [s][t](n)        :write (n) logical tracks (starting with) t from s          <AMIGA+0-9>         :get marked location
 >f (n)              ;format disk (in drive n)                                   <AMIGA+SHIFT+0-9>   :mark location (only keypad!)
 H  [s][e](p)        ;hear memory from s to e (with period p)                    <AMIGA+SHIFT+RIGHT> :indirect on JMP/Bcc/JSR addresses
 R  [s]              ;set range for address scan                                 <AMIGA+SHIFT+LEFT>  :exdirect
                                                                                 <AMIGA+D>           :toggle use of symbols in general
                                                                                 <AMIGA+S>           :toggle use of symbols for d16(ax)
                                                                                 <AMIGA+M>           :toggle MMU on/off
                                                                                 <AMIGA+G>           :perform an additional RTS
                                                                                 <AMIGA+>>           :scan for access on view address
                                                                                 <AMIGA+<>           :continue scan
                                                                                 <AMIGA+ALT+r>       :select large register list
                                                                                 <AMIGA+Z>           :enable EA calculation
                                                                                 <AMIGA+L>           :toggle between PAl/NTSC and NTSC overscan
---------------------------------------------------------------------------------------------------------------------------------------

