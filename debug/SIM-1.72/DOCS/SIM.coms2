-------------------------------------------------------------------------------
 COMMANDS SIM v1.72
-------------------------------------------------------------------------------
 a  (s)(e)           :show memory as ascii (from s (to e))
 b                   :list all breakpoints
 bj [s]              :set JSR-breakpoint at s
 bs [s]              :set stack breakpoint
 b  [s](j)           :set illegal breakpoint at s (with jokers, see below)
       *             :make breakpoint resident
       [n]           :make counter breakpoint
       ? [n]         :make condition breakpoint
       j|l|r         :make button breakpoint
 b  [s]              :kill any breakpoint at s
 bk                  :kill all breakpoints
 c  [s][e][t](j)     :compare from s to e with t (with jokers, see below)
       +/- [n]       :compare every nth byte, as- (s<e) or descending (s>e)
       *             :report the equal bytes, not the differing ones
       @             :execute F9 when reporting (m0=source,m1=target)
       !o|m|n        :all reports to matchbuffer. (o=old ones stay, m=same
                     :ones stay, n=new ones stay when finished)
 c  (s)(t)           :(set source (and target) new and) continue compare
 d  (s)(e)           :show disassembly of memory (from s (to e))
 e  [s][d]           :edit memory directly at s
 e  (s)              :start to edit in loopmode (at s)
 e> [s](d)           :edit in loopmode
 f  [s][e](j)[d](m)  :find data d (with jokers, see 'compare')
                     :from s to e (with mask m)
 f  (s)(e)           :(set start (and end) new and) continue find
 f  [s][e](j) i [i]  :find disassembly (with jokers, see compare)
 g  [s]              :go to subroutine at s
 gw [s]              :prepare 'go to subroutine' to s
 h  (n)              :show (nth last) history
 i  (n)              :leave out (n) instructions
 k  [s][e]           :define matchbuffer from s to e
 k?                  :give matchbuffer measurements
 k*                  :init matchbuffer again
 k  {@}[s]           :show entries higher than s (report using F9)
 k                   :show next entry
 l  (s)(e)           :disassemble copperlist (from s (to e))
 l*                  :activate actual copperlist
 l? (s)(e)           :search for active copperlist (from s (to e))
 l= (n)              :find quick copperlist (one or two)
 m  (s)(e)           :show memory as hex/ascii (from s (to e))
 n  [s][i]           :assemble instructions directly at s
 n  (s)              :start to assemble in loopmode (at s)
 n> [s][i]           :assemble in loopmode
 o  [s][e][d]        :occupy memory from s to e with data d
 p  (s)(e)           :print text (from s (to e))
 q                   :return to debug server, confirm before quit
 r  {?}              :show all registers (all memories)
 r  [r]{=}[x]        :set register r with value x
 s  (p)(b)(s)        :set display (and backup (and transfer S.I.M.))
 t  [s][e][t]        :transfer memory from s to e at t
 u                   :do next step, don't follow jst and bsr
 v                   :push exception frame back on stack
 w                   :show state of all traps
 w  [x]              :set or clear trap x
 wk                  :kill all traps
 x                   :continue program, confirm before exit
 z  (j)              :tracestep (with jokers, see below)
    [n]              :do n tracesteps
    * [x]            :trace till pc=x
    ? [n]            :trace till result of formula not zero
    j|l|r            :trace till fire, left or right button pressed
    c                :68020 trace emulation
 A  [n]              :set startaddress of active window
 B  [s]              :calculate and set bootchecksum
 D  (n)              :show (set) active drive for trackoperations
 D? (n)              :find track of actual drive (drive n)
 F                   :list definitions of function keys
 F  [n](c){@}        :set function key n with macro c (execute directly)
 K  [s]              :calculate and set blockchecksum
 L  [f][s](n)(s)     :load file f to mem at s (n bytes (with seek value s))
 P  (s)(m)           :show plane (start at s (init modulo with m))
 Q                   :return directly to debug server
 S  [f][s][e]        :save memory from s to e as file f
 T  [n]{@}           :set (smart) linkterm of active window
 V  (path)           :list directory (press <SPACE> for more)
 X                   :continue program directly
 ?  [n]{,}(n)        :calculate result of formula(s)
 <s [s][b](n)        :read (n) sectors (starting with) b at s
 >s [s][b](n)        :write (n) sectors  (starting with) b from s
 <t [s][t](n)        :read (n) logical tracks (starting with) t at s
 >t [s][t](n)        :write (n) logical tracks (starting with) t from s
 >f (n)              ;format disk (in drive n)
 H  [s][e](p)        ;hear memory from s to e (with period p)
 R  [s]              ;set range for address scan
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
 MONITOR FUNCTION KEY OVERVIEW
-------------------------------------------------------------------------------
 <CURSOR>            :move cursor one step
 <SHIFT+CURSOR>      :move cursor to limit
 <ALT+CURSOR UP>     :command history back
 <ALT+CURSOR DOWN>   :command history foreward
 <DEL>               :delete char in line
 <SHIFT+DEL>         :insert space in line
 <ALT+DEL>           :clear screen
 <BACKSPACE>         :backspace
 <SHIFT+BACKSPACE>   :real backspace
 <ALT+BACKSPACE>     :clear line
 <ESC>               :toggle debugger on/off
 <TAB>               :switch between windows
 <SHIFT+ESC>         :insert commandline
 <ALT+ESC>           :copy commandline
 <HELP>              :first helppage
 <SHIFT+HELP>        :second helppage
-------------------------------------------------------------------------------
 Graphic Searcher Function Key Overview
-------------------------------------------------------------------------------
 <CURSOR UP>         :one line up
 <CURSOR DOWN>       :one line down
 <CURSOR RIGHT>      :plane one word down
 <CURSOR LEFT>       :plane one word up
 <SHIFT+UP>          :plane one page down
 <SHIFT+DOWN>        :plane one page up
 <DEL>               :subtract 2 from modulo
 <HELP>              :add 2 to modulo
 <SHIFT+DEL>         :subtract 16 from modulo
 <SHIFT+HELP>        :add 16 to modulo
 <BACKSPACE>         :clear modulo
 <CR>                :switch hires/lores
-------------------------------------------------------------------------------
 Debugger Function Key Overview
-------------------------------------------------------------------------------
 <AMIGA+UP>          :one line up
 <AMIGA+DOWN>        :one line down
 <AMIGA+RIGHT>       :one byte/word up
 <AMIGA+LEFT>        :one byte/word down
 <AMIGA+SHIFT+UP>    :one page up
 <AMIGA+SHIFT+DOWN>  :one page down
 <AMIGA+ALT+UP>      :decrease actual window
 <AMIGA+ALT+DOWN>    :increase actual window
 <AMIGA+S+A+UP>      :dec. window 0, inc. window 1
 <AMIGA+S+A+DOWN>    :inc. window 0, dec. window 1
 <AMIGA+a>           :select asciidump
 <AMIGA+b>           :set/clear breakpoint at top
 <AMIGA+c>           :compare next
 <AMIGA+d>           :select disassembly
 <AMIGA+e>           :edit at startaddr of window
 <AMIGA+f>           :find next
 <AMIGA+g>           :leave subroutine
 <AMIGA+i>           :leave out instruction
 <AMIGA+j>           :jump to startaddr of window
 <AMIGA+k>           :select swiss/american keymap
 <AMIGA+l>           :select copperlist disassembly
 <AMIGA+m>           :select hexdump
 <AMIGA+n>           :assemble at startaddr of window
 <AMIGA+p>           :select text
 <AMIGA+q>           :quit to debug server
 <AMIGA+r>           :recalculate linkterms
 <AMIGA+s>           :split/unsplit window
 <AMIGA+u>           :next step
 <AMIGA+v>           :set/clear resident breakpoint
 <AMIGA+x>           :exit
 <AMIGA+z>           :trace step
 <AMIGA+B>           :set/clear JSR-breakpoint
 <AMIGA+H>           :hardcopy of screen
 <AMIGA+N>           :replace top instruction by NOPs
 <AMIGA+P>           :toggle printer
 <AMIGA+!>           :flush keystatefield
 <AMIGA+?>           :toggle keyboardbuffer killer
 <AMIGA+\>           :toggle Auto Unmodify Traps
 <AMIGA++>           :toggle fully printable charset
 <AMIGA+[>           :indirect (windowaddr=[windowaddr])
 <AMIGA+]>           :exdirect
 <AMIGA+{>           :BCPL indirect
 <AMIGA+}>           :enter last indirect
 <AMIGA+F1-F10>      :toggle F-keys on/off
 <AMIGA+0-9>         :get marked location
 <AMIGA+SHIFT+0-9>   :mark location (only keypad!)
 <AMIGA+SHIFT+RIGHT> :indirect on JMP/Bcc/JSR addresses
 <AMIGA+SHIFT+LEFT>  :exdirect
 <AMIGA+D>           :toggle use of symbols in general
 <AMIGA+S>           :toggle use of symbols for d16(ax)
 <AMIGA+M>           :toggle MMU on/off
 <AMIGA+G>           :perform an additional RTS
 <AMIGA+>>           :scan for access on view address
 <AMIGA+<>           :continue scan
 <AMIGA+ALT+r>       :select large register list
 <AMIGA+L>           :toggle between PAl/NTSC and NTSC overscan
 <AMIGA+Z>           :enable EA calculation for condition BKPTs/trace
-------------------------------------------------------------------------------
