OsGrind configuration file syntax specification
Editor: Thomas Richter
----------------------------------------------------------------------

Introduction:

This file specifies the syntax and syntax elements of the configuration
file of OsGrind, the flexible Os function call validator.

The configuration file is typically kept in the ENV: directory.

The syntax of the configuration is defined such that the files that
come with the AmigaOs SDK can be re-used for OsGrind purposes. In
particular, this makes OsGrind easily upgradable to future Os releases
without requring to update the program.

In particular, OsGrind requires the following two file types from the
AmigaOs SDK:

*) FD files defining the Os functions and its parameters.

*) The assembler include files (".i files") defining Os structures.

Both files can be used without change and can (and should) be included
in OsGrind.config.

----------------------------------------------------------------------

OsGrind configuration files consists of the following syntax elements:

*) Commands. Commands start with a double hash-mark in the first
column. Commands include those commands found in FD-files defining
the Os functions.

*) Function definitions: Function definitions start at the leftmost
column and provide argument names and register assignments. The syntax
of function definitions match those of FD files. A function definition
starts with letters (lower and upper case) and an opening bracket behind
the function name, without any blank spaces. The first pair of brackets
contains the argument names, the second pair the register assignment.

*) Equates: Equates start at the leftmost column with letters (upper
and lower case), but are terminated by blank spaces rather than an
opening bracket, followed by the EQU directive, and an assembler
expression that defines the value of the equate. Equates define
symbolic names for constant values that can be used within ##check
blocks.

*) Directives that define structural elements. Directives start with
blank spaces (SPACE, ASCII 32, or TAB, ASCII 09) followed by the
directive, and its arguments. Arguments of the directives are separated
by space. OsGrind recognizes the macros defined in the AmigaOs
include file <exec/types.i> as directives, and they operate as if
interpreted by an AmigaOs compatible assembler. Unknown directives are
ignored and skipped over.

*) Function check blocks following the ##check function, enclosed in
curly braces. Elements within the check block follow approximately
the syntax of the C language.

*) Comments: Comments start with a * (Star) or ; (Semicolon) in the
leftmost column. They are ignored by OsGrind. Note that OsGrind does
NOT support C or C++ style comments (i.e. /*..*/ and //... )

*) Assembler expressions: Some directives take arguments whose value
is given by an assembler expression. Such an expression is evaluted
to a numerical constant upon interpretation of the configuration
file.

*) Expressions: Arguments of the functions used in the ##check block
are also given by expressions. The syntax of the expression is
closely related to that of the assembler expressions, though some
functional differences exist due to the legacy background of both
types of expressions. Assembler expressions derive from the Motorola
assembler syntax, Expressions derive from the C language. For
example, in Assembler expressions, the ! (exclamation mark) is a
binary operator implementing a binary-or, in the C syntax, this is
expressed by the vertical bar | whereas ! is a unary operator
implementing a logical-NOT.

This syntax definition seems curious, but it was defined such that
existing FD and assembler include files can be re-used without any
change.

----------------------------------------------------------------------

OsGrind Commands:

Command start with a double-hash mark in the first two columns of
a configuration file. The following commands are supported by
OsGrind:


##include "filename"

Includes another file into the include file. Forwards interpretation
of OsGrind to that file, and continues in that file until an EOF
or an ##end command, then continues with the current file. Includes
can be nested.

This is particularly useful to include Os FD files to define function
vectors, or Os structures by including assembler ".i" files.


##end

Terminates the OsGrind configuration file, or an include file. All
lines below ##end are ignored. Interpretation of an OsGrind file
also terminates at the EOF of the file.


##public
##private

Ignored and skipped over. OsGrind learns both private and public
function definitions.


##bias offset

Defines the bias of a function entry relative to a library base.
"offset" is a decimal number defining the byte offset of the next
function relative to the library base, in descending (negative)
direction. For each function definition, the bias is automatically
incremented by 6 bytes.


##base libbase

Defines a symbolic name for the library base. A leading underscore
(i.e. "_") is removed by OsGrind. The library base defines an
implicit argument to functions which is passed into register A6
upon calling Os functions. It can be referenced in ##check blocks
under the name given as argument to ##base, just without the
underscore, and will refer to register A6.


##vectors "libname"

Defines the name of the library (e.g. "exec.library" "dos.library").
The name shall be enclosed in double quotes. OsGrind uses this name
to find or open the library in question.

OsGrind also learns from ##vectors whether the function definition
relates to a library, a device or a resource. For that, it interprets
the string following the dot (".") in the name.

Note that ##vectors is an extension of the FD file syntax, though
borrowed from the COP/DDT syntax of the same author.


##unit unitno

In case the vectors refer to a device, not a library, ##unit defines
the unit number to open by OsGrind. ##unit takes a numerical argument,
encoded as decimal number.


##flags openflags

This defines additional flags that are used for opening devices to
patch their functions. ##flags takes a numerical argument, encoded
as decimal number.


##check functionname {
  ...
}

Defines a check OsGrind shall perform for the arguments of the
function given as first argument. The function name matches the
name of one of the functions defined earlier by function definitions.

The actual check code follows the opening curly brace ("{") on following
lines. A ##check block terminates with a closing curly brace ("}").

The syntax of ##check blocks is defined below.

----------------------------------------------------------------------

Function definitions:

A function definition assigns a name to a library entry point. The
entry point corresponds to the current bias, which is set by the ##bias
command. The bias is incremented automatically by 6 for each seen
function definition.

A function definition starts at the leftmost column, with letters
(A-Z, a-z), and an opening bracket "(".

The first bracket pair defines the function arguments, separated by
comma.

The second bracket pair defines the register assignment within which
these arguments are expected. Registers are "d0" through "d7", and "a0"
through "a6". Registers are separated by comma (",") or slash ("/").
There is no functional difference between commas and slashes.

For example, the function definition:

AddHead(list,node)(a0/a1)

defines a library entry of the name "AddHead" taking two arguments
named "list" and "node", expected in registers "a0" and "a1".

The arguments can be referenced later on in ##check blocks by the
names given in the function definition.

----------------------------------------------------------------------

Equates:

Equates start at the leftmost column with Ascii letters ("A" through
"Z" or "a" through "z"), followed by a blank space, followed by the
EQU directive (see below).

Equates define symbolic names of the value given by the Assembler
expression following the EQU directive.

These symbolic names can be used in a ##check block as a shortcut
or readable alternative of a number.

----------------------------------------------------------------------

Directives:

Directives define Os structures and provide symbolic names to
structure offsets. They also define types of structure components.

Directives always start with one or multiple blank spaces and
can take one or multiple arguments separated by commata (",").


OsGrind understands the following directives:


	STRUCTURE short_name,initial_offset

Start of an Os structure. STRUCTURE takes two arguments:

The first argument defines the name space into which the structure
is placed. It is a short (two or three letter) acronym of the
structure which is ignored by OsGrind.

The second argument is an Assembler expression (see below) which
defines the initial offset at which the first element of the
structure is placed. This is 0 for base-structures, but is non-zero
in case a structure "inherits" another structure as base. In
such a case, the initial offset is the size of the base.


The following directives define structure elements. The structure
offset is automatically incremented by the size of the corresponding
element, and the value of the defined symbolic name is the offset
relative to the start of the structure plus the initial offset:


	UBYTE name

Defines a structure component that is 1 byte large, and assigns to
the structure offset the symbolic name given as argument. The
type of the structure element is an unsigned byte.


     	BYTE name
	
Defines a structure component that is 1 byte large, and assigns to
the structure offset the symbolic name given as argument. The
type of the structure element is a signed byte.


	UWORD name

Defines a structure component that is 2 bytes large, and assigns to
the structure offset the symbolic name given as argument. The
type of the structure element is an unsigned word.


	WORD name

Defines a structure component that is 2 bytes large, and assigns to
the structure offset the symbolic name given as argument. The
type of the structure element is a signed word.


	ULONG name

Defines a structure component that is 4 bytes large, and assigns to
the structure offset the symbolic name given as argument. The
type of the structure element is an unsigned long word.


	LONG name

Defines a structure component that is 4 bytes large, and assigns to
the structure offset the symbolic name given as argument. The
type of the structure element is a signed long word.


	CPTR name
	APTR name
	BPTR name	

Defines a structure component that is 4 bytes large, and assigns to
the structure offset the symbolic name given as argument. The
type of the structure element is a pointer. Note that all these are
equivalent, it is up to the user of these structure elements to
potentially left-shift the values of these elements to convert a
BCPL style BPTR to a C-style APTR. Syntactially, all three are
identical.


	LABEL name

Defines a structural element that is 0 bytes large, and assigns
it a symbolic name that can be referenced in ##check blocks. Labels
are typically used to identify the size of structures, namely
by placing one at the end of it. Note that OsGrid does not provide
a sizeof() operator.


	STRUCT name,size

Defines a structural element that is a variable number of bytes large,
and assigns it a symbolic name. The size is an Assembler expression,
i.e. can be computed. This is typically used to include other
structures in a structure.



that can be referenced in ##check blocks. Labels
are typically used to identify the size of structures, namely
by placing one at the end of it. Note that OsGrid does not provide
a sizeof() operator.


The following additional directives are also understood; they are
unrelated to structure definitions:


label	  EQU expression

Assigns a symbolic name to an expression. The symblic name is defined
on the leftmost column, and is separated by spaces from the EQU
directive. The EQU directive takes an Assembler expression as single
argument.


	BITDEF short_name,name,expr

Defines a pair of equates. The name of the first equate is formed
by concatenating the short_name, the (implicit) string "F_" and
name. Its value is set to 1<<expr, where "<<" indicates left shift.

The second equate is formed by concatenating the short_name, the
(implicit) string "B_" and name. Its value is set to expr.

expr is an Assembler expression that is evaluated and used to
compute the value of the equates that are defined.

For example,

	BITDEF MEM,PUBLIC,0

is equivalent to the following two equates:

MEMF_PUBLIC	EQU	1<<0
MEMB_PUBLIC	EQU	0


All other directives are silently ignored by OsGrind. In particular,
OsGrind DOES NOT understand the "INCLUDE" directive of most assemblers
and ignores it.

Including additional files shall be done by the ##include command
instead.

----------------------------------------------------------------------

Assembler expressions:

Assembler expressions represent values. They are evaluated at compile
time. Assembler expressions support the following operators and
elements:


	0-9,$0-9,A-F,0x0-9,A-F

Numbers evaluate to their value. Numbers can be either decimal,
or hexadecimal. The $ sign, or equivalently the sequences 0x and 0X
introduce a hexadecimal number.


Operators in increasing priority:

	||   	Logical or.
		a || b is 1 if either a or b is non-zero, and is 0
		otherwise.
		
	&&	Logical and.
		a && b is 1 if a and b are non-zero, and is 0
		otherwise.

	! 	Binary or.
		a ! b is computed by logical or-ing the bits of the
		expression a with that of the expression b.

	|	Binary or, identical to !

	^	Binary exclusive or.
		a ^ b is formed by inverting all those bits in a
		which are set in b, i.e. forming an exclusive-or
		of the numerical values of the a and b expression.

	&	Binary and.
		a & b is computed by logical and-ing the expression
		a with that of the expression b.

	==,!=	Comparison for equality and non-equality.
		a == b evaluates to 1 if a is identical to b, and
		evaluates to 0 otherwise.
		a != b evaluates to 1 if a is different from b, and
		evaluates to 1 if they are identical.

	>=,>
	<=,<	Signed comparisons.
		a >= b evaluates to 1 if a is greater or equal to b,
		a >  b evaluates to 1 if a is greater than b,
		a <= b evaluates to 1 if a is smaller or equal to b,
		a <  b evaluates to 1 if a is smaller than b,
		and all the above evaluate to 0 otherwise.
		
		Note that these comparisons take signed 32 bit values,
		i.e. 0xffffffff < 0 evaluates to 1 as the first
		expression is identical to the two's complement
		representation of -1.

	>>,<<	Signed right shift and signed left shift.
		a >> b shifts a b-bits to the right, replicating the
		sign bit.
		a << b shifts a b-bits to the left.

	+,-	Addition and subtraction.
		a+b evaluates to the sum of a and b.
		a-b evaluates to the difference of a and b.

	*,/,%	Signed multiplication, division and remainder.
		a*b evaluates to the product of a and b.
		a/b evaluates to the quotiend of a and b, and
		aborts compilation if b is 0.
		a%b evalutes to the remainder of the division of
		a by b, and aborts compilation if b is 0.
		
		Note that all three operators implement signed
		arithmetics, i.e.
		0xffffffff * a = -a

	-	Unary minus.
		computes the two's component of its right-hand
		argument. -a is the two's component of a.

	+	Unary plus.
		does nothing, returns its right-hand argument.
		+a is a itself.

	~	One's complement.
		~a is the one's complement of a, i.e. formed by
		inverting all bits of a.

	(..)	Groups expressions. Evaluates the expression
		in the brackets first.

	numbers	0-9,$0-$A,0x0-0xA
		evalutes to the number itself.

	symbol	any defined symbol is evaluated to the value it
		was defined to.

----------------------------------------------------------------------

Check blocks:

These blocks define the actual testing logic OsGrind implements.
The syntax of the check blocks follows roughtly the syntax of the
C language. However, OsGind is an (almost) type-less language and
does not perform tests whether a pointer points to the correct type
of an expression.

A check block starts with the command

##check function_name {

on the leftmost column, where <function_name> is the name of the
Os funtion whose parameters are to be tested. The <function_name>
matches a former function definition, i.e. typically from the
inclusion of a ".fd" file.

The check block starts with the curly brace ("{") on the same
line, i.e. the line of the ##check command, and terminates on the
matching closing curly brace ("}").

The ##check block consists of one or multiple assertions that
tests parameters. Currently, OsGrind supports only two assertion,
namely

	assert(expression,"error string",optional-arguments)
and
	on assert(expr,"string",opt-arguments) return expr2

The first assertion does the following: It creates code that 
evalutes <expression> at run-time, and if the expression 
evalutes to 0, OsGrind reports a "Hit", i.e. an error report.

For that, it takes the "error string", uses this as C-style
format string and creates an error report from this string and
the <optional-arguments> which are formatted according to the
error string. Thus, the above is roughly equivalent to the
following segment in the C language:

    if (!expression) printf("error string",optional arguments);

Since the formatting is run through the system RawDoFmt() function,
and arguments are provided as 32-bit values, use "%ld" and "%lx" to
insert decimal or hexadecimal numbers in the output.


The second syntax tests the expression and prints an error string
exactly as the first one, but if an error report is generated, it
also terminates the call without forwarding to the Os, and returns
the value behind the "return" keyword to the caller. That is, the 
second type of assertion is roughly equivalent to:

    if (!expr) { printf("string",opt-arguments); return expr2 }

A ##check block may contain multiple assertions which are checked
from top to bottom. An assertion may optionally be terminated by
a semicolon.

----------------------------------------------------------------------

Expressions:

The first argument of assertions is an Expression. While related,
Expressions are differen from Assembler expressions. The former are
evaluated at run time, as part of the Os function call, the latter
at compile time. The syntax is slightly different, and follows the
rules of the C language.

Within expressions, the Os arguments are available under their
symbolic names given in the function definition, and structure
elements are available through their names defined by the directives.

For example, given the following OsGrind commands and function
definitions

##vectors "exec.library"
##base _SysBase
..
AddPort(port)(a1)
...
   STRUCTURE	LN,0
	APTR	LN_SUCC
	APTR	LN_PRED
	UBYTE	LN_TYPE
	BYTE	LN_PRI
	APTR	LN_NAME
	LABEL	LN_SIZE
...
##check AddPort {
...
}

checks for the exec.library function AddPort() are defined. The
function name "AddPort" in ##check matches the function definition.

Within the check block, the symbol "port" refers to the contents of
register "a1", due to the function definition, and the symbol
"SysBase" refers to register "a6" through the ##base command.

Structure components can be referenced through the C-style "->"
operator, whose right-hand argument shall be a structure component
defined by a directive. Thus, the expression

	port->LN_NAME

takes the argument in register A1, uses it as a pointer, and reads
from the offset LN_NAME relative to the pointer in A1 another
pointer, i.e. a 32-bit value. 

OsGrind is a typeless language, it does not check (and neither has
information on) the type of the pointer. 

Expressions may contain multiple operators, as listed below, in
increasing priority. I.e. Higher priority means that the operators
bind "stronger" and are evaluated first:

	||   	Logical or.
		a || b is 1 if either a or b is non-zero, and is 0
		otherwise. OsGrind implements "shortcut" evaluation,
		i.e. b is not evaluated if a is non-zero.
		
	&&	Logical and.
		a && b is 1 if a and b are non-zero, and is 0
		otherwise. OsGrind implements "shortcut" evaluation,
		i.e. b is not evaluated if a is 0.

	| 	Binary or.
		a | b is computed by logical or-ing the bits of the
		expression a with that of the expression b. Note
		that unlike Assembler expressions, ! is NOT identical
		to the | operator.

	^	Binary exclusive or.
		a ^ b is formed by inverting all those bits in a
		which are set in b, i.e. forming an exclusive-or
		of the numerical values of the a and b expression.

	&	Binary and.
		a & b is computed by logical and-ing the expression
		a with that of the expression b.

	==,!=	Comparison for equality and non-equality.
		a == b evaluates to 1 if a is identical to b, and
		evaluates to 0 otherwise.
		a != b evaluates to 1 if a is different from b, and
		evaluates to 1 if they are identical.

	}=,}
	{=,{	Unsigned comparisons.
	>=,>
	<=,<	Signed comparisons.
		a >= b evaluates to 1 if a is greater or equal to b,
		a >  b evaluates to 1 if a is greater than b,
		a <= b evaluates to 1 if a is smaller or equal to b,
		a <  b evaluates to 1 if a is smaller than b,
		a }= b evaluates to 1 if a is higher or same than b,
		a }  b evaluates to 1 if a is higher than b,
		a {= b evaluates to 1 if a is lower or same than b,
		a {  b evaluates to 1 if a is lower than b,
		and all the above evaluate to 0 otherwise.

		Note that >=,>,<=,< implement signed comparison,
		using two's complement interpretation of bits, whereas
		}=,},{=,{ implement unsigned comparisons using all
		bits for comparison.

		Unfortunately, the function definition lacks type
		declarations, thus the signed-ness of a type is not
		(necessarily) availalbe to OsGrind. Instead, the
		type of arguments are deduced from the comparison
		operator.

	}},{{	Unsigned right shift and unsigned left shift.
	>>,<<	Signed right shift and signed left shift.
		a >> b shifts a b-bits to the right, replicating the
		sign bit.
		a }} b shifts a b-bits right, including the MSB
		which is also shifted right.
		a << b shifts a b-bits to the left.
		a {{ b is identical to a << b.

	+,-	Addition and subtraction.
		a+b evaluates to the sum of a and b.
		a-b evaluates to the difference of a and b.

	*,/,%	Signed multiplication, division and remainder.
		a*b evaluates to the product of a and b.
		a/b evaluates to the quotiend of a and b, and
		aborts compilation if b is 0.
		a%b evalutes to the remainder of the division of
		a by b, and aborts compilation if b is 0.
		
		Note that all three operators implement signed
		arithmetics, i.e.
		0xffffffff * a = -a

	-	Unary minus.
		computes the two's component of its right-hand
		argument. -a is the two's component of a.

	+	Unary plus.
		does nothing, returns its right-hand argument.
		+a is a itself.

	!	Logical complement.
		!a evaluates to 0 if a is non-zero, and
		!a evaluates to 1 if a is 0.

	~	One's complement.
		~a is the one's complement of a, i.e. formed by
		inverting all bits of a.

	a->b	Takes the left-hand argument, uses it as a pointer,
		and retrieves the structure component whose name
		is given by the right argument. The structure shall
		be defined by a STRUCTURE directive.

	a.b	Takes the left-hand argument, which shall be a
		structure component defined by STRUCT, and
		reads from it the structure component given by the
		name of the right-hand argument.

	(..)	Groups expressions. Evaluates the expression
		in the brackets first.

	UBYTE(a) cast to UBYTE
		evaluates the expression a and takes the 8 least
		significant bits of it, clearing all remaining bits.

	BYTE(a) cast to BYTE
		evaluates the expression a and sign-extents the 8
		least significant bits to full width.

	UWORD(a) cast to UWORD
		evaluates the expression a and takes the 16 least
		significant bits of it, clearning all remaining bits.

	WORD(a)	cast to WORD
		evaluates the expression a and sign-extents the 16
		least significant bits to full width.

	LONG(a) cast to LONG
		does nothing, only provided for consistency.
		
	ULONG(a) cast to ULONG
		does nothing, only provided for consistency.

	BPTR(a)	cast from BPTR
		left-shift the argument by two, converting the
		argument from a BCPL value to a regular pointer.

	strlen(a) string length
		compute the length of a C-style string.

	TypeOfMem(a) memory type
		returns the memory type as exec-type flags.

	GetTagData(id,default,tags)
		retrieves from the tag list given as last argument
		the tag given by the first argument, returning the
		default given as middle argument if not present.

	args	Function arguments.
		Function evaluate to their values, i.e. args
		evaluates to the contents of the register whose
		symbolic name is given in the function definition.

	eqn	Equates
		Evaluate to their values defined by a LABEL or
		EQU directive.

	numbers	0-9,$0-$A,0x0-0xA
		evalutes to the number itself.

	symbol	any defined symbol is evaluated to the value it
		was defined to.

Note that OsGrind does not define a sizeof() operator. Instead,
the label defined at the end of the structure definition can be
used as replacement. I.e. the expression "LN_SIZE" evaluates to
the size of the "Node" structure.

----------------------------------------------------------------------

Hints:

The assertions require its first argument to be TRUE to avoid an
error report, i.e. the first argument defines a condition that
shall be met for the call to be correct.

Some Os functions only use the lower bits of the arguments. To ignore
the upper bits, use the cast operators UWORD/WORD/UBYTE/BYTE to ignore
or sign-extend the arguments to the full width.


