;$VER: OsGrind.config 40.2 (20.01.2020)
##vectors "exec.library"
##include "FD:exec_lib.fd"
##include "INCLUDE:exec/nodes.i"
##include "INCLUDE:exec/lists.i"
##include "INCLUDE:exec/libraries.i"
##include "INCLUDE:exec/interrupts.i"
##include "INCLUDE:exec/ports.i"
##include "INCLUDE:exec/io.i"
##include "INCLUDE:exec/semaphores.i"
##include "INCLUDE:exec/execbase.i"
*------------------ exec.library checks ----------------------------------------
##check AddPort {
on assert(port,"AddPort: Port shall be non-NULL") return 0;
assert(port->LN_NAME,"AddPort: Port name not initialized");
}
##check AllocMem {
on assert(byteSize,"AllocMem: byteSize must be non-zero") return 0;
assert(byteSize >= 0,"AllocMem: negative byteSize unpredictable to flush memory");
}
##check AllocVec {
on assert(byteSize,"AllocVec: byteSize must be non-zero") return 0;
assert(byteSize >= 0,"AllocVec: negative byteSize unpredictable to flush memory");
}
##check CopyMem {
assert(!(dest >= source && dest < source + size),"CopyMem: memory areas shall be non-overlapping");
}
##check CopyMemQuick {
assert((source & 3) == 0 && (dest & 3) == 0,"CopyMemQuick: source and destination shall be long-word aligned");
assert(!(dest >= source && dest < source + size),"CopyMemQuick: memory areas shall be non-overlapping");
}
##check CreateIORequest {
on assert(port,"CreateIORequest: porst shall be non-NULL") return 0;
assert(size >= IO_SIZE,"CreateIORequest: IORequest size shall be at least IO_SIZE");
assert(port->MP_FLAGS == PA_SIGNAL && port->MP_SIGTASK,"CreateIORequest: ioReplyPort shall be initialized");
}
##check DeleteMsgPort {
on assert(port,"DeleteMsgPort: Port shall be non-NULL") return 0;
assert(port->MP_MSGLIST.LH_HEAD->LN_SUCC == 0,"DeleteMsgPort: Port shall be empty upon deletion");
}
##check Enable {
assert(SysBase->IDNestCnt >= 0,"Enable: shall match a corresponding Disable()");
}
##check Permit {
assert(SysBase->TDNestCnt >= 0,"Permit: shall match a corresponding Forbid()");
}
##check FindPort {
assert(SysBase->IDNestCnt >= 0 || SysBase->TDNestCnt >= 0,
	"FindPort: Shall be called in Forbid() or Disable() lock to ensure reliable result");
}
##check FindSemaphore {
assert(SysBase->IDNestCnt >= 0 || SysBase->TDNestCnt >= 0,
	"FindSemaphore: Shall be called in Forbid() or Disable() lock to ensure reliable result");
}
##check FindTask {
assert(name == 0 || SysBase->IDNestCnt >= 0 || SysBase->TDNestCnt >= 0,
	"FindTask: Shall be called in Forbid() or Disable() lock to ensure reliable result");
}
##check FreeSignal {
assert(signalNum >= 0,"FreeSignal: signalNum shall be non-negative");
assert(signalNum < 0 || signalNum >= 16,"FreeSignal: Shall only release user signals");
}
##check InitSemaphore {
on assert(sigSem,"InitSemaphore: Semaphore pointer shall be non-NULL") return 0;
assert(sigSem->SS_NESTCOUNT == 0 && sigSem->SS_WAITQUEUE.MLH_HEAD == 0 && sigSem->SS_WAITQUEUE.MLH_TAIL == 0 &&
       sigSem->SS_WAITQUEUE.MLH_TAILPRED == 0 &&
       sigSem->SS_MULTIPLELINK.MLN_SUCC == 0 && sigSem->SS_MULTIPLELINK.MLN_PRED == 0 &&
       sigSem->SS_MULTIPLELINK.SSR_WAITER == 0 &&
       sigSem->SS_OWNER == 0 && sigSem->SS_QUEUECOUNT == 0 &&
       sigSem->LN_SUCC == 0 && sigSem->LN_PRED == 0 && sigSem->LN_TYPE == 0 &&
       sigSem->LN_NAME == 0,
       "InitSemphore: All fields shall be cleared to 0");
}
##check OldOpenLibrary {
assert(0,"OldOpenLibrary: This function is obsolete and shall not be used");
}
##check Procure {
assert(SysBase->LIB_VERSION >= 39,"Procure: Non working for ExecBase version < 39");
}
##check Vacate {
assert(SysBase->LIB_VERSION >= 39,"Vacate: Non working for ExecBase version < 39");
}
##check ReleaseSemaphore {
on assert(sigSem,"ReleaseSemaphore: Semaphore pointer shall be non-NULL") return 0;
assert(sigSem->SS_NESTCOUNT > 0,"ReleaseSemaphore: Semaphore is shall be locked upon release");
}
##check SetFunction {
assert(SysBase->IDNestCnt >= 0 || SysBase->TDNestCnt >= 0,
	"SetFunction: Shall be called in Forbid() or Disable() lock to ensure reliable result");
on assert(funcOffset < 0,"SetFunction: Function offset shall be negative") return 0;
on assert(-funcOffset <= library->LIB_NEGSIZE,"SetFunction: Target function does not exist") return 0;
}
##check AddDevice {
on assert(device,"AddDevice: Device shall be non-NULL") return 0;
assert(device->LN_TYPE == NT_DEVICE,"AddDevice: Node to be added shall be a device");
}
##check AddIntServer {
assert(intNumber >= 0 && intNumber <= 31,"AddIntServer: Interrupt number must be between 0 and 31");
on assert(interrupt,"AddIntServer: interrupt must be non-NULL") return 0;
assert(interrupt->LN_TYPE == NT_INTERRUPT,"AddIntServer: interrupt shall be of type NT_INTERRUPT");
on assert(interrupt->IS_CODE,"AddIntServer: is_Code shall be non-NULL") return 0;
}
*------------------ dos.library checks ----------------------------------------
##vectors "dos.library"
##include "FD:dos_lib.fd"
##include "INCLUDE:dos/dos.i"
##check Open {
assert(accessMode == MODE_OLDFILE || 
       accessMode == MODE_READWRITE || 
       accessMode == MODE_NEWFILE,
       "Open: mode %ld invalid, shall be MODE_OLDFILE, MODE_READWRITE or MODE_NEWFILE",
       accessMode);
}
##check Lock {
assert(type == SHARED_LOCK || type == EXCLUSIVE_LOCK,
       "Lock: mode %ld invalid, shall be SHARED_LOCK or EXCLUSIVE_LOCK",type);
}
##check CreateProc {
assert(pri >= -128 && pri <= 127,"CreateProc: Priority shall be between -128 and 127");
assert((stackSize & 3) == 0,"CreateProc: stackSize shall be divisible by 4");
assert(stackSize >= 512,"CreateProc: stackSize shall be larger than 512");
}
##check Examine {
assert((fileInfoBlock & 3) == 0,"Examine: fileInfoBlock shall be longword aligned");
}
##check ExNext {
assert((fileInfoBlock & 3) == 0,"ExNext: fileInfoBlock shall be longword aligned");
}
##check ExamineFH {
assert((fib & 3) == 0,"ExamineFH: fileInfoBlock shall be longword aligned");
}
##check ExAll {
assert((buffer & 1) == 0,"ExAll: buffer shall be word aligned");
}
##check ExAllEnd {
assert((buffer & 1) == 0,"ExAllEnd: buffer shall be word aligned");
}
##check Info {
assert((parameterBlock & 3) == 0,"Info: parameterBlock shall be longword aligned");
}
##check MatchFirst {
assert((anchor & 3) == 0,"MatchFirst: anchor shall be longword aligned");
}
##check MatchNext {
assert((anchor & 3) == 0,"MatchNext: anchor shall be longword aligned");
}
##check MatchEnd {
assert((anchor & 3) == 0,"MatchEnd: anchor shall be longword aligned");
}
##check RunCommand {
on assert(paramptr,"RunCommand: Parameters shall be non-NULL") return 0;
assert(strlen(paramptr) == paramlen,"RunCommand: paramlen shall be identical to strlen(paramptr)");
}
##check SetVBuf {
assert(DOSBase->LIB_VERSION >= 40,"SetVBuf: Not implemented until V40");
assert((buff & 3) == 0,"SetVBuf: buffer shall be longword aligned");
}
*------------------ graphics.library checks -------------------------------------------
##vectors "graphics.library"
##include "FD:graphics_lib.fd"
##include "INCLUDE:utility/tagitem.i"
##include "INCLUDE:graphics/gfx.i"
##include "INCLUDE:graphics/gfxnodes.i"
##include "INCLUDE:graphics/view.i"
##include "INCLUDE:graphics/rastport.i"
##include "INCLUDE:graphics/scale.i"
##include "INCLUDE:graphics/sprite.i"
##include "INCLUDE:graphics/displayinfo.i"
##include "INCLUDE:graphics/modeid.i"
##check AreaEllipse {
assert(WORD(a) > 0 && WORD(b) > 0,"AreaEllipse: Ellipse radii shall be > 0");
}
##check DrawEllipse {
assert(WORD(a) > 0 && WORD(b) > 0,"DrawEllipse: Ellipse radii shall be > 0");
}
##check BitMapScale {
on assert(bitScaleArgs,"BitMapScale: bitScaleArgs shall be non-NULL") return 0;
assert(bitScaleArgs->bsa_XSrcFactor >= 1 && bitScaleArgs->bsa_XSrcFactor < 16384,
       "BitMapScale: bsa_XSrcFactor shall be between 1 and 16383");
assert(bitScaleArgs->bsa_YSrcFactor >= 1 && bitScaleArgs->bsa_YSrcFactor < 16384,
       "BitMapScale: bsa_YSrcFactor shall be between 1 and 16383");
assert(bitScaleArgs->bsa_XDestFactor >= 1 && bitScaleArgs->bsa_XDestFactor < 16384,
       "BitMapScale: bsa_XDestFactor shall be between 1 and 16383");
assert(bitScaleArgs->bsa_YDestFactor >= 1 && bitScaleArgs->bsa_YDestFactor < 16384,
       "BitMapScale: bsa_YDestFactor shall be between 1 and 16383");
assert(bitScaleArgs->bsa_Flags == 0,"BitMapScale: bsa_Flags shall be 0");
assert(bitScaleArgs->bsa_XSrcFactor != bitScaleArgs->bsa_XDestFactor || bitScaleArgs->bsa_SrcWidth > 1024,
       "BitMapScale: bsa_SrcWidth shall be <= 1024 if src and dest X factors are identical");
assert(bitScaleArgs->bsa_YSrcFactor > bitScaleArgs->bsa_YDestFactor ||
       (bitScaleArgs->bsa_DestX & 0xf) + bitScaleArgs->bsa_DestWidth < 1024,
       "BitMapScale: dest Width shall be < 1024 if expanding in Y direction");
}
##check ChangeVPBitMap {
on assert(bm && vp,"ChangeVPBitMap: bitmap and viewport pointers shall be non-NULL") return 0;
assert(bm->bm_BytesPerRow == vp->vp_RasInfo->ri_BitMap->bm_BytesPerRow &&
       bm->bm_Rows        == vp->vp_RasInfo->ri_BitMap->bm_Rows &&
       bm->bm_Depth       == vp->vp_RasInfo->ri_BitMap->bm_Depth,
       "ChangeVPBitMap: new bitmap layout shall match layout of currently active bitmap");
}
##check EraseRect {
assert(WORD(xMin) <= WORD(xMax) && WORD(yMin) <= WORD(yMax),"EraseRect: min shall be <= max");
}
##check FreeColorMap {
assert(colorMap,"FreeColorMap: colorMap shall be non-NULL");
}
##check GetExtSpriteA {
assert(GfxBase->LIB_VERSION >= 40,"GetExtSpriteA: this function is insecure below V40");
}
##check ChangeSprite {
assert(TypeOfMem(newData) & 2,"ChangeSprite: sprite data shall be in CHIP RAM");
}
##check AllocSpriteDataA {
on assert(bm && tags,"AllocSpriteData: bitmap and tags shall be non-NULL") return 0;
assert((bm->bm_BytesPerRow << 3) >= GetTagData(SPRITEA_Width,0,tags),
       "AllocSpriteDataA: Bitmap is too small for the width");
assert(bm->bm_Rows >= GetTagData(SPRITEA_OutputHeight,0,tags),
       "AllocSpriteDataA: Bitmap is too small for the height");
}
##check MakeVPort {
on assert(vp,"MakeVPort: ViewPort shall be non-NULL") return 0;
assert(vp->vp_RasInfo,"MakeVPort: vp_RasInfo shall be non-NULL")
}
##check RectFill {
assert(WORD(xMin) <= WORD(xMax) && WORD(yMin) <= WORD(yMax),"RectFill: min shall be <= max");
}
##check ScalerDiv {
assert(UWORD(factor) >= 0 && UWORD(factor) <= 16383,"ScalerDiv: factor shall be in range 0..16383");
assert(UWORD(numerator) >= 1 && UWORD(numerator) <= 16383,"ScalerDiv: numerator shall be in range 1..16383");
assert(UWORD(denominator) >= 1 && UWORD(denominator) <= 16383,"ScalerDiv: numerator shall be in range 1..16383");
}
##check SetChipRev {
assert(0,"SetChipRev: This function shall only be called by SetPatch");
}
##check SetFont {
on assert(textFont,"SetFont: textFont shall be non-NULL") return 0;
}
##check SetMaxPen {
assert(maxpen > 0,"SetMaxPen: maxpen shall be > 0");
}
##check BestModeIDA {
on assert(tags,"BestModeIDA: tags shall be non-NULL") return 0;
assert(GetTagData(BIDTAG_NominalWidth,1,tags) > 0,"BestModeIDA: BIDTAG_NominalWidth shall be > 0");
assert(GetTagData(BIDTAG_NominalHeight,1,tags) > 0,"BestModeIDA: BIDTAG_NominalHeight shall be > 0");
assert(GetTagData(BIDTAG_DesiredWidth,1,tags) > 0,"BestModeIDA: BIDTAG_DesiredWidth shall be > 0");
assert(GetTagData(BIDTAG_DesiredHeight,1,tags) > 0,"BestModeIDA: BIDTAG_DesiredHeight shall be > 0");
}
*------------------ intuition.library checks ------------------------------------------
##vectors "intuition.library"
##include "FD:intuition_lib.fd"
##include "INCLUDE:devices/timer.i"
##include "INCLUDE:devices/inputevent.i"
##include "INCLUDE:intuition/intuition.i"
##check CloseWindow {
on assert(window,"CloseWindow: window shall be non-NULL") return 0;
assert(window->wd_UserPort == 0 || window->wd_UserPort->MP_MSGLIST.LH_HEAD->LN_SUCC == 0,
      "CloseWindow: IDCMP Port shall be not empty");
assert(window->wd_MenuStrip == 0,"CloseWindow: MenuStrip shall be empty");
}
##check EasyRequestArgs {
assert(easyStruct->es_StructSize >= EasyStruct_SIZEOF,
       "EasyRequestArgs: es_StructSize shall be at least EasyStruct_SIZEOF bytes large");
}
##check GadgetMouse {
assert(1,"GadgetMouse: This function is obsolete");
}
##check MakeClass {
assert(superClassID || superClassPtr,"MakeClass: superClassPtr and superClassID shall not both be NULL");
}
##check ModifyIDCMP {
on assert(window,"ModifyIDCMP: window shall be non-NULL") return 0;
assert(flags || window->wd_UserPort == 0 || window->wd_UserPort->MP_MSGLIST.LH_HEAD->LN_SUCC == 0,
      "ModifyIDCMP: IDCMP is not empty before setting IDCMP flags to 0");
}
##check ScreenDepth {
assert(reserved == 0,"ScreenDepth: reserved shall be set to 0 for forward compatibility");
}
##check SetMenuStrip {
assert(window && menu,"SetMenuStrip: window and menu shall be non-NULL");
}
##check SetPointer {
assert(width <= 32,"SetPointer: pointer width shall be <= 32");
assert(-xOffset >= 0 && -xOffset <= width && -yOffset >= 0 && -yOffset <= height,
       "SetPointer: hot spot shall be within the sprite image");
}
*------------------ gadtools.library checks -------------------------------------------
##vectors "gadtools.library"
##include "FD:gadtools_lib.fd"
##include "INCLUDE:intuition/gadgetclass.i"
##include "INCLUDE:libraries/gadtools.i"
##check CreateGadgetA {
assert(kind >= 0 && kind <= 14 && kind != 10,"CreateGadgetA: Gadget kind %ld is unsupported, shall be >= 0 and <= 14");
on assert(gad,"CreateGadgetA: previous gadget pointer gad shall not be NULL") return 0;
on assert(ng,"CreateGadgetA: new gadget shall not be NULL") return 0;
assert(ng->gng_VisualInfo != 0,"CreateGadgetA: ng->VisualInfo shall not be NULL");
assert(ng->gng_TextAttr != 0,"CreateGadgetA: ng->TextAttr shall not be NULL");
}
##check GT_GetGadgetAttrsA {
assert(req == 0,"GT_GetGadgetAttrsA: req argument shall be NULL for forward compatibility");
}
##check GT_RefreshWindow {
assert(req == 0,"GT_RefreshWindow: req argument shall be NULL for forward compatibility");
}
##check GT_SetGadgetAttrsA {
assert(req == 0,"GT_SetGadgetAttrsA: req argument shall be NULL for forward compatibilty");
}
*------------------ commodities.library checks ----------------------------------------
##vectors "commodities.library"
##include "FD:commodities_lib.fd"
##include "INCLUDE:libraries/commodities.i"
##check AttachCxObj {
assert(CxBase->LIB_VERSION >= 38 || headObj != 0,"AttachCxObj: headObj shall be non-NULL for V37 and below")
}
##check CxBroker {
on assert(nb,"CxBroker: newBroker pointer shall be non-NULL") return 0;
assert(nb->nb_Version == NB_VERSION,"CxBroker: nb->nb_Version shall be NB_VERSION");
assert(nb->nb_Name,"CxBroker: Name shall be non-NULL");
assert(nb->nb_Title,"CxBroker: Title shall be non-NULL");
assert(nb->nb_Descr,"CxBroker: Description shall be non-NULL");
on assert(nb->nb_Name,"CxBroker: nb_Name shall be non-NULL") return 0;
assert(strlen(nb->nb_Name) < CBD_NAMELEN,"CxBroker: Name shall be shorter than CBD_NAMELEN");
on assert(nb->nb_Title,"CxBroker: nb_Title shall be non-NULL") return 0;
assert(strlen(nb->nb_Title) < CBD_TITLELEN,"CxBroker: Title shall be shorter than CBD_TITLELEN");
on assert(nb->nb_Descr,"CxBroker: nb_Descr shall be non-NULL") return 0;
assert(strlen(nb->nb_Descr) < CBD_DESCRLEN,"CxBroker: Description shall be shorter than CBD_DESCRLEN");
assert(nb->nb_Unique {= 3,"CxBroker: nb_Unique value %ld is invalid, shall be <= 3",nb->nb_Unique);
}
##check CxMsgData {
assert(CxBase->LIB_VERSION >= 38 || cxm,"CxMsgData: cxm shall be non-NULL for V37 and below");
}
##check CxMsgID {
assert(CxBase->LIB_VERSION >= 38 || cxm,"CxMsgID: cxm shall be non-NULL for V37 and below");
}
##check CxMsgType {
assert(CxBase->LIB_VERSION >= 38 || cxm,"CxMsgType: cxm shall be non-NULL for V37 and below");
}
##check DisposeCxMsg {
assert(cxm,"DisposeCxMsg: cxm shall be non-NULL");
}
##check DivertCxMsg {
assert(cxm,"DivertCxMsg: cxm shall be non-NULL");
}
##check EnqueueCxObj {
assert(CxBase->LIB_VERSION >= 38 || headObj,"EnqueueCxObj: cxm shall be non-NULL");
}
##check InsertCxObj {
assert(CxBase->LIB_VERSION >= 38 || headObj,"InsertCxObj: cxm shall be non-NULL");
}
##check RouteCxMsg {
assert(cxm,"RouteCxMsg: cxm shall be non-NULL");
assert(co,"RouteCxMsg: co shall be non-NULL");
}
##check SetCxObjPri {
assert(pri >= -128 && pri <= 127,"SetCxObjPri: Priority shall be between -128 and 127");
}
*------------------ utility.library checks ----------------------------------------
##vectors "utility.library"
##include "FD:utility_lib.fd"
##include "INCLUDE:utility/name.i"
##check AllocNamedObjectA {
assert(name,"AllocNamedObject: name shall be non-NULL");
assert((GetTagData(ANO_Flags,0,tagList) & ~(NSF_NODUPS | NSF_CASE)) == 0,
       "AllocNamedObject: ANO_Flags shall only contain bits NSF_NODUPS or NSF_CASE");
}
##check MapTags {
assert(UtilityBase->LIB_VERSION >= 39 || mapType == MAP_KEEP_NOT_FOUND,
       "MapTags: For V39, mapType shall be MAP_KEEP_NOT_FOUND");
assert(mapType == MAP_KEEP_NOT_FOUND || MAP_REMOVE_NOT_FOUND,
       "MapTags: mapType shall be MAP_KEEP_NOT_FOUND or MAP_REMOVE_NOT_FOUND");
}
