;Install memory window keys
;
;This file is the same as 'mkeys' except for the extra comments.
;If you read this file carefully you will surely know a lot more about
;PowerVisor.
;
;The general syntax in this file is :
;
;  <command>
;  <<< general explanation of command (behaviour, expected arguments, ...)
;     {argument list}
;  >>> execution of command (what happens, returned result, ...)
;     ...
;

-openpw memory 0 0 640 200
   ;Open a physical window 'memory'. In this physical window we will open
   ;our logical window. If you want the 'memory' logical window in the
   ;'Main' (the default) physical window you can remove this command
   ;and replace the first 'memory' in the next command with 'main'.
   ;You also need to replace all occurences of 'closepw' in this file
   ;with 'closelw'.
   ;The '-' in front of this line prevents output from the 'openpw'
   ;command to appear on your default logical window (probably 'Main').
   ;This is a bit cleaner.

-openlw memory memory 80 40
   ;Open the 'memory' logical window in the 'memory' physical window.
   ;The output of our memory view will appear in this logical window.
   ;There are 80 columns and 40 rows in the logical window.

-setflag memory 128+32 128+32
   ;Here we set some flags for our logical window.
   ;The 128 flag is set indicating that the user can't interrupt the output
   ;in the 'memory' logical window with <Esc>
   ;The 32 flag is set indicating that the home position of the logical
   ;window is equal to the topmost position. The home position is the
   ;place where all output starts if the window was just cleared.

memptr=0
   ;Our variable containing the pointer to the memory we are currently
   ;viewing. We start at address 0

alias _vm 'on memory {home;m memptr}'
   ;To make life easier for us, we install this alias command.
   ;This command refreshes the memory display on the 'Memory' logical
   ;window.

alias _ra 'remattach []'
   ;To make life easier for us, we install this alias command.
   ;This command removes a key attachement (see later)

_vm
   ;Refresh the memory display.

   ;The following commands install all the keys used to scroll in
   ;the memory view. The variables _k<x> are used so that we can
   ;remove these keys later.
   ;The 'attach' command attaches a command to a key. The first argument
   ;is the command string to execute when the user later presses that key.
   ;The second and third arguments are the key code and qualifier. The
   ;last argument indicates if we should see feedback for the command on
   ;the screen ('e' means no feedback).
   ;I will only explain the the most difficult key assignment. The other
   ;ones are similar and easier.

_k1={attach '{memptr=memptr-16;_vm}' 03e 01 e}
_k2={attach '{memptr=memptr+16;_vm}' 01e 01 e}
_k3={attach '{memptr=memptr-1;_vm}' 02d 01 e}
_k4={attach '{memptr=memptr+1;_vm}' 02f 01 e}
_k5={attach '{memptr=memptr-(20*16);_vm}' 03f 01 e}
_k6={attach '{memptr=memptr+(20*16);_vm}' 01f 01 e}
_k7={attach '_vm' 02e 01 e}
_k8={attach '{getstring \'Give address\' 256;memptr=eval(input);_vm}' 0f 01 e}
_k9={attach '{v if((mode)&3,if(((mode)&3)==1,{mode word},{mode byte}),{mode long});_vm}' 03c 01 e}
   ;_k9=
   ;<<< assignment to _k9, argument is :
   ;  {attach '{v if((mode)&3,if(((mode)&3)==1,{mode word},{mode byte}),{mode long});_vm}' 03c 01 e}
   ;>>> we evaluate this expression :
   ;  {
   ;  <<< group operator, argument is :
   ;     attach '{v if((mode)&3,if(((mode)&3)==1,{mode word},{mode byte}),{mode long});_vm}' 03c 01 e
   ;  >>> the 'attach' command is executed :
   ;     attach
   ;     <<< attach command, this command attaches a command to a key. This
   ;     <<< command has four arguments :
   ;        '{v if((mode)&3,if(((mode)&3)==1,{mode word},{mode byte}),{mode long});_vm}'
   ;        03c
   ;        01
   ;        e
   ;     <<< the first argument is the command to be assigned. The second and third
   ;     <<< arguments are the code and qualifer for the key. The last argument
   ;     <<< ('e') states that the command must not be added to the commandline
   ;     <<< history when the key is pressed (no feedback).
   ;     <<< The string is parsed, this results in :
   ;        {v if((mode)&3,if(((mode)&3)==1,{mode word},{mode byte}),{mode long});_vm}
   ;     >>> The key attachement is make.
   ;     >>> result of 'attach' command is the pointer to the key attachement node.
   ;  >>> result of group operator is the pointer to the key attachement node.
   ;>>> _k9=pointer to the key attachement node.

   ;When the key is pressed later, the following command is executed as if it
   ;was typed in at that moment :
   ;{v if((mode)&3,if(((mode)&3)==1,{mode word},{mode byte}),{mode long});_vm}
   ;{
   ;<<< group operator, execute all arguments :
   ;  v if((mode)&3,if(((mode)&3)==1,{mode word},{mode byte}),{mode long})
   ;  _vm
   ;>>> First execution results in :
   ;  v
   ;  <<< void command, evaluate all arguments :
   ;     if((mode)&3,if(((mode)&3)==1,{mode word},{mode byte}),{mode long})
   ;  >>> First argument is evaluated :
   ;     if
   ;     <<< if function, evaluate first argument, if true then evaluate
   ;     <<< second argument else evaluate last argument. Arguments for
   ;     <<< 'if' are :
   ;        (mode)&3
   ;        if(((mode)&3)==1,{mode word},{mode byte})
   ;        {mode long}
   ;     >>> if (mode)&3 (the last two bits of the mode variable) are not equal
   ;     >>> to 0, the first string is evaluated :
   ;        if
   ;        <<< if function, evaluate first argument, if true then evaluate
   ;        <<< second argument else evaluate last argument. Arguments for
   ;        <<< 'if' are :
   ;           ((mode)&3)==1
   ;           {mode word}
   ;           {mode byte}
   ;        >>> if mode&3 is equal to 1, the first string is evaluated :
   ;           {
   ;           <<< group operator, argument is :
   ;              mode word
   ;           >>> execution of command results in the 'word' memory display
   ;           >>> setting to be initialized.
   ;        >>> if mode&3 is not equal to 1, the second string is evaluted :
   ;           {
   ;           <<< group operator, argument is :
   ;              mode byte
   ;           >>> execution of command results in the 'byte' memory display
   ;           >>> setting to be initialized.
   ;        >>> result of 'if' is that either 'word' or 'byte' is choosen
   ;        >>> as the memory display setting.
   ;     >>> if mode&3 is equal to 0, the second string is evaluated :
   ;        {
   ;        <<< group operator, argument is :
   ;           mode long
   ;        >>> execution of command results in the 'long' memory display setting
   ;        >>> to be initialized.
   ;     >>> result of this 'if' is that one of 'byte', 'word' or 'long' memory
   ;     >>> display mode is choosen depending on the previous setting.
   ;  >>> This is also the result of the 'void' command.
   ;>>> The second argument of the group operator is also executed :
   ;  _vm
   ;  <<< alias for refreshing of memory display, no arguments.
   ;  >>> refresh the memory display.
   ;>>> this command toggles between 'byte', 'word' or 'long' memory display
   ;>>> and refreshes the display.

_mkeys={attach '{closepw memory;remvar memptr;_ra \(_k1);_ra \(_k2);_ra \(_k3);_ra \(_k4);_ra \(_k5);_ra \(_k6);_ra \(_k7);_ra \(_k8);_ra \(_k9);_ra _mkeys;remvar _mkeys;unalias _vm;unalias _ra}' 01d 09 e}
   ;This command installs a command on Ctrl+Shift-1 to remove all aliases and
   ;all key attachements.
   ;_mkeys=
   ;<<< assignment to _mkeys, argument is :
   ;  {attach '{closepw memory;remvar memptr;_ra \(_k1);_ra \(_k2);_ra \(_k3);_ra \(_k4);_ra \(_k5);_ra \(_k6);_ra \(_k7);_ra \(_k8);_ra \(_k9);_ra _mkeys;remvar _mkeys;unalias _vm;unalias _ra}' 01d 09 e}
   ;>>> we evaluate this expression :
   ;  {
   ;  <<< group operator, argument is :
   ;     attach '{closepw memory;remvar memptr;_ra \(_k1);_ra \(_k2);_ra \(_k3);_ra \(_k4);_ra \(_k5);_ra \(_k6);_ra \(_k7);_ra \(_k8);_ra \(_k9);_ra _mkeys;remvar _mkeys;unalias _vm;unalias _ra}' 01d 09 e
   ;  >>> the 'attach' command is executed :
   ;     attach
   ;     <<< attach command, this command attaches a command to a key. This
   ;     <<< command has four arguments :
   ;        '{closepw memory;remvar memptr;_ra \(_k1);_ra \(_k2);_ra \(_k3);_ra \(_k4);_ra \(_k5);_ra \(_k6);_ra \(_k7);_ra \(_k8);_ra \(_k9);_ra _mkeys;remvar _mkeys;unalias _vm;unalias _ra}'
   ;        01d
   ;        09
   ;        e
   ;     <<< the first argument is the command to be assigned. The second and third
   ;     <<< arguments are the code and qualifer for the key. The last argument
   ;     <<< ('e') states that the command must not be added to the commandline
   ;     <<< history when the key is pressed (no feedback).
   ;     <<< The string is parsed, this results in :
   ;        {closepw memory;remvar memptr;_ra 123;_ra 124;_ra 125;_ra 126;_ra 127;_ra 128;_ra 129;_ra 130;_ra 131;_ra _mkeys;remvar _mkeys;unalias _vm;unalias _ra}
   ;     <<< Note how I replaced the \(_k<x>) construction with a number. This
   ;     <<< number is the address of the variable _k<x> (the numbers choosen
   ;     <<< in this example are completely arbitrary and are even impossible).
   ;     <<< The \(<expression>) construction as used above is very useful for
   ;     <<< such situations. After the key attachement is made we can simply
   ;     <<< remove all _k<x> variables since the contents of these variables is
   ;     <<< already fixed in the attachement string.
   ;     >>> The key attachement is make.
   ;     >>> result of 'attach' command is the pointer to the key attachement node.
   ;  >>> result of group operator is the pointer to the key attachement node.
   ;>>> _mkeys=pointer to the key attachement node.

   ;When the Ctrl+Shift-1 key is pressed later, the following command is executed
   ;as if it was typed in at that moment :
   ;{closepw memory;remvar memptr;_ra 123;_ra 124;_ra 125;_ra 126;_ra 127;_ra 128;_ra 129;_ra 130;_ra 131;_ra _mkeys;remvar _mkeys;unalias _vm;unalias _ra}
   ;{
   ;<<< group operator, execute all arguments :
   ;  closepw memory
   ;  remvar memptr
   ;  _ra 123
   ;  _ra 124
   ;  _ra 125
   ;  _ra 126
   ;  _ra 127
   ;  _ra 128
   ;  _ra 129
   ;  _ra 130
   ;  _ra 131
   ;  _ra _mkeys
   ;  remvar _mkeys
   ;  unalias _vm
   ;  unalias _ra
   ;>>> first execution results in :
   ;  closepw
   ;  <<< close physical window, first argument is physical window name :
   ;     memory
   ;  >>> physical and logical window are closed
   ;>>> second argument is executed :
   ;  remvar
   ;  <<< remove a variable, first argument is variable name :
   ;     memptr
   ;  >>> 'memptr' is removed
   ;>>> third argument is executed :
   ;  _ra
   ;  <<< remove a key attachement, first argument is pointer to attachment
   ;  <<< node :
   ;     123
   ;  >>> attachement node is removed
   ;>>> the same for all other '_ra' commands and one 'remvar' command
   ;  .
   ;  .
   ;  .
   ;>>> last two commands are executed :
   ;  unalias
   ;  <<< remove an alias definition :
   ;     _vm
   ;  >>> alias definition '_vm' is removed
   ;>>> equivalent for last 'unalias' command.
   ;>>> Everything is cleaned up.

remvar _k1 _k2 _k3 _k4 _k5 _k6 _k7 _k8 _k9
   ;Remove all variables used in this script.
   ;We can do this now because we have burned the contents of these variables
   ;fixed in the key attachement string needed to remove everything.

print '\0aShift in combination with the following keys on numeric keypad :\0a'
print '   8 (Up)    scroll one line up\0a'
print '   2 (Down)  scroll one line down\0a'
print '   9 (PgUp)  scroll one page up\0a'
print '   3 (PgDn)  scroll one page down\0a'
print '   4 (Left)  scroll one byte left\0a'
print '   6 (Right) scroll one byte right\0a'
print '   5         refresh display\0a'
print '   0         ask new address\0a'
print '   .         switch between byte/word and long mode\0a'
print 'Ctrl+Shift 1 to remove display\0a'
