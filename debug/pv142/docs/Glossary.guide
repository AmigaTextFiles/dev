@Database "Glossary.hyper"
@master "pv:docs/Glossary.guide"

@Node Main "Glossary (Tue Nov  3 14:51:18 1992)"
Contents:
	@{" abbreviations            " Link "abbreviations"}
	@{" active logical window    " Link "active logical window"}
	@{" address operator         " Link "address operator"}
	@{" aliases                  " Link "aliases"}
	@{" alias string             " Link "alias string"}
	@{" ARexx port               " Link "ARexx port"}
	@{" ARexx scripts            " Link "ARexx scripts"}
	@{" auto output snap         " Link "auto output snap"}
	@{" autodefault              " Link "autodefault"}
	@{" autoscalable             " Link "autoscalable"}
	@{" box                      " Link "box"}
	@{" breakpoint node          " Link "breakpoint node"}
	@{" breakpoints              " Link "breakpoints"}
	@{" code                     " Link "code"}
	@{" commandline              " Link "commandline"}
	@{" conditional breakpoints  " Link "conditional breakpoints"}
	@{" conditional expressions  " Link "conditional expressions"}
	@{" constants                " Link "constants"}
	@{" contents operator        " Link "contents operator"}
	@{" crash node               " Link "crash node"}
	@{" current debug node       " Link "current debug node"}
	@{" current list             " Link "current list"}
	@{" current list indicator   " Link "current list indicator"}
	@{" current logical window   " Link "current logical window"}
	@{" current tag list         " Link "current tag list"}
	@{" debug nodes              " Link "debug nodes"}
	@{" debug tasks              " Link "debug tasks"}
	@{" double quotes            " Link "double quotes"}
	@{" dummy debug task         " Link "dummy debug task"}
	@{" execute mode             " Link "execute mode"}
	@{" expression               " Link "expression"}
	@{" fancy mode               " Link "fancy mode"}
	@{" FD-files                 " Link "FD-files"}
	@{" feedback mode            " Link "feedback mode"}
	@{" flow mode                " Link "flow mode"}
	@{" fullscreen debugger      " Link "fullscreen debugger"}
	@{" function definitions     " Link "function definitions"}
	@{" function monitor         " Link "function monitor"}
	@{" functions                " Link "functions"}
	@{" group operator           " Link "group operator"}
	@{" history buffer           " Link "history buffer"}
	@{" hold mode                " Link "hold mode"}
	@{" home position            " Link "home position"}
	@{" hot key                  " Link "hot key"}
	@{" instance                 " Link "instance"}
	@{" interrupt key            " Link "interrupt key"}
	@{" IntuiTick                " Link "IntuiTick"}
	@{" key attacements          " Link "key attacements"}
	@{" key code                 " Link "key code"}
	@{" led monitor              " Link "led monitor"}
	@{" linenumber operator      " Link "linenumber operator"}
	@{" list                     " Link "list"}
	@{" list element             " Link "list element"}
	@{" list operator            " Link "list operator"}
	@{" log file                 " Link "log file"}
	@{" logical window           " Link "logical window"}
	@{" LW                       " Link "LW"}
	@{" machinelanguage scripts  " Link "machinelanguage scripts"}
	@{" macro                    " Link "macro"}
	@{" masterbox                " Link "masterbox"}
	@{" ML-scripts               " Link "ML-scripts"}
	@{" MMU tree                 " Link "MMU tree"}
	@{" monitor functions        " Link "monitor functions"}
	@{" MORE checking            " Link "MORE checking"}
	@{" names                    " Link "names"}
	@{" nofancy mode             " Link "nofancy mode"}
	@{" normal breakpoints       " Link "normal breakpoints"}
	@{" output log               " Link "output log"}
	@{" pause key                " Link "pause key"}
	@{" pen                      " Link "pen"}
	@{" physical window          " Link "physical window"}
	@{" PortPrint                " Link "PortPrint"}
	@{" PowerVisor device        " Link "PowerVisor device"}
	@{" PowerVisor screen        " Link "PowerVisor screen"}
	@{" PowerVisor scripts       " Link "PowerVisor scripts"}
	@{" PowerVisor startup file  " Link "PowerVisor startup file"}
	@{" PowerVisor window        " Link "PowerVisor window"}
	@{" prefix operators         " Link "prefix operators"}
	@{" private breakpoints      " Link "private breakpoints"}
	@{" profile tracing          " Link "profile tracing"}
	@{" profiler breakpoint      " Link "profiler breakpoint"}
	@{" profiling                " Link "profiling"}
	@{" prompt                   " Link "prompt"}
	@{" PVDevice                 " Link "PVDevice"}
	@{" PVSD file                " Link "PVSD file"}
	@{" PW                       " Link "PW"}
	@{" qualifier                " Link "qualifier"}
	@{" quote operator           " Link "quote operator"}
	@{" quotes                   " Link "quotes"}
	@{" real-top windows         " Link "real-top windows"}
	@{" recursive aliases        " Link "recursive aliases"}
	@{" resident breakpoints     " Link "resident breakpoints"}
	@{" resident commands        " Link "resident commands"}
	@{" resident ML-scripts      " Link "resident ML-scripts"}
	@{" resource tracking        " Link "resource tracking"}
	@{" routine trace mode       " Link "routine trace mode"}
	@{" scripts                  " Link "scripts"}
	@{" single quotes            " Link "single quotes"}
	@{" singlestep mode          " Link "singlestep mode"}
	@{" size bar                 " Link "size bar"}
	@{" snapping                 " Link "snapping"}
	@{" special operator         " Link "special operator"}
	@{" special variables        " Link "special variables"}
	@{" stack checking           " Link "stack checking"}
	@{" stack fail level         " Link "stack fail level"}
	@{" standard logical window  " Link "standard logical window"}
	@{" startup file             " Link "startup file"}
	@{" string expansion         " Link "string expansion"}
	@{" string pointers          " Link "string pointers"}
	@{" strings                  " Link "strings"}
	@{" structure definition     " Link "structure definition"}
	@{" strong quote             " Link "strong quote"}
	@{" symbols                  " Link "symbols"}
	@{" tag                      " Link "tag"}
	@{" tag file                 " Link "tag file"}
	@{" tag list                 " Link "tag list"}
	@{" task accounting          " Link "task accounting"}
	@{" Task Control Block (TCB) " Link "Task Control Block (TCB)"}
	@{" task list                " Link "task list"}
	@{" TCB                      " Link "TCB"}
	@{" templates                " Link "templates"}
	@{" temporary breakpoint     " Link "temporary breakpoint"}
	@{" timeout breakpoints      " Link "timeout breakpoints"}
	@{" top-visible windows      " Link "top-visible windows"}
	@{" trace check              " Link "trace check"}
	@{" variables                " Link "variables"}

Various:
	@{" Back to main contents    " Link "pv:docs/PowerVisor.guide/Main"}
@EndNode

@Node "abbreviations" "Glossary : abbreviations"
   PowerVisor allows you to abbreviate several things. You can abbreviate
   command names and names for list elements

      Tutor chapters : @{" Expresions " Link "pv:docs/Expressions.guide/Main"} @{" Getting Started " Link "pv:docs/GettingStarted.guide/Main"}
@EndNode

@Node "active logical window" "Glossary : active logical window"
   The active logical window is the logical window where you can scroll
   with the keyboard. You can see if a logical window is active by looking
   at the titlebar. A full (blue in AmigaDOS 2.0) titlebar indicates that
   the logical window is active. Note that the active logical window is NOT
   the same as the current logical window.
   Starting at V1.10, the active logical window is also used for pending
   input (see the @{" Screens and windows " Link "pv:docs/Screen.guide/Main"} chapter for more info)

      Commands : @{" scroll " Link "pv:docs/CommandRef.guide/Scroll"} @{" active " Link "pv:docs/CommandRef.guide/Active"}
      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
      Related terminology : @{" current logical window " Link "current logical window"} @{" logical window " Link "logical window"}
@EndNode

@Node "address operator" "Glossary : address operator"
   The address operator ('&') can be used to ask the address of an element
   in the current list. You can only use this operator for the @{" exec " Link "pv:docs/Lists.guide/Exec"},
   @{" graf " Link "pv:docs/Lists.guide/Graf"} and @{" intb " Link "pv:docs/Lists.guide/Intb"} lists. An address operator always precedes a
   list operator

      Tutor chapters : @{" Expressions " Link "pv:docs/Expressions.guide/Main"}
      Related terminology : @{" contents operator " Link "contents operator"} @{" list operator " Link "list operator"}
@EndNode

@Node "aliases" "Glossary : aliases"
   An alias in its simpliest form is another name for a command. PowerVisor
   aliases are a bit more powerful than normal aliases. You can actually
   construct whole new commands with them

      Commands : @{" alias " Link "pv:docs/CommandRef.guide/Alias"} @{" unalias " Link "pv:docs/CommandRef.guide/Unalias"}
      Tutor chapters : @{" Installing PowerVisor " Link "pv:docs/InstallingPV.guide/Main"}
      Related terminology : @{" alias string " Link "alias string"} @{" recursive aliases " Link "recursive aliases"}
@EndNode

@Node "alias string" "Glossary : alias string"
   The alias string is the string that is used instead of the commandline
   when an alias command is entered. It is in fact the definition of the
   alias

      Commands : @{" alias " Link "pv:docs/CommandRef.guide/Alias"} @{" unalias " Link "pv:docs/CommandRef.guide/Unalias"}
      Tutor chapters : @{" Installing PowerVisor " Link "pv:docs/InstallingPV.guide/Main"}
      Related terminology : @{" aliases " Link "aliases"}
@EndNode

@Node "ARexx port" "Glossary : ARexx port"
   The ARexx port is used by ARexx to send commands to. The name of
   the PowerVisor ARexx port is REXX_POWERVISOR

      Commands : @{" rx " Link "pv:docs/CommandRef.guide/Rx"}
      Tutor chapters : @{" Scripts " Link "pv:docs/Scripts.guide/Main"}
      Related terminology : @{" ARexx scripts " Link "ARexx scripts"}
@EndNode

@Node "ARexx scripts" "Glossary : ARexx scripts"
   An ARexx script is a ASCII script file containing ARexx commands.
   ARexx is a versatile script language for the Amiga. With ARexx you
   can interface PowerVisor to any other program supporting ARexx or
   you can write powerful scripts making life easier for you and other
   users of PowerVisor. ARexx scripts must begin with a comment
   (/* */)

      Commands : @{" rx " Link "pv:docs/CommandRef.guide/Rx"}
      Tutor chapters : @{" Scripts " Link "pv:docs/Scripts.guide/Main"}
      Related terminology : @{" PowerVisor scripts " Link "PowerVisor scripts"} @{" scripts " Link "scripts"} @{" ML-scripts " Link "ML-scripts"}
                            @{" ARexx port " Link "ARexx port"}
@EndNode

@Node "auto output snap" "Glossary : auto output snap"
   This feature is an optional setting for logical windows. When 'auto
   output snap' is on, the logical window will automatically scroll to
   the place where output appears. 'auto output snap' is on by default
   for the 'Main' logical window. You can change this behaviour with
   the @{" setflags " Link "pv:docs/CommandRef.guide/Setflags"} or @{" prefs " Link "pv:docs/CommandRef.guide/Prefs"} commands

      Commands : @{" setflags " Link "pv:docs/CommandRef.guide/Setflags"} @{" prefs " Link "pv:docs/CommandRef.guide/Prefs"}
      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
      Related terminology : @{" logical windows " Link "logical windows"} @{" MORE checking " Link "MORE checking"}
                            @{" home position " Link "home position"}
@EndNode

@Node "autodefault" "Glossary : autodefault"
   Autodefault is a method provided to make life easier for the user.
   Normally when PowerVisor parses some sequence of characters, several
   steps occur. In one of these steps PowerVisor tests if the sequence
   of characters could be an abbreviation for a name of a 'list element'
   in the current list.
   But some commands are only useful for specific list elements. For
   example : the @{" freeze " Link "pv:docs/CommandRef.guide/Freeze"} command to freeze a task is only useful for
   tasks. Therefor 'freeze' uses 'autodefault' to the 'task' list. This
   means that the parsing of the sequence of characters is not done for
   the current list but for the task list. In practice this means that
   you can simply use the name of the task even if the @{" task " Link "pv:docs/Lists.guide/Task"} list is
   not the current list. Many commands use this feature (see the
   @{" Command Reference " Link "pv:docs/CommandRef.guide/Main"} chapter if you want to know if a certain command
   uses 'autodefault'). Some functions also use 'autodefault'

      Related terminology : @{" list element " Link "list element"} @{" current list " Link "current list"}
@EndNode

@Node "autoscalable" "Glossary : autoscalable"
   When a logical window is autoscalable for one or both directions
   (vertical or horizontal) the visible size will always be equal to
   the real size (in that direction) (see 'logical window' for more info).
   This means that when you change the visible size (by opening or closing
   another logical window or by dragging the size bar) the logical window
   will be cleared and the real size will be recomputed. The 'Main' logical
   window is NOT autoscalable by default

      Commands : @{" fit " Link "pv:docs/CommandRef.guide/Fit"} @{" colrow " Link "pv:docs/CommandRef.guide/Colrow"}
      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
      Related terminology : @{" logical window " Link "logical window"} @{" box " Link "box"}
@EndNode

@Node "box" "Glossary : box"
   A box is used by the physical window to manage the space for logical
   windows. A box has a parent (unless it is the root box for the
   physical window) and two children (unless it is a leaf of the box
   tree). A box with no children (a leaf box) corresponds with a
   logical window.

      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
      Related terminology : @{" logical window " Link "logical window"} @{" physical window " Link "physical window"}
                            @{" masterbox " Link "masterbox"}
@EndNode

@Node "breakpoint node" "Glossary : breakpoint node"
   A breakpoint node is the internal data structure used by PowerVisor
   to hold information about a breakpoint. Each breakpoint has its
   own breakpoint node. You can use @{" info " Link "pv:docs/CommandRef.guide/Info"} for a debug node to see
   a list of all breakpoint nodes

      Commands : @{" info " Link "pv:docs/CommandRef.guide/Info"} @{" debug " Link "pv:docs/CommandRef.guide/Debug"}
      Tutor chapters : @{" Debugging " Link "pv:docs/Debug.guide/Main"}
      Related terminology : @{" breakpoints " Link "breakpoints"} @{" debug nodes " Link "debug nodes"}
@EndNode

@Node "breakpoints" "Glossary : breakpoints"
   A breakpoint is a location in memory where a debug node should stop
   (sometimes depending on some condition). They are implemented using
   'ILLEGAL' instructions (so don't use them in shared memory)

      Commands : @{" break " Link "pv:docs/CommandRef.guide/Break"} @{" trace " Link "pv:docs/CommandRef.guide/Trace"} @{" debug " Link "pv:docs/CommandRef.guide/Debug"}
      Tutor chapters : @{" Debugging " Link "pv:docs/Debug.guide/Main"}
      Related terminology : @{" debug nodes " Link "debug nodes"} @{" normal breakpoints " Link "normal breakpoints"}
                            @{" timeout breakpoints " Link "timeout breakpoints"} @{" conditional breakpoints " Link "conditional breakpoints"}
                            @{" temporary breakpoints " Link "temporary breakpoints"} @{" profile breakpoints " Link "profile breakpoints"}
                            @{" resident breakpoints " Link "resident breakpoints"} @{" private breakpoints " Link "private breakpoints"}
@EndNode

@Node "code" "Glossary : code"
   See @{" key code " Link "key code"}
@EndNode

@Node "commandline" "Glossary : commandline"
   The commandline of PowerVisor is a stringgadget. This means that you
   can use all stringgadget editing facilities supported by the
   operating system. You can also use some extra facilities provided
   by PowerVisor like the 'history buffer'.
   By default the commandline is 400 bytes long but you may decrease
   or increase this value with the @{" prefs " Link "pv:docs/CommandRef.guide/Prefs"} command

      Commands : @{" prefs " Link "pv:docs/CommandRef.guide/Prefs"}
      Tutor chapters : @{" Getting Started " Link "pv:docs/GettingStarted.guide/Main"}
      Related terminology : @{" history buffer " Link "history buffer"}
@EndNode

@Node "conditional breakpoints" "Glossary : conditional breakpoints"
   Conditional breakpoints only break when a certain condition (expression)
   is true

      Commands : @{" break " Link "pv:docs/CommandRef.guide/Break"} @{" trace " Link "pv:docs/CommandRef.guide/Trace"} @{" debug " Link "pv:docs/CommandRef.guide/Debug"}
      Tutor chapters : @{" Debugging " Link "pv:docs/Debug.guide/Main"}
      Related terminology : @{" breakpoints " Link "breakpoints"} @{" debug node " Link "debug node"}
@EndNode

@Node "conditional expressions" "Glossary : conditional expressions"
   Using the @{" if() " Link "pv:docs/Functions.guide/If"} function you can make conditional expressions like in
   C

      Tutor chapters : @{" Expressions " Link "pv:docs/Expressions.guide/Main"}
      Related terminology : @{" expression " Link "expression"}
@EndNode

@Node "constants" "Glossary : constants"
   A constant is just like a PowerVisor variable. The only difference
   is that you can't change the value (obvious :-)
   'version' is the only constant in the current version of PowerVisor

      Commands : @{" vars " Link "pv:docs/CommandRef.guide/Vars"}
      Tutor chapters : @{" Expressions " Link "pv:docs/Expressions.guide/Main"}
      Related terminology : @{" variables " Link "variables"} @{" functions " Link "functions"} @{" special variables " Link "special variables"}
@EndNode

@Node "contents operator" "Glossary : contents operator"
   The contents operator ('*') can be used to read from memory locations.
   You can use it in expressions or before the assignment operator

      Tutor chapters : @{" Expressions " Link "pv:docs/Expressions.guide/Main"}
      Related terminology : @{" address operator " Link "address operator"}
@EndNode

@Node "crash node" "Glossary : crash node"
   A crash node (in the @{" crsh " Link "pv:docs/Lists.guide/Crsh"} list) corresponds with a crashed task.
   When a task crashes and PowerVisor traps the crash, PowerVisor will
   create a crash node and halt the task. This crash node contains
   some extra information about the crash
@EndNode

@Node "current debug node" "Glossary : current debug node"
   The current debug node is the debug node that you are currently
   debugging. All trace and breakpoint commands use the current debug
   node. You can have more than one debug node in memory at the same
   time

      Commands : @{" with " Link "pv:docs/CommandRef.guide/With"} @{" duse " Link "pv:docs/CommandRef.guide/Duse"}
      Tutor chapters : @{" Debugging " Link "pv:docs/Debug.guide/Main"}
      Related terminology : @{" debug node " Link "debug node"}
@EndNode

@Node "current list" "Glossary : current list"
   When PowerVisor parses some sequence of characters, several
   steps occur. In one of these steps PowerVisor tests if the sequence
   of characters could be an abbreviation for a name of a 'list element'
   in a certain list. This list is the current list. In the bottom
   left corner of the PowerVisor window you can see the name of the
   current list. If you want to change the current list to some other
   list, just type the name of the other list (@{" task " Link "pv:docs/Lists.guide/Task"}, @{" lock " Link "pv:docs/Lists.guide/Lock"},
   @{" wins " Link "pv:docs/Lists.guide/Wins"}, ...). Note that some commands do not use the current list for
   parsing sequences of characters (see 'autodefault')

      Commands : @{" task " Link "pv:docs/Lists.guide/Task"} @{" lock " Link "pv:docs/Lists.guide/Lock"} @{" wins " Link "pv:docs/Lists.guide/Wins"} ...
      Tutor chapters : @{" List Reference " Link "pv:docs/Lists.guide/Main"}
      Related terminology : @{" list " Link "list"} @{" list element " Link "list element"} @{" autodefault " Link "autodefault"}
                            @{" current list indicator " Link "current list indicator"}
@EndNode

@Node "current list indicator" "Glossary : current list indicator"
   The current list indicator is located in the left-bottom corner of
   the 'Main' physical window (the PowerVisor window). It displays
   the name of the current list ('Task', ...).
   Right from the current list indicator is the prompt

      Related terminology : @{" current list " Link "current list"} @{" prompt " Link "prompt"}
@EndNode

@Node "current logical window" "Glossary : current logical window"
   The current logical window is the logical window that receives all
   output from most commands. This is 'Main' by default. Note that the
   current logical window is NOT the same as the active logical window

      Commands : @{" current " Link "pv:docs/CommandRef.guide/Current"} @{" on " Link "pv:docs/CommandRef.guide/On"}
      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
      Related terminology : @{" active logical window " Link "active logical window"} @{" logical window " Link "logical window"}
@EndNode

@Node "current tag list" "Glossary : current tag list"
   The current tag list is the tag list that is used by all the
   tag commands. There are sixteen possible tag lists (0..15)

      Commands : @{" tg " Link "pv:docs/CommandRef.guide/Tg"} @{" usetag " Link "pv:docs/CommandRef.guide/Usetag"}
      Tutor chapters : @{" Looking at things " Link "pv:docs/LookingAtThings.guide/Main"}
      Related terminology : @{" tag list " Link "tag list"} @{" tag " Link "tag"}
@EndNode

@Node "debug nodes" "Glossary : debug nodes"
   See @{" debug tasks " Link "debug tasks"}
@EndNode

@Node "debug tasks" "Glossary : debug tasks"
   (or debug nodes) A debug task is a task you are debugging. When it
   is called a debug task, we are talking about the real task. When
   it is called a debug node (which is logically the same) we are also
   talking about the task in most cases, but sometimes the term debug
   node is used for the internal structure needed by PowerVisor to
   debug the task (this last meaning is actually more exact than the
   first one). All debug nodes are in the @{" dbug " Link "pv:docs/Lists.guide/Dbug"} list

      Commands : @{" dbug " Link "pv:docs/Lists.guide/Dbug"} @{" debug " Link "pv:docs/CommandRef.guide/Debug"}
      Tutor chapters : @{" Debugging " Link "pv:docs/Debug.guide/Main"}
@EndNode

@Node "double quotes" "Glossary : double quotes"
   See @{" quotes " Link "quotes"}
@EndNode

@Node "dummy debug task" "Glossary : dummy debug task"
   With a dummy debug task you can make symbols without having to create
   a real debug task. This makes it more easy to disassemble programs.
   You can't trace or set breakpoints with a dummy debug task, but you
   can create and show symbols

      Commands : @{" debug " Link "pv:docs/CommandRef.guide/Debug"} @{" symbol " Link "pv:docs/CommandRef.guide/Symbol"}
      Tutor chapters : @{" Debugging " Link "pv:docs/Debug.guide/Main"}
      Related terminology : @{" debug nodes " Link "debug nodes"}
@EndNode

@Node "execute mode" "Glossary : execute mode"
   See @{" singlestep mode " Link "singlestep mode"}
@EndNode

@Node "expression" "Glossary : expression"
   A sequence of characters corresponding with some algebraic or other
   operations on integers

      Tutor chapters : @{" Expressions " Link "pv:docs/Expressions.guide/Main"}
@EndNode

@Node "fancy mode" "Glossary : fancy mode"
   Fancy mode is another name for two-bitplane mode. PowerVisor is
   in fancy mode when the PowerVisor screen uses two bitplanes (default).
   Otherwise PowerVisor is in 'nofancy' mode

      Commands : @{" mode " Link "pv:docs/CommandRef.guide/Mode"}
      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
      Related terminology : @{" nofancy mode " Link "nofancy mode"}
@EndNode

@Node "FD-files" "Glossary : FD-files"
   A fd-file (function definition file) contains definitions for the
   functions defined in a shared library (you can find these files
   on the Extras 1.3 disk). PowerVisor uses these files for several
   purposes (to make the disassembly more readable when you are
   debugging for example, the @{" addfunc " Link "pv:docs/CommandRef.guide/Addfunc"} command also uses FD-files).
   All loaded FD-files are in the @{" fdfi " Link "pv:docs/Lists.guide/Fdfi"} list

      Commands : @{" loadfd " Link "pv:docs/CommandRef.guide/Loadfd"} @{" unloafd " Link "pv:docs/CommandRef.guide/Unloafd"} @{" fdfi " Link "pv:docs/Lists.guide/Fdfi"}
      Related terminology : @{" function definitions " Link "function definitions"}
@EndNode

@Node "feedback mode" "Glossary : feedback mode"
   When feedback mode is on (default) PowerVisor will first print each
   command on the PowerVisor window before executing it. That way you
   have an easy way to know which command caused which output

      Commands : @{" mode " Link "pv:docs/CommandRef.guide/Mode"}
      Tutor chapters : @{" Getting Started " Link "pv:docs/GettingStarted.guide/Main"}
@EndNode

@Node "flow mode" "Glossary : flow mode"
   See @{" singlestep mode " Link "singlestep mode"}
@EndNode

@Node "fullscreen debugger" "Glossary : fullscreen debugger"
   Normally debugging in PowerVisor is commandline based. Using the
   @{" fdebug " Link "pv:docs/Aliases.guide/Fdebug"} alias (or the 'db' script) you can install a fullscreen
   debugger. This fullscreen debugger uses the 'Debug' logical window
   for output

      Commands : @{" debug " Link "pv:docs/CommandRef.guide/Debug"} @{" fdebug " Link "pv:docs/Aliases.guide/Fdebug"} @{" dwin " Link "pv:docs/Lists.guide/Dwin"}
      Tutor chapters : @{" Debugging " Link "pv:docs/Debug.guide/Main"}
@EndNode

@Node "function definitions" "Glossary : function definitions"
   A function definition is a definition for a library function
   (the name, registers, ...). Function definitions are part of
   an FD-file

      Commands : @{" loadfd " Link "pv:docs/CommandRef.guide/Loadfd"} @{" libinfo " Link "pv:docs/CommandRef.guide/Libinfo"} @{" libfunc " Link "pv:docs/CommandRef.guide/Libfunc"}
      Related terminology : @{" FD-files " Link "FD-files"}
@EndNode

@Node "function monitor" "Glossary : function monitor"
   The function monitor is the device in PowerVisor that monitors
   library functions (monitor functions)

      Commands : @{" addfunc " Link "pv:docs/CommandRef.guide/Addfunc"}
      Related terminology : @{" monitor functions " Link "monitor functions"}
@EndNode

@Node "functions" "Glossary : functions"
   A function is a routine you may include in expressions. It has
   some arguments (or none) and most often a result. Note that PowerVisor
   always expects brackets after the function name even if there are no
   arguments (like in C). Functions live in the same list as variables.
   This is why you can't have a variable with the same name as a function

      Commands : @{" vars " Link "pv:docs/CommandRef.guide/Vars"}
      Tutor chapters : @{" Expressions " Link "pv:docs/Expressions.guide/Main"}
      Related terminology : @{" variables " Link "variables"} @{" constants " Link "constants"} @{" special variables " Link "special variables"}
@EndNode

@Node "group operator" "Glossary : group operator"
   The group operator ('{' ... '}') can be used to group several commands
   together. You can do this because you want to execute several commands
   at once or because you are interested in the return code of the last
   executed command in the list. Group operators can be used as stand
   alone command or in expressions. The commands in the group are seperated
   by ';'.
   The group operator is also useful if you want to create recursive
   aliases

      Tutor chapters : @{" Expressions " Link "pv:docs/Expressions.guide/Main"}
      Related terminology : @{" recursive aliases " Link "recursive aliases"}
@EndNode

@Node "history buffer" "Glossary : history buffer"
   To make editing easier PowerVisor supports a history buffer. Using
   the arrow up/down keys you can move in this history buffer and make
   changes to previous commands.
   You can change the maximum number of lines in the history buffer with
   the @{" prefs " Link "pv:docs/CommandRef.guide/Prefs"} command

      Commands : @{" prefs " Link "pv:docs/CommandRef.guide/Prefs"}
      Tutor chapters : @{" Getting Started " Link "pv:docs/GettingStarted.guide/Main"}
      Related terminology : @{" commandline " Link "commandline"}
@EndNode

@Node "hold mode" "Glossary : hold mode"
   When PowerVisor is in hold mode, the screens and windows of PowerVisor
   are all closed. This is useful to preserve memory. You can reopen
   PowerVisor with the hot key

      Commands : @{" hold " Link "pv:docs/CommandRef.guide/Hold"}
      Related terminology : @{" hot key " Link "hot key"}
@EndNode

@Node "home position" "Glossary : home position"
   The home position for a logical window depends on whether the logical
   window is a top-visible window or a real-top window

      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
      Related terminology : @{" top-visible windows " Link "top-visible windows"} @{" real-top windows " Link "real-top windows"}
@EndNode

@Node "hot key" "Glossary : hot key"
   The PowerVisor hot key is the key combination used to bring the
   PowerVisor screen to the front. Normally the hot key is
   <right-shift>+<right-alt>+'?' but you can redefine it to any other
   key you want with the @{" prefs " Link "pv:docs/CommandRef.guide/Prefs"} command

      Commands : @{" prefs " Link "pv:docs/CommandRef.guide/Prefs"}
      Tutor chapters : @{" Getting Started " Link "pv:docs/GettingStarted.guide/Main"}
      Related terminology : @{" hold mode " Link "hold mode"} @{" interrupt key " Link "interrupt key"} @{" pause key " Link "pause key"}
@EndNode

@Node "instance" "Glossary : instance"
   When you run more than one PowerVisor at the same time you get multiple
   instances of PowerVisor. The first instance is the master (number 0).
   All other instances are slaves. Slave instances can't debug. You can
   get the number of the instance you are in by looking at the 'pv'
   constant. You can also use the @{" arexxport() " Link "pv:docs/Functions.guide/Arexxport"} and @{" pubscreen() " Link "pv:docs/Functions.guide/Pubscreen"}
   functions if you want to write ARexx scripts.
@EndNode

@Node "interrupt key" "Glossary : interrupt key"
   The interrupt key (<esc> by default) can be used to interrupt a
   PowerVisor command. You can use any key you want for the interrupt
   key with the @{" prefs " Link "pv:docs/CommandRef.guide/Prefs"} command

      Commands : @{" prefs " Link "pv:docs/CommandRef.guide/Prefs"}
      Tutor chapters : @{" Installing PowerVisor " Link "pv:docs/InstallingPV.guide/Main"}
      Related terminology : @{" hot key " Link "hot key"} @{" pause key " Link "pause key"}
@EndNode

@Node "IntuiTick" "Glossary : IntuiTick"
   An IntuiTick is one tenth of a second. It is used by the @{" refresh " Link "pv:docs/CommandRef.guide/Refresh"}
   command to measure the refresh rate

      Commands : @{" refresh " Link "pv:docs/CommandRef.guide/Refresh"}
@EndNode

@Node "key attacements" "Glossary : key attacements"
   See @{" macro " Link "macro"}
@EndNode

@Node "key code" "Glossary : key code"
   A key code is some quantity used by the Amiga operating system to
   distinguish between different keys on the keyboard. PowerVisor uses
   key codes in several cases (in conjunction with qualifiers) in order
   to install some commands on keys or other things

      Commands : @{" attach " Link "pv:docs/CommandRef.guide/Attach"} @{" prefs " Link "pv:docs/CommandRef.guide/Prefs"}
      Tutor chapters : @{" Installing PowerVisor " Link "pv:docs/InstallingPV.guide/Main"}
      Related terminology : @{" code " Link "code"} @{" qualifier " Link "qualifier"}
@EndNode

@Node "led monitor" "Glossary : led monitor"
   This is a (older) name for the function monitor

      Related terminology : @{" function monitor " Link "function monitor"}
@EndNode

@Node "linenumber operator" "Glossary : linenumber operator"
   The linenumber operator ('#') is useful when debugging. Directly after
   the operator follows a linenumber in the currently loaded source. The
   result is the address in memory for that linenumber

      Tutor chapters : @{" Expressions " Link "pv:docs/Expressions.guide/Main"} @{" Debugging " Link "pv:docs/Debug.guide/Main"}
      Releated terminology : 'special operator'
@EndNode

@Node "list" "Glossary : list"
   A list contains some list elements (structures or nodes). You can look
   at a list with the @{" list " Link "pv:docs/CommandRef.guide/List"} command. You can ask more information
   about a list element in a list with the @{" info " Link "pv:docs/CommandRef.guide/Info"} command.
   For example the @{" task " Link "pv:docs/Lists.guide/Task"} list contains all processes and tasks. The list
   is called 'task' and each list element in the list is either a process
   or a task.

      Commands : @{" list " Link "pv:docs/CommandRef.guide/List"} @{" info " Link "pv:docs/CommandRef.guide/Info"}
      Tutor chapters : @{" List Reference " Link "pv:docs/Lists.guide/Main"} @{" Looking at things " Link "pv:docs/LookingAtThings.guide/Main"}
      Related terminology : @{" list element " Link "list element"} @{" current list " Link "current list"}
@EndNode

@Node "list element" "Glossary : list element"
   See @{" list " Link "list"}
@EndNode

@Node "list operator" "Glossary : list operator"
   The list operator (':') is a binary operator with both arguments for
   the operator optional. You can use it to search some item in a list

      Tutor chapters : @{" Expressions " Link "pv:docs/Expressions.guide/Main"} @{" List Reference " Link "pv:docs/Lists.guide/Main"}
      Related terminology : @{" list " Link "list"} @{" list element " Link "list element"} @{" address operator " Link "address operator"}
@EndNode

@Node "log file" "Glossary : log file"
   A log file is a file used to store all output appearing in a logical
   window. You can only have one log file at a time and only for one
   logical window

      Commands : @{" log " Link "pv:docs/CommandRef.guide/Log"} @{" to " Link "pv:docs/CommandRef.guide/To"}
      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
      Related terminology : @{" logical windows " Link "logical windows"} @{" output log " Link "output log"}
@EndNode

@Node "logical window" "Glossary : logical window"
   A logical window is the primary output device used by PowerVisor. It
   corresponds with a visible rectangle on a physical window (or
   Intuition window). You can have more than one logical window on
   each physical window. A logical window has an internal size and
   a visible size. The internal size is the number of columns and
   rows that PowerVisor really remembers for that logical window.
   The visible size is the part of the logical window that you can see.
   Using commands or keys you can scroll the visible logical window
   region in the real logical window region.
   The most important logical window is the 'Main' logical window. This
   logical window is always open and receives all output (by default)
   for most commands. All logical windows can be found in the @{" lwin " Link "pv:docs/Lists.guide/Lwin"}
   list

      Commands : @{" openlw " Link "pv:docs/CommandRef.guide/Openlw"} @{" closelw " Link "pv:docs/CommandRef.guide/Closelw"} @{" rwin " Link "pv:docs/CommandRef.guide/Rwin"} @{" dwin " Link "pv:docs/CommandRef.guide/Dwin"} @{" awin " Link "pv:docs/CommandRef.guide/Awin"} @{" owin " Link "pv:docs/CommandRef.guide/Owin"} @{" xwin " Link "pv:docs/CommandRef.guide/Xwin"}
      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
      Related terminology : @{" physical window " Link "physical window"} @{" LW " Link "LW"}
                            @{" standard logical window " Link "standard logical window"}
@EndNode

@Node "LW" "Glossary : LW"
   An abbreviation for @{" logical window " Link "logical window"}

      Related terminology : @{" logical window " Link "logical window"}
@EndNode

@Node "machinelanguage scripts" "Glossary : machinelanguage scripts"
   See @{" ML-scripts " Link "ML-scripts"}
@EndNode

@Node "macro" "Glossary : macro"
   A macro is another (and better) name for a key attachement. I hope to
   remove the term 'key attachement' from all documentation and use
   'macro' instead. A macro is a command that is attached to a key.
   When you press that key the command is executed.

      Commands : @{" attach " Link "pv:docs/CommandRef.guide/Attach"} @{" remattach " Link "pv:docs/CommandRef.guide/Remattach"}
      Tutor chapters : @{" Installing PowerVisor " Link "pv:docs/InstallingPV.guide/Main"}
      Related terminology : @{" key attachement " Link "key attachement"}
@EndNode

@Node "masterbox" "Glossary : masterbox"
   The masterbox is the box that is always present in a physical window.
   It is the root of the box tree. The masterbox is the only box that
   can have no children while containing no logical window

      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
      Related terminology : @{" box " Link "box"} @{" logical windows " Link "logical windows"} @{" physical windows " Link "physical windows"}
@EndNode

@Node "ML-scripts" "Glossary : ML-scripts"
   ML-scripts (or machinelanguage scripts) are scripts written in an
   external language (like C or machinelanguage). They are useful
   for more specialized tasks. Some examples can be found in the
   's/pv' subdirectory

      Commands : @{" script " Link "pv:docs/CommandRef.guide/Script"} @{" pvcall " Link "pv:docs/CommandRef.guide/Pvcall"}
      Tutor chapters : @{" Scripts " Link "pv:docs/Scripts.guide/Main"} @{" The wizard corner " Link "pv:docs/pv:docs/TheWizCorner.guide/Main"}
      Related terminology : @{" ARexx scripts " Link "ARexx scripts"} @{" PowerVisor scripts " Link "PowerVisor scripts"} @{" scripts " Link "scripts"}
@EndNode

@Node "MMU tree" "Glossary : MMU tree"
   The MMU tree (or Memory Management Unit tree) is used by the 68851,
   68030 or 68040 for memory management. On the Amiga the MMU is only
   marginally used. PowerVisor can make it's own MMU tree using the
   @{" watch " Link "pv:docs/CommandRef.guide/Watch"} command. With this command you can enable the PowerVisor
   memory protection system.

      Commands : @{" mmutree " Link "pv:docs/CommandRef.guide/Mmutree"} @{" mmuregs " Link "pv:docs/CommandRef.guide/Mmuregs"} @{" Watch " Link "pv:docs/CommandRef.guide/Watch"}
      Tutor chapters : @{" Looking at things " Link "pv:docs/LookingAtThings.guide/Main"}
@EndNode

@Node "monitor functions" "Glossary : monitor functions"
   Monitor functions are library functions you are monitoring with the
   @{" addfunc " Link "pv:docs/CommandRef.guide/Addfunc"} command. Using this command provides a powerful way to
   debug some programs

      Commands : @{" addfunc " Link "pv:docs/CommandRef.guide/Addfunc"}
@EndNode

@Node "MORE checking" "Glossary : MORE checking"
   MORE checking is an optional setting for logical windows. When
   MORE checking is on, PowerVisor will wait for a key press after
   a full page of output has appeared (a full page is measured by
   the real size of the logical window and not by the visible size).
   MORE checking is on by default for the 'Main' logical window

      Commands : @{" mode " Link "pv:docs/CommandRef.guide/Mode"}
      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
      Related terminology : @{" auto output snap " Link "auto output snap"} @{" logical windows " Link "logical windows"}
                            @{" home position " Link "home position"}
@EndNode

@Node "names" "Glossary : names"
   Names are actually strings but without the single quotes. There is
   no other significant difference. Note however, that names are NOT
   always interpreted in the same way as a normal string (with single
   quotes). For example, you cannot use single quotes when you want
   the name to use as a variable

      Tutor chapters : @{" Expressions " Link "pv:docs/Expressions.guide/Main"}
      Related terminology : @{" strings " Link "strings"} @{" single quotes " Link "single quotes"}
@EndNode

@Node "nofancy mode" "Glossary : nofancy mode"
   See @{" fancy mode " Link "fancy mode"}
@EndNode

@Node "normal breakpoints" "Glossary : normal breakpoints"
   See @{" breakpoints " Link "breakpoints"}
@EndNode

@Node "output log" "Glossary : output log"
   See @{" log file " Link "log file"}
@EndNode

@Node "pause key" "Glossary : pause key"
   The pause key ('<right-alt>+<help> by default) can be used to pause
   the output of a command

      Commands : @{" prefs " Link "pv:docs/CommandRef.guide/Prefs"}
      Tutor chapters : @{" Installing PowerVisor " Link "pv:docs/InstallingPV.guide/Main"}
      Related terminology : @{" hot key " Link "hot key"} @{" interrupt key " Link "interrupt key"}
@EndNode

@Node "pen" "Glossary : pen"
   A pen is a graphical object. A pen in PowerVisor has a name and a
   value. For all graphic operations PowerVisor uses a pen. This means
   that you can customize all colors you see on the PowerVisor screen
   (and not only with RGB values)

      Commands : @{" prefs " Link "pv:docs/CommandRef.guide/Prefs"}
      Tutor chapters : @{" Installing PowerVisor " Link "pv:docs/InstallingPV.guide/Main"} @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
@EndNode

@Node "physical window" "Glossary : physical window"
   A physical window directly corresponds with a normal Intuition
   window. A physical window can contain one or more logical windows.
   The visible size for logical windows is managed by the physical
   windows using the 'Box' concept. The most important physical
   window is the 'Main' physical window. This physical window contains
   the 'Main' logical window. All physical windows can be found in
   the @{" pwin " Link "pv:docs/Lists.guide/Pwin"} list

      Commands : @{" openpw " Link "pv:docs/CommandRef.guide/Openpw"} @{" closepw " Link "pv:docs/CommandRef.guide/Closepw"}
      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
      Related terminology : @{" logical window " Link "logical window"} @{" box " Link "box"} @{" PW " Link "PW"}
@EndNode

@Node "PortPrint" "Glossary : PortPrint"
   PowerVisor supports a PortPrint feature. This means that you can
   print debug information (using the powervisor.library) on the
   PowerVisor screen. This is useful for tasks for example because
   they normally can't easily print output. The name PortPrint is
   derived from the way this feature works. A message is send to
   the PowerVisor message port containing the output string (or
   some other data because PowerVisor supports more types of output).
   Note that the output of the portprint commands appears on the
   'PPrint' logical window if this window is open

      Commands : @{" owin " Link "pv:docs/CommandRef.guide/Owin"}
@EndNode

@Node "PowerVisor device" "Glossary : PowerVisor device"
   See @{" PVDevice " Link "PVDevice"}
@EndNode

@Node "PowerVisor screen" "Glossary : PowerVisor screen"
   This is the screen where all PowerVisor windows (physical windows)
   live. It is possible that this screen does not exist. This happens
   when you have opened PowerVisor on the WorkBench screen or on any
   other screen in the system

      Commands : @{" screen " Link "pv:docs/CommandRef.guide/Screen"}
      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
      Related terminology : @{" physical windows " Link "physical windows"} @{" PowerVisor window " Link "PowerVisor window"}
@EndNode

@Node "PowerVisor scripts" "Glossary : PowerVisor scripts"
   PowerVisor scripts are simple script containing only sequential
   PowerVisor commands. They are useful for installing things. Some
   examples scripts can be found in the 's/pv' subdirectory. The
   PowerVisor startup script (s/PowerVisor-startup) is also a
   PowerVisor script. For more complex scripts you should use
   ARexx

      Commands : @{" script " Link "pv:docs/CommandRef.guide/Script"}
      Tutor chapters : @{" Scripts " Link "pv:docs/Scripts.guide/Main"}
      Related terminology : @{" ARexx scripts " Link "ARexx scripts"} @{" scripts " Link "scripts"} @{" ML-scripts " Link "ML-scripts"}
@EndNode

@Node "PowerVisor startup file" "Glossary : PowerVisor startup file"
   See @{" startup file " Link "startup file"}
@EndNode

@Node "PowerVisor window" "Glossary : PowerVisor window"
   The PowerVisor window is another name for the 'Main' physical window.
   This physical window contains at least the 'Main' logical window for
   standard output

      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
      Related terminology : @{" PowerVisor screen " Link "PowerVisor screen"} @{" physical windows " Link "physical windows"}
                            @{" logical windows " Link "logical windows"}
@EndNode

@Node "prefix operators" "Glossary : prefix operators"
   Prefix operators are operators you can put in front off the commandline
   before you execute it (press enter). These prefix operators have
   some effect on the output of the command or on other things

      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"} @{" Technical information " Link "pv:docs/TechnicalInfo.guide/Main"}
@EndNode

@Node "private breakpoints" "Glossary : private breakpoints"
   Private breakpoints are used by PowerVisor to skip an instruction or
   for other purposes

      Commands : @{" break " Link "pv:docs/CommandRef.guide/Break"} @{" debug " Link "pv:docs/CommandRef.guide/Debug"} @{" trace " Link "pv:docs/CommandRef.guide/Trace"}
      Tutor chapters : @{" Debugging " Link "pv:docs/Debug.guide/Main"}
      Related terminology : @{" debug nodes " Link "debug nodes"} @{" breakpoints " Link "breakpoints"}
@EndNode

@Node "profile tracing" "Glossary : profile tracing"
   Profile tracing is implemented with the 'trace p' and 'trace pf'
   commands. The big difference with normal profiling is that profile
   tracing is exact. The normal profiler (with the 'prof' command)
   interrupts the program at certain sampling points and searches for
   the closest symbol. The 'profile tracer' intercepts every symbol that
   is passed ('trace p') or every symbol that is used as the destination
   of a 'bra', 'bsr', ... ('trace pf')

      Commands : @{" trace " Link "pv:docs/CommandRef.guide/Trace"} @{" prof " Link "pv:docs/CommandRef.guide/Prof"}
      Tutor chapters : @{" Debugging " Link "pv:docs/Debug.guide/Main"}
      Related terminology : @{" profiling " Link "profiling"}
@EndNode

@Node "profiler breakpoint" "Glossary : profiler breakpoint"
   A profiler breakpoint never breaks, but only increments a counter
   everytime the breakpoint is passed. This is useful to gather usage
   statistics

      Commands : @{" break " Link "pv:docs/CommandRef.guide/Break"} @{" trace " Link "pv:docs/CommandRef.guide/Trace"} @{" debug " Link "pv:docs/CommandRef.guide/Debug"}
      Tutor chapters : @{" Debugging " Link "pv:docs/Debug.guide/Main"}
      Related terminology : @{" breakpoints " Link "breakpoints"} @{" debug nodes " Link "debug nodes"} @{" profiling " Link "profiling"}
@EndNode

@Node "profiling" "Glossary : profiling"
   A profiler is a program that determines which routines in a process or
   task use a lot of CPU time. These routines are likely candidates for
   optimization. PowerVisor implements profiling with the 'prof' command

      Commands: @{" prof " Link "pv:docs/CommandRef.guide/Prof"}
      Related terminology : @{" profiler breakpoint " Link "profiler breakpoint"} @{" profile tracing " Link "profile tracing"}
@EndNode

@Node "prompt" "Glossary : prompt"
   The prompt is the '>' symbol right from the current list indicator.
   It indicates the stringgadget or commandline where you can type
   PowerVisor commands

      Related terminology : @{" current list indicator " Link "current list indicator"}
@EndNode

@Node "PVDevice" "Glossary : PVDevice"
   (or PowerVisor device) A PVDevice is a data structure used by some
   commands. With a PVDevice you can open any device in the system and
   send commands to it. This is useful to test selfmade devices or
   to learn about other devices

      Commands : @{" opendev " Link "pv:docs/CommandRef.guide/Opendev"} @{" devcmd " Link "pv:docs/CommandRef.guide/Devcmd"}
@EndNode

@Node "PVSD file" "Glossary : PVSD file"
   A pvsd file (PowerVisor Structure Definition file) contains some
   structures. 'pvsd' files are made by the 'MStruct' utility or with the
   @{" struct " Link "pv:docs/CommandRef.guide/Struct"} command

      Commands : @{" addstruct " Link "pv:docs/CommandRef.guide/Addstruct"} @{" interprete " Link "pv:docs/CommandRef.guide/Interprete"} @{" struct " Link "pv:docs/CommandRef.guide/struct"}
      Tutor chapters : @{" Looking at things " Link "pv:docs/LookingAtThings.guide/Main"}
      Related terminology : @{" structure definition " Link "structure definition"}
@EndNode

@Node "PW" "Glossary : PW"
   An abbreviation for @{" physical window " Link "physical window"}

      Related terminology : @{" physical window " Link "physical window"}
@EndNode

@Node "qualifier" "Glossary : qualifier"
   A qualifier is used together with a key code to distinguish between
   different key presses. A qualifier says something about some special
   keys pressed at the same time with the key (shift, alt, ...)

      Commands : @{" attach " Link "pv:docs/CommandRef.guide/Attach"} @{" prefs " Link "pv:docs/CommandRef.guide/Prefs"}
      Tutor chapters : @{" Installing PowerVisor " Link "pv:docs/InstallingPV.guide/Main"}
      Related terminology : @{" key code " Link "key code"}
@EndNode

@Node "quote operator" "Glossary : quote operator"
   The quote operator (or backslash '\') can be used to put integers,
   characters or other strings in one way or another in a string or
   string pointer. The quote operator is actually quiet powerful

      Tutor chapters : @{" Expressions " Link "pv:docs/Expressions.guide/Main"}
      Related terminology : @{" strings " Link "strings"} @{" string pointers " Link "string pointers"} @{" quotes " Link "quotes"}
@EndNode

@Node "quotes" "Glossary : quotes"
   Quotes are used to define a string or string pointer. A single quote
   is used for real strings and a double quote is used for string pointers.
   For commands expecting a string there is no difference between using
   the single quote or the double quote. But if a command expects an
   integer as an argument there is a difference. A double quoted string (or
   string pointer) is in fact a pointer to that string while a single
   quoted string will be parsed according to several steps (variable, list
   element, symbol, function, ...)

      Tutor chapters : @{" Expressions " Link "pv:docs/Expressions.guide/Main"}
      Related terminology : @{" strong quote " Link "strong quote"} @{" strings " Link "strings"} @{" string pointers " Link "string pointers"}
@EndNode

@Node "real-top windows" "Glossary : real-top windows"
   A real-top window is a logical window with the home position set
   to location (0,0). This means that when the logical window is cleared
   the current cursor position is automatically set to that position and
   the logical window is scrolled to the top-left visible corner in
   the real region of the logical window. The 'Refresh' and 'Debug'
   logical windows are real-top windows by default. See
   'top-visible windows' for the other way to set the home position

      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
      Related terminology : @{" top-visible windows " Link "top-visible windows"} @{" logical window " Link "logical window"}
                            @{" home position " Link "home position"}
@EndNode

@Node "recursive aliases" "Glossary : recursive aliases"
   Using the group operator you can make recursive aliases. This is
   because alias expansion is done again in a new group

      Tutor chapters : @{" Installing PowerVisor " Link "pv:docs/InstallingPV.guide/Main"}
      Related terminology : @{" aliases " Link "aliases"} @{" group operator " Link "group operator"}
@EndNode

@Node "resident breakpoints" "Glossary : resident breakpoints"
   A resident breakpoint is a breakpoint that you can put in your program
   even before PowerVisor is running. You put it in your program before
   compiling or assembling it. Resident breakpoints (like all breakpoints)
   are simply 'ILLEGAL' instructions

      Commands : @{" debug " Link "pv:docs/CommandRef.guide/Debug"}
      Tutor chapters : @{" Debugging " Link "pv:docs/Debug.guide/Main"}
      Related terminology : @{" debug nodes " Link "debug nodes"} @{" breakpoints " Link "breakpoints"}
@EndNode

@Node "resident commands" "Glossary : resident commands"
   See @{" resident ML-scripts " Link "resident ML-scripts"}
@EndNode

@Node "resident ML-scripts" "Glossary : resident ML-scripts"
   (or resident commands) For faster execution you can make ML-scripts
   resident. Note that they must be reentrant

      Commands : @{" resident " Link "pv:docs/CommandRef.guide/Resident"} @{" unresident " Link "pv:docs/CommandRef.guide/Unresident"}
      Tutor chapters : @{" Scripts " Link "pv:docs/Scripts.guide/Main"}
      Related terminology : @{" resident commands " Link "resident commands"} @{" ML-scripts " Link "ML-scripts"}
@EndNode

@Node "resource tracking" "Glossary : resource tracking"
   Resource tracking is useful to see what resources a certain program
   uses. Possible resources are: allocated memory, open libraries,
   allocated signals, open files, locks, ... PowerVisor can track
   resources for a process or task with the @{" track " Link "pv:docs/CommandRef.guide/Track"} command

      Commands : @{" track " Link "pv:docs/CommandRef.guide/Track"}
@EndNode

@Node "routine trace mode" "Glossary : routine trace mode"
   See @{" singlestep mode " Link "singlestep mode"}
@EndNode

@Node "scripts" "Glossary : scripts"
   See @{" ARexx scripts " Link "ARexx scripts"}, @{" PowerVisor scripts " Link "PowerVisor scripts"} or @{" ML-scripts " Link "ML-scripts"}
@EndNode

@Node "single quotes" "Glossary : single quotes"
   See @{" quotes " Link "quotes"}
@EndNode

@Node "singlestep mode" "Glossary : singlestep mode"
   When you are tracing a program (a debug node), PowerVisor can use
   three modes : 'singlestep mode', 'execute mode', 'flow mode' or 'routine
   trace mode'. In singlestep mode each instruction is executed step by
   step. After each instruction an exception handler is called and some
   action is performed (you can control this action with the 'trace'
   command). In execute mode the program is running at full speed. The
   program only stops when a breakpoint or other exception occurs. If you
   have a 68020 or higher you can also use 'flow mode'. This is like
   'singlestep mode'. The difference is that the exception handler
   is only called after a change of program flow. 'flow mode' is a lot
   faster than 'singlestep mode' (still slower than 'execute mode') but
   it is also somewhat less accurate because there are less
   'sampling points'. The last possibility is 'routine trace mode'. This
   is equivalent to 'singlestep mode' but singlestepping only occurs in
   the current routine. If a BSR or JSR call is encountered this call
   will be executed at full speed ('execute mode'). Using this feature
   you can restrict the 'trace check' to the current subroutine

      Commands : @{" trace " Link "pv:docs/CommandRef.guide/Trace"} @{" break " Link "pv:docs/CommandRef.guide/Break"} @{" debug " Link "pv:docs/CommandRef.guide/Debug"}
      Tutor chapters : @{" Debugging " Link "pv:docs/Debug.guide/Main"}
      Related terminology : @{" debug nodes " Link "debug nodes"} @{" trace check " Link "trace check"}
@EndNode

@Node "size bar" "Glossary : size bar"
   The size bar is the (mostly horizontal) bar between two logical windows.
   You can use this bar to resize the logical windows

      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
      Related terminology : @{" logical windows " Link "logical windows"}
@EndNode

@Node "snapping" "Glossary : snapping"
   Snapping is the process of moving the mouse to a position in a logical
   window and clicking on the word under the mouse pointer. The word
   will be copied to the stringgadget

      Tutor chapters : @{" Getting Started " Link "pv:docs/GettingStarted.guide/Main"}
@EndNode

@Node "special operator" "Glossary : special operator"
   The special operator ('@') is useful when debugging. It returns the
   value of the registername directly after the operator character

      Tutor chapters : @{" Expressions " Link "pv:docs/Expressions.guide/Main"} @{" Debugging " Link "pv:docs/Debug.guide/Main"}
      Releated terminology : 'linenumber operator'
@EndNode

@Node "special variables" "Glossary : special variables"
   Special variables are a bit special :-) Special variables behave
   like normal variables in that you can assign values to them. But
   when you assign something to a special variable, a certain routine
   is called. The 'mode' variable is an example of a special variable.
   When you change something in the mode variable PowerVisor will
   automatically adapt all internal settings to the new settings provided
   in the assignment

      Commands : @{" vars " Link "pv:docs/CommandRef.guide/Vars"} @{" mode " Link "pv:docs/CommandRef.guide/Mode"}
      Tutor chapters : @{" Looking at things " Link "pv:docs/LookingAtThings.guide/Main"}
      Related terminology : @{" variables " Link "variables"} @{" constants " Link "constants"} @{" functions " Link "functions"}
@EndNode

@Node "stack checking" "Glossary : stack checking"
   PowerVisor has two stack checkers (not counting the internal stack
   checker for PowerVisor). These stack checkers check if a certain
   task (with the @{" stack " Link "pv:docs/CommandRef.guide/Stack"} command) or all tasks (with the @{" account " Link "pv:docs/CommandRef.guide/Account"}
   command) have enough room left on the stack. The minimum amount of room
   allowed on the stack is called the 'stack fail level'

      Commands : @{" stack " Link "pv:docs/CommandRef.guide/Stack"} @{" account " Link "pv:docs/CommandRef.guide/Account"}
      Related terminology : @{" stack fail level " Link "stack fail level"}
@EndNode

@Node "stack fail level" "Glossary : stack fail level"
   The stack fail level is the minimum size of the stack that PowerVisor
   allows before it will halt a task. It is used both by the @{" account " Link "pv:docs/CommandRef.guide/Account"}
   and the @{" stack " Link "pv:docs/CommandRef.guide/Stack"} commands

      Commands : @{" stack " Link "pv:docs/CommandRef.guide/Stack"} @{" account " Link "pv:docs/CommandRef.guide/Account"} @{" prefs " Link "pv:docs/CommandRef.guide/Prefs"}
      Related terminology : @{" stack checking " Link "stack checking"}
@EndNode

@Node "standard logical window" "Glossary : standard logical window"
   A standard logical window is a logical window with a predefined
   meaning for PowerVisor. In the current version there are seven
   standard logical windows : Main, Extra, Debug, Refresh, Rexx, PPrint
   and Source

      Commands : @{" rwin " Link "pv:docs/CommandRef.guide/Rwin"} @{" awin " Link "pv:docs/CommandRef.guide/Awin"} @{" dwin " Link "pv:docs/CommandRef.guide/Dwin"} @{" xwin " Link "pv:docs/CommandRef.guide/Xwin"} @{" owin " Link "pv:docs/CommandRef.guide/Owin"} @{" swin " Link "pv:docs/CommandRef.guide/Swin"}
      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
      Related terminology : @{" logical window " Link "logical window"}
@EndNode

@Node "startup file" "Glossary : startup file"
   (or 'PowerVisor startup file') The startup file or s/PowerVisor-startup
   file is equivalent to the startup-sequence file. It is a PowerVisor
   script containing initialization commands. It is executed when
   PowerVisor starts

      Related terminology : @{" scripts " Link "scripts"} @{" PowerVisor scripts " Link "PowerVisor scripts"}
@EndNode

@Node "string expansion" "Glossary : string expansion"
   String expansion is sometimes used to refer to the process of parsing
   a string (a sequence of characters) while assigning special meanings
   to some characters (like the quote operator and strong quote operator)

      Tutor chapters : @{" Expressions " Link "pv:docs/Expressions.guide/Main"}
      Related terminology : @{" strings " Link "strings"} @{" quote operator " Link "quote operator"} @{" strong quote " Link "strong quote"}
@EndNode

@Node "string pointers" "Glossary : string pointers"
   A string pointer (defined with double quotes) is a pointer to
   a sequence of characters. It is actually an integer is and is
   used as such by all commands expecting integers as an argument.
   This means that arithmetic on string pointers is perfectly valid
   and is equivalent to C pointer arithmetic

      Tutor chapters : @{" Expressions " Link "pv:docs/Expressions.guide/Main"}
      Related terminology : @{" strings " Link "strings"} @{" quotes " Link "quotes"}
@EndNode

@Node "strings" "Glossary : strings"
   A string (defined with or without single quotes) is a sequence of
   characters. Normally strings are surrounded by single quotes (or
   without quotes) but if a command expects a string as an argument
   double quotes will do as well. Note that this is NOT the case for
   a command expecting an integer as an argument. Strings (with
   single quotes) will be parsed according to some steps (variable,
   function, symbol, list element, ...) while a string pointer
   (with double quotes) simply corresponds to the pointer to the
   string

      Tutor chapters : @{" Expressions " Link "pv:docs/Expressions.guide/Main"}
      Related terminology : @{" string pointers " Link "string pointers"} @{" quotes " Link "quotes"}
@EndNode

@Node "structure definition" "Glossary : structure definition"
   A structure definition corresponds with a structure (like in C or
   assembler) or a record (like in Pascal). With the external utility
   'MStruct' you can make structure definitions to be used by
   PowerVisor. A structure definition contains a list of names (for
   the structure fields) and their corresponding types (APTR, BPTR,
   BSTR, CSTR, BYTE, WORD, LONG, ...). You can interprete a range
   of memory as a structure or you can use tags to permanently define
   a region of memory as a structure

      Commands : @{" addstruct " Link "pv:docs/CommandRef.guide/Addstruct"} @{" interprete " Link "pv:docs/CommandRef.guide/Interprete"} @{" struct " Link "pv:docs/CommandRef.guide/Struct"}
      Tutor chapters : @{" Looking at things " Link "pv:docs/LookingAtThings.guide/Main"}
      Related terminology : @{" pvsd file " Link "pvsd file"} @{" tag " Link "tag"}
@EndNode

@Node "strong quote" "Glossary : strong quote"
   The strong quote '' (or <alt>+8 on the keyboard) is normally not
   used very often. Using the strong quotes you can easily put all
   characters in a string expect one. This is the character directly
   after the string quote. This character is used to end the
   strong quote region

      Tutor chapters : @{" Expressions " Link "pv:docs/Expressions.guide/Main"}
      Related terminology : @{" strings " Link "strings"} @{" string pointers " Link "string pointers"} @{" quotes " Link "quotes"}
@EndNode

@Node "symbols" "Glossary : symbols"
   Symbols are names for labels and addresses used in programs. Most
   assemblers and compilers can output symbols in the program hunks.
   PowerVisor supports these symbols when you are debugging programs

      Commands : @{" symbol " Link "pv:docs/CommandRef.guide/Symbol"} @{" debug " Link "pv:docs/CommandRef.guide/Debug"}
      Tutor chapters : @{" Debugging " Link "pv:docs/Debug.guide/Main"}
@EndNode

@Node "tag" "Glossary : tag"
   A tag is a definition for a region of memory. There are 16 tag lists.
   Each tag list can contain an arbitrary number of tags. One tag contains
   a pointer to the start of a memory block, a size in bytes and a type
   (Byte/Ascii, Code, Structure, ...)

      Commands : @{" addtag " Link "pv:docs/CommandRef.guide/Addtag"} @{" remtag " Link "pv:docs/CommandRef.guide/Remtag"} @{" view " Link "pv:docs/CommandRef.guide/View"}
      Tutor chapters : @{" Looking at things " Link "pv:docs/LookingAtThings.guide/Main"}
      Related terminology : @{" tag list " Link "tag list"} @{" tag file " Link "tag file"} @{" current tag list " Link "current tag list"}
@EndNode

@Node "tag file" "Glossary : tag file"
   A tag file contains some tags saved with the @{" savetags " Link "pv:docs/CommandRef.guide/Savetags"} command.

      Commands : @{" savetags " Link "pv:docs/CommandRef.guide/Savetags"} @{" loadtags " Link "pv:docs/CommandRef.guide/Loadtags"}
      Tutor chapters : @{" Looking at things " Link "pv:docs/LookingAtThings.guide/Main"}
      Related terminology : @{" tag " Link "tag"} @{" tag list " Link "tag list"}
@EndNode

@Node "tag list" "Glossary : tag list"
   See @{" tag " Link "tag"}
@EndNode

@Node "task accounting" "Glossary : task accounting"
   When you enable task accounting (with the @{" account " Link "pv:docs/CommandRef.guide/Account"} command) PowerVisor
   counts the number of task switches for each task. This gives a rough
   indication of the cpu time a task uses. You can see this accounting
   information in the @{" task " Link "pv:docs/Lists.guide/Task"} list

      Commands : @{" account " Link "pv:docs/CommandRef.guide/Account"} @{" list " Link "pv:docs/CommandRef.guide/List"}
@EndNode

@Node "Task Control Block (TCB)" "Glossary : Task Control Block (TCB)"
   The Task Control Block is another name for the task structure.

      Related terminolgy : @{" TCB " Link "TCB"} @{" task list " Link "task list"}
@EndNode

@Node "task list" "Glossary : task list"
   The @{" task " Link "pv:docs/Lists.guide/Task"} list contains all processes and tasks currently in the
   system.

      Commands : @{" task " Link "pv:docs/Lists.guide/Task"} @{" list " Link "pv:docs/CommandRef.guide/List"}
      Tutor chapters : @{" List Reference " Link "pv:docs/Lists.guide/Main"}
      Related terminology : @{" list " Link "list"}
@EndNode

@Node "TCB" "Glossary : TCB"
   See @{" Task Control Block (TCB) " Link "Task Control Block (TCB)"}
@EndNode

@Node "templates" "Glossary : templates"
   A template is a syntaxical description of a command. If you have the
   online help files installed (PowerVisor-help and PowerVisor-ctrl)
   you can get command templates by using '?' as the first argument (just
   like CLI commands)
@EndNode

@Node "temporary breakpoint" "Glossary : temporary breakpoint"
   A temporary breakpoint only breaks once. After the breakpoint has done
   its work it will automatically disappear

      Commands : @{" break " Link "pv:docs/CommandRef.guide/Break"} @{" trace " Link "pv:docs/CommandRef.guide/Trace"} @{" debug " Link "pv:docs/CommandRef.guide/Debug"}
      Tutor chapters : @{" Debugging " Link "pv:docs/Debug.guide/Main"}
      Related terminology : @{" breakpoints " Link "breakpoints"} @{" debug nodes " Link "debug nodes"}
@EndNode

@Node "timeout breakpoints" "Glossary : timeout breakpoints"
   A timeout breakpoint only breaks after a specified number of times

      Commands : @{" break " Link "pv:docs/CommandRef.guide/Break"} @{" trace " Link "pv:docs/CommandRef.guide/Trace"} @{" debug " Link "pv:docs/CommandRef.guide/Debug"}
      Tutor chapters : @{" Debugging " Link "pv:docs/Debug.guide/Main"}
      Related terminology : @{" breakpoints " Link "breakpoints"} @{" debug nodes " Link "debug nodes"}
@EndNode

@Node "top-visible windows" "Glossary : top-visible windows"
   A top-visible logical window is a logical window with the home position
   set to the top-left position of the bottom-left visible region of the
   real region of the logical window. This means that when such a window
   is cleared, the current cursor position is set to that position and
   the logical window is scrolled to the bottom visible region.
   The 'Main' logical window is top-visible by default. See
   'real-top windows' for the other way to set the home position

      Tutor chapters : @{" Screens and windows " Link "pv:docs/Screen.guide/Main"}
      Related terminology : @{" real-top windows " Link "real-top windows"} @{" logical windows " Link "logical windows"}
                            @{" home position " Link "home position"}
@EndNode

@Node "trace check" "Glossary : trace check"
   The 'trace check' is the check that the 'trace' command uses to
   determine if the tracing should be stopped. Some possible trace checks
   are : a register has changed, a condition is true, some counter has
   counted to zero, some address is reached, ...
   The 'trace check' is set with the first argument after the 'trace'
   command. If you append a 'r', 't' or 'f' after this first argument
   you can control where and how often the 'trace check' should be
   performed

      Commands : @{" trace " Link "pv:docs/CommandRef.guide/Trace"}
      Tutor chapters : @{" Debugging " Link "pv:docs/Debug.guide/Main"}
      Related terminology : @{" singlestep mode " Link "singlestep mode"}
@EndNode

@Node "variables" "Glossary : variables"
   A variable can be used to remember some value. PowerVisor only has
   integer type variables (although a variable may point to a string,
   this is in fact a C string). There is no limitation (except memory)
   on the length of the variable name. A variable name must start with
   a letter or an underscore but may contain digits in the rest of the
   name.
   Note that variables, constants, special variables and functions all
   live in the same internal list

      Commands : @{" vars " Link "pv:docs/CommandRef.guide/Vars"} @{" remvar " Link "pv:docs/CommandRef.guide/Remvar"} @{" assign " Link "pv:docs/CommandRef.guide/Assign"}
      Tutor chapters : @{" Expressions " Link "pv:docs/Expressions.guide/Main"}
      Related terminology : @{" constants " Link "constants"} @{" functions " Link "functions"} @{" special variables " Link "special variables"}
@EndNode
