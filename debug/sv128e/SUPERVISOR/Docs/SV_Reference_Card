      SUPERVISOR v1.28 © THE 1702 GROUP 1997. Designed & Coded by DAN
$VER: SV_Reference_Card 1.28

			   Quick Command Summary
			   =====================

Console keys:
------------
(Misc)
ARROWS			:Move the cursor
HELP			:Show console help-page
BACKSPACE		:Clear previous char
DELETE			:Clear next char
RETURN			:Process line
ENTER			:Process line
SHIFT+LEFTARROW		:Cursor to start of line
SHIFT+RIGHTARROW	:Cursor to end of line
SHIFT+UPARROW		:Cursor to first line
SHIFT+DOWNARROW		:Cursor	to last line
SHIFT+PGUP		:Cursor to first line
SHIFT+PGDN		:Cursor to last line
SHIFT+INS		:Toggle insert on/off
SHIFT+RETURN		:Process line and go back(only when editing)
SHIFT+ENTER		:Cursor to next line
SHIFT+BACKSPACE		:Insert space
SHIFT+DEL		:Insert space
SHIFT+HELP		:Clear screen
CTRL+A			:Cursor to start of line
CTRL+Z			:Cursor to end of line
CTRL+X			:Clear line
CTRL+U			:Delete to BOL
CTRL+K			:Delete to EOL
CTRL+I			:Tab
CTRL+H			:Home
CTRL+J			:Cursor to next line
CTRL+R			:Reverse on
CTRL+O			:Reverse off
CTRL+Q			:Delete to cursor pos
CTRL+W			:Delete from cursor pos
CTRL+F			:(Un)Lock keypadnumbers
CTRL+G			:(Un)Lock scrolling
CTRL+M			:Process line
CTRL+RETURN 		:Insert line
CTRL+DEL		:Clear key buffer
CTRL+HELP		:Refresh screen
CTRL+LEFTARROW		:Delete to BOL
CTRL+RIGHTARROW		:Delete to EOL
CTRL+S			:Smartscrolling on/off
CTRL+P			:Toggle insert on/off
(FKeys)
F1			:Show previous command
F2			:Show next command
F8			:Toggle RTM window
F9			:Toggle info bar (a buffer will be allocated if required)
F10			:Turn page
SHIFT+F1		:Search command
SHIFT+F2		:End of command history
SHIFT+F3		:Repeat last command
SHIFT+F9		:Kill infobar & free its buffer
SHIFT+F10		:Toggle timer
CTRL+F9			:Expand RTM window (+1 line)
CTRL+F10		:Shrink RTM window (-1 line)
(Keypad)
SHIFT+END		:Cursor to bottom left
SHIFT+NUML		:(Un)Lock keypadnumbers
SHIFT+SCRL		:(Un)Lock scrolling
SHIFT+HOME		:Cursor to upper left
SHIFT+DEL		:Clear next char
SHIFT+ARROWS		:Move the cursor
SHIFT+/			:Smartscrolling on/off
(Special)
ESC			:Break command
CTRL+SHIFT		:Break command
CTRL+ALT		:Break command
ALT			:Delay scrolling
AMIGA			:Lock scrolling

RTM shortcuts:
-------------
ALT+`			:Next view
ALT+0-9			:Jump to mark 0-9
ALT+-			:Jump to automark
ALT+UPARROW		:Previous line
ALT+DOWNARROW		:Next line
ALT+LEFTARROW		:Pull address & jump to it
ALT+RIGHTARROW		:Push current viewaddress & jump to <ea1>(dsm&hex view only)
ALT+D			:Swap vars DC <-> RTM
ALT+Q			:Reset view address
ALT+B			:Toggle BP
ALT+,			:Sub 2 to viewaddress
ALT+.			:Add 2 to viewaddress
ALT+W			:Go to RES(0).CRES=0
ALT+E			:Go to RES(-1).CRES=-1
ALT+A			:Decrease CRES,jump to RES(CRES)
ALT+S			:Increase CRES,jump to RES(CRES)
ALT+T			:Trace instruction
ALT+V			:Toggle smartview
ALT+Y			:Trace flow
ALT+Z			:Single step
ALT+R			:Run program
ALT+U			:Skip instruction
ALT+N			:Decrease modulo
ALT+M			:Increase modulo
ALT+P			:Toggle MemManager (M)
ALT+L			:Toggle auto-lock on 1st result (R)
ALT+J			:(PCTracer)Find previous PC difference
ALT+K			:(PCTracer)Find next PC difference
ALT+SHIFT+0-9		:Set mark 0-9
ALT+SHIFT+UPARROW	:Previous page
ALT+SHIFT+DOWNARROW	:Next page
ALT+SHIFT+LEFTARROW	:Jump to first level
ALT+SHIFT+RIGHTARROW	:Push current viewaddress & jump to <ea2>(dsm view only)
ALT+SHIFT+D		:Go to DC address
ALT+SHIFT+Q		:Reset view address&mode
ALT+SHIFT+U		:Toggle smart/(U)continuous update
ALT+SHIFT+Z		:Zap all breakpoints
ALT+SHIFT+X		:Toggle NOP
ALT+SHIFT+B		:Jump to BCPL address
ALT+SHIFT+,		:Go to first level
ALT+SHIFT+.		:Go to previous level
ALT+SHIFT+M		:Clear modulo
ALT+SHIFT+`		:Previous view
ALT+SHIFT+F		:Find all references to current viewaddress
ALT+SHIFT+K		:(PCTracer)Kill PC map
ALT+SHIFT+T		:Trace PC

Monitor commands:
----------------
!			:Restart monitor
!!			:Exit
!B			:Toggle boot-capture
!C[flag]		:Restore TOD
!D			:AutoDiskInit on/off
!I			:Toggle beam-synced scrolling
!K			:Hard reset
!L			:Restore screen
!M			:Toggle taskcpt
!N			:Toggle PAL/NTSC
!Ppri			:Set resident priority
!Q			:Reboot
!R			:Toggle reset-freeze
!S[flag]		:Use blitter
!T[I]			:Cache on/off
!V[vectortable]		:Set VBR
!W[taskaddress]		:Capture task
!X			:Rem SV from resident tags
!Y			:Toggle interrupt transparency
!Z[keycode]		:Set freeze-key
#B			:Pause/Continue macro execution	(REGISTERED VERSION)
#E			:Toggle echo			(REGISTERED VERSION)
#F			:Toggle fkeys			(REGISTERED VERSION)
#I			:Macro info			(REGISTERED VERSION)
#L[name]		:List macro[s]			(REGISTERED VERSION)
#U[n,string]		:Show/Edit fkeys		(REGISTERED VERSION)
#X[args]		:External command		(REGISTERED VERSION)
%			:Show RawKey
&&strt,end,long[,long]	:Find encryption key
&st,end,eor,sub[,mode]	:En/De-code memory
(size[,flags]	 	:Alloc memory
)[segment,size] 	:Free memory
*[flag] 		:Safety
++s,e,mod,rs,re[,xs,xe]	:Relocate binary
+start,dest[,relcbase]	:Relocate executable
-[flag]			:Sign on/off
.			:List breakpoints
/[flag]			:Symbolic copper disassembly on/off
0[base-id]		:Set default base
1			:Config disassembler
2A[start,end]		:AutoGfxSearch
2Bcopperlist[,end]	:Add PictureData from copperlist (Update grdata)
2Ccopperlist[,end]	:Fetch PictureData from copperlist (Create grdata)
2I			:GfxRipper info
2K[pic#]		:Kill IFF/GfxRipper data
2L[L]			:Show GfxRipper data
2M[address]		:Generate IFF from current grdata
2N			:Resume AutoGfxSearch
2P			:Preview IFF pic (get size)
2S			:Show current picture
2U			:Get current colormap
2V			:List IFF pics
3			:Config assembler
<			:Breakpoints on/off
=			:Symbol info
=!			:Zap labels
=$name[,address]	:Define label
=/[$]|[pattern]	 	:Symbol table
=[=]name[,value|expr]	:Define symbol
>>			:Show config codes for Patcher
>F[addr]		:Free patchmem
>I|X[s]vec[,endvec]	:Include|Exclude vector[s]
>L			:Show vector list
>P			:Lock patcmem
>[mode]|[C] 		:Set patcher
??[flag]		:Packed calc result on/off
?expression		:Calculate expression value
AC[address]		:Assemble (COPPER)
A[address]		:Assemble (680x0)
Bname[ arguments]	:Do macro			(REGISTERED VERSION)
B\[address] 		:Calculate bootblock checksum
CMstart1,end1,start2	:Compare memory
COstart,end,dest	:Copy memory
D[startaddr][,endaddr]	:Disassemle 680x0 code
EC			:Strobe copper
EE[n,string]		:Config RealTimeMonitor
EH[H]			:Trainer info
EI[l][,m][,s,e][,wrkmem]:Init TrainerFinder
EM			:Toggle MemoryManager
EQ			:Free TrainerFinder memory
ER			:Init RealTimeMonitor
ES[l]			:Search trainer
EW[flag]		:MemoryWatcher on/off
FA[address] 		:Find address
FDstart,end,data	:Find disassembly
FIstart,end[,data]	:Fill memory
FMs,e,dat[,msk][,fm,lm]	:Find data (MASKABLE)
FRaddress[,mode][,limit]:Find relative address
Fstart,end,data[,H|O]	:Find data (NORMAL|ENCRYPTED)
G[address]		:Go
H[commandlist]		:Help
I			:Info
IAbase[,size][,flags]	:AddMem				(REGISTERED VERSION)
IC			:Trainer info
ID[A]			:Disk info
IF			:Freezer info
IH![name]		:Custom regs info		(REGISTERED VERSION)
IH[addr]		:Custom regs info		(REGISTERED VERSION)
IKnodenumber 		:Kill memory
IM[node#]		:Mem info
INtasknumber		:Task info
IR[*][modulenumber]	:Resident info
IT[taskname]		:Task info
IV			:Version info
Jaddress		:Jump (execute local routine)
K			:Trace over
KN			:Put NOP
KR			:Do RTS
KS			:Skip next instruction
L[startaddr][,endaddr]	:Disassemble copperlist
M[B|W|L]address,value 	:Poke
N!			:Kill PC map
N[address]		:Show PC map
OC[moduleaddress]	:Backup mod
OD[start,end]		:DeepFind mod
OF[start,end]		:FastFind mod
OI[moduleaddress]	:Module info
OMstrt,end[,per][,vol]	:Hear mem
OP[moduleaddress]	:Play module
OR[moduleaddress]	:Toggle module ID
OS			:Stop/Continue module playing
OX			:Free modbak
P[sspace][,hash][,fast]	:Set symbol memory
Q[startaddr][,endaddr]	:Hex dump
RS[dev][,adr][,of][,len]:Read block
S[address][,modulo]	:View memory
T/[mode][,address]	:Link tracer
T:[start][,end]		:PC Trace
T[*]!adrregnumber,value	:Address trace
T[*]%condition		:Conditional trace
T[*]&conditionvarnumber	:Conditional trace
T[*][steps][,mode] 	:Trace into
UA[address][,start,end]	:Find changes to address
UB[address][,start,end]	:Find all references to address
UC[start,end]		:Find copperlist
UD[start,end]		:Find copperlist
UIstartreg[,endreg]	:Include regs in CopperFinder list
UL			:Show CopperFinder include list
UP			:Config CopperFinder
UT[copperlist][,copcon]	:Test copperlist
UU			:Show config codes for CopperFinder
UXstartreg[,endreg]	:Exclude regs from CopperFinder list
WS[dev][,adr][,of][,len]:Write block
X[B|F|R|S]		:Display regs
Y[unit][,mode][,dos]	:Format disk
Z[!|address[,[attr]cnt]]:Add/Remove breakpoint[s]
][flag] 		:Raw-Key/ASCII mode
`[address]		:Move chipdata
{[flag]			:Keyboard restore on/off

FKEYS - Default bindings:
------------------------
(0-9:F1-F10, 16-25:SHIFT+F1-F10, 10-15/26-29:CTRL+F1-F10)
<NORMAL>
00-F1=internal(HISTBACK)	+ macro(<empty>)	+ string(<empty>)
01-F2=internal(HISTFORWARD)	+ macro(<empty>)	+ string(<empty>)
02-F3=internal(<empty>)		+ macro(LED)		+ string(<empty>)
03-F4=internal(<empty>)		+ macro(RTMPEEK)	+ string(<empty>)
04-F5=internal(<empty>)		+ macro(CLEANUP)	+ string(<empty>)
05-F6=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
06-F7=internal(SWAPPAGE)	+ macro(<empty>)	+ string(<empty>)
07-F8=internal(TOGGLERTM)	+ macro(<empty>)	+ string(<empty>)
08-F9=internal(TOGGLESTATLINE)	+ macro(<empty>)	+ string(<empty>)
09-F10=internal(TURNPAGE)	+ macro(<empty>)	+ string(<empty>)
<SHIFT>
16-F1=internal(HISTSEARCH)	+ macro(<empty>)	+ string(<empty>)
17-F2=internal(HISTBOTTOM)	+ macro(<empty>)	+ string(<empty>)
18-F3=internal(HISTREPEAT)	+ macro(<empty>)	+ string(<empty>)
19-F4=internal(<empty>)		+ macro(RTMENDPEEK)	+ string(<empty>)
20-F5=internal(<empty>)		+ macro	(SHOWCOP)	+ string(<empty>)
21-F6=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
22-F7=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
23-F8=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
24-F9=internal(REMOVESTATLINE)	+ macro(<empty>)	+ string(<empty>)
25-F10=internal(TOGGLETIMER)	+ macro(<empty>)	+ string(<empty>)
<CONTROL>
10-F1=internal(<empty>)		+ macro(NOBERR)		+ string(<empty>)
11-F2=internal(<empty>)		+ macro(GOBT)		+ string(<empty>)
12-F3=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
13-F4=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
14-F5=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
15-F6=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
26-F7=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
27-F8=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
28-F9=internal(EXPANDRTM)	+ macro(<empty>)	+ string(<empty>)
29-F10=internal(SHRINKRTM)	+ macro(<empty>)	+ string(<empty>)
-- Each FKEY can have up to 3 types of functions associated:  INTERNALS, --
-- MACROS   and   STRINGS,   with  these  priorities:   STRINGS  (max),  --
-- MACROS (med), INTERNALS (min)					 --
** MACROS and STRINGS are available in REGISTERED VERSION only **
							  ----
Default defines for C? symbols:
------------------------------
(used by trace and breakpoint system as condition-terms)
C0	:pc<$f80000!pc>$ffffff
C1	:(peekb($bfe001)&$80)<$80
C2	:pc=bt
C3	:<empty>
C4	:<empty>
C5	:<empty>
C6	:<empty>
C7	:<empty>
C8	:<empty>
C9	:<empty>

Internal macros: (REGISTERED VERSION: v1.24r+ required)
---------------
#:AUTOCONFIG
;FKey definitions
;#\u10,!!\\0a
;#\u11,if\\0a
;#\u12,=/\\0a
;#\u13,dbt\\0a
;#\u14,dpc\\0a
;#\u15,x\\0a

#:LED,(3)-1
;toggle filter
mb$bfe001,peekb($bfe001)|2

#:RTMPEEK,(4)-1
@IF rtmmode=0
pkremember[rtm
rtm[ea1(rtm)
rtmmode[1
@ENDC

#:RTMENDPEEK,15+(4)
@IFD pkremember
@IF rtmmode
rtm[pkremember
rtmmode[0
=pkremember
@ENDC
@ENDC

#:GOBT,11
@IF SYS>>16&2
;use fast trace on 68020+ CPUs
t*&2
@ELSE
t&2
@ENDC

#:__BOOT
;wait for BootBlock execution
#C127
; ^FM_BOOT
@IF BBMODE
@IF BBMODE=1
t*&2
@ENDC
@IF BBMODE=2
pc[bt
@ENDC
@IF BBMODE=3
bbbak0[PEEKW(bt)
m(bt),$4afc
b\\bt-$c
m(bt),bbbak0
=bbbak0
zbt,r
!!
b\\bt-$c
@ENDC
@PRINT '<BootBlock ready to run>'
@ENDC
CLEANUP

#:CLEANUP,(5)-1
;remake the display on each freezer activation
#A
;^match all freeze codes
!L

#:NOBERR,10
;disable BusError on A3000/A4000
m$de0000,$7f7f
@PRINT 'Bus error OFF'

#:SPLIT
;SPLIT lock1,lock2[,size]
@IF NARG<2
@PRINT 'Missing arguments!'
@PRINT 'Usage:'
@PRINT 'SPLIT lock1,lock2[,size]'
@QUIT
@ENDC
view1[\1
view2[\2
@IF NARG>2
spcnt[\3
@ELSE
spcnt[RTMSIZE/2-1
@ENDC
spsize[spcnt
ER
EE#0,?spsize,view1
spcnt[spcnt+1
EEspcnt-1,t-- View#2 ---
EEspcnt,!view2+rtm-view1
@lab loop
_spcnt[spcnt+1
_spend[(spsize)*2+1
@IF spcnt<spend
_EEspcnt,!
@GOTO loop
@ENDC
=spend
=spcnt

#:CMP
;CMP start1,end1,start2
@IF NARG<3
@PRINT 'Missing arguments!'
@PRINT 'Usage:'
@PRINT 'CMP start1,end1,start2'
@QUIT
@ENDC
SPLIT \1,\3
CM\1,\2,\3
rtm[res(0)

#:SHOWCOP,15+(5)
;SHOWCOP [copperlist]
@IF NARG
l\1,COPEND(\1)+4
@ELSE
lcop,COPEND(cop)+4
@ENDC
##

Macro Special-Commands: (REGISTERED VERSION)
----------------------
## or NULL 		:EndOfMacros
#\			:replaced with #
#:name[,Func#]		:define macro (macro text follows)
#C[code]		:(inside macro)define macro code(mcm_Link)
#A			:(inside macro)all codes will match this macro
@ECHO			:(inside macro) toggle echo on/off
@FNC <n>		:(inside macro) execute internal function 'n'
@IF <expr>		:start conditional if result>0
@IFD <symbol>		:start conditional if <symbol> exists
@ELSE			:execute if <expr> is false
@ENDC			:end of conditional
@PRINT <"txt"|expr>[,N]	:print text/decvalue. N=noline
@HPRINT <"txt"|expr>[,N]:print text/hexvalue. N=noline
@GOTO <label>		:go to <label>
@LAB <label>		:<label> for @GOTO command
@QUIT			;exit from macro
\n			:replace with arg 'n' (it may be anywhere on the line)(1<=n<=9)
\\			:replaced with \
;			:Remark (line is not executed)
* lines with '#' are processed on first pass (init-macros preparsing)
* '@' commands are processed on each macro execution
* #, @ and ; commands must be at beginning of a line
* \n args can't be on macro-command lines!(the lines beginning with @)
