@database SUPERVISOR.guide
@width 80
@index idx

@$VER: SUPERVISOR.guide 1.28 (05.03.97)
@(C) THE 1702 GROUP
@AUTHOR Dan

@REM ** This is an AmigaGuide document. Read it with an AmigaGuide viewer **

@node idx "SUPERVISOR® Manual"
@next idx



			     @{B}Select a Document@{UB}

			     @{" Installer Docs " link	SVInstaller.guide/main}
			     @{"  Program Docs  " link	SUPERVISOR.guide/main}
@endnode

@node main "SUPERVISOR® Documentation"
@prev SVInstaller.guide/main
@next main
****************************************************************************
*                  SUPERVISOR (c) 1992-1997 THE 1702 GROUP                 *
*                          Designed & Coded by DAN                         *
*                           Released on  05-03-97                          *
* This program is ShareWare.You may copy it freely provided that all files *
*               in this package are included without changes               *
*--------------------------------------------------------------------------*
*                         SUPERVISOR Release 1.28                          *
*                               USER MANUAL                                *
****************************************************************************

	@{B}Table of Contents:@{UB}

	@{" About this manual         " link About}
	@{" Introduzione              " link Intro}
	@{" Installazione             " link Install}
	@{" Configurazioni supportate " link SysConfig}
	@{" Il Freezer                " link Freezer}
	@{" Il Monitor                " link Monitor}
	@{" Il Debugger di sorgente   " link Source}
	@{" Il Real Time Monitor      " link RTM}
	@{" Gestione Avanzata         " link Adv}
	@{" Codici Speciali           " link CharTab}
	@{" Tabella Riassuntiva       " link RefCard}
	@{" Trouble-shooting          " link Troubles}
	@{" Bug Reports               " link Bugs}
	@{" Copyright                 " link Notice}
	@{" Registrazione             " link HowToRegister}
	@{" Demo Restrictions         " link DemoLimits}
	@{" Distribution              " link Copying}
	@{" Cracking SUPERVISOR ...   " link Hackers}
	@{" History                   " link History 250}
	@{" Author Info               " link Address}
@endnode

@node About "SUPERVISOR®: About this manual"
@prev About
@next About
                             @{B}About this manual@{UB}

  SUPERVISOR e' distribuito in diversi formati; i principali sono:

o Versione dimostrativa (Evaluation)
o Versione registrata (Registered)
o Versione debug-Evaluation
o Versione debug-Registered
o Versioni BetaTest varie

  Le  prime due versioni sono quelle destinate al pubblico, mentre le altre
sono  riservate  ai  collaudatori  e all' autore di questo programma per la
fase  di  sviluppo.  Queste ultime comprendono vari extra rispetto alle due
versioni standard, fra cui un mini-debugger interno integrato.
  Questo  manuale copre unicamente gli argomenti relativi alle due versioni
pubbliche ufficiali.
@endnode

@node Copying "SUPERVISOR®: Distribution"
@prev Copying
@next Copying
                               @{U}@{B}Distribution@{UB}@{UU}

@{I}Evaluation version:@{UI}
o No file may be copied individually.  You may only copy the whole umodified
  archive.
o The archive may not be sold for profit.
o The  EXECUTABLE  files  produced  with  'Generate File' option may not be
  copied.
o The   BINARY   modules  produced  with  'Generate  File'  option  may  be
  distributed  only  if  included  inside  your  programs as their internal
  debuggers.   The  modules  must  be  present  in your program without any
  modification.   While  running your program may patch them, provided that
  no  Copyright  notice  is  in  any  way  altered and that no 'Evaluation'
  reminders are removed.

@{I}Registered version:@{UI}
o No  file  may  be  distributed  (in  ANYWAY  to ANYONE!).  If you are not
  willing to do so, please read the section about the @{"PROTECTION" link Hackers}, first!

@{I}Other versions:@{UI}
o Reserved for developers only!  (Contact me if you want to know more)

                   @{U}These conditions may change in future@{UU}
@endnode

@node Hackers "SUPERVISOR®: -- READ THIS BEFORE TRYING TO CRACK SUPERVISOR --"
@prev Hackers
@next Hackers
                      @{U}@{B}The best protection ever seen!@{UB}@{UU}
        (If you are planning to crack my program, read this first!)

@{B}I - Cracking the EVALUATION version@{UB}:
  If  you take a look at the SUPERVISOR executable you can see it's made of
two  hunks:

- The  first  is  the  installer  procedure:  it can handle all versions of
  SUPERVISOR,  thus  it  may  be  the  same  for EVALUATION, REGISTERED and
  DEVELOPER releases.
- The second is the main program:  each version has a DIFFERENT code, so in
  the  evaluation  code you will NOT find ANY of the routine related to the
  features  present  in  the  registered  version.   In some cases the code
  differs even when it behaves in the same manner!

  For these reasons @{I}it is impossible to make a @{U}real@{UU} REGISTERED version from
an EVALUATION one@{UI}.


@{B}II - Copying the REGISTERED version@{UB}:
  Since  each REGISTERED copy is PERSONALIZED, before spreading it you need
to remove all the markings which may lead to you (such as serial numbers).
  Unfortunately this program has an almost uncrackable way of storing your
personal data inside its code:

  If  you  compare  two  copies  (same  version)  with two different serial
numbers  you  will  see that almost every single byte of them doesn't match
each  other.  This is due to the fact that many routines are assembled in a
different  place according to their serial number.  Some other routines are
even  replaced  with some other equivalent(!) ones.  And at least there are
many other little surprises that I won't mention to you!

  @{I}Remember that I only need a single marking left to track you down!@{UI}

  To  make  a  registered  copy  I only need to change a 32bit number (that
makes over 4,000,000,000 (!) of heavily different 'copies') and assemble it
...   to unregister it YOU will spend many months of hard work reassembling
the whole program!  All this to spare $10?  Besides consider that when (and
IF)  you  finish  to  crack  ONE version, it's very likely that I will have
already  released better and newer versions which will make your work of no
interest for anybody!
@endnode

@node Intro "SUPERVISOR® Documentation: Introduzione"
@prev Intro
                               @{B}Introduzione@{UB}

  SUPERVISOR e' stato concepito con l' intenzione di creare il piu' potente
freezer per AMIGA.

  Un  freezer  e'  un  tipo  di debugger molto evoluto che permette il piu'
accurato  monitoraggio  possibile  di  un  qualsiasi programma.  Esso e' in
grado di funzionare in assenza del sistema e di prendere il controllo della
macchina in qualsiasi stato essa si trovi.
  Attivando il freezer si provoca un congelamento di tutte le attivita' del
sistema,  dopodiche'  ci  si  ritrova innanzi ad un monitor che permette di
esaminarne  ogni  singolo  bit e ogni singolo aspetto, nonche' di apportare
quante  e  quali modifiche si ritenga opportuno:  in altre parole, si ha il
pieno controllo della macchina!
  Allo  scongelamento  tutto  riprende  a  funzionare  come  se nulla fosse
accaduto (@{I}trasparenza@{UI}).

  Esistono  freezer  @{U}hardware@{UU}  e  @{U}software@{UU};  SUPERVISOR  fa parte di quest'
ultima  categoria.
   I  primi  si  avvalgono  di  circuiteria  specifica che permette loro di
prendere  facilmente  il  controllo  della  macchina  e di intercettare gli
accessi  ai registri @{I}write-only,@{UI} in modo da poterne conoscere il contenuto.
Essi  hanno  l'  enorme  handicap  di  essere strettamente dipendenti dalla
configurazione  per  la  quale  sono  stati  progettati,  per  cui  possono
funzionare  solo  con  alcuni  tipi  di  macchina,  non  ne  consentono  l'
espansione  e  risultano  pertanto  adatti  solo ai modelli piu' vecchi con
configurazione  minima.   Ritengo  che  un aggiornamento per i modelli piu'
recenti  non  sarebbe  neppure  proponibile,  in quanto, a parte gli appena
citati limiti, le macchine attuali sono dotati di almeno un 68020, il quale
e'  dotato  del registro VBR, che permette la rilocazione della tabella dei
vettori.   Esso risulta utilissimo ai freezer software, ma diviene il punto
debole di quelli hardware.
  I   freezer  software,  invece  si  avvalgono  unicamente  delle  risorse
disponibili  sulla  macchina  sulla quale girano, e, sebbene risultino meno
efficienti  con  configurazioni  minime,  sono senza dubbio piu' versatili,
flessibili   e   maneggevoli,   facilmente   aggiornabili  (e'  sufficiente
procurarsi  la  nuova  versione  del  programma)  ,  adatti ai sistemi piu'
potenti, ma soprattuto sono molto piu' economici!

  I  freezer sono probabilmente gli unici programmi che lecitamente possono
e  anzi debbono funzionare senza avvalersi del sistema operativo, in quanto
e'  loro  prerogativa  operare  in qualsiasi stato si trovi la macchina, in
modo  da  permettere  all' utente di avere sempre il piu' completo quadro e
controllo della situazione.
  Un freezer puo' rivelarsi utile persino per il debugging di programmi che
girano  normalmente  sotto  sistema,  in  particolare quando vi sono alcune
routine  funzionanti in modo supervisore:  queste ultime non possono essere
tracciate  da  un normale debugger, dal momento che le eccezioni utilizzate
per  questo  fine,  in  modo  supervisore  vengono interpretate dal sistema
operativo come una situazioni di crash, con conseguente guru!

  Al momento SUPERVISOR e' senza dubbio il MIGLIOR freezer/monitor/debugger
disponibile  per  Amiga,  sia  tra  quelli  software (il 99% di essi non si
avvicina  neppure  lontanamente alle prestazioni offerte da SUPERVISOR) che
hardware  (i quali, per come la vedo io, risultano piu' efficienti solo con
un vecchio Amiga inespanso:  CPU 68000 e 512k di RAM).

Esaminiamo alcune specifiche di questo programma:
- Documentazione   in   formato   amigaguide  e  @{"Help in linea" link SVInstaller.guide/OnlineHelp}  durante  l'
  installazione.  Nel monitor sono integrate tabelle riassuntive per l' uso
  della tastiera, dei comandi, e dei registri hardware di AMIGA (per nome e
  per indirizzo) con possibilita' di consultare singole voci.

- Singolo  file  eseguibile  molto  @{I}compatto@{UI}  e  @{I}autonomo@{UI} contenente sia il
  programma  principale  che  le  routine  di installazione.  Sebbene possa
  accedere  a  librerie  o  a  file  di vario genere esterni, essi non sono
  indispensabili  al suo funzionamento.  In pratica per usare SUPERVISOR e'
  sufficiente avere il solo file @{B}mon@{UB}.

- Possibilita'  di  creare  un  modulo autonomo preconfigurato @{I}eseguibile @{UI}o
  @{I}binario @{UI}(inseribile in un programma come proprio debugger interno)

- Codice compatibile con tutti i processori dal 68000 al 68060, in grado di
  avvantaggiarsi  delle  proprieta'  specifiche  delle  varie  CPU.   SV e'
  attualmente  l'  unico  che  gestisce  correttamente i due stack del modo
  supervisore (Interrupt & Master) del 68020/030/040!

- Supporto  per  il  cambio  CPU  a  caldo.  Se durante il reset avviene un
  cambio  CPU  (come  consentito  da alcune schede acceleratrici), SV e' in
  grado di adattarsi automaticamente al nuovo processore.

- Supporto per tutti i chip custom da Agnus/Denise a Alice/Lisa.

- Rispristino  nella  fase  di  @{I}scongelamento @{UI}di tutti i registri alterati.
  Per  quanto  riguarda i famosi @{I}Write Only,@{UI} non potendo far affidamento su
  hardware  specifico  (come  detto  in  precedenza),  il problema e' stato
  risolto nella seguente maniera:

  1-L'  ambiente  @{"monitor" link Monitor}  utilizza  il  minor numero possibile di registri
    Write-Only:
    - Video:	 1 bitplane, hires.  Aggiornamento video effettuato tramite
		 VBlank interrupt anziche' per mezzo del Copper.
    - Scrolling: il  blitter  viene  utilizzato  solo  se  richiesto  dall'
		 utente.   Le  routine  di  scrolling  per  il  680x0  sono
		 comunque   discretamente   veloci,  e  rendono  totalmente
		 inutile l'utilizzo del del blitter qualora si possieda una
		 CPU appena piu' veloce del normale.
    -  DiskDMA:  i  registri  DMA  del  disco  vengono  utilizzati  solo se
		 necessario.  Per cui se l' utente non effettua operazioni
		 di I/O sul disco essi rimangono invariati.
  2- I  pochi  registri  utilizzati, di norma dovrebbero venir ripristinati
     automaticamente   dal   Copper   al   momento   dello  'scongelamento'
     (pochissimi  i  programmi che non ne fanno uso).  Comunque, in caso di
     necessita'  l'  utente  puo'  indicare  al freezer il contenuto che il
     registro Write Only dovrebbe assumere allo scongelamento.

  *- SUPERVISOR  e'  in  grado  di ripristinare al 100% lo stato di ciascun
     drive,  come  riposizionamento  delle  testine,  e  stato  del  motore
     (ricordo che il bit MTR della porta B del circuito CIAB -NON- riflette
     necessariamente  lo  stato del motore dei drive, poiche' essi LATCHano
     questo segnale solo quando il segnale SELx corrispondente va a livello
     basso).

  **- Notare  che  attualmente  SV  e' il freezer software piu' accurato in
      assoluto  fra  tutti  quelli  esistenti  su AMIGA grazie ad un codice
      estremamente 'intelligente' ma che allo stesso tempo permette in ogni
      momento  l'  intervento manuale dell' utente per sopperire a tutte le
      mancanze  che  un' intelligenza artificiale puo' avere.  In futuro e'
      in  progetto  di  far  uso  di  eventuali MMU, ma comunque in maniera
      facoltativa,  in  modo  da  non  compromettere  la compatibilita' con
      macchine  che non ne sono dotate, o con sistemi che non ne permettano
      la condivisione.

- Una volta installato e' completamente indipendente dal sistema operativo!
  Cio'  non  esclude pero' che si possano monitorizzare le sue attivita' ed
  eventualmente interagire con esso se le sue strutture risultano intatte.

- Potenti  comandi  di  debugging,  fra cui la possibilita' di intercettare
  qualsiasi accesso ad un determinato indirizzo durante l' esecuzione di un
  programma SENZA bisogno di MMU!!!

- Disassembler simbolico, @{"source-level" link Source} debugger.

- Assembler di linea espandibile tramite moduli esterni.

- Real   Time   Monitor   (@{"RTM" link RTM}):    monitor   in   tempo  reale,  altamente
  personalizzabile.   Fornisce le sue informazioni in una finestra a parte,
  in  modo  da non disturbare il normale funzionamento del programma.  Puo'
  essere comandato dall' utente in maniera semplice e veloce.

- Interfaccia utente confortevole, di semplice e veloce gestione.

- D-DOS  e'  il  sistema  operativo di gestione dischi di questo programma.
  Supporta  3  filesystem  (Standard,  FFS,  e  NEW,  specifico  di  questo
  programma),  due  sistemi  di  formattazione  (Standard  AMIGADOS, e Fat-
  Track).   Tuttavia  il  sistema  e'  ancora  in  fase di sviluppo e sara'
  presente in forma completa solo nelle successive versioni!

- Gestione  della  memoria:   il  programma  dispone di una propria area di
  lavoro  'interna'  e  di  un altro blocco (configurabile dall' utente) di
  memoria  esterna,  gestita con principi analoghi a quelli di Exec, quindi
  con  funzioni  di  allocazione  e  di deallocazione, che ne permettono la
  ripartizione  dinamica  tra  il @{"monitor" link Monitor} e l' utente in base alle esigenze
  che di volta in volta si presentano.

- @{"Memory Manager" link MemManager}

- Sistema  di  @{"valutazione" link Eval}  di  espressioni:  tutte le immissioni numeri da
  parte  dell'  utente  vengono  gestite  da questo sistema, il quale ha le
  seguenti caratteristiche:
  1-riconosce  i  seguenti  tipi  di  dati:   esadecimale, ottale, binario,
    decimale, ascii, rawkey, breakpoint, banchi di memoria, assembly;
  2-gestisce 10 tipi di variabili;
  3-valuta  intere  espressioni,  con operandi di qualsiasi tipo fra quelli
    sopra indicati, con priorita' e parentesi.

- Grande quantita' di funzioni riguardanti la ricerca dati (Trainer Finder,
  Heavy  Search, Code Search, Relative Search, Copperlist Finder, Gfx&Music
  Ripper, ...).

- Possibilita'   di   configurare  a  piacimento  quasi  ogni  aspetto  del
  programma.

- Coesiste con altri programmi residenti (es: ZKick).

* Consiglio  di prendervi un po' di tempo per leggere la documentazione che
segue,  con la quale sarete in grado di sfruttare al meglio le possibilita'
offerte da questo programma.  Ne vale davvero la pena!
@endnode

@node Install "SUPERVISOR® Documentation: Installazione"
                          @{"INSTALLAZIONE DEI FILES" link SVInstaller.guide/Config}

                         @{U}@{B}INSTALLAZIONE in MEMORIA@{UB}@{UU}

  Per  poter  funzionare,  SUPERVISOR  necessita  di  essere configurato ed
installato nella memoria del computer.
  La procedura di configurazione/installazione e il programma principale si
trovano integrati in un unico file eseguibile molto compatto.
  La documentazione della procedura di installazione e quella del programma
vero e proprio si trovano tuttavia in due file separati, ma interagenti fra
di loro, in modo da renderne la consultazione piu' semplice ed immediata.
  Consiglio  di  leggere  il @{"documento" link SVInstaller.guide/main} relativo all' installazione prima di
procedere con il presente e con l' utilizzo del programma.
@endnode

@node SysConfig "SUPERVISOR® Documentation: Configurazioni Supportate"
@next SysConfig
                         @{B}CONFIGURAZIONI SUPPORTATE@{UB}

 SUPERVISOR  puo'  virtualmente funzionare su di una macchina versione base
con  256k  di RAM, tuttavia in questo modo i risultati ottenibili sarebbero
pressoche' nulli, poiche' non ci sarebbe sufficiente memoria per coesistere
con altri programmi.  La configurazione ottimale e' la seguente:

- @{I}Computer:@{UI} qualsiasi modello Amiga.
- @{I}Sistema Operativo:@{UI} 1.2-3.1 (supportati e testati), e futuri
- @{I}CPU:@{UI} 68000-68060.   SV  e'  in  grado  di  avvantaggiarsi e di gestire le
  potenzialita'  offerte dal processore montato sulla macchina su cui gira.
  L'  aumento  di  prestazioni  anche  con un semplice 68010 rispetto ad un
  68000 e' veramente notevole!
  Il  funzionamento  sotto  68060  non e' garantito al 100%, poiche' non ho
  avuto   la   possibilita'  di  provarlo  su  macchine  dotate  di  questo
  processore.
- @{I}FPU:@{UI} 68881/2 (riconosciute ma non utilizzate).
- @{I}MMU:@{UI} in  questa versione l' unica MMU supportata e' quella del 68040.  L'
  unico   impiego   e'   attualmente   quello   di  garantire  una  maggior
  compatibilita'  in  sistemi con memoria virtuale (sebbene io sconsigli l'
  utilizzo  di  SV  in  presenza  di  essa)  o  con programmi di debug come
  Enforcer.   La  procedura  di  @{"configurazione" link SVInstaller.guide/Main} tramite il gadget @{"Use MMU40" link SVInstaller.guide/Misc 93}
  permette di selezionare se agire su di essa o ignorarla.  Le azioni su di
  essa   consistono   nella  disabilitazione  delle  eventuali  tabelle  di
  conversione  e  nella reimpostazione delle caches durante l' utilizzo del
  monitor.    Allo   scongelamento  del  programma  tutte  le  impostazioni
  originali  vengono ovviamente ripristinate.  Un inconveniente di cio' sta
  nel  fatto  che  programmi  e  dati residenti in indirizzi rimappati (es:
  kickstart @{I}fastrom,@{UI} memoria virtuale) vengono visti con il @{"monitor" link Monitor} al loro
  indirizzo fisico effettivo.
- @{I}Chip Grafici@{UI}: Normale,  ECS,  AGA.   SV  supporta  e si avvantaggia delle
  caratteristiche  presenti  sui  vari  chip custom.  Con il chipset AGA la
  tabella dei colori viene ripristinata automaticamente.
- @{I}Memoria:@{UI} almeno  1Mb  consigliato  (chip o fast, sebbene sussistano delle
  lievi  differenze  di  funzionamento a seconda del tipo di memoria in cui
  viene   installato  il  programma).   La  massima  quantita'  di  memoria
  chip(graphics  mem)/fast  utilizzabile dipende solo dalle possibilita' di
  indirizzamento offerte dal chip AGNUS/ALICE(per la CHIP) e dalla CPU.
  **NOTA:  Per effettuare una installazione residente decente occorre avere
  almeno 512k di memoria LOCALE, oppure 1Mb di memoria CHIP.
- @{I}Drives:@{UI} da  1 a 4 unita' da 3"1/2,DD(/HD:il supporto per l' alta densita'
  non e' completo, come non lo e' ancora il D-DOS).
- @{I}Utente:@{UI}   le prestazioni ottenibili da questo programma sono direttamente
  proporzionali  al  grado  di conoscenza della macchina da parte di chi lo
  usa, per cui chi non va oltre a 'ed s:startup-sequence' sta solo perdendo
  il suo tempo leggendo questo file!
@endnode

@node Freezer "SUPERVISOR® Documentation: Freezer"
@prev Freezer
                                @{B}IL FREEZER@{UB}

  L'  ingresso  in  ambiente  SUPERVISOR  avviene tramite il @{U}freezer.@{UU}  Esso
permette  di  @{I}congelare @{UI} il programma in esecuzione.  Tramite il @{U}monitor@{UU} si
avra'  il  completo  controllo  su  di  esso.   Cio'  avverra'  in  maniera
assolutamente  @{I}trasparente@{UI}:   all'  uscita  dal  @{"monitor" link Monitor},  tutti i registri
vengono   ripristinati   ricreando   l'   ambiente   esistente   prima  del
congelamento, ed infine viene riavviato (@{I}scongelato@{UI}) il programma, il quale
riprende a funzionare come se nulla fosse accaduto.
  Il   freezer  puo'  essere  attivato  in  una  grande  varieta'  di  modi
configurabili dall'utente:
 1- @{I}richiesta  utente @{UI}(pressione dei pulsanti di mouse & joystick/pressione
    tasto definito dall' utente)
 2- @{I}reset @{UI}
 3- @{I}caricamento del bootblock @{UI}
 4- @{I}break-point @{UI}
 5- @{I}eccezione @{UI}CPU/FPU/MMU
 6- @{I}trace @{UI}
 7- @{I}chiamata programma utente @{UI}
 8- @{I}level 7 @{UI}
 9- @{I}Chiamata al debugger di sistema@{UI} (RomWack/SAD)
10- @{I}Guru Meditation @{UI}
11- @{I}Installer/BOOT@{UI}
12- @{I}Installer/DEBUG@{UI}
13- @{I}Installer/FREEZE@{UI}

@{U}Mouse&Joy/UserDefinedKey freeze@{UU}:
  Per  questa funzione possono venir utilizzati gli interrupt dal livello 1
al 6.  Per i livelli 1-5 l' handler utilizzato viene 'attaccato' al gestore
preesistente, per cui ad ogni interrupt SV controlla se vi e' una richiesta
di  congelamento  da  parte  dell'  utente:   in  caso  positivo congela il
programma  in  esecuzione, in caso negativo ripassa il controllo al gestore
originario  dell' interrupt in questione.  Il livello 6, a meno che non sia
attivata  la funzione @{"transparent int" link ComTansp} invece non viene condiviso con nessun
altro, e la sua attivazione viene forzata periodicamente tramite il timer B
del  circuito  CIAb.   Se  @{"transparent int" link ComTansp}  e'  attivo  il  livello 6 viene
trattato   esattamente  come  gli  altri.   L'  utente  puo'  scegliere  se
richiedere  il  congelamento  tramite  la pressione contemporanea del tasto
sinistro  del mouse e del pulsante del joystick, oppure con la pressione di
un tasto prescelto sulla tastiera.

@{U}Reset freeze@{UU}:
  SV puo' essere reso residente ed attivarsi automaticamente ad ogni reset.
Questa funzione viene effettuata tramite i vettori KickMemPtr e KickTagPtr.
  SV e' in grado di concatenarsi ad eventuali altri moduli residenti, senza
rimuoverli.   Si  ha  cosi'  ad  esempio  la  possibilita' di utilizzare il
s.o.2.0 con ZKick e SV contemporaneamente!
  Sotto  i  sistemi  operativi antecedenti al 2.0 i programmi resistenti al
reset  non  vi  sopravvivono  in  presenza  di piu' di 512k di memoria chip
poiche'  in questi casi il S.O.  ripulisce il contenuto di tutta la memoria
interna  considerando  il  fatto  una  condizione di malfunzionamento della
macchina.  SV elimina automaticamente questo problema.
 Vedere anche la documentazione riguardante l'@{"installazione" link SVInstaller.guide/main} del programma.

@{U}BootBlock freeze@{UU}:
  Viene  modificata  la  funzione  Exec/DoIO  in  modo da intercettare ogni
accesso al boot block.
  Notare  che  rendendo SV residente e/o utilizzando il ResetFreeze vengono
modificati  vettori  spesso  utilizzati  anche  dai virus, per cui anche SV
viene  segnalato  da un VirusDetector come un virus.  A questo punto non e'
piu'  possibile  stabilire  se sia effettivamente presente un virus oltre a
SV.   La  cosa migliore da fare e' dunque quella di effettuare un controllo
antivirus PRIMA dell' installazione del programma!

@{U}BreakPoint@{UU}:
  SV  puo'  venire  attivato  ogni  qualvolta  la CPU tenti di eseguire un'
istruzione  ad una locazione su cui sia stato precedentemente installato un
Break-Point.   Il Break-Point puo' anche essere di tipo @{I}condizionale,@{UI} ossia
fa  attivare  il freezer solo quando vengono verificate tutte le condizioni
imposte  dall'  utente  (ad  esempio  quando  un  certo  registro assume un
determinato  valore),  oppure  a  @{I}contatore,@{UI}  cioe' scatta solo dopo che l'
istruzione  su  cui e' piazzato e' stata eseguita un prestabilito numero di
volte.

@{U}Exception@{UU}:
  Possono  essere  intercettate  tutte  le  eccezioni  del 680x0 e dei suoi
coprocessori nel campo dei vettori da 2 a 63.

@{U}Trace@{UU}:
  Un programma puo' venir monitorizzato passo per passo tramite la funzione
di  trace  del  680x0.   Notare  che  SV puo' sfruttare questa modalita' in
svariati modi.  Vedere la sezione riguardante i comandi di @{"tracciamento" link ComT}.

@{U}UserCall@{UU}:
  SV fornisce l' indirizzo della routine di autofreeze in modo che l'utente
possa chiamare il freezer dal proprio programma.
  SV   inoltre   dispone   di   @{"funzioni avanzate" link Adv}   che  ne  permettono  la
gestione/espansione/automatizzazione/...  da parte di altri programmi.

@{U}Level 7@{UU}:
  Gli  interrupt  di  livello  7(NMI)  non  vengono  gestiti dall' hardware
interno  di  AMIGA;  l'utente  puo'  dunque,  tramite  circuiteria esterna,
generarli autonomamente per servirsene per i propri scopi.
 Per  questo motivo il vettore INT7(VBR+$7c) non viene quasi mai utilizzato
dai   programmi   (tranne   qualche  rara  eccezione),  e  resta  libero  a
disposizione di SV.  Tramite level 7, SV e' in pratica richiamabile in ogni
momento,  anche in caso di crash del sistema (purche' ovviamente il vettore
non sia stato alterato, il processore non sia bloccato e la zona di memoria
in cui risiede SV non sia stata distrutta!).

@{U}Debug()@{UU}:
  SV  puo'  sostituirsi  al debugger di sistema RomWack o SAD.  Caricate il
Workbench con @{I}LoadWB -debug @{UI}e provate il menu 'segreto'.

@{U}GURU()@{UU}:
  I  GURU  MEDITATION  possono venir intercettati prima della loro comparsa
rendendo SV residente con adeguata priorita' e abilitando il @{I}Reset freeze@{UI}.

@{U}Installer@{UU}:
  La  procedura  di installazione (contenuta nell' eseguibile 'mon') quando
SUPERVISOR  risulta  gia'  installato  in  memoria mette a disposizione un'
interfaccia  per  interagire con il sistema.  Questa e' costituita dal menu
utility e da alcuni parametri CLI, tra cui:
BOOT	:simula  il  boot  dal  drive  specificato  ed attiva il monitor al
	 momento dell' esecuzione;
DEBUG	:effettua il debug di un eseguibile;
FREEZE	:invoca il freezer.
  (Questi  argomenti sono trattati in maniera piu' approfondita nel manuale
della procedura di @{"installazione" link SVInstaller.guide/main}).
@endnode

@node Monitor "SUPERVISOR® Documentation: Monitor"
                                @{B}IL MONITOR@{UB}

  Una  volta effettuato il @{I}congelamento @{UI}l' utente si trovera' d' innanzi ad
un potente Monitor dal quale potra' manipolare il programma congelato.

	@{B}Approfondiamo l' argomento@{UB}:
	@{" Interfaccia utente " link Interface}
	@{" Comandi            " link Commands}
	@{" Variabili          " link VARS}
	@{" Numeri             " link Eval}
	@{" Stringhe           " link Strings}
	@{" Macro              " link Macros}
	@{" Consigli ed Esempi " link Tutorial}
@endnode

@node Source "SUPERVISOR® Documentation: Source Debugger"
                              @{U}@{B}Source Debugger@{UB}@{UU}

  Dalla  versione  1.28 SUPERVISOR permette anche il debugging a livello di
sorgente.  Per utilizzarlo occorre caricare un eseguibile con l' opzione da
linea  di  comando dell' installer.  Il file deve contenere informazioni di
debug  del  tipo  @{B}LINE@{UB}  o  @{B}HCLN@{UB}  (generati  dai piu' popolari compilatori e
assemblatori); nel caso in cui non siano presenti informazioni sul percorso
completo  dei  sorgenti,  questi  ultimi  debbono  trovarsi nella directory
corrente.   Non  esistono  limitazioni  (a  parte la memoria) sul numero di
sorgenti  che  possono  essere  caricati  per  uno  stesso eseguibile.  (Un
eseguibile  puo'  essere  costituito da diversi moduli generati da sorgenti
separati.)

  La  finestra  in  cui  viene mostrato il codice sorgente e' alternativa a
quella  del  monitor.   Si  puo'  passare  dall'  una all' altra tramite la
combinazione di tasti SHIFT-ESC.
  I tasti di controllo sono:

tasti cursore:	permettono  di  muoversi  attraverso  il sorgente; shiftati
		producono movimenti piu' ampi.
     HOME o T:	posiziona all' inizio del testo.
      END o B:	posiziona al termine del testo.
      SHIFT-B:	setta/rimuove  un breakpoint all' istruzione corrispondente
		alla prima linea di sorgente visualizzata nella pagina.
	    S:	passa al successivo sorgente.
	    L:	salta alla linea corrispondente al codice mostrato nel RTM.
      SHIFT-L:	salta alla posizione corrispondente al PC.
	0...9:	salta ad una delle posizioni precedentemente memorizzate.
    SHIFT-0-9:	salva  la  posizione corrente in una delle 10 memorie; ogni
		sorgente ha 10 memorie indipendenti.
@endnode

@node RTM "SUPERVISOR® Documentation: Real Time Monitor"
@next RTM
                             @{U}@{B}Real Time Monitor@{UB}@{UU}

  Il  Real  Time  Monitor  (RTM)  e'  una  finestra in cui vengono mostrati
registri  o  zone  di  memoria  in  vari  formati  in  tempo  reale:   ogni
cambiamento ai dati in essa visualizzati viene mostrato immediatamente.
  Le  due  finestre  in  cui risulta diviso lo schermo quando RTM e' attivo
sono  indipendenti  l'  una  dall' altra, per quanto riguarda l' input e l'
output,  ma  interagiscono  per  altri  aspetti.   I  comandi a RTM vengono
normalmente  impartiti  tramite  la  combinazione  del  tasto ALT con altri
tasti.   Cio'  non  provoca  alcun  effetto  sulla finestra del @{"monitor" link Monitor}, ma
provoca  cambiamenti  all'  interno  dell' altra.  La finestra del RTM puo'
venir   ingrandita,   rimpicciolita   o  disattivata.   Cio'  puo'  coprire
parzialmente  l' altra, ma ne lascia intatti i contenuti, i quali sono resi
nuovamente disponibili non appena non risultano piu' coperti dal RTM.
  Tuttavia,  agendo con il @{"monitor" link Monitor}, zone di memoria e/o registri utilizzati
anche  dal  RTM si provocano cambiamenti da entrambe le parti; i comandi di
controllo  programma  del RTM agiscono anche sulla finestra del @{"monitor" link Monitor}; il
settaggio del RTM si effettua tramite @{"monitor" link Monitor}.

@{U}Struttura della finestra del RTM@{UU}:
  La  finestra  e'  costituita da un numero variabile di linee contenenti i
valori  di  registri o di locazioni di memoria in varie forme @{I}(disassembly,
esadecimale,  ASCII, bitmap)@{UI}.  Ciascuna di esse puo' essere bloccata su un'
espressione  indicata dall' utente, o pilotabile da tastiera.  Il contenuto
di  un  gruppo  di  linee 'pilotabili' puo' essere fatto scorrere, variato,
utilizzato  per  settare BreakPoint, e possono essere intraprese su di esso
una  gran  varieta' di azioni.  Un' altro modo per controllare l' indirizzo
della zona visualizzata e' tramite la @{"variabile" link VARS} @{U}rtm@{UU} @{I}(view-address)@{UI}.

@{U}Tasti di controllo@{UU}:
ALT+`			:cambia vista(successiva:dsm->hex->ascii->bitmap->)
ALT+0-9			:salta alla memoria 0-9
ALT+-			:salta all' automark
ALT+freccia su		:linea precendente
ALT+freccia giu'	:linea successiva
ALT+freccia sinistra	:preleva  l'  ultimo  indirizzo  dello  stackrtm  e
			^visualizza a partire da esso
ALT+freccia destra	:memorizza l' indirizzo corrente  nello  stackrtm e
			^salta   al   primo   indirizzo   effettivo   dell'
			^istruzione corrente (disassembly-view only) o all'
			^indirizzo  contenuto  nelle  prime  due word dell'
			^hex-view
ALT+D			:scambia il contenuto delle @{"variabili" link VARS} @{U}DC@{UU} e @{U}RTM@{UU}
ALT+Q			:ritorna all' indirizzo base
ALT+B			:setta/rimuove  un breakpoint alla prima istruzione
			^in alto (dsm-view only)
ALT+,			:decrementa di 2 il view-address
ALT+.			:incrementa di 2 il view-address
ALT+W			:visualizza   il   primo  risultato  ed  azzera  il
			^contatore di risultato
ALT+E			:pone   il  contatore  di  risultato  sull'  ultimo
			^risultato e lo visualizza
ALT+A			:decrementa  il contatore di risultato e visualizza
			^il risultato da esso indicato
ALT+S			:incrementa  il contatore di risultato e visualizza
			^il risultato da esso indicato
ALT+T			:esegue la successiva istruzione; le subroutine non
			^vengono tracciate
ALT+V			:commuta  tra  smartview  e  normalview:   la prima
			^quando si riaggancia all' indirizzo base, ricentra
			^la  visuale  solo se esso non e' gia' visibile nel
			^display  corrente; la seconda riaggancia sempre l'
			^indirizzo base alla prima linea del display
ALT+Y			:traccia  il  cambiamento  di  flusso del programma
			^(68020+)
ALT+Z			:esegue una singola istruzione
ALT+R			:riprende l' esecuzione del programma congelato
ALT+U			:incrementa il PC sino alla successiva istruzione
ALT+N			:decrementa il modulo modulo (bitmap-view only)
ALT+M			:incrementa il modulo modulo (bitmap-view only)
ALT+P			:attiva/disattiva il @{"MemoryManager" link MemManager}
ALT+L			:attiva/disattiva  il  salto  automatico  al  primo
			^risultato  trovato.   Se  attivo la barra di stato
			^del RTM mostra la lettera @{I}R.@{UI}
ALT+J			:(@{"PC-tracer" link ComTracePC})salta    alla    precedente  differenza
			^riscontrata tra le ultime due mappe PC in memoria
ALT+K			:(@{"PC-tracer" link ComTracePC})salta successiva differenza riscontrata
			^tra le ultime due mappe PC in memoria
ALT+SHIFT+0-9		:salta alla memoria 0-9
ALT+SHIFT+frecciasu	:pagina precedente
ALT+SHIFT+frecciagiu'	:pagina successiva
ALT+SHIFT+frecciasinis.	:salta al primo indirizzo dello stackrtm
ALT+SHIFT+frecciadestra	:memorizza l' indirizzo corrente  nello  stackrtm e
			^salta   al  secondo  indirizzo   effettivo   dell'
			^istruzione corrente (disassembly-view only)
ALT+SHIFT+Z		:rimuove tutti i breakpoint
ALT+SHIFT+X		:(dsm-view only)mette un istruzione @{I}NOP @{UI}al posto di
			^quella    che   si   trova   sulla   prima   linea
			^visualizzata.   La word di memoria prima di essere
			^alterata   viene   preventivamente  copiata  nella
			^@{"variabile" link VARS}  @{U}NOPBAK@{UU}.   L'  istruzione  @{I}NOP @{UI} e'  gia'
			^presente, la rimpiazza con il contenuto di @{U}NOPBAK@{UU}.
ALT+SHIFT+B		:salta  all'  indirizzo  BCPL contenuto nelle prime
			^due word visualizzate nell' hex-view
ALT+SHIFT+,		:svuota lo stackrtm
ALT+SHIFT+.		:rimuove l' ultimo indirizzo dallo stackrtm
ALT+SHIFT+M		:azzera il modulo (bitmap-view only)
ALT+SHIFT+`		:cambia vista(precedente:dsm->bitmap->ascii->hex->)
ALT+SHIFT+D		:salta all' indirizzo contenuto nella @{"variabile" link VARS} @{U}DC@{UU}
ALT+SHIFT+Q		:ritorna all' indirizzo base e reimposta la visuale
			^di default (in base alla @{"variabile" link VARS} @{U}rtmdefmode@{UU}).
ALT+SHIFT+U		:imposta  il  tipo  di  aggiornamento del contenuto
			^della  finestra  del  RTM:  sempre (in questo caso
			^viene  visualizzata  la  lettera  @{I}U @{UI}nella barra di
			^stato del RTM), o solo quando necessario
ALT+SHIFT+F		:ricerca tutti i riferimenti relativi all'indirizzo
			^corrente
ALT+SHIFT+K		:(@{"PC-tracer" link ComTracePC})rimuove   le   mappe  PC  eventualmente
			^presenti in memoria
ALT+SHIFT+T		:Effettua  il  tracciamento del PC.  La prima volta
			^che  viene  utilizzato inizializza una nuova mappa
			^relativa all' indirizzo correntemente visualizzato
			^nella  finestra  RTM;  le  volte  successive viene
			^creata   la   mappa  di  confronto  rispetto  alla
			^precedente.     Vedi    @{"PC-tracer" link ComTracePC}   per   maggiori
			^informazioni
@endnode

@node MemManager "SUPERVISOR® Documentation: Memory Manager"
                              @{U}@{B}Memory Manager@{UB}@{UU}

  Il  Memory  Manager  e'  un  gestore  per la lettura e la scrittura della
memoria,  che consente di evitare crash dovuti ad accessi illegali, nonche'
una  piu'  agevole  l'  esplorazione  del sistema, grazie alla capacita' di
conversione  di  indirizzi, che rende trasparente l' accesso a quei blocchi
di  memoria (es:  l' area per il DMA video) che vengono spostati durante l'
utilizzo del monitor.

Caratteristiche principali:
o Puo'  essere (dis)attivato in qualsiasi momento.  I buffer utilizzati dal
  MM sono automaticamente deallocati quando non e' in funzione.  Il monitor
  e'  in  grado  di funzionare senza problemi anche in assenza di esso, per
  cui in caso di memoria insufficiente il MM non e' inizializzato, ma SV e'
  utilizzabile ugualmente.
o Gestisce  banchi RAM, ROM, soft Kickstart e rimappatura di indirizzi.  La
  lettura  di  aree  di  memoria  inesistenti  ritorna  0  come valore.  La
  scrittura  avviene  solo  su  aree  alterabili  (RAM).   Gli  accessi  ad
  indirizzi virtuali avvengono convertendo l' indirizzo logico in indirizzo
  fisico e prelevando/scrivendo il dato da/su quest' ultimo.
o Per  velocizzare la procedura il MemoryManager alloca una tabella di 4096
  bytes piu' strutture di 18 byte per ogni blocco di memoria mappato.  Ogni
  blocco maggiore di 512k viene scomposto in pagine <= 512k.
o Al  momento  dell' installazione SV si crea una mappa di tutta la memoria
  RAM,  della  ROM  e dell' eventuale zona in cui sia caricato un kickstart
  software;  quest'  area,  se  presente,  viene marcata come ROM.  In piu'
  aggiunge,  i  blocchi  configurati  dall'  utente  (massimo 2), e rimappa
  alcune  zone  di memoria in modo che possano venir individuate in maniera
  trasparente  ai loro indirizzi originari.  Cio' avviene ad esempio per l'
  area utilizzata dal display del monitor.

 Attualmente il Memory Manager e' supportato da:
- @{"RealTimeMonitor" link RTM} (100%)
- Monitor: @{"D" link ComD}, @{"Q" link ComQ}, @{"L" link ComL} (editing incluso)
	   @{"FM" link ComFM}.
@endnode

@node Interface "SUPERVISOR® Documentation: Monitor/Interfaccia utente"
@prev Interface
@next Commands
                            @{B}INTERFACCIA UTENTE@{UB}

  L'  @{U}interfaccia utente@{UU} e' il mezzo che permette all' utente di comunicare
con  il  @{"monitor" link Monitor}  e  viceversa.  In @{B}SUPERVISOR@{UB} viene chiamata @{U}console@{UU} ed e'
costituita  da  un  organo  di  @{I}input@{UI},  la @{"tastiera" link Keyboard}, e da uno di @{I}output@{UI}, il
@{"video" link Video}.

@{U}Note sul funzionamento della Console@{UU}:
  Tutto  cio' che si trova sul video non viene in alcun modo elaborato fino
alla pressione di un tasto di immissione.
  Facendo scorrere  una pagina verso l' alto o verso il basso si provoca la
perdita  IRREVERSIBILE dei caratteri posti sulla prima o sull'ultima linea,
per far posto all' ingresso di una nuova linea.
  Il  passaggio  da  una  pagina ad un altra NON provoca alcuna perdita del
testo in essa contenuto.
  Solo   in   seguito  alla  pressione  di  uno  dei  tasti  di  immissione
(RETURN,ENTER,...)  la  linea su cui si trova il cursore viene esaminata ed
elaborata.   Se  abilitata  la  CommandLineHistory,  la  linea  viene anche
mantenuta in un buffer di memoria per un eventuale riutilizzo futuro.
  E'  possibile  effettuare  modifiche direttamente sull'output prodotto da
molti comandi!
  C'e'  inoltre  una  speciale  funzione, BACKRETURN, supportata da tutti i
comandi di editing, che permette l' editing anche verso l' alto.
@endnode

@node Keyboard "SUPERVISOR® Documentation: Monitor/Interfaccia utente/Tastiera"
@prev Keyboard
@next Video
@{B}@{U}TASTIERA@{UU}@{UB}:

  Le  @{"routine" link KeybInfo}  per  la  gestione della tastiera sono state sviluppate molto
accuratamente,  con prestazioni risultanti che non hanno nulla da invidiare
a  quelle  di  un  sofisticato  sistema  operativo.  Tutto cio' sembra cosa
piuttosto  banale,  tuttavia la maggioranza dei programmi che gestiscono la
tastiera  senza  l' intervento del sistema operativo sono dotati di pessime
routine  piene  di  bug, senza contare che spesso i cicli di ritardo per l'
handshaking  con  il  controller  della tastiera vengono effettuati tramite
CPU.   Cio'  puo'  creare  problemi con i processori piu' veloci!

  SV dispone internamente di una mappa della tastiera predefinita, tuttavia
l'  utente  ha  la possibilita' di @{"sostituirla" link SVInstaller.guide/Input} con una qualsiasi tra quelle
disponibili sul disco di sistema o di usarne una @{"personalizzata" link SVInstaller.guide/CustomKeymap}.
  Per  informazioni  dettagliate  sull'  argomento vedere la documentazione
sull' @{"installazione" link SVInstaller.guide/main}.
  Quello  che  segue  e' uno schema che elenca le principali funzioni della
tastiera, in base alla mappa di default.

- @{I}I tasti alfanumerici, e di punteggiatura @{UI}sono mappati come nella tastiera
  USA (QWERTY).  Sono comunque supportati anche i tasti aggiuntivi presenti
  nelle tastiere europee (il tasto a destra dello shift sinistro e il tasto
  a sinistra di RETURN).

- @{I}I  tasti  cursore @{UI} (le frecce)  permettono il movimento del cursore sullo
  schermo.   Provando  a  muovere  il  cursore  oltre il limite superiore o
  inferiore  dello schermo si provoca uno scorrimento della pagina verso l'
  alto o verso il basso.

- @{I}Il tasto TAB (SHIFT+TAB) @{UI}  fa   spostare   il   cursore   al   successivo
  (precedente)  punto  di  tabulazione.   La  distanza  di  tabulazione  e'
  definibile dall' utente; il default e' di 8 caratteri.

- @{I}I tasti RETURN ed ENTER @{UI}eleborano la linea corrente.

- @{I}Tasti Funzione @{UI} sono  utilizzati per visualizzare @{U}stringhe@{UU} definite dall'
  utente,  @{U}macro@{UU},  e  @{U}funzioni speciali@{UU}  (denominate  in  questo  documento
  @{U}funzioni interne@{UU}).
  ** Nella   versione   @{"dimostrativa" link Notice}  stringhe  utente  e  macro  non  sono
  disponibili.  L' unico cambiamento attuabile dall' utente e' la posizione
  delle  funzioni  interne  tramite  l'  uso  di  una  mappa della tastiera
  personalizzata.   Nella  versione  registrata,  invece,  i  tasti possono
  essere definiti tramite il comando @{"#U" link ComEdFK}
  Segue una tabella delle funzioni interne abbinate ai tasti funzione:
    F1= (se  attiva  la  cmdline  history) mostra il comando precedente.
    F2= (se  attiva  la  cmdline  history) mostra il comando successivo.
    F7= scambia la pagina attuale con quella precedentemente memorizzata.
    F8= attiva/disattiva il RealTimeMonitor.
    F9= attiva/disattiva la barra informazioni.
   F10= attiva la pagina successiva.
   SHIFT+F1= (se attiva la cmdline history) cerca una stringa che inizi per
	     la  stessa  sequenza di caratteri compresa tra l' inizio della
	     linea corrente e la posizione del cursore.
   SHIFT+F2= (se attiva la cmdline history) va in fondo al buffer.
   SHIFT+F3= (se attiva la cmdline history) riesegue l' ultimo comando.
   SHIFT+F9= disattiva la linea d' informazione e libera la memoria da essa
	     utilizzata (circa 100 bytes).
   SHIFT+F10= Seleziona  il  timer  visualizzato  sulla barra informazioni:
	      tempo  parziale (indica il tempo trascorso dall' inizio dell'
	      ultimo  congelamento  effettuato),  o tempo totale (indica il
	      tempo totale trascorso in ambiente SV).

- @{I}Il  tasto  ConTRoL@{UI}  ha  la  duplice funzione di tasto di STOP (se premuto
  insieme  al  tasto  @{I}SHIFT@{UI}),  per  interrompere  l'  esecuzione  di alcuni
  comandi, e di controllo da usarsi in unione ad altri tasti:
   ^I= TAB
   ^U,^cursore  sini.= cancella  i caratteri a sinista del cusore fino all'
		       inizio della linea in cui si trova.
   ^K,cursore  destro= cancella  i caratteri a destra del cursore fino alla
		       fine della linea in cui si trova.
   ^X= cancella la linea in cui si trova il cursore.
   ^Q= cancella tutti  i  caratteri dalla posizione del cursore all' inizio
       della pagina.
   ^W= cancella  tutti  i  caratteri  dalla posizione del cursore alla fine
       della pagina.
   ^A= posiziona il cursore all' inizio della linea in cui si trova.
   ^Z= posiziona il cursore alla fine della linea in cui si trova.
   ^HELP= rinfresca lo schermo
   ^J= LINE FEED+CR
   ^M= RETURN
   ^H= HOME
   ^Y= toggle INSERT (cambia tra @{U}inserimento@{UU} e @{U}overwrite@{UU})
   ^RETURN= inserisce  una  nuova  linea nella posizione in cui si trova il
	    cursore.  Il comportamento della funzione e' condizionato dallo
	    stato  dell'  inserimento.  OFF=viene inserita una linea vuota.
	    ON=viene copiata la linea gia' presente.
   ^ESC= inverte   lo   stato   del  tasto  ALT.   (Da  usarsi  se  si  usa
	 prevalentemente  il @{"RTM" link RTM}.  La soluzione migliore e' comunque quella
	 di mappare il @{"RTM" link RTM} sul tastierino.)

- @{I}I tasti SHIFT e CAPS LOCK @{UI}servono per visualizzare i caratteri alfabetici
  in maiuscolo e i caratteri di punteggiatura.

- @{I}Il tasto SHIFT @{UI}ha anche le seguenti funzioni:
   SHIFT+CTRL= interrompe l' esecuzione di un comando.
   SHIFT+ESC= commuta tra @{"monitor" link Monitor} e debugger di @{"sorgente" link Source}.
   SHIFT+frecce su,giu',sin.,des.= spostano il cursore rispettivamente alla
				   prima  e all' ultima linea della pagina,
				   all' inizio  e  alla fine della linea in
				   cui esso si trova.
   SHIFT+frecce tastierino= muovono il cursore.
   SHIFT+BACKSPACE= inserisce uno spazio alla posizione del cursore.
   SHIFT+DEL= inserisce uno spazio alla posizione del cursore.
   SHIFT+HOME= posiziona il cursore all' inizio della pagina.
   SHIFT+END=  posiziona  il  cursore all' inizio  dell'ultima  linea della
	       pagina.
   SHIFT+PaGeUP= posiziona il cursore alla prima linea della pagina.
   SHIFT+PaGeDowN= posiziona il cursore all' ultima linea della pagina.
   SHIFT+HELP= cancella la pagina e porta il cursore all'inizio della prima
	       linea(CLS).
   SHIFT+DEL sul tastierino= DELete.
   SHIFT+INSert= abilita/disabilita il modo di inserimento.
   SHIFT+NUMLock= Commuta  le  funzioni  del  tastierino  (numeri/controllo
		  cursore).
   SHIFT+SCRLock= Blocca/Attiva lo scrolling (Pause).
   SHIFT+/(tastierino)= SmartScrolling on/off.

- Il tasto AMIGA blocca lo scrolling finche' non viene rilasciato.

- @{I}Il tasto ALT @{UI}utilizzato durante lo scrolling lo rallenta in base a quanto
  settato dall' utente (vedi @{"variabile" link VARS} @{U}scroll@{UU}).  Utilizzato in combinazione
  con altri tasti serve a gestire il @{"RealTimeMonitor" link RTM}.

- @{I}Il  tasto  ESC @{UI} (come  la  combinazione @{I}SHIFT+CTRL@{UI}) puo' essere usato per
  interrompere l' esecuzione di un comando.
@endnode

@node CharTab "SUPERVISOR® Documentation: Control Chars Table"
@prev CharTab
@next CharTab
                          @{U}@{B}Codici Speciali di I/O@{UB}@{UU}

  I  codici  speciali  per  le  routine  di  I/O  di  SV differiscono dagli
standard.   Pertanto  per  la  creazione  di  mappe  personalizzate, per la
gestione  di  input  derivanti  da  SV  o  per  l'  invio  di  stringhe  da
visualizzare  sullo  schermo di SV occorre far riferimento alla tabella che
segue:

@{U}Control Chars Table@{UU}:
$00=NULL(no action will be taken)
$01=cursor to start of line
$02=cursor to end of line
$03=pgup
$04=pgdwn
$05=end
$06=clrleft
$07=clrright
$08=clrline
$09=tab
$0A=newline(*ENTER, in input mode)
$0B=home
$0C=cls
$0D=cr
$0E=shifttab
$0F=insert line
$10=cursor left
$11=cursor right
$12=cursor up
$13=cursor down
$14=reverse on
$15=reverse off
$16=backspace
$17=delete
$18=insert on/off
$19=adjust cursor pos: if line is empty move to start of line, else newline
$1A=linefeed
$1B=esc (currently there is no escape sequence defined)
$1C=clear until cursor pos
$1D=clear from cursor pos
$1E=refreshscreen
$1F=insert space
fkeys:$80-$89/shifted=$90-99/CTRLed=$8a-$8f,$9a-$9d
$9E=(rtm)previousview
$9F=(rtm)nextview
$A0-$a9=(rtm)get mark0-9
$AA=(rtm)prevline
$AB=(rtm)nextline
$AC=(rtm)indirectjmp1
$AD=(rtm)pull&jump
$AE=(rtm)resetviewaddress
$AF=(rtm)togglebp
$B0-$B9=(rtm)set mark0-9
$BA=(rtm)pgup
$BB=(rtm)pgdwn
$BC=(rtm)indirectjmp2
$BD=(rtm)jmp to 1st level
$BE=(rtm)address=address-2
$BF=(rtm)address=address+2
$C0=(rtm)jump to res(0).cres=0
$C1=(rtm)jump to res(-1).cres=-1
$C2=(rtm)cres=cres-1,jump to res(cres)
$C3=(rtm)cres=cres+1,jump to res(cres)
$C4=(rtm)togglesmartview
$C5=(rtm)zapallbps
$C6=(rtm)traceinstruction
$C7=(rtm)singlestep
$C8=(rtm)flowtrace
$C9=(rtm)runprogram
$CA=(rtm)skipinstruction
$CB=(rtm)putnop
$CC=(rtm)jmpbcpl
$CD=(rtm)return to 1st level
$CE=(rtm)back to previous level
$CF=(rtm)clear modulo
$D0=(rtm)modulo-2
$D1=(rtm)modulo+2
$D2=(rtm)DoRTS*TODO*
$D3=(rtm)DoJSR*TODO*
$D4=(rtm)toggleMM
$D5=(rtm)exg vars DC<->RTM
$D6=(rtm)togglesmartupdate
$D7=(rtm)move DC->RTM
$D8=(rtm)jump to automark
$D9=(rtm)find all references to current address
$DA=(rtm)toggle AutoResultLock
$F0=backreturn
$F1=clear key buffer
$F2=help
** $20-$7f correspond to the standard ASCII codes. Other codes are reserved.
@endnode

@node RefCard "SUPERVISOR® Documentation: Command Summary"
                              @{U}@{B}Command Summary@{UB}@{UU}

@{U}@{I}Console keys@{UI}@{UU}:
@{I}(Misc)@{UI}
ARROWS			:Move the cursor
HELP			:Show console help-page
BACKSPACE		:Clear previous char
DELETE			:Clear next char
RETURN			:Process line
ENTER			:Process line
SHIFT+LEFTARROW		:Cursor to start of line
SHIFT+RIGHTARROW	:Cursor to end of line
SHIFT+UPARROW		:Cursor to first line
SHIFT+DOWNARROW		:Cursor	to last line
SHIFT+PGUP		:Cursor to first line
SHIFT+PGDN		:Cursor to last line
SHIFT+INS		:Toggle insert on/off
SHIFT+RETURN		:Process line and go back(only when editing)
SHIFT+ENTER		:Cursor to next line
SHIFT+BACKSPACE		:Insert space
SHIFT+DEL		:Insert space
SHIFT+HELP		:Clear screen
CTRL+A			:Cursor to start of line
CTRL+Z			:Cursor to end of line
CTRL+X			:Clear line
CTRL+U			:Delete to BOL
CTRL+K			:Delete to EOL
CTRL+I			:Tab
CTRL+H			:Home
CTRL+J			:Cursor to next line
CTRL+R			:Reverse on
CTRL+O			:Reverse off
CTRL+Q			:Delete to cursor pos
CTRL+W			:Delete from cursor pos
CTRL+F			:(Un)Lock keypadnumbers
CTRL+G			:(Un)Lock scrolling
CTRL+M			:Process line
CTRL+RETURN 		:Insert line
CTRL+DEL		:Clear key buffer
CTRL+HELP		:Refresh screen
CTRL+LEFTARROW		:Delete to BOL
CTRL+RIGHTARROW		:Delete to EOL
CTRL+S			:Smartscrolling on/off
CTRL+P			:Toggle insert on/off
@{I}(FKeys)@{UI}
F1			:Show previous command
F2			:Show next command
F8			:Toggle RTM window
F9			:Toggle info bar (a buffer will be allocated if required)
F10			:Turn page
SHIFT+F1		:Search command
SHIFT+F2		:End of command history
SHIFT+F3		:Repeat last command
SHIFT+F9		:Kill infobar & free its buffer
SHIFT+F10		:Toggle timer
CTRL+F9			:Expand RTM window (+1 line)
CTRL+F10		:Shrink RTM window (-1 line)
@{I}(Keypad)@{UI}
SHIFT+END		:Cursor to bottom left
SHIFT+NUML		:(Un)Lock keypadnumbers
SHIFT+SCRL		:(Un)Lock scrolling
SHIFT+HOME		:Cursor to upper left
SHIFT+DEL		:Clear next char
SHIFT+ARROWS		:Move the cursor
SHIFT+/			:Smartscrolling on/off
@{I}(Special)@{UI}
ESC			:Break command
CTRL+SHIFT		:Break command
CTRL+ALT		:Break command
ALT			:Delay scrolling
AMIGA			:Lock scrolling

@{U}@{I}RTM shortcuts@{UI}@{UU}:
ALT+`			:Next view
ALT+0-9			:Jump to mark 0-9
ALT+-			:Jump to automark
ALT+UPARROW		:Previous line
ALT+DOWNARROW		:Next line
ALT+LEFTARROW		:Pull address & jump to it
ALT+RIGHTARROW		:Push current viewaddress & jump to <ea1>(dsm&hex view only)
ALT+D			:Swap DC <-> RTM vars
ALT+Q			:Reset view address
ALT+B			:Toggle BP
ALT+,			:Sub 2 to viewaddress
ALT+.			:Add 2 to viewaddress
ALT+W			:Go to RES(0).CRES=0
ALT+E			:Go to RES(-1).CRES=-1
ALT+A			:Decrease CRES,jump to RES(CRES)
ALT+S			:Increase CRES,jump to RES(CRES)
ALT+T			:Trace instruction
ALT+V			:Toggle smartview
ALT+Y			:Trace flow
ALT+Z			:Single step
ALT+R			:Run program
ALT+U			:Skip instruction
ALT+N			:Decrease modulo
ALT+M			:Increase modulo
ALT+P			:Toggle @{"MemoryManager" link MemManager} (M)
ALT+L			:Toggle auto-lock on 1st result (R)
ALT+J			:(@{"PC-tracer" link ComTracePC})Find previous PC difference
ALT+K			:(@{"PC-tracer" link ComTracePC})Find next PC difference
ALT+SHIFT+0-9		:Set mark 0-9
ALT+SHIFT+UPARROW	:Previous page
ALT+SHIFT+DOWNARROW	:Next page
ALT+SHIFT+LEFTARROW	:Jump to first level
ALT+SHIFT+RIGHTARROW	:Push current viewaddress & jump to <ea2>(dsm view only)
ALT+SHIFT+D		:Go to DC address
ALT+SHIFT+Q		:Reset view address&mode
ALT+SHIFT+U		:Toggle smart/(U)continuous update
ALT+SHIFT+Z		:Zap all breakpoints
ALT+SHIFT+X		:Toggle NOP
ALT+SHIFT+B		:Jump to BCPL address
ALT+SHIFT+,		:Go to first level
ALT+SHIFT+.		:Go to previous level
ALT+SHIFT+M		:Clear modulo
ALT+SHIFT+`		:Previous view
ALT+SHIFT+F		:Find all references to current viewaddress
ALT+SHIFT+K		:(@{"PC-tracer" link ComTracePC})Kill PC map
ALT+SHIFT+T		:@{"Trace PC" link ComTracePC}

@{U}@{I}Monitor commands@{UI}@{UU}:
@{"!" link ComRest}			:Restart monitor
@{"!!" link ComExit}			:Exit
@{"!B" link ComBootFrz}			:Toggle boot-capture
@{"!C" link ComResTOD}[flag]		:Restore TOD
@{"!D" link ComADI}			:AutoDiskInit on/off
@{"!I" link ComBSync}			:Toggle beam-synced scrolling
@{"!K" link ComKill}			:Hard reset
@{"!L" link ComResScr}			:Restore screen
@{"!M" link ComTask}			:Toggle taskcpt
@{"!N" link ComPALNTSC}			:Toggle PAL/NTSC
@{"!P" link ComSetPri}pri			:Set resident priority
@{"!Q" link ComReset}			:Reboot
@{"!R" link ComResF}			:Toggle reset-freeze
@{"!S" link ComBlt}[flag]		:Use blitter
@{"!T" link ComCache}[I]			:Cache on/off
@{"!V" link ComVBR}[vectortable]		:Set VBR
@{"!W" link ComCapTask}[taskaddress]		:Capture task
@{"!X" link ComRemSV}			:Remove SV from resident tags
@{"!Y" link ComTansp}			:Toggle interrupt transparency
@{"!Z" link ComSetFK}[keycode]		:Set freeze-key
@{"#B" link ComMACB}			:Pause/Continue macro execution	(REGISTERED VERSION)
@{"#E" link ComMACE}			:Toggle echo			(REGISTERED VERSION)
@{"#F" link ComMACF}			:Toggle fkeys			(REGISTERED VERSION)
@{"#I" link ComMACI}			:Macro info			(REGISTERED VERSION)
@{"#L" link ComMACL}[name]		:List macro[s]			(REGISTERED VERSION)
@{"#U" link ComEdFK}[n,string]		:Show/Edit fkeys		(REGISTERED VERSION)
@{"#X" link ComExtCom}[args]		:External command		(REGISTERED VERSION)
@{"%" link ComRKM}			:Show RawKey
@{"&&" link ComFdKey}strt,end,long[,long]	:Find encryption key
@{"&" link ComEnc}st,end,eor,sub[,mode]	:En/De-code memory
@{"(" link ComAlloc}size[,flags]	 	:Alloc memory
@{")" link ComFree}[segment,size] 	:Free memory
@{"*" link ComSaf}[flag] 		:Safety
@{"++" link ComRelB}s,e,mod,rs,re[,xs,xe]	:Relocate binary
@{"+" link ComRelE}start,dest[,relcbase]	:Relocate executable
@{"-" link ComSign}[flag]			:Sign on/off
@{"." link ComBPLst}			:List breakpoints
@{"/" link ComHSWTC}[flag]			:Symbolic copper disassembly on/off
@{"0" link Com0}[base-id]		:Set default base
@{"1" link Com1}			:Config disassembler
@{"2A" link ComGR2A}[start,end]		:AutoGfxSearch
@{"2B" link ComGR2B}copperlist[,end]	:Add PictureData from copperlist (Update grdata)
@{"2C" link ComGR2C}copperlist[,end]	:Fetch PictureData from copperlist (Create grdata)
@{"2I" link ComGR2I}			:GfxRipper info
@{"2K" link ComGR2K}[pic#]		:Kill IFF/GfxRipper data
@{"2L" link ComGR2L}[L]			:Show GfxRipper data
@{"2M" link ComGR2M}[address]		:Generate IFF from current grdata
@{"2N" link ComGR2N}			:Resume AutoGfxSearch
@{"2P" link ComGR2P}			:Preview IFF pic (get size)
@{"2S" link ComGR2S}			:Show current picture
@{"2U" link ComGR2U}			:Get current colormap
@{"2V" link ComGR2V}			:List IFF pics
@{"3" link Com3}			:Config assembler
@{"<" link ComBPA}			:Breakpoints on/off
@{"=" link ComSymInfo}			:Symbol info
@{"=!" link ComZapLabs}			:Zap labels
@{"=$" link ComDefLab}name[,address]	:Define label
@{"=/" link ComSymTab}[matchstring] 	:Symbol table
@{"=[=]" link ComDefSym}name[,value|expr]	:Define symbol
@{">>" link ComCPcfg}			:Show config codes for Patcher
@{">F" link ComFrPMem}[addr]		:Free patchmem
@{">I" link ComIVEC}[s]vec[,endvec]	:Include vector[s]
@{">X" link ComXVEC}[s]vec[,endvec]	:Exclude vector[s]
@{">L" link ComSPL}			:Show vector list
@{">P" link ComLkPMem}			:Lock patcmem
@{">" link ComPCON}[mode]|[C] 		:Set patcher
@{"??" link ComSCflg}[flag]		:Packed calc result on/off
@{"?" link ComCalc}expression		:Calculate expression value
@{"AC" link ComAC}[address]		:Assemble (COPPER)
@{"A" link ComA}[address]		:Assemble (680x0)
@{"B" link ComB2}name[ arguments]	:Do macro			(REGISTERED VERSION)
@{"B" link ComB}\\[address] 		:Calculate bootblock checksum
@{"CM" link ComCM}start1,end1,start2	:Compare memory
@{"CO" link ComCO}start,end,dest	:Copy memory
@{"D" link ComD}[startaddr][,endaddr]	:Disassemle 680x0 code
@{"EC" link ComEC}			:Strobe copper
@{"EE" link ComEE}[n,string]		:Config RealTimeMonitor
@{"EH" link ComCheat}[H]			:Trainer info
@{"EI" link ComCheat}[l][,m][,s,e][,wrkmem]:Init TrainerFinder
@{"EM" link ComEM}			:Toggle MemoryManager
@{"EQ" link ComCheat}			:Free TrainerFinder memory
@{"ER" link ComER}			:Init RealTimeMonitor
@{"ES" link ComCheat}[l]			:Search trainer
@{"EW" link ComEW}[flag]		:MemoryWatcher on/off
@{"FA" link ComFA}[address] 		:Find address
@{"FD" link ComFD}start,end,data	:Find disassembly
@{"FI" link ComFI}start,end[,data]	:Fill memory
@{"FM" link ComFM}s,e,dat[,msk][,fm,lm]	:Find data (MASKABLE)
@{"FR" link ComFR}address[,mode][,limit]:Find relative address
@{"F" link ComF}start,end,data[,H|O]	:Find data (NORMAL|ENCRYPTED)
@{"G" link ComG}[address]		:Go
@{"H" link ComH}[commandlist]		:Help
@{"I" link ComI}			:Environment info
@{"IA" link ComIA}base[,size][,flags]	:AddMem				(REGISTERED VERSION)
@{"IC" link ComIC}			:Trainer info
@{"ID" link ComID}[A]			:Disk info
@{"IF" link ComIF}			:Freezer info
@{"IH!" link ComIH}[name]		:Custom regs info		(REGISTERED VERSION)
@{"IH" link ComIH}[addr]		:Custom regs info		(REGISTERED VERSION)
@{"IK" link ComIK}nodenumber 		:Kill memory
@{"IM" link ComIM}[node#]		:Mem info
@{"IN" link ComIT}tasknumber		:Task info
@{"IR" link ComIR}[*][modulenumber]	:Resident info
@{"IT" link ComIT}[taskname]		:Task info
@{"IV" link ComIV}			:Version info
@{"J" link ComJ}address		:Jump (execute local routine)
@{"K" link ComK}			:Trace over
@{"KN" link ComKN}			:Put NOP
@{"KR" link ComKR}			:Do RTS
@{"KS" link ComKS}			:Skip next instruction
@{"L" link ComL}[startaddr][,endaddr]	:Disassemble copperlist
@{"M" link ComM}[B|W|L]address,value 	:Poke
@{"N!" link ComKillPCMap}			:Kill PC map
@{"N" link ComN}[address]		:Show PC map
@{"OC" link ComRip 49}[moduleaddress]	:Backup mod
@{"OD" link ComRip}[start,end]		:DeepFind mod
@{"OF" link ComRip}[start,end]		:FastFind mod
@{"OI" link ComRip 18}[moduleaddress]	:Module info
@{"OM" link ComOM}strt,end[,per][,vol]	:Hear mem
@{"OP" link ComRip 32}[moduleaddress]	:Play module
@{"OR" link ComRip 24}[moduleaddress]	:Toggle module ID
@{"OS" link ComRip 45}			:Stop/Continue module playing
@{"OX" link ComRip 69}			:Free modbak
@{"P" link ComP}[sspace][,hash][,fast]	:Set symbol memory
@{"Q" link ComQ}[startaddr][,endaddr]	:Hex dump
@{"RS" link ComRS}[dev][,adr][,of][,len]:Read block
@{"S" link ComS}[address][,modulo]	:View memory
@{"T/" link ComTLINK}[mode][,address]	:Link tracer
@{"T:" link ComTracePC}[start][,end]		:PC Trace
@{"T[*]!" link ComT}adrregnumber,value	:Address trace
@{"T[*]%" link ComT}condition		:Conditional trace
@{"T[*]&" link ComT}conditionvarnumber	:Conditional trace
@{"T[*]" link ComT}[steps][,mode] 	:Trace into
@{"UA" link ComUA}[address][,start,end]	:Find changes to address
@{"UB" link ComUB}[address][,start,end]	:Find all references to address
@{"UC" link ComCLF 15}[start,end]		:Find copperlist from cpucode
@{"UD" link ComCLF 24}[start,end]		:Find copperlist from chipmem
@{"UI" link ComCLF 86}startreg[,endreg]	:Include regs in CopperFinder list
@{"UL" link ComCLF 81}			:Show CopperFinder include list
@{"UP" link ComCLF 29}			:Config CopperFinder
@{"UT" link ComCLF}[copperlist][,copcon]	:Test copperlist
@{"UU" link ComCPcfg}			:Show config codes for CopperFinder
@{"UX" link ComCLF 92}startreg[,endreg]	:Exclude regs from CopperFinder list
@{"WS" link ComWS}[dev][,adr][,of][,len]:Write block
@{"X" link ComX}[B|F|R|S]		:Display regs
@{"Y" link ComY}[unit][,mode][,dos]	:Format disk
@{"Z" link ComZ}[!|address[,[attr]cnt]]:Add/Rem breakpoint[s]
@{"]" link ComRAW}[flag] 		:Raw-Key/ASCII mode
@{"`" link ComMoveChip}[address]		:Move chipdat
@{"{" link ComKRest}[flag]			:Keyboard restore on/off

@{U}@{I}FKEYS - Default bindings@{UI}@{UU}:
(0-9:F1-F10, 16-25:SHIFT+F1-F10, 10-15/26-29:CTRL+F1-F10)
<@{I}NORMAL@{UI}>
00-F1=internal(HISTBACK)	+ macro(<empty>)	+ string(<empty>)
01-F2=internal(HISTFORWARD)	+ macro(<empty>)	+ string(<empty>)
02-F3=internal(<empty>)		+ macro(LED)		+ string(<empty>)
03-F4=internal(<empty>)		+ macro(RTMPEEK)	+ string(<empty>)
04-F5=internal(<empty>)		+ macro(CLEANUP)	+ string(<empty>)
05-F6=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
06-F7=internal(SWAPPAGE)	+ macro(<empty>)	+ string(<empty>)
07-F8=internal(TOGGLERTM)	+ macro(<empty>)	+ string(<empty>)
08-F9=internal(TOGGLESTATLINE)	+ macro(<empty>)	+ string(<empty>)
09-F10=internal(TURNPAGE)	+ macro(<empty>)	+ string(<empty>)
<@{I}SHIFT@{UI}>
16-F1=internal(HISTSEARCH)	+ macro(<empty>)	+ string(<empty>)
17-F2=internal(HISTBOTTOM)	+ macro(<empty>)	+ string(<empty>)
18-F3=internal(HISTREPEAT)	+ macro(<empty>)	+ string(<empty>)
19-F4=internal(<empty>)		+ macro(RTMENDPEEK)	+ string(<empty>)
20-F5=internal(<empty>)		+ macro	(SHOWCOP)	+ string(<empty>)
21-F6=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
22-F7=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
23-F8=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
24-F9=internal(REMOVESTATLINE)	+ macro(<empty>)	+ string(<empty>)
25-F10=internal(TOGGLETIMER)	+ macro(<empty>)	+ string(<empty>)
<@{I}CONTROL@{UI}>
10-F1=internal(<empty>)		+ macro(NOBERR)		+ string(<empty>)
11-F2=internal(<empty>)		+ macro(GOBT)		+ string(<empty>)
12-F3=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
13-F4=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
14-F5=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
15-F6=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
26-F7=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
27-F8=internal(<empty>)		+ macro(<empty>)	+ string(<empty>)
28-F9=internal(EXPANDRTM)	+ macro(<empty>)	+ string(<empty>)
29-F10=internal(SHRINKRTM)	+ macro(<empty>)	+ string(<empty>)
-- Each FKEY can have up to 3 types of functions associated:  INTERNALS, --
-- MACROS   and   STRINGS,   with  these  priorities:   STRINGS  (max),  --
-- MACROS (med), INTERNALS (min)					 --
** MACROS and STRINGS are available in REGISTERED VERSION @{U}only @{UU}**

@{U}@{I}Default defines for C? symbols@{UI}@{UU}:
(@{I}used by trace and breakpoint system as condition-terms@{UI})
C0	:pc<$f80000!pc>$ffffff
C1	:(peekb($bfe001)&$80)<$80
C2	:pc=bt
C3	:<empty>
C4	:<empty>
C5	:<empty>
C6	:<empty>
C7	:<empty>
C8	:<empty>
C9	:<empty>

@{U}@{I}Internal macros@{UI}@{UU}: (REGISTERED VERSION: @{B}v1.24r+ required@{UB})
#:AUTOCONFIG
;FKey definitions
;#\\u10,!!\\\\0a
;#\\u11,if\\\\0a
;#\\u12,=/\\\\0a
;#\\u13,dbt\\\\0a
;#\\u14,dpc\\\\0a
;#\\u15,x\\\\0a

#:LED,(3)-1
;toggle filter
mb$bfe001,peekb($bfe001)|2

#:RTMPEEK,(4)-1
\@IF rtmmode=0
pkremember[rtm
rtm[ea1(rtm)
rtmmode[1
=pkremember
\@ENDC

#:RTMENDPEEK,15+(4)
\@IFD pkremember
\@IF rtmmode
rtm[pkremember
rtmmode[0
\@ENDC
\@ENDC

#:GOBT,11
\@IF SYS>>16&2
;use fast trace on 68020+ CPUs
t*&2
\@ELSE
t&2
\@ENDC

#:__BOOT
;wait for BootBlock execution
#C127
; ^FM_BOOT
\@IF BBMODE
\@IF BBMODE=1
t*&2
\@ENDC
\@IF BBMODE=2
pc[bt
\@ENDC
\@IF BBMODE=3
bbbak0[PEEKW(bt)
m(bt),$4afc
b\\\\bt-$c
m(bt),bbbak0
=bbbak0
zbt,r
!!
b\\\\bt-$c
\@ENDC
\@PRINT '<BootBlock ready to run>'
\@ENDC
CLEANUP

#:CLEANUP,(5)-1
;remake the display on each freezer activation
#A
;^match all freeze codes
!L

#:NOBERR,10
;disable BusError on A3000/A4000
m$de0000,$7f7f
\@PRINT 'Bus error OFF'

#:SPLIT
;SPLIT lock1,lock2[,size]
\@IF NARG<2
\@PRINT 'Missing arguments!'
\@PRINT 'Usage:'
\@PRINT 'SPLIT lock1,lock2[,size]'
\@QUIT
\@ENDC
view1[\\1
view2[\\2
\@IF NARG>2
spcnt[\\3
\@ELSE
spcnt[RTMSIZE/2-1
\@ENDC
spsize[spcnt
ER
EE#0,?spsize,view1
spcnt[spcnt+1
EEspcnt-1,t-- View#2 ---
EEspcnt,!view2+rtm-view1
\@lab loop
_spcnt[spcnt+1
_spend[(spsize)*2+1
\@IF spcnt<spend
_EEspcnt,!
\@GOTO loop
\@ENDC
=spend
=spcnt

#:CMP
;CMP start1,end1,start2
\@IF NARG<3
\@PRINT 'Missing arguments!'
\@PRINT 'Usage:'
\@PRINT 'CMP start1,end1,start2'
\@QUIT
\@ENDC
SPLIT \\1,\\3
CM\\1,\\2,\\3
rtm[res(0)

#:SHOWCOP,15+(5)
;SHOWCOP [copperlist]
\@IF NARG
l\\1,COPEND(\\1)+4
\@ELSE
lcop,COPEND(cop)+4
\@ENDC
##

@{U}@{I}Macro Special-Commands@{UI}@{UU}: (REGISTERED VERSION)
## or NULL 		:EndOfMacros
#\\			:replaced with #
#:name[,Func#]		:define macro (macro text follows)
#C[code]		:(inside macro)define macro code(mcm_Link)
#A			:(inside macro)all codes will match this macro
\@ECHO			:(inside macro) toggle echo on/off
\@FNC <n>		:(inside macro) execute internal function 'n'
\@IF <expr>		:start conditional if result>0
\@IFD <symbol>		:start conditional if <symbol> exists
\@ELSE			:execute if <expr> is false
\@ENDC			:end of conditional
\@PRINT <"txt"|expr>[,N]	:print text/decvalue. N=noline
\@HPRINT <"txt"|expr>[,N]:print text/hexvalue. N=noline
\@GOTO <label>		:go to <label>
\@LAB <label>		:<label> for @GOTO command
\@QUIT			;exit from macro
\\n			:replace with arg 'n' (it may be anywhere on the line)(1<=n<=9)
\\\\			:replaced with \\
;			:Remark (line is not executed)
* lines with '#' are processed on first pass (init-macros preparsing)
* '@' commands are processed on each macro execution
* #, @ and ; commands must be at beginning of a line
* \\n args can't be on macro-command lines!(the lines beginning with @)
@endnode

@node KeybInfo "SUPERVISOR® Documentation: Monitor/Interfaccia utente/Keyboard Handler"
@prev KeybInfo
@next KeybInfo
@{B}@{U}Caratteristiche Tecniche@{UU}@{UB}:
  Il  driver  della  tastiera utilizza i due timer e gli interrupt generati
dal circuito CIAA (livello 2) per effettuare le sue operazioni.
-  Gestisce  il Reset Warning:  nelle tastiere che lo supportano (in genere
   su  Amiga  1000/2000/3000/1200/4000),  quando  l' utente schiaccia i tre
   tasti  di  reset,  il  controller  invia un codice di Reset Warning, per
   avvisare  il  programma  che sta girando in quel momento che la macchina
   sta  per  resettarsi.   Il software puo' rispondere ad esso chiedendogli
   una  proroga  fino  a  10 secondi per concludere le operazioni in corso.
   Dunque  nelle  tastiere  in  cui e' supportato il reset warning, qualora
   l'utente  provi  a  resettare  la  macchina, SV  segnalera' loro di aver
   ricevuto  il messaggio, dopodiche' si mettera' in attesa per 10 secondi.
   Qualora  si volesse anticipare il reset bastera' premere il pulsante del
   joystick.   Durante  questi 10 secondi di tempo tutte le attivita' della
   macchina possono continuare normalmente, eccetto l'input dalla tastiera,
   dal  momento  che  il suo processore avra cessato la scansione dei tasti
   per aspettare il momento in cui dovra' effettuare la procedura di reset.

-  Supporta  la  ripetizione  dei tasti e ritardo pre-ripetizione, entrambi
   configurabili dall'utente.

-  Utilizza  un buffer di 64 byte per memorizzare i caratteri in attesa che
   vengano prelevati dal programma principale.  Questo significa che nessun
   tasto  premuto  viene  perso, neanche se in quel momento il programma si
   sta occupando di altre cose.

-  Gestisce  i  tasti  CTRL,CAPSLOCK,SHIFTl/r,AMIGAl/r,ALTl/r/NumLOCK, come
   tasti  speciali  per  la  selezione della mappa della tastiera.  I tasti
   ALTernati possono essere scambiati con quelli non alternati.

-  Dispone  di  un  handler ausiliario di livello 3.  Alcuni dispositivi di
   espansione (es:  i controller di HardDisk) generano interrupt di livello
   2  autonomi, non mascherabili singolarmente tramite INTENA.  SV non puo'
   (ne'  deve)  servirsi dell' interrupt di livello 2 quando c' e' gia' una
   richiesta  esterna  attiva  su  di  esso.   Quando  SV rileva una simile
   situazione,  trasferisce  la  gestione  della tastiera all' interrupt di
   livello  3  e ne informa l' utente.  Il driver di livello 3 risulta piu'
   impreciso  e  genera  cicli  di  ripetizione/ritardo  del  tasto premuto
   differenti  rispetto  a  quello  di  livello 2 (a parita' di settaggio).
   Comunque   di   regola,   sebbene  SV  sia  programmato  per  funzionare
   correttamente  e  trasparentemente  in  ogni situazione, e' prudente @{B}@{U}NON@{UU}
   @{U}CONGELARE MAI QUANDO L' HARD-DISK E' IN FUNZIONE, SOPRATTUTTO DURANTE LE@{UU}
   @{U}OPERAZIONI   DI  OUTPUT!@{UU}@{UB}   Non  e'  molto  piacevole  vedersi  distrutti
   centinaia di MegaByte di dati!!!  Qualora doveste erroneamente congelare
   durante  una  operazione su Hard-Disk (led acceso, messaggio di notifica
   da  parte  del @{"monitor" link Monitor}) la cosa migliore da fare e' uscire e ricongelare
   ad operazione conclusa!
@endnode

@node Video "SUPERVISOR® Documentation: Monitor/Interfaccia utente/Video"
@prev Keyboard
@next Video
@{B}@{U}VIDEO@{UU}@{UB}:

  A  mio parere un' aspetto che in un programma del genere non dovrebbe mai
venire  trascurato  e'  proprio  il  sistema  di comunicazione tra utente e
programma.   Esso  secondo me e' la prima cosa da prendere in esame poiche'
costituisce  uno  dei maggiori punti di forza del prodotto.  Un @{"monitor" link Monitor} che
fa  uso  di un input tipo CLI1.2 risulta assolutamente scomodo da gestire e
provoca  una  notevole frustrazione in colui che se ne deve servire, specie
in  caso  di  uso  intensivo!   In SV ho cercato di creare l' ambiente piu'
confortevole che un prodotto di questo tipo possa avere.  A questo scopo mi
sono  ispirato  principalmente  alle mie passate esperienze con il glorioso
C64,  aggiungendo  pero' anche alcuni elementi tipici dell' ambiente AMIGA.
Ecco alcune caratteristiche di questo sistema:

- L'  utente  ha  a  disposizione  un  certo  numero  (che egli stesso puo'
  selezionare  al  momento dell' installazione) di "@{I}pagine@{UI}", visualizzabili
  una  alla  volta  tramite il tasto F10.  Sono totalmente indipendenti tra
  loro,  ed  utilizzabili  in  qualsiasi  momento durante la fase di input.
  Ogni  pagina e' costituita da un numero di linee variabile (configurabile
  dall' utente) della lunghezza di 80 caratteri ciascuna.
- Il cursore puo' venir spostato a piacimento per tutto lo schermo.
- Scrolling bidirezionale.
- SmartScrolling:   se lo si desidera, facendo scorrere lo schermo verso l'
  alto  o  verso il basso, il @{"monitor" link Monitor} puo' introdurre automaticamente nella
  prima o nell' ultima linea rimasta vuota (a seconda della direzione dello
  scrolling)  la  precedente  o la successiva riga di output del comando di
  editing usato nelle vicinanze.
- Numerose funzioni di editing.
- CommandLineHistory  (configurabile).   Permette di richiamare stringhe di
  comando digitate in precedenza (tipo 'Shell' di sistema).
- L'  ultima  linea  dello  schermo  puo'  venir, a scelta, utilizzata come
  'barra  informazioni'.  Su  di  essa vengono visualizzate informazioni di
  utilita'  per l' utente, messaggi sullo stato interno del @{"monitor" link Monitor}, ecc...
  In  caso  di  assenza  della  InfoBar  gli errori interni (per chiarirci:
  anomalie  di  funzionamento  della  macchina  o  di qualche routine di SV
  stesso, non imputabili all' utente, per lo meno non direttamente) vengono
  segnalati  tramite  il cambio del colore di fondo dello schermo o tramite
  l' output standard della console.
- Blanker.   Viene  controllato  dalla  @{"variabile blanker" link VARS},  che permette di
  selezionare  il tempo prima del blanking, la modalita' di funzionamento e
  di  disattivarlo.   Il blanker puo' funzionare in due modi:  schermo nero
  oppure  rendendo  lo  schermo  piu'  scuro  del  50%.   Per quest' ultima
  modalita'  vengono  sfruttati  tutti e 24 i bit di colore del chipset AGA
  (se presente).  La cosa sembrerebbe inutile ed irrilevante, ma vorrei far
  presente  che  con  i chipset antecedenti se il colore del testo e quello
  dello  sfondo  sono molto simili, quando vengono diminuiti di intensita',
  perdendo  1 bit di precisione, risultano identici, rendendo invisibile il
  testo  (cosa indesiderata da chi ha scelto questa modalita' piuttosto che
  l' altra!).
- E molto altro ancora ...

@{U}Caratteristiche tecniche del sistema di output@{UU}:
  SUPERVISOR  utilizza  un  video  @{I}Character-Mapped  virtuale@{UI}.   Le routine
principali  (lampeggiamento  cursore,  refresh, scrolling) sono gestite dal
VBlank  interrupt  (level  3).   Per  motivi  di velocita' e di estetica le
operazioni  di  scrolling  vengono  effettuate con routine specifiche e non
tramite il refresh dello schermo virtuale.  Possono venir utilizzati la CPU
o il blitter, a scelta dell'utente.
   Al  VBlank interrupt e' anche affidata la gestione dei registri hardware
video,  anziche', come e' consuetudine, al copper (leggere @{"introduzione" link Intro} per
maggiori informazioni).
   I  colori dello sfondo e del testo vengono settati una volta sola, nella
startup del freezer, per cui e' possibile cambiarli con una semplice 'poke'
(comando  @{"m" link ComM}),  come  si faceva con il vecchio C64.  Nelle prossime versioni
saranno  comunque  molto  probabilmente  gestiti  anch'  essi dall' handler
video,   per   l'utilizzo   da   parte   di   alcune   funzioni  di  futura
implementazione.
@endnode

@node Commands "SUPERVISOR® Documentation: Monitor/Comandi"
@prev Interface
@next VARS
                                  @{B}COMANDI@{UB}

  L'  utente  richiede  al monitor di effettuare le operazioni che desidere
mediante l' uso dei @{U}comandi@{UU}.
  I  @{U}comandi@{UU} sono contraddistinti da una o piu' lettere che identificano la
loro funzione (@{I}nome del comando@{UI}) e dai parametri (@{I}argomenti@{UI}) che forniscono
indicazioni  su  come  deve  essere  effettuata  la funzione richiesta.  Ad
esempio:
	@{U}D$fc0000@{UU}
Disassembla  il  contenuto  della memoria a partire dall'indirizzo @{B}$fc0000@{UB}.
'@{B}D@{UB}'  e'  il  nome del comando.  Puo' essere scritto sia in maiuscolo che in
minuscolo, come per tutti gli altri comandi; @{B}$fc0000@{UB} e' un parametro.
  La  sintassi  di  questo  comando  viene  descritta nella forma seguente:
D[start][,end]
  Le  parentesi  quadre  racchiudono dei parametri facoltativi.  Infatti in
questo caso si sarebbe potuto digitare semplicemente:
D
  L'effetto  sarebbe  stato  quello  di  disassemblare  il  contenuto della
memoria a partire dall'ultimo indirizzo utilizzato.
  La  parentesi quadre mostrate nella descrizione della sintassi NON devono
essere digitate!  Sarebbe quindi un errore:  @{B}D[$70000]@{UB}
  Ogni parametro e' separato dal precedente tramite una virgola (@{B},@{UB}).
  I  parametri  stringa  vanno  racchiusi  tra virgolette (@{B}""@{UB} o @{B}''@{UB}) qualora
contengano caratteri di fine argomento o spazi.
  La  sequenza  @{B}::@{UB}  permette di utilizzare piu' comandi sulla stessa linea.
Es:  @{U}Z!::!!@{UU}  rimuove tutti i breakpoint ed esce.
  Le  lettere  maiuscole indicano le @{I}keywords@{UI}.  L'utente puo' digitarle sia
in maiuscolo che in minuscolo.
  Le  lettere in minuscolo descrivono il parametro che deve essere immesso.
Puo' essere di tipo @{"stringa" link Strings} o @{"numerico" link Eval}.
  Il carattere @{B}|@{UB} indica dei parametri alternativi tra loro.
  Parametri  indirizzo:   l' indirizzo iniziale e' sempre @{I}inclusivo,@{UI} quello
finale  e'  @{I}esclusivo.@{UI}  Es:  @{U}FI$80000,$80100,0@{UU} azzera tutte le locazioni di
memoria comprese tra @{U}$80000@{UU} e @{U}$800ff@{UU}.


                           @{B}SINTASSI DEI COMANDI@{UB}

@{I}@{B}Copper:@{UB}@{UI}
@{"Assemble copperlist" link ComAC}
@{"Disassemble copperlist" link ComL}
@{"CopperHelp switch" link ComHSWTC}
@{"CopperList Finder" link ComCLF}
@{"Show CLF Config-Codes" link ComCPcfg}
@{"Init Copper" link ComEC}

@{I}@{B}680x0/Freezer:@{UB}@{UI}
@{"Assemble 680x0 code" link ComA}
@{"Disassemble 680x0 code" link ComD}
@{"Exit" link ComExit}
@{"Go" link ComG}
@{"Jump" link ComJ}
@{"Set|Clear BP" link ComZ}
@{"Show BPs" link ComBPLst}
@{"BP Activation" link ComBPA}
@{"Toggle int transparency" link ComTansp}
@{"Patcher Control" link ComPCON}
@{"Lock patch code" link ComLkPMem}
@{"Free patch code" link ComFrPMem}
@{"Show patch-list" link ComSPL}
@{"Include vector(s)" link ComIVEC}
@{"Exclude vector(s)" link ComXVEC}
@{"Show Patcher Config-Codes" link ComCPcfg}
@{"CPU Registers" link ComX}
@{"Trace into" link ComT}
@{"Trace over" link ComK}
@{"Skip instruction" link ComKS}
@{"Put NOP" link ComKN}
@{"Do RTS" link ComKR}
@{"Link tracer" link ComTLINK}
@{"Capture task" link ComCapTask}

@{I}@{B}PC-tracer:@{UB}@{UI}
@{"Trace PC" link ComTracePC}
@{"Kill PC map" link ComKillPCMap}
@{"Show PC map" link ComN}

@{I}@{B}Ricerca/Gestione memoria:@{UB}@{UI}
@{"Trainer" link ComCheat}
@{"ST|NT|PT-Module finder" link ComRip}
@{"Gfx ripper" link ComGRip}
@{"Compare" link ComCM}
@{"Copy" link ComCO}
@{"Find data" link ComF} (NORMAL/ENCRYPTED)
@{"Find data" link ComFM} (MASKABLE)
@{"Find address" link ComFA}
@{"Find changes" link ComUA}
@{"Find disassembly" link ComFD}
@{"Find encryption key" link ComFdKey}
@{"Find references" link ComUB}
@{"Find Relative" link ComFR}
@{"Fill" link ComFI}
@{"Encode memory" link ComEnc}
@{"Poke" link ComM}
@{"Hex dump" link ComQ}
@{"Show memory" link ComS}
@{"Alloc memory" link ComAlloc}
@{"Free memory" link ComFree}
@{"Relocate executable" link ComRelE}
@{"Relocate binary" link ComRelB}
@{"Move chipdata" link ComMoveChip}
@{"Add memory" link ComIA} (REGISTERED VERSION ONLY)
@{"Memory info" link ComIM}
@{"Kill memory" link ComIK}
@{"Memory watcher" link ComEW}

@{I}@{B}Memory Manager:@{UB}@{UI}
@{"Toggle MM" link ComEM}

@{I}@{B}Disco:@{UB}@{UI}
 SV  dispone  di  un  suo  sistema operativo interno (@{"D-DOS" link DDOSInfo} ©THE 1702 GROUP
1992) per la gestione delle 4 unita' a disco di AMIGA, in grado di gestire:
a)@{I}formattazione   standard   880K   e   formattazione   ad  alta  capacita'
  990K(approssimato  per difetto!  la capacita' esatta e' di 1014176 byte),
  per quanto riguarda le routine a basso livello;@{UI}
b)@{I}standardfilesystem,  fastfilesystem, d-filesystem, per quanto riguarda la
  parte  ad  alto  livello.  *** Questa sezione non e' ancora ultimata, per
  cui  i  file saranno accessibili solo nelle versioni successive.@{UI}
@{"Format" link ComY}
@{"ReadBlock" link ComRS}
@{"WriteBlock" link ComWS}
@{"DiskInfo" link ComID}
@{"AutoDiskInit" link ComADI}
@{"BootBlockChecksum" link ComB}

@{I}@{B}Informazioni:@{UB}@{UI}
@{"Help" link ComH}
@{"Info" link ComI}
@{"Freezer info" link ComIF}
@{"Custom regs info" link ComIH} (REGISTERED VERSION ONLY)
@{"Task info" link ComIT}
@{"Trainer info" link ComIC}
@{"Resident info" link ComIR}
@{"Version info" link ComIV}
@{"Raw key monitor" link ComRKM}

@{I}@{B}Controllo:@{UB}@{UI}
@{"Set default base" link Com0}
@{"Toggle packed calculator res" link ComSCflg}
@{"Toggle Rawkey|ASCII" link ComRAW}
@{"Sign" link ComSign}
@{"Safety" link ComSaf}
@{"Assembler settings" link Com3}
@{"Disassembler settings" link Com1}
@{"Restart" link ComRest}
@{"Toggle Boot-Freeze" link ComBootFrz}
@{"Restore TOD" link ComResTOD}
@{"Kill SUPERVISOR (Hard Reset)" link ComKill}
@{"Reboot" link ComReset}
@{"Toggle Reset-Freeze" link ComResF}
@{"Toggle BeamSync" link ComBSync}
@{"Blitter" link ComBlt}
@{"Cache" link ComCache}
@{"Set resident-pri" link ComSetPri}
@{"Remove Resident" link ComRemSV}
@{"Set VBR" link ComVBR}
@{"Set FreezeKey" link ComSetFK}
@{"Toggle keyboard-restore" link ComKRest}
@{"Restore Screen" link ComResScr}
@{"Toggle PAL|NTSC" link ComPALNTSC}
@{"Task-capture ON|OFF" link ComTask}
@{"Edit FKeys" link ComEdFK} (REGISTERED VERSION ONLY)

@{I}@{B}Vari:@{UB}@{UI}
@{"Hear Memory" link ComOM}
@{"Calculator" link ComCalc}

@{I}@{B}Gestione variabili:@{UB}@{UI}
@{"Set symbol memory" link ComP}
@{"Symbol info" link ComSymInfo}
@{"Show symbol table" link ComSymTab}
@{"Zap labels" link ComZapLabs}
@{"Define symbol" link ComDefSym}
@{"Define label" link ComDefLab}

@{I}@{B}RealTimeMonitor:@{UB}@{UI}
@{"Init RTM" link ComER}
@{"Config RTM" link ComEE}

@{I}@{B}Gestione macro:@{UB}@{UI}(REGISTERED VERSION ONLY)
@{"Do macro" link ComB2}
@{"Pause|Cont macro exec" link ComMACB}
@{"Toggle macro echo" link ComMACE}
@{"Toggle macro fkeys" link ComMACF}
@{"Macro Info" link ComMACI}
@{"List macro[s]" link ComMACL}

@{I}@{B}Espansione:@{UB}@{UI}(REGISTERED VERSION ONLY)
@{"External Command" link ComExtCom}
@endnode

@node ComAC "SUPERVISOR® Documentation: Monitor/Comandi/Assemble copperlist"
@prev ComAC
                            @{U}@{B}Assemble copperlist@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}AC[address]@{UB}
Assembla codici per il copper.  Il parametro @{U}address@{UU} specifica l' indirizzo
della  prima  linea da assemblare.  Se omesso viene utilizzato l' indirizzo
@{"corrente" link DCnote}.   Il  monitor  risponde  visualizzando  l' istruzione copper all'
indirizzo  specificato  con  a fianco il cursore.  L' utente puo' digitarne
una nuova o passare a quella successiva premendo RETURN.

@{U}@{I}Il formato delle istruzioni e' il seguente@{UI}@{UU}:
 @{B}MOVE #data16,destination@{UB}
@{I}dove@{UI}
 'data16'  e'  un operando contenente il dato immediato a 16 bit (0-$ffff),
 'destination'    e'  l' indirizzo   assoluto   destinazione.    L'operando
 destinazione   puo'   essere   espresso  in  forma  completa  ($dffxxx)  o
 semplicemente indicando l' offset ($xxx).

 @{B}WAIT Y8,X7,BFD1,YMASK7,XMASK7@{UB}
 @{B}SKIP Y8,X7,BFD1,YMASK7,XMASK7@{UB}
@{I}dove@{UI}
 Y8	rappresenta  la  posizione  Y  del pennello elettronico (8 bit meno
        significativi)
 X7	rappresenta  la  posizione  X  del  pennello  elettronico (bit 1-8)
        l'operando  e' di 7 bit e va espesso con un numero compreso tra 0 e
        $7f
 BFD1	Blitter Finished Disable, 1 bit (0-1)
 YMASK7	maschera per Y, 7 bit (0-$7f)
 XMASK7	maschera per X, 7 bit (0-$7f)
@endnode

@node ComL "SUPERVISOR® Documentation: Monitor/Comandi/Disassemble copperlist"
                          @{U}@{B}Disassemble copperlist@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}L[start][,end]@{UB}
Disassembla   istruzioni   del   copper.    Il  parametro  @{U}start@{UU}  specifica
l' indirizzo dal quale partira' l'operazione; se omesso viene utilizzato l'
@{"indirizzo corrente" link DCnote}.   Il  parametro  @{U}end@{UU} indica l'indirizzo al quale dovra'
terminare  l' operazione; se omesso vene visualizzato un numero ottimale di
linee.   Questo  comando  e'  dotato  di  @{I}auto-repeat;@{UI}  cio'  significa che
terminata   la   visualizzazione   e'   sufficiente   premere   RETURN  per
disassemblare  un'  altra  porzione  di  memoria.  L' output del comando e'
editabile:   ci  si  posiziona  col  cursore  su  di una linea, si modifica
qualcosa,  e  si  preme  RETURN o BACKRETURN (SHIFT+RETURN).  Con RETURN si
passa  all'editing della linea successiva, con BACKRETURN si passa a quella
precedente.   Attualmente e' editabile solo la parte in Linguaggio Macchina
(quella  visualizzata  in  esadecimale) della linea.  In fase di editing e'
consigliabile  disattivare  l'  @{I}inserimento.@{UI}   Ricordare  che  le modifiche
vengono memorizzate solo in seguito ad un (BACK)RETURN!
@endnode

@node ComHSWTC "SUPERVISOR® Documentation: Monitor/Comandi/CopperHelp switch"
                             @{U}@{B}CopperHelp switch@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}/[flag]@{UB}
Questo  comando  influenza  l'  output  del  comando  @{"L" link ComL}.   Senza  parametri
visualizza l' ultima impostazione.  @{U}flag=0@{UU} disattiva la visualizzazione dei
nomi dei registri hardware.  @{U}flag=1@{UU} visualizza i nomi dei registri hardware
accanto   al  dissassembly  delle  istruzioni  MOVE  del  copper.   @{U}flag=-1@{UU}
visualizza i nomi dei registri hardware al posto del loro indirizzo.
@endnode

@node ComCLF "SUPERVISOR® Documentation: Monitor/Comandi/CopperList Finder"
                             @{U}@{B}CopperList Finder@{UB}@{UU}

 SV  e'  dotato  di  un  efficientissimo  sistema di ricerca di copperlist.
Diamogli un' occhiata:

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}UT[coplst][,copcon]@{UB}
Prova    (esegue)    la    copperlist   all'   indirizzo   @{U}coplst@{UU}.
@{U}copcon@{UU}  serve  ad  impostare l' omonimo registro hardware.  Se il parametro
@{U}coplst@{UU} non e' presente viene provata la copperlist del programma congelato.
**NOTA:   @{B}La  copperlist  utilizzata  con  questo  comando  e  l' eventuale
settaggio del registro COPCON rimangono validi anche allo scongelamento del
programma.@{UB}

@rem line 15
@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}UC[start,end]@{UB}
Ricerca delle possibili copperlist esaminando il codice del 680x0.  La zona
di  ricerca  puo'  venir  indicata  o lasciata dedurre al monitor.  Ad ogni
ritrovamento vengono indicati codice generatore e copperlist (@{I}saddr:caddr@{UI}).
Al  termine  della ricerca viene indicata la copperlist piu' verosimile tra
quelle  trovate.   I  criteri  di  ricerca  possono  essere  configurati  a
piacimento dall' utente:  a questo scopo vedere @{B}UI@{UB},@{B}UL@{UB},@{B}UX@{UB},@{B}UP@{UB}.

@rem line 24
@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}UD[start,end]@{UB}
Ricerca possibili copperlist in memoria chip.  L' utente puo' delimitare la
zona di ricerca o lasciare che avvenga per tutta la memoria chip.

@rem line 29
@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}UP@{UB}
In seguito all' immissione di questo comando vengono poste alcune domande a
cui  occorre  rispondere  con  un  Y(=si), N(=no), o un semplice RETURN(per
accettare  il  settaggio  preesistente),  al fine di impostare i criteri di
ricerca delle copperlist.
>@{I}CopperList Check? @{UI}
 Questo  vale  solo  per  il  comando UC.  Rispondendo N viene disabilitato
qualsiasi controllo sulla validita' della copperlist trovata.
>@{I}Only DFF000-DFF200 regs? @{UI}
 Rispondendo  Y  vengono  ammessi solo gli accessi ai registri compresi tra
$dff000  e  $dff200  nelle  istruzioni  MOVE.  In futuro potrebbero esserci
registri  mappati  oltre questi indirizzi:  con questa opzione e' possibile
includerli.
>@{I}Allow SKIP inst.? @{UI}
 Rispondendo N non si accettano copperlist con istruzioni SKIP.
>@{I}Beam check? @{UI}
 Se si risponde Y viene controllato se le istruzioni WAIT e SKIP sono poste
in ordine cronologico.
>@{I}Allow wait/skip for same scanline? @{UI}
 Permette  (Y)  che  ci  siano  piu' istruzioni wait e/o skip per la stessa
linea di scansione verticale.
>@{I}StandarEndOfCopperList? @{UI}
 Y=la  copperlist  deve  terminare  con il classico -2, o con un accesso ai
registri COPJMP.
>@{I}Move required? @{UI}
 Y=la copperlist deve contenere almeno una istruzione MOVE.
>@{I}Wait required? @{UI}
 Y=la copperlist deve contenere almeno una istruzione WAIT.
>@{I}Allow regs reuse on same scanline? @{UI}
 Y=Ogni  registro  hardware non puo' venir scritto piu' di una volta a meno
che  non  sia  intervallato  da istruzioni WAIT.  Il registro BPLCON3 e' l'
unico  che  puo' far eccezione, in quanto e' usato nelle copperlist AGA per
la  selezione  dei banchi della tabella dei colori.  Ogni accesso a BPLCON3
consente di riusare i registri dei colori in assenza di WAIT separatori.

>@{I}Regs check? @{UI}
 Y=controlla  che  i registri hardware usati siano fra quelli ammessi dall'
utente.   Il controllo avviene solo per i registri compresi tra $40 e $200.
Da  0  a  $40  non  sono mai ammessi; da $200 in poi sono ammessi in base a
quanto detto precedentemente.
>@{I}Allow BFD=0? @{UI}
 Y=nelle istruzioni WAIT e SKIP, BFD deve essere sempre uguale a 1.
>@{I}Deep scan? @{UI}
 (Valido  solo  per  il  comando  @{B}UC@{UB})Y=Effettua  una  ricerca piu'
approfondita,  ma  lievemente  piu'  lenta.   In  alcune rare situazioni si
ottengono migliori risultati settando questo parametro ad N.
>@{I}Min. # of coppercodes @{UI}
 Questa  domanda  richiede l' impostazione di un numero, che rappresenta il
minimo  numero  di  istruzioni  che  deve contenere la copperlist affinche'
possa essere ritenuta valida.

@rem line 81
@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}UL@{UB}
Mostra  la  lista dei registri che possono essere acceduti dalle istruzioni
MOVE del Copper.

@rem line 86
@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}UIstartreg[,endreg]@{UB}
Include  uno  o  piu'  registri nella lista @{B}UL@{UB}.  Specificando solo @{U}startreg@{UU}
viene  solo  abilitato  il  registro  indicato.   Specificando anche @{U}endreg@{UU}
vengono inseriti tutti i registri compresi tra @{U}startreg@{UU} e @{U}endreg@{UU}.

@rem line 92
@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}UXstartreg[,endreg]@{UB}
Come @{B}UI@{UB}, ma anziche' includere serve ad escludere i registri.
@endnode

@node ComEC "SUPERVISOR® Documentation: Monitor/Comandi/Init Copper"
                                @{U}@{B}Init Copper@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}EC@{UB}
Attiva/disattiva  la  reinizializzazione del copper (tramite COPJMP1) nella
fase di scongelamento.
@endnode

@node ComA "SUPERVISOR® Documentation: Monitor/Comandi/Assemble 680x0 code"
                            @{U}@{B}Assemble 680x0 code@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}A[address]@{UB}
Assembla  codice  del  680x0.   Il parametro @{U}address@{UU} specifica l' indirizzo
della  prima  linea da assemblare.  Se omesso viene utilizzato l' indirizzo
@{"corrente" link DCnote}.   Il  monitor  risponde  visualizzando  l' istruzione copper all'
indirizzo  specificato  con  a fianco il cursore.  L' utente puo' digitarne
una nuova o passare a quella successiva premendo RETURN.
L' assemblatore di linea utilizzato e' configurabile tramite il comando @{"3" link Com3}.
@endnode

@node ComD "SUPERVISOR® Documentation: Monitor/Comandi/Disassemble 680x0 code"
                          @{U}@{B}Disassemble 680x0 code@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}D[start][,end]@{UB}
Disassembla   istruzioni  del  680x0.   Il  parametro  @{U}start@{UU}  specifica  l'
indirizzo  dal  quale  partira' l'operazione; se omesso viene utilizzato l'
indirizzo  @{"corrente" link DCnote}.   Il parametro @{U}end@{UU} indica l' indirizzo al quale dovra'
terminare  l' operazione; se omesso vene visualizzato un numero ottimale di
linee.   Questo  comando  e'  dotato  di  @{I}auto-repeat;@{UI}  cio'  significa che
terminata   la   visualizzazione   e'   sufficiente   premere   RETURN  per
disassemblare  un'altra porzione di memoria.  Le linee sulle quali e' stato
posto  un  @{"BreakPoint" link ComZ} sono visualizzate in negativo.  L' output del comando
e'  editabile:   ci  si  posiziona col cursore su di una linea, si modifica
qualcosa,  e  si  preme  RETURN o BACKRETURN (SHIFT+RETURN).  Con RETURN si
passa  all'editing della linea successiva, con BACKRETURN si passa a quella
precedente.    In   fase   di   editing  e'  consigliabile  disattivare  l'
@{I}inserimento.@{UI}   Ricordare  che  le  modifiche  vengono  memorizzate  solo in
seguito ad un (BACK)RETURN!
  Il @{"MemoryManager" link MemManager} e' supportato.
@endnode

@node ComExit "SUPERVISOR® Documentation: Monitor/Comandi/Exit"
                                   @{U}@{B}Exit@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!!@{UB}
Esce  dal  monitor:  il programma viene scongelato.  L' esecuzione riprende
dall' indirizzo puntato dal @{B}PC@{UB}.
@endnode

@node ComG "SUPERVISOR® Documentation: Monitor/Comandi/Go"
                                    @{U}@{B}Go@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}G[address]@{UB}
Il programma riprende l' esecuzione dall' indirizzo specificato o dal @{B}PC@{UB} se
il  parametro  @{U}address@{UU}  viene  omesso.   Prima  dello  scongelamento  viene
visualizzata la seguente richiesta:
@{B}BreakPoint:@{UB}
occorre  rispondere specificando un indirizzo al quale posizionare un Break
Point  oppure premere RETURN per continuare.  La richiesta viene effettuata
piu'  volte  sino a che non si risponde con un semplice RETURN per indicare
che  tutti  i  BreakPoint  sono  stati  piazzati.
@endnode

@node ComJ "SUPERVISOR® Documentation: Monitor/Comandi/Jump"
                                   @{U}@{B}Jump@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}Jaddress@{UB}
Esegue  la  routine  all'  indirizzo  specificato  e ritorna al monitor.  A
differenza  di  @{"Go" link ComG},  l'  esecuzione  del sottoprogramma avviene in ambiente
monitor, e non sono utilizzabili @{I}BreakPoint.@{UI}  Al ritorno al monitor tutti i
registri  alterati  vengono  memorizzati.   Molto  probabilmente  quando il
programma verra' scongelato necessitera' dei vecchi valori dei registri; in
questo  caso  e'  sufficiente  utilizzare  il comando @{"XR" link ComX}.  La chiamata alla
subroutine  avviene  in modo @{I}Supervisore @{UI}(sono quindi utilizzabili tutte le
istruzioni);  gli interrupt sono disabilitati (tramite @{B}SR@{UB}) e il video viene
spento.   Questo  per  consentire  l' utilizzo di tutti i registri CPU, dal
momento  che  in  ambiente  monitor alcuni registri sono utilizzati in modo
@{I}globale @{UI}sia dal programma principale, sia dalle routine d' interrupt, e non
possono  per questo venir toccati.  @{U}La subroutine NON deve modificare i bit
di @{B}SR@{UB}, puo' solo servirsi di @{B}CCR@{UB}, e deve terminare con una istruzione @{B}RTS@{UB}.@{UU}
@endnode

@node ComZ "SUPERVISOR® Documentation: Monitor/Comandi/Set|Clear BP"
                               @{U}@{B}Set|Clear BP@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}Z[!/address][,attr]cnt]@{UB}
Aggiunge  o rimuove BreakPoint(BP).  Seguito dal parametro @{B}!@{UB}  rimuove tutti
i  BreakPoint  e  disabilita l' intercettazione delle istruzioni illlegali.
Senza il parametro @{B}!@{UB}  funziona da Toggle: se all' indirizzo specificato dal
parametro  @{U}address@{UU} e' presente un BreakPoint, esso viene rimosso; se non e'
presente  viene inserito.  Se non viene fornito il parametro @{U}address@{UU}, viene
preso  l'  indirizzo contenuto nel registro PC(congelato).  Dal momento che
e'   piuttosto   fastidioso  utilizzare  numeri  per  accedere  ai  singoli
BreakPoint,   esiste   una  facilitazione all' interno  del  @{"valutatore" link Eval}  di
espressioni:   vedere paragrafo riguardante.  Ogni qualvolta venga aggiunto
un  BreakPoint  viene riabilitata la funzione di rilevamento di essi.  Essa
puo'  venir  manipolata  tramite  un appropriato @{"comando" link ComBPA}; se disabilitata i
BreakPoint   non   vengono  settati  ne'  rilevati.   @{U}attrcnt@{UU}  permette  di
configurare al meglio ogni singolo BreakPoint:
X	disattiva/riattiva un BP (senza rimuoverlo dalla lista)
R	rimuove  automaticamente  il  BP  dopo  il suo utilizzo (R non puo'
	essere usato insieme a D)
D	disabilita  automaticamente  il BP dopo il suo utilizzo (D non puo'
	essere usato insieme ad R)
C	condizionale:   se  questo  attributo  viene  impostato, il freezer
	viene  invocato  al  passaggio  del  programma  sul  BP  solo se la
	condizione specificata dal parametro @{I}cnt @{UI}(vedi sotto) e' vera.
M	invoca il freezer ad ogni passaggio del programma su di esso (anche
	se cnt<>0)
cnt	stabilisce  quante volte il programma deve passare su di esso prima
	che  l' azione impostata con @{B}R@{UB} o @{B}D@{UB} sia effettuata.  Se il parametro
	@{B}N@{UB}  non  e'  selezionato  il  freezer  viene invocato solo quando il
	conteggio  raggiunge lo 0.  Se il flag @{B}D@{UB} e' impostato questo numero
	indica  il  simbolo  contenente  la  condizione  da verificare.  Il
	simbolo avra' nome Cn dove n e' un numero compreso tra 0 e 9.  Esso
	deve  essere  di  tipo  @{I}CUSTOM FUNCTION @{UI} e  dovra'  pertanto essere
	definito  con il comando @{"==" link ComDefSym}.  Alcuni di essi sono gia' definiti con
	delle  impostazioni  di  comune utilita'.  Se l' utente lo desidera
	puo'  comunque  ridefinire  anch'  essi.  Ricordarsi che al momento
	della  verifica  della condizione non tutti i simboli dinamici sono
	aggiornati:   quelli  su  cui  si  puo' fare affidamento sono:  pc,
	d0-d7/a0-a7 (a7=SSP).

@{U}STACK@{UU}: Lo stack usato al passaggio su di un BreakPoint e' il seguente:
@{B}(68000)  3 WORDS (6 BYTES) exception stack-frame
(68010+) 4 WORDS (8 BYTES) exception stack-frame
       +10 WORDS (20 BYTES) register backup
(68000)  = 13 WORDS (26 BYTES)
(68010+) = 14 WORDS (28 BYTES)
<switch to internal stack>@{UB}

  @{I}SV  in  pratica  utilizza  il  suo  stack  interno  per  la  gestione dei
breakpoint minimizzando l' uso di quello del programma (il bp condizionale,
in particolare, richiede una gran quantita' di stack).@{UI}
@endnode

@node ComBPLst "SUPERVISOR® Documentation: Monitor/Comandi/Show BPs"
                                 @{U}@{B}Show BPs@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}.@{UB}
Visualizza  l'  elenco  di  tutti  i  BreakPoint  installati,  con  il loro
rispettivo  nomero  d' ordine (utilizzabile all' interno di un' espressione
preceduto  dall'  identificatore  '.'.   Es:D.1 disassembla a partire dall'
indirizzo del primo BreakPoint), indirizzo ed attributi.
@endnode

@node ComBPA "SUPERVISOR® Documentation: Monitor/Comandi/BP Activation"
                               @{U}@{B}BP Activation@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}<@{UB}
Abilita/disabilita il rilevamento dei BreakPoint.  Se questa funzione viene
disabilitata  i  BreakPoint  precedentemente  prescelti  NON vanno comunque
persi:   semplicemente  non vengono posti nel programma congelato ne' viene
installato  il codice di rilevazione sino alla successiva riabilitazione di
questa funzione.
@endnode

@node ComTansp "SUPERVISOR® Documentation: Monitor/Comandi/Toggle int transparency"
                          @{U}@{B}Toggle int transparency@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!Y@{UB}
Attiva/disattiva  la  trasparenza degli handler di interrupt per la cattura
dei programmi.  Attualmente agisce sugli handler di livello 2 e 6:
@{U}INT6@{UU}:   se  il  modo  trasparente e' disattivato, l'interrupt e' gestito in
modo esclusivo, altrimenti e' condiviso con l' handler preesistente;
@{U}INT2@{UU}:   se  il  modo  trasparente  e'  attivo,  la gestione dell' interrupt
avviene  in  maniera  piu'  trasparente,  evitando la chiamata all' handler
originario  in  assenza  di richiesta su INTREQ e CIAA-ICR (cio' accade nel
caso in cui SV e' attivato tramite pressione di un tasto).
@endnode

@node ComPCON "SUPERVISOR® Documentation: Monitor/Comandi/Patcher Control"
                              @{U}@{B}Patcher Control@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}>[mode]/[C]@{UB}
Attiva/disattiva  l'  intercettazione  delle  eccezioni  della CPU.  Questa
funzione  e'  fondamentale  per  SV, poiche' esso prende il controllo della
macchina  proprio  tramite  le  eccezioni.  Disattivando questa funzione si
limita  fortemente  la  capacita'  di  congelamento  di  SV.   Il parametro
opzionale  @{U}mode@{UU}  e'  disponibile  solo  nelle  macchine  dotate  di 68010 o
superiori.   @{U}mode=0@{UU}  seleziona  il  funzionamento  normale:   le  eccezioni
vengono  intercettate  modificando  il  relativo  vettore.   Con @{U}mode@{UU}<>0 SV
riesce  a prendere il controllo di oltre il 99% dei programmi senza bisogno
di  alcun  intervento da parte dell' utente:  la quasi totalita' dei giochi
esistenti  per amiga assume che la tabella dei vettori si trovi nel primo K
di  memoria,  essendo  stato  scritto per il 68000 (o comunque si limita al
controllo  cache  nei  processori  superiori), pochissimi altri accedono al
registro  VBR,  ma  solo  durante  l'  inizializzazione  (nel  qual caso e'
richiesto un intervento minimo dell' utente), e qualche rarissimo programma
ne  fa  un uso abbastanza intensivo.  SV dunque modifica l' indirizzo della
tabella  dei  vettori  con  di  una propria tabella.  Ogni eccezione dunque
viene  sempre  'filtrata'  attraverso  il  gestore  interno  di SV, per poi
ripassare  il  controllo  alla  routine  indicata dalla vecchia tabella dei
vettori.
Il  parametro  @{U}C@{UU}  (il quale esclude il parametro @{U}mode@{UU}) seleziona il tipo di
intercettazione:   @{I}esclusiva @{UI} (default), o @{I}condivisa.@{UI}  In modo @{I}esclusivo @{UI}le
eccezioni  vengono solo intercettate da SV, in modo @{I}condiviso @{UI}vengono prima
intercettate  dal  freezer  e poi, all' uscita dal monitor, vengono gestite
dall' handler originale.
ATTENZIONE:   Al  fine  di ottenere il massimo dell' efficienza, le routine
per  la  gestione  di eccezioni non si trovano pre-programmate all' interno
del programma, ma vengono @{I}generate@{UI} di volta in volta da questo comando, per
cui,  e'  consigliabile  lasciare  libero sempre qualche centinaio di bytes
nella  @{I}memoria esterna@{UI}, per non trovarsi in situazioni in cui SV non riesce
ad  ottenere lo spazio necessario per i propri handler, lasciando l' utente
impossibilitato a richiamare il freezer.
@endnode

@node ComLkPMem "SUPERVISOR® Documentation: Monitor/Comandi/Lock patch code"
                              @{U}@{B}Lock patch code@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}>P@{UB}
L'  area  di  memoria contenente il codice di controllo delle eccezioni che
permette l' attivazione del freezer nelle condizioni richieste dall' utente
NON  viene  liberata.  Come gia' accennato questo codice non e' statico, ma
viene generato di volta in volta 'su misura' in base alle necessita'.  Cio'
porta pero' ad alcuni spiacevoli effetti collaterali:  se il vecchio codice
viene  liberato  quando  e'  ancora  in  uso,  il crash del sistema sarebbe
pressoche'  inevitabile.   Onde  evitare  cio'  SV elimina i vecchi handler
solamente  ogni  due  attivazioni del freezer:  in pratica normalmente sono
presenti  contemporaneamente  due  gruppi  di handler di eccezioni:  quello
corrente  e  quello precedente.  Cio' al 99% dei casi non da' problemi.  La
rimanenza  dei  casi e' in genere costituita da programmi che, come SV, non
si  impossessano  delle  eccezioni  in modo esclusivo, ma ne condividono la
gestione  con  l'  handler  precedente.   In  queste RARE occasioni @{I}occorre@{UI}
bloccare  il  codice in memoria fino a che non si e' certi che non sia piu'
in uso.
@endnode

@node ComFrPMem "SUPERVISOR® Documentation: Monitor/Comandi/Free patch code"
                              @{U}@{B}Free patch code@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}>F[address]@{UB}
Libera la zona di memoria contenente i gestori di eccezione precedentemente
bloccata  con  il comando @{">P" link ComLkPMem}.  @{U}address@{UU} serve a specificare l' indirizzo del
blocco  di  memoria.   Se  viene  omesso  viene automaticamente liberato l'
ultimo.   NOTA:   Solo l' ultimo viene ricordato.  Per quelli precedenti va
specificato il parametro @{U}address@{UU} (gli indirizzi vengono forniti dal comando
@{"IF" link ComIF}).
@endnode

@node ComSPL "SUPERVISOR® Documentation: Monitor/Comandi/Show patch-list"
                              @{U}@{B}Show patch-list@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}>L@{UB}
Mostra  la lista dei vettori delle eccezioni da intercettare.  L' output e'
nel seguente formato:  @{I}numero vettore:offset vettore.@{UI}
@endnode

@node ComIVEC "SUPERVISOR® Documentation: Monitor/Comandi/Include vector(s)"
                             @{U}@{B}Include vector(s)@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}>Ivectoroffset[,vectoroffset]@{UB}
Include  uno  o  piu'  vettori  nella  lista d' intercettazione.  I vettori
utilizzabili  sono  nel  campo  2-63  (offset:$08-$3f).   Per  includere un
vettore  basta  indicare il suo offset.  Per includere piu' vettori occorre
indicare il vettore iniziale e quello finale, separati da una virgola.
@endnode

@node ComXVEC "SUPERVISOR® Documentation: Monitor/Comandi/Exclude vector(s)"
                             @{B}@{B}Exclude vector(s)@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}>Xvectoroffset[,vectoroffset]@{UB}
Esclude  uno  o  piu'  vettori  nella  lista d' intercettazione.  I vettori
utilizzabili  sono  nel  campo  2-63  (offset:$08-$3f).   Per  escludere un
vettore  basta  indicare il suo offset.  Per escludere piu' vettori occorre
indicare il vettore iniziale e quello finale, separati da una virgola.
@endnode

@node ComCPcfg "SUPERVISOR® Documentation: Monitor/Comandi/Patcher|CopperFinder CFG"
                         @{U}@{B}Patcher|CopperFinder CFG@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}>>@{UB}
 @{B}UU@{UB}
Visualizzano i codici di configurazione del @{B}Patcher@{UB} e del @{B}CopperListFinder@{UB},
rispettivamente.   Questi  codici vanno usati nei gadget della procedura di
configurazione,  in modo da ottenere le proprie impostazioni personalizzate
ogni volta che si installa SV.
@endnode

@node ComX "SUPERVISOR® Documentation: Monitor/Comandi/CPURegisters"
                               @{U}@{B}CPURegisters@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}X[B/F/R/S]@{UB}
Visualizza  i  contenuti dei registri CPU relativi al programma congelato .
Nella prima linea viene visualizzato il contenuto degli otto registri dati;
nella  seconda  i  registri  indirizzo  (per  A7 (SP) viene visualizzato il
registro  appropriato  (USP  o SSP) in base al flag S in SR.  La terza riga
contiene USP, SSP e SR.  SR viene visualizzato con una word esadecimale, ed
a fianco i vari bit sotto forma di lettera.  I flag visualizzati variano in
base alla CPU.
NOTE  per  68020+.   I  due  flag  T1  e T0 vengono rappresentati con T e t
rispettivamente.   Il contenuto del registro SSP corrisponde ad ISP o MSP a
seconda dello stato del flag M.
ATTENZIONE:   per  la lettura dello stack tener presente che:  il contenuto
dello  stack  utente  non  viene  alterato  al  congelamento,  per  cui  e'
sufficiente partire  dall' indirizzo contenuto in USP, mentre per gli stack
supervisore  (sul  68020/30 sono 2), sebbene SV utilizzi, quando e' attivo,
un  suo  stack  proprio,  al  momento del congelamento vengono poste alcune
informazioni  in  uno  degli  stack supervisore del programma di cui si sta
prendendo  il  controllo.  Il congelamento avviene sempre tramite eccezione
della  CPU,  e  successiva  chiamata  alla  routine  principale  di freeze.
Esaminiamo quindi lo stack dal punto indicato da SSP:
-APTR:puntatore alla funzione Freeze()
-stack  frame  di eccezione (dimensioni variabili a seconda del processore:
 3  o  7 words con un 68000, da 4 a 46 con un 68020).  La @{"variabile" link VARS} SSP (da
 non confondersi con l' omonimo registro) permette di accedere direttamente
 al contenuto dello stack che si trova dopo lo stack frame di congelamento,
 evitando all' utente il calcolo manuale dell' indirizzo.
-stack del programma congelato
NOTA:  i 4 byte precedenti all' indirizzo puntato da SSP vengono anch' essi
alterati  (dovrebbero  contenere il dump del registro A5, se la memoria non
mi tradisce).
  Sull'ultima   linea   viene   visualizzato   il  registro  PC  e  accanto
disassemblata  la  linea  corrispondente.   Qualora  si  siano  alterati  i
contenuti  di  uno  o  piu'  registri  e  si  voglia recuperare i contenuti
iniziali,   occorre   specificare   il   parametro  @{I}R @{UI}(Restore),  il  quale
ripristinera'  i  vecchi  valori  memorizzati  al  momento dell'entrata nel
@{"monitor" link Monitor}  o  con  il parametro @{I}B @{UI}(Backup).  Come appena detto il parametro @{I}B @{UI}
puo'  venir  utilizzato  per  memorizzare il contenuto dei registri per poi
richiamarlo  in  un  secondo  momento.  Ricordo ancora una volta che questa
operazione  viene  effettuata automaticamente ogni qualvolta si effettua un
congelamento .  Tutti i registri alterati tra una visualizzazione e l'altra
vengono  visualizzati  in negativo.  L' output di questo comando puo' venir
editato:   posizionarsi  col  cursore  sulla  linea desiderata, cambiarne i
contenuti e premere RETURN.
  Il parametro @{I}S @{UI}necessita almeno di un 68010.  Visualizza informazioni sul
frame  presente  nello  stack  supervisore,  come  descritto  in  precenza.
Fornisce  la lunghezza espressa in WORD e, se possibile, l' indirizzo dell'
istruzione  che  ha causato l' eccezione (ad esempio con il frame di 6 word
generato  da  un'  eccezione  di traccia).  Quest' ultima informazione puo'
essere  utile  in quanto, in genere, il PC punta alla successiva istruzione
da  eseguire  e  la  precedente  puo' non essere rintracciabile facilmente,
soprattutto quando si verifica un cambiamento di flusso (RTS).
  Con il parametro @{I}F @{UI}vengono visualizzate le informazioni ottenibili con il
parametro S (68010+) ed i contenuti dei registri CPU.
@endnode

@node ComT "SUPERVISOR® Documentation: Monitor/Comandi/Trace into"
                                @{U}@{B}Trace into@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}T[*][steps][,mode]@{UB}
 @{B}T[*]!addressregisternumber,value@{UB}
 @{B}T[*]&condition#@{UB}
 @{B}T[*]%condition@{UB}
Questo  comando  permette  l'  esecuzione  di un programma passo-passo:  il
programma  viene  scongelato  per  l'  esecuzione  del numero di istruzioni
desiderate,  dopodiche'  viene  ricongelato.   Con  la  prima  sintassi  e'
possibile  specificare il numero di passi da effettuare (default = 1 passo)
e  la  modalita' (default:mode=0).  Il modo 0 e' lievemente piu' veloce del
modo  1:   la  differenza  tra  loro sta nel fatto che nel modo 0 il bit di
trace  viene settato una volta sola, mentre nel modo 1 viene forzato a 1 ad
ogni   passo.    In   pratica   una   istruzione   del  tipo:   move  #0,sr
interromperebbe  il  processo  di  tracciamento in modo 0 ma non in modo 1.
Con  la  sintassi  @{B}T!@{UB}...   il  tracing  viene  effettuato  fino  a  che  un
determinato registro indirizzo non contiene il valore desiderato.  Il primo
parametro  rappresenta  il numero del registro in questione (0-7),mentre il
secondo  il  valore che deve assumere.  In questo e' possibile intercettare
con  estrema facilita' un qualsiasi accesso ad una determinata locazione!!!
Dalle  prove  effettuate  devo  dire  che  i  risultati  sono semplicemente
eccezionali! Il comandi @{B}T&@{UB} e @{B}T%@{UB} permettono il tracciamento condizionale,
ovvero che viene interrotto solo quando la condizione specificata dall'
utente  non  risulta  vera.  Il comando @{B}T&@{UB} puo' essere seguito da un numero
(il  default  e'  altrimenti  0)  compreso  tra  0  e  9  che indichera' il
corrispondente  simbolo di tipo @{I}CUSTOM FUNCTION @{UI}di nome C0-C9 contenente la
condizione da controllare ad ogni passo.  Alcuni simboli contengono gia dei
valori  predefiniti di comune utilita'.  L' utente puo', volendo ridefinire
anch'  essi.   Ricordo  ancora  una  volta  che  essi devono essere di tipo
CUSTOM-FUNCTION  e  che  pertanto vanno definiti con il comando @{"==" link ComDefSym}.  Infine
tener  presente  che  la  stringa  di  condizione  puo'  far  riferimento a
qualsiasi  altro  simbolo  o  funzione, ma che non tutti i simboli dinamici
vengono   aggiornati   allo  scopo  di  non  rallentare  eccessivamente  il
tracciamento:   i  simboli  dinamici  aggiornati  sono:   pc, e d0-d7/a0-a7
(a7=SSP)!   Con  il comando @{B}T%@{UB} la condizione va specificata direttamente di
seguito al comando, come suo parametro.
   Notare che se il programma 'tracciato' provoca o subisce (interrupt) una
eccezione,   il   tracing   viene   sospeso   fino   al  ritorno  alla  sua
esecuzione(RTE).   Per  questo  stesso  motivo,  effettuando il trace sotto
sistema, in multitasking, il tracciamento avviene solo nell'ambito del task
in  cui  e' iniziato.  Per informazioni sui task usare il comando @{"IT/N" link ComIT}.  Il
parametro  opzionale  '*',valido  per  tutti  i  tipi di trace, permette di
utilizzare  lo  speciale  Trace  del 68020 e superiori.  Un passo in questa
modalita' corrisponde anziche' alla successiva istruzione LM, al successivo
cambio  di  flusso del programma:  in pratica ogni qualvolta una istruzione
modifichi  direttamente  il  contenuto  del  PC  (RTS,JSR,JMP,Bcc,...).  In
pratica  il  flow-trace nel modo normale puo' venir impiegato per agevolare
il   debugging   di  un  programma,  mentre  con  l'  address-tracer  serve
essenzialmente  per  diminuire notevolmente i tempi di ricerca a scapito di
una   possibile   minor   precisione.    Ovviamente   questa  modalita'  e'
utilizzabile  solo  da chi possiede CPU adeguate (almeno un 68020).  Notare
che  sul  68040  il  flow-tracer  funziona  in  modo  sensibilmente diverso
rispetto al 68020/030.
  @{I}Il  trace  condizionale richiede una discreta quantita' di stack, per cui
evitare  di  impiegarlo  con programmi dotati di stack estremamente piccoli
(es:  <256 bytes).@{UI}
@endnode

@node ComK "SUPERVISOR® Documentation: Monitor/Comandi/Trace over"
                                @{U}@{B}Trace over@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}K@{UB}
Esegue  la  successiva  istruzione.   In  caso  di  chiamata  a  subroutine
(BSR/JSR)  il  programma  viene  ricongelato  solo  al  termine  della  sua
esecuzione:  in pratica il contenuto della subroutine non viene tracciato.
@endnode

@node ComKS "SUPERVISOR® Documentation: Monitor/Comandi/Skip instruction"
                             @{U}@{B}Skip instruction@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}KS@{UB}
L'  istruzione  indicata dal @{I}PC @{UI}non viene eseguita, facendo incrementare il
valore  del  Contatore  di  Programma  sino all' indirizzo dell' istruzione
successiva.
@endnode

@node ComKN "SUPERVISOR® Documentation: Monitor/Comandi/Put NOP"
                                  @{U}@{B}Put NOP@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}KN@{UB}
Mette  un  istruzione  @{I}NOP @{UI}al posto di quella correntemente puntata dal PC.
La  word  di memoria prima di essere alterata viene preventivamente copiata
nella @{"variabile" link VARS} @{B}NOPBAK@{UB}.
@endnode

@node ComKR "SUPERVISOR® Documentation: Monitor/Comandi/Do RTS"
                                  @{U}@{B}Do RTS@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}KR@{UB}
Simula  l'  effetto  di  una  istruzione RTS, prelevando una longword dallo
stack,  ponendola  nel  PC ed incrementando SP.  Attualmente questo comando
funziona solo quando il programma congelato si trova in USER MODE (il bit S
di SR non e' settato).
@endnode

@node ComTLINK "SUPERVISOR® Documentation: Monitor/Comandi/Link tracer"
                                @{U}@{B}Link tracer@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}T/[mode][,address]@{UB}
Permette di congiungere le routine di tracciamento di SV con altre esterne.
@{I}NOTA  BENE:   Questo  sistema  serve solo per il tracciamento ATTIVO (ossia
effettuato  da  SV  con  il comando TRACE(@{"T" link ComT})).  Per il tracciamento PASSIVO
(ossia  effettuato e gestito da programmi esterni, ma intercettato anche da
SV  occorre  inserire  il vettore di traccia nella lista di intercettazione
(@{U}>I$24@{UU})  ed abilitare l' intercettazione condivisa (@{">C" link ComPCON}) e quindi restituire
il  controllo  al  programma  esterno (@{"!!" link ComExit}).  E' inutile dire che i migliori
risultati si ottengono in modalita' @{U}FakeVBR.@{UU}@{UI}
Il  tracciamento  passivo  e'  utile  in  particolar  modo  quando si e' in
presenza di protezioni basate sul Trace-Encoding.

Utilizzato  senza parametri fornisce informazioni sullo stato del TraceLink
(attivato/disattivato,  indirizzo  Trace  Handler  esterno,  ecc...).  @{U}mode@{UU}
specifica il tipo di link da effettuare:

0=nessuno (disattiva il link)
1=SV trace handler viene attaccato in cima a quello esterno.  In pratica ad
  ogni  passo  SV  prende  il  controllo per primo.  Il parametro 'address'
  specifica l'indirizzo al quale deve essere passato il controllo alla fine
  di ogni passo.  In questa modalita' non occorrera' quasi mai utilizzarlo,
  poiche' SV e' in grado di ricavarsi da solo l'indirizzo del trace handler
  esterno, tramite il vettore di eccezione del TRACE.
2 e 3=SV  trace  handle  viene  attaccato  in  coda  a  quello esterno.  La
      differenza  tra  il  modo  2  e  3  sta  nella  maniera  in cui viene
      modificata  la routine esterna:  infatti, dal momento che deve essere
      quest'ultima a passare il controllo a SV al termine dell'elaborazione
      di  ciascun passo, essa deve essere opportunamente corretta.  Per far
      cio'  e  necessario  sostituire l'ultima istruzione della routine con
      un'istruzione  di  salto  che  passi il controllo a SV.  Normalmente,
      l'istruzione di uscita e' un RTE, lunga solo 16 bit (una parola), una
      istruzione  di salto ad indirizzo assoluto del tipo JMP <ea> e' lunga
      ben  3  word,  per  cui  si andrebbe ad alterare parte di cio' che si
      trova  oltra la routine in questione; per cui SV mette a disposizione
      due sistemi alternativi:
       A(modo2)-l'istruzione RTE viene sostituita dall'istruzione TRAP #$F.
                Il  vantaggio  sta  nel  fatto  che  TRAP  e'  della stessa
                lunghezza  di  RTE;  gli  svantaggi  stanno  in  una  minor
                velocita'  di  esecuzione  e nell'utilizzo di un vettore di
                TRAP, che deve quindi essere disponibile.
       B(modo3)-l'istruzione RTE viene sostituita con JMP <ea>.  I vantaggi
                consistono  in  una  maggior  velocita' di esecuzione e nel
                fatto che il vettore di trap rimane libero per altri scopi.
                Lo  svantaggio  e'  che  modificando la longword successiva
                all'istruzione   RTE   potrebbe   danneggiare  informazioni
                importanti per il programma esterno.
Il   parametro   'address'  specifica l' indirizzo  al  quale  deve  essere
effettuata  la  modifica (l'istruzione con cui termina il trace handler, in
pratica l' indirizzo al  quale si trova l' istruzione RTE).  Omettendolo SV
prova  a  cercarlo  da  solo.   Qualora il tentativo fallisse l'utente deve
necessariamente specificare il parametro 'address'.  Una volta abilitato il
link e' sufficiente utlizzare le istruzioni 'T' viste in precedenza.
@endnode

@node ComCapTask "SUPERVISOR® Documentation: Monitor/Comandi/Capture task"
                               @{U}@{B}Capture task@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!W[task]@{UB}
Seleziona il task da catturare.  Il parametro @{U}task@{UU} e' l' indirizzo del task
desiderato.   Se  omesso  viene  utilizzato l' indirizzo @{"corrente" link DCnote}.  Un buon
sistema  per  sfruttare  cio'  e' di visualizzare l' elenco task tramite il
comando  @{"IT" link ComIT},  e  poi  selezionare  un  task  specifico tramite @{"ITtaskname" link ComIT} o
@{"INtasknumber" link ComIT}  (i suddetti comandi effettuano tra l' altro, un aggiornamento
della  @{"variabile" link VARS}  @{"DC" link DCnote}), e quindi digitare il comando @{B}!W@{UB} senza parametri.  Il
task  deve  trovarsi  in  stato di @{I}attesa @{UI}(WAITING); al suo @{I}risveglio @{UI}viene
immediatamente  catturato  dal  freezer.   Assicurarsi  di aver attivato lo
switch @{"!M" link ComTask}.
@endnode

@node ComTracePC "SUPERVISOR® Documentation: Monitor/Comandi/Trace PC"
                                 @{U}@{B}Trace PC@{UB}@{UU}

  Il  PC-tracer  e'  un sistema che permette di mappare tutte le istruzioni
eseguite  dalla  CPU  entro  un' area di memoria prestabilita.  Utilizza un
doppio  buffer  in  modo  da  permettere  confronti  sul  comportamento del
programma  in  esame in situazioni diverse.  Con cio' si ha la possibilita'
di  conoscere  esattamente,  senza  il minimo sforzo ed in una quantita' di
tempo   insignificante,   anche   con   programmi   di   grosse  dimensioni
(Generalmente pochi secondi sono piu' che sufficienti!!!)!
  E'  bene  sapere  che sussistono differenze di funzionamento in base alla
CPU  presente:   lo  stack  frame  di  eccezione dei processori 68000/68010
permette  di  conoscere  solamente  la  successiva  istruzione da eseguire,
mentre  quello  degli  altri  processori  fornisce anche l' indirizzo dell'
istruzione  appena eseguita; SV utilizza quest' ultima informazione, quando
cio' e' possibile.  Da cio' risulta che con:
68020+ la mappa e' del tutto corretta;
68000/68010  la  prima  istruzione eseguita non e' presente nella mappa, l'
istruzione  successiva  all' ultima eseguita e' invece mappata.  Il che non
e'  nulla  di preoccupante, ma e' necessario esserne informati onde evitare
di trarre errate conclusioni.
  Il  PC-tracer  e'  disponibile anche agli utenti non registrati, anche se
faccio  notare  che  tutte  le routine di tracciamento (PC-tracer compreso)
nella versione dimostrativa sono notevolmente piu' lente.

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}T:[start][,end]@{UB}
Riprende  l'  esecuzione del programma congelato con il PC-tracer attivato.
I  parametri @{U}start@{UU} ed @{U}end@{UU} specificano una nuova zona di memoria da mappare.
Se presente solo @{U}start@{UU} l' intervallo e' definito come
@{U}start-pctwidth,start+pctwidth@{UU}
(@{U}pctwidth@{UU} e' una variabile ridefinibile dall' utente).
Se i parametri sono assenti e non e' presente alcuna mappa in memoria viene
assunto  @{U}start@{UU}=@{U}pc@{UU};  viene quindi mappata l' area compresa tra @{U}pc@{UU}-@{U}pctwidth@{UU} e
@{U}pc@{UU}+@{U}pctwidth@{UU}.
Utilizzato  senza  parametri quando una mappa e' gia' stata creata, provoca
la  realizzazione  della  mappa  di  confronto.   La zona considerata e' la
stessa.   In  caso  sia  gia'  presente anche la mappa di confronto, quest'
ultima  prende  il posto della prima, mentre quella nuove e' utilizzata per
il confronto.

Vedere anche i comandi @{"N" link ComN} ed @{"N!" link ComKillPCMap}.

NOTA:   il  PC-tracer  non  si  interrompe automaticamente, come le normale
modalita'  di  traccia, quando si verifica una condizione prestabilita.  E'
lasciato  all' utente il compito di effettuare il congelamento mediante gli
usuali  metodi  di attivazione del freezer.  Cio' e' a mio parere il metodo
piu'  efficiente.   L'  inconveniente  sta  nel fatto che il task congelato
rimane  con  il  flag  di  traccia  settato.  Se si riavvia il programma in
modalita'  normale,  cioe'  senza  il  gestore  di  eccezioni di traccia di
SUPERVISOR,  il  programma,  eseguita  la successiva istruzione, genera un'
eccezione  non  richiesta  con conseguente crash del sistema.  La soluzione
consiste  nell'  abilitare  l'  intercettazione  passiva (comando >I$24 del
monitor  o  tramite  la  procedura  di configurazione se si la vuol rendere
permanente; in questo caso vedere anche comando @{">>" link ComCPcfg}).
@endnode

@node ComKillPCMap "SUPERVISOR® Documentation: Monitor/Comandi/Kill PC map"
                                @{U}@{B}Kill PC map@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}N!@{UB}
Rimuove tutte le mappe create con il @{"PC-tracer" link ComTracePC}.
@endnode

@node ComN "SUPERVISOR® Documentation: Monitor/Comandi/Show PC map"
                                @{U}@{B}Show PC map@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}N[address]@{UB}
Mostra  la  mappa  creata con il @{"PC-tracer" link ComTracePC}.  address e' l' indirizzo da cui
deve  iniziare  l'  operazione.   Se  omesso  viene utilizzato l' indirizzo
@{"corrente" link DCnote}. Ogni linea di output e' costituita da:
· un   numero  esadecimale,  indicante  l'  indirizzo  iniziale  a  cui  si
  riferiscono le informazioni riportare nella linea stessa;
· una  sequenza  di caratteri, ciascuno rappresentante una word di memoria.
  I possibili caratteri sono:
    X la word non si trova nell' intervallo considerato nella mappa;
    . l' istruzione all' indirizzo considerato non e' stata eseguita;
    + l'  istruzione  all'  indirizzo considerato e' stata eseguita.  Se e'
      presente  il  buffer  di  confronto  questo  simbolo  indica  che  l'
      istruzione e' stata eseguita entrambe le volte;
    1 confronto: l' istruzione e' stata eseguita solo la prima volta;
    2 confronto: l' istruzione e' stata eseguita solo la seconda volta.

  Questo  comando e' dotato di @{I}auto-repeat;@{UI} cio' significa che terminata la
visualizzazione  e' sufficiente premere RETURN per visualizzare la mappa di
un'altra porzione di memoria.
@endnode

@node ComCheat "SUPERVISOR® Documentation: Monitor/Comandi/Trainer"
                                  @{U}@{B}Trainer@{UB}@{UU}

 Il  @{I}cercatrainer @{UI}non fa altro che ricercare tutti le locazioni di memoria,
nella  zona  indicata  dall'utente, o in quella di default (chipmemory), il
cui contenuto corrisponda al numero di vite (o energia, o che altro sia...)
indicato  dall'  utente.   Quando viene trovata piu' di una locazione viene
richiesto di riprendere il gioco, di perdere una o piu' vite, ricongelare e
indicare il nuovo numero di vite.  Tutte le locazioni trovate in precedenza
vengono ricontrollate per verificare quali di esse coincidano ancora con il
nuovo  numero  di  vite.   Il  ciclo  si ripete finche' non rimane una sola
locazione il cui contenuto sia uguale al numero di vite correnti.  Nel qual
caso  e'  quasi  certamente  il  conta-vite  cercato; modificandolo si puo'
alterare  a  piacimento  il  numero  di  vite.   SV  fornisce anche tutti i
riferimenti a  quell' indirizzo (relativi ed assoluti); in linea di massima
questi  dovrebbero essere parte delle istruzioni in Linguaggio Macchina che
si  occupano  di  gestire  le vite.  Modificandole si possono ottenere vite
infinite.   Le  vite  possono  essere memorizzate in vari formati; SV e' in
grado di riconoscere i seguenti:
0-@{I}BINARIO PURO @{UI}(default)
1-@{I}ASCII @{UI}
2-@{I}BCD @{UI}
 Qualora  non  si  riuscisse  a  trovare il trainer con un formato, si puo'
riprovare  con  gli  altri due.  Tener presente che alcune volte (in genere
quando  le  vite  sono espresse in forma di icone) la vita in uso non viene
conteggiata, per cui bisogna indicarne una di meno!
 Per lavorare, questa funzione ha bisogno di una certa quantita' di memoria
di lavoro  (variabile  in relazione alle dimensioni dell' area da cercare e
alla quantita'  di  dati  trovati).   L' utente  puo'  specificare  le  sue
dimensioni oppure lasciare il compito a SV.  Se il buffer non potesse venir
allocato  (non  c'e' abbastanza memoria esterna libera) la ricerca non puo'
venir  effettuata.   Se invece il buffer non dovesse essere sufficiente per
memorizzare  tutti i dati necessari (non e' possibile conoscere a priori le
esatte  dimensioni  del  buffer!)  la procedura continua, ma la ricerca non
viene effettuata per tutta l' area richiesta.

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}EI[lives][,mode][,start,end][,workmemorysize]@{UB}
Inizializza  il  cerca  trainer.   @{U}lives@{UU}  indica le vite che si possiedono.
@{U}mode@{UU}  la  modalita'  di  ricerca (descritta precedentemente).  @{U}start@{UU} ed @{U}end@{UU}
definiscono  l' area  di  ricerca.  @{U}workmemorysize@{UU} la dimensione (in bytes)
dell' area di lavoro.

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}ES[lives]@{UB}
Continua  la  ricerca  con  un  nuovo numero di vite.  Utilizzato quando il
cerca  trainer  non e' ancora inizializzato funziona come @{B}EI@{UB} (e accetta gli
stessi  parametri).   Dal  momento che questo comando puo' anche sostituire
@{B}EI@{UB},  quest'  ultimo e' necessario solamente quando si desidera rieffettuare
una nuova ricerca interrompendo quella gia' in corso.

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}EH[H]@{UB}
Fornisce  informazioni  sull'  andamento  della  ricerca.   Specificando il
parametro  @{I}H @{UI} si  ottengono  informazioni piu' approfondite, contenenti gli
indirizzi di tutti i possibili conta-vite trovati.

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}EQ@{UB}
Libera  la  memoria  utilizzata dal cercatrainer.  Ogni operazione in corso
viene  quindi  abbandonata.   Qualora la ricerca fallisca questa operazione
viene effettuata automaticamente.

Riassumiamo in breve:
1-Iniziare la partita e congelare
2-Inizializzare  il  trainer finder (@{B}EI@{UB}) specificando il numero di vite che
  si  possiede  (se  sono 3 non e' necessario), il metodo di ricerca (se si
  desidera  specificarlo), l' area  di  ricerca  (oppure lasciare che venga
  effettuata in  chip  memory), e la dimensione dell' area di lavoro (se si
  desidera specificarlo)
3-Il  procedimento ha inizio:  se non viene trovato niente riprovare con un
  altro  metodo  di ricerca oppure indicando una vita in meno di quelle che
  effettivamente  si  possiedono;  se  il  contavite  viene  trovato subito
  modificare il byte all'indirizzo che viene fornito per ottenere il numero
  di  vite desiderato, oppure sfruttare le informazioni fornite per rendere
  le vite infinite. Altrimenti passare al punto successivo
4-Riprendere il gioco, perdere qualche vita e ricongelare
5-Indicare  il  nuovo numero di vite (@{B}ESvite@{UB}) oppure digitare semplicemente
  @{B}ES@{UB}  se  le vite sono diminuite di una sola unita' dalla volta precedente.
  Ripetere dal punto 3.

 Questa  procedura puo' venir usata anche per trovare armi, energia e altre
cose del genere!
@endnode

@node ComRip "SUPERVISOR® Documentation: Monitor/Comandi/ST|NT|PT-Module Finder"
                          @{U}@{B}ST|NT|PT-Module Finder@{UB}@{UU}

  Questo  set  di  comandi permette la ricerca e la manipolazione di moduli
SoundTracker, NoiseTracker, ProTracker.

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}OD[start,end]@{UB}
 @{B}OF[start,end]@{UB}
Ricercano un modulo nell' area specificata (start,end) o nella memoria chip
come default.  OF effettua l' operazione piuttosto velocemente.  OD e' piu'
lento  ma  permette  di trovare anche moduli protetti (vale a dire senza la
stringa  di  identificazione @{B}M.K.@{UB}).  Con questo metodo e' possibile trovare
anche  moduli  ProRunner  (la  struttura  del  modulo  e'  la  medesima, ma
necessita  di  una  conversione  di  formato per poter essere ascoltato con
ST/NT/PT),  presenti in alcune Intro.  L' ultimo modulo trovato viene posto
nella variabile 'mod'.

@rem line 18
@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}OI[modaddr]@{UB}
Fornisce  informazioni su di un modulo.  @{I}modaddr @{UI}specifica l' indirizzo del
modulo;  se omesso viene utilizzato l' indirizzo posto nella variabile @{I}mod.@{UI}
Se specificato @{U}modaddr@{UU} viene posto nella variabile @{I}mod.@{UI}

@rem line 24
@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}OR[modaddr]@{UB}
Rimuove/reimposta   alternativamente  la  stringa  di  identificazione  del
modulo.   Se  si  rimuove  la  stringa di identificazione il modulo risulta
invisibile a molti altri Ripper e al comando @{B}OF@{UB}.  Reimpostarla e' invece d'
obbligo  per  l'  utilizzo del modulo sotto ST/NT/PRO-Tracker e sotto molti
Player.  Il parametro @{U}modaddr@{UU} funziona come nel comando @{B}OI@{UB}.

@rem line 32
@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}OP[modaddr]@{UB}
Suona un modulo situato in memoria chip (il modulo puo' essere ricercato in
qualsiasi  tipo  di  memoria,  ma  per poter essere ascoltato deve trovarsi
necessariamente in chip).  Il parametro 'modaddr' funziona come nel comando
OI.    La   routine   impiegata  per  l'  ascolto  del  modulo  deriva  dal
ProTracker2.3A.   I  cicli di ritardo basati sulla velocita' della CPU sono
stati rimossi (non piu' problemi sul mio A4000!), tuttavia l' esecuzione e'
basata  sulla  frequenza di scansione dello schermo, per cui tra NTSC e PAL
il  modulo  viene suonato a velocita' diversa.  (In fondo questo e' solo un
freezer, e non ho ritenuto opportuno di utilizzare un' altro timer CIA, con
relativo intserver).

@rem line 45
@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}OS@{UB}
Interrompe l' esecuzione di un modulo.

@rem line 49
@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}OC[modaddr]@{UB}
Come  gia'  notificato nel capitolo relativo, attualmente tramite SV non e'
possibile  salvare  dei dati su disco in forma di file.  In ogni caso anche
quando  sara' terminato il filehandler di SV, saranno accessibili solo le 4
unita'  a  floppy  da 3"1/2.  Per cui chiunque voglia salvare i propri dati
direttamente sul proprio HardDisk o che comunque trovi scomodo il formato a
'blocchi'   (del  quale  comunque  sara'  costretto  a  far  uso  in  molte
occasioni!), ha a disposizione questo comando.  Esso effettua una copia del
modulo  nella  propria memoria (assicurarsi di installare SV come programma
residente   e   con   una   memoria   esterna   di   dimensioni  adeguate).
Successivamente  sara' sufficiente ricaricare il programma 'mon'.  Anziche'
il  menu  di installazione verra' visualizzato un requester dal quale sara'
possibile  salvare il modulo dove si preferisce.  Leggere la documentazione
sull' installazione per maggiori informazioni.  @{B}***Questa operazione non e'
effettuabile nella versione dimostrativa!@{UB}
  L'  indirizzo  e  la lunghezza della copia del modulo sono indicati dalle
@{"variabili" link VARS} MODBAK e MODLEN.
  Il parametro @{U}modaddr@{UU} funziona come nel comando @{B}OI@{UB}.

@rem line 69
@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}OX@{UB}
Libera la memoria utilizzata per il backup del modulo (comando @{B}OC@{UB}).

---------------------------------------------------------------------------
@{B}NB@{UB}:  @{I} Anche  grafica  e  suono  possono essere protetti da @{UI}@{U}copyright@{UU}!@{I}  Cio'
significa  che  in  genere  e'  vietato  mettere  in circolazione materiale
estratto  da  programmi  che  non  sono  di pubblico dominio.  E' opportuno
tenere sempre ben presente questo fatto!@{UI}
---------------------------------------------------------------------------
@endnode

@node ComGRip "SUPERVISOR® Documentation: Monitor/Comandi/GfxRipper"
@next ComCM
                                 @{U}@{B}GfxRipper@{UB}@{UU}

	@{" Introduzione           " link ComGRInfo}
	@{" AutoSearch             " link ComGR2A}
	@{" Add data from coplst   " link ComGR2B}
	@{" Fetch data from coplst " link ComGR2C}
	@{" Ripper Info            " link ComGR2I}
	@{" Kill IFF|AllData       " link ComGR2K}
	@{" Show grdata            " link ComGR2L}
	@{" Make IFF               " link ComGR2M}
	@{" Resume AutoSearch      " link ComGR2N}
	@{" Get IFF size           " link ComGR2P}
	@{" Show current pic       " link ComGR2S}
	@{" Get current colmap     " link ComGR2U}
	@{" List pics              " link ComGR2V}

---------------------------------------------------------------------------
@{B}NB@{UB}:  @{I} Anche  grafica  e  suono  possono essere protetti da @{UI}@{U}copyright@{UU}!@{I}  Cio'
significa  che  in  genere  e'  vietato  mettere  in circolazione materiale
estratto  da  programmi  che  non  sono  di pubblico dominio.  E' opportuno
tenere sempre ben presente questo fatto!@{UI}
---------------------------------------------------------------------------
@endnode

@node ComGRInfo "SUPERVISOR® Documentation: Monitor/Comandi/GfxRipper/Introduzione"
@prev ComGRInfo
                         @{U}@{B}Introduzione al GfxRipper@{UB}@{UU}

  SUPERVISOR  e'  dotato di un eccellente sistema di ricerca di immagini in
memoria.    Il  tutto  puo'  essere  effettuato  in  maniera  completamente
automatica  o  con  interventi  manuali  da  parte dell' utente, in modo da
essere in grado di ottenere il meglio da ogni situazione possibile.
  Lo  scopo  di  questo  sistema  e' quello di poter catturare le schermate
grafiche presenti in memoria, e salvarle su disco in formato IFF.
  I file IFF devono innanzitutto essere creati in memoria: cio' puo' essere
effettuato ad un indirizzo assoluto prescelto dall' utente, e poi da questo
salvato  su  disco manualmente, oppure in un blocco di memoria allocato dal
monitor   stesso.    I  file  IFF  generati  in  quest'  ultimo  modo  sono
completamente  gestiti  dal monitor tramite una lista, la quale puo' essere
visualizzata,  acquisire  nuove  picture,  o  essere rimossa in parte o del
tutto.   Tramite  il  menu  @{"utility" link SVInstaller.guide/Util}  (che  agisce  sotto  sistema),  e' poi
possibile  salvare tutte immagini presenti in questa lista.  Nella versione
dimostrativa  non  e' presente questo menu, per cui il salvataggio dei file
su  disco  va effettuato manualmente.  Non mi dilunghero' in spiegazioni su
come  effettuare  questa  procedura (che a proposito puo' essere necessaria
anche  agli  utenti  registrati nel caso in cui sia necessario un reset per
tornare  al sistema, e SUPERVISOR, in seguito ad esso, ne risulti rimosso a
causa  della  distruzione  delle strutture di Exec in memoria), poiche' chi
non  ne  fosse  in  grado,  probabilmente non saprebbe neppure usare questo
programma!

  Il  ripper  si  avvale  di  una  struttura  dati, chiamata @{I}grdata,@{UI} da cui
ottiene  le  informazioni necessarie per generare i file IFF.  Tutti i dati
in  questa  struttura  possono  essere  immessi dall' utente, dal GfxRipper
stesso, o da entrambi.
  La  struttura  @{I}grdata @{UI} viene visualizzata con il comando @{"2L" link ComGR2L} e puo' essere
modificata  semplicemente  posizionandosi sui valori da alterare, digitando
quelli  nuovi  e premendo quindi RETURN (!  premere RETURN e' importante al
fine  di  memorizzare  le  modifiche fatte !  Come gia' detto RETURN agisce
solo  sulla  linea  su cui si trova il cursore, per cui esso va premuto per
OGNI linea alla quale siano stati apportati cambiamenti !)


@{B}La struttura grdata@{UB}:

@{I}.2LL@{UI}
;PIC:# 640,# 704,# 256,# 2,#  -8,#  -8, $A2000003
;PA1: 00023808 00028808
;COL00: 0AAA0AAA 00000000 0FFF0FFF 068B068B

o La  prima  linea  (@{B}PIC@{UB})  definisce  l' aspetto e il tipo di immagine.  E'
  costituita da 7 parametri:
  1-Indica la dimensione in pixel dello schermo e deve essere di dimensioni
    non  superiori  a  quelle del parametro successivo:  spesso l' immagine
    visualizzata   e'  di  dimensioni  inferiori  rispetto  all'  effettiva
    dimensione  della  pagina video.  Qualora si desideri invece salvare l'
    intera  pagina  effettivamente  importata  dal DMA si puo' porre questo
    parametro a 0.
  2-Indica  l'  effettiva  dimensione  in pixel di una linea video.  Questo
    parametro   e'   INDISPENSABILE   all'  individuazione  della  corretta
    fisionomia  dell'  immagine  e  deve essere variato con attenzione:  un
    aumento  o  una  diminuzione di questo paramentro deve corrispondere ad
    un'  altrettanta diminuzione o aumento, rispettivamente, del modulo, il
    quale, va ricordato, e' pero' espresso in byte.
  3-Indica  la  dimensione  verticale in pixel dell' immagine.  Puo' essere
    variato   a  piacimento  senza  problemi.   Attualmente  la  dimensione
    verticale  viene  calcolata  in risoluzione non interlacciata.  Qualora
    quindi  l'  immagine fosse interlacciata, il valore di questo parametro
    deve   corrispondere   alla  meta'  delle  linee  da  cui  e'  composta
    verticalmente  (es:  640x512 va indicata come 640x256).  Il file IFF e'
    comunque generato correttamente!
  4-Indica il numero di bitplane (e il conseguente numero di colori) da cui
    e' costituita la picture.
  5-Indica  il valore (puo' anche essere negativo) in byte da aggiungere al
    termine  di  ogni linea per ottenere l' indirizzo di quella successiva.
    Viene  in  genere settato con il valore contenuto nel registro BPL1MOD.
    Se  si  desidera  modificarlo occorre variare anche il parametro 2, per
    mantenere una corretta visualizzazione della stessa immagine.
  6-Ha la stessa funzione del precedente, ma mentre il 5) viene usato per i
    bitplane  dispari,  questo  viene  usato  per i  bitplane pari.  Il suo
    valore in genere corrisponde a BPL2MOD.
  7-I  primi  2 byte rappresentano BPLCON0, gli altri 2 FMODE(AGA).  Questo
    parametro  e'  utilizzato  per  determinare  alcune caratteristiche del
    display, come la risoluzione e la dimensione del data-fetch.
o La  linea  successiva  contiene  i  puntatori ai bitplane.  Il numero dei
  puntatori  e'  legato  al  terzo  parametro della prima linea, per cui se
  quest'  ultimo  vale  0,  non  essendoci  puntatori,  questa linea non e'
  neppure visualizzata.
o Le  linee  successive  rappresentano  i colori, il cui numero dipende dal
  numero  dei  bitplane  e dal modo grafico utilizzato (EHB, HAM o normale).
  La tabella dei colori  e'  visualizzata  solo  se  e' stato specificato il
  parametro   @{I}L @{UI}  con  il  comando  @{"2L" link ComGR2L}  (puo'  essere  indesiderato  vedere
  continuamente visualizzata una tabella con 256 colori!).

  Attualmente  il  GfxRipper  supporta tutti i modi NTSC e PAL escluso @{I}dual
playfield@{UI}.  I modi grafici programmabili non sono supportati.
  Le  schermate in dual playfield possono comunque essere salvate separando
ciascun  playfield manualmente, raggruppando prima i bitplane dispari e poi
quelli pari (con relativo banco di colori).

  Il  GfxRipper  e'  veramente  efficiente e versatile.  Nonostante cio' l'
utente  che  prova  a  servirsene  per  le prime volte puo' trovare qualche
difficolta' e scoraggiarsi presto.
  La  fonte  primaria  delle  difficolta'  puo'  essere spesso quella della
ricerca  della  copperlist  giusta.  Il copperlist finder e' attualmente il
migliore  esistente in circolazione, ma va 'tarato' correttamente a seconda
delle  cirostanze.   Il comando @{"UP" link ComCLF 29} permette di filtrare tutte le copperlist
trovate,  in  modo  da  escludere  quelle  che non rispondano a particolari
proprieta'!   Per questo occorre innanzitutto far pratica con esso.  Spesso
i  risultati  piu'  veloci  si  possono  ottenere  con  @{"UC" link ComCLF 15}  (ricerca  della
copperlist dal codice 680x0 del programma congelato).  In questo caso se si
teme  che  venga filtrata via qualche copperlist di troppo e' consigliabile
disattivare  il  copperlist  check (primo parametro impostato con @{"UP" link ComCLF 29}).  Un'
altra cosa importante e' sperimentare il GfxRipper in maniera veloce, senza
perdere   troppo   tempo,   in  modo  da  vedere  praticamente  i  principi
funzionamento ed impratichirsi nelle procedure da effettuare.  Per far cio'
si  puo'  provare a rippare lo schermo del workbench, purche' pero' si stia
utilizzando una modalita' video NTSC o PAL!

  Dalla  versione  1.28  di  SUPERVISOR  la copperlist attiva e' ottenibile
senza  alcun  problema  tramite  la nuova funzione @{"COPLC" link VARS}(), che fornisce il
contenuto dei registri COPxLC. (Es: @{"2B" link ComGR2B}COPLC(1) o @{"2C" link ComGR2C}COPLC(1))
@endnode

@node ComGR2A "SUPERVISOR® Documentation: Monitor/Comandi/GfxRipper/AutoSearch"
                                @{U}@{B}AutoSearch@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}2A[start,end]@{UB}
Ricerca  immagini  in  tutta  la  memoria  chip  o  nell' area indicata dai
parametri  @{U}start@{UU}  ed  @{U}end@{UU}.  Cio' viene effettuato dapprima individuando una
copperlist   (a   questo   proposito   e'  bene  ricordare  di  configurare
adeguatamente il Copperlist Finder, comando @{"UP" link ComCLF 29}), per poi da essa ricavare i
tutti  i  parametri  necessari  a  definire  la picture.  Essa viene quindi
visualizzata e l' utente puo' scegliere il da farsi tramite la pressione di
uno dei seguenti tasti:
 @{B}Y@{UB}: @{I}accetta la pic trovata;@{UI}
 @{B}N@{UB}: @{I}cerca la successiva;@{UI}
 @{B}M@{UB}: @{I}accetta e crea immediatamente il file IFF.@{UI}

@{B}IMPORTANTE@{UB}:   l' immagine non e' necessariamente identica al quella salvata
in  formato IFF:  ad esempio, se e' molto grande ne viene mostrata solo una
parte,  (piu'  che sufficiente a dare un' idea di cosa si tratti); tuttavia
il  file  generato  risulta molto piu' accurato.  In caso venga trovata una
picture  non  visualizzabile  con  il  chipset  che si dispone (e' alquanto
improbabile,  poiche'  non  ha senso che un programma generi una copperlist
che  non  possa  utilizzare),  viene emesso un messaggio, che informa della
cosa e richiede se si vuol procedere comunque:  in pratica il file IFF puo'
essere ugualmente creato, indipendentemente dal fatto che l' immagine sia o
meno  adatta  a  chip  grafici  correnti.   Cio'  e'  utile in quanto molti
pic-viewer  in  circolazione  adattano  automaticamente l' immagine ai modi
grafici supportati dalla macchina su cui girano.

  La  copperlist puo' contenere parametri insufficienti:  in questo caso l'
utente deve intervenire manualmente.  Vediamo alcuni casi in particolare.

o @{U}Manca la tabella dei colori@{UU}:  se la pic in questione e' la stessa che era
visualizzata  nel  momento  in  cui  si e' effettuato il congelamento (cosa
estremamente  probabile),  e  si  dispone del chipset AGA, i colori possono
essere  ottenuti direttamente dai registri dei colori usando il comando @{"2U" link ComGR2U}.
Nel  malaugurato  caso  in  cui  non  si  disponga  di chipset AGA, occorre
ricercare la tabella attraverso il programma congelato (ci si puo' avvalere
del  comando  @{"UA" link ComUA}$dff180)  e  poi  immettere manualmente i colori trovati in
@{I}grdata @{UI} (non  dovrebbe  richiedere  molto  tempo:  sotto ECS o OCS i colori
sono, nel peggiore dei casi, 32!)
o @{U}Mancano le dimensioni@{UU}:  quella verticale non e' mai un problema:  si puo'
usare  il valore che si preferisce; quella orizzontale, nel caso in cui non
si riesca a dedurla ad occhio (nel caso in cui corrisponda allo schermo del
programma  congelato  si  puo'  usare @{"UT" link ComCLF} per esaminarla con calma), occorre
sbirciare nel programma congelato, magari servendosi di @{"UA" link ComUA}$dff092
o @{U}Manca il parametro sulla risoluzione@{UU}:  questo non dovrebbe essere affatto
un problema!
@endnode

@node ComGR2B "SUPERVISOR® Documentation: Monitor/Comandi/GfxRipper/Add picdata from coplst"
                          @{U}@{B}Add picdata from coplst@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}2Bcopperlist[,end]@{UB}
Simile  al  comando @{"2A" link ComGR2A}, solamente che la copperlist anziche' essere cercata
e'  specificata  dall'  utente  con il paramentro @{U}copperlist@{UU}.  Il parametro
@{U}end@{UU}, serve a terminare l' acquisizione dati in un punto diverso dal normale
termine  della  copperlist.   Cio'  e'  utile  in particolar modo quando la
copperlist contiene informazioni per piu' display attaccati l' uno sotto l'
altro:   in questo caso verrebbe acquisita solamente la bitmap situata piu'
in  basso,  in  quanto  i  dati  relativi  ad  essa rimpiazzerebbero quelli
precedenti  (i  registri  usati sono gli stessi, ma con valori differenti).
Grazie  a  questo  parametro  e'  possibile  scegliere selettivamente quale
immagine si preferisce.
  @{I}Questo comando differisce dal comando @{"2C" link ComGR2C} in quanto permette di AGGIUNGERE
informazioni a quelle gia' presenti precedentemente.@{UI}
@endnode

@node ComGR2C "SUPERVISOR® Documentation: Monitor/Comandi/GfxRipper/Fetch picdata from coplst"
                         @{U}@{B}Fetch picdata from coplst@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}2Ccopperlist[,end]@{UB}
Simile  al  comando @{"2A" link ComGR2A}, solamente che la copperlist anziche' essere cercata
e'  specificata  dall'  utente  con il paramentro @{U}copperlist@{UU}.  Il parametro
@{U}end@{UU}, serve a terminare l' acquisizione dati in un punto diverso dal normale
termine  della  copperlist.   Cio'  e'  utile  in particolar modo quando la
copperlist contiene informazioni per piu' display attaccati l' uno sotto l'
altro:   in questo caso verrebbe acquisita solamente la bitmap situata piu'
in  basso,  in  quanto  i  dati  relativi  ad  essa rimpiazzerebbero quelli
precedenti  (i  registri  usati sono gli stessi, ma con valori differenti).
Grazie  a  questo  parametro e' possibile scegliere quale selettivamente l'
immagine che si preferisce.
  Questo  comando  differisce  dal  comando  @{"2B" link ComGR2B}  in  quanto NON permette di
AGGIUNGERE  informazioni  a quelle gia' presenti precedentemente:  prima di
attingere  i  dati dalla copperlist, i parametri principali della struttura
@{I}grdata @{UI} (vedi  @{"Introduzione" link ComGRInfo}) sono inizializzati tramite i valori di default
del freezer (vedi @{"variabili" link VARS} @{I}bplcon01, diw, ddf@{UI} e @{I}fmode@{UI}).
@endnode

@node ComGR2I "SUPERVISOR® Documentation: Monitor/Comandi/GfxRipper/Ripper Info"
                                @{U}@{B}Ripper Info@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}2I@{UB}
Fornisce informazioni sul GfxRipper.
@endnode

@node ComGR2K "SUPERVISOR® Documentation: Monitor/Comandi/GfxRipper/Kill IFF|AllData"
                             @{U}@{B}Kill IFF|AllData@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}2K[pic#]@{UB}
Senza  parametri  libera  tutta  la  memoria usata dal GfxRipper e con essa
tutti  gli eventuali moduli IFF memorizzati (in questo caso viene richiesta
conferma  se lo switch @{"Safety" link ComSaf} e' attivo).  Indicando il numero d' ordine di
una  pic,  come  mostrato nella lista ottenuta col comando @{"2V" link ComGR2V}, questa viene
rimossa, e la memoria da essa occupata resa di nuovo disponibile.
@endnode

@node ComGR2L "SUPERVISOR® Documentation: Monitor/Comandi/GfxRipper/Show grdata"
                                @{U}@{B}Show grdata@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}2L[L]@{UB}
Visualizza  la  struttura  @{I}grdata @{UI} (vedi  @{"Introduzione" link ComGRInfo}  al  gfxripper).  La
tabella dei colori viene mostrata solo se presente il parametro @{I}L@{UI}.
@endnode

@node ComGR2M "SUPERVISOR® Documentation: Monitor/Comandi/GfxRipper/Make IFF"
                                 @{U}@{B}Make IFF@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}2M[address]@{UB}
Crea  un  modulo  IFF  all'  indirizzo  specificato  dal parametro address,
oppure,  se  quest'  ultimo e' omesso, in un blocco di memoria allocato dal
monitor,  ed  in  piu' inserito in nella lista delle pic da salvare tramite
@{"utility" link SVInstaller.guide/Util}  menu.   (L'  indirizzo  del blocco puo' essere ottenuto tramite il
comando @{"2I" link ComGR2I}).
NB:   ogni nuova IFFpic viene inserita al primo posto nella lista!  Cio' e'
da  tener  presente in particolare quando si desidera rimuovere un elemento
dalla lista con il comando @{"2K" link ComGR2K}!
@endnode

@node ComGR2N "SUPERVISOR® Documentation: Monitor/Comandi/GfxRipper/Resume AutoSearch"
                             @{U}@{B}Resume AutoSearch@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
  @{B}2N@{UB}
Riprende la ricerca automatica iniziata con il comando @{"2A" link ComGR2A} dal punto in cui
la  si  e'  interrotta.   (Il  comando @{"2I" link ComGR2I} fornisce l' indirizzo al quale e'
terminata l' ultima ricerca).
@endnode

@node ComGR2P "SUPERVISOR® Documentation: Monitor/Comandi/GfxRipper/Get IFF size"
                               @{U}@{B}Get IFF size@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}2P@{UB}
Fornisce  la lunghezza del file IFF che verrebbe creato con le impostazioni
correnti.
@endnode

@node ComGR2S "SUPERVISOR® Documentation: Monitor/Comandi/GfxRipper/Show current pic"
                             @{U}@{B}Show current pic@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}2S@{UB}
Visualizza l' immagine relativa alle impostazioni correnti.
@{B}IMPORTANTE@{UB}:   l' immagine non e' necessariamente identica al quella salvata
in  formato IFF:  ad esempio, se e' molto grande ne viene mostrata solo una
parte,  (piu'  che sufficiente a dare un' idea di cosa si tratti); tuttavia
il  file  generato  risulta molto piu' accurato.  In caso venga trovata una
picture  non  visualizzabile  con  il  chipset  che si dispone (e' alquanto
improbabile,  poiche'  non  ha senso che un programma generi una copperlist
che  non  possa  utilizzare),  viene emesso un messaggio, che informa della
cosa e richiede se si vuol procedere comunque:  in pratica il file IFF puo'
essere ugualmente creato, indipendentemente dal fatto che l' immagine sia o
meno  adatta  ai  chip  grafici  correnti.   Cio'  e' utile in quanto molti
pic-viewer  in  circolazione  adattano  automaticamente l' immagine ai modi
grafici supportati dalla macchina su cui girano.
@endnode

@node ComGR2U "SUPERVISOR® Documentation: Monitor/Comandi/GfxRipper/Get current colmap"
                            @{U}@{B}Get current colmap@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}2U@{UB}
(AGA)  Compila  la  tabella  dei  colori con quelli usati nello schermo del
programma congelato.
@endnode

@node ComGR2V "SUPERVISOR® Documentation: Monitor/Comandi/GfxRipper/List pics"
@next ComGR2V
                                 @{U}@{B}List pics@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}2V@{UB}
Visualizza l' elenco di tutte le IFFpicture in memoria.
@endnode

@node ComCM "SUPERVISOR® Documentation: Monitor/Comandi/Compare"
@prev ComGRip
                                  @{U}@{B}Compare@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}CMstart,end,destination@{UB}
Confronta  due blocchi di memoria, riportando tutti gli eventuali indirizzi
contenenti  valori  differenti.   @{U}start@{UU}  e  @{U}end@{UU} rappresentano gli indirizzi
entro  i  quali  e'  compreso  il  primo  blocco  di  memoria,  destination
rappresenta l' indirizzo al quale ha inizio il secondo blocco.
@endnode

@node ComCO "SUPERVISOR® Documentation: Monitor/Comandi/Copy"
                                   @{U}@{B}Copy@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}COstart,end,destination@{UB}
Copia  un  blocco  di  memoria all' indirizzo  specificato.   @{U}start@{UU}  e  @{U}end@{UU}
rappresentano  gli  indirizzi  entro i quali e' compreso il primo blocco di
memoria, destination rappresenta l' indirizzo al quale ha inizio il secondo
blocco.
@endnode

@node ComF "SUPERVISOR® Documentation: Monitor/Comandi/Find data"
                                 @{U}@{B}Find data@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}Fstart,end,data[,H/O]@{UB}
Ricerca  una  stringa  in  memoria.   @{U}start@{UU}  ed  @{U}end@{UU}  sono  i parametri che
delimitano l' area  in  questione.   @{U}data@{UU}  e'  la  stringa  di caratteri da
cercare.  Se @{U}data@{UU} e' espresso in esadecimale, binario, ASCII o assembly, la
stringa  puo' essere di qualsiasi lunghezza che possa entrare nel buffer di
linea;  la  stringa  viene  allineata  a  destra, per cui non e' necessario
specificare  degli zeri non significativi per completare il primo byte.  In
decimale,ottale,  ecc...  puo' essere al massimo lunga una longword(32bit):
il  programma  scomporra' automaticamente il numero nella quantita' di byte
necessari.   I parametri opzionali @{I}H @{UI}ed @{I}O @{UI}(l' uno esclude l' altro) servono
ad  effettuare  una  ricerca  molto accurata (Heavy Search), permettendo di
trovare  anche  dati  protetti.   Al  termine  della  ricerca, se portata a
termine  con  risultati  positivi,  viene  indicato il modo migliore per la
decodifica  della  stringa  e i parametri da usare per la decodifica con il
comando @{"&" link ComEnc}.
@endnode

@node ComFM "SUPERVISOR® Documentation: Monitor/Comandi/Find data"
                                 @{U}@{B}Find data@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}FMstart,end,data[,mask][,firstmaskablechar,lastmaskablechar]@{UB}
Ricerca  una  stringa stringa di dati in memoria.  I parametri @{U}start@{UU}, @{U}end@{UU} e
@{U}data@{UU}  sono  gli stessi del comando @{"F" link ComF}, come pure e' molto simile la funzione
svolta.   Ma  mentre @{"F" link ComF} ha facilitazioni sulla ricerca dati protetti, questo
permette  di  applicare  una  maschera  alla  stringa da trovare in modo da
escludere  alcuni  sui  bit  o interi byte dal confronto.  @{U}mask@{UU} rappresenta
appunto la maschera da applicare a tutta la stringa @{U}data@{UU}.  Qualora fosse di
dimensioni inferiori a @{U}data@{UU} essa viene automaticamente replicata piu' volte
in modo da raggiungere le stesse dimensioni di @{U}data@{UU}.  Se risulta piu' lunga
la  parte  in eccedenza viene ignorata.  I parametri @{U}first/lastmaskablechar@{UU}
indicano  rispettivamente  il  primo  e  l'  ultimo carattere ai quali deve
essere applicata la maschera.
  I  default  variano  in  base al tipo di dato da cercare.  Se @{U}data@{UU} e' una
stringa  ASCII  (es:   "text")  la maschera di default e' $5F e i caratteri
mascherabili  sono  "A"  -  "z"!$80  (permettendo  cosi'  di  trovare  si i
caratteri  maiuscoli  che quelli minuscoli), altrimenti (es:  $DEADCODE) la
maschera  di  default  e'  $FF  e  tutti i caratteri sono resi mascherabili
(0-$FF).   Attenzione:   @{U}first/lastmask@{UU}...  hanno come default $5F-$FA solo
se  e' si sta usando anche la maschera di default (in pratica se sono stati
specificati  solo  i primi tre parametri), per tutti gli altri casi il loro
default e' 0-$ff.
  Per  la  ricerca  di  stringhe  di  testo questo comando e' di gran lunga
preferibile ad @{"F" link ComF}.
  Nella  @{"VERSIONE REGISTRATA" link Notice} questo comando utilizza routine ottimizzate in
base ai parametri specificati, risultando spesso molto piu' veloce rispetto
alla @{"VERSIONE DIMOSTRATIVA" link Notice}.
  FM supporta il @{"MemoryManager" link MemManager}.
@endnode

@node ComFA "SUPERVISOR® Documentation: Monitor/Comandi/Find address"
                               @{U}@{B}Find address@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}FA[address]@{UB}
Ricerca  tutti i possibili riferimenti (assoluti e relativi) all' indirizzo
specificato da @{U}address@{UU} o a quello @{"corrente" link DCnote}.
@endnode

@node ComUA "SUPERVISOR® Documentation: Monitor/Comandi/Find changes"
                               @{U}@{B}Find changes@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}UA[address][,start,end]@{UB}
Ricerca  in  un  programma  le  istruzioni @{I}MOVE @{UI}che alterano un determinato
indirizzo.   @{U}address@{UU}  specifica  l'  indirizzo  della locazione desiderata;
@{U}start@{UU} ed @{U}end@{UU} (devono essere presenti o omessi entrambi) indicano l' area di
ricerca.  Per default la ricerca avviene nella zona intorno al @{I}PC @{UI}corrente.
Questo  comando  e'  in  grado  di  leggere ed interpretare un programma in
codice macchina.
@endnode

@node ComFD "SUPERVISOR® Documentation: Monitor/Comandi/Find disassembly"
                             @{U}@{B}Find disassembly@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}FDstart,end,data@{UB}
Ricerca  una  istruzione o parte di essa nell' ambito della zona di memoria
specificata  da  @{U}start@{UU}  e  @{U}end@{UU}.  La ricerca avviene disassemblando tutte le
istruzioni a partire dall' indirizzo specificato e confrontandole con @{U}data@{UU}.
data puo' contenere i seguenti caratteri speciali:
@{B}@@{UB}	indica che l' intera stringa va ricercata solamente nel campo degli
	operandi dell' istruzione;
@{B}?@{UB}	sostituisce un qualsiasi carattere;
@{B}*@{UB}	sostituisce una qualsiasi sequenza di caratteri;

** NOTA: se  il disassembly simbolico attivo (vedi comando @{"1" link Com1}) la ricerca e'
effettuata   in   modalita'  CASE-SENSITIVE  (i  caratteri  maiuscoli  sono
considerati  distinti dai corrispondenti minuscoli), per cui in questo caso
occorre far bene attenzione a scrivere i nomi delle istruzioni in MINUSCOLO
e i registri in maiuscolo.

@{I}Esempi:@{UI}
FD,chip,move*.l
FD,chip,@d0
FD,chip,move.w $180*
FD,chip,sub*.? *,d1
FDpc-$1000,pc+$1000,adda.? *MyL?b*,A5
@endnode

@node ComFdKey "SUPERVISOR® Documentation: Monitor/Comandi/Find encryption key"
                            @{U}@{B}Find encryption key@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}&&start,end,data1[,data2]@{UB}
Permette di trovare una chiave di 16 o 32 bit per la decodifica di dati con
or  esclusivo.   @{U}start@{UU}  ed  @{U}end@{UU}  indicano  l'  area  da  cercare.  @{U}data1@{UU} va
utilizzato per la ricerca di chiave di 16 bit, mentre @{U}data1@{UU} e @{U}data2@{UU} insieme
vanno  impiegati  per  chiavi a 32 bit.  Questi due parametri rappresentano
ciascuno  quattro  byte consecutivi che l' area da decodificare contiene in
un  punto  qualsiasi.   @{U}data2@{UU}  (se  utilizzato) deve contenere altri 4 byte
CONSECUTIVI   a   @{U}data1@{UU}.    NOTA:    l'  operazione  viene  effettuata  con
allineamento  a  WORD,  per  cui  qualora  si fornissero come @{I}data @{UI}stringhe
ASCII,  l' operazione puo' dover essere ripetuta due volte provando diversi
allineamenti  di byte (es:  se "dos.library" si trova ad indirizzo pari, la
chiave viene trovata con @{I}data1="dos." @{UI}e @{I}data2="libr",@{UI} mentre se si trova ad
indirizzo  dispari,  i  parametri  dovranno essere del tipo:  @{I}data1="os.l",@{UI}
@{I}data2="ibra"@{UI}).
@endnode

@node ComUB "SUPERVISOR® Documentation: Monitor/Comandi/Find references"
                              @{U}@{B}Find references@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}UB[address][,start,end]@{UB}
Ricerca  in  un programma le istruzioni @{I}MOVE @{UI}e @{I}LEA @{UI}che fanno riferimento ad
un  determinato  indirizzo.  @{U}address@{UU} specifica l' indirizzo della locazione
desiderata;  @{U}start@{UU}  ed  @{U}end@{UU}  (devono  essere  presenti  o  omessi entrambi)
indicano  l'  area  di  ricerca.  Per default la ricerca avviene nella zona
intorno  al  @{I}PC @{UI} corrente.   Questo  comando  e'  in  grado  di  leggere ed
interpretare un programma in codice macchina.
@endnode

@node ComFR "SUPERVISOR® Documentation: Monitor/Comandi/Find Relative"
                               @{U}@{B}Find Relative@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}FRaddress[,mode][,limit]@{UB}
Cerca un riferimento relativo all' indirizzo indicato.  @{U}address@{UU} rappresenta
l'  indirizzo  al  quale  devono  puntare  gli  operandi da trovare.  @{U}mode@{UU},
opzionale  (default  0)  specifica  le caratteristiche che devono avere gli
operandi in questione.

0-@{I}codici CPU:@{UI} (gli  indirizzi che verranno trovati molto probabilmente sono
              parte di istruzioni 680x0)
1-@{I}tabelle:@{UI} si  mira  a trovare elementi di tabelle di offset, con puntatori
           relativi  alla posizione del puntatore stesso.  In assembler una
           tabella del genere sarebbe scritta nel modo:
           dc.b/w/l data1-*,data2-*,....
            oppure
           dr.b/w/l data1,data2,....
2-@{I}tabelle:@{UI} per tabelle con puntatori relativi ad un indirizzo assoluto.  In
	   questo caso viene assunto viene assunto che le tabelle puntino a
	   stringhe  di  testo  terminanti  con  un  NULL  ($00).   Bisogna
	   specificare  con  il  parametro  @{U}limit@{UU} il numero di elementi che
	   dovrebbe  contenere la tabella (approssimare sempre per difetto,
	   mai  per  eccesso).  @{U}address@{UU} indica la prima stringa di testo di
	   questa tabella.

3-@{I}tabelle:@{UI} per tabelle con puntatori relative ad un indirizzo assoluto.  In
	   questo  caso  i  dati  a cui puntano le tabelle da ricercare non
	   devono    essere   necessariamente   stringhe   di   testo,   e'
	   indispensabile  pero'  un  certo  aiuto  da  parte dell' utente.
	   @{U}address@{UU}  specifica  il primo elemento puntato dalla tabella; gli
	   altri elementi vengono richiesti successivamente dal monitor.

@{I}Occorrono   almeno   2  elementi  i modi 3 e 4.@{UI}
@endnode

@node ComFI "SUPERVISOR® Documentation: Monitor/Comandi/Fill"
                                   @{U}@{B}Fill@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}FIstart,end[,data]@{UB}
Riempie  un  area  di  memoria  con  il  pattern specificato.  @{U}start@{UU} ed @{U}end@{UU}
delimitano l' area  in questione.  @{U}data@{UU} (se omesso viene assunto $00) segue
le stesse indicazioni del comando @{"Find" link ComF}.
@endnode

@node ComEnc "SUPERVISOR® Documentation: Monitor/Comandi/Encode memory"
                               @{U}@{B}Encode memory@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}&start,end,eor,sub[,mode]@{UB}
(De)codifica  la  zona  di  memoria specificata da @{U}start@{UU} ed @{U}end@{UU}.  @{U}eor@{UU} e @{U}sub@{UU}
sono le due costanti da impiegare nella decodifica.  @{U}mode@{UU} indica il tipo di
decodifica  da  effettuare:   puo'  valere  0  o  1; 0 e' il default e puo'
pertanto essere omesso.
Questo  comando  andrebbe  usato insieme all' @{"HeavyFind" link ComF}, per decodificare i
dati da esso trovati.  Come trovare dati protetti ed effettuarvi modifiche:
1-Usare  il  comando  @{"F" link ComF}  con  il  parametro  @{I}H.@{UI}  Riprovare con @{I}O @{UI}in caso di
  risultati negativi.
2-Decodificare  l' area con i parametri forniti dal comando precedente.  La
  zona  di  memoria  puo'  anche  essere indicata (@{U}start@{UU} ed @{U}end@{UU}) in maniera
  approssimata,  l'  importante  e' pero' riutilizzare gli stessi parametri
  (start ed end) per la ricodifica della stessa nel passo 4.
3-Apportare le modifiche desiderate.
4-Ricodificare  l'  area utilizzando gli STESSI parametri @{U}start@{UU}, @{U}end@{UU} ed @{U}eor@{UU}
  utilizzati nel passo 2.  Il parametro @{U}sub@{UU} va complementato(@{U}-sub@{UU}), @{U}mode@{UU} va
  commutato (se 0 in 1, se 1 in 0).
@endnode

@node ComM "SUPERVISOR® Documentation: Monitor/Comandi/Poke"
                                   @{U}@{B}Poke@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}M[B/W/L]address,value@{UB}
Mette  @{U}value@{UU}  nella  locazione  @{U}address@{UU}.   @{I}B,W,L@{UI}  stanno  per Byte, Word  e
Longword,   il  default  e'  @{I}W.@{UI}   Funziona  come  'poke'  sul  c64.   Utile
particolarmente per i registri hardware.
@endnode

@node ComQ "SUPERVISOR® Documentation: Monitor/Comandi/Hex Dump"
                                 @{U}@{B}Hex Dump@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}Q[start][,end]@{UB}
Visualizza  il  contenuto  di  un'area di memoria in formato esadecimale ed
ASCII.   Ogni  linea  contiene l' indirizzo  del  primo byte, 4 longword in
esadecimale,  16  caratteri  ASCII.   In  base  al  settaggio  dello switch
@{"ASCII/RAWKEY" link ComRAW},  i  byte  vengono visualizzati come ASCII o come codici della
tastiera.   Molte  volte  le  parole che servono ad abilitare il cheat mode
sono  memorizzate in questo formato.  Normalmente chi non ricorda a memoria
tutti  i  codici della tastiera deve ricorrere alla noiosa consultazione di
tabelle; in questo modo invece e' sufficiente dare una sbirciata con questo
comando.   I  parametri  @{U}start@{UU}  e  @{U}end@{UU} specificano la zona da visualizzare.
Omettendo @{U}start@{UU} viene utilizzato l' indirizzo @{"corrente" link DCnote}. Omettendo @{U}end@{UU} viene
visualizzato  un  numero  ottimale  di  linee.  Questo comando e' dotato di
@{I}auto-repeat.@{UI}   L'  output  e'  editabile dall'utente.  Utilizzando il tasto
BACKRETURN   si   puo'  effettuare  l' editing all' indietro.   Notare  che
attualmente  non  e'  possibile  modificare  la  parte testuale qualora sia
attivato il modo @{"RAWKEY" link ComRAW}.
  Il @{"MemoryManager" link MemManager} e' supportato.
@endnode

@node ComS "SUPERVISOR® Documentation: Monitor/Comandi/Show Memory"
                                @{U}@{B}Show Memory@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}S[address][,modulo][,mode]@{UB}
Visualizza  graficamente il contenuto della chip memory.  Utile per cercare
immagini in  memoria.  @{U}address@{UU} rappresenta l' indirizzo di partenza; se non
specificato  viene  utilizzato  l'  @{"indirizzo corrente" link DCnote}. @{U}modulo@{UU} e' il modulo
del bitplane visualizzato; se non e' specificato, come default viene preso
il  valore della @{"variabile" link VARS} @{B}bplmod@{UB}.  Con il mouse ci si sposta attraverso la
memoria, i due pulsanti permettono di modificare il modulo; il pulsante del
joystick  lo  riazzera.   Premendo  i tasti @{I}L @{UI}e @{I}H @{UI}si passa tra bassa e alta
risoluzione.    Poiche'   il   registro  BPLCON1  e'  write  only  e  viene
necessariamente utilizzato da SV, questo comando puo' essere utilizzato per
il  ripristino,  in  caso  di  necessita', di questo registro hardware.  Al
termine  della  procedura  (tasto  CTRL) il valore del modulo settato dall'
utente  viene memorizzato nella @{"variabile" link VARS} @{B}bplmod@{UB}, utilizzata poi al momento
dello scongelamento.
@endnode

@node ComAlloc "SUPERVISOR® Documentation: Monitor/Comandi/Alloc memory"
                               @{U}@{B}Alloc memory@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}(size[,flags]@{UB}
Alloca  una blocco di memoria delle dimensioni richieste.  @{U}size@{UU} rappresenta
la  lunghezza  del  blocco  in bytes, i @{U}flag@{UU} sono gli stessi della funzione
Exec/AllocMem().  La memoria ottenuta dalla funzione fa parte della memoria
@{"esterna" link SVInstaller.guide/Tech}  di  SV.   Questa funzione viene per lo piu' usata internamente, ma
puo' essere d' aiuto anche all'utente qualora avesse bisogno di una zona di
memoria  sicura  per  effettuare  una  certa  operazione,  senza correre il
rischio  di  alterare  il  programma  congelato.  Il puntatore al blocco di
memoria  e  le  sue  dimensioni  vengono visualizzate (in caso di riuscita)
subito  dopo all' immissione  del comando, e possono essere successivamente
richiamati tramite le due @{"variabili" link VARS} @{I}MEM @{UI}e @{I}LEN.@{UI}
@endnode

@node ComFree "SUPERVISOR® Documentation: Monitor/Comandi/Free memory"
                                @{U}@{B}Free memory@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B})[segment,size]@{UB}
Restituisce un blocco di memoria.  Omettendo i due parametri viene liberato
l'  ultimo blocco allocato dall'utente (se disponibile).  @{U}segment@{UU} indica l'
indirizzo  del primo byte del blocco, @{U}size@{UU} le sue dimensioni (in bytes).  I
due  parametri possono essere omessi solo i coppia.  E' importante liberare
la  memoria allocata quando si e' finito di utilizzarla, poiche' essa viene
resa  di  nuovo  disponibile ad un possibile uso da parte di altre funzioni
del monitor.
IMPORTANTE: la memoria liberata deve essere la stessa allocata dal comando
@{"(" link ComAlloc} e con identiche dimensioni (@{U}size@{UU})!
@endnode

@node ComRelE "SUPERVISOR® Documentation: Monitor/Comandi/Relocate Executable"
                            @{U}@{B}Relocate Executable@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}+start,destination[,relocbase]@{UB}
Riloca  un programma.  Il programma deve essere nel formato richiesto dalla
funzione  DOS  LoadSeg()  (executable).  @{U}start@{UU} indica l' indirizzo a cui si
trova  il  il  modulo  da rilocare.  @{U}destination@{UU} l' indirizzo al quale deve
essere  rilocato (non c' e' default, poiche' rilocarlo automaticamente allo
stesso  indirizzo di origine puo' essere pericoloso in caso di sezioni BSS,
le  quali potrebbero far si' che il programma destinazione finisca sopra ai
dati  sorgenti prima che essi vengano letti:  deve percio' essere l' utente
a  saper  valutare la zona ideale per la rilocazione).  L' ultimo parametro
indica ripetto a quale indirizzo deve essere effettuata la rilocazione.  Se
omesso viene usato l' indirizzo @{U}destination@{UU}.
@endnode

@node ComRelB "SUPERVISOR® Documentation: Monitor/Comandi/Relocate Binary"
                              @{U}@{B}Relocate Binary@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}++start,end,modulo,rangestart,rangeend,excludestart,excludend@{UB}
Riloca programma e/o dati in che si trovano in forma binaria pura.  @{U}start@{UU} e
@{U}end@{UU} indicano la zona di memoria in cui effettuare l' operazione.  @{U}modulo@{UU} e'
il  valore  da  aggiungere  a  tutti gli indirizzi assoluti di 32bit che si
trovano  compresi  nel  campo  espresso del @{U}rangestart@{UU}-@{U}rangeend@{UU} e non fanno
parte del campo di esclusione @{U}excludestart@{UU}-@{U}excludeend@{UU}.
@endnode

@node ComMoveChip "SUPERVISOR® Documentation: Monitor/Comandi/Move chipdata"
                               @{U}@{B}Move chipdata@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}`[address]@{UB}
Quando  si  entra  nel  monitor  una  certa quantita' di memoria chip viene
utilizzata  per il DMA video e del disco.  Cio' non porta ad alcun problema
per  il  programma  congelato,  poiche' il contenuto della suddetta zona di
memoria  viene preventivamente copiata in un blocco di memoria esterna, per
venir poi ripristinata all' atto dello scongelamento.  Il problema sussiste
pero'  per  l'  utente  quando  ha  bisogno  di visualizzare questa zona di
memoria.  La soluzione adottata  per risolvere questo problema e' quella di
spostare  l'  area  video  in  altro  loco ogni qualvolta se ne presenti la
necessita'.   Senza parametri la memoria video viene spostata nei 256Kbytes
successivi  o precedenti la zona attuale.  Il parametro @{U}address@{UU} permette di
specificare l' indirizzo manualmente.
@{U}@{B}NOTA: l' indirizzo rappresenta il margine superiore e non quello inferiore!@{UU}@{UB}
  Tutto  questo discorso e' valido solo nel caso si sia scelto il parametro
@{I}chipmem backup @{UI}nella configurazione.
@endnode

@node ComIA "SUPERVISOR® Documentation: Monitor/Comandi/Add Memory"
                                @{U}@{B}Add Memory@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}IAbase[,size][,flags]@{UB}
Aggiunge una @{I}regione @{UI}di memoria al sistema operativo.  Questa funzione puo'
essere  utilizzata  solo se Exec e' intatta.  Normalmente questo comando va
usato  per  rendere  visibile  blocchi  di  memoria  non  autoconfiguranti,
(vecchie  espansioni  per Amiga1000 o Memoria FAST interna dei modelli piu'
recenti  (A4000)  che  non  viene riconosciuta quando si utilizzano vecchie
versioni  di  Kickstart).   @{U}base@{UU}  rappresenta  l'  indirizzo iniziale della
memoria.   @{U}size@{UU}  la  sua  dimensione (default=512k), flags i suoi attributi
(default=0).
@{B}Questo comando non e' disponibile nella versione dimostrativa.@{UB}
@endnode

@node ComIM "SUPERVISOR® Documentation: Monitor/Comandi/Memory Info"
                                @{U}@{B}Memory Info@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}IM[node#]@{UB}
Visualizza  informazioni  sulla  memoria  disponibile  sotto  sistema.   Il
sistema   deve  ovviamente  essere  intatto  per  poter  utilizzare  questa
funzione.   Indicando  il  numero  d'  ordine  di  una  regione  di memoria
specifica,  vengono  visualizzate  solo  le  informazioni relative a quest'
ultima, ma in forma piu' dettagliata.
@endnode

@node ComIK "SUPERVISOR® Documentation: Monitor/Comandi/Kill Memory"
                                @{U}@{B}Kill Memory@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}IKnode#@{UB}
Rimuove una regione di memoria dal sistema.  Per poter usare questo comando
Exec deve essere intatta.
@endnode

@node ComEW "SUPERVISOR® Documentation: Monitor/Comandi/Memory Watcher"
                              @{U}@{B}Memory Watcher@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}EW[flag]@{UB}
Switch.   Controlla  il  memory  watcher.  Senza parametri ne visualizza lo
status  (ON/OFF).   Se  il  parametro  @{U}flag@{UU}  vale  0  il  @{I}MemWatcher @{UI} viene
disattivato,   se  >0  viene  attivato.   Il  memory  watcher  consente  di
visualizzare  in tempo reale un' area di memoria chip durante l' esecuzione
di  un programma.  Per far cio' SV allo scongela il programma con il copper
disabilitato  e  con  un  INT3SERVER attaccato a quello preesistente che si
occupa  di  resettare al valore indicato dalla variabile @{U}DC@{UU} i puntatori del
bitplane#1 ad ogni @{I}Vertical Blanking.@{UI}
NOTE:  La maniera migliore per impostare l' area di memoria da visualizzare
e' quella di utilizzare il comando @{"S(Show Memory)" link ComS}.  Uscendo dalla procedura
le  variabili  @{U}DC@{UU}  e  @{U}bplmod@{UU} vengono automaticamente impostate.  Scongelare
quindi  immediatamente  il  programma, evitando di utilizzare altri comandi
che  possano  rialterare  il valore di @{U}DC@{UU}.  Il tipo di risoluzione, colore,
ecc...    del   bitplane  possono  essere  impostati  tramite  le  apposite
variabili.   Ovviamente  il  @{I}MemWatcher @{UI} non  puo'  funzionare  quando  gli
interrupt  di  livello  3  sono  disabilitati o generati esclusivamente dal
copper!
@endnode

@node ComEM "SUPERVISOR® Documentation: Monitor/Comandi/Toggle MM"
                                 @{U}@{B}Toggle MM@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}EM@{UB}
Attiva/disattiva  il @{"Memory Manager" link MemManager}.  Disattivando il MM si libera anche la
memoria da esso occupata.
@endnode

@node ComY "SUPERVISOR® Documentation: Monitor/Comandi/Format"
                                  @{U}@{B}Format@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}Y[unit][,mode][,dos]@{UB}
Formatta un disco.  @{U}unit@{UU} rappresenta il numero del drive [0-4] nel quale si
trova  il disco da formattare.  @{U}mode@{UU} indica il tipo di formattazione che si
desidera:   0-@{I}normale @{UI} (AmigaDOS  compatibile),1-@{I}fat-track @{UI} (6184  byte per
traccia), 2-non viene effettuata la formattazione a basso livello:  vengono
solamente inizializzate le strutture DOS (equivalente del parametro 'QUICK'
del  comando  cli  FORMAT).   @{U}dos@{UU} rappresenta il tipo di file system che si
vuole  utilizzare  su  quel  disco.  0 per il vecchio file sistem, 1 per il
fast  file  system  (ATTENZIONE:   in  ambiente  DOS,  il FastFileSystem su
dischetto  e'  utilizzabile  senza  difficolta'  solo  con il sistema 2.0 o
superiori!), 3 per il file system specifico di SV.
 Dal  momento  che  in questa versione le routine di gestione file non sono
ancora  complete,  viene creato il BootBlock, di identificazione, ma non il
RootBlock!
 Indipendentemente  dallo  stato  del @{"Safety" link ComSaf} viene richiesta conferma prima
dell' operazione.
@endnode

@node ComRS "SUPERVISOR® Documentation: Monitor/Comandi/ReadBlock"
                                 @{U}@{B}ReadBlock@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}RS[device][,address][,offset][,length]@{UB}
Carica  in memoria una porzione di dati dal disco.  @{U}device@{UU} (default 0) e il
numero  dell'  unita'  contenente  il disco dal quale devono essere letti i
dati.   @{U}address@{UU}  (il  default  e'  indicato  dalla @{"variabile" link VARS} @{B}dsk@{UB})   e'   l'
indirizzo  a partire dal quale verranno memorizzati i dati; puo' essere sia
memoria  FAST  che CHIP, e non deve necessariamente essere pari!  Se non si
conosce  una  zona  di  memoria  sicura  nella  quale  caricare  il blocco,
consiglio di ricorrere al comando @{"(" link ComAlloc}. @{U}offset@{UU} indica l' inizio del blocco del
disco.   Deve essere espresso in bytes.  Puo' essere un qualsiasi numero da
0  alla  massima  capacita'  del  disco-1.   length  (default  $400)  e' la
lunghezza  del  blocco  da caricare.  Possono essere omessi anche parametri
intermedi; per far cio' occorre, pur tralasciando il parametro, specificare
la virgola separatoria (es:  @{U}RS1,,880*512,$200@{UU}).
@endnode

@node ComWS "SUPERVISOR® Documentation: Monitor/Comandi/WriteBlock"
                                @{U}@{B}WriteBlock@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}WS[device][,address][,offset][,length]@{UB}
Scrive  un  blocco di memoria sul disco.  Per i parametri vedere il comando
@{"RS" link ComRS}.   Se il blocco dovra' essere scritto a partire dall' offset 0, e la sua
lunghezza  e'  di  almeno  1024  bytes,  e reca un' intestazione DOS, viene
assunto  che  i primi 1024 bytes costituiscano un BootBlock; se il checksum
del  bootblock  non  e'  corretto  viene ricalcolato prima di effettuare la
scrittura  sul  disco.   Se il @{"safety" link ComSaf} del monitor non e' disabilitato viene
preventivamente richiesta conferma.
@endnode

@node ComID "SUPERVISOR® Documentation: Monitor/Comandi/DiskInfo"
                                 @{U}@{B}DiskInfo@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}ID[A]@{UB}
Riporta  informazioni  sui  drive  e  sui dischi.  Alcune informazioni sono
disponibili solo se i drive sono stati inizializzati (vedere comando @{"!D" link ComADI}).
Specificando il parametro @{I}A @{UI}si forza l' inizializzazione di tutti i drive.
@endnode

@node ComADI "SUPERVISOR® Documentation: Monitor/Comandi/AutoDiskInit"
                               @{U}@{B}AutoDiskInit@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!D@{UB}
Attiva disattiva alternativamente l' inizializzazione automatica dei drive.
Per  default  ogni qualvolta si congela un programma, per quanto riguarda i
drives,  SV  si  limita  a  memorizzare  lo  stato  di ciascun motore, ed a
bloccarli.   Quando  l'utente  prova ad effettuare una qualsiasi operazione
legata  ai  drive, il drive in questione, se utilizzato per la prima volta,
viene  'inizializzato',  ossia vengono annotate altre informazioni relativi
al  drive,  come  ad  esempio  la  posizione  della  testina,  viene quindi
controllato  il  disco,  creati i buffer, ecc...  L' inizializzazione di un
drive richiede circa mezzo secondo; allo scongelamento viene speso circa un
altro  mezzo  secondo per il ripristino di ciascun drive inizializzato.  Se
AutoDiskInit  e' disabilitato l' inizializzazione viene effettuata solo per
i  drive per i quali e' necessaria nel momento in cui essi sono utilizzati.
Se  e'  abilitato,  viene  effettuata  automaticamente  all' inizio di ogni
congelamento.
 Normalmente il settaggio migliore e' OFF, poiche' non comporta sprechi di
tempo ne' modifiche inutili ai registri write only.
@endnode

@node ComB "SUPERVISOR® Documentation: Monitor/Comandi/BootBlockChecksum"
                             @{U}@{B}BootBlockChecksum@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}B\\[address]@{UB}
Calcola  il  checksum  di  un  bootblock  che si trova in memoria.  @{U}address@{UU}
indica  l'  indirizzo  al  quale  si  trova  il  bootblock; se omesso viene
utilizzato l'indirizzo contenuto nella @{"variabile" link VARS} @{B}dsk@{UB}, utilizzata anche come
default dei comandi @{"RS" link ComRS} e @{"WS" link ComWS}.
@endnode

@node ComH "SUPERVISOR® Documentation: Monitor/Comandi/Help"
                                   @{U}@{B}Help@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}H[commandlist]@{UB}
Senza  parametri  fornisce una sintetica descrizione di tutti i comandi del
monitor.   Specificando  di  seguito la prima lettera di uno o piu' comandi
viene  visualizzata  per ciascuno una linea di descrizione della rispettiva
sintassi e funzione.
@endnode

@node ComI "SUPERVISOR® Documentation: Monitor/Comandi/Info"
                                   @{U}@{B}Info@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}I@{UB}
Fornisce utili informazioni di vario genere.
@endnode

@node ComIF "SUPERVISOR® Documentation: Monitor/Comandi/Freezer info"
                               @{U}@{B}Freezer info@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}IF@{UB}
Fornisce informazioni sul freezer.
@endnode

@node ComIH "SUPERVISOR® Documentation: Monitor/Comandi/Custom regs info"
                             @{U}@{B}Custom regs info@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}IH![name]@{UB}
Fornisce  l'  indirizzo  del/i  registro/i  hardware  avente/i il nome o il
prefisso  specificato  dal  parametro @{U}name@{UU}.  Omettendo @{U}name@{UU} vengono fornite
informazioni su tutti i registri hardware.

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}IH[addr]@{UB}
Fornisce  il  nome  del registro hardware che si trova all' indirizzo @{U}addr@{UU}.
Se @{U}addr@{UU} e' omesso vengono fornite informazioni su tutti i registri hardware

@{B}Questi comandi non sono disponibili nella versione dimostrativa.@{UB}
@endnode

@node ComIT "SUPERVISOR® Documentation: Monitor/Comandi/Task Info"
                                 @{U}@{B}Task Info@{UB}@{UU}

NOTA:   @{I}I  seguenti  due comandi sono attivi solo se Exec e' ancora intatta
(in pratica con i programmi che coesistono con il sistema).@{UI}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}IT[taskname]@{UB}
Senza  parametri fornisce l' elenco dei task presenti ed il loro rispettivo
stato.   Seguito  da  un nome viene visualizzato solo il primo task trovato
rispondente a quel nome, con informazioni piu' aprrofondite.  Possono venir
usati i caratteri Jolly '*' e '?'.

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}INtasknumber@{UB}
Fornisce  informazioni  su  un task specifico.  @{U}tasknumber@{UU} rappresenta il
numero  d' ordine del task desiderato.  Il numero viene visualizzato con il
comando @{B}IT@{UB}.
@endnode

@node ComIC "SUPERVISOR® Documentation: Monitor/Comandi/Trainer Info"
                               @{U}@{B}Trainer Info@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}IC@{UB}
Fornisce  informazioni sullo stato del cercatrainer e sull' andamento della
ricerca eventualmente in corso.
@endnode

@node ComIR "SUPERVISOR® Documentation: Monitor/Comandi/Resident Info"
                               @{U}@{B}Resident Info@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}IR[*][modulenumber]@{UB}
Fornisce  informazioni  sui  moduli  residenti del sistema.  Il parametro @{U}*@{UU}
indica  che  si  deve fare riferimento a @{I}Exec/ResModules,@{UI} omettendolo viene
utilizzato  @{I}Exec/KickTagPtr.@{UI}   @{U}modulenumber@{UU}  indica  il modulo sul quale si
vogliono  informazioni  specifiche  (il  numero del modulo e' fornito nella
lista  globale  che  viene visualizzata se il comando e' usato senza questo
parametro).  @{B}NOTA: Questo comando funziona solo se Exec e' intatta.@{UB}
@endnode

@node ComIV "SUPERVISOR® Documentation: Monitor/Comandi/Version Info"
                               @{U}@{B}Version Info@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}IV@{UB}
Fornisce la versione delle principali routine costituenti questo programma.
@endnode

@node ComRKM "SUPERVISOR® Documentation: Monitor/Comandi/Raw key monitor"
                              @{U}@{B}Raw key monitor@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}%@{UB}
Attiva  il  monitor  della tastiera.  Premendo o rilasciando un tasto viene
visualizzato il relativo codice trasmesso dalla tastiera.  Per terminare la
procedura premere il tasto sinistro del mouse.
@endnode

@node Com0 "SUPERVISOR® Documentation: Monitor/Comandi/Set default base"
                             @{U}@{B}Set default base@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}0[base-id]@{UB}
Cambia   la   base  numerica  di  default.   @{U}base-id@{UU}  e'  il  carattere  di
identificazione della base desiderata:
@{B}$ => esadecimale
@ => ottale
% => binario
# => decimale (default iniziale)
. => break-point
_ => membank@{UB}
 Omettendo il parametro viene visualizzata la base di default corrente.
@endnode

@node ComSCflg "SUPERVISOR® Documentation: Monitor/Comandi/Toggle packed calculator res"
                       @{U}@{B}Toggle packed calculator res@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}??[flag]@{UB}
Imposta  il  formato  dell'  output  del  comando  @{"?" link ComCalc}  del monitor.  @{U}flag=ON@{UU}
imposta l' output compatto su una singola linea.
@endnode

@node ComRAW "SUPERVISOR® Documentation: Monitor/Comandi/Toggle Rawkey|ASCII"
                            @{U}@{B}Toggle Rawkey|ASCII@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}][flag]@{UB}
Imposta il codice utilizzato da quei comandi (@{"?" link ComCalc}, @{"Q" link ComQ}, ...) che visualizzano i
caratteri  associati  a valori numerici di 8 bit.  @{U}flag@{UU}=ON:  keyboardrawkey
(codice della tastiera); @{U}flag=OFF@{UU}:  ASCII.
@endnode

@node ComSign "SUPERVISOR® Documentation: Monitor/Comandi/Sign"
                                   @{U}@{B}Sign@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}-[flag]@{UB}
Attiva/disattiva  il  segno  per  tutti  gli  operandi.  Normalmente solo i
numeri  visualizzati  in decimale vengono visualizzati con segno; tutti gli
altri  vengono  presi  in  valore assoluto.  Se lo switch e' attivo anche i
numeri  espressi  con  gli  altri  sistemi  di  numerazione  possono essere
complementati e preceduti da segno '-'.
@REM ***Soon to be obsolete. It will be removed in future versions!!!***
@endnode

@node ComSaf "SUPERVISOR® Documentation: Monitor/Comandi/Safety"
                                  @{U}@{B}Safety@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}*[flag]@{UB}
Abilita/disabilita  la  richiesta di conferma per le operazioni che possono
comportare la perdita irreversibile di dati.
@endnode

@node Com3 "SUPERVISOR® Documentation: Monitor/Comandi/Assembler settings"
                            @{U}@{B}Assembler settings@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}3@{UB}
Richiama   il   menu   di   configurazione  dell'  assemblatore.   I  tasti
utilizzabili sono i seguenti:

@{B}A@{UB}-Seleziona  se  utilizzare  l'  assembler  interno  o  quello  esterno (se
  presente).    L'  assembler  interno  e'  attualmente  molto  limitato  e
  riconosce  solo  alcune  istruzioni  e  modi  di  indirizzamento  di  uso
  frequente.    Qualora  l'  utente  non  trovasse  cio'  sufficiente  puo'
  installarne  uno  esterno  realizzato  da  lui su misura in base alle sue
  esigenze.   I  dettagli  per  la  realizzazione  del  modulo esterno sono
  spiegati  nella documentazione della procedura di installazione alla voce
  @{"Assembler Esterno" link SVInstaller.guide/ExtAsm}.
@{B}B@{UB}-Attiva/Disattiva  la  possibilita'  di editare la parte in assembly nell'
  output del comando @{"D" link ComD}.
@endnode

@node Com1 "SUPERVISOR® Documentation: Monitor/Comandi/Disassembler Settings"
                           @{U}@{B}Disassembler Settings@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}1@{UB}
Richiama   il   menu   di  configurazione  del  disassemblatore.   I  tasti
utilizzabili sono i seguenti:

@{B}A@{UB}-Attiva/Disattiva  la  nuova  sintassi  delle  istruzioni introdotta dalla
  Motorola  a  partire dal processore 68020.  Se disattivato, per i modi di
  indirizzamento  comuni  al  68000 viene utilizzata la sintassi originale,
  altrimenti viene sempre visualizzata quella nuova.
@{B}B@{UB}-Attiva/Disattiva  il  modo esadecimale per tutti gli operandi.  Se attivo
  alcuni  operandi  (es:   gli  offset  negativi)  vengono  visualizzati in
  decimale.    Se  disattivato  tutti  i  numeri  vengono  visualizzati  in
  esadecimale.
@{B}C@{UB}-Attiva/Disattiva  il  modo  @{I}senza  segno.@{UI}   Se  attivo tutti gli operandi
  vengono  visualizzati  senza segno (per cui, come effetto collaterale non
  vengono  neppure  visualizzati in decimale, se negativi).  Se disattivato
  gli  operandi  negativi sono visualizzati in complemento a 2 preceduti da
  segno.
@{B}D@{UB}-Attiva/Disattiva il riconoscimento delle istruzioni del 68010¹.
@{B}E@{UB}-Attiva/Disattiva il riconoscimento delle istruzioni del 68020¹.
@{B}F@{UB}-Attiva/Disattiva il riconoscimento delle istruzioni del 68030¹.
@{B}G@{UB}-Attiva/Disattiva il riconoscimento delle istruzioni del 68040¹.
@{B}H@{UB}-Attiva/Disattiva il riconoscimento delle istruzioni del 68060¹.
@{B}I@{UB}-Attiva/Disattiva  l'  ottimizzazione  nella sintassi del disassemblaggio.
  Se disattivato, la sintassi utilizzata e' rigorosamente conforme a quella
  stabilita dalla Motorola.  Se attivato alcune forme vengono @{I}snellite.@{UI}
@{B}J@{UB}-Attiva/Disattiva  l'  inserimento  della  linea di separazione ad ogni in
  seguito ad istruzioni che cambiano il flusso del programma.  (@{"MONITOR" link Monitor}).
@{B}K@{UB}-Attiva/Disattiva  la  segnalazione  di tutte le istruzioni appartenenti a
  processori diversi dal 68000.  (Valido solo per il comando @{"D" link ComD}).
@{B}L@{UB}-Attiva/Disattiva  l'  inserimento  della  linea di separazione ad ogni in
  seguito ad istruzioni che cambiano il flusso del programma.  (@{"RTM" link RTM}).
@{B}M@{UB}-Attiva/Disattiva   il  disassembly  simbolico.   Le  etichette  di  linea
  appaiono al posto dei codici in esadecimale.
@{B}N@{UB}-Attiva/Disattiva  l'  impostazione  automatica  del disassembly simbolico
  (parametro precedente), in base alla presenza o meno di @{"LABEL" link VARS} in memoria.
@{B}O@{UB}-Attiva/Disattiva  la visualizzazione simbolica delle chiamate a libreria.
  Vedere anche "SVInstaller/@{"LibFile" link SVInstaller.guide/LibFile}".
@{B}P@{UB}-Se  attivo sono le chiamate a librerie residenti in ROM sono visualizzate
  in maniera simbolica. Vedere anche "SVInstaller/@{"LibFile" link SVInstaller.guide/LibFile}.
@{B}Q@{UB}-Attiva/Disattiva  la  visualizzazione  dei  codici  delle  istruzioni  in
  esadecimale.
@{B}X@{UB}-Esce dalla procedura di configurazione del disassembler.

¹NOTA:   le  opzioni  di  controllo  processore  definite  dall' utente non
vengono  usate  nella  visualizzazione dei registri:  l' ultima linea della
lista-registri,  contiene  il valore corrente del PC e l' istruzione che si
trova  a  quell'  indirizzo,  disassemblata in base al processore di cui e'
dotata  la  macchina  (ad  esempio  @{U}TST.l A0@{UU}  e'  segnalato come istruzione
illegale  su  di  un  68000, mentre viene normalmente visualizzato su di un
68020).
@endnode

@node ComRest "SUPERVISOR® Documentation: Monitor/Comandi/Restart"
                                  @{U}@{B}Restart@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!@{UB}
Rivisualizza il titolo.
@endnode

@node ComBootFrz "SUPERVISOR® Documentation: Monitor/Comandi/BootFreeze"
                                @{U}@{B}BootFreeze@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!B@{UB}
Attiva/disattiva   alternatamente  il  BootFreeze.   Se  il  BootFreeze  e'
attivato,  SV  si  linka alla funzione @{I}DoIO @{UI}della libreria @{I}Exec,@{UI} in modo da
intercettare  ogni  accesso  in lettura al BootBlock del disco.  Ogni volta
che  cio'  si  verifica  viene  richiamato il freezer.  Questa opzione puo'
venir  selezionata  in  ogni  momento, ma il linking con la funzione @{I}DoIO()@{UI}
avviene solo al momento dell' installazione e al reboot della macchina, per
cui  se  si e' installato SV con questa opzione ad @{U}OFF@{UU} e successivamente la
si  riattiva tramite questo comando, esso avra' effetto solo dal successivo
Reboot.  Una volta installato il @{I}DoIO() handler,@{UI} questa funzione ha effetto
immediato ogni volta che la si usa.
@endnode

@node ComResTOD "SUPERVISOR® Documentation: Monitor/Comandi/Restore TOD"
                                @{U}@{B}Restore TOD@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!C[ON/OFF]@{UB}
Attiva/disattiva  il  ripristino  dei  registri TimeOfDay dei circuiti CIA.
Nonostante  i  registri  'sveglia'  siano  Write  Only  SV  e'  in grado di
occuparsene  ugualmente  nel modo piu' efficace possibile.  Tutto questo e'
stato implementato per ragioni di completezza del programma, ma normalmente
non  vi  sara'  alcun  bisogno  di  farne  ricorso,  anzi sara' preferibile
disattivare   questa   opzione,  poiche'  se  l'orologio  viene  congelato,
ovviamente allo scongelamento andra' indietro rispetto al tempo reale.
@endnode

@node ComKill "SUPERVISOR® Documentation: Monitor/Comandi/Kill SUPERVISOR (Hard Reset)"
                       @{U}@{B}Kill SUPERVISOR (Hard Reset)@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!K@{UB}
Effettua una reset di tutto il sistema.  Poiche' Exec viene preventivamente
cancellata,  questa  operazione  equivale  ad  un reset Hardware:  tutta la
memoria   interna   (CHIP   e   SLOW)   viene   azzerata,   le  periferiche
reinizializzate,  e tutti i programmi residenti in RAM vengono rimossi.  Se
lo switch di sicurezza e' attivo viene chiesta conferma prima di procedere.
@endnode

@node ComReset "SUPERVISOR® Documentation: Monitor/Comandi/Reboot"
                       @{U}@{B}Reboot@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!Q@{UB}
Resetta il sistema.  Se si vuole resettare il sistema, uscire dal monitor e
quindi  premere  i  tre CTRL-LAMIGA-RAMIGA, oppure usare il questo comando.
E'  sconsigliabile resettare mentre il monitor e' attivo senza usare questo
comando per i seguenti motivi:
1-l' area video usata dal monitor rimane alterata
2-sebbene sia stata prestata particolare attenzione al problema, resettando
  nel mezzo di alcune operazioni, SV potrebbe rimanerne danneggiato
3-con  il  CopyBack attivato le ultime impostazioni effettuate dall' utente
  potrebbero  venir  perdute, in quanto presenti in Cache ma non in memoria
  al  momento  del  reset, e, cosa peggiore, molte strutture del programma,
  per  lo  stesso  motivo,  potrebbero rimaner parzialmente o integralmente
  distrutte, causando enorme caos al reset del sistema.

Se  lo  switch  di  sicurezza  e'  attivo  viene  chiesta conferma prima di
procedere.
Questo  comando  e'  utile anche quando SV non e' reso residente, in quanto
evita la sequenza del @{"Reset Warning" link KeybInfo}.
@endnode

@node ComResF "SUPERVISOR® Documentation: Monitor/Comandi/Reset Freeze"
                               @{U}@{B}Reset Freeze@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!R@{UB}
Attiva/disattiva il ResetFreeze. Se attivo e se SV e' stato reso residente,
ad ogni reset ci si ritrova automaticamente nel monitor.
@endnode

@node ComBSync "SUPERVISOR® Documentation: Monitor/Comandi/Toggle BeamSync"
                              @{U}@{B}Toggle BeamSync@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!I@{UB}
Commuta tra scrolling veloce(poco fluido) e scrolling lento(fluido).
@endnode

@node ComBlt "SUPERVISOR® Documentation: Monitor/Comandi/Blitter"
                                  @{U}@{B}Blitter@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!S[ON/OFF]@{UB}
Attiva  disattiva  il blitter per le routine di scrolling.  Chi utilizza un
68000 potrebbe trovare lo scrolling non eccessivamente fluido.  Per ovviare
a  questo  inconveniente  puo' attivare il blitter.  Ricordo che i registri
del  blitter  sono  Write  Only,  per  cui  c'e'  il rischio che si causino
problemi  al programma del quale SV ha preso il controllo quando esso sara'
scongelato!
@endnode

@node ComCache "SUPERVISOR® Documentation: Monitor/Comandi/Cache"
                                   @{U}@{B}Cache@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!T[I]@{UB}
Attiva/disattiva  le  cache  (se  presenti)  della CPU.  Senza parametri si
agisce  sulla  Cache  Dati  (se  presente  solo  la Cache Istruzioni agisce
direttamente  su  quest'  ultima), con il parametro @{I}I @{UI}si agisce sulla Cache
Istruzioni.   Se  il  processore  montato  lo  supporta, SV attiva la Cache
Istruzioni   durante   il   suo  funzionamento  per  ottenere  le  migliori
prestazioni.   La  Cache  Dati viene lasciata disabilitata per default, dal
momento  che richiede una adeguata configurazione hardware e/o software del
sistema, per funzionare correttamente senza problemi:  la memoria chip ed i
registri  hardware  non  dovrebbero  essere  utilizzati  dalla  cache dati.
Occorre  pertanto  un  hardware  come quello presente sui modelli 3000/4000
oppure  utilizzare  una MMU per inibire tali locazioni.  Se l' utente sa di
poter far affidamento sulla Cache Dati puo' attivarla senza preoccupazioni.
SV  e' progettato per funzionare correttamente con Cache, Burst e CopyBack.
Lo  stato  della  Cache  Dati  viene  'ricordato' ad ogni riattivazione del
monitor.
@endnode

@node ComSetPri "SUPERVISOR® Documentation: Monitor/Comandi/Set resident-pri"
                             @{U}@{B}Set resident-pri@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!Ppri@{UB}
Imposta la priorita' (-128, +127) del ROMTAG di SV.  Con un' alta priorita'
SV  sara'  attivato prima dei dispositivi esterni autoconfiguranti, i quali
saranno  a  disposizione  dell'  utente a 0xE80000 (attenzione ai danni, in
particolare all' HD!).  Con una bassa priorita' si hanno disposizione tutte
le  periferiche gia' configurate.  NOTA:  se la priorita' e' piu' bassa del
modulo  di  BootStrap  di  sistema, SV non viene riattivato in seguito a un
reset!
@endnode

@node ComRemSV "SUPERVISOR® Documentation: Monitor/Comandi/Remove Resident"
                              @{U}@{B}Remove Resident@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!X@{UB}
Disabilita  la  capacita'  di  SV di sopravvivere al reset.  Per rimuoverlo
definitivamente dalla  memoria occorrera' un reboot.  Se @{"safety" link ComSaf} e' attivato
viene  richiesta  conferma  prima  dell'  operazione.   Tecnicamente  SV si
'sgancia'  dalla  lista  dei moduli residenti.  Cio' viene effettuato senza
causare  danni  ad altri programmi eventualmente residenti.  Questo comando
e' utilizzabile solo se SV e' stato reso residente.
@endnode

@node ComVBR "SUPERVISOR® Documentation: Monitor/Comandi/Set VBR"
                                  @{U}@{B}Set VBR@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!V[vectortable]@{UB}
(68010 e superiori) Copia la tabella dei vettori all' indirizzo @{U}vectortable@{UU}
e  setta VBR.  Qualora fosse omesso il parametro @{U}vectortable@{UU} la tabella dei
vettori  CPU viene copiata in un blocco di memoria allocato automaticamente
dal monitor.
@endnode

@node ComSetFK "SUPERVISOR® Documentation: Monitor/Comandi/Set FreezeKey"
                               @{U}@{B}Set FreezeKey@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!Z[keycode]@{UB}
Seleziona  il  tasto 'magico' di chiamata del freezer.  @{U}keycode@{UU} rappresenta
il  codice  'raw'  del  tasto  desiderato.  Esso puo' essere ottenuto anche
tramite  il  @{"rawkey monitor" link ComRKM}.   Omettendo  il parametro si ritorna al metodo
@{I}Joy+Mouse.@{UI}
@endnode

@node ComKRest "SUPERVISOR® Documentation: Monitor/Comandi/Toggle keyboard-restore"
                          @{U}@{B}Toggle keyboard-restore@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}{[ON/OFF]@{UB}
Attiva disattiva il ripristino della tastiera.  Se attivo (@{U}ON@{UU}), all' uscita
del  monitor, prima di effettuare lo scongelamento, SV richiede all' utente
di  premere  tutti  i  tasti  che  si  trovavano  premuti  al  momento  del
congelamento,  e  di  rilasciare  tutti  gli altri.  Di ciascun tasto viene
visualizzato nome (relativo alla tastiera USA) e codice.  La procedura puo'
venir  interrotta,  passando immediatamente allo scongelamento, premendo il
pulsante sinistro del mouse.
  Se  l'  ingresso  al  monitor e' avvenuto tramite pressione di un tasto e
questo  tasto  NON  e'  stato  catturato dal keyboard handler del programma
congelato   (cio'   in  genere  accade  quando  si  usa  il  level2-entry),
SUPERVISOR,   correttamente,  non  ne  richiede  la  pressione  durante  il
keyboard-restoring.
@endnode

@node ComResScr "SUPERVISOR® Documentation: Monitor/Comandi/Restore Screen"
                              @{U}@{B}Restore Screen@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!L@{UB}
Ripristina   lo   schermo   di   SV.   Utile  nel  caso  in  cui  si  abbia
accidentalmente  modificato  qualche  registro  hardware (ad esempio con il
comando  @{"M" link ComM})  causando  confusione  sullo  schermo.  Nota:  allo startup del
freezer  gli  sprites  non vengono effettivamente disabilitati:  in realta'
viene  seguita  la procedura standard consistente nella disabilitazione del
DMA  degli  sprite  durante il vertical blanking (al fine di effettuare uno
scongelamento  il  piu'  accurato possibile).  Tuttavia questo sistema puo'
non  funzionare  nel  100%  dei  casi,  causando  talvolta delle fastidiose
strisce  verticali  lungo lo schermo.  Qualora cio' si verificasse, si puo'
usare  questo  comando,  il  quale  disabilita  effettivamente  gli  sprite
hardware.   La  @{"macro" link Macros}  @{B}CLEANUP@{UB} effettua questa procedura automaticamente ad
ogni attivazione del monitor.
@endnode

@node ComPALNTSC "SUPERVISOR® Documentation: Monitor/Comandi/Toggle PAL|NTSC"
                              @{U}@{B}Toggle PAL|NTSC@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!N@{UB}
Commuta  tra  NTSC/PAL.   Richiede  ECS  o  superiori.  Evitare di cambiare
manualmente  (comando  @{"M" link ComM}),  onde  evitare  malfunzionamenti  del programma.
Notare che il cambiamento influenza anche il programma congelato.
@endnode

@node ComTask "SUPERVISOR® Documentation: Monitor/Comandi/Task-capture ON|OFF"
                            @{U}@{B}Task-capture ON|OFF@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}!M@{UB}
Attiva/disattiva  l' intercettatore di task.  Questa funzione ha bisogno di
effettuare  una modifica ad un vettore di salto di una libreria di sistema,
per cui vale lo stesso discorso fatto per il comando @{"!B" link ComBootFrz}.
@endnode

@node ComEdFK "SUPERVISOR® Documentation: Monitor/Comandi/Edit FKeys"
                                @{U}@{B}Edit FKeys@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}#U[n,string]@{UB}
Usato  senza  parametri  visualizza  la  configurazione  currente dei tasti
funzione,  seguito dai due parametri modifica la configurazione.  Il metodo
piu'  rapido  consiste nell' usare il comando senza parametri e poi editare
il  suo  output.   @{U}n@{UU}(0-29)  e' il numero del tasto; @{U}string@{UU} e' la stringa da
abbinare  al  tasto.   Il  carattere  @{B}\\@{UB} seguito da due cifre esadecimali @{B}xx@{UB}
inserisce  un  carattere  di  @{"codice" link CharTab}  @{B}xx@{UB}.  Con la sequenza @{B}\\\\@{UB} si ottiene un
singolo  carattere  @{B}\\@{UB}.  I @{"codici" link CharTab} speciali ($80-$9d), eventualmente presenti
nelle stringhe abbinate ai tasti funzione, provocano l' esecuzione di macro
aventi lo stesso codice, oppure in mancanza di esse, delle funzioni interne
corrispondenti.   In  base  alle  impostazioni  di default ad ogni tasto e'
assegnato un codice di una funzione interna.
In   caso  di  memoria  insufficiente,  in  modo  @{"LOMEM" link SVInstaller.guide/MainMenu 25}  e  nella  versione
dimostrativa  la tabella di definizione personalizzata non viene creata e i
tasti funzioni sono unicamente abbinati alle funzioni interne.
@endnode

@node ComOM "SUPERVISOR® Documentation: Monitor/Comandi/Hear Memory"
                                @{U}@{B}Hear Memory@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}OMstart,end[,period][,vol]@{UB}
Suona come @{I}sample @{UI}una zona di memoria.  @{U}start@{UU} ed @{U}end@{UU} definiscono l' area da
ascoltare;  @{U}period@{UU}  il  periodo (se  omesso  o  vale  0 il registro AUDxPER
mantiene  l' impostazione preesistente); @{U}vol@{UU} e' il volume (default=64).  La
zona  di memoria puo' essere sia FAST che CHIP.  Il tasto @{I}AMIGA @{UI}puo' essere
usato  per  sospendere momentaneamente l' esecuzione, la quale riprende non
appena esso viene rilasciato.
@endnode

@node ComCalc "SUPERVISOR® Documentation: Monitor/Comandi/Calculator"
                                @{U}@{B}Calculator@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}?expression@{UB}
Calcola  il  valore  di  una  @{"espressione" link Eval}  e  ne visualizza il risultato in
binario,  ottale,  esadecimale, decimale, ASCII (se lo switch ] e' attivato
il  numero  viene considerato come codice della tastiera, quindi convertito
in  una  stringa  di  testo  che  indichi  i(l)  tasto/i  a  cui appartiene
/appartengono  i(l)  codice/i.   Dal  momento  che i codici trasmessi dalla
tastiera  danno  informazioni solo sul tasto premuto e non sul carattere ad
esso  assegnato,  SV  fa  riferimento  ad  una tastiera di tipo USA, che e'
quella a cui con maggior probabilita' il programma in esame si riferisce!).
Il  tipo di output di questo comando (su una singola linea o su piu' linee)
puo' essere impostato tramite lo switch @{"??" link ComSCflg}.
@endnode

@node ComP "SUPERVISOR® Documentation: Monitor/Comandi/Set symbol memory"
                           @{U}@{B}Set symbol area size@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}P[sspace][,hash][,fast]@{UB}
Imposta e inizializza la memoria destinata alle @{"variabili" link VARS}.
- @{U}sspace@{UU}  indica  la  dimensione  della zona in cui verranno memorizzate le
  variabili.   Se  il  valore  specificato  risulta  troppo  piccolo  viene
  utilizzata la dimensione di default.
- @{U}hash@{UU}  indica  la  dimensione  in  longword  della  tabella utilizzata dal
  disassembler per trovare velocemente i simboli.  Attualmente il numero e'
  approssimato alla potenza di 2 piu' piccola piu' vicina.
- @{U}fast@{UU}  e' un flag che indica la modalita' di gestione delle variabili:  se
  @{U}fast@{UU}=0  le variabili vengono memorizzate in ordine alfabetico, se @{U}fast@{UU}<>0
  le  variabili  non  sono  ordinate.   E'  saggio utilizzare quest' ultima
  modalita' in particolare quando si effettua il debug di un file con molti
  simboli:  il caricamento risulta enormemente piu' veloce.

Questo  comando  cancella  tutte  le variabili eventualmente definite dall'
utente;  in tal caso, comunque, se attivo lo switch @{"safety" link ComSaf}, viene richiesta
conferma  prima  di  procedere.  In caso di memoria insufficiente non sara'
possibile  utilizzare  alcuna  variabile.   Cio'  non  creera'  problemi al
funzionamento  del  monitor,  ma  sara'  fonte di seri disagi per l' utente
abituato a farne uso!
@endnode

@node ComSymInfo "SUPERVISOR® Documentation: Monitor/Comandi/Symbol info"
                                @{U}@{B}Symbol info@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}=@{UB}
Fornisce  informazioni  sull'  area  dedicata alle @{"variabili" link VARS} (per lo piu' a
scopo di debugging:  di nessuna utilita' per un normale utente).
@endnode

@node ComSymTab "SUPERVISOR® Documentation: Monitor/Comandi/Show symbol table"
                             @{U}@{B}Show symbol table@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}=/[matchstring]@{UB}
Visualizza  tutte  le @{"variabili" link VARS} definite, i loro valori e il loro tipo.  Il
parametro  @{U}matchstring@{UU}  funge  da filtro:  se presente vengono visualizzate
solo  quelle  variabili  il  cui nome inizi con @{U}matchstring@{UU}.  La stringa di
filtro  puo'  contenere il caratteri jolly @{I}? @{UI} e @{I}*.@{UI}  Il primo sostituisce un
qualsiasi  carattere,  il  secondo  una  sequenza di caratteri di qualsiasi
lunghezza.   I  caratteri  maiuscoli  sono considerati @{I}differenti @{UI}da quelli
minuscoli.  Esempi:
=/		:Visualizza l' elenco completo delle variabili
=/bpl		:Visualizza tutte le variabili che iniziano per @{I}bpl @{UI}
=/t*r?		:Visualizza  tutte  le  variabili  che  iniziano  per  @{I}t @{UI} e
		 finiscono  con  @{I}r @{UI} seguito da un qualsiasi altro carattere
		 (es:@{U}timerA@{UU} e @{U}timerB@{UU})
@endnode

@node ComZapLabs "SUPERVISOR® Documentation: Monitor/Comandi/Zap labels"
                                @{U}@{B}Zap labels@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}=!@{UB}
Rimuove  tutte  le @{"variabili" link VARS} etichetta (LABEL) dalla memoria.  Se attivo lo
switch  @{"safety" link ComSaf},  viene  richiesta conferma prima di procedere.  Se e' stato
impostato  il flag @{"Auto Kill Labels" link SVInstaller.guide/Debug} la rimozione avviene automaticamente al
termine del programma caricato con l' opzione @{"DEBUG" link SVInstaller.guide/Config}.
@endnode

@node ComDefSym "SUPERVISOR® Documentation: Monitor/Comandi/Define symbol"
                               @{U}@{B}Define symbol@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}=[=]name[,value]@{UB}
Crea, rimuove, modifica il valore di una @{"variabile" link VARS}.  Specificando solamente
il  nome  della  variabile,  essa, se esiste e se e' del tipo giusto, viene
rimossa.   Specicando  il  parametro  @{U}value@{UU}  viene  creata  se  non  ancora
esistente,   il  parametro  viene  calcolato  (puo'  essere  una  qualsiasi
espressione,  un  semplice  numero, un' altra variabile ...  tutto cio' che
viene  accettato  dal  @{"valutatore di espressioni" link Eval}) e posto come valore della
variabile  (se la variabile puo' essere scritta!).  Il nome della variabile
puo'  contenere qualsiasi lettera o numero, ma nessun carattere speciale, e
deve  iniziare  per  lettera.   Una  maniera  piu'  veloce per definire una
variabile e' la seguente:  @{B}variabile[valore@{UB}.  Per rimuovere la variabile e'
pero' necessario far ricorso a questo comando.
  Tutte  le  variabili  create  sono  di  tipo  USER-VARIABLE,  per  creare
variabili di tipo USER-FUNCTION e' necessario il parametro @{B}=@{UB}.
  Voglio  ribadire ancora una volta quanto le variabili siano importanti in
SV.   Consiglio  a  chiunque di farne uso molto spesso:  tutto diventa piu'
semplice  ed  immediato;  inoltre evitano l' uso intensivo del block notes.
Tener  presente  che  le  variabili,  come tutti gli altri parametri di SV,
rimangono  invariate  anche  dopo  il reboot della macchina (purche' SV sia
residente!).
@endnode

@node ComDefLab "SUPERVISOR® Documentation: Monitor/Comandi/Define label"
                               @{U}@{B}Define label@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}=$name[,address]@{UB}
Crea,  rimuove,  modifica  il  valore  di  una @{"variabile" link VARS} etichetta (LABEL).
Funziona  analogamente al comando @{"=[=]" link ComDefSym}, tenendo presente che questo tipo di
variabile  e'  anche  utilizzato dal disassembler in modalita' simbolica, e
che  il suo valore rappresenta in tal caso l' indirizzo da etichettare.  Se
e'  stato  impostato  il  flag  @{"Auto Kill Labels" link SVInstaller.guide/Debug}  la  rimozione di TUTTE le
variabili  etichetta  (definite  manualmente  o importate dal file) avviene
automaticamente al termine del programma caricato con l' opzione @{"DEBUG" link SVInstaller.guide/Config}.
@endnode

@node ComER "SUPERVISOR® Documentation: Monitor/Comandi/Init RTM"
                                 @{U}@{B}Init RTM@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}ER@{UB}
Inizializza  il buffer per la configurazione del RealTimeMonitor e lo stack
per  la penetrazione indiretta e ritorno.  Normalmente questa operazione e'
automaticamente  effettuata all' installazione del monitor, tranne nel caso
in  cui non ci sia abbastanza memoria sufficiente o si sia usata l' opzione
LOMEM-MODE.   Senza  il  suddetto buffer il RTM funziona ugualmente, ma non
puo'   essere  personalizzato  linea per linea.   Senza  lo  stack  non  e'
possibile utilizzare i comandi PUSH/PULL&JUMP.
Un'  altro  utilizzo  tipico  di  questo  comando e' quello di resettare le
impostazioni di configurazione del RTM.
@endnode

@node ComEE "SUPERVISOR® Documentation: Monitor/Comandi/Config RTM"
                                @{U}@{B}Config RTM@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}EE[n,commandstring]@{UB}
Usato senza parametri visualizza la configurazione attuale del @{"RTM" link RTM}, seguito
dai  due  parametri  modifica  la  configurazione.   Il  metodo piu' rapido
consiste  nell'  usare  il  comando  senza  parametri  e poi editare il suo
output.   n  e'  il numero di linea; commandstring e' la stringa di comando
per impostare l' output di una o piu' righe di dati nella forma desiderata.
I comandi attualmente supportati sono i seguenti:

d[address]		:visualizza  una  linea di disassembly.  @{U}address@{UU} e'
			:l'  indirizzo  dell'  istruzione da disassemblare.
			:Qualora   si   vogliano  visualizzare  piu'  linee
			:consecutive, l' indirizzo va fornito solo la prima
			:volta,   per   tutte   le   successive   linee  va
			:specificato  solo  il  comando senza parametri, in
			:modo  da  utilizzare  automaticamente l' indirizzo
			:successivo rispetto alla linea precedente.

h[address]		:visualizza   una  linea  con  il  contenuto  della
			:memoria  in  forma  esadecimale  ed  ASCII.  Per i
			:parametri  vale  lo  stesso  discorso fatto per il
			:comando @{I}d.@{UI}

a[address]		:visualizza   una  linea  con  il  contenuto  della
			:memoria in formato ASCII.  Per i parametri vale lo
			:stesso discorso fatto per il comando @{I}d.@{UI}

b[address][,modulo]	:visualizza graficamente il contenuto della memoria
			:in  un blocco di 640x8 pixel.  @{I}modulo@{UI} e' il valore
			:che  va aggiunto all' indirizzo al termine di ogni
			:linea di 640 pixel (=80 bytes).  Per il resto fare
			:riferimento alla descrizione del comando @{I}d.@{UI}

r0|1|2|3		:visualizza una linea con il contenuto dei registri
			:CPU.    0=registri   dati,  1=registri  indirizzo,
			:2=stack   pointer  e  status  register,  3=PC  con
			:disassembly della relativa istruzione.

?[lines][,addr][,mod]	:visualizza   un   gruppo   di   linee  con  output
			:controllabile  dall'  utente  (vedi  @{"tabella RTM" link RTM}).
			:@{U}lines@{UU} e' il numero di linee utilizzabili da questo
			:comando:   con  il  valore  -1  (default)  vengono
			:utilizzate  tutte le linee rimaste libere ed oltre
			:al  gruppo dati controllabili dall' utente vengono
			:visualizzati   i  registri  CPU.   @{U}address@{UU}  e'  l'
			:indirizzo  di  base  per l' output di dati:  viene
			:utilizzato  ogni  volta  che  il gruppo dati viene
			:lockato  e con il comando ALT+Q.  @{U}modulo@{UU} serve per
			:il  bitplane  view.   Questo comando va utilizzato
			:una volta sola.

![address]		:visualizza  una  linea con output in concordanza a
			:quello  delle linee mostrate dal comando @{B}?@{UB}.  Utile
			:per  dividere  la  finestra  RTM  in  piu' visuali
			:interattive.    Un   ottimo  esempio  puo'  essere
			:trovato nelle macro interne @{U}SPLIT@{UU} e @{U}CMP@{UU}.

t[text]			:visualizza   una   linea  vuota  o  con  il  testo
			:specificato   nel   parametro   @{U}text@{UU}.   Utile  per
			:commentare  i  dati  contenuti  della finestra del
			:RTM.

**  I  caratteri  maiuscoli sono considerati DIFFERENTI da quelli minuscoli
dal  parser  del  RTM,  per  cui  i  comandi  vanno  scritti con gli stessi
caratteri  indicati  nella documentazione, a differenza dei normali comandi
del monitor.

Esempi:
EE#1,d.1
EE#2,d
EE#3,d
EE#4,d
EE#5,?-1,pc

EE#0,?4,view1
EE#1,
EE#2,
EE#3,
EE#4,t-- View#2 --
EE#5,!view2+rtm-view1
EE#6,!
EE#7,!
EE#8,!
@endnode

@node ComB2 "SUPERVISOR® Documentation: Monitor/Comandi/Do macro"
                                 @{U}@{B}Do macro@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}Bname[ arguments]@{UB}
Esegue  la  @{"macro" link Macros}  di  nome  @{U}name@{UU}.  Qualora la funzione @{"AutoMacro" link SVInstaller.guide/Macros 5} sia stata
attivata,  questo  comando  e' pressoche' inutile.  Un normale comando puo'
essere  distinto esplicitamente da una macro (qualora dovesse venir confuso
con una macro con lo stesso nome) facendolo precedere dal carattere '_'.
@endnode

@node ComMACB "SUPERVISOR® Documentation: Monitor/Comandi/Pause|Cont macro exec"
                           @{U}@{B}Pause|Cont macro exec@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}#B@{UB}
Sospende  o  continua  l'  esecuzione  di una macro (puo' essere usato all'
interno  di  una  macro  per  interromperla,  e  poi  in  modo  diretto per
riprenderne l' esecuzione).
@endnode

@node ComMACE "SUPERVISOR® Documentation: Monitor/Comandi/Toggle macro echo"
                             @{U}@{B}Toggle macro echo@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}#E@{UB}
Attiva  disattiva l' echo dei comandi contenuti nelle macro durante la loro
esecuzione (globale).
@endnode

@node ComMACF "SUPERVISOR® Documentation: Monitor/Comandi/Toggle macro fkeys"
                            @{U}@{B}Toggle macro fkeys@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}#F@{UB}
Attiva/disattiva l' uso dei tasti funzione per il richiamo delle macro.
@endnode

@node ComMACI "SUPERVISOR® Documentation: Monitor/Comandi/Macro Info"
                                @{U}@{B}Macro Info@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}#I@{UB}
Fornisce informazioni sulle macro.
@endnode

@node ComMACL "SUPERVISOR® Documentation: Monitor/Comandi/List macro[s]"
                               @{U}@{B}List macro[s]@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}#L[name]@{UB}
Visualizza  l'  elenco  di  tutte le macro installate, oppure visualizza il
contenuto  della  macro il cui nome e' corrisponde a quello indicato con il
parametro @{U}name@{UU}.
@endnode

@node ComExtCom "SUPERVISOR® Documentation: Monitor/Comandi/External Command"
@next ComExtCom
                             @{U}@{B}External Command@{UB}@{UU}

@{U}@{I}Sintassi@{UI}@{UU}:
 @{B}#X[arguments]@{UB}
Esegue un comando esterno definito in @{"uh_CustomCom" link supervisor/supervisor.i/main}.
@endnode

@node VARS "SUPERVISOR® Documentation: Monitor/Variabili"
@prev Commands
@next Eval
                                 @{B}@{U}Variabili@{UU}@{UB}

  Le  variabili,  piu'  volte  nominate  in  questo  manuale, permettono di
associare  dei  nomi  a  dei  numeri,  in  modo  da  non essere costretti a
stressanti  esercizi  di  memoria,  e  consentono  una  veloce, semplice ed
efficiente  manipolazione  dei  dati.   Una  variabile  viene  riconosciuta
immettendo  semplicemente  il  suo nome.  Al suo posto verra' utilizzato il
valore ad essa associato.  Attualmente SV gestisce 10 tipi di variabili, di
cui le seguenti 7 sono attualmente utilizzate:

@{B}USER VARIABLE@{UB} - Il  loro  valore  e'  immagazzinato  nell'  area variabili.
Possono  essere  lette,  scritte  e  cancellate  dall'  utente.  Il nome e'
case-sensitive   (i  caratteri  maiuscoli  sono  considerati  distinti  dai
corrispondenti minuscoli).
@{B}SYSTEM VARIABLE@{UB} - Il  loro  dato e' immagazzinato nella memoria interna del
monitor e  corrisponde ad una effettiva variabile utilizzata dal codice del
monitor.   Possono  essere  lette, modificate, ma non rimosse dall' utente.
Possono  venir  utilizzate  dal  monitor.   Il  nome  e'  case-sensitive (i
caratteri   maiuscoli   sono   considerati   distinti   dai  corrispondenti
minuscoli).
@{B}*SYSTEM FUNCTION@{UB} - Funzione:   va seguita da un parametro (es:  @{U}FNC(x)@{UU}), in
base al quale restituisce un valore numerico.
@{B}CUSTOM FUNCTION@{UB} - Funzione   definibile   dall'   utente,   contenente  un'
espressione  numerica  qualsiasi.   L'  espressione  in  essa  contenuta e'
valutata  ogni  volta  che  la  variabile viene incontrata.  Essa va sempre
seguita  da  un parametro, che viene passato alla sotto-espressione tramite
la  variable @{U}ARG@{UU}.  (Es:  la variabile @{U}MUL@{UU} contiene la seguente espressione:
@{U}ARG*2@{UU}.  Digitando @{U}?MUL(3)@{UU} il risultato visualizzato e' @{U}6@{UU}.
@{B}LABEL@{UB} - Etichettano con nomi simbolici locazioni di memoria.  Funzionano in
maniera  analoga  alle  @{B}USER VARIABLE@{UB},  ma  in  piu'  sono  utilizzate  dal
disassembler   in   modalita'  simbolica.   Esse  possono  essere  definite
manualmente  dall'  utente  e/o caricate da un file caricato con l' opzione
@{"DEBUG" link SVInstaller.guide/Config}.
@{B}*USER@{UB}  -  Il  loro valore e' immagazzinato nell' area variabili.  Possono
essere  solo  lette.   Contengono  valori  costanti  di  frequente uso.  La
variabile viene riconosciuta sia con caratteri minuscoli che con maiuscoli!
@{B}*SYSTEM@{UB} - Il loro dato e' immagazzinato nella memoria interna del monitor e
corrisponde  ad  una  effetiva variabile utilizzata dal codice del monitor.
L'  utente  ha  solo accesso in lettura.  Il monitor stesso puo' farne uso.
La  variabile  viene  riconosciuta  sia  con  caratteri  minuscoli  che con
maiuscoli!

* @{I}Tutte le variabili lavorano con dati di 32 bit.@{UI}

Segue  l' elenco delle piu' importanti funzioni e variabili speciali sempre
disponibili:
ABS(x)	Funzione: restituisce il valore assoluto di @{B}x@{UB}.

BBMODE	Variabile  presente  nella versione registrata.  Serve ad impostare
	il  funzionamento della macro __BOOT.  0=disattivata.  1-3:attivata
	(1-3  corrispondono  a 3 metodi di procedura diversa.  Esaminare il
	contenuto  della macro per conoscerli:  __BOOT e' prevalentemente a
	scopo dimostrativo).

@rem line 49
BT	Quando viene 'catturato' un bootblock, questa variabile riflette l'
	indirizzo del codice di boot.  L' indirizzo iniziale del boot sara'
	quindi  uguale a BT+$c.  In seguito al congelamento del boot, si e'
	soliti guardarne il contenuto (@{"D" link ComD}bt, @{"Q" link ComQ}bt, ...) e piazzare su di esso
	dei  Break-Point.  Poiche' essi andrebbero ad alterare il checksum,
	facendo si' che il sistema non lo esegua, occorre, in genere uscire
	con  @{"G" link ComG}pc.   Caricando  il boot tramite il boot-simulator di SV, Gpc
	non  e'  necessario,  poiche' il checksum viene calcolato prima del
	congelamento.

C0-9	Le  variabile  con nome @{U}C0@{UU},@{U}C1@{UU},...@{U}C9@{UU} andrebbero sempre definite come
	@{I}CUSTOM FUNCTION @{UI}  (comando  @{"==" link ComDefSym}),  poiche'  vengono  utilizzate  dai
	breakpoint e dal tracciamento condizionale (per essi l' espressione
	contenuta   in   queste  variabili  rappresenta  la  condizione  da
	verificare  per  attivare  il  freezer).  Alcune di esse contengono
	gia' delle impostazioni di default di comune utilita', che comunque
	possono   essere  variate  dall'  utente  nel  caso  non  risultino
	interessanti.
	C0:verifica  che  il  PC  non  punti  alla  ROM.   Utile per uscire
	   velocemente da chiamate alla ROM (es:  @{"T" link ComT}*&0);
	C1:verifica  che  non  sia  premuto  il  tasto  del  joystick.  Per
	   @{"breakpoint" link ComZ}  attivabili  tramite  pressione  di  un  tasto  o per
	   @{"tracciamenti" link ComT} a comando;
	C2:verifica che il pc punti al bootblock.

CHIP	Dimensione della memoria CHIP. (Esempio d' uso:@{U}@{"F" link ComF},CHIP,"data"@{UU})

COPLC(x) Fornisce  il  contenuto di uno dei due registri del copper COP@{B}x@{UB}LC.
	Questa  funzione  puo'  causare il momentaneo blocco del sistema al
	fine di cercare la copperlist attiva.  @{B}x@{UB} puo' valere 1, 2, -1 o -2.
	Con i due parametri positivi la ricerca e' effettuata solo la prima
	volta, mentre le successive utilizzano il valore presente in cache.
	I parametri negativi provocano una nuova ricerca incondizionata.

DC	Viene  aggiornata da molti comandi del monitor.  Riflette l' ultimo
	indirizzo  di  memoria  a  cui  si  e'  acceduto,  per  poter esser
	utilizzato come indirizzo di default successivamente dallo stesso o
	da  un  altro  comando.   Puo'  anche venir utilizzata direttamente
	dall' utente.

EA1(x)	Funzione:  disassembla l' istruzione all' indirizzo @{B}x@{UB} e restituisce
	il  valore  del primo indirizzo effettivo a cui essa fa riferimento
	l' istruzione.  Se non esiste il risultato e' 0.

EA2(x)	Funzione:  disassembla l' istruzione all' indirizzo @{B}x@{UB} e restituisce
	il   valore   del   secondo  indirizzo  effettivo  a  cui  essa  fa
	riferimento.  Se non esiste il risultato e' 0.

LEN	Fornisce  la  lunghezza dell' ultimo blocco di memoria allocato con
	il comando @{"Alloc" link ComAlloc}.

MEM	Fornisce l' indirizzo dell' ultimo segmento allocato con @{"Alloc" link ComAlloc}.

NOPBAK	Contiene  il  valore dell' ultima word di memoria sostituita con un
	opcode @{I}NOP.@{UI}  (Comando @{"KN" link ComKN} del @{"monitor" link Monitor} o @{U}ALT+SHIFT+X@{UU} del @{"RTM" link RTM}).

OFF	Costante. Valore: -1. Utile con i comandi switch.

ON	Costante. Valore: 0. Per i comandi switch.

PEEK(x)	Funzione:   restituisce  il  contenuto  della longword (32bit) alla
	locazione di memoria specificata da @{B}x@{UB}.

PEEKB(x) Funzione:    restituisce  il  contenuto  della  byte  (8bit)  alla
	locazione di memoria specificata da @{B}x@{UB}.

PEEKW(x) Funzione:   restituisce  il  contenuto  della  word  (16bit)  alla
	locazione di memoria specificata da @{B}x@{UB}.

RES(x)	Funzione:  i comandi di ricerca o simili spesso forniscono numerosi
	risultati.   Essi,  oltre  ad  essere  visualizzati  sullo schermo,
	vengono  memorizzati  in  un  buffer  temporaneo, le cui dimensioni
	possono   essere  specificate  nella  procedura  di  configurazione
	tramite  @{"Result array" link SVInstaller.guide/Misc 10}.   I  dati  di  questo  buffer possono essere
	ottenuti  tramite  questa  funzione.  L' argomento @{B}x@{UB} della funzione
	indica  il  numero  del dato desiderato.  Se @{B}x@{UB} e' negativo, il dato
	viene scelto partendo dall' ultimo presente nel buffer (Es.:RES(-2)
	fornisce  il  penultimo  risultato ottenuto dall' ultimo comando di
	ricerca effettuato in precedenza).

SSP	Registro 680x0 SSP (congelato).  La variabile e' @{I}Read Only,@{UI} poiche'
	in  realta'  il  registro  SSP  del  programma dopo il congelamento
	differisce   di   alcune  unita',  infatti,  come  descritto  nella
	trattazione  del  comando  @{"X" link ComX},  viene  creato  uno  stack  frame  di
	eccezione.  Di conseguenza il registro SSP va modificato tramite il
	comando per la gestione dei registri (@{"X" link ComX}), ricordandosi di replicare
	il   frame  qualora  si  volesse  cambiare  indirizzo  dello  stack
	supervisore.

bplcn01	Contiene  i  valori  dei  registri  bplcon0(31:16) e bplcon1{15:0).
	L'utente  puo',  tramite  questa  variabile,  aiutare  il freezer a
	ripristinare  il  suo  valore  originale,  oppure  lasciarlo al suo
	valore di default.

bplmod	L'  omonimo  registro  hardware  write  only  viene  utilizzato dal
	monitor.   L'utente  puo',  tramite  questa  variabile,  aiutare il
	freezer a ripristinare il suo valore originale, oppure lasciarlo al
	suo valore di default.

beamcon0	I  16bit  meno significativi di questa variabile contengono
	il  valore del registro hardware BEAMCON0.  Il bit 31 e' usato come
	flag.  A questo proposito occorre fare un certo discorsetto:  SV e'
	in   grado   di   gestire   autonomamente   questo   registro  solo
	parzialmente.   Se  si  lavora unicamente nei modi standard PAL e/o
	NTSC,  il freezer si adatta automaticamente alla modalita' corrente
	e  lavora  senza  problemi.   Se  invece  si  utilizzano  modalita'
	grafiche  avanzate  (in genere con il workbench), occorre impostare
	il  valore  per  il  rispristino  corretto  del  suddetto registro.
	Normalmente la procedura di installazione si occupa automaticamente
	del problema controllando il tipo di modo video in uso.  Se il modo
	video  e'  di  tipo  standard  setta  il bit31 di questa variabile,
	indicando  al  freezer  di non toccare beamcon0, ma di adattarsi di
	volta  in volta alla modalita' NTSC/PAL corrente.  Se il modo video
	e'  di  tipo  programmabile  carica  nella variabile l' appropriato
	valore  del  registro ed azzera il bit31, segnalando al freezer che
	alla  sua attivazione dovra' forzare una modalita' standard ed allo
	scongelamento   dovra'  ripristinare  lo  stato  originale  facendo
	riferimento al contenuto di questa variabile.

blanker	Registro  di  controllo  del  blanker.   I  bit 24-31 (le due cifre
	esadecimali   piu'   a   sinistra)   indicano   la   modalita'   di
	funzionamento:       0=spento,1=diminuisce      i     colori     di
	intensita',2=oscura  totalmente lo schermo.  I bit 0-15 (le quattro
	cifre  esadecimali  piu' a destra) indicano il tempo di inattivita'
	del  canale  di input, in secondi, che deve trascorrere prima dell'
	attivazione del blanker.

cacr	Registro CACR (congelato) del 68020 e superiori.

ciaaicr	Registro CIAAicr (congelato). Validi solo i primi 8 bit!

ciaapra	Registro CIAApra (congelato). Validi solo i primi 8 bit!

color	Colore  dello  sfondo  (bit{31:16}),  e  del  testo (bit{15:0}) del
	monitor

ddf	Contiene i valori della coppia di registri DDFSTRT e DDFSTOP, posti
	rispettivamente  nella word piu' significativa(DDFSTRT) e in quella
	meno significativa(DDFSTOP).  Questa variabile viene utilizzata per
	il ripristino dei suddetti registri al momento dello scongelamento.
	In  alcuni  casi  l'  utente  dovra'  agire su questa variabile per
	ottenere   un   corretto   ripristino  del  display  del  programma
	congelato.

dsk	Indirizzo di default per i comandi del disco.

diw	Contiene i valori della coppia di registri DDFSTRT e DDFSTOP.  Vale
	lo stesso discorso fatto per la variabile @{I}ddf.@{UI}

fmode	I 16bit meno significativi di questa variabile contengono il valore
	dell'  omonimo  registro hardware FMODE (AGA only).  Vale lo stesso
	discorso fatto per la variabile @{I}ddf.@{UI}

intena	Registro INTENA (congelato). Validi solo i primi 16 bit!

intreq	Registro INTREQ (congelato). Validi solo i primi 16 bit!

int1-7	Indirizzo  degli  autovettori di interrupt.  Usare queste variabili
	per leggerli e/o modificarli.  NON usare nessun altro sistema!!!

keydel	Ritardo prima della ripetizione dei tasti.

keyrep	Velocita' di ripetizione.

m0-9	Sono 10 registri a disposizione dell' utente.  Andrebbero usati per
	memorizzare  indirizzi  di  memoria  di accesso frequente.  Possono
	essere  letti  e  scritti normalmente come tutte le altre variabili
	tramite   @{"RealTimeMonitor" link RTM}.   Esso  infatti  utilizza  come @{I}mark0-9 @{UI}
	proprio questi registri.

oldcolh	Utilizzata  per  il  ripristino dei colori 0/1.  Con il chipset AGA
	viene  impostata  automaticamente  e  non richiede intervento dell'
	utente.

oldcoll	Con  il  chipset  AGA  riflette i bit meno significativi dei colori
	0/1.  Non richiede intervento da parte dell' utente.

pc	Registro 680x0 PC (congelato).

rtm	Variabile:    indirizzo   iniziale  per  il  @{"RealTimeMonitor" link RTM}.   Per
	spostarsi   velocemente   in  una  zona  di  memoria  completamente
	differente  con  il  RTM  si puo' agire su questa variabile.  Utile
	anche per l' implementazione di nuovi funzioni RTM via @{"macro" link Macros}.

rtmdefmode	Visuale di default per @{"RTM" link RTM}.

rtmmode	Visuale corrente del @{"RTM" link RTM}.

scroll	Permette  di  regolare  il  tempo  di rallentamento dello scrolling
	(espresso  in  cinquantesimi  o  sessantesimi  di secondo a seconda
	della  modalita'  PAL  o  NTSC  in  uso) utilizzato quando si tiene
	premuto  il  tasto @{I}ALT.@{UI}  Se il bit31 e' attivo il monitor regola di
	volta  in  volta  automaticamente  questo  valore; se e' uguale a 0
	rimane il valore impostato dall' utente.

tab	Distanza tra i punti di tabulazione.

timerA	{31:24}:CIAAtalo,{23:16}:CIAAtahi,{15:8}:CIAAtblo,{7:0}:CIAAtbhi.

timerB	{15:8}:CIABtalo,{7:0}:CIABtahi.

usp	Registro 680x0 USP (congelato).
@endnode

@node Macros "SUPERVISOR® Documentation: Monitor/Macro"
@prev Strings
@next Tutorial
                               @{U}@{B}Macro-Comandi@{UB}@{UU}

  Le  macro  non  sono  altro  che  Macro-Comandi  definibili dall' utente,
contenenti  sequenze  di  comandi  elementari e/o comandi speciali appositi
specifici  delle  macro.   Una macro puo' essere richiamata/attivata in tre
modi diversi:
a)come  comando  (@{"Bnomemacro" link ComB2},  oppure,  nel  caso la funzione @{"AutoMacro" link SVInstaller.guide/Macros 5} sia
  stata attivata, digitando semplicemente il suo nome);
b)tramite la pressione di un tasto funzione prescelto;
c)programmandola per attivarsi automaticamente all' avviamento del monitor,
  quando il codice di congelamento coincide con quello richiesto.

@{U}Struttura di un file di macro@{UU}:
  I  file  di  macro  possono  essere  realizzati con un semplice editor di
testo,  dopodiche', puo' essere aggiunto alla lista delle macro del monitor
tramite la procedura di @{"configurazione" link SVInstaller.guide/Macros}.
  Il file di macro puo' contenere un numero qualsiasi di macro e deve avere
la seguente struttura:

-@{I}definizione macro @{UI}
-@{I}n linee di comandi @{UI} (1  solo  comando  per  linea:   non  si puo' usare la
 sequenza @{B}::@{UB})
-@{I}definizione nuova macro@{UI}
-....
-@{B}##@{UB} per  terminare  le  definizioni.   L'  elaborazione del file ha termine
 quando  viene  incontrata  una  linea  iniziante con questi due caratteri;
 tutto  cio'  che si trova dopo non viene esaminato.  LE DEFINIZIONI DEVONO
 SEMPRE TERMINARE CON QUESTA SEQUENZA!
-le linee che iniziano con il carattere @{B};@{UB} non vengono esaminate.

NOTA:   al momento dell' installazione del programma il file di macro viene
caricato  in  memoria,  e  quindi  elaborato.   Se  durante questa fase non
vengono  riscontrati  errori,  le  macro  vengono aggiunte alla lista delle
macro interne del monitor.


  Segue una lista dei comandi speciali per le macro:

  I  seguenti  comandi  sono presi in considerazione durante la costruzione
della  tabella  delle macro.  Tutti iniziano con il carattere @{B}#@{UB} all' inizio
della linea.

@{B}## o NULL(0x00)@{UB}	:termine definizioni
@{B}#\\@{UB}		:il  carattere  @{B}#@{UB}  viene  considerato  dall'  interprete un
                :carattere  speciale  di  controllo.   Qualora  si  volesse
		:utilizzarlo  come  semplice  carattere  all' inizio di una
		:linea  occorre  far  uso della sequenza @{B}#\\@{UB}, la quale viene
		:sostituita dal carattere @{B}#@{UB}.
@{B}#:name[,func#]@{UB}  :definisce  una  nuova  macro  di  nome @{U}name@{UU}.  Il parametro
		:opzionale  @{U}func#@{UU}  rappresenta il numero del tasto funzione
		:con il quale la macro puo' venir richiamata.
@{B}#C[code]@{UB}	:(dopo  il  comando  @{B}#:@{UB}) definisce il codice di attivazione
		:di una  macro.  Quando  questo  coincide  con il codice di
		:congelamento (@{"FREEZE_MODE" link supervisor/supervisor.i/main}), la macro viene automaticamente
		:attivata.   @{U}code@{UU} indica il codice da assegnare alla macro.
		:Se omesso viene assegnato il codice 0.
@{B}#A@{UB}		:per   far  attivare  una  macro  automaticamente  ad  ogni
		:richiamo del freezer.

  I  seguenti comandi vengono presi in considerazione durante l' esecuzione
della  macro in cui sono contenuti.  Tutti iniziano con il carattere @{B}@@{UB} all'
inizio della linea di comando.

@{B}@ECHO@{UB}		:attiva/disattiva  la  visualizzazione  dei  comandi di una
		:macro durante la sua esecuzione (locale).
@{B}@FNC n@{UB}		:esegue la funzione @{I}n.@{UI}
@{B}@IF expr@{UB}	:inizio  condizionale:   se  il risultato dell' @{"espressione" link Eval}
		:@{I}expr @{UI} e'  diverso  da  @{I}0 @{UI}esegue tutti i successivi comandi
		:sino all' istruzione @{B}@ELSE@{UB} o @{B}@ENDC@{UB}.
@{B}@ELSE@{UB}		:esegue  tutti  i  comandi  successivi sino all' istruzione
		:@{B}@ENDC@{UB}  qualora  l' espressione della precedente istruzione
		:@{B}@IF@{UB}  avesse  dato  risultato  @{I}0 @{UI}vengono eseguiti i comandi
		:compresi   tra   questa  istruzione  (se  presente)  e  il
		:successivo @{B}@ENDC@{UB}.
@{B}@ENDC@{UB}		:fine del condizionale.
@{B}@PRINT "txt"|expr[,N]@{UB}	:visualizza  un testo @{U}txt@{UU} (deve essere indicato tra
		:virgolette, in modo da essere riconosciuto) o il risultato
		:di  una  @{"espressione" link Eval} @{U}expr@{UU}.  Se presente il parametro @{I}N,@{UI} al
		:termine  del  testo  non viene effettuato un cambio linea.
		:Il   risulato  dell'  @{"espressione" link Eval}  viene  visualizzato  in
		:decimale.
@{B}@HPRINT "txt"|expr[,N]@{UB}	:visualizza  un testo @{U}txt@{UU} (deve essere indicato tra
		:virgolette, in modo da essere riconosciuto) o il risultato
		:di  una  espressione @{U}expr@{UU}.  Se presente il parametro @{I}N,@{UI} al
		:termine  del  testo  non viene effettuato un cambio linea.
		:Il   risulato  dell'  @{"espressione" link Eval}  viene  visualizzato  in
		:esadecimale.
@{B}@GOTO label@{UB}	:sposta  l'  esecuzione  della macro alla linea specificata
		:(@{U}label@{UU}).
@{B}@LAB label@{UB}	:etichetta una linea per il comando @{B}@GOTO@{UB}.
@{B}@QUIT@{UB}		:termina  l'  esecuzione della macro.  Utile in particolare
		:nei condizionali.

  La sequenza \\n, che puo' essere presente in qualsiasi luogo su una linea
NON  contenente  un comando speciale (ossia su tutte linee che non iniziano
con  il  carattere  @),  viene sostituita con il parametro il cui numero d'
ordine e' n.
  Quando  si  invoca una macro, tutto cio' che e' stato digitato di seguito
al  suo  nome  viene  preso come PARAMETRO.  Il primo parametro deve essere
separato  dal  nome  tramite  almeno  uno  SPAZIO vuoto, i successivi vanno
separati da virgole!
  Ad esempio se si digita:
DIV 8,2
  i  due  parametri 8 e 2 potrebbero venir utilizzati in un' ipotetica macro
  di nome DIV nella linea:
?\\1/\\2
  dando origine a:
?8/2
  la  quale  avrebbe  l'  effetto  di  stampare  sullo  schermo 4, ossia il
quoziente della divisione 8:2.

                                    ---

  Tramite macro e' possibile realizzare un vero e proprio programma, creare
nuovi  comandi,  ...   in  pratica  si puo' potenziare SUPERVISOR sino all'
inverosimile.   Quando  avro'  abbastanza tempo a disposizione scrivero' un
Tutorial approfondito sull' argomento.

***  Le  macro possono essere utilizzate anche per settare alcuni parametri
iniziali  del  monitor  non definibili direttamente tramite la procedura di
configurazione,  come  ad  esempio  per la creazione/definizione automatica
variabili  personalizzate  ad  ogni  avviamento del monitor.  Allo scopo di
facilitare   la   cosa,  il  monitor  alla  sua  prima  attivazione  esegue
automaticamente la macro di nome @{B}AUTOCONFIG@{UB}, se presente.

NOTA:   Questa  funzione  NON  e'  disponibile  nella versione dimostrativa
(Evaluation  Version).   Questa  ed  alcune altre funzioni sono disponibili
solamente nella versione @{"registrata" link Notice}.
@endnode

@node Tutorial "SUPERVISOR® Documentation: Monitor/Consigli ed Esempi"
@prev Macros
@next Tutorial
                            @{B}CONSIGLI ED ESEMPI@{UB}

  SUPERVISOR  e'  un  programma  estremamente  potente  e versatile, le cui
prestazioni  variano,  come  gia'  detto  in  precedenza,  in rapporto alla
macchina su cui gira e al grado di conoscenza/esperienza dell' utente.
  Eccellenti   risultati   sono   ottenibili   anche   con   configurazioni
estremamente scarse (68000/1Mb/Original Chipset), ma e' richiesto un grosso
lavoro da parte dell' utente.  Con configurazioni piu' @{I}spinte @{UI}l' intervento
manuale e' ridotto al minimo.
  Un  ruolo importantissimo, valido per qualsiasi configurazione, e' svolto
dalle  @{I}funzioni  avanzate @{UI} e  dalle  @{I}macro.@{UI}   Tramite esse e' possibile far
svolgere,  ad  esempio,  al  programma  diverse  funzioni in modo del tutto
automatico   ed   intelligente.    Si   puo'   far  si'  che  SV  riconosca
automaticamente il programma in esecuzione ed intraprenda delle determinate
azioni  su  di esso,  senza  alcun   intervento  manuale.  Tuttavia @{"Macro" link Macros} e
@{"Funzioni Avanzate" link Adv}  NON sono disponibili nella versione dimostrativa.  Invia
i  tuoi  contributi all' @{"autore" link Address} di questo programma ed otterrai la versione
Completa (Registered Version).

  SV  puo'  anche servire a far funzionare certi giochi che si rifiutano di
girare   su   talune   macchine.   Una  grande  quantita'  di  problemi  e'
riscontrabile  ad  esempio  con  l' AMIGA4000/040.  Le cause in genere sono
legate a:
-@{I}CPU: @{UI}  il  programma  non  e'  cache  compatibile,  oppure  le usa in modo
scorretto  (sono  ancora  moltissimi  i  programmatori che non sanno che le
cache  sul  68040  sono  gestite in maniera diversa rispetto al 68020/030).
Accessi  ad  indirizzi  illegali (diversi programmi, a causa di qualche bug
non scoperto nella fase di testing, accedono di tanto in tanto ad indirizzi
al  di fuori della loro area di lavoro.  Cio' viene rilevato dall' hardware
di  gestione della memoria il quale genera un @{B}Address Error)@{UB}.  Problemi con
il  prefetch.   Problemi di velocita':  se un programma gira interamente in
memoria  chip  con  le  cache  disabilitate  la  velocita' di esecuzione e'
INFERIORE rispetto a quella di un A500/68000!!!.
-@{I}Kickstart: @{UI}il programma non gira correttamente sotto 3.x
-@{I}Memoria: @{UI}  il  programma  non  usa  il sistema per il riconoscimento della
memoria  fast  e ne ricerca la presenza agli indirizzi @{B}0x200000@{UB} e @{B}0xC00000@{UB},
oppure  si  sta  utilizzando  un @{B}RAMKick@{UB}, il quale non riconosce la memoria
fast specifica dell' A4000 (non essendo autoconfigurante).
  @{I}Tutti  questi  problemi  sono facilmente risolvibili con SV,@{UI} infatti esso
permette, tra l' altro, di:
- disabilitare le cache nei momenti in cui queste causano problemi, per poi
riabilitarle quando necessario;
- intercettare le istruzioni privilegiate;
- disabilitare la protezione sulla memoria (@{B}@{"M" link ComM}$de0000,$7f7f@{UB});
- aggiungere memoria non configurata dal kickstart (@{B}@{"IA" link ComIA}addr,size@{UB});
- far  si'  che  un  programma  si  installi  in memoria @{B}FAST@{UB}, mettere vite
  infinite, estrarre i moduli Noise/ProTracker, ...

  Ma  veniamo  ora  alla  questione  piu'  importante.  Fino ad ora abbiamo
parlato  di  cio' che si puo' far con SV ma non di COME lo si fa.
  Tutte  le attivita' vengono svolte dal monitor il quale viene attivato in
seguito  al  congelamento del sistema, permettendone cosi' la piu' completa
monitorizzazione e controllo.  Qui di seguito parleremo solo dell' utilizzo
MANUALE  di  SV,  poiche'  il  funzionamento  automatico viene trattato nel
capitolo  ad esso riservato, ed inoltre, per potersene servire(=programmare
delle azioni automatiche) occorre conoscere il funzionamento manuale!
  La  funzione  @{B}FakeVBR@{UB} (non disponibile con CPU 68000:  richiede almeno il
68010)  permette  di prendere il controllo in maniera immediata della quasi
totalita'  del  software:   in  pratica  di  tutti  quei  programmi che non
utilizzano  il  registro  VBR.   Con  la  modalita'  normale  il  controllo
immediato  e'  ottenibile  solo  se  i  vettori  di  interrupt  non vengono
modificati.
   Qualora  il freezer non sia attivabile occorrera' un certo intervento da
parte  dell'  utente.   Il  caso  classico  e'  quello dei programmi che si
avviano dal BootBlock.
1-Installare  SV  con  @{B}MakeResident=ON@{UB}  e @{B}BootCapture=ON@{UB} (gia' attivi nella
configurazione  di  default),  e  resettare  con  il  disco  contenente  il
programma da esaminare nel drive.
2-Al caricamento del @{I}BootBlock @{UI}il monitor si attivera' automaticamente.  La
variabile @{"BT" link VARS 49} conterra' l' indirizzo del BootCode.  Digitare @{B}Dbt@{UB}, e studiare
il codice di avviamento.
3-Piazzare   gli   opportuni  @{I}BreakPoint @{UI} e  riavviare.   Nota:   piazzando
BreakPoint sul codice di Boot si altera il suo checksum, facendo si' che il
sistema  non  lo  esegua.   Il  sistema  migliore  percio'  consiste  nell'
eseguirlo manualmente ad esempio uscendo dal monitor con @{B}gBT@{UB}.
(Gli  utenti  registrati  si  possono servire delle due @{"macro" link Macros} dimostrative,
@{B}GOBT@{UB} e @{B}__BOOT@{UB}.)
4-Seguire  il  programma,  eventualmente  piazzando altri BreakPoint, o con
comandi  di  tracciamento  (@{B}T@{UB}),  sino  al  raggiungimento della routine che
installa gli handler di interrupt.  Normalmente non occorre alcuna modifica
ad   essa:    piazzare  un  BreakPoint  sull'  istruzione  successiva  all'
istallazione  degli  interrupt.   SV  prendera'  il controllo a quel punto.
Allo  scongelamento  gli  handler  di  SV  verranno  concatenati  a  quelli
preesistenti.


                   ---> @{U}@{B}Forse non sapevate che ...@{UB}@{UU} <---

  SUPERVISOR e' dotato di numerosissime funzioni di cui spesso se ne ignora
l'  esistenza  (nemmeno  io  le ricordo tutte!).  A questo scopo di seguito
sono  riassunte alcune caratteristiche interessanti del programma.  In piu'
ricordo  che  e' presente una tabella riassuntiva dei comandi sia in questo
manuale che in un file ASCII separato.  Tuttavia e' bene tener presente che
cio'  non  costituisce affatto una trattazione dettagliata ed esauriente di
ogni aspetto di SUPERVISOR, per la quale rimando alla lettura integrale del
presente manuale!

o Il  monitor  puo' gestire piu' pagine di lavoro (configurabili al momento
  dell'  installazione).   Tramite il tasto F10 e' possibile passare da una
  pagina  all'  altra.  E' utile avere almeno due pagine a disposizione, in
  modo  da  disporre  di  un'  area  ausiliaria  in cui effettuare tutte le
  operazioni di 'contorno' senza compromettere l' area di lavoro.

o E'  fondamentale  conoscere  a  fondo  il  sistema di variabili di cui e'
  dotato  SUPERVISOR.   Esse  agevolano  in  maniera  veramente notevole il
  lavoro  con  il  monitor.   Si passa dalle semplici variabili utente, che
  possono  essere  usate ad esempio per 'appuntare' valori importanti, alle
  variabili  di sistema, che permettono di effettuare importanti operazioni
  speciali, alle funzioni predefinite e quelle programmabili.
  Alcune  variabili  sono  dedicate  al RTM.  Esse possono essere usate per
  controllarlo  o  per ottenerne informazioni da utilizzare con il monitor.
  (Es.  variabile @{B}rtm@{UB}).  I 'mark' effettuati tramite ALT+SHIFT+0..9 vengono
  memorizzati nelle corrispondenti variabili 'm0' ...  'm9'.

o Il  @{"RTM" link RTM}  e'  un' efficientissima alternativa a molte funzioni di indagine
  sulla  memoria  e  di  debug  del  monitor.  Da notare la possibilita' di
  visualizzare tutte locazioni trovate dall' ultima funzione di ricerca.

o La  macro  @{B}AUTOCONFIG@{UB}  puo'  essere  usata  per  effettuare  tutte quelle
  preimpostazioni  non effettuabili tramite la procedura di configurazione,
  come ad esempio la definizione di variabili.

o I  @{"BreakPoint" link ComZ} e i comandi di @{"traccia" link ComT} condizionali talvolta possono essere
  la chiave per risolvere i piu' intricati problemi.

o Dalla   versione  1.26  si  ha  a  disposizione  un  potente  sistema  di
  tracciamento  in  grado di mappare tutte le istruzioni eseguite dalla CPU
  entro  un'  area  di memoria prestabilita.  Vedere @{"PC-tracer" link ComTracePC} per maggiori
  informazioni.

o SV  puo'  anche  essere  utilizzato  come  debugger  di file eseguibili o
  simulare il boot del disco a sistema gia' caricato.  Vedi @{"parametri CLI" link SVInstaller.guide/Config}.

o I  primi  tre tasti del tastierino (esistono anche i corrispettivi CTRL-G
  per  @{I}ScrollLock @{UI} e  CTRL-S  per @{I}SmartScrolling @{UI}sulla tastiera principale)
  SHIFTati  commutano  l'  abilitazione  di tre funzioni speciali:  @{I}NumLock
@{UI}  (permette di utilizzare il tastierino per muovere il cursore), @{I}ScrollLock
@{UI}  (blocca   lo  scrolling),  @{I}SmartScrolling @{UI} (effettua  la  visualizzazione
  automatica  di ulteriori linee di output in ogni qualvolta si provoca uno
  scorrimento  dello  schermo  spingendo  il  cursore  verso  l' estremita'
  inferiore o superiore dello schermo).

o Se  avete una discreta quantita' di RAM non siate avari e riservatene una
  certa  parte a SUPERVISOR.  Con i settaggi di default SUPERVISOR funziona
  egregiamente, ma e' comunque ben lontano dal massimo delle sue capacita'.
  Infatti,  a  parte  il fatto, piuttosto evidente, che con poca memoria si
  hanno  seri  problemi  nel  salvare  dati  trovati  con Gfx/PT-ripper, ma
  soprattutto  si  perde un gran numero di servizi aggiuntivi (che vanno da
  semplici  mappe  di  memoria  del sistema a tabelle di velocizzazione per
  varie funzioni) che SV offre quando le risorse lo permettono.

o I  comandi  @{"UA" link ComUA} e @{"UB" link ComUB} sono utilissimi per ricercare i settaggi dei registri
hardware  all'  interno di un programma, ed anche per trovare tante cosette
interessanti.   Non  dimentichiamoci  che  sono in grado di interpretare un
programma! Faro' solo un piccolo esempio per chiarire:
 @{B}UB$dff180@{UB}
puo'  trovare  l'  istruzione  680x0 che accede all' indirizzo $DFF180 all'
interno di una routine del tipo:
	lea	$dff100,a1
	lea	$60(a1),a2
--->	move.w	#$f,$20(a2)	;<--- accesso all' indirizzo $DFF180
Il  passo  successivo  a  questo  punto  dovrebbe essere @{I}ALT+A @{UI}e @{I}ALT+B,@{UI} per
visualizzare con il RealTimeMonitor i risultati della ricerca.  (Ovviamente
non tutte le istruzioni e modi di indirizzamento possibili sono supportati,
ma  cio'  e'  piu'  che  sufficiente  a far si' che delle routine, le quali
potrebbero  richiedere  molte  ore  di  lavoro  per essere trovate, vengano
invece @{I}stanate @{UI}in non piu' di un paio di secondi!!!).

** La  tastiera  e'  personalizzabile,  per  cui  i  tasti  sopra  nominati
   (riferiti alla configurazione di default) possono non corrispondere!
@endnode

@node DDOSInfo "SUPERVISOR® Documentation: About Disk System"
@prev DDOSInfo
@next DDOSInfo
@{U}@{B}Informazioni tecniche@{UB}@{UU}:
  Per  chiunque  desideri  utilizzare  questo  tipo  formato  ecco  i  dati
necessari:

Tracks: 164
Fisical sectors per track: 1
Bytes per sector: 6184 (0x1828)

SyncMark:0x4489

The Track structure:

	 2*SYNC	(0x4489 MFM)
	 1*INFO	(encoded:8 bytes) ID:0x17,TRACK#,Reserved(NULL),Reserved(NULL)
      6184 DATA	(encoded:12368 bytes)
     1*CHECKSUM	(encoded:8 bytes) (SYNC and INFO are not included in checksum)


Encoding:
  Each  longword  (4 bytes) is encoded into 2 longwords using the following
routine:

_Encode	;_Encode(UncodedLong,Buffer)(D0,A1)
	move.l	#$55555555,d6	;mask
encode	move.l	d0,d3	;jump here if D6 is already loaded
	lsr.l	#1,d0
	bsr.s	.1
	move.l	d3,d0
.1	and.l	d6,d0
	move.l	d0,d2
	eor.l	d6,d2
	move.l	d2,d1
	lsl.l	#1,d2
	lsr.l	#1,d1
	bset	#$1f,d1
	and.l	d2,d1
	or.l	d1,d0
	btst	#0,-1(a1)
	beq.s	.2
	bclr	#$1f,d0
.2	move.l	d0,(a1)+
	rts


The CheckSum:

CheckSum	;CheckSum(DataBlock)(A0),Result(32bitBlockCheckSum)(D0)
	move.w	#blocklen/4-1,d2	;blocklen=6184
	moveq	#-1,d0
.loop	move.l	(a0)+,d1
	eor.l	d1,d0
	dbf	d2,.loop
	rts


Example of Track Encoding:

;Presets:
gap	equ	500
safe	equ	1
longlen	equ	$1828

MakeTrack	;MakeTrack(UncodedBlock,RawTrackBuffer,Track)(A0,A1,D1.b)
		;Results(RawTrackBuffer,DskLen)(A2,D1.w)
	move.l	a1,a2	;save raw buffer start
	move.l	#$aaaaaaaa,d6	;0x00 MFM ENCODED
	move.w	#gap/2-1,d0
.1	move.l	d6,(a1)+
	dbf	d0,.1

	move.l	#$44894489,(a1)+
	lsr.l	#1,d6
	moveq	#$17,d0		;format identifier
	lsl.l	#8,d0
	move.b	d1,d0		;id+trknumb
	swap	d0
	bsr	encode		;write header

	move.w	#longlen/4-1,d4
	moveq	#-1,d5		;checksum
.2	move.l	(a0)+,d0	;get long from buffer
	eor.l	d0,d5		;calc. checksum
	bsr	encode		;encode long
	dbf	d4,.2
	move.l	d5,d0
	bsr	encode		;store checksum
	moveq	#0,d0		;dummy
	bsr	encode
	move.w	#$c000+gap+10+longlen+safe,d1	;10 is syncword+id+cksum
	rts	;You can use D1 to load DSKLEN(note that density isn't set)
;--------------------------------------------------------------------------

 Da  notare  come la SyncWord, l' inizio dell' intestazione della traccia e
la  relativa  codifica  in  MFM siano simili a quelle del formato AmigaDOS:
questo  e'  stato  fatto  volutamente affinche' fosse possibile riconoscere
velocemente   il   formato  della  traccia.   In  questo  modo,  un  Loader
multiformato  (come  quello  interno a SUPERVISOR), leggendo la traccia una
sola  volta  (stesso SyncMark), puo' riconoscerne immediatamente il formato
(longword  di identificazione memorizzata in formato compatibile) e passare
direttamente alla relativa decodifica!

* Ho intenzione di sviluppare, un giorno o l' altro, il @{U}fattrack.device@{UU} per
consentire l' utilizzo dei dischi formattati con questo sistema anche sotto
AMIGADOS.
@endnode

@node Adv "SUPERVISOR® Documentation: Gestione Avanzata"
@prev Adv
@next Adv
                             @{B}GESTIONE AVANZATA@{UB}

  SV  in  modo  @{I}Residente @{UI}offre la possibilita' di essere controllato da un
programma  esterno.   Il tutto avviene tramite la struttura SVTAG.  Essa e'
utilizzabile  solo  in  seguito ad una installazione RESIDENTE del monitor.
Il  puntatore ad essa si ottiene tramite la procedura descritta nella macro
@{"FINDSV" link supervisor/supervisor.i/main}  contenuta nel file include @{"supervisor/supervisor.i" link supervisor/supervisor.i/main}.  Nella versione
@{"dimostrativa" link Notice},   riconoscibile   dall'   ID  @{B}SVDEMOID@{UB}  la  struttura  e'  da
considerarsi valida, consistente ed attendibile solo fino ad @{B}svdemo_SIZEOF@{UB},
tutti  gli  altri  campi  sono  da considerarsi privati.  Raccomando di non
provare  ad  usare  assolutamente  ne'  in lettura ne' in scrittura tutti i
campi  seguenti  @{B}svdemo_SIZEOF@{UB}  nella  versione  dimostrativa,  poiche', lo
ribadisco  ancora  una volta:  la versione dimostrativa e quella registrata
non  differiscono  di  un  semplice  @{I}flag,@{UI}  ma  hanno  @{U}notevoli  differenze
strutturali@{UU},   ed   inoltre   non  e'  possibile  effettuare  il  controllo
preliminare  di  consistenza descritto di seguito, da farsi SEMPRE prima di
utilizzare la struttura:

-verificare (ed eventualmente lockare:  usare BSET) se la struttura e' gia'
 in  uso  da  parte  di altri task.  (Questo viene fatto automaticamente da
 @{"FINDSV" link supervisor/supervisor.i/main})

-verificare  che  st_ID sia uguale a SVID e SVTAG+RT_VERSION non sia minore
 di  SVVER.   Una  differente  st_ID indica che la struttura e' cambiata in
 modo  radicale  e non e' piu' compatibile con le precedenti versioni.  Una
 RT_VERSION  maggiore,  rispetto  a quella ricercata, indica la presenza di
 nuovi  elementi  nella  struttura,  ma assicura la completa compatibilita'
 delle parti preesistenti.

@{B}Analizziamo la struttura@{UB}:
@{U}st_CacheCon@{UU}	funzione   di   controllo   Cache:   va  chiamata  in  modo
		@{I}supervisore @{UI}  con  @{U}A5=SVdata@{UU},  @{U}D0=CacheBits@{UU},  @{U}D1=CacheMask@{UU}.
		(Analoga a @{I}Exec/CacheControl(),@{UI} ma non richiede la presenza
		del sistema).
@{U}st_CacheClr@{UU}	funzione di pulizia Cache:  va chiamata in modo @{I}supervisore@{UI}
		con   @{U}A5=SVdata@{UU}.   Analoga  a  @{I}Exec/CacheClearU(),@{UI}  ma  non
		richiede la presenza del sistema.
@{U}st_CHIPS@{UU}	bit{15:8}=agnus type/bit{7:0}=denise type
@{U}st_CPU@{UU}		copia  di Exec/AttnFlags (SV dispone di una routine interna
		per la rilevazione della CPU, in modo da avere informazioni
		consistenti  anche  sotto S.O.  1.3, ma anche e soprattutto
		per  non  dipendere  dalla  presenza del sistema al momento
		della  chiamata;  tuttavia  le  informazioni  riportate  in
		questa   variabile   sono   prelevate  dalle  strutture  di
		sistema, per motivi che non sto a descrivere).
@{U}st_DATA@{UU}		puntatore all' area dati di SV.
@{U}st_DisIO@{UU}	se  <>0 disabilita la cattura del BootBlock(ammesso che sia
		stata  selezionata  nella  fase  di  installazione).   Fare
		riferimento    alle    macro   @{"DISABLEBOOTBLOCKCAPTURE" link supervisor/supervisor.i/main}   ed
		@{"ENABLEBOOTBLOCKCAPTURE" link supervisor/supervisor.i/main}.
@{U}st_ID@{UU}		id della struttura (descritto in precedenza).
@{U}st_Install@{UU}	***privato.
@{U}st_NewUHandlers@{UU}	se   durante   l'  esecuzione  del  monitor  si  effettuano
		modifiche  alla  struttura  @{"UserHandler" link supervisor/supervisor.i/main}, per accertarsi che
		esse   vengano  attivate  immediatamente  occorre  chiamare
		questa funzione con @{U}A5=SVdata@{UU}.  Un tipico uso e' in caso di
		ridirezione   temporanea  dell'  output  (ad  esempio  alla
		stampante).
@{U}st_NewVBR@{UU}	va  chiamata  per  informare  SV  del  cambiamento  di VBR.
		st_VBR   va   preventivamente   aggiornato   dal  programma
		chiamante  con il nuovo valore di VBR.  In seguito a questa
		chiamata  l'  utente  dovrebbe  occuparsi  di effettuare un
		CacheClear.
@{U}st_NewVBR2@{UU}	come  st_NewVBR,  ma  in  questo  caso  non occorre settare
		st_VBR,   ne'   occuparsi  delle  Cache.   Questa  funzione
		richiede  pero', a differenza di st_NewVBR, Exec, in quanto
		fa  uso  della funzione Exec/Supervisor per passare in modo
		Supervisore  (necessario  per manipolare direttamente VBR e
		CACR).   st_VBR  viene  settato  automaticamente  da questa
		funzione.
@{U}st_PrgLen@{UU}	dimensioni del codice di SV.
@{U}st_PrgStart@{UU}	indirizzo iniziale del codice di SV.
@{U}st_RemoveSV@{UU}	rimuove SV dalla lista dei moduli residenti.
@{U}st_Seg@{UU}		ultimo file caricato con @{U}DEBUG/K@{UU} (o @{U}-D@{UU}).
@{U}st_Serial@{UU}	numero di serie del programma (==#utente).
@{U}st_SVMem@{UU}	puntatore al blocco di memoria esterna.
@{U}st_SVMemLen@{UU}	dimensione del blocco di memoria esterna.
@{U}st_TextStream@{UU}	parametri per la formattazione di @{U}UserText@{UU}.
@{U}st_UserEntry@{UU}	chiamando  questa  funzione  (@{U}jsr  st_UserEntry(SVTAG)@{UU})  si
		causa  un' attivazione del freezer:  il programma chiamante
		verra' dunque congelato.
@{U}st_UserHandler@{UU}	puntatore alla struttura @{"UserHandler" link supervisor/supervisor.i/main} (creata dall' utente).
		Tramite  questa  struttura  e'  possibile interagire con un
		programma  esterno:   si puo' ampliare il set di funzioni e
		di  comandi,  ridirezionare input e output (per la gestione
		di questi ultimi far riferimento alla @{"tabella" link CharTab} dei codici di
		controllo), nonche' rendere SV parte di un programma ancora
		piu' complesso.
@{U}st_UserInfo@{UU}	puntatore alla struttura @{"UserInfo" link supervisor/supervisor.i/main}.
@{U}st_UserText@{UU}	testo utente.  Il suo utilizzo da parte del monitor dipende
		dal  settagio  dei  @{"flags" link supervisor/supervisor.i/main}  STF_APPENDUTEXT, STF_USERFTTXT e
		STF_USERHEADER.
@{U}st_VBR@{UU}		puntatore alla tabella dei vettori di eccezione.
@{U}st_WarnSub@{UU}	questa  puntatore  viene  definito dall' utente, in modo da
		puntare ad un propria routine, che viene richiamata ad ogni
		attivazione  del Freezer, in modo da informare un programma
		esterno  dell'  evento.   Cio'  avviene solo se STB_WARN e'
		posto ad 1.
st_Seg		Puntatore  BCPL  alla  seglist  del  modulo  di  cui si sta
		effettuando il debug.
st_NewUHandlers	Questa  funzione  va  chiamata  per  rendere immediatamente
		attivi  i cambiamenti effettuati alla struttura UserHandler
		durante mentre il monitor e' gia' attivo.
st_InternalLoadSeg		Analoga  all'  omonima funzione del DOS36+,
				ma  utilizzabile sotto qualsiasi KickStart.
				Vedere autodocs del DOS per i parametri.
st_InternalLoadSegDebug		Come la precedente, ma in piu' carica tutte
				le   informazioni  di  debug  eventualmente
				contenute   nel   file   all'  interno  del
				monitor.
st_InternalUnLoadSeg		Anche per questa funzione vale quanto detto
				in  precedenza.  Questa funzione puo' anche
				causare    la   rimozione   di   tutte   le
				informazioni    di    debug   caricate   in
				precedenza  (in  base  a  quanto  stabilito
				dall' utente in fase di configurazione).

**NOTA:   A  partire  da  SUPERVISOR 1.28 va controllato il bit STB_DEMO in
st_Flags  per  verificare  se si e' in presenza della versione dimostrativa
(STB_DEMO=1)  o  di quella registrata (STB_DEMO=0).  Ho deciso di rimuovere
alcune  limitazioni  che impedivano un' adeguata valutazione del programma.
Cio'  ha  reso  necessaria  di  una  struttura SVTAG piu' consistente, che,
pertanto,  ora  reca  lo  stesso  codice  di identificazione della versione
registrata in st_ID.  In @{"supervisor.i" link supervisor/supervisor.i/main} sono elencati i campi utilizzabili.
@endnode

@node Eval "SUPERVISOR® Documentation: Monitor/Valutazione numerica"
@prev VARS
@next Strings
@{B}@{U}Valutazione numerica@{UU}@{UB}:

  Ogni  qualvolta  sia  richiesta l' immissione di un valore numerico, esso
puo'  essere  dedotto  da un' intera espressione matematica.  Le operazioni
supportate sono le seguenti:

+ @{I}addizione@{UI} (a+b)
- @{I}sottrazione@{UI} (a-b)
* @{I}prodotto@{UI} (a*b)
/ @{I}rapporto@{UI} (a/b)
^ @{I}elevamento a potenza@{UI} (a^b)
! @{I}or logico@{UI} (a!b)
| @{I}or esclusivo logico@{UI} (a|b)
& @{I}and logico@{UI} (a&b)
~ @{I}complemento a 1 @{UI}(~a)
- @{I}complemento a 2 @{UI}(-a)
\\ @{I}indirizzamento  indiretto  a  memoria postindicizzato@{UI} (a\\b).  Viene letta
  una  longword  all' indirizzo 'a&$fffffffe'  e  vi  viene  sommato b.  Ad
  esempio:  D4\\-456 disassembla il vettore della funzione Exec/DoIO.
<< @{I}scorrimento binario a sinistra@{UI} (a<<b)
>> @{I}scorrimento binario a destra@{UI} (a>>b)
<= @{I}confronto: minoranza o uguaglianza@{UI} (a<=b)
>= @{I}confronto: maggioranza o uguaglianza@{UI} (a>=b)
< @{I}confronto: minoranza@{UI} (a<b)
> @{I}confronto: maggioranza@{UI} (a>b)
= @{I}confronto: uguaglianza@{UI} (a=b)

  Il  risultato  delle  operazioni  di  confronto e' -1 se la condizione e'
vera, 0 se non lo e'.

-L' espressione puo' essere composta da uno o puo' numeri espressi in una o
 piu' delle seguenti basi:

$ esadecimale	*I numeri possono terminare in K(<<10) o M(<<20)
@ ottale	*I numeri possono terminare in K(<<10) o M(<<20)
% binario	*I numeri possono terminare in K(<<10) o M(<<20)
# decimale	*I numeri possono terminare in K(<<10) o M(<<20)
"' ASCII. Le  virgolette  ("  oppure  ') vanno poste anche al termine della
          stringa  ASCII,  se  dopo  di  essa  occorra specificare un altro
          parametro,  poiche' altrimenti la virgola di separazione verrebbe
          considerata  come  parte  della  stringa.   Il  carattere di fine
          stringa deve essere lo stesso utilizzato all' inizio (' con ' e "
          con  ").   Qualora  si  voglia  utilizzare lo stesso carattere di
          identificazione  all' interno della stringa occorre digitarlo due
          volte consecutive ('I''m').
.bp BreakPoint. E'  una 'base' speciale, che serve ad agevolare la gestione
		dei  BreakPoint.  'bp' e' un numero decimale compreso tra 1
		e   il   numero  di  BreakPoint  attualmente  settati,  che
		rappresenta  il  numero d' ordine del BreakPoint desiderato
		(il   numero  d' ordine   viene   fornito   nella   tabella
		visualizzabile  col  comando @{"." link ComBPLst}.  La funzione restituisce l'
		indirizzo in cui e' localizzato il BreakPoint specificato.
_bank#		Ritorna l' indirizzo del banco di memoria desiderato. @{U}bank#@{UU}
		rappresenta il numero del banco desiderato.
` assembly	Restituisce il codice operativo dell' istruzione assembly.

  Ogni  numero  va preceduto dal carattere che identifica la base in cui e'
espresso  (es:$60000  sta  per 60000 esadecimale).  I numeri espressi nella
base di default, configurabile dall' utente (inizialmente base 10), possono
essere  espressi  senza  il  relativo  carattere  di identificazione.  Sono
accettati  i suffissi @{I}K @{UI}e @{I}M,@{UI} i quali moltiplicano il numero rispettivamente
per 2^10 e 2^20.
  All'  interno  di  un'  espressione  numerica i numeri sono trattati come
interi  di  32  bit (al limite estesi allineati a destra se piu' piccoli, o
troncati  in  caso di tipo assembly con codice operativo piu' maggiore di 2
word  (sono  considerate  le prime 2)).  In caso di parametri-stringa, come
quelli  richiesti da alcuni comandi (@{"F" link ComF}, @{"FI" link ComFI}, @{"FM" link ComFM}, ...) la dimensione dei dati
espressi  in  esadecimale,  binario, ASCII o assembly, e' limitata solo dal
buffer di linea.
  Sono  supportati  anche  vari  tipi  di  @{"variabili" link VARS}.   Esse  possono venir
utilizzate in luogo di un qualsiasi numero.
  Le  operazioni vengono effettuate rispettando le priorita' che ha ciascun
operatore.   Possono  venir  utilizzate  parentesi.   Le  parentesi possono
essere nidificate.  Esempio:  -((PC+5)*6/4-(($1234^7)+~3)-6=%10101+"1234")
@endnode

@node Strings "SUPERVISOR® Documentation: Monitor/Stringhe"
@prev Eval
@next Macros
@{B}@{U}I parametri stringa@{UU}@{UB}:

  I parametri stringa possono includere qualsiasi tipo di carattere tenendo
presente che:
1-gli spazi vengono soppressi
2-le  virgole determinano la fine del paramentro e quindi non possono venir
  incluse all' interno della stringa

  Per  poter utilizzare spazi e virgole all' interno di una stringa, quest'
ultima  deve  essere  racchiusa  tra  virgolette (" o ').  La virgoletta di
chiusura (facoltativa a meno che non debba seguire un altro parametro) deve
essere  la  stessa  utilizzata  in apertura (" con " e ' con ').  Per poter
utilizzare  delle  virgolette  come  caratteri  all' interno di una stringa
utilizzare  un  carattere  diverso da quello usato in apertura (" con ' o '
con "), oppure raddoppiarlo ("" o '') se uguale a quello usato in apertura.
@endnode

@node DCnote "SUPERVISOR® Documentation: Monitor/Variabili/DC"
@prev DCnote
@next DCnote
                           @{U}@{B}Indirizzo di default@{UB}@{UU}

  Molti  comandi che agiscono sulla memoria fanno riferimento ad una comune
variabile  di  default,  quando  non  e' presente il parametro indicante l'
indirizzo  iniziale  (generalmente  @{U}start@{UU})  sulla linea di comando.  Questa
variabile viene aggiornata al termine dell' esecuzione degli stessi comandi
in  modo da contenere il valore dell' indirizzo al quale sono giunti a quel
punto.  Cio' permette di accedere rapidamente a zone di memoria consecutive
con  uno  o  piu' comandi in successione, senza preoccuparsi di specificare
alcun indirizzo.
  Ad  ogni  ingresso al monitor la suddetta variabile viene caricata con il
valore del registro PC congelato.
  L'  utente  puo'  inoltre  farvi  riferimento esplicito (in sola lettura)
tramite la @{"variabile" link VARS} @{I}DC.@{UI}
@endnode

@node Troubles "SUPERVISOR®: Trouble-shooting"
@prev SVInstaller.guide/Troubles
@next Troubles
	@{U}@{B}Problemi nell' uso del Freezer/Monitor:@{UB}@{UU}

@{B}- Il  programma  dopo  l' installazione non risulta configurato esattamente
  come definito nella procedura di configurazione.@{UB}
  Cio'  e'  dovuto  al  fatto che sono stati incontrati problemi al momento
  dell'  installazione  del  monitor,  ma tali da consentirne ugualmente il
  corretto funzionamento.  Alcuni esempi:
  a)FONT  e/o  KEYMAP  non  trovati.   Viene  visualizzato  un avviso sulla
  finestra di output, ripiegando poi su FONT e/o KEYMAP di default.
  b)Minor  numero  di  pagine  di  quelle richieste, oppure buffer di vario
  genere  di  dimensioni  minori  di  quelle  richieste  o  totalmente  non
  disponibili.    Cio'   e'   causato   da   mancanza  di  @{"Memoria Esterna" link SVInstaller.guide/Tech}.
  Specificare un @{"Data size" link SVInstaller.guide/FrzCtrl 25} di dimensioni maggiori.

@{B}- @{"Joy+Mouse Freeze" link ComSetFK}  selezionato,  ma  il  freezer non si attiva premendo il
  tasto del mouse e quello del joystick.@{UB}
  Sotto  1.3,  in  genere  occorre  anche  premere un tasto qualsiasi sulla
  tastiera per attivare gli interrupt di @{"livello 2" link ComIVEC}.

@{B}- Sullo  schermo  del  monitor  viene  visualizzata  una  fastidiosa  linea
  verticale.@{UB}
  Per  default  SV  non  tocca  i registri degli sprites durante la fase di
  congelamento.   Si  limita  a  disattivarne  il  DMA  durante il vertical
  blanking.   Per  disattivare  effettivamente  gli  sprites  utilizzare il
  comando  @{"!L" link ComResScr}.   Tramite  @{"macro" link Macros}  questa  procedura  puo'  essere effettuata
  automaticamente ad ogni attivazione del monitor.

@{B}- Allo scongelamento di un programma il display risulta confuso.@{UB}
  Cio'  e'  dato  dal  fatto  che alcuni registri hardware sono settati una
  volta  sola  dal  programma e non sono mai gestiti dalla copperlist, come
  normalmente  avviene.   Con  l'  aiuto  dei comandi @{"UA" link ComUA} e @{"UB" link ComUB} ricercare nel
  programma   i   valori   originali   dei   registri   (normalmente   sono
  DDFSTRT/DDFSTOP[$dff92/94] e BPL1MOD[$dff108] se il display e' totalmente
  confuso;  se  mancano dei colori o c' e' qualche bitplane sganciato, o la
  risoluzione  e'  differente  si  tratta  di  BPLCON0[$dff100];  se  nell'
  immagine appaiono elementi che non dovrebbero essere visibili la causa e'
  DIWSTRT/DIWSTOP[$dff08e/90]).   E'  consigliabile crearsi una @{"macro" link Macros} con i
  settaggi  necessari  per  ogni  programma  di  questo tipo in modo da non
  perdere tempo ogni volta.

@{B}- Alcuni programmi non funzionano con SV in memoria.@{UB}
  o Se si dispone di poca memoria la causa e' molto probabilmente dovuta al
    fatto  che  il programma va a distruggere l' area in cui e' situato SV.
    Se  si sa che quel determinato programma puo' funzionare anche con soli
    512Kb  di  RAM e si dispone di almeno un 1Mb, installare SV nei 512K di
    memoria  piu' alti, far si' che il programma veda solo 512K di memoria,
    utilizzando il comando @{"IK" link ComIK} o agendo manualmente sul codice.
  o Se  si  dispone  di molta memoria e una CPU superiore al 68000 la causa
    potrebbe   essere   attribuita   all'   utilizzo   del   modo  FakeVBR,
    incompatibile  con  alcuni  rari  programmi  che  in  genere copiano la
    tabella  dei  vettori  in  pagina  zero  facendo  si'  che il codice di
    eccezione richiami se stesso all' infinito.  Utilizzare il modo FakeVBR
    (comando @{">" link ComPCON}) fino a poco prima del momento in cui si sa per certo che il
    programma  si  blocca,  congelare e passare al modo normale, oppure non
    utilizzarlo affatto, oppure intervenire sul programma stesso.

@{B}- Quando SV e' residente in seguito ad un reset la macchina va in GURU.@{UB}
  a)Prima del reboot qualche programma ha danneggiato gravemente l' area di
  memoria  in cui SV risiede.  Se la funzione @{"Safe Reset" link SVInstaller.guide/FrzCtrl 90} e' attivata provare
  a tener premuto il pulsante del Joystick durante il reset:  cio' dovrebbe
  causare una reinizializzazione totale del sistema.  Altrimenti occorre un
  @{I}ColdReboot:@{UI}  spegnere e riaccendere il computer!
  b)Si e' lasciato l' @{I}autofire @{UI}inserito.  Leggere la descrizione del gadget
  @{"Safe Reset" link SVInstaller.guide/FrzCtrl 90} nella documentazione della procedura di @{"installazione" link SVInstaller.guide/main}.

- @{B}Il monitor confonde i caratteri del nome del comando con quelli del primo
  parametro.@{UB}
  Un  caso  classico  e'  con  il  comando  F:   se  ad  esempio si volesse
  effettuare  una  ricerca  della stringa $123456 dall' indirizzo contenuto
  nella variabile inizio all' indirizzo inizio+$1000 si dovrebbe scrivere:
	@{I}Finizio,inizio+$1000,$123456 @{UI}
  ma,  esistendo  anche  il  comando  FI, il monitor interpreterebbe la 'i'
  iniziale  del  primo  parametro  come facente parte del nome del suddetto
  comando @{"FI" link ComFI}, prendendo quindi la restante parte 'bc' come parametro, dando
  conseguentemente  risultati  diversi da quelli desiderati.  Per ovviare a
  questo  inconveniente  e'  sufficiente racchiudere il primo parametro tra
  parentesi tonde () (nel nostro esempio quindi:  F(inizio),inizio+...).
  Qualcuno  risolve  il  problema separando il parametro con uno spazio, ma
  personalmente  sconsiglio  questo metodo poiche' funziona solo con alcuni
  comandi  e  anche  per  questi  ultimi non e' garantito essere supportato
  in futuro.

- @{B}Confusione tra macro e comandi normali.@{UB}
  Le  macro  possono  essere  invocate esplicitamente tramite il comando b,
  mentre i comandi possono essere contraddistinti dal prefisso _. Esempi:
	@{I}bCOPIA invece di COPIA per non confonderla con il comando CO 
	_I invece di I per non confonderlo con l' ipotetica macro INFO @{UI}

	@{"Problemi nella fase di installazione" link SVInstaller.guide/Troubles}
@endnode

@node Bugs "SUPERVISOR®: Bug Reports"
@prev Bugs
@next Bugs
                                @{B}Bug Reports@{UB}

  Please  before  reporting  any bugs make sure your problem is a real bug!
So first read carefully the manual and the @{"throuble-shooting" link Troubles} section:  what
you  believe  is  a  BUG  may  be  a program feature, or an improperly used
function  that  led  to  strange  or  disastrous  results  (such  as system
crashes!).
  If your problem cannot be solved send your reports to my @{"address" link Address}, and
please, don't write just @{I}SV doesn't work.@{UI} That doesn't help me tracking
the source of the problem. I need the following information:

a) Installer  &  SUPERVISOR  version  (they  are  both  shown in the status
   window).
b) The machine you are using:
   - MODEL (A500(+)/600/1200/2000/2500/3000/4000/CDTV/CD32/...)
   - CPU (68000/010/020/030/040/...).
   - CUSTOM CHIPSET (NORMAL/ECS AGNUS or ALICE, NORMAL/ECS DENISE, ...).
   - SYSTEM VERSION (Kickstart and Workbench at least).
   - MEMORY type (CHIP, FAST, LOCAL, ...), size and address.
     Eg:  $505 (FAST), at $7800000-$7FFFFFF (8.0 meg).
   * You  can get this information from @{I}SysInfo @{UI}(type:  @{U}SysInfo -p >ram:cfg@{UU}
     then send me the output file @{B}ram:cfg@{UB}) or @{I}ShowConfig @{UI}(type:  @{U}ShowConfig@{UU}
     @{U}>ram:cfg@{UU} then send me the output file @{B}ram:cfg@{UB}).
c) The programs which were multitasking while SV was running.
d) If SVInstaller was started from CLI or from Workbench.
e) Load  SVInstaller  WITHOUT  the  options  @{U}NOCHECK@{UU}  & @{U}AUTO@{UU}, then save the
   configuration and include it in your report).
f) Describe your problem and the circumstances under which it arises.


           -- Consigli e Suggerimenti sono sempre ben accetti --
@endnode

@node Notice "SUPERVISOR®: Copyright and License"
@prev Notice
@next Notice
                                 @{B}Copyright@{UB}

  This  program  is  @{B}SHAREWARE@{UB}  that  means  that if you find it useful you
should  send  me $10 (or more!) and you'll get the @{B}registered version@{UB}.  The
@{B}registered  version@{UB}  has  advanced commands/features, faster/more efficient
code, no time restrictions, and Config files enabled.
  The  @{B}evaluation version@{UB} (@{B}demo@{UB}) will allow you to test SV capabilities but
it is not suitable for intensive use.
  @{B}NOTE:@{UB}    although   the  @{B}demo@{UB}  and  @{B}registered@{UB}  versions  have  the  same
installation  code,  the Freezer/Monitor code is DIFFERENT, so don't try to
crack  ...  you' ll have to rewrite a lot of routines that are NOT included
in the @{B}evaluation version@{UB}.  (You have been warned, don't waste your time!).

  @{B}SUPERVISOR@{UB}  is  @{B}copyright  (c)1992-1997 @{UB}by@{B} THE 1702 GROUP@{UB}, any commercial
usage  or  selling  of  this  program,  without  written  authorization, is
@{U}@{B}ABSOLUTELY FORBIDDEN@{UB}@{UU}.

  This  software  is  provided  @{B}AS IS@{UB}  without warranty of any kind, either
expressed  or implied.  By using it, you agree to accept the entire risk as
to the quality and performance of the program.

---------------------------------------------------------------------------
L'  AUTORE  NON SI ASSUME ALCUNA RESPONSABILITA' IN MERITO A QUALUNQUE COSA
DI  QUALUNQUE  GENERE  DERIVANTE  DALL'  USO  DI  QUESTO  PRODOTTO  (DANNI,
MALFUNZIONAMENTI,  BUG  ...)!   L'  UTENTE  SE  NE  SERVE  A  SUO RISCHIO E
PERICOLO!   QUALSIASI  EVENTUALE  AZIONE  ILLEGALE  PERPETRATA PER MEZZO DI
QUESTO  PROGRAMMA  NON E' IMPUTABILE AL SOTTOSCRITTO, BENSI' A COLUI CHE HA
SCELTO  DI  FARNE  UN  USO  IMPROPRIO.   MI  RISERVO  INOLTRE IL DIRITTO DI
SOSPENDERE  LO  SVILUPPO  DI  NUOVE VERSIONI DEL PROGRAMMA O DI VARIARLE IN
MANIERA  DIVERSA  RISPETTO A QUANTO RIPORTATO NELLA PRESENTE DOCUMENTAZIONE
IN QUALSIASI MOMENTO E SENZA ALCUN PREAVVISO!
---------------------------------------------------------------------------

DAN of THE 1702 GROUP 
(Lo  sviluppo  di questo programma mi e' costato moltissimo tempo...  spero
sia utile a molti!)
@endnode

@node HowToRegister "SUPERVISOR®: Registrazione"
                               @{U}@{B}Registrazione@{UB}@{UU}

  Se desideri registrarti hai due possibilita':

o @{B}Ricevere  il programma per posta@{UB}:  invia un vaglia postale di almeno Lit.
17000  (diciassettemila)  al  mio  @{"indirizzo" link Address}  e  ti  verra'  recapitato  il
dischetto con la versione registrata.

o @{B}Prelevare il programma via modem@{UB}:  invia un vaglia postale di almeno Lit.
10000  (diecimila)  al  mio  @{"indirizzo" link Address}.   Ti  contattero'  e  potrai subito
prelevare  l'  archivio  con la versione registrata via modem.  (Se abiti a
Roma e possiedi un modem questa e' senza dubbio la soluzione piu' veloce ed
economica!)

  @{I}Gli utenti registrati possono prelevare le update gratuitamente via modem
chiamandomi  al  mio  numero,  oppure  ricerverle per posta inviandomi Lit.
5000 (cinquemila).@{UI}
@endnode

@node DemoLimits "SUPERVISOR®: Demo Restrictions"
@prev DemoLimits
@next DemoLimits
                  @{U}@{B}Limitazioni della versione dimostrativa@{UB}@{UU}

	@{"Limitazioni dell' INSTALLER" link SVInstaller.guide/DemoLimits}

	@{U}Limitazioni di SUPERVISOR@{UU}:
- Alla prima attivazione del monitor viene visualizzato per qualche secondo
  un  messaggio che ricorda di registrarsi qualora si trovasse il programma
  intessante.
- Il tempo d' uso e' limitato.
- Alcune routine sono piu' lente e sensibilmente meno efficienti.
- Le @{"funzioni avanzate" link Adv} per il controllo esterno non sono disponibili.
- Il  monitor  non  fa  uso  di  schermi in modo interlacciato ed e' quindi
  limitato ad un massimo 35 righe anziche' 70.
- Il sistema di gestione @{"macro" link Macros} non e' presente.
- Il  menu @{"utility" link SVInstaller.guide/Util} dell' installer (che permette il salvataggio di moduli e
  picture)  non  e'  presente,  per cui il salvataggio di grafica e musiche
  estratti  con  gli appositi Gfx&ModuleRipper inclusi nel monitor, risulta
  molto piu' scomodo.
- I  comandi
  @{"IA" link ComIA},	@{"B" link ComB2},	@{"#B" link ComMACB},
  @{"#E" link ComMACE},	@{"#F" link ComMACF},	@{"#I" link ComMACI},
  @{"#L" link ComMACL},	@{"#U" link ComEdFK},	@{"IH" link ComIH},
  @{"IH!" link ComIH}
  non  sono  presenti.   Inoltre il comando @{"OC" link ComRip 49} perde di utilita', in quanto
  manca il menu @{"utility" link SVInstaller.guide/Util} nell' installer.
@endnode

@node History "SUPERVISOR®: History"
@prev SVInstaller.guide/History
@next History
	@{"Installer History" link SVInstaller.guide/History 142}

	@{U}@{B}SUPERVISOR History@{UB}@{UU}:

@{I}@{B}V0.99 Released in 1993 @{UB}@{UI}
Versione  ßeta.  Distribuita solamente ad un numero ristretto di persone, a
scopo di prova.

@{I}@{B}V1.0a (1994) Not Released @{UB}@{UI}
Mai messa in circolazione ufficialmente.  La descrizione di questa versione
e' integrata alle successive (1.0b/c).

@{I}@{B}V1.0b/c Released in November/December 1994 @{UB}@{UI}
Codice notevolmente ampliato/migliorato/corretto.  Molte routine sono state
completamente  riscritte  rispetto  alla v0.99.  I cambiamenti sono tanti e
tali  che  risultano  pressoche'  impossibili  da elencare.  Per di piu' le
precedenti  versioni  non dovrebbero essere in possesso di nessuno, per cui
un confronto dettagliato non sarebbe di grande utilita'.

@{I}@{B}V1.1 Released on 24/12/94 @{UB}@{UI}
@{I}BugFix:@{UI}
- Disassembler:    correzioni,   miglioramenti   vari   (es:   il  registro
  destinazione del comando @{I}LEA @{UI}veniva disassemblato scorrettamente).
- Comando  @{"X" link ComX}.   Riorganizzato  l'  output  in maniera piu' ordinata (Con il
  68030   i   bit   del   registro   @{I}CACR @{UI} non  entravano  in  una  linea).
  Aggiunte/migliorate varie cosette qua e la'.
- Funzione @{"RES()" link VARS} in alcuni casi forniva risultati errati.
- Varie.

@{I}Cambiamenti/Aggiunte:@{UI}
- Riconoscimento automatico di macro, senza dover ricorrere al comando @{"B" link ComB2}.
- Task Capture (comandi @{"!W" link ComCapTask} e @{"!M" link ComTask}).
- Nuovi comandi di ricerca attraverso il codice (@{"UA" link ComUA} e @{"UB" link ComUB}).
- Maggiori e piu' comprensibili messaggi informativi qua e la'.
- Ottimizzazioni  di  codice  varie, di irrilevante interesse per l' utente
  finale.

@{I}@{B}V1.11 Released on 9/1/95 @{UB}@{UI}
@{I}BugFix:@{UI}
- Comandi  @{"UA" link ComUA}/@{"UB" link ComUB}:   una  residua istruzione di debug causava l' alterazione
  del contenuto delle locazioni $80000-$80007.

@{I}Cambiamenti/Aggiunte:@{UI}
- Comando @{"#X" link ComExtCom}.
- Potenziate/migliorate alcune routine.  Tra l' altro, ora SV puo' accedere
  ad  indirizzi  dispari  in  presenza di processore 68020 o superiori.  Il
  parametro   @{"Force Even" link SVInstaller.guide/Misc 126}  nella  procedura  di  installazione  consente  di
  disabilitare  questa  caratteristica,  dal  momento  che  esistono alcune
  vecchie   schede  con  68020  che  non  supportano  questa  modalita'  di
  funzionamento propria di questo processore e dei suoi discendenti.
- Documentazione  dei  comandi  @{"K" link ComK}  e @{"KS" link ComKS}.  Sino ad oggi (15/1/95) questi due
  utilissimi  comandi  erano  menzionati  unicamente nell' help interno del
  monitor.   Il  manuale  non  li  nominava  neppure.   Ringrazio Giulio D'
  Ambrosio per avermi fatto scoprire questa mancanza.

@{I}@{B}V1.2ß Released on 19/2/95 @{UB}@{UI}
Questa release contiene numerosissimi miglioramenti/aggiunte/bugfix.  Spero
di non tralasciare nulla di importante!
**NOTA:  ßeta Release:  non e' ancora stato effettuato un testing adeguato.

@{I}BugFix:@{UI}
- MEGABUG  galattico  nell'  handler  della  tastiera  corretto, eliminato,
  distrutto.
- Tonnellate di correzioni varie.

@{I}Miglioramenti e aggiunte:@{UI}
- Documentazione:   @{"tabella" link RefCard}  riepilogativa  di  tutti i comandi aggiunta in
  questo documento e come file ASCII separato.
- Supporto per INT3 esterni.
- (VERSIONE  REGISTRATA) Attivata/ampliata/migliorata la gestione dei tasti
  funzione (NOTA: l' utilizzo tramite macro non funzionava nelle precedenti
  versioni).
- @{"Real-Time-Monitor" link RTM}.
- @{"Memory Manager" link MemManager}.
- @{"BreakPoint" link ComZ} e @{"trace" link ComT} condizionali.
- E'  ora possibile utilizzare un filtro per la visualizzazione della lista
  delle variabili (comando @{"=/" link ComSymTab}).
- Gestione intelligente del registro @{"BEAMCON0" link VARS}.
- @{"Tastiera" link Keyboard}: nuovi tasti speciali (F8, SHIFT+BACKSPACE/DEL).
- Nuove @{"funzioni e variabili" link VARS}: ABS(), EA1() ,EA2(), d0-d7/a0-a7, RTM, BBMODE
  NOPBAK.
- (VERSIONE REGISTRATA) Nuove @{"macro" link Macros} dimostrative (AUTOCONFIG, __BOOT).
- Nuovo comando per macro (QUIT) e possibilita' di nidificare gli @{I}If.@{UI}
- Nuovi comandi monitor:
	@{"++" link ComRelB}
	@{"OM" link ComOM}
	@{"FD" link ComFD}
	@{"ER" link ComER}
	@{"EE" link ComEE}
	@{"KN" link ComKN}
	@{"KR" link ComKR}
	@{"EM" link ComEM}
	@{"#U" link ComEdFK} (VERSIONE REGISTRATA)

@{I}@{B}V1.21 Released on 5/4/95 @{UB}@{UI}
@{I}BugFix:@{UI}
- Corretto l' help interno e i documenti esterni.  (Erano presenti parecchi
  errori, omissioni, ed imprecisioni).
- Corretto  errore  nel comando @{"UT" link ComCLF} nel ripristino dello schermo del monitor
  in  modalita'  ECS/AGA:   i registri ECS/AGA venivano settati prima della
  disattivazione  del  @{I}copper,@{UI} generando in alcuni casi un display confuso,
  dovuto all' interferenza del suddetto coprocessore negli stessi registri.

@{I}Miglioramenti e aggiunte:@{UI}
- Supporto @{"MMU40" link SysConfig}.
- @{"Safe Reset" link SVInstaller.guide/FrzCtrl 83} disattivabile.
- Nuovi comandi @{"RTM" link RTM}: ALT+D, ALT+SHIFT+D, ALT+SHIFT+D.
- Migliorato  il sistema macro.  Il comando @{"#L" link ComMACL} e' ora operativo.  (VERSIONE
  REGISTRATA)
- La  funzione  di  BREAK  ora va effettuata tramite CTRL+ALT o CTRL+SHIFT,
  invece  che  con  il  solo  tasto  CTRL,  al fine di evitare interruzioni
  indesiderate di macro e comandi richiamati tramite CTRL+tastofunzione.

@{I}@{B}V1.22 Released on 21/5/95 @{UB}@{UI}
@{I}BugFix:@{UI}
- 680x0  disassembler:   alcune  istruzioni  illegali  erano  disassemblate
  scorrettamente.  Corretti problemi in modo 68000.
- @{"Macro" link Macros}:  la linea successiva al comando @{B}#C@{UB} veniva ignorata (non mi ero mai
  accorto  di  questo  problema  in quanto ero solito 'commentare' la linea
  successiva!)
- Vari.

@{I}Miglioramenti e aggiunte:@{UI}
- (VERSIONE  REGISTRATA)  Monitor:   puo'  far uso di schermi con fino a 70
  linee in modo interlacciato.
- 680x0 disassembler: aggiunta istruzione @{B}MOVE16@{UB}.
- Velocizzate e perfezionate alcune routine del RTM.
- CopperList-Finder:   migliorato  il  supporto  per  le  copperlist  AGA e
  regolati  i default iniziali in modo da renderli adatti ad un numero piu'
  vasto di situazioni senza intervento da parte dell' utente.
- Implementato  @{"GfxRipper" link ComGRip}:   e' ora possibile salvare gli schermi congelati
  in formato IFF (i modi AGA sono ovviamente supportati!).  I comandi sono:
	@{"2A" link ComGR2A}
	@{"2C" link ComGR2C}
	@{"2I" link ComGR2I}
	@{"2K" link ComGR2K}
	@{"2L" link ComGR2L}
	@{"2M" link ComGR2M}
	@{"2P" link ComGR2P}
	@{"2S" link ComGR2S}
	@{"2U" link ComGR2U}
	@{"2V" link ComGR2V}
(Alessandro: spero che ora sarai soddisfatto!)

@{I}@{B}V1.23 Released on 1/6/95 @{UB}@{UI}
@{I}BugFix:@{UI}
- Correzioni varie, in particolare nell' ambito del @{"GfxRipper" link ComGRip}.

@{I}Miglioramenti e aggiunte:@{UI}
- Nuovo parametro @{U}end@{UU} per il comando @{"2C" link ComGR2C}.
- Comando @{"2B" link ComGR2B}.

@{I}@{B}V1.24 Released on 4/9/95 @{UB}@{UI}
@{I}BugFix:@{UI}
- Numerose correzioni e perfezionamenti un po' dappertutto.

@{I}Miglioramenti e aggiunte:@{UI}
- Ripristino tastiera (vedi comando @{"{" link ComKRest}).
- (VERSIONE REGISTRATA) Velocizzate le routine di output.
- Reso il freezer ancora piu' efficiente.
- Riorganizzato l' @{I}help @{UI}interno.
- Self-Test  (configurabile):   SV  puo'  effettuare ad ogni attivazione un
  autocontrollo   sull'   integrita'   del   suo  codice  ed  eventualmente
  intraprendere  determinate  azioni  selezionabili tramite la procedura di
  installazione.
- Il  prompt  e'  ora  configurabile (per la verita' lo e' sempre stato, ma
  mancava l' opzione nell' installer).
- Ancora  miglioramenti  nel  GfxRipper.   Supporto  per  @{I}ExtraHalfBrite @{UI} e
  @{I}Bitplane ScanDoubling.@{UI}
- @{"MemoryManager" link MemManager} completato ed installato in numerosi comandi.
- @{"RTM" link RTM}.   Nuove funzioni:  @{U}AutoMark@{UU} (@{B}ALT@{UB}+@{B}-@{UB}), ResultLock (@{B}ALT@{UB}+@{B}L@{UB}), @{U}FindAddress@{UU}
  (@{B}ALT@{UB}+@{B}SHIFT@{UB}+@{B}F@{UB}).  Nuovi comandi di @{"configurazione" link ComEE}:  @{B}t@{UB} e @{B}!@{UB}
- (VERSIONE REGISTRATA) Nuove macro interne: @{B}CMP@{UB}, @{B}SPLIT@{UB}, @{B}SHOWCOP@{UB}.
- @{"Variabili" link VARS}:    funzione   @{B}COPEND@{UB},   variabile  @{B}NARG@{UB}  per  macro  (VERSIONE
  REGISTRATA).
- Nuovi comandi:
	@{"2N" link ComGR2N}
	@{"FM" link ComFM}

@{I}@{B}V1.25 Released on 19/6/96 @{UB}@{UI}
** Durante  gli  ultimi  mesi  ho  avuto  pochissimo tempo da dedicare allo
sviluppo  di  questo programma, percio' questa versione contiene unicamente
piccole   correzioni  (in  particolare  al  gfx-ripper,  che  ora  dovrebbe
funzionare  correttamente  con  pagine  di  qualsiasi dimensione) e qualche
piccolo  miglioramento,  che  sinceramente  non ricordo piu'.  Avrei voluto
mettere  in  circolazione  questa  versione  come  nuova MAJOR RELEASE, ma,
poiche'  finira' per slittare per qualche altro mese ancora, mi e' sembrato
opportuno far vedere che SUPERVISOR e' ancora vivo!

@{I}BugFix:@{UI}
- Correzioni  e  perfezionamenti vari al GfxRipper.  Se non ricordo male e'
  rimasto solo da ultimare il supporto per il dual playfield.
- Vari.

@{I}Miglioramenti e aggiunte:@{UI}
- Il  cursore  ora  indica  graficamente  (solido/trasparente)  lo stato di
  attesa  di  input o di elaborazione di un comando.  Utile se si decide di
  sopprimere il @{"Prompt" link SVInstaller.guide/Con 40}.
- ???

@{I}@{B}V1.26 Released on 07/12/96 @{UB}@{UI}
@{I}BugFix:@{UI}
- Rimossi (spero) tutti i problemi nella procedura di inizializzazione.
- La valutazione delle stringhe ASCII aveva qualche problema in presenza di
  determinati caratteri.
- Revisionato e perfezionato il memory-handler.
- Corretti tutti i bug nell' output in modalita' @{"keyboardrawkey" link ComRAW}.
- Pulizia  generale:  rimosso/sostituito/corretto/migliorato codice vecchio
  e instabile.

@{I}Miglioramenti e aggiunte:@{UI}
- @{"RTM" link RTM}:	o Supporto per @{I}keyboardrawkey @{UI}
	o Copper View + parametro di configurazione @{B}L@{UB} in @{"Dsm Settings" link Com1}
	o PC map (vedi sotto)
- @{"PC-tracer" link ComTracePC}.  I comandi sono:
	[MONITOR]
	@{"N!" link ComKillPCMap}		:Kill PC map
	@{"N" link ComN}		:Show PC map
	@{"T:" link ComTracePC}		:Trace PC
	[RTM]
	ALT+J		:Find previous PC difference
	ALT+K		:Find next PC difference
	ALT+SHIFT+K	:Kill PC map
	ALT+SHIFT+T	:Trace PC
- Il comando @{"?" link ComCalc}  (calculator) puo' opzionalmente visualizzare i risultati in
  un  formato  piu'  compatto.  Il tipo di output va impostato con il nuovo
  switch @{"??" link ComSCflg}.
- Assembler  di  linea.   SUPERVISOR  puo'  servirsi  del  miniassemblatore
  interno   o   di   uno  esterno  installabile  tramite  la  procedura  di
  configurazione.  I comandi sono:
	@{"3" link Com3}		:Config assembler
	@{"A" link ComA}		:Assemble (680x0)
- Nuovo datatype: @{"assembly" link Eval}.
- Disassembly simbolico.
	=> Nuovi @{"parametri" link Com1} di configurazione del disassembler:
		@{U}SymbolicDsm@{UU}, @{U}AutoLabels@{UU}
	=> Nuovo tipo di simbolo: LABEL, e relativi comandi di supporto:
		@{"=!" link ComZapLabs}
		@{"=$" link ComDefLab}
		@{"P" link ComP}  (esteso con nuovi parametri)
- Altri nuovi comandi: (VERSIONE REGISTRATA)
	@{"IH" link ComIH}		:Custom regs info
	@{"IH!" link ComIH}		:Custom regs info

@{I}@{B}V1.27 Released on 08/12/96 @{UB}@{UI}
@{I}BugFix:@{UI}
- Copper  disassembler  e PT-ripper erano stati rotti accidentalmente.  Ora
  dovrebbe essere tutto a posto.

@{I}@{B}V1.28 Released on 05/03/97 @{UB}@{UI} (CURRENT)
@{I}BugFix:@{UI}
- L' output del comando @{"L" link ComL} e' di nuovo editabile.
- Rimosso  ADDRESS ERROR nella fase di inizializzazione, che si manifestava
  in presenza di 68000 con un bel crash al momento dell' installazione.

@{I}Miglioramenti e aggiunte:@{UI}
- Assembler interno: implementato pseudo-opcode @{B}DC.x@{UB}.
- Nuova  @{"funzione" link VARS}:   @{B}COPLC()@{UB}.   Fornisce  il  valore dei registri COPLC1/2.
  Particolarmente utile in unione al GfxRipper (Es:@{B}2Ccoplc(2)@{UB}).
- Debugger:
      o @{"LibFile" link SVInstaller.guide/LibFile}:   il  disassembler  puo' ora visualizzare i nomi simbolici
	delle  funzioni  delle  librerie  di sistema tramite un @{"LibFile" link SVInstaller.guide/LibFile} che
	SUPERVISOR  genera mediante i Function Descriptor files (i .fd, per
	intenderci).
      o Loader:   completo  supporto  per  gli  overlay e per tutti i nuovi
	hunk fino al DOS40.
      o @{"Source-Level" link Source} (HCLN/LINE):  e' ora possibile monitorare direttamente
	il sorgente di un programma!
- Tastiera:   i tasti ALTernati possono essere scambiati con quelli normali
  (CTRL-ESC).   Il tastierino numerico puo' essere adibito al controllo del
  @{"RTM" link RTM}, rendendone l' uso piu' immediato.
- Supporto per il 68060.
@endnode

@node Address "SUPERVISOR®: Author Info"
@prev Address
@next Address

	@{U}@{B}Address@{UB}@{UU}

	Daniele Di Bella
	V.le Tito Livio 8
	00136 Roma, Italia
@endnode
