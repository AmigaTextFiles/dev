<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>man getopt_long(3)</title>

</head>
<body>
<div id="container">
<div id="top">
	<span class="title">
	manpagez: man pages &amp; more
	</span><br />
	<span class="subtitle">
	man getopt_long(3)
	</span>
</div>
<div id="toplink">

</div>
<div id="contentmenu">
<table width="100%" cellpadding="0">

</table>
</div>

<div id="content">
<pre>
getopt_long(3)           BSD Library Functions Manual           getopt_long(3)


</pre>
<h2>NAME</h2><pre>
     <b>getopt_long</b>, <b>getopt_long_only</b> -- get long options from command line argu-
     ment list


</pre>
<h2>LIBRARY</h2><pre>
     Standard C Library (libc, -lc)


</pre>
<h2>SYNOPSIS</h2><pre>
     <b>#include</b> <b>&lt;getopt.h&gt;</b>

     <i>extern</i> <i>char</i> <i>*optarg</i>;
     <i>extern</i> <i>int</i> <i>optind</i>;
     <i>extern</i> <i>int</i> <i>optopt</i>;
     <i>extern</i> <i>int</i> <i>opterr</i>;
     <i>extern</i> <i>int</i> <i>optreset</i>;

     <i>int</i>
     <b>getopt_long</b>(<i>int</i> <i>argc</i>, <i>char</i> <i>*</i> <i>const</i> <i>*argv</i>, <i>const</i> <i>char</i> <i>*optstring</i>,
         <i>const</i> <i>struct</i> <i>option</i> <i>*longopts</i>, <i>int</i> <i>*longindex</i>);

     <i>int</i>
     <b>getopt_long_only</b>(<i>int</i> <i>argc</i>, <i>char</i> <i>*</i> <i>const</i> <i>*argv</i>, <i>const</i> <i>char</i> <i>*optstring</i>,
         <i>const</i> <i>struct</i> <i>option</i> <i>*longopts</i>, <i>int</i> <i>*longindex</i>);


</pre>
<h2>DESCRIPTION</h2><pre>
     The <b>getopt_long</b>() function is similar to <b><a href="/man/3/getopt/">getopt(3)</a></b> but it accepts options
     in two forms: words and characters.  The <b>getopt_long</b>() function provides
     a superset of the functionality of <b><a href="/man/3/getopt/">getopt(3)</a></b>.  The <b>getopt_long</b>() function
     can be used in two ways.  In the first way, every long option understood
     by the program has a corresponding short option, and the option structure
     is only used to translate from long options to short options.  When used
     in this fashion, <b>getopt_long</b>() behaves identically to <b><a href="/man/3/getopt/">getopt(3)</a></b>.  This is
     a good way to add long option processing to an existing program with the
     minimum of rewriting.

     In the second mechanism, a long option sets a flag in the <i>option</i> struc-
     ture passed, or will store a pointer to the command line argument in the
     <i>option</i> structure passed to it for options that take arguments.  Addition-
     ally, the long option's argument may be specified as a single argument
     with an equal sign, e.g.,

           myprogram --myoption=somevalue

     When a long option is processed, the call to <b>getopt_long</b>() will return 0.
     For this reason, long option processing without shortcuts is not back-
     wards compatible with <b><a href="/man/3/getopt/">getopt(3)</a></b>.

     It is possible to combine these methods, providing for long options pro-
     cessing with short option equivalents for some options.  Less frequently
     used options would be processed as long options only.

     The <b>getopt_long</b>() call requires a structure to be initialized describing
     the long options.  The structure is:

           struct option {
                   char *name;
                   int has_arg;
                   int *flag;
                   int val;
           };

     The <i>name</i> field should contain the option name without the leading double
     dash.

     The <i>has</i><b>_</b><i>arg</i> field should be one of:

           no_argument        no argument to the option is expect
           required_argument  an argument to the option is required
           optional_argument  an argument to the option may be presented.

     If <i>flag</i> is not NULL, then the integer pointed to by it will be set to the
     value in the <i>val</i> field.  If the <i>flag</i> field is NULL, then the <i>val</i> field
     will be returned.  Setting <i>flag</i> to NULL and setting <i>val</i> to the corre-
     sponding short option will make this function act just like <b><a href="/man/3/getopt/">getopt(3)</a></b>.

     If the <i>longindex</i> field is not NULL, then the integer pointed to by it
     will be set to the index of the long option relative to <i>longopts</i>.

     The last element of the <i>longopts</i> array has to be filled with zeroes.

     The <b>getopt_long_only</b>() function behaves identically to <b>getopt_long</b>() with
     the exception that long options may start with `-' in addition to `--'.
     If an option starting with `-' does not match a long option but does
     match a single-character option, the single-character option is returned.


</pre>
<h2>RETURN VALUES</h2><pre>
     If the <i>flag</i> field in struct option is NULL, <b>getopt_long</b>() and
     <b>getopt_long_only</b>() return the value specified in the <i>val</i> field, which is
     usually just the corresponding short option.  If <i>flag</i> is not NULL, these
     functions return 0 and store <i>val</i> in the location pointed to by <i>flag</i>.
     These functions return `:' if there was a missing option argument, `?' if
     the user specified an unknown or ambiguous option, and -1 when the argu-
     ment list has been exhausted.


</pre>
<h2>EXAMPLES</h2><pre>
     int bflag, ch, fd;
     int daggerset;

     /* options descriptor */
     static struct option longopts[] = {
             { "buffy",      no_argument,            NULL,           'b' },
             { "fluoride",   required_argument,      NULL,           'f' },
             { "daggerset",  no_argument,            &amp;daggerset,     1 },
             { NULL,         0,                      NULL,           0 }
     };

     bflag = 0;
     while ((ch = getopt_long(argc, argv, "bf:", longopts, NULL)) != -1)
             switch (ch) {
             case 'b':
                     bflag = 1;
                     break;
             case 'f':
                     if ((fd = open(optarg, O_RDONLY, 0)) == -1)
                             err(1, "unable to open %s", optarg);
                     break;
             case 0:
                     if (daggerset) {
                             fprintf(stderr,"Buffy will use her dagger to "
                                 "apply fluoride to dracula's teeth\n");
                     }
                     break;
             default:
                     usage();
     }
     argc -= optind;
     argv += optind;


</pre>
<h2>IMPLEMENTATION DIFFERENCES</h2><pre>
     This section describes differences to the GNU implementation found in
     glibc-2.1.3:

     <b>o</b>   Setting of <i>optopt</i> for long options with <i>flag</i> != NULL:

         GNU  sets <i>optopt</i> to <i>val</i>.

         BSD  sets <i>optopt</i> to 0 (since <i>val</i> would never be returned).

     <b>o</b>   Setting of <i>optarg</i> for long options without an argument that are
         invoked via `-W' (`W;' in option string):

         GNU  sets <i>optarg</i> to the option name (the argument of `-W').

         BSD  sets <i>optarg</i> to NULL (the argument of the long option).

     <b>o</b>   Handling of `-W' with an argument that is not (a prefix to) a known
         long option (`W;' in option string):

         GNU  returns `-W' with <i>optarg</i> set to the unknown option.

         BSD  treats this as an error (unknown option) and returns `?' with
              <i>optopt</i> set to 0 and <i>optarg</i> set to NULL (as GNU's man page docu-
              ments).

     <b>o</b>   BSD does not permute the argument vector at the same points in the
         calling sequence as GNU does.  The aspects normally used by the
         caller (ordering after -1 is returned, value of <i>optind</i> relative to
         current positions) are the same, though.  (We do fewer variable
         swaps.)


</pre>
<h2>ENVIRONMENT</h2><pre>
     POSIXLY_CORRECT  If set, option processing stops when the first non-
                      option is found and a leading `-' or `+' in the
                      <i>optstring</i> is ignored.


</pre>
<h2>SEE ALSO</h2><pre>
     <b><a href="/man/3/getopt/">getopt(3)</a></b>


</pre>
<h2>HISTORY</h2><pre>
     The <b>getopt_long</b>() and <b>getopt_long_only</b>() functions first appeared in GNU
     libiberty.  The first BSD implementation of <b>getopt_long</b>() appeared in
     NetBSD 1.5, the first BSD implementation of <b>getopt_long_only</b>() in
     OpenBSD 3.3.  FreeBSD first included <b>getopt_long</b>() in FreeBSD 5.0,
     <b>getopt_long_only</b>() in FreeBSD 5.2.


</pre>
<h2>BUGS</h2><pre>
     The <i>argv</i> argument is not really const as its elements may be permuted
     (unless POSIXLY_CORRECT is set).

     The implementation can completely replace <b><a href="/man/3/getopt/">getopt(3)</a></b>, but right now we are
     using separate code.

BSD                              April 1, 2000                             BSD
</pre>
<hr>
Mac OS X 10.5 - Generated Sun Oct 28 21:30:51 EDT 2007
</div>
<div id="footer2">
	<table width="100%" cellpadding="10">

	</table>
</div>
<div id="footer">
<pre>
&copy; manpagez.com 2000-2008
Individual documents may contain additional copyright information.
</pre>
</div>
</div>
</body>
</html>
