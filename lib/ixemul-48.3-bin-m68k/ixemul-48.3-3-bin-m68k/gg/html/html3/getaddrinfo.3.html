<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>man gai_strerror(3)</title>

</head>
<body>
<div id="container">
<div id="top">

</div>
<div id="toplink">

</div>
<div id="contentmenu">
<table width="100%" cellpadding="0">

</table>
</div>

<div id="content">
<pre>
getaddrinfo(3)           BSD Library Functions Manual           getaddrinfo(3)


</pre>
<h2>NAME</h2><pre>
     <b>freeaddrinfo</b>, <b>getaddrinfo</b> -- socket address structure to host and service
     name


</pre>
<h2>SYNOPSIS</h2><pre>
     <b>#include</b> <b>&lt;sys/socket.h&gt;</b>
     <b>#include</b> <b>&lt;netdb.h&gt;</b>

     <i>void</i>
     <b>freeaddrinfo</b>(<i>struct</i> <i>addrinfo</i> <i>*ai</i>);

     <i>int</i>
     <b>getaddrinfo</b>(<i>const</i> <i>char</i> <i>*restrict</i> <i>nodename</i>, <i>const</i> <i>char</i> <i>*restrict</i> <i>servname</i>,
         <i>const</i> <i>struct</i> <i>addrinfo</i> <i>*restrict</i> <i>hints</i>,
         <i>struct</i> <i>addrinfo</i> <i>**restrict</i> <i>res</i>);


</pre>
<h2>DESCRIPTION</h2><pre>
     The <b>getaddrinfo</b>() function is used to get a list of IP addresses and port
     numbers for host <i>nodename</i> and service <i>servname</i>.  It is a replacement for
     and provides more flexibility than the <b><a href="/man/3/gethostbyname/">gethostbyname(3)</a></b> and
     <b><a href="/man/3/getservbyname/">getservbyname(3)</a></b> functions.

     The <i>nodename</i> and <i>servname</i> arguments are either pointers to NUL-terminated
     strings or the null pointer.  An acceptable value for <i>nodename</i> is either
     a valid host name or a numeric host address string consisting of a dotted
     decimal IPv4 address or an IPv6 address.  The <i>servname</i> is either a deci-
     mal port number or a service name listed in <b><a href="/man/5/services/">services(5)</a></b>.  At least one of
     <i>nodename</i> and <i>servname</i> must be non-null.

     <i>hints</i> is an optional pointer to a struct addrinfo, as defined by
     &lt;<i>netdb.h</i>&gt;:

     struct addrinfo {
             int ai_flags;           /* input flags */
             int ai_family;          /* protocol family for socket */
             int ai_socktype;        /* socket type */
             int ai_protocol;        /* protocol for socket */
             socklen_t ai_addrlen;   /* length of socket-address */
             struct sockaddr *ai_addr; /* socket-address for socket */
             char *ai_canonname;     /* canonical name for service location */
             struct addrinfo *ai_next; /* pointer to next in list */
     };

     This structure can be used to provide hints concerning the type of socket
     that the caller supports or wishes to use.  The caller can supply the
     following structure elements in <i>hints</i>:

     <i>ai</i><b>_</b><i>family</i>      The protocol family that should be used.  When <i>ai</i><b>_</b><i>family</i>
                    is set to PF_UNSPEC, it means the caller will accept any
                    protocol family supported by the operating system.

     <i>ai</i><b>_</b><i>socktype</i>    Denotes the type of socket that is wanted: SOCK_STREAM,
                    SOCK_DGRAM, or SOCK_RAW.  When <i>ai</i><b>_</b><i>socktype</i> is zero the
                    caller will accept any socket type.

     <i>ai</i><b>_</b><i>protocol</i>    Indicates which transport protocol is desired, IPPROTO_UDP
                    or IPPROTO_TCP.  If <i>ai</i><b>_</b><i>protocol</i> is zero the caller will
                    accept any protocol.

     <i>ai</i><b>_</b><i>flags</i>       <i>ai</i><b>_</b><i>flags</i> is formed by OR'ing the following values:

                    AI_CANONNAME    If the AI_CANONNAME bit is set, a success-
                                    ful call to <b>getaddrinfo</b>() will return a
                                    NUL-terminated string containing the
                                    canonical name of the specified hostname
                                    in the <i>ai</i><b>_</b><i>canonname</i> element of the first
                                    addrinfo structure returned.

                    AI_NUMERICHOST  If the AI_NUMERICHOST bit is set, it indi-
                                    cates that <i>nodename</i> should be treated as a
                                    numeric string defining an IPv4 or IPv6
                                    address and no name resolution should be
                                    attempted.

                    AI_PASSIVE      If the AI_PASSIVE bit is set it indicates
                                    that the returned socket address structure
                                    is intended for use in a call to <b><a href="/man/2/bind/">bind(2)</a></b>.
                                    In this case, if the <i>nodename</i> argument is
                                    the null pointer, then the IP address por-
                                    tion of the socket address structure will
                                    be set to INADDR_ANY for an IPv4 address
                                    or IN6ADDR_ANY_INIT for an IPv6 address.

                                    If the AI_PASSIVE bit is not set, the
                                    returned socket address structure will be
                                    ready for use in a call to <b><a href="/man/2/connect/">connect(2)</a></b> for
                                    a connection-oriented protocol or
                                    <b><a href="/man/2/connect/">connect(2)</a></b>, <b><a href="/man/2/sendto/">sendto(2)</a></b>, or <b><a href="/man/2/sendmsg/">sendmsg(2)</a></b> if a
                                    connectionless protocol was chosen.  The
                                    IP address portion of the socket address
                                    structure will be set to the loopback
                                    address if <i>nodename</i> is the null pointer
                                    and AI_PASSIVE is not set.

     All other elements of the addrinfo structure passed via <i>hints</i> must be
     zero or the null pointer.

     If <i>hints</i> is the null pointer, <b>getaddrinfo</b>() behaves as if the caller pro-
     vided a struct addrinfo with <i>ai</i><b>_</b><i>family</i> set to PF_UNSPEC and all other
     elements set to zero or NULL.

     After a successful call to <b>getaddrinfo</b>(), <i>*res</i> is a pointer to a linked
     list of one or more addrinfo structures.  The list can be traversed by
     following the <i>ai</i><b>_</b><i>next</i> pointer in each addrinfo structure until a null
     pointer is encountered.  The three members <i>ai</i><b>_</b><i>family,</i> <i>ai</i><b>_</b><i>socktype,</i> and
     <i>ai</i><b>_</b><i>protocol</i> in each returned addrinfo structure are suitable for a call
     to <b><a href="/man/2/socket/">socket(2)</a></b>.  For each addrinfo structure in the list, the <i>ai</i><b>_</b><i>addr</i> mem-
     ber points to a filled-in socket address structure of length <i>ai</i><b>_</b><i>addrlen</i>.

     This implementation of <b>getaddrinfo</b>() allows numeric IPv6 address notation
     with scope identifier, as documented in chapter 11 of draft-ietf-
     ipv6-scoping-arch-02.txt.  By appending the percent character and scope
     identifier to addresses, one can fill the sin6_scope_id field for
     addresses.  This would make management of scoped addresses easier and
     allows cut-and-paste input of scoped addresses.

     At this moment the code supports only link-local addresses with the for-
     mat.  The scope identifier is hardcoded to the name of the hardware
     interface associated with the link (such as ne0).  An example is
     ``fe80::1%ne0'', which means ``fe80::1 on the link associated with the
     ne0 interface''.

     The current implementation assumes a one-to-one relationship between the
     interface and link, which is not necessarily true from the specification.

     All of the information returned by <b>getaddrinfo</b>() is dynamically allo-
     cated: the addrinfo structures themselves as well as the socket address
     structures and the canonical host name strings included in the addrinfo
     structures.

     Memory allocated for the dynamically allocated structures created by a
     successful call to <b>getaddrinfo</b>() is released by the <b>freeaddrinfo</b>() func-
     tion.  The <i>ai</i> pointer should be a addrinfo structure created by a call to
     <b>getaddrinfo</b>().


</pre>
<h2>RETURN VALUES</h2><pre>
     <b>getaddrinfo</b>() returns zero on success or one of the error codes listed in
     <b><a href="/man/3/gai_strerror/">gai_strerror(3)</a></b> if an error occurs.


</pre>
<h2>EXAMPLES</h2><pre>
     The following code tries to connect to ``www.kame.net'' service ``http''
     via a stream socket.  It loops through all the addresses available,
     regardless of address family.  If the destination resolves to an IPv4
     address, it will use an AF_INET socket.  Similarly, if it resolves to
     IPv6, an AF_INET6 socket is used.  Observe that there is no hardcoded
     reference to a particular address family.  The code works even if
     <b>getaddrinfo</b>() returns addresses that are not IPv4/v6.

           struct addrinfo hints, *res, *res0;
           int error;
           int s;
           const char *cause = NULL;

           memset(&amp;hints, 0, sizeof(hints));
           hints.ai_family = PF_UNSPEC;
           hints.ai_socktype = SOCK_STREAM;
           error = getaddrinfo("www.kame.net", "http", &amp;hints, &amp;res0);
           if (error) {
                   errx(1, "%s", gai_strerror(error));
                   /*NOTREACHED*/
           }
           s = -1;
           for (res = res0; res; res = res-&gt;ai_next) {
                   s = socket(res-&gt;ai_family, res-&gt;ai_socktype,
                       res-&gt;ai_protocol);
                   if (s &lt; 0) {
                           cause = "socket";
                           continue;
                   }

                   if (connect(s, res-&gt;ai_addr, res-&gt;ai_addrlen) &lt; 0) {
                           cause = "connect";
                           close(s);
                           s = -1;
                           continue;
                   }

                   break;  /* okay we got one */
           }
           if (s &lt; 0) {
                   err(1, "%s", cause);
                   /*NOTREACHED*/
           }
           freeaddrinfo(res0);

     The following example tries to open a wildcard listening socket onto ser-
     vice ``http'', for all the address families available.

           struct addrinfo hints, *res, *res0;
           int error;
           int s[MAXSOCK];
           int nsock;
           const char *cause = NULL;

           memset(&amp;hints, 0, sizeof(hints));
           hints.ai_family = PF_UNSPEC;
           hints.ai_socktype = SOCK_STREAM;
           hints.ai_flags = AI_PASSIVE;
           error = getaddrinfo(NULL, "http", &amp;hints, &amp;res0);
           if (error) {
                   errx(1, "%s", gai_strerror(error));
                   /*NOTREACHED*/
           }
           nsock = 0;
           for (res = res0; res &amp;&amp; nsock &lt; MAXSOCK; res = res-&gt;ai_next) {
                   s[nsock] = socket(res-&gt;ai_family, res-&gt;ai_socktype,
                       res-&gt;ai_protocol);
                   if (s[nsock] &lt; 0) {
                           cause = "socket";
                           continue;
                   }

                   if (bind(s[nsock], res-&gt;ai_addr, res-&gt;ai_addrlen) &lt; 0) {
                           cause = "bind";
                           close(s[nsock]);
                           continue;
                   }
                   (void) listen(s[nsock], 5);

                   nsock++;
           }
           if (nsock == 0) {
                   err(1, "%s", cause);
                   /*NOTREACHED*/
           }
           freeaddrinfo(res0);


</pre>
<h2>LEGACY SYNOPSIS</h2><pre>
     <b>#include</b> <b>&lt;sys/types.h&gt;</b>
     <b>#include</b> <b>&lt;sys/socket.h&gt;</b>
     <b>#include</b> <b>&lt;netdb.h&gt;</b>

     The include file &lt;<i>sys/types.h</i>&gt; is necessary.


</pre>
<h2>SEE ALSO</h2><pre>
     <b><a href="/man/2/bind/">bind(2)</a></b>, <b><a href="/man/2/connect/">connect(2)</a></b>, <b><a href="/man/2/send/">send(2)</a></b>, <b><a href="/man/2/socket/">socket(2)</a></b>, <b><a href="/man/3/gai_strerror/">gai_strerror(3)</a></b>,
     <b><a href="/man/3/gethostbyname/">gethostbyname(3)</a></b>, <b><a href="/man/3/getnameinfo/">getnameinfo(3)</a></b>, <b><a href="/man/3/getservbyname/">getservbyname(3)</a></b>, <b><a href="/man/3/resolver/">resolver(3)</a></b>,
     <b><a href="/man/5/hosts/">hosts(5)</a></b>, <b>resolv.conf(5)</b>, <b><a href="/man/5/services/">services(5)</a></b>, <b><a href="/man/7/hostname/">hostname(7)</a></b>, <b><a href="/man/8/named/">named(8)</a></b>

     R. Gilligan, S. Thomson, J. Bound, J. McCann, and W. Stevens, <i>Basic</i>
     <i>Socket</i> <i>Interface</i> <i>Extensions</i> <i>for</i> <i>IPv6</i>, RFC 3493, February 2003.

     S. Deering, B. Haberman, T. Jinmei, E. Nordmark, and B. Zill, <i>IPv6</i> <i>Scoped</i>
     <i>Address</i> <i>Architecture</i>, internet draft, draft-ietf-ipv6-scoping-
     arch-02.txt, work in progress material.

     Craig Metz, "Protocol Independence Using the Sockets API", <i>Proceedings</i> <i>of</i>
     <i>the</i> <i>freenix</i> <i>track:</i> <i>2000</i> <i>USENIX</i> <i>annual</i> <i>technical</i> <i>conference</i>, June 2000.


</pre>
<h2>STANDARDS</h2><pre>
     The <b>getaddrinfo</b>() function is defined by the IEEE Std 1003.1g-2000
     (``POSIX.1'') draft specification and documented in RFC 3493, ``Basic
     Socket Interface Extensions for IPv6''.

BSD                            December 20, 2004                           BSD
</pre>
<hr>
Mac OS X 10.5 - Generated Sun Oct 28 21:30:31 EDT 2007
</div>
<div id="footer2">
	<table width="100%" cellpadding="10">

	</table>
</div>
<div id="footer">
<pre>
&copy; manpagez.com 2000-2008
Individual documents may contain additional copyright information.
</pre>
</div>
</div>
</body>
</html>
