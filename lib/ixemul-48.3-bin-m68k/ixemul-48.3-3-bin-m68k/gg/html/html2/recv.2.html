                                      <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>recv(2) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>NAME</a></h2>
    
<h2><a name='sect1' href='#toc1'>SYNOPSIS</a></h2>
        
<h2><a name='sect2' href='#toc2'>DESCRIPTION</a></h2>

and  are used to receive messages from a socket, and may be used to receive
data on a socket whether or not it is connection-oriented.  If  is non-nil,
and the socket is not connection-oriented, the source address of the message
is filled in.  is a value-result parameter, initialized to the size of the
buffer associated with  and modified on return to indicate the actual size
of the address stored there.  The   call is normally used only on a   socket
(see  and is identical to  with a nil  parameter. As it is redundant, it
may not be supported in future releases.  All three routines return the
length of the message on successful completion. If a message is too long
to fit in the supplied buffer, excess bytes may be discarded depending
on the type of socket the message is received from (see   If no messages
are available at the socket, the receive call waits for a message to arrive,
unless the socket is nonblocking (see  in which case the value -1 is returned
and the external variable  set to  The receive calls normally return any
data available, up to the requested amount, rather than waiting for receipt
of the full amount requested; this behavior is affected by the socket-level
options  and  described in   The  call may be used to determine when more
data arrive.  The  argument to a recv call is formed by   one or more of
the values:      The  flag requests receipt of out-of-band data that would
not be received in the normal data stream. Some protocols place expedited
data at the head of the normal data queue, and thus this flag cannot be
used with such protocols. The MSG_PEEK flag causes the receive operation
to return data from the beginning of the receive queue without removing
that data from the queue. Thus, a subsequent receive call will return the
same data. The MSG_WAITALL flag requests that the operation block until
the full request is satisfied. However, the call may still return less data
than requested if a signal is caught, an error or disconnect occurs, or
the next data to be received is of a different type than that returned.
 The  call uses a   structure to minimize the number of directly supplied
parameters. This structure has the following form, as defined in    struct
msghdr { <tt> </tt>&nbsp;<tt> </tt>&nbsp;caddr_t<tt> </tt>&nbsp;<tt> </tt>&nbsp;msg_name;<tt> </tt>&nbsp;<tt> </tt>&nbsp;/* optional address */<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;u_int<tt> </tt>&nbsp;<tt> </tt>&nbsp;msg_namelen;<tt> </tt>&nbsp;<tt> </tt>&nbsp;/* size of address */<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;struct<tt> </tt>&nbsp;<tt> </tt>&nbsp;iovec *msg_iov;<tt> </tt>&nbsp;<tt> </tt>&nbsp;/* scatter/gather array */<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;u_int<tt> </tt>&nbsp;<tt> </tt>&nbsp;msg_iovlen;<tt> </tt>&nbsp;<tt> </tt>&nbsp;/* # elements in msg_iov */<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;caddr_t<tt> </tt>&nbsp;<tt> </tt>&nbsp;msg_control;<tt> </tt>&nbsp;<tt> </tt>&nbsp;/* ancillary data, see below */<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;u_int<tt> </tt>&nbsp;<tt> </tt>&nbsp;msg_controllen; /* ancillary data buffer len */<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;int<tt> </tt>&nbsp;<tt> </tt>&nbsp;msg_flags;<tt> </tt>&nbsp;<tt> </tt>&nbsp;/* flags on received message */<br>
 };   Here  and  specify the destination address if the socket is unconnected;
 may be given as a null pointer if no names are desired or required.  and
 describe scatter gather locations, as discussed in   which has length
 points to a buffer for other protocol control related messages or other
miscellaneous ancillary data. The messages are of the form:  struct cmsghdr
{ <tt> </tt>&nbsp;<tt> </tt>&nbsp;u_int<tt> </tt>&nbsp;<tt> </tt>&nbsp;cmsg_len;<tt> </tt>&nbsp;<tt> </tt>&nbsp;/* data byte count, including hdr */<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;int<tt> </tt>&nbsp;<tt> </tt>&nbsp;cmsg_level;<tt> </tt>&nbsp;<tt> </tt>&nbsp;/* originating protocol */<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;int<tt> </tt>&nbsp;<tt> </tt>&nbsp;cmsg_type;<tt> </tt>&nbsp;<tt> </tt>&nbsp;/* protocol-specific type */<br>
 /* followed by <tt> </tt>&nbsp;<tt> </tt>&nbsp;u_char<tt> </tt>&nbsp;<tt> </tt>&nbsp;cmsg_data[]; */<br>
 };  As an example, one could use this to learn of changes in the data-stream
in XNS/SPP, or in ISO, to obtain user-connection-request data by requesting
a recvmsg with no data buffer provided immediately after an  call.  Open
file descriptors are now passed as ancillary data for  domain sockets,
with  set to  and  set to   The  field is set on return according to the
message received.  indicates end-of-record; the data returned completed a
record (generally used with sockets of type   indicates that the trailing
portion of a datagram was discarded because the datagram was larger than
the buffer supplied.  indicates that some control data were discarded due
to lack of space in the buffer for ancillary data.  is returned to indicate
that expedited or out-of-band data were received.  
<h2><a name='sect3' href='#toc3'>RETURN VALUES</a></h2>
These calls
return the number of bytes received, or -1 if an error occurred. 
<h2><a name='sect4' href='#toc4'>ERRORS</a></h2>
The
calls fail if:   The argument  is an invalid descriptor.  The socket is
associated with a connection-oriented protocol and has not been connected
(see  and   The argument  does not refer to a socket.  The socket is marked
non-blocking, and the receive operation would block, or a receive timeout
had been set, and the timeout expired before data were received.  The receive
was interrupted by delivery of a signal before any data were available.
 The receive buffer pointer(s) point outside the process&rsquo;s address space.
 
<h2><a name='sect5' href='#toc5'>SEE ALSO</a></h2>
     
<h2><a name='sect6' href='#toc6'>HISTORY</a></h2>
The  function call appeared in  <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>NAME</a></li>
<li><a name='toc1' href='#sect1'>SYNOPSIS</a></li>
<li><a name='toc2' href='#sect2'>DESCRIPTION</a></li>
<li><a name='toc3' href='#sect3'>RETURN VALUES</a></li>
<li><a name='toc4' href='#sect4'>ERRORS</a></li>
<li><a name='toc5' href='#sect5'>SEE ALSO</a></li>
<li><a name='toc6' href='#sect6'>HISTORY</a></li>
</ul>
</body>
</html>
