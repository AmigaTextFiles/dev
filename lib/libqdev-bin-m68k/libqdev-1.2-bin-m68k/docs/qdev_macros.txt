;
; $VER: qdev_macros.txt 1.16 (12/09/2014) English
;

TABLE OF CONTENTS

qdev.h/LP2IEEE()
qdev.h/QBASEASSIGN()
qdev.h/QBASEASSIGN2()
qdev.h/QBASEDECL()
qdev.h/QBASEDECL2()
qdev.h/QBASEJUMPTAB()
qdev.h/QBASELOCAL()
qdev.h/QBASEPOINTER()
qdev.h/QBASERESOLVE()
qdev.h/QBASESLOTS()
qdev.h/QDEV_HLP_ASMDIVU()
qdev.h/QDEV_HLP_ASMMULU()
qdev.h/QDEV_HLP_DELTAITER()
qdev.h/QDEV_HLP_DELTASCAN()
qdev.h/QDEV_HLP_DFUNC()
qdev.h/QDEV_HLP_DIVUQUAD()
qdev.h/QDEV_HLP_DSTOTV()
qdev.h/QDEV_HLP_GETREG()
qdev.h/QDEV_HLP_ISLISTEMPTY()
qdev.h/QDEV_HLP_ITERATE()
qdev.h/QDEV_HLP_MULUQUAD()
qdev.h/QDEV_HLP_NOINTSEC()
qdev.h/QDEV_HLP_NOSWITCH()
qdev.h/QDEV_HLP_PROCDECL()
qdev.h/QDEV_HLP_PROCEXIT()
qdev.h/QDEV_HLP_REMOTE()
qdev.h/QDEV_HLP_RESGLOB()
qdev.h/QDEV_HLP_SETREG()
qdev.h/QDEV_HLP_TASKDECL()
qdev.h/QDEV_HLP_TVTODS()
qdev.h/REGARG()
qdev.h/REGVAR()
qdev.h/__LOADA4()
qdev.h/__SAVEA4()
qdev.h/QDEVDEBUG()
qdev.h/QDEVDEBUGIO()
qdev.h/MFADD()
qdev.h/MFCGE()
qdev.h/MFCLE()
qdev.h/MFCMP()
qdev.h/MFDIV()
qdev.h/MFFIX()
qdev.h/MFFLT()
qdev.h/MFMUL()
qdev.h/MFSUB()
qdev.h/MFVALUE()
qdev.h/QDEV_HLP_ABS()
qdev.h/QDEV_HLP_ADDTV()
qdev.h/QDEV_HLP_ASMALIAS()
qdev.h/QDEV_HLP_ASMENTRY()
qdev.h/QDEV_HLP_BADDR()
qdev.h/QDEV_HLP_BYTESPERROW()
qdev.h/QDEV_HLP_EQUALIZEUC()
qdev.h/QDEV_HLP_EQUALIZELC()
qdev.h/QDEV_HLP_E_DIVULONG10()
qdev.h/QDEV_HLP_FFPTOIEEE()
qdev.h/QDEV_HLP_FLIP()
qdev.h/QDEV_HLP_FNV32CSUM()
qdev.h/QDEV_HLP_FNV32HASH()
qdev.h/QDEV_HLP_IEEETOFFP()
qdev.h/QDEV_HLP_LCOPYMEM()
qdev.h/QDEV_HLP_LSHIFT64()
qdev.h/QDEV_HLP_MAX()
qdev.h/QDEV_HLP_MIN()
qdev.h/QDEV_HLP_MKBADDR()
qdev.h/QDEV_HLP_MKSTR()
qdev.h/QDEV_HLP_MULU32X32()
qdev.h/QDEV_HLP_N_DIVULONG10()
qdev.h/QDEV_HLP_N_MULUXXX10()
qdev.h/QDEV_HLP_NEG()
qdev.h/QDEV_HLP_QUICKFILL()
qdev.h/QDEV_HLP_SWAPQUAD()
qdev.h/QDEV_HLP_POPCOUNT()
qdev.h/QDEV_HLP_RASSIZE()
qdev.h/QDEV_HLP_ROUNDPOW2()
qdev.h/QDEV_HLP_RSHIFT64()
qdev.h/QDEV_HLP_SUBTV()
qdev.h/QDEV_HLP_SWAPLONG()
qdev.h/QDEV_HLP_SWAPQUAD()
qdev.h/QDEV_HLP_SWAPWORD()



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      LP2IEEE() - IEEE arithmetic function caller macro(Amiga
                  only).



   SYNOPSIS

      res = LP2IEEE(
             offs, rt, name, t1, v1, r1, t2, v2, r2, bt, bn);

      LONG LP2IEEE(<offset>, <return type>, <func name>,
                   <arg type 1>, <variable 1>, (arg reg 1>,
                   <arg type 2>, <variable 2>, (arg reg 2>,
                                      <unused>, <base name>);



   FUNCTION

      This macro allows to call two argument IEEE function.
      It is quite useful when one wants to use 'mathieeexxx'
      libraries without 'gcc' global wrappers.



   INPUTS

      offs  - Func. offset as specified in the FD. The value
              must not be negative, the macro does this!

      rt    - Function return type(d0 and d1 for double).

      name  - Symbolic name of the function to be called.

      t1    - Type of the first argument(float or double).

      v1    - Variable to be passed in the first argument.

      r1    - Register that will be used(always d0).

      t2    - Type of the second argument(float or double).

      v2    - Variable to be passed in the second argument.

      r2    - Register that will be used(d1 if first arg was
              float or d2 if it was double!).

      bt    - Unused base related variable. Can be ommited.

      bn    - Base name of the library(MathIeeeSingBasBase).



   RETURNS

      Depends on the function. See the autodocs of particular
      IEEE routine-set.



   BASES

      [MathIeeeDoubBasBase], [MathIeeeDoubTransBase],
      [MathIeeeSingBasBase], [MathIeeeSingTransBase]



   NOTES

      This macro plays an important role in double-type, math
      related macros: '_IEEEXPxxx()' who are post-mapped as
      'MFxxx()' macros.



   SEE ALSO

      MFxxx()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QBASEASSIGN() - Feeds function private base with proper
                      pointers.



   SYNOPSIS

      QBASEASSIGN(b, i);

      QBASEASSIGN(<base_name>, <ptr>);



   FUNCTION

      Takes a pointer (cached base) and resolves both: local
      and main bases out of it.



   INPUTS

      b - Base name/symbol.

      i - Pointer as obtained with QBASEPOINTER(xxxBase).



   RETURNS

      No output.



   BASES

      None.



   NOTES

      Use this macro to reload base pointers as cached during
      runtime. This macro works similarly to QBASEDECL(). The
      only difference is it does not emit types.



   SEE ALSO

      QBASEDECL(), QBASEDECL2(), QBASEASSIGN2(),
      QBASELOCAL(), QBASEPOINTER(), QBASEJUMPTAB(),
      QBASESLOTS(), QBASERESOLVE()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QBASEASSIGN2() - Assigns a base (main and local) given
                       pointer.



   SYNOPSIS

      QBASEASSIGN2(b, i);

      QBASEASSIGN2(<base_name>, <ptr>);



   FUNCTION

      Takes a value (pointer) and stuffs it to 'b' which can
      be single base or double base (if LBS is enabled).
      


   INPUTS

      b - Base name/symbol.

      i - New, immediate base pointer.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      Use this macro to reload base addresses with the same
      pointer. Ususally you will want to use this macro to
      declare function private SysBase.

      Caution! Bases shall be declared with QBASEDECL2() for
      this macro to work properly!



   SEE ALSO

      QBASEDECL(), QBASEDECL2(), QBASEASSIGN(),
      QBASELOCAL(), QBASEPOINTER(), QBASEJUMPTAB(),
      QBASESLOTS(), QBASERESOLVE()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QBASEDECL() - In-function (internal) library base decl.
                    macro.



   SYNOPSIS

      QBASEDECL(t, b, i...);

      QBASEDECL(<type>, <base_name>, [init_value]);



   FUNCTION

      This macro allows to declare (function private) library
      base as cached. When LBS(Local Base Support) is enabled
      then this macro assigns proper pointers to so called
      main and local bases.



   INPUTS

      t - Library specific structure/type (struct Library *). 

      b - Base name/symbol.

      i - QBASEPOINTER(xxxBase). Do not pass NULL nor random
          pointers!



   RETURNS

      No output.



   BASES

      None.



   NOTES

      If you want to be able to alter jump table of some lib.
      at runtime for use in current context only and you need
      to cache library bases because they may be unavailable
      as globals at some point then use this macro so that
      inlines will not reference global symbols.



   SEE ALSO

      QBASEDECL2(), QBASEASSIGN2(), QBASEASSIGN(),
      QBASELOCAL(), QBASEPOINTER(), QBASEJUMPTAB(),
      QBASESLOTS(), QBASERESOLVE()



   EXAMPLE

      #include <qlbs.h>     // This must be the first header!

      #include <proto/exec.h>
      #include <proto/dos.h>
      #include <qdev.h>

      /*
       * Suppose you need to cache DOSBase for some reason.
      */
      struct mycache
      {
        struct DosLibrary *mc_dos;
      };

      struct mycache *docache(void)
      {
        struct mycache *mc;

        if ((mc =
              AllocVec(sizeof(struct mycache), MEMF_PUBLIC)))
        {
          /*
           * You want to cache the alias which is resolvable
           * with QBASEPOINTER(). The reason for doing this
           * is that it may provide custom jump table.
          */
          mc->mc_dos = QBASEPOINTER(DOSBase);
        }

        return mc;
      }

      /*
       * Then you want to call "dos.library" function using
       * that cached base.
      */
      LONG Output_cached(struct mycache *mc)
      {
        /*
         * What happens here is that if 'qlbs.h' was included
         * then there are two declarations! One is 'DOSBase'
         * (main) and the other is 'L_DOSBase' that points at
         * redefinable alias which is used in a function call.
        */
        QBASEDECL(struct DosLibrary *, DOSBase, mc->mc_dos);

        return Output();
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QBASEDECL2() - In-function (internal) library base decl.
                     macro.



   SYNOPSIS

      QBASEDECL2(t, b, i...);

      QBASEDECL2(<type>, <base_name>, [init_value]);



   FUNCTION

      This macro is similar to QBASEDECL() except that it does
      not try to resolve main base out of local base.



   INPUTS

      t - Library specific structure/type (struct Library *). 

      b - Base name/symbol.

      i - Initial val/pointer. In most cases it will be NULL
          or nothing if 'b' must stay uninitialised.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      Use this macro in conjunction with  QBASEASSIGN2()  when
      you need to reload library base addrs sometime later.



   SEE ALSO

      QBASEDECL(), QBASEASSIGN(), QBASEASSIGN2(),
      QBASELOCAL(), QBASEPOINTER(), QBASEJUMPTAB(),
      QBASESLOTS(), QBASERESOLVE()



   EXAMPLE

      #include <qlbs.h>
      #include <proto/exec.h>
      #include <qdev.h>

      /*
       * You may have noticed that in this example the use
       * of QBASEDECL2() is not necessary since there is just
       * one func. that cannot take an advantage of alternate
       * jumptable anyway. Note however that in case when some
       * other routine references global base you must define
       * through macro or 'AvailMem()' will be called using
       * globally available base!
      */
      LONG myAvailMem(void)
      {
        QBASEDECL2(struct ExecBase *, SysBase);

        QBASEASSIGN2(SysBase, (*((struct ExecBase **)4)));

        return AvailMem(MEMF_PUBLIC);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QBASEJUMPTAB() - Returns pointer to local jump table.



   SYNOPSIS

      ptr = QBASEJUMPTAB(b);

      [struct Libarary *] QBASEJUMPTAB(<base_name>);



   FUNCTION

      Returns ptr to local jump table/vector based on main
      base symbol.



   INPUTS

      b - Main base pointer/symbol.



   RETURNS

      Local jump table/vector pointer.



   BASES

      None.



   NOTES

      Use this macro if you need to resolve call entry ptr
      out of local base using 'mem_addrfromlvo()'.



   SEE ALSO

      QBASEDECL(), QBASEDECL2(), QBASEASSIGN2(),
      QBASELOCAL(), QBASEPOINTER(), QBASESLOTS(),
      QBASERESOLVE()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QBASELOCAL() - Ret. local base symbol if LBS has been
                     enabled.



   SYNOPSIS

      lbase = QBASELOCAL(b);

      <local_base> QBASELOCAL(<base_name>);



   FUNCTION

      This macro returns local base symbol if LBS is enabled
      or returns passed in symbol if LBS is disabled.



   INPUTS

      b - Base name/symbol.



   RETURNS

      Local or main symbol.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

      QBASEDECL(), QBASEDECL2(), QBASEASSIGN(),
      QBASEASSIGN2(), QBASEPOINTER(), QBASEJUMPTAB(),
      QBASESLOTS(), QBASERESOLVE()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QBASEPOINTER() - Returns pointer to the local base.



   SYNOPSIS

      ptr = QBASEPOINTER(b);

      [struct Library **] QBASEPOINTER(<base_name>);



   FUNCTION

      Returns ptr to local base based on main base symbol.



   INPUTS

      b - Main base pointer/symbol.



   RETURNS

      Local base pointer.



   BASES

      None.



   NOTES

      Use this macro to cache local base so that it can be
      QBASEASSIGN()'ed to function-private base.



   SEE ALSO

      QBASEDECL(), QBASEDECL2(), QBASEASSIGN2(),
      QBASELOCAL(), QBASEJUMPTAB(), QBASESLOTS(),
      QBASERESOLVE()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QBASERESOLVE() - Resolves real base from local one
                       that was cached.



   SYNOPSIS

      ptr = QBASERESOLVE(sym)

      [struct Library *] QBASERESOLVE(<symbol>);



   FUNCTION

      Returns ptr to real/global base if its local alias
      was cached with QBASEPOINTER().



   INPUTS

      sym - Cache variable.



   RETURNS

      Global base pointer.



   BASES

      None.



   NOTES

      This macro is only defined in 'qdev.h', so you can
      access LBS ptrs without the need to activate it.



   SEE ALSO

      QBASEDECL(), QBASEDECL2(), QBASEASSIGN2(),
      QBASELOCAL(), QBASEJUMPTAB(), QBASESLOTS()



   EXAMPLE

      ...

      /*
       * In reality address of  L_MyBase is cached here!
      */
      void *MyBaseCached = QBASEPOINTER(MyBase);

      ...

      void myfunction(void *MyBaseCached)
      {
        void *MyBase = QBASERESOLVE(MyBaseCached);

        ...
      }

      ...



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QBASESLOTS() - Returns predefined number of slots
                     for given base.



   SYNOPSIS

      slots = QBASESLOTS(b, p...);

      [LONG] QBASESLOTS(<base_name>, [percent]);



   FUNCTION

      Returns number of slots per base as resolved from
      inlines at the time of 'qlbs.h' header generation. 
      This way jump table allocation under previous OS
      releases may be as big as under OS 3.1 .



   INPUTS

      b - Main base symbol.

      p - How much bigger should the jump table be (in
          percents). This argument is optional. Passing
          25 to 50 % should cover all private slots most
          of the time. This optional argument exists in
          case 'lbasegen' was not able to access FD file
          per 'b' during 'qlbs.h' generation.



   RETURNS

      Number of slots a jump table should have. Pass the
      value to QDEV_PRV_LBS_SLOT2OFF() to get the amount
      of memory needed which is also highest possible
      offset.



   BASES

      None.



   NOTES

      If 'qlbs.h' is not included then this macro always
      returns 0 and the optional 'p' gets blasted as is.

      At all times use contants/values that are know at
      compilation time so that preprocessor will compute
      the final value.

      Max number of slots that can be doubled (p = 100)
      is 32736. The macro contains little hack to avoid
      division when values are not constant.
      


   SEE ALSO

      QBASEDECL(), QBASEDECL2(), QBASEASSIGN2(),
      QBASELOCAL(), QBASEJUMPTAB(), QBASEPOINTER(),
      QBASERESOLVE()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_ASMDIVU() - Allows to divide 64 bit integer
                           by the 32 bit one.



   SYNOPSIS

      res = QDEV_HLP_ASMDIVU(q, r, n1, n0, d);

      QDEV_HLP_ASMDIVU(
              [ULONG], [ULONG], [ULONG], [ULONG], [ULONG]);



   FUNCTION

      This macro is a direct assembly instruction alias who
      allows to divide unsigned, 64 bit int. by the 32 bit
      divisor. The result in a 32 bit quotient, and 32 bit
      reminder.



   INPUTS

      q  - Quotient to be computed.

      r  - Remainder to be computed.

      n1 - Most significant 32 bits of the dividend.

      n0 - Least significant 32 bits of the dividend.

      d  - Divisor.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      Code generated using this macro will only function OK
      on 68020 onwards!

      This macro requires that some operands to be prepared
      by the first stage division in case 64 bit result is
      to be expected!



   SEE ALSO

      QDEV_HLP_ASMDIVU(),
      QDEV_HLP_DIVUQUAD(), QDEV_HLP_MULUQUAD()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_ASMMULU() - Allows to multiply 32bit x 32bit
                           integers and get 64bit result.



   SYNOPSIS

      res = QDEV_HLP_ASMMULU(w1, w0, u, v);

      QDEV_HLP_ASMMULU([ULONG], [ULONG], [ULONG], [ULONG]);



   FUNCTION

      This macro is a direct assembly instruction alias who
      allows to multiply two unsigned, 32 bit integers that
      will form the 64 bit result.



   INPUTS

      w1 - Most significant 32 bits of the multiplication.

      w0 - Least significant 32 bits of the multiplication.

      u  - First operand.

      v  - Second operand.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      Code generated using this macro will only function OK
      on 68020 onwards!



   SEE ALSO

      QDEV_HLP_ASMDIVU()
      QDEV_HLP_DIVUQUAD(), QDEV_HLP_MULUQUAD()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_DELTAITER() - Allows to traverse Amiga, doubly
                             linked list in a fast way.



   SYNOPSIS

      QDEV_HLP_DELTAITER(lh, type, h, t);

      QDEV_HLP_DELTAITER(
                  struct List *, <type>, <node_h>, <node_t>);



   FUNCTION

      This macro allows to traverse the Amiga, doubly linked
      list by reducing number of iterations by a half by
      examining head and tail entries at once. Principle of
      operation on a list of 10 nodes explained:

      Regular walkthrough gets slower and slower as it goes.
      1    2    3    4    5    6    7    8    9    10
      ->   ->   ->   ->   ->   ->   ->   ->   ->   -> E = End

      Delta scan slows down only to a certain point (half the
      regular scan).
      1    2    3    4    5    6    7    8    9    10
      ->   ->   ->   ->   -> E <-   <-   <-   <-   <-

      So it looks like this in reality which means that even
      entry miss is faster and bottom entries can be found
      with the same overhead as the top ones:

      1 & 10    2 & 9     3 & 8     4 & 7     5 & 6
      ->        ->        ->        ->        ->      E



   INPUTS

      list - Addr. of the list (struct List, struct MinList).

      type - Typecasting of the <node_(h|t)> pointer.

      h    - Head node pointer (entry from the top).

      t    - Tail node pointer (entry from the bottom).



   RETURNS

      No output.



   BASES

      None.



   NOTES

      This macro does not cache ln_Succ, ln_Pred pointers so
      it is not safe to call 'Remove()' during iteration!

      This macro was designed mainly to quickly compare the
      node addresses. It is most probably useless for other
      purposes (counting, data extraction, etc). Use helper
      macros QDEV_HLP_DELTA#? to match and stop at the delta
      point.

      All OS lists can be traversed with this macro but some
      sort of arbitration must be provided. This is typically
      to be Forbid()/Permit() pair.



   SEE ALSO

      QDEV_HLP_ISLISTEMPTY(), QDEV_HLP_ITERATE(),
      QDEV_HLP_DELTASCAN()



   EXAMPLE

      #include <proto/exec.h>
      #include <qdev.h>

      LONG isonlist(struct List *lh, void *node)
      {
        REGISTER struct Node *a;
        REGISTER struct Node *b;
        REGISTER LONG res = 0;

        /*
         * Enter forbidden state in case of OS list.
        */
        QDEV_HLP_NOSWITCH
        (
          QDEV_HLP_DELTAITER(lh, struct Node *, a, b)
          {
            if (((res = QDEV_HLP_DELTAADDR(node, a, b)))   ||
                  QDEV_HLP_DELTACOND(struct Node *, a, b))
            {
              break;
            }
          }
        );

        return res;
      }
     


   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_DELTASCAN() - Allows to traverse Amiga, doubly
                             linked l. in a fast way (cached).



   SYNOPSIS

      QDEV_HLP_DELTASCAN(lh, na, code);

      QDEV_HLP_DELTASCAN(struct List *, <nodearray>, <code>);



   FUNCTION

      This m. works in a similar way as QDEV_HLP_DELTAITER().



   INPUTS

      list - Address of the list(struct List, struct MinList).

      na   - Node array of 4 entries (struct Node *n[4]).

      code - Code that will be executed per loop.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      In theory it is safe to call 'Remove()' at any point as
      nodes are cached but this way macro is slower than the
      QDEV_HLP_DELTAITER()!

      This macro was designed mainly to quickly compare the
      node addresses. Use helper macros QDEV_HLP_DS#? to match
      and break.

      All OS lists can be traversed with this macro, but some
      sort of arbitration must be provided. This is typically
      to be Forbid()/Permit() pair.



   SEE ALSO

      QDEV_HLP_ISLISTEMPTY(), QDEV_HLP_ITERATE(),
      QDEV_HLP_DELTAITER()



   EXAMPLE

      #include <proto/exec.h>
      #include <qdev.h>

      LONG isonlist_ds(struct List *lh, void *node)
      {
        REGISTER struct Node *QDEV_HLP_DSVARDECL(n);
        REGISTER LONG res = 0;

        /*
         * Enter forbidden state in case of OS list.
        */
        QDEV_HLP_NOSWITCH
        (
          QDEV_HLP_DELTASCAN
          (
            lh, n,

            if ((res = (LONG)QDEV_HLP_DSMATCH(
            QDEV_HLP_DSNODEH(n), QDEV_HLP_DSNODET(n), node)))
            {
              QDEV_HLP_DSBREAK(n);
            }
          );
        );

        return res;
      }
     


   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_DFUNC() - Creates driver function for actual
                         function.



   SYNOPSIS

      QDEV_HLP_DFUNC(r, at, dn, fn);

      QDEV_HLP_DFUNC(<registers>, <type>, <driver>, <func>);



   FUNCTION

      This macro makes it possible to generate a wrapper func
      that saves and restores particular registers so that it
      is safe to use high level code in restricted code. This
      macro defines the driver as global!



   INPUTS

      r   - Register names in m68k assembly notation that are
            ought to be saved and then restored. Regs can be
            grouped in ranges, passed alone and/or separated
            by slashes. For instance: d1-d4/d7/a1-a3/a6 .

      at  - Return type of the driver function. This gives a
            hint to compiler on how to treat driver function
            in your code.

      dn  - Driver function symbol.

      fn  - Actual function symbol. Code that will be called
            by the driver.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      A group of QDEV_DFREGS_#? contains predefined registers
      for most problematic/used functions.



   SEE ALSO

   EXAMPLE

      /*
       * This routine is to utilise two registers, d0 and d1.
       * Output = d0, input = d1. Compiler will save them but
       * if you attempt direct assmebly pokes on other regs
       * then after it returns your program may fail.
      */
      LONG myroutine(REGARG(LONG in, d1))
      {
        /*
         * This is in no way an example on how to code! It is
         * a bad karma! Unfortunately some AmigaOS routines
         * are coded in a similar way... But lets go back to
         * the point. OK the d2 is now trashed and it was not
         * saved.
        */
        asm("\n\t move.l #0x0008,d2"
            "\n\t rol.l  #1,d2     "
            "\n\t and.l  d1,d2     ");

        return in;
      }

      /*
       * There is an easy way to fix this problem. We need to
       * introduce the driver for this routine by taking out
       * registers it uses. Registers a5(frame) and a7(stack)
       * must always be discarded.
      */
      QDEV_HLP_DFUNC
      (
        d2-d7/a0-a4/a6,
        LONG, drv_myroutine,
        myroutine
      );

      /*
       * Use preprocessor to redefine symbol so that there is
       * no need to edit whole code. Please keep in mind that
       * the driver function defines return type only so be
       * careful about arguments afterwards!
      */
      #define myroutine drv_myroutine

      int main(void)
      {
        printf("value = %ld\n", myroutine(64));

        return 0;
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_DIVUQUAD() - Fast(ASM) 64 bit integer division.



   SYNOPSIS

      res = QDEV_HLP_DIVUQUAD(num, div);

      [UQUAD] QDEV_HLP_DIVUQUAD([UQUAD], [ULONG]);



   FUNCTION

      This macro allows to divide 64 bit integer by 32 bit one
      using direct CPU(68020+) code.



   INPUTS

      num - 64 bit integer(dividend).

      div - 32 bit integer(divisor).


                                    
   RETURNS

      Returns 64 bit integer only(no remainder anywhere)!



   BASES

      None.



   NOTES

      This marco depends on MC68020 or greater microprocessor!



   SEE ALSO

      QDEV_HLP_MULUQUAD()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_DSTOTV() - Converts from DateStamp to timeval
                          notation.



   SYNOPSIS

      QDEV_HLP_DSTOTV(tv, ds);

      QDEV_HLP_DSTOTV(struct timeval *, struct DateStamp *);



   FUNCTION

      This macro allows to convert from system DateStamp to
      higher resolution tv time holder.



   INPUTS

      tv - Timeval pointer whose fileds will be computed.

      ds - DateStamp holder.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      This macro is useful when one wants to manipulate the
      time and date as it is simplier to subtract or add two
      timevals than DateStamps.

      This macro due to high arithmetic load(including div.)
      is somewhat unsuitable for time critical use.



   SEE ALSO

      QDEV_HLP_TVTODS()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_GETREG() - Obtains contents of a 32bit register.



   SYNOPSIS

      val = QDEV_HLP_GETREG(reg);

      [ULONG] QDEV_HLP_GETREG(<symbol>);



   FUNCTION

      This macro allows to fetch contents of a CPU register in
      current context.



   INPUTS

      reg - CPU register name(32bit, lower case: a0, sp, ...).



   RETURNS

      Returns contents of requested register.



   BASES

      None.



   NOTES

      This macro does not utilise CPU dependant code at all!



   SEE ALSO

      QDEV_HLP_SETREG()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_ISLISTEMPTY() - Checks if certain doubly linked
                               list is empty or not.



   SYNOPSIS

      res = QDEV_HLP_ISLISTEMPTY(list)

      [BOOL] QDEV_HLP_ISLISTEMPTY(struct List *)



   FUNCTION

      This macro allows to detect whether the list passed in is
      empty or not.



   INPUTS

      list - List or MinList pointer.



   RETURNS

      Returns TRUE if list is empty or FALSE otherwise.



   BASES

      None.



   NOTES

      An arbitration is often required when examining a public
      list!



   SEE ALSO

      QDEV_HLP_ITERATE(), QDEV_HLP_DELTASCAN()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_ITERATE() - Allows to walkthrough Amiga, doubly
                           linked list.



   SYNOPSIS

      QDEV_HLP_ITERATE(list, type, node)

      QDEV_HLP_ITERATE(struct List *, <type>, <node>)



   FUNCTION

      This macro allows to traverse the Amiga, doubly linked
      list in a manner allowing to read data per node.



   INPUTS

      list - Address of the list(struct List, struct MinList).

      type - Structure that wraps struct Node/struct MinNode
             that then defines its primary members.

      node - Address of the structure as declared in the code.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      Please note that this macro is unsuitable for list chain
      manipulation! Calling 'Remove()' is strictly discouraged
      as this may cause unpredictible behaviour!

      All OS lists can be traversed with this macro, but some
      sort of arbitration must be provided. This is typically
      to be Forbid()/Permit() pair.



   SEE ALSO

      QDEV_HLP_ISLISTEMPTY(), QDEV_HLP_DELTASCAN()
      QDEV_HLP_DELTAITER()



   EXAMPLE

      #include <proto/exec.h>
      #include <exec/execbase.h>
      #include <proto/alib.h>
      #include <qdev.h>

      #define MINCHUNKS  128

      struct myentry
      {
        struct Node me_node;
        ULONG       me_hash;
      };

      void iteratelibs(void)
      {
        struct myentry *me;
        struct Library *lib;
        struct List lh;
        void *cluster;

        if ((cluster = mem_alloccluster(
                            sizeof(struct myentry), MINCHUNKS,
                                 MEMF_PUBLIC | MEMF_LARGEST)))
        {
          NewList(&lh);

          /*
           * Enter forbidden state and collect entries.
          */
          QDEV_HLP_NOSWITCH
          (
            QDEV_HLP_ITERATE(
                     &SysBase->LibList, struct Library *, lib)
            {
              if ((me = mem_getmemcluster(cluster)))
              {
                me->me_hash =
                   QDEV_HLP_FNV32IHASH(lib->lib_Node.ln_Name);

                AddTail(&lh, (struct Node *)me);
              }
              else
              {
                break;
              }
            }
          );

          /*
           * Now dump the hashes safely.
          */
          QDEV_HLP_ITERATE(&lh, struct myentry *, me)
          {
            FPrintf(
                Output(), "me_hash = 0x%08lx\n", me->me_hash);
          }

          mem_freecluster(cluster);
        }
      }     



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_MULUQUAD() - Fast(ASM) 32 x 32 = 64 bit integer
                            multiply.



   SYNOPSIS

      res = QDEV_HLP_MULUQUAD(num, mul);

      [UQUAD] QDEV_HLP_MULUQUAD([ULONG], [ULONG]);



   FUNCTION

      This macro allows to multiply two 32 bit integers with
      the result being 64 bit int. using CPU dependant code.



   INPUTS

      num - 32 bit integer operand.

      mul - 32 bit integer operand(multiplier).


                                    
   RETURNS

      Returns 64 bit integer.



   BASES

      None.



   NOTES

      This marco depends on MC68020 or greater microprocessor!



   SEE ALSO

      QDEV_HLP_DIVUQUAD()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_NOINTSEC() - Disable()/Enable() brace support.



   SYNOPSIS

      QDEV_HLP_NOINTSEC(code);

      QDEV_HLP_NOINTSEC(<code>);



   FUNCTION

      This macro allows to shutdown the critical task code in
      a bubble of no other bubbles(no interrupts can happen).



   INPUTS

      code - A snippet of code with usual syntax rules.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      QDEV_HLP_NOSWITCH()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_NOSWITCH() - Forbid()/Permit() brace support.



   SYNOPSIS

      QDEV_HLP_NOSWITCH(code);

      QDEV_HLP_NOSWITCH(<code>);



   FUNCTION

      This macro allows to brace the critical task code with
      arbitration.



   INPUTS

      code - A snippet of code with usual syntax rules.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      QDEV_HLP_NOINTSEC()



   EXAMPLE

      #include <proto/exec.h>
      #include <exec/execbase.h>
      #include <qdev.h>

      ...

      struct MsgPort *mp;

      QDEV_HLP_NOSWITCH
      (
        QDEV_HLP_ITERATE(
                   &SysBase->PortList, struct MsgPort *, mp)
        {
          ...
        }
      );

      ...



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_PROCDECL() - Blasts subprocess code with LFRA
                            artefact.



   SYNOPSIS

      QDEV_HLP_PROCDECL(fmod, symbol, code)

      QDEV_HLP_PROCDECL(<fmod>, <symbol>, <code>)



   FUNCTION

      This macro was created to cause LFRA on stack of newly
      created process so that one can easily guess the parent.



   INPUTS

      fmod   - Function modifiers like 'static' for instance.
               Can be totally omitted as well.

      symbol - Function name. Quite essential.

      code   - Code that this function will carry. The syntax
               does not differ from regular syntax.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      This macro is similar to 'QDEV_HLP_TASKDECL()', but can
      only be used for process creation!

      See 'fmpp', 'nfo_ischildofproc()' & 'nfo_issegremote()'
      docs for more details on parent-children matching.



   SEE ALSO

      QDEV_HLP_TASKDECL()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_PROCEXIT() - Causes process to exit immediately.



   SYNOPSIS

      QDEV_HLP_PROCEXIT(ra);

      QDEV_HLP_PROCEXIT([ULONG]);



   FUNCTION

      This little macro allows to trickly exit DOS process at
      any stage with segment and memory list dealloation.



   INPUTS

      ra - Return address. This is typically to be the pointer
           as found in (pr->pr_ReturnAddr - sizeof(LONG)).



   RETURNS

      No output.



   BASES

      None.



   NOTES

      All memory process did allocate that was to put onto the
      task memory list will not be deallocated!



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_REMOTE() - Executes code that alters alien TCB.



   SYNOPSIS

      QDEV_HLP_REMOTE(tc, code);

      QDEV_HLP_REMOTE((struct Task *), <code>);



   FUNCTION

      This macro allows to affect alien TCB by pretending that
      SysBase->ThisTask is it. This macro does not inject code
      in alien/remote task!



   INPUTS

      tc   - Remote task address.

      code - Code to be executed that will affect 'tc'.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      Must use this macro in either: QDEV_HLP_NOSWITCH() and/or
      QDEV_HLP_NOINTSEC() and cannot call routines that break
      forbidden state!



   SEE ALSO

      QDEV_HLP_NOSWITCH(), QDEV_HLP_NOINTSEC()



   EXAMPLE

      #include <proto/exec.h>
      #include <exec/execbase.h>
      #include <proto/dos.h>
      #include <proto/intuition.h>

      #include <qdev.h>

      ...

      struct Window *win;
      struct FileHandle *fh;
      struct MsgPort *mp;
      UBYTE *ptr;
      LONG fd;

      /*
       * This example shows how to change screen bar text that
       * the shell window sets when becomes active.
      */
      if ((fd = Open("CONSOLE:", MODE_OLDFILE)))
      {
        if ((win = nfo_getwinaddr(fd)))
        {
          if (nfo_iswindow(win))
          {
            /*
             * OK, now we are sure that the shell has its own
             * window. Lets find out what is the address of a
             * CON: process for this window.
            */
            fh = QDEV_HLP_BADDR(fd);

            mp =
             (struct MsgPort *)QDEV_HLP_ABS((LONG)fh->fh_Type);

            /*
             * Attempt to allocate self-deallocating memory as
             * if CON: did it.
            */
            QDEV_HLP_NOSWITCH
            (
              QDEV_HLP_REMOTE
              (
                mp->mp_SigTask,

                /*
                 * This memory will be deallocated upon CON:'s
                 * death (when you close the shell typically).
                */
                ptr = mem_alloclfvec(32, MEMF_PUBLIC);
              );

              if (ptr)
              {
                /*
                 * Fill that mem. with some text and set it as
                 * a new screen bar text.
                */
                *ptr = 0;

                txt_strncat(ptr, "My new screen title!", 32);

                /*
                 * Not safe to call in 'QDEV_HLP_REMOTE()' !!!
                */
                SetWindowTitles(win, (UBYTE *)-1, ptr);
              }
            );
          }
        }

        Close(fd);
      }

      ...



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_RESGLOB() - Declares a variable in code seg.



   SYNOPSIS

      QDEV_HLP_RESGLOB(type, name);

      QDEV_HLP_RESGLOB(<type>, <name>);



   FUNCTION

      This macro is especially useful when one wants to put
      true globals in resident binaries.



   INPUTS

      type - Type of variable(datatype, struct, pointer).

      name - Symbol name of this very variable.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      Beware! Code generated with QDEV_HLP_RESGLOB() decls
      is considered self-modifying!

      Do not define library bases using this macro, it will
      not work!



   SEE ALSO

   EXAMPLE

      #include <qdev.h>

      ...

      QDEV_HLP_RESGLOB(LONG, myglobal) = 256;

      ...



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_SETREG() - Feeds particular CPU register with 
                          32bit value.



   SYNOPSIS

      QDEV_HLP_SETREG(reg, val);

      QDEV_HLP_SETREG(<symbol>, [ULONG]);



   FUNCTION

      This macro allows to inject 32 bit value in one of the
      m68k CPU registers.



   INPUTS

      reg - CPU register name(32bit, lower case: a0, sp, ...).

      val - Value/address that will be set.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      This macro uses CPU dependant assembly thus can only be
      used on a m68k family CPUs.



   SEE ALSO

      QDEV_HLP_SETGEG()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_TASKDECL() - Blasts subtask code in a special
                            manner.



   SYNOPSIS

      QDEV_HLP_TASKDECL(fmod, symbol, code)

      QDEV_HLP_TASKDECL(<fmod>, <symbol>, <code>)



   FUNCTION

      This macro was created for two reasons. 1) To wrap code
      so that LFRA is to be found on stack and  2) to balance
      I/O in the debug support since task function must never
      return.



   INPUTS

      fmod   - Function modifiers like 'static' for instance.
               Can be totally omitted as well.

      symbol - Function name. Quite essential.

      code   - Code that this function will carry. The syntax
               does not differ from normal function body.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      This macro defines SysBase implicitly to call task rem.
      function 'RemTask()'. You must not call it in 'code'!



   SEE ALSO

      QDEV_HLP_PROCDECL()



   EXAMPLE

      #include <proto/exec.h>
      #include <exec/execbase.h>
      #include <proto/dos.h>

      #include <qdev.h>

      QDEV_HLP_TASKDECL
      (
        , myfunction,

        struct ExecBase *SysBase = *((struct ExecBase **)4);

        Wait(SIGBREAKF_CTRL_C);

        ...

        Forbid();
      )

      ...



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_TVTODS() - Converts from timeval notation to
                          DateStamp.



   SYNOPSIS

      QDEV_HLP_TVTODS(ds, tv);

      QDEV_HLP_TVTODS(struct DateStamp *, struct timeval *);



   FUNCTION

      This macro allows to convert from higher resolution tv
      to lower resolution ds time holder.



   INPUTS

      ds - DateStamp pointer whose fields will be computed
           from timeval.

      tv - Timeval holder.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      This macro is useful when one wants to manipulate the
      time and date as it is simplier to subtract or add two
      timevals than DateStamps.

      This macro due to high arithmetic load(including div.)
      is somewhat unsuitable for time critical use.



   SEE ALSO

      QDEV_HLP_DSTOTV()



   EXAMPLE

      #include <proto/dos.h>
      #include <qdev.h>

      int main(void)
      {
        struct DateTime dat;
        struct timeval dst;
        struct timeval src;
        UBYTE buftime[LEN_DATSTRING] =
                {'0', '0', ':', '0', '0', ':', '0', '0', 0};

        DateStamp(&dat.dat_Stamp);

        QDEV_HLP_DSTOTV(&src, &dat.dat_Stamp);

        Delay(50);

        DateStamp(&dat.dat_Stamp);
    
        QDEV_HLP_DSTOTV(&dst, &dat.dat_Stamp);
    
        QDEV_HLP_SUBTV(&dst, &src);

        QDEV_HLP_TVTODS(&dat.dat_Stamp, &dst);

        dat.dat_Format = FORMAT_DOS;
      
        dat.dat_Flags = 0;
      
        dat.dat_StrDay = NULL;
      
        dat.dat_StrDate = NULL;
      
        dat.dat_StrTime = buftime;

        DateToStr(&dat);

        FPrintf(Output(), "%03ld:%s\n",
              dat.dat_Stamp.ds_Days, (LONG)dat.dat_StrTime);

        return 0;
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      REGARG() - Var. definition macro that makes it possible
                 to assign it particular CPU register.



   SYNOPSIS

      REGARG(var, reg)

      REGARG(<type> <name>, <register>)



   FUNCTION

      This macro can be used to declare the function arguments
      in a way that the declarations can then be modified with
      no direct code changes due to '__register' and '__asm'
      aliases that can be redefined.



   INPUTS

      var - Normal variable declaration(like: LONG num).

      reg - One of the m68xxx register name(like: d1).



   RETURNS

      No output.



   BASES

      None.



   NOTES

      Always use this macro to declare function arguments, so
      that assembly interface can easily be modified anytime
      giving you the ability to switch to arguments on stack.



   SEE ALSO

      REGVAR()



   EXAMPLE

      __saveds __interrupt LONG myfunc(REGARG(LONG num, d1))
      {
        return -(num);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      REGVAR() - Var. definition macro that makes it possible
                 to assign it particular CPU register.



   SYNOPSIS

      REGVAR(var, reg)

      REGVAR(<type> <name>, <register>)



   FUNCTION

      This macro can be used to declare the function vars in
      a way that the declarations are solid and cannot easily
      be modified.



   INPUTS

      var - Normal variable declaration(like: LONG num).

      reg - One of the m68xxx register name(like: d1).



   RETURNS

      No output.



   BASES

      None.



   NOTES

      Always use this macro to declare function variables, so
      that they are given the exact CPU registers through-out
      the execution of the function.

      This macro uses direct abbreviations such as 'register'
      and 'asm'!



   SEE ALSO

      REGARG()



   EXAMPLE

      LONG myfunc(LONG in)
      {
        REGVAR(LONG num, d1) = in;

        return -(num);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      __LOADA4() - Loads the contents of a variable into CPU
                   register A4.



   SYNOPSIS

      __LOADA4(val);

      __LOADA4([LONG]);



   FUNCTION

      This macro allows to restore the contents of A4 m68xxx
      CPU register on a per-context-basis. This macro is only
      active when binary model requested in 'gcc' is either
      '-resident' or '-resident32' and the define '-Dresident'
      was passed.



   INPUTS

      val - Var.(not its address!) that stores the contents of
            the register.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      Use this macro when compiling so called pure executables
      when the parent proc. spawns some children and they need
      to access parent's globals(prior to A4!).

      The macro will be a stub when binary model is just reloc
      so it can stay in the code independently of the setting.



   SEE ALSO

      __SAVEA4()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      __SAVEA4() - Saves the contents of a CPU register A4 in
                   the variable given.



   SYNOPSIS

      __SAVEA4(val);

      __SAVEA4([LONG]);



   FUNCTION

      This macro allows to store the contents of A4  m68xxx CPU
      register in a variable for later use. This macro is only
      active when binary model requested in 'gcc' is '-resident'
      or '-resident32' and the define '-Dresident' was passed.



   INPUTS

      val - Var.(not its address!) that will keep the contents
            of the register.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      Use this macro when compiling so called pure executables
      when the parent proc. spawns some children and they need
      to access parent's globals(prior to A4!).

      The macro will be a stub when binary model is just reloc
      so it can stay in the code independently of the setting.



   SEE ALSO

      __LOADA4()



   EXAMPLE

      #include <proto/exec.h>
      #include <exec/execbase.h>
      #include <proto/dos.h>
      #include <proto/alib.h>
      #include <qdev.h>

      struct mystruct
      {
        LONG  ms_a4;
        LONG  ms_sync;
        void *ms_tc;
      };

      void subtask(void)
      {
        struct ExecBase *SysBase = (*((struct ExecBase **) 4));
        struct mystruct *ms;

        Wait(SIGBREAKF_CTRL_C);

        if ((ms = SysBase->ThisTask->tc_UserData))
        {
          __LOADA4(ms->ms_a4);

          /*
           * Can now use all the bases parent did initilize.
          */
          ...

          Forbid();

          ms->ms_sync--;

          Signal(ms->ms_tc, SIGBREAKF_CTRL_C);
        }

        RemTask(SysBase->ThisTask);
      }

      int main(void)
      {
        struct Task *tc;
        struct mystruct ms;

        __SAVEA4(ms.ms_a4);

        ms.ms_sync = 0;

        ms.ms_tc = SysBase->ThisTask;

        if ((tc = CreateTask("subtask", 0, subtask, 4096)))
        {
          ms.ms_sync++;

          tc->tc_UserData = &ms;

          Signal(tc, SIGBREAKF_CTRL_C);
        }

        /*
         * Wait for the 'subtask()'s to be complete. This is
         * the best way when spawning multiple children.
        */
        while (ms.ms_sync)
        {
          Wait(SIGBREAKF_CTRL_C);
        }

        return 0;
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEVDEBUG() - Library own built-in serial port debug
                    output.



   SYNOPSIS

      QDEVDEBUG(fmt, va...);

      QDEVDEBUG(UBYTE *, [char *]);



   FUNCTION

      Family of these macros are tied to 'qdev' debug support
      module which makes it possible to visually track program
      flow at any stage and virtually in any state(interrupt,
      private exception, kernel hooks, etc).



   INPUTS

      fmt - Standard 'txt_vcbpsnprintf()' formating options or
            plain text.

      va  - Arguments that accompany '%' preceeded options in
            'fmt'.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      Please note, that the debug support subsystem transfers
      all messages to Amiga's built-in serial port @ 9600 bps!

      Redirection is possible though, via either 'sashimi' or
      'sushi'.

      Even though no BASES were given it does reference 'exec'
      in a private way, but no need to worry about SysBase!

      Macros 'QDEVDEBUG_R()' and 'QDEVDEBUG_RR()' can be used
      in conjunction with 'QDEVDEBUGIO()' debug inliner macro.
      They basically switch output relevance at some point and
      in case of double R sustain it until the end of program.

      To enable the debug facility #define ___QDEV_DEBUGINFO 1



   SEE ALSO

      QDEVDEBUGIO()



   EXAMPLE

      ...

      QDEVDEBUG(QDEVDBSPACE "About to poke the hardware!\n");

      ...



   BUGS

      You should not be using this debug facility in resident
      binaries who cause interrupts or have children and such,
      since globals who are A4 relative may not be available!



 ----------------------------------------------------------------------------
                                 PORTA - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEVDEBUGIO() - Debug facility extension(inliner) macro.



   SYNOPSIS

      QDEVDEBUGIO(va...);

      QDEVDEBUGIO([ULONG]);



   FUNCTION

      This macro extends the 'QDEVDEBUG[x]()' debug family in
      that it adds quick function location info(BFD-free) and
      relevance switching and many more useful features that
      help in debugging.



   INPUTS

      va - Optional function or program related control flags.
           See the 'qdev_debug.txt' file for more details.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      This macro should always be placed at the bottom of the
      function, prefereably after the 'return' statement.

      To enable function entry/exit information specify these
      '-fno-inline-functions -finstrument-functions' flags at
      the compilation time. Especially the last option is of
      great priority when you need other features to work!

      If you want to disable entry/exit info per particular
      function then add '__nifunc' before the declaration.



   SEE ALSO

      QDEVDEBUG()



   EXAMPLE

      #include <qdev.h>

      /*
       * Entry/exit info will be printed along with enclosed
       * debug output.
      */
      LONG myfunc(LONG x)
      {
        QDEVDEBUG(QDEVDBFARGS "(x = %ld)\n", x);

        return (x & 3);

        QDEVDEBUGIO();
      }

      /*
       * Entry/exit info will not be printed, but 'QDEVDEBUG'
       * will be still visible.
      */
      __nifunc LONG myfunc2(LONG x)
      {
        QDEVDEBUG(QDEVDBFARGS "(x = %ld)\n", x);

        return (x & 3);

        QDEVDEBUGIO();
      }



   BUGS

      Bugs? what bugs ;-) ?



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      MFADD() - Allows to add one float/double to the another.



   SYNOPSIS

      sum = MFADD(x, y);

      MFARITH MFADD(MFARITH, MFARITH);



   FUNCTION

      This macro allows to add two floats or doubles like you
      would call 'IEEE[S|D]PAdd()'.



   INPUTS

      x - IEEE floating point value(single/double precision).

      y - IEEE floating point value(single/double precision).



   RETURNS

      Returns the sum of x + y as an IEEE floating point val.



   BASES

      [MathIeeeDoubBasBase], [MathIeeeSingBasBase]



   NOTES

      By default macro will operate on single precision IEEE
      values. To switch to double, define ___QDEV_DOUBLEPREC.



   SEE ALSO

      MFSUB(), MFMUL(), MFDIV(), MFFIX(), MFFLT(),
      MFCMP(), MFCLE(), MFCGE()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      MFCGE() - Allows to determine if one float or double
                is greater or equal another float or double.



   SYNOPSIS

      res = MFCGE(x, y);

      LONG MFCGE(MFARITH, MFARITH);



   FUNCTION

      This macro allows to compare two floats/doubles such
      that it is possible to know if x is greater or equal y.



   INPUTS

      x - IEEE floating point value(single/double precision).

      y - IEEE floating point value(single/double precision).



   RETURNS

      Returns 1 if (x >= y), 0 otherwise.



   BASES

      [MathIeeeDoubBasBase], [MathIeeeSingBasBase]



   NOTES

      By default macro will operate on single precision IEEE
      values. To switch to double, define ___QDEV_DOUBLEPREC.



   SEE ALSO

      MFADD(), MFSUB(), MFMUL(), MFDIV(), MFFIX(), MFFLT(),
      MFCMP(), MFCLE()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      MFCLE() - Allows to determine if one float or double
                is less or equal another float or double.



   SYNOPSIS

      res = MFCLE(x, y);

      LONG MFCLE(MFARITH, MFARITH);



   FUNCTION

      This macro allows to compare two floats/doubles such
      that it is possible to know if x is less or equal y.



   INPUTS

      x - IEEE floating point value(single/double precision).

      y - IEEE floating point value(single/double precision).



   RETURNS

      Returns 1 if (x <= y), 0 otherwise.



   BASES

      [MathIeeeDoubBasBase], [MathIeeeSingBasBase]



   NOTES

      By default macro will operate on single precision IEEE
      values. To switch to double, define ___QDEV_DOUBLEPREC.



   SEE ALSO

      MFADD(), MFSUB(), MFMUL(), MFDIV(), MFFIX(), MFFLT(),
      MFCMP(), MFCGE()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      MFCMP() - Allows to compare two single or double prec.
                values.



   SYNOPSIS

      res = MFCMP(x, y);

      LONG MFCMP(MFARITH, MFARITH);



   FUNCTION

      This macro allows to compare two floats/doubles like
      you would call 'IEEE[S|D]PCmp()'.



   INPUTS

      x - IEEE floating point value(single/double precision).

      y - IEEE floating point value(single/double precision).



   RETURNS

      Returns -1 if (x < y), 0 if (x == y) and 1 if (x > y).



   BASES

      [MathIeeeDoubBasBase], [MathIeeeSingBasBase]



   NOTES

      By default macro will operate on single precision IEEE
      values. To switch to double, define ___QDEV_DOUBLEPREC.



   SEE ALSO

      MFADD(), MFSUB(), MFMUL(), MFDIV(), MFFIX(), MFFLT(),
      MFCLE(), MFCGE()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      MFDIV() - Allows to divide one float or double by
                another.



   SYNOPSIS

      div = MFDIV(x, y);

      MFARITH MFDIV(MFARITH, MFARITH);



   FUNCTION

      This macro allows to divide two floats/doubles like
      you would call 'IEEE[S|D]PDiv()'.



   INPUTS

      x - IEEE floating point value(single/double precision).

      y - IEEE floating point value(single/double precision).



   RETURNS

      Returns the div of x / y as an IEEE floating point val.



   BASES

      [MathIeeeDoubBasBase], [MathIeeeSingBasBase]



   NOTES

      By default macro will operate on single precision IEEE
      values. To switch to double, define ___QDEV_DOUBLEPREC.



   SEE ALSO

      MFADD(), MFSUB(), MFMUL(), MFFIX(), MFFLT(),
      MFCMP(), MFCLE(), MFCGE()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      MFFIX() - Allows to convert IEEE floating point value
                to 32 bit integer.



   SYNOPSIS

      int = MFFIX(x);

      LONG MFFIX(MFARITH);



   FUNCTION

      This macro allows to convert float or double like you
      would call 'IEEE[S|D]PFix()'.



   INPUTS

      x - IEEE floating point value(single/double precision).



   RETURNS

      Ret. an integer of IEEE. Overflow will be indicated by
      the largest positive value.



   BASES

      [MathIeeeDoubBasBase], [MathIeeeSingBasBase]



   NOTES

      By default macro will operate on single precision IEEE
      values. To switch to double, define ___QDEV_DOUBLEPREC.



   SEE ALSO

      MFADD(), MFSUB(), MFMUL(), MFDIV(), MFFLT(),
      MFCMP(), MFCLE(), MFCGE()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      MFFLT() - Allows to convert 32bit integer to single or
                double precision IEEE floating point value.



   SYNOPSIS

      flt = MFFLT(x);

      MFARITH MFFLT(LONG);



   FUNCTION

      This macro allows to convert integer to float or double
      like you would call 'IEEE[S|D]PFlt()'.



   INPUTS

      x - 32 bit integer value.



   RETURNS

      Returns IEEE value according to the input. There are no
      exceptions!



   BASES

      [MathIeeeDoubBasBase], [MathIeeeSingBasBase]



   NOTES

      By default macro will operate on single precision IEEE
      values. To switch to double, define ___QDEV_DOUBLEPREC.



   SEE ALSO

      MFADD(), MFSUB(), MFMUL(), MFDIV(), MFFIX(),
      MFCMP(), MFCLE(), MFCGE()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      MFMUL() - Allows to multiply one float or double by
                another.



   SYNOPSIS

      mul = MFMUL(x, y);

      MFARITH MFMUL(MFARITH, MFARITH);



   FUNCTION

      This macro allows to multiply two floats/doubles like
      you would call 'IEEE[S|D]PMul()'.



   INPUTS

      x - IEEE floating point value(single/double precision).

      y - IEEE floating point value(single/double precision).



   RETURNS

      Returns the mul of x * y as an IEEE floating point val.



   BASES

      [MathIeeeDoubBasBase], [MathIeeeSingBasBase]



   NOTES

      By default macro will operate on single precision IEEE
      values. To switch to double, define ___QDEV_DOUBLEPREC.



   SEE ALSO

      MFADD(), MFSUB(), MFDIV(), MFFIX(), MFFLT(),
      MFCMP(), MFCLE(), MFCGE()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      MFSUB() - Allows to subtract one float or double from
                another.



   SYNOPSIS

      sub = MFSUB(x, y);

      MFARITH MFSUB(MFARITH, MFARITH);



   FUNCTION

      This macro allows to subtract one float or double from
      another like you would call 'IEEE[S|D]PSub()'.



   INPUTS

      x - IEEE floating point value(single/double precision).

      y - IEEE floating point value(single/double precision).



   RETURNS

      Returns the sub of x - y as an IEEE floating point val.



   BASES

      [MathIeeeDoubBasBase], [MathIeeeSingBasBase]



   NOTES

      By default macro will operate on single precision IEEE
      values. To switch to double, define ___QDEV_DOUBLEPREC.



   SEE ALSO

      MFADD(), MFMUL(), MFDIV(), MFFIX(), MFFLT(),
      MFCMP(), MFCLE(), MFCGE()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      MFVALUE() - MFARITH value guard macro.



   SYNOPSIS

      out = MFVALUE(in);

      MFARITH MFVALUE(MFARITH);



   FUNCTION

      This macro is a stub when operating on IEEE values but
      when  ___QDEV_NOIEEEMATH  was specified during compile
      then it converts all explicit values to FFP before the
      assignment or when such values are to be passed to the
      math function(MFADD, MFSUB, MFMUL, MFDIV, ...).



   INPUTS

      in - Value known at compilation time in IEEE format.



   RETURNS

      Depending on control macro returns input in FFP format
      or passes it through(IEEE).
      


   BASES

      None.



   NOTES

      See the notes of 'QDEV_HLP_IEEETOFFP()' macro for more
      details.

      The use of this macro is necessary when one uses 'gcc'
      and wants to perform 'mathffp.library' calls.



   SEE ALSO

      MFSUB(), MFMUL(), MFDIV(), MFFIX(), MFFLT(),
      MFCMP(), MFCLE(), MFCGE(), QDEV_HLP_IEEETOFFP()



   EXAMPLE

      ...

      MFARITH x = MFVALUE(1.99999);

      ...



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_ABS() - Absolutifies the value given so it is
                       always positive.



   SYNOPSIS

      abs = QDEV_HLP_ABS(a);

      [LONG] QDEV_HLP_ABS([LONG]);



   FUNCTION

      This macro allows to turn possibly negative value into
      a positive one.



   INPUTS

      a - Value of any type that can hold an integer.



   RETURNS

      Returns a if it is already positive or its absolutfied
      eqiuvalent.


   BASES

      None.



   NOTES

      This macro can cause side effects, due to multiple arg.
      evaluation! Make sure that what you pass are just the
      arguments or constants or non-permanent statements.



   SEE ALSO

      QDEV_HLP_MIN(), QDEV_HLP_MAX(),
      QDEV_HLP_NEG(), QDEV_HLP_FLIP()



   EXAMPLE

      #include <qdev.h>

      ...

      LONG x = -6;
      LONG z;

      /*
       * Example of the right usage, so no side effects will
       * occurr.
      */
      z = QDEV_HLP_ABS((x - 1));

      /*
       * Example of side effect statement which can turn the
       * code into bad state.
      */
      z = QDEV_HLP_ABS(x--);

      ...      



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_ADDTV() - Adds a timeval to another timeval.



   SYNOPSIS

      QDEV_HLP_ADDTV(dst, src);

      QDEV_HLP_ADDTV(struct timeval *, struct timeval *);



   FUNCTION

      This macro is able to sum two 'tv' holders and store
      the result in 'dst'.



   INPUTS

      dst - Timeval that acts as a result.

      src - Timeval that will be added to 'dst'.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      Warning, 'struct timeval' must be defined the Amigish
      way: tv_secs, tv_micro!



   SEE ALSO

      QDEV_HLP_SUBTV()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_ASMALIAS() - Allows to create symbol alias on
                            linker level.



   SYNOPSIS

      QDEV_HLP_ASMALIAS(new, old);

      QDEV_HLP_ASMALIAS(<new_symbol>, <old_symbol>);



   FUNCTION

      This macro allows to create symbol alias using stabs
      interface. Each such statement must be put outside the
      function body!



   INPUTS

      new - Newly created symbol that refrences 'old' symbol.

      old - A symbol that will be given an alias.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      Symbols need not to be declared in the object that is
      being compiled.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_ASMENTRY() - Allows to inject assembly routine.



   SYNOPSIS

      QDEV_HLP_ASMENTRY(name, code);

      QDEV_HLP_ASMENTRY(<name>, <code>);



   FUNCTION

      This macro allows to write assembly routines who will be
      then interfaced with the C code.



   INPUTS

      name - Name of the routine.

      code - Body of the routine. Machine rel./pseudo assembly.
             Each line of code must be quoted and must contain
             '\n\t' preferably at the beginning.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      The only routine that uses this is 'nfo_m68cputype()'. It
      also happens to be open-source.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_BADDR() - Descrambles strictly BCPL pointer.



   SYNOPSIS

      ptr = QDEV_HLP_BADDR(addr);

      [APTR] = QDEV_HLP_BADDR([LONG]);



   FUNCTION

      This macro allows to convert the address from BCPL to
      normal C style notation.



   INPUTS

      addr - An address as BPTR, a 4 byte aligned, 32bit in
             size, possibly integer.



   RETURNS

      Returns direct pointer(a physical memory reference).



   BASES

      None.



   NOTES

      None.



   SEE ALSO

      QDEV_HLP_MKBADDR()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_BYTESPERROW() - Computes the size of one row of
                               standard Amiga bitmap.



   SYNOPSIS

      rowsize = QDEV_HLP_BYTESPERROW(w);

      [ULONG] QDEV_HLP_BYTESPERROW([UWORD]);



   FUNCTION

      This macro allows to compute size of row a single plane
      would take in order to construct standard Amiga bitmap.



   INPUTS

      w - Width(in pixels) of the projected/existing bitmap.



   RETURNS

      Returns size of a single row in bytes. This value is 16
      aligned always.



   BASES

      None.



   NOTES

      There is a QDEV_HLP_BYTESPERROW64() incarnation of this
      macro. Please do not use it on regular bitmaps!



   SEE ALSO

      QDEV_HLP_RASSIZE()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_EQUALIZEUC() - Changes lower cased characters
                              into upper cased ones.



   SYNOPSIS

      uchr = QDEV_HLP_EQUALIZEUC(chr);

      [ULONG] QDEV_HLP_EQUALIZEUC([ULONG]);



   FUNCTION

      This macro allows to change the casing of a particular
      character by making it upper case. It does 8 bit ASCII
      so that international chars are also to be taken into
      account.



   INPUTS

      chr - Input character(automatically typecasted).



   RETURNS

      Returns the input as upper case or passes through what
      was given.



   BASES

      None.



   NOTES

      This macro can be overriden by the 'utility.library'
      function 'ToUpper()' by defining ___QDEV_UTILITYCHAREQ



   SEE ALSO

      QDEV_HLP_EQUALIZELC()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_EQUALIZELC() - Changes upper cased characters
                              into lower cased ones.



   SYNOPSIS

      lchr = QDEV_HLP_EQUALIZELC(chr);

      [ULONG] QDEV_HLP_EQUALIZELC([ULONG]);



   FUNCTION

      This macro allows to change the casing of a particular
      character by making it lower case. It does 8 bit ASCII
      so that international chars are also to be taken into
      account.



   INPUTS

      chr - Input character(automatically typecasted).



   RETURNS

      Returns the input as lower case or passes through what
      was given.



   BASES

      None.



   NOTES

      This macro can be overriden by the 'utility.library'
      function 'ToLower()' by defining ___QDEV_UTILITYCHAREQ



   SEE ALSO

      QDEV_HLP_EQUALIZEUC()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_E_DIVULONG10() - Enhanced, by 10 32 bit integer
                                division.



   SYNOPSIS

      res = QDEV_HLP_E_DIVULONG10(num)

      [ULONG] QDEV_HLP_E_DIVULONG10([ULONG]);



   FUNCTION

      This macro allows to quickly divide 32 bit number by 10
      using CPU independent code.



   INPUTS

      num - 32 bit dividend(unsigned).



   RETURNS

      Returns the 32 bit integer that is 10 times smaller than
      'num'.



   BASES

      None.



   NOTES

      This macro is especially efficient on 68020 and up CPUs.

      No underflow, nor divide-by-zero are ever reported, the
      default CPU/OS exception mechanism is not involved!



   SEE ALSO

      QDEV_HLP_N_DIVULONG10(), QDEV_HLP_N_MULUXXX10(),
      QDEV_HLP_MULU32X32()



   EXAMPLE

      None.



   BUGS

      This reciprocal multiplication can only return accurate
      results when 'num' is smaller or equal 2863311538!



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_FFPTOIEEE() - Converts FFP(Motorola) float to
                             IEEE 754 format.



   SYNOPSIS

      out = QDEV_HLP_FFPTOIEEE(in);

      MFARITH QDEV_HLP_FFPTOIEEE(MFARITH);



   FUNCTION

      This macro was written with  'mathffp.library' in mind
      so that it can be utilised from GCC too. FFP to IEEE.



   INPUTS

      in - 32 bit FFP float value.



   RETURNS

      Returns value in IEEE format.



   BASES

      None.



   NOTES

      This macro is branchless thusly no overflow detection
      is performed!



   SEE ALSO

      QDEV_HLP_IEEETOFFP()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_FLIP() - Changes the singedness of an integer.



   SYNOPSIS

      b = QDEV_HLP_FLIP(a);

      [LONG] QDEV_HLP_NEG([LONG]);



   FUNCTION

      This macro allows to change signedness of input value.



   INPUTS

      a - Value of any type that can hold an integer.



   RETURNS

      Returns value of opposite sign.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

      QDEV_HLP_MIN(), QDEV_HLP_MAX(),
      QDEV_HLP_ABS(), QDEV_HLP_NEG()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_FNV32CSUM() - Allows to compute FNV1a 32 bit
                             checksum.



   SYNOPSIS

      csum = QDEV_HLP_FNV32CSUM(ics, ptr, size);

      [ULONG] QDEV_HLP_FNV32CSUM(ULONG, [UBYTE *], [LONG]);



   FUNCTION

      This macro allows to checksum memory region using FNV
      alogorithm. Checksum is 32bit wide.



   INPUTS

      ics  - Hash base initlizer. This can be either FNV own
             prime or result from previous macro instance so
             that memory can be checksummed in blocks.

      ptr  - Memory address to start at.

      size - Size of that memory region.


   RETURNS

      Returns 32 bit FNV checksum or the initializer in the
      worst case.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

      QDEV_HLP_FNV32HASH()



   EXAMPLE

      ...

      #include <proto/dos.h>
      #include <qdev.h>

      ULONG checksumfnv32(UBYTE *file)
      {
        UBYTE buf[1024];
        ULONG csum = QDEV_HLP_FNV32PRIME;
        LONG read;
        LONG fd;
        
        if ((fd = Open(file, MODE_OLDFILE)))
        {
          while ((read = Read(fd, buf, sizeof buf)) > 0)
          {
            csum = QDEV_HLP_FNV32CSUM(csum, buf, read); 
          }

          Close(fd);
        }

        return csum;
      }

      ...



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_FNV32HASH() - Hashes the string using FNV1a
                             algorithm.



   SYNOPSIS

      hash = QDEV_HLP_FNV32HASH(string);

      [ULONG] QDEV_HLP_FNV32HASH([UBYTE *]);



   FUNCTION

      This macro allows to hash NULL term. string with FNV
      algorithm.



   INPUTS

      string - Standard NULL terminated string.



   RETURNS

      Returns 32 bit FNV1a hash value.



   BASES

      None.



   NOTES

      This algorithm even though very simple and 32 bit in
      width is quite powerful when used on 7 bit ASCII!

      Case insensitive version is also available. Look for
      'QDEV_HLP_FNV32IHASH()' in the header file.



   SEE ALSO

      QDEV_HLP_FNV32CSUM()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_IEEETOFFP() - Converts a float from IEEE 754
                             to FFP(Motorola) format.



   SYNOPSIS

      out = QDEV_HLP_IEEETOFFP(in);

      MFARITH QDEV_HLP_IEEETOFFP(MFARITH);



   FUNCTION

      This macro was written with 'mathffp.library' in mind
      so that it can be utilised from GCC too. IEEE TO FFP.



   INPUTS

      in - 32 bit IEEE float value.



   RETURNS

      Returns value in FFP format.



   BASES

      None.



   NOTES

      This macro is branchless thusly no overflow detection
      is performed!



   SEE ALSO

      QDEV_HLP_FFPTOIEEE()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_LCOPYMEM() - Fast memory copy macro for small
                            data.



   SYNOPSIS

      QDEV_HLP_LCOPYMEM(to, from, len);

      QDEV_HLP_LCOPYMEM(void *, void *, long);



   FUNCTION

      This macro allows to copy data upto 59 bytes in a fast
      way by being transformed into efficient assembly with
      super small overhead.



   INPUTS

      to   - Memory address where the data will be copied to.

      from - Memory address where the data will be read from.
             If this is contant then generated code may/will
             be even faster since it may be PC relative.

      len  - Size of the copy. Pass integer that is known at
             compilation time to benefit from this macro! If
             this value is not known then call to '_bcopy()'
             will be generated...



   RETURNS

      No output.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

      QDEV_HLP_QUICKFILL()



   EXAMPLE

      ...

      #define TEXT "Compile and disassemble :)"
      /*            ^^^^^^^^^^^^^^^^^^^^^^^^^^
                    L   L   L   L   L   L   BBB  */
      void routine(void)
      {
        UBYTE buf[32];

        QDEV_HLP_LCOPYMEM(buf, TEXT, sizeof(TEXT));

        printf("%s\n", buf);
      }

      ...

      LC1:
        .ascii "Compile and disassemble :)\0"
      LC2:
        .ascii "%s\12\0"
        .even
        .globl _routine
      _routine:
        link a5,#-32
        movel LC1,a5@(-32)
        movel LC1+4,a5@(-28)
        movel LC1+8,a5@(-24)
        movel LC1+12,a5@(-20)
        movel LC1+16,a5@(-16)
        movel LC1+20,a5@(-12)
        moveb LC1+24,a5@(-8)
        moveb LC1+25,a5@(-7)
        moveb LC1+26,a5@(-6)
        pea a5@(-32)
        pea LC2
        jbsr _printf
        unlk a5
        rts



   BUGS
      
      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_LSHIFT64() - Shifts contents of 64bit datatype
                            left.



   SYNOPSIS

      res = QDEV_HLP_LSHIFT64(val, bits);

      [ULONG] QDEV_HLP_LSHIFT64([VUQUAD], [ULONG]);



   FUNCTION

      This macro allows to shift in place any UQUAD or VUQUAD
      by this many bits left.



   INPUTS

      val  - Direct datatype(UQUAD/VUQUAD) symbol(non-ptr).

      bits - Amount of bits to shift left(1 to 63).



   RETURNS

      Returns boolean that indicates, if there is anything to
      shift. 0 = means nothing to shift.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

      QDEV_HLP_RSHIFT64()



   EXAMPLE

      See the  'cnv_UQUADtoBITS()' macro now on how to use in
      a loop.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_MAX() - Picks the highest from given values.



   SYNOPSIS

      c = QDEV_HLP_MAX(a, b);

      [LONG] QDEV_HLP_MAX([LONG], [LONG]);



   FUNCTION

      This macro allows to select the highest possible value
      out of two values as passed in.



   INPUTS

      a - First value of any type that can hold an integer.

      b - Second value of any type that can hold an integer.



   RETURNS

      Returns a or b depending on what is greater than the
      other argument.



   BASES

      None.



   NOTES

      This macro can cause side effects, due to multiple arg.
      evaluation! Make sure that what you pass are just the
      arguments or constants or non-permanent statements.



   SEE ALSO

      QDEV_HLP_MIN(), QDEV_HLP_ABS(),
      QDEV_HLP_NEG(), QDEV_HLP_FLIP()



   EXAMPLE

      #include <qdev.h>

      ...

      LONG x = 6;
      LONG y = 3;
      LONG z;

      /*
       * Example of the right usage, so no side effects will
       * occurr.
      */
      z = QDEV_HLP_MAX((x - 1), y);

      /*
       * Example of side effect statement which can turn the
       * code into bad state.
      */
      z = QDEV_HLP_MAX(x--, y);

      ...      



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_MIN() - Picks the lowest from two passed in
                       values.



   SYNOPSIS

      c = QDEV_HLP_MIN(a, b);

      [LONG] QDEV_HLP_MIN([LONG], [LONG]);



   FUNCTION

      This macro allows to pick the lowest possible value out
      of two values as passed in.



   INPUTS

      a - First value of any type that can hold an integer.

      b - Second value of any type that can hold an integer.



   RETURNS

      Returns a or b depending on what is less than the other
      argument.



   BASES

      None.



   NOTES

      This macro can cause side effects, due to multiple arg.
      evaluation! Make sure that what you pass are just the
      arguments or constants or non-permanent statements.



   SEE ALSO

      QDEV_HLP_MAX(), QDEV_HLP_ABS(),
      QDEV_HLP_NEG(), QDEV_HLP_FLIP()



   EXAMPLE

      #include <qdev.h>

      ...

      LONG x = 6;
      LONG y = 3;
      LONG z;

      /*
       * Example of the right usage, so no side effects will
       * occurr.
      */
      z = QDEV_HLP_MIN((x - 1), y);

      /*
       * Example of side effect statement which can turn the
       * code into bad state.
      */
      z = QDEV_HLP_MIN(x--, y);

      ...      



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_MKBADDR() - Turns C style address into BCPL
                           pointer.



   SYNOPSIS

      ptr = QDEV_HLP_MKBADDR(var);

      [LONG] = QDEV_HLP_MKBADDR([APTR]);



   FUNCTION

      This macro allows to convert regular C address into
      32bit BCPL pointer.



   INPUTS

      var - Anything that carries the 32bit address which
            is multiple of LONG size.



   RETURNS

      Returns valid, scrambled BPTR pointer as long as the
      input is multiple of 4 and an even value!



   BASES

      None.



   NOTES

      Must always get even address that is multiple of 4,
      otherwise the descrambled address will be invalid!



   SEE ALSO

      QDEV_HLP_BADDR()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_MKSTR() - Turns free symbols into strings on
                         a preprocessor level.



   SYNOPSIS

      string = QDEV_HLP_MKSTR(symbol)

      UBYTE * QDEV_HLP_MKSTR(<symbol>)



   FUNCTION

      This macro allows to turn any free symbol into string
      by double expansion.



   INPUTS

      symbol - Anything literal with no double quotes will
               do.



   RETURNS

      Returns text constant.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      ...

      #define SIZEOFHELL 666

      UBYTE text[] =
       "The hell is as big as " QDEV_HLP_MKSTR(SIZEOFHELL);

      ...



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_MULU32X32() - Multiplies two 32 bit integers.



   SYNOPSIS

      QDEV_HLP_MULU32X32(a, b, vuq);

      QDEV_HLP_MULU32X32([ULONG], [ULONG], [VUQUAD]);



   FUNCTION

      This macro allows to multiply two 32 bit integers and
      write the result into real or virtual 64 bit datatype.



   INPUTS

      a   - 32 bit operand.

      b   - 32 bit operand.

      vuq - Direct(non-pointer) 64 bit result holder.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      This macro is totally CPU indpendent and in many cases
      at least two times faster than compiler wrapped code.



   SEE ALSO

      QDEV_HLP_N_MULUXXX10()



   EXAMPLE

      #include <stdio.h>
      #include <qdev.h>

      int main(void)
      {
        ULONG a = 2000000000;
        ULONG b = 4;
        VUQUAD vuq;

        QDEV_HLP_MULU32X32(a, b, vuq);

        printf("%qd\n", *(UQUAD *)&vuq);

        return 0;
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_N_DIVULONG10() - Normal/not-so-fast, by 10 32
                                bit integer division.



   SYNOPSIS

      res = QDEV_HLP_N_DIVULONG10(num)

      [ULONG] QDEV_HLP_N_DIVULONG10([ULONG]);



   FUNCTION

      This macro allows to just divide the 32bit number by 10
      using compiler API.



   INPUTS

      num - 32 bit dividend(unsigned).



   RETURNS

      Returns the 32bit integer that is 10 times smaller than
      'num'.



   BASES

      None.



   NOTES

      This macro is slightly slower that the enhanced version
      on Motorola 68xxx processors, as the code generated by
      the compiler references 64 bit wrappers. On the other
      hand it may be way faster on other CPUs.

      No underflow, nor divide-by-zero are ever reported, the
      default CPU/OS exception mechanism is not involved!



   SEE ALSO

      QDEV_HLP_E_DIVULONG10(), QDEV_HLP_N_MULUXXX10()



   EXAMPLE

      None.



   BUGS

      This reciprocal multiplication can only return accurate
      results when 'num' is smaller or equal 2863311538!



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_N_MULUXXX10() - By 10, type independent int.
                               multiplication.



   SYNOPSIS

      res = QDEV_HLP_N_MULUXXX10(num, type);

      <type> QDEV_HLP_N_MULUXXX10(<integer>, <type>);



   FUNCTION

      This macro allows to multiply by 10 using bitwise ops.



   INPUTS

      num  - Any word size operand(unsigned).

      type - Type of that operand(UWORD, ULONG, UQUAD, ...).



   RETURNS

      Ret. the integer of '<type>' that is 10 times greater
      than 'num'.



   BASES

      None.



   NOTES

      This macro is very efficient when working on UQUADs on
      68xxx CPUs. Keep in mind that no overflow is signaled!



   SEE ALSO

      QDEV_HLP_E_DIVULONG10(), QDEV_HLP_N_DIVULONG10()
      QDEV_HLP_MULU32X32()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_NEG() - Negativises the value given so it is
                       always on minus.



   SYNOPSIS

      neg = QDEV_HLP_NEG(a);

      [LONG] QDEV_HLP_NEG([LONG]);



   FUNCTION

      This macro allows to turn possibly positive value into
      a negative one.



   INPUTS

      a - Value of any type that can hold an integer.



   RETURNS

      Returns a if it is already negative or its negativised
      eqiuvalent.


   BASES

      None.



   NOTES

      This macro can cause side effects, due to multiple arg.
      evaluation! Make sure that what you pass are just the
      arguments or constants or non-permanent statements.



   SEE ALSO

      QDEV_HLP_MIN(), QDEV_HLP_MAX(), QDEV_HLP_ABS()



   EXAMPLE

      #include <qdev.h>

      ...

      LONG x = 6;
      LONG z;

      /*
       * Example of the right usage, so no side effects will
       * occurr.
      */
      z = QDEV_HLP_NEG((x + 1));

      /*
       * Example of side effect statement which can turn the
       * code into bad state.
      */
      z = QDEV_HLP_NEG(x++);

      ...      



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_QUICKFILL() - Wordsize dependant memory filler.



   SYNOPSIS

      QDEV_HLP_QUICKFILL(ptr, t, val, size);

      QDEV_HLP_QUICKFILL
                      (void *, <type>, <value>, <sizeof buf>);



   FUNCTION

      This macro allows to inline sort of 'memset()', but all
      is based upon word size. Effectively the buffer must be
      multiple of 't', but 'size' is in bytes!



   INPUTS

      ptr  - Address of the buffer that will be filled with
             'val'.

      t    - Type of the datatype(BYTE, WORD, LONG, QUAD,...)

      val  - Value that is of word width.

      size - Size of the buffer to be filled with 'val' words.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      You must be absolutely sure that what you specify is of
      the right size. In other words buffer must be multiple
      of sizeof(<type>)!



   SEE ALSO

      QDEV_HLP_LCOPYMEM()



   EXAMPLE

      ...

      LONG table[32];

      QDEV_HLP_QUICKFILL(
                  &table[0], LONG, 0x7FFFFFFE, sizeof(table));

      ...



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_SWAPQUAD() - Allows to swap contents of QUAD.



   SYNOPSIS

      res = QDEV_HLP_SWAPQUAD(val);

      [QUAD] QDEV_HLP_SWAPQUAD([QUAD]);



   FUNCTION

      This macro is quite useful when there is a need to in-
      place swap contents of QUAD/UQUAD/VQUAD/VUQUAD. Little
      <> big endian conversion.



   INPUTS

      val - Direct variable only!



   RETURNS

      Additionally returns what was swapped.



   BASES

      None.



   NOTES

      Remember though that the contents of the datatype will
      be rotated in place!



   SEE ALSO

      QDEV_HLP_SWAPWORD(), QDEV_HLP_SWAPLONG()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_POPCOUNT() - Counts bits set in 32bit integer.



   SYNOPSIS

      res = QDEV_HLP_POPCOUNT(x);

      [ULONG] QDEV_HLP_POPCOUNT([ULONG]);



   FUNCTION

      This macro is very useful when all 1's must be computed
      very fast. The method is known as Parallel Count.



   INPUTS

      x - 32 bit unsigned integer.



   RETURNS

      Returns how many 1's is set in that integer.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_RASSIZE() - Computes a single plane of Amiga
                           bitmap.



   SYNOPSIS

      planesize = QDEV_HLP_RASSIZE(w ,h);

      [ULONG] QDEV_HLP_RASSIZE([UWORD], [UWORD]);



   FUNCTION

      This macro allows to compute raster size, which is to
      say a single bitmap plane size.



   INPUTS

      w - Width(in pixels) of the projected/existing bitmap.

      h - Height(in pixels) of the projected/existing bitmap.



   RETURNS

      Returns size of a single plane in bytes.



   BASES

      None.



   NOTES

      There is a QDEV_HLP_RASSIZE64() incarnation of this
      macro. Please do not use it on regular bitmaps!



   SEE ALSO

      QDEV_HLP_BYTESPERROW()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_ROUNDPOW2() - Rounds 32 bit integer to nearest
                             power of 2 number.



   SYNOPSIS

      res = QDEV_HLP_ROUNDPOW2(val);

      ULONG QDEV_HLP_ROUNDPOW2([ULONG]);



   FUNCTION

      This macro allows to round the input value to the power
      of 2 using bitwise trick.



   INPUTS

      val - 32 bit only value.



   RETURNS

      Returns value to the power of 2.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_RSHIFT64() - Shifts contents of 64bit datatype
                            right.



   SYNOPSIS

      res = QDEV_HLP_RSHIFT64(val, bits);

      [ULONG] QDEV_HLP_RSHIFT64([VUQUAD], [ULONG]);



   FUNCTION

      This macro allows to shift in place any UQUAD or VUQUAD
      by this many bits right.



   INPUTS

      val  - Direct datatype(UQUAD/VUQUAD) symbol(non-ptr).

      bits - Amount of bits to shift right(1 to 63).



   RETURNS

      Returns boolean that indicates, if there is anything to
      shift. 0 = means nothing to shift.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

      QDEV_HLP_LSHIFT64()



   EXAMPLE

      See the  'cnv_UQUADtoBITS()' macro now on how to use in
      a loop.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_SUBTV() - Subtracts one timeval from another.



   SYNOPSIS

      QDEV_HLP_SUBTV(dst, src);

      QDEV_HLP_SUBTV(struct timeval *, struct timeval *);



   FUNCTION

      This macro is able to properly subtract one tv holder
      from another and store the result in 'dst'.



   INPUTS

      dst - Timeval that acts as a result.

      src - Timeval that will be subtracted from 'dst'.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      Warning, 'struct timeval' must be defined the Amigish
      way: tv_secs, tv_micro!



   SEE ALSO

      QDEV_HLP_ADDTV()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_SWAPLONG() - Allows to swap contents of LONG.



   SYNOPSIS

      res = QDEV_HLP_SWAPLONG(val);

      [LONG] QDEV_HLP_SWAPLONG([LONG]);



   FUNCTION

      This macro is quite useful when there is a need to in-
      place swap contents of LONG/ULONG datatype. Lil <> big
      endian conversion.



   INPUTS

      val - Direct variable or value.



   RETURNS

      Additionally returns what was swapped.



   BASES

      None.



   NOTES

      Remember though that the contents of the datatype will
      be rotated in place!



   SEE ALSO

      QDEV_HLP_SWAPWORD(), QDEV_HLP_SWAPQUAD()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_SWAPQUAD() - Allows to swap contents of QUAD.



   SYNOPSIS

      res = QDEV_HLP_SWAPQUAD(val);

      [QUAD] QDEV_HLP_SWAPQUAD([QUAD]);



   FUNCTION

      This macro is quite useful when there is a need to in-
      place swap contents of QUAD/UQUAD/VQUAD/VUQUAD. Little
      <> big endian conversion.



   INPUTS

      val - Direct variable only!



   RETURNS

      Additionally returns what was swapped.



   BASES

      None.



   NOTES

      Remember though that the contents of the datatype will
      be rotated in place!



   SEE ALSO

      QDEV_HLP_SWAPWORD(), QDEV_HLP_SWAPLONG()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - PUBLIC
 ----------------------------------------------------------------------------

   NAME

      QDEV_HLP_SWAPWORD() - Allows to swap contents of WORD.



   SYNOPSIS

      res = QDEV_HLP_SWAPWORD(val);

      [WORD] QDEV_HLP_SWAPWORD([WORD]);



   FUNCTION

      This macro is quite useful when there is a need to in-
      place swap contents of WORD/UWORD datatype. Lil <> big
      endian conversion.



   INPUTS

      val - Direct variable or value.



   RETURNS

      Additionally returns what was swapped.



   BASES

      None.



   NOTES

      Remember though that the contents of the datatype will
      be rotated in place!



   SEE ALSO

      QDEV_HLP_SWAPLONG(), QDEV_HLP_SWAPQUAD()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
