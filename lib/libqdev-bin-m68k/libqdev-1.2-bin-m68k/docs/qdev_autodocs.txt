;
; $VER: qdev_autodocs.txt 1.163 (12/09/2014) English
;

TABLE OF CONTENTS

libqdev.a/crt_createargv()
libqdev.a/crt_destroyargv()
libqdev.a/crt_initmethod()
libqdev.a/crt_exitmethod()
libqdev.a/crt_newinstance()
libqdev.a/crt_freeinstance()
libqdev.a/ctl_clipath()
libqdev.a/ctl_devmount()
libqdev.a/ctl_devunmount()
libqdev.a/ctl_diskreqoff()
libqdev.a/ctl_diskreqon()
libqdev.a/ctl_haltidcmp()
libqdev.a/ctl_newshell()
libqdev.a/ctl_rearrangecon()
libqdev.a/ctl_relabel()
libqdev.a/ctl_setclistack()
libqdev.a/ctl_swapbackpen()
libqdev.a/ctl_udirassign()
libqdev.a/ctl_addbartrigger()
libqdev.a/ctl_pokebartrigger()
libqdev.a/ctl_rembartrigger()
libqdev.a/ctl_addconlogo()
libqdev.a/ctl_swapconlogo()
libqdev.a/ctl_remconlogo()
libqdev.a/ctl_addconlogof()
libqdev.a/ctl_remconlogof()
libqdev.a/ctl_setconlogof()
libqdev.a/ctl_openconscreen()
libqdev.a/ctl_closeconscreen()
libqdev.a/ctl_doconswitch()
libqdev.a/ctl_undoconswitch()
libqdev.a/ctl_addidcmphandler()
libqdev.a/ctl_remidcmphandler()
libqdev.a/ctl_findscreensafe()
libqdev.a/ctl_lockscreensafe()
libqdev.a/ctl_unlockscreensafe()
libqdev.a/ctl_addviewctrl()
libqdev.a/ctl_remviewctrl()
libqdev.a/ctl_zoomifycon()
libqdev.a/ctl_setsmparams()
libqdev.a/dev_getdiskcmdset()
libqdev.a/dev_opendiskdev()
libqdev.a/dev_closediskdev()
libqdev.a/dev_getdiskgeo()
libqdev.a/dev_freediskgeo()
libqdev.a/dev_getdiskrdb()
libqdev.a/dev_freediskrdb()
libqdev.a/dmt_mountcb()
libqdev.a/dos_addfdrelay()
libqdev.a/dos_ctrlfdrelay()
libqdev.a/dos_dopacket()
libqdev.a/dos_getpacket()
libqdev.a/dos_qflink()
libqdev.a/dos_qfopen()
libqdev.a/dos_qfwait()
libqdev.a/dos_qfispending()
libqdev.a/dos_qfsetmode()
libqdev.a/dos_qfsetintsig()
libqdev.a/dos_qfsetfctwait()
libqdev.a/dos_qfread()
libqdev.a/dos_qfwrite()
libqdev.a/dos_qfseek()
libqdev.a/dos_qfabort()
libqdev.a/dos_qfclose()
libqdev.a/dos_remfdrelay()
libqdev.a/dos_addlinkpoint()
libqdev.a/dos_dclinkpoint()
libqdev.a/dos_remlinkpoint()
libqdev.a/dos_devbymsgport()
libqdev.a/dos_makedevice()
libqdev.a/dos_checkdevice()
libqdev.a/dos_killdevice()
libqdev.a/dos_getfmfdrelay()
libqdev.a/dos_freefmfdrelay()
libqdev.a/dos_replypacket()
libqdev.a/dos_swapmpfdrelay()
libqdev.a/dos_waitpacket()
libqdev.a/han_binaryifh()
libqdev.a/han_rollifh()
libqdev.a/han_rwifh()
libqdev.a/han_termifh()
libqdev.a/mem_allocbmapthere()
libqdev.a/mem_cooperate()
libqdev.a/mem_dosynctask()
libqdev.a/mem_dosynctasks()
libqdev.a/mem_freepentab()
libqdev.a/mem_getwbstartup()
libqdev.a/mem_grabqarea()
libqdev.a/mem_iloadseg()
libqdev.a/mem_uniloadseg()
libqdev.a/mem_iloadseg2()
libqdev.a/mem_uniloadseg2()
libqdev.a/mem_initemptybmap()
libqdev.a/mem_remapbitmap()
libqdev.a/mem_remapbitmap2()
libqdev.a/mem_signalsafe()
libqdev.a/mem_makebmapfromimg()
libqdev.a/mem_addexhandler()
libqdev.a/mem_remexhandler()
libqdev.a/mem_attachhotvec()
libqdev.a/mem_attachrelhotvec()
libqdev.a/mem_detachhotvec()
libqdev.a/mem_resolvehotvec()
libqdev.a/mem_obtainhotvec()
libqdev.a/mem_obtainrelhotvec()
libqdev.a/mem_openifh()
libqdev.a/mem_closeifh()
libqdev.a/mem_convimgtobmap()
libqdev.a/mem_copyitnimage()
libqdev.a/mem_freeitnimage()
libqdev.a/mem_setaddrjtslot()
libqdev.a/mem_setdatajtslot()
libqdev.a/mem_allocjumptable()
libqdev.a/mem_freejumptable()
libqdev.a/mem_swapjumptable()
libqdev.a/mem_filljumptable()
libqdev.a/mem_importjumptable()
libqdev.a/mem_growpenholder()
libqdev.a/mem_freepenholder()
libqdev.a/mem_loadpicture()
libqdev.a/mem_freepicture()
libqdev.a/mem_alloclfvec()
libqdev.a/mem_freelfvec()
libqdev.a/mem_checklfvec()
libqdev.a/mem_allocvecpooled()
libqdev.a/mem_freevecpooled()
libqdev.a/mem_setvecpooled()
libqdev.a/mem_allocmemregion()
libqdev.a/mem_freememregion()
libqdev.a/mem_attachsniffer()
libqdev.a/mem_detachsniffer()
libqdev.a/mem_allocterm()
libqdev.a/mem_fixterm()
libqdev.a/mem_freeterm()
libqdev.a/mem_maketokenlist()
libqdev.a/mem_freetokenlist()
libqdev.a/mod_codereloc()
libqdev.a/mod_codefree()
libqdev.a/mod_codefind()
libqdev.a/mod_findktpresby()
libqdev.a/mod_getmemlist()
libqdev.a/mod_kicktaglink()
libqdev.a/mod_kicktagunlink()
libqdev.a/mod_ktpresunlink()
libqdev.a/mod_ktprescount()
libqdev.a/mod_addmodule()
libqdev.a/mod_delmodule()
libqdev.a/mod_adddiskmodule()
libqdev.a/mod_deldiskmodule()
libqdev.a/nfo_devvercmp()
libqdev.a/nfo_findgfxentry()
libqdev.a/nfo_findgfxrange()
libqdev.a/nfo_findgfxreso()
libqdev.a/nfo_findgfxsm()
libqdev.a/nfo_fsquery()
libqdev.a/nfo_fssmvalid()
libqdev.a/nfo_getcmcolors()
libqdev.a/nfo_getconioreq()
libqdev.a/nfo_getconunit()
libqdev.a/nfo_getscparams()
libqdev.a/nfo_getdrimap()
libqdev.a/nfo_getviscount()
libqdev.a/nfo_getvisstate()
libqdev.a/nfo_getwinaddr()
libqdev.a/nfo_grepml()
libqdev.a/nfo_idcmptoindex()
libqdev.a/nfo_isblitable()
libqdev.a/nfo_ischildofproc()
libqdev.a/nfo_isdev64bit()
libqdev.a/nfo_isdirectory()
libqdev.a/nfo_isinstack()
libqdev.a/nfo_isonmemlist()
libqdev.a/nfo_isonlistofml()
libqdev.a/nfo_ispdev64bit()
libqdev.a/nfo_issegremote()
libqdev.a/nfo_istask()
libqdev.a/nfo_iswindow()
libqdev.a/nfo_ktm()
libqdev.a/nfo_libvercmp()
libqdev.a/nfo_m68kcputype()
libqdev.a/nfo_modeidcount()
libqdev.a/nfo_scanlist()
libqdev.a/nfo_scanturbo()
libqdev.a/nfo_screencount()
libqdev.a/nfo_stackreport()
libqdev.a/nfo_stackvalid()
libqdev.a/nfo_typeofgfxmem()
libqdev.a/nfo_waitback()
libqdev.a/nfo_whichchipset()
libqdev.a/nfo_getargsource()
libqdev.a/nfo_freeargsource()
libqdev.a/ctl_clirun()
libqdev.a/ctl_makedir()
libqdev.a/ctl_getsmparams()
libqdev.a/mem_addrfrombase()
libqdev.a/mem_findinfile()
libqdev.a/mem_findinfileq()
libqdev.a/mem_lzwcompress()
libqdev.a/mem_lzwdecompress()
libqdev.a/mem_lzwfree()
libqdev.a/mem_scanfile()
libqdev.a/mem_scanlbl()
libqdev.a/mem_allocarray()
libqdev.a/mem_accessarray()
libqdev.a/mem_freearray()
libqdev.a/mem_alloccluster()
libqdev.a/mem_freecluster()
libqdev.a/mem_getmemcluster()
libqdev.a/mem_freememcluster()
libqdev.a/mem_copysmlcb()
libqdev.a/mem_freesmlcb()
libqdev.a/mem_readsrcimage()
libqdev.a/mem_freesrcimage()
libqdev.a/nfo_getsystime()
libqdev.a/nfo_scanml()
libqdev.a/txt_debugprintf()
libqdev.a/txt_strboth()
libqdev.a/txt_strpat()
libqdev.a/cnv_ALtoULONG()
libqdev.a/cnv_AtoULONG()
libqdev.a/cnv_ULONGtoA()
libqdev.a/cnv_ULONGtoBITS()
libqdev.a/ctl_relocdrimap()
libqdev.a/dev_sizeingigs()
libqdev.a/dos_bcopydevice()
libqdev.a/mem_addrfromlvo()
libqdev.a/mem_csumchs32()
libqdev.a/mem_csumeor32()
libqdev.a/mem_csumint32()
libqdev.a/mem_fnv128hash()
libqdev.a/mem_fnv64hash()
libqdev.a/mem_pjw64hash()
libqdev.a/nfo_isconsole()
libqdev.a/txt_psnprintf()
libqdev.a/nfo_ismode15khz()
libqdev.a/nfo_isprime()
libqdev.a/nfo_nearestprime()
libqdev.a/nfo_numdivisors()
libqdev.a/txt_bstrncat()
libqdev.a/txt_bstrnpcat()
libqdev.a/txt_strnvacat()
libqdev.a/txt_datdat()
libqdev.a/txt_fixquotes()
libqdev.a/txt_fnv128hash()
libqdev.a/txt_fnv64hash()
libqdev.a/txt_iniparse()
libqdev.a/txt_memcmp()
libqdev.a/txt_memfill()
libqdev.a/txt_needslash()
libqdev.a/txt_noansi()
libqdev.a/txt_nocomment()
libqdev.a/txt_parseline()
libqdev.a/txt_pjw64hash()
libqdev.a/txt_quickhash()
libqdev.a/txt_skipcc()
libqdev.a/txt_strchr()
libqdev.a/txt_strcmp()
libqdev.a/txt_strcspn()
libqdev.a/txt_stripansi()
libqdev.a/txt_strlen()
libqdev.a/txt_strncat()
libqdev.a/txt_strnpcat()
libqdev.a/txt_strspn()
libqdev.a/txt_strstr()
libqdev.a/txt_strtok()
libqdev.a/txt_tokenify()
libqdev.a/txt_vcbpsnprintf()
libqdev.a/txt_vpsnprintf()



 ----------------------------------------------------------------------------
                                 AMIGA - CRT_#?
 ----------------------------------------------------------------------------

   NAME

      crt_createargv() - Creates array of command line args.



   SYNOPSIS

      res = crt_createargv(cr, argc, argv);

      LONG crt_createargv(struct qcrtregs *, int *, char ***);



   FUNCTION

      This func. allows to parse the command line of current
      process and form an array of arguments. Result is pretty
      much like with standard C lib.



   INPUTS

      cr   - Special startup structure that contains saved/
             predefined CPU registers.

      argc - Pointer to argument count variable (&argc).

      argv - Pointer to argument array symbol (&argv).



   RETURNS

      Returns alloc address (to be treated like boolean) upon
      success or NULL on failure.



   BASES

      [SysBase]



   NOTES

      Use handy QDEV_QCRT_ARGV() macro for quick setup. There
      is no need to make a pointer from argc and argv.

      Current implementation distinguishes escaped quotes in
      three syntaxes. Amiga, where quotes are preceeded with
      an asterisk (*), normal synatx backslash (\) and older
      syntax single quote ('). No other chars are unescaped!



   SEE ALSO

      crt_exitmethod(), crt_newinstance(),
      crt_freeinstance(), crt_destroyargv()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CRT_#?
 ----------------------------------------------------------------------------

   NAME

      crt_destroyargv() - Frees array of command line args and
                          restores previous setup.



   SYNOPSIS

      crt_destroyargv(cr, argc, argv);

      LONG crt_destroyargv(struct qcrtregs *, int *, char ***);



   FUNCTION

      This func. frees the allocated memory and restores argc
      and argv to startup native values.



   INPUTS

      cr   - Special startup structure that contains saved/
             predefined CPU registers.

      argc - Pointer to argument count variable (&argc).

      argv - Pointer to argument array symbol (&argv).



   RETURNS

      No output.



   BASES

      [SysBase]



   NOTES

      Use handy QDEV_QCRT_ARGV() macro for quick setup. There
      is no need to make a pointer from argc and argv.



   SEE ALSO

      crt_exitmethod(), crt_newinstance(),
      crt_freeinstance(), crt_createargv()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CRT_#?
 ----------------------------------------------------------------------------

   NAME

      crt_initmethod() - Deals with creator's requirements.



   SYNOPSIS

      crt_initmethod(cr);

      void crt_initmethod(struct qcrtregs *);



   FUNCTION

      This routine is responsible for detecting what are
      the properties/penalties of current task or process.
      It does deal with the WB startup message and sets
      proper method in a flag variable of special startup
      structure. 



   INPUTS

      cr   - Special startup structure that contains saved/
             predefined CPU registers.



   RETURNS

      No output.



   BASES

      [SysBase]



   NOTES

      Use handy QDEV_QCRT_METHOD() macro for quick setup.
      It should always be used before QDEV_QCRT_NEW() !



   SEE ALSO

      crt_exitmethod(), crt_newinstance(),
      crt_freeinstance(), crt_createargv(),
      crt_destroyargv()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CRT_#?
 ----------------------------------------------------------------------------

   NAME

      crt_exitmethod() - Performs cleanup procedures prior
                         to environment.



   SYNOPSIS

      crt_exitmethod(cr);

      void crt_exitmethod(struct qcrtregs *);



   FUNCTION

      For now this func. just replies the message back to
      Workbench if program was started by it. 



   INPUTS

      cr   - Special startup structure that contains saved/
             predefined CPU registers.



   RETURNS

      No output.



   BASES

      [SysBase]



   NOTES

      Use handy QDEV_QCRT_METHOD() macro for quick setup.
      It should always be used before QDEV_QCRT_NEW() !



   SEE ALSO

      crt_initmethod(), crt_newinstance(),
      crt_freeinstance(), crt_createargv(),
      crt_destroyargv()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CRT_#?
 ----------------------------------------------------------------------------

   NAME

      crt_newinstance() - Copies and relocates data section.



   SYNOPSIS

      ok = crt_newinstance(cr);

      LONG crt_newinstance(struct qcrtregs *);



   FUNCTION

      This routine allows to copy and relocate data section
      in a (resident) binary that uses QCRT startup code.
      The need for relocation is determined automatically.



   INPUTS

      cr   - Special startup structure that contains saved/
             predefined CPU registers.



   RETURNS

      Returns new data region address or maximum value LONG
      can be if no relocation was necessary. NULL will be
      returned if there is not enough memory available.



   BASES

      [SysBase]



   NOTES

      Automatic A4 reloading can be suppressed by putting a
      flag QDEV_QCRT_F_NOA4 in 'cr_f'.



   SEE ALSO

      crt_freeinstance(), crt_initmethod(),
      crt_exitmethod(), crt_createargv(),
      crt_destroyargv()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CRT_#?
 ----------------------------------------------------------------------------

   NAME

      crt_freeinstance() - Frees relocated data section.



   SYNOPSIS

      crt_freeinstance(cr);

      void crt_freeinstance(struct qcrtregs *);



   FUNCTION

      This routine frees the copy of primary data section
      and restores A4 register to original state.



   INPUTS

      cr   - Special startup structure that contains saved/
             predefined CPU registers.



   RETURNS

      No output.



   BASES

      [SysBase]



   NOTES

      Automatic A4 reloading can be suppressed by putting a
      flag QDEV_QCRT_F_NOA4 in 'cr_f'.



   SEE ALSO

      crt_newinstance(), crt_initmethod(),
      crt_exitmethod(), crt_createargv(),
      crt_destroyargv()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_clipath() - Allows to manipulate CLI process paths.



   SYNOPSIS

      res = ctl_clipath(mode, path);

      LONG ctl_clipath(LONG, UBYTE *);



   FUNCTION

      This function allows to perform simple ops on CLI paths,
      such as: adding, removing, searching for or clearing.



   INPUTS

      mode - Type of op. See header file for more details.

      path - NULL terminated string/path.



   RETURNS

      Function may return either negative or positive value when
      it was successful or 0 if it wasnt.



   BASES

      SysBase, DOSBase



   NOTES

      When searching for a 'path' negative address to the path
      entry structure may be returned. It will be so if that is
      the first path on the list. Otherwise the address will be 
      positive, but you will not gain access to the exact entry
      but the previous one!!! See source code for more details.



   SEE ALSO

   EXAMPLE

      ...

      ctl_clipath(QDEV_CTL_CLIPATH_RESET, NULL);

      if ((ctl_clipath(QDEV_CTL_CLIPATH_ADD, "ram:")))
      {
        ...
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_devmount() - Allows to interpret mountlists.



   SYNOPSIS

      res = ctl_devmount(mlfile, mlpatt, range,
                               flags, cbdata, cbcode);

      LONG ctl_devmount(UBYTE *, UBYTE *, LONG,
        ULONG, void *, LONG (*)(struct nfo_sml_cb *));



   FUNCTION

      This function allows to perform various ops on
      mountlist entries using callback. Its purpose is
      to mount devices using 'dmt_mountcb()' callback
      but it can be used to do something else too.



   INPUTS

      mlfile - Mountlist filename.

      mlpatt - Device(handler) name. Standard AmigaOS
               patterns are allowed here. Presence or
               lack of colon(s) is fine.

      range  - Boundary check. See 'nfo_grepml()' for
               more details.

      flags  - Flags passed to the callback.

      cbdata - Private user data pointer.

      cbcode - Callback pointer.



   RETURNS

      See 'nfo_grepml()' for possible output.



   BASES

      SysBase, DOSBase, IconBase



   NOTES

      See  'nfo_grepml()'  for more details. Yes, this
      function wraps it.

      If  you  need output from under the callback per
      entry, then wrap  'dmt_mountcb()'. Var. 'cbdata'
      will be mapped to 'sc->sc_userdata'.

      Note! Even  erroneous/bogus  mountlist   entries
      will  be  passed  to the callback, so you really
      must  inspect  'sc->sc_gerror'  and decide what
      to do.

      Dont forget that you must copy 'sc' structure in
      the callback to retain its contents during scan.
      In other words if you want to write your own CB
      that mounts devices then you must make a copy of
      'sc' so it can live along with 'DeviceNode'.

      To copy 'sc' use 'mem_copysmlcb()', it will make
      sure that every member/pointer is long aligned.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_devunmount() - Allows to unmount dos handlers.



   SYNOPSIS

      res = ctl_devunmount(devpatt, flags, cbdata, cbcode);

      LONG ctl_devunmount(UBYTE *, ULONG,
                    void *, void (*)(struct ctl_umn_cb *));



   FUNCTION

      This func. allows to unmount handlers or filesystems.



   INPUTS

      devpatt - One or  more device name(s)(with or without
                colon). Standard patterns can be used.

      flags   - Control flags. Currently only two flags are
                being recognized:  QDEV_CTL_DMT_FKEEPGOING
                - this flag allows forcible unmounting, and
                QDEV_CTL_DMT_FSIGCALLER - set a signal trap
                so caller will eventually terminate on pkt.
                reply.

      cbdata  - User data.

      cbcode  - Callback function.



   RETURNS

      Number of devices successfully unmounted.



   BASES

      SysBase, DOSBase



   NOTES

      While forcible unmouting is not always the best thing
      to do it is generally considered relatively safe. You
      may be surprised by that, but it really is. This is
      because  'ctl_devunmount()'  shields running handlers
      from outside world by taking over their message ports
      and by bringing processes down in a piecewise way.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_diskreqoff() - Turns off disk requesters in current 
                         process.



   SYNOPSIS

      winptr = ctl_diskreqoff();

      APTR ctl_diskreqoff(void);



   FUNCTION

      This function will disable "disk replace" and such reqs
      in current process.



   INPUTS

      No input.



   RETURNS

      Returns pointer which user should store somewhere in
      case of restoration.



   BASES

      SysBase



   NOTES

      If a program in which 'ctl_diskreqoff()' was called will
      quit without latter call to 'ctl_diskreqon()' then that
      CLI will be requesterless!



   SEE ALSO

      ctl_diskreqon()



   EXAMPLE

      ...

      APTR winptr;

      winptr = ctl_diskreqoff();

      ctl_diskreqon(winptr);



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_diskreqon() - Turns on disk requesters in current
                        process.



   SYNOPSIS

      ctl_diskreqon(winptr);

      void ctl_diskreqon(APTR);



   FUNCTION

      This func. will restore previously disabled disk repl.
      requesters in current process.



   INPUTS

      winptr - Win. ptr as obtained with 'ctl_diskreqoff()'.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      It is wise to call 'ctl_diskreqon()' before leaving to CLI 
      if 'ctl_diskreqoff()' was called.



   SEE ALSO

      ctl_diskreqoff()



   EXAMPLE

      ...

      APTR winptr;

      winptr = ctldiskreqoff();

      ctl_diskreqon(winptr);



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_haltidcmp() - Stops IDCMP message/event broadcasts.



   SYNOPSIS

      ctl_haltidcmp(window);

      void ctl_haltidcmp(struct Window *);



   FUNCTION

      This funcc will strip all the messages pending and will
      deallocate message port from the window so further event
      handling is impossible.



   INPUTS

      window - Window pointer.



   RETURNS

      No output.



   BASES

      SysBase, IntuitionBase



   NOTES

      Use this function before closing your window to answer
      late and undesired events.

      If 'window->UserPort->mp_Node.ln_Type' is not NT_MSGPORT
      then no 'ModifyIDCMP()' will be called but UserPort will
      will be NULLed and all events set to 0.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_newshell() - Spawns new interactive shell process
                       and returns its address.



   SYNOPSIS

      pr = ctl_newshell(fd, from);

      struct Process *ctl_newshell(LONG, UBYTE *);



   FUNCTION

      This func. creates new interactive shell and returns
      its address.



   INPUTS

      fd   - FileHandle that will be used for input/output.

      from - Filename name of a script to be executed upon
             startup. Can be NULL.



   RETURNS

      Returns pointer to new shell proc or NULL on failure.



   BASES

      SysBase, DOSBase



   NOTES

      When you need to access 'pr' then arbitrate the call
      first with 'Forbid()' / 'Permit()' and never disable
      interrupts or this function will cause a deadlock!



   SEE ALSO

      ctl_clirun()



   EXAMPLE

      ...

      struct Process *pr;
      LONG fd;
      LONG num = -1;

      if ((fd = Open("CON:", MODE_OLDFILE)))
      {
        QDEV_HLP_NOSWITCH
        (
          if ((pr = ctl_newshell(fd, NULL)))
          {
            num = pr->pr_TaskNum;
          }
        );

        FPrintf(Output(), "NewShell at: %s\n", num);

        Close(fd);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_rearrangecon() - [Re]arrange consoles on the screen. 



   SYNOPSIS

      ctl_rearrangecon(cd, how);

      void ctl_rearrangecon(struct ctl_csn_data *, ULONG);



   FUNCTION

      This func. allows to make use of three more consoles as
      opened by 'ctl_openconscreen()'(if requested). For now
      there are three ways of arranging windows: horizontally,
      vertically and by tiling



   INPUTS

      cd  - Pointer to a screen shell.

      how - How to arrange consoles. See main header for more
            details.



   RETURNS

      No output.



   BASES

      IntuitionBase, MathIeeeXXXXBasBase



   NOTES

      ORing('|') values 1-32 while using QDEV_CTL_RECON_CROSS
      flag will adjust separator thickness.



   SEE ALSO

      ctl_zoomifycon(), ctl_openconscreen(),
      ctl_closeconscreen()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_relabel() - Allows to change the name of the volume.



   SYNOPSIS

      res = ctl_relabel(device, label);

      BOOL ctl_relabel(UBYTE *, UBYTE *);



   FUNCTION

      This function wraps 'Relabel()', so effecitively no disk
      replace requesters will popup on failure.



   INPUTS

      device - Device you are about to relabel(with ':').

      label  - New label for that device(without ':').



   RETURNS

      Returns boolean, TRUE for OK and FALSE for failure.



   BASES

      DOSBase



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_setclistack() - Allows to set new CLI stack size.



   SYNOPSIS

      oldstack = ctl_setclistack(stack);

      ULONG ctl_setclistack(ULONG);



   FUNCTION

      This function allows to set new stack size in for a CLI
      ('cli->cli_DefaultStack'). The stack size itself can
      range  from 2048 to 2097152 bytes. Value passed will be
      LONG aligned automatically.



   INPUTS

      stack - New stack size.



   RETURNS

      Old stack size will be returned, or 0 if new stack is out
      of range.



   BASES

      DOSBase



   NOTES

      You should generally remeber to restore old stack on exit. 
      Nothing bad will happend if you dont, but keep in mind
      that this new stack may/will affect other programs if
      that CLI didnt terminate.



   SEE ALSO

      None.



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_swapbackpen() - Allows to change background pen
                          in fullscreen console.



   SYNOPSIS

      ctl_swapbackpen(cd, pen);

      void ctl_swapbackpen(struct ctl_csn_data *, ULONG);



   FUNCTION

      This function alters background color in fullscreen
      console dialog.



   INPUTS

      cd  - Fullscreen console ptr -ctl_openconscreen() .

      pen - Pen number(0 - 255). Pen out of range will be
            clipped to last possible pen.



   RETURNS

      No output.



   BASES

      SysBase, GfxBase, LayersBase



   NOTES

      Before window-to-layer conversion no special func.
      was necessary to change background color, but area
      refreshes were hell slow.



   SEE ALSO

      ctl_openconscreen(), ctl_closeconscreen()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_udirassign() - Micro directory assigner/unassigner.



   SYNOPSIS

      res = ctl_udirassign(vpath, obj, flags);

      BOOL ctl_udirassign(UBYTE *, UBYTE *, ULONG);



   FUNCTION

      This function allows to quickly associate directories with
      virtual paths. It does nearly what 'Assign' shell command
      does.



   INPUTS

      vpath - Virtual path/node('mypath:'). Must include colon!

      obj   - Full path to directory to be referenced. Files are
              not allowed and will be discarded!

      flags - Op. type flags. See header file.



   RETURNS

      Func. may return TRUE if operation was successful or FALSE
      if something failed.



   BASES

      (SysBase), DOSBase



   NOTES

      This function behaves pretty much like 'Assign' command so
      if 'obj' is NULL then all the 'vpath' related entries get
      removed including 'vpath'.

      Removing or adding multiassign entries is possible thanks
      to 'flags'. Also,  late and path assigns are availale this
      way.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_addbartrigger() - Adds title bar trigger in top left
                            corner of the screen.



   SYNOPSIS

      trigbar = ctl_addbartrigger(cd);

      void *ctl_addbartrigger(struct ctl_csn_data *);



   FUNCTION

      This function allows user to toggle title bar of the con.
      screen. It installs one point window in top left corner
      which when clicked with the left mouse button toggles the
      title bar.



   INPUTS

      cd - Structure returned by the 'ctl_openconscreen()'.



   RETURNS

      Returns 'trigbar' data or NULL upon failure.



   BASES

      SysBase, (GfxBase), (IntuitionBase)



   NOTES

      This function no longer uses task exceptions directly!



   SEE ALSO

      ctl_rembartrigger(), ctl_pokebartrigger()



   EXAMPLE

      See the 'EXAMPLE' in 'ctl_openconscreen()' article.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_pokebartrigger() - Allows to toggle title bar from
                             under the program.



   SYNOPSIS

      state = ctl_pokebartrigger(ptr, win);

      LONG ctl_pokebartrigger(void *, struct Window *);



   FUNCTION

      This function does what user with mouse can do. It allows
      to toggle title bar without going through the exception
      handler.



   INPUTS

      ptr - Pointer as returned by 'ctl_addbartrigger()' func.

      win - Window(can be NULL) that will gain the focus after
            the toggle.



   RETURNS

      Returns current state of the screen title bar(0 - invisible
      or 1 - visible).



   BASES

      SysBase, (GfxBase), (IntuitionBase)



   NOTES

      None.



   SEE ALSO

      ctl_addbartrigger(), ctl_rembartrigger()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_rembartrigger() - Removes title bar trigger from top
                            left corner of the screen.



   SYNOPSIS

      ctl_addbartrigger(ptr);

      void ctl_rembartrigger(void *);



   FUNCTION

      This function removes title bar trigger as installed with
      'ctl_addbartrigger()'.



   INPUTS

      ptr - Trigger bar pointer.



   RETURNS

      No output.



   BASES

      SysBase, (GfxBase), (IntuitionBase)



   NOTES

      None.



   SEE ALSO

      ctl_addbartrigger(), ctl_pokebartrigger()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_addconlogo() - Adds logo to the fullscreen CLI.



   SYNOPSIS

      ptr = ctl_addconlogo(cc, bm, x, y);

      void *ctl_addconlogo(struct ctl_csn_cwin *,
                             struct BitMap *, UWORD, UWORD);



   FUNCTION

      This function allows to add logo(BitMap) in the upper-
      left corner of the fullscreen CLI.



   INPUTS

      cc - Pointer to desired window.

      bm - Standard BitMap structure.

      x  - Position in X axis.

      y  - Position in Y axis.



   RETURNS

      Returns pointer to the logo data or NULL if something
      went wrong.



   BASES

      SysBase, DOSBase, GfxBase, IntuitionBase



   NOTES

      You should call this function as soon as you open the
      CLI cus it will use console stream('cd_con') to rescale
      its UI area.

      You will have to take care of the palette if your pict.
      does not comply to ANSI colors. If you need full-auto
      setup then use 'guigfx.library' it will do its best for
      your picture too look best.

      Maximum space used for the logo in Y axis is determined
      with a fixed value! See source code for more details.

      This function uses private task exception mechanism,
      but addresses of the bitmaps with params and data can
      be put on stack.

      The easiest way to embed logo in your proggy is to use
      so famous 'PersonalPaint'(ver. 7). You then setup colors
      according to the fullscreen CLI palette, draw the logo,
      cut it and save as a brush using 'C Source' plugin. Then
      you include that file(its a header) in your program and
      pass it to the 'mem_convimgtobmap()' and you are done.
      Please note that 'gcc' does not understand 'chip' key.,
      so you will have to '#define chip'. Plus if you do not
      use patches like 'fblit' then you will have to
      'mem_copyitnimage()' into chip mem before doing conv. or
      else your picture will be trashy! This is not necessary
      if you use gfx board tho, but your code may not run too
      well anywhere else! See 'testsuite/conscreen-test.c' for
      more details.

      If you want to reserve the area only then make an empty
      BitMap with 'mem_initemptybmap()'.



   SEE ALSO

      ctl_remconlogo(), ctl_swapconlogo()



   EXAMPLE

      ...

      void *logo;
      struct ctl_csn_cwin *cc = <yourconsole>;
      struct BitMap *bm = <yourbitmap>;

      ...

        if ((logo = ctl_addconlogo(cc, bm, 0, 0)))
        {
          ...

          ctl_remconlogo(logo);
        }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_swapconlogo() - Swaps logo on the current handle.



   SYNOPSIS

      size = ctl_swapconlogo(ptr, bm, x, y);

      ULONG ctl_swapconlogo(void *, 
                                struct BitMap *, UWORD, UWORD);



   FUNCTION

      This function allows to swap logo(BitMap) that was added
      by the 'ctl_addconlogo()' and also change its position on
      the screen.



   INPUTS

      ptr - Logo handle as obtained with 'ctl_addconlogo()'.

      bm  - Standard BitMap structure.

      x   - Start point in X axis('bm' must be not NULL).

      y   - Start point in Y axis('bm' must be not NULL).



   RETURNS

      Outputs size of the area logo can be put to. The first 16
      bits is X and the second 16 bits is Y. This allows to use
      bitmaps that will be prepared during runtime and to cover
      whole available area if needed.



   BASES

      SysBase, DOSBase, GfxBase, IntuitionBase



   NOTES

      Swapping logo does not imply changing the effective area!
      For example, if primary logo is 40x40 and the logo to be
      put in place is 40x50 then it will be trimmed to 40!

      Starting points will be checked against the boundaries so
      you do not need to worry about that.

      If you want to animate and move that animation across the
      screen call 'WaitTOF()' after every rendered frame!

      Never freeze a task that executes this code or your Miggy
      will hang! This is due to 'Forbid()'/'Permit()' pair that
      is a must if older(V39 and below) 'console.device'...
      Note however that 'nfo_ktm()' allows to freeze such tasks
      without probs as it takes care of race conditions!



   SEE ALSO

      ctl_addconlogo(), ctl_remconlogo()



   EXAMPLE

      ...

      void *logo;
      ULONG size;
      UWORD x;
      UWORD y;

      /*
       * Obtaining total available logo space.
      */
      size = ctl_swapconlogo(logo, NULL, 0, 0);

      x = (size >> 16);

      y = (size & 0xFFFF);
      


   BUGS

      Although this bug was worked-around i decided to leave
      its description. Read on!

      It looks like 'XorRectRegion()' function does some wrong
      ops... If one rectangle is to intersect another with the
      shift in Y axis to the very top assuming previous and
      current coords,

                    +------+      +- - - +
      +------+      +- - - +              
      |      |      |      |      |      |
      |      | ---> | X-OR | --->         
      |      |      +------+      +------+ 
      +------+      +- - - +      +------+ <--- Not reflected!

      then the area left is not reflected in 'RectangleRegion'
      but everything seems to work when the shift occurrs to 
      the bottom!



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_remconlogo() - Removes logo from fullscreen CLI.



   SYNOPSIS

      ctl_remconlogo(ptr);

      void ctl_swapconlogo(void *);



   FUNCTION

      This function allows to strip logo(BitMap) that was added
      by the 'ctl_addconlogo()'.



   INPUTS

      ptr - Logo handle as obtained with 'ctl_addconlogo()'.



   RETURNS

      No output.



   BASES

      SysBase, DOSBase, GfxBase, IntuitionBase



   NOTES

      None.



   SEE ALSO

      ctl_addconlogo(), ctl_swapconlogo()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_addconlogof() - Adds logo from file to particular
                          console of the screen shell.



   SYNOPSIS

      logof = ctl_addconlogof(cc, file, x, y);

      void *ctl_addconlogof(struct ctl_csn_cwin *,
                                    UBYTE *, UWORD, UWORD);



   FUNCTION

      This function allows to load any(provided there is a
      datatype that supports it and the 'guigfx.library' is
      installed) picture or binary animation and place it in
      the upper-[left] corner of the console of the screen
      shell.



   INPUTS

      cc   - Screen shell window pointer.

      file - Picture filename.

      x    - X axis position.

      y    - Y axis position.



   RETURNS

      Returns logo handle or NULL if no success(no memory or
      file cannot be loaded).



   BASES

      SysBase, (DOSBase), (GfxBase), ([GuiGFXBase]),
      (IntuitionBase)



   NOTES

      This function will remap your picture or animation so
      it will possibly look good independently of the screen
      palette.



   SEE ALSO

      ctl_remconlogof(), ctl_setconlogof()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_remconlogof() - Removes logo loaded from file.



   SYNOPSIS

      ctl_remconlogof(ptr);

      void ctl_remconlogof(void *);



   FUNCTION

      This function removes the  logo as  installed with
      'ctl_addconlogof()'.



   INPUTS

      ptr - Logo handle.



   RETURNS

      No output.



   BASES

      SysBase, (DOSBase), (GfxBase), ([GuiGFXBase]),
      (IntuitionBase)



   NOTES

      None.



   SEE ALSO

      ctl_addconlogof(), ctl_setconlogof()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_setconlogof() - Allows to set parameters per logof.



   SYNOPSIS

      res = ctl_setconlogof(ptr, what, parm);

      LONG ctl_setconlogof(void *, LONG, LONG);



   FUNCTION

      This function lets one alter the parmeters of a logof.



   INPUTS

      ptr  - Logo handle.

      what - What shall be set/unset (QDEV_CTL_SETCONLF_#?).

      parm - Parameter value.



   RETURNS

      Returns state/value after setting or getting something.



   BASES

      SysBase



   NOTES

      Currently this function allows to set the animation pri.
      only. Use the (~) to unset (i.e. ~QDEV_CTL_SETCONLF_#?).

      In case of: QDEV_CTL_SETCONLF_ANIMLOW it does not take
      'parm' so it can be NULL.

      Changes take place immediately after calling this func!



   SEE ALSO

      ctl_addconlogof(), ctl_remconlogof()



   EXAMPLE

      ...

      void *logo;

      if ((logo = ctl_addconlogo(...)))
      {
        ctl_setconlogof(logo, QDEV_CTL_SETCONLF_ANIMPRI, -10);

        ...
      }

      ...



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_openconscreen() - Allows to open fullscreen con.
                            dialog.


   SYNOPSIS

      condata = ctl_openconscreen(cf);

      struct ctl_csn_data *ctl_openconscreen(
                                     struct ctl_csn_feed *);



   FUNCTION

      This function allows to open fullscreen console dialog.
      


   INPUTS

      cf - Feed structure, that is desc. in the header file.



   RETURNS

      Returns pointer to console struct. or NULL on failure.



   BASES

      SysBase, DOSBase, GfxBase, IntuitionBase,
      [DiskfontBase], MathIeeeXXXXBasBase



   NOTES

      If the feed structure is filled with zeroes then this 
      function should be still successful!

      Tolerated errors will be reflected in 'cf' and/or 'cd'.
      Rejected fields will be NULL.

      Important! Never pass 'cd->cd_cc[x].cc_con' directly
      anywhere, you must duplicate it first! The easiest way
      to do this is to call 'ctl_doconswitch()'.

      Locking pens who exceed curr. palette is safe, it will
      simply have no effect.

      This function allows upto 4 consoles to be opened per
      screen.

      This function will initialize IDCMP that  can only  be
      used through indexed handlers(see structures)! Never
      call 'ModifyIDCMP(cd->cd_cc[x].cc_mainwin, 0)'! There
      are special functions to control events.



   SEE ALSO

      ctl_closeconscreen(), ctl_addidcmphandler(),
      ctl_remidcmphandler(), ctl_swapbackpen()



   EXAMPLE

      ...

      struct Screen *screen;
      struct ctl_csn_feed cf;
      struct ctl_csn_data *cd;
      struct ctl_csh_data csh = {0, 0, 0};
      struct ColorSpec colors[] = {
      /*
       * ANSI colors.
      */
                                   { 0, 0x0, 0x0, 0x0}, 
                                   { 1, 0xE, 0x0, 0x0},
                                   { 2, 0x0, 0xE, 0x0},
                                   { 3, 0xE, 0xE, 0x0},
                                   { 4, 0x0, 0x0, 0xE},
                                   { 5, 0xE, 0x0, 0xE},
                                   { 6, 0x0, 0xE, 0xE},
                                   { 7, 0xE, 0xE, 0xE},
      /*
       * Workbench alike colors(moved).
      */
                                   { 8, 0xA, 0xA, 0xA},
                                   { 9, 0x0, 0x0, 0x0},
                                   {10, 0xF, 0xF, 0xF},
                                   {11, 0x8, 0x6, 0xE},
      /*
       * Table terminator.
      */
                                   {-1,   0,   0,   0}};
      /*
       * Default pen mappings(4+ bit screen is necessary
       * for correct on screen layout).
      */
      UWORD defdrimap[] = {8, 9, 9, 10, 9, 11, 10, 
                                   8, 10, 9, 10, 9, ~0};
      QDEV_NFO_DRIMAPTYPEI(drimap);
      void *bartrig;

      memset(&cf, 0 , sizeof(struct ctl_csn_feed);

      cf.cf_handler = "KCON://///JUMP";

      cf.cf_depth = 4;

      cf.cf_cs = colors;

      /*
       * Protect the palette in a depth independent manner.
       * Lock first 12 and last 4 pens.
      */
      cf.cf_lfirst = 12;

      cf.cf_llast = 4;

      /*
       * Try to obtain pen mappings from Workbench.
      */
      if (((screen = ctl_lockscreensafe(NULL))) &&
            (nfo_getdrimap(drimap, screen)))
      {
        /*
         * Relocate them to fit moved palette. Colors start
         * at pen number 8 and the default pen mappings are
         * generally using first 4 pens.
        */
        ctl_relocdrimap(drimap, 8, cf.cf_depth);

        cf.cf_drimap = drimap;

        ctl_unlockscreensafe(screen);
      }
      else
      {
        cf.cf_drimap = defdrimap;
      }

      if ((cd = ctl_openconscreen(&cf)))
      {
        if ((bartrig = ctl_addbartrigger(cd)))
        {
          ctl_doconswitch(&csh, cd->cd_cc[0].cc_con);

          if (cf.cf_handler == NULL)
          {
            FPrintf(cd->cd_con, "Warning, using the 'CON:'!\n");
          }

          Execute("", csh->ct_mewcon, NULL);

          ctl_undoconswitch(&csh);

          ctl_rembartrigger(bartrig);
        }

        ctl_closeconscreen(cd);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_closeconscreen() - Closes fullscreen console dialog.



   SYNOPSIS

      ctl_closeconscreen(cd);

      void ctl_closeconscreen(struct ctl_csn_data *cd);



   FUNCTION

      This function allows to close fullscreen console dialog.
      


   INPUTS

      cd - Data structure as returned by 'ctl_openconscreen()'.



   RETURNS

      No output.



   BASES

      SysBase, DOSBase, DiskfontBase, GfxBase, IntuitionBase



   NOTES

      Make sure that all the add-ons are deallocated first!

      This function will block if there are some visitors from
      the outside! All windows must be closed for it to resume.



   SEE ALSO

      ctl_openconscreen(), ctl_addidcmphandler(),
      ctl_remidcmphandler(), ctl_swapbackpen()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_doconswitch() - Make freshly obtained console 
                          the default in a process.



   SYNOPSIS

      ctl_doconswitch(ct, fd);

      void ctl_doconswitch(struct ctl_csh_data *, LONG);



   FUNCTION

      This function clones and attaches given console file
      desc. to the process and makes it default for it.



   INPUTS

      ct - Switch structure.

      fd - File descriptor.



   RETURNS

      No output.



   BASES

      SysBase, DOSBase



   NOTES

      Always remember to restore original file descriptor 
      if you are going to quit the process!

      It is possible to cascadify switches, but you have
      to remeber the order they were applied in!

      Important! Only output handles are being set here, so
      'Input()' still points at primary console!

      Important! Only this function is able to properly
      clone 'fdrelay' handles!!!

      It is safe to call this function any number of times.



   SEE ALSO

      ctl_undoconswitch()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_undoconswitch() - Undo the default console fd
                            selection.



   SYNOPSIS

      ctl_undoconswitch(ct);

      void ctl_undoconswitch(struct ctl_csh_data *);



   FUNCTION

      This function restores original console in a process.



   INPUTS

      ct - Switch structure.



   RETURNS

      No output.



   BASES

      SysBase, DOSBase



   NOTES

      It is safe to call this function any number of times.



   SEE ALSO

      ctl_doconswitch()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_addidcmphandler() - Attaches your IDCMP related code to
                              particular 'cc' window.



   SYNOPSIS

      ctl_addidcmphandler(cc, ci);

      __interrupt void ctl_addidcmphandler(
                   struct ctl_csn_cwin *, struct ctl_csn_ient *);



   FUNCTION

      This function allows to attach your IDCMP_#? event to the
      particular fullscreen console window.



   INPUTS

      cc    - Pointer to one of the windows as intialised by the
              'ctl_openconscreen()'.

      ci    - Structure that carries code and data pointers. You
              must really allocate memory for data since private
              task exceptions are rather stack hungry!



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      Although this routine does not return anything it will fail
      if 'ci' node area is not NULL initially and lh members are
      NULL. This protects from Guru on multiple calls.

      If you did overlook the ient structure then you know that
      it carries the exact number of nodes as there is windows.
      This allows to use single structure to attach the very same
      code to all windows if necessary. General rule is: One node
      == one event.

      Important! Member 'cc_imsg' contains current Intuition msg.
      but do not 'ReplyMsg()' to it! This will be done by the
      master handler code.

      Note! Your code will be called in a private task exception.
      This means that the only safe way to call most of the OS
      functions is to 'CreateTask()' first. Functions considered
      interrupt-safe are OK here tho, but 'Wait()' is not one of
      them ;-) . And one more thing, always add the '__interrupt'
      attribute before CB body!

      This function automatically enables the event as found in
      'ci_idcmpev'!

      Member 'cc_numwin' is used to select 'ient' node. Its very
      important for this value to be sane.

      ORing('|')  QDEV_CTL_LFLPRIV_HEAD against 'cc_lflags' makes
      it possible to install event handler before existing ones.



   SEE ALSO

      ctl_remidcmphandler(), ctl_openconscreen(),
      ctl_closeconscreen()



   EXAMPLE

      __interrupt void myhandler(
                           struct ctl_csn_cwin *cc, void *mydata)
      {
        /*
         * Do something when window becomes active.
        */
      }

      ...

      struct ctl_csn_data *cd = <init screen>;
      struct ctl_csn_ient *ci;

      if ((ci = AllocVec(
          sizeof(struct ctl_csn_ient), MEMF_PUBLIC | MEF_CLEAR)))
      {
        ci->ci_idcmpev = IDCMP_ACTIVEWINDOW;

        ci->ci_idcmpcode = myhandler;

        ci->ci_idcmpdata = NULL;

        ctl_addidcmphandler(&cd->cd_cc[0], ci);

        ctl_addidcmphandler(&cd->cd_cc[1], ci);

        ...

        ctl_remidcmphandler(&cd->cd_cc[1], ci);

        ctl_remidcmphandler(&cd->cd_cc[0], ci);

        FreeVec(ci);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_remidcmphandler() - Removes custom IDCMP handler from
                              'cc' window.



   SYNOPSIS

      ctl_remidcmphandler(cc, ci);

      __interrupt void ctl_remidcmphandler(
                 struct ctl_csn_cwin *, struct ctl_csn_ient *);



   FUNCTION

      This function detaches your IDCMP_#? event from where it
      was attached.



   INPUTS

      cc    - Pointer to one of the windows as intialised by the
              'ctl_openconscreen()'.

      ci    - Structure that carries code and/or data pointers.
              Make sure that this node is attached first before
              removing!



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      This routine is dangerous to use when  'ic' was not added
      to the list first!

      This routine automatically disables the event as found in
      'ci_idcmpev' if list is empty after removing handler.



   SEE ALSO

      ctl_addidcmphandler(), ctl_openconscreen(),
      ctl_closeconscreen()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_findscreensafe() - Try to find the screen in the
                             OS without probing(opening) it.



   SYNOPSIS

      res = ctl_findscreensafe(pubname, buf, len);

      LONG ctl_findscreensafe(UBYTE *, UBYTE *, LONG);



   FUNCTION

      This function is similar to 'ctl_lockscreensafe()' in
      that it will not trigger screen opening. All it does
      is to find the screen and copy its name to the buffer
      provided.



   INPUTS

      pubname - Pub. screen name(not a title!). NULL for
                'Workbench'. Use '*' to obtain a name of
                current/active screen. Case sensitive!

      buf     - Buffer to store the screen name. This can
                be NULL if just an indication is needed.

      len     - Buffer size. If 0 then plain indication.



   RETURNS

      Returns negative value if buffer is too small to hold
      the entire name, -1 if no buffer was provided, 0 if
      screen was not found and 1 for success.



   BASES

      IntuitionBase



   NOTES

      None.



   SEE ALSO

      ctl_lockscreensafe(), ctl_unlockscreensafe()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_lockscreensafe() - Try to lock the screen without
                             explicitly opening it.



   SYNOPSIS

      screen = ctl_lockscreensafe(pubname);

      struct Screen *ctl_lockscreensafe(UBYTE *);



   FUNCTION

      This function wraps 'LockPubScreen()'. It will check
      if the screen is present in the system before locking
      it, so effectively screen wont pop up.



   INPUTS

      pubname - Public screen name(not a title!). NULL for
                'Workbench'. Asterisk('*') for current one.
                Name is case sensitive!



   RETURNS

      Returns pointer to the screen or NULL if it could not
      be locked, cus it is not present.



   BASES

      IntuitionBase



   NOTES

      None.



   SEE ALSO

      ctl_unlockscreensafe(), ctl_findscreensafe()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_unlockscreensafe() - Try to unlock the screen.



   SYNOPSIS

      ctl_unlockscreensafe(screen);

      void ctl_unlockscreensafe(struct Screen *);



   FUNCTION

      This function wraps 'UnlockPubScreen()'.



   INPUTS

      screen - Screen to be unlocked.



   RETURNS

      No output.



   BASES

      IntuitionBase



   NOTES

      None.



   SEE ALSO

      ctl_lockscreensafe(), ctl_findscreensafe()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_addviewctrl() - Adds view control to the screen
                          shell.



   SYNOPSIS

      vctrl = ctl_addviewctrl(cd, fct);

      void *ctl_addviewctrl(struct ctl_csn_data *, ULONG);



   FUNCTION

      This function adds view control capability to the
      screen shell which allows to rearrange and zoom
      windows with the keyboard.



   INPUTS

      cd  - Screen shell pointer.

      fct - Zoom factor(step in %).



   RETURNS

      Returns ptr to the control block or NULL on error.



   BASES

      SysBase, GfxBase, LayersBase, IntuitionBase



   NOTES

      Using this func. makes sense with 2 or more windows!

      To control the view slide mouse pointer to the right
      bottom corner of the active window. OSD will show up.
      Now you can use numeric keypad(comfy) or equiv. keys
      on regular kb. Keys currently bound are as follows:

         '+' - Increase the size of the current window.

         '-' - Decrease the size of the current window.

         '/' - Change the arrangement of windows.

         '*' - Reset the arrangement size.

         '.' - Toggle window separator.

         '\r'- Quit setup(the return key).

      Sliding back to location that activated OSD will also
      quit setup.



   SEE ALSO

      ctl_remviewctrl()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_remviewctrl() - Removes view control from
                          screen shell.



   SYNOPSIS

      ctl_remviewctrl(ptr);

      void ctl_remviewctrl(void *);



   FUNCTION

      This function removes view control as added with
      'ctl_addviewctrl()'.



   INPUTS

      ptr - Control block pointer.



   RETURNS

      No output.



   BASES

      SysBase, GfxBase, LayersBase, IntuitionBase



   NOTES

      None.



   SEE ALSO

      ctl_addviewctrl()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_zoomifycon() - Zoom particular console on the
                         screen shell screen. 



   SYNOPSIS

      res = ctl_zoomifycon(cc, fct);

      LONG ctl_zoomifycon(struct ctl_csn_cwin *, LONG);



   FUNCTION

      This function allows to zoom or tele given console
      window in such a way that the rest of the windows do
      the opposite op.



   INPUTS

      cc  - Window to be zoomed.

      fct - Zoom factor in percents(-100 to 100).



   RETURNS

      Returns negative or positive value if the operation
      was successful or 0 if nothing was done.



   BASES

      IntuitionBase, MathIeeeXXXXBasBase



   NOTES

      This func. will have the effect on 2+ window screen
      shell plus 'ctl_rearrangecon()' must be used first!

      Var. 'fct' is not relative to current window size,
      but to a screen size!



   SEE ALSO

      ctl_rearrangecon(), ctl_openconscreen(),
      ctl_closeconscreen()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_setsmparams() - Allows to set modeid and/or depth
                          in 'screenmode.prefs' file.



   SYNOPSIS

      res = ctl_setsmparams(filename, modeid, depth);

      BOOL ctl_setsmparams(UBYTE *, ULONG *, UWORD *);



   FUNCTION

      This function allows to manipulate modeid and/or depth
      in OS file that is used to define display properties.



   INPUTS

      filename - NULL terminated string holding filename.

      modeid   - Address of ULONG container that defines some
                 value or NULL if data is not to be set.

      depth    - Address of UWORD container that defines some
                 value or NULL if data is not to be set.



   RETURNS

      Returns TRUE upon success or FALSE if operation couldnt
      be completed.



   BASES

      SysBase, DOSBase



   NOTES

      Passing NULL to 'modeid' and 'depth' at the same time
      is considered no-op.

      If file to be modified does not exist then it will be
      created.



   SEE ALSO

      ctl_getsmparams(), nfo_getscparams()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DEV_#?
 ----------------------------------------------------------------------------

   NAME

      dev_getdiskcmdset() - Get info about available command
                            sets that are supported by this
                            device.



   SYNOPSIS

      cmdset = dev_getdiskcmdset(dd);

      LONG dev_getdiskcmdset(struct dev_ddv_data *);



   FUNCTION

      This function obtains information about supported cmd
      sets(Native/NSD64/TD64).



   INPUTS

      dd - 'struct dev_ddv_data' as obtained with open func.



   RETURNS

      Returns OR'ed('|') flags. See header file.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      nfo_isdev64bit()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DEV_#?
 ----------------------------------------------------------------------------

   NAME

      dev_opendiskdev() - Allows to open 'exec'-style disk
                          device.



   SYNOPSIS

      dd = dev_opendiskdev(device, unit, flags);

      struct dev_ddv_data *dev_opendiskdev(
                           UBYTE *, LONG, LONG);



   FUNCTION

      This function allows to open disk dev. in comfortable
      manner.



   INPUTS

      device - AmigaOS device name, with ".device" suffix.

      unit   - Unit number of that device.

      flags  - Device specific flags.



   RETURNS

      Returns pointer to 'struct dev_ddv_data' in which all
      usual stuff sits.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      dev_closediskdev()



   EXAMPLE

      See source code of 'a-nfo_isdev64bit.c' on how to use.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DEV_#?
 ----------------------------------------------------------------------------

   NAME

      dev_closediskdev() - Allows to close 'exec'-style disk
                           device.



   SYNOPSIS

      dev_closediskdev(dd);

      void dev_opendiskdev(struct dev_ddv_data *);



   FUNCTION

      This function allows to close disk dev. in comfortable
      manner.



   INPUTS

      dd - 'struct dev_ddv_data' as obtained with open func.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      dev_opendiskdev()



   EXAMPLE

      See source code of 'a-nfo_isdev64bit.c' on how to use.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DEV_#?
 ----------------------------------------------------------------------------

   NAME

      dev_getdiskgeo() - Obtains Drive Geometry form device
                         driver.



   SYNOPSIS

      dg = dev_getdiskgeo(dd);

      void *dev_getdiskgeo(struct dev_ddv_data *);



   FUNCTION

      This function tries to obtain hardcoded device defaults.
      These are Drive Geometry params. They are useful when 
      the device does not support RDB and you want to get some
      basic info.



   INPUTS

      dd - Disk device structure.



   RETURNS

      Returns 'void' pointer that can be then attched to the
      'DriveGeometry' structure.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      dev_freediskgeo()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DEV_#?
 ----------------------------------------------------------------------------

   NAME

      dev_freediskgeo() - Free Drive Geometry memory.



   SYNOPSIS

      dev_freediskgeo(dg);

      void dev_getdiskgeo(void *);



   FUNCTION

      This function frees the memory block as used to store
      Drive Geometry params.



   INPUTS

      dg - Pointer as obtained with 'dev_getdiskgeo()'.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      dev_getdiskgeo()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DEV_#?
 ----------------------------------------------------------------------------

   NAME

      dev_getdiskrdb() - Obtains RDB from media.



   SYNOPSIS

      rdb = dev_getdiskrdb(dd);

      void *dev_getdiskrdb(struct dev_ddv_data *);



   FUNCTION

      This function allows to obtain Rigid Disk Block from 
      media that has it.



   INPUTS

      dd - Disk device structure.



   RETURNS

      Returns 'void' pointer that can be then attached to 
      'RigidDiskBlock' structure or NULL for no RDB.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      dev_freediskrdb()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DEV_#?
 ----------------------------------------------------------------------------

   NAME

      dev_freediskrdb() - Frees RDB memory allocation.



   SYNOPSIS

      dev_freediskrdb(rdb);

      void dev_getdiskrdb(void *);



   FUNCTION

      This function frees memory block as used to store
      RDB.



   INPUTS

      rdb - Pointer to block of memory as obtained with
      'dev_getdiskrdb()'.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      dev_getdiskrdb()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DMT_#?
 ----------------------------------------------------------------------------

   NAME

      dmt_mountcb() - Complete handler/filesystem installation
                      callback.



   SYNOPSIS

      res = dmt_mountcb(sc);

      LONG dmt_mountcb(struct nfo_sml_cb *);



   FUNCTION

      This function when used with  'ctl_devmount()' allows to
      mimic system 'Mount' command.



   INPUTS

      sc  - Standard 'nfo_scanml()' callback data.



   RETURNS

      See 'nfo_scanml()' for more details.



   BASES

      SysBase, DOSBase



   NOTES

      This func. does not output anything, it only sets error
      code in 'sc->sc_gerror'.

      This func. does copy the callback structure internally!

      Warning! If your intention is to use this routine stand
      alone then please look at the priv. struct nfo_int_data
      for minimal buffer requirements, struct nfo_sml_cb ptrs
      shall reflect!

      Especially 'sc_sd.sd_dosdevice' & 'sc.sc_sd.sd_handler'
      members cannot point at constants! Always provide at
      least QDEV_NFO_PRV_NAMELEN buffer!



   SEE ALSO

      ctl_devmount(), nfo_grepml(), nfo_scanml()



   EXAMPLE

      See 'fsmount' program in 'tools/' directory for typical
      usage.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_addfdrelay() - Starts up file descriptor relay as
                         a DOS device.



   SYNOPSIS

      res = dos_addfdrelay(name, termsig);

      BOOL dos_addfdrelay(UBYTE *, ULONG);



   FUNCTION

      This function is a subsystem that allows to relay data
      to n other file descriptors using just one call to the
      write routine.



   INPUTS

      name    - NULL terminated DOS device name. Name can be
                suffixized with colon(':'), but that is not
                necessary.

      termsig - Device termination signal. NULL if you dont
                wish for it to be terminable.



   RETURNS

      Returns TRUE if device was up and running, or FALSE if
      it didnt init properly.



   BASES

      SysBase, DOSBase



   NOTES

      If you decide to spawn this device in sepearate process
      from under your code space then make sure every fd you
      attach does not emit termination signal back to you! It
      is just unwise to quit in such case.

      Do 'ctl_doconswitch()' on a fd of a channel you want to
      be the default in order to use 'Output()' and 'CONSOLE:'
      (requires setting default flag on the channel too).

      Standard 'ReadArgs()' cmd line opts are as follows:
      "CN=CHANNAME,CP=CHANPASS/K,CD=CHANDEF/K,TF=TERMFILES/K,
      CE=CHANPIPE/K,CH=CHANPATH/K,NE=NOEOFGEN/K,DF=DESTFILE/K,
      RF=REMFILE/K,CF=CLOSEFILE/K,BF=BUFFILE/K,SA=STRIPANSI/K,
      TS=TERMSIG/K,LF=LINEFMT/K,RB=ROLLBUF/K,FR=FLUSHREQ/K" .


      CN=CHANNAME   - Channel name. Channel creation is easy,
                      if there is no such channel then it will
                      be created.

      CP=CHANPASS   - Channel password. To protect your chan.
                      with a password type it either: +<pwd>
                      or <pwd>, to deactivate use -<pwd>.

      CD=CHANDEF    - Should the channel requested right now
                      be the default? Argument is boolean.

      TF=TERMFILES  - Close down/terminate all files on this
                      channel if last client disconnects. In
                      case of files who are VCRs, delays will
                      be computed from scratch!

      CE=CHANPIPE   - Using this will allow channel to be
                      used as an ordinary pipe, which will
                      disallow any other options below! This
                      argument takes size. 0 = No pipe. Pipe
                      created with the help of this option is
                      synchronous, however it does some nice
                      tricks to avoid blocking!

      CH=CHANPATH   - With this 3 state switch you can turn
                      the channel into router(or path finder)
                      which will allow automatic channel
                      discovery per process when combined
                      with 'CD=CHANDEF' and "CONSOLE:". All
                      possible states are: 0 - dont act as
                      a router, 1 - seek in pipes, 2 - seek
                      in relays.

      NE=NOEOFGEN   - Dont generate EOF when in pipe mode.
                      This will be set per file descriptor!

      DF=DESTFILE   - Where to relay your data? Argument can
                      be ordinary file name, that must exist,
                      or the address of file descriptor. Note
                      that passing addresses that you dont
                      own is very bad idea. Also, there is a
                      protection that prevents random numbers
                      from being treated as functional f. d.

      RF=REMFILE    - Remove this file from channel. Argument
                      is boolean.

      CF=CLOSEFILE  - Should file attached to the channel be
                      automatically closed when it is removed
                      or whole relay goes down? This argument
                      is boolean.

      BF=BUFFILE    - Should buffering be used for this file
                      descriptor? Upto 1.48 argument was bool.
                      Now it is (0/1/2) where 2 activates the
                      data flush after each write. Note that
                      setting buffering is actually one time
                      operation and only before using FH. This
                      is because OS changes it internally
                      after first 'FWrite()'. Then this switch
                      has no effect and file stays buffered!

      SA=STRIPANSI  - Should ANSI escape codes be removed on
                      this file descriptor? Note that escape
                      code stripping works a bit different for
                      virtual files(ANSI is collected and can
                      be stripped when reading data!). This
                      argument is boolean(0 or 1). Aside that
                      options 2 and 3 will allow CSI query
                      and VCR mode respectively.

      TS=TERMSIG    - Should signal be sent to the owner if
                      this file  descriptor is being removed
                      or whole relay goes down? Argument is
                      number in one of four numeral systems.
                      0 means no signal. Also, signal will be
                      sent only when auto closing the file is
                      off!

      LF=LINEFMT    - Should every new line be prefixed with
                      some header? This argument accepts text
                      which can contain various format opts.
                      Format options begin with '%' character
                      and are:

                      'A' - Address of the owner of this file
                            descriptor.

                      'a' - Address of this file descriptor.

                      'C' - Total channel count in the proc.

                      'c' - Number of clients using this chan.

                      'd' - Device name of this process.

                      'f' - F. descriptor count on this chan.

                      'g' - Will this channel terminate all
                            the files after last client is
                            gone?

                      'h' - Will this f. descriptor pass the
                            ANSI through?

                      'i' - Will this file descriptor prebuf.
                            the data?

                      'j' - Will this f. descriptor be closed
                            automatically?

                      'k' - Is this channel the default one?

                      'L' - Is this channel password prot.?

                      'l' - Line format buffer for this chan.

                      'N' - This file descriptor name.

                      'n' - Current channel name.

                      'r' - Num. of failed relay attempts on
                            this file desc.

                      'S' - Address of the client that curr.
                            sends something.

                      's' - Signal to be sent to the owner of
                            this file desc.

                      'T' - Amount of time this chan. exists.

                      't' - Current system time.

                      'W' - Number of all file descriptors in
                            the process.

                      'w' - Number of all clients in the proc.

                      'x' - Number of direct requests needed 
                            to flush dead chans.

                      'y' - Number of reqs left to flush dead
                            channels.

                      'z' - Number of flushed channels.

      RB=ROLLBUF    - Should this channel have rollover buf?
                      Rollover buffer is virtual file that is
                      able to collect what was written to the
                      channel with the ability to wrap if end
                      of file is reached. Argument is size of
                      that virtual file. 0 means no file.

      FR=FLUSHREQ   - After how many direct requests unused
                      channels should be removed? 0 means no
                      channel removal.

      To obtain relay statistics, 'Open()' your relay and do
      the 'FGets()' until EOF with minimum 256 bytes buffer .
      The easiest way to see the stats is to use 'type' from
      shell.

      If you have virtual file attached to your chan. and you
      want to access it, then also 'Open()' your relay on the
      requested channel and do the 'Read()' or 'FGets()'. You
      dont have to worry about the cursor as writing uses
      different variable. Also you cant 'Seek()' in v. file
      because it is rollover!

      Note that if you use 'termsig' then consoles opened
      from under the relay may/will rebroadcast signals back
      to relay and if there is no clients it may eventually
      go down!

      Maximum number of rollover files(one per chan.) is 16!
      This is because virtual files use 'AllocSignal()', and
      there is only 16 signals available per process!

      Important! File handles as obtained with 'Open()' dont
      reference public message port, but a private one that
      is strictly associated with the given FH! The only way
      to clone the FH is to pass it to the 'ctl_doconswitch()'
      function.

      Warning! File buffering in kickstarts V39.xxx and less
      is a bit different than that in V40.xxx thus buffered
      relay files may receive the data at literally different
      times! This may be a problem if you map local virtual
      files, write to them through FDR and expect data to be
      in the buffer immediately. You will have to turn off
      the buffering in FDR for such files while putting them
      on the channel to be on the safe side! Additionally use
      argument BF 2 for buffered files (1.49 feature) .



   SEE ALSO

      dos_remfdrelay(), dos_ctrlfdrelay()



   EXAMPLE

      See 'fdrelay-test.c' for more details.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_ctrlfdrelay() - Allows to control File Descriptor
                          Relay.



   SYNOPSIS

      res = dos_ctrlfdrelay(dev, chan, pass,
                                          flags, file, arg);

      LONG dos_ctrlfdrelay(UBYTE *, UBYTE *, UBYTE *,
                                       ULONG, ULONG, ULONG);



   FUNCTION

      This function allows to control 'dos_addfdrelay()' on
      a C level.



   INPUTS

      dev   - Amiga DOS device name(including colon(':')).

      chan  - Optional channel to concatenate if it was not
              specified in 'dev'.

      pass  - Optional password. Set to NULL if no password.
              The syntax is: "<password>" == "+<password>",
              and to unset "-<password>".

      flags - Ctrl flags. They are described in the header.

      file  - NULL term. string or an address. Depending on
              the flag.

      arg   - Additional argument that depends on the flag.



   RETURNS

      Returns 1 or an address to the f. descriptor(depending
      on the flag) 0 on failure.



   BASES

      DOSBase



   NOTES

      Warning! Flags that translate to 'BF' argument that is:
      QDEV_DOS_FDR_NOFILEBUFFER, QDEV_DOS_FDR_FILEBUFFER  and
      QDEV_DOS_FDR_WRITEFLUSH are mutually exclusive!



   SEE ALSO

      dos_addfdrelay(), dos_remfdrelay()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_dopacket() - Sends DOS pkt to a given msg. port.



   SYNOPSIS

      res = dos_dopacket(mpi, action,
                            arg1, arg2, arg3, arg4, arg5);

      LONG dos_dopacket(struct MsgPort *, LONG,
                            LONG, LONG, LONG, LONG, LONG);



   FUNCTION

      This function sends a DOS packet and awaits reply.



   INPUTS

      mpi    - MsgPort to which packet will be put.

      action - Standard action number.

      arg1   - Packet argument.

      arg2   - Packet argument.

      arg3   - Packet argument.

      arg4   - Packet argument.

      arg5   - Packet argument.



   RETURNS

      Returns 'dp_Res1'. This function cannot fail itself.



   BASES

      SysBase



   NOTES

      This  func. tries to mimic 'DoPkt()', but there are
      some differences. First of 'dp_Res2' cannot be read
      with 'IoErr()' plus it is not being put in register
      D1!

      This func. can be called safely from under the task!



   SEE ALSO

      dos_replypacket(), dos_waitpacket()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_getpacket() - Retrieves DOS packet from message
                        port.



   SYNOPSIS


      dp = dos_getpacket(mp);

      struct DosPacket *dos_getpacket(struct MsgPort *);



   FUNCTION

      This function allows to retrieve one DosPacket from
      MsgPort at a time. Message gets removed from MsgPort
      on return.




   INPUTS

      mp      - MsgPort at which packets are to arrive.



   RETURNS

      Returns pointer to DosPacket or  NULL if no message
      was delivered/on the list.



   BASES

      SysBase



   NOTES

      This func. does not check if MsgPort collects valid
      DosPackets. It is upto you to confirm this.

      Description of this function was missing in 1.0 rel.



   SEE ALSO

      dos_waitpacket()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_qflink() - Links  ordinary f. d. with 'qfile'.



   SYNOPSIS

      qf = dos_qflink(fd);

      struct qfile *dos_qflink(BPTR);



   FUNCTION

      This function allows to turn already opened file
      descriptor into 'qfile' descriptor.



   INPUTS

      fd - Normal file desc. as obtained with 'Open()'.



   RETURNS

      Returns special file descriptor pointer or NULL if
      memory or message port allocation failed.



   BASES

      SysBase, DOSBase



   NOTES

      Func. does 'AllocSignal()' thru 'CreateMsgPort()'!

      Once the 'fd' is linked you should not be touching
      it or  using directly! Same  applies to 'Close()',
      do not call it! Use the 'dos_qfclose()' instead.



   SEE ALSO

      dos_qfopen(), dos_qfclose(), dos_qfwait(),
      dos_qfispending(), dos_qfsetmode(),
      dos_qfsetintsig(), dos_qfsetintsig(),
      dos_qfread(), dos_qfwrite(), dos_qfseek(),
      dos_qfclose()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_qfopen() - Open a file for input or output.



   SYNOPSIS

      ptr = dos_qfopen(name, mode);

      struct qfile *dos_qfopen(UBYTE *, LONG);



   FUNCTION

      Basically this function wraps on  'Open()' adding
      an asynchronous I/O capability.



   INPUTS

      name - NULL term. filename of a file to access.

      mode - Standard 'Open()' modes(MODE_OLDFILE, ...).



   RETURNS

      Returns special file descriptor pointer or NULL if
      memory or message port allocation or file opening
      failed.



   BASES

      SysBase, DOSBase



   NOTES

      Func. does 'AllocSignal()' thru 'CreateMsgPort()'!



   SEE ALSO

      dos_qfclose(), dos_qfwait(), dos_qfispending(),
      dos_qfsetmode(), dos_qfsetintsig(),
      dos_qfsetfctwait(), dos_qfread(), dos_qfwrite(),
      dos_qfseek(), dos_qfabort(), dos_qflink()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_qfwait() - Waits until operation is complete.



   SYNOPSIS

      res1 = dos_qfwait(qf, intsig);

      LONG dos_qfwait(struct qfile *, LONG);



   FUNCTION

      This func. allows to synchronise async  'qfile'
      descriptor with the ability to interrupt with a
      signal.



   INPUTS

      qf     - Ptr to a valid 'qfile' file descriptor.

      intsig - Standard, masked signal. 0 == no int.



   RETURNS

      May return -2 if interrupted or 'dp_Res1' taken
      from the DOS packet.



   BASES

      SysBase, DOSBase



   NOTES

      Although provided as a part of the API please do
      use only when really needed and with care!



   SEE ALSO

      dos_qfopen(), dos_qfclose(), dos_qfispending(),
      dos_qfsetmode(), dos_qfsetintsig(),
      dos_qfsetfctwait(), dos_qfread(), dos_qfwrite(),
      dos_qfseek(), dos_qfabort(), dos_qflink()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_qfispending() - Check if operation is still in
                          progress on 'qfile'.



   SYNOPSIS

      res = dos_qfispending(qf)

      LONG dos_qfispending(struct qfile *);



   FUNCTION

      This func. allows to check if asynchronous request
      is complete or not.



   INPUTS

      qf   - Pointer to a valid 'qfile' file descriptor.



   RETURNS

      Boolean result. 1 == oper.  is  still in progress,
      0 == operation complete.



   BASES

      SysBase, DOSBase



   NOTES

      Do not use in a taight loop, since status can only
      be changed by  'dos_qfread()',  'dos_qfwrite()' or
      'dos_qfwait()'!



   SEE ALSO

      dos_qfopen(), dos_qfclose(), dos_qfwait(),
      dos_qfsetmode(), dos_qfsetintsig(),
      dos_qfsetfctwait(), dos_qfread(), dos_qfwrite(),
      dos_qfseek(), dos_qfabort(), dos_qflink()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_qfsetmode() - Set mode on 'qfile' descriptor.



   SYNOPSIS

      dos_qfsetmode(qf, mode);

      void dos_qfsetmode(struct qfile *, LONG);



   FUNCTION

      This function allows to switch between synchronous
      and asynchronous.



   INPUTS

      qf   - Pointer to a valid 'qfile' file descriptor.

      mode - QFILE_SYNC or QFILE_ASYNC.



   RETURNS

      No output.



   BASES

      SysBase, DOSBase



   NOTES

      None.



   SEE ALSO

      dos_qfopen(), dos_qfclose(), dos_qfwait(),
      dos_qfispending(), dos_qfsetintsig(),
      dos_qfsetfctwait(), dos_qfread(), dos_qfwrite(),
      dos_qfseek(), dos_qfabort(), dos_qflink()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_qfsetintsig() - Set int. signal on 'qfile'.



   SYNOPSIS

      dos_qfsetintsig(qf, sig);

      void dos_qfsetintsig(struct qfile *, LONG);



   FUNCTION

      This func. allows to set int. signal on 'qfile'
      so that operation that blocked can be bypassed
      temporarily.



   INPUTS

      qf   - Ptr to a valid 'qfile' file descriptor.

      sig  - Standard, masked signal. 0 == no signal.



   RETURNS

      No output.



   BASES

      SysBase, DOSBase



   NOTES

      When combined with 'timer.device' allows I/O
      timeouts.



   SEE ALSO

      dos_qfopen(), dos_qfclose(), dos_qfwait(),
      dos_qfispending(), dos_qfsetmode(),
      dos_qfsetfctwait(), dos_qfread(), dos_qfwrite(),
      dos_qfseek(), dos_qfabort(), dos_qflink()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_qfsetfctwait() - Set wait factor on 'qfile'.



   SYNOPSIS

      dos_qfsetfctwait(qf, ticks);

      void dos_qfsetfctwait(struct qfile *, LONG);



   FUNCTION

      With this function asynchronous file descriptors
      can be adjusted in the way that this much time
      must elapse until checking for the handler reply.
      Funcs affected: 'dos_qfread()', 'dos_qfwrite()'.
      By default 3 ticks are used in 3 attempts.



   INPUTS

      qf    - Ptr to a valid 'qfile' file descriptor.

      ticks - Amount of time to wait in ticks. 0 == no
              delay, -1 == cooperative checks(this is
              considered insiginificant delay).



   RETURNS

      No output.



   BASES

      SysBase, DOSBase



   NOTES

      Do not set too high or else there will be lags,
      and thus the data rate will be poor.

      If you want to do something between requests and
      you will call 'dos_qfwait()' afterwards then you
      can safely use 0. Value of -1 should be used in
      a tight loop where your process must get lots of
      CPU time.

      Please note, when going to make a prog that will
      transfer from one async. handle to the another
      async. handle then one of handles must always be
      of a positive value so that CPU load is sane.



   SEE ALSO

      dos_qfopen(), dos_qfclose(), dos_qfwait(),
      dos_qfispending(), dos_qfsetmode(),
      dos_qfsetintsig(), dos_qfread(), dos_qfwrite(),
      dos_qfseek(), dos_qfabort(), dos_qflink()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_qfread() - Request amount of data on 'qfile'.



   SYNOPSIS

      res = dos_qfread(qf, ptr, size);

      LONG dos_qfread(struct qfile *, void *, LONG);



   FUNCTION

      This function works like  'Read()' in general but
      can also be totally asynchronous!



   INPUTS

      qf    - Ptr to a valid 'qfile' file descriptor.

      ptr   - Pointer to a buffer space.

      size  - Size of that buffer.



   RETURNS

      May return -2 if no data is yet available, -1 on
      error, 0 on EOF and a positive value if supplied
      buffer was successfuly filled.



   BASES

      SysBase, DOSBase



   NOTES

      No special precautions except that your code must
      handle -2 result specially and do not treat it as
      and error!

      This func. latches error permanently which is to
      say that whenever error occurrs no further ops
      are possible!

      Important! It is advised to use private exception
      handler to catch all standard signals(C, D, E, F)
      instead of testing them directly! This is because
      when in async mode, the 'Delay()' may be used and
      it does clobber C signal!



   SEE ALSO

      dos_qfopen(), dos_qfclose(), dos_qfwait(),
      dos_qfispending(), dos_qfsetmode(),
      dos_qfsetintsig(), dos_qfsetintsig(),
      dos_qfwrite(), dos_qfseek(), dos_qfabort()
      dos_qflink()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_qfwrite() - Export amount of data on 'qfile'.



   SYNOPSIS

      res = dos_qfwrite(qf, ptr, size);

      LONG dos_qfwrite(struct qfile *, void *, LONG);



   FUNCTION

      This function works like 'Write()' in general but
      can also be totally asynchronous!



   INPUTS

      qf    - Ptr to a valid 'qfile' file descriptor.

      ptr   - Pointer to a buffer space.

      size  - Size of that buffer.



   RETURNS

      May return -2 if no data was transferred yet, -1
      or 0 on error, and a positive value if supplied
      buffer was exported.



   BASES

      SysBase, DOSBase



   NOTES

      You must really protect the supplied buffer from
      being overwritten elsewhere in your code when -2
      is returned! Use 'dos_qfispending()' to decide if
      it is safe to alter it or not.

      This function latches error permanently which is
      to say that whenever error occurrs no further
      ops are possible!      

      Important! It is advised to use private exception
      handler to catch all standard signals(C, D, E, F)
      instead of testing them directly! This is because
      when in async mode, the 'Delay()' may be used and
      it does clobber C signal!



   SEE ALSO

      dos_qfopen(), dos_qfclose(), dos_qfwait(),
      dos_qfispending(), dos_qfsetmode(),
      dos_qfsetintsig(), dos_qfsetintsig(),
      dos_qfread(), dos_qfseek(), dos_qfabort(),
      dos_qflink()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_qfseek() - Seek in 'qfile' file descriptor.



   SYNOPSIS

      res = dos_qfseek(qf, off, whence);

      LONG dos_qfseek(struct qfile *, LONG, LONG);



   FUNCTION

      This function alter-wraps 'Seek()'. It is in no
      way asynchronous once internal call was made!



   INPUTS

      qf     - Ptr to a valid 'qfile' file descriptor.

      off    - File offset.

      whence - Offset control(OFFSET_BEGINNING, ...).



   RETURNS

      May return -2 if previous operation is still in
      progress. Non-permanent -1 on error and 0 and up
      on success.



   BASES

      SysBase, DOSBase



   NOTES

      This function can only be successful when no op.
      is pending on the file descriptor!
      


   SEE ALSO

      dos_qfopen(), dos_qfclose(), dos_qfwait(),
      dos_qfispending(), dos_qfsetmode(),
      dos_qfsetintsig(), dos_qfsetintsig(),
      dos_qfread(), dos_qfwrite(), dos_qfabort(),
      dos_qflink()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_qfabort() - Try to abort current operation.



   SYNOPSIS

      res = dos_qfabort(qf)

      LONG dos_qfabort(struct qfile *);



   FUNCTION

      This function tries to abort operation which is
      in progress.



   INPUTS

      qf     - Ptr to a valid 'qfile' file descriptor.



   RETURNS

      Can return -1 if there is nothing to abort, 0 if
      operation cannot be aborted cus handler is up to
      this operation at the moment and 1 on success.



   BASES

      SysBase, DOSBase



   NOTES

      None.



   SEE ALSO

      dos_qfopen(), dos_qfclose(), dos_qfwait(),
      dos_qfispending(), dos_qfsetmode(),
      dos_qfsetintsig(), dos_qfsetintsig(),
      dos_qfread(), dos_qfwrite(), dos_qfseek(),
      dos_qflink()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_qfclose() - Close previously opened 'qfile'.



   SYNOPSIS

      dos_qfclose(qf);

      void dos_qfclose(struct qfile *);



   FUNCTION

      The opposite of 'dos_qfopen()' function.



   INPUTS

      qf - Pointer to a valid 'qfile' file descriptor.



   RETURNS

      No output.



   BASES

      SysBase, DOSBase



   NOTES

      None.



   SEE ALSO

      dos_qfopen(), dos_qfwait(), dos_qfispending(),
      dos_qfsetmode(), dos_qfsetintsig(),
      dos_qfsetfctwait(), dos_qfread(), dos_qfwrite(),
      dos_qfseek(), dos_qfabort(), dos_qflink()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_remfdrelay() - Tries to terminate relay process by
                         sending ACTION_DIE packet.



   SYNOPSIS

      res = dos_remfdrelay(name);

      LONG dos_remfdrelay(UBYTE *);



   FUNCTION

      This func. tries to terminate relay process by sending
      ACTION_DIE packet to it.



   INPUTS

      name    - NULL terminated DOS device name. Name can be
                suffixized with colon(':'), but that is not
                necessary.



   RETURNS

      Function will return 1 if packet was sent, -1 if it was
      not and/or 0 if device does not exist(anymore).



   BASES

      (SysBase), DOSBase



   NOTES

      This function doesnt guarantee device removal! You can,
      however place it in a loop together with some delayer
      and if it returns 0 then the device is considered gone.



   SEE ALSO

      dos_addfdrelay(), dos_ctrlfdrelay()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_addlinkpoint() - Starts up a link point as a DOS
                           device.



   SYNOPSIS

      res = dos_addlinkpoint(dir, name, termsig);

      BOOL dos_addlinkpoint(UBYTE *, UBYTE *, ULONG);



   FUNCTION

      This function is a subsystem that allows to unify
      files and streams, so they all look like files.



   INPUTS

      dir     - Directory name which will be used as a link
                space. It could also be a filename or string
                containing particular entries.

      name    - NULL terminated DOS device name. Name can be
                suffixized with colon(':'), but that is not
                necessary.

      termsig - Device termination signal. NULL if you dont
                wish for it to be terminable.



   RETURNS

      Returns TRUE if device was up and running, or FALSE if
      it didnt init properly.



   BASES

      SysBase, DOSBase



   NOTES

      If you decide to spawn this device in sepearate process
      from under your code space then make sure you wont go
      away while it is up!

      Each entry/mapped file can be defined using these 'LPX'
      arguments('ReadArgs()'):
      "LPF=LINKPOINTFILE/A/K,LPS=LINKPOINTSIZE/K,
      LPT=LINKPOINTTASKS/K,LPC=LINKPOINTCLI/K,
      LPW=LINKPOINTWAIT/K"


      LPF=LINKPOINTFILE  -  Target file/stream. Standard DOS
                            notation, like: 'lpf dev:[file]'.
                            Note that this is mandatory or
                            else file you did create will be
                            the target itself.

      LPS=LINKPOINTSIZE  -  Allows to set dummy file/stream
                            size. By default size of target
                            will be used for files and -1
                            (0xFFFFFFFF) for streams to fix
                            broken programs. You can specify
                            2 gigs max (0x7FFFFFFF) for the
                            object to be fully readable.

      LPT=LINKPOINTTASKS -  Task(s) who should be allowed or
                            denied to access this mapping. 
                            Syntax is same as in 'nfo_ktm()'
                            which means that the patterns or
                            exact matches can be delimited
                            with comma(s). Case insensitive!

      LPC=LINKPOINTCLI   -  Run this CLI command whenever
                            new client requests some mapping.
                            Command should react to C signal
                            cus after ACTION_END it will be
                            delivered. A '@' char. in front
                            of a command will cause only one
                            command to be spawned(if it is
                            not running) on multiple calls.
                            A '&' character in front of file
                            or pipe will indicate that this
                            object has to be accessed to die.
                            This is especially useful when
                            dealing with pipes. If the cmd is
                            still running after the client is
                            gone then its process will wait
                            until command is complete.

      LPW=LINKPOINTWAIT  -  If set above 0 then mapping's own
                            packet interface will be timeout
                            assisted. Values exp. in seconds.
                            A-must-use  feature when dealing
                            with  clients who  do  not inform
                            that they are about to end. This
                            is typically the case with progs
                            who offer files over some network
                            and are unable to determine what
                            happened to their clients. The
                            timeout is renewed every received
                            packet.

      All above arguments must be put in the very first line!
      Also target file/stream name must fit 80 bytes since it
      will be packed into comment field!

      This  thing  does multitask,  so it can successfully be
      used to map single tasking handlers.

      If you have 'TCP:' mounted and want 'HTTP:' or 'RHTTP:'
      device then just create '.httpdevice' object and assign
      your linkpoint to 'HTTP:' and/or 'RHTTP:'(raw output).

      Please note! You cannot manipulate filesystem structure
      directly(make, delete, rename,...). It is only possible
      to define objects externally and perform refresh thru
      'dos_dclinkpoint()' or 'DiskChange' from CLI.

      If you want to create a file/buffer with manual entries
      then each line must look like this(without quotes):
      '<mapping> = <lpx arguments><lf>'. For instance, this:
      'google = lpf http://google.com<lf>' will allow you to
      read 'Google' index file with just 'type lp0:google' if
      your device is 'LP0:'.

      Yes, "Link Point" also implements internal '[R]HTTP:',
      so that you can map WWW streams very easily. What that
      means to users? Think of old progs + multimedia here.

      Error status can be detected with 'Info' command. It
      will show you how many objects were discarded for some
      reason(usually invalid name).

      Linkpoint can be write protected just like any other FS
      with 'lock' command.



   SEE ALSO

      dos_remlinkpoint(), dos_dclinkpoint()



   EXAMPLE

      None.



   BUGS

      See 'a-dos_addlinkpoint.c' for more details.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_dclinkpoint() - Performs ACTION_INHIBIT twice to
                          refresh linkpoint.



   SYNOPSIS

      res = dos_dclinkpoint(name);

      LONG dos_dclinkpoint(UBYTE *);



   FUNCTION

      This function tries to refresh linkpoint contents by
      sending ACTION_INHIBIT packet to it.



   INPUTS

      name    - NULL terminated DOS device name. Name can be
                suffixized with colon(':'), but that is not
                necessary.



   RETURNS

      Function will return 1 if packet was sent, -1 if it was
      not and/or 0 if device does not exist(anymore).



   BASES

      (SysBase), DOSBase



   NOTES

      Can be called from tasks without any side effects.



   SEE ALSO

      dos_addlinkpoint(), dos_remlinkpoint()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_remlinkpoint() - Tries  to  terminate linkpoint by
                           sending ACTION_DIE packet.



   SYNOPSIS

      res = dos_remlinkpoint(name);

      LONG dos_remlinkpoint(UBYTE *);



   FUNCTION

      This function tries to terminate linkpoint by sending
      ACTION_DIE packet to it.



   INPUTS

      name    - NULL terminated DOS device name. Name can be
                suffixized with colon(':'), but that is not
                necessary.



   RETURNS

      Function will return 1 if packet was sent, -1 if it was
      not and/or 0 if device does not exist(anymore).



   BASES

      (SysBase), DOSBase



   NOTES

      This function doesnt guarantee device removal! You can,
      however place it in a loop together with some delayer
      and if it returns 0 then the device is considered gone.



   SEE ALSO

      dos_addlinkpoint(), dos_dclinkpoint()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_devbymsgport() - Allows to locate the device by
                           having its message port.



   SYNOPSIS

      dol = dos_devbymsgport(mp);

      struct DosList *dos_devbymsgport(struct MsgPort *);



   FUNCTION

      This function is useful when there is a need to find
      the device knowing its message port as obtained from
      lock or volume node.



   INPUTS

      mp - Message port address.



   RETURNS

      Returns DosList device pointer or NULL if the device
      was not found.



   BASES

      SysBase, DOSBase



   NOTES

      This function does 'Forbid()'/'Permit()' internally,
      but in case you want to fiddle with 'dol' you must
      brace it aditionally!

      This func. can be called safely from under the task!



   SEE ALSO

      dos_checkdevice()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_makedevice() - Allows to add DOS device to the OS.



   SYNOPSIS

      dol = dos_makedevice(name);

      struct DosList *dos_makedevice(UBYTE *);



   FUNCTION

      This func. initializes and adds DOS device to the system.



   INPUTS

      name - Standard DOS device name lower or upper case, with
             or without the colon(':').



   RETURNS

      Returns DosList pointer or NULL if there was no mem. for
      the device internals or name was found invalid or the dev.
      is already in the system.



   BASES

      SysBase, DOSBase



   NOTES

      None.



   SEE ALSO

      dos_killdevice(), dos_checkdevice()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_checkdevice() - Allows to check for DOS entry on
                          the list.



   SYNOPSIS

      dol = dos_checkdevice(name, type);

      struct DosList *dos_checkdevice(UBYTE *, LONG);



   FUNCTION

      This func. is useful when there is a need to query
      the device after it was created in a standalone proc.



   INPUTS

      name - Standard DOS device name lower or upper case,
             with or without the colon(':').

      type - Type of entry(DLT_DEVICE, DLT_VOLUME, ...).
             Ranges can be formed using upper 16 bits:
             'type = (DLT_NONBINDING << 16) | DLT_DEVICE;'
             where the range starts at DLT_DEVICE and ends
             at DLT_NONBINDING.



   RETURNS

      Returns DosList pointer or NULL if the device was not
      found.



   BASES

      SysBase, DOSBase



   NOTES

      You should really brace this function with 'Forbid()'
      / 'Permit()' pair! Functions such as 'LockDosList()'
      / 'UnLockDosList()' can also be used, but only in a
      process!

      It is best to combine this function in a delay sliced
      and time framed loop.

      This func. can be called safely from under the task!



   SEE ALSO

      dos_makedevice(), dos_killdevice()



   EXAMPLE

      ...

      #define ONESECOND   50
      #define LOOPDELAY    5
      #define TIMEOUT      \
              (ONESECOND / \
               LOOPDELAY)

      /*
       * Argument 'timeout' expresses values in seconds or
       * will trigger one time check if 0 is to be passed.
      */
      struct DosList *checkdev(UBYTE *name, LONG timeout)
      {
        struct DosList *dol;


        timeout = ((timeout > 0) ? 
                                (timeout * TIMEOUT) : 1);

        Forbid();

        while (((dol =
           dos_checkdevice(name, DLT_DEVICE)) == NULL) &&
                                             (--timeout))
        {
          /*
           * This will break forbidden state temporarily!
          */
          Delay(LOOPDELAY);
        }

        Permit();

        return dol;
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_killdevice() - Allows to strip DOS device from OS.



   SYNOPSIS

      dol = dos_killdevice(dol);

      struct DosList *dos_killdevice(struct DosList *);



   FUNCTION

      This function cleans up what 'dos_makedevice()' creates.



   INPUTS

      dol - DosList pointer as obtained with 'dos_makedevice()'.



   RETURNS

      May return what was passed in 'dol' if the device cannot
      be removed for some mysterious reason. Normally it should
      return NULL.



   BASES

      SysBase, DOSBase



   NOTES

      This function will tell all the clients who sent the pkt.
      lately that the device is not available anymore.



   SEE ALSO

      dos_makedevice(), dos_checkdevice()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_getfmfdrelay() - Obtains an address of the master
                           fd relay structure.



   SYNOPSIS

      fm = dos_getfmfdrelay(name)

      void *dos_getfmfdrelay(UBYTE *);



   FUNCTION

      This function allows low level ops to be performed
      on fd relay.



   INPUTS

      name - DOS device name(with or without colon(':')).



   RETURNS

      Returns pointer to 'fm' or NULL.



   BASES

      DOSBase



   NOTES

      This function doesnt block whole relay, but increases
      client count.

      Always  'Forbid()'/'Permit()'  protect before reading
      anything from this structure.



   SEE ALSO

      dos_freefmfdrelay()



   EXAMPLE

      ...

      struct dos_fdr_main *fm;
      struct dos_fdr_chan *fc;

      if ((fm = dos_getfmfdrelay("MYRELAY:")))
      {
        Forbid();

        QDEV_HLP_ITERATE(
               &fm->fm_chanlist, struct dos_fdr_chan *, fc)
        {
          ...
        }

        Permit();

        dos_freefmfdrelay(fm);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_freefmfdrelay() - Unlocks fd relay so it can die.



   SYNOPSIS

      dos_freefmfdrelay(ptr)

      void dos_freefmfdrelay(void *);



   FUNCTION

      This function unlocks fd relay, if it was locked with
      'dos_getfmfdrelay()'.



   INPUTS

      ptr - Pointer  to fd relay internals as obtained with
            'dos_getfmfdrelay()'.



   RETURNS

      No output.



   BASES

      DOSBase



   NOTES

      None.



   SEE ALSO

      dos_getfmfdrelay()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_replypacket() - Replies the DOS packet back to the
                          sender.



   SYNOPSIS

      dos_replypacket(dp, mpi, r1, r2);

      void dos_replypacket(struct DosPacket *, 
                               struct MsgPort *, LONG, LONG);



   FUNCTION

      This function sends reply packet back to the issuer of
      the initial packet.



   INPUTS

      dp  - DosPacket as obtained with 'dos_waitpacket()'.

      mpi - MsgPort at which initial packet was received.

      r1  - Result number 1(status usually).

      r2  - Result number 2(extended error).



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      This  func. can be called  safely from under the task!



   SEE ALSO

      dos_waitpacket()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_swapmpfdrelay() - Allows to switch message ports
                            in FH.



   SYNOPSIS

      omp = dos_swapmpfdrelay(fd, mp);

      struct MsgPort *dos_swapmpfdrelay(
                                  LONG, struct MsgPort *);



   FUNCTION

      This function should be used when there is a need to
      eliminate  FDR soft-interrupt that will be generated
      whenever file related  function gets called on given
      FH.



   INPUTS

      fd - FileHandle obtained with 'Open()' targetted at
           FDR possibly.

      mp - Message port that should be attached or NULL.



   RETURNS

      Returns previous message port on success or NULL on
      failure.



   BASES

      None.



   NOTES

      After calling 'dos_swapmpfdrelay(fd, NULL);' your FH
      will use global device message port. This also means
      that some packets(ACTION_DISK_INFO, ACTION_WAIT_CHAR,
      ACTION_TIMER_PACKET and ACTION_SCREEN_MODE) will not
      work anymore!

      Restoring prev. message port before calling 'Close()'
      is not mandatory in case of FDR related swap.



   SEE ALSO

      dos_getfmfdrelay(), dos_freefmfdrelay()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_waitpacket() - Awaits DOS packet on a given msg.
                         port.



   SYNOPSIS


      dp = dos_waitpacket(mp, termsig);

      struct DosPacket *dos_waitpacket(
                                 struct MsgPort *, ULONG);



   FUNCTION

      This function waits for a DosPacket to be delivered to
      requested MsgPort.



   INPUTS

      mp      - MsgPort at which packets will arrive.

      termsig - Additional termination signal if 'Wait()' is
                to be interrupted(can be 0 if no need to).



   RETURNS

      Returns pointer to DosPacket or NULL if 'termsig' was
      received, thus this function can be in charge of the
      dispatcher loop.



   BASES

      SysBase



   NOTES

      This  func. can be called safely from under the task!



   SEE ALSO

      dos_replypacket()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - HAN_#?
 ----------------------------------------------------------------------------

   NAME

      han_binaryifh() - Binary handler for use with the
                        'mem_openifh()'.



   SYNOPSIS

      osigs = han_binaryifh(sigs, id);

      __saveds __interrupt ULONG han_binaryifh(
                               register ULONG __asm("d0"),
              register struct mem_ifh_data * __asm("a1"));



   FUNCTION

      This handler allows to read the data until EOF only,
      but of course allows 'Seek()' to be used!



   INPUTS

      sigs - Current signals.

      id   - Handler exception data.



   RETURNS

      Returns the 'sigs' back to 'exec'.



   BASES

      SysBase



   NOTES

      [30-Dec-2013] Warning! This routine may require hot
      vectoring and thus a wrapper to restore A4 register
      when binary model requested is resident and code is
      to be executed from under OS function such as
      'InternalLoadSeg()'!



   SEE ALSO

      mem_openifh(), mem_closeifh(),
      han_rollifh(), han_rwifh(), han_termifh()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - HAN_#?
 ----------------------------------------------------------------------------

   NAME

      han_rollifh() - Rollover handler for use with the
                      'mem_openifh()'.



   SYNOPSIS

      osigs = han_rollifh(sigs, id);

      __saveds __interrupt ULONG han_rollifh(
                            register ULONG __asm("d0"),
            register struct mem_ifh_data * __asm("a1"));



   FUNCTION

      This handler allows to collect and read the data.
      Data that dont fit will cause wrap around and thus
      overwrite top of the buffer.



   INPUTS

      sigs - Current signals.

      id   - Handler exception data.



   RETURNS

      Returns the 'sigs' back to 'exec'.



   BASES

      SysBase



   NOTES

      Using 'Seek()' with  'OFFSET_BEGINNING' is a must
      if you want to start 'Read()'ing from the rollover
      buffer.

      Using 'Seek()' with 'OFFSET_CURRENT' shuld be done
      after receiving EOF so that new read area starting
      from current position can be defined.

      Currently 'OFFSET_END' is not implemented! Use the
      'OFFSET_BEGINNING' with buffer size for that.

      Function 'Seek()' will always return 0. No failure
      is possible though.

      Values to go into  'offset' cannot be negative! It
      is advised to always pass 0.

      [30-Dec-2013] Warning! This routine may require hot
      vectoring and thus a wrapper to restore A4 register
      when binary model requested is resident and code is
      to be executed from under OS function such as
      'InternalLoadSeg()'!



   SEE ALSO

      mem_openifh(), mem_closeifh(),
      han_binaryifh(), han_rwifh(), han_termifh()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - HAN_#?
 ----------------------------------------------------------------------------

   NAME

      han_rwifh() - Read/write binary handler for use with
                    'mem_openifh()'.



   SYNOPSIS

      osigs = han_rwifh(sigs, id);

      __saveds __interrupt ULONG han_rwifh(
                               register ULONG __asm("d0"),
              register struct mem_ifh_data * __asm("a1"));



   FUNCTION

      This handler allows to 'Read()' and 'Write()' the
      data until EOF and of course allows 'Seek()' to be
      used!



   INPUTS

      sigs - Current signals.

      id   - Handler exception data.



   RETURNS

      Returns the 'sigs' back to 'exec'.



   BASES

      SysBase



   NOTES

      You must 'Write()' something first to 'Read()' it!

      [30-Dec-2013] Warning! This routine may require hot
      vectoring and thus a wrapper to restore A4 register
      when binary model requested is resident and code is
      to be executed from under OS function such as
      'InternalLoadSeg()'!



   SEE ALSO

      mem_openifh(), mem_closeifh(),
      han_rollifh(), han_binaryifh(), han_termifh()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - HAN_#?
 ----------------------------------------------------------------------------

   NAME

      han_termifh() - Read/write capable virtual terminal
                      handler for use with 'mem_openifh()'.



   SYNOPSIS

      osigs = han_termifh(sigs, id);

      __saveds __interrupt ULONG han_termifh(
                                register ULONG __asm("d0"),
               register struct mem_ifh_data * __asm("a1"));



   FUNCTION

      This handler emulates 'console.device' entriely in
      memory. It is the most advanced packet handler of all
      handlers in this library.



   INPUTS

      sigs - Current signals.

      id   - Handler exception data.



   RETURNS

      Returns the 'sigs' back to 'exec'.



   BASES

      SysBase



   NOTES

      This handler requires special preparation before it
      can be used. You must 'mem_allocterm()' first of the
      size you want and pass the resulting pointer in 1st
      argument of 'mem_openifh()' setting 2nd arg. to 0.

      With 'SetMode()' you can switch between DSR and the
      terminal area. So that when you need to get CPR you
      select QDEV_HAN_SMTERM_POS, but when you require to
      read terminal, QDEV_HAN_SMTERM_TERM.

      Call 'Seek()' with OFFSET_BEGINNING so you can req.
      any byte within the terminal. All counting from top
      of course. Please note that sequences may appear in
      the buffer first!

      Call 'Seek(<fd>, 0, 0);' to set cursor at the top of
      the read area and to request optimized feed. Chunks
      of text will be positioned with extra ESC[#;#H seqs.
      No need to worry about cursor position in the real
      terminal! This mode does not allow particular byte
      to be requested.



   SEE ALSO

      mem_openifh(), mem_closeifh(),
      han_rollifh(), han_binaryifh(), han_rwifh()



   EXAMPLE

      ...

      void *term;
      LONG read;
      LONG fd;
      UBYTE buf[128];

      if ((term = mem_allocterm(80, 25, -1)))
      {
        if ((fd = mem_openifh(term, 0, han_termifh)))
        {
          FPrintf(fd, "\x1B[10;10HHello World!");

          /*
           * Clear real terminal before reading virtual
           * one.
          */
          Write(Output(), "\x1B" "c", 2);

          /*
           * Request terminal area access. Normally this
           * is DSR feedback.
          */
          SetMode(fd, QDEV_HAN_SMTERM_TERM);

          /*
           * Set to the first byte. Data comming from fd
           * are full terminal dump!
          */
          Seek(fd, 0, OFFSET_BEGINNING);

          while ((read = Read(fd, buf, sizeof(buf))) > 0)
          {
            Write(Output(), buf, read);
          }

          /*
           * The very last virtual terminal byte is NULL
           * mostly thus the need for LF!
          */
          Write(Output(), "\n", 1);

          mem_closeifh(fd);
        }

        mem_freeterm(term);
      }



   BUGS

      Following sequences are not implemented because i do
      not really know how they work...
      ;
      ESCH        HTS    HORIZONTAL TABULATION SET
      ESC[#W  n   CTC    CURSOR TABULATION CONTROL
      ESC[#g  1-  TBC    TABULATION CLEAR

      Following sequences are implemented at abs. minimum:
      ;
      ESC[#n  1-  DSR    DEVICE STATUS REPORT(6/CPR)

      Most private Amiga sequences are not recognized and
      will not be implemented most probably. The only priv
      Amiga sequence implemented is:
      ;
      ESC[ s  0   aSDSS  SET DEFAULT SGR SETTINGS

      Beware there is something wrong with color handling,
      but i was not able to investigate yet. The bug shows
      up when colors were requested before cursor going to
      be put before current position. The background that
      was of certain color is destroyed...

      Interesingly or not 'console.device' V39+ has probs
      handling 'ESC[#@' sequence properly. The memory will
      be trashed and the machine may/will crash whenever
      the cursor is at the end of line and char + 1 is to
      be inserted. Use this from CLI: echo "*e[A*e[D*e[2@"
      to reproduce the bug.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_allocbmapthere() - Allocates  standard  BitMap in
                             given type of memory.



   SYNOPSIS

      bm = mem_allocbmapthere(w, h, d, type);

      struct BitMap *mem_allocbmapthere(
                               ULONG, ULONG, ULONG, ULONG);



   FUNCTION

      This function tries to mimic 'AllocBitMap()' allowing
      user to allocate the BitMap in any memory.



   INPUTS

      w    - Width in pixels.

      h    - Height in pixels.

      d    - Depth in bits(max 8).

      type - Type of memory(standard 'AllocMem()' flags).



   RETURNS

      Returns pointer to the bitmap or NULL if there is not
      enough memory.



   BASES

      SysBase



   NOTES

      BitMap created with this function can be passed to
      'FreeBitMap()'.

      BitMap created by this function is in standard Amiga
      format.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_cooperate() - Turns preemption into cooperativeness
                        at the task level.



   SYNOPSIS

      mem_cooperate(pri, signal);

      void mem_cooperate(LONG, ULONG);



   FUNCTION

      This func. changes the behaviour of a loop on a preemptive
      system. This results in a loop that does not steal all the
      CPU time, but grants it to others who are equally or higher
      prioritised.



   INPUTS

      pri    - Priority that the task will be set to when going
               to cooperate. It should be 0 to avoid lockups that
               may happen if your code executes at high priority.
               Never pass anything above 0. Going lower is safe
               though, but your task could not be able to recover
               if there is a lot of processing going on in the
               system.

      signal - Signal that will be used to synchronise. This has
               to be preallocated signal!



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      Use this function in a busy-loop event handling if there is
      no other efficient way to do that. You can use SIGF_SINGLE
      signal for that purpose.

      Original task priority will be restored when this function 
      is done.



   SEE ALSO

   EXAMPLE

      ...

      LONG spawnedtasks = 0;

      ...

      spawnedtasks += spawntask();

      for(;;)
      {
        if (spawnedtasks == 0)
        {
          break;
        }

        mem_cooperate(0, SIGF_SINGLE);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_dosynctask() - Narrows task switching to selected
                         task.



   SYNOPSIS

      res = mem_dosynctask(addr);

      LONG mem_dosynctask(ULONG);



   FUNCTION

      This function allows exclusive interaction with given
      task by manipulating task priorities, so effectively
      it looks like 'Forbid()', but it is not!



   INPUTS

      addr   - Task address as integer. Passing NULL causes
               restore.



   RETURNS

      Returns 1 if synchronisation was attempted, 0 if it
      is in progress.



   BASES

      SysBase



   NOTES

      This function is very helpful when there is a need to
      detect when certain task gives away its CPU time.

      Do not use this function if you know that task youre
      trying to spy on never calls 'Wait()' or 'Signal()',
      either directly or indirectly and/or does not die or
      too dense signal(below 50 micros) is being delivered
      from interrupts. Machine lockup guaranteed!

      There is no way to tell whether 'Wait()' or 'Signal()'
      were called. Task will loose CPU in both cases!

      In order to stay in sync. you must call 'Forbid()' or
      'Disable()'(preferred) as soon as possible. This must
      be done right after calling this function ;-) . Then
      do what you want, except for 'Wait()' ing(directly or
      indirectly) and after that 'Permit()' or 'Enable()'.

      Task presence wont be assured! If 'addr' does not
      correspond any task, this func. will return at once.

      If this function is being used from concurrent tasks
      then it will block for the period of synchronisation
      in all other tasks, even in those who have advantage
      of priority!



   SEE ALSO

      mem_dosynctasks()



   EXAMPLE

      See 'testsuite/dosynctask-test.c' for more details.



   BUGS

      There is one, yes. There is workaround for it too. If
      task youre spying on 'Signal()'s some other task then
      two things may happen:

      1. You will resume, being sure activity ceased and
      if you did send a signal to terminate that task then
      after you are done that previously signaled task will
      resume.

      2. If that signalled task will be wanting to reply it
      may certainly not be able to find the caller anymore.

      What to do? Call 'mem_cooperate(-127, SIGF_SINGLE);'
      right after 'Signal()' which should be placed right
      after 'mem_dosynctask()', so you will pass your CPU
      time to that signalled task. This isnt without probs,
      cus others will also resume but works. If you want to
      be sure communication is complete try even -128. Do
      not worry priority related lockup is generally not
      possible in this state.

      Please note! Do not incorporate 'mem_cooperate()' in
      'mem_dosynctask()', make a wrapper instead, cus there
      must be two separate calls for this to work!



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_dosynctasks() - Narrows task switching to selected
                          tasks.



   SYNOPSIS

      res = mem_dosynctask(tasks);

      LONG mem_dosynctask(ULONG *);



   FUNCTION

      This function allows pseudo-exclusive interaction with
      multiple tasks by manipulating their priorities, so it
      it looks like 'Forbid()', but it is not!



   INPUTS

      tasks  - Array of task addresses terminated with NULL.
               Addresses are integers! Passing NULL causes
               restore.



   RETURNS

      Returns 1 if synchronisation was attempted, 0 if it
      is in progress.



   BASES

      SysBase



   NOTES

      This function is very helpful when there is a need to
      detect when a group of tasks go to sleep.

      Do not use this function if you know that task youre
      trying to spy on never calls 'Wait()' or 'Signal()',
      either directly or indirectly and/or does not die or
      too dense signal(below 50 micros) is being delivered
      from interrupts. Machine lockup guaranteed!

      There is no way to tell whether 'Wait()' or 'Signal()'
      were called. Task may loose CPU in both cases, but
      in case of 'Signal()' it can only be detectable when
      calling task signals task not in the 'tasks' table!

      In order to stay in sync. you must call 'Forbid()' or
      'Disable()'(preferred) as soon as possible. This must
      be done right after calling this function ;-) . Then
      do what you want, except for 'Wait()' ing(directly or
      indirectly) and after that 'Permit()' or 'Enable()'.

      Task presence wont be assured! If 'tasks' does not
      correspond any tasks, this func. will return at once.

      If this function is being used from concurrent tasks
      then it will block for the period of synchronisation
      in all other tasks, even in those who have advantage
      of priority!



   SEE ALSO

      mem_dosynctask()



   EXAMPLE

      See 'testsuite/dosynctask-test.c' for more details.



   BUGS

      See 'mem_dosynctask()'.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_freepentab() - Releases pens back to free pool.



   SYNOPSIS

      mem_freepentab(cm, tab);

      void mem_freepentab(struct ColorMap *, WORD *);



   FUNCTION

      This func. should be used after 'mem_remapbitmap()'
      if BitMap is no longer in use(displayed).



   INPUTS

      cm  - Pointer to ColorMap.

      tab - Pointer to a pen table(cache).



   RETURNS

      No output.



   BASES

      GfxBase



   NOTES

      This function expects that the 'tab' is always 256
      WORDs wide!

      Call this function even if 'mem_remapbitmap2()' or
      'mem_remapbitmap()' did fail!



   SEE ALSO

      mem_growpenholder(), mem_freepenholder(),
      mem_remapbitmap()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_getwbstartup() - Obtains a copy of 'WBStartup'
                           message in a 'QCLI' process.



   SYNOPSIS

      wbs = mem_getwbstartup(pr);

      void *mem_getwbstartup(struct Process *);



   FUNCTION

      This function allows to read 'Workbench' arguments
      in a 'QCLI'(relaunched Workbench process to act as
      a normal CLI) process.



   INPUTS

      pr   - Process pointer. Passing NULL means -this-
             process.



   RETURNS

      Returns 'WBStartup' pointer or NULL if process is
      not a 'QCLI' one.



   BASES

      SysBase



   NOTES

      This function is really simple, all it does is to
      check if 'pr_Arguments' contain a magic and a ptr.

      Please do not 'ReplyMsg()' to this message, its a
      copy taken from previous instance!!!



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_grabqarea() - Grants access to private, global 'qdev'
                        area where I/O specific stuff lives.



   SYNOPSIS

      qa = mem_grabqarea();

      void *mem_grabqarea(void);



   FUNCTION

      This function acts as a quick globals resolver, a bit
      like a public resource, but unnamed and a lot quicker.



   INPUTS

      No input.



   RETURNS

      Shall return 'struct qarea' pointer. If it fails then it
      means that the OS is really in a bad shape.



   BASES

      SysBase



   NOTES

      This func. serves as a quick globals resolver for other
      'qdev' related functions/subsystems.

      The actual structure is defined in the priv. header due
      to the nature of the function.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_iloadseg() - Allows to load executable off of memory.



   SYNOPSIS

      segs = mem_iloadseg(objptr, objlen);

      LONG mem_iloadseg(void *, LONG);



   FUNCTION

      This function can be very helpful when there is a need to
      load/run something that was hexdumped typically without
      the need of restoring it on the medium first.



   INPUTS

      objptr - Pointer to (hexdumped) data.

      objlen - Size of that data.



   RETURNS

      Function returns standard seglist, that can be freed with
      OS 'UnLoadSeg()'. NULL will indicate loading error.



   BASES

      SysBase, DOSBase



   NOTES

      Dont do 'Forbid()' or 'Disable()' before using this func.
      or it will block! Also never put your data on stack! 
      Follow  'SEE ALSO' to find out why.



   SEE ALSO

      mem_uniloadseg(), mem_openifh(), mem_closeifh()



   EXAMPLE

      ...

      #define datasize 172
      static UBYTE databuf[] = {0x00, 0x00, 0x03, 0xF3, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 
        0x00, 0x07, 0x00, 0x00, 0x03, 0xE9, 0x00, 0x00, 0x00, 0x12, 
        0x48, 0xE7, 0x20, 0x1E, 0x49, 0xF9, 0x00, 0x00, 0x00, 0x00, 
        0x2A, 0x78, 0x00, 0x04, 0x43, 0xEC, 0x00, 0x00, 0x70, 0x24,
        0x2C, 0x4D, 0x4E, 0xAE, 0xFD, 0xD8, 0x26, 0x40, 0x4A, 0x80, 
        0x67, 0x1A, 0x2C, 0x4B, 0x4E, 0xAE, 0xFF, 0xC4, 0x22, 0x00,
        0x41, 0xEC, 0x00, 0x0C, 0x24, 0x08, 0x4E, 0xAE, 0xFE, 0xAA,
        0x22, 0x4B, 0x2C, 0x4D, 0x4E, 0xAE, 0xFE, 0x62, 0x70, 0x00,
        0x4C, 0xDF, 0x78, 0x04, 0x4E, 0x75, 0x4E, 0x71, 0x4E, 0x75,
        0x4E, 0x71, 0x00, 0x00, 0x03, 0xEC, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x03, 0xF2, 0x00, 0x00, 0x03, 0xEA,
        0x00, 0x00, 0x00, 0x07, 0x64, 0x6F, 0x73, 0x2E, 0x6C, 0x69,
        0x62, 0x72, 0x61, 0x72, 0x79, 0x00, 0x48, 0x65, 0x6C, 0x6C,
        0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x21, 0x0A, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x03, 0xF2};

      ...

      struct Task *task;
      BPTR output;
      LONG segs;

      output = Open("CONSOLE:", MODE_OLDFILE);

      if ((segs = mem_iloadseg(databuf, datasize)) != NULL)
      {
        task = (struct Task *)CreateNewProcTags(
                                 NP_Seglist    , (ULONG)segs,
                                 NP_FreeSeglist, TRUE,
                                 NP_Cli        , TRUE,
                                 NP_CommandName, (ULONG)"helloworld",
                                 NP_Name       , (ULONG)"mytask",
                                 NP_StackSize  , 4096,
                                 NP_Output     , output,
                                 NP_CloseOutput, TRUE,
                                 NP_CloseInput , TRUE,
                                 TAG_DONE      , NULL);

        if (task == NULL)
        {
          mem_uniloadseg(segs);
        }
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_uniloadseg() - Unload the seglist.



   SYNOPSIS

      mem_uniloadseg(segs);

      void mem_uniloadseg(LONG);



   FUNCTION

      This function simply wraps 'UnLoadSeg()'.



   INPUTS

      segs - Segs as loaded with 'mem_iloadseg()'.



   RETURNS

      No output.



   BASES

      SysBase, DOSBase



   NOTES

      None.



   SEE ALSO

      mem_iloadseg(), mem_openifh(), mem_closeifh()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_iloadseg2() - Allows to scatter-load executable off
                        of memory.



   SYNOPSIS

      segs = mem_iloadseg2(objptr, objlen);

      LONG mem_iloadseg2(void *, LONG);



   FUNCTION

      This function does exactly what 'mem_iloadseg()' does,
      but does not require 'mem_xxxifh()' subsystem thus its
      a bit faster, smaller and guaranteed to work even when
      all allocatable signals are exhausted.



   INPUTS

      objptr - Pointer to (hexdumped) data.

      objlen - Size of that data.



   RETURNS

      Function returns standard seglist,  that can be freed
      with OS 'UnLoadSeg()'. NULL means loading error.



   BASES

      SysBase, DOSBase



   NOTES

      No restrictions on addressing and type of arbitration.



   SEE ALSO

      mem_uniloadseg2()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_uniloadseg2() - Unload the seglist.



   SYNOPSIS

      mem_uniloadseg2(segs);

      void mem_uniloadseg2(LONG);



   FUNCTION

      This function simply wraps 'UnLoadSeg()'.



   INPUTS

      segs - Segs as loaded with 'mem_iloadseg2()'.



   RETURNS

      No output.



   BASES

      SysBase, DOSBase



   NOTES

      None.



   SEE ALSO

      mem_iloadseg2()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_initemptybmap() - Initialise empty BitMap.



   SYNOPSIS

      mem_initemptybmap(bm, w, h, d);

      void mem_initemptybmap(
                       struct BitMap *, UWORD, UWORD, UWORD);



   FUNCTION

      This function allows to have "empty" BitMap. It is in
      fact a rectange that will be most probably drawn with
      color 0.



   INPUTS

      bm - BitMap container(as created on stack for example).

      w  - Width.

      h  - Height.

      d  - Depth.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      BitMap can be 1 to 8 bit only!



   SEE ALSO

      mem_convimgtobmap()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_remapbitmap() - Remaps the BitMap to fit new
                          ColorMap.



   SYNOPSIS

      newbm = mem_remapbitmap(bm, rgb32, cm, tab, type);

      struct BitMap *mem_remapbitmap(struct BitMap *,
             ULONG *, struct ColorMap *, WORD *, ULONG);



   FUNCTION

      This function allows to remap the bitmap, so it can
      be displayed using 'cm'.



   INPUTS

      bm    - BitMap to be remapped.

      rgb32 - Palette of that BitMap. An array where the
              very first entry is record header of ULONG
              and each component(R, G, B) is ULONG wide.

      cm    - ColorMap pointer.

      tab   - Pen table, the cache.

      type  - Type of memory(standard 'AllocMem()' flags)
              with one small exception. Passing MEMF_CHIP
              means use 'AllocBitMap()'!



   RETURNS

      Ret. ptr to new bitmap or NULL if there were probs.



   BASES

      SysBase, GfxBase



   NOTES

      Please note!  Pen  table('tab') must be of at least
      QDEV_MEM_RBP_PTABSIZE counting in WORDs!  Also,  it
      must be initialised to -1 for each entry on first
      use.

      This pen table can be used multiple times, so that
      remapping other bitmaps with same palette will be
      a lot faster.

      If you dont display any of the remapped bitmaps do
      'mem_freepentab()' or 'mem_freepenholder()' if pen
      accumulation was requested!

      Important! This func. works on standard 8 bit Amiga
      bitmaps only! Interleaved bmaps are not supported!

      Pseudo transparency can be achieved by predefining
      entry in the table. This is typically entry indexed
      with 0 that maps to 0(tab[0] = 0;), but you can do
      that for other colors too. Remeber though that such
      a table is considered hacked, so you better restore
      what you altered to -1 before passing it to the
      'mem_freepentab()' function!

      BitMap created with this function can be passed to
      'FreeBitMap()'.

      This func. uses code from 'supp/sup_c2p2c' written
      by Morten Eriksen.



   SEE ALSO

      mem_growpenholder(), mem_freepenholder(),
      mem_freepentab(), mem_loadpicture(),
      mem_freepicture()



   EXAMPLE

      See 'a-mem_xxxpicture()' for more details.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_remapbitmap2() - Remaps the BitMap to fit new
                           ColorMap (low mem. version).



   SYNOPSIS

      newbm = mem_remapbitmap2(bm, rgb32, cm, tab, type);

      struct BitMap *mem_remapbitmap2(struct BitMap *,
             ULONG *, struct ColorMap *, WORD *, ULONG);



   FUNCTION

      This function allows to remap the bitmap, so it can
      be displayed using 'cm'.



   INPUTS

      bm    - BitMap to be remapped.

      rgb32 - Palette of that BitMap. An array where the
              very first entry is record header of ULONG
              and each component(R, G, B) is ULONG wide.

      cm    - ColorMap pointer.

      tab   - Pen table, the cache.

      type  - Type of memory(standard 'AllocMem()' flags)
              with one small exception. Passing MEMF_CHIP
              means use 'AllocBitMap()'!



   RETURNS

      Ret. ptr to new bitmap or NULL if there were probs.



   BASES

      SysBase, GfxBase



   NOTES

      This function does exactly what 'mem_remapbitmap()'
      does, except that it does not need to allocate the
      chunky buffer. Main gains are: low memory setup or
      fragmented memory are not a problem when working on
      huge bitmaps. But this routine is slightly slower.

      See NOTES of 'mem_remapbitmap()' for more details.



   SEE ALSO

      mem_freepentab(), mem_loadpicture(),
      mem_freepicture()



   EXAMPLE

      See 'a-mem_xxxpicture()' for more details.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_signalsafe() - Wraps 'Signal()' making it safe to
                         call on random addresses.



   SYNOPSIS

      res = mem_signalsafe(tc, sig);

      LONG mem_signalsafe(struct Task *, ULONG);



   FUNCTION

      This function makes sure that the address corresponds
      a task (as found on the list) and if so signals it.



   INPUTS

      tc  - Task address.

      sig - Signal mask. If this is 0 then no Signal() will
            be called. You can use 0 to see if 'tc' is just
            there.



   RETURNS

      Returns 1 on success (task is there and/or has been
      signalled) or 0 on failure.



   BASES

      [SysBase]



   NOTES

      This routine does not reference global 'SysBase' thus
      it should be safe to use it anywhere in your process.

      Of course this routine is hell slow compared to 'exec'
      alone 'Signal()' so do not use it when you do not have
      to.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_makebmapfromimg() - Creates BitMap from Image.



   SYNOPSIS

      bm = mem_makebmapfromimg(image, type);

      struct BitMap *mem_makebmapfromimg(
                                     struct Image *, ULONG)



   FUNCTION

      This function converts Image to BitMap which gets its
      own memory.



   INPUTS

      image - Pointer to Image structure.

      type  - Type(MEMF_CHIP, MEMF_PUBLIC,...) of memory to
              use for the BitMap data.
              


   RETURNS

      Returns newly created BitMap or NULL if there was no
      memory.



   BASES

      SysBase, (GfxBase)



   NOTES

      This function does not allocate one big chunk of mem.
      needed to store the data, so chances are that it will
      be successful even if your mem. is very fragmented.

      BitMap created with  this function can be  passed to
      'FreeBitMap()'.

      BitMap can be 1 to 8 bits only!

      BitMap created  by this function is in standard Amiga
      format.



   SEE ALSO

      mem_convimgtobmap()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_addexhandler() - Allows programmer to have multiple
                           exception routines in a single task.



   SYNOPSIS

      sigbit = mem_addexhandler(presig, usercode, userdata);

      LONG mem_addexhandler(LONG, void *, void *);



   FUNCTION

      This function installs exception code in such a way that
      the exception mechanism become in-exclusive, so user can
      call some code per signal.



   INPUTS

      presig   - Preallocated signal(sigbit) or -1 for auto
                 allocated one.

      usercode - User exception routine. It must follow the
                 very same rules as denoted in 'RKM'.

      userdata - User general purpose data pointer.



   RETURNS

      Function returns signal number that can be then used to
      call the exception handler. That value is also used to
      identify the handler itself.



   BASES

      SysBase



   NOTES

      Exception handlers can be freed in any order. Also sigs
      can be manipulated without restrictions.

      Installing exception handler of this family on top of the
      unrelated one is possible. It will be wrapped. You must
      remember tho not to touch 'tc_ExceptCode'/'tc_ExceptData'
      after doing so!

      There can be 16 user handlers with automatically allocated
      signals maximally, because there is only 16 free signals
      per task.

      Never pass pointer to the data that are on stack! You can 
      either 'static' it or just allocate the memory and put it
      there. Reason for this is that when you call the init func
      in a nested call and then go back that data is gone!

      You must not call 'CreateProcTags()' in exception handler,
      but you can call 'CreateTask()'.

      Do not call functions that operate on critical data nor
      use arbitration or allocate something exclusively!!!

      Exception may cause short stack shrinkage, since it does
      put whole context in there! Make sure that you do not use
      more than a half of your stack space to be on the safe
      side.

      General rule is: one signal == one exception. This means
      that two signals that reference same exception code will
      cause two calls! But, unrelated exception handler (the one
      that was in 'tc_ExceptCode' before first call to this f.)
      will behave the old way and will be triggered once for all
      signals that has just arrived!



   SEE ALSO

      mem_remexhandler(), mem_attachsniffer(),
      mem_detachsniffer()



   EXAMPLE

      See source code of 'a-mem_xxxifh.c' for a practical use.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_remexhandler() - Removes one exception handler from 
                           task.



   SYNOPSIS

      mem_remexhandler(intsig);

      void mem_addexhandler(LONG);



   FUNCTION

      This function removes what 'mem_addexhandler()' installs.



   INPUTS

      intsig - Interrupt/exception signal associated with the
               handler.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      Handlers can be freed in any order since they reside in
      slots.

      The only protection from wrong signal bit value is when
      it exceeds 31.

      If at the time when the slot is being freed any pending
      and preallocated signal was caught then it will be send
      to the task! Possible 'Wait()' will be satisfied. If
      that is not what you want then clear this signal using 
      'SetSignal()' after 'mem_remexhandler()'.



   SEE ALSO

      mem_addexhandler(), mem_attachsniffer(),
      mem_detachsniffer()



   EXAMPLE

      See source code of 'a-mem_xxxifh.c' for a practical use.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_attachhotvec() - Allocates and attaches hot vector
                           array to current task.



   SYNOPSIS

      hot = mem_attachhotvec(id, size);

      void *mem_attachhotvec(ULONG, LONG);



   FUNCTION

      This func. allocates and attaches "hot vector" array to a
      task so that programmer can pass pointers of variables to
      callbacks/hooks that do not take data pointer. All within
      current task.



   INPUTS

      id   - Unique hot vector identification number (32 bit).
             Please use values in range from 0x00400000 to
             0x7FFFFFFF. Do not use value of 0 at all or you
             may encounter false matches!

      size - Size of the array. Stuffing anything below 4 will
             result in an array of at least 4 vectors.



   RETURNS

      Function returns pointer to MemList or NULL upon failure.
      Member 'ml_ME[0].me_Addr' points at the vector root data.



   BASES

      SysBase



   NOTES

      This function links hot vector against 'tc_MemEntry' list
      of current task so you may skip 'mem_detachhotvec()' and
      the memory will still be deallocated upon task or process
      death. But to keep up with good programming practices do
      that only when you aboslutely have to.

      Func. may fail if there is not enough memory but will not
      fail if selected 'id' is collisious! This is to allow new
      hot vector to overlay the existing one. Useful.

      Function applies MEMF_CLEAR automatically so vectors are
      all zeroed.

      Do not use id values below 0x00400000. They are reserved
      for 'qdev' routines!

      Do not use id values above 0x7FFFFFFF. They are intended
      for relative id allocation! Yes, that is possible.



   SEE ALSO

      mem_attachrelhotvec(), mem_detachhotvec(),
      mem_obtainhotvec(), mem_obtainrelhotvec(),
      mem_resolvehotvec()



   EXAMPLE

      ...

      void *hot;
      LONG **vec;

      /*
       * Allocate hot vector of 16 vectors giving it an id of
       * 0x00400000.
      */
      if ((hot = mem_attachhotvec(0x00400000, 16)))
      {
        /*
         * Obtain address to top of the hot vector by passing
         * 0. Now you setup the array so that further call to
         * this func loads it in a callback for instance.
        */
        vec = mem_obtainhotvec(0x00400000, 0);

        vec[0] = (LONG *)<my addr 1>;

        vec[1] = (LONG *)<my addr 2>;

        ...

        mem_detachhotvec(hot);
      }

      ...



   BUGS

      Maybe not a bug, but a design principle. You must really
      take care of id collision before it happens. And that is
      quite difficult task if you do not know of any other hot
      vectors. Thus please use the 'mem_attachrelhotvec()' and
      'mem_obtainrelhotvec()' instead. Thank you!



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_attachrelhotvec() - Allocates and attaches hot vector
                              array in relation to wrapper fp.



   SYNOPSIS

      hot = mem_attachrelhotvec(fp, size);

      void *mem_attachrelhotvec(void *, LONG);



   FUNCTION

      This func. allocates and attaches "hot vector" array to a
      task (wrapper code relative) so that programmer can pass
      pointers of variables to callbacks/hooks that do not take
      data pointer. All within current task.



   INPUTS

      fp   - Function pointer of wrapper responsible for hot
             vector array recovery.

      size - Size of the array. Stuffing anything below 4 will
             result in an array of at least 4 vectors.



   RETURNS

      Function returns pointer to MemList or NULL upon failure.
      Member 'ml_ME[0].me_Addr' points at the vector root data.



   BASES

      SysBase



   NOTES

      See notes of 'mem_attachhotvec()' func. for more details.

      This function is a wrapper on top of real allocator that
      is able to translate function pointer to upper id values.
      No id collision is possible under normal usage.



   SEE ALSO

      mem_attachhotvec(), mem_detachhotvec(),
      mem_obtainhotvec(), mem_obtainrelhotvec(),
      mem_resolvehotvec()



   EXAMPLE

      /*
       * Create wrapper function that will be unique in itself
       * then return with function that obtains hot vec. This
       * is your hot vector resolver from now on.
      */
      __interrupt LONG **gethotvec00(LONG ent)
      {
        return mem_obtainrelhotvec(gethotvec00, ent);
      }

      int main(void)
      {
        void *hot;
        LONG **vec;

        /*
         * Allocate hot vector array of size 16 in a relative
         * way. Func. pointer will be translated into dynamic
         * id.
        */
        if ((hot = mem_attachrelhotvec(gethotvec00, 16)))
        {
          /*
           * Obtain address to top of the hot vector array.
          */
          vec = gethotvec00(0);

          vec[0] = (LONG *)<my addr 1>;

          vec[1] = (LONG *)<my addr 2>;

          ...

          mem_detachhotvec(hot);
        }

        return 0;
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_detachhotvec() - Detaches hot vector from current
                           task and deallocates it.



   SYNOPSIS

      mem_detachhotvec(hot);

      void mem_deatchhotvec(void *);



   FUNCTION

      This routine does the opposite to 'mem_attachhotvec()'
      or 'mem_attachrelhotvec()'.



   INPUTS

      hot - Pointer to hot vector as obtained with the attach
            function.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      Make sure that no further calls to 'mem_obtainhotvec()'
      will occur before calling this function! In worst case
      obtained address will be NULL though.



   SEE ALSO

      mem_attachhotvec(), mem_attachrelhotvec(),
      mem_obtainhotvec(), mem_obtainrelhotvec(),
      mem_resolvehotvec()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_resolvehotvec() - Checks if hot vector is still in
                            a valid state.



   SYNOPSIS

      id = mem_resolvehotvec(hot);

      __saveds __interrupt ULONG mem_resolvehotvec(void *);



   FUNCTION

      This routine checks if hot vector array can be accessed
      or freed.




   INPUTS

      hot - Pointer to hot vector as obtained with the attach
            function.



   RETURNS

      Returns an ID of hot vector array if it is valid or 0
      if not.



   BASES

      SysBase



   NOTES

      If you need to access the array as attached to a remote
      task then do it in QDEV_HLP_NOSWITCH() macro along with
      calling this routine. For short informational purposes
      arbitration is not necessary.



   SEE ALSO

      mem_attachhotvec(), mem_detachhotvec(),
      mem_attachrelhotvec(), mem_obtainhotvec(),
      mem_obtainrelhotvec()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_obtainhotvec() - Obtains hot vector by taking its
                           id value.



   SYNOPSIS

      vec = mem_obtainhotvec(id, ent);

      __saveds __interrupt LONG **mem_obtainhotvec(
                                              ULONG, LONG);



   FUNCTION

      This function resolves "hot vector" by its unique id.



   INPUTS

      id  - Hot vec. id as assigned in 'mem_attachhotvec()'.

      ent - Vector number to obtain. You will want to pass
            0 so that top of array can be accessed but you
            may like to code overlaid hot vectors that grow
            so in that case you may want to poll for newly
            attached hot vector of the same id.



   RETURNS

      Hot vec. address or NULL on miss or when array is out
      of range.



   BASES

      [SysBase]



   NOTES

      This routine does not reference global 'SysBase' thus
      it should be safe to use it anywhere in your process.

      Even though function is safe to call from interrupts
      it will most likely not be able to resolve hot vector
      if this interrupt was not caused by your task.

      This function blocks task switching at the time of id
      test.
   


   SEE ALSO

      mem_attachhotvec(), mem_attachrelhotvec(),
      mem_detachhotvec(), mem_obtainrelhotvec(),
      mem_resolvehotvec()



   EXAMPLE

      ...

      LONG **vec;

      /*
       * Try to obtain 3rd(0, 1, 2) vector of this hot vec.
      */
      if ((vec = mem_obtainhotvec(0x00400000, 2)))
      {
        /*
         * Go to top of an array of vectors and check 0 vec.
        */
        vec -= 2;

        if (*vec)
        {
          ...
        }
      }

      ...



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_obtainrelhotvec() - Obtains hot vector by taking
                              wrapper fp.



   SYNOPSIS

      vec = mem_obtainrelhotvec(fp, ent);

      __saveds __interrupt LONG **mem_obtainrelhotvec(
                                             void *, LONG);



   FUNCTION

      This function resolves "hot vector" throuh an address
      of its wrapper.



   INPUTS

      fp  - Function pointer to wrapper that surrounds this
            routine.

      ent - Vector number to obtain. You will want to pass
            0 so that top of array can be accessed or some
            particular vector.



   RETURNS

      Hot vec. address or NULL on miss or when array is out
      of range.



   BASES

      [SysBase]



   NOTES

      This routine does not reference global 'SysBase' thus
      it should be safe to use it anywhere in your process.

      Even though function is safe to call from interrupts
      it will most likely not be able to resolve hot vector
      if this interrupt was not caused by your task.

      This function blocks task switching at the time of id
      test.   

      This func. is a wrapper on top of real allocator that
      is able to translate func pointer to upper id values.
      No id collision is possible under normal usage.



   SEE ALSO

      mem_attachhotvec(), mem_attachrelhotvec(),
      mem_detachhotvec(), mem_obtainhotvec(),
      mem_resolvehotvec()



   EXAMPLE

      __interrupt LONG **resolvehotvec00(LONG ent)
      {
        return mem_obtainrelhotvec(resolvehotvec00, ent);
      }

      __interrupt LONG **resolvehotvec01(LONG ent)
      {
        return mem_obtainrelhotvec(resolvehotvec01, ent);
      }

      ...

      LONG **vec;

      if ((vec = resolvehotvec00(2)))
      {
        ...
      }

      ...



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_openifh() - Create internal/emulated file desc.



   SYNOPSIS

      fd = mem_openifh(objptr, objlen, handler);

      LONG mem_openifh(void *, LONG, ULONG (*)
                               (register ULONG __asm("d0"),
              register struct mem_ifh_data * __asm("a1")));



   FUNCTION

      This func. allows to emulate file descriptor to which
      at the other end user data and its size are attached.
      


   INPUTS

      objptr  - Pointer to (hexdumped) data.

      objlen  - Size of that data.

      handler - Packet handler.



   RETURNS

      Returns almost compatible to 'Open()' file descriptor,
      but it cannot be 'Close()'d !!!



   BASES

      SysBase, DOSBase



   NOTES

      Please note, emulated file descriptors are picky mainly
      because they do not multitask! Also, there can be up to
      16 such file desc. per process, see 'mem_addexhandler()'
      to find out why.

      Dont 'Forbid()'/'Permit()' protect 'mem_openifh()'/
      'mem_closeifh()' code, or it will block forever upon
      read attempt, because there will be no way to jump to
      the exception routnie!

      Possible ops on emulated file descriptors depend on the
      handler! Overall you can generally use all the standard
      'dos' funcs.(including buffered ones).

      Never manipulate 'tc_ExceptCode'/'tc_ExceptData' after
      you obtained the descriptor! Use 'mem_addexhandler()'
      if you need custom exception handler.

      Never pass pointer to the data that are on stack! You
      can either 'static' it or just allocate the memory and
      put it there. This applies to 'Read()', 'Write()' and
      the like as well!

      Exception data structure is defined and described  in
      the private header!



   SEE ALSO

      mem_closeifh(), han_rollifh(),
      han_binaryifh(), han_termifh(), han_rwifh()



   EXAMPLE

      See 'a-mem_iloadseg.c' for a practical use.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_closeifh() - Close internal/emulated file desc.
                       obtained with 'mem_openifh()'.



   SYNOPSIS

      mem_closeifh(fd);

      void mem_closeifh(LONG);



   FUNCTION

      Closes emulated file descriptor.



   INPUTS

      fd - The descriptor.



   RETURNS

      No output.



   BASES

      SysBase, DOSBase



   NOTES

      None.



   SEE ALSO

      mem_openifh(), han_rollifh(),
      han_binaryifh(), han_termifh(), han_rwifh()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_convimgtobmap() - Converts Intuition Image to BitMap.



   SYNOPSIS

      mem_convimgtobmap(bm, image, vuq, hasher);

      void mem_convimgtobmap(struct BitMap *, struct Image *,
                  VUQUAD *, ULONG (*)(VUQUAD *, void *, LONG));



   FUNCTION

      This function allows to convert standard Intuition Image
      to Graphics BitMap structure without the need to allocate
      memory for it.



   INPUTS

      bm     - BitMap container(as created on stack for ex.).

      image  - Standard Image structure.

      vuq    - Pointer to real or virtual UQUAD. Can be NULL
               if data hashing is not needed.

      hasher - Hashing routine. Pass NULL if data hashing is
               not required. Hashing function template looks
               like 'mem_pjw64hash()'.



   RETURNS

      No output.



   BASES

      (GfxBase)



   NOTES

      Important! Dont free the image data at the time of using
      this BitMap!!!

      BitMap can be 1 to 8 bit only!

      BitMap created by this function is in standard Amiga fmt.

      If you need to hash all the planes, then always remeber
      to zero the 'vuq' before function call.



   SEE ALSO

      mem_initemptybmap()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_copyitnimage() - Makes a copy of Intuition Image.



   SYNOPSIS

      image = mem_copyitnimage(image, memtype);

      struct Image *mem_copyitnimage(struct Image *, ULONG);



   FUNCTION

      This function allows to make a copy of Intuition Image
      and choose what memory will be the destination one.



   INPUTS

      image   - Standard Intuition Image structure.

      memtype - Standard 'AllocMem()' memory type flags.



   RETURNS

      Returns pointer to the copy of Image or NULL.



   BASES

      SysBase



   NOTES

      Function can copy images whose bit depth is not higher
      than 8!



   SEE ALSO

      mem_freeitnimage()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_freeitnimage() - Frees copied Intuition Image.



   SYNOPSIS

      mem_freeitnimage(image);

      void mem_freeitnimage(struct Image *);



   FUNCTION

      This function frees the memory as allocated with the
      'mem_copyitnimage()'.



   INPUTS

      image - Copy of the Image.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      Never pass images not copied by 'mem_copyitnimage()'!



   SEE ALSO

      mem_copyitnimage()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_setaddrjtslot() - Sets offset or absolute routine
                            address per slot.



   SYNOPSIS

      ofp = mem_setaddrjtslot(jtab, fp, slot);

      LONG mem_setaddrjtslot(
                            struct Library **, LONG, LONG);



   FUNCTION

      This LBS companion function allows programmer to load
      routine offset at which routine jump entry resides or
      pass the function address directly per slot.



   INPUTS

      jtab - Local jump table pointer.

      fp   - Offset (negative value) or address (a positive
             value). Stuffing 0 makes this routine to ret.
             existing offset/address only.

      slot - Slot number to affect. Counting from 1. If you
             want to use offsets then include priv. header:
             'a-mem_xxxjumptable.h' and use macros.


   RETURNS

      Ret. old/curr. offset or absolute pointer or NULL if
      nothing was set.



   BASES

      SysBase



   NOTES

      Warning! No arbitration is performed when altering the
      slot!

      Normally this function will call 'CacheClearU()' after
      new 'fp' has been set! It is possible to disable that.

      This func. works pretty much like 'SetFunction()'. The
      difference is it does not modify jump table but a call
      table.

      Yes, this function can change slot appearance in a way
      that if a j. table was allocated strictly for absolute
      addressing or strictly for relative addressing it is
      possible to change that per slot anytime. See enclosed
      example below.



   SEE ALSO

      mem_allocjumptable(), mem_freejumptable(),
      mem_swapjumptable(), mem_importjumptable(),
      mem_filljumptable(), mem_setdatajtslot(),
      mem_addrfrombase()



   EXAMPLE

      #include <qlbs.h>
      #include <qdev.h>
      #include <proto/exec.h>

      /*
       * Slot number 5 is at offset 30 in our local 'jt'.
      */
      #define Wait_CALL(signalSet) LP1(\
      30, ULONG, Wait, ULONG, signalSet, d0,, *(void **)jt)

      ...

      struct Library **jt;

      if ((jt = mem_allocjumptable(16,
            QDEV_MEM_LBS_FABSCALL | QDEV_MEM_LBS_FNOFLUSH)))
      {
        /*
         * Associate jump table with call table. You must
         * call this routine if you don't import other lib!
        */
        mem_filljumptable(jt, -1, -1, 1, 16);

        /*
         * I have got 16 slots and i want to map one of the
         * 'exec' routines, say 'Wait()' which is at -318 to
         * slot 5 in a relative way.
        */
        mem_setaddrjtslot(jt, -318, 5);

        mem_setdatajtslot(jt, SysBase, 5);

        /*
         * Allow cache flushes and do flush them right now.
        */
        mem_swapjumptable(NULL, jt);

        /*
         * I can now call 'exec' routine using my local jump
         * table.
        */
        Wait_CALL(SIGBREAKF_CTRL_C);

        mem_freejumptable(jt);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_setdatajtslot() - Sets userdata/base pointer to be
                            loaded in A6 reg. before func.
                            call as per slot.



   SYNOPSIS

      oldud = mem_setdatajtslot(jtab, ud, slot);

      void *mem_setdatajtslot(
                           struct Library **, void *, LONG);



   FUNCTION

      This LBS companion function allows programmer to have
      custom pointer in A6 register while the program jumps
      to one of the local jump table routines.



   INPUTS

      jtab - Local jump table pointer.

      ud   - User data pointer or real library base. Stuff
             NULL to switch to jump table default data ptr.
             Stuff -1 to only get the existing data ptr.

      slot - Slot number to affect. Counting from 1. If you
             want to use offsets then include priv. header:
             'a-mem_xxxjumptable.h' and use macros.


   RETURNS

      Returns old/existing userdata or NULL if not attached
      or jtab is incompatible.



   BASES

      SysBase



   NOTES

      Warning! No arbitration is performed when altering the
      slot!

      Normally this function will call 'CacheClearU()' after
      new 'ud' has been set! It is possible to disable that.



   SEE ALSO

      mem_allocjumptable(), mem_freejumptable(),
      mem_swapjumptable(), mem_importjumptable(),
      mem_filljumptable(), mem_setaddrjtslot(),
      mem_addrfrombase()


   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_allocjumptable() - Allocates new jump table for
                             use with LBS.



   SYNOPSIS

      jtab = mem_allocjumptable(slots, flags);

      struct Library **mem_allocjumptable(LONG, LONG);



   FUNCTION

      With this function it is possible to allocate fresh
      jump table so it can be used (after preparation) in
      a program in place of main jump table of a certain
      OS library.



   INPUTS

      slots - Size of table expressed in number of slots.
              A single slot is 6 bytes wide. Public funcs
              start at slot 5 (30th byte). Passing 0-4
              will return jump table that has 4 slots.

      flags - Allocate/import flags. At the time of alloc
              it is possible to tell how source jump tab.
              should be imported. By default (if 0) calls
              will be QDEV_MEM_LBS_FRELCALL.



   RETURNS

      Returns ptr to another pointer that references jump
      table or NULL if there is not enough memory.



   BASES

      SysBase



   NOTES

      Do not use 'SetFunction()' on this very jump table!
      There are special functions to alter its contents.

      Local jump tables also allocate call tables! These
      are slots that contain methods reponsible for func
      calls.

      Some words on flags. With QDEV_MEM_LBS_FRELCALL the
      call table will reference offsets. This means that
      if someone does 'SetFunction()' on a real base (the
      source) this jump table will resolve swapped func.
      With QDEV_MEM_LBS_FABSCALL jump table gets imported
      with offsets being already resolved/cached. Thusly
      changes to source library base will not be visible.



   SEE ALSO

      mem_freejumptable(), mem_swapjumptable(),
      mem_importjumptable(), mem_filljumptable(),
      mem_setdatajtslot(), mem_setaddrjtslot(),
      mem_addrfrombase()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_freejumptable() - Frees previously allocated
                            jump table.



   SYNOPSIS

      mem_freejumptable(jtab);

      void mem_freejumptable(struct Library **);



   FUNCTION

      This func deallocates jump table as created with
      'mem_allocjumptable()'.



   INPUTS

      jtab - Jump table pointer.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      None.   



   SEE ALSO

      mem_allocjumptable(), mem_swapjumptable(),
      mem_importjumptable(), mem_filljumptable(),
      mem_setdatajtslot(), mem_setaddrjtslot(),
      mem_addrfrombase()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_swapjumptable() - Swaps the jump table in local
                            base.



   SYNOPSIS

      ojtab = mem_swapjumptable(base, jtab);

      struct Library **mem_swapjumptable(
                    struct Library *, struct Library **);



   FUNCTION

      This function allows to replace jump table in local
      base.
      


   INPUTS

      base - QBASEPOINTER(xxxBase) pointer.

      jtab - Jump table pointer. If this argument is NULL
             then existing jump table will be returned
             only.



   RETURNS

      Returns previous jump table or NULL if 'base' does
      not resemble local base.



   BASES

      SysBase



   NOTES

      This function stops interrupts at the time of swap
      and flushes CPU caches!

      If 'base' is NULL and allocator was supplied with
      QDEV_MEM_LBS_FNOFLUSH  flag  then  further calls to
      'mem_importjumptable()', 'mem_filljumptable()',
      'mem_setdatajtslot()' & 'mem_setaddrjtslot()' will
      cause cache flushes.



   SEE ALSO

      mem_allocjumptable(), mem_freejumptable(),
      mem_importjumptable(), mem_filljumptable(),
      mem_setdatajtslot(), mem_setaddrjtslot(),
      mem_addrfrombase()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_filljumptable() - Fills a range of slots with 
                            given opcode and/or address.



   SYNOPSIS

      slots = mem_filljumptable(
                         dst, inst, addr, start, count);

      LONG mem_filljumptable(struct Library **,
                                LONG, LONG, LONG, LONG);



   FUNCTION

      This routine allows to setup jump table quick such
      that single routine can be spread across different
      slots.



   INPUTS

      dst   - Destination jump table as created with the
              alloc. function.

      inst  - m68k CPU call instruction after which func
              address is to be expected. JMP = 0x4EF9 or
              JSR = 0x4EB9. Pass -1 so that instruction
              will not be altered.

      addr  - Routine address for this slot range. Pass
              -1 if you do not want to touch the ptr.

      start - Start slot. Min. 1. Fyi, in reality slots
              grow downwards so 1 == -1, but neg. values
              are not accepted!

      count - Number of slots affected. Min. 1



   RETURNS

      Returns 0 if all slots as specified in count have
      been filled or a positive number of slots that are
      out of range.



   BASES

      SysBase



   NOTES

      Warning! No arbitration is applied during filling!

      If both: 'inst' and 'addr' are -1 then each jump
      table slot will be given respective call table ptr.
      Instruction is altered too. Use this mode to fix
      jump table quickly.

      It is safe to specify out of range values in start
      and count. Sanity checks are made.

      The func. will return -slots if 'dst' is not local
      jump table.

      Caution! First 4 slots(offsets 6 - 24) are library
      private routines.

      This routine modifies the jump table only! It does
      not alter call table in any way.



   SEE ALSO

      mem_allocjumptable(), mem_freejumptable(),
      mem_swapjumptable(), mem_importjumptable(),
      mem_setdatajtslot(), mem_setaddrjtslot(),
      mem_addrfrombase()



   EXAMPLE

      #include <qdev.h>
      #include <a-mem_xxxjumptable.h>

      ...

      long myroutine(void)
      {
        txt_debugprintf(32, "Unimplemented yet!\n");

        return 0;
      }

      ...

      struct Library **jt;

      /*
       * Allocate new jump table that has 8 slots or in
       * original meaning is (8 * 6) == 48 bytes wide.
      */
      if ((jt = mem_allocjumptable(8, 0)))
      {
        /*
         * Load warning routine address to last 4 slots
         * where 5th slot is taken into account as well,
         * thus: 5/1, 6/2, 7/3, 8/4 .
        */
        mem_filljumptable(jt,
           QDEV_PRV_LBS_JMPINST, (LONG)myroutine, 5, 4);

        ...
      }

      ...



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_importjumptable() - Prepares/copies jump table
                              off source object.



   SYNOPSIS

      slots = mem_importjumptable(dst, src);

      LONG mem_importjumptable(
                  struct Library **, struct Library **);



   FUNCTION

      This func. prepares destination jump table using
      information contained in source jump table.



   INPUTS

      dst - Destination jump table as created with alloc
            function.

      src - Source jump table. Can be any valid library
            base. Real bases have to be vectorized first
            (&SysBase). Local jump tables are vectors
            already.



   RETURNS

      Returns 0 if all slots have been copied/prepped or
      number of slots that did not fit in 'dst'.



   BASES

      SysBase



   NOTES

      Warning! No arbitration is applied during copying!

      The func. will return -slots if 'dst' is not local
      jump table.

      In fact this routine does not raw copy jump tables
      but does call-table-referencing for each offset.
      What that means is, you can messup jump table and
      easily fix it using 'mem_filljumptable()' without
      knowing op code nor address!

      If QDEV_MEM_LBS_FABSCALL flag was specified at the
      time of allocation of 'dst' and if 'src' is a real
      lib. base then all its offsets will be resolved!
      This will cache  'src'  function pointers in other
      words. With  QDEV_MEM_LBS_FRELCALL offsets will be
      resolved during function call.



   SEE ALSO

      mem_allocjumptable(), mem_freejumptable(),
      mem_swapjumptable(), mem_filljumptable(),
      mem_setdatajtslot(), mem_setaddrjtslot(),
      mem_addrfrombase()



   EXAMPLE

      #include <qlbs.h>
      #include <qdev.h>
      #include <proto/exec.h>

      ...

      struct Library **jt;
      struct Library **old;

      /*
       * Allocate number of slots OS 3.1 SysBase has. To
       * remind you QBASESLOTS() accepts second optional
       * argument that allows to enlarge number of slots
       * by some amount (expressed in %), say 25.
      */
      if ((jt =
            mem_allocjumptable(QBASESLOTS(SysBase), 0)))
      {
        if (mem_importjumptable(
                  jt, (struct Library **)&SysBase) == 0)
        {
          if ((old =
            mem_swapjumptable(QBASEPOINTER(SysBase), jt)))
          {
            /*
             * Any 'exec' calls will now be attempted
             * through local jump table.
            */
            ...

            mem_swapjumptable(QBASEPOINTER(SysBase), old);
          }
        }
      }

      ...



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_growpenholder() - Accumulates local pen caches.



   SYNOPSIS

      mem_growpenholder(htab, ptab);

      void mem_growpenholder(WORD *, WORD *);



   FUNCTION

      This func. allows to accumulate pen tables, so that
      there is no need for a separate cache per bitmap,
      who was remapped to fit given colormap.



   INPUTS

      htab - Pointer to holder table.

      ptab - Pointer to a pen table.



   RETURNS

      No output.



   BASES

      GfxBase



   NOTES

      This function expects that the 'htab' and 'ptab' are
      always 256 WORDs wide!

      Holder table entries must be initialized to 0 before
      first call.

      Important! This func. modifies 'ptab', so each entry
      gets set to -1 after examination.

      Warning! Do not intermix pen caches who correspond
      distinct 'ColorMap's!



   SEE ALSO

      mem_freepenholder(), mem_remapbitmap()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_freepenholder() - Frees accumulated pens in 
                            the holder table.



   SYNOPSIS

      mem_freepenholder(cm, htab);

      void mem_freepenholder(struct ColorMap *, WORD *);



   FUNCTION

      This function allows to free what was accumulated 
      by the 'mem_growpenholder()' in relation to 'cm'.



   INPUTS

      cm   - Pointer to ColorMap.

      htab - Pointer to a holder table.



   RETURNS

      No output.



   BASES

      GfxBase



   NOTES

      This function expects that the 'htab' is always 256
      WORDs wide!

      Important! This func. modifies 'htab', so each entry
      gets set to 0 after pen release.



   SEE ALSO

      mem_growpenholder(), mem_remapbitmap()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_loadpicture() - Allows to load and remap picture(s)
                          so they look best on a given screen.



   SYNOPSIS

      bmap = mem_loadpicture(file, cm, rp, memtype, flags);

      struct BitMap **mem_loadpicture(UBYTE *,
       struct ColorMap *, struct RastPort *, ULONG, ULONG);



   FUNCTION

      This func. allows to load binary('genanim' produced) or
      any other picture thru datatypes, using 'guigfx.library'.



   INPUTS

      file    - NULL terminated string.

      cm      - ColorMap to fit.

      rp      - RastPort to be used by the 'guigfx'.

      memtype - Memory type(binary images only!).

      flags   - Image/color flags.



   RETURNS

      Returns an array of bitmaps(last one is always NULL) or
      NULL if there is not enough memory.



   BASES

      SysBase, DOSBase, GfxBase, [GuiGFXBase]



   NOTES

      This func. can load binary animations too! Use 'PPaint'
      & 'genanim'.

      Frame optimization is essentially possible. Currently
      PJW64 hashing algorithm is being used to fish out duped
      frames.

      This function assumes that color 0 is pseudo transparent
      for binary pictures!

      Please dont assume that 'guigfx' returns standard Amiga
      BitMap!



   SEE ALSO

      mem_freepicture()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_freepicture() - Frees the array of bitmaps.



   SYNOPSIS

      mem_freepicture(bm);

      void mem_freepicture(struct BitMap **);



   FUNCTION

      This func.  frees what 'mem_loadpicture()' does
      allocate.



   INPUTS

      bm - BitMap vector.



   RETURNS

      No output.



   BASES

      SysBase, DOSBase, GfxBase, [GuiGFXBase]



   NOTES

      Please always use this function rather than trying
      to free the bitmaps yourself and thus causing mem.
      leak!



   SEE ALSO

      mem_loadpicture()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_alloclfvec() - Allocate memory in a leak-free way.



   SYNOPSIS

      ptr = mem_alloclfvec(size, flags);

      void *mem_alloclfvec(ULONG, ULONG);



   FUNCTION

      This is leak-free memory allocator. This means that no
      memory leaks are possible after program has ended even
      though no 'mem_freelfvec()' was called.



   INPUTS

      size  - Amount of memory to allocate.

      flags - Standard 'AllocMem()' flags.



   RETURNS

      Pointer to freshly allocated memory region or  NULL if
      unsuccessful.



   BASES

      (SysBase)



   NOTES

      This function uses Hot Vector Array subsystem directly.
      No auxiliary memory allocations are being performed.

      Caution! Allocations take a little more memory that it
      was actually requested!

      Whenever you need to allocate memory to a remote task,
      do not access 'ptr' without checking if that memory is
      still available with 'mem_checklfvec()'!

      Do not allocate memory with this routine and grant the
      pointer to other tasks if you know that they cannot do
      the memory validity checks! Memory will become invalid
      upon death of your task or process!



   SEE ALSO

      mem_freelfvec(), mem_checklfvec()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_freelfvec() - Deallocate leak-free memory if not
                        needed anymore.



   SYNOPSIS

      mem_freelfvec(ptr);

      void mem_freelfvec(void *);



   FUNCTION

      Frees the memory prev. alloc. with 'mem_alloclfvec()'.



   INPUTS

      ptr - Pointer as obtained with 'mem_alloclfvec()'.



   RETURNS

      No output.



   BASES

      (SysBase)



   NOTES

      The use of this routine is not necessary ;-)  but feel
      free to go with good programming practices.

      Never pass alien (AllocMem()/AllocVec/etc) pointers to
      this function!

      Always 'mem_checklfvec()' 'ptr' of memory that was not
      attached to your task before freeing memory.



   SEE ALSO

      mem_alloclfvec(), mem_checklfvec()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_checklfvec() - Checks if allocated memory is still
                         available.



   SYNOPSIS

      res = mem_checklfvec(ptr);

      LONG mem_checklfvec(void *);



   FUNCTION

      Checks if memory that was allocated in a leak-free way
      is still accessible.



   INPUTS

      ptr - Pointer as obtained with 'mem_alloclfvec()'.



   RETURNS

      Returns a boolean value (1 == OK, 0 == not OK).



   BASES

      SysBase



   NOTES

      Must call this routine in QDEV_HLP_NOSWITCH() macro if
      access to 'ptr' is planned.



   SEE ALSO

      mem_alloclfvec(), mem_freelfvec()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_allocvecpooled() - Allocate memory with pool manager.



   SYNOPSIS

      ptr = mem_allocvecpooled(size, flags);

      void *mem_allocvecpooled(ULONG, ULONG);



   FUNCTION

      The function at the outside resembles 'AllocVec()' very
      much, but internally uses automatically adjusted pools.
      It is very good solution if you need a lot of tiny mem.
      allocs so that memory fragmentation is at the very sane
      level.



   INPUTS

      size  - Amount of memory to allocate.

      flags - Standard 'AllocMem()' flags.



   RETURNS

      Pointer to freshly allocated memory region or NULL if
      unsuccessful.



   BASES

      SysBase



   NOTES

      Please note, this func. distinguishes between MEMF_CHIP
      and MEMF_FAST memory allocations only! On a system that
      has chip mem. only flags: MEMF_ANY, MEMF_PUBLIC will use
      node that is responsible for fast memory allocations!

      MEMF_CLEAR works of course and may be applied per each
      memory allocation.

      This function does simple memory tracking so mem. leaks
      can be easily detected with 'mem_setvecpooled()'.

      See source code for a default pool values.



   SEE ALSO

      mem_freevecpooled(), mem_setvecpooled()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_freevecpooled() - Deallocate memory with pool man.



   SYNOPSIS

      mem_freevecpooled(ptr);

      void mem_freevecpooled(void *);



   FUNCTION

      Frees the mem. prev. alloc. with 'mem_allocvecpooled()'.



   INPUTS

      ptr - Pointer as obtained with 'mem_allocvecpooled()'.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      With the help of 'mem_setvecpooled()' whole pool can be
      deallocated without the need of using this routine.

      Never pass 'AllocMem()'ed/'AllocVec()'ed pointers to this
      function!



   SEE ALSO

      mem_allocvecpooled(), mem_setvecpooled()



   EXAMPLE

      ...

      UBYTE *bptr;
      ULONG *lptr;

      if ((bptr = mem_allocvecpooled(4096, MEMF_PUBLIC)))
      {
        if ((lptr = mem_allocvecpooled(4096 * 4, MEMF_PUBLIC)))
        {
          ...

          /* mem_freevecpooled(lptr) */
        }

        /* mem_freevecpooled(bptr) */
      }

      /*
       * Deallocate memory of those two allocs in one go
      */
      mem_setvecpooled(MEMF_PUBLIC, QDEV_MEM_XXXVPI_FREE, 
                                          QDEV_MEM_XXXVPV_NOCH);



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_setvecpooled() - Set/get allocation params per proc.



   SYNOPSIS

      parm = mem_setvecpooled(memtype, item, value);

      LONG mem_setvecpooled(ULONG, ULONG, LONG);



   FUNCTION

      This function allows to set or get memory params out of
      internal pool nodes. There are two nodes, the 'chip' and
      'fast' node. They are maintained per process.



   INPUTS

      memtype - MEMF_CHIP or MEMF_FAST(and its brothers).

      item    - Item to set or request, see header file for
                available items.

      value   - Value to set in place or -1 to just get it.



   RETURNS

      Returns old value or -1 upon error.



   BASES

      SysBase



   NOTES

      Currenty this function can only set two params and these
      are: puddle size and treshold. See Commodore-Amiga 'RKM'
      for more info on those. Anyway, these values can only
      be set if no calls to 'mem_allocvecpooled()' were made!
      See 'a-mem_xxxvecpooled.c' for the default pool values.

      At any time you may request info about: real amount of
      memory allocated, total amount of memory allocated,
      number of all memory allocations, pool pointer addr. as
      an integer and/or free the pools at once, see defines.



   SEE ALSO

      mem_allocvecpooled(), mem_freevecpooled()



   EXAMPLE

      #include <proto/exec.h>
      #include <exec/memory.h>
      #include <proto/dos.h>

      /* 
       * 'AllocVec()'/'FreeVec()' pair will be turned into 
       * 'mem_allocvecpooled()'/'mem_freevecpooled()' pair.
      */
      #define ___QDEV_FORCEPOOLS

      #include <qdev.h>

      ...

      UBYTE *ptr;

      if (QDEV_MEM_XXXVPINIT(MEMF_FAST, 32768, 32768))
      {
        if ((ptr = AllocVec(4096, MEMF_FAST | MEMF_CLEAR)))
        {
          FPrintf(Output(), "%ld bytes of memory is now"
                                               " allocated\n",
                                   mem_setvecpooled(MEMF_FAST, 
                                         QDEV_MEM_XXXVPI_REAL, 
                                       QDEV_MEM_XXXVPV_NOCH));

          FreeVec(ptr);
        }
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_allocmemregion() - Allocate semi-absolute memory in
                             the range of start and end addr.



   SYNOPSIS

      ptr = mem_allocmemregion(size, flags, start, end);

      void *mem_allocmemregion(ULONG, ULONG, ULONG, ULONG);



   FUNCTION

      This function allows to allocate memory according to the
      addresses passed in, but that is not true absolute alloc.,
      but a form of choosing region from which memory can be
      allocated(always upside down).



   INPUTS

      size  - Amount of memory to allocate.

      flags - Standard 'AllocMem()' flags.

      start - Start address(physical).

      end   - End address(physical).



   RETURNS

      Pointer to freshly allocated memory region or NULL if
      unsuccessful.



   BASES

      SysBase



   NOTES

      Important! This function is very different form standard
      memory allocation. You cannot use first 8 bytes, it is a
      space where 'MemChunk' sits!!!

      Please note, this func. searches for a last free memory
      block on each memory node, thus all the allocations will
      be made in reverse order! This is just ideal solution
      for resident modules.

      Also, short ranges within same memory node and big sizes
      of the allocation are very likely to fail due to internal
      memory organisation(chunks) which is unpredictible, so it
      is best to assume at least node range if not two or more
      neighbour nodes.

      Range of arguments: 'start' and 'end' must be greater or
      equal than 'size'!

      Flags MEMF_REVERSE and MEMF_NO_EXPUNGE are assumed to be
      the default!

      MEMF_CLEAR works of course and may be applied per each
      memory allocation.

      Always use 'QDEV_MEM_REGALIGN()' macro to properly align
      size of the allocation!



   SEE ALSO

      mem_freememregion()



   EXAMPLE

      ...

      #include <qdev.h>

      #define MYBUFFERLEN 16384

      struct ptrwrapper
      {
        struct MemChunk pw_mc;     /* Reserved first 8 bytes     */
        ULONG           pw_size;   /* Additional size tracker    */
        UBYTE           pw_buf[4]; /* Dummy buffer size          */
        /*
         * No new members beyond this point allowed, because 
         * 'pw_buf' can be bigger('MYBUFFERLEN')!
        */
      };

      ...

      struct ptrwrapper *pw;
      ULONG size = QDEV_MEM_REGALIGN(  /* Always use this macro! */
        sizeof(struct ptrwrapper) + MYBUFFERLEN); 
      UBYTE *ptr;

      /*
       * We will try to allocate 16k of memory in a node that
       * is guaranteed not to go away at reset starting from
       * node that has highest priority so if there is fast
       * memory in that 24bit area it will be utilised in the
       * first place.
      */
      if ((pw = mem_allocmemregion(size, MEMF_LOCAL, 
                                       QDEV_MOD_ADE_24BITLOWER,
                                     QDEV_MOD_ADE_24BITUPPER)))
      {
        pw->pw_size = size;

        ptr = pw->pw_buf; /* Now you can use 'MYBUFFERLEN' space */

        ...

        mem_freememregion(pw, pw->pw_size);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_freememregion() - Deallocate semi-absolute memory.



   SYNOPSIS

      mem_freememregion(ptr, size);

      void mem_freememregion(void *, ULONG);



   FUNCTION

      Frees the mem. prev. alloc. with 'mem_allocmemregion()'.



   INPUTS

      ptr  - Pointer as obtained with 'mem_allocmemregion()'.

      size - Size of the allocation.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      This function is just a 'FreeMem()' wrapper, even though
      you better stick to it, cus it is guaranteed not to be
      pool deallocator which you may be using in your code!!!



   SEE ALSO

      mem_allocmemregion()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_attachsniffer() - Installs a sniffer on a given msg.
                            port.



   SYNOPSIS

      ptr = mem_attachsniffer(mp, usercode, userdata);

      void *mem_attachsniffer(
                            struct MsgPort *, void *, void *);



   FUNCTION

      This function makes it possible to spy on msg. port I/O
      of virtually any task that is running in the system.



   INPUTS

      mp       - PA_SIGNAL based message port that references
                 a task that is running. Orphaned/incompatible
                 msg. ports will be rejected!

      usercode - Sniffer function as created with magic macro
                 QDEV_MEM_SNIFFUNC().

      userdata - User supplied data. You can pass the 'mp' ptr
                 here to have quick access in sniffer func.



   RETURNS

      Function returns 'ient' handle if all went fine or NULL
      if 'mp' is invalid or there is not enough memory avail.



   BASES

      SysBase



   NOTES

      Yes, this code relies on private task exception mechanism
      so you must treat them pretty much like interrupts!

      Yes, it is possible to attach sniffer to message ports of
      different than your task.

      Yes, unlike 'mem_addexhandler()' which is restricted to
      only one handler per signal this routine allows multiple
      handlers on single mp/signal.

      No, it does not interfere with  'mem_addexhandler()'  and
      'mem_remexhandler()'. All will work as if there were no
      sniffers installed.

      Note that sniffers are always called in LIFO order. Every
      newly added sniffer is the first to call! As to exception
      routine, it will be called last. This allows to see what
      arrived on port before exception handler processes it.

      Remark! Sniffers (and especially long sniffer chains) are
      slower than exceptions alone!



   SEE ALSO

      mem_detachsniffer(), mem_addexhandler(),
      mem_remexhandler() 



   EXAMPLE

      ...

      #define ___QDEV_DEBUGINFO

      QDEV_MEM_SNIFFUNC
      (
        mysniffer,

        QDEV_MEM_SNIFEXEC();
        QDEV_MEM_SNIFUSER(struct MsgPort *, mp);
        struct Message *mn;

        QDEV_HLP_ITERATE(&mp->mp_MsgList, struct Message *, mn)
        {
          /*
           * This will be visible on remote terminal connected
           * via serial port or if redirector such as 'sashimi'
           * was started then in other shell.
          */
          QDEVDEBUG_N("mn_ReplyPort\nmn_Length\n\n\n",
                              mn->mn_ReplyPort, mn->mn_Length);
        }

        /*
         * Let the task, process what is in the queue. Without
         * this statement task may never notice that something
         * was sent to its message port.
        */
        QDEV_MEM_SNIFPASS();
      );

      ...

      void *spy;
      struct MsgPort *mp = <pointer>;

      if ((spy = mem_attachsniffer(mp, mysniffer, mp)))
      {
        ...
      }

      ...



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_detachsniffer() - Removes a sniffer on a given msg.
                            port.



   SYNOPSIS

      mem_detachsniffer(ptr);

      void mem_detachsniffer(void *);



   FUNCTION

      Removes sniffer from message port as installed with the
      'mem_attachsniffer()'.



   INPUTS

      ptr - Ptr to 'eint' handle as returned by the installer.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      It is safe to call this function if message port or the
      task pointed to by are invalid.

      Keep in mind that if you have installed the sniffer and
      the task/process ended before you were able to remove
      it there will be memory leak!



   SEE ALSO

      mem_attachsniffer(), mem_addexhandler(),
      mem_remexhandler() 



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_allocterm() - Allocates terminal I/O & buffer.



   SYNOPSIS

      ad = mem_allocterm(cols, rows, fchar);

      void *mem_allocterm(LONG, LONG, LONG);



   FUNCTION

      This func. allocates virtual terminal I/O and area
      that can be used with 'han_termifh()' pkt handler.



   INPUTS

      cols  - Number of terminal columns, min 1.

      rows  - Number of terminal rows, min 1.

      fchar - Fill character, passing -1 will pick 0x20.
              Each 'fchar' sets the actual terminal byte
              to QDEV_MEM_PRV_FNOCHAR. 



   RETURNS

      Returns pointer to private 'struct mem_act_data' or
      NULL if there is not enough memory.



   BASES

      SysBase



   NOTES

      By default object will link against 'memmove()', so
      you can prep your own memory moving routine or you
      can hack on 'ad_mmfp' and change it at runtime. The
      'libnix' routine is not bad in general.



   SEE ALSO

      mem_fixterm(), mem_freeterm(),
      mem_openifh(), mem_closeifh(), han_termifh()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_fixterm() - Fixes all terminal function and data
                      pointers.



   SYNOPSIS

      mem_fixterm(ptr);

      void mem_fixterm(void *);



   FUNCTION

      This function can be useful when terminal buffer is
      to be used across processes or was loaded residently
      into memory.



   INPUTS

      ptr - Pointer to virtual terminal area.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      Especially use this func. when one process allocates
      the terminal, passes its pointer to another process
      and dies so that the other process will swap all FPs
      to point at its code space.

      User CBs wont be fixed you will have to take care of
      that!



   SEE ALSO

      mem_allocterm(), mem_freeterm(),
      mem_openifh(), mem_closeifh(), han_termifh()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_freeterm() - Frees the virtual terminal memory.



   SYNOPSIS

      mem_freeterm(ptr);

      void mem_freeterm(void *);



   FUNCTION

      This func. deallocates what 'mem_allocterm()' have
      allocated.



   INPUTS

      ptr - Pointer to virtual terminal area.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      mem_allocterm(), mem_fixterm(),
      mem_openifh(), mem_closeifh(), han_termifh()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_maketokenlist() - Tokenizes NULL term. string and
                            creates a list.



   SYNOPSIS

      list = mem_maketokenlist(string, delim);

      struct MinList *mem_maketokenlist(UBYTE *, LONG);



   FUNCTION

      This function is able to tokenize a string and create
      'MinList' containing these tokens.



   INPUTS

      string - NULL terminated string.

      delim  - Delimiter character.



   RETURNS

      Returns pointer to 'MinList' or NULL if there is not
      enough memory.



   BASES

      SysBase



   NOTES

      To iterate the list use 'QDEV_HLP_ITERATE' macro and
      'mem_mtl_iter' structure!

      List of tokens, including the list bootstrap is one 
      big memory block, so dont try to free single entries!



   SEE ALSO

      mem_freetokenlist()



   EXAMPLE

      ...

      struct MinList *ml;
      struct mem_mtl_iter *mi;
      UBYTE *string = "so,many,commas,eh?";

      if ((ml = mem_maketokenlist(string, ',')))
      {
        QDEV_HLP_ITERATE(ml, struct mem_mtl_iter *, mi)
        {
          FPrintf(Output(), "%s\n", (LONG)mi->mi_token);
        }

        mem_freetokenlist(ml);
      }
      


   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_freetokenlist() - Frees the token list.



   SYNOPSIS

      mem_freetokenlist(ml);

      void mem_freetokenlist(struct MinList *);



   FUNCTION

      This func. frees what 'mem_maketokenlist()' allocates.



   INPUTS

      ml - List as obtained with 'mem_maketokenlist()' func.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      mem_maketokenlist()



   EXAMPLE

      None.
      


   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MOD_#?
 ----------------------------------------------------------------------------

   NAME

      mod_codereloc() - Puts the code and data segments in
                        reset-proof memory and relocates
                        them.



   SYNOPSIS

      ml = mod_codereloc(fd, flags, start, end);

      struct MemList *mod_codereloc(
                                LONG, ULONG, ULONG, ULONG);



   FUNCTION

      This func. relocates the code in given type of memory
      and then returns volatile MemList so that its entries
      can be connected to the module header.



   INPUTS

      fd    -  Standard FileHandle as returned by 'Open()',
               which allows to load standard HUNK files.

      flags -  Std. mem flags. Usually you will want to use
               MEMF_LOCAL or MEMF_CHIP.

      start -  Start of memory node/region. See the macros
               that define regions.

      end   -  End of memory node/region. This can even be
               set to upper bound of Amiga addressation.
               


   RETURNS

      Returns an address to MemList which references whole
      seglist, splited across MemEntries or NULL if loading
      failed or there is not enough memory.



   BASES

      SysBase, DOSBase



   NOTES

      In the 'ml->ml_Node.ln_Name' var. you will find the
      seglist. Please do not free it with 'UnLoadSeg()' and
      do not specify 'NP_FreeSeglist, TRUE' tag while making
      new process or else Guru will knock yer out! To free
      the segments use 'mod_codefree()'.

      If you intend to load the libraries, devices or some
      resources with this routine then use 'mod_codefind()'
      and pass '&ml->ml_ME[0]' to locate the ROMTAG. Dont
      forget to check if 'ml->ml_NumEntries > 1', and if so
      then such lib. may contain some globals or bss which
      may be problematic!

      Warning! Returned MemList is volatile which means you
      cannot use it directly in your module, you must copy
      each MemEntry descriptor!

      You can use this function with virtual files as well!



   SEE ALSO

      mod_codefree(), mod_codefind(),
      mem_allocmemregion(), mem_freememregion()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MOD_#?
 ----------------------------------------------------------------------------

   NAME

      mod_codefree() - Frees the memory of relocated code.



   SYNOPSIS

      mod_codefree(ml);

      void mod_codefree(struct MemList *);



   FUNCTION

      This f. frees what was allocated by 'mod_codefree()'.



   INPUTS

      ml  -  Memory list pointer which references the code
             and/or data areas.



   RETURNS

      No output.



   BASES

      SysBase, DOSBase



   NOTES

      None.



   SEE ALSO

      mod_codereloc(),
      mem_allocmemregion(), mem_freememregion()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MOD_#?
 ----------------------------------------------------------------------------

   NAME

      mod_codefind() - Locates Resident(ROMTAG) in freshly
                       relocated binary.



   SYNOPSIS

      rt = mod_codefind(me);

      struct Resident *mod_codefind(struct MemEntry *);



   FUNCTION

      This function allows to locate the Resident structure
      that every residentable object should carry.



   INPUTS

      me  -  Memory entry pointer which references the code
             area.



   RETURNS

      Returns the Resident pointer or NULL if code lacks it.



   BASES

      None.



   NOTES

      Having this information is cruicial in the process of
      module creation, and possibly allows you to link this
      code to the OS chains at this point, but for the sake
      of consistency please copy the contents of 'rt' to
      the 'struct mod_ktl_head' and then NULL it out!



   SEE ALSO

      mod_codereloc(), mod_codefree(),



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MOD_#?
 ----------------------------------------------------------------------------

   NAME

      mod_findktpresby() - Finds 'KickTagPtr' linked module in
                           one of six ways.



   SYNOPSIS

      rt = mod_findktpresby(mode, ptr);

      struct Resident *mod_findktpresby(LONG, UBYTE *);



   FUNCTION

      This function is able to find 'KickTagPtr' module by: its
      version or name or idstring or data pointer or type or by
      doing compare on data.



   INPUTS

      mode - Searching mode, see header file for defines. If you
             pass positive value(data length) here then you have
             to pass a pointer to this much data as well.

      ptr  - Pointer to either NULL term. string or value as
             a pointer in case of version or type.



   RETURNS

      Returns standard 'Resident' structure or NULL if it was
      unable to find anything.



   BASES

      SysBase, (DOSBase)



   NOTES

      When searching for mod. name or idstring standard AmigaDOS
      patterns can be used. Searching is case in-sensitive.

      Data compare is being done against 'rt->rt_Init' and its
      size is being determined by subtracting it from 
      'rt->rt_EndSkip', so it may not always be what you want
      if certain module has more than one 'MemEntry'! Also, data
      compare is case sensitive!



   SEE ALSO

   EXAMPLE

      ...

      /* 
       * Value below is: moveq 	#MEMF_PUBLIC!MEMF_FAST,d1
       *                 moveq 	#10,d2
      */
      #define MYCODESEQ 0x7205740A 

      struct Resident *rt;
      ULONG codeseq = MYCODESEQ;

      Forbid();

      /*
       * Search for a module that has a ver. of 44.
      */
      if ((rt = mod_findktpresby(QDEV_MOD_FSB_ME_VER, 
                                                  (UBYTE *)44)))
      {
        ...
      }

      /*
       * Search for a module with this date.
      */
      if ((rt = mod_findktpresby(QDEV_MOD_FSB_ME_IDSTR, 
                                               "#?5.6.96#?")))
      {
        ...
      }

      /*
       * Search for a module that contains this code 
       * sequence. It need not to be code, it can be
       * text as well. 
      */
      if ((rt = mod_findktpresby(sizeof(codeseq), 
                                            (UBYTE *)&codeseq)))
      {
        ...
      }

      Permit();



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MOD_#?
 ----------------------------------------------------------------------------

   NAME

      mod_getmemlist() - Tries to obtain 'MemList' of the
                         resident module.



   SYNOPSIS

      ml = mod_getmemlist(ptr, size);

      struct MemList *mod_getmemlist(void *, LONG);



   FUNCTION

      This function tries to find 'MemList' of particular
      'Resident' as found in the 'KickTagPtr' chain.



   INPUTS

      ptr  - Start address. Usually 'Resident' structure
             pointer.

      size - Size of data. Usually 'Resident' structure
             size.



   RETURNS

      Returns 'MemList' or NULL.



   BASES

      SysBase



   NOTES

      This func. iterates 'MemEntry' entries of 'MemList'
      to make sure 'Resident' matches the area.



   SEE ALSO

   EXAMPLE

      See 'a-mod_ktpresunlink.c' for a practical use.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MOD_#?
 ----------------------------------------------------------------------------

   NAME

      mod_kicktaglink() - Links custom module to the system
                          chains.



   SYNOPSIS

      res = mod_kicktaglink(kh);

      BOOL mod_kicktaglink(struct mod_ktl_head *);



   FUNCTION

      This function allows to add the module to the system.
      It then computes new checksum.



   INPUTS

      kh   - Default module header.



   RETURNS

      Returns boolean, TRUE for OK and FALSE for failure.



   BASES

      SysBase



   NOTES

      In 1.00 of this code there was a 'KickCheckSum' check
      that decided whether to link or not. Now function does
      discard broken KMP/KTP chains and always returns OK.



   SEE ALSO

      mod_kicktagunlink()



   EXAMPLE

      See src. code of 'a-mod_xxxmodule.c' for a practical
      application.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MOD_#?
 ----------------------------------------------------------------------------

   NAME

      mod_kicktagunlink() - Unlinks the module from system.



   SYNOPSIS

      mod_kicktagunlink(kh)

      void mod_kicktagunlink(struct mod_ktl_head *);



   FUNCTION

      This function strips the module of off the 'KickTagPtr'
      and its 'MemList' form 'KickMemPtr' and then computes
      new checksum.



   INPUTS

      kh - Module header.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      mod_kicktaglink()



   EXAMPLE

      See 'a-mod_xxxmodule.c' and 'a-mod_ktpresunlink.c' for a 
      practical use.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MOD_#?
 ----------------------------------------------------------------------------

   NAME

      mod_ktpresunlink() - Unlinks the module from system
                           knowing its 'Resident' structure.



   SYNOPSIS

      res = mod_ktpresunlink(rt);

      BOOL mod_ktpresunlink(struct Resident *);



   FUNCTION

      This function allows to unlink any resident module
      from system as found in the 'KickTagPtr' chain.



   INPUTS

      rt - 'Resident' structure as obtained from the chain.



   RETURNS

      Returns boolean, TRUE for OK and FALSE for failure.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MOD_#?
 ----------------------------------------------------------------------------

   NAME

      mod_ktprescount() - Counts 'KickTagPtr' resident modules.



   SYNOPSIS

      count = mod_ktprescount();

      LONG mod_ktprescount(void)



   FUNCTION

      This function counts res. mods('KickTagPtr' only) in the
      system.



   INPUTS

      No input.



   RETURNS

      Returns number of modules.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MOD_#?
 ----------------------------------------------------------------------------

   NAME

      mod_addmodule() - Create and add module to the system.



   SYNOPSIS

      ptr = mod_addmodule(af);

      void *mod_addmodule(struct mod_ade_feed *);



   FUNCTION

      With this function custom module creation is no longer
      heavy magic. All you have to do is to pass proper args
      and youre done.



   INPUTS

      af - Module feed structure.



   RETURNS

      Returns pointer to the allocation/module or NULL if no
      success.



   BASES

      SysBase



   NOTES

      'struct mod_ade_feed' is described in the header file.

      Dummy(no real life code/data) modules can be created
      by supplying 0 to 'af_dataptr' and/or 'af_datalen'.

      If you want to allocate just the space in the module
      then supply 'af_dataptr' with NULL and pick the amount
      of memory your module should have by supplying it to
      'af_datalen'(min 4 bytes). Also remeber that the dummy
      code will occupy first 4 bytes!



   SEE ALSO

      mod_delmodule()



   EXAMPLE

      ...

      #include <qdev.h>

      ...

      struct mod_ade_feed af;
      void *modptr;

      af.af_memflags = MEMF_LOCAL;
  
      af.af_memstart = QDEV_MOD_ADE_24BITLOWER;
  
      af.af_memend = QDEV_MOD_ADE_24BITUPPER;
  
      af.af_dataptr = NULL;
  
      af.af_datalen = 0;
  
      af.af_rtflags = RTF_COLDSTART;
  
      af.af_type = NT_UNKNOWN;
  
      af.af_pri = 0;
  
      af.af_ver = 0;
  
      af.af_nameptr = "dummymodule";
  
      af.af_idstrptr = "dummymodule 0.0 (Today)";

      if ((modptr = mod_addmodule(&af)))
      {
        /* 
         * Pressing Ctrl-E unloads the module. If you reboot
         * at this point then the module will be initialised
         * at startup.
        */
        Wait(SIGBREAKF_CTRL_E); 

        mod_delmodule(modptr);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MOD_#?
 ----------------------------------------------------------------------------

   NAME

      mod_delmodule() - Deletes freshly loaded(not used yet)
                        module.



   SYNOPSIS

      mod_delmodule(kh);

      void mod_delmodule(struct mod_ktl_head *);



   FUNCTION

      This function allows to strip the module that was just
      added to the system and isnt in use.



   INPUTS

      kh - Module header structure(pointer as obtained with 
           'mod_addmodule()').



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      Please note, if you obtain 'MemList' of certain module
      then dont pass its 'ml_ME[xxx].me_Addr' to this func!
      Only modules that were not used at all can be deleted
      permanently(with memory deallocation)!



   SEE ALSO

      mod_addmodule()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MOD_#?
 ----------------------------------------------------------------------------

   NAME

      mod_adddiskmodule() - Load and add module to the OS.



   SYNOPSIS

      kh = mod_adddiskmodule(fd, af);

      void *mod_adddiskmodule(LONG, struct mod_adi_feed *);



   FUNCTION

      Basically this function allows to load any Amiga hunk
      file that contains Resident(ROMTAG) structure. Usual
      stuff like: libraries, devices and some resources can
      be loaded with no prob.



   INPUTS

      fd - FileHandle as obtained with 'Open()' or virtual
           file handler.

      af - Disk module feed structure.



   RETURNS

      Returns pointer to the allocation/module or NULL upon
      failure.



   BASES

      SysBase, DOSBase



   NOTES

      'struct mod_adi_feed' is described in the qdev.h file.

      Member 'kh_ml.ml_Node.ln_Name' points at table of two
      LONGs where the very first one is the seglist and the
      other volatile result of 'mem_codereloc()' which will
      become invalid after reboot!

      This func. does check if module is already in memory.
      See file that describes structures for more info.



   SEE ALSO

      mod_deldiskmodule()



   EXAMPLE

      ...

      #include <qdev.h>

      ...

      struct mod_adi_feed af;
      void *kh;
      LONG fd;

      af.af_memflags = MEMF_LOCAL;
  
      af.af_memstart = QDEV_MOD_ADE_24BITLOWER;
  
      af.af_memend = QDEV_MOD_ADE_32BITUPPER;

      af.af_flags = 0;

      af.af_error = 0;

      if ((fd = Open("LIBS:version.library", MODE_OLDFILE)))
      {
        if ((kh = mod_adddiskmodule(fd, &af)))
        {
          /* 
           * Pressing Ctrl-E unloads the module right away.
          */
          Wait(SIGBREAKF_CTRL_E); 

          mod_deldiskmodule(kh);
        }
        else
        {
          FPrintf(Output(), "%ld\n", af->af_error);
        }

        Close(fd);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - MOD_#?
 ----------------------------------------------------------------------------

   NAME

      mod_deldiskmodule() - Deletes freshly loaded(not used
                            yet) disk module.



   SYNOPSIS

      mod_deldiskmodule(kh);

      void mod_deldiskmodule(struct mod_ktl_head *);



   FUNCTION

      This func. allows to strip the module that was just
      added to the system and isnt in use yet.



   INPUTS

      kh - Module header structure(pointer as obtained with 
           'mod_adddiskmodule()').



   RETURNS

      No output.



   BASES

      SysBase, DOSBase



   NOTES

      Please note, if you obtain 'MemList' of certain module
      then dont pass its 'ml_ME[xxx].me_Addr' to this func!
      Only modules that were not used at all can be deleted
      permanently(with memory deallocation)!



   SEE ALSO

      mod_adddiskmodule()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_devvercmp() - Allows to compare device vers. and/or
                        its id string.



   SYNOPSIS

      ver = nfo_devvercmp(restype, name, unit, minver, pattern);

      WORD nfo_devvercmp(LONG, UBYTE *, LONG, UWORD, UBYTE *);



   FUNCTION

      This function allows to quickly compare version and/or id
      string of a device that is on the disk or in the memory.



   INPUTS

      restype - Type of op. There are two types. One that allows
                to load the device into mem. for the inspection
                and one that scans the memory for that device.

      name    - Name of the object, with ".device" suffix.

      unit    - Unit of that device.

      minver  - Minimum version of the object.

      pattern - Pattern that can match something in id string.
                This argument can be NULL if there is no need to
                search for the pattern.



   RETURNS

      Function returns -1 on miss/error or object version.



   BASES

      SysBase, (DOSBase)



   NOTES

      None.



   SEE ALSO

      nfo_libvercmp()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_findgfxentry() - Allows to find either modeid or
                           resolution in the mon. database.



   SYNOPSIS

      modeid = nfo_findgfxentry(query, defdepth);

      ULONG nfo_findgfxentry(UBYTE *, ULONG *);



   FUNCTION

      This function is a textual interface to three modeid
      rel. funcs: 'nfo_findgfxrange()', 'nfo_findgfxreso()'
      and 'nfo_findgfxsm()' that allows to find modeid in
      the monitor database in a comfortable way.



   INPUTS

      query    - NULL terminated string containing at least
                 one textual argument in one of four numeral
                 systems.

      defdepth - New default depth to use when not specified
                 in the 'query'. This argument must be a ptr
                 to the integer. The very first 2 bytes must
                 contain the default depth and the other two
                 will contain users choice after this func.
                 is complete. NULL can be specified so that
                 the default depth will be switched to 2bits
                 when looking for screenmode.



   RETURNS

      Returns modeid or INVALID_ID.



   BASES

      SysBase, GfxBase, IntuitionBase, (MathIeeeXXXXBasBase)



   NOTES

      See source code for the default bit depth value.

      The template for 'query' is: "<[modeid] | [XxY[xD]]>
       [[rlow] [rhigh] | [monname]] [flag] [flag] [...]",
      where the very first argument must be either modeid
      or resolution. Second argument can be range or mon.
      name or flag, and the rest of the line can be flags.

      AmigaOS patterns can be used in '[monname]', but be
      careful as it may cause ranges to be unreliable!

      The flags are defined in 'graphics/displayinfo.h' in
      OS includes. Please note that you only pass literals
      after 'DIPF_IS_'. For example, having 'DIPF_IS_LACE'
      you just pass 'lace'.

      There are two very special flags, see the autodocs
      on 'nfo_findgfxreso()'.

      There is at least one  property  flag that may cause
      monitor name not to be recogized, its PAL. The cure
      for that is to type 'P?L' or 'PAL#?' if you mean the
      monitor.

      There is a very special monitor available called
      "ACTIVE" that translates to current monitor.

      The most safe setup is '640x400x4 cofact similar' as
      this is guaraneed to be found on OCS/ECS/AGA/CGX/P96
      independently of PAL or NTSC system.



   SEE ALSO

      nfo_findgfxreso(), nfo_findgfxsm(),
      nfo_findgfxrange()



   EXAMPLE

      ...

      ULONG modeid;

      /*
       * Find this or lower resolution anywhere with the 
       * default bit depth.
      */
      if (modeid = nfo_findgfxentry(
                     "640x480 similar", NULL) != 
                                               INVALID_ID)
      {
        ...
      }

      /*
       * Try to find this resolution in gfx boards only
       * using range.
      */
      if (modeid = nfo_findgfxentry(
        "640x480x7 0xAFFFF 0xFFFFFFFF", NULL) != 
                                               INVALID_ID)
      {
        ...
      }

      /*
       * Try to find this modeid.
      */
      if (modeid = nfo_findgfxentry(
                             "0x99004", NULL) != 
                                               INVALID_ID)
      {
        ...
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_findgfxrange() - Tries to determine range according
                           to the monitor name.



   SYNOPSIS

      res = nfo_findgfxrange(monname, rlow, rhigh);

      BOOL nfo_findgfxrange(UBYTE *, ULONG *, ULONG *):



   FUNCTION

      This function allows to determine effective range of the
      monitor in the database.



   INPUTS

      monname - NULL terminated string containing monitor name. 
                AmigaOS patterns can be used here! Name is case
                insensitive.

      rlow    - Input/output low range argument.

      rhigh   - Input/output high range argument.



   RETURNS

      Returns boolean. TRUE if range was found or FALSE if not.



   BASES

      (SysBase), (DOSBase), GfxBase



   NOTES

      This function expects input on range arguments before it
      can return monitor range.

      Important! You should always pass 0xFFFF in 'rlow' arg.
      to avoid false range detection(0 to 0xFFFF is considered
      startup monitor which can/will be doubled if you load
      the proper monitor!).



   SEE ALSO

      nfo_findgfxsm(), nfo_findgfxreso(), nfo_findgfxentry()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_findgfxreso() - Allows to find modeid according to
                          the resolution.



   SYNOPSIS

      modeid = nfo_findgfxreso(resox, resoy, depth, flags,
                                               rlow, rhigh);

      ULONG nfo_findgfxreso(ULONG, ULONG, ULONG, ULONG,
                                              ULONG, ULONG);



   FUNCTION

      This function allows to find 'modeid' of a given reso.
      in the monitor database.



   INPUTS

      resox - First resolution argument.

      resoy - Second resolution argument.

      depth - Depth in bits(1 to 32).

      flags - Property flags(can be 0).

      rlow  - Low range argument.

      rhigh - High range argument.



   RETURNS

      Returns modeid or INVALID_ID.



   BASES

      GfxBase, MathIeeeXXXXBasBase



   NOTES

      Arg. 'flags' is what 'graphics/displayinfo.h' defines.
      New flags are:

      DIPF_IS_YCOFACT - Allows to skew the Y resolution arg.
      so neighbour resolutions can be used. For instance if
      you request 640x400, but the system lacks it and there
      is something close to it like 640x480 or 640x512 then
      it will be utilised.

      DIPF_IS_SIMILAR - This flag will allow the final reso.
      to be smaller than what you expect. For example, lets
      say that you want 640x400, but the highest available
      resolution right now is 320x200, so it will be picked.
      You can combine DIPF_IS_YCOFACT with this flag too.

      If you want to increase probability of matching  color
      mapped screenmode then always pass 2 in the 'depth'.
      Function will do incrementory steps until 8 bits.

      If  you want  to increase  probability of matching RGB
      screenmode then always pass 32 in the 'depth'. Func.
      will do the decrementory steps until 15 bits.



   SEE ALSO

      nfo_findgfxsm(), nfo_findgfxentry(),
      nfo_findgfxrange()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

     nfo_findgfxsm() - Finds valid modeid in the database.



   SYNOPSIS

     dih = nfo_findgfxsm(modeid, flags, rlow, rhigh);

     APTR nfo_findgfxsm(ULONG, ULONG, ULONG, ULONG);



   FUNCTION

     This function tries to find 'modeid' in the database
     of loaded monitors and also makes sure it is usable.



   INPUTS

      modeid - Modeid from 0 to 0xFFFFFFFE.

      flags  - Property flags(can be 0).

      rlow   - Low range argument.

      rhigh  - High range argument.



   RETURNS

      Returns 'DisplayInfoHandle' like 'FindDisplayInfo()
      does or NULL if 'modeid' is invalid.



   BASES

      GfxBase



   NOTES

      Args 'rlow' and 'rhigh' are very useful if you want
      to narrow searching.



   SEE ALSO

      nfo_findgfxreso(), nfo_findgfxentry(),
      nfo_findgfxrange()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_fsquery() - General purpose filesystem query routine.



   SYNOPSIS

      success = nfo_fsquery(userlen, exlen, file, edval, 
                                  termsig, userdata, usercode);

      BOOL nfo_fsquery(ULONG, ULONG, UBYTE *, LONG, 
                 ULONG, void *, BOOL (*)(struct nfo_fsq_cb *));



   FUNCTION

      This function allows to query objects on a filesystem. It
      uses 'ExAll()' to do that and this 'ExAllData' structure
      that is available to user in the callback.



   INPUTS

      userlen  - General purpose buffer length that can be used
                 in the callback per 'nfo_fsquery()'. Passing 0
                 will give user 4 bytes in the callback member.

      exlen    - 'ExAll()' buffer length, see source code for a
                 minimum value.

      file     - File or path to 'Lock()'.

      edval    - One of ED_xxx val. as taken from 'dos/exall.h'.

      termsig  - Optional termination signal to get out of the
                 loop at any time. Values from 'AllocSignal()'
                 must be '(1L << sig)'. 0 means no term. sig.

      userdata - External user data/structure.

      usercode - Callback function.



   RETURNS

      Returns TRUE if everything went fine or FALSE otherwise.



   BASES

      SysBase, DOSBase



   NOTES

      Although this function was written in such a way that it
      can call itself in the callback, it is generally not wise
      to do so without constant stack size monitoring! This
      function will eat at most 120 bytes of stack. In theory
      this should allow up to 25 inner calls with 4096 bytes of
      stack, practically it is 15 before stack drops to 1024
      bytes. This is still most efficient way of listing files
      if you know you wont cross(by recursing) 15 directories.

      Callback structure is described in the header file.

      If termination signal was used then it must be cleared
      ('Signal(0L, signal)') after the function returns or else
      it will trigger further!



   SEE ALSO

   EXAMPLE

      ...

      void fsq_abspath(BOOL path, UBYTE *buf, LONG buflen, 
                                        UBYTE *base, UBYTE *visit)
      {
        txt_psnprintf(buf, buflen, "%s%c%s%c", 
                                        base, txt_needslash(base), 
                       visit, ((path) ? txt_needslash(visit) : 0));
      }

      BOOL fsq_cb(struct nfo_fsq_cb *fc)
      {
        if (fc->fc_ead->ed_Type == ST_FILE)
        {
          fsq_abspath(FALSE, fc->fc_userptr, fc->fc_userlen,
                                 fc->fc_file, fc->fc_ead->ed_Name);

          FPrintf(Output(), "   file: %s\n", (LONG)fc->fc_userptr);
        }
        else
        {
          fsq_abspath(TRUE, fc->fc_userptr, fc->fc_userlen,
                                 fc->fc_file, fc->fc_ead->ed_Name);

          FPrintf(Output(), " dir: %s\n", (LONG)fc->fc_userptr);

          if (nfo_stackreport(NULL) > 1024)
          {
            if ((nfo_fsquery(fc->fc_userlen, fc->fc_exlen, 
                      fc->fc_userptr, fc->fc_edval, fc->fc_termsig, 
                       fc->fc_userdata, fc->fc_usercode)) == FALSE)
            {
              /*
               * This is to get rid of irrelevant error messages.
              */
              if ((SetSignal(0L, 0L) & fc->fc_termsig) != 
                                                    fc->fc_termsig)
              {
                FPrintf(Output(), "error: cant access '%s'!\n", 
                                             (LONG)fc->fc_userptr);

                Signal(FindTask(NULL), fc->fc_termsig);
              }

              return FALSE;
            }
          }
          else
          {
            FPrintf(Output(), "   warning: stack overflow"
                                                    " avoided!\n");
          }
        }

        return TRUE;
      }

      int main(int argc, char **argv)
      {
        if (argc >= 2)
        {
          nfo_fsquery(1024, 1024, argv[1], ED_TYPE, SIGBREAKF_CTRL_C, 
                                                      NULL, fsq_cb);

          SetSignal(0L, SIGBREAKF_CTRL_C);
        }

        return 0;
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_fssmvalid() - Checks if 'fssm' contains true device
                        reference.



   SYNOPSIS

      ptr = nfo_fssmvalid(fssmptr);

      void *nfo_fssmvalid(void *);



   FUNCTION

      This function allows to filter out fake 'FileSysStartupMsg'
      pointers.



   INPUTS

      fssmptr - 'struct FileSysStartupMsg' pointer.



   RETURNS

      Returns passed pointer if 'fssm' is valid or NULL if it is
      not.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_getcmcolors() - Obtains desired amount of colors from
                          ColorMap and stores them in ColorSpec
                          (RGB4!).



   SYNOPSIS

      total = nfo_getcmcolors(cs, cm, start, amount);

      LONG nfo_getcmcolors(struct ColorSpec *, 
                                  struct ColorMap *, LONG, LONG);



   FUNCTION

      This function allows to fetch RGB values of requested pens
      and stores them in ColorSpec array. Obtained data is 4 bits
      per gun!



   INPUTS

      cs     - Pointer to start of ColorSpec.

      cm     - ColorMap pointer.

      start  - Start pen in a ColorMap.

      amount - Number of pens to extract.



   RETURNS

      Function returns how many pens were actually extracted.



   BASES

      IntuitionBase



   NOTES

      This func. regards total available pens in 'cm' plus checks
      for possible terminator in 'cs'. You should generally term.
      ColorSpec table before passing it to this func., so possible
      mem. trash can be avoided if you pass too much in 'amount'.



   SEE ALSO

   EXAMPLE

      ...

      struct Screen *screen;
      struct ColorSpec cs[] =
      {
        { 0, 0x0, 0x0, 0x0},
        { 1, 0x0, 0x0, 0x0},
        { 2, 0x0, 0x0, 0x0},
        { 3, 0x0, 0x0, 0x0},
        {-1, 0x0, 0x0, 0x0}
      };

      if ((screen = ctl_lockscreensafe(NULL)))
      {
        nfo_getcmcolors(&cs[0], screen->ViewPort.ColorMap, 0, 4);

        ctl_unlockscreensafe(screen);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_getconioreq() - Obtains an address of handler's
                          request from FileHandle.



   SYNOPSIS

      io = nfo_getconioreq(fd);

      struct IOStdReq *nfo_getconioreq(LONG);



   FUNCTION

      This function allows to extract console handler I/O
      from 'fd' by sending ACTION_DISK_INFO packet.
      


   INPUTS

      fd - FileHandle as obtained with 'Open()'.



   RETURNS

      Returns NULL on failure or IOStdReq pointer.



   BASES

      SysBase, DOSBase



   NOTES

      It is advised to 'CheckIO()' whether this is really
      a request.



   SEE ALSO

      nfo_getwinaddr(), nfo_iswindow(), nfo_getconunit()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_getconunit() - Obtains CU address from FileHandle.



   SYNOPSIS

      cu = nfo_getconunit(fd);

      struct ConUnit *nfo_getconunit(LONG);



   FUNCTION

      This func. allows to extract console internals from
      'fd' by sending ACTION_DISK_INFO packet.
      


   INPUTS

      fd - FileHandle as obtained with 'Open()'.



   RETURNS

      Returns NULL on failure or ConUnit pointer.



   BASES

      SysBase, DOSBase



   NOTES

      This func. may return Unit structure pointer that not
      not necessarily is ConUnit!



   SEE ALSO

      nfo_getwinaddr(), nfo_iswindow(), nfo_getconioreq()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_getscparams() - Obtains modeid and/or depth from
                          given 'screen'.



   SYNOPSIS

      res = nfo_getscparams(screen, modeid, depth);

      BOOL nfo_getscparams(struct Screen *, ULONG *, UWORD *);



   FUNCTION

      This function allows to get screenmode and/or depth in
      two ways. It can get modeid of currently passed 'screen'
      (which can be the active one) or from the 'Workbench'
      screen. Additionally if 'Workbench' is closed then it
      tries to load 'screenmode.prefs' from: 'ENV:Sys/' and if
      that fails then from archive at: 'EnvArc:Sys/' or from:
      'SYS:Prefs/Env-Archive/Sys/'.



   INPUTS

      screen - Screen pointer or NULL('Workbench') or -1 to
               read from file only.

      modeid - Address of ULONG container or NULL if data is
               not to be obtained.

      depth  - Address of UWORD container or NULL if data is
               not to be obtained.



   RETURNS

      Returns TRUE upon success or FALSE if something went
      wrong.



   BASES

      SysBase, (DOSBase), GfxBase, (IntuitionBase)



   NOTES

      Passing NULL to 'modeid' and 'depth' at the same time
      is considered no-op.

      If you want to fetch 'Workbench' params with NULL in
      'screen' then you should inspect 'modeid' with
      'nfo_findgfxsm()', because the result might be read
      from 'screenmode.prefs' and that need not to be valid!



   SEE ALSO

      ctl_getsmparams(), ctl_setsmparams()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_getdrimap() - Get a copy of DrawInfo pen mappings.



   SYNOPSIS

      result = nfo_getdrimap(drimap, screen);

      BOOL nfo_getdrimap(UWORD *, struct Screen *);



   FUNCTION

      This function copies screen's 'dri_Pens' to local table.



   INPUTS

      drimap - Locally supplied pen mapping table.

      screen - Screen from which mapping will be taken.



   RETURNS

      Returns TRUE is everything went fine or FALSE if it did
      not.



   BASES

      SysBase, IntuitionBase



   NOTES

      Lock the desired screen before requesting pen mappings!



   SEE ALSO

   EXAMPLE

      ...

      #include <proto/intuition.h>

      #include <qdev.h>
      ...

      struct Screen *screen;
      QDEV_NFO_DRIMAPTYPEI(drimap);

      if ((screen = ctl_lockscreensafe(NULL)))
      {
        if (nfo_getdrimap(drimap, screen))
        {
          if (drimap[BARDETAILPEN] != ~0)
          {
            ...
          }
        }

        ctl_unlockscreensafe(screen);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_getviscount() - Checks what is the visitor count
                          for a particular screen.



   SYNOPSIS

      count = nfo_getviscount(screen);

      LONG nfo_getviscount(struct Screen *);



   FUNCTION

      This function allows to see what is the visitor count
      on a certain, public screen.



   INPUTS

      screen - Screen structure.



   RETURNS

      Returns visitor count in range of -32768 to 32767 or
      -32769 if screen was not found.



   BASES

      IntuitionBase



   NOTES

      None.



   SEE ALSO

   EXAMPLE

     None.



   BUGS

     None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_getvisstate() - Checks if there are any visitors 
                          to a public screen.



   SYNOPSIS

      state = nfo_getvisstate(screen);

      BOOL nfo_getvisstate(struct Screen *);



   FUNCTION

      This function allows to check if there are any windows
      opened on a certain, public screen.



   INPUTS

      screen - Screen structure.



   RETURNS

      Returns TRUE if there are visitors or FALSE otherwise.



   BASES

      IntuitionBase



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_getwinaddr() - Obtains window pointer from FileHandle.



   SYNOPSIS

      win = nfo_getwinaddr(fd);

      struct Window *nfo_getwinaddr(LONG);



   FUNCTION

      This func. allows to obtain console Window ptr. from 'fd'
      by sending ACTION_DISK_INFO packet.
      


   INPUTS

      fd - FileHandle as obtained with 'Open()'.



   RETURNS

      Returns NULL on failure or pointer to a console Window or
      if 'fd' points at non-console handler its 'dol'(volume).



   BASES

      SysBase, DOSBase



   NOTES

      Please note that you never know what will be returned in
      case you have no idea what you have just 'Open()'ed! Its
      advised to use the 'nfo_iswindow()' function to make sure
      that the pointer is really a Window.



   SEE ALSO

      nfo_iswindow(), nfo_getconunit(), nfo_getconioreq()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_grepml() - Allows to scan and inspect Mountlist
                     entries.



   SYNOPSIS

      res = nfo_grepml(buflen, file, fd, termsig, pattern, 
                                             range, userdata, 
                                                    usercode);

      LONG nfo_grepml(LONG, UBYTE *, LONG, ULONG, UBYTE *, 
                                                LONG, void *, 
                               LONG (*)(struct nfo_sml_cb *));



   FUNCTION

      This function is 'nfo_scanml()' wrapper with the addition
      of ability to determine if Mountlist entry is a filesystem
      and if it can be considered valid before mounting.



   INPUTS

      buflen   - How long one line can be(in bytes). See src. 
                 code of 'a-mem_scanlbl.c' for absolute min.

      file     - Mountlist file name(this is just to skip name
                 from lock extraction, so this function can 
                 also work with emulated file descriptors).

      fd       - File descriptor as obtained with 'Open()'.

      termsig  - Additional termination signal.

      pattern  - AmigaOS pattern syntax to include or exclude
                 some devices. Passing NULL or "#?" means list
                 all devices. Devices must not be suffixed 
                 with the colon ':' .

      range    - Range that certain filesystem must not exceed.
                 Values must be expressed in gigabytes. Passing 
                 neg. values, like -4 for instance will impose 
                 4 gigs boundary, and also will enforce magic
                 checks against physical medium to make sure it
                 does not end unexpectedly(incl. 64bit command
                 tests). Passing 0 wont impose any limitations
                 and passing positive value will enforce checks
                 for the range only(no medium tests).

      userdata - User variable.

      usercode - User callback.



   RETURNS

      Function may -2 if there was an error, -1 if cb didnt 
      terminate iterator(not an error, it means file was read
      until EOF), and 0 and up if user requested term. of the
      call.



   BASES

      (SysBase), (DOSBase)



   NOTES

      Important! Following callback members: 'sc_sd.sd_unit', 
      'sc_sd.sd_flags' & 'sc_sd.sd_startup' are of mixed type!
      They can hold either string or integer! If the first byte
      is 0 then integer value should be inspected at bytes 1 to
      4, like this: '*((LONG *)&sc->sc_sd.sd_unit[1])' .

      Please note, every string you read from the callback must
      be copied before passing somewhere else! Do not adapt raw
      'sc', copy it with 'mem_copysmlcb()' first!

      It also informs about the errors in the 'sd_errors'('\n'
      separated keys who have broken data).

      This func. uses 'mem_scanlblncc()' to filter out C style
      comments, so 0 in return is considered "comments in bad
      shape"!!!

      This function sets 'sc_gerror' in the callback struct.,
      thus you have to look in there to determine what happend!
      See header file for error codes.



   SEE ALSO

      nfo_scanml(), mem_copysmlcb(), mem_freesmlcb()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_idcmptoindex() - Translates IDCMP flags to their
                           index values.



   SYNOPSIS

      index = nfo_idcmptoindex(flag);

      __interrupt LONG nfo_idcmptoindex(ULONG);



   FUNCTION

      This function is able to translate IDCMP_#? flags to
      their corresponding indexes.



   INPUTS

      flag - Single IDCMP flag.



   RETURNS

      Returns index. If given flag isnt known then returns
      last possible(dummy) index.



   BASES

      None.



   NOTES

      Index value can be in range of 0 to 31. In fact this
      routine can be used to translate not related flags
      into indexes. Lowest possible flag 0x00000001 maps
      to 0 and highest 0x80000000 to 31. 0x00000000 will
      also give 31!

      This function utilises 'switch()' for maximum speed.



   SEE ALSO

   EXAMPLE

      /*
       * An alternative implementation can be created like
       * this. Note however that passing 0 in 'flag' will
       * return 32 and not 31 nor 0!
      */
      LONG altidcmptoindex(ULONG flag)
      {
        return QDEV_HLP_POPCOUNT(((flag & -flag) - 1));
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_isblitable() - Tells if given image data can be
                         displayed.



   SYNOPSIS

      res = nfo_isblitable(ptr, modeid);

      BOOL nfo_isblitable(void *, ULONG);



   FUNCTION

      This func. takes a pointer and/or 'modeid' and checks
      if it can be displayed from that location.



   INPUTS

      ptr    - Memory address.

      modeid - Modeid that points at specific hardware such
               as CGX or P96 driven graphics board. Passing
               INVALID_ID disables the check.



   RETURNS

      Returns TRUE if data are free to be blitted to screen
      or FALSE that most probably means: use MEMF_CHIP ...



   BASES

      SysBase, (GfxBase), [(CyberGfxBase)]



   NOTES

      What you want to pass to this function is typically
      one of the plane pointers of a BitMap or Intuition
      Image data pointer.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_ischildofproc() - Checks if particular task/child 
                            belongs to this process.



   SYNOPSIS

      res = nfo_ischildofproc(child, proc);

      LONG nfo_ischildofproc(struct Task *, struct Process *);



   FUNCTION

      This function tries to determine if examined task is a
      child of "this" process.



   INPUTS

      child  - Pointer to a Task. Checked item.

      proc   - Pointer to a Process. Reference.



   RETURNS

      Returns 0 if the task is not a child of this process or
      or PC or LFRA(negative value) if it is.



   BASES

      SysBase, (DOSBase)



   NOTES

      You must really post-confirm somehow that this function
      did its job right. Detecting children of a handler proc
      is simple though as you can compare the names in most
      cases.

      This function may also return 0 if task has no standard
      stack or if process does not contain any seglists or if
      'proc' is not really a process.

      Function will call 'Forbid()' / 'Permit()' pair during
      examining.

      Its up to you to check if task or process are valid!
      This is not necessary if you are calling this function
      taking task addresses from iterator though.

      This code may be able to find 'proc' as 'child' if you
      are passing 'child' as received from task iterator when
      'proc' is not you!

      This function is sort of universal. Besides its concept
      can also be used to find a parent of a child. All you
      have to do is to pass different processes while 'child'
      is same.

      This func. will be unable to locate the child if it was
      granted a copy of parent's fake seglist! RexxMaster is
      known to do something like that.



   SEE ALSO

      nfo_issegremote()



   EXAMPLE

      None.



   BUGS

      -1-
      Warning! If there are multiple processes who are using
      residently loaded or ROM seglist, and these processes
      have children then all the children(independently of the
      respective parent) and these processes will be assumed
      'proc' children! This kinda sucks, and i have no idea
      how to fix this...

      A simple workaround for handlers is to compare device
      name against taskname, which seems to work in most cases
      but may/will be totally untrue for other programs.

      I have studied pretty much whole 'exec/' directory of
      includes, was stack sniffing, even overlooking AROS code
      and i did not find a thing that would allow to easily
      distinguish shared seglist processes. This seems really
      hopeless :-( .

      -2-
      As this function compares the PC against code segment it
      may be totally wrong in case CPU gets transferred beyond
      this segment...

      All is just fine when there are single JSR ops to outter
      code. But when they nest, such as when OS function wraps
      other OS function, like 'WaitPort() wraps 'Wait()' for
      instance then things change badly...

      -3-
      Happily not only the PC is taken into account, but sadly
      stack gets examined heuristically for the existence of
      local function return address within 10 first LONGs by
      BYTE stepping. This sucks, but that is still better than
      nothing.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_isdev64bit() - Checks if dev. understands 64bit cmds.



   SYNOPSIS

      res = nfo_isdev64bit(device, unit);

      LONG nfo_isdev64bit(UBYTE *, LONG);



   FUNCTION

      This function allows to query the device to see if it is
      able to work beyond 4 GiB boundary.



   INPUTS

      device - Standard AmigaOS device name including ".device".

      unit   - Unit of that device(0-255).



   RETURNS

      Returns ORed('|') flags(see header file) or 0 if the dev.
      does not support 64bit commands at all or -1 if there was
      an error.



   BASES

      (SysBase)



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      ...

      LONG query

      if ((query = nfo_isdev64bit("scsi.device", 0)) > -1)
      {
        if ((query & QDEV_NFO_ISDEV64BIT_NSD64) ==
                            QDEV_NFO_ISDEV64BIT_NSD64)
        {
          /* Device is NSD64 compliant        */
        }

        if ((query & QDEV_NFO_ISDEV64BIT_TD64)  ==
                             QDEV_NFO_ISDEV64BIT_TD64)
        {
          /* Device is (also) TD64 compliant  */
        }
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_isdirectory() - Checks if given lock points to a dir.



   SYNOPSIS

      res = nfo_isdirectory(lock);

      LONG nfo_isdirectory(LONG);



   FUNCTION

      This function will check if object is a directory or not.
      It can also detect softlinked directories(depends on fs!).



   INPUTS

      lock - Standard AmigaDOS lock.



   RETURNS

      Returns 1 if object is a directory, -1 if object is linked
      directory or 0 if it is something else.



   BASES

      DOSBase



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_isinstack() - Checks if given address fits task or
                        process stack space.



   SYNOPSIS

      res = nfo_isinstack(tc, addr);

      LONG nfo_isinstack(struct Task *, void *);



   FUNCTION

      This func. allows to check if given address is within
      stack of some task or process.



   INPUTS

      tc   - Task/process pointer.

      addr - Address to check.



   RETURNS

      Returns 0 if address is out of bounds or 1 if it fits
      current task/process stack space.



   BASES

      SysBase



   NOTES

      This function may also return 0 if passed 'tc' has no
      valid stack.

      This func. makes use of SIGF_SINGLE and also does the
      atomic context swap, so it may break 'Forbid()'!



   SEE ALSO

      nfo_ischildofproc(), nfo_issegremote()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_isonmemlist() - Checks if given address fits mem.
                          list.



   SYNOPSIS

      me = nfo_isonmemlist(ml, addr);

      struct MemEntry *nfo_isonmemlist(
                                  struct MemList *, void *);



   FUNCTION

      This func. allows to check if given address is within
      memory list.



   INPUTS

      ml   - Memory list pointer.

      addr - Address to check.



   RETURNS

      Returns NULL if address is out of bounds or pointer to
      'MemEntry' if it fits current memory list.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      nfo_isinstack(), nfo_isonlistofml()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_isonlistofml() - Checks if given address fits 
                           chain of memory lists.



   SYNOPSIS

      me = nfo_isonlistofml(list, addr);

      struct MemEntry *nfo_isonlistofml(
                                     struct List *, void *);



   FUNCTION

      This func. allows to check if given address is within
      some of the memory list as chained by the 'List'.



   INPUTS

      list - Pointer to 'List' of 'MemList's.

      addr - Address to check.



   RETURNS

      Returns NULL if address is out of bounds or an address
      to 'MemEntry' if it fits some memory list.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      nfo_isinstack(), nfo_isonmemlist()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_ispdev64bit() - Checks if partition's device is 64bit
                          compliant.



   SYNOPSIS

      res = nfo_ispdev64bit(device);

      LONG nfo_ispdev64bit(UBYTE *);



   FUNCTION

      This function allows to determine if the device that is
      used to support a filesystem understands 64bit commands.



   INPUTS

      device - Standard AmigaDOS device/volume name('DH0:').



   RETURNS

      Returns ORed('|') flags(see header file) or 0 if the dev.
      does not support 64bit commands at all, or -1 on error.



   BASES

      (SysBase), DOSBase



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_issegremote() - Checks if given process uses remote
                          seglist.



   SYNOPSIS

      res = nfo_issegremote(pr);

      LONG nfo_issegremote(struct Process *);



   FUNCTION

      This function allows to check if given process executes
      code that belongs to someone else.



   INPUTS

      pr   - Process address.



   RETURNS

      Returns 0 if the process is not using remote seglist or
      or PC(program counter), or -1 if PC is not available.



   BASES

      SysBase, (DOSBase)



   NOTES

      This function may also return 0 if passed 'pr' is not
      really a process.

      Function will call 'Forbid()' / 'Permit()' pair during
      examining.

      It up to you to check if process is valid! This is not
      necessary if you are calling this function taking task
      addresses from iterator though.



   SEE ALSO

      nfo_ischildofproc()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_istask() - Checks if given address points at TCB.



   SYNOPSIS

      res = nfo_istask(address);

      LONG nfo_istask(ULONG);



   FUNCTION

      Basically this func. allows to see if task is already
      there or not there.



   INPUTS

      address - Task address.



   RETURNS

      Returns 0 if  given address doesnt represent any task
      or 1 if it does.



   BASES

      SysBase



   NOTES

      This func. presumes that prompt ready "Shell Process"
      does not exist!



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_iswindow() - Checks if supplied address corresponds
                       really a Window.



   SYNOPSIS

      res = nfo_iswindow(win);

      BOOL nfo_iswindow(struct Window *);



   FUNCTION

      This func. allows to check if pointer references opened
      Window or not.



   INPUTS

      win - Pointer to check, a Window possibly.



   RETURNS

      Returns FALSE if addr. given does not point at a valid
      Window or TRUE if it does.



   BASES

      SysBase, IntuitionBase



   NOTES

      None.



   SEE ALSO

      nfo_getwinaddr(), nfo_getconunit()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_ktm() - Kool Task Manipulator as a function.



   SYNOPSIS

      addr = nfo_ktm(fd, name, flags, setarg);

      ULONG nfo_ktm(LONG, UBYTE *, ULONG, LONG);



   FUNCTION

      This function allows simple ops(priority change,
      signalling, freeze and activate) to be performed
      on tasks. It also allows just to search in tasks.



   INPUTS

      fd     - Output file descriptor, can be NULL.
               If you want output then pass 'Output()'.

      name   - NULL terminated string that can contain
               ordinary name or AmigaOS patterns or CLI
               number or task address in one of four
               numeral systems.

      flags  - Flags that  determine type of ops and/or
               how to search. See header file.

      setarg - This arg. is to be used in conjunction
               with flags who take an argument.



   RETURNS

      Returns task address or 0 on failure/miss.



   BASES

      SysBase, DOSBase



   NOTES

      This func. works in forbidden state which should
      make task freezing a lot safer.

      If 'name' was supplied with an int. then it will
      be dispatched following way. CLI process numbers
      should be in range of 1 to 4096 everything above
      is considered an address! Additionally negative
      integers mean: -1 = list tasks and non-CLI proc.
      -2 = list all tasks, -3 = list non-CLi processes
      -4 = list all CLI processes.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_libvercmp() - Allows to compare library vers. and/or
                        its id string.



   SYNOPSIS

      ver = nfo_libvercmp(restype, name, minver, pattern);

      WORD nfo_libvercmp(LONG, UBYTE *, UWORD, UBYTE *);



   FUNCTION

      This function allows to quickly compare version and/or id
      string of a library that is on the disk or in the memory.



   INPUTS

      restype - Type of op. There are two types. One that allows
                to load the library into mem. for the inspection
                and one that scans the memory for that library.

      name    - Name of the object, with ".library" suffix.

      minver  - Minimum version of the object.

      pattern - Pattern that can match something in id string.
                This argument can be NULL if there is no need to
                search for the pattern.



   RETURNS

      Function returns -1 on miss/error or object version.



   BASES

      SysBase, (DOSBase)



   NOTES

      None.



   SEE ALSO

      nfo_devvercmp()



   EXAMPLE

      ...

      if ((nfo_libvercmp(QDEV_NFO_XXXVERCMP_MEM, 
                                             "graphics.library",
                                                             40,
                                           "#?18.5.93#?")) > -1)
      {
        /* Original(40.68) "graphics.library" */
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_m68kcputype() - Obtains CPU type of m68k family in OS
                          notation.



   SYNOPSIS

      cpu = nfo_m68kcputype();

      ULONG nfo_m68kcputype(void);



   FUNCTION

      This  function  determines what  CPU  is  currently being
      used. The output is nearly what 'AttnFlags' would deliver.
      Nearly cus it is plain CPU type info and nothing more!
      


   INPUTS

      No input.



   RETURNS

      Returns CPU type. 0 == 68000.



   BASES

      SysBase



   NOTES

      Original 68060 detection code by Harry 'Piru' Sintonen.

      Reports correctly the 68060 CPU under the V39 and earlier.

      If you need to check for the CPU continously in your code
      then buffer the output in some variable cus calling this
      function frequently(especially on 68060) kills the system
      performance!



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_modeidcount() - Counts screenmode entires.



   SYNOPSIS

      count = nfo_modeidcount();

      ULONG nfo_modeidcount(void);



   FUNCTION

      This function allows to count screenmodes, so it can be
      used to check if particular monitor during startup works
      for instance.



   INPUTS

      No input.



   RETURNS

      Returns number of screenmodes.



   BASES

      GfxBase



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_scanlist() - Allows to scan a chain of lists.



   SYNOPSIS

      res = ULONG nfo_scanlist(lists, userdata, usercode);

      ULONG nfo_scanlist(ULONG *, void *, 
                          ULONG (*)(struct nfo_sct_cb *));



   FUNCTION

      This function allows to scan a chain of lists in one
      go.



   INPUTS

      lists    - Array of lists(their pointers as ints).
                 0 terminates the array.

      userdata - Userdata, can be NULL.

      usercode - Function that will be called each time
                 new entry is encountered.



   RETURNS

      It is actually up to programmer what this func. will
      return. Please note that to force this function to
      quit, callback must return something that is above 0!



   BASES

      SysBase



   NOTES

      This function is able to iterate 'struct List' and
      'struct MinList' only!

      Please note, system lists should be processed in
      forbidden state!

      This func. was written in such a way that 'Remove()'
      can safely be called on iterated entries.



   SEE ALSO

      nfo_scanturbo()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_scanturbo() - Iterates an array of doubly linked
                        lists in a fast way.



   SYNOPSIS

      res = nfo_scanturbo(list, udata, ucode);

      LONG nfo_scanturbo(
                LONG, void *, void (*)(struct nfo_stu_cb *));



   FUNCTION

      This func. does the delta scan of a list by accessing
      both ends at a time and passing them (nodes) to the CB.



   INPUTS

      list  - An array(table) of pointers to (struct List *)
              pointers.

      udata - User data pointer (NULL if no data).

      ucode - Callback function pointer.



   RETURNS

      Returns 0 if no stu_ures CB struct. member was altered
      by the user.



   BASES

      None.



   NOTES

      This func. indeed is faster than regular iteration even
      on entry miss since it only needs to do the (LIST / 2)!
      In worst case when the entry is located in the middle
      of the list it will be as slow as regular iteration but
      way faster when the entry is somewhere near bottom and
      the top of course.

      Processing speed also depends on what will be done in
      the CB. Simple address matching may turn out turbo, but
      string comparision not necessarily since you will have
      to compare two times in a row for head and tail nodes.

      Use the  QDEV_NFO_STURBO_MATCH() macro to quickly check
      given address against both nodes. This macro returns
      the node which matches the address.

      Use QDEV_NFO_STURBO_BREAK() macro after the successful
      match to stop iterator.

      Visit 'examples' directory to learn how to properly use
      this routine.



   SEE ALSO


      nfo_scanlist()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_screencount() - Counts screens in the system.



   SYNOPSIS

      count = nfo_screencount();

      ULONG nfo_screencount(void);



   FUNCTION

      This function allows to count opened screens in the
      system.



   INPUTS

      No input.



   RETURNS

      Number of opened screens.



   BASES

      SysBase, IntuitionBase



   NOTES

      This function does not make use the 'LockIBase()'
      / 'UnlockIBase()' pair due to highly likely race
      condition! The interrupts are turned off instead. 



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_stackreport() - Reports how much stack is free per
                          task.



   SYNOPSIS

      freestack = nfo_stackreport(addr);

      LONG nfo_stackreport(ULONG);



   FUNCTION

      With this function it is possible to obtain information
      about the free stack of any task.



   INPUTS

      addr - Address of a task, 0 = current task.



   RETURNS

      Returns free stack, if value is negative then it may mean
      that the task code is trashed.
      


   BASES

      SysBase



   NOTES

      It is wise to check if particular task has the stack at
      all with 'nfo_stackvalid()'.

      Do not call this function from pseudo-interrupts(private
      task exceptions)!

      This function utilises SIGF_SINGLE and also does the
      atomic context swap, so it may break 'Forbid()'!



   SEE ALSO

      nfo_stackvalid()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_stackvalid() - Tells if a task has the stack at all
                         and if it is valid.



   SYNOPSIS

      bool = nfo_stackvalid(addr);

      BOOL nfo_stackvalid(ULONG);



   FUNCTION

      This function checks stack presence and validity.



   INPUTS

      addr - Address of a task, 0 = current task.



   RETURNS

      Returns TRUE if stack is valid and FALSE if it is not.
      


   BASES

      SysBase



   NOTES

      Do not call this func. from pseudo-interrupts(private
      task exceptions)!

      This function utilises SIGF_SINGLE and also does the
      atomic context swap, so it may break 'Forbid()'!



   SEE ALSO

      nfo_stackreport()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_typeofgfxmem() - Returns type of memory that will
                           be used for graphics rendering.



   SYNOPSIS

      type = nfo_typeofgfxmem(modeid);

      ULONG nfo_typeofgfxmem(ULONG);



   FUNCTION

      This function can tell if it is okay to blit the gfx
      where it currently sits.



   INPUTS

      modeid - Modeid that will be checked for existence on
               CGX/P96 monitor list. Pass INVALID_ID if you
               dont want to check for that.



   RETURNS

      Can return what 'TypeOfMem()' returns or MEMF_PUBLIC
      if 'modeid' belongs to CGX or P96. The easiest way to
      to determine if rendering can be done using fast mem.
      is to check for MEMF_CHIP by doing logical AND('&').



   BASES

      SysBase, GfxBase, [CyberGfxBase]



   NOTES

      Do not rely on this func. when BitMap is to be used
      as a screen bitmap!



   SEE ALSO

      nfo_isblitable()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_waitback() - Wait/check for particular task or port.



   SYNOPSIS

      addr = nfo_waitback(name, flags, timeout, termsig);

      ULONG nfo_waitback(UBYTE *, ULONG, LONG, ULONG);




   FUNCTION

      This function allows, to wait or to check for particular
      task or port. Function is timeout and termination signal
      assisted.



   INPUTS

      name    - NULL terminated string containing either task
                name or process name(square bracket braced),
                or task address or process number(1-4096).
                Notation of integers is what 'cnv_AtoULONG()'
                can do. AmigaOS pattern matching works here.

      flags   - Where to perform the search. See header file.
                All flags that dont take the argument can be
                used, maybe except for QDEV_NFO_KTM_FMASS who
                has no effect.

      timeout - Timeout in seconds. 0 means one time check.

      termsig - Additional termination signal(masked one).



   RETURNS

      Returns an address of first found task/port or 0 when
      nothing was found.



   BASES

      SysBase, DOSBase



   NOTES

      This function allows to wait for multiple tasks or ports
      at once. Specify task or port names by delimiting them
      with commas(',') - Logical AND. You can also use pattern
      syntax using normal brackets and delimiting names inside
      with pipe('|') - Logical OR.

      When waiting for a port an address of the port will be
      returned and not the address of the task that did create
      it!



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_whichchipset() - System friendly chipset detection.



   SYNOPSIS

      chipset = nfo_whichchipset();

      ULONG nfo_whichchipset(void);



   FUNCTION

      This function can tell what chipset is currently being
      used. Routine will also return proper value if this is
      just an emulation. 



   INPUTS

      No input.



   RETURNS

      Returns type of chipset. See header file for defines.



   BASES

      GfxBase



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_getargsource() - Provides with alternative arg.
                           source(s).



   SYNOPSIS

       rdi = nfo_getargsource(loops, ttname, envname);

       struct RDArgs *nfo_getargsource(
                                   LONG *, UBYTE *, UBYTE *):



   FUNCTION

      This func. was written in such a way that the command
      line interface can also be used as a prefs parser.



   INPUTS

      loops   - Pointer to a datatype that will hold number
                of possible 'ReadArgs()' loops needed(2 max).
                This argument can be NULL.

      ttname  - Filename of object from which comment or
                tooltypes will be read. If this arg. is NULL
                then -this- binary will be the source.

      envname - Filename of the file that holds arguments. If
                this argument is NULL or file referenced cant
                be opened then 'ttname' will be utilised.



   RETURNS

      Function returns pointer to a cooked 'RDArgs' or NULL
      on error.



   BASES

      SysBase, DOSBase, IconBase



   NOTES

      This func. offers a way of creating preferences based
      on  existing argument set.  Main advantage is however
      possiblity  to self-contain  prefs in  binary file by
      using  its  tooltypes(if an icon is available) or
      comment field. Aside from that external configuration
      file can be used.

      Please  note  that  'envname'  has  priority over the
      tooltypes/comment field(if it does exist)!

      Standard AmigaDOS comments are supported both in the
      comment and in file. In case of file you can organise
      arguments line by line.

      Remember that file comments can be max 80 bytes long!



   SEE ALSO

      nfo_freeargsource()



   EXAMPLE

      ...

      struct RDArgs *rda[2] = {0, 0};
      struct RDArgs *rdi;
      void *rdiptr;
      LONG loops;
      LONG argv[1];


      rdi = nfo_getargsource(&loops, NULL, NULL);

      rdiptr = rdi;

      argv[0] = 0;

      while(loops--)
      {
        rda[loops] = ReadArgs("MYARG", argv, rdiptr);

        rdiptr = NULL;
      }

      Flush(Input());

      if ((rda[0]) || (rda[1]))
      {
        ...

        if (rda[0])
        {
          FreeArgs(rda[0]);
        }

        if (rda[1])
        {
          FreeArgs(rda[1]);
        }
      }

      if (rdi)
      {
        nfo_freeargsource(rdi);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 AMIGA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_freeargsource() - Frees alternative argument src.



   SYNOPSIS

       nfo_freeargsource(rdi);

       void nfo_freeargsource(struct RDArgs *);



   FUNCTION

      Frees what 'nfo_getargsource()' allocates.



   INPUTS

      rdi - Args ptr as cooked with 'nfo_getargsource()'.



   RETURNS

      No output.



   BASES

      SysBase, DOSBase



   NOTES

      None.



   SEE ALSO

      nfo_getargsource()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_clirun() - Allows to run program in a CLI.



   SYNOPSIS

      res = ctl_clirun(cmd, output, async);

      LONG ctl_clirun(UBYTE *, UBYTE *, BOOL);



   FUNCTION

      This func. allows to run program in a CLI either in sync
      with the current process or asynchronously always in OS
      native shell.



   INPUTS

      cmd    - Command to be launched.

      output - Where to redirect the output. Most common are:
               "CONSOLE:" or "NIL:", but that can be any other
               existing target. To redirect to a file you will
               have to create it first and allow in-exclusive
               access. Passing NULL means "CONSOLE:".

      async  - TRUE for async., FALSE for sync.



   RETURNS

      Returns -1 on error or the return code of the command.



   BASES

      DOSBase



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_makedir() - Creates a directory on a filesystem.



   SYNOPSIS

      res = ctl_makedir(objname);

      BOOL ctl_makedir(UBYTE *);



   FUNCTION

      This function simply creates a directory on a filesystem.



   INPUTS

      objname - Directory name.



   RETURNS

      Returns boolean, TRUE for OK and FALSE for failure.



   BASES

      DOSBase



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_getsmparams() - Allows to obtain modeid and/or depth
                          from 'screenmode.prefs' file.



   SYNOPSIS

      res = ctl_getsmparams(filename, modeid, depth);

      BOOL ctl_getsmparams(UBYTE *, ULONG *, UWORD *);



   FUNCTION

      This function allows to read modeid and/or depth from OS
      file that defines display properties.



   INPUTS

      filename - NULL terminated string holding filename.

      modeid   - Address of ULONG container or NULL if data is
                 not to be obtained.

      depth    - Address of UWORD container or NULL if data is
                 not to be obtained..



   RETURNS

      Returns TRUE upon success or FALSE if operation couldnt
      be completed.



   BASES

      SysBase, DOSBase



   NOTES

      Passing NULL to 'modeid' and 'depth' at the same time is
      considered no-op.



   SEE ALSO

      ctl_setsmparams(), nfo_getscparams()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_addrfrombase() - Allows to resolve an absolute address 
                           of a function (LBS).



   SYNOPSIS

      funcaddr = mem_addrfrombase(libbase, offset);

      APTR mem_addrfrombase(void *, LONG);



   FUNCTION

      This func is almost identical to 'mem_addrfromlvo()' macro
      except that it is also able to resolve pointers from local
      bases (LBS).



   INPUTS

      libbase - Base of a shared library. If you need to resolve
                from local base then pass through QBASEPOINTER()
                macro. For example: QBASEPOINTER(SysBase), ...

      offset  - Negative offset of particular func. as seen in
                LVO's or 'RKM' offsets.



   RETURNS

      An absolute address to a function.



   BASES

      None.



   NOTES

      See the notes of  'mem_addrfromlvo()'  for more details on
      proper usage.

      Resolving from local bases with  'mem_addrfromlvo()'  will
      result in particular call entry points and not the final
      routine addresses!



   SEE ALSO

      mem_addrfromlvo()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_findinfile() - Allows to search in a file (by FH).



   SYNOPSIS

      res = mem_findinfile(buflen, fd, data, datalen, hits);

      LONG mem_findinfile(ULONG, LONG, UBYTE *, LONG, LONG);



   FUNCTION

      With this one you are able to find either, a NULL terminated 
      string or bin. data in a file. The search is case sensitive!



   INPUTS

      buflen  - Buffer size used for sequential reading. It can be
                0 so the default value defined in 'mem_scanfile()'
                will be used. Generally 8192 to 65536 bytes is OK
                in most cases, but if you need to seek for 512 k
                pattern for instance then double that value here!
                Passing negative val. switches to case insensitive
                mode.

      fd      - Standard BCPLed FileHandle as get with 'Open()'.

      data    - NULL terminated string or binary data.

      datalen - Length of 'data', passing -1 will determine size of
                NULL terminated string.

      hits    - How many times data should occurr, passing -1 here
                will produce total number of hits per file, passing
                0 will report last occurrence at its location in
                bytes, passing 1 will try to find the very first 
                occurrence; numbers equal/higher than 1 may be used 
                to test if this much times 'data' appears to be in
                a given file.



   RETURNS

      May return byte at which 'data' was found or total 'data'
      occurrences, depending what was passed in 'hits' argument.
      It may also return these error codes: -2 if file could not
      be opened or there was not enough memory, -1 will be set
      if 'data' was not found anywhere in the file. 



   BASES

      SysBase, DOSBase



   NOTES

      Function can safely be terminated with SIGBREAKF_CTRL_C
      (Control-C).

      If termination signal was used then it must be cleared
      ('Signal(0L, signal)') after the function returns or else
      it will trigger some exception handler or something similar
      further.

      This function makes it possible to reuse the 'fd' and do
      the purely positional find until EOF.



   SEE ALSO

      mem_scanfile(), mem_findinfileq()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_findinfileq() - Allows to search in a file (by name).



   SYNOPSIS

      res = mem_findinfileq(buflen, file, data, datalen, hits);

      LONG mem_findinfileq(ULONG, UBYTE *, UBYTE *, LONG, LONG);



   FUNCTION

      With this one you are able to find either, a NULL terminated 
      string or bin. data in a file. The search is case sensitive!



   INPUTS

      buflen  - Buffer size used for sequential reading. It can be
                0 so the default value defined in 'mem_scanfile()'
                will be used. Generally 8192 to 65536 bytes is OK
                in most cases, but if you need to seek for 512 k
                pattern for instance then double that value here!
                Passing negative val. switches to case insensitive
                mode.

      file    - File(filename) to search in.

      data    - NULL terminated string or binary data.

      datalen - Length of 'data', passing -1 will determine size of
                NULL terminated string.

      hits    - How many times data should occurr, passing -1 here
                will produce total number of hits per file, passing
                0 will report last occurrence at its location in
                bytes, passing 1 will try to find the very first 
                occurrence; numbers equal/higher than 1 may be used 
                to test if this much times 'data' appears to be in
                a given file.



   RETURNS

      May return byte at which 'data' was found or total 'data'
      occurrences, depending what was passed in 'hits' argument.
      It may also return these error codes: -2 if file could not
      be opened or there was not enough memory, -1 will be set
      if 'data' was not found anywhere in the file. 



   BASES

      SysBase, DOSBase



   NOTES

      Function can safely be terminated with SIGBREAKF_CTRL_C
      (Control-C).

      If termination signal was used then it must be cleared
      ('Signal(0L, signal)') after the function returns or else
      it will trigger some exception handler or something similar
      further.



   SEE ALSO

      mem_scanfile(), mem_findinfile()



   EXAMPLE

      ...

      LONG res;

      if ((res = mem_findinfileq(0, "famous_ppl.db", 
                                     "Jay Miner", -1, 1)) >= 0)
      {
        UBYTE buf[256];
        BPTR fd;

        if ((fd = Open("famous_ppl.db", MODE_OLDFILE)))
        {
          Seek(fd, res, OFFSET_BEGINNING);

          FGets(fd, buf, 256);

          FPuts(Output(), buf);

          Close(fd);
        }
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_lzwcompress() - Super small LZW data compressor.



   SYNOPSIS

      pd = mem_lzwcompress(ptr, size);

      struct mem_pak_data *mem_lzwcompress(UBYTE *, ULONG);



   FUNCTION

      This function is just ideal for compressing text or
      bitmap data, where reduction on size is desired and
      also code size must be kept as small as possible.



   INPUTS

      ptr  - Pointer to memory region to be compressed.

      size - Size of that region.



   RETURNS

      Returns pointer to memory block that may contain the
      compressed data or NULL if no memory is available.



   BASES

      SysBase



   NOTES

      Always inspect 'pd_size' after compression, if it is
      0 then compressing this data is pointless.

      By def. 12 bit coding is being used. The header will
      contain that info. See source code for details.

      By default there is no checksum added to the packed
      data, its up to you how and what will be checksummed.



   SEE ALSO

      mem_lzwdecompress(), mem_lzwfree()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_lzwdecompress() - Super  small  LZW data  depacker.



   SYNOPSIS

      pd = mem_lzwdecompress(ptr, size);

      struct mem_pak_data *mem_lzwdecompress(UBYTE *, ULONG);



   FUNCTION

      This func. is just ideal for embeding it anywhere where
      compressed data is to be expected.



   INPUTS

      ptr  - Pointer to memory region to be decompressed.

      size - Size of that region.



   RETURNS

      Returns  pointer to memory  block that may contain  the
      decompressed data or NULL if no memory is available or
      data is corrupt or dont resemble LZW.



   BASES

      SysBase



   NOTES

      Always inspect 'pd_size' after decompression, if it is
      0 then decompressing this data was not possible.



   SEE ALSO

      mem_lzwcompress(), mem_lzwfree()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_lzwfree() - Frees compressed or decompressed mem.
                      block.



   SYNOPSIS

      mem_lzwfree(pd);

      void mem_lzwdecompress(struct mem_pak_data *pd);



   FUNCTION

      This function frees compressed or decompressed memory
      block.



   INPUTS

      pd - Memory block pointer.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      mem_lzwcompress(), mem_lzwdecompress()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_scanfile() - Allows to work on data stream using 
                       callback.
                       

   SYNOPSIS

      res = mem_scanfile(
                     buflen, fd, termsig, userdata, usercode);

      LONG mem_scanfile(ULONG, LONG, ULONG, void *, 
                               LONG (*)(struct mem_sfe_cb *));



   FUNCTION

      This is general puprose function that streams the data on 
      a given file descriptor until EOF. Buffer is orginised in
      such a way that the former buffer is divided by two, so
      each time there is a need to read new portion of data,
      lower halve of the buffer(block) is being copied to the
      upper halve and then new data is being read to the lower
      halve. This way there is an illusion of continuous data.
      User can hook in thru a callback in which all the magic
      can be done.



   INPUTS

      buflen   - Buffer len. Passing 0 will enforce hardcoded
                 buffer size(see function source).

      fd       - File desc./handle as obtained with 'Open()'.

      termsig  - Optional termination signal, 0 means no term. 
                 sig.. Private signal as obtained with 
                 'mysig = AllocSignal()' must be '(1L << mysig)'
                 before passing!

      userdata - General purpose argument, user will want to 
                 pass its variable or structure here.

      usercode - Callback function that returns LONG aligned
                 result.



   RETURNS

      Function returns -2 if memory allocation failed. Value of 
      -1 must be used to indicate FALSE and 0 and up for TRUE
      in the callback.



   BASES

      SysBase, DOSBase



   NOTES

      Callback structure is described in the header file.

      If termination signal was used then it must be cleared
      ('Signal(0L, signal)') after the function returns or
      else it will trigger some exception handler or something
      similar further.



   SEE ALSO

      mem_findinfile()



   EXAMPLE

      See source code of 'a-mem_findinfile.c' for a practical
      application.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_scanlbl() - Allows to work on lines as read from 
                      file.

                       

   SYNOPSIS

      res = mem_scanlbl(buflen, fd, termsig, userdata, 
                                                usercode);

      LONG mem_scanlbl(ULONG, LONG, ULONG, void *, 
                           LONG (*)(struct mem_lbl_cb *));



   FUNCTION

      This is general puprose function that streams the data 
      on  a given file descriptor line by line until EOF. 
      User can hook in thru a callback in which all the magic
      can be done.



   INPUTS

      buflen   - Total line length. Passing 0 will enforce
                 hardcoded buffer size(see function source).

      fd       - File desc./handle as obtained with 'Open()'.

      termsig  - Optional termination signal, 0 means no term. 
                 sig.. Private signal as obtained with 'mysig 
                 = AllocSignal()' must be '(1L << mysig)'
                 before passing!

      userdata - General purpose argument, user will want to 
                 pass its variable or structure here.

      usercode - Callback function that returns LONG aligned
                 result.



   RETURNS

      Function returns -2 if memory allocation failed. Value
      of -1 must be used to indicate FALSE and 0 and up for
      TRUE in the callback.



   BASES

      SysBase, DOSBase



   NOTES

      Please note, this func. allocates twice the 'buflen',
      so if you add 'lc_bufptr + lc_buflen' you will be able
      to access the other half!

      There is also 'mem_scanlblncc()' variant of this func.
      that filters out C style comments. Beware, this func.
      swaps 'lc_lineptr', so it points to the other half of
      'lc_bufptr', which means you dont sum vars like above
      in order to access extra space, you just use it as it
      is! This function also informs about broken comments
      by returning 0!

      Callback structure is described in the header file.

      If termination signal was used then it must be cleared
      ('Signal(0L, signal)') after the function returns or
      else it will trigger some exception handler or
      something else further.



   SEE ALSO

   EXAMPLE

      See source code of 'a-mem_scanlblncc.c' on how to use
      callbacks.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_allocarray() - Allocate non-continous(cell based)
                         array.



   SYNOPSIS

      ptr = mem_allocarray(blksize, size, nodes, flags);

      void *mem_allocarray(ULONG, ULONG, ULONG, ULONG);



   FUNCTION

      This function tries to allocate array of desired size
      in  such a way that even heavily fragmented memory is
      not an issue.



   INPUTS

      blksize - Single cell size(will be rounded to the
                nearest power of 2). Currently this can
                be a value ranging from 4096 to 65536.

      size    - Size of one element. This cannot exceed
                'blksize'! Anyway, the widest possible
                datatype is QUAD.

      nodes   - How many elements.

      flags   - Standard memory flags.



   RETURNS

      Returns  ptr to  newly created array or NULL if there
      is not enough memory.



   BASES

      SysBase



   NOTES

      Returned pointer is not what you think, so do not read
      / write it standard way! Use 'mem_accessarray()' macro
      to poke.



   SEE ALSO

      mem_freearray(), mem_accessarray()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_accessarray() - Access cell based  array element.



   SYNOPSIS

      addr = mem_accessarray(ptr, size, node);

      ULONG mem_accessarray(ULONG *, ULONG, ULONG);



   FUNCTION

      This  function allows to access particular element in
      the array both for reading and writing.



   INPUTS

      ptr    - Array address.

      size   - Size of one element.

      node   - Element(index) to access.



   RETURNS

      Returns addr. as an integer that should be typecasted
      to the word size spcified in 'size'.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      mem_allocarray(), mem_freearray()



   EXAMPLE

      ...

      void *array;

      /*
       * Create an array as big as 524288 elements, where
       * each element is 4 bytes wide. It is something like
       * you would declare 'ULONG array[524288]' but wont
       * of course require large continous memory block.
      */
      if ((array = mem_allocarray(4096,
                       sizeof(ULONG), 524288, MEMF_PUBLIC)))
      {
        /*
         * Write something to element 123456.
        */
        (*(ULONG *)mem_accessarray(
                array, sizeof(ULONG), 123456)) = 0xFEEDF00D;

        ...

        mem_freearray(array);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_freearray() - Free cell based array.



   SYNOPSIS

      mem_freearray(ptr);

      void mem_allocarray(void *);



   FUNCTION

      This function frees the memory occupied by the array.



   INPUTS

      ptr    - Array address.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      mem_allocarray(), mem_accessarray()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_alloccluster() - Allocate memory for the cluster.



   SYNOPSIS

      ptr = mem_alloccluster(size, chunks, flags);

      void *mem_alloccluster(ULONG, ULONG, ULONG);



   FUNCTION

      This func.  allocates memory for the cluster of equally
      sized chunks.



   INPUTS

      size   - Size of one chunk.

      chunks - How many chunks.

      flags  - Memory flags. Oring('|') MEMF_LARGEST will
               allow clusters to be linked, which means that
               if this cluster becomes empty new one will be
               allocated and linked in.



   RETURNS

      Returns ptr to newly created cluster or NULL if there
      is not enough memory.



   BASES

      SysBase



   NOTES

      Please note that you will need to sacrifice 4 bytes per
      chunk, which can be quite a memory for big clusters...

      Always LONG align structures that will be then granted
      that memory if you need to BPTRize them!

      Cluster can be shared across tasks or processes with no
      problems.

      Currently there is no way to track in-cluster allocs
      with common debug tools.

      Keep in mind that  MEMF_CLEAR is only valid for chunks
      that were obtained for a first time. Releasing them and
      obtaining once again does not clear the memory!



   SEE ALSO

      mem_freecluster(), mem_getmemcluster(),
      mem_freememcluster()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_freecluster() - Frees prev. allocated cluster.



   SYNOPSIS

      mem_freecluster(ptr);

      void mem_freecluster(void *);



   FUNCTION

      This function frees cluster memory as allocated with
      'mem_alloccluster()'.



   INPUTS

      ptr - Cluster pointer.



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      mem_alloccluster(), mem_getmemcluster(),
      mem_freememcluster()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_getmemcluster() - Obtains pointer to a chunk from
                            the given cluster.



   SYNOPSIS

      mem = mem_getmemcluster(ptr);

      void *mem_getmemcluster(void *);



   FUNCTION

      This func.  gets pointer to free chunk from the cluster.



   INPUTS

      ptr - Cluster pointer.



   RETURNS

      Function will return pointer to the mem. whose size was
      set in 'mem_alloccluster()' or NULL if there is no free
      chunks left.



   BASES

      SysBase



   NOTES

      Use this function if you need to allocate lots of small
      and always equal portions of memory frequently as this
      function really prevents heavy mem. fragmentation plus
      it is much faster than 'AllocMem()' alone!

      Keep in mind that  MEMF_CLEAR is only valid for chunks
      that were obtained for a first time. Releasing them and
      obtaining once again does not clear the memory!



   SEE ALSO

      mem_alloccluster(), mem_freecluster(),
      mem_freememcluster()



   EXAMPLE

      ...

      void *cluster;
      void *ptra;
      void *ptrb;

      /*
       * This will alloc. 8 chunks 32 bytes each in one block.
      */
      if ((cluster = mem_alloccluster(32, 8, MEMF_PUBLIC)))
      {
        /*
         * Now you can use that chunk area, eg. 32 bytes!
        */
        if ((ptra = mem_getmemcluster(cluster)))
        {
          /*
           * And another...
          */
          if ((ptrb = mem_getmemcluster(cluster)))
          {
            ...

            /*
             * Please note that deallocating chunks who wont
             * be freed during runtime is not necessary as
             * last call will clean it all up.
            */
            mem_freememcluster(ptrb);
          }

          mem_freememcluster(ptra);
        }

        mem_freecluster(cluster);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_freememcluster() - Returns chunk back to cluster.



   SYNOPSIS

      mem_freememcluster(mem);

      void mem_freememcluster(void *);



   FUNCTION

      This func.  sets current chunk attribute to reusable.



   INPUTS

      mem - Chunk ptr as obtained with 'mem_getmemcluster()' 



   RETURNS

      No output.



   BASES

      SysBase



   NOTES

      Important! Clusters that were linked in are never being
      freed when they are not used! The only way get back the
      memory is to 'mem_freecluster()'. 



   SEE ALSO

      mem_alloccluster(), mem_freecluster(),
      mem_getmemcluster()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_copysmlcb() - Allows to copy 'nfo_sml_cb' struct.



   SYNOPSIS

      newsc = mem_copysmlcb(sc);

      struct nfo_sml_cb *mem_copysmlcb(struct nfo_sml_cb *);



   FUNCTION

      This function will make a copy of what 'nfo_scanml()'
      passes to the callback function.



   INPUTS

      sc       - Pointer to 'nfo_sml_cb' structure.



   RETURNS

      Func. may return NULL if there is not enough memory.



   BASES

      SysBase



   NOTES

      Function aligns memory space of each member to long,
      so that immediate BCPL conversion is possible. All
      you have to do is to decrease 1 byte per string ptr
      and make the BCPL.

      Do not pass the result of this func. to the mounter
      CB = 'dmt_mountcb()' or your computer will explode!

      This function does not make a copy of parser related
      variables!



   SEE ALSO

      mem_freesmlcb(), nfo_grepml(), nfo_scanml()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_freesmlcb() - Frees copied 'nfo_sml_cb' struct.



   SYNOPSIS

      mem_freesmlcb(sc);

      void mem_copysmlcb(struct nfo_sml_cb *);



   FUNCTION

      This function will free what 'mem_copysmlcb()' has
      allocated.



   INPUTS

      sc       - Pointer to 'nfo_sml_cb' structure.



   RETURNS

      No outout.



   BASES

      SysBase



   NOTES

      None.



   SEE ALSO

      mem_copysmlcb(), nfo_grepml(), nfo_scanml()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_readsrcimage() - Transforms 'struct Images' as found
                           in C source code into fully qualified
                           images.



   SYNOPSIS

      im = mem_readsrcimage(errptr, fname);

      struct Image *mem_readsrcimage(LONG *, UBYTE *);



   FUNCTION

      This func. works a bit like C compiler except that it only
      compiles Intuition  Images along with all necessary tables
      that contain bitmap and palette data.



   INPUTS

      errptr - Error pointer of LONG or NULL if no errors are to
               be reported.

      fname  - Filename of C header file that contains 'Image's.



   RETURNS

      Returns pointer to 'Image' that may reference other 'Image'
      through 'im->NextImage'. NULL will be returned on error.



   BASES

      SysBase, DOSBase



   NOTES

      All separate Image structures as found in the source file
      will form a chain in the order they were found. Do not pre
      reference them, just leave the 'NextImage' set to NULL.

      This function tries to be smart in the way that it manages
      to attach RGB4/RGB32 palettes to the image! As you know
      palettes are not referenced by the Image structure so this
      is somewhat guessing. Palette pointers are located after
      'NextImage' member. First ULONG contains RGB4 address and
      the next one RGB32.

      This function does not analyze symbol syntax, so it is
      possible to construct 'Image's by hand. The only rule here
      is to use the very same "prefix" for all tables. Lets say
      that the 'Image' structure is called 'myimage' then image
      data and palettes must start with 'myimage' too. It is not
      necessary to signify RGB4 or RGB32 per palette. Word width
      is the factor! So in case of bitmap, data symbol should be
      'myimagedata' and palette 'myimagepal4', 'myimagepal32'.

      This function detects datatypes directly, no typdefs are
      possible. The only datatypes supported are 'ULONG' and
      'UWORD'!

      Size of the table must be known at the time of parsing cus
      only one pass is taken.



   SEE ALSO

      mem_freesrcimage()



   EXAMPLE

      ...

      struct Image *im;
      struct Image *ptr;
      UWORD *rgb4;
      ULONG *rgb32;

      if ((im = mem_readsrcimage(NULL, "picture.h")))
      {
        ptr = im;

        while (ptr)
        {
          /*
           * Palette can be extracted like this or by creating a
           * wrapper structure. Please test the extracted address
           * for NULL though!
          */
          ptr++;

          rgb4 = (UWORD *)*(ULONG *)ptr;

          rgb32 = (ULONG *)ptr;

          rgb32 = (ULONG *)*(ULONG *)++rgb32;

          ptr--;

          ...

          ptr->NextImage;
        }

        mem_freesrcimage(im);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_freesrcimage() - Frees post-compiled Intutition Image
                           or many of them if they were chained.



   SYNOPSIS

      mem_freesrcimage(im);

      void mem_readsrcimage(struct Image *);



   FUNCTION

      This func. frees the memory that is occupied by the Image
      and its tables.



   INPUTS

      im - Image pointer as obtained with 'mem_readsrcimage()'.



   RETURNS

      No output.



   BASES

      SysBase, DOSBase



   NOTES

      Please always use this function instead of 'FreeVec()' as
      'Image's are not direct allocations and only this routine
      knows how to do it right!



   SEE ALSO

      mem_readsrcimage()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_getsystime() - Requests absolute time from OS.



   SYNOPSIS

      nfo_getsystime(tv, tz);

      __nifunc __interrupt void nfo_getsystime(
                              struct timeval *, void *);



   FUNCTION

      This function allows to obtain current time. It is
      a 'gettimeofday()' wrapper in most cases. Only the
      Amiga uses 'timer.device/GetSysTime()'.



   INPUTS

      tv - OS dependant timeval structure.

      tz - Time zone pointer(optional).



   RETURNS

      No output.



   BASES

      SysBase, TimerBase



   NOTES

      This func. does not 'OpenDevice("timer.device",..)'
      but seeks for it in the system and borrows library
      base. Once the base is found it gets buffered!

      Unfortunately 'GetSysTime()' does not offer micro
      precision, so it will be 0...



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_scanml() - Allows to scan and inspect Mountlist
                     entries.



   SYNOPSIS

      res = nfo_scanml(buflen, file, fd, termsig, pattern, 
                                              defde, userdata, 
                                                    usercode);

      LONG nfo_scanml(LONG, UBYTE *, LONG, ULONG, UBYTE *, 
                                    struct DosEnvec *, void *, 
                               LONG (*)(struct nfo_sml_cb *));



   FUNCTION

      This function allows to scan and inspect Ml. entries.
      Mountlist args will be put into logical vars as found in
      the callback structure. Each callback call will be done
      as soon as new device entry will be encountered or upon
      EOF.



   INPUTS

      buflen   - How long one line can be(in bytes). See src. 
                 code of 'a-mem_scanlbl.c' for absolute min.

      file     - Mountlist file name(this is just to skip name
                 from lock extraction, so this function can 
                 also work with emulated file descriptors).

      fd       - File descriptor as obtained with 'Open()'.

      termsig  - Additional termination signal.

      pattern  - AmigaOS pattern syntax to include or exclude
                 some devices. Passing NULL or "#?" means list
                 all devices. Devices must not be suffixized 
                 with the colon ':' . If you need to preset
                 the 'sd_dosdevice' in the CB then stuff '\e'
                 (ESC character) as a first byte and append
                 the handler name, like '\eMYDEVICE'.

      defde    - Default 'DosEnvec' that will be set per entry
                 before filling it with the data obtained from
                 file. Can be NULL so all the members will be
                 0.

      userdata - User variable.

      usercode - User callback.



   RETURNS

      Function may -2 if there was an error, -1 if cb didnt 
      terminate iterator(not an error, it means file was read
      until EOF), and 0 and up if user requested term. of the
      call.



   BASES

      SysBase, (DOSBase)



   NOTES

      Important! Following callback members: 'sc_sd.sd_unit', 
      'sc_sd.sd_flags' & 'sc_sd.sd_startup' are of mixed type!
      They can hold either string or integer! If the first byte
      is 0 then integer value should be inspected at bytes 1 to
      4, like this: '*((LONG *)&sc->sc_sd.sd_unit[1])' .

      Please note, every string you read from the callback must
      be copied before passing somewhere else! Do not adapt raw
      'sc', copy it with 'mem_copysmlcb()' first!

      It also informs about the errors in the 'sd_errors'('\n'
      separated keys who have broken data).

      This func. uses 'mem_scanlblncc()' to filter out C style
      comments, so 0 in return is considered "comments in bad
      shape"!!!



   SEE ALSO

      nfo_grepml(), mem_copysmlcb(), mem_freesmlcb()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_debugprintf() - Produces output according to the
                          formating options and sends it over
                          the built-in serial port.



   SYNOPSIS

      txt_debugprintf(maxwrite, fmt, ...);

      __nifunc __interrupt LONG txt_debugprintf(
                                   LONG, const UBYTE *, ...);



   FUNCTION

      This func. wraps 'txt_vcbpsnprintf()' to form something
      like 'kprintf()'.



   INPUTS

      maxwrite - Maximum write size.

      fmt      - Formatting string.

      ...      - Additional arguments.



   RETURNS

      Returns what 'txt_vpsnprintf()' returns(amount of text
      transferred).



   BASES

      None.



   NOTES

      This function acts and behaves like 'kprintf()' so progs
      like: 'sushi' or 'sashimi' allow redirection.

      This func. is guaranteed to return after 'maxwrite' bytes
      of potential garbage.

      Warning!  This function may arbitrate with 'Disable()' /
      'Enable()' pair ! See 'Makefile'.

      See 'txt_vpsnprintf()' for available formatting options.

      Beware! Using '%b' with BCPL data on stack may result in
      address mess! All addresses to be BCPLed must be multiple
      of 4! See 'testsuite/textfuncs-test.c' for more details.

      Can be used without defining and initialising any bases,
      and/or without opening any libraries.

      If is safe to call this function from tasks and software
      interrupts. It is even safe to allow others to call this
      function from your context.

      Variable list 'txt_vdebugprintf()' exists.



   SEE ALSO

      txt_vcbpsnprintf(), txt_vpsnprintf()



   EXAMPLE

      ...

      txt_debugprintf(32,
                  "my task: 0x%08lx\n", (ULONG)FindTask(NULL));



   BUGS

      None known.                                  



 ----------------------------------------------------------------------------
                                 PORTA - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_strboth() - Compares two strings using cascaded
                      comparison.



   SYNOPSIS

      res = txt_strboth(str1, str2);

      LONG txt_strboth(const UBYTE *, const UBYTE *);



   FUNCTION

      This function allows to compare the string using standard
      comparison function and if that doesnt result in equality,
      tries AmigaOS patterns on it(provided 'str2' contains
      them). 



   INPUTS

      str1 - NULL terminated string against which comparing will
             be done.

      str2 - NULL terminated string, that will be compared. AOS
             patterns allowed(more on patterns can be found in 
             Commodore-Amiga 'RKM').



   RETURNS

      Returns positive value if strings are equal or pattern
      matching was successful.



   BASES

      (SysBase), (DOSBase)



   NOTES

      There is also case insensitive variant of this function,
      called: 'txt_striboth()'. Please note that by def. there
      is no UTF-8 support in case insensitive version, but it
      may do support it when compiled to use 'utility.library'
      (-D___QDEV_UTILITYCHAREQ)! Plus both of these have ptr
      checking wrappers called: 
      'txt_pstrboth()' and 'txt_pstriboth()' respectively.

      This function was made so special pattern characters as
      used in AmigaOS pattern parser can be compared too.



   SEE ALSO

   EXAMPLE

      ...

      /*
       * AmigaOS pattern parser discards brackets from the text
       * so effectively you cant compare bracketed strings, this
       * function allows that and even more.
      */
      UBYTE *data = "(Bracketed)";

      if ((txt_strboth(data, "(Bracketed)")))
      {
        if ((txt_strboth(data, "#?Bracketed#?")))
        {
          ...
        }
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 PORTA - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_strpat() - Compares two strings using AmigaOS pattern
                     matching facility.



   SYNOPSIS

      res = txt_strpat(str1, str2);

      LONG txt_strpat(const UBYTE *, const UBYTE *);



   FUNCTION

      This function is able to compare fully or partially two
      strings using AmigaOS pattern syntax.



   INPUTS

      str1 - NULL terminated string against which comparing will
             be done.

      str2 - NULL terminated string, that will be compared. AOS
             patterns allowed(more on patterns can be found in 
             Commodore-Amiga 'RKM').



   RETURNS

      Returns positive value if strings are equal or pattern
      matching was successful.



   BASES

      SysBase, DOSBase



   NOTES

      There is also case insensitive variant of this function,
      called: 'txt_stripat()'. Please note that by def. there
      is no UTF-8 support in case insensitive version, but it
      may do support it when compiled to use 'utility.library'
      (-D___QDEV_UTILITYCHAREQ)! Plus both of these have ptr
      checking wrappers called: 
      'txt_pstrpat()' and 'txt_pstripat()' respectively.

      Please note, case sensitive pattern matching is about
      3 times slower than using ordinary string matching funcs.
      such as 'txt_strstr()', 'txt_strcmp()' and up to 10 times
      slower when using case insensitive variant!!! 

      This function cannot compare strings that contain special
      pattern characters and are not related to patterns! If you
      want standard comparison plus pattern comparison then use 
      'txt_strboth()'.



   SEE ALSO

   EXAMPLE

      ...

      UBYTE *data = "Your CPU is: 68040\n";

      if ((txt_strpat(data, "#?68040#?")))
      {
        ...
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - CNV_#?
 ----------------------------------------------------------------------------

   NAME

      cnv_ALtoULONG() - Converts stringified, digit grouped
                        number to integer.



   SYNOPSIS

      success = cnv_ALtoULONG(string, value, flags);

      LONG cnv_ALtoULONG(UBYTE *, ULONG *, ULONG);



   FUNCTION

      This func. is able to convert numbers who were digit
      grouped by the locale affected string generators, thus
      the letter 'L' in the function name.



   INPUTS

      string - NULL terminated string that contains a number.

      value  - Pointer to integer variable. It must be of the
               size pointer is! Dont pass pointers to 'UBYTE',
               or 'UWORD' sized datatypes or memory will be
               trashed!!!

      flags  - Base(2,8,10,16), see header file for defines.



   RETURNS

      Function will return -1 if converted value in negative.
      0 will be returned if conversion failed and 1 if the
      value is positive. Value of -666 will be returned if
      there was an underflow and 666 for overflow.



   BASES

      None.



   NOTES

      This func. is a wrapper to 'cnv_AtoULONG()' which skips
      on white spaces, single quotes, commas and dots.

      UQUAD variant of this function exists.



   SEE ALSO

      cnv_AtoULONG(), cnv_ULONGtoA()



   EXAMPLE

      ...

      ULONG value = 0;
      UBYTE *string;

      /*
       * This is essentially possible with this function.
      */
      string = "  0 x 1000 2000  ";

      if ((cnv_ALtoULONG(string, &value, QDEV_CNV_UXXXFBE_H)))
      {
        if (value == 0x10002000)
        {
          ...
        }
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - CNV_#?
 ----------------------------------------------------------------------------

   NAME

      cnv_AtoULONG() - Converts stringified number to integer.



   SYNOPSIS

      success = cnv_AtoULONG(string, value, flags);

      LONG cnv_AtoULONG(UBYTE *, ULONG *, ULONG);



   FUNCTION

      This function is able to convert what 'cnv_ULONGtoA()'
      is able to produce to ULONG or LONG integer.



   INPUTS

      string - NULL terminated string that contains a number.

      value  - Pointer to integer variable. It must be of the
               size pointer is! Dont pass pointers to 'UBYTE',
               or 'UWORD' sized datatypes or memory will be
               trashed!!!

      flags  - Bases(2,8,10,16), see header file for defines.
               If this is 0 then autodetection will be done.



   RETURNS

      Function will return -1 if converted value in negative.
      0 will be returned if conversion failed and 1 if the
      value is positive. Value of -666 will be returned if
      there was an underflow and 666 for overflow.



   BASES

      None.



   NOTES

      This func. automagically determines hexadecimals who beg.
      with '$' or '0x', octals who begin with 'q' or '0o' or
      binaries who begin with '%' or '0b' prefixes. If it cant
      determine type of number then defaults to decimal unless
      'base' is not something else.

      All notations mentioned above can be signed(macros for
      handling signed datatypes exist).

      Values can be aligned to as many zeroes as possible.

      Please note that the binary conversion is the slowest,
      but still several times faster when compared to 'ixemul's
      'atoi()'.

      UQUAD variant of this function exists.



   SEE ALSO

      cnv_ULONGtoA(), cnv_ULONGtoBITS()



   EXAMPLE

      ...

      ULONG value = 0;
      UBYTE *string = "35007";

      if ((cnv_AtoULONG(string, &value, QDEV_CNV_UXXXFBE_D)))
      {
        if (value == 35007)
        {
          ...
        }
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - CNV_#?
 ----------------------------------------------------------------------------

   NAME

      cnv_ULONGtoA() - Stringifies the int. in one of four
                       ways.



   SYNOPSIS

      ptr = cnv_ULONGtoA(buffer, value, flags);

      UBYTE *cnv_ULONGtoA(UBYTE *, ULONG, ULONG);



   FUNCTION

      This function allows to represent the integer visually
      as: binary or octal or decimal or hexadecimal.



   INPUTS

      buffer - Buffer space in which converted value will
               appear. The buffer size is defined under the
               QDEV_CNV_UXXXLEN in header file and it is an
               absolute minimum. Also, dont rely on this
               input as a pointer, use returned pointer!!!

      value  - ULONG value.

      flags  - Generally flags are organised in such a way
               that 0xaabbccdd means: aa - number of zeros
               to pad, bb - type of prefix per num. system,
               cc - lower or upper case letters in hex.,
               dd - type of output(bin., oct., dec., hex.)
               See header file for exact values. You simply
               OR('|') them.



   RETURNS

      Returns pointer to the start of the converted value.



   BASES

      None.



   NOTES

      If 'flags' are 0 then standard decimal conversion will
      be performed.

      Please note, decimal conversion is the slowest of all
      numeral systems, cus it relies on division which is
      generally slow.

      This function allows signedness(use respective macro).

      UQUAD variant of this function exists.



   SEE ALSO

      cnv_AtoULONG(), cnv_ULONGtoBITS() 



   EXAMPLE

      ...

      UBYTE buf[QDEV_CNV_UXXXLEN];

      FPrintf(Output(), "%s\n", (LONG)cnv_ULONGtoA(buf, 999,
                                          QDEV_CNV_UXXXFALGN));



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - CNV_#?
 ----------------------------------------------------------------------------

   NAME

      cnv_ULONGtoBITS() - Determines how many bits in the value.



   SYNOPSIS

      bits = cnv_ULONGtoBITS(value);

      ULONG cnv_ULONGtoBITS(ULONG);



   FUNCTION

      With this function you can find out exactly how many bits
      are needed for a given value. 



   INPUTS

      value - ULONG value.



   RETURNS

      Number of bits.



   BASES

      None.



   NOTES

      UQUAD variant of this function exists.



   SEE ALSO

      cnv_AtoULONG(), cnv_ULONGtoA()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - CTL_#?
 ----------------------------------------------------------------------------

   NAME

      ctl_relocdrimap() - Primitive DrawInfo pen mappings
                          relocator.



   SYNOPSIS

      ctl_relocdrimap(drimap, startpen, depth);

      void ctl_relocdrimap(UWORD *, LONG, UWORD);



   FUNCTION

      This function allows to relocate pen mappings by adding or
      subtracting start of group of pens reflected at different
      location.



   INPUTS

      drimap   - Pen mapping table.

      startpen - Start of first pen of the group(-128 to 127).

      depth    - Depth of the screen.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      Warning, 'startpen' can cause wrap-around of the mapping
      value! For example if 'startpen' is 8 and the pen mapping
      value is 251 it will be then 3 = ((UBYTE)251 + 8).

      Pen mappings who exceed 'depth' will be just fit down!

      Mapping table must be ~0 terminated!



   SEE ALSO

   EXAMPLE

      See 'EXAMPLE' of 'ctl_openconscreen()' on how to use.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - DEV_#?
 ----------------------------------------------------------------------------

   NAME

      dev_sizeingigs() - Allows to compute size of the area
                         and express it in gigabytes.



   SYNOPSIS

      size = dev_sizeingigs(cyls, bsize, bpt, heads);

      LONG dev_sizeingigs(LONG, LONG, LONG, LONG);



   FUNCTION

      This function computes disk area size based upon four
      common values and expresses it in gigabytes.



   INPUTS

      cyls  - Medium cylinders.

      bsize - Medium block size.

      bpt   - Medium blocks per track.

      heads - Medium heads.



   RETURNS

      Returns size in gigabytes.



   BASES

      None.



   NOTES

      By default this func. does not use QUAD datatype to
      compute the value! See source code for more details.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - DOS_#?
 ----------------------------------------------------------------------------

   NAME

      dos_bcopydevice() - Creates device name from NULL term.
                          string.
                         


   SYNOPSIS

      res = dos_bcopydevice(out, in, osize);

      UBYTE *dos_bcopydevice(UBYTE *, UBYTE *, LONG);



   FUNCTION

      This function copies NULL terminated string into out.
      buffer in such a way that all the letters become upper
      cased plus additional colon(':') gets removed. Output
      in non-scambled BSTR!!!



   INPUTS

      out   - Output buffer.

      in    - Input buffer.

      osize - Output buffer size.

 

   RETURNS

      Returns pointer to first letter in the output buffer
      or NULL if string could not be copied.



   BASES

      None.



   NOTES

      Please note, even though output is non-scrambled BSTR
      the string is NULL terminated!

      What you pass into 'out' must really be LONG aligned!
      Do not use stack!



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_addrfromlvo() - Allows to determine an absolute address 
                          of a function in opened, shared lib.



   SYNOPSIS

      funcaddr = mem_addrfromlvo(libbase, offset);

      APTR mem_addrfromlvo(void *, LONG);



   FUNCTION

      This function can be very helpful if an absolute address of 
      certain shared library function is needed.



   INPUTS

      libbase - Base of a shared library, like: SysBase, DOSBase, 
                ...

      offset  - Negative offset of particular function as seen in 
                LVO's or 'RKM' offsets.



   RETURNS

      An absolute address to a function.



   BASES

      None.



   NOTES

      Important! If you intend to use this function to call LVO
      functions then you must declare the base locally and setup
      the relative jump register! This is typically to be A6.

      Important! Local function pointers must include proper arg
      registers! Refer to FD files.



   SEE ALSO

      mem_addrfrombase()



   EXAMPLE

      ...

      /*
       * As long as you do not intend to call the function this
       * will work even with global bases.
      */
      LONG (*_Output)();

      _Output = mem_addrfromlvo(DOSBase, -60); 
                                           /* -60 == Output() */
      ...

      /*
       * But if you want to call something then local base must
       * be register assisted and no middle code can be called!
      */
      LONG res;

      res =
      ({
        register struct ExecBase *SysBase asm("a6") =
                                   (*((struct ExecBase **) 4));
        ULONG (*_AvailMem)(register ULONG asm("d1")) =
                                mem_addrfromlvo(SysBase, -216);
                                       /* -216 == AvailMem() */
        register ULONG amount asm("d0");

        amount = _AvailMem(MEMF_CHIP);

        amount;
      })

      ...



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_csumchs32() - CHS type 3 checksumming routine.



   SYNOPSIS

      sum = mem_csumchs32(memptr, memlen);

      ULONG mem_csumchs32(void *, LONG);



   FUNCTION

      This function allows to compute CHS type 3 checksum for
      a given memory region.



   INPUTS

      memptr - Memory pointer.

      memlen - Memory length.



   RETURNS

      Returns checksum or (ULONG)~0 if given pointer in NULL.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

      mem_csumeor32(), mem_csumint32()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_csumeor32() - EOR with additional base checksum.



   SYNOPSIS

      sum = mem_csumeor32(memptr, memlen, base);

      ULONG mem_csumeor32(void *, LONG, ULONG);



   FUNCTION

      This func. allows to compute EOR checksum for a given
      memory region.



   INPUTS

      memptr - Memory pointer.

      memlen - Memory length.

      base   - Additional base.



   RETURNS

      Returns checksum or 'base' if given pointer in NULL.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

      mem_csumchs32(), mem_csumint32()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_csumint32() - INT checksumming routine.



   SYNOPSIS

      sum = mem_csumint32(memptr, memlen);

      ULONG mem_csumint32(void *, LONG);



   FUNCTION

      This func. allows to compute INT checksum for a given
      memory region.



   INPUTS

      memptr - Memory pointer.

      memlen - Memory length.



   RETURNS

      Returns checksum or (ULONG)0 if given pointer in NULL.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

      mem_csumeor32(), mem_csumchs32()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_fnv128hash() - 128 bit FNV-1a routine that works
                         on memory region.



   SYNOPSIS

      hash = mem_fnv128hash(vuq128, memptr, memlen);

      ULONG mem_fnv128hash(VUQ128 *, void *, LONG);



   FUNCTION

      This function allows to hash memory region using FNV1a
      routine.



   INPUTS

      vuq128 - Pointer to 128bit datatype. Can be NULL so the
               only output will be lower 32 bits through the
               'hash'.

      memptr - Data pointer.

      memlen - Length of that data.



   RETURNS


      Returns low 32 bits of 'vuq128' or its initializer if
      data is 0.



   BASES

      None.



   NOTES

      This function should produce the very same values as
      the 'txt_fnv128hash()' one.

      Important! Arg. in 'vuq128' must generally be inited
      to 0 before passing! This will not clobber the builtin
      initializer!

      Beware this routine is 0 sensitive, which means it may
      be unsuitable to hash some nasty memory blocks!

      This routine is very slow so use only when absolutely
      necessary.



   SEE ALSO

      txt_fnv128hash(), txt_fnv64hash()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_fnv64hash() - Allows to hash data in the memory.



   SYNOPSIS

      hash = mem_fnv64hash(vuq, memptr, memlen);

      ULONG mem_fnv64hash(VUQUAD *, void *, LONG);



   FUNCTION

      This function allows to hash memory region using FNV1a
      routine.



   INPUTS

      vuq    - Pointer to 64bit datatype. Can be NULL so the
               only output will be lower 32 bits through the
               'hash'.

      memptr - Data pointer.

      memlen - Length of that data.



   RETURNS

      Returns 32 or 64 value or its initilizer if data is 0.



   BASES

      None.



   NOTES

      This function should produce the very same values as
      the 'txt_fnv64hash()' one.

      Important! Arg. in 'vuq' must generally be initialised
      to 0 before passing! This will not clobber the builtin
      initializer!

      Beware this routine is 0 sensitive, which means it may
      be unsuitable to hash some nasty memory blocks!



   SEE ALSO

      txt_fnv64hash(), mem_pjw64hash()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - MEM_#?
 ----------------------------------------------------------------------------

   NAME

      mem_pjw64hash() - Allows to hash data in the memory.



   SYNOPSIS

      hash = mem_pjw64hash(vuq, memptr, memlen);

      ULONG mem_pjw64hash(VUQUAD *, void *, LONG);



   FUNCTION

      This function allows to hash memory region using
      simplified PJW routine extended to work on 64bit
      datatype.



   INPUTS

      vuq    - Pointer to 64bit datatype. Can be NULL so the
               only output will be lower 32 bits through the
               'hash'.

      memptr - Data pointer.

      memlen - Length of that data.



   RETURNS

      Returns 32bit or 64bit value or 0 if all the data is
      0.



   BASES

      None.



   NOTES

      This function should produce the very same values as
      the 'txt_pjw64hash()' one.

      Important! Arg. in 'vuq' must generally be initialised
      to 0 before passing!



   SEE ALSO

      txt_pjw64hash(), mem_fnv64hash()



   EXAMPLE

      /*
       * Example on how to compute the checksum.
      */
      ...

      VUQUAD vuq;
      UBYTE buffer[256];
      LONG readlen;
      LONG fd;

      vuq.vuq_hi = 0;

      vuq.vuq_lo = 0;

      if ((fd = Open("ram:disk.info", MODE_OLDFILE)))
      {
        while ((readlen = Read(fd, buffer, 256)))
        {
          mem_pjw64hash(&vuq, buffer, readlen);
        }

        Close(fd);
      }

      FPrintf(Output(), "CSUM = 0x%08lx%08lx\n",
                              vuq.vuq_hi, vuq.vuq_lo);

      ...



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_isconsole() - Check if string equals to '*' or
                        'CONSOLE:'.



   SYNOPSIS

      res = nfo_isconsole(ptr, len);

      BOOL nfo_isconsole(UBYTE *, LONG);



   FUNCTION

      This  func. allows to check if given string equals
      to std console input as then passed to the 'Open()'
      function.



   INPUTS

      ptr  -  NULL or non-NULL terminated text pointer.

      len  -  Length of that text.



   RETURNS

      Returns TRUE if string is a potential console call
      or FALSE otherwise.



   BASES

      None.



   NOTES

      This func.  does not compare on byte by byte basis
      but uses bitwise ops which should be faster than
      'txt_stricmp()' or 'txt_memicmp()'. The comparison
      is case insensitive!



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_ismode15khz() - Checks if passed modeid is 15kHz one.



   SYNOPSIS

      res = nfo_ismode15khz(modeid);

      BOOL nfo_ismode15khz(ULONG);



   FUNCTION

      This function can tell if passed modeid is PAL or NTSC one.



   INPUTS

      modeid - Standard modeid.



   RETURNS

      Returns TRUE if modeid is 15kHz one or FALSE if it is not.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_isprime() - Tells if given integer is a prime.



   SYNOPSIS

      res = nfo_isprime(num);

      BOOL nfo_isprime(LONG);



   FUNCTION

      This  function allows to see if given integer is a
      prime.



   INPUTS

      num - The integer.



   RETURNS

      Returns TRUE if number is prime or FALSE if it is
      not.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_nearestprime() - Returns nearest prime integer.



   SYNOPSIS

      prime = nfo_nearestprime(num);

      LONG nfo_nearestprime(LONG);



   FUNCTION

      This function allows to find nearest prime integer.
      according to input.



   INPUTS

      num - The integer.



   RETURNS

      Always returns a prime.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - NFO_#?
 ----------------------------------------------------------------------------

   NAME

      nfo_numdivisors() - Determines how many divisors given
                          number has.



   SYNOPSIS

      div = nfo_numdivisors(num);

      LONG nfo_numdivisors(LONG);



   FUNCTION

      This func.   can tell how many divisors for particular
      number.



   INPUTS

      num - The interger.



   RETURNS

      Returns number of divisors.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_bstrncat() - Concatenate BCPL string to NULL term.
                       string.



   SYNOPSIS

      len = txt_bstrncat(dst, src, dlen);

      LONG txt_bstrncat(UBYTE *, LONG, LONG);



   FUNCTION

      This function appends BCPL string to NULL terminated one.



   INPUTS

      dst  - Destination string.

      src  - Source BCPL string.

      dlen - Destinantion length.



   RETURNS

      Returns amount of data that was put in the destination.
      Overflow will be indicated by inverting the value, so neg.
      result means that the data was truncated. 0 will mean that
      no copy took place.



   BASES

      None.



   NOTES

      This function is slightly different than normal 'strncat()'
      instead of length of source string it expects the dest. 
      length which is much safier on non-MMU systems.

      This function can successfully be used as 'strncpy()' as
      well. In such case you have to remember to NULL the first
      byte of the destination buffer.

      This func. comes with two more variants: 'txt_bstrncatlc()'
      & 'txt_bstrncatuc()' who allow to transform the text on the
      fly to lower or upper case.

      Truncation can be detected by adding buffer size to the
      output of the function. If it is 1 then the last call did
      truncate the output.

      Beware! Never create BCPL address to data put on stack!!!
      All addresses to be BCPLed must be multiple of 4!



   SEE ALSO

   EXAMPLE

      ...

      #define SIZE 256

      ...

      /*
       * This is how BCPL string look likes, first byte is length 
       * of the string and then the string. Pay attention to this
       * 'static' it causes data not to be put on stack.
      */
      static UBYTE bcplstr[] = {11, 'B', 'C', 'P', 'L', ' ', 
                                     's', 'u', 'c', 'k', 's', '!'};
      LONG bcplptr = QDEV_HLP_MKBADDR(bcplstr); /* Non-direct ptr! */
      UBYTE buf[SIZE] = {0};

      txt_bstrncat(buf, bcplptr, SIZE);



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_bstrnpcat() - Concatenate BCPL string to NULL term.
                        string.



   SYNOPSIS

      res = txt_bstrnpcat(dst, src, dlen);

      LONG txt_bstrnpcat(LONG *, LONG, LONG *);



   FUNCTION

      This function appends BCPL string to NULL terminated one.



   INPUTS

      dst  - Pointer to a var. that holds dest. address.

      src  - Source BCPL string.

      dlen - Pointer to a var. that holds dest. len.



   RETURNS

      Returns 0 if everything went fine or negative or positive
      value on overflow.



   BASES

      None.



   NOTES

      This function does not iterate to find end of the string,
      so it is much faster and much safier than 'txt_bstrncat()',
      but you should still NULL terminate the very first byte of
      the string!

      This f. comes with two more variants: 'txt_bstrnpcatlc()' &
      'txt_bstrnpcatuc()' who allow to transform the text on the
      fly to lower or upper case.

      To compute how long the string is you just subtract 'dlen'
      from 'dst' capacity.

      Beware! Never create BCPL address to data put on stack!!!
      All addresses to be BCPLed must be multiple of 4!



   SEE ALSO

   EXAMPLE

      ...

      #define SIZE 256

      ...

      /*
       * This is how BCPL string look likes, first byte is length 
       * of the string and then the string. Pay attention to this
       * 'static' it causes data not to be put on stack.
      */
      UBYTE buf[SIZE] = {0};
      static UBYTE bcplstr[] = {11, 'B', 'C', 'P', 'L', ' ', 
                                     's', 'u', 'c', 'k', 's', '!'};
      LONG bcplptr = QDEV_HLP_MKBADDR(bcplstr); /* Non-direct ptr! */
      LONG size = SIZE;
      LONG addr = (LONG)&buf[0];

      txt_bstrnpcat(&addr, bcplptr, &size);



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_strnvacat() - Combo string creation/concatenation.



   SYNOPSIS

      res = txt_strnvacat(dst, dlen, vfmt, ...);

      LONG txt_strnvacat(LONG *, LONG *, UBYTE *, ...);



   FUNCTION

      This function allows to build NULL terminated string
      with the help of formatting options as found in the
      'txt_vpsnprintf()' function. This function can be used
      to concatenate too.



   INPUTS

      dst  - Pointer to a var. that holds dest. address.

      dlen - Pointer to a var. that holds dest. len.

      vfmt - Formatting string.

      ap   - Variable args pointer.



   RETURNS

      Ret. 0 upon success or 1 upon overflow or -1 if there
      is no room.



   BASES

      None.



   NOTES

      Beware! Using '%b' with BCPL data on stack may result
      in address mess! All addresses to be BCPLed must be
      multiple of 4!



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.                                  



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_datdat() - Finds x byte data in y = x + z byte data
                     buffer.



   SYNOPSIS

      ptr = txt_datdat(dat1, len1, dat2, len2);

      UBYTE *txt_datdat(const UBYTE *, LONG,
                          const UBYTE *, LONG);



   FUNCTION

      This function allows to search for a binary data in
      greater or equal than that data binary buffer.



   INPUTS

      dat1 - Binary data in which search process will take 
             place.

      len1 - Size of that data.

      dat2 - Binary data that will be seek for in 'dat1'.

      len2 - Size of that data.



   RETURNS

      Important! Function returns pointer past the beginning of
      found 'dat2', so in other words you will have to 'ptr -=
      len2;' to achieve start of that found pattern.



   BASES

      None.



   NOTES

      There is also case insensitive variant of this function,
      called: 'txt_datidat()'. Please note that by def. there
      is no UTF-8 support in case insensitive version, but it
      may do support it when compiled to use 'utility.library'
      (-D___QDEV_UTILITYCHAREQ)! Plus both of these have ptr
      checking wrappers called: 
      'txt_pdatdat()' and 'txt_pdatidat()' respectively.



   SEE ALSO

   EXAMPLE

      See source code of 'a-mem_findinfile.c' for a practical
      application.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_fixquotes() - Unescapes quotes in an array of args.



   SYNOPSIS

      txt_fixquotes(array, arlen, flags);

      void txt_fixquotes(LONG **, LONG, LONG);



   FUNCTION

      Allows to unescape and/or rem. escaped quotes from NULL
      terminated strings attached to the array of addresses.



   INPUTS

      array  - Array of pointers to NULL terminated strings.

      arlen  - Length of the array expressed in LONGs (number
               of elements).

      flags  - Prefixation type and removal control. Up to 3
               prefixes can be specified.



   RETURNS

      No output.



   BASES

      None.



   NOTES

      Warning! This f. changes contents of the input strings!

      It is possible to stuff own prefixes in flags argument
      as first three bytes are designated to carry them.

      This function should be used it two passes. In the first
      pass you will be given number of actual arguments, so you
      know how big array is required. In the second pass you
      parse the string. It is wise to allocate the count + 1 so
      you can NULL terminate it.

      Escaped quotes are not unescaped! This routine handles 3
      types of escaped quotes (double quotes specifically). The
      Amiga syntax: *" - asterisk+quote, regular syntax: \" -
      backslash+quote or: '" - single quote+quote.



   SEE ALSO

      txt_parseline()



   EXAMPLE

      None.

      

   BUGS

      None known.                                  



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_fnv128hash() - Allows to hash any NULL terminated
                         string using 128 bit FNV-1a.


   SYNOPSIS

      hash = txt_fnv128hash(vuq128, str);

      ULONG txt_fnv128hash(VUQ128 *, UBYTE *);



   FUNCTION

      This function allows to hash a string using FNV128a
      routine. Thanks to prime numbers and 128bit datatype
      this routine has extremally low repetition rate.



   INPUTS

      vuq128 - Ptr to 128bit datatype. Can be NULL so the
               only output will be lower 32 bits through the
               'hash'.

      string - NULL terminated string.



   RETURNS

      Returns low 32 bits of 'vuq128' or hash base if string
      is NULL.



   BASES

      None.



   NOTES


      Case  insensitive version of this routine exists and
      its called 'txt_fnv128ihash()'.



   SEE ALSO

      mem_fnv128hash(), mem_fnv64hash()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_fnv64hash() - Allows to hash any NULL term. string.



   SYNOPSIS

      hash = txt_fnv64hash(vuq, str);

      ULONG txt_fnv64hash(VUQUAD *, UBYTE *);



   FUNCTION

      This function allows to hash a string using FNV64a
      routine. Thanks to prime numbers and 64bit datatype
      this routine has extremally low repetition rate.



   INPUTS

      vuq    - Pointer to 64bit datatype. Can be NULL so the
               only output will be lower 32 bits through the
               'hash'.

      string - NULL terminated string.



   RETURNS

      Returns 32bit or 64bit value or hash base if string is
      NULL.



   BASES

      None.



   NOTES

      Plain 32bit version of this routine exists and can be
      found in the header file as a macro.

      Case  insensitive version of this routine exists and
      its called 'txt_fnv64ihash()'.



   SEE ALSO

      mem_pjw64hash(), mem_fnv64hash(), mem_fnv128hash()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_iniparse() - Tries to parse an INI-style line.



   SYNOPSIS

      success = txt_iniparse(string, sepchr, ini, flags);

      BOOL txt_iniparse(
             UBYTE *, LONG, struct txt_ipe_form *, LONG);



   FUNCTION

      This function parses given string in such a way that the
      "key" and "data" get separated and can be then inspected.



   INPUTS

      string - NULL terminated string of "key = data" form.

      sepchr - Separator character, '=' for INI style line.

      ini    - Parser structre from which "key" and "data" can
               be read.

      flags  - Parser ctrl flags. These are QDEV_TXT_NC_F_#?.



   RETURNS

      Function returns TRUE if parser was successful and FALSE
      if it wasnt.



   BASES

      None.



   NOTES

      Function structure is described in the header file.

      Function uses 'txt_nocomment()' as its engine and thus
      its flagset is accepted. Parser direction flags have no
      impact on this routine!

      Please note, this function does not allocate any memory
      for "key" and "data", so if you process public data then
      always remeber to terminate it after you are done. It is
      not necessary to terminate the data if next buffer fill 
      will wipe the data anyway.

      Macro that wraps this function accepts flags as varargs,
      so effectively you need not to pass them when no special
      requirements.



   SEE ALSO

   EXAMPLE

      ...

      UBYTE *data = "\tTypeOfLaugh = lol # Can be one of these:"
                    " haha, lol, lmao or rotfl";
      QDEV_TXT_INIPARSETYPE(ini);

      if ((QDEV_TXT_INIPARSEINIT(data, '=', ini)))
      {
        FPrintf(Output(), "Key: %s\nData: %s\n", 
                                           (LONG)ini.ini_key,
                                         (LONG)ini.ini_data);

        QDEV_TXT_INIPARSETERM(ini);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_memcmp() - Compares two memory regions of upto
                     size.



   SYNOPSIS

      res = txt_memcmp(ptr1, ptr2, size);

      LONG txt_memcmp(void *, void*, LONG);



   FUNCTION

      This function works like so famous 'memcmp()', but
      tries to operate on long words if possible.



   INPUTS

      ptr1 - Pointer to a memory region.

      ptr2 - Pointer to a memory region.

      size - Size of that memory region.



   RETURNS

      Returns 0 if both regions contain the same data or
      -1 if long word/1 if byte comparison failed.



   BASES

      None.



   NOTES

      This func. doesnt care about even or odd pointers!

      Interesingly 'txt_memicmp()' func. exists! It does
      ignore letter case.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_memfill() - Fills the memory with a given val.



   SYNOPSIS

      ptr = txt_memfill(ptr, val, size);

      void *txt_memfill(void *, LONG, LONG);



   FUNCTION

      This function works like so famous 'memset()', but
      tries to operate on long words if possible.



   INPUTS

      ptr  - Pointer to a memory region.

      val  - Value with which that region will be filled.

      size - Size of that memory region.



   RETURNS

      Returns what was passed.



   BASES

      None.



   NOTES

      This function doesnt care about even or odd pointers!!!



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_needslash() - See if path can be suffixed with slash.



   SYNOPSIS

      value = txt_needslash(string);

      UBYTE txt_needslash(UBYTE);



   FUNCTION

      This function will determine if given path can be suffixed
      with a slash if it has not got ':' or '/' at the end.



   INPUTS

      string - NULL terminated path.



   RETURNS

      Returns '/' or 0.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_noansi() - Checks if character might be a part of
                     ANSI sequence.



   SYNOPSIS

      res = txt_noansi(chr, ptr);

      LONG txt_noansi(ULONG, ULONG *);



   FUNCTION

      This function checks if character passed in might possibly
      be a part of ANSI sequence. It does that by caching flags.



   INPUTS

      chr - Character to examine.

      ptr - Character/flags cache.



   RETURNS

      Returns 1 if character does not belong to the ANSI sequence
      or 0 if it does.



   BASES

      None.



   NOTES

      To correctly determine whether certain character belongs to
      ANSI sequence you must start at the sequence initiator(ESC
      and/or CSI)!

      Historically this function was caching previous character
      and was able to only work on ESC prefixed sequences.
      


   SEE ALSO

      txt_stripansi()



   EXAMPLE

      ...

      UBYTE *text = "\x1B[32mColored text comming up.\x1B[0m";
      UBYTE *ptr = text;
      UBYTE hold[] = {NULL, NULL};
      ULONG store = QDEV_TXT_NA_ALL;

      while (*ptr)
      {
        if (txt_noansi(ptr, &store))
        {
          hold[0] = *ptr

          FPrintf(Output(), "%s", (LONG)hold);
        }

        ptr++;
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_nocomment() - Focuses on a text diregarding comments
                        and other useless things.



   SYNOPSIS

      ptr = txt_nocomment(string, dir);

      UBYTE *txt_nocomment(UBYTE *, LONG);



   FUNCTION

      This function allows to strip AmigaDOS(';') or UNIX('#') or 
      C++('//') or C('/**/') style comments plus skips on tabs,
      spaces, quotes, dbl. quotes, newlines, carriage returns, so
      as a result user gets pointer(s) to real start of and/or
      end of NULL term. text.



   INPUTS

      string - NULL terminated string.

      dir    - Direction of parsing, QDEV_TXT_NC_F_REW = from
               right to left, QDEV_TXT_NC_F_FWD = from left to
               right. This argument is considered flag holder
               too.



   RETURNS

      Returns pointer to the first byte at which real text starts,
      or byte past end of real text(so it can be NULL terminated
      for instance).



   BASES

      None.



   NOTES

      Single byte comments like ';' or '#' or double byte '//' at
      the beginning of the line will cause NULL when direction is
      QDEV_TXT_NC_F_REW. Usually you should always parse from
      right to left to see if line is "blank" or not.

      Single byte comments when put inside double quotes will not
      be treated as comments. This: ";text" is not a comment!

      C style comments cannot be stripped when put inside a valid
      text. This: "te/*comment*/xt" will not be fixed!

      If working on an original buffer, dont forget to restore its
      contents if you modify it!

      See source code of 'i-txt_iniparse.c' for a practical use.



   SEE ALSO

   EXAMPLE

      ...

      UBYTE *data = "/* comment */ \t \t 'Hi there!'"
                    " ;# \t /* another one */ \" ### \"";
      UBYTE *ptr;
      UBYTE tmp;

      if ((ptr = txt_nocomment(data, QDEV_TXT_NC_F_REW)))
      {
        tmp = *ptr;

        *ptr = '\0';

        FPrintf(Output(), "%s\n",
           (LONG)txt_nocomment(data, QDEV_TXT_NC_F_FWD));

        *ptr = tmp;
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_parseline() - Assembles an array of arguments from
                        string.



   SYNOPSIS

      count = txt_parseline(line, array);

      LONG txt_parseline(UBYTE *, LONG **);



   FUNCTION

      This func. can easily assemble an array of arguments with
      no extra memory allocation.



   INPUTS

      line  - A NULL terminated string that is to be altered.
              Make sure that you pass a copy that is writable!

      array - Pointer to array of addresses. If this is NULL
              then only count will be returned. Source string
              will not be altered.



   RETURNS

      Returns number of the arguments found.



   BASES

      None.



   NOTES

      Warning! This func. changes contents of the input string!

      This function should be used it two passes. In the first
      pass you will be given number of actual arguments, so you
      know how big array is required. In the second pass you
      parse the string. It is wise to allocate the count + 1 so
      you can NULL terminate it.

      All LF, CR, TAB and SPACE characters are always filtered
      outside quotation!

      Escaped quotes are not unescaped! This routine handles 3
      types of escaped quotes (double quotes specifically). The
      Amiga syntax: *" - asterisk+quote, regular syntax: \" -
      backslash+quote or: '" - single quote+quote.



   SEE ALSO

      txt_tokenify(), txt_fixquotes()



   EXAMPLE

      ...

      UBYTE text[] = "1 \"2\" \\\"3\\\"";
      UBYTE *ptr;
      LONG count;
      LONG **array;
      LONG **aptr;
      
      if ((count = txt_parseline(text, NULL)))
      {
        if ((array = AllocVec(sizeof(text) +
                     (count + 1) * sizeof(LONG), MEMF_PUBLIC)))
        {
          array[count] = NULL;

          ptr = (UBYTE *)&array[count + 1];

          CopyMem(text, ptr, sizeof(text));

          txt_parseline(ptr, array);

          aptr = array;

          while (*aptr)
          {
            FPrintf(Output(), "%s\n", (LONG)*aptr++);
          }

          FreeVec(array);
        }
      }

      

   BUGS

      None known.                                  



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_pjw64hash() - Allows to hash any NULL term. string.



   SYNOPSIS

      hash = txt_pjw64hash(vuq, string);

      ULONG txt_pjw64hash(VUQUAD *, UBYTE *);



   FUNCTION

      This function allows to hash a string using simplified
      PJW routine extended to work on 64bit datatype. Thanks
      to wider datatype this routine has very low repetition
      rate.



   INPUTS

      vuq    - Pointer to 64bit datatype. Can be NULL so the
               only output will be lower 32 bits through the
               'hash'.

      string - NULL terminated string.



   RETURNS

      Returns 32bit or 64bit value or 0 if string is NULL.



   BASES

      None.



   NOTES

      This function should produce the very same values as
      the 'mem_pjw64hash()' one.

      Case  insensitive version of this routine exists and
      its called 'txt_pjw64ihash()'.



   SEE ALSO

      mem_pjw64hash()



   EXAMPLE

      ...

      UQUAD q;
      VUQUAD vuq;
      UBYTE buf[8];
      ULONG hash;
      UBYTE *data = "Hash me plenty!";

      /*
       * Use real QUAD datatype.
      */
      txt_pjw64hash((VUQUAD *)&q, data);

      printf("HASH = 0x%16qx\n", q);

      /*
       * Use virtual QUAD datatype.
      */
      txt_pjw64hash(&vuq, data);

      printf("HASH = 0x%08lx%08lx\n",
                                vuq.vuq_hi, vuq.vuq_lo);

      /*
       * Use some plain buffer.
      */
      txt_pjw64hash((VUQUAD *)buf, data);

      printf("HASH = 0x%08lx%08lx\n",
                  *(ULONG *)&buf[0], *(ULONG *)&buf[4]);

      /*
       * Obtain 32bit hash only.
      */
      hash = txt_pjw64hash(NULL, data);

      printf("HASH = 0x%08lx\n", hash);

      ...



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_psnprintf() - Produces output according to the format.



   SYNOPSIS

      length = txt_psnprintf(buffer, size, fmt, ...);

      LONG txt_psnprintf(UBYTE *, LONG, const UBYTE *, ...);



   FUNCTION

      This func. wraps 'txt_vpsnprintf()' to act like any other
      'snprintf()' implementation.



   INPUTS

      buffer - Output buffer(will be NULL terminated).

      size   - Output buffer size.

      fmt    - Formatting string.

      ...    - Additional arguments.



   RETURNS

      Returns length of newly formatted string or negative value
      if string had to be truncated.



   BASES

      None.



   NOTES

      When going to output 64bit values from 32bit ones always
      remeber to typecast such a var. with '(QUAD)' or '(UQUAD)'.

      Truncation can be detected by adding buffer size to the
      output of the function. If it is 1 then the last call did
      truncate the output.

      See 'txt_vpsnprintf()' for available formatting options.

      Beware! Using '%b' with BCPL data on stack may result in
      address mess! All  addresses to be BCPLed must  be multiple
      of 4! See 'testsuite/textfuncs-test.c' for more details.



   SEE ALSO

      txt_vpsnprintf()



   EXAMPLE

      ...

      UBYTE buf[256];

      txt_psnprintf(buf, 256, "I have %ld apples and im %s!", 3, 
                                                         "happy");

      txt_psnprintf(buf, 256, "This = %qd is wrong! And this = %qd"
                                     "is right ;-) .", 0x7FFFFFFF,
                                                 (QUAD)0x7FFFFFFF);



   BUGS

      None known.                                  



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_quickhash() - Allows to hash any NULL term. string.



   SYNOPSIS

      hash = txt_quickhash(string);

      ULONG txt_quickhash(UBYTE *);



   FUNCTION

      This function allows to hash a string using very simple
      and yet collision prone algorithm. This func. is great
      for hashing ASCII(1-127) if strengh of hash in not the
      goal.



   INPUTS

      string - NULL terminated string.



   RETURNS

      Returns unique hash value ;-) or 0 if string is NULL.



   BASES

      None.



   NOTES

      Warning! This algorithm is weird and likes to wear crazy
      hat!

      Case  insensitive version of this routine exists and its
      called 'txt_quickihash()'.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_skipcc() - Skips C-style comments in NULL term.
                     strings in a special manner.



   SYNOPSIS

      output = txt_skipcc(string, sf);

      UBYTE *txt_skipcc(UBYTE *, struct txt_scc_form *);



   FUNCTION

      This function allows to skip C-style comments in the
      strings or even in whole data streams as delivered in
      line or block chunks.



   INPUTS

      string - NULL terminated string to be parsed.

      sf     - Feed form structure that is described in
               the header file.



   RETURNS

      Returns pointer to a string that is free of comments
      nearby. It should never return NULL under normal
      circumstances.



   BASES

      None.



   NOTES

      This function allows to process comments that are
      within comments.

      This function needs special preparation before it can
      be used, so it is advised to use macros.

      This function does not modify input data in any way,
      but data termination is a must which can be done on
      the outside.

      Imbalance in closing comments may cause whole parsing
      not to return any data beyond the point when it had
      its start! You have to start and end any comment with
      just a bit of care(standard)! You can always look in
      'sf_comm' to see if comments are messed up.

      Beware! When working on streams and/or data blocks
      make sure that the buffer is '/*' and '*/' synced at
      all times! Buffer must not end with just '/' or '*',
      cus another fill may kill the comment marker!



   SEE ALSO

   EXAMPLE

      ...

      UBYTE *data = "This text/*string!*/ contains"
                            "/*/*/*/*/*/*weird*/*/*/*/*/*/"
                            " comments at the source level"
                            " /*yes, sir!*/that should be"
                            " invisible after the execution"
                            "/*exactly!*/!\n";
      QDEV_TXT_SKIPCCTYPE(sf);

      QDEV_TXT_SKIPCCINIT(sf);

      QDEV_TXT_SKIPCCITER(data, sf)
      {
        /*
         * This destroys the data, but hopefully can be very
         * easily reversed!
        */
        if (sf.sf_start)
        {
          *sf.sf_start = '\0';
        }

        /*
         * This sort of check is essential, always do it this
         * way!
        */
        if (*sf.sf_ptr)
        {
          printf("%s", sf.sf_ptr);
        }
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_strchr() - Finds a character in a given string.



   SYNOPSIS

      ptr = txt_strchr(str, chr);

      UBYTE *txt_strchr(const UBYTE, LONG);



   FUNCTION

      This function allows to find nearest single character
      in some string.



   INPUTS

      str - NULL terminated string.

      chr - Character.



   RETURNS

      Pointer to that found character or NULL if it was not
      found.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_strcmp() - Compares two strings.



   SYNOPSIS

      res = txt_strcmp(str1, str2);

      LONG txt_strcmp(const UBYTE *, const UBYTE *);



   FUNCTION

      This function is able to compare two strings.



   INPUTS

      str1 - NULL terminated string.

      str2 - NULL terminated string.



   RETURNS

      Returns 0 if strings are equal.



   BASES

      None.



   NOTES

      There is also case insensitive variant of this function,
      called: 'txt_stricmp()'. Please note that by def. there
      is no UTF-8 support in case insensitive version, but it
      may do support it when compiled to use 'utility.library'
      (-D___QDEV_UTILITYCHAREQ)! Plus both of these have ptr
      checking wrappers called: 
      'txt_pstrcmp()' and 'txt_pstricmp()' respectively.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_strcspn() - Searches a string for a set of characters.



   SYNOPSIS

      res = txt_strcspn(str1, str2);

      LONG txt_strcspn(const UBYTE *, const UBYTE *);



   FUNCTION

     This function computes the length of the initial segment of
     'str1' which consists entirely of characters not in 'str2'.



   INPUTS

     str1 - String with text.

     str2 - String that contains one or more characters.



   RETURNS

      Returns the number of characters spanned.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_stripansi() - Strips ANSI sequences from string.



   SYNOPSIS

      len = txt_stripansi(out, in);

      LONG txt_stripansi(UBYTE *, UBYTE *);



   FUNCTION

      This function allows to strip all the ANSI sequences 
      from given string.



   INPUTS

      out - Output buffer pointer. Always remember to add
            1 to the allocation of space of that buffer!

      in  - NULL terminated input string.



   RETURNS

      Returns number of bytes written to the output buffer.



   BASES

      None.



   NOTES

      Output buffer must generally be equally sized as the
      input string plus remember about additional one byte
      for the NULL terminator!

      Certain VT100 sequences(those who end with numbers)
      cannot be stripped with this routine.

      Do not use this function when working on streams! It
      is unsuitable for this kind of processing.



   SEE ALSO

      txt_noansi()



   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_strlen() - Checks how long the string is.



   SYNOPSIS

      length = txt_strlen(str);

      LONG txt_strlen(const UBYTE *);



   FUNCTION

      This function returns length of the NULL term. string.



   INPUTS

      str - NULL terminated string.



   RETURNS

      Length of that string.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_strncat() - Concatenate two strings.



   SYNOPSIS

      len = txt_strncat(dst, src, dlen);

      LONG txt_strncat(UBYTE *, UBYTE *, LONG);



   FUNCTION

      This function appends 'src' NULL terminated string to 'dst'
      NULL terminated string, regarding available space in 'dst'.



   INPUTS

      dst  - Destination string.

      src  - Source string.

      dlen - Destinantion length.



   RETURNS

      Returns amount of data that was put in the destination.
      Overflow will be indicated by inverting the value, so neg.
      result means that the data was truncated. 0 will mean that
      no copy took place.



   BASES

      None.



   NOTES

      This function is slightly different than normal 'strncat()',
      instead of length of source string it expects the dest. len.
      which is much safier on non-MMU systems.

      This function can successfully be used as 'strncpy()' as
      well. In such case you have to remember to NULL the first
      byte of the destination buffer.

      This func. comes with two more variants: 'txt_strncatlc()' &
      'txt_strncatuc()' who allow to transform the text on the
      fly to lower or upper case.

      Truncation can be detected by adding buffer size to the
      output of the function. If it is 1 then the last call did
      truncate the output.



   SEE ALSO

   EXAMPLE

      ...

      #define SIZE 256

      ...

      UBYTE buf[SIZE] = {0};

      txt_strncat(buf, "Hello ", SIZE);

      txt_strncat(buf, "world!", SIZE);



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_strnpcat() - Concatenate two strings.



   SYNOPSIS

      res = txt_strnpcat(dst, src, dlen);

      LONG txt_strnpcat(LONG *, UBYTE *, LONG *);



   FUNCTION

      This func. appends 'src' NULL terminated string to 'dst'
      NULL terminated string, regarding avail. space in 'dst'.



   INPUTS

      dst  - Pointer to a var. that holds dest. address.

      src  - Source string.

      dlen - Pointer to a var. that holds dest. len.



   RETURNS

      Returns 0 if everything went fine or negative or positive
      value on overflow.



   BASES

      None.



   NOTES

      This function does not iterate to find end of the string,
      so it is much faster and much safier than 'txt_strncat()',
      but you should still NULL terminate the very first byte of
      the string!

      This f. comes with two more variants: 'txt_strnpcatlc()' &
      'txt_strnpcatuc()' who allow to transform the text on the
      fly to lower or upper case.

      To compute how long the string is you just subtract 'dlen'
      from 'dst' capacity.



   SEE ALSO

   EXAMPLE

      ...

      #define SIZE 256

      ...

      UBYTE buf[SIZE] = {0};
      LONG size = SIZE;
      LONG addr = (LONG)&buf[0];

      txt_strnpcat(&addr, "Hello ", &size);

      txt_strnpcat(&addr, "world!", &size);



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_strspn() - Searches a string for a set of characters.



   SYNOPSIS

      res = txt_strspn(str1, str2);

      LONG txt_strspn(const UBYTE *, const UBYTE *);



   FUNCTION

      This function returns the number of characters in the 
      initial segment of 'str1' which consist only of characters
      from 'str2'.



   INPUTS

      str1 - String with text.

      str2 - String that contains one or more characters.



   RETURNS

      Returns the number of characters spanned.



   BASES

      None.



   NOTES

      None.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_strstr() - Finds a string in the string.



   SYNOPSIS

      ptr = txt_strstr(str1, str2);

      UBYTE *txt_strstr(const UBYTE *, const UBYTE *);



   FUNCTION

      This function allows to search for a NULL term. string
      in another NULL terminated string.



   INPUTS

      str1 - String in which search process will take place.

      str2 - String to be searched for.



   RETURNS

      Important! Function returns pointer past the beginning of
      found 'str2', so in other words you will have to 'ptr -=
      txt_strlen(str2);' to achieve start of that found pattern.



   BASES

      None.



   NOTES

      There is also case insensitive variant of this function,
      called: 'txt_stristr()'. Please note that by def. there
      is no UTF-8 support in case insensitive version, but it
      may do support it when compiled to use 'utility.library'
      (-D___QDEV_UTILITYCHAREQ)! Plus both of these have ptr
      checking wrappers called: 
      'txt_pstrstr()' and 'txt_pstristr()' respectively.



   SEE ALSO

   EXAMPLE

      None.



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_strtok() - General purpose tokenisator.



   SYNOPSIS

      token = txt_strtok(str1, str2, tptr);

      UBYTE *txt_strtok(UBYTE *, const UBYTE *, ULONG *);



   FUNCTION

      This func. allows to tokenise a NULL terminated string,
      so that programmer can build configuration parser quite
      easily for example.



   INPUTS

      str1 - String that will be parsed. Only first time op.
             requires the string, all other ops use NULL!

      str2 - String with delimiter/separator characters.

      tptr - Pointer to 8 byte buffer, 'ULONG buf[2]' will
             be just fine.



   RETURNS

      Returns token every call, or NULL if no tokens or the
      end of string has been reached.



   BASES

      None.



   NOTES

      This function is somewhat different than standard one
      as found in many C libraries. Firstly it not only 
      remembers the address in user variable but also last
      character that was destroyed so effecitevly this func.
      does not require a copy of the data to be worked on
      and not at least if data is not being shared amongst
      other threads or tasks.

      The recommended way of using this function is through
      the macros that can be found in the header file.



   SEE ALSO

   EXAMPLE

      ...

      UBYTE *token;
      UBYTE *string = "red,green,blue";
      QDEV_TXT_STRTOKTYPE(tdata);

      if ((token = QDEV_TXT_STRTOKINIT(string, ",", tdata)))
      {
        do
        {
          FPrintf(Output(), "Colour: %s\n", (LONG)token);
        } while ((token = QDEV_TXT_STRTOKNEXT(",", tdata)));

        QDEV_TXT_STRTOKTERM(tdata); /* This is very important */
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_tokenify() - Tokenify NULL terminated string using
                       single character separator.



   SYNOPSIS

      token = txt_tokenify(string, addr, sep);

      UBYTE *txt_tokenify(UBYTE *, LONG *, LONG);



   FUNCTION

      This function is similar to 'txt_strtok()'. It is also
      a lot faster.



   INPUTS

      string - NULL terminated string.

      addr   - Address of the 'sep' character in 'string'.

      sep    - Separator character.



   RETURNS

      Returns pointer to start of token or NULL.



   BASES

      None.



   NOTES

      Different 'sep' characters can be used during parsing.



   SEE ALSO

   EXAMPLE

      ...

      UBYTE *string = "one:two:three";
      LONG addr = (LONG)string;
      UBYTE *ptr;
      LONG old;

      while((ptr = txt_tokenify((UBYTE *)addr, &addr, ':')))
      {
        QDEV_TXT_TOKENSET(old, addr);

        FPrintf(Output(), "%s\n", (LONG)ptr);

        QDEV_TXT_TOKENCLR(old, addr);
      }



   BUGS

      None known.



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_vcbpsnprintf() - Produces output according to the fmt.



   SYNOPSIS

      length = txt_vcbpsnprintf(putfunc, buffer, size, vfmt, ap);

      __nifunc __interrupt LONG txt_vcbpsnprintf(void (*)(
                                    register UBYTE * __asm("a0"),
                                      register LONG __asm("d0")),
                          UBYTE *, LONG, const UBYTE *, va_list);



   FUNCTION

      This function does exactly what 'txt_vpsnprintf()' does,
      but the output can be built/redirected through the callback
      function.



   INPUTS

      putfunc - Callback function.

      buffer  - Output buffer(will be NULL terminated).

      size    - Output buffer size.

      vfmt    - Formatting string.

      ap      - Variable args pointer.



   RETURNS

      Returns length of newly formatted string or negative value
      if string had to be truncated.



   BASES

      None.



   NOTES

      Please disregard direct registers in prototype. Only Amiga
      makes use of them. Other platforms will follow the default
      arguments passing conventions.

      Argument 'buffer' can be used to carry user data, but this
      will be true only on first char printout!

      Beware! Using '%b' with BCPL data on stack may result in
      address mess! All  addresses to be BCPLed must be multiple
      of 4! See 'testsuite/textfuncs-test.c' for more details.



   SEE ALSO

      txt_vpsnprintf(), txt_debugprintf()



   EXAMPLE

      ...

      /*
       * Callback function.
      */
      __saveds __interrupt void myputfunc(REGARG(UBYTE *ptr, a0),
                                            REGARG(LONG chr, d0))
      {
        /*
         * This will make it act as 'txt_vpsnprintf()'. Yep, ptr
         * is increasing internally. You can put something else 
         * in here, 'RawPutChar()' maybe?
        */
        *ptr = chr;
      }

      /*
       * Main function.
      */
      __interrupt LONG mysnprintf(
                          UBYTE *ptr, LONG, len, UBYTE *fmt, ...)
      {
        va_list ap;
        LONG res;

        va_start(ap, fmt);

        res = txt_vcbpsnprintf(myputfunc, ptr, len, fmt, ap);

        va_end(ap);

        return res;
      }

      ...

      UBYTE buf[256];

      buf[0] = '\0';

      mysnprintf(buf, 256, "%s %s %ld!", "Printo", "numero", 1);

      FPrintf(Output(), "%s\n", (LONG)buf);



   BUGS

      None known.                                  



 ----------------------------------------------------------------------------
                                 INDEP - TXT_#?
 ----------------------------------------------------------------------------

   NAME

      txt_vpsnprintf() - Produces output according to the format.



   SYNOPSIS

      length = txt_vpsnprintf(buffer, size, vfmt, ap);

      LONG txt_vpsnprintf(UBYTE *, LONG, const UBYTE *, va_list);



   FUNCTION

      This function allows to build a string with the help of
      different datatypes represented as a clear text. Format
      options begin with '%' character and are:


         '+' - Upper case string/char output.

         '-' - Lower case string/char output.

         '0' - When put right after the format pointer will allow
               zero padding with digits(0-9). Padding is also
               possible with the space. In such case one needs to
               start with '1' onwards.

         'l' - If put once will indicate LONG datatype, when put
               once more will indicate QUAD.

         'N' - This modifier can be used together with 'b' and
               's' to detect NULL pointers.

         'q' - This is QUAD modifier and can be used with all the
               integer outputting options below.

         't' - This is number of bits modifier. Effective output
               will be number of bits this integer consists of.



         'B' - Output integer as a binary stream.

         'b' - Output BSTR(Amiga non-NULL terminated string).

         'c' - Output one character excluding 0.

         'd' - Output signed decimal value.

         'i' - Same as above.

         'M' - Load size of the upcoming memory data as passed
               with 'm'.

         'm' - Output non-NULL terminated string or data.

         'O' - Output octal value.

         'o' - Same as above.

         's' - Output NULL terminated string.

         'U' - Output unsigned integer value.

         'u' - Same as above.

         'X' - Output the int. as a hex. with upper case letters.

         'x' - Output the int. as a hex. with lower case letters.



   INPUTS

      buffer - Output buffer(will be NULL terminated).

      size   - Output buffer size.

      vfmt   - Formatting string.

      ap     - Variable args pointer.



   RETURNS

      Returns length of newly formatted string or negative value
      if string had to be truncated.



   BASES

      None.



   NOTES

      There is a wrapper function for direct use and it is called
      'txt_psnprintf()'.

      Truncation can be detected by adding buffer size to the
      output of the function. If it is 1 then the last call did
      truncate the output.

      Beware! Using '%b' with BCPL data on stack may result in
      address mess! All  addresses to be BCPLed must  be multiple
      of 4! See 'testsuite/textfuncs-test.c' for more details.



   SEE ALSO

      txt_psnprintf()



   EXAMPLE

      None.



   BUGS

      None known.                                  



 ----------------------------------------------------------------------------
