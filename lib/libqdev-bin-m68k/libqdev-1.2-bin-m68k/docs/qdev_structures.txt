;
; $VER: qdev_structures.txt 1.10 (15/08/2014) English
;



 Public structures
###########################################################################



struct qdevdbsymspace
{
  long ss_dbdi;
  char ss_name[QDEVDBTEXTLEN];
  char ss_file[QDEVDBTEXTLEN];
  long ss_line;
  long ss_flags;
  long ss_last;
  long ss_dbid;
};

ss_dbdi  -  Debug  magic cookie  that  reads  backwards as  defined  in the
            QDEVDBMAGICDI. Its  purpose is to brace debug information so it
            can be easily located.

ss_name  -  Symbol buffer space. This member holds the name of the function
            name typically. String is NULL terminated.

ss_file  -  Symbol's/object's  file name where symbol is located. String is
            NULL terminated.

ss_line  -  Number of the line where  one's function ends. This line number
            will point at the debugging macro I/O.

ss_flags -  Debugger flagset  as established  at the compilation time. This
            member is special in the meaning it can be modified at runtime!

ss_last  -  Debugger own  local  irrelevance buffer  position pointer. This
            member  can  be  altered  at  runtime  if QDEVDBF_NORMALFILL is
            defined!

ss_dbid  -  Debug  magic  cookie  that   reads  normal as  defined  in  the
            QDEVDBMAGICID. Its  purpose is to brace debug information so it
            can easily be located.



struct txt_ipe_form
{
  UBYTE   *ini_key;
  UBYTE   *ini_data;
  ULONG    ini_bck[4];
};

ini_key  -  Keyword  address as set  after parsing  the input. This pointer
            will be targeting at NULL terminated text.

ini_data -  Data value address  as set after pasing the input. This pointer
            will also be targeting at NULL terminated text.

ini_bck  -  A  handy table that will be used to store and restore NULLified
            characters. [0] and [2] - the address, [1] and [3] - the value.



struct txt_scc_form
{
  UBYTE   *sf_ptr;
  UBYTE   *sf_start;
  UBYTE   *sf_end;
  LONG     sf_quot;
  LONG     sf_count;
  LONG     sf_comm;
};

sf_ptr   -  Explicit  function output. This member receives current address
            when used through QDEV_TXT_SKIPCCITER() macro. It can safely be
            read on byte by byte basis until NULL.

sf_start -  After  each pass this  will point at byte that should be NULLed
            so that  comment block is separated from  perciding text. Its a
            start of comment block in other words.

sf_end   -  End of this very comment and start of new text area at the same
            time. This member is circular!

sf_quot  -  Quotation  character  within which comments  should be kept. If
            you  need to provide  your own char  then pass it in 0xbb0000ch
            form,  where bb  is boolean(must  be set to  1) and ch is char.
            This var. must be set to 0x01000000 for total comment removal.

sf_count -  Number of comments  encountered so far in this stream or block.

sf_comm  -  This member acts as an unmatched comment counter. It may return
            1 in the worst case and the parsing will be complete when block
            of text starts with closing comment!



struct mem_sfe_cb
{
  LONG    sc_buflen;
  LONG    sc_halflen;
  UBYTE  *sc_block;
  LONG    sc_blklen;
  UBYTE  *sc_data;
  LONG    sc_datalen;
  LONG    sc_total;
  void   *sc_userdata;
};

sc_buflen
         -  Size  of the whole buffer allocated. This may be very different
            from function input because it is being recomputed on entrance!

sc_halflen
         -  Size of a halve of the buffer based upon sc_buflen. Recomputed!

sc_block -  Address of the memory that was allocated to store the data. One
            big block.

sc_data  -  Address  of the  memory region  where data were just read into.
            This pointer will change after second pass from sc_block to the
            second half!

sc_datalen
         -  Amount of data that was read into memory pointed to by sc_data.

sc_total -  Total  amount of data as read from  file. This member is a byte
            counter.

sc_userdata
         -  User data  pointer that will be  passed to the callback. Can be
            whatever user wants.



struct mem_lbl_cb
{
  LONG    lc_buflen;
  UBYTE  *lc_bufptr;
  UBYTE  *lc_lineptr;
  LONG    lc_linenum;
  void   *lc_userdata;
};

lc_buflen
         -  Size  of line buffer. This  value is a direct  copy of function
            input. Min possible value is 1024.

lc_bufptr
         -  Buffer space area pointer of lc_buflen size.

lc_lineptr
         -  Current  line pointer, the  current  line  as read from file in
            other words.

lc_linenum
         -  Current  line number. If this is  -1 then EOF just happened, so
            there is no more data.

lc_userdata
         -  User data  pointer that will be  passed to the callback. Can be
            whatever user wants.



struct mem_mtl_iter
{
  struct MinNode  mi_node;
  UBYTE          *mi_token;
};

mi_node  -  Standard  minimal node as defined  in OS headers  to chain this
            structure.

mi_token -  Single  word/chunk of text that was  extracted from input data.



struct mem_pak_data
{
  UBYTE  *pd_data;
  ULONG   pd_size;
};

pd_data  -  Data block address or NULL if there was an error compressing or
            decompressing.

pd_size  -  Data block size or 0 if there was an error while compressing or
            decompressing.



struct ctl_csn_feed
{
  struct TextAttr      cf_ta;
  struct ColorSpec    *cf_cs;
  UWORD               *cf_drimap;
  UBYTE                cf_lfirst;
  UBYTE                cf_llast;
  ULONG                cf_modeid;
  ULONG                cf_depth;
  UBYTE               *cf_handler;
  UBYTE               *cf_title;
  UBYTE               *cf_pubname;
  LONG                 cf_backpen;
  LONG                 cf_ibgpen;
  LONG                 cf_ifgpen;
  LONG                 cf_active;
  LONG                 cf_numcon;
  BOOL                 cf_commo;
  BOOL                 cf_behind;
};

cf_ta    -  Standard  font selection structure. Can be  NULLed if no custom
            font  is necessary. If font cannot  be located then the default
            one will be used.

cf_cs    -  Pointer  that takes  ColorSpec table so  that new colors can be
            set for this screen. Can be NULL if standard colors are fine.

cf_drimap
         -  Pen  mapping table aka DrawInfo. This  table consists of UWORDs
            that are  ~0 terminated. Each entry  defines logical pen number
            used for  rendering OS  related elements. Set to  NULL if it is
            OK to use default mappings.

cf_lfirst
         -  If  this  is  set  to something above  0 then the  very first n
            colors will be locked.

cf_llast -  If  this  is set to  value  above 0 then  last n colors will be
            locked counting from last color in 8 bit notation.

cf_modeid
         -  Standard  modeid  value  that selects the monitor/graphics chip
            used to handle the screen.

cf_depth -  Color  depth  of the  screen  to be opened. This  value  should
            really  be  always  truncated  to something like 8 even for RGB
            screenmodes. Well accepted values start from 1 to 8.

cf_handler
         -  Console  handler name  and/or its arguments. By default this is
            'CON:'. Can be NULL if no special wishes.

cf_title -  Name of the  public screen for visibility. NULL terminated text
            in here. You can pass NULL too so that cf_pubname will be used.

cf_pubname
         -  Name  of the public  screen for unique marking. If this is NULL
            then unique screen number will be used instead in hex notation.

cf_backpen
         -  Pen number to be used as a background color before any windows.

cf_ibgpen
         -  Pen number to be used for background of the OSD facility.

cf_ifgpen
         -  Pen number to be used for foreground of the OSD facility.

cf_active
         -  Which  window should be active by default? Possible choices are
            0 to 3. Everything outsize this range has no effect.

cf_numcon
         -  How many shells should there be on the screen? Possible choices
            are 1 to 4. 0 means 1. Note, it is not enough just to state the
            amount of windows, you still need to call rearranger function!

cf_commo -  This member is boolean and allows to activate Commodore 64 look
            and feel.

cf_behind
         -  Should the screen be opened behind all other screens? Member is
            boolean.



struct ctl_csn_cwin
{
  struct ctl_csn_data *cc_cd;
  struct IntuiMessage *cc_imsg;
  struct Window       *cc_mainwin;
  BPTR                 cc_con;
  struct MinList       cc_idcmp[QDEV_CTL_CSN_MAXINDEX];
  LONG                 cc_index;
  LONG                 cc_numwin;
  LONG                 cc_zoomed;
  LONG                 cc_zoomfct;
  LONG                 cc_rpylim;
  ULONG                cc_iflags;
  ULONG                cc_lflags;
};

cc_cd    -  This is  security pointer, so that when this  structure pointer
            is  being passed somewhere  alone then  there is still a way to
            access root parameters.

cc_imsg  -  This  is packed  pointer so that no pseudo-interrupt  will  eat 
            stack  where  Intuition messages  are being  dispatched. Just a
            helper one that does not matter in normal operation.

cc_mainwin
         -  Window that is now associated with the console handler. Just do
            not close it from code and everything will be OK.

cc_con   -  Console  FileHandle  that is BPTR  which is an interface to the
            handler which talks to cc_mainwin. Calling 'Close()' will close
            the window!

cc_idcmp -  IDCMP  index that represents particular  IDCMP  message. Attach
            your pseudo-interrupt function here by converting message ID to
            index. Use the respective function to add/del!

cc_index -  This is  being used in the IDCMP pseudo-interrupt dispatcher to
            reduce stack usage.

cc_numwin
         -  Number of  this very window. All windows are enumerated so that
            it is easy to identify them. First window has a value of 0.

cc_zoomed
         -  Kludgy zoom/size indicator used to mark changes globally.

cc_zoomfct
         -  Current zoom factor this window will scale with. Zoom factor is
            normally expressed in % and can range form 1 to 100.

cc_rpylim
         -  Maximum pixels in Y axis logo can take from top to bottom. This
            is freely setable. The default value is QDEV_CTL_PRV_REPOSLIM.

cc_iflags
         -  Image  related flags that apply  to this very window. These are
            defined as QDEV_MEM_IFLPIC_#? group.

cc_lflags
         -  Logo  playback flags that apply to this  very window. These are
            defined as QDEV_CTL_LFLLOGO_#? group.



struct ctl_csn_ient
{
  struct MinNode       ci_node[QDEV_CTL_CSN_MAXWINDOWS];
  LONG                 ci_idcmpev;
  void               (*ci_idcmpcode)(
                       struct ctl_csn_cwin *, void *);
  void                *ci_idcmpdata;
};

ci_node  -  Standard, minimal node to be able to create list -  IDCMP entry
            list. There is one node for each window so code can be reused.           

ci_idcmpev
         -  Single  Intuition  event flag to determine where to install the
            handler. All standard IDCMP_#? macros accepted.

ci_idmpcode
         -  Code that will be executed in private task exception. First arg
            is the window and the second userdata.

ci_idmpdata
         -  Userdata as passed to the  'ci_idcmpcode()' routine. Previously
            this was accesible from  'cc' but this is no longer possible in
            a direct way.



struct ctl_csn_data
{
  struct SignalSemaphore  cd_isem;
  WORD                    cd_spad;
  struct MsgPort          cd_smp;
  WORD                    cd_mpad;
  struct IntuitionBase   *cd_ib;
  struct GfxBase         *cd_gb;
  struct Library         *cd_mb;
  struct Library         *cd_db;
  struct TextFont        *cd_tf;
  struct Window          *cd_actvwin;
  struct Layer           *cd_back;
  struct Hook             cd_h;
  struct Screen          *cd_screen;
  LONG                    cd_signal;
  LONG                    cd_numcon;
  ULONG                   cd_winapp;
  LONG                    cd_backpen;
  LONG                    cd_ibgpen;
  LONG                    cd_ifgpen;
  WORD                    cd_xzero;
  WORD                    cd_yzero;
  struct ctl_csn_cwin     cd_cc[QDEV_CTL_CSN_MAXWINDOWS];
  struct ctl_csn_ient     cd_actidcmp;
};

cd_isem  -  General purpose SignalSemaphore  that can be used to prioritize
            Intuition or  Graphics related  stuff. This is  mostly  used to
            manage  refreshing of logo stuff as  well as window zooming and
            such.

cd_spad  -  Semaphore  aligner so  the  rest of  members is  LONG  aligned.

cd_smp   -  Very special  message port that gets attached to each window so
            that  there is a need for just one  task signal to handle IDCMP
            on all windows.

cd_mpad  -  MsgPort  aligner  so   the  rest of  members is  LONG  aligned.

cd_ib    -  Local  copy of IntuitionBase  so that subtasks  can easily call
            Intuition functions.

cd_gb    -  Locally buffered  GfxBase. Used  to pass to backfill hook. This
            may also be passed to subtasks.

cd_mb    -  Local copy of MathIeeeXXXXBasBase to avoid global compiler rel.
            references.

cd_db    -  Local instance of  DiskfontBase  so that disk fonts can be used
            where possible without explicitly requiring the former library.

cd_tf    -  TextFont  handle if the font was  successfully loaded into mem.

cd_actvwin
         -  This  will  point at  the window  that is  active by  now. This
            is not being protected by cd_isem! Caching(&cd_actvwin) address
            of this variable is strongly recommended.

cd_back  -  Background layer that masks screen and title bar. In early time
            this was smart refreshed window.

cd_h     -  Backfill hook that carries callback that is responsible for the
            background color.

cd_screen
         -  Standard screen pointer. This  is the screen where all cc live.

cd_signal
         -  This screen's signal bit. This is  used to notify  process that
            the screen can be safely closed.

cd_numcon
         -  Total number  of consoles opened on  this screen. Please do not
            hack on this or there will be nasty side effects.

cd_winapp
         -  Window appearance flags. This is used to rearrange the view, to
            store the info on how to rearrange. See QDEV_CTL_RECON_#? macro
            group. You should not be touching this directly.

cd_backpen
         -  Pen number  to be used for  background in screen masking layer.

cd_ibgpen
         -  Pen number to be used  for background of the OSD facility. This
            is a copy of cf_ibgpen more or less.

cd_ifgpen
         -  Pen number to be used  for foreground of the OSD facility. This
            is a copy of cf_ifgpen more or less.

cd_xzero -  Init related zero coordinate  for X axis,  so called real zero.

cd_yzero -  Init related zero coordinate  for Y axis,  so called real zero.

cd_cc    -  Console window array. Console handlers in other words.

cd_actidcmp
         -  Default  IDCMP  entry for active window tracker that is created
            on init.



struct ctl_csh_data
{
  LONG ct_oldtask;
  LONG ct_oldcon;
  LONG ct_newcon;
};

ct_oldtask
         -  Original console  task(msg. port) is being  stored in here when
            switching the output.

ct_oldcon
         -  Original Output() is being stored in here when switching to the
            new output.

cd_newcon
         -  The BPTRed FileHandle that will be new default output in 'this'
            process.



struct ctl_umn_cb
{
  UBYTE *uc_devname;
  LONG   uc_state;
  void  *uc_userdata;
};

uc_devname
         -  Device/handler  name(colonless)  that was  just  probed. Do not
            pass this pointer across tasks!

uc_state -  Device/handler state. See  QDEV_CTL_DMT_STATE_#? group for more
            details.

uc_userdata
         -  User data  pointer that will be  passed to the callback. Can be
            whatever user wants. 



struct nfo_sml_data
{
  UBYTE  *sd_dosdevice;
  UBYTE  *sd_handler;
  LONG    sd_hantype;
  UBYTE  *sd_device;
  UBYTE  *sd_unit;
  UBYTE  *sd_flags;
  UBYTE  *sd_control;
  UBYTE  *sd_startup;
  LONG    sd_stacksize;
  LONG    sd_priority;
  LONG    sd_globvec;
  LONG    sd_activate;
  LONG    sd_forceload;
  UBYTE  *sd_errors;
};

sd_dosdevice
         -  Normally mountlist  scanner will attach colon  free  DOS device
            name in here.

sd_handler
         -  This  coresponds logical  Handler,  EHandler  or  FileSystem as
            found in the mountlist.

sd_hantype
         -  Mountlist scanner tries to determine mountblock type by putting
            one of QDEV_NFO_SCANML_#? here.

sd_device
         -  This  will be  non-NULL  only when  mountblock is a EHandler or
            a FileSystem.

sd_unit  -  Unit can be literal name or a number. If the very first byte is
            NULL then one should inspect LONG starting at byte 1.

sd_flags -  Flags  can be a s tring or  a number. If the very first byte is
            NULL then one should inspect ULONG starting at byte 1.

sd_control
         -  NULL terminated  Control string, or NULL. Although redundant it
            is being used by the mounter!

sd_startup
         -  This can either be a string or startup value. Syntax same as in
            sd_flags.

sd_stacksize
         -  Amount of stack that will be used for new handler process. This
            is analogous to the Stack in mountblock. Effectively this value
            will be LONG aligned in dn_StackSize!

sd_priority
         -  Priority of the handler process. This  can be -128 to 127 only!

sd_globvec
         -  Logical GlobVec value. Used  commonly to  kludge BCPL binaries.

sd_activate
         -  If  this is set to one then handler  will be loaded and mounted
            right away, otherwise its stub will be added to the list.

sd_forceload
         -  Enforce  handler(the binary) to  load under  any circumstances.

sd_errors
         -  Scanner  will  put all keys  that were  found  erroneous in the
            buffer. These keys will be  '\n'  separated. This member points
            at that buffer, or should. It can also be NULL.



struct nfo_fsq_cb
{
  LONG              fc_userlen;
  UBYTE            *fc_userptr;
  LONG              fc_exlen;
  UBYTE            *fc_file;
  LONG              fc_edval;
  ULONG             fc_termsig;
  void             *fc_userdata;
  void             *fc_usercode;
  struct ExAllData *fc_ead;
};

fc_userlen
         -  Preallocated  user space length that can be used inside the CB.
            Min 4 bytes.

fc_userptr
         -  Preallocated  user space  pointer. This  serves as a  temporary
            buffer that user may  use inside the callback. This memory gets
            freed automatically.

fc_exlen -  Size  of the buffer that is  used to collect filesystem related
            info. See fc_ead member.

fc_file  -  File or path as passed to the function.

fc_edval -  One of  the ED_xxx macros that allow to determine how much data
            to get.

fc_termsig
         -  Termination signal so that it is possible to break the internal
            loop and leave the function at anytime. 0 means no signal.

fc_userdata
         -  User data  pointer that will be  passed to the callback. Can be
            whatever user wants.

fc_usercode
         -  Callback function pointer as passed to the main function.

fc_ead   -  Filesystem  related info can be read from this structure per CB
            call.



struct nfo_sml_cb
{
  struct DosList            sc_dol;
  ULONG                     sc_fake1;
  ULONG                     sc_wall1;
  struct FileSysStartupMsg  sc_fssm;
  ULONG                     sc_fake2;
  ULONG                     sc_wall2;
  struct DosEnvec           sc_de;
  struct nfo_sml_data       sc_sd;
  ULONG                     sc_pflags;
  ULONG                     sc_eflags;
  LONG                      sc_gerror;
  UBYTE                    *sc_file;
  void                     *sc_userdata;
};

sc_dol   -  This  member is only being  used by the mounter. It is  here to
            establish  just one structure  that is exchangable  between the
            scanner and mounter.

sc_fake1 -  As this  structure is  being allocated in one big block and the
            device  handling in the  OS is multipointer  the allocation  is
            faked for compatibility reasons. Must be 0!

sc_wall1 -  All  allocations  are  aligned  to at least 8 bytes. Gotta fake
            that too. Must be 0!

sc_fssm  -  Part  of that fake allocation! Again, used by the mounter only!

sc_fake2 -  This faked allocation is sc_de related, we emulate that pointer
            too. Must be 0!

sc_wall2 -  All  allocations  are  aligned  to at least 8 bytes. Gotta fake
            that too. Must be 0!

sc_de    -  Standard  mountlist related param table. Firstly established by
            the scanner and then used by the mounter.

sc_sd    -  Additional  mountblock parameters that get utilised while doing
            mount.

sc_pflags
         -  Keyword  presence flags allow to easily detect params that were
            not passed through the mountblock.

sc_eflags
         -  Keyword error flags allow to easily detect inconsistencies just
            by comparing the member against 0.

sc_gerror
         -  Scanner-helper  error values  are being  reported  through this
            variable.

sc_file  -  Mountlist file name as passed to the function.

sc_userdata
         -  User data  pointer that will be  passed to the callback. Can be
            whatever user wants.



struct nfo_sct_cb
{
  ULONG *tc_lists;
  ULONG *tc_listaddr;
  void  *tc_itemaddr;
  void  *tc_userdata;
};

tc_lists -  This  member  holds the  address  of  the array  that  contains
            addresses of the lists. Table is NULL terminated.

tc_listaddr
         -  Current list being iterated, its address.

tc_itemaddr
         -  Address of  the  entry on currently iterated list(tc_listaddr).

tc_userdata
         -  User data  pointer that will be  passed to the callback. Can be
            whatever user wants.



struct nfo_stu_cb
{
  struct Node **stu_ln[4];
  LONG        **stu_lhtab;
  LONG         *stu_btab;
  void         *stu_udata;
  LONG          stu_ures;
};

stu_ln   -  Head[0]  and  Tail[1]  vectors that point at node pointers. Use
            dedicated macros QDEV_NFO_STURBO_NODE#?() to access them in CB.
            Always check the  Tail[1] == Head[0]  to avoid doubled ops. The
            other 2 entries are caches.

stu_lhtab
         -  Address  of the pointer  to the array  of lists. With dedicated
            macros it's possible to get array ptr = QDEV_NFO_STURBO_LISTA()
            or current list ptr = QDEV_NFO_STURBO_LISTP().

stu_btab -  Break table of  2 LONGs, that gets stuffed in *stu_lhtab if one
            wants to get out of the loop.

stu_udata
         -  User data are available here.

stu_ures -  User  result variable. This is  the return value of a function.
            It's important to alter it (to something different than 0) when
            used in a conditional statement.



struct mod_ktl_head
{
  struct MemChunk  kh_mc;
  ULONG           *kh_ar[2];
  struct Resident  kh_rt;
  struct MemList   kh_ml;
};

kh_mc    -  Absolute allocation memory mark aka MemChunk. This will be used
            by the bootstrap to reallocate this block.

kh_ar    -  Local  singly linked,  double node scrambling. In  effect after
            linking against OS chains([0] - Resident, [1] - Next entry).

kh_rt    -  Resident module node area, the control/info block. You must use
            this  field  regardless of  already prepared block! Just make a
            copy and NULL the old one out.

kh_ml    -  MemoryList that will carry this very memory block. This is done
            when  linking the module against  OS chains with module related
            functions. Warning,  the use of  QDEV_MEM_REGALIGN() macro is a
            must before ever allocating the memory!



struct mod_ade_feed
{
  ULONG    af_memflags;
  ULONG    af_memstart;
  ULONG    af_memend;
  UBYTE   *af_dataptr;
  LONG     af_datalen;
  ULONG    af_rtflags;
  UBYTE    af_type;
  BYTE     af_pri;
  UBYTE    af_ver;
  UBYTE   *af_nameptr;
  UBYTE   *af_idstrptr;
};

af_memflags
         -  Standard  memory  flags  such  as  MEMF_CHIP or  MEMF_PUBLIC or
            MEMF_LOCAL along with MEMF_CLEAR.

af_memstart
         -  Physical  start address of possible allocation. This  should be
            start of the memory node but can be approximated absolute start
            of memory region. Use QDEV_MOD_ADE_#? macros.

af_memend
         -  Physical  end address of  possible allocation. State  where the
            range ends. Use QDEV_MOD_ADE_#? macros.

af_dataptr
         -  Pointer to  data you want the module  to carry. Pass NULL if no
            data  nor  code. On  success  address this  member carries will
            change to point at the module data/space!

af_datalen
         -  Length  of that data  or length to  just allocate  the space if
            af_dataptr is NULL. Pass 0 if no allocation is to be made.

af_rtflags
         -  Standard  Resident flags to put in the info/control block. This
            is typically to be RTF_COLDSTART.

af_type  -  NT_xxx type of the object, can be anything you like.

af_pri   -  Priority of the module. This really matters when bootstrapping.
            You  must know when  your module can  be initialized. Use  some
            system monitor to study all modules in the OS. Usually 0.

af_ver   -  Standard version notation.

af_nameptr
         -  Name  of your module. On  success address  this member  carries
            will change to point at the name in the module!

af_idstrptr
         -  Identification  string your  module will  get. Can  be NULL. On
            success address this member carries will change to point at the
            ID string in the module!



struct mod_adi_feed
{
  ULONG    af_memflags;
  ULONG    af_memstart;
  ULONG    af_memend;
  ULONG    af_flags;
  LONG     af_error;
};

af_memflags
         -  Standard  memory  flags  such  as  MEMF_CHIP or  MEMF_PUBLIC or
            MEMF_LOCAL along with MEMF_CLEAR.

af_memstart
         -  Physical  start address of possible allocation. This  should be
            start of the memory node but can be approximated absolute start
            of memory region. Use QDEV_MOD_ADE_#? macros.

af_memend
         -  Physical  end address of  possible allocation. State  where the
            range ends. Use QDEV_MOD_ADE_#? macros.

af_flags -  Loader  related control flags. There is just one flag now which
            allows to load and relocate all sections.

af_error -  Dos  borrowed  errors codes. Following  codes are  pre-defined:
            ERROR_OBJECT_LINKED - May  appear when  KTP/KMP linking failed.
            ERROR_OBJECT_EXISTS - The module  of such name  already in mem.
            ERROR_OBJECT_NOT_FOUND - Will appear when binary is ROMTAGless.
            ERROR_OBJECT_TOO_LARGE - Will  appear  when  binary  comes with
            additional  segments  and   QDEV_MOD_DISKMOD_FLOADALL  was  not
            specified. Other  than  that  InternalLoadSeg()  may return its
            error value here too. If this member is zero after failure then
            there was not enough memory.



struct dev_ddv_data
{
  struct MsgPort *dd_mp;
  struct IOExtTD *dd_iotd;
  void           *dd_usercode;
  void           *dd_userdata;
};

dd_mp    -  Device message port. Pretty much standard thing.

dd_iotd  -  Device  request space. By  default  all TD related  devices are
            supported.

dd_usercode
         -  User code  pointer that will be  passed to the callback. Can be
            whatever user wants.

dd_userdata
         -  User data  pointer that will be  passed to the callback. Can be
            whatever user wants.



struct qfile
{
  struct MsgPort        *qf_mp;
  struct StandardPacket  qf_sp;
  LONG                   qf_in;
  LONG                   qf_mo;
  LONG                   qf_er;
  LONG                   qf_si;
  LONG                   qf_ti;
  LONG                   qf_fd;
};

qf_mp    -  Quick  file message port that  is used to do  asynchronous ops.

qf_sp    -  Standard DOS  packet that is used to carry messages to/from the
            handler.

qf_in    -  Int. operation  indicator that also acts as a simple semaphore.

qf_mo    -  Quick file mode. Either synchronous or asynchronous.

qf_er    -  Internal I/O error  latch, used as a security guard, so risk of
            ditching FH or disk space is reduced.

qf_si    -  Signal bit used to get out of wait state temporarily.

qf_ti    -  Request status probing interval in ticks. By default this is 3.

qf_fd    -  Real   FileHandle  as  obtained  with  Open(). Do  not  use  it
            directly!



 Private structures
###########################################################################



struct ctl_cph_data
{
  BPTR cd_next;
  BPTR cd_lock;
};

cd_next  -  This can  point at next such structure  or be NULL  if no  more
            entries.

cd_lock  -  Standard  shared lock that points  at some directory or assign.



struct ctl_unm_res
{
  struct Library     ur_lib;
  struct Interrupt   ur_is;
  void             (*ur_devhan)(
                      REGARG(struct MsgPort *, a1));
  ULONG            (*ur_inject)(REGARG(ULONG, d0),
                                REGARG(void *, a1));
  UBYTE              ur_name[QDEV_CTL_PRV_RNAMELEN];
};

ur_lib   -  Dummy packet handler resource structure that will be created as
            soon as something needs to be unmounted forcibly.

ur_is    -  Interrupt  skeleton that carries dummy packet  handler pointer.

ur_devhan
         -  Dummy packet handler itself. Current implementation tries to be
            comaptible with most filesystems around.

ur_inject
         -  Process  exit injection  function. When  put into tc_ExceptCode
            and  when  tc_ExceptData = (APTR)((ULONG)pr->pr_ReturnAddr - 4)
            can terminate the process at any point without major quirks. Of
            course exception stuff must be prepared!

ur_name  -  Buffer  space to store the  name of this  resource. The text is
            NULL terminated.



struct ctl_trg_data
{
  struct ctl_csn_cwin      td_cc;
  struct ctl_csn_ient      td_ci;
  struct SignalSemaphore   td_trigsem;
  WORD                     td_spad;
  struct Window          **td_trigfwin;
  struct Task             *td_trigtask;
  volatile LONG            td_trigcnt;
  LONG                     td_trigbar;
  UBYTE                    td_trigcol[2];
};

td_cc    -  The toggle  window that is of 1 pixel in the top-left corner of
            the screen.

td_ci    -  IDCMP_ACTIVEWINDOW  handler carry. Whenever this window becomes
            active a toggle action will be taken.

td_trigsem
         -  Since title bar toggle is being done  in the subtask there must
            be some sort of arbitration.

td_spad  -  Semaphore  aligner so  the  rest of  members is  LONG  aligned.

td_trigfwin
         -  Focus-back  carry that  will be  activated after tc_cc was  LMB
            treated.

td_trigtask
         -  Address  of the task that  will do the  toggle. This  member is
            being used in the exception handler.

td_trigcnt
         -  Number  of toggle tasks that  were spawned. They are td_trigsem
            protected.

td_trigbar
         -  Internal title bar visible/invisible toggle. Pure logic(0 / 1).

td_trigcol
         -  Pen numbers used to mask that 1 pixel when title bar is visible
            or invisible.



struct ctl_acl_data
{
  struct ctl_csn_cwin    *ad_cc;
  struct SignalSemaphore  ad_dsem;
  WORD                    ad_spad;
  struct BitMap          *ad_bm;
  struct GfxBase         *ad_gb;
  struct Task            *ad_task;
  void                  (*ad_forbid)();
  void                  (*ad_permit)();
  volatile LONG           ad_cnt;
  struct ctl_csn_ient     ad_ev;
  LONG                    ad_rectx;
  LONG                    ad_recty;
  LONG                    ad_logox;
  LONG                    ad_logoy;
  LONG                    ad_startx;
  LONG                    ad_starty;
  LONG                    ad_bmapx;
  LONG                    ad_bmapy;
};

ad_cc    -  One  of  the console windows that  the  logo is now  associated
            with.

ad_dsem  -  Semaphore  that is being used to arbitrate logo refreshing such
            as when refreshing subtasks were spawned in parallel.

ad_spad  -  Semaphore  aligner so  the  rest of  members is  LONG  aligned.

ad_bm    -  Logo  bitmap. This is  usually in standard Amiga format, but no
            guarantee that it actually is.

ad_gb    -  Locally buffered GfxBase. Used  to pass across subtasks so they
            can access graphics.library functions quickly.

ad_task  -  A  subtask  that will be  signalled after  local  exception  is
            complete. This very subtask will be the refresher!

ad_forbid
         -  Wrapper function used on OS with console.device V39 and less to
            fix race  condition that may occurr when  rendering to window's
            RastPort that is owned by the console handler.

ad_permit
         -  See ad_forbid for more details.

ad_cnt   -  Safety  counter, so there is a limit on parallel subtasks which
            prevents mess.

ad_ev    -  IDCMP_REFRESHWINDOW event carry.

ad_rectx -  Total rendition area in X axis available to the logo. This acts
            as a trimmer.

ad_recty -  Total rendition area in Y axis available to the logo. This acts
            as a trimmer.

ad_logox -  Effective rendition area  for X  axis. This gets  computed from
            ad_rectx, ad_startx, and ad_bmapx.

ad_logoy -  Effective rendition area  for Y  axis. This gets  computed from
            ad_recty, ad_starty, and ad_bmapy.

ad_startx
         -  X coordinate  to start drawing at. This  gets copied from func.
            input.

ad_starty
         -  Y coordinate  to start drawing at. This  gets copied from func.
            input.

ad_bmapx -  Logo bitmap size in pixels for X axis. This gets extracted with
            the help of graphics.library.

ad_bmapy -  Logo bitmap size in pixels for Y axis. This gets extracted with
            the help of graphics.library.



struct ctl_acf_data
{
  struct ctl_csn_cwin     *ad_cc;
  struct SignalSemaphore   ad_sem;
  WORD                     ad_spad;
  struct Task             *ad_task;
  struct BitMap          **ad_bm;
  struct BitMap          **ad_lbm;
  struct MsgPort          *ad_tmp;
  struct timerequest      *ad_treq;
  ULONG                    ad_fdly;
  ULONG                    ad_cdly;
  UWORD                    ad_xpos;
  UWORD                    ad_ypos;
  void                    *ad_logo;
  LONG                     ad_pri;
  void                   (*ad_start)(struct ctl_acf_data *);
  void                   (*ad_stop)(struct ctl_acf_data *);
  struct ctl_csn_ient      ad_eva;
  struct ctl_csn_ient      ad_evi;
};

ad_cc    -  One  of  the console windows that  the  logo is now  associated
            with.

ad_sem   -  This semaphore is used to control anim subtask installation and
            removal. It  prevents  deadend  situation when calling dealloc.
            function.

ad_spad  -  Semaphore  aligner so  the  rest of  members is  LONG  aligned.

ad_task  -  An address of current  anim subtask. There can be only one such
            subtask. This is also used as an indication.

ad_bm    -  NULL terminated  array of logo bitmaps. Switching from frame to
            frame is as simple as can be.

ad_lbm   -  Last time bitmap address. This is the switching pointer. If you
            will  ad_stop() and then  ad_start() then the animation will be
            resumed when it was stopped.

ad_tmp   -  Timer msg. port. Used as a part of timer.device initialization.

ad_treq  -  Timer  resquest space. Used to send  frame and/or cycle delays.

ad_fdly  -  Frame delay in micros.

ad_cdly  -  Cycle delay in micros.

ad_xpos  -  X coordinate to start animating at. This gets copied from func.
            input.

ad_ypos  -  Y coordinate to start animating at. This gets copied from func.
            input.

ad_logo  -  All  the logo  related  internals. See  ctl_acl_data structure.

ad_pri   -  Anim subtask  priority. It  is always computed to be lower than
            the mother's priority.

ad_start -  Logo  playback  control  hook. This  one  starts  the playback.

ad_stop  -  Terminates  animation subtask  causing animation to freeze. The
            ad_start will resume the animation where it was stopped.

ad_eva   -  IDCMP_ACTIVEWINDOW handler carry.

ad_evi   -  IDCMP_INACTIVEWINDOW handler carry.



struct ctl_csn_wrap
{
  void               (*cw_wrapcode)(
                       struct ctl_csn_cwin *, void *);
  void                *cw_wrapdata;
  void                *cw_userdata;
};

cw_wrapcode
         -  Code that will be wrapped. You want to pass  cc_idcmpcode[n] in
            here. You  then glue  your code to  cc_idcmpcode[n]. When  your
            current code  gets executed  you call  QDEV_CTL_PRV_CWEXECUTE()
            macro to execute wrapped code.

cw_wrapdata
         -  Data(cc_idcmpdata[n]) that  will be put to wrapped cw_wrapcode.

cw_userdata
         -  User data  pointer that  will be  passed  in  argument 2 of the
            pseudo-interrupt function. Can be whatever user wants.



struct ctl_avc_data
{
  struct ctl_csn_data  *ad_cd;
  struct ctl_csn_cwin  *ad_cc;
  struct GfxBase       *ad_gb;
  struct IntuitionBase *ad_ib;
  struct Library       *ad_lb;
  struct Layer         *ad_layer;
  struct Task          *ad_task;
  volatile LONG         ad_cnt;
  struct ctl_csn_ient   ad_evia;
  struct ctl_csn_ient   ad_evib;
  LONG                  ad_flga;
  LONG                  ad_flgb;
  LONG                  ad_rflg;
  LONG                  ad_efct;
  LONG                  ad_mfct;
  WORD                  ad_xosd;
  WORD                  ad_yosd;
  ULONG                 ad_xcosd;
  ULONG                 ad_ycosd;
};

ad_cd    -  Locally buffered console screen  that is needed for things like
            screen's bitmap poking, semaphore switching, layer creation and
            the like.

ad_cc    -  This member is used in pseudo-interrupt as well as subtask that
            this pseudo-interrupt has created. Tricky!

ad_gb    -  Locally buffered GfxBase. Used  to pass across subtasks so they
            can access graphics.library functions quickly.

ad_ib    -  Locally  buffered IntuitionBase. This is  used to  pass  across
            subtasks so they can access intuition.library functions fast.

ad_lb    -  Locally  buffered  LayersBase. This  is  used  to  pass  across
            subtasks so they can access layers.library functions fast.

ad_layer -  The OSD layer. Not a faully qualified window though!

ad_task  -  Subtasks  get created for a  brief moment. They  never wait for
            the events. This  is good at one  side, cus they do not take up
            memory  for too long, but  on the  other  hand on  demand  task
            creation may be really slow under some circumstances. You  dont
            want to touch this, cus  whole op is  very atomic  and what was
            valid a second ago is surely invalid now.

ad_cnt   -  Subtask  counter, the  limiter, global  subsystem   protection.

ad_evia  -  IDCMP_MOUSEMOVE  handler carry. Used to activate the one below.

ad_evib  -  IDCMP_VANILLAKEY  handler carry. This  handler  allows keyboard
            stuff in console window.

ad_flga  -  Mouse  move  pseudo-interrupt  latch. This is used to establish
            the OSD when mouse is at certain position.

ad_flgb  -  Window  zoom  flags that get  pre-set in  the pseudo-interrupt.

ad_rflg  -  Rearrange  flags  that get  pre-set  in  the  pseudo-interrupt.

ad_efct  -  Effective zoom factor in  %. This is used as a direction of the
            zoom.

ad_mfct  -  A  copy of zoom  factor in  %  as taken  from  function  input.

ad_xosd  -  Size of the OSD layer in X axis in pixels.

ad_yosd  -  Size of the OSD layer in Y axis in pixels.

ad_xcosd -  How  many characters are needed for X resolution to display it.

ad_ycosd -  How  many characters are needed for Y resolution to display it.



struct dev_nsd_data
{
  ULONG nd_devqueryformat;
  ULONG nd_sizeavailable;
  UWORD nd_devicetype;
  UWORD nd_devicesubtype;
  UWORD *nd_suppcommands;
};

nd_devqueryformat
         -  According  to the  NSD  manual, device query  type is always 0.

nd_sizeavailable
         -  Tells you how much(bytes) of the structure contains valid data.
            The minimum valid value is 16.

nd_devicetype
         -  This tells you about the  NSD type of device you are accessing.
            If  a device returns  such a type,  then it must  be able to at
            least handle all the documented features for V40 of the OS.

nd_devicesubtype
         -  There might  be special incarnations  of a device  with special
            capabilities  beyond the standard  set. At the moment  none are
            defined and a device is required to return 0 here.

nd_suppcommands
        -   This points to a NULL terminated list of io_Command values that
            are supported by the device. In case of  IOERR_NOCMD the device
            is considered non-NSD.



struct dos_fdr_main
{
  void                *fm_cluster;
  struct MinList       fm_chanlist;
  struct MinList       fm_clilist;
  struct dos_fdr_chan *fm_chandef;
  LONG                 fm_chancount;
  LONG                 fm_fdtotal;
  LONG                 fm_clitotal;
  LONG                 fm_fdcheck;
  UBYTE               *fm_devname;
  LONG                 fm_flushreq;
  LONG                 fm_flushcnt;
  LONG                 fm_flushnum;
  struct DosList      *fm_dol;
  struct DosPacket    *fm_dp;
  struct timerequest   fm_treq;
  void                *fm_gluefp;
};

fm_cluster
         -  Memory cluster where all the clients live. Consider this memory
            pool where each allocation is of fixed size, requires no global
            arbitration and is incredibly fast upon chunk request.

fm_chanlist
         -  A list of all channels created so far on this descriptor relay.

fm_clilist
         -  A list of all descriptor relay clients/callers.

fm_chandef
         -  So called default channel when calling by "*" or "CONSOLE:". It
            can be set/changed at any point. By default there is no default
            channel but when called a "NULL" channel is created.

fm_chancount
         -  Total number of channels created and maintained. This count can
            decrease in case  channel-self-termination-when-no-clients  was
            set.

fm_fdtotal
         -  Total number of all file descriptors handled right now.

fm_clitotal
         -  Total number of clients/callers linked to the descriptor relay.

fm_fdcheck
         -  Reference address used  to check against  each FileHandle. This
            in particular is fh_Func1.

fm_devname
         -  This  member points at the  device name. The name is colonless.

fm_flushreq
         -  After how many addressed channel calls, dead channels(marked as
            killable when no client) should be flushed.

fm_fluchcnt
         -  Current addressed channel access count. This wraps at crca 255!

fm_flushnum
         -  Number of channels that were removed at this time. This is only
            useful when debugging.

fm_dol   -  This Doslist pointer is here just to make inter-function access
            quicker. It really points at the device node!

fm_dp    -  Main DOS packet pointer, also here to make it all look simplier
            when dealing with nested calls.

fm_treq  -  This  is  not a  primary  timer  request  space as you may have
            guessed. It is only a template that gets copied per instance!

fm_gluefp
         -  Standalone  packet glue  I/O,  a  real interrupt  function that
            gets loaded from separate segment! This function is responsible
            for fh_Arg1  injection into dp_Res2,  so that  all packets  are
            fully operational from a single process.



struct dos_fdr_stat
{
  LONG                 fs_statlen;
  UBYTE               *fs_statptr;
  UBYTE                fs_statbuf[QDEV_DOS_PRV_MINLEN];
};

fs_statlen
         -  Size  of  the  human  readable  data  that  occupy  the buffer.
            This will be decreasing during reading.

fs_statptr
         -  Position in the buffer,  this is moving pointer it changes upon
            each read attempt.

fs_statbuf
         -  Data buffer itself. No  new members allowed beyond its point as
            the area is implicit and may vary in size!



struct dos_fdr_glue
{
  struct Interrupt     fg_is;
  struct MsgPort       fg_mp;
};

fg_is    -  Interrupt that defines the packet glue logic and the data to be
            delivered to this very interrupt.

fg_mp    -  Private(as per caller) message port that triggers the interrupt
            as defined above.



struct dos_fdr_llac
{
  struct MinNode       fl_node;
  struct MinNode       fl_pnode;
  struct dos_fdr_glue  fl_fg;
  void                *fl_ptr;
  ULONG                fl_status;
  ULONG                fl_chrstore;
  LONG                 fl_rollrlen;
  LONG                 fl_rollrpos;
  LONG                 fl_flags;
  ULONG                fl_tcaddr;
  struct timerequest   fl_treq;
  struct DosPacket     fl_tdp;
};

fl_node  -  Standard, minimal node to be able to create list - client list.

fl_pnode -  Kludgy pipe related node. This  is used to redirect  clients to
            particular pools(read, write, wait) when dealing with pipes.

fl_fg    -  Packet glue logic that defines where to inject what when packet
            action is requested.

fl_ptr   -  Channel pointer  this client is now  associated with(if lucky).

fl_status
         -  Type of chan as assigned to fl_ptr. Can be QDEV_DOS_PRV_#?STAT.

fl_chrstore
         -  Depending  on channel  type this  member can be  used to  store
            single character as used by the ANSI filter or packet carry.

fl_rollrlen
         -  Depending  on channel  type this  member can be  used to  store
            size of the rollover area or to carry packet argument.

fl_rollrpos
         -  Depending  on channel  type this  member can be  used to  store
            current position in the rollover area or to carry packet arg.

fl_flags -  Channel behaviour flags as defined in QDEV_DOS_PRV_F#?.

fl_tcaddr
         -  Caller  task/process address. This  address gets  buffered upon
            first client call.

fl_treq  -  Real, private  timer request  space needed  to implement single
            process WaitForChar().

fl_tdp   -  Real, private  timer packet needed  to implement single process
            WaitForChar().



struct dos_fdr_chan
{
  struct MinNode       fc_node;
  struct dos_fdr_llac *fc_fl;
  struct dos_fdr_file *fc_vff;
  struct DateTime      fc_chandat;
  struct MinList       fc_fdlist;
  LONG                 fc_fdcount;
  LONG                 fc_clicount;
  LONG                 fc_clfiles;
  LONG                 fc_striplen;
  UBYTE               *fc_stripbuf;
  UBYTE               *fc_stripend;
  ULONG                fc_passhash;
  ULONG                fc_status;
  LONG                 fc_vcrstate;
  LONG                 fc_vcrchr;
  struct DosPacket     fc_vcrdp;
  struct EClockVal     fc_vcrev;
  UBYTE                fc_vcrseq[QDEV_CNV_UXXXLEN];
  ULONG                fc_reserved[QDEV_DOS_PRV_RESERVED];
  UBYTE                fc_channame[QDEV_DOS_PRV_CHNAMLEN];
  UBYTE                fc_chfmtbuf[QDEV_DOS_PRV_CHFMTLEN];
  UBYTE                fc_chfmtout[QDEV_DOS_PRV_CHFMTLEN];
};

fc_node  -  Standard minimal node to be able to create list - channel list.

fc_fl    -  Kludgy client  forwarding pointer. This  is used so that client
            memory gets extracted only once for all lower level functions.

fc_vff   -  So called "virtual file" - the rollover buffer file.

fc_chandat
         -  Channel creation datestamp in DOS format.

fc_fdlist
         -  All files attached to this channel. All files that will be fed
            with data upon relay attempt.

fc_fdcount
         -  Number of files on the fc_fdlist list.

fc_clicount
         -  Client count on this channel.

fc_clfiles
         -  Close files boolean. This is used to tell the descriptor relay
            that  when last  client disconnects or  there no clients for n
            addresed channel calls then these files should be closed.

fc_striplen
         -  Size of the ANSI filter buffer.

fc_stripbuf
         -  ANSI filter buffer pointer.

fc_stripend
         -  ANSI filter pointer indicator.

fc_passhash
         -  Hash of a password this channels is protected with. This is all
            symbolic.

fc_status
         -  Type  of this channel. Can  be what QDEV_DOS_PRV_#?STAT define.

fc_vcrstate
         -  Video Cassette Recorder boolean. This  allows to  record  relay
            channel flow to a file with or without exact delays.

fc_vcrchr
         -  Last VCR character as sliced by the packets to track ANSI seqs.

fc_vcrdp -  Very  special VCR packet  that takes part in all  other  packet
            or data tracing process.

fc_vcrev -  Packet  delay storage. Primarely  it was in fact EClockVal  but
            now it is timeval in the sense of contents!

fc_vcrseq
         -  Special VCR  ANSI time sequence  that gets  appended after each
            received packet. This is clear-text!

fc_reserved
         -  Reserved area. Can be used by hackers for any purpose.

fc_channame
         -  This  channel  name.  Normal  NULL  terminated  string  though.

fc_chfmtbuf
         -  Buffer that is intended to carry user defined prefixes that may
            appear before each clear-text line. Additional predefined modes
            are available by using %.

fc_chfmtout
         -  Buffer  that stores  exapanded  fc_chfmtbuf. The  visible text.



struct dos_fdr_file
{
  struct MinNode       ff_node;
  struct MinList       ff_rlist;
  struct MinList       ff_wlist;
  struct MinList       ff_alist;
  LONG                 ff_awaits;
  LONG                 ff_xmode;
  LONG                 ff_fmtbool;
  LONG                 ff_stripansi;
  LONG                 ff_fdaddr;
  LONG                 ff_fdclose;
  LONG                 ff_fdbuf;
  UBYTE               *ff_fdvptr;
  ULONG                ff_fdvsize;
  ULONG                ff_failcnt;
  ULONG                ff_tcaddr;
  ULONG                ff_tcsig;
  UBYTE                ff_fname[QDEV_DOS_PRV_FNAMELEN];
};

ff_node  -  Standard,  minimal node to  be able to create list - file list.

ff_rlist -  List of all clients who  wait to read something but there is no
            writer at the moment.

ff_wlist -  List of all clients who wait to write something but there is no
            reader at the moment.

ff_alist -  List of all clients who  wait for key stroke and  who will time
            out eventually.

ff_awaits
         -  A variable that gets increased each time clients must be put to
            sleep.

ff_xmode -  This is RAW or CON  mode indicator as set by  the corresponding
            DOS function.

ff_fmtbool
         -  Shall the fc_chfmtout be put in front of new line for this file
            boolean. This is not user switch!

ff_stripansi
         -  Tri-state switch  responsible for ANSI filtering. From  type of
            file point of view its context varies! For normal files it does
            trigger ANSI filtering on write, but for  virtual files only on
            read request! This member can also trigger VCR if -2.

ff_fdaddr
         -  Real file FileHandle, also called file descriptor.

ff_fdclose
         -  Should ff_fdaddr be  closed on channel  and or descriptor relay
            termination boolean.

ff_fdbuf -  Should ff_fdaddr  be buffered or not  boolean. This  can be set
            only when no ops where requested on the FileHandle.

ff_fdvptr
         -  Virtual file data buffer pointer. Allocated  automatically dont
            touch!

ff_fdvsize
         -  Virtual file data buffer size. The rollover area.

ff_failcnt
         -  How many relay packets  failed to pass thru  ff_fdaddr counter.

ff_tcaddr
         -  Address  of a task or process who owns the ff_fdaddr. The addr.
            will be validated before any op.

ff_tcsig -  Signal to be send to ff_tcaddr if channel  or relay get killed.
            This is mutual  exclusive to ff_fdclose. If  this is  0 then no
            signal will be generated.

ff_fname -  Shortened name of this relay file. Normal NULL terminated text.



struct dos_alp_llac
{
  struct MinNode        al_node;
  struct FileLock       al_fl;
  LONG                  al_fdaddr;
  struct FileInfoBlock  al_fib;
  ULONG                 al_flags;
  LONG                  al_wait;
  struct Process       *al_pr;
  struct Process       *al_cpr;
};

al_node  -  Standard, minimal node to be able to create list - client list.

al_fl    -  Standard  OS lock structure. Pay  attention to where it resides
            as this structure serves as 'call' and 'lock' at the same time!

al_fdaddr
         -  Real FileHandle that gets wrapped through this call.

al_fib   -  Copy of FileInfoBlock as found in the dos_alp_file. Needed here
            due to possible disk changing!

al_flags -  Wrapped  file flags. This member is considered private for now!

al_wait  -  Own packet interface  timeout. Quite useful thing  when working
            on network files. Values expressed is seconds.

al_pr    -  Process  that is now associated  with this caller. This process
            is responsible for dispatching plain I/O packets.

al_cpr   -  CLI process that executes user code. This can be very tricky as
            this may be associated per file, thus one caller may serve as a
            CLI guard!



struct dos_alp_file
{
  struct MinNode        af_node;
  struct FileInfoBlock  af_fib;
  ULONG                 af_flags;
  LONG                  af_wait;
  UBYTE                 af_tasks[QDEV_DOS_PRV_FLMAXLEN];
  UBYTE                 af_cli[QDEV_DOS_PRV_FLMAXLEN];
  UBYTE                *af_cmd;
  UBYTE                *af_args;
};

af_node  -  Standard,  minimal node to  be able to create list - file list.

af_fib   -  FileInfoBlock  as established  upon this node creation. Members
            that are unknown at creation get filled upon file call.

af_flags -  Private dos_alp_file flags. Currently used to mark circularity.

af_wait  -  Timeout  per caller packet  interface as  provided by the user.

af_tasks -  Comma separated  list  of  tasks that are  allowed or denied to
            access this file. AmigaOS patterns are allowed here.

af_cli   -  CLI command buffer. This  is used to carry command name and its
            arguments.

af_cmd   -  CLI command name pointer(af_cli related). 

af_args  -  CLI command arguments pointer(af_cli related).



struct dos_alp_main
{
  void                 *am_cluster;
  void                 *am_fcluster;
  struct MinList        am_links;
  struct MinList        am_clilist;
  UBYTE                *am_devname;
  struct DosList       *am_dol;
  struct DosList        am_vol;
  struct DosPacket     *am_dp;
  void                 *am_last;
  struct dos_alp_file   am_af;
  LONG                  am_isfs;
  LONG                  am_wrprot;
  LONG                  am_dfiles;
  LONG                  am_filenull;
  UBYTE                 am_fileline[QDEV_DOS_PRV_MAXARGLEN];
  UBYTE                 am_argline[QDEV_DOS_PRV_MAXARGLEN];
};

am_cluster
         -  Memory cluster where all the clients live. Consider this memory
            pool where each allocation is of fixed size, requires no global
            arbitration and is incredibly fast upon chunk request.

am_fcluster
         -  Memory cluster that files  use. Can auto expand at any point as
            opposed to am_cluster.

am_links -  List of all links(wrapped files, dos_alp_file).

am_clilist
         -  A  list of all callers who  were granted  access to real files.

am_devname
         -  This  member points at the  device name. The name is colonless.

am_dol   -  This Doslist pointer is here just to make inter-function access
            quicker. It really points at the device node!

am_vol   -  Virtual device volume that is really a copy of am_dol, but acts
            as a fully qualified volume.

am_dp    -  Main DOS packet pointer, also here to make it all look simplier
            when dealing with nested calls.

am_last  -  As linkpoint really tries to maintain consistent file list that
            never  changes on addressation this member is serves  as a list
            terminator.

am_af    -  Root object(ST_ROOT). This  file although not  on the file list
            is a kickstart for other files.

am_isfs  -  Dynamic filesystem indicator. This toggles when linkpoint is to
            be stream device only.

am_wrprot
         -  Write protection indicator.

am_dfiles
         -  Discarded files count. This  is used to tell the used that some
            of the  files could not be mapped. The  info can be obtained by
            using  'Info'  command, where  Errors  field will reflect  this
            member.

am_filenull
         -  NULL in am_fileline position indicator.

am_fileline
         -  This  buffer is used to store real  file locations while making
            a list of wrapped files.

am_argline
         -  This buffer is used to store LPX  arguments who then get parsed
            by ReadArgs().



struct dos_mde_wrap
{
  struct DosList mw_dol;
  UBYTE          mw_name[QDEV_DOS_PRV_NAMELEN];
};

mw_dol   -  Standard DosList that acts as a device node.

mw_name  -  Name of the DOS device. Unscrambled  BSTR with NULL terminator!



struct mem_coe_data
{
  void  (*cd_switch)();
  ULONG   cd_signal;
};

cd_switch
         -  Old  tc_Switch  function pointer. This gets executed in the new
            switch function.

cd_signal
         -  Signal that  will be used to wakeup this task,  after all other
            tasks are complete.



struct qarea
{
  struct SignalSemaphore  qa_dst;
  struct List             qa_ulist;
  LONG                   *qa_slot[QDEV_MEM_PRV_TOTALQSLOTS];
};

qa_dst   -  Private,  but  global signal  semaphore  that is  used  by  the 
            mem_dosynctask() to protect against mid-way sync. attempts.

qa_ulist -  A  list where anyone  can link in some critical/global data and
            then resolve them quick. It's recommended to disable interrupts
            while adding or removing nodes!

qa_slot  -  Array of  pointers for even quicker data resolving. To use this
            you  will have to grab a  slot  check if it is empty(NULL)  and
            attach  the address. If  there is no empty  slots then you will
            have to use qa_ulist.



struct mem_exr_rman
{
  LONG              *er_entflags;
  LONG              *er_reserved;
  LONG             (*er_remote)(LONG, void *, void *, void *);
};

er_entflags
         -  Pointer to flags that describe this slot when  ei_entflags sets
            the  remote management flag  (QDEV_MEM_PRV_FEXTINIT). These are
            flags of the upper level slot allocator.

er_reserved
         -  Reserved for further use. Not intended for storing user address
            as it may be utilised by handler allocator.

er_remote
         -  Remote init/kill routine that gets called if ei_entflags define
            external init. Argument assignment: 1 = level, 2 = ei_userdata,
            3 = usercode (actual),  4 = userdata (actual). The routine must
            return 1 on success and 0 on failure when initalizing.



struct mem_exr_ient
{
  LONG               ei_entflags;
  ULONG            (*ei_usercode)
              (REGARG(ULONG, d0),
             REGARG(void *, a1));
  APTR              *ei_userdata;
};

ei_entflags
         -  Flags  that describe this slot. This  is private and should not
            be altered unless you know what you are doing.

ei_usercode
         -  User exception code that is associated with signal bit. You can
            swap  this code freely. This  can effectively be set to NULL if
            no exception is desired under some circumstances.

ei_userdata
         -  User data that will be passed in argument 2 on the ei_usercode.



struct mem_exr_glob
{
  ULONG                eg_status;
  ULONG                eg_count;
  struct mem_exr_ient  eg_ei[(QDEV_MEM_PRV_MAXINDEX + 1)];
};

eg_status
         -  Global exception struct. identification. QDEV_MEM_PRV_STATUSID.

eg_count -  Number  of private task  exception handlers  that are currently
            active. Not counting primary exception handler!

eg_ei    -  Exception  routine slots. There is exactly 32 slots as there is
            exactly  32  possible signals. The  additional  slot holds  the 
            primary  exception handler at the time of first init so it will
            be called like there was no modification to the task.



struct mem_hot_root
{
  ULONG   hr_id;
  ULONG   hr_hh;
  ULONG   hr_ent;
  UBYTE   hr_name[QDEV_PRV_MEM_HOT_NLEN];
  LONG  **hr_vec;
};

hr_id    -  Hot vector array  identification value. Must never be 0. Values
            upto 0x003FFFFF are private to 'qdev' which means you shall not
            use them. Values from 0x00400000 to 0x7FFFFFFF are public which
            means you can use them. Values from 0x80000000 are intended for
            dynamic allocations only.

hr_hh    -  Hot  vector root hash  value. Currently there is no use for it.

hr_ent   -  Number of vectors in this array. You may always expect at least
            4 vectors of sizeof(LONG *) each.

hr_name  -  Buffer  for the name of this  hot vector array. Name is defined
            in QDEV_PRV_MEM_HOT_NAME. It is a stub as function that obtains
            vector  never checks this  but expects  that ml_Node.ln_Name is
            not NULL.

hr_vec   -  Pointer to hot vector array. The array  starts right after this
            member.



struct mem_ifh_data
{
  struct Message    *id_me;
  struct DosPacket  *id_dp;
  struct FileHandle *id_fh;
  struct MsgPort     id_mp;
  struct MsgPort    *id_mpp;
  void              *id_dataptr;
  LONG               id_datalen;
  LONG               id_datapos;
  LONG               id_datatrk;
  LONG               id_readlen;
  LONG               id_readpos;
  LONG              *id_datappos;
  LONG              *id_dataptrk;
  LONG              *id_readplen;
  LONG              *id_readppos;
  LONG               id_fd;
  LONG               id_res1;
  LONG               id_res2;
};

id_me    -  Message pointer  used in  the macros. Probably  useless most of
            the time, but quite helpful when debugging.

id_dp    -  Handy  DosPacket  pointer that handlers can use when extracting
            the message.

id_fh    -  Very special FileHandle that defines the basics of this virtual
            file.

id_mp    -  Artifficial  message port that triggers private excpetion which
            contains packet handler for this virtual file.

id_mpp   -  MsgPort pointer used in the macros. Aside from swapping message
            port also useful when debugging.

id_dataptr
         -  Virtual  file  buffer  pointer. This should point at the memory
            that will be Read() or Write() affected.

id_datalen
         -  Virtual file buffer size.

id_datapos
         -  Depending  on handler  implementation this can be used to track
            cursor pos., but can be used to do something totally different.

id_datatrk
         -  Depending  in handler  implementation this  can be used to mark
            end of  buffer, but of  course you  may use it  to do something
            else.

id_readlen
         -  Reading can  use its own variables, so this is the purpose, but
            as stated above you may make other uses of it.

id_readpos
         -  Reading can have different cursor positioning if you like. This
            member  can be used the other way as well. It  is up to you how
            it all will be arranged.

id_datappos
         -  You may operate on  pointers in the handler code rather than on
            integers directly. This has some advantages, such as it is very
            easy(id_datappos = &id_datapos) to hack on the virtual file. By
            default tied to id_datapos.

id_dataptrk
         -  Same as above. By default tied to id_datatrk integer. One  such
            handler that uses these pointers is han_rollifh().

id_readplen
         -  Also a handy pointer that is tied to id_readlen integer.

id_readppos
         -  Same as above. By default tied to id_readpos integer.

id_fd    -  BPTR'ed id_fh.

id_res1  -  Doubled/feedback  dp_Res1  to have more comfort while assigning
            new values that then get exported through dp_Res1.

id_res2  -  Doubled/feedback  dp_Res2  to have more comfort while assigning
            new values that then get exported through dp_Res2.



struct qdev_lbs_slot
{
  UWORD ls_inst;
  ULONG ls_addr;
};

ls_inst  -  m68k routine call instruction that will look for the address in
            upcoming long word.

ls_addr  -  Routine address.



struct mem_pic_data
{
  struct ColorMap         *pd_cm;
  struct Library          *pd_ggb;
  APTR                     pd_dh;
  ULONG                    pd_frames;
  ULONG                    pd_fdly;
  ULONG                    pd_cdly;
  WORD                     pd_ptab[QDEV_MEM_RBP_PTABSIZE];
  WORD                     pd_htab[QDEV_MEM_RBP_PTABSIZE];
};

pd_cm    -  ColorMap  pointer  as passed to the  function. Keep it valid at
            all times!

pd_ggb   -  Private instance of 'guigfx.library' that the function may use.

pd_dh    -  GuiGfx draw handle that stores picture related stuff.

pd_frames
         -  Number  of bitmaps that this very single  mem_pic_data handles.

pd_fdly  -  Frame  delay as used in binary animation  expressed in  micros.

pd_cdly  -  Cycle  delay as used in binary animation  expressed in  micros.

pd_ptab  -  Local pen caching table. This is used to cache  ObtainBestPen()
            result so that color remapping is nicely turboed.

pd_htab  -  Global pen caching table so that there is no need for selective
            pd_ptab per frame. All  pens of all frames go  then through the
            ReleasePen() in one pass.



struct mem_pic_opti
{
  struct BitMap           *po_bm;
  VUQUAD                   po_hash;
};

po_bm    -  Bitmap pointer. If  this structure forms a table then each bmap
            occupies one entry. There  is no way that po_bm can ever repeat
            in the array!

po_hash  -  Hash of all Bitmap planes. Currently mem_loadpicture() uses the
            mem_pjw64hash() routine.



struct qdev_mem_pool
{
  struct SignalSemaphore mp_sem;
  LONG                   mp_init;
  void                  *mp_pool;
  LONG                   mp_pudsize;
  LONG                   mp_tressize;
  ULONG                  mp_allocs;
  ULONG                  mp_total;
  ULONG                  mp_oflags;
};

mp_sem   -  Semaphore  that  protects  from  allocating same  memory region
            twice as requested from concurrent tasks.

mp_init  -  Base parameters(mp_pudsize, mp_tressize) latch.

mp_pool  -  Memory pool pointer. This gets allocated using system function.

mp_pudsize
         -  Puddle size. Has the very same  meaning as the OS related func.

mp_tressize
         -  Treshold size. Has the  very same meaning  as the OS pool func.

mp_allocs
         -  Allocation count for this memory pool. Useful when doing memory
            leak detection.

mp_total -  How much  memory was taken from system so far. Memory leaks can
            easily be detected without using special software.

mp_oflags
         -  Originally passed memory flags.



struct mem_sni_ient
{
  struct Node          si_node;
  struct mem_sni_glob *si_sg;
  LONG                 si_entflags;
  ULONG              (*si_usercode)
               (REGARG(ULONG, d0),
              REGARG(void *, a1));
  APTR                *si_userdata;
};

si_node  -  Standard node to be able to create chained list. By default all
            fields are NULL.

si_sg    -  Back  pointer to sniffer  root structure as installed in one of
            exception slots.

si_entflags
         -  Flags  that describe  state of this  'ient'. Currently only the
            sg_natsi is affected by flags.

si_usercode
         -  User sniffer code that is associated with message port. You can
            swap  this code freely. This  can effectively be set to NULL if
            no call is desired under some circumstances.

si_userdata
         -  User data that will be passed in argument 2 on the si_usercode.



struct mem_sni_glob
{
  ULONG                sg_status;
  ULONG                sg_count;
  LONG                 sg_sigbit;
  struct Task         *sg_tc;
  struct List          sg_list;
  struct mem_exr_rman *sg_er;
  struct mem_sni_ient  sg_natsi;
};

sg_status
         -  Global sniffer structure identification. QDEV_MEM_PRV_STATUSID.

sg_count -  Number of sniffer handlers that are currently active. This acts
            like a sync too.

sg_sigbit
         -  Signal bit/slot number at which this root structure is attached
            to ei_userdata.

sg_tc    -  Task address  as recovered from message port. This task handles
            the exceptions so it may not be 'FindTask(NULL)'!

sg_list  -  List of all handlers that are associated with particular signal
            as allocated on a task level.

sg_er    -  Remote management bits. This  structure  must  be  available to
            mem_addexhandler()/mem_remexhandler() so effectively its memory
            starts before 'struct mem_sni_glob'!

sg_natsi -  Node for handler that is to be  installed/removed with standard
            mem_addexhandler()/mem_remexhandler() thru sg_er->er_remote().



struct mem_act_data
{
  LONG    ad_id;
  LONG    ad_cols;
  LONG    ad_rows;
  LONG    ad_xpos;
  LONG    ad_ypos;
  LONG    ad_size;
  LONG    ad_bytes;
  LONG    ad_tval;
  LONG    ad_tlen;
  LONG    ad_toon;
  LONG    ad_tooc;
  LONG    ad_mode;
  UQUAD   ad_fill;
  UQUAD   ad_tsgr;
  UQUAD   ad_tact;
  UQUAD  *ad_treg;
  UBYTE  *ad_ereg;
  UBYTE  *ad_eend;
  void *(*ad_mmfp)(void *, const void *, size_t);
  void  (*ad_clrfp)(void *, LONG, LONG);
  void  (*ad_scrfp)(void *, LONG);
  void  (*ad_oplfp)(void *, LONG);
  void  (*ad_opcfp)(void *, LONG);
  void  (*ad_ucbfp)(void *, UQUAD *);
  void  (*ad_uokfp)(void *, LONG);
  void   *ad_udata;
  LONG    ad_tab[QDEV_MEM_PRV_TERMTAB];
  UBYTE   ad_exp[QDEV_MEM_PRV_TERMEXP];
  UBYTE   ad_buf[QDEV_MEM_PRV_TERMMIN];
};

ad_id    -  Terminal identification val. as defined in QDEV_MEM_PRV_TERMID.

ad_cols  -  Total terminal columns.

ad_rows  -  Total terminal rows.

ad_xpos  -  Current cursor column. Please note that this value may be found
            out of  range for a brief moment when  examined directly during
            'Write()' that just takes place!

ad_ypos  -  Current cursor row. Please  note that  this value  may be found
            out of  range for a brief moment when  examined directly during
            'Write()' that just takes place!

as_size  -  Real size of the  'ad_buf'  area. This value is always multiple
            of 'sizeof(UQUAD)'.

ad_bytes -  Logical size of  terminal on per byte basis(ad_cols * ad_rows).

ad_tval  -  Temporary ANSI sequence parameter collection. This is used when
            parsing the sequence.

ad_tlen  -  Size  of the 'ad_tab' array at  this very moment. No. of params
            collected.

ad_toon  -  Out-of-node  parameter bitfield.  This is used  to track params
            that were left without value, like: ESC[;6H where -line- param.
            was ommited, so it is possible to use  'ad_tab[0]' as -column-.

ad_tooc  -  Out-of-node  bit counter. Counter  gets shifted 1 bit left each
            time parameter switch(';') is detected.

ad_mode  -  Basic  terminal  modes as  flags such  as LNM, AWM, AWS and G1.

ad_fill  -  Terminal  fill pattern. This is a  bitfield and character store
            at the same time.

ad_tsgr  -  Terminal  SGR  tracker. Used when  dealing with  non-terminated
            sequences where cursor is usually rewinded to particular place.

ad_tact  -  Terminal SGR  active tracker. This  only tracks activators that
            are then cleared after each write cycle.

ad_treg  -  Terminal tracking register is reponsible  for keeping an eye on
            last byte,  so position change  can be  easily noticed  just by
            comparing the addresses.

ad_ereg  -  Sequence expansion start  ptr that is mostly tied to  'ad_exp'.

ad_eend  -  Sequence expansion end pointer that tells how big is the stream
            of sequences for this very terminal byte.

ad_mmfp  -  Memory move function pointer. By default points at 'memmove()',
            and the argument template is UNIX-like. This FP cannot be NULL!

ad_clrfp -  Terminal  clear function pointer. The  routine assigned to this
            FP  is responsible for clearing parts of the terminal. Argument
            template is: 'ad_clrfp(ad, start, end)' where 'ad' is the term.
            area pointer, 'start' is the absolute byte to start clearing at
            and 'end' is the absolute byte to stop clearing at. Function is
            protected from overflows. This FP cannot be NULL!

ad_scrfp -  Terminal scroll function pointer. This routine allows to scroll
            on  line-by-line-from-top-or-bottom basis only. The template is
            as follows: 'ad_clrfp(ad, lines)' where  'ad' is terminal stuff
            and 'lines' amount of lines to scroll. Note that 'lines' can be
            negative, so that scroll takes place the other way around. This
            FP cannot be NULL!

ad_oplfp -  Insert/delete  lines  function pointer. This  routine allows to
            insert or delete lines and thus possibly scroll the terminal at
            any point according to curr. coords(ad_xpos, ad_ypos). Template
            and restrictions same as in 'ad_scrfp'.

ad_opcfp -  Insert/delete  characters function pointer. This routine allows
            to  insert or  delete characters in  a given line  according to
            curr. coords(ad_xpos, ad_ypos). Template: 'ad_opcfp(ad, chars)'
            where 'chars'  can be negative which means delete. This FP must
            not be NULL!

ad_ucbfp -  Usercode function pointer of template: 'ad_ucbfp(ad, termbyte)'
            This  callback will be called whenever  ASCII character was put
            to the terminal. Remember  though that code  pointed to by will
            be executed  as pseudo-interrupt which  should be  treated like
            a  software   interrupt  if  terminal  is  being  used  through
            'mem_openifh()'! By default the FP is NULL.

ad_uokfp -  Usercode  function  pointer  of template: 'ad_uokfp(ad, size)'.
            This callback gets  called after the write did finish. This may
            also  be executed from  under the pseudo-interrupt! By  default
            the FP is NULL.

ad_udata -  General  purpose user pointer as passed to the 'ad_ucbfp()' and
            'ad_uokfp()'. Set to NULL by default.

ad_tab   -  ANSI sequence parameter table.

ad_exp   -  ANSI sequence expasion buffer that is used when reading off the
            terminal.

ad_buf   -  Terminal char space where each "byte" is an UQUAD that combines
            bitfield and real character.



struct mem_mtl_data
{
  struct MinList  md_ml;
  void           *md_ptr;
};

md_ml    -  MinList that holds all tokens as nodes.

md_ptr   -  Token  cluster pointer. See  struct mem_mtl_iter in public sec.



struct mod_ade_data
{
  struct mod_ktl_head ad_kh;
  UBYTE               ad_name[QDEV_MOD_PRV_ADENAMELEN];
  UBYTE               ad_idstr[QDEV_MOD_PRV_ADEIDSTRLEN];
  UBYTE               ad_data[QDEV_MOD_PRV_ADEUSRBUF];
};

ad_kh    -  Module header that contains all  the magic internals needed for
            the module to init and survive in memory.

ad_name  -  Module  name buffer space. Normal  NULL terminated text though.

ad_idstr -  Module  ID  string  buffer space. Also  NULL  terminated  text.

ad_data  -  Module  data buffer space. No new members  allowed  beyond this
            member due to varying data size.



struct qdev_ttv_skel
{
  UBYTE *ts_name;
  ULONG  ts_value;
};

ts_name  -  NULL terminated text that represents the flag, namely ts_value.

ts_value -  The flag value itself.



struct nfo_fsq_data
{
  struct ExAllControl *fd_eac;
  struct ExAllData    *fd_ead;
  struct nfo_fsq_cb    fd_fc;
  BOOL                 fd_check;
  BPTR                 fd_lock;
  UBYTE                fd_buf[QDEV_NFO_PRV_FSQTOTAL];
};

fd_eac   -  Standard, ExAllControl  memory  region. All I/O  is being  done
            thanks to this control block.

fd_ead   -  Filesystem related data pointer that when given raw input turns
            it into  fully structurised memory block. This  is used  in the
            iterator internally.

fd_fc    -  Callback  internals where aside from others  fd_ead  is mapped.

fd_check -  ExAll() iterator guard.

fd_lock  -  Lock  that was obtained  on an input  object. Do  not touch it!

fd_buf   -  ExAll() and  user spaces. No  new members  allowed beyond  this
            structure member!



struct nfo_grep_data
{
  struct dev_ddv_data   *gd_dd;
  LONG                   gd_range;
  LONG                   gd_rangerev;
  LONG                   gd_mlendof;
  struct RigidDiskBlock *gd_rdb;
  struct DriveGeometry  *gd_dg;
  struct DosEnvec        gd_de;
  LONG                   gd_rc;
  void                  *gd_olduserdata;
  void                  *gd_userdata;
  LONG                 (*gd_usercode)(struct nfo_sml_cb *);
};

gd_dd    -  Simplified device handle. This is  used to query the TD device.

gd_range -  Range  this  very  partition shall be  within(counting from 0).
            Value  expressed in gigabytes. Can  be negative though, so that
            additional gd_dd checks will be performed.

gd_rangerev
         -  An absolute gd_range value.

gd_mlendof
         -  Value  computed  from  mountblock parameters  that get compared
            against gd_rangerev.

gd_rdb   -  RigidDiskBlock  pointer as read from the device associated with
            gd_dd member.

gd_dg    -  DriveGeometry  pointer as read from  the device driver when RDB
            is unreadable.

gd_de    -  Defaults  that  get copied  per mountblock  before fetching the 
            actual values.

gd_rc    -  Callback return code.

gd_olduserdata
         -  Internal user data swapper-pointer.

gd_userdata
         -  User data  pointer that can be found in  the nfo_sml_cb struct.

gd_usercode
         -  Callback  function  pointer as  passed to  the init.  function.



struct nfo_ktm_data
{
  void            *kd_cluster;
  struct MinList   kd_list;
  ULONG            kd_faddr;
  UBYTE           *kd_name;
  UBYTE           *kd_patt;
  ULONG            kd_addr;
  ULONG            kd_flags;
  LONG             kd_setarg;
  LONG           (*kd_strcmp)(const UBYTE *, const UBYTE *);
  LONG           (*kd_strpat)(UBYTE *, UBYTE *);
};

kd_cluster
         -  KTM's own memory cluster. All  task/process/port  related infos
            are being packed in here.

kd_list  -  List of all fetched entries.

kd_faddr -  First  matching object address. This acts as a latch, and so it
            gets returned by the function.

kd_name  -  Literal object name as passed to the function.

kd_patt  -  The result of pattern expansion if detected at all.

kd_addr  -  Depending on the range this can be used to seek for CLI process
            (1-4096) or particular task address.

kd_flags -  Function  control  flags. See  QDEV_NFO_KTM_F#? macros for more
            details.

kd_setarg
         -  Optional  argument one of the  kd_flags  may require. More info
            can be found the main library header.

kd_strcmp
         -  String  compare function  pointer. This can  either be the case
            sensitive or insensitive function.

kd_strpat
         -  Pattern matching func.  pointer. For now internally implemented
            pattern matching is being used for performance reasons.



struct nfo_ktm_task
{
  struct MinNode  kl_node;
  UBYTE           kl_tasktext[QDEV_NFO_PRV_TEXTSIZE];
};

kl_node  -  Standard, minimal node to be able to create list - object list.

kl_tasktext
         -  Human  readable  object(task, process, port) buffer  space. The
            text is NULL terminated.



struct mem_fif_user
{
  UBYTE *fu_data;
  LONG   fu_datalen;
  LONG   fu_hits;
  LONG   fu_count;
  LONG   fu_cont;
  LONG   fu_gpos;
  UBYTE *fu_optr;
  UBYTE *fu_bptr;
  LONG   fu_blen;
  LONG   fu_cpos;
  UBYTE *(*fu_cmp)
         (const UBYTE *dat1, LONG len1,
          const UBYTE *dat2, LONG len2);
};

fu_data  -   Data  region  pointer. This will  be  seek against  the  file.

fu_datalen
         -   Data region length.

fu_hits  -   Max. number  of fu_data  occurrences  to be found in the file.

fu_count -   Number of fu_data hits so far.

fu_cont  -   Offset that gets computed after each hit and then added to the
             main pointer.

fu_gpos  -   Global  file  position(in  bytes)  this  fu_data  were  found.

fu_optr  -   Hit reference  pointer that allows to compute the distance and
             additional position.

fu_bptr  -   Main  looping  pointer txt_datdat()  function uses  as a start
             point.

fu_blen  -   Size of the memory block as referenced by the fu_bptr pointer.

fu_cpos  -   Current block offset that maps to memory past the hit. Used to
             compute fu_cont.

fu_cmp   -   Data compare function pointer with template of 'txt_datdat()'.



struct mem_tab_data
{
  LONG    td_codech[QDEV_MEM_PRV_TABLESIZE];
  ULONG   td_codepre[QDEV_MEM_PRV_TABLESIZE];
  UBYTE   td_appchar[QDEV_MEM_PRV_TABLESIZE];
};

td_codech
         -  This  is used as a character lookup table,  so that data can be
            actually compressed.

td_codepre
         -  All compression/decompression  prefixes are  being stored here.

td_appchar
         -  Depending on action this serves as a helper buffer when packing
            or as a stack when unpacking.



struct mem_lzw_data
{
  struct mem_pak_data ld_pd;
  struct mem_tab_data ld_td;
  UBYTE               ld_data[QDEV_MEM_PRV_DATASIZE];
};

ld_pd    -  Structure  that  will  be  the  only  visible part of the  I/O.

ld_td    -  Arrays that  are needed to compress and  decompress given data.

ld_data  -  Buffer space that is linked to the ld_pd pointer member. As you
            may have guessed it will hold the result of I/O. No new members
            allowed beyond this point!



struct mem_clr_head
{
  struct mem_clr_head    *ch_next;
  struct SignalSemaphore  ch_sem;
  ULONG                   ch_size;
  ULONG                   ch_chunks;
  ULONG                   ch_flags;
  ULONG                   ch_total;
  ULONG                   ch_list;
  UBYTE                   ch_space[QDEV_MEM_PRV_MINSPCLEN];
};

ch_next  -  This will point at another cluster that had to be linked in due
            to exhaustion of the current one. Merging is trasparent.

ch_sem   -  Semaphore  that is used to  arbitrate parallel memory requests.

ch_size  -  Size of one chunk of memory that is to be requested.

ch_chunks
         -  Number  of memory chunks  this cluster  consists of  initially.

ch_flags -  Standard memory allocation flags. Please note that MEMF_LARGEST
            flag is all valid and enables cluster merging!

ch_list  -  Singly  linked list of free chunks. Each  chunk node is first 4
            bytes. When chunk is  not allocated it points at another chunk,
            but when it is allocated structure pointer is stuffed in.

ch_space -  Raw cluster area. No  new members allowed beyond this point for
            obvious reason.



struct mem_prl_feed
{
  struct List  pf_tab;
  struct List  pf_im;
  UBYTE       *pf_ptr;
  UBYTE       *pf_end;
  LONG         pf_type;
  LONG         pf_bal;
  ULONG        pf_size;
  void        *pf_node;
  ULONG        pf_hash;
  UBYTE        pf_name[(QDEV_PRV_PRL_SYMLEN + 1)];
};

pf_tab   -  List of RGB4 and/or  RGB32 palettes wrapped using 'mem_prl_tab'
            structure. Additional node members are also being used!

pf_im    -  List of Image structures wrapped using 'mem_prl_tab'. This list
            gets flushed upon function exit independently of result.

pf_ptr   -  This variable is used in the parser function. It is responsible
            for holding start address of the symbol/object.

pf_end   -  Also used in the parser. What it does is to mark where the obj.
            ends.

pf_type  -  Object  identification. Can be one of  QDEV_PRV_PRL_T_#? . This
            member is used in object handler function.

pf_bal   -  Lexical brace  balance guard. All sort of  brackets, quotes and
            stuff  is checked. This must always be 0 in order for the func.
            to be successful.

pf_size  -  Size of the  object/table as expressed using  QDEV_PRV_PRL_L_#?
            macros. 

pf_node  -  An  address of last  palette/structure  added to the respective
            list.

pf_hash  -  32bit FNV hash of pf_name. This is used to match ImageData fast
            that are placed on pf_tab list temporarily.

pf_name  -  Name of the  symbol that was  associated with the object/table.



struct mem_prl_tab
{
  struct Node  pt_node;
  LONG         pt_len;
  ULONG        pt_hash;
  UBYTE        pt_name[((QDEV_PRV_PRL_SYMLEN + 4) & ~3)];
  UBYTE        pt_tab[QDEV_PRV_PRL_MINLEN];
};

pt_node  -  Standard node to be able to make chain of entries - table list.

pt_len   -  Size of the pt_tab expressed in bytes.

pt_hash  -  32bit FNV  hash of pt_name. This is used to match entries fast.

pt_name  -  Name of the symbol that was associated with  pt_tab data block.

pt_tab   -  Data block. This  is implicit  thus no new  members beyond this
            point!



struct nfo_int_data
{
  LONG                (*id_usercode)(struct nfo_sml_cb *);
  struct DosEnvec      *id_defde;
  struct nfo_sml_cb     id_sc;
  struct nfo_che_data  *id_cd;
  struct nfo_che_data  *id_cdp;
  UBYTE                *id_pattern;
  QDEV_TXT_INIPARSETYPE(id_ini);
  QDEV_TXT_INIPARSETYPE(id_dev);
  LONG                  id_jumptocb;
  UBYTE                *id_devptr;
  LONG                  id_rc;
  UBYTE                 id_dosdevice[QDEV_NFO_PRV_NAMELEN];
  UBYTE                 id_handler[QDEV_NFO_PRV_NAMELEN];
  UBYTE                 id_device[QDEV_NFO_PRV_NAMELEN];
  UBYTE                 id_unit[QDEV_NFO_PRV_NAMELEN];
  UBYTE                 id_flags[QDEV_NFO_PRV_NAMELEN]; 
  UBYTE                 id_control[QDEV_NFO_PRV_NAMELEN];
  UBYTE                 id_startup[QDEV_NFO_PRV_NAMELEN];
  UBYTE                 id_errors[QDEV_NFO_PRV_ERRORAREA];
};

id_usercode
         -  User callback  function pointer as passed to the main function.

id_defde -  This may  point at the predefined  DosEnvec  that will be  used
            just before fetching  mountblock parameters. This member can be
            NULL as well so that default values per CB will be 0.

id_sc    -  Callback related data. This  will be passed in the id_usercode.

id_cd    -  Mountblock related keyword lookup table. A foundation that gets
            assigned to id_cdp.

id_cdp   -  Keyword lookup table pointer.

id_pattern
         -  Handler name(s) or a  pattern as passed to the parent function.

id_ini   -  Keyword = Data, ini style splitter structure.

id_dev   -  Device: Keyword = Data, crazy style splitter structure.

id_jumptocb
         -  Somewhat dirty  id_dev  compatibility kludge. This is used when
            the handler name shares the same line as ini pair.

id_devptr
         -  Handler  name as read  from mountlist. This gets  copied to the
            id_dosdevice.


id_rc    -  Callback return code. This  RC  is used by the mem_scanlblncc()
            function.

id_dosdevice
         -  Handler buffer space that is assigned to logical pointer of the
            id_sc.

id_handler
         -  Binary  handler  name space that is  assigned to  the analogous
            pointer of the id_sc. This member accepts Handler, EHandler and
            FileSystem.

id_device
         -  Binary device name space that is assigned to the analogous ptr.
            of the id_sc.

id_unit  -  Device unit. This  can either be  NULL  terminated string or an
            integer  that shall  be inspected  at byte  [1] to [4](LONG) if
            [0] == NULL.

id_flags -  Device flags. This can either be  NULL  terminated string or an
            integer  that shall be inspected  at byte  [1] to [4](ULONG) if
            [0] == NULL.

id_control
         -  Control flags(textual) buffer space.

id_startup
         -  Startup field. This can either be NULL  terminated string or an
            integer  that shall be inspected  at byte  [1] to [4](ULONG) if
            [0] == NULL.

id_errors
         -  Keywords that had  faulty params. This buffer may carry newline
            delimited keywords who were not interpreted for some reason.



struct nfo_che_data
{
  LONG   (*cd_func)(LONG *, LONG *, struct nfo_int_data *);
  void    *cd_dest;
  LONG     cd_type;
  UBYTE   *cd_key;
};

cd_func  -  Extractor  function pointer. Different  keywords use  different
            extractors(text, integer).

cd_dest  -  This ties to the particular nfo_sml_cb structure member. Direct
            extraction.

cd_type  -  Type of keyword, classification(16 bit) and  its flags(16 bit).

cd_key   -  Constant  NULL  terminated keyword  reference. Text  that  gets
            compared on byte by byte basis.



struct qcrtregs
{
  LONG     *cr_a;
  LONG      cr_id;
  LONG      cr_n;
  LONG      cr_f;
  union
  {
    struct
    {
      LONG   d[8];
      LONG  *a[8];
    } *m68k;
  } cr;
};

cr_a     -  Standard  C argument  compatibility kludge. This  member stores
            the address of cr_id .

cr_id    -  Identification value,  actually a text =  QCRT that will appear
            in argv[0].

cr_n     -  NULL termination for the above.

cr_f     -  Startup  control  flags that user  may specify  for all sort of
            add-ons. Method occupies first 8 bits!

cr.m68k.d
         -  A set(0 - 7) of data registers. These get saved early. The m68k
            structure points at the stack too but a bit closer to start.

cr.m68k.a
         -  A set(0 - 7) of address registers. See source code for presets.
