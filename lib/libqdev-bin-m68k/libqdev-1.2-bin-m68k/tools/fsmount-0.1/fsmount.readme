
fsmount-0.1
------------

---

One of the most poorly documented  things in the AmigaOS is probably device
mounting. Before  'fsmount' was born i really didnt know how 'Mount' works.
Besides i wanted something more powerful and more flexible. I spent quite a
time on building blocks, so that all of them combined gave totally new tool
that  tries  to  establish  new grounds for device mounting and unmounting.
Below is a list of things 'fsmount' can currently do for you:

   () Really  tries to mimic  'Mount'  in what it  does internally, despite
   somewhat different command line interface.

   () 64bit  device  detection   based  upon  Mountlist  values  and/or  by
   querying the device driver.

   () Pattern and handler type  assisted  mounting, so that handler entries
   can all be stored in one file.

   () Handler  name  uniquzation(similar  to  what  bootstrap  is  doing on
   startup)

   () Safe handler unmounting plus  peacewise handler removal that does not
   cause processes involved to lockup(in most cases).

---

NOTES:

[*]
Requires 68020(no FPU)+, OS2.04(in theory)+, 24+ KiB of free memory, device
to mount or unmount.

[*]
While  mounting  and unmounting with 'fsmount' can be as clean as possible,
unmounting  handlers  mounted  with  alien  mounters,  such as 'Mount' will
always result in memory leaks! Compatibility kludges on this level are just
waste of time.

[*]
Study  the source code for more datails :-] . This  is the only way to know
how  it actually  works and this might be  a pain because there is a lot to
study.

---

HELP:

   > fsmount ?

     DEVICE=DEVPAT/A,FROM=MOUNTLIST/K,DR=DEVRANGE/N,FS=FILESYSTEMS/S,
     H=HANDLERS/S,E=EHANDLERS/S,NO=DONOTMOUNT/S,A=ALLOWBROKEN/S,
     U=UNIQUEDEV/S,DISMOUNT=KILL/S,S=SIGCALLERS/S,F=FORCE/S



   DEVICE=DEVPAT/A   -  Handler/device name(s) to  mount or unmount(with or
                        without  colon). Standard  AmigaOS  patterns can be
                        used here. For  example,  passing: "(HD1|HD2)" will
                        call only  for these two devices. Single  mountlist
                        entries/filenames can of course be specified.

   FROM=MOUNTLIST/K  -  By  default all devices  will be mounted from  file
                        'DEVS:Mountlist'. This  can be changed by supplying
                        this argument with new place.

   DR=DEVRANGE/N     -  Device  range is a  nifty thing. You  can tell  the
                        'fsmount'  to  mount  only  those  devices  who are
                        within this range(counting from start of the disk).
                        Range  must  be  expressed in gigabytes. Range  can 
                        also be negative(this will trigger  device checks). 
                        The  most usable sanity check is to stuff -128 (LBA
                        mode), so handlers who  need 64bit commands will be
                        discarded  both, if  drive is  too small  or device
                        driver cannot handle TD64 or NSD64 commands.

   FS=FILESYSTEMS/S  -  Take care of filesystems(by default everything will
                        be processed). This and two next  switches are flag
                        switches which means they can be mixed.

   H=HANDLERS/S      -  Take  care  of ehandlers(by default everything will
                        be processed).

   E=EHANDLERS/S     -  Take  care  of  handlers(by default everything will
                        be processed).

   NO=DONOTMOUNT/S   -  Do not mount anything. This  is useful for catching
                        syntax/datatype errors. If  private debug output is
                        compiled in then  useful  data will be printed. The
                        output reflects processed data!

   A=ALLOWBROKEN/S   -  Allow  broken  entries to pass. Broken keys will be
                        given the defaults.

   U=UNIQUEDEV/S     -  Uniqufy  device names when  they are already in the
                        system. For instance given 'HD0' is already mounted
                        another  attempt  will  result in  'HD0.1'. Another
                        with 'HD0.2' and so on...

   DISMOUNT=KILL/S   -  Try to  dismount what was passed in the  very first
                        argument.

   S=SIGCALLERS/S    -  This  is  strictly  dismount  related  switch. When
                        combined  with  switch  below  will program message
                        port in  such  a way  that the dummy packet handler
                        will send  C,D,E,F  signals  to the callers so they
                        can quit peacefully.

   F=FORCE/S         -  In  case when devices  are to be mounted  this will
                        discard  broken  entries  and will keep going. When
                        unmounting this will cause forcible unmounting, but
                        only when the device does  not want  to  go away on
                        'ACTION_DIE'.

---

USAGE:

   ; Mount devs 'HD1', 'HD2' and 'HD3' from 'custom.mountlist'
   ; making sure they will fit on currently connected drive
   ; and that the device driver is capable of TD64 or NSD64
   fsmount (HD1|HD2|HD3) from DEVS:custom.mountlist -128

   ; See what would happen on trying to mount all filesystems
   ; from 'custom.mountlist' regarding range
   fsmount #? from DEVS:custom.mountlist -128 no fs f
      ;...
      ;TTT:
      ;0,0: Handler        = filesysres 45.10 (3.8.2001)
      ;0,0: EHandler       = filesysres 45.10 (3.8.2001)
      ;0,0: FileSystem     = filesysres 45.10 (3.8.2001)
      ;0,1: Device         = scsi.device
      ;0,1: Unit           = 0
      ;0,1: Flags          = 0x00000000
      ;0,0: BlockSize      = 512
      ;0,1: Surfaces       = 16
      ;0,1: BlocksPerTrack = 255
      ;0,0: SectorPerBlock = 1
      ;0,1: Reserved       = 2
      ;0,0: PreAlloc       = 0
      ;0,1: Interleave     = 0
      ;0,1: LowCyl         = 1029
      ;0,1: HighCyl        = 1156
      ;0,1: Buffers        = 16
      ;0,1: BufMemType     = 0
      ;0,1: MaxTransfer    = 0x0001FE00
      ;0,1: Mask           = 0x0FFFFFFE
      ;0,0: BootPri        = 0
      ;0,1: DosType        = 0x444F5305
      ;0,0: Baud           = 1200
      ;0,0: Control        = 0
      ;0,0: BootBlocks     = 0
      ;0,1: StackSize      = 2048
      ;0,1: Priority       = 1
      ;0,1: GlobVec        = -1
      ;0,0: Startup        = 0x00000000
      ;0,1: Activate       = 1
      ;0,0: ForceLoad      = 1
      ;#
      ;H_TYPE: (0x00000004)
      ;E_CODE: (0x00000000)
      ;...
      ;
      ; This is especially interesting case. But let me just
      ; explain some mysterious symbols first. These comma
      ; separated booleans indicate 'error,setting: ...' and
      ; that means that if the keyword was supplied with bad
      ; data then it will be 1, otherwise 0 and that data is
      ; user specified(1) or default(0). Two return codes
      ; mean, in case of 'H_TYPE' - handler type and 'E_CODE'
      ; - exit code, should always be 0.
      ;
      ; Now, im sure you have spotted that the 'Handler' is
      ; something weird. This is because at the source level
      ; this mount block does only come with 'DosType' which
      ; gets resolved by 'FileSystem.resource' who holds all
      ; resident/ROM seglists of filesystems. So if you see
      ; this sort of magic, be sure that the filesystem was
      ; sucessfully located. On the other hand if you see
      ; 'filesystem' here then this may mean that 'DosType'
      ; either was not found  or you requested native FFS of
      ; 0x444F5300.

   ; Make sure that 'VMM' swap partition is in the first 4 gig
   ; area before mounting
   fsmount VMM from DEVS:custom.mountlist -4

   ; Mount 'RAD' from 'Storage' directory, just like 'Mount'
   ; would do it
   fsmount SYS:Storage/DOSDrivers/RAD

   ; Try to dismount 'CC0' in a polite way
   fsmount CC0 dismount

   ; Make your system as unusable as possible :-) , all your
   ; devices will disappear! This is good for testing overall
   ; system/filesystem stability.
   fsmount #? dismount f

---
megacz
