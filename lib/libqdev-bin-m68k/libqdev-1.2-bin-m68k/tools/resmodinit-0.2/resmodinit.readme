
resmodinit-0.2
---------------

---

When  it comes to resident  modules there is  plenty of  software  that can
load  ROMTAG equipped binaries. Just to name a  few there is 'LoadResident'
from  'RemApollo',  there is  'LoadModule'  form 'THOR'  and few more progs
that can be found on Aminet. The problem is they are too skinny on feedback
and  do not allow to  reuse the memory  of non-bootstrapped  modules. Aside
from that  they also lack  pattern  matching and multipass  which is really
handy because one launch can load all you require.

---

NEWS:

   [03-Jan-2014]   0.2   * Due to broken code relocator in the library this
                           program was crashing when compiled as resident.

                         * Fixed output dump that was showing wrong address
                           ranges.

---

NOTES:

[*]
Requires  68020(no FPU)+, OS2.04(theoretically)+, 16+ kilos of free memory.

[*]
The only supported memory is of type MEMF_LOCAL. This means that eventually
chip memory will be used when none of the fast memory nodes are reset-safe.

[*]
This program  allocates the memory in reverse order at all times,  the only
way to  change that is to reduce end memory address. Beware though, modules
rather  like high memory, so  unless you know what you are doing i dare you
to change that. Please note that memory within this range must be  LOCAL to
be utilised!

[*]
As  stated in the  intro 'resmodinit'  can totally remove modules(including
memory deallocation) that have not been used yet. This has some advantages,
like depending  on  some conditions you can create a script/batch that will
load some  modules and  when something  fails  you can remove  them and try
again without memory leaks.

[*]
To ensure maximum  compatibility this prog.  uses OS default scatter-loader
aka  'InternalLoadSeg()'. Note  however  that the  custom memory  allocator
references 'AllocAbs()'  in such a manner that memory type requirements are
ineffective as per hunk!

[*]
Batches can  be as simple as the list  or as complex as scripts. It is much
nicer to enclose all modules you require in a single file and use it across
different  setups rather than bloating your 'startup-sequence' with tons of
separate commands.

[*]
When module  has been deleted  you will see  its size  either as a negative
value which means that this much memory was freed or  0 which means that no
memory was freed(module is in use so it is unwise to deallocate its mem).

---

HELP:

   > resmodinit ?

     M=MODULE,ML=MLOW/K,MH=MHIGH/K,24=24BIT/S,C=CHIP/S,D=DELETE/S,F=FORCE/S



   M=MODULE    -  Filename  of the module(s). Patterns  make it possible to
                  pick  all or particular  modules at a time. You  can also
                  pass batch file in here. Please note  that the batch file
                  must have ';RMI' in the very first line to be recognized.

   ML=MLOW/K   -  Absolute start address  that should be within some memory
                  node. This can be non-existant address as this just makes
                  the range within which some memory nodes are to be found.
                  By default this is set to past zero page.

   MH=MHIGH/K  -  Absolute  end address that  should be either very high or
                  point at the end of particular memory node. Set to 2 gigs
                  by  default. If your 32 bit fast ram is not L like  LOCAL
                  then the  DMA memory will be probed and if that fails too
                  then chip memory will be utilised!

   24=24BIT/S  -  Narrows the address space to 24 bits. Useful when dealing
                  with DMA dependant code/data. Small remark though. Memory
                  within  this space  must have L flag  set. If there is no
                  fast memory there then chip memory will be used!

   C=CHIP/S    -  Narrows the address space to 2 megs of chip memory. Handy
                  when  dealing with modules whose data will be accessed by
                  the custom chips.


   D=DELETE/S  -  When specified along with the M=MODULE then such a module
                  will  be deleted. You can delete modules by their virtual
                  numbers  or  literal  names. Patterns  still do work, but
                  batches do not!

   F=FORCE/S   -  This switch instructs the program that it should not stop
                  on  error(s)  when  loading. Note  however  that the  $RC
                  env. variable  will be  set to 5 for warning or to 10 for
                  pseudo-error.

---

BATCH:

Aside  module  entries batches can  include so called  directives who allow
selective  load/unload.  Directives   are  square  bracketed  single  state
conditionals(non-if-else). Hopefully  directives can nest. Below  is a list
of all available directives:

   [24          =      24bit]  -  Every  module  within this directive will
                                  be given memory in the 24 bit DMA memory.

   [c           =       chip]  -  Every  module  within this directive will
                                  be placed in chip memory.

   [d           =     delete]  -  With  this  directive module  deletion is
                                  possible from under the batch. Just place
                                  the names and terminate the directive.

   [f           =      force]  -  When put at the beginning of a batch will
                                  cause parser not to stop on error.

   [`<command>` <op> <value>]  -  Anything  braced  in  backquotes  will be 
                                  treated  as a command. The comparision is
                                  based on return code of such command.

   [chip        <op> <value>]  -  Allows  chip memory comparison. Left-hand
                                  operand  will be turned  into free amount
                                  of memory.

   [cpu         <op> <value>]  -  Allows  CPU  type  comparison(range  from
                                  68000 to 68060).

   [fast        <op> <value>]  -  Allows  fast memory comparison. Left-hand
                                  operand  will be turned  into free amount
                                  of memory.

   [memory      <op> <value>]  -  Allows total memory comparison. Left-hand
                                  operand  will be turned  into free amount
                                  of memory.

   [os          <op> <value>]  -  Allows  OS(exec.library) ver. comparison.


   [error       <op> <value>]  -  DOS error code(as outputted to the shell)
                                  conditional. This  directive can  be used
                                  as per entry or at the bottom as an error
                                  handler. Generally errors start at 200.

   [end]                       -  Directive terminator. You want to use it!


As to <op>'s they are pretty much like in C programming language. Following
operators are implemented:

   '==' - Equal.
   '> ' - Greater than.
   '>=' - Greater or equal.
   '< ' - Less than.
   '<=' - Less or equal.
   '!=' - Not equal.


A  <value>  is a 32bit  integer that can be  expressed in four most popular
numeral  systems:  decimal,  hexadecimal, octal and binary.  All  notations
except for decimal require single or double character prefixes.

---

USAGE:

   ; Make something reset-proof so it gets inited
   ; at bootstrap
   resmodinit LIBS:asl.library
     ;Memory type : LOCAL
     ;Memory reg. : 0x00001000 - 0x7FFFFFFF
     ;
     ;Input file  : LIBS:asl.library
     ;Module name : asl.library
     ;Module ver. : 42
     ;Module type : 9
     ;Module pri. : 0
     ;Module opts : 0x80
     ;Module segs : 2
     ;ME[ 0]      : 0x04F936B0 - 0x04F93717 (   104)
     ;ME[ 1]      : 0x04F94348 - 0x04F9DF1F ( 39896)
     ;ME[ 2]      : 0x04F93718 - 0x04F94347 (  3120)
     ;ME[#?]      : ---------- - ---------- ( 43120)
     ;Status      : (0) All OK

   ; Load multiple objs at a time using patterns
   cd LIBS:
   resmodinit (asl.#?|workbench.#?|icon.#?)

   ; Load everything disregarding potential errors
   resmodinit DEVS:Modules/#? force

   ; Dump module list
   resmodinit
     ;001. [asl.library      ] (  40664)   asl 4[...]
     ;002. [workbench.library] ( 196208)   workb[...]
     ;003. [icon.library     ] (  44840)   icon.[...]
     ;---. [#?               ] ( 281712)   ---

   ; Remove one module from KTP and/or KMP knowing
   ; its name
   resmodinit icon.library delete

   ; Remove one module from KTP and/or KMP knowing
   ; its number
   resmodinit 2 delete

   ; Remove all modules using OS pattern matching
   resmodinit #? delete

   ; Set new absolute mem. region that is the only
   ; area allowed
   resmodinit <mymodule> ml 0x00100000 mh 0x001FFFFF

---
megacz
