/*
 * Generated by gdbus-codegen 2.30.1. DO NOT EDIT.
 *
 * The license of this code is the same as for the source it was derived from.
 */

#ifdef HAVE_CONFIG_H
#  include "config.h"
#endif

#include "gdbus-test-codegen-generated.h"

#ifdef G_OS_UNIX
#  include <gio/gunixfdlist.h>
#endif

typedef struct
{
  GDBusArgInfo parent_struct;
  gboolean use_gvariant;
} _ExtendedGDBusArgInfo;

typedef struct
{
  GDBusMethodInfo parent_struct;
  const gchar *signal_name;
  gboolean pass_fdlist;
} _ExtendedGDBusMethodInfo;

typedef struct
{
  GDBusSignalInfo parent_struct;
  const gchar *signal_name;
} _ExtendedGDBusSignalInfo;

typedef struct
{
  GDBusPropertyInfo parent_struct;
  const gchar *hyphen_name;
  gboolean use_gvariant;
} _ExtendedGDBusPropertyInfo;

typedef struct
{
  GDBusInterfaceInfo parent_struct;
  const gchar *hyphen_name;
} _ExtendedGDBusInterfaceInfo;

typedef struct
{
  const _ExtendedGDBusPropertyInfo *info;
  guint prop_id;
  GValue orig_value; /* the value before the change */
} ChangedProperty;

static void
_changed_property_free (ChangedProperty *data)
{
  g_value_unset (&data->orig_value);
  g_free (data);
}

static gboolean
_g_strv_equal0 (gchar **a, gchar **b)
{
  gboolean ret = FALSE;
  guint n;
  if (a == NULL && b == NULL)
    {
      ret = TRUE;
      goto out;
    }
  if (a == NULL || b == NULL)
    goto out;
  if (g_strv_length (a) != g_strv_length (b))
    goto out;
  for (n = 0; a[n] != NULL; n++)
    if (g_strcmp0 (a[n], b[n]) != 0)
      goto out;
  ret = TRUE;
out:
  return ret;
}

static gboolean
_g_variant_equal0 (GVariant *a, GVariant *b)
{
  gboolean ret = FALSE;
  if (a == NULL && b == NULL)
    {
      ret = TRUE;
      goto out;
    }
  if (a == NULL || b == NULL)
    goto out;
  ret = g_variant_equal (a, b);
out:
  return ret;
}

G_GNUC_UNUSED static gboolean
_g_value_equal (const GValue *a, const GValue *b)
{
  gboolean ret = FALSE;
  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));
  switch (G_VALUE_TYPE (a))
    {
      case G_TYPE_BOOLEAN:
        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));
        break;
      case G_TYPE_UCHAR:
        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));
        break;
      case G_TYPE_INT:
        ret = (g_value_get_int (a) == g_value_get_int (b));
        break;
      case G_TYPE_UINT:
        ret = (g_value_get_uint (a) == g_value_get_uint (b));
        break;
      case G_TYPE_INT64:
        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));
        break;
      case G_TYPE_UINT64:
        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));
        break;
      case G_TYPE_DOUBLE:
        ret = (g_value_get_double (a) == g_value_get_double (b));
        break;
      case G_TYPE_STRING:
        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);
        break;
      case G_TYPE_VARIANT:
        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));
        break;
      default:
        if (G_VALUE_TYPE (a) == G_TYPE_STRV)
          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));
        else
          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));
        break;
    }
  return ret;
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.Bar
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenBar
 * @title: FooiGenBar
 * @short_description: Generated C code for the org.project.Bar D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.Bar ---- */

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_hello_world_IN_ARG_greeting =
{
  {
    -1,
    "greeting",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bar_method_info_hello_world_IN_ARG_pointers[] =
{
  &_foo_igen_bar_method_info_hello_world_IN_ARG_greeting,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_hello_world_OUT_ARG_response =
{
  {
    -1,
    "response",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bar_method_info_hello_world_OUT_ARG_pointers[] =
{
  &_foo_igen_bar_method_info_hello_world_OUT_ARG_response,
  NULL
};

static const GDBusAnnotationInfo _foo_igen_bar_method_hello_world_annotation_info_0 =
{
  -1,
  "Key3",
  "Value3",
  NULL
};

static const GDBusAnnotationInfo _foo_igen_bar_method_hello_world_annotation_info_1 =
{
  -1,
  "ExistingAnnotation",
  "blah",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_bar_method_hello_world_annotation_info_pointers[] =
{
  &_foo_igen_bar_method_hello_world_annotation_info_0,
  &_foo_igen_bar_method_hello_world_annotation_info_1,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_bar_method_info_hello_world =
{
  {
    -1,
    "HelloWorld",
    (GDBusArgInfo **) &_foo_igen_bar_method_info_hello_world_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_igen_bar_method_info_hello_world_OUT_ARG_pointers,
    (GDBusAnnotationInfo **) &_foo_igen_bar_method_hello_world_annotation_info_pointers
  },
  "handle-hello-world",
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_byte =
{
  {
    -1,
    "val_byte",
    "y",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_boolean =
{
  {
    -1,
    "val_boolean",
    "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_int16 =
{
  {
    -1,
    "val_int16",
    "n",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_uint16 =
{
  {
    -1,
    "val_uint16",
    "q",
    NULL
  },
  FALSE
};

static const GDBusAnnotationInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_arg_val_int32_annotation_info_0 =
{
  -1,
  "Key6",
  "Value6",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_bar_method_info_test_primitive_types_IN_ARG_arg_val_int32_annotation_info_pointers[] =
{
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_arg_val_int32_annotation_info_0,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_int32 =
{
  {
    -1,
    "val_int32",
    "i",
    (GDBusAnnotationInfo **) &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_arg_val_int32_annotation_info_pointers
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_uint32 =
{
  {
    -1,
    "val_uint32",
    "u",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_int64 =
{
  {
    -1,
    "val_int64",
    "x",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_uint64 =
{
  {
    -1,
    "val_uint64",
    "t",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_double =
{
  {
    -1,
    "val_double",
    "d",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_string =
{
  {
    -1,
    "val_string",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_objpath =
{
  {
    -1,
    "val_objpath",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_signature =
{
  {
    -1,
    "val_signature",
    "g",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_bytestring =
{
  {
    -1,
    "val_bytestring",
    "ay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bar_method_info_test_primitive_types_IN_ARG_pointers[] =
{
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_byte,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_boolean,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_int16,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_uint16,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_int32,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_uint32,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_int64,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_uint64,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_double,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_string,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_objpath,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_signature,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_bytestring,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_byte =
{
  {
    -1,
    "ret_byte",
    "y",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_boolean =
{
  {
    -1,
    "ret_boolean",
    "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_int16 =
{
  {
    -1,
    "ret_int16",
    "n",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_uint16 =
{
  {
    -1,
    "ret_uint16",
    "q",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_int32 =
{
  {
    -1,
    "ret_int32",
    "i",
    NULL
  },
  FALSE
};

static const GDBusAnnotationInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_arg_ret_uint32_annotation_info_0 =
{
  -1,
  "Key7",
  "Value7",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_arg_ret_uint32_annotation_info_pointers[] =
{
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_arg_ret_uint32_annotation_info_0,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_uint32 =
{
  {
    -1,
    "ret_uint32",
    "u",
    (GDBusAnnotationInfo **) &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_arg_ret_uint32_annotation_info_pointers
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_int64 =
{
  {
    -1,
    "ret_int64",
    "x",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_uint64 =
{
  {
    -1,
    "ret_uint64",
    "t",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_double =
{
  {
    -1,
    "ret_double",
    "d",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_string =
{
  {
    -1,
    "ret_string",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_objpath =
{
  {
    -1,
    "ret_objpath",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_signature =
{
  {
    -1,
    "ret_signature",
    "g",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_bytestring =
{
  {
    -1,
    "ret_bytestring",
    "ay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_pointers[] =
{
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_byte,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_boolean,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_int16,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_uint16,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_int32,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_uint32,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_int64,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_uint64,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_double,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_string,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_objpath,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_signature,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_bytestring,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_bar_method_info_test_primitive_types =
{
  {
    -1,
    "TestPrimitiveTypes",
    (GDBusArgInfo **) &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_pointers,
    NULL
  },
  "handle-test-primitive-types",
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_dict_s_to_s =
{
  {
    -1,
    "dict_s_to_s",
    "a{ss}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_dict_s_to_pairs =
{
  {
    -1,
    "dict_s_to_pairs",
    "a{s(ii)}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_a_struct =
{
  {
    -1,
    "a_struct",
    "(iss)",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_array_of_strings =
{
  {
    -1,
    "array_of_strings",
    "as",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_array_of_objpaths =
{
  {
    -1,
    "array_of_objpaths",
    "ao",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_array_of_signatures =
{
  {
    -1,
    "array_of_signatures",
    "ag",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_array_of_bytestrings =
{
  {
    -1,
    "array_of_bytestrings",
    "aay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_pointers[] =
{
  &_foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_dict_s_to_s,
  &_foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_dict_s_to_pairs,
  &_foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_a_struct,
  &_foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_array_of_strings,
  &_foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_array_of_objpaths,
  &_foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_array_of_signatures,
  &_foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_array_of_bytestrings,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_non_primitive_types_OUT_ARG_result =
{
  {
    -1,
    "result",
    "ay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bar_method_info_test_non_primitive_types_OUT_ARG_pointers[] =
{
  &_foo_igen_bar_method_info_test_non_primitive_types_OUT_ARG_result,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_bar_method_info_test_non_primitive_types =
{
  {
    -1,
    "TestNonPrimitiveTypes",
    (GDBusArgInfo **) &_foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_igen_bar_method_info_test_non_primitive_types_OUT_ARG_pointers,
    NULL
  },
  "handle-test-non-primitive-types",
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_request_signal_emission_IN_ARG_which_one =
{
  {
    -1,
    "which_one",
    "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bar_method_info_request_signal_emission_IN_ARG_pointers[] =
{
  &_foo_igen_bar_method_info_request_signal_emission_IN_ARG_which_one,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_bar_method_info_request_signal_emission =
{
  {
    -1,
    "RequestSignalEmission",
    (GDBusArgInfo **) &_foo_igen_bar_method_info_request_signal_emission_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-request-signal-emission",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_bar_method_info_request_multi_property_mods =
{
  {
    -1,
    "RequestMultiPropertyMods",
    NULL,
    NULL,
    NULL
  },
  "handle-request-multi-property-mods",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_bar_method_info_unimplemented_method =
{
  {
    -1,
    "UnimplementedMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-unimplemented-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_bar_method_info_property_cancellation =
{
  {
    -1,
    "PropertyCancellation",
    NULL,
    NULL,
    NULL
  },
  "handle-property-cancellation",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_bar_method_info_pointers[] =
{
  &_foo_igen_bar_method_info_hello_world,
  &_foo_igen_bar_method_info_test_primitive_types,
  &_foo_igen_bar_method_info_test_non_primitive_types,
  &_foo_igen_bar_method_info_request_signal_emission,
  &_foo_igen_bar_method_info_request_multi_property_mods,
  &_foo_igen_bar_method_info_unimplemented_method,
  &_foo_igen_bar_method_info_property_cancellation,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_signal_info_test_signal_ARG_val_int32 =
{
  {
    -1,
    "val_int32",
    "i",
    NULL
  },
  FALSE
};

static const GDBusAnnotationInfo _foo_igen_bar_signal_info_test_signal_ARG_arg_array_of_strings_annotation_info_0 =
{
  -1,
  "Key8",
  "Value8",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_bar_signal_info_test_signal_ARG_arg_array_of_strings_annotation_info_pointers[] =
{
  &_foo_igen_bar_signal_info_test_signal_ARG_arg_array_of_strings_annotation_info_0,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_signal_info_test_signal_ARG_array_of_strings =
{
  {
    -1,
    "array_of_strings",
    "as",
    (GDBusAnnotationInfo **) &_foo_igen_bar_signal_info_test_signal_ARG_arg_array_of_strings_annotation_info_pointers
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_signal_info_test_signal_ARG_array_of_bytestrings =
{
  {
    -1,
    "array_of_bytestrings",
    "aay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_signal_info_test_signal_ARG_dict_s_to_pairs =
{
  {
    -1,
    "dict_s_to_pairs",
    "a{s(ii)}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bar_signal_info_test_signal_ARG_pointers[] =
{
  &_foo_igen_bar_signal_info_test_signal_ARG_val_int32,
  &_foo_igen_bar_signal_info_test_signal_ARG_array_of_strings,
  &_foo_igen_bar_signal_info_test_signal_ARG_array_of_bytestrings,
  &_foo_igen_bar_signal_info_test_signal_ARG_dict_s_to_pairs,
  NULL
};

static const GDBusAnnotationInfo _foo_igen_bar_signal_test_signal_annotation_info_0 =
{
  -1,
  "Key4",
  "Value4",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_bar_signal_test_signal_annotation_info_pointers[] =
{
  &_foo_igen_bar_signal_test_signal_annotation_info_0,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_igen_bar_signal_info_test_signal =
{
  {
    -1,
    "TestSignal",
    (GDBusArgInfo **) &_foo_igen_bar_signal_info_test_signal_ARG_pointers,
    (GDBusAnnotationInfo **) &_foo_igen_bar_signal_test_signal_annotation_info_pointers
  },
  "test-signal"
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_signal_info_another_signal_ARG_word =
{
  {
    -1,
    "word",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bar_signal_info_another_signal_ARG_pointers[] =
{
  &_foo_igen_bar_signal_info_another_signal_ARG_word,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_igen_bar_signal_info_another_signal =
{
  {
    -1,
    "AnotherSignal",
    (GDBusArgInfo **) &_foo_igen_bar_signal_info_another_signal_ARG_pointers,
    NULL
  },
  "another-signal"
};

static const _ExtendedGDBusSignalInfo * const _foo_igen_bar_signal_info_pointers[] =
{
  &_foo_igen_bar_signal_info_test_signal,
  &_foo_igen_bar_signal_info_another_signal,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_y =
{
  {
    -1,
    "y",
    "y",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "y",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_b =
{
  {
    -1,
    "b",
    "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "b",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_n =
{
  {
    -1,
    "n",
    "n",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "n",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_q =
{
  {
    -1,
    "q",
    "q",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "q",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_i =
{
  {
    -1,
    "i",
    "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "i",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_u =
{
  {
    -1,
    "u",
    "u",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "u",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_x =
{
  {
    -1,
    "x",
    "x",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "x",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_t =
{
  {
    -1,
    "t",
    "t",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "t",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_d =
{
  {
    -1,
    "d",
    "d",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "d",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_s =
{
  {
    -1,
    "s",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "s",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_o =
{
  {
    -1,
    "o",
    "o",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "o",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_g =
{
  {
    -1,
    "g",
    "g",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "g",
  FALSE
};

static const GDBusAnnotationInfo _foo_igen_bar_property_ay_annotation_info_0 =
{
  -1,
  "Key5",
  "Value5",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_bar_property_ay_annotation_info_pointers[] =
{
  &_foo_igen_bar_property_ay_annotation_info_0,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_ay =
{
  {
    -1,
    "ay",
    "ay",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    (GDBusAnnotationInfo **) &_foo_igen_bar_property_ay_annotation_info_pointers
  },
  "ay",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_as =
{
  {
    -1,
    "as",
    "as",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "as",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_aay =
{
  {
    -1,
    "aay",
    "aay",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "aay",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_ao =
{
  {
    -1,
    "ao",
    "ao",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ao",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_ag =
{
  {
    -1,
    "ag",
    "ag",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ag",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_finally_normal_name =
{
  {
    -1,
    "FinallyNormalName",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "finally-normal-name",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_readonly_property =
{
  {
    -1,
    "ReadonlyProperty",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "readonly-property",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_writeonly_property =
{
  {
    -1,
    "WriteonlyProperty",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "writeonly-property",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_i =
{
  {
    -1,
    "unset_i",
    "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-i",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_d =
{
  {
    -1,
    "unset_d",
    "d",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-d",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_s =
{
  {
    -1,
    "unset_s",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-s",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_o =
{
  {
    -1,
    "unset_o",
    "o",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-o",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_g =
{
  {
    -1,
    "unset_g",
    "g",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-g",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_ay =
{
  {
    -1,
    "unset_ay",
    "ay",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-ay",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_as =
{
  {
    -1,
    "unset_as",
    "as",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-as",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_ao =
{
  {
    -1,
    "unset_ao",
    "ao",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-ao",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_ag =
{
  {
    -1,
    "unset_ag",
    "ag",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-ag",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_struct =
{
  {
    -1,
    "unset_struct",
    "(idsogayasaoag)",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-struct",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_igen_bar_property_info_pointers[] =
{
  &_foo_igen_bar_property_info_y,
  &_foo_igen_bar_property_info_b,
  &_foo_igen_bar_property_info_n,
  &_foo_igen_bar_property_info_q,
  &_foo_igen_bar_property_info_i,
  &_foo_igen_bar_property_info_u,
  &_foo_igen_bar_property_info_x,
  &_foo_igen_bar_property_info_t,
  &_foo_igen_bar_property_info_d,
  &_foo_igen_bar_property_info_s,
  &_foo_igen_bar_property_info_o,
  &_foo_igen_bar_property_info_g,
  &_foo_igen_bar_property_info_ay,
  &_foo_igen_bar_property_info_as,
  &_foo_igen_bar_property_info_aay,
  &_foo_igen_bar_property_info_ao,
  &_foo_igen_bar_property_info_ag,
  &_foo_igen_bar_property_info_finally_normal_name,
  &_foo_igen_bar_property_info_readonly_property,
  &_foo_igen_bar_property_info_writeonly_property,
  &_foo_igen_bar_property_info_unset_i,
  &_foo_igen_bar_property_info_unset_d,
  &_foo_igen_bar_property_info_unset_s,
  &_foo_igen_bar_property_info_unset_o,
  &_foo_igen_bar_property_info_unset_g,
  &_foo_igen_bar_property_info_unset_ay,
  &_foo_igen_bar_property_info_unset_as,
  &_foo_igen_bar_property_info_unset_ao,
  &_foo_igen_bar_property_info_unset_ag,
  &_foo_igen_bar_property_info_unset_struct,
  NULL
};

static const GDBusAnnotationInfo _foo_igen_bar_annotation_info_0 =
{
  -1,
  "Key1",
  "Value1",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_bar_annotation_info_pointers[] =
{
  &_foo_igen_bar_annotation_info_0,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_bar_interface_info =
{
  {
    -1,
    "org.project.Bar",
    (GDBusMethodInfo **) &_foo_igen_bar_method_info_pointers,
    (GDBusSignalInfo **) &_foo_igen_bar_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_igen_bar_property_info_pointers,
    (GDBusAnnotationInfo **) &_foo_igen_bar_annotation_info_pointers
  },
  "bar",
};


/**
 * foo_igen_bar_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_bar_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_bar_interface_info;
}

/**
 * foo_igen_bar_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenBar interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_bar_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "y");
  g_object_class_override_property (klass, property_id_begin++, "b");
  g_object_class_override_property (klass, property_id_begin++, "n");
  g_object_class_override_property (klass, property_id_begin++, "q");
  g_object_class_override_property (klass, property_id_begin++, "i");
  g_object_class_override_property (klass, property_id_begin++, "u");
  g_object_class_override_property (klass, property_id_begin++, "x");
  g_object_class_override_property (klass, property_id_begin++, "t");
  g_object_class_override_property (klass, property_id_begin++, "d");
  g_object_class_override_property (klass, property_id_begin++, "s");
  g_object_class_override_property (klass, property_id_begin++, "o");
  g_object_class_override_property (klass, property_id_begin++, "g");
  g_object_class_override_property (klass, property_id_begin++, "ay");
  g_object_class_override_property (klass, property_id_begin++, "as");
  g_object_class_override_property (klass, property_id_begin++, "aay");
  g_object_class_override_property (klass, property_id_begin++, "ao");
  g_object_class_override_property (klass, property_id_begin++, "ag");
  g_object_class_override_property (klass, property_id_begin++, "finally-normal-name");
  g_object_class_override_property (klass, property_id_begin++, "readonly-property");
  g_object_class_override_property (klass, property_id_begin++, "writeonly-property");
  g_object_class_override_property (klass, property_id_begin++, "unset-i");
  g_object_class_override_property (klass, property_id_begin++, "unset-d");
  g_object_class_override_property (klass, property_id_begin++, "unset-s");
  g_object_class_override_property (klass, property_id_begin++, "unset-o");
  g_object_class_override_property (klass, property_id_begin++, "unset-g");
  g_object_class_override_property (klass, property_id_begin++, "unset-ay");
  g_object_class_override_property (klass, property_id_begin++, "unset-as");
  g_object_class_override_property (klass, property_id_begin++, "unset-ao");
  g_object_class_override_property (klass, property_id_begin++, "unset-ag");
  g_object_class_override_property (klass, property_id_begin++, "unset-struct");
  return property_id_begin - 1;
}



/**
 * FooiGenBar:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link>.
 */

/**
 * FooiGenBarIface:
 * @parent_iface: The parent interface.
 * @handle_hello_world: Handler for the #FooiGenBar::handle-hello-world signal.
 * @handle_property_cancellation: Handler for the #FooiGenBar::handle-property-cancellation signal.
 * @handle_request_multi_property_mods: Handler for the #FooiGenBar::handle-request-multi-property-mods signal.
 * @handle_request_signal_emission: Handler for the #FooiGenBar::handle-request-signal-emission signal.
 * @handle_test_non_primitive_types: Handler for the #FooiGenBar::handle-test-non-primitive-types signal.
 * @handle_test_primitive_types: Handler for the #FooiGenBar::handle-test-primitive-types signal.
 * @handle_unimplemented_method: Handler for the #FooiGenBar::handle-unimplemented-method signal.
 * @get_aay: Getter for the #FooiGenBar:aay property.
 * @get_ag: Getter for the #FooiGenBar:ag property.
 * @get_ao: Getter for the #FooiGenBar:ao property.
 * @get_as: Getter for the #FooiGenBar:as property.
 * @get_ay: Getter for the #FooiGenBar:ay property.
 * @get_b: Getter for the #FooiGenBar:b property.
 * @get_d: Getter for the #FooiGenBar:d property.
 * @get_finally_normal_name: Getter for the #FooiGenBar:finally-normal-name property.
 * @get_g: Getter for the #FooiGenBar:g property.
 * @get_i: Getter for the #FooiGenBar:i property.
 * @get_n: Getter for the #FooiGenBar:n property.
 * @get_o: Getter for the #FooiGenBar:o property.
 * @get_q: Getter for the #FooiGenBar:q property.
 * @get_readonly_property: Getter for the #FooiGenBar:readonly-property property.
 * @get_s: Getter for the #FooiGenBar:s property.
 * @get_t: Getter for the #FooiGenBar:t property.
 * @get_u: Getter for the #FooiGenBar:u property.
 * @get_unset_ag: Getter for the #FooiGenBar:unset-ag property.
 * @get_unset_ao: Getter for the #FooiGenBar:unset-ao property.
 * @get_unset_as: Getter for the #FooiGenBar:unset-as property.
 * @get_unset_ay: Getter for the #FooiGenBar:unset-ay property.
 * @get_unset_d: Getter for the #FooiGenBar:unset-d property.
 * @get_unset_g: Getter for the #FooiGenBar:unset-g property.
 * @get_unset_i: Getter for the #FooiGenBar:unset-i property.
 * @get_unset_o: Getter for the #FooiGenBar:unset-o property.
 * @get_unset_s: Getter for the #FooiGenBar:unset-s property.
 * @get_unset_struct: Getter for the #FooiGenBar:unset-struct property.
 * @get_writeonly_property: Getter for the #FooiGenBar:writeonly-property property.
 * @get_x: Getter for the #FooiGenBar:x property.
 * @get_y: Getter for the #FooiGenBar:y property.
 * @another_signal: Handler for the #FooiGenBar::another-signal signal.
 * @test_signal: Handler for the #FooiGenBar::test-signal signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link>.
 */

static void
foo_igen_bar_default_init (FooiGenBarIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenBar::handle-hello-world:
   * @object: A #FooiGenBar.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_greeting: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.HelloWorld">HelloWorld()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_bar_complete_hello_world() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-hello-world",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarIface, handle_hello_world),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * FooiGenBar::handle-test-primitive-types:
   * @object: A #FooiGenBar.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_val_byte: Argument passed by remote caller.
   * @arg_val_boolean: Argument passed by remote caller.
   * @arg_val_int16: Argument passed by remote caller.
   * @arg_val_uint16: Argument passed by remote caller.
   * @arg_val_int32: Argument passed by remote caller.
   * @arg_val_uint32: Argument passed by remote caller.
   * @arg_val_int64: Argument passed by remote caller.
   * @arg_val_uint64: Argument passed by remote caller.
   * @arg_val_double: Argument passed by remote caller.
   * @arg_val_string: Argument passed by remote caller.
   * @arg_val_objpath: Argument passed by remote caller.
   * @arg_val_signature: Argument passed by remote caller.
   * @arg_val_bytestring: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.TestPrimitiveTypes">TestPrimitiveTypes()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_bar_complete_test_primitive_types() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-test-primitive-types",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarIface, handle_test_primitive_types),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    14,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_UCHAR, G_TYPE_BOOLEAN, G_TYPE_INT, G_TYPE_UINT, G_TYPE_INT, G_TYPE_UINT, G_TYPE_INT64, G_TYPE_UINT64, G_TYPE_DOUBLE, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * FooiGenBar::handle-test-non-primitive-types:
   * @object: A #FooiGenBar.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_dict_s_to_s: Argument passed by remote caller.
   * @arg_dict_s_to_pairs: Argument passed by remote caller.
   * @arg_a_struct: Argument passed by remote caller.
   * @arg_array_of_strings: Argument passed by remote caller.
   * @arg_array_of_objpaths: Argument passed by remote caller.
   * @arg_array_of_signatures: Argument passed by remote caller.
   * @arg_array_of_bytestrings: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.TestNonPrimitiveTypes">TestNonPrimitiveTypes()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_bar_complete_test_non_primitive_types() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-test-non-primitive-types",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarIface, handle_test_non_primitive_types),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    8,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT, G_TYPE_VARIANT, G_TYPE_VARIANT, G_TYPE_STRV, G_TYPE_STRV, G_TYPE_VARIANT, G_TYPE_STRV);

  /**
   * FooiGenBar::handle-request-signal-emission:
   * @object: A #FooiGenBar.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_which_one: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.RequestSignalEmission">RequestSignalEmission()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_bar_complete_request_signal_emission() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-request-signal-emission",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarIface, handle_request_signal_emission),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT);

  /**
   * FooiGenBar::handle-request-multi-property-mods:
   * @object: A #FooiGenBar.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.RequestMultiPropertyMods">RequestMultiPropertyMods()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_bar_complete_request_multi_property_mods() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-request-multi-property-mods",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarIface, handle_request_multi_property_mods),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenBar::handle-unimplemented-method:
   * @object: A #FooiGenBar.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.UnimplementedMethod">UnimplementedMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_bar_complete_unimplemented_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-unimplemented-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarIface, handle_unimplemented_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenBar::handle-property-cancellation:
   * @object: A #FooiGenBar.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.PropertyCancellation">PropertyCancellation()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_bar_complete_property_cancellation() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-property-cancellation",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarIface, handle_property_cancellation),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooiGenBar::test-signal:
   * @object: A #FooiGenBar.
   * @arg_val_int32: Argument.
   * @arg_array_of_strings: Argument.
   * @arg_array_of_bytestrings: Argument.
   * @arg_dict_s_to_pairs: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-project-Bar.TestSignal">"TestSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("test-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarIface, test_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    4, G_TYPE_INT, G_TYPE_STRV, G_TYPE_STRV, G_TYPE_VARIANT);

  /**
   * FooiGenBar::another-signal:
   * @object: A #FooiGenBar.
   * @arg_word: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-project-Bar.AnotherSignal">"AnotherSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("another-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarIface, another_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /* GObject properties for D-Bus properties: */
  /**
   * FooiGenBar:y:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.y">"y"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_uchar ("y", "y", "y", 0, 255, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:b:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.b">"b"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("b", "b", "b", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:n:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.n">"n"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("n", "n", "n", G_MININT16, G_MAXINT16, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:q:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.q">"q"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_uint ("q", "q", "q", 0, G_MAXUINT16, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:i:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.i">"i"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("i", "i", "i", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:u:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.u">"u"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_uint ("u", "u", "u", 0, G_MAXUINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:x:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.x">"x"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int64 ("x", "x", "x", G_MININT64, G_MAXINT64, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:t:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.t">"t"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_uint64 ("t", "t", "t", 0, G_MAXUINT64, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:d:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.d">"d"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_double ("d", "d", "d", -G_MAXDOUBLE, G_MAXDOUBLE, 0.0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:s:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.s">"s"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("s", "s", "s", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:o:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.o">"o"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("o", "o", "o", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:g:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.g">"g"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("g", "g", "g", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:ay:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.ay">"ay"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("ay", "ay", "ay", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:as:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.as">"as"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("as", "as", "as", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:aay:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.aay">"aay"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("aay", "aay", "aay", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:ao:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.ao">"ao"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("ao", "ao", "ao", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:ag:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.ag">"ag"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("ag", "ag", "ag", G_VARIANT_TYPE ("ag"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:finally-normal-name:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.FinallyNormalName">"FinallyNormalName"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("finally-normal-name", "FinallyNormalName", "FinallyNormalName", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:readonly-property:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.ReadonlyProperty">"ReadonlyProperty"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("readonly-property", "ReadonlyProperty", "ReadonlyProperty", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:writeonly-property:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.WriteonlyProperty">"WriteonlyProperty"</link>.
   *
   * Since the D-Bus property for this #GObject property is writable but not readable, it is meaningful to write to it on both the client- and service-side. It is only meaningful, however, to read from it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("writeonly-property", "WriteonlyProperty", "WriteonlyProperty", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-i:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_i">"unset_i"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("unset-i", "unset_i", "unset_i", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-d:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_d">"unset_d"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_double ("unset-d", "unset_d", "unset_d", -G_MAXDOUBLE, G_MAXDOUBLE, 0.0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-s:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_s">"unset_s"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("unset-s", "unset_s", "unset_s", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-o:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_o">"unset_o"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("unset-o", "unset_o", "unset_o", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-g:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_g">"unset_g"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("unset-g", "unset_g", "unset_g", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-ay:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_ay">"unset_ay"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("unset-ay", "unset_ay", "unset_ay", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-as:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_as">"unset_as"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("unset-as", "unset_as", "unset_as", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-ao:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_ao">"unset_ao"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("unset-ao", "unset_ao", "unset_ao", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-ag:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_ag">"unset_ag"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("unset-ag", "unset_ag", "unset_ag", G_VARIANT_TYPE ("ag"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-struct:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_struct">"unset_struct"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("unset-struct", "unset_struct", "unset_struct", G_VARIANT_TYPE ("(idsogayasaoag)"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

typedef FooiGenBarIface FooiGenBarInterface;
G_DEFINE_INTERFACE (FooiGenBar, foo_igen_bar, G_TYPE_OBJECT);

/**
 * foo_igen_bar_get_y: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.y">"y"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
guchar 
foo_igen_bar_get_y (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_y (object);
}

/**
 * foo_igen_bar_set_y: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.y">"y"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_y (FooiGenBar *object, guchar value)
{
  g_object_set (G_OBJECT (object), "y", value, NULL);
}

/**
 * foo_igen_bar_get_b: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.b">"b"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
foo_igen_bar_get_b (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_b (object);
}

/**
 * foo_igen_bar_set_b: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.b">"b"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_b (FooiGenBar *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "b", value, NULL);
}

/**
 * foo_igen_bar_get_n: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.n">"n"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint16 
foo_igen_bar_get_n (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_n (object);
}

/**
 * foo_igen_bar_set_n: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.n">"n"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_n (FooiGenBar *object, gint16 value)
{
  g_object_set (G_OBJECT (object), "n", value, NULL);
}

/**
 * foo_igen_bar_get_q: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.q">"q"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
guint16 
foo_igen_bar_get_q (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_q (object);
}

/**
 * foo_igen_bar_set_q: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.q">"q"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_q (FooiGenBar *object, guint16 value)
{
  g_object_set (G_OBJECT (object), "q", value, NULL);
}

/**
 * foo_igen_bar_get_i: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.i">"i"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
foo_igen_bar_get_i (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_i (object);
}

/**
 * foo_igen_bar_set_i: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.i">"i"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_i (FooiGenBar *object, gint value)
{
  g_object_set (G_OBJECT (object), "i", value, NULL);
}

/**
 * foo_igen_bar_get_u: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.u">"u"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
guint 
foo_igen_bar_get_u (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_u (object);
}

/**
 * foo_igen_bar_set_u: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.u">"u"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_u (FooiGenBar *object, guint value)
{
  g_object_set (G_OBJECT (object), "u", value, NULL);
}

/**
 * foo_igen_bar_get_x: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.x">"x"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint64 
foo_igen_bar_get_x (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_x (object);
}

/**
 * foo_igen_bar_set_x: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.x">"x"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_x (FooiGenBar *object, gint64 value)
{
  g_object_set (G_OBJECT (object), "x", value, NULL);
}

/**
 * foo_igen_bar_get_t: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.t">"t"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
guint64 
foo_igen_bar_get_t (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_t (object);
}

/**
 * foo_igen_bar_set_t: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.t">"t"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_t (FooiGenBar *object, guint64 value)
{
  g_object_set (G_OBJECT (object), "t", value, NULL);
}

/**
 * foo_igen_bar_get_d: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.d">"d"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gdouble 
foo_igen_bar_get_d (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_d (object);
}

/**
 * foo_igen_bar_set_d: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.d">"d"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_d (FooiGenBar *object, gdouble value)
{
  g_object_set (G_OBJECT (object), "d", value, NULL);
}

/**
 * foo_igen_bar_get_s: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.s">"s"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_s() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_s (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_s (object);
}

/**
 * foo_igen_bar_dup_s: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.s">"s"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_s (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "s", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_s: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.s">"s"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_s (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "s", value, NULL);
}

/**
 * foo_igen_bar_get_o: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.o">"o"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_o() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_o (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_o (object);
}

/**
 * foo_igen_bar_dup_o: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.o">"o"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_o (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "o", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_o: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.o">"o"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_o (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "o", value, NULL);
}

/**
 * foo_igen_bar_get_g: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.g">"g"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_g() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_g (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_g (object);
}

/**
 * foo_igen_bar_dup_g: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.g">"g"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_g (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "g", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_g: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.g">"g"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_g (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "g", value, NULL);
}

/**
 * foo_igen_bar_get_ay: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.ay">"ay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_ay() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_ay (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_ay (object);
}

/**
 * foo_igen_bar_dup_ay: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.ay">"ay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_ay (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "ay", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_ay: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.ay">"ay"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_ay (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "ay", value, NULL);
}

/**
 * foo_igen_bar_get_as: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.as">"as"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_as() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *const *
foo_igen_bar_get_as (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_as (object);
}

/**
 * foo_igen_bar_dup_as: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.as">"as"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_strfreev().
 */
gchar **
foo_igen_bar_dup_as (FooiGenBar *object)
{
  gchar **value;
  g_object_get (G_OBJECT (object), "as", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_as: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.as">"as"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_as (FooiGenBar *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "as", value, NULL);
}

/**
 * foo_igen_bar_get_aay: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.aay">"aay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_aay() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *const *
foo_igen_bar_get_aay (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_aay (object);
}

/**
 * foo_igen_bar_dup_aay: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.aay">"aay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_strfreev().
 */
gchar **
foo_igen_bar_dup_aay (FooiGenBar *object)
{
  gchar **value;
  g_object_get (G_OBJECT (object), "aay", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_aay: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.aay">"aay"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_aay (FooiGenBar *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "aay", value, NULL);
}

/**
 * foo_igen_bar_get_ao: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.ao">"ao"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_ao() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *const *
foo_igen_bar_get_ao (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_ao (object);
}

/**
 * foo_igen_bar_dup_ao: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.ao">"ao"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_strfreev().
 */
gchar **
foo_igen_bar_dup_ao (FooiGenBar *object)
{
  gchar **value;
  g_object_get (G_OBJECT (object), "ao", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_ao: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.ao">"ao"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_ao (FooiGenBar *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "ao", value, NULL);
}

/**
 * foo_igen_bar_get_ag: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.ag">"ag"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_ag() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
foo_igen_bar_get_ag (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_ag (object);
}

/**
 * foo_igen_bar_dup_ag: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.ag">"ag"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
foo_igen_bar_dup_ag (FooiGenBar *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "ag", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_ag: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.ag">"ag"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_ag (FooiGenBar *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "ag", value, NULL);
}

/**
 * foo_igen_bar_get_finally_normal_name: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.FinallyNormalName">"FinallyNormalName"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_finally_normal_name() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_finally_normal_name (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_finally_normal_name (object);
}

/**
 * foo_igen_bar_dup_finally_normal_name: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.FinallyNormalName">"FinallyNormalName"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_finally_normal_name (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "finally-normal-name", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_finally_normal_name: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.FinallyNormalName">"FinallyNormalName"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_finally_normal_name (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "finally-normal-name", value, NULL);
}

/**
 * foo_igen_bar_get_readonly_property: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.ReadonlyProperty">"ReadonlyProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_readonly_property() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_readonly_property (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_readonly_property (object);
}

/**
 * foo_igen_bar_dup_readonly_property: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.ReadonlyProperty">"ReadonlyProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_readonly_property (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "readonly-property", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_readonly_property: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.ReadonlyProperty">"ReadonlyProperty"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_bar_set_readonly_property (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "readonly-property", value, NULL);
}

/**
 * foo_igen_bar_get_writeonly_property: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.WriteonlyProperty">"WriteonlyProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is not readable, it is only meaningful to use this function on the service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_writeonly_property() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_writeonly_property (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_writeonly_property (object);
}

/**
 * foo_igen_bar_dup_writeonly_property: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.WriteonlyProperty">"WriteonlyProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is not readable, it is only meaningful to use this function on the service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_writeonly_property (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "writeonly-property", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_writeonly_property: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.WriteonlyProperty">"WriteonlyProperty"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_writeonly_property (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "writeonly-property", value, NULL);
}

/**
 * foo_igen_bar_get_unset_i: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_i">"unset_i"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
foo_igen_bar_get_unset_i (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_i (object);
}

/**
 * foo_igen_bar_set_unset_i: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_i">"unset_i"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_i (FooiGenBar *object, gint value)
{
  g_object_set (G_OBJECT (object), "unset-i", value, NULL);
}

/**
 * foo_igen_bar_get_unset_d: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_d">"unset_d"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gdouble 
foo_igen_bar_get_unset_d (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_d (object);
}

/**
 * foo_igen_bar_set_unset_d: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_d">"unset_d"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_d (FooiGenBar *object, gdouble value)
{
  g_object_set (G_OBJECT (object), "unset-d", value, NULL);
}

/**
 * foo_igen_bar_get_unset_s: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_s">"unset_s"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_unset_s() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_unset_s (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_s (object);
}

/**
 * foo_igen_bar_dup_unset_s: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.unset_s">"unset_s"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_unset_s (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "unset-s", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_unset_s: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_s">"unset_s"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_s (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "unset-s", value, NULL);
}

/**
 * foo_igen_bar_get_unset_o: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_o">"unset_o"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_unset_o() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_unset_o (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_o (object);
}

/**
 * foo_igen_bar_dup_unset_o: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.unset_o">"unset_o"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_unset_o (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "unset-o", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_unset_o: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_o">"unset_o"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_o (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "unset-o", value, NULL);
}

/**
 * foo_igen_bar_get_unset_g: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_g">"unset_g"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_unset_g() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_unset_g (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_g (object);
}

/**
 * foo_igen_bar_dup_unset_g: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.unset_g">"unset_g"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_unset_g (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "unset-g", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_unset_g: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_g">"unset_g"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_g (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "unset-g", value, NULL);
}

/**
 * foo_igen_bar_get_unset_ay: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_ay">"unset_ay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_unset_ay() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_unset_ay (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_ay (object);
}

/**
 * foo_igen_bar_dup_unset_ay: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.unset_ay">"unset_ay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_unset_ay (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "unset-ay", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_unset_ay: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_ay">"unset_ay"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_ay (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "unset-ay", value, NULL);
}

/**
 * foo_igen_bar_get_unset_as: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_as">"unset_as"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_unset_as() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *const *
foo_igen_bar_get_unset_as (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_as (object);
}

/**
 * foo_igen_bar_dup_unset_as: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.unset_as">"unset_as"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_strfreev().
 */
gchar **
foo_igen_bar_dup_unset_as (FooiGenBar *object)
{
  gchar **value;
  g_object_get (G_OBJECT (object), "unset-as", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_unset_as: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_as">"unset_as"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_as (FooiGenBar *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "unset-as", value, NULL);
}

/**
 * foo_igen_bar_get_unset_ao: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_ao">"unset_ao"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_unset_ao() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *const *
foo_igen_bar_get_unset_ao (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_ao (object);
}

/**
 * foo_igen_bar_dup_unset_ao: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.unset_ao">"unset_ao"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_strfreev().
 */
gchar **
foo_igen_bar_dup_unset_ao (FooiGenBar *object)
{
  gchar **value;
  g_object_get (G_OBJECT (object), "unset-ao", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_unset_ao: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_ao">"unset_ao"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_ao (FooiGenBar *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "unset-ao", value, NULL);
}

/**
 * foo_igen_bar_get_unset_ag: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_ag">"unset_ag"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_unset_ag() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
foo_igen_bar_get_unset_ag (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_ag (object);
}

/**
 * foo_igen_bar_dup_unset_ag: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.unset_ag">"unset_ag"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
foo_igen_bar_dup_unset_ag (FooiGenBar *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "unset-ag", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_unset_ag: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_ag">"unset_ag"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_ag (FooiGenBar *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "unset-ag", value, NULL);
}

/**
 * foo_igen_bar_get_unset_struct: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_struct">"unset_struct"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_unset_struct() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
foo_igen_bar_get_unset_struct (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_struct (object);
}

/**
 * foo_igen_bar_dup_unset_struct: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.unset_struct">"unset_struct"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
foo_igen_bar_dup_unset_struct (FooiGenBar *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "unset-struct", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_unset_struct: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_struct">"unset_struct"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_struct (FooiGenBar *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "unset-struct", value, NULL);
}

/**
 * foo_igen_bar_emit_test_signal:
 * @object: A #FooiGenBar.
 * @arg_val_int32: Argument to pass with the signal.
 * @arg_array_of_strings: Argument to pass with the signal.
 * @arg_array_of_bytestrings: Argument to pass with the signal.
 * @arg_dict_s_to_pairs: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-project-Bar.TestSignal">"TestSignal"</link> D-Bus signal.
 */
void
foo_igen_bar_emit_test_signal (
    FooiGenBar *object,
    gint arg_val_int32,
    const gchar *const *arg_array_of_strings,
    const gchar *const *arg_array_of_bytestrings,
    GVariant *arg_dict_s_to_pairs)
{
  g_signal_emit_by_name (object, "test-signal", arg_val_int32, arg_array_of_strings, arg_array_of_bytestrings, arg_dict_s_to_pairs);
}

/**
 * foo_igen_bar_emit_another_signal:
 * @object: A #FooiGenBar.
 * @arg_word: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-project-Bar.AnotherSignal">"AnotherSignal"</link> D-Bus signal.
 */
void
foo_igen_bar_emit_another_signal (
    FooiGenBar *object,
    const gchar *arg_word)
{
  g_signal_emit_by_name (object, "another-signal", arg_word);
}

/**
 * foo_igen_bar_call_hello_world:
 * @proxy: A #FooiGenBarProxy.
 * @arg_greeting: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.HelloWorld">HelloWorld()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_call_hello_world_finish() to get the result of the operation.
 *
 * See foo_igen_bar_call_hello_world_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_bar_call_hello_world (
    FooiGenBar *proxy,
    const gchar *arg_greeting,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "HelloWorld",
    g_variant_new ("(s)",
                   arg_greeting),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_bar_call_hello_world_finish:
 * @proxy: A #FooiGenBarProxy.
 * @out_response: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_call_hello_world().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_bar_call_hello_world().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_hello_world_finish (
    FooiGenBar *proxy,
    gchar **out_response,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_response);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_hello_world_sync:
 * @proxy: A #FooiGenBarProxy.
 * @arg_greeting: Argument to pass with the method invocation.
 * @out_response: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.HelloWorld">HelloWorld()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_call_hello_world() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_hello_world_sync (
    FooiGenBar *proxy,
    const gchar *arg_greeting,
    gchar **out_response,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "HelloWorld",
    g_variant_new ("(s)",
                   arg_greeting),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_response);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_test_primitive_types:
 * @proxy: A #FooiGenBarProxy.
 * @arg_val_byte: Argument to pass with the method invocation.
 * @arg_val_boolean: Argument to pass with the method invocation.
 * @arg_val_int16: Argument to pass with the method invocation.
 * @arg_val_uint16: Argument to pass with the method invocation.
 * @arg_val_int32: Argument to pass with the method invocation.
 * @arg_val_uint32: Argument to pass with the method invocation.
 * @arg_val_int64: Argument to pass with the method invocation.
 * @arg_val_uint64: Argument to pass with the method invocation.
 * @arg_val_double: Argument to pass with the method invocation.
 * @arg_val_string: Argument to pass with the method invocation.
 * @arg_val_objpath: Argument to pass with the method invocation.
 * @arg_val_signature: Argument to pass with the method invocation.
 * @arg_val_bytestring: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.TestPrimitiveTypes">TestPrimitiveTypes()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_call_test_primitive_types_finish() to get the result of the operation.
 *
 * See foo_igen_bar_call_test_primitive_types_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_bar_call_test_primitive_types (
    FooiGenBar *proxy,
    guchar arg_val_byte,
    gboolean arg_val_boolean,
    gint16 arg_val_int16,
    guint16 arg_val_uint16,
    gint arg_val_int32,
    guint arg_val_uint32,
    gint64 arg_val_int64,
    guint64 arg_val_uint64,
    gdouble arg_val_double,
    const gchar *arg_val_string,
    const gchar *arg_val_objpath,
    const gchar *arg_val_signature,
    const gchar *arg_val_bytestring,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "TestPrimitiveTypes",
    g_variant_new ("(ybnqiuxtdsog^ay)",
                   arg_val_byte,
                   arg_val_boolean,
                   arg_val_int16,
                   arg_val_uint16,
                   arg_val_int32,
                   arg_val_uint32,
                   arg_val_int64,
                   arg_val_uint64,
                   arg_val_double,
                   arg_val_string,
                   arg_val_objpath,
                   arg_val_signature,
                   arg_val_bytestring),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_bar_call_test_primitive_types_finish:
 * @proxy: A #FooiGenBarProxy.
 * @out_ret_byte: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_boolean: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_int16: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_uint16: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_int32: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_uint32: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_int64: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_uint64: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_double: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_string: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_objpath: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_signature: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_bytestring: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_call_test_primitive_types().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_bar_call_test_primitive_types().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_test_primitive_types_finish (
    FooiGenBar *proxy,
    guchar *out_ret_byte,
    gboolean *out_ret_boolean,
    gint16 *out_ret_int16,
    guint16 *out_ret_uint16,
    gint *out_ret_int32,
    guint *out_ret_uint32,
    gint64 *out_ret_int64,
    guint64 *out_ret_uint64,
    gdouble *out_ret_double,
    gchar **out_ret_string,
    gchar **out_ret_objpath,
    gchar **out_ret_signature,
    gchar **out_ret_bytestring,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(ybnqiuxtdsog^ay)",
                 out_ret_byte,
                 out_ret_boolean,
                 out_ret_int16,
                 out_ret_uint16,
                 out_ret_int32,
                 out_ret_uint32,
                 out_ret_int64,
                 out_ret_uint64,
                 out_ret_double,
                 out_ret_string,
                 out_ret_objpath,
                 out_ret_signature,
                 out_ret_bytestring);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_test_primitive_types_sync:
 * @proxy: A #FooiGenBarProxy.
 * @arg_val_byte: Argument to pass with the method invocation.
 * @arg_val_boolean: Argument to pass with the method invocation.
 * @arg_val_int16: Argument to pass with the method invocation.
 * @arg_val_uint16: Argument to pass with the method invocation.
 * @arg_val_int32: Argument to pass with the method invocation.
 * @arg_val_uint32: Argument to pass with the method invocation.
 * @arg_val_int64: Argument to pass with the method invocation.
 * @arg_val_uint64: Argument to pass with the method invocation.
 * @arg_val_double: Argument to pass with the method invocation.
 * @arg_val_string: Argument to pass with the method invocation.
 * @arg_val_objpath: Argument to pass with the method invocation.
 * @arg_val_signature: Argument to pass with the method invocation.
 * @arg_val_bytestring: Argument to pass with the method invocation.
 * @out_ret_byte: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_boolean: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_int16: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_uint16: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_int32: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_uint32: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_int64: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_uint64: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_double: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_string: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_objpath: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_signature: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_bytestring: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.TestPrimitiveTypes">TestPrimitiveTypes()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_call_test_primitive_types() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_test_primitive_types_sync (
    FooiGenBar *proxy,
    guchar arg_val_byte,
    gboolean arg_val_boolean,
    gint16 arg_val_int16,
    guint16 arg_val_uint16,
    gint arg_val_int32,
    guint arg_val_uint32,
    gint64 arg_val_int64,
    guint64 arg_val_uint64,
    gdouble arg_val_double,
    const gchar *arg_val_string,
    const gchar *arg_val_objpath,
    const gchar *arg_val_signature,
    const gchar *arg_val_bytestring,
    guchar *out_ret_byte,
    gboolean *out_ret_boolean,
    gint16 *out_ret_int16,
    guint16 *out_ret_uint16,
    gint *out_ret_int32,
    guint *out_ret_uint32,
    gint64 *out_ret_int64,
    guint64 *out_ret_uint64,
    gdouble *out_ret_double,
    gchar **out_ret_string,
    gchar **out_ret_objpath,
    gchar **out_ret_signature,
    gchar **out_ret_bytestring,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "TestPrimitiveTypes",
    g_variant_new ("(ybnqiuxtdsog^ay)",
                   arg_val_byte,
                   arg_val_boolean,
                   arg_val_int16,
                   arg_val_uint16,
                   arg_val_int32,
                   arg_val_uint32,
                   arg_val_int64,
                   arg_val_uint64,
                   arg_val_double,
                   arg_val_string,
                   arg_val_objpath,
                   arg_val_signature,
                   arg_val_bytestring),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(ybnqiuxtdsog^ay)",
                 out_ret_byte,
                 out_ret_boolean,
                 out_ret_int16,
                 out_ret_uint16,
                 out_ret_int32,
                 out_ret_uint32,
                 out_ret_int64,
                 out_ret_uint64,
                 out_ret_double,
                 out_ret_string,
                 out_ret_objpath,
                 out_ret_signature,
                 out_ret_bytestring);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_test_non_primitive_types:
 * @proxy: A #FooiGenBarProxy.
 * @arg_dict_s_to_s: Argument to pass with the method invocation.
 * @arg_dict_s_to_pairs: Argument to pass with the method invocation.
 * @arg_a_struct: Argument to pass with the method invocation.
 * @arg_array_of_strings: Argument to pass with the method invocation.
 * @arg_array_of_objpaths: Argument to pass with the method invocation.
 * @arg_array_of_signatures: Argument to pass with the method invocation.
 * @arg_array_of_bytestrings: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.TestNonPrimitiveTypes">TestNonPrimitiveTypes()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_call_test_non_primitive_types_finish() to get the result of the operation.
 *
 * See foo_igen_bar_call_test_non_primitive_types_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_bar_call_test_non_primitive_types (
    FooiGenBar *proxy,
    GVariant *arg_dict_s_to_s,
    GVariant *arg_dict_s_to_pairs,
    GVariant *arg_a_struct,
    const gchar *const *arg_array_of_strings,
    const gchar *const *arg_array_of_objpaths,
    GVariant *arg_array_of_signatures,
    const gchar *const *arg_array_of_bytestrings,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "TestNonPrimitiveTypes",
    g_variant_new ("(@a{ss}@a{s(ii)}@(iss)^as^ao@ag^aay)",
                   arg_dict_s_to_s,
                   arg_dict_s_to_pairs,
                   arg_a_struct,
                   arg_array_of_strings,
                   arg_array_of_objpaths,
                   arg_array_of_signatures,
                   arg_array_of_bytestrings),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_bar_call_test_non_primitive_types_finish:
 * @proxy: A #FooiGenBarProxy.
 * @out_result: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_call_test_non_primitive_types().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_bar_call_test_non_primitive_types().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_test_non_primitive_types_finish (
    FooiGenBar *proxy,
    gchar **out_result,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^ay)",
                 out_result);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_test_non_primitive_types_sync:
 * @proxy: A #FooiGenBarProxy.
 * @arg_dict_s_to_s: Argument to pass with the method invocation.
 * @arg_dict_s_to_pairs: Argument to pass with the method invocation.
 * @arg_a_struct: Argument to pass with the method invocation.
 * @arg_array_of_strings: Argument to pass with the method invocation.
 * @arg_array_of_objpaths: Argument to pass with the method invocation.
 * @arg_array_of_signatures: Argument to pass with the method invocation.
 * @arg_array_of_bytestrings: Argument to pass with the method invocation.
 * @out_result: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.TestNonPrimitiveTypes">TestNonPrimitiveTypes()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_call_test_non_primitive_types() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_test_non_primitive_types_sync (
    FooiGenBar *proxy,
    GVariant *arg_dict_s_to_s,
    GVariant *arg_dict_s_to_pairs,
    GVariant *arg_a_struct,
    const gchar *const *arg_array_of_strings,
    const gchar *const *arg_array_of_objpaths,
    GVariant *arg_array_of_signatures,
    const gchar *const *arg_array_of_bytestrings,
    gchar **out_result,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "TestNonPrimitiveTypes",
    g_variant_new ("(@a{ss}@a{s(ii)}@(iss)^as^ao@ag^aay)",
                   arg_dict_s_to_s,
                   arg_dict_s_to_pairs,
                   arg_a_struct,
                   arg_array_of_strings,
                   arg_array_of_objpaths,
                   arg_array_of_signatures,
                   arg_array_of_bytestrings),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^ay)",
                 out_result);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_request_signal_emission:
 * @proxy: A #FooiGenBarProxy.
 * @arg_which_one: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.RequestSignalEmission">RequestSignalEmission()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_call_request_signal_emission_finish() to get the result of the operation.
 *
 * See foo_igen_bar_call_request_signal_emission_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_bar_call_request_signal_emission (
    FooiGenBar *proxy,
    gint arg_which_one,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "RequestSignalEmission",
    g_variant_new ("(i)",
                   arg_which_one),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_bar_call_request_signal_emission_finish:
 * @proxy: A #FooiGenBarProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_call_request_signal_emission().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_bar_call_request_signal_emission().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_request_signal_emission_finish (
    FooiGenBar *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_request_signal_emission_sync:
 * @proxy: A #FooiGenBarProxy.
 * @arg_which_one: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.RequestSignalEmission">RequestSignalEmission()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_call_request_signal_emission() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_request_signal_emission_sync (
    FooiGenBar *proxy,
    gint arg_which_one,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "RequestSignalEmission",
    g_variant_new ("(i)",
                   arg_which_one),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_request_multi_property_mods:
 * @proxy: A #FooiGenBarProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.RequestMultiPropertyMods">RequestMultiPropertyMods()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_call_request_multi_property_mods_finish() to get the result of the operation.
 *
 * See foo_igen_bar_call_request_multi_property_mods_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_bar_call_request_multi_property_mods (
    FooiGenBar *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "RequestMultiPropertyMods",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_bar_call_request_multi_property_mods_finish:
 * @proxy: A #FooiGenBarProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_call_request_multi_property_mods().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_bar_call_request_multi_property_mods().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_request_multi_property_mods_finish (
    FooiGenBar *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_request_multi_property_mods_sync:
 * @proxy: A #FooiGenBarProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.RequestMultiPropertyMods">RequestMultiPropertyMods()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_call_request_multi_property_mods() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_request_multi_property_mods_sync (
    FooiGenBar *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "RequestMultiPropertyMods",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_unimplemented_method:
 * @proxy: A #FooiGenBarProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.UnimplementedMethod">UnimplementedMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_call_unimplemented_method_finish() to get the result of the operation.
 *
 * See foo_igen_bar_call_unimplemented_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_bar_call_unimplemented_method (
    FooiGenBar *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "UnimplementedMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_bar_call_unimplemented_method_finish:
 * @proxy: A #FooiGenBarProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_call_unimplemented_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_bar_call_unimplemented_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_unimplemented_method_finish (
    FooiGenBar *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_unimplemented_method_sync:
 * @proxy: A #FooiGenBarProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.UnimplementedMethod">UnimplementedMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_call_unimplemented_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_unimplemented_method_sync (
    FooiGenBar *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "UnimplementedMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_property_cancellation:
 * @proxy: A #FooiGenBarProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.PropertyCancellation">PropertyCancellation()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_call_property_cancellation_finish() to get the result of the operation.
 *
 * See foo_igen_bar_call_property_cancellation_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_bar_call_property_cancellation (
    FooiGenBar *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "PropertyCancellation",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_bar_call_property_cancellation_finish:
 * @proxy: A #FooiGenBarProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_call_property_cancellation().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_bar_call_property_cancellation().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_property_cancellation_finish (
    FooiGenBar *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_property_cancellation_sync:
 * @proxy: A #FooiGenBarProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.PropertyCancellation">PropertyCancellation()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_call_property_cancellation() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_property_cancellation_sync (
    FooiGenBar *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "PropertyCancellation",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_complete_hello_world:
 * @object: A #FooiGenBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @response: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.HelloWorld">HelloWorld()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_bar_complete_hello_world (
    FooiGenBar *object,
    GDBusMethodInvocation *invocation,
    const gchar *response)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   response));
}

/**
 * foo_igen_bar_complete_test_primitive_types:
 * @object: A #FooiGenBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @ret_byte: Parameter to return.
 * @ret_boolean: Parameter to return.
 * @ret_int16: Parameter to return.
 * @ret_uint16: Parameter to return.
 * @ret_int32: Parameter to return.
 * @ret_uint32: Parameter to return.
 * @ret_int64: Parameter to return.
 * @ret_uint64: Parameter to return.
 * @ret_double: Parameter to return.
 * @ret_string: Parameter to return.
 * @ret_objpath: Parameter to return.
 * @ret_signature: Parameter to return.
 * @ret_bytestring: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.TestPrimitiveTypes">TestPrimitiveTypes()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_bar_complete_test_primitive_types (
    FooiGenBar *object,
    GDBusMethodInvocation *invocation,
    guchar ret_byte,
    gboolean ret_boolean,
    gint16 ret_int16,
    guint16 ret_uint16,
    gint ret_int32,
    guint ret_uint32,
    gint64 ret_int64,
    guint64 ret_uint64,
    gdouble ret_double,
    const gchar *ret_string,
    const gchar *ret_objpath,
    const gchar *ret_signature,
    const gchar *ret_bytestring)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(ybnqiuxtdsog^ay)",
                   ret_byte,
                   ret_boolean,
                   ret_int16,
                   ret_uint16,
                   ret_int32,
                   ret_uint32,
                   ret_int64,
                   ret_uint64,
                   ret_double,
                   ret_string,
                   ret_objpath,
                   ret_signature,
                   ret_bytestring));
}

/**
 * foo_igen_bar_complete_test_non_primitive_types:
 * @object: A #FooiGenBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @result: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.TestNonPrimitiveTypes">TestNonPrimitiveTypes()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_bar_complete_test_non_primitive_types (
    FooiGenBar *object,
    GDBusMethodInvocation *invocation,
    const gchar *result)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(^ay)",
                   result));
}

/**
 * foo_igen_bar_complete_request_signal_emission:
 * @object: A #FooiGenBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.RequestSignalEmission">RequestSignalEmission()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_bar_complete_request_signal_emission (
    FooiGenBar *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_bar_complete_request_multi_property_mods:
 * @object: A #FooiGenBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.RequestMultiPropertyMods">RequestMultiPropertyMods()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_bar_complete_request_multi_property_mods (
    FooiGenBar *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_bar_complete_unimplemented_method:
 * @object: A #FooiGenBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.UnimplementedMethod">UnimplementedMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_bar_complete_unimplemented_method (
    FooiGenBar *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_bar_complete_property_cancellation:
 * @object: A #FooiGenBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.PropertyCancellation">PropertyCancellation()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_bar_complete_property_cancellation (
    FooiGenBar *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenBarProxy:
 *
 * The #FooiGenBarProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenBarProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenBarProxy.
 */

struct _FooiGenBarProxyPrivate
{
  GData *qdata;
};

static void foo_igen_bar_proxy_iface_init (FooiGenBarIface *iface);

G_DEFINE_TYPE_WITH_CODE (FooiGenBarProxy, foo_igen_bar_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAR, foo_igen_bar_proxy_iface_init));

static void
foo_igen_bar_proxy_finalize (GObject *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_bar_proxy_parent_class)->finalize (object);
}

static void
foo_igen_bar_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 30);
  info = _foo_igen_bar_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_igen_bar_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  error = NULL;
  if (!g_dbus_proxy_call_finish (proxy, res, &error))
    {
      g_warning ("Error setting property `%s' on interface org.project.Bar: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
}

static void
foo_igen_bar_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 30);
  info = _foo_igen_bar_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.project.Bar", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_igen_bar_proxy_set_property_cb, (gpointer) info);
  g_variant_unref (variant);
}

static void
foo_igen_bar_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_bar_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_BAR);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_BAR);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_bar_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bar_interface_info, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bar_interface_info, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static guchar 
foo_igen_bar_proxy_get_y (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  guchar value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "y");
  if (variant != NULL)
    {
      value = g_variant_get_byte (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
foo_igen_bar_proxy_get_b (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "b");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gint16 
foo_igen_bar_proxy_get_n (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  gint16 value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "n");
  if (variant != NULL)
    {
      value = g_variant_get_int16 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static guint16 
foo_igen_bar_proxy_get_q (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  guint16 value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "q");
  if (variant != NULL)
    {
      value = g_variant_get_uint16 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gint 
foo_igen_bar_proxy_get_i (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "i");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static guint 
foo_igen_bar_proxy_get_u (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  guint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "u");
  if (variant != NULL)
    {
      value = g_variant_get_uint32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gint64 
foo_igen_bar_proxy_get_x (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  gint64 value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "x");
  if (variant != NULL)
    {
      value = g_variant_get_int64 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static guint64 
foo_igen_bar_proxy_get_t (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  guint64 value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "t");
  if (variant != NULL)
    {
      value = g_variant_get_uint64 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gdouble 
foo_igen_bar_proxy_get_d (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  gdouble value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "d");
  if (variant != NULL)
    {
      value = g_variant_get_double (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_s (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "s");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_o (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "o");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_g (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "g");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_ay (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ay");
  if (variant != NULL)
    {
      value = g_variant_get_bytestring (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *const *
foo_igen_bar_proxy_get_as (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *const *value = NULL;
  value = g_datalist_get_data (&proxy->priv->qdata, "as");
  if (value != NULL)
    return value;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "as");
  if (variant != NULL)
    {
      value = g_variant_get_strv (variant, NULL);
      g_datalist_set_data_full (&proxy->priv->qdata, "as", (gpointer) value, g_free);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *const *
foo_igen_bar_proxy_get_aay (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *const *value = NULL;
  value = g_datalist_get_data (&proxy->priv->qdata, "aay");
  if (value != NULL)
    return value;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "aay");
  if (variant != NULL)
    {
      value = g_variant_get_bytestring_array (variant, NULL);
      g_datalist_set_data_full (&proxy->priv->qdata, "aay", (gpointer) value, g_free);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *const *
foo_igen_bar_proxy_get_ao (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *const *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ao");
  if (variant != NULL)
    {
      value = g_variant_get_objv (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static GVariant *
foo_igen_bar_proxy_get_ag (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ag");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_finally_normal_name (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "FinallyNormalName");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_readonly_property (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ReadonlyProperty");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_writeonly_property (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "WriteonlyProperty");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gint 
foo_igen_bar_proxy_get_unset_i (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_i");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gdouble 
foo_igen_bar_proxy_get_unset_d (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  gdouble value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_d");
  if (variant != NULL)
    {
      value = g_variant_get_double (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_unset_s (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_s");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_unset_o (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_o");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_unset_g (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_g");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_unset_ay (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_ay");
  if (variant != NULL)
    {
      value = g_variant_get_bytestring (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *const *
foo_igen_bar_proxy_get_unset_as (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *const *value = NULL;
  value = g_datalist_get_data (&proxy->priv->qdata, "unset_as");
  if (value != NULL)
    return value;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_as");
  if (variant != NULL)
    {
      value = g_variant_get_strv (variant, NULL);
      g_datalist_set_data_full (&proxy->priv->qdata, "unset_as", (gpointer) value, g_free);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *const *
foo_igen_bar_proxy_get_unset_ao (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *const *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_ao");
  if (variant != NULL)
    {
      value = g_variant_get_objv (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static GVariant *
foo_igen_bar_proxy_get_unset_ag (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_ag");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static GVariant *
foo_igen_bar_proxy_get_unset_struct (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_struct");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static void
foo_igen_bar_proxy_init (FooiGenBarProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_BAR_PROXY, FooiGenBarProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_bar_interface_info ());
}

static void
foo_igen_bar_proxy_class_init (FooiGenBarProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (FooiGenBarProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_bar_proxy_finalize;
  gobject_class->get_property = foo_igen_bar_proxy_get_property;
  gobject_class->set_property = foo_igen_bar_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_bar_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_bar_proxy_g_properties_changed;


  foo_igen_bar_override_properties (gobject_class, 1);
}

static void
foo_igen_bar_proxy_iface_init (FooiGenBarIface *iface)
{
  iface->get_y = foo_igen_bar_proxy_get_y;
  iface->get_b = foo_igen_bar_proxy_get_b;
  iface->get_n = foo_igen_bar_proxy_get_n;
  iface->get_q = foo_igen_bar_proxy_get_q;
  iface->get_i = foo_igen_bar_proxy_get_i;
  iface->get_u = foo_igen_bar_proxy_get_u;
  iface->get_x = foo_igen_bar_proxy_get_x;
  iface->get_t = foo_igen_bar_proxy_get_t;
  iface->get_d = foo_igen_bar_proxy_get_d;
  iface->get_s = foo_igen_bar_proxy_get_s;
  iface->get_o = foo_igen_bar_proxy_get_o;
  iface->get_g = foo_igen_bar_proxy_get_g;
  iface->get_ay = foo_igen_bar_proxy_get_ay;
  iface->get_as = foo_igen_bar_proxy_get_as;
  iface->get_aay = foo_igen_bar_proxy_get_aay;
  iface->get_ao = foo_igen_bar_proxy_get_ao;
  iface->get_ag = foo_igen_bar_proxy_get_ag;
  iface->get_finally_normal_name = foo_igen_bar_proxy_get_finally_normal_name;
  iface->get_readonly_property = foo_igen_bar_proxy_get_readonly_property;
  iface->get_writeonly_property = foo_igen_bar_proxy_get_writeonly_property;
  iface->get_unset_i = foo_igen_bar_proxy_get_unset_i;
  iface->get_unset_d = foo_igen_bar_proxy_get_unset_d;
  iface->get_unset_s = foo_igen_bar_proxy_get_unset_s;
  iface->get_unset_o = foo_igen_bar_proxy_get_unset_o;
  iface->get_unset_g = foo_igen_bar_proxy_get_unset_g;
  iface->get_unset_ay = foo_igen_bar_proxy_get_unset_ay;
  iface->get_unset_as = foo_igen_bar_proxy_get_unset_as;
  iface->get_unset_ao = foo_igen_bar_proxy_get_unset_ao;
  iface->get_unset_ag = foo_igen_bar_proxy_get_unset_ag;
  iface->get_unset_struct = foo_igen_bar_proxy_get_unset_struct;
}

/**
 * foo_igen_bar_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_bar_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_bar_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_BAR_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Bar", NULL);
}

/**
 * foo_igen_bar_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_bar_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenBarProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBar *
foo_igen_bar_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_BAR (ret);
  else
    return NULL;
}

/**
 * foo_igen_bar_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenBarProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBar *
foo_igen_bar_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_BAR_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Bar", NULL);
  if (ret != NULL)
    return FOO_IGEN_BAR (ret);
  else
    return NULL;
}


/**
 * foo_igen_bar_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_bar_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_bar_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_bar_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_BAR_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Bar", NULL);
}

/**
 * foo_igen_bar_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_bar_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenBarProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBar *
foo_igen_bar_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_BAR (ret);
  else
    return NULL;
}

/**
 * foo_igen_bar_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_bar_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenBarProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBar *
foo_igen_bar_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_BAR_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Bar", NULL);
  if (ret != NULL)
    return FOO_IGEN_BAR (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenBarSkeleton:
 *
 * The #FooiGenBarSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenBarSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenBarSkeleton.
 */

struct _FooiGenBarSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_igen_bar_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_BAR);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_BAR);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_bar_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bar_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_bar_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bar_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_bar_skeleton_vtable =
{
  _foo_igen_bar_skeleton_handle_method_call,
  _foo_igen_bar_skeleton_handle_get_property,
  _foo_igen_bar_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_igen_bar_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_igen_bar_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_bar_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_igen_bar_skeleton_vtable;
}

static GVariant *
foo_igen_bar_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_bar_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_bar_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_bar_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_bar_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Bar", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_igen_bar_emit_changed (gpointer user_data);

static void
foo_igen_bar_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (skeleton->priv->lock);

  if (emit_changed)
    _foo_igen_bar_emit_changed (skeleton);
}

static void
_foo_igen_bar_on_signal_test_signal (
    FooiGenBar *object,
    gint arg_val_int32,
    const gchar *const *arg_array_of_strings,
    const gchar *const *arg_array_of_bytestrings,
    GVariant *arg_dict_s_to_pairs)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Bar", "TestSignal",
    g_variant_new ("(i^as^aay@a{s(ii)})",
                   arg_val_int32,
                   arg_array_of_strings,
                   arg_array_of_bytestrings,
                   arg_dict_s_to_pairs), NULL);
}

static void
_foo_igen_bar_on_signal_another_signal (
    FooiGenBar *object,
    const gchar *arg_word)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Bar", "AnotherSignal",
    g_variant_new ("(s)",
                   arg_word), NULL);
}

static void foo_igen_bar_skeleton_iface_init (FooiGenBarIface *iface);
G_DEFINE_TYPE_WITH_CODE (FooiGenBarSkeleton, foo_igen_bar_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAR, foo_igen_bar_skeleton_iface_init));

static void
foo_igen_bar_skeleton_finalize (GObject *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  g_value_array_free (skeleton->priv->properties);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_bar_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_bar_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 30);
  g_mutex_lock (skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties->values[prop_id - 1], value);
  g_mutex_unlock (skeleton->priv->lock);
}

static gboolean
_foo_igen_bar_emit_changed (gpointer user_data)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties->values[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      g_dbus_connection_emit_signal (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     "org.freedesktop.DBus.Properties",
                                     "PropertiesChanged",
                                     g_variant_new ("(sa{sv}as)",
                                                    "org.project.Bar",
                                                    &builder, &invalidated_builder),
                                     NULL);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (skeleton->priv->lock);
  return FALSE;
}

static void
_foo_igen_bar_schedule_emit_changed (FooiGenBarSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_igen_bar_skeleton_notify (GObject      *object,
  GParamSpec *pspec)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_igen_bar_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (skeleton->priv->lock);
}

static void
foo_igen_bar_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 30);
  g_mutex_lock (skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties->values[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_igen_bar_schedule_emit_changed (skeleton, _foo_igen_bar_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties->values[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties->values[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_igen_bar_skeleton_init (FooiGenBarSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_BAR_SKELETON, FooiGenBarSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
  skeleton->priv->properties = g_value_array_new (30);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[0], G_TYPE_UCHAR);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[1], G_TYPE_BOOLEAN);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[2], G_TYPE_INT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[3], G_TYPE_UINT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[4], G_TYPE_INT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[5], G_TYPE_UINT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[6], G_TYPE_INT64);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[7], G_TYPE_UINT64);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[8], G_TYPE_DOUBLE);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[9], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[10], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[11], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[12], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[13], G_TYPE_STRV);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[14], G_TYPE_STRV);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[15], G_TYPE_STRV);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[16], G_TYPE_VARIANT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[17], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[18], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[19], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[20], G_TYPE_INT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[21], G_TYPE_DOUBLE);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[22], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[23], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[24], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[25], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[26], G_TYPE_STRV);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[27], G_TYPE_STRV);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[28], G_TYPE_VARIANT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[29], G_TYPE_VARIANT);
}

static guchar 
foo_igen_bar_skeleton_get_y (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  guchar value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_uchar (&(skeleton->priv->properties->values[0]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static gboolean 
foo_igen_bar_skeleton_get_b (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  gboolean value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties->values[1]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static gint16 
foo_igen_bar_skeleton_get_n (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  gint value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties->values[2]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static guint16 
foo_igen_bar_skeleton_get_q (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  guint value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_uint (&(skeleton->priv->properties->values[3]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static gint 
foo_igen_bar_skeleton_get_i (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  gint value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties->values[4]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static guint 
foo_igen_bar_skeleton_get_u (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  guint value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_uint (&(skeleton->priv->properties->values[5]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static gint64 
foo_igen_bar_skeleton_get_x (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  gint64 value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_int64 (&(skeleton->priv->properties->values[6]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static guint64 
foo_igen_bar_skeleton_get_t (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  guint64 value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_uint64 (&(skeleton->priv->properties->values[7]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static gdouble 
foo_igen_bar_skeleton_get_d (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  gdouble value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_double (&(skeleton->priv->properties->values[8]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_s (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties->values[9]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_o (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties->values[10]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_g (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties->values[11]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_ay (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties->values[12]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static const gchar *const *
foo_igen_bar_skeleton_get_as (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *const *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_boxed (&(skeleton->priv->properties->values[13]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static const gchar *const *
foo_igen_bar_skeleton_get_aay (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *const *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_boxed (&(skeleton->priv->properties->values[14]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static const gchar *const *
foo_igen_bar_skeleton_get_ao (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *const *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_boxed (&(skeleton->priv->properties->values[15]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static GVariant *
foo_igen_bar_skeleton_get_ag (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  GVariant *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties->values[16]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_finally_normal_name (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties->values[17]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_readonly_property (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties->values[18]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_writeonly_property (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties->values[19]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static gint 
foo_igen_bar_skeleton_get_unset_i (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  gint value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties->values[20]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static gdouble 
foo_igen_bar_skeleton_get_unset_d (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  gdouble value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_double (&(skeleton->priv->properties->values[21]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_unset_s (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties->values[22]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_unset_o (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties->values[23]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_unset_g (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties->values[24]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_unset_ay (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties->values[25]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static const gchar *const *
foo_igen_bar_skeleton_get_unset_as (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *const *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_boxed (&(skeleton->priv->properties->values[26]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static const gchar *const *
foo_igen_bar_skeleton_get_unset_ao (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *const *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_boxed (&(skeleton->priv->properties->values[27]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static GVariant *
foo_igen_bar_skeleton_get_unset_ag (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  GVariant *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties->values[28]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static GVariant *
foo_igen_bar_skeleton_get_unset_struct (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  GVariant *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties->values[29]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static void
foo_igen_bar_skeleton_class_init (FooiGenBarSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooiGenBarSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_bar_skeleton_finalize;
  gobject_class->get_property = foo_igen_bar_skeleton_get_property;
  gobject_class->set_property = foo_igen_bar_skeleton_set_property;
  gobject_class->notify       = foo_igen_bar_skeleton_notify;


  foo_igen_bar_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_bar_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_bar_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_bar_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_bar_skeleton_dbus_interface_get_vtable;
}

static void
foo_igen_bar_skeleton_iface_init (FooiGenBarIface *iface)
{
  iface->test_signal = _foo_igen_bar_on_signal_test_signal;
  iface->another_signal = _foo_igen_bar_on_signal_another_signal;
  iface->get_y = foo_igen_bar_skeleton_get_y;
  iface->get_b = foo_igen_bar_skeleton_get_b;
  iface->get_n = foo_igen_bar_skeleton_get_n;
  iface->get_q = foo_igen_bar_skeleton_get_q;
  iface->get_i = foo_igen_bar_skeleton_get_i;
  iface->get_u = foo_igen_bar_skeleton_get_u;
  iface->get_x = foo_igen_bar_skeleton_get_x;
  iface->get_t = foo_igen_bar_skeleton_get_t;
  iface->get_d = foo_igen_bar_skeleton_get_d;
  iface->get_s = foo_igen_bar_skeleton_get_s;
  iface->get_o = foo_igen_bar_skeleton_get_o;
  iface->get_g = foo_igen_bar_skeleton_get_g;
  iface->get_ay = foo_igen_bar_skeleton_get_ay;
  iface->get_as = foo_igen_bar_skeleton_get_as;
  iface->get_aay = foo_igen_bar_skeleton_get_aay;
  iface->get_ao = foo_igen_bar_skeleton_get_ao;
  iface->get_ag = foo_igen_bar_skeleton_get_ag;
  iface->get_finally_normal_name = foo_igen_bar_skeleton_get_finally_normal_name;
  iface->get_readonly_property = foo_igen_bar_skeleton_get_readonly_property;
  iface->get_writeonly_property = foo_igen_bar_skeleton_get_writeonly_property;
  iface->get_unset_i = foo_igen_bar_skeleton_get_unset_i;
  iface->get_unset_d = foo_igen_bar_skeleton_get_unset_d;
  iface->get_unset_s = foo_igen_bar_skeleton_get_unset_s;
  iface->get_unset_o = foo_igen_bar_skeleton_get_unset_o;
  iface->get_unset_g = foo_igen_bar_skeleton_get_unset_g;
  iface->get_unset_ay = foo_igen_bar_skeleton_get_unset_ay;
  iface->get_unset_as = foo_igen_bar_skeleton_get_unset_as;
  iface->get_unset_ao = foo_igen_bar_skeleton_get_unset_ao;
  iface->get_unset_ag = foo_igen_bar_skeleton_get_unset_ag;
  iface->get_unset_struct = foo_igen_bar_skeleton_get_unset_struct;
}

/**
 * foo_igen_bar_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link>.
 *
 * Returns: (transfer full) (type FooiGenBarSkeleton): The skeleton object.
 */
FooiGenBar *
foo_igen_bar_skeleton_new (void)
{
  return FOO_IGEN_BAR (g_object_new (FOO_IGEN_TYPE_BAR_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.Bar.Frobnicator
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenBarFrobnicator
 * @title: FooiGenBarFrobnicator
 * @short_description: Generated C code for the org.project.Bar.Frobnicator D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.Bar.Frobnicator ---- */

static const _ExtendedGDBusMethodInfo _foo_igen_bar_frobnicator_method_info_random_method =
{
  {
    -1,
    "RandomMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-random-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_bar_frobnicator_method_info_pointers[] =
{
  &_foo_igen_bar_frobnicator_method_info_random_method,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_bar_frobnicator_interface_info =
{
  {
    -1,
    "org.project.Bar.Frobnicator",
    (GDBusMethodInfo **) &_foo_igen_bar_frobnicator_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "bar-frobnicator",
};


/**
 * foo_igen_bar_frobnicator_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_bar_frobnicator_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_bar_frobnicator_interface_info;
}

/**
 * foo_igen_bar_frobnicator_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenBarFrobnicator interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_bar_frobnicator_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * FooiGenBarFrobnicator:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link>.
 */

/**
 * FooiGenBarFrobnicatorIface:
 * @parent_iface: The parent interface.
 * @handle_random_method: Handler for the #FooiGenBarFrobnicator::handle-random-method signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link>.
 */

static void
foo_igen_bar_frobnicator_default_init (FooiGenBarFrobnicatorIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenBarFrobnicator::handle-random-method:
   * @object: A #FooiGenBarFrobnicator.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar-Frobnicator.RandomMethod">RandomMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_bar_frobnicator_complete_random_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-random-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarFrobnicatorIface, handle_random_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

}

typedef FooiGenBarFrobnicatorIface FooiGenBarFrobnicatorInterface;
G_DEFINE_INTERFACE (FooiGenBarFrobnicator, foo_igen_bar_frobnicator, G_TYPE_OBJECT);

/**
 * foo_igen_bar_frobnicator_call_random_method:
 * @proxy: A #FooiGenBarFrobnicatorProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar-Frobnicator.RandomMethod">RandomMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_frobnicator_call_random_method_finish() to get the result of the operation.
 *
 * See foo_igen_bar_frobnicator_call_random_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_bar_frobnicator_call_random_method (
    FooiGenBarFrobnicator *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "RandomMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_bar_frobnicator_call_random_method_finish:
 * @proxy: A #FooiGenBarFrobnicatorProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_frobnicator_call_random_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_bar_frobnicator_call_random_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_frobnicator_call_random_method_finish (
    FooiGenBarFrobnicator *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_frobnicator_call_random_method_sync:
 * @proxy: A #FooiGenBarFrobnicatorProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar-Frobnicator.RandomMethod">RandomMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_frobnicator_call_random_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_frobnicator_call_random_method_sync (
    FooiGenBarFrobnicator *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "RandomMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_frobnicator_complete_random_method:
 * @object: A #FooiGenBarFrobnicator.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar-Frobnicator.RandomMethod">RandomMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_bar_frobnicator_complete_random_method (
    FooiGenBarFrobnicator *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenBarFrobnicatorProxy:
 *
 * The #FooiGenBarFrobnicatorProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenBarFrobnicatorProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenBarFrobnicatorProxy.
 */

struct _FooiGenBarFrobnicatorProxyPrivate
{
  GData *qdata;
};

static void foo_igen_bar_frobnicator_proxy_iface_init (FooiGenBarFrobnicatorIface *iface);

G_DEFINE_TYPE_WITH_CODE (FooiGenBarFrobnicatorProxy, foo_igen_bar_frobnicator_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAR_FROBNICATOR, foo_igen_bar_frobnicator_proxy_iface_init));

static void
foo_igen_bar_frobnicator_proxy_finalize (GObject *object)
{
  FooiGenBarFrobnicatorProxy *proxy = FOO_IGEN_BAR_FROBNICATOR_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_bar_frobnicator_proxy_parent_class)->finalize (object);
}

static void
foo_igen_bar_frobnicator_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
foo_igen_bar_frobnicator_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
foo_igen_bar_frobnicator_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_bar_frobnicator_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_BAR_FROBNICATOR);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_BAR_FROBNICATOR);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_bar_frobnicator_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenBarFrobnicatorProxy *proxy = FOO_IGEN_BAR_FROBNICATOR_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bar_frobnicator_interface_info, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bar_frobnicator_interface_info, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_igen_bar_frobnicator_proxy_init (FooiGenBarFrobnicatorProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_BAR_FROBNICATOR_PROXY, FooiGenBarFrobnicatorProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_bar_frobnicator_interface_info ());
}

static void
foo_igen_bar_frobnicator_proxy_class_init (FooiGenBarFrobnicatorProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (FooiGenBarFrobnicatorProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_bar_frobnicator_proxy_finalize;
  gobject_class->get_property = foo_igen_bar_frobnicator_proxy_get_property;
  gobject_class->set_property = foo_igen_bar_frobnicator_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_bar_frobnicator_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_bar_frobnicator_proxy_g_properties_changed;

}

static void
foo_igen_bar_frobnicator_proxy_iface_init (FooiGenBarFrobnicatorIface *iface)
{
}

/**
 * foo_igen_bar_frobnicator_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_frobnicator_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_bar_frobnicator_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_bar_frobnicator_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_BAR_FROBNICATOR_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Bar.Frobnicator", NULL);
}

/**
 * foo_igen_bar_frobnicator_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_frobnicator_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_bar_frobnicator_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenBarFrobnicatorProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBarFrobnicator *
foo_igen_bar_frobnicator_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_BAR_FROBNICATOR (ret);
  else
    return NULL;
}

/**
 * foo_igen_bar_frobnicator_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_frobnicator_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenBarFrobnicatorProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBarFrobnicator *
foo_igen_bar_frobnicator_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_BAR_FROBNICATOR_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Bar.Frobnicator", NULL);
  if (ret != NULL)
    return FOO_IGEN_BAR_FROBNICATOR (ret);
  else
    return NULL;
}


/**
 * foo_igen_bar_frobnicator_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_bar_frobnicator_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_frobnicator_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_bar_frobnicator_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_bar_frobnicator_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_BAR_FROBNICATOR_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Bar.Frobnicator", NULL);
}

/**
 * foo_igen_bar_frobnicator_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_frobnicator_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_bar_frobnicator_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenBarFrobnicatorProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBarFrobnicator *
foo_igen_bar_frobnicator_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_BAR_FROBNICATOR (ret);
  else
    return NULL;
}

/**
 * foo_igen_bar_frobnicator_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_bar_frobnicator_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_frobnicator_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenBarFrobnicatorProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBarFrobnicator *
foo_igen_bar_frobnicator_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_BAR_FROBNICATOR_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Bar.Frobnicator", NULL);
  if (ret != NULL)
    return FOO_IGEN_BAR_FROBNICATOR (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenBarFrobnicatorSkeleton:
 *
 * The #FooiGenBarFrobnicatorSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenBarFrobnicatorSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenBarFrobnicatorSkeleton.
 */

struct _FooiGenBarFrobnicatorSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_igen_bar_frobnicator_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenBarFrobnicatorSkeleton *skeleton = FOO_IGEN_BAR_FROBNICATOR_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_BAR_FROBNICATOR);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_BAR_FROBNICATOR);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_bar_frobnicator_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenBarFrobnicatorSkeleton *skeleton = FOO_IGEN_BAR_FROBNICATOR_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bar_frobnicator_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_bar_frobnicator_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenBarFrobnicatorSkeleton *skeleton = FOO_IGEN_BAR_FROBNICATOR_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bar_frobnicator_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_bar_frobnicator_skeleton_vtable =
{
  _foo_igen_bar_frobnicator_skeleton_handle_method_call,
  _foo_igen_bar_frobnicator_skeleton_handle_get_property,
  _foo_igen_bar_frobnicator_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_igen_bar_frobnicator_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_igen_bar_frobnicator_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_bar_frobnicator_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_igen_bar_frobnicator_skeleton_vtable;
}

static GVariant *
foo_igen_bar_frobnicator_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenBarFrobnicatorSkeleton *skeleton = FOO_IGEN_BAR_FROBNICATOR_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_bar_frobnicator_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_bar_frobnicator_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_bar_frobnicator_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_bar_frobnicator_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Bar.Frobnicator", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_igen_bar_frobnicator_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void foo_igen_bar_frobnicator_skeleton_iface_init (FooiGenBarFrobnicatorIface *iface);
G_DEFINE_TYPE_WITH_CODE (FooiGenBarFrobnicatorSkeleton, foo_igen_bar_frobnicator_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAR_FROBNICATOR, foo_igen_bar_frobnicator_skeleton_iface_init));

static void
foo_igen_bar_frobnicator_skeleton_finalize (GObject *object)
{
  FooiGenBarFrobnicatorSkeleton *skeleton = FOO_IGEN_BAR_FROBNICATOR_SKELETON (object);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_bar_frobnicator_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_bar_frobnicator_skeleton_init (FooiGenBarFrobnicatorSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_BAR_FROBNICATOR_SKELETON, FooiGenBarFrobnicatorSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
}

static void
foo_igen_bar_frobnicator_skeleton_class_init (FooiGenBarFrobnicatorSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooiGenBarFrobnicatorSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_bar_frobnicator_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_bar_frobnicator_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_bar_frobnicator_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_bar_frobnicator_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_bar_frobnicator_skeleton_dbus_interface_get_vtable;
}

static void
foo_igen_bar_frobnicator_skeleton_iface_init (FooiGenBarFrobnicatorIface *iface)
{
}

/**
 * foo_igen_bar_frobnicator_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link>.
 *
 * Returns: (transfer full) (type FooiGenBarFrobnicatorSkeleton): The skeleton object.
 */
FooiGenBarFrobnicator *
foo_igen_bar_frobnicator_skeleton_new (void)
{
  return FOO_IGEN_BAR_FROBNICATOR (g_object_new (FOO_IGEN_TYPE_BAR_FROBNICATOR_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.Baz
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenBaz
 * @title: FooiGenBaz
 * @short_description: Generated C code for the org.project.Baz D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.Baz ---- */

static const _ExtendedGDBusInterfaceInfo _foo_igen_baz_interface_info =
{
  {
    -1,
    "org.project.Baz",
    NULL,
    NULL,
    NULL,
    NULL
  },
  "baz",
};


/**
 * foo_igen_baz_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_baz_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_baz_interface_info;
}

/**
 * foo_igen_baz_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenBaz interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_baz_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * FooiGenBaz:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link>.
 */

/**
 * FooiGenBazIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link>.
 */

static void
foo_igen_baz_default_init (FooiGenBazIface *iface)
{
}

typedef FooiGenBazIface FooiGenBazInterface;
G_DEFINE_INTERFACE (FooiGenBaz, foo_igen_baz, G_TYPE_OBJECT);

/* ------------------------------------------------------------------------ */

/**
 * FooiGenBazProxy:
 *
 * The #FooiGenBazProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenBazProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenBazProxy.
 */

struct _FooiGenBazProxyPrivate
{
  GData *qdata;
};

static void foo_igen_baz_proxy_iface_init (FooiGenBazIface *iface);

G_DEFINE_TYPE_WITH_CODE (FooiGenBazProxy, foo_igen_baz_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAZ, foo_igen_baz_proxy_iface_init));

static void
foo_igen_baz_proxy_finalize (GObject *object)
{
  FooiGenBazProxy *proxy = FOO_IGEN_BAZ_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_baz_proxy_parent_class)->finalize (object);
}

static void
foo_igen_baz_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
foo_igen_baz_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
foo_igen_baz_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_baz_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_BAZ);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_BAZ);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_baz_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenBazProxy *proxy = FOO_IGEN_BAZ_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_baz_interface_info, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_baz_interface_info, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_igen_baz_proxy_init (FooiGenBazProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_BAZ_PROXY, FooiGenBazProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_baz_interface_info ());
}

static void
foo_igen_baz_proxy_class_init (FooiGenBazProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (FooiGenBazProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_baz_proxy_finalize;
  gobject_class->get_property = foo_igen_baz_proxy_get_property;
  gobject_class->set_property = foo_igen_baz_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_baz_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_baz_proxy_g_properties_changed;

}

static void
foo_igen_baz_proxy_iface_init (FooiGenBazIface *iface)
{
}

/**
 * foo_igen_baz_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_baz_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_baz_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_baz_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_BAZ_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Baz", NULL);
}

/**
 * foo_igen_baz_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_baz_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_baz_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenBazProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBaz *
foo_igen_baz_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_BAZ (ret);
  else
    return NULL;
}

/**
 * foo_igen_baz_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_baz_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenBazProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBaz *
foo_igen_baz_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_BAZ_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Baz", NULL);
  if (ret != NULL)
    return FOO_IGEN_BAZ (ret);
  else
    return NULL;
}


/**
 * foo_igen_baz_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_baz_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_baz_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_baz_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_baz_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_BAZ_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Baz", NULL);
}

/**
 * foo_igen_baz_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_baz_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_baz_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenBazProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBaz *
foo_igen_baz_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_BAZ (ret);
  else
    return NULL;
}

/**
 * foo_igen_baz_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_baz_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_baz_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenBazProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBaz *
foo_igen_baz_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_BAZ_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Baz", NULL);
  if (ret != NULL)
    return FOO_IGEN_BAZ (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenBazSkeleton:
 *
 * The #FooiGenBazSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenBazSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenBazSkeleton.
 */

struct _FooiGenBazSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_igen_baz_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenBazSkeleton *skeleton = FOO_IGEN_BAZ_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_BAZ);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_BAZ);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_baz_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenBazSkeleton *skeleton = FOO_IGEN_BAZ_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_baz_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_baz_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenBazSkeleton *skeleton = FOO_IGEN_BAZ_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_baz_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_baz_skeleton_vtable =
{
  _foo_igen_baz_skeleton_handle_method_call,
  _foo_igen_baz_skeleton_handle_get_property,
  _foo_igen_baz_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_igen_baz_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_igen_baz_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_baz_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_igen_baz_skeleton_vtable;
}

static GVariant *
foo_igen_baz_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenBazSkeleton *skeleton = FOO_IGEN_BAZ_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_baz_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_baz_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_baz_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_baz_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Baz", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_igen_baz_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void foo_igen_baz_skeleton_iface_init (FooiGenBazIface *iface);
G_DEFINE_TYPE_WITH_CODE (FooiGenBazSkeleton, foo_igen_baz_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAZ, foo_igen_baz_skeleton_iface_init));

static void
foo_igen_baz_skeleton_finalize (GObject *object)
{
  FooiGenBazSkeleton *skeleton = FOO_IGEN_BAZ_SKELETON (object);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_baz_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_baz_skeleton_init (FooiGenBazSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_BAZ_SKELETON, FooiGenBazSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
}

static void
foo_igen_baz_skeleton_class_init (FooiGenBazSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooiGenBazSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_baz_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_baz_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_baz_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_baz_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_baz_skeleton_dbus_interface_get_vtable;
}

static void
foo_igen_baz_skeleton_iface_init (FooiGenBazIface *iface)
{
}

/**
 * foo_igen_baz_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link>.
 *
 * Returns: (transfer full) (type FooiGenBazSkeleton): The skeleton object.
 */
FooiGenBaz *
foo_igen_baz_skeleton_new (void)
{
  return FOO_IGEN_BAZ (g_object_new (FOO_IGEN_TYPE_BAZ_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface com.acme.Coyote
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenComAcmeCoyote
 * @title: FooiGenComAcmeCoyote
 * @short_description: Generated C code for the com.acme.Coyote D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link> D-Bus interface in C.
 */

/* ---- Introspection data for com.acme.Coyote ---- */

static const _ExtendedGDBusMethodInfo _foo_igen_com_acme_coyote_method_info_run =
{
  {
    -1,
    "Run",
    NULL,
    NULL,
    NULL
  },
  "handle-run",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_com_acme_coyote_method_info_sleep =
{
  {
    -1,
    "Sleep",
    NULL,
    NULL,
    NULL
  },
  "handle-sleep",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_com_acme_coyote_method_info_attack =
{
  {
    -1,
    "Attack",
    NULL,
    NULL,
    NULL
  },
  "handle-attack",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_com_acme_coyote_method_info_pointers[] =
{
  &_foo_igen_com_acme_coyote_method_info_run,
  &_foo_igen_com_acme_coyote_method_info_sleep,
  &_foo_igen_com_acme_coyote_method_info_attack,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_igen_com_acme_coyote_signal_info_surprised =
{
  {
    -1,
    "Surprised",
    NULL,
    NULL
  },
  "surprised"
};

static const _ExtendedGDBusSignalInfo * const _foo_igen_com_acme_coyote_signal_info_pointers[] =
{
  &_foo_igen_com_acme_coyote_signal_info_surprised,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_igen_com_acme_coyote_property_info_mood =
{
  {
    -1,
    "Mood",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "mood",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_igen_com_acme_coyote_property_info_pointers[] =
{
  &_foo_igen_com_acme_coyote_property_info_mood,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_com_acme_coyote_interface_info =
{
  {
    -1,
    "com.acme.Coyote",
    (GDBusMethodInfo **) &_foo_igen_com_acme_coyote_method_info_pointers,
    (GDBusSignalInfo **) &_foo_igen_com_acme_coyote_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_igen_com_acme_coyote_property_info_pointers,
    NULL
  },
  "com-acme-coyote",
};


/**
 * foo_igen_com_acme_coyote_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_com_acme_coyote_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_com_acme_coyote_interface_info;
}

/**
 * foo_igen_com_acme_coyote_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenComAcmeCoyote interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_com_acme_coyote_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "mood");
  return property_id_begin - 1;
}



/**
 * FooiGenComAcmeCoyote:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link>.
 */

/**
 * FooiGenComAcmeCoyoteIface:
 * @parent_iface: The parent interface.
 * @handle_attack: Handler for the #FooiGenComAcmeCoyote::handle-attack signal.
 * @handle_run: Handler for the #FooiGenComAcmeCoyote::handle-run signal.
 * @handle_sleep: Handler for the #FooiGenComAcmeCoyote::handle-sleep signal.
 * @get_mood: Getter for the #FooiGenComAcmeCoyote:mood property.
 * @surprised: Handler for the #FooiGenComAcmeCoyote::surprised signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link>.
 */

static void
foo_igen_com_acme_coyote_default_init (FooiGenComAcmeCoyoteIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenComAcmeCoyote::handle-run:
   * @object: A #FooiGenComAcmeCoyote.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-acme-Coyote.Run">Run()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_com_acme_coyote_complete_run() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-run",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenComAcmeCoyoteIface, handle_run),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenComAcmeCoyote::handle-sleep:
   * @object: A #FooiGenComAcmeCoyote.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-acme-Coyote.Sleep">Sleep()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_com_acme_coyote_complete_sleep() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-sleep",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenComAcmeCoyoteIface, handle_sleep),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenComAcmeCoyote::handle-attack:
   * @object: A #FooiGenComAcmeCoyote.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-acme-Coyote.Attack">Attack()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_com_acme_coyote_complete_attack() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-attack",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenComAcmeCoyoteIface, handle_attack),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooiGenComAcmeCoyote::surprised:
   * @object: A #FooiGenComAcmeCoyote.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-com-acme-Coyote.Surprised">"Surprised"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("surprised",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenComAcmeCoyoteIface, surprised),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * FooiGenComAcmeCoyote:mood:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-com-acme-Coyote.Mood">"Mood"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("mood", "Mood", "Mood", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

typedef FooiGenComAcmeCoyoteIface FooiGenComAcmeCoyoteInterface;
G_DEFINE_INTERFACE (FooiGenComAcmeCoyote, foo_igen_com_acme_coyote, G_TYPE_OBJECT);

/**
 * foo_igen_com_acme_coyote_get_mood: (skip)
 * @object: A #FooiGenComAcmeCoyote.
 *
 * Gets the value of the <link linkend="gdbus-property-com-acme-Coyote.Mood">"Mood"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_com_acme_coyote_dup_mood() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_com_acme_coyote_get_mood (FooiGenComAcmeCoyote *object)
{
  return FOO_IGEN_COM_ACME_COYOTE_GET_IFACE (object)->get_mood (object);
}

/**
 * foo_igen_com_acme_coyote_dup_mood: (skip)
 * @object: A #FooiGenComAcmeCoyote.
 *
 * Gets a copy of the <link linkend="gdbus-property-com-acme-Coyote.Mood">"Mood"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_com_acme_coyote_dup_mood (FooiGenComAcmeCoyote *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "mood", &value, NULL);
  return value;
}

/**
 * foo_igen_com_acme_coyote_set_mood: (skip)
 * @object: A #FooiGenComAcmeCoyote.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-com-acme-Coyote.Mood">"Mood"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_com_acme_coyote_set_mood (FooiGenComAcmeCoyote *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "mood", value, NULL);
}

/**
 * foo_igen_com_acme_coyote_emit_surprised:
 * @object: A #FooiGenComAcmeCoyote.
 *
 * Emits the <link linkend="gdbus-signal-com-acme-Coyote.Surprised">"Surprised"</link> D-Bus signal.
 */
void
foo_igen_com_acme_coyote_emit_surprised (
    FooiGenComAcmeCoyote *object)
{
  g_signal_emit_by_name (object, "surprised");
}

/**
 * foo_igen_com_acme_coyote_call_run:
 * @proxy: A #FooiGenComAcmeCoyoteProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-com-acme-Coyote.Run">Run()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_com_acme_coyote_call_run_finish() to get the result of the operation.
 *
 * See foo_igen_com_acme_coyote_call_run_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_com_acme_coyote_call_run (
    FooiGenComAcmeCoyote *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Run",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_com_acme_coyote_call_run_finish:
 * @proxy: A #FooiGenComAcmeCoyoteProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_com_acme_coyote_call_run().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_com_acme_coyote_call_run().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_com_acme_coyote_call_run_finish (
    FooiGenComAcmeCoyote *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_com_acme_coyote_call_run_sync:
 * @proxy: A #FooiGenComAcmeCoyoteProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-com-acme-Coyote.Run">Run()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_com_acme_coyote_call_run() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_com_acme_coyote_call_run_sync (
    FooiGenComAcmeCoyote *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Run",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_com_acme_coyote_call_sleep:
 * @proxy: A #FooiGenComAcmeCoyoteProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-com-acme-Coyote.Sleep">Sleep()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_com_acme_coyote_call_sleep_finish() to get the result of the operation.
 *
 * See foo_igen_com_acme_coyote_call_sleep_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_com_acme_coyote_call_sleep (
    FooiGenComAcmeCoyote *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Sleep",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_com_acme_coyote_call_sleep_finish:
 * @proxy: A #FooiGenComAcmeCoyoteProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_com_acme_coyote_call_sleep().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_com_acme_coyote_call_sleep().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_com_acme_coyote_call_sleep_finish (
    FooiGenComAcmeCoyote *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_com_acme_coyote_call_sleep_sync:
 * @proxy: A #FooiGenComAcmeCoyoteProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-com-acme-Coyote.Sleep">Sleep()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_com_acme_coyote_call_sleep() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_com_acme_coyote_call_sleep_sync (
    FooiGenComAcmeCoyote *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Sleep",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_com_acme_coyote_call_attack:
 * @proxy: A #FooiGenComAcmeCoyoteProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-com-acme-Coyote.Attack">Attack()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_com_acme_coyote_call_attack_finish() to get the result of the operation.
 *
 * See foo_igen_com_acme_coyote_call_attack_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_com_acme_coyote_call_attack (
    FooiGenComAcmeCoyote *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Attack",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_com_acme_coyote_call_attack_finish:
 * @proxy: A #FooiGenComAcmeCoyoteProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_com_acme_coyote_call_attack().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_com_acme_coyote_call_attack().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_com_acme_coyote_call_attack_finish (
    FooiGenComAcmeCoyote *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_com_acme_coyote_call_attack_sync:
 * @proxy: A #FooiGenComAcmeCoyoteProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-com-acme-Coyote.Attack">Attack()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_com_acme_coyote_call_attack() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_com_acme_coyote_call_attack_sync (
    FooiGenComAcmeCoyote *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Attack",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_com_acme_coyote_complete_run:
 * @object: A #FooiGenComAcmeCoyote.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-acme-Coyote.Run">Run()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_com_acme_coyote_complete_run (
    FooiGenComAcmeCoyote *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_com_acme_coyote_complete_sleep:
 * @object: A #FooiGenComAcmeCoyote.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-acme-Coyote.Sleep">Sleep()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_com_acme_coyote_complete_sleep (
    FooiGenComAcmeCoyote *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_com_acme_coyote_complete_attack:
 * @object: A #FooiGenComAcmeCoyote.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-acme-Coyote.Attack">Attack()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_com_acme_coyote_complete_attack (
    FooiGenComAcmeCoyote *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenComAcmeCoyoteProxy:
 *
 * The #FooiGenComAcmeCoyoteProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenComAcmeCoyoteProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenComAcmeCoyoteProxy.
 */

struct _FooiGenComAcmeCoyoteProxyPrivate
{
  GData *qdata;
};

static void foo_igen_com_acme_coyote_proxy_iface_init (FooiGenComAcmeCoyoteIface *iface);

G_DEFINE_TYPE_WITH_CODE (FooiGenComAcmeCoyoteProxy, foo_igen_com_acme_coyote_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_COM_ACME_COYOTE, foo_igen_com_acme_coyote_proxy_iface_init));

static void
foo_igen_com_acme_coyote_proxy_finalize (GObject *object)
{
  FooiGenComAcmeCoyoteProxy *proxy = FOO_IGEN_COM_ACME_COYOTE_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_com_acme_coyote_proxy_parent_class)->finalize (object);
}

static void
foo_igen_com_acme_coyote_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_igen_com_acme_coyote_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_igen_com_acme_coyote_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  error = NULL;
  if (!g_dbus_proxy_call_finish (proxy, res, &error))
    {
      g_warning ("Error setting property `%s' on interface com.acme.Coyote: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
}

static void
foo_igen_com_acme_coyote_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_igen_com_acme_coyote_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "com.acme.Coyote", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_igen_com_acme_coyote_proxy_set_property_cb, (gpointer) info);
  g_variant_unref (variant);
}

static void
foo_igen_com_acme_coyote_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_com_acme_coyote_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_COM_ACME_COYOTE);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_COM_ACME_COYOTE);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_com_acme_coyote_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenComAcmeCoyoteProxy *proxy = FOO_IGEN_COM_ACME_COYOTE_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_com_acme_coyote_interface_info, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_com_acme_coyote_interface_info, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static const gchar *
foo_igen_com_acme_coyote_proxy_get_mood (FooiGenComAcmeCoyote *object)
{
  FooiGenComAcmeCoyoteProxy *proxy = FOO_IGEN_COM_ACME_COYOTE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Mood");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
foo_igen_com_acme_coyote_proxy_init (FooiGenComAcmeCoyoteProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_COM_ACME_COYOTE_PROXY, FooiGenComAcmeCoyoteProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_com_acme_coyote_interface_info ());
}

static void
foo_igen_com_acme_coyote_proxy_class_init (FooiGenComAcmeCoyoteProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (FooiGenComAcmeCoyoteProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_com_acme_coyote_proxy_finalize;
  gobject_class->get_property = foo_igen_com_acme_coyote_proxy_get_property;
  gobject_class->set_property = foo_igen_com_acme_coyote_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_com_acme_coyote_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_com_acme_coyote_proxy_g_properties_changed;


  foo_igen_com_acme_coyote_override_properties (gobject_class, 1);
}

static void
foo_igen_com_acme_coyote_proxy_iface_init (FooiGenComAcmeCoyoteIface *iface)
{
  iface->get_mood = foo_igen_com_acme_coyote_proxy_get_mood;
}

/**
 * foo_igen_com_acme_coyote_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_com_acme_coyote_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_com_acme_coyote_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_com_acme_coyote_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_COM_ACME_COYOTE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "com.acme.Coyote", NULL);
}

/**
 * foo_igen_com_acme_coyote_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_com_acme_coyote_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_com_acme_coyote_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenComAcmeCoyoteProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenComAcmeCoyote *
foo_igen_com_acme_coyote_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_COM_ACME_COYOTE (ret);
  else
    return NULL;
}

/**
 * foo_igen_com_acme_coyote_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_com_acme_coyote_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenComAcmeCoyoteProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenComAcmeCoyote *
foo_igen_com_acme_coyote_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_COM_ACME_COYOTE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "com.acme.Coyote", NULL);
  if (ret != NULL)
    return FOO_IGEN_COM_ACME_COYOTE (ret);
  else
    return NULL;
}


/**
 * foo_igen_com_acme_coyote_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_com_acme_coyote_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_com_acme_coyote_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_com_acme_coyote_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_com_acme_coyote_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_COM_ACME_COYOTE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "com.acme.Coyote", NULL);
}

/**
 * foo_igen_com_acme_coyote_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_com_acme_coyote_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_com_acme_coyote_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenComAcmeCoyoteProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenComAcmeCoyote *
foo_igen_com_acme_coyote_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_COM_ACME_COYOTE (ret);
  else
    return NULL;
}

/**
 * foo_igen_com_acme_coyote_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_com_acme_coyote_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_com_acme_coyote_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenComAcmeCoyoteProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenComAcmeCoyote *
foo_igen_com_acme_coyote_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_COM_ACME_COYOTE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "com.acme.Coyote", NULL);
  if (ret != NULL)
    return FOO_IGEN_COM_ACME_COYOTE (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenComAcmeCoyoteSkeleton:
 *
 * The #FooiGenComAcmeCoyoteSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenComAcmeCoyoteSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenComAcmeCoyoteSkeleton.
 */

struct _FooiGenComAcmeCoyoteSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_igen_com_acme_coyote_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_COM_ACME_COYOTE);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_COM_ACME_COYOTE);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_com_acme_coyote_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_com_acme_coyote_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_com_acme_coyote_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_com_acme_coyote_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_com_acme_coyote_skeleton_vtable =
{
  _foo_igen_com_acme_coyote_skeleton_handle_method_call,
  _foo_igen_com_acme_coyote_skeleton_handle_get_property,
  _foo_igen_com_acme_coyote_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_igen_com_acme_coyote_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_igen_com_acme_coyote_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_com_acme_coyote_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_igen_com_acme_coyote_skeleton_vtable;
}

static GVariant *
foo_igen_com_acme_coyote_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_com_acme_coyote_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_com_acme_coyote_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_com_acme_coyote_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_com_acme_coyote_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "com.acme.Coyote", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_igen_com_acme_coyote_emit_changed (gpointer user_data);

static void
foo_igen_com_acme_coyote_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (skeleton->priv->lock);

  if (emit_changed)
    _foo_igen_com_acme_coyote_emit_changed (skeleton);
}

static void
_foo_igen_com_acme_coyote_on_signal_surprised (
    FooiGenComAcmeCoyote *object)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "com.acme.Coyote", "Surprised",
    g_variant_new ("()"), NULL);
}

static void foo_igen_com_acme_coyote_skeleton_iface_init (FooiGenComAcmeCoyoteIface *iface);
G_DEFINE_TYPE_WITH_CODE (FooiGenComAcmeCoyoteSkeleton, foo_igen_com_acme_coyote_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_COM_ACME_COYOTE, foo_igen_com_acme_coyote_skeleton_iface_init));

static void
foo_igen_com_acme_coyote_skeleton_finalize (GObject *object)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (object);
  g_value_array_free (skeleton->priv->properties);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_com_acme_coyote_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_com_acme_coyote_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties->values[prop_id - 1], value);
  g_mutex_unlock (skeleton->priv->lock);
}

static gboolean
_foo_igen_com_acme_coyote_emit_changed (gpointer user_data)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties->values[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      g_dbus_connection_emit_signal (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     "org.freedesktop.DBus.Properties",
                                     "PropertiesChanged",
                                     g_variant_new ("(sa{sv}as)",
                                                    "com.acme.Coyote",
                                                    &builder, &invalidated_builder),
                                     NULL);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (skeleton->priv->lock);
  return FALSE;
}

static void
_foo_igen_com_acme_coyote_schedule_emit_changed (FooiGenComAcmeCoyoteSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_igen_com_acme_coyote_skeleton_notify (GObject      *object,
  GParamSpec *pspec)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (object);
  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_igen_com_acme_coyote_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (skeleton->priv->lock);
}

static void
foo_igen_com_acme_coyote_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties->values[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_igen_com_acme_coyote_schedule_emit_changed (skeleton, _foo_igen_com_acme_coyote_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties->values[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties->values[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_igen_com_acme_coyote_skeleton_init (FooiGenComAcmeCoyoteSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_COM_ACME_COYOTE_SKELETON, FooiGenComAcmeCoyoteSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
  skeleton->priv->properties = g_value_array_new (1);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[0], G_TYPE_STRING);
}

static const gchar *
foo_igen_com_acme_coyote_skeleton_get_mood (FooiGenComAcmeCoyote *object)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties->values[0]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static void
foo_igen_com_acme_coyote_skeleton_class_init (FooiGenComAcmeCoyoteSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooiGenComAcmeCoyoteSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_com_acme_coyote_skeleton_finalize;
  gobject_class->get_property = foo_igen_com_acme_coyote_skeleton_get_property;
  gobject_class->set_property = foo_igen_com_acme_coyote_skeleton_set_property;
  gobject_class->notify       = foo_igen_com_acme_coyote_skeleton_notify;


  foo_igen_com_acme_coyote_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_com_acme_coyote_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_com_acme_coyote_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_com_acme_coyote_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_com_acme_coyote_skeleton_dbus_interface_get_vtable;
}

static void
foo_igen_com_acme_coyote_skeleton_iface_init (FooiGenComAcmeCoyoteIface *iface)
{
  iface->surprised = _foo_igen_com_acme_coyote_on_signal_surprised;
  iface->get_mood = foo_igen_com_acme_coyote_skeleton_get_mood;
}

/**
 * foo_igen_com_acme_coyote_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link>.
 *
 * Returns: (transfer full) (type FooiGenComAcmeCoyoteSkeleton): The skeleton object.
 */
FooiGenComAcmeCoyote *
foo_igen_com_acme_coyote_skeleton_new (void)
{
  return FOO_IGEN_COM_ACME_COYOTE (g_object_new (FOO_IGEN_TYPE_COM_ACME_COYOTE_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface com.acme.Rocket
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenRocket123
 * @title: FooiGenRocket123
 * @short_description: Generated C code for the com.acme.Rocket D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link> D-Bus interface in C.
 */

/* ---- Introspection data for com.acme.Rocket ---- */

static const _ExtendedGDBusMethodInfo _foo_igen_rocket123_method_info_ignite_xyz =
{
  {
    -1,
    "Ignite",
    NULL,
    NULL,
    NULL
  },
  "handle-ignite-xyz",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_rocket123_method_info_pointers[] =
{
  &_foo_igen_rocket123_method_info_ignite_xyz,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_igen_rocket123_signal_info_exploded_xyz =
{
  {
    -1,
    "Exploded",
    NULL,
    NULL
  },
  "exploded-xyz"
};

static const _ExtendedGDBusSignalInfo * const _foo_igen_rocket123_signal_info_pointers[] =
{
  &_foo_igen_rocket123_signal_info_exploded_xyz,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_igen_rocket123_property_info_speed_xyz =
{
  {
    -1,
    "Speed",
    "d",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "speed-xyz",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_rocket123_property_info_direction =
{
  {
    -1,
    "Direction",
    "(ddd)",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "direction",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_rocket123_property_info_type_ =
{
  {
    -1,
    "Type",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "type-",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_igen_rocket123_property_info_pointers[] =
{
  &_foo_igen_rocket123_property_info_speed_xyz,
  &_foo_igen_rocket123_property_info_direction,
  &_foo_igen_rocket123_property_info_type_,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_rocket123_interface_info =
{
  {
    -1,
    "com.acme.Rocket",
    (GDBusMethodInfo **) &_foo_igen_rocket123_method_info_pointers,
    (GDBusSignalInfo **) &_foo_igen_rocket123_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_igen_rocket123_property_info_pointers,
    NULL
  },
  "rocket123",
};


/**
 * foo_igen_rocket123_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_rocket123_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_rocket123_interface_info;
}

/**
 * foo_igen_rocket123_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenRocket123 interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_rocket123_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "speed-xyz");
  g_object_class_override_property (klass, property_id_begin++, "direction");
  g_object_class_override_property (klass, property_id_begin++, "type-");
  return property_id_begin - 1;
}



/**
 * FooiGenRocket123:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link>.
 */

/**
 * FooiGenRocket123Iface:
 * @parent_iface: The parent interface.
 * @handle_ignite_xyz: Handler for the #FooiGenRocket123::handle-ignite-xyz signal.
 * @get_direction: Getter for the #FooiGenRocket123:direction property.
 * @get_speed_xyz: Getter for the #FooiGenRocket123:speed-xyz property.
 * @get_type_: Getter for the #FooiGenRocket123:type- property.
 * @exploded_xyz: Handler for the #FooiGenRocket123::exploded-xyz signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link>.
 */

static void
foo_igen_rocket123_default_init (FooiGenRocket123Iface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenRocket123::handle-ignite-xyz:
   * @object: A #FooiGenRocket123.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-acme-Rocket.Ignite">Ignite()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_rocket123_complete_ignite_xyz() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-ignite-xyz",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenRocket123Iface, handle_ignite_xyz),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooiGenRocket123::exploded-xyz:
   * @object: A #FooiGenRocket123.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-com-acme-Rocket.Exploded">"Exploded"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("exploded-xyz",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenRocket123Iface, exploded_xyz),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * FooiGenRocket123:speed-xyz:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-com-acme-Rocket.Speed">"Speed"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_double ("speed-xyz", "Speed", "Speed", -G_MAXDOUBLE, G_MAXDOUBLE, 0.0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenRocket123:direction:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-com-acme-Rocket.Direction">"Direction"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("direction", "Direction", "Direction", G_VARIANT_TYPE ("(ddd)"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenRocket123:type-:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-com-acme-Rocket.Type">"Type"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("type-", "Type", "Type", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

typedef FooiGenRocket123Iface FooiGenRocket123Interface;
G_DEFINE_INTERFACE (FooiGenRocket123, foo_igen_rocket123, G_TYPE_OBJECT);

/**
 * foo_igen_rocket123_get_speed_xyz: (skip)
 * @object: A #FooiGenRocket123.
 *
 * Gets the value of the <link linkend="gdbus-property-com-acme-Rocket.Speed">"Speed"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gdouble 
foo_igen_rocket123_get_speed_xyz (FooiGenRocket123 *object)
{
  return FOO_IGEN_ROCKET123_GET_IFACE (object)->get_speed_xyz (object);
}

/**
 * foo_igen_rocket123_set_speed_xyz: (skip)
 * @object: A #FooiGenRocket123.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-com-acme-Rocket.Speed">"Speed"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_rocket123_set_speed_xyz (FooiGenRocket123 *object, gdouble value)
{
  g_object_set (G_OBJECT (object), "speed-xyz", value, NULL);
}

/**
 * foo_igen_rocket123_get_direction: (skip)
 * @object: A #FooiGenRocket123.
 *
 * Gets the value of the <link linkend="gdbus-property-com-acme-Rocket.Direction">"Direction"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_rocket123_dup_direction() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
foo_igen_rocket123_get_direction (FooiGenRocket123 *object)
{
  return FOO_IGEN_ROCKET123_GET_IFACE (object)->get_direction (object);
}

/**
 * foo_igen_rocket123_dup_direction: (skip)
 * @object: A #FooiGenRocket123.
 *
 * Gets a copy of the <link linkend="gdbus-property-com-acme-Rocket.Direction">"Direction"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
foo_igen_rocket123_dup_direction (FooiGenRocket123 *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "direction", &value, NULL);
  return value;
}

/**
 * foo_igen_rocket123_set_direction: (skip)
 * @object: A #FooiGenRocket123.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-com-acme-Rocket.Direction">"Direction"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_rocket123_set_direction (FooiGenRocket123 *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "direction", value, NULL);
}

/**
 * foo_igen_rocket123_get_type_: (skip)
 * @object: A #FooiGenRocket123.
 *
 * Gets the value of the <link linkend="gdbus-property-com-acme-Rocket.Type">"Type"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_rocket123_dup_type_() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_rocket123_get_type_ (FooiGenRocket123 *object)
{
  return FOO_IGEN_ROCKET123_GET_IFACE (object)->get_type_ (object);
}

/**
 * foo_igen_rocket123_dup_type_: (skip)
 * @object: A #FooiGenRocket123.
 *
 * Gets a copy of the <link linkend="gdbus-property-com-acme-Rocket.Type">"Type"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_rocket123_dup_type_ (FooiGenRocket123 *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "type-", &value, NULL);
  return value;
}

/**
 * foo_igen_rocket123_set_type_: (skip)
 * @object: A #FooiGenRocket123.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-com-acme-Rocket.Type">"Type"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_rocket123_set_type_ (FooiGenRocket123 *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "type-", value, NULL);
}

/**
 * foo_igen_rocket123_emit_exploded_xyz:
 * @object: A #FooiGenRocket123.
 *
 * Emits the <link linkend="gdbus-signal-com-acme-Rocket.Exploded">"Exploded"</link> D-Bus signal.
 */
void
foo_igen_rocket123_emit_exploded_xyz (
    FooiGenRocket123 *object)
{
  g_signal_emit_by_name (object, "exploded-xyz");
}

/**
 * foo_igen_rocket123_call_ignite_xyz:
 * @proxy: A #FooiGenRocket123Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-com-acme-Rocket.Ignite">Ignite()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_rocket123_call_ignite_xyz_finish() to get the result of the operation.
 *
 * See foo_igen_rocket123_call_ignite_xyz_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_rocket123_call_ignite_xyz (
    FooiGenRocket123 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Ignite",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_rocket123_call_ignite_xyz_finish:
 * @proxy: A #FooiGenRocket123Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_rocket123_call_ignite_xyz().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_rocket123_call_ignite_xyz().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_rocket123_call_ignite_xyz_finish (
    FooiGenRocket123 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_rocket123_call_ignite_xyz_sync:
 * @proxy: A #FooiGenRocket123Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-com-acme-Rocket.Ignite">Ignite()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_rocket123_call_ignite_xyz() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_rocket123_call_ignite_xyz_sync (
    FooiGenRocket123 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Ignite",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_rocket123_complete_ignite_xyz:
 * @object: A #FooiGenRocket123.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-acme-Rocket.Ignite">Ignite()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_rocket123_complete_ignite_xyz (
    FooiGenRocket123 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenRocket123Proxy:
 *
 * The #FooiGenRocket123Proxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenRocket123ProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenRocket123Proxy.
 */

struct _FooiGenRocket123ProxyPrivate
{
  GData *qdata;
};

static void foo_igen_rocket123_proxy_iface_init (FooiGenRocket123Iface *iface);

G_DEFINE_TYPE_WITH_CODE (FooiGenRocket123Proxy, foo_igen_rocket123_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_ROCKET123, foo_igen_rocket123_proxy_iface_init));

static void
foo_igen_rocket123_proxy_finalize (GObject *object)
{
  FooiGenRocket123Proxy *proxy = FOO_IGEN_ROCKET123_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_rocket123_proxy_parent_class)->finalize (object);
}

static void
foo_igen_rocket123_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  info = _foo_igen_rocket123_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_igen_rocket123_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  error = NULL;
  if (!g_dbus_proxy_call_finish (proxy, res, &error))
    {
      g_warning ("Error setting property `%s' on interface com.acme.Rocket: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
}

static void
foo_igen_rocket123_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  info = _foo_igen_rocket123_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "com.acme.Rocket", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_igen_rocket123_proxy_set_property_cb, (gpointer) info);
  g_variant_unref (variant);
}

static void
foo_igen_rocket123_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_rocket123_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_ROCKET123);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_ROCKET123);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_rocket123_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenRocket123Proxy *proxy = FOO_IGEN_ROCKET123_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_rocket123_interface_info, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_rocket123_interface_info, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gdouble 
foo_igen_rocket123_proxy_get_speed_xyz (FooiGenRocket123 *object)
{
  FooiGenRocket123Proxy *proxy = FOO_IGEN_ROCKET123_PROXY (object);
  GVariant *variant;
  gdouble value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Speed");
  if (variant != NULL)
    {
      value = g_variant_get_double (variant);
      g_variant_unref (variant);
    }
  return value;
}

static GVariant *
foo_igen_rocket123_proxy_get_direction (FooiGenRocket123 *object)
{
  FooiGenRocket123Proxy *proxy = FOO_IGEN_ROCKET123_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Direction");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static const gchar *
foo_igen_rocket123_proxy_get_type_ (FooiGenRocket123 *object)
{
  FooiGenRocket123Proxy *proxy = FOO_IGEN_ROCKET123_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Type");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
foo_igen_rocket123_proxy_init (FooiGenRocket123Proxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_ROCKET123_PROXY, FooiGenRocket123ProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_rocket123_interface_info ());
}

static void
foo_igen_rocket123_proxy_class_init (FooiGenRocket123ProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (FooiGenRocket123ProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_rocket123_proxy_finalize;
  gobject_class->get_property = foo_igen_rocket123_proxy_get_property;
  gobject_class->set_property = foo_igen_rocket123_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_rocket123_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_rocket123_proxy_g_properties_changed;


  foo_igen_rocket123_override_properties (gobject_class, 1);
}

static void
foo_igen_rocket123_proxy_iface_init (FooiGenRocket123Iface *iface)
{
  iface->get_speed_xyz = foo_igen_rocket123_proxy_get_speed_xyz;
  iface->get_direction = foo_igen_rocket123_proxy_get_direction;
  iface->get_type_ = foo_igen_rocket123_proxy_get_type_;
}

/**
 * foo_igen_rocket123_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_rocket123_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_rocket123_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_rocket123_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_ROCKET123_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "com.acme.Rocket", NULL);
}

/**
 * foo_igen_rocket123_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_rocket123_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_rocket123_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenRocket123Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenRocket123 *
foo_igen_rocket123_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_ROCKET123 (ret);
  else
    return NULL;
}

/**
 * foo_igen_rocket123_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_rocket123_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenRocket123Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenRocket123 *
foo_igen_rocket123_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_ROCKET123_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "com.acme.Rocket", NULL);
  if (ret != NULL)
    return FOO_IGEN_ROCKET123 (ret);
  else
    return NULL;
}


/**
 * foo_igen_rocket123_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_rocket123_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_rocket123_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_rocket123_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_rocket123_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_ROCKET123_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "com.acme.Rocket", NULL);
}

/**
 * foo_igen_rocket123_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_rocket123_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_rocket123_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenRocket123Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenRocket123 *
foo_igen_rocket123_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_ROCKET123 (ret);
  else
    return NULL;
}

/**
 * foo_igen_rocket123_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_rocket123_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_rocket123_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenRocket123Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenRocket123 *
foo_igen_rocket123_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_ROCKET123_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "com.acme.Rocket", NULL);
  if (ret != NULL)
    return FOO_IGEN_ROCKET123 (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenRocket123Skeleton:
 *
 * The #FooiGenRocket123Skeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenRocket123SkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenRocket123Skeleton.
 */

struct _FooiGenRocket123SkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_igen_rocket123_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_ROCKET123);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_ROCKET123);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_rocket123_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_rocket123_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_rocket123_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_rocket123_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_rocket123_skeleton_vtable =
{
  _foo_igen_rocket123_skeleton_handle_method_call,
  _foo_igen_rocket123_skeleton_handle_get_property,
  _foo_igen_rocket123_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_igen_rocket123_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_igen_rocket123_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_rocket123_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_igen_rocket123_skeleton_vtable;
}

static GVariant *
foo_igen_rocket123_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_rocket123_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_rocket123_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_rocket123_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_rocket123_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "com.acme.Rocket", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_igen_rocket123_emit_changed (gpointer user_data);

static void
foo_igen_rocket123_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (skeleton->priv->lock);

  if (emit_changed)
    _foo_igen_rocket123_emit_changed (skeleton);
}

static void
_foo_igen_rocket123_on_signal_exploded_xyz (
    FooiGenRocket123 *object)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "com.acme.Rocket", "Exploded",
    g_variant_new ("()"), NULL);
}

static void foo_igen_rocket123_skeleton_iface_init (FooiGenRocket123Iface *iface);
G_DEFINE_TYPE_WITH_CODE (FooiGenRocket123Skeleton, foo_igen_rocket123_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_ROCKET123, foo_igen_rocket123_skeleton_iface_init));

static void
foo_igen_rocket123_skeleton_finalize (GObject *object)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (object);
  g_value_array_free (skeleton->priv->properties);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_rocket123_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_rocket123_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  g_mutex_lock (skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties->values[prop_id - 1], value);
  g_mutex_unlock (skeleton->priv->lock);
}

static gboolean
_foo_igen_rocket123_emit_changed (gpointer user_data)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties->values[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      g_dbus_connection_emit_signal (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     "org.freedesktop.DBus.Properties",
                                     "PropertiesChanged",
                                     g_variant_new ("(sa{sv}as)",
                                                    "com.acme.Rocket",
                                                    &builder, &invalidated_builder),
                                     NULL);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (skeleton->priv->lock);
  return FALSE;
}

static void
_foo_igen_rocket123_schedule_emit_changed (FooiGenRocket123Skeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_igen_rocket123_skeleton_notify (GObject      *object,
  GParamSpec *pspec)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (object);
  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_igen_rocket123_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (skeleton->priv->lock);
}

static void
foo_igen_rocket123_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  g_mutex_lock (skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties->values[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_igen_rocket123_schedule_emit_changed (skeleton, _foo_igen_rocket123_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties->values[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties->values[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_igen_rocket123_skeleton_init (FooiGenRocket123Skeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_ROCKET123_SKELETON, FooiGenRocket123SkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
  skeleton->priv->properties = g_value_array_new (3);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[0], G_TYPE_DOUBLE);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[1], G_TYPE_VARIANT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[2], G_TYPE_STRING);
}

static gdouble 
foo_igen_rocket123_skeleton_get_speed_xyz (FooiGenRocket123 *object)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (object);
  gdouble value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_double (&(skeleton->priv->properties->values[0]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static GVariant *
foo_igen_rocket123_skeleton_get_direction (FooiGenRocket123 *object)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (object);
  GVariant *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties->values[1]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_rocket123_skeleton_get_type_ (FooiGenRocket123 *object)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (object);
  const gchar *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties->values[2]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static void
foo_igen_rocket123_skeleton_class_init (FooiGenRocket123SkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooiGenRocket123SkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_rocket123_skeleton_finalize;
  gobject_class->get_property = foo_igen_rocket123_skeleton_get_property;
  gobject_class->set_property = foo_igen_rocket123_skeleton_set_property;
  gobject_class->notify       = foo_igen_rocket123_skeleton_notify;


  foo_igen_rocket123_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_rocket123_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_rocket123_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_rocket123_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_rocket123_skeleton_dbus_interface_get_vtable;
}

static void
foo_igen_rocket123_skeleton_iface_init (FooiGenRocket123Iface *iface)
{
  iface->exploded_xyz = _foo_igen_rocket123_on_signal_exploded_xyz;
  iface->get_speed_xyz = foo_igen_rocket123_skeleton_get_speed_xyz;
  iface->get_direction = foo_igen_rocket123_skeleton_get_direction;
  iface->get_type_ = foo_igen_rocket123_skeleton_get_type_;
}

/**
 * foo_igen_rocket123_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link>.
 *
 * Returns: (transfer full) (type FooiGenRocket123Skeleton): The skeleton object.
 */
FooiGenRocket123 *
foo_igen_rocket123_skeleton_new (void)
{
  return FOO_IGEN_ROCKET123 (g_object_new (FOO_IGEN_TYPE_ROCKET123_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.Bat
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenBat
 * @title: FooiGenBat
 * @short_description: Generated C code for the org.project.Bat D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.Bat ---- */

static const _ExtendedGDBusArgInfo _foo_igen_bat_method_info_force_method_IN_ARG_force_in_i =
{
  {
    -1,
    "force_in_i",
    "i",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_method_info_force_method_IN_ARG_force_in_s =
{
  {
    -1,
    "force_in_s",
    "s",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_method_info_force_method_IN_ARG_force_in_ay =
{
  {
    -1,
    "force_in_ay",
    "ay",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_method_info_force_method_IN_ARG_force_in_struct =
{
  {
    -1,
    "force_in_struct",
    "(i)",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bat_method_info_force_method_IN_ARG_pointers[] =
{
  &_foo_igen_bat_method_info_force_method_IN_ARG_force_in_i,
  &_foo_igen_bat_method_info_force_method_IN_ARG_force_in_s,
  &_foo_igen_bat_method_info_force_method_IN_ARG_force_in_ay,
  &_foo_igen_bat_method_info_force_method_IN_ARG_force_in_struct,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_method_info_force_method_OUT_ARG_force_out_i =
{
  {
    -1,
    "force_out_i",
    "i",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_method_info_force_method_OUT_ARG_force_out_s =
{
  {
    -1,
    "force_out_s",
    "s",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_method_info_force_method_OUT_ARG_force_out_ay =
{
  {
    -1,
    "force_out_ay",
    "ay",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_method_info_force_method_OUT_ARG_force_out_struct =
{
  {
    -1,
    "force_out_struct",
    "(i)",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bat_method_info_force_method_OUT_ARG_pointers[] =
{
  &_foo_igen_bat_method_info_force_method_OUT_ARG_force_out_i,
  &_foo_igen_bat_method_info_force_method_OUT_ARG_force_out_s,
  &_foo_igen_bat_method_info_force_method_OUT_ARG_force_out_ay,
  &_foo_igen_bat_method_info_force_method_OUT_ARG_force_out_struct,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_bat_method_info_force_method =
{
  {
    -1,
    "ForceMethod",
    (GDBusArgInfo **) &_foo_igen_bat_method_info_force_method_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_igen_bat_method_info_force_method_OUT_ARG_pointers,
    NULL
  },
  "handle-force-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_bat_method_info_pointers[] =
{
  &_foo_igen_bat_method_info_force_method,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_signal_info_force_signal_ARG_force_i =
{
  {
    -1,
    "force_i",
    "i",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_signal_info_force_signal_ARG_force_s =
{
  {
    -1,
    "force_s",
    "s",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_signal_info_force_signal_ARG_force_ay =
{
  {
    -1,
    "force_ay",
    "ay",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_signal_info_force_signal_ARG_force_struct =
{
  {
    -1,
    "force_struct",
    "(i)",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bat_signal_info_force_signal_ARG_pointers[] =
{
  &_foo_igen_bat_signal_info_force_signal_ARG_force_i,
  &_foo_igen_bat_signal_info_force_signal_ARG_force_s,
  &_foo_igen_bat_signal_info_force_signal_ARG_force_ay,
  &_foo_igen_bat_signal_info_force_signal_ARG_force_struct,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_igen_bat_signal_info_force_signal =
{
  {
    -1,
    "ForceSignal",
    (GDBusArgInfo **) &_foo_igen_bat_signal_info_force_signal_ARG_pointers,
    NULL
  },
  "force-signal"
};

static const _ExtendedGDBusSignalInfo * const _foo_igen_bat_signal_info_pointers[] =
{
  &_foo_igen_bat_signal_info_force_signal,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bat_property_info_force_i =
{
  {
    -1,
    "force_i",
    "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "force-i",
  TRUE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bat_property_info_force_s =
{
  {
    -1,
    "force_s",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "force-s",
  TRUE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bat_property_info_force_ay =
{
  {
    -1,
    "force_ay",
    "ay",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "force-ay",
  TRUE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bat_property_info_force_struct =
{
  {
    -1,
    "force_struct",
    "(i)",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "force-struct",
  TRUE
};

static const _ExtendedGDBusPropertyInfo * const _foo_igen_bat_property_info_pointers[] =
{
  &_foo_igen_bat_property_info_force_i,
  &_foo_igen_bat_property_info_force_s,
  &_foo_igen_bat_property_info_force_ay,
  &_foo_igen_bat_property_info_force_struct,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_bat_interface_info =
{
  {
    -1,
    "org.project.Bat",
    (GDBusMethodInfo **) &_foo_igen_bat_method_info_pointers,
    (GDBusSignalInfo **) &_foo_igen_bat_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_igen_bat_property_info_pointers,
    NULL
  },
  "bat",
};


/**
 * foo_igen_bat_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_bat_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_bat_interface_info;
}

/**
 * foo_igen_bat_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenBat interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_bat_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "force-i");
  g_object_class_override_property (klass, property_id_begin++, "force-s");
  g_object_class_override_property (klass, property_id_begin++, "force-ay");
  g_object_class_override_property (klass, property_id_begin++, "force-struct");
  return property_id_begin - 1;
}



/**
 * FooiGenBat:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link>.
 */

/**
 * FooiGenBatIface:
 * @parent_iface: The parent interface.
 * @handle_force_method: Handler for the #FooiGenBat::handle-force-method signal.
 * @get_force_ay: Getter for the #FooiGenBat:force-ay property.
 * @get_force_i: Getter for the #FooiGenBat:force-i property.
 * @get_force_s: Getter for the #FooiGenBat:force-s property.
 * @get_force_struct: Getter for the #FooiGenBat:force-struct property.
 * @force_signal: Handler for the #FooiGenBat::force-signal signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link>.
 */

static void
foo_igen_bat_default_init (FooiGenBatIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenBat::handle-force-method:
   * @object: A #FooiGenBat.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_force_in_i: Argument passed by remote caller.
   * @arg_force_in_s: Argument passed by remote caller.
   * @arg_force_in_ay: Argument passed by remote caller.
   * @arg_force_in_struct: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bat.ForceMethod">ForceMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_bat_complete_force_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-force-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBatIface, handle_force_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    5,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT, G_TYPE_VARIANT, G_TYPE_VARIANT, G_TYPE_VARIANT);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooiGenBat::force-signal:
   * @object: A #FooiGenBat.
   * @arg_force_i: Argument.
   * @arg_force_s: Argument.
   * @arg_force_ay: Argument.
   * @arg_force_struct: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-project-Bat.ForceSignal">"ForceSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("force-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBatIface, force_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    4, G_TYPE_VARIANT, G_TYPE_VARIANT, G_TYPE_VARIANT, G_TYPE_VARIANT);

  /* GObject properties for D-Bus properties: */
  /**
   * FooiGenBat:force-i:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bat.force_i">"force_i"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("force-i", "force_i", "force_i", G_VARIANT_TYPE ("i"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBat:force-s:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bat.force_s">"force_s"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("force-s", "force_s", "force_s", G_VARIANT_TYPE ("s"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBat:force-ay:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bat.force_ay">"force_ay"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("force-ay", "force_ay", "force_ay", G_VARIANT_TYPE ("ay"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBat:force-struct:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bat.force_struct">"force_struct"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("force-struct", "force_struct", "force_struct", G_VARIANT_TYPE ("(i)"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

typedef FooiGenBatIface FooiGenBatInterface;
G_DEFINE_INTERFACE (FooiGenBat, foo_igen_bat, G_TYPE_OBJECT);

/**
 * foo_igen_bat_get_force_i: (skip)
 * @object: A #FooiGenBat.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bat.force_i">"force_i"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bat_dup_force_i() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
foo_igen_bat_get_force_i (FooiGenBat *object)
{
  return FOO_IGEN_BAT_GET_IFACE (object)->get_force_i (object);
}

/**
 * foo_igen_bat_dup_force_i: (skip)
 * @object: A #FooiGenBat.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bat.force_i">"force_i"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
foo_igen_bat_dup_force_i (FooiGenBat *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "force-i", &value, NULL);
  return value;
}

/**
 * foo_igen_bat_set_force_i: (skip)
 * @object: A #FooiGenBat.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bat.force_i">"force_i"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bat_set_force_i (FooiGenBat *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "force-i", value, NULL);
}

/**
 * foo_igen_bat_get_force_s: (skip)
 * @object: A #FooiGenBat.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bat.force_s">"force_s"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bat_dup_force_s() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
foo_igen_bat_get_force_s (FooiGenBat *object)
{
  return FOO_IGEN_BAT_GET_IFACE (object)->get_force_s (object);
}

/**
 * foo_igen_bat_dup_force_s: (skip)
 * @object: A #FooiGenBat.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bat.force_s">"force_s"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
foo_igen_bat_dup_force_s (FooiGenBat *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "force-s", &value, NULL);
  return value;
}

/**
 * foo_igen_bat_set_force_s: (skip)
 * @object: A #FooiGenBat.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bat.force_s">"force_s"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bat_set_force_s (FooiGenBat *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "force-s", value, NULL);
}

/**
 * foo_igen_bat_get_force_ay: (skip)
 * @object: A #FooiGenBat.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bat.force_ay">"force_ay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bat_dup_force_ay() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
foo_igen_bat_get_force_ay (FooiGenBat *object)
{
  return FOO_IGEN_BAT_GET_IFACE (object)->get_force_ay (object);
}

/**
 * foo_igen_bat_dup_force_ay: (skip)
 * @object: A #FooiGenBat.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bat.force_ay">"force_ay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
foo_igen_bat_dup_force_ay (FooiGenBat *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "force-ay", &value, NULL);
  return value;
}

/**
 * foo_igen_bat_set_force_ay: (skip)
 * @object: A #FooiGenBat.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bat.force_ay">"force_ay"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bat_set_force_ay (FooiGenBat *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "force-ay", value, NULL);
}

/**
 * foo_igen_bat_get_force_struct: (skip)
 * @object: A #FooiGenBat.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bat.force_struct">"force_struct"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bat_dup_force_struct() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
foo_igen_bat_get_force_struct (FooiGenBat *object)
{
  return FOO_IGEN_BAT_GET_IFACE (object)->get_force_struct (object);
}

/**
 * foo_igen_bat_dup_force_struct: (skip)
 * @object: A #FooiGenBat.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bat.force_struct">"force_struct"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
foo_igen_bat_dup_force_struct (FooiGenBat *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "force-struct", &value, NULL);
  return value;
}

/**
 * foo_igen_bat_set_force_struct: (skip)
 * @object: A #FooiGenBat.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bat.force_struct">"force_struct"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bat_set_force_struct (FooiGenBat *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "force-struct", value, NULL);
}

/**
 * foo_igen_bat_emit_force_signal:
 * @object: A #FooiGenBat.
 * @arg_force_i: Argument to pass with the signal.
 * @arg_force_s: Argument to pass with the signal.
 * @arg_force_ay: Argument to pass with the signal.
 * @arg_force_struct: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-project-Bat.ForceSignal">"ForceSignal"</link> D-Bus signal.
 */
void
foo_igen_bat_emit_force_signal (
    FooiGenBat *object,
    GVariant *arg_force_i,
    GVariant *arg_force_s,
    GVariant *arg_force_ay,
    GVariant *arg_force_struct)
{
  g_signal_emit_by_name (object, "force-signal", arg_force_i, arg_force_s, arg_force_ay, arg_force_struct);
}

/**
 * foo_igen_bat_call_force_method:
 * @proxy: A #FooiGenBatProxy.
 * @arg_force_in_i: Argument to pass with the method invocation.
 * @arg_force_in_s: Argument to pass with the method invocation.
 * @arg_force_in_ay: Argument to pass with the method invocation.
 * @arg_force_in_struct: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bat.ForceMethod">ForceMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bat_call_force_method_finish() to get the result of the operation.
 *
 * See foo_igen_bat_call_force_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_bat_call_force_method (
    FooiGenBat *proxy,
    GVariant *arg_force_in_i,
    GVariant *arg_force_in_s,
    GVariant *arg_force_in_ay,
    GVariant *arg_force_in_struct,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "ForceMethod",
    g_variant_new ("(@i@s@ay@(i))",
                   arg_force_in_i,
                   arg_force_in_s,
                   arg_force_in_ay,
                   arg_force_in_struct),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_bat_call_force_method_finish:
 * @proxy: A #FooiGenBatProxy.
 * @out_force_out_i: (out): Return location for return parameter or %NULL to ignore.
 * @out_force_out_s: (out): Return location for return parameter or %NULL to ignore.
 * @out_force_out_ay: (out): Return location for return parameter or %NULL to ignore.
 * @out_force_out_struct: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bat_call_force_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_bat_call_force_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bat_call_force_method_finish (
    FooiGenBat *proxy,
    GVariant **out_force_out_i,
    GVariant **out_force_out_s,
    GVariant **out_force_out_ay,
    GVariant **out_force_out_struct,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@i@s@ay@(i))",
                 out_force_out_i,
                 out_force_out_s,
                 out_force_out_ay,
                 out_force_out_struct);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bat_call_force_method_sync:
 * @proxy: A #FooiGenBatProxy.
 * @arg_force_in_i: Argument to pass with the method invocation.
 * @arg_force_in_s: Argument to pass with the method invocation.
 * @arg_force_in_ay: Argument to pass with the method invocation.
 * @arg_force_in_struct: Argument to pass with the method invocation.
 * @out_force_out_i: (out): Return location for return parameter or %NULL to ignore.
 * @out_force_out_s: (out): Return location for return parameter or %NULL to ignore.
 * @out_force_out_ay: (out): Return location for return parameter or %NULL to ignore.
 * @out_force_out_struct: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bat.ForceMethod">ForceMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bat_call_force_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bat_call_force_method_sync (
    FooiGenBat *proxy,
    GVariant *arg_force_in_i,
    GVariant *arg_force_in_s,
    GVariant *arg_force_in_ay,
    GVariant *arg_force_in_struct,
    GVariant **out_force_out_i,
    GVariant **out_force_out_s,
    GVariant **out_force_out_ay,
    GVariant **out_force_out_struct,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "ForceMethod",
    g_variant_new ("(@i@s@ay@(i))",
                   arg_force_in_i,
                   arg_force_in_s,
                   arg_force_in_ay,
                   arg_force_in_struct),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@i@s@ay@(i))",
                 out_force_out_i,
                 out_force_out_s,
                 out_force_out_ay,
                 out_force_out_struct);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bat_complete_force_method:
 * @object: A #FooiGenBat.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @force_out_i: Parameter to return.
 * @force_out_s: Parameter to return.
 * @force_out_ay: Parameter to return.
 * @force_out_struct: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bat.ForceMethod">ForceMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_bat_complete_force_method (
    FooiGenBat *object,
    GDBusMethodInvocation *invocation,
    GVariant *force_out_i,
    GVariant *force_out_s,
    GVariant *force_out_ay,
    GVariant *force_out_struct)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(@i@s@ay@(i))",
                   force_out_i,
                   force_out_s,
                   force_out_ay,
                   force_out_struct));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenBatProxy:
 *
 * The #FooiGenBatProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenBatProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenBatProxy.
 */

struct _FooiGenBatProxyPrivate
{
  GData *qdata;
};

static void foo_igen_bat_proxy_iface_init (FooiGenBatIface *iface);

G_DEFINE_TYPE_WITH_CODE (FooiGenBatProxy, foo_igen_bat_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAT, foo_igen_bat_proxy_iface_init));

static void
foo_igen_bat_proxy_finalize (GObject *object)
{
  FooiGenBatProxy *proxy = FOO_IGEN_BAT_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_bat_proxy_parent_class)->finalize (object);
}

static void
foo_igen_bat_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 4);
  info = _foo_igen_bat_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_igen_bat_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  error = NULL;
  if (!g_dbus_proxy_call_finish (proxy, res, &error))
    {
      g_warning ("Error setting property `%s' on interface org.project.Bat: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
}

static void
foo_igen_bat_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 4);
  info = _foo_igen_bat_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.project.Bat", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_igen_bat_proxy_set_property_cb, (gpointer) info);
  g_variant_unref (variant);
}

static void
foo_igen_bat_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_bat_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_BAT);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_BAT);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_bat_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenBatProxy *proxy = FOO_IGEN_BAT_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bat_interface_info, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bat_interface_info, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static GVariant *
foo_igen_bat_proxy_get_force_i (FooiGenBat *object)
{
  FooiGenBatProxy *proxy = FOO_IGEN_BAT_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "force_i");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static GVariant *
foo_igen_bat_proxy_get_force_s (FooiGenBat *object)
{
  FooiGenBatProxy *proxy = FOO_IGEN_BAT_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "force_s");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static GVariant *
foo_igen_bat_proxy_get_force_ay (FooiGenBat *object)
{
  FooiGenBatProxy *proxy = FOO_IGEN_BAT_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "force_ay");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static GVariant *
foo_igen_bat_proxy_get_force_struct (FooiGenBat *object)
{
  FooiGenBatProxy *proxy = FOO_IGEN_BAT_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "force_struct");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static void
foo_igen_bat_proxy_init (FooiGenBatProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_BAT_PROXY, FooiGenBatProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_bat_interface_info ());
}

static void
foo_igen_bat_proxy_class_init (FooiGenBatProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (FooiGenBatProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_bat_proxy_finalize;
  gobject_class->get_property = foo_igen_bat_proxy_get_property;
  gobject_class->set_property = foo_igen_bat_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_bat_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_bat_proxy_g_properties_changed;


  foo_igen_bat_override_properties (gobject_class, 1);
}

static void
foo_igen_bat_proxy_iface_init (FooiGenBatIface *iface)
{
  iface->get_force_i = foo_igen_bat_proxy_get_force_i;
  iface->get_force_s = foo_igen_bat_proxy_get_force_s;
  iface->get_force_ay = foo_igen_bat_proxy_get_force_ay;
  iface->get_force_struct = foo_igen_bat_proxy_get_force_struct;
}

/**
 * foo_igen_bat_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bat_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_bat_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_bat_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_BAT_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Bat", NULL);
}

/**
 * foo_igen_bat_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bat_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_bat_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenBatProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBat *
foo_igen_bat_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_BAT (ret);
  else
    return NULL;
}

/**
 * foo_igen_bat_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bat_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenBatProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBat *
foo_igen_bat_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_BAT_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Bat", NULL);
  if (ret != NULL)
    return FOO_IGEN_BAT (ret);
  else
    return NULL;
}


/**
 * foo_igen_bat_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_bat_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bat_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_bat_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_bat_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_BAT_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Bat", NULL);
}

/**
 * foo_igen_bat_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bat_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_bat_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenBatProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBat *
foo_igen_bat_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_BAT (ret);
  else
    return NULL;
}

/**
 * foo_igen_bat_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_bat_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bat_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenBatProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBat *
foo_igen_bat_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_BAT_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Bat", NULL);
  if (ret != NULL)
    return FOO_IGEN_BAT (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenBatSkeleton:
 *
 * The #FooiGenBatSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenBatSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenBatSkeleton.
 */

struct _FooiGenBatSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_igen_bat_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_BAT);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_BAT);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_bat_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bat_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_bat_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bat_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_bat_skeleton_vtable =
{
  _foo_igen_bat_skeleton_handle_method_call,
  _foo_igen_bat_skeleton_handle_get_property,
  _foo_igen_bat_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_igen_bat_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_igen_bat_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_bat_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_igen_bat_skeleton_vtable;
}

static GVariant *
foo_igen_bat_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_bat_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_bat_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_bat_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_bat_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Bat", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_igen_bat_emit_changed (gpointer user_data);

static void
foo_igen_bat_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (skeleton->priv->lock);

  if (emit_changed)
    _foo_igen_bat_emit_changed (skeleton);
}

static void
_foo_igen_bat_on_signal_force_signal (
    FooiGenBat *object,
    GVariant *arg_force_i,
    GVariant *arg_force_s,
    GVariant *arg_force_ay,
    GVariant *arg_force_struct)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Bat", "ForceSignal",
    g_variant_new ("(@i@s@ay@(i))",
                   arg_force_i,
                   arg_force_s,
                   arg_force_ay,
                   arg_force_struct), NULL);
}

static void foo_igen_bat_skeleton_iface_init (FooiGenBatIface *iface);
G_DEFINE_TYPE_WITH_CODE (FooiGenBatSkeleton, foo_igen_bat_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAT, foo_igen_bat_skeleton_iface_init));

static void
foo_igen_bat_skeleton_finalize (GObject *object)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (object);
  g_value_array_free (skeleton->priv->properties);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_bat_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_bat_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 4);
  g_mutex_lock (skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties->values[prop_id - 1], value);
  g_mutex_unlock (skeleton->priv->lock);
}

static gboolean
_foo_igen_bat_emit_changed (gpointer user_data)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties->values[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      g_dbus_connection_emit_signal (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     "org.freedesktop.DBus.Properties",
                                     "PropertiesChanged",
                                     g_variant_new ("(sa{sv}as)",
                                                    "org.project.Bat",
                                                    &builder, &invalidated_builder),
                                     NULL);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (skeleton->priv->lock);
  return FALSE;
}

static void
_foo_igen_bat_schedule_emit_changed (FooiGenBatSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_igen_bat_skeleton_notify (GObject      *object,
  GParamSpec *pspec)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (object);
  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_igen_bat_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (skeleton->priv->lock);
}

static void
foo_igen_bat_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 4);
  g_mutex_lock (skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties->values[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_igen_bat_schedule_emit_changed (skeleton, _foo_igen_bat_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties->values[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties->values[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_igen_bat_skeleton_init (FooiGenBatSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_BAT_SKELETON, FooiGenBatSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
  skeleton->priv->properties = g_value_array_new (4);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[0], G_TYPE_VARIANT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[1], G_TYPE_VARIANT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[2], G_TYPE_VARIANT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[3], G_TYPE_VARIANT);
}

static GVariant *
foo_igen_bat_skeleton_get_force_i (FooiGenBat *object)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (object);
  GVariant *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties->values[0]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static GVariant *
foo_igen_bat_skeleton_get_force_s (FooiGenBat *object)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (object);
  GVariant *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties->values[1]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static GVariant *
foo_igen_bat_skeleton_get_force_ay (FooiGenBat *object)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (object);
  GVariant *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties->values[2]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static GVariant *
foo_igen_bat_skeleton_get_force_struct (FooiGenBat *object)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (object);
  GVariant *value;
  g_mutex_lock (skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties->values[3]));
  g_mutex_unlock (skeleton->priv->lock);
  return value;
}

static void
foo_igen_bat_skeleton_class_init (FooiGenBatSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooiGenBatSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_bat_skeleton_finalize;
  gobject_class->get_property = foo_igen_bat_skeleton_get_property;
  gobject_class->set_property = foo_igen_bat_skeleton_set_property;
  gobject_class->notify       = foo_igen_bat_skeleton_notify;


  foo_igen_bat_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_bat_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_bat_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_bat_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_bat_skeleton_dbus_interface_get_vtable;
}

static void
foo_igen_bat_skeleton_iface_init (FooiGenBatIface *iface)
{
  iface->force_signal = _foo_igen_bat_on_signal_force_signal;
  iface->get_force_i = foo_igen_bat_skeleton_get_force_i;
  iface->get_force_s = foo_igen_bat_skeleton_get_force_s;
  iface->get_force_ay = foo_igen_bat_skeleton_get_force_ay;
  iface->get_force_struct = foo_igen_bat_skeleton_get_force_struct;
}

/**
 * foo_igen_bat_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link>.
 *
 * Returns: (transfer full) (type FooiGenBatSkeleton): The skeleton object.
 */
FooiGenBat *
foo_igen_bat_skeleton_new (void)
{
  return FOO_IGEN_BAT (g_object_new (FOO_IGEN_TYPE_BAT_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.Authorize
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenAuthorize
 * @title: FooiGenAuthorize
 * @short_description: Generated C code for the org.project.Authorize D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.Authorize ---- */

static const _ExtendedGDBusMethodInfo _foo_igen_authorize_method_info_check_not_authorized =
{
  {
    -1,
    "CheckNotAuthorized",
    NULL,
    NULL,
    NULL
  },
  "handle-check-not-authorized",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_authorize_method_info_check_authorized =
{
  {
    -1,
    "CheckAuthorized",
    NULL,
    NULL,
    NULL
  },
  "handle-check-authorized",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_authorize_method_info_check_not_authorized_from_object =
{
  {
    -1,
    "CheckNotAuthorizedFromObject",
    NULL,
    NULL,
    NULL
  },
  "handle-check-not-authorized-from-object",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_authorize_method_info_pointers[] =
{
  &_foo_igen_authorize_method_info_check_not_authorized,
  &_foo_igen_authorize_method_info_check_authorized,
  &_foo_igen_authorize_method_info_check_not_authorized_from_object,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_authorize_interface_info =
{
  {
    -1,
    "org.project.Authorize",
    (GDBusMethodInfo **) &_foo_igen_authorize_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "authorize",
};


/**
 * foo_igen_authorize_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_authorize_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_authorize_interface_info;
}

/**
 * foo_igen_authorize_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenAuthorize interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_authorize_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * FooiGenAuthorize:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link>.
 */

/**
 * FooiGenAuthorizeIface:
 * @parent_iface: The parent interface.
 * @handle_check_authorized: Handler for the #FooiGenAuthorize::handle-check-authorized signal.
 * @handle_check_not_authorized: Handler for the #FooiGenAuthorize::handle-check-not-authorized signal.
 * @handle_check_not_authorized_from_object: Handler for the #FooiGenAuthorize::handle-check-not-authorized-from-object signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link>.
 */

static void
foo_igen_authorize_default_init (FooiGenAuthorizeIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenAuthorize::handle-check-not-authorized:
   * @object: A #FooiGenAuthorize.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorized">CheckNotAuthorized()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_authorize_complete_check_not_authorized() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-check-not-authorized",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenAuthorizeIface, handle_check_not_authorized),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenAuthorize::handle-check-authorized:
   * @object: A #FooiGenAuthorize.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Authorize.CheckAuthorized">CheckAuthorized()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_authorize_complete_check_authorized() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-check-authorized",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenAuthorizeIface, handle_check_authorized),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenAuthorize::handle-check-not-authorized-from-object:
   * @object: A #FooiGenAuthorize.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorizedFromObject">CheckNotAuthorizedFromObject()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_authorize_complete_check_not_authorized_from_object() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-check-not-authorized-from-object",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenAuthorizeIface, handle_check_not_authorized_from_object),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

}

typedef FooiGenAuthorizeIface FooiGenAuthorizeInterface;
G_DEFINE_INTERFACE (FooiGenAuthorize, foo_igen_authorize, G_TYPE_OBJECT);

/**
 * foo_igen_authorize_call_check_not_authorized:
 * @proxy: A #FooiGenAuthorizeProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorized">CheckNotAuthorized()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_authorize_call_check_not_authorized_finish() to get the result of the operation.
 *
 * See foo_igen_authorize_call_check_not_authorized_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_authorize_call_check_not_authorized (
    FooiGenAuthorize *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "CheckNotAuthorized",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_authorize_call_check_not_authorized_finish:
 * @proxy: A #FooiGenAuthorizeProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_authorize_call_check_not_authorized().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_authorize_call_check_not_authorized().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_authorize_call_check_not_authorized_finish (
    FooiGenAuthorize *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_authorize_call_check_not_authorized_sync:
 * @proxy: A #FooiGenAuthorizeProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorized">CheckNotAuthorized()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_authorize_call_check_not_authorized() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_authorize_call_check_not_authorized_sync (
    FooiGenAuthorize *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "CheckNotAuthorized",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_authorize_call_check_authorized:
 * @proxy: A #FooiGenAuthorizeProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Authorize.CheckAuthorized">CheckAuthorized()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_authorize_call_check_authorized_finish() to get the result of the operation.
 *
 * See foo_igen_authorize_call_check_authorized_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_authorize_call_check_authorized (
    FooiGenAuthorize *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "CheckAuthorized",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_authorize_call_check_authorized_finish:
 * @proxy: A #FooiGenAuthorizeProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_authorize_call_check_authorized().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_authorize_call_check_authorized().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_authorize_call_check_authorized_finish (
    FooiGenAuthorize *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_authorize_call_check_authorized_sync:
 * @proxy: A #FooiGenAuthorizeProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Authorize.CheckAuthorized">CheckAuthorized()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_authorize_call_check_authorized() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_authorize_call_check_authorized_sync (
    FooiGenAuthorize *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "CheckAuthorized",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_authorize_call_check_not_authorized_from_object:
 * @proxy: A #FooiGenAuthorizeProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorizedFromObject">CheckNotAuthorizedFromObject()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_authorize_call_check_not_authorized_from_object_finish() to get the result of the operation.
 *
 * See foo_igen_authorize_call_check_not_authorized_from_object_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_authorize_call_check_not_authorized_from_object (
    FooiGenAuthorize *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "CheckNotAuthorizedFromObject",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_authorize_call_check_not_authorized_from_object_finish:
 * @proxy: A #FooiGenAuthorizeProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_authorize_call_check_not_authorized_from_object().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_authorize_call_check_not_authorized_from_object().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_authorize_call_check_not_authorized_from_object_finish (
    FooiGenAuthorize *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_authorize_call_check_not_authorized_from_object_sync:
 * @proxy: A #FooiGenAuthorizeProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorizedFromObject">CheckNotAuthorizedFromObject()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_authorize_call_check_not_authorized_from_object() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_authorize_call_check_not_authorized_from_object_sync (
    FooiGenAuthorize *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "CheckNotAuthorizedFromObject",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_authorize_complete_check_not_authorized:
 * @object: A #FooiGenAuthorize.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorized">CheckNotAuthorized()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_authorize_complete_check_not_authorized (
    FooiGenAuthorize *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_authorize_complete_check_authorized:
 * @object: A #FooiGenAuthorize.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Authorize.CheckAuthorized">CheckAuthorized()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_authorize_complete_check_authorized (
    FooiGenAuthorize *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_authorize_complete_check_not_authorized_from_object:
 * @object: A #FooiGenAuthorize.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorizedFromObject">CheckNotAuthorizedFromObject()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_authorize_complete_check_not_authorized_from_object (
    FooiGenAuthorize *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenAuthorizeProxy:
 *
 * The #FooiGenAuthorizeProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenAuthorizeProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenAuthorizeProxy.
 */

struct _FooiGenAuthorizeProxyPrivate
{
  GData *qdata;
};

static void foo_igen_authorize_proxy_iface_init (FooiGenAuthorizeIface *iface);

G_DEFINE_TYPE_WITH_CODE (FooiGenAuthorizeProxy, foo_igen_authorize_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_AUTHORIZE, foo_igen_authorize_proxy_iface_init));

static void
foo_igen_authorize_proxy_finalize (GObject *object)
{
  FooiGenAuthorizeProxy *proxy = FOO_IGEN_AUTHORIZE_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_authorize_proxy_parent_class)->finalize (object);
}

static void
foo_igen_authorize_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
foo_igen_authorize_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
foo_igen_authorize_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_authorize_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_AUTHORIZE);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_AUTHORIZE);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_authorize_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenAuthorizeProxy *proxy = FOO_IGEN_AUTHORIZE_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_authorize_interface_info, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_authorize_interface_info, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_igen_authorize_proxy_init (FooiGenAuthorizeProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_AUTHORIZE_PROXY, FooiGenAuthorizeProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_authorize_interface_info ());
}

static void
foo_igen_authorize_proxy_class_init (FooiGenAuthorizeProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (FooiGenAuthorizeProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_authorize_proxy_finalize;
  gobject_class->get_property = foo_igen_authorize_proxy_get_property;
  gobject_class->set_property = foo_igen_authorize_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_authorize_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_authorize_proxy_g_properties_changed;

}

static void
foo_igen_authorize_proxy_iface_init (FooiGenAuthorizeIface *iface)
{
}

/**
 * foo_igen_authorize_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_authorize_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_authorize_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_authorize_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_AUTHORIZE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Authorize", NULL);
}

/**
 * foo_igen_authorize_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_authorize_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_authorize_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenAuthorizeProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenAuthorize *
foo_igen_authorize_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_AUTHORIZE (ret);
  else
    return NULL;
}

/**
 * foo_igen_authorize_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_authorize_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenAuthorizeProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenAuthorize *
foo_igen_authorize_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_AUTHORIZE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Authorize", NULL);
  if (ret != NULL)
    return FOO_IGEN_AUTHORIZE (ret);
  else
    return NULL;
}


/**
 * foo_igen_authorize_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_authorize_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_authorize_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_authorize_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_authorize_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_AUTHORIZE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Authorize", NULL);
}

/**
 * foo_igen_authorize_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_authorize_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_authorize_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenAuthorizeProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenAuthorize *
foo_igen_authorize_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_AUTHORIZE (ret);
  else
    return NULL;
}

/**
 * foo_igen_authorize_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_authorize_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_authorize_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenAuthorizeProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenAuthorize *
foo_igen_authorize_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_AUTHORIZE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Authorize", NULL);
  if (ret != NULL)
    return FOO_IGEN_AUTHORIZE (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenAuthorizeSkeleton:
 *
 * The #FooiGenAuthorizeSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenAuthorizeSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenAuthorizeSkeleton.
 */

struct _FooiGenAuthorizeSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_igen_authorize_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenAuthorizeSkeleton *skeleton = FOO_IGEN_AUTHORIZE_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_AUTHORIZE);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_AUTHORIZE);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_authorize_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenAuthorizeSkeleton *skeleton = FOO_IGEN_AUTHORIZE_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_authorize_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_authorize_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenAuthorizeSkeleton *skeleton = FOO_IGEN_AUTHORIZE_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_authorize_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_authorize_skeleton_vtable =
{
  _foo_igen_authorize_skeleton_handle_method_call,
  _foo_igen_authorize_skeleton_handle_get_property,
  _foo_igen_authorize_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_igen_authorize_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_igen_authorize_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_authorize_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_igen_authorize_skeleton_vtable;
}

static GVariant *
foo_igen_authorize_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenAuthorizeSkeleton *skeleton = FOO_IGEN_AUTHORIZE_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_authorize_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_authorize_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_authorize_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_authorize_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Authorize", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_igen_authorize_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void foo_igen_authorize_skeleton_iface_init (FooiGenAuthorizeIface *iface);
G_DEFINE_TYPE_WITH_CODE (FooiGenAuthorizeSkeleton, foo_igen_authorize_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_AUTHORIZE, foo_igen_authorize_skeleton_iface_init));

static void
foo_igen_authorize_skeleton_finalize (GObject *object)
{
  FooiGenAuthorizeSkeleton *skeleton = FOO_IGEN_AUTHORIZE_SKELETON (object);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_authorize_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_authorize_skeleton_init (FooiGenAuthorizeSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_AUTHORIZE_SKELETON, FooiGenAuthorizeSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
}

static void
foo_igen_authorize_skeleton_class_init (FooiGenAuthorizeSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooiGenAuthorizeSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_authorize_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_authorize_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_authorize_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_authorize_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_authorize_skeleton_dbus_interface_get_vtable;
}

static void
foo_igen_authorize_skeleton_iface_init (FooiGenAuthorizeIface *iface)
{
}

/**
 * foo_igen_authorize_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link>.
 *
 * Returns: (transfer full) (type FooiGenAuthorizeSkeleton): The skeleton object.
 */
FooiGenAuthorize *
foo_igen_authorize_skeleton_new (void)
{
  return FOO_IGEN_AUTHORIZE (g_object_new (FOO_IGEN_TYPE_AUTHORIZE_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.MethodThreads
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenMethodThreads
 * @title: FooiGenMethodThreads
 * @short_description: Generated C code for the org.project.MethodThreads D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.MethodThreads ---- */

static const _ExtendedGDBusArgInfo _foo_igen_method_threads_method_info_get_self_OUT_ARG_self_pointer =
{
  {
    -1,
    "self_pointer",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_method_threads_method_info_get_self_OUT_ARG_pointers[] =
{
  &_foo_igen_method_threads_method_info_get_self_OUT_ARG_self_pointer,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_method_threads_method_info_get_self =
{
  {
    -1,
    "GetSelf",
    NULL,
    (GDBusArgInfo **) &_foo_igen_method_threads_method_info_get_self_OUT_ARG_pointers,
    NULL
  },
  "handle-get-self",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_method_threads_method_info_pointers[] =
{
  &_foo_igen_method_threads_method_info_get_self,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_method_threads_interface_info =
{
  {
    -1,
    "org.project.MethodThreads",
    (GDBusMethodInfo **) &_foo_igen_method_threads_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "method-threads",
};


/**
 * foo_igen_method_threads_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_method_threads_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_method_threads_interface_info;
}

/**
 * foo_igen_method_threads_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenMethodThreads interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_method_threads_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * FooiGenMethodThreads:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link>.
 */

/**
 * FooiGenMethodThreadsIface:
 * @parent_iface: The parent interface.
 * @handle_get_self: Handler for the #FooiGenMethodThreads::handle-get-self signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link>.
 */

static void
foo_igen_method_threads_default_init (FooiGenMethodThreadsIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenMethodThreads::handle-get-self:
   * @object: A #FooiGenMethodThreads.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-MethodThreads.GetSelf">GetSelf()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_method_threads_complete_get_self() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-self",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenMethodThreadsIface, handle_get_self),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

}

typedef FooiGenMethodThreadsIface FooiGenMethodThreadsInterface;
G_DEFINE_INTERFACE (FooiGenMethodThreads, foo_igen_method_threads, G_TYPE_OBJECT);

/**
 * foo_igen_method_threads_call_get_self:
 * @proxy: A #FooiGenMethodThreadsProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-MethodThreads.GetSelf">GetSelf()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_method_threads_call_get_self_finish() to get the result of the operation.
 *
 * See foo_igen_method_threads_call_get_self_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_method_threads_call_get_self (
    FooiGenMethodThreads *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "GetSelf",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_method_threads_call_get_self_finish:
 * @proxy: A #FooiGenMethodThreadsProxy.
 * @out_self_pointer: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_method_threads_call_get_self().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_method_threads_call_get_self().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_method_threads_call_get_self_finish (
    FooiGenMethodThreads *proxy,
    gchar **out_self_pointer,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_self_pointer);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_method_threads_call_get_self_sync:
 * @proxy: A #FooiGenMethodThreadsProxy.
 * @out_self_pointer: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-MethodThreads.GetSelf">GetSelf()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_method_threads_call_get_self() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_method_threads_call_get_self_sync (
    FooiGenMethodThreads *proxy,
    gchar **out_self_pointer,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "GetSelf",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_self_pointer);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_method_threads_complete_get_self:
 * @object: A #FooiGenMethodThreads.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @self_pointer: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-MethodThreads.GetSelf">GetSelf()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_method_threads_complete_get_self (
    FooiGenMethodThreads *object,
    GDBusMethodInvocation *invocation,
    const gchar *self_pointer)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   self_pointer));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenMethodThreadsProxy:
 *
 * The #FooiGenMethodThreadsProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenMethodThreadsProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenMethodThreadsProxy.
 */

struct _FooiGenMethodThreadsProxyPrivate
{
  GData *qdata;
};

static void foo_igen_method_threads_proxy_iface_init (FooiGenMethodThreadsIface *iface);

G_DEFINE_TYPE_WITH_CODE (FooiGenMethodThreadsProxy, foo_igen_method_threads_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_METHOD_THREADS, foo_igen_method_threads_proxy_iface_init));

static void
foo_igen_method_threads_proxy_finalize (GObject *object)
{
  FooiGenMethodThreadsProxy *proxy = FOO_IGEN_METHOD_THREADS_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_method_threads_proxy_parent_class)->finalize (object);
}

static void
foo_igen_method_threads_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
foo_igen_method_threads_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
foo_igen_method_threads_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_method_threads_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_METHOD_THREADS);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_METHOD_THREADS);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_method_threads_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenMethodThreadsProxy *proxy = FOO_IGEN_METHOD_THREADS_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_method_threads_interface_info, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_method_threads_interface_info, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_igen_method_threads_proxy_init (FooiGenMethodThreadsProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_METHOD_THREADS_PROXY, FooiGenMethodThreadsProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_method_threads_interface_info ());
}

static void
foo_igen_method_threads_proxy_class_init (FooiGenMethodThreadsProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (FooiGenMethodThreadsProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_method_threads_proxy_finalize;
  gobject_class->get_property = foo_igen_method_threads_proxy_get_property;
  gobject_class->set_property = foo_igen_method_threads_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_method_threads_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_method_threads_proxy_g_properties_changed;

}

static void
foo_igen_method_threads_proxy_iface_init (FooiGenMethodThreadsIface *iface)
{
}

/**
 * foo_igen_method_threads_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_method_threads_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_method_threads_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_method_threads_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_METHOD_THREADS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.MethodThreads", NULL);
}

/**
 * foo_igen_method_threads_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_method_threads_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_method_threads_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenMethodThreadsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenMethodThreads *
foo_igen_method_threads_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_METHOD_THREADS (ret);
  else
    return NULL;
}

/**
 * foo_igen_method_threads_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_method_threads_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenMethodThreadsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenMethodThreads *
foo_igen_method_threads_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_METHOD_THREADS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.MethodThreads", NULL);
  if (ret != NULL)
    return FOO_IGEN_METHOD_THREADS (ret);
  else
    return NULL;
}


/**
 * foo_igen_method_threads_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_method_threads_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_method_threads_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_method_threads_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_method_threads_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_METHOD_THREADS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.MethodThreads", NULL);
}

/**
 * foo_igen_method_threads_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_method_threads_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_method_threads_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenMethodThreadsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenMethodThreads *
foo_igen_method_threads_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_METHOD_THREADS (ret);
  else
    return NULL;
}

/**
 * foo_igen_method_threads_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_method_threads_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_method_threads_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenMethodThreadsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenMethodThreads *
foo_igen_method_threads_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_METHOD_THREADS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.MethodThreads", NULL);
  if (ret != NULL)
    return FOO_IGEN_METHOD_THREADS (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenMethodThreadsSkeleton:
 *
 * The #FooiGenMethodThreadsSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenMethodThreadsSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenMethodThreadsSkeleton.
 */

struct _FooiGenMethodThreadsSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_igen_method_threads_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenMethodThreadsSkeleton *skeleton = FOO_IGEN_METHOD_THREADS_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_METHOD_THREADS);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_METHOD_THREADS);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_method_threads_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenMethodThreadsSkeleton *skeleton = FOO_IGEN_METHOD_THREADS_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_method_threads_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_method_threads_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenMethodThreadsSkeleton *skeleton = FOO_IGEN_METHOD_THREADS_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_method_threads_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_method_threads_skeleton_vtable =
{
  _foo_igen_method_threads_skeleton_handle_method_call,
  _foo_igen_method_threads_skeleton_handle_get_property,
  _foo_igen_method_threads_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_igen_method_threads_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_igen_method_threads_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_method_threads_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_igen_method_threads_skeleton_vtable;
}

static GVariant *
foo_igen_method_threads_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenMethodThreadsSkeleton *skeleton = FOO_IGEN_METHOD_THREADS_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_method_threads_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_method_threads_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_method_threads_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_method_threads_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.MethodThreads", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_igen_method_threads_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void foo_igen_method_threads_skeleton_iface_init (FooiGenMethodThreadsIface *iface);
G_DEFINE_TYPE_WITH_CODE (FooiGenMethodThreadsSkeleton, foo_igen_method_threads_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_METHOD_THREADS, foo_igen_method_threads_skeleton_iface_init));

static void
foo_igen_method_threads_skeleton_finalize (GObject *object)
{
  FooiGenMethodThreadsSkeleton *skeleton = FOO_IGEN_METHOD_THREADS_SKELETON (object);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_method_threads_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_method_threads_skeleton_init (FooiGenMethodThreadsSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_METHOD_THREADS_SKELETON, FooiGenMethodThreadsSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
}

static void
foo_igen_method_threads_skeleton_class_init (FooiGenMethodThreadsSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooiGenMethodThreadsSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_method_threads_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_method_threads_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_method_threads_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_method_threads_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_method_threads_skeleton_dbus_interface_get_vtable;
}

static void
foo_igen_method_threads_skeleton_iface_init (FooiGenMethodThreadsIface *iface)
{
}

/**
 * foo_igen_method_threads_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link>.
 *
 * Returns: (transfer full) (type FooiGenMethodThreadsSkeleton): The skeleton object.
 */
FooiGenMethodThreads *
foo_igen_method_threads_skeleton_new (void)
{
  return FOO_IGEN_METHOD_THREADS (g_object_new (FOO_IGEN_TYPE_METHOD_THREADS_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.InlineDocs
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenInlineDocs
 * @title: FooiGenInlineDocs
 * @short_description: Generated C code for the org.project.InlineDocs D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.InlineDocs ---- */

static const _ExtendedGDBusArgInfo _foo_igen_inline_docs_method_info_foo_method_IN_ARG_greeting =
{
  {
    -1,
    "greeting",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_inline_docs_method_info_foo_method_IN_ARG_pointers[] =
{
  &_foo_igen_inline_docs_method_info_foo_method_IN_ARG_greeting,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_inline_docs_method_info_foo_method_OUT_ARG_response =
{
  {
    -1,
    "response",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_inline_docs_method_info_foo_method_OUT_ARG_pointers[] =
{
  &_foo_igen_inline_docs_method_info_foo_method_OUT_ARG_response,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_inline_docs_method_info_foo_method =
{
  {
    -1,
    "FooMethod",
    (GDBusArgInfo **) &_foo_igen_inline_docs_method_info_foo_method_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_igen_inline_docs_method_info_foo_method_OUT_ARG_pointers,
    NULL
  },
  "handle-foo-method",
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_inline_docs_method_info_method2_IN_ARG_greeting =
{
  {
    -1,
    "greeting",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_inline_docs_method_info_method2_IN_ARG_pointers[] =
{
  &_foo_igen_inline_docs_method_info_method2_IN_ARG_greeting,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_inline_docs_method_info_method2_OUT_ARG_response =
{
  {
    -1,
    "response",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_inline_docs_method_info_method2_OUT_ARG_pointers[] =
{
  &_foo_igen_inline_docs_method_info_method2_OUT_ARG_response,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_inline_docs_method_info_method2 =
{
  {
    -1,
    "Method2",
    (GDBusArgInfo **) &_foo_igen_inline_docs_method_info_method2_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_igen_inline_docs_method_info_method2_OUT_ARG_pointers,
    NULL
  },
  "handle-method2",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_inline_docs_method_info_pointers[] =
{
  &_foo_igen_inline_docs_method_info_foo_method,
  &_foo_igen_inline_docs_method_info_method2,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_inline_docs_signal_info_bar_signal_ARG_blah =
{
  {
    -1,
    "blah",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_inline_docs_signal_info_bar_signal_ARG_boo =
{
  {
    -1,
    "boo",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_inline_docs_signal_info_bar_signal_ARG_pointers[] =
{
  &_foo_igen_inline_docs_signal_info_bar_signal_ARG_blah,
  &_foo_igen_inline_docs_signal_info_bar_signal_ARG_boo,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_igen_inline_docs_signal_info_bar_signal =
{
  {
    -1,
    "BarSignal",
    (GDBusArgInfo **) &_foo_igen_inline_docs_signal_info_bar_signal_ARG_pointers,
    NULL
  },
  "bar-signal"
};

static const _ExtendedGDBusSignalInfo * const _foo_igen_inline_docs_signal_info_pointers[] =
{
  &_foo_igen_inline_docs_signal_info_bar_signal,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_igen_inline_docs_property_info_baz_property =
{
  {
    -1,
    "BazProperty",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "baz-property",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_inline_docs_property_info_property2 =
{
  {
    -1,
    "Property2",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "property2",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_inline_docs_property_info_property3 =
{
  {
    -1,
    "Property3",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "property3",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_inline_docs_property_info_property4 =
{
  {
    -1,
    "Property4",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "property4",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_inline_docs_property_info_property5 =
{
  {
    -1,
    "Property5",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "property5",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_inline_docs_property_info_fancy_property =
{
  {
    -1,
    "FancyProperty",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "fancy-property",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_igen_inline_docs_property_info_pointers[] =
{
  &_foo_igen_inline_docs_property_info_baz_property,
  &_foo_igen_inline_docs_property_info_property2,
  &_foo_igen_inline_docs_property_info_property3,
  &_foo_igen_inline_docs_property_info_property4,
  &_foo_igen_inline_docs_property_info_property5,
  &_foo_igen_inline_docs_property_info_fancy_property,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_inline_docs_interface_info =
{
  {
    -1,
    "org.project.InlineDocs",
    (GDBusMethodInfo **) &_foo_igen_inline_docs_method_info_pointers,
    (GDBusSignalInfo **) &_foo_igen_inline_docs_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_igen_inline_docs_property_info_pointers,
    NULL
  },
  "inline-docs",
};


/**
 * foo_igen_inline_docs_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_inline_docs_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_inline_docs_interface_info;
}

/**
 * foo_igen_inline_docs_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenInlineDocs interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_inline_docs_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "baz-property");
  g_object_class_override_property (klass, property_id_begin++, "property2");
  g_object_class_override_property (klass, property_id_begin++, "property3");
  g_object_class_override_property (klass, property_id_begin++, "property4");
  g_object_class_override_property (klass, property_id_begin++, "property5");
  g_object_class_override_property (klass, property_id_begin++, "fancy-property");
  return property_id_begin - 1;
}



/**
 * FooiGenInlineDocs:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link>.
 */

/**
 * FooiGenInlineDocsIface:
 * @parent_iface: The parent interface.
 * @handle_foo_method: Handler for the #FooiGenInlineDocs::handle-foo-method signal.
 * @handle_method2: Handler for the #FooiGenInlineDocs::handle-method2 signal.
 * @get_baz_property: Getter for the #FooiGenInlineDocs:baz-property property.
 * @get_fancy_property: Getter for the #FooiGenInlineDocs:fancy-property property.
 * @get_property2: Getter for the #FooiGenInlineDocs:property2 property.
 * @get_property3: Getter for the #FooiGenInlineDocs:property3 property.
 * @get_property4: Getter for the #FooiGenInlineDocs:property4 property.
 * @get_property5: Getter for the #FooiGenInlineDocs:property5 property.
 * @bar_signal: Handler for the #FooiGenInlineDocs::bar-signal signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link>.
 */

static void
foo_igen_inline_docs_default_init (FooiGenInlineDocsIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenInlineDocs::handle-foo-method:
   * @object: A #FooiGenInlineDocs.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_greeting: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-InlineDocs.FooMethod">FooMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_inline_docs_complete_foo_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-foo-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenInlineDocsIface, handle_foo_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * FooiGenInlineDocs::handle-method2:
   * @object: A #FooiGenInlineDocs.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_greeting: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-InlineDocs.Method2">Method2()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_inline_docs_complete_method2() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-method2",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenInlineDocsIface, handle_method2),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooiGenInlineDocs::bar-signal:
   * @object: A #FooiGenInlineDocs.
   * @arg_blah: Argument.
   * @arg_boo: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-project-InlineDocs.BarSignal">"BarSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("bar-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenInlineDocsIface, bar_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    2, G_TYPE_STRING, G_TYPE_STRING);

  /* GObject properties for D-Bus properties: */
  /**
   * FooiGenInlineDocs:baz-property:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-InlineDocs.BazProperty">"BazProperty"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("baz-property", "BazProperty", "BazProperty", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenInlineDocs:property2:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-InlineDocs.Property2">"Property2"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("property2", "Property2", "Property2", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenInlineDocs:property3:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-InlineDocs.Property3">"Property3"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("property3", "Property3", "Property3", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenInlineDocs:property4:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-InlineDocs.Property4">"Property4"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("property4", "Property4", "Property4", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenInlineDocs:property5:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-InlineDocs.Property5">"Property5"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("property5", "Property5", "Property5", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenInlineDocs:fancy-property:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-InlineDocs.FancyProperty">"FancyProperty"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("fancy-property", "FancyProperty", "FancyProperty", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

typedef FooiGenInlineDocsIface FooiGenInlineDocsInterface;
G_DEFINE_INTERFACE (FooiGenInlineDocs, foo_igen_inline_docs, G_TYPE_OBJECT);

/**
 * foo_igen_inline_docs_get_baz_property: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-InlineDocs.BazProperty">"BazProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_inline_docs_dup_baz_property() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_inline_docs_get_baz_property (FooiGenInlineDocs *object)
{
  return FOO_IGEN_INLINE_DOCS_GET_IFACE (object)->get_baz_property (object);
}

/**
 * foo_igen_inline_docs_dup_baz_property: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-InlineDocs.BazProperty">"BazProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_inline_docs_dup_baz_property (FooiGenInlineDocs *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "baz-property", &value, NULL);
  return value;
}

/**
 * foo_igen_inline_docs_set_baz_property: (skip)
 * @object: A #FooiGenInlineDocs.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-InlineDocs.BazProperty">"BazProperty"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_inline_docs_set_baz_property (FooiGenInlineDocs *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "baz-property", value, NULL);
}

/**
 * foo_igen_inline_docs_get_property2: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-InlineDocs.Property2">"Property2"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_inline_docs_dup_property2() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_inline_docs_get_property2 (FooiGenInlineDocs *object)
{
  return FOO_IGEN_INLINE_DOCS_GET_IFACE (object)->get_property2 (object);
}

/**
 * foo_igen_inline_docs_dup_property2: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-InlineDocs.Property2">"Property2"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_inline_docs_dup_property2 (FooiGenInlineDocs *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "property2", &value, NULL);
  return value;
}

/**
 * foo_igen_inline_docs_set_property2: (skip)
 * @object: A #FooiGenInlineDocs.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-InlineDocs.Property2">"Property2"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_inline_docs_set_property2 (FooiGenInlineDocs *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "property2", value, NULL);
}

/**
 * foo_igen_inline_docs_get_property3: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-InlineDocs.Property3">"Property3"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_inline_docs_dup_property3() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_inline_docs_get_property3 (FooiGenInlineDocs *object)
{
  return FOO_IGEN_INLINE_DOCS_GET_IFACE (object)->get_property3 (object);
}

/**
 * foo_igen_inline_docs_dup_property3: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-InlineDocs.Property3">"Property3"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_inline_docs_dup_property3 (FooiGenInlineDocs *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "property3", &value, NULL);
  return value;
}

/**
 * foo_igen_inline_docs_set_property3: (skip)
 * @object: A #FooiGenInlineDocs.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-InlineDocs.Property3">"Property3"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_inline_docs_set_property3 (FooiGenInlineDocs *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "property3", value, NULL);
}

/**
 * foo_igen_inline_docs_get_property4: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-InlineDocs.Property4">"Property4"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_inline_docs_dup_property4() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_inline_docs_get_property4 (FooiGenInlineDocs *object)
{
  return FOO_IGEN_INLINE_DOCS_GET_IFACE (object)->get_property4 (object);
}

/**
 * foo_igen_inline_docs_dup_property4: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-InlineDocs.Property4">"Property4"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_inline_docs_dup_property4 (FooiGenInlineDocs *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "property4", &value, NULL);
  return value;
}

/**
 * foo_igen_inline_docs_set_property4: (skip)
 * @object: A #FooiGenInlineDocs.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-InlineDocs.Property4">"Property4"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_inline_docs_set_property4 (FooiGenInlineDocs *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "property4", value, NULL);
}

/**
 * foo_igen_inline_docs_get_property5: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-InlineDocs.Property5">"Property5"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_inline_docs_dup_property5() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_inline_docs_get_property5 (FooiGenInlineDocs *object)
{
  return FOO_IGEN_INLINE_DOCS_GET_IFACE (object)->get_property5 (object);
}

/**
 * foo_igen_inline_docs_dup_property5: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-InlineDocs.Property5">"Property5"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this functi