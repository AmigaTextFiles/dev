@DATABASE  CommonFuncs.guide
@REM Source: CommonFuncs.c
@$VER: CommonFuncs.guide V3.4 (31-Jan-2005) by J.T. Steichen
@(C) CopyRight (C)2005 by J.T. Steichen, All Rights Reserved.
 
@NODE "toc" "CommonFuncs.guide"
@{JCENTER}
    @{fg highlight}@{b}TABLE OF CONTENTS@{ub}@{fg text}@{JLEFT}

   @{" Purpose   " LINK "MAIN"} -- Main node

   @{" Byt2Str()           " LINK "Byt2Str()"}
   @{" CFFindMenuPtr()     " LINK "CFFindMenuPtr()"}
   @{" CloseLibs()         " LINK "CloseLibs()"}
   @{" ComputeFont()       " LINK "ComputeFont()"}
   @{" ComputeY()          " LINK "ComputeY()"}
   @{" ComputeX()          " LINK "ComputeX()"}
   @{" DisplayTitle()      " LINK "DisplayTitle()"}
   @{" drawArc()           " LINK "drawArc()"}
   @{" FGetS()             " LINK "FGetS()"}
   @{" File_DirReq()       " LINK "File_DirReq()"}
   @{" FileReq()           " LINK "FileReq()"}
   @{" FindIcon()          " LINK "FindIcon()"}
   @{" FindTools()         " LINK "FindTools()"}
   @{" FontXDim()          " LINK "FontXDim()"}
   @{" GetActiveScreen()   " LINK "GetActiveScreen()"}
   @{" GetActiveWindow()   " LINK "GetActiveWindow()"}
   @{" GetPathName()       " LINK "GetPathName()"}
   @{" getScreenModeID()   " LINK "getScreenModeID()"}
   @{" GetToolBoolean()    " LINK "GetToolBoolean()"}
   @{" GetToolInt()        " LINK "GetToolInt()"}
   @{" GetToolStr()        " LINK "GetToolStr()"}
   @{" getUserFont()       " LINK "getUserFont()"}
   @{" GetUserResponse()   " LINK "GetUserResponse()"}
   @{" GetUserString()     " LINK "GetUserString()"}
   @{" Guarded_AllocLV()   " LINK "Guarded_AllocLV()"}
   @{" Guarded_FreeLV()    " LINK "Guarded_FreeLV()"}
   @{" Handle_Problem()    " LINK "Handle_Problem()"}
   @{" HideListFromView()  " LINK "HideListFromView()"}
   @{" HSV2RGB()           " LINK "HSV2RGB()"}
   @{" IsGadgetSelected()  " LINK "IsGadgetSelected()"}
   @{" IsMenuChecked()     " LINK "IsMenuChecked()"}
   @{" itoa()              " LINK "itoa()"}
   @{" MakeHexASCIIStr()   " LINK "MakeHexASCIIStr()"}
   @{" ModifyListView()    " LINK "ModifyListView()"}
   @{" NotifyUser()        " LINK "NotifyUser()"}
   @{" OpenLibs()          " LINK "OpenLibs()"}
   @{" ReportAllocLVError()" LINK "ReportAllocLVError()"}
   @{" RGB2HSV()           " LINK "RGB2HSV()"}
   @{" SanityCheck()       " LINK "SanityCheck()"}
   @{" SetNotifyWindow()   " LINK "SetNotifyWindow()"}
   @{" SetReqButtons()     " LINK "SetReqButtons()"}
   @{" SetTagItem()        " LINK "SetTagItem()"}
   @{" SetTagPair()        " LINK "SetTagPair()"}
   @{" SetupList()         " LINK "SetupList()"}
   @{" UserInfo()          " LINK "UserInfo()"}

@ENDNODE

@TOC "toc"

@NODE "MAIN" "CommonFuncs.c"
@{fg shine}CommonFuncs.c@{fg text}

@{b}NAME@{ub}
@{b}    @{b}CommonFuncs.c@{ub}

@{ub}
@{b}DESCRIPTION@{ub}
    Functions that get used a lot for GUI programming, especially for
    GadToolsBox-generated GUIs.  This file is used to generate 
    CommonFuncs.o - a Link-able Object for the SAS-C (V6.58) compiler, or
    CommonFuncsPPC.o - a Link-able Object for the gcc V2.95+ compiler.

    This a link-able object because there are far too many shared 
    libraries for the Amiga OS as it is, I couldn't see cluttering 
    someone's hard drive with another one (especially my own!).
@{FG SHINE}
    Any program that uses CommonFuncsPPC.o will have to declare @{B}
    struct Library        *GadToolsBase & 
    struct GadTaoolsIFace *IGadTools@{UB}, then open & close the gadtools.library
    (-lauto does NOT take care of gadtools.library for you!). @{FG TEXT}
    
    @{" Table of Contents " LINK "toc"}

@{b}HISTORY@{ub}
    31-Jan-2005 - Added GetUserString() Requester code (V3.4).

    24-Jan-2005 - Replaced all string.h functions with their
                  equivalent functions in libstringfuncs.a.

    21-Jan-2005 - Added OpenFile() & TrimSpaces() functions.
    14-Jan-2005 - Added IsGadgetSelected() & IsMenuChecked() functions. 
    20-Oct-2004 - All functions are now independent of the User
                  opening & closing the correct libraries for AmigaOS4.0.
    17-Oct-2004 - Added AmigaOS4.0 conditional support (via gcc)
    01-Oct-2003 - Added void strClear( char * ) function.L1054
    24-Sep-2003 - Added GetActiveWindow() calls to all the Requesters.
    09-Sep-2003 - Added the drawArc() function.
    09-Apr-2002 - Added the getUserFont() function.
    20-Mar-2002 - Added the GetActiveWindow() function.
    12-Jan-2002 - Added the CFFindMenuPtr() function.
    03-Oct-2001 - Added itoa() function.
    03-Apr-2001 - Added the SetupList() function.
    25-Sep-2000 - Added the GetActiveScreen() function.
    24-Sep-2000 - Added DisplayTitle() & UserInfo() functions.
    17-Sep-2000 - Added SetTagPair(), Guarded_FreeLV(), &
                  Guarded_AllocLV() functions.
    28-Aug-2000 - Added GetPathName() function.
    18-May-2000 - Added FontXDim() function.
    17-May-2000 - Added GetScreenModeID() function.
    19-Jan-2000 - Changed FileReq() to check for NULL parameter. 
                  Added File_DirReq() function.

@{b}AUTHOR@{ub}
@{b}    James T. Steichen
    2217 N. Tamarack Dr.
    Slayton, Mn. 56172-1155, USA
    jimbot\@frontiernet.net

@{ub}
@{b}NOTES@{ub}
@{b}@{fg shine}    $VER: @{b}CommonFuncs.c@{ub} 3.1 (14-Jan-2005) by J.T. Steichen

@{fg text}@{ub}
@{b}COPYRIGHT@{ub}
    @{b}CommonFuncs.c@{ub} & CommonFuncs.h (c) 1999-2005 by J.T. Steichen,
    All Rights Reserved.

@ENDNODE

@NODE "GetUserString()" "GetUserString()"

                          @{FG SHINE}GetUserString()@{FG TEXT} 

@{B}NAME
    GetUserString() @{UB}

@{B}DESCRIPTION@{UB}
    Ask the user to supply a string to the calling program, NULL if
    the User Cancels or enters a string with zero length.

@{B}SYNOPSIS @{UB}
    UBYTE *string = GetUserString( struct Window *parentW, UBYTE *msg, UBYTE *title );

@{B}INPUTS@{UB}
   parentW - Address of the parent window from the calling program.
   msg     - Inform the User what string to enter (Keep it short!).
   title   - Requester title string (Keep it short!).

@{B}RESULTS@{UB}
    This function returns the string the User entered, NULL if there's
    an ERROR or if the User did NOT enter a string.
@{FG SHINE}
@{B}WARNINGS@{UB} @{FG TEXT}
    This function uses functions located in link object -lstringfuncs
    for gcc.
    This function does NOT adjust the requester width if you enter 
    either a long msg or title & will clip them.

@ENDNODE

@NODE "IsGadgetSelected()" "IsGadgetSelected()"
@{FG SHINE}IsGadgetSelected()@{FG TEXT} 
@{B}NAME@{UB}
@{B}    IsGadgetSelected() @{UB}

@{B}SYNOPSIS@{UB}
    BOOL IsGadgetSelected( struct Gadget *g ); 

@{B}DESCRIPTION@{UB}
    Returns TRUE if the Gadget g is Selected/Checked, FALSE otherwise.

@{B}INPUTS@{UB}
    g     - Gadget structure pointer to examine.

@ENDNODE

@NODE "IsMenuChecked()" "IsMenuChecked()"
@{FG SHINE}IsMenuChecked()@{FG TEXT} 
@{B}NAME@{UB}
@{B}    IsMenuChecked() @{UB}

@{B}SYNOPSIS@{UB}
    BOOL IsMenuChecked( struct MenuItem *m ); 

@{B}DESCRIPTION@{UB}
    Returns TRUE if the MenuItem m is Checked, FALSE otherwise.

@{B}INPUTS@{UB}
    m     - MenuItem structure pointer to examine.

@ENDNODE

@NODE "drawArc()" "drawArc()"
@{FG SHINE}drawArc()@{FG TEXT} 
@{B}NAME@{UB}
@{B}    drawArc() @{UB}

@{B}SYNOPSIS@{UB}
    void drawArc( struct Window *w, int xs, int ys, float angle, int xc, int yc ); 

@{B}DESCRIPTION@{UB}
    Draw an Arc into the given Window using graphics functions.

@{B}INPUTS@{UB}
    w     - Window structure pointer.
    Xs    - starting Window Horizontal coordinate. 
    Ys    - starting Window Vertical   coordinate. 
    angle - the length of the arc in radians. 
    Xc    - the Horizontal coordinate of the arc pivot point.
    Yc    - the Vertical   coordinate of the arc pivot point.

@{B}WARNING@{UB}
    Be sure that GfxBase & Intuition are open BEFORE using this function.
    Set the drawing Pen(s), draw Mode & Line Pattern BEFORE using this function.

@ENDNODE

@NODE "ModifyListView()" "ModifyListView()"
@{fg shine}ModifyListView()@{fg text}

@{b}NAME@{ub}
@{b}    ModifyListView()

@{ub}
@{b}SYNOPSIS@{ub}
    void ModifyLsitView( struct Gadget *listview_gadget,
                         struct Window *window_pointer,
                         struct List   *listview_contents,
                         struct Gadget *string_gadget
                       ); 


@{b}DESCRIPTION@{ub}
    Change the Given ListView Gadget for the window to the 
    new parameters, which will re-display it.


@{b}SEE ALSO@{ub}
    HideListFromView()

@ENDNODE

@NODE "HideListFromView()" "HideListFromView()"
@{fg shine}HideListFromView()@{fg text}

@{b}NAME@{ub}
@{b}    HideListFromView()

@{ub}
@{b}SYNOPSIS@{ub}
    void HideListFromView( struct Gadget *listview_gadget,
                           struct Window *window_pointer
                         );


@{b}DESCRIPTION@{ub}
    Turn off the Given ListView Gadget for the window, so that it
    can be modified elsewhere.


@{b}SEE ALSO@{ub}
    ModifyListView()

@ENDNODE

@NODE "FGetS()" "FGetS()"
@{fg shine}FGetS()@{fg text}

@{b}NAME@{ub}
@{b}    FGetS()

@{ub}
@{b}SYNOPSIS@{ub}
    char *str = FGetS( char *buffer, int readlength, FILE *fptr );


@{b}DESCRIPTION@{ub}
    This function is identical to the C library function fgets()
    except that it changes the \\n at the end of a line to a \\0.

@ENDNODE

@NODE "SetTagPair()" "SetTagPair()"
@{fg shine}SetTagPair()@{fg text}

@{b}NAME@{ub}
@{b}    SetTagPair()

@{ub}
@{b}SYNOPSIS@{ub}
    void SetTagPair( struct TagItem *taglist, ULONG tag, ULONG value );


@{b}DESCRIPTION@{ub}
    Add a Tag & value to a TagItem list.  If taglist is NULL, 
    nothing is done by this function.
    This function completes the functionality for using TagLists.


@{b}NOTES@{ub}
@{b}@{fg shine}    taglist is really an array of ULONG values organized into pairs.

@{fg text}@{ub}
@{b}WARNINGS@{ub}
@{b}    No check is done to see if there is space in the Tag list
    for the added pair (so why not reserve space by using: 
    {TAG_IGNORE, NULL} in the taglist you provide?).
@{ub}
@ENDNODE

@NODE "SetTagItem()" "SetTagItem()"
@{fg shine}SetTagItem()@{fg text}

@{b}NAME@{ub}
@{b}    SetTagItem()

@{ub}
@{b}SYNOPSIS@{ub}
    void SetTagItem( struct TagItem *taglist, ULONG tag, ULONG value );


@{b}DESCRIPTION@{ub}
    This function searches the given taglist for the given tag.  If
    the tag is found, its value (ti_Data) is changed to the given
    value.  This function completes the functionality for using 
    TagLists.

@ENDNODE

@NODE "HSV2RGB()" "HSV2RGB()"
@{fg shine}HSV2RGB()@{fg text}

@{b}NAME@{ub}
@{b}    HSV2RGB()

@{ub}
@{b}SYNOPSIS@{ub}
    struct ColorCoords *ans = HSV2RGB( struct ColorCoords *input );


@{b}DESCRIPTION@{ub}
    Convert an HSV (Hue, Saturation & Luminance) coordinate into
    RGB (red, green & blue).


@{b}NOTES@{ub}
@{b}@{fg shine}    red, green & blue are values from 0 to 255 (normally).

@{fg text}@{ub}
@{b}WARNINGS@{ub}
@{b}    If you want the input structure for later, save it before
    passing it to this function, since it modifies it & returns it.

@{ub}
@ENDNODE

@NODE "RGB2HSV()" "RGB2HSV()"
@{fg shine}RGB2HSV()@{fg text}

@{b}NAME@{ub}
@{b}    RGB2HSV()

@{ub}
@{b}SYNOPSIS@{ub}
    struct ColorCoords *ans = RGB2HSV( struct ColorCoords *input );


@{b}DESCRIPTION@{ub}
    Convert an RGB color coordinate set into HSV (Hue,
    Saturation & Luminance).


@{b}NOTES@{ub}
@{b}@{fg shine}    red, green & blue are values from 0 to 255 (normally).

@{fg text}@{ub}
@{b}WARNINGS@{ub}
@{b}    If you want the input structure for later, save it before
    passing it to this function, since it modifies it & returns it.
@{ub}
@ENDNODE

@NODE "OpenLibs()" "OpenLibs()"
@{fg shine}OpenLibs()@{fg text}

@{b}NAME@{ub}
@{b}    OpenLibs()

@{ub}
@{b}SYNOPSIS@{ub}
    int result = OpenLibs( void );


@{b}DESCRIPTION@{ub}
    Open the three most-commonly used libraries (V39+) - 

       intuition.library, graphics.library & gadtools.library.


@{b}RETURN VALUE@{ub}
@{b}    Negative integer if a library could NOT be opened, zero if
    all was successful.
@{ub}
@ENDNODE

@NODE "CloseLibs()" "CloseLibs()"
@{fg shine}CloseLibs()@{fg text}

@{b}NAME@{ub}
@{b}    CloseLibs()

@{ub}
@{b}SYNOPSIS@{ub}
    void CloseLibs( void );


@{b}DESCRIPTION@{ub}
    Close the three most-commonly used libraries - 

       intuition.library, graphics.library & gadtools.library.

@ENDNODE

@NODE "FindIcon()" "FindIcon()"
@{fg shine}FindIcon()@{fg text}

@{b}NAME@{ub}
@{b}    FindIcon()

@{ub}
@{b}DESCRIPTION@{ub}
    Find the icon associated with pgmname (if any) & process the
    ToolTypes array in the icon with ToolProc().


@{b}SYNOPSIS@{ub}
    void *rval = FindIcon( void              *(ToolProc)(char **), 
                           struct DiskObject *dobj,
                           char              *pgmname
                         );


@{b}INPUTS@{ub}
    ToolProc() - a Pointer to a function that will perform an
                 operation on the ToolTypes array from the Icon
                 if the icon was found.

    dobj       - storage (for a later call to FreeDiskObject())

    pgmname    - The name of the icon to look for (without the
                 ".info" at the end of the string). 


@{b}NOTES@{ub}
@{b}@{fg shine}    If the user starts a program from the CLI, & the icon is in
    the same directory, we will get the ToolTypes from the icon
    instead of using the built-in defaults.
@{fg text}@{ub}
@ENDNODE

@NODE "GetToolBoolean()" "GetToolBoolean()"
@{fg shine}GetToolBoolean()@{fg text}

@{b}NAME@{ub}
@{b}    GetToolBoolean()

@{ub}
@{b}DESCRIPTION@{ub}
    Find the tooltype boolean that matches the given name.


@{b}SYNOPSIS@{ub}
    boolean ans = GetToolBoolean( char **toolptr,
                                  char  *name,
                                  int    defaultBool
                                );


@{b}INPUTS@{ub}
    toolptr     = pointer from FindTools() call.
    name        = tool we're searching the icon for.
    defaultBool = default boolean to return if the tool isn't found.


@{b}NOTES@{ub}
@{b}@{fg shine}    The following strings will return a Boolean value of TRUE:
        
        "TRUE", "YES", "OK" & "OKAY"

    any other value will return FALSE.
@{fg text}@{ub}
@ENDNODE

@NODE "GetToolInt()" "GetToolInt()"
@{fg shine}GetToolInt()@{fg text}

@{b}NAME@{ub}
@{b}    GetToolInt() 

@{ub}
@{b}DESCRIPTION@{ub}
    Find the tooltype integer that matches the given name.


@{b}SYNOPSIS@{ub}
    tool_int = GetToolInt( char **toolarray,
                           char  *toolname,
                           int    default_val
                         );


@{b}INPUTS@{ub}
    toolarray   = pointer from FindTools() call.
    toolname    = tool we're searching the icon for.
    default_val = default integer to return if the tool isn't found.

@ENDNODE

@NODE "GetToolStr()" "GetToolStr()"
@{fg shine}GetToolStr()@{fg text}

@{b}NAME@{ub}
@{b}    GetToolStr()

@{ub}
@{b}DESCRIPTION@{ub}
    Find the tooltype string that matches the given name.


@{b}SYNOPSIS@{ub}
    toolstring = GetToolStr( char **toolarray,
                             char  *toolname,
                             char  *default_tool
                           );


@{b}INPUTS@{ub}
    toolarray    = pointer from FindTools() call.
    toolname     = tool we're searching the icon for.
    default_tool = default string to return if the tool isn't found.

@ENDNODE

@NODE "FindTools()" "FindTools()"
@{fg shine}FindTools()@{fg text}

@{b}NAME@{ub}
@{b}    FindTools()
 
@{ub}
@{b}DESCRIPTION@{ub}
    Locate a tools array for a given name.


@{b}SYNOPSIS@{ub}
    char **toolarray = FindTools( struct DiskObject *diskobj,
                                  char              *filename,
                                  BPTR               directory_lock
                                );


@{b}INPUTS@{ub}
    filename = null-terminated name of file to look for.
    lock     = directory to look for file in.
    diskobj  = storage (for a later call to FreeDiskObject()) 


@{b}WARNINGS@{ub}
@{b}    Be sure to call FreeDiskObject() later in your program.
    FindTools() doesn't do this because it doesn't know what 
    you're going to do with the ToolTypes. 
@{ub}
@ENDNODE

@NODE "ComputeFont()" "ComputeFont()"
@{fg shine}ComputeFont()@{fg text}

@{b}NAME@{ub}
@{b}    ComputeFont()

@{ub}
@{b}SYNOPSIS@{ub}
    void ComputeFont( struct Screen   *screen,
                      struct TextAttr *font,
                      struct CompFont *cfont,
                      UWORD            width,
                      UWORD            height
                    );


@{b}DESCRIPTION@{ub}
    Initialize the CompFont structure according to the supplied
    values in the font, width & height.  If the results won't fit
    the screen dimensions, use topaz (8) in the computations
    instead.


@{b}NOTES@{ub}
@{b}@{fg shine}    GfxBase has to be open BEFORE calling this function!
@{fg text}@{ub}
@ENDNODE

@NODE "ComputeY()" "ComputeY()"
@{fg shine}ComputeY()@{fg text}

@{b}NAME@{ub}
@{b}    ComputeY()

@{ub}
@{b}SYNOPSIS@{ub}
    UWORD size = ComputeY( UWORD fontysize, UWORD value );


@{b}DESCRIPTION@{ub}
    This function returns 
         (fontysize * value + (fontysize / 2)) / fontysize


@{b}NOTES@{ub}
@{b}@{fg shine}    This function will probably be changed to private later.
@{fg text}@{ub}
@ENDNODE

@NODE "ComputeX()" "ComputeX()"
@{fg shine}ComputeX()@{fg text}

@{b}NAME@{ub}
@{b}    ComputeX()

@{ub}
@{b}SYNOPSIS@{ub}
    UWORD size = ComputeX( UWORD fontxsize, UWORD value );


@{b}DESCRIPTION@{ub}
    This function returns 
         (fontxsize * value + (fontxsize / 2)) / fontxsize


@{b}NOTES@{ub}
@{b}@{fg shine}    This function will probably be changed to private later.
@{fg text}@{ub}
@ENDNODE

@NODE "UserInfo()" "UserInfo()"
@{fg shine}UserInfo()@{fg text}

@{b}NAME@{ub}
@{b}    UserInfo()

@{ub}
@{b}SYNOPSIS@{ub}
    void UserInfo( char *message, char *windowtitle );


@{b}DESCRIPTION@{ub}
    Tell user some information.


@{b}NOTES@{ub}
@{b}@{fg shine}    Be sure to call SetNotifyWindow( wptr ) BEFORE using this 
    function for the first time!
@{fg text}@{ub}
@ENDNODE

@NODE "SanityCheck()" "SanityCheck()"
@{fg shine}SanityCheck()@{fg text}

@{b}NAME@{ub}
@{b}    SanityCheck - Get a Yes/No Response from the user.

@{ub}
@{b}SYNOPSIS@{ub}
    Boolean answer = SanityCheck( char *question );


@{b}FUNCTION@{ub}
@{b}@{fg shine}    Return TRUE if the User pressed the 'YES' button.
    Return FALSE if the User pressed the 'NO' button.

@{fg text}@{ub}
@{b}INPUTS@{ub}
    question - question the User has to respond to.


@{b}NOTES@{ub}
@{b}@{fg shine}    Be sure to call SetNotifyWindow( wptr ) BEFORE using this 
    function for the first time!
@{fg text}@{ub}
@ENDNODE

@NODE "GetUserResponse()" "GetUserResponse()"
@{fg shine}GetUserResponse()@{fg text}

@{b}NAME@{ub}
@{b}    GetUserResponse - Get a button response from the user.

@{ub}
@{b}SYNOPSIS@{ub}
    int ans = GetUserResponse( char *info, char *title, int *errnum );


@{b}FUNCTION@{ub}
@{b}@{fg shine}    Return -1 if there's no window, otherwise return the ordinal
    of the button the user pressed.  This means that there can be
    more than two choice buttons for the User to choose from.

@{fg text}@{ub}
@{b}INPUTS@{ub}
    info   - Information string for the user to act on.
    title  - Title of the Problem Requester.
    errnum - Optional error number.


@{b}NOTES@{ub}
@{b}@{fg shine}    GetUserResponse() will return 0 for the right-most button,
    instead of n, where n is the number of buttons.  This is the
    behavior of the EasyRequest() function (so don't blame me!).

    Call SetReqButtons() before using this function &
    be sure to call SetNotifyWindow( wptr ) BEFORE using this 
    function for the first time!
@{fg text}@{ub}
@ENDNODE

@NODE "Handle_Problem()" "Handle_Problem()"
@{fg shine}Handle_Problem()@{fg text}

@{b}NAME@{ub}
@{b}    Handle_Problem()

@{ub}
@{b}SYNOPSIS@{ub}
    int ans = Handle_Problem( char *info, char *title, int *errnum );


@{b}DESCRIPTION@{ub}
    Get a Yes/No Response from the user.


@{b}FUNCTION@{ub}
@{b}@{fg shine}    Return -1 if the user selected the ABORT (far-right) button,
    else return the errnum value (normally 0).

@{fg text}@{ub}
@{b}INPUTS@{ub}
    info   - Information string for the user to act on.
    title  - Title of the Problem Requester.
    errnum - Optional error number (normally NULL).


@{b}NOTES@{ub}
@{b}@{fg shine}    Be sure to call SetNotifyWindow( wptr ) BEFORE using this 
    function for the first time!
@{fg text}@{ub}
@ENDNODE

@NODE "NotifyUser()" "NotifyUser()"
@{fg shine}NotifyUser()@{fg text}

@{b}NAME@{ub}
@{b}    NotifyUser() - Internal to CommonFuncs.o only (PRIVATE!)

@{ub}
@{b}SYNOPSIS@{ub}
    int ans = NotifyUser( char          *info, 
                          char          *title,
                          struct Window *wptr, 
                          int           *errnum
                        );


@{b}DESCRIPTION@{ub}
    Get a response from the user.


@{b}FUNCTION@{ub}
@{b}@{fg shine}    Return -1 if the user selected the far-right button (ABORT?),
    else return 0 (CONTINUE?).

@{fg text}@{ub}
@{b}INPUTS@{ub}
    info   - Information string for the user to act on.
    title  - Title of the Problem Requester.
    wptr   - The window to open the Requester on.
    errnum - Optional error number (normally NULL).

@ENDNODE

@NODE "SetReqButtons()" "SetReqButtons()"
@{fg shine}SetReqButtons()@{fg text}

@{b}NAME@{ub}
@{b}    SetReqButtons

@{ub}
@{b}SYNOPSIS@{ub}
    (void) SetReqButtons( char *newbuttons );


@{b}DESCRIPTION@{ub}
    Set the buttons for the Information requester to the given 
    format string.


@{b}NOTES@{ub}
@{b}@{fg shine}    The user of this function should return the buttons to a
    known string after Handle_Problem() or the other User-
    requesters are called.
@{fg text}@{ub}
@ENDNODE

@NODE "SetNotifyWindow()" "SetNotifyWindow()"
@{fg shine}SetNotifyWindow()@{fg text}

@{b}NAME@{ub}
@{b}    SetNotifyWindow()

@{ub}
@{b}SYNOPSIS@{ub}
    (void) SetNotifyWindow( struct Window *wptr );


@{b}DESCRIPTION@{ub}
    Set the window pointer that Handle_Problem() & other User-
    Requesters will use for the EasyRequest() call.

@ENDNODE

@NODE "FileReq()" "FileReq()"
@{fg shine}FileReq()@{fg text}

@{b}NAME@{ub}
@{b}    FileReq()

@{ub}
@{b}SYNOPSIS@{ub}
    int len = FileReq( char *filename, struct TagItem *taglist );


@{b}DESCRIPTION@{ub}
    Display the ASL file requester with the given taglist.


@{b}NOTES@{ub}
@{b}@{fg shine}    This function is identical to File_DirReq() except that we
    don't use the Directory parameter.

    The suggested taglist items should be:

    ASLFR_Window,          (ULONG) WindowPointer // definitely needed!

    ASLFR_TitleText,       (ULONG) "Example title..." 
    ASLFR_InitialHeight,   200,
    ASLFR_InitialWidth,    400,
    ASLFR_InitialTopEdge,  16,
    ASLFR_InitialLeftEdge, 50,
    ASLFR_PositiveText,    (ULONG) "OKAY!",
    ASLFR_NegativeText,    (ULONG) "CANCEL!",
    ASLFR_InitialPattern,  (ULONG) "#?",
    ASLFR_InitialFile,     (ULONG) "",
    ASLFR_InitialDrawer,   (ULONG) "RAM:",
    ASLFR_Flags1,          FRF_DOPATTERNS,
    ASLFR_Flags2,          FRF_REJECTICONS,
    ASLFR_SleepWindow,     1,
    ASLFR_PrivateIDCMP,    1,
    TAG_END
@{fg text}@{ub}
@ENDNODE

@NODE "File_DirReq()" "File_DirReq()"
@{fg shine}File_DirReq()@{fg text}

@{b}NAME@{ub}
@{b}    File_DirReq()

@{ub}
@{b}SYNOPSIS@{ub}
    int len = File_DirReq( char           *filename, 
                           char           *dirname,
                           struct TagItem *taglist
                         );


@{b}DESCRIPTION@{ub}
    Display the ASL file requester with the given taglist.  Return
    the size of the file selected as well as the filename & Directory.

    The suggested taglist items should be:

    ASLFR_Window,          (ULONG) WindowPointer // definitely needed!

    ASLFR_TitleText,       (ULONG) "Example title..." 
    ASLFR_InitialHeight,   200,
    ASLFR_InitialWidth,    400,
    ASLFR_InitialTopEdge,  16,
    ASLFR_InitialLeftEdge, 50,
    ASLFR_PositiveText,    (ULONG) "OKAY!",
    ASLFR_NegativeText,    (ULONG) "CANCEL!",
    ASLFR_InitialPattern,  (ULONG) "#?",
    ASLFR_InitialFile,     (ULONG) "",
    ASLFR_InitialDrawer,   (ULONG) "RAM:",
    ASLFR_Flags1,          FRF_DOPATTERNS,
    ASLFR_Flags2,          FRF_REJECTICONS,
    ASLFR_SleepWindow,     1,
    ASLFR_PrivateIDCMP,    1,
    TAG_END

@ENDNODE

@NODE "MakeHexASCIIStr()" "MakeHexASCIIStr()"
@{fg shine}MakeHexASCIIStr()@{fg text}

@{b}NAME@{ub}
@{b}    MakeHexASCIIStr()

@{ub}
@{b}SYNOPSIS@{ub}
    unsigned int length = MakeHexASCIIStr( char *output, 
                                           char *input,
                                           int   inputlength
                                         );


@{b}DESCRIPTION@{ub}
    Take an input binary string & generate a displayable ASCII 
    string that displays the HexaDecimal value of each byte as
    well as the ASCII representation (for characters >= 0x20 &
    <= 0x7E).

    Output will be as follows:

    /------------ Hex Bytes ----------\\ /--- ASCII ----\\

    22334455 22334455 A7223344 7F223344 "3DU"3DU."3D."3D 


@{b}WARNINGS@{ub}
@{b}    The output buffer has to be FOUR times as long as the input
    buffer!  The maximum value for inlen should be 20 bytes, with
    16 being the nominal value.
@{ub}
@ENDNODE

@NODE "Byt2Str()" "Byt2Str()"
@{fg shine}Byt2Str()@{fg text}

@{b}NAME@{ub}
@{b}    Byt2Str()

@{ub}
@{b}SYNOPSIS@{ub}
    char *hexstr = Byt2Str( char *output, UBYTE input_byte );


@{b}DESCRIPTION@{ub}
    Take an input binary character & generate a displayable 
    two-character ASCII 
    string that displays the HexaDecimal value of each byte.


@{b}WARNINGS@{ub}
@{b}    The output buffer has to be TWO times as long as the input
    buffer (+ 1 for nil); in other words supply a buffer that's
    three characters long!
@{ub}
@ENDNODE

@NODE "getScreenModeID()" "getScreenModeID()"
@{fg shine}getScreenModeID()@{fg text}

@{b}NAME@{ub}
@{b}    getScreenModeID()

@{ub}
@{b}SYNOPSIS@{ub}
    ULONG mode = getScreenModeID( struct TagItem *taglist, 
                                  struct Screen  *screen,
                                  char           *req_title
                                ); 


@{b}DESCRIPTION@{ub}
    Obtain a user-selected (via ASL) ScreenModeID value.  NULL will
    be returned if you supply a NULL value for the screen pointer,
    or if you press & release the Cancel Gadget on the Requester.

@ENDNODE

@NODE "FontXDim()" "FontXDim()"
@{fg shine}FontXDim()@{fg text}

@{b}NAME@{ub}
@{b}    FontXDim()

@{ub}
@{b}SYNOPSIS@{ub}
    int length = FontXDim( struct TextAttr *font );


@{b}DESCRIPTION@{ub}
    Determine the horizontal distance for one character in the given
    font.

@ENDNODE

@NODE "GetPathName()" "GetPathName()"
@{fg shine}GetPathName()@{fg text}

@{b}NAME@{ub}
@{b}    GetPathName()
  
@{ub}
@{b}SYNOPSIS@{ub}
    char *path = GetPathName( char *pathbuf, char *filename, int size );


@{b}DESCRIPTION@{ub}
    Return with the Path portion of a filename string.

@ENDNODE

@NODE "Guarded_AllocLV()" "Guarded_AllocLV()"
@{fg shine}Guarded_AllocLV()@{fg text}

@{b}NAME@{ub}
@{b}    Guarded_AllocLV()

@{ub}
@{b}SYNOPSIS@{ub}
    struct ListViewMem *lvm = Guarded_AllocLV( int numitems, 
                                               int itemsize
                                             );


@{b}DESCRIPTION@{ub}
    Allocate the memory associated with a ListView Gadget.

@ENDNODE

@NODE "ReportAllocLVError()" "ReportAllocLVError()"
@{fg shine}ReportAllocLVError()@{fg text}

@{b}NAME@{ub}
@{b}    ReportAllocLVError()

@{ub}
@{b}SYNOPSIS@{ub}
    void ReportAllocLVError( void );


@{b}DESCRIPTION@{ub}
    Display a requester informing the User the error that 
    Guarded_AllocLV() found.


@{b}SEE ALSO@{ub}
    Guarded_AllocLV(), Guarded_FreeLV()

@ENDNODE

@NODE "Guarded_FreeLV()" "Guarded_FreeLV()"
@{fg shine}Guarded_FreeLV()@{fg text}

@{b}NAME@{ub}
@{b}    Guarded_FreeLV()

@{ub}
@{b}SYNOPSIS@{ub}
    void Guarded_FreeLV( struct ListViewMem *lvm );


@{b}DESCRIPTION@{ub}
    Free the memory associated with a ListView Gadget & reset 
    the Guard. 

@ENDNODE

@NODE "DisplayTitle()" "DisplayTitle()"
@{fg shine}DisplayTitle()@{fg text}

@{b}NAME@{ub}
@{b}    DisplayTitle()

@{ub}
@{b}SYNOPSIS@{ub}
    void DisplayTitle( struct Window *wptr, char *windowTitle );


@{b}DESCRIPTION@{ub}
    Display the given text as a title for the given Window.


@{b}NOTES@{ub}
@{b}@{fg shine}    The title is silently limited to 79 characters in length.
@{fg text}@{ub}
@ENDNODE

@NODE "GetActiveScreen()" "GetActiveScreen()"
@{fg shine}GetActiveScreen()@{fg text}

@{b}NAME@{ub}
@{b}    GetActiveScreen()

@{ub}
@{b}SYNOPSIS@{ub}
    struct Screen *active = GetActiveScreen( void );


@{b}DESCRIPTION@{ub}
    Return a pointer to the Active Screen.

@ENDNODE

@NODE "GetActiveWindow()" "GetActiveWindow()"
@{fg shine}GetActiveWindow()@{fg text}

@{b}NAME@{ub}
@{b}    GetActiveWindow()

@{ub}
@{b}SYNOPSIS@{ub}
    struct Window *active = GetActiveWindow( void );


@{b}DESCRIPTION@{ub}
    Return a pointer to the Active Window.

@ENDNODE

@NODE "SetupList()" "SetupList()"
@{fg shine}SetupList()@{fg text}

@{b}NAME@{ub}
@{b}    SetupList()

@{ub}
@{b}SYNOPSIS@{ub}
    void SetupList( struct List *lst, struct ListViewMem *lvm );


@{b}DESCRIPTION@{ub}
    Initialize a List structure for a ListView Gadget.

@ENDNODE

@NODE "itoa()" "itoa()"
@{fg shine}itoa()@{fg text}

@{b}NAME@{ub}
@{b}    itoa()

@{ub}
@{b}SYNOPSIS@{ub}
    void itoa( int convertMe, char *stringbuffer );


@{b}DESCRIPTION@{ub}
    convert an decimal integer to a string.


@{b}WARNINGS@{ub}
@{b}    Make sure that stringbuffer is at least 20 characters long!
@{ub}
@ENDNODE

@NODE "CFFindMenuPtr()" "CFFindMenuPtr()"
@{fg shine}CFFindMenuPtr()@{fg text}

@{b}NAME@{ub}
@{b}    CFFindMenuPtr()

@{ub}
@{b}DESCRIPTION@{ub}
    Return a pointer to a menu item that has the given title.

@ENDNODE

@NODE "getUserFont()" "getUserFont()"
@{fg shine}getUserFont()@{fg text}

@{b}NAME@{ub}
@{b}    getUserFont()

@{ub}
@{b}SYNOPSIS@{ub}
    struct TextAttr *font = getUserFont( struct TagItem *taglist, 
                                         struct Screen  *screen,
                                         char           *req_title
                                       ); 


@{b}DESCRIPTION@{ub}
    Obtain a user-selected (via ASL) Font.  A NULL value for the FONT
    is returned if you press & release the Cancel Gadget on the 
    Requester.

 WARNING
    Store the result BEFORE the next call to getUserFont()!!

@ENDNODE
