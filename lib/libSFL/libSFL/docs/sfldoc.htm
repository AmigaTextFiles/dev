<HTML><HEAD><!--Revised: 1 Jan 1999 By: Pieter Hintjens-->
<TITLE>The Standard Function Library</TITLE></HEAD>
<BODY BACKGROUND="newstone.gif">
<TABLE WIDTH=100%><TR><TD ALIGN=LEFT>
 | <A HREF="/index.htm"> iMatix home page</A><BR>
 | <A href="sfldoc.htm">&lt;&lt;</A> | &lt;
 | &gt; | <A href="sfldoc.htm">&gt;&gt;</A>
<TD ALIGN=RIGHT>
<IMG SRC="sfl80c.gif" ALT="SFL Logo" WIDTH=80 HEIGHT=60 ALIGN=RIGHT HSPACE=10>
<FONT SIZE=5><B>SFL</B><BR><FONT SIZE=2>Version 2.11
</TABLE>
<HR>

<H1>The Standard Function Library</H1>

<P>The SFL (Standard Function Library) from iMatix is a portable function
library for C/C++ programs. The SFL is the result of many years'
development, and is provided as Open Source software for the benefit of the
Internet community.

<P>You may want to go straight to the <A href="sfldoc.htm#TOC">Table of Contents</A>.

<P>The SFL is written in ANSI C and has been ported to MS-DOS, Windows,
OS/2, Linux and other UNIX systems (IBM AIX, SunOS, HP/UX, Solaris, NetBSD,
FreeBSD, SCO OpenServer, Digital UNIX) and Digital OpenVMS. It comes with
complete sources and documentation in HTML.

<P>The SFL provides about 450 functions that cover these areas:
<UL>
<LI>Compression, encryption, and encoding;
<LI>Datatype conversion and formatting;
<LI>Dates, times, and calendars;
<LI>Directory and environment access;
<LI>User and process groups;
<LI>Inverted bitmap indices;
<LI>Symbol tables;
<LI>Error message files;
<LI>Configuration files;
<LI>String manipulation and searching;
<LI>File access;
<LI>Internet socket access;
<LI>Internet programming (MIME, CGI);
<LI>SMTP (e-mail) access;
<LI>Server (batch) programming;
<LI>Program tracing.
</UL>

<P>The SFL is free software that you may use and distribute for
private or commercial purposes according to the
<A href="sfldoc.htm#license">SFL License Agreement</A>.

<P>Send comments about the SFL, bug reports, and submissions to
<A HREF="mailto:sfl@imatix.com">sfl@imatix.com</A>.

<A NAME="TOC">&nbsp;</A>
<H2>Table of Contents</H2>
<MENU>
<LI><A HREF="#TOC1">What Is The SFL</A></LI>
<MENU>
<LI><A HREF="#TOC2">Origins</A></LI>
<LI><A HREF="#TOC3">Objectives</A></LI>
<LI><A HREF="#TOC4">Portability</A></LI>
</MENU>
<LI><A HREF="#TOC5">Installing The SFL</A></LI>
<MENU>
<LI><A HREF="#TOC6">Availability and Distribution</A></LI>
<LI><A HREF="#TOC7">Installation for UNIX Systems</A></LI>
<LI><A HREF="#TOC8">Installation for Digital VMS Systems</A></LI>
<LI><A HREF="#TOC9">Installation for Windows</A></LI>
<LI><A HREF="#TOC10">Installation for MS-DOS</A></LI>
</MENU>
<LI><A HREF="#TOC11">Using The SFL</A></LI>
<MENU>
<LI><A HREF="#TOC12">The Universal Header File - prelude.h</A></LI>
<LI><A HREF="#TOC13">The Library Header File - sfl.h</A></LI>
<LI><A HREF="#TOC14">System Notes</A></LI>
<LI><A HREF="#TOC15">To Do List</A></LI>
</MENU>
<LI><A HREF="#TOC16">Contributors and References</A></LI>
<LI><A HREF="#TOC17">The SFL License Agreement</A></LI>
<LI><A HREF="#TOC18">Universal Header File for C programming</A></LI>
<LI><A HREF="#TOC19">Define SFL version</A></LI>
<LI><A HREF="#TOC20">Large bitstring manipulation functions</A></LI>
<MENU>
<LI><A HREF="#TOC21"><TT>bits_init</TT></A></LI>
<LI><A HREF="#TOC22"><TT>bits_term</TT></A></LI>
<LI><A HREF="#TOC23"><TT>bits_create</TT></A></LI>
<LI><A HREF="#TOC24"><TT>bits_destroy</TT></A></LI>
<LI><A HREF="#TOC25"><TT>bits_set</TT></A></LI>
<LI><A HREF="#TOC26"><TT>bits_clear</TT></A></LI>
<LI><A HREF="#TOC27"><TT>bits_test</TT></A></LI>
<LI><A HREF="#TOC28"><TT>bits_fput</TT></A></LI>
<LI><A HREF="#TOC29"><TT>bits_fget</TT></A></LI>
</MENU>
<LI><A HREF="#TOC30">Compression functions</A></LI>
<MENU>
<LI><A HREF="#TOC31"><TT>compress_block</TT></A></LI>
<LI><A HREF="#TOC32"><TT>expand_block</TT></A></LI>
<LI><A HREF="#TOC33"><TT>compress_rle</TT></A></LI>
<LI><A HREF="#TOC34"><TT>expand_rle</TT></A></LI>
<LI><A HREF="#TOC35"><TT>compress_nulls</TT></A></LI>
<LI><A HREF="#TOC36"><TT>expand_nulls</TT></A></LI>
<LI><A HREF="#TOC37"><TT>compress_bits</TT></A></LI>
<LI><A HREF="#TOC38"><TT>expand_bits</TT></A></LI>
</MENU>
<LI><A HREF="#TOC39">Console output functions</A></LI>
<MENU>
<LI><A HREF="#TOC40"><TT>console_send</TT></A></LI>
<LI><A HREF="#TOC41"><TT>console_enable</TT></A></LI>
<LI><A HREF="#TOC42"><TT>console_disable</TT></A></LI>
<LI><A HREF="#TOC43"><TT>console_set_mode</TT></A></LI>
<LI><A HREF="#TOC44"><TT>console_capture</TT></A></LI>
<LI><A HREF="#TOC45"><TT>coprintf</TT></A></LI>
<LI><A HREF="#TOC46"><TT>coputs</TT></A></LI>
<LI><A HREF="#TOC47"><TT>coputc</TT></A></LI>
</MENU>
<LI><A HREF="#TOC48">Conversion functions</A></LI>
<MENU>
<LI><A HREF="#TOC49"><TT>conv_bool_str</TT></A></LI>
<LI><A HREF="#TOC50"><TT>conv_date_pict</TT></A></LI>
<LI><A HREF="#TOC51"><TT>conv_date_str</TT></A></LI>
<LI><A HREF="#TOC52"><TT>conv_number_str</TT></A></LI>
<LI><A HREF="#TOC53"><TT>conv_str_bool</TT></A></LI>
<LI><A HREF="#TOC54"><TT>conv_str_date</TT></A></LI>
<LI><A HREF="#TOC55"><TT>conv_str_day</TT></A></LI>
<LI><A HREF="#TOC56"><TT>conv_str_number</TT></A></LI>
<LI><A HREF="#TOC57"><TT>conv_str_time</TT></A></LI>
<LI><A HREF="#TOC58"><TT>conv_time_pict</TT></A></LI>
<LI><A HREF="#TOC59"><TT>conv_time_str</TT></A></LI>
</MENU>
<LI><A HREF="#TOC60">Encryption and decryption functions</A></LI>
<MENU>
<LI><A HREF="#TOC61"><TT>crypt_encode</TT></A></LI>
<LI><A HREF="#TOC62"><TT>crypt_decode</TT></A></LI>
<LI><A HREF="#TOC63"><TT>calculate_crc</TT></A></LI>
</MENU>
<LI><A HREF="#TOC64">Date and time functions</A></LI>
<MENU>
<LI><A HREF="#TOC65"><TT>date_now</TT></A></LI>
<LI><A HREF="#TOC66"><TT>time_now</TT></A></LI>
<LI><A HREF="#TOC67"><TT>leap_year</TT></A></LI>
<LI><A HREF="#TOC68"><TT>julian_date</TT></A></LI>
<LI><A HREF="#TOC69"><TT>day_of_week</TT></A></LI>
<LI><A HREF="#TOC70"><TT>next_weekday</TT></A></LI>
<LI><A HREF="#TOC71"><TT>prev_weekday</TT></A></LI>
<LI><A HREF="#TOC72"><TT>week_of_year</TT></A></LI>
<LI><A HREF="#TOC73"><TT>year_quarter</TT></A></LI>
<LI><A HREF="#TOC74"><TT>default_century</TT></A></LI>
<LI><A HREF="#TOC75"><TT>pack_date</TT></A></LI>
<LI><A HREF="#TOC76"><TT>pack_time</TT></A></LI>
<LI><A HREF="#TOC77"><TT>unpack_date</TT></A></LI>
<LI><A HREF="#TOC78"><TT>unpack_time</TT></A></LI>
<LI><A HREF="#TOC79"><TT>date_to_days</TT></A></LI>
<LI><A HREF="#TOC80"><TT>days_to_date</TT></A></LI>
<LI><A HREF="#TOC81"><TT>date_to_timer</TT></A></LI>
<LI><A HREF="#TOC82"><TT>timer_to_date</TT></A></LI>
<LI><A HREF="#TOC83"><TT>timer_to_time</TT></A></LI>
<LI><A HREF="#TOC84"><TT>timer_to_gmdate</TT></A></LI>
<LI><A HREF="#TOC85"><TT>timer_to_gmtime</TT></A></LI>
<LI><A HREF="#TOC86"><TT>time_to_csecs</TT></A></LI>
<LI><A HREF="#TOC87"><TT>csecs_to_time</TT></A></LI>
<LI><A HREF="#TOC88"><TT>future_date</TT></A></LI>
<LI><A HREF="#TOC89"><TT>past_date</TT></A></LI>
<LI><A HREF="#TOC90"><TT>date_diff</TT></A></LI>
<LI><A HREF="#TOC91"><TT>valid_date</TT></A></LI>
<LI><A HREF="#TOC92"><TT>valid_time</TT></A></LI>
<LI><A HREF="#TOC93"><TT>date_is_future</TT></A></LI>
<LI><A HREF="#TOC94"><TT>date_is_past</TT></A></LI>
<LI><A HREF="#TOC95"><TT>timezone_string</TT></A></LI>
<LI><A HREF="#TOC96"><TT>local_to_gmt</TT></A></LI>
<LI><A HREF="#TOC97"><TT>gmt_to_local</TT></A></LI>
<LI><A HREF="#TOC98"><TT>safe_localtime</TT></A></LI>
<LI><A HREF="#TOC99"><TT>safe_gmtime</TT></A></LI>
</MENU>
<LI><A HREF="#TOC100">External data representation functions</A></LI>
<MENU>
<LI><A HREF="#TOC101"><TT>exdr_write</TT></A></LI>
<LI><A HREF="#TOC102"><TT>exdr_writed</TT></A></LI>
<LI><A HREF="#TOC103"><TT>exdr_read</TT></A></LI>
</MENU>
<LI><A HREF="#TOC104">Fast string searching functions</A></LI>
<MENU>
<LI><A HREF="#TOC105"><TT>strfind</TT></A></LI>
<LI><A HREF="#TOC106"><TT>strfind_r</TT></A></LI>
<LI><A HREF="#TOC107"><TT>strfind_rb</TT></A></LI>
<LI><A HREF="#TOC108"><TT>memfind</TT></A></LI>
<LI><A HREF="#TOC109"><TT>memfind_r</TT></A></LI>
<LI><A HREF="#TOC110"><TT>memfind_rb</TT></A></LI>
<LI><A HREF="#TOC111"><TT>txtfind</TT></A></LI>
</MENU>
<LI><A HREF="#TOC112">File-access functions</A></LI>
<MENU>
<LI><A HREF="#TOC113"><TT>file_open</TT></A></LI>
<LI><A HREF="#TOC114"><TT>file_locate</TT></A></LI>
<LI><A HREF="#TOC115"><TT>file_close</TT></A></LI>
<LI><A HREF="#TOC116"><TT>file_read</TT></A></LI>
<LI><A HREF="#TOC117"><TT>file_readn</TT></A></LI>
<LI><A HREF="#TOC118"><TT>file_write</TT></A></LI>
<LI><A HREF="#TOC119"><TT>file_copy</TT></A></LI>
<LI><A HREF="#TOC120"><TT>file_concat</TT></A></LI>
<LI><A HREF="#TOC121"><TT>file_rename</TT></A></LI>
<LI><A HREF="#TOC122"><TT>file_delete</TT></A></LI>
<LI><A HREF="#TOC123"><TT>file_exists</TT></A></LI>
<LI><A HREF="#TOC124"><TT>file_where</TT></A></LI>
<LI><A HREF="#TOC125"><TT>file_where_ext</TT></A></LI>
<LI><A HREF="#TOC126"><TT>file_cycle</TT></A></LI>
<LI><A HREF="#TOC127"><TT>file_cycle_needed</TT></A></LI>
<LI><A HREF="#TOC128"><TT>file_has_changed</TT></A></LI>
<LI><A HREF="#TOC129"><TT>safe_to_extend</TT></A></LI>
<LI><A HREF="#TOC130"><TT>default_extension</TT></A></LI>
<LI><A HREF="#TOC131"><TT>fixed_extension</TT></A></LI>
<LI><A HREF="#TOC132"><TT>strip_extension</TT></A></LI>
<LI><A HREF="#TOC133"><TT>add_extension</TT></A></LI>
<LI><A HREF="#TOC134"><TT>strip_file_path</TT></A></LI>
<LI><A HREF="#TOC135"><TT>strip_file_name</TT></A></LI>
<LI><A HREF="#TOC136"><TT>get_new_filename</TT></A></LI>
<LI><A HREF="#TOC137"><TT>file_is_readable</TT></A></LI>
<LI><A HREF="#TOC138"><TT>file_is_writeable</TT></A></LI>
<LI><A HREF="#TOC139"><TT>file_is_executable</TT></A></LI>
<LI><A HREF="#TOC140"><TT>file_is_program</TT></A></LI>
<LI><A HREF="#TOC141"><TT>file_is_directory</TT></A></LI>
<LI><A HREF="#TOC142"><TT>file_is_legal</TT></A></LI>
<LI><A HREF="#TOC143"><TT>file_exec_name</TT></A></LI>
<LI><A HREF="#TOC144"><TT>get_file_size</TT></A></LI>
<LI><A HREF="#TOC145"><TT>get_file_time</TT></A></LI>
<LI><A HREF="#TOC146"><TT>get_file_lines</TT></A></LI>
<LI><A HREF="#TOC147"><TT>file_slurp</TT></A></LI>
<LI><A HREF="#TOC148"><TT>file_slurpl</TT></A></LI>
<LI><A HREF="#TOC149"><TT>file_set_eoln</TT></A></LI>
<LI><A HREF="#TOC150"><TT>get_tmp_file_name</TT></A></LI>
<LI><A HREF="#TOC151"><TT>file_fhredirect</TT></A></LI>
<LI><A HREF="#TOC152"><TT>file_fhrestore</TT></A></LI>
<LI><A HREF="#TOC153"><TT>ftmp_open</TT></A></LI>
<LI><A HREF="#TOC154"><TT>ftmp_close</TT></A></LI>
</MENU>
<LI><A HREF="#TOC155">Fortune-cookie functions</A></LI>
<MENU>
<LI><A HREF="#TOC156"><TT>fortune_build</TT></A></LI>
<LI><A HREF="#TOC157"><TT>fortune_read</TT></A></LI>
</MENU>
<LI><A HREF="#TOC158">Initialisation file access functions</A></LI>
<MENU>
<LI><A HREF="#TOC159"><TT>ini_find_section</TT></A></LI>
<LI><A HREF="#TOC160"><TT>ini_scan_section</TT></A></LI>
<LI><A HREF="#TOC161"><TT>ini_dyn_load</TT></A></LI>
<LI><A HREF="#TOC162"><TT>ini_dyn_loade</TT></A></LI>
<LI><A HREF="#TOC163"><TT>ini_dyn_save</TT></A></LI>
<LI><A HREF="#TOC164"><TT>ini_dyn_changed</TT></A></LI>
<LI><A HREF="#TOC165"><TT>ini_dyn_refresh</TT></A></LI>
<LI><A HREF="#TOC166"><TT>ini_dyn_value</TT></A></LI>
<LI><A HREF="#TOC167"><TT>ini_dyn_values</TT></A></LI>
<LI><A HREF="#TOC168"><TT>srcdoc W (sflini.c 649): function ini_dyn_default not known</TT></A></LI>
</MENU>
<LI><A HREF="#TOC169">Multilanguage support</A></LI>
<MENU>
<LI><A HREF="#TOC170"><TT>set_userlang</TT></A></LI>
<LI><A HREF="#TOC171"><TT>set_userlang_str</TT></A></LI>
<LI><A HREF="#TOC172"><TT>get_userlang</TT></A></LI>
<LI><A HREF="#TOC173"><TT>get_userlang_str</TT></A></LI>
<LI><A HREF="#TOC174"><TT>set_accents</TT></A></LI>
<LI><A HREF="#TOC175"><TT>get_accents</TT></A></LI>
<LI><A HREF="#TOC176"><TT>get_units_name</TT></A></LI>
<LI><A HREF="#TOC177"><TT>get_tens_name</TT></A></LI>
<LI><A HREF="#TOC178"><TT>get_day_name</TT></A></LI>
<LI><A HREF="#TOC179"><TT>get_day_abbrev</TT></A></LI>
<LI><A HREF="#TOC180"><TT>get_month_name</TT></A></LI>
<LI><A HREF="#TOC181"><TT>get_month_abbrev</TT></A></LI>
<LI><A HREF="#TOC182"><TT>timestamp_string</TT></A></LI>
</MENU>
<LI><A HREF="#TOC183">Line buffering functions</A></LI>
<MENU>
<LI><A HREF="#TOC184"><TT>linebuf_create</TT></A></LI>
<LI><A HREF="#TOC185"><TT>linebuf_destroy</TT></A></LI>
<LI><A HREF="#TOC186"><TT>linebuf_reset</TT></A></LI>
<LI><A HREF="#TOC187"><TT>linebuf_append</TT></A></LI>
<LI><A HREF="#TOC188"><TT>linebuf_first</TT></A></LI>
<LI><A HREF="#TOC189"><TT>linebuf_next</TT></A></LI>
<LI><A HREF="#TOC190"><TT>linebuf_last</TT></A></LI>
<LI><A HREF="#TOC191"><TT>linebuf_prev</TT></A></LI>
</MENU>
<LI><A HREF="#TOC192">Linked-list functions</A></LI>
<MENU>
<LI><A HREF="#TOC193"><TT>list_unlink</TT></A></LI>
<LI><A HREF="#TOC194"><TT>list_relink</TT></A></LI>
<LI><A HREF="#TOC195"><TT>list_add</TT></A></LI>
<LI><A HREF="#TOC196"><TT>list_remove</TT></A></LI>
<LI><A HREF="#TOC197"><TT>list_sort</TT></A></LI>
</MENU>
<LI><A HREF="#TOC198">SMTP mailer function</A></LI>
<MENU>
<LI><A HREF="#TOC199"><TT>smtp_send_mail_ex</TT></A></LI>
<LI><A HREF="#TOC200"><TT>smtp_send_mail</TT></A></LI>
</MENU>
<LI><A HREF="#TOC201">Mathematic functions</A></LI>
<MENU>
<LI><A HREF="#TOC202"><TT>point_in_rect</TT></A></LI>
<LI><A HREF="#TOC203"><TT>point_in_circle</TT></A></LI>
<LI><A HREF="#TOC204"><TT>point_in_poly</TT></A></LI>
</MENU>
<LI><A HREF="#TOC205">Message-file access functions</A></LI>
<MENU>
<LI><A HREF="#TOC206"><TT>open_message_file</TT></A></LI>
<LI><A HREF="#TOC207"><TT>close_message_file</TT></A></LI>
<LI><A HREF="#TOC208"><TT>print_message</TT></A></LI>
<LI><A HREF="#TOC209"><TT>message_text</TT></A></LI>
</MENU>
<LI><A HREF="#TOC210">Memory allocation functions</A></LI>
<MENU>
<LI><A HREF="#TOC211"><TT>mem_alloc_</TT></A></LI>
<LI><A HREF="#TOC212"><TT>mem_realloc_</TT></A></LI>
<LI><A HREF="#TOC213"><TT>mem_strdup_</TT></A></LI>
<LI><A HREF="#TOC214"><TT>mem_strfree_</TT></A></LI>
<LI><A HREF="#TOC215"><TT>mem_free_</TT></A></LI>
<LI><A HREF="#TOC216"><TT>mem_assert_</TT></A></LI>
<LI><A HREF="#TOC217"><TT>mem_checkall_</TT></A></LI>
<LI><A HREF="#TOC218"><TT>mem_check_</TT></A></LI>
<LI><A HREF="#TOC219"><TT>mem_descr_</TT></A></LI>
<LI><A HREF="#TOC220"><TT>mem_new_trans_</TT></A></LI>
<LI><A HREF="#TOC221"><TT>mem_commit_</TT></A></LI>
<LI><A HREF="#TOC222"><TT>mem_rollback_</TT></A></LI>
<LI><A HREF="#TOC223"><TT>mem_size_</TT></A></LI>
<LI><A HREF="#TOC224"><TT>mem_used</TT></A></LI>
<LI><A HREF="#TOC225"><TT>mem_allocs</TT></A></LI>
<LI><A HREF="#TOC226"><TT>mem_frees</TT></A></LI>
<LI><A HREF="#TOC227"><TT>mem_display</TT></A></LI>
<LI><A HREF="#TOC228"><TT>mem_scavenger</TT></A></LI>
<LI><A HREF="#TOC229"><TT>mem_freeall</TT></A></LI>
</MENU>
<LI><A HREF="#TOC230">MIME support functions</A></LI>
<MENU>
<LI><A HREF="#TOC231"><TT>encode_base64</TT></A></LI>
<LI><A HREF="#TOC232"><TT>decode_base64</TT></A></LI>
<LI><A HREF="#TOC233"><TT>decode_mime_time</TT></A></LI>
<LI><A HREF="#TOC234"><TT>encode_mime_time</TT></A></LI>
</MENU>
<LI><A HREF="#TOC235">Linked-list functions</A></LI>
<MENU>
<LI><A HREF="#TOC236"><TT>node_create</TT></A></LI>
<LI><A HREF="#TOC237"><TT>node_destroy</TT></A></LI>
<LI><A HREF="#TOC238"><TT>node_relink_after</TT></A></LI>
<LI><A HREF="#TOC239"><TT>node_relink_before</TT></A></LI>
<LI><A HREF="#TOC240"><TT>node_unlink</TT></A></LI>
<LI><A HREF="#TOC241"><TT>node_relink</TT></A></LI>
</MENU>
<LI><A HREF="#TOC242">Directory access functions</A></LI>
<MENU>
<LI><A HREF="#TOC243"><TT>open_dir</TT></A></LI>
<LI><A HREF="#TOC244"><TT>read_dir</TT></A></LI>
<LI><A HREF="#TOC245"><TT>close_dir</TT></A></LI>
<LI><A HREF="#TOC246"><TT>format_dir</TT></A></LI>
<LI><A HREF="#TOC247"><TT>fix_dir</TT></A></LI>
<LI><A HREF="#TOC248"><TT>free_dir</TT></A></LI>
<LI><A HREF="#TOC249"><TT>load_dir_list</TT></A></LI>
<LI><A HREF="#TOC250"><TT>free_dir_list</TT></A></LI>
<LI><A HREF="#TOC251"><TT>sort_dir_list</TT></A></LI>
<LI><A HREF="#TOC252"><TT>add_dir_list</TT></A></LI>
<LI><A HREF="#TOC253"><TT>resolve_path</TT></A></LI>
<LI><A HREF="#TOC254"><TT>locate_path</TT></A></LI>
<LI><A HREF="#TOC255"><TT>clean_path</TT></A></LI>
<LI><A HREF="#TOC256"><TT>get_curdir</TT></A></LI>
<LI><A HREF="#TOC257"><TT>set_curdir</TT></A></LI>
<LI><A HREF="#TOC258"><TT>file_matches</TT></A></LI>
<LI><A HREF="#TOC259"><TT>make_dir</TT></A></LI>
<LI><A HREF="#TOC260"><TT>remove_dir</TT></A></LI>
<LI><A HREF="#TOC261"><TT>dir_usage</TT></A></LI>
<LI><A HREF="#TOC262"><TT>dir_files</TT></A></LI>
</MENU>
<LI><A HREF="#TOC263">Process control functions</A></LI>
<MENU>
<LI><A HREF="#TOC264"><TT>process_create_full</TT></A></LI>
<LI><A HREF="#TOC265"><TT>process_create</TT></A></LI>
<LI><A HREF="#TOC266"><TT>process_setinfo</TT></A></LI>
<LI><A HREF="#TOC267"><TT>process_open_io</TT></A></LI>
<LI><A HREF="#TOC268"><TT>process_close_io</TT></A></LI>
<LI><A HREF="#TOC269"><TT>process_status</TT></A></LI>
<LI><A HREF="#TOC270"><TT>process_kill</TT></A></LI>
<LI><A HREF="#TOC271"><TT>process_close</TT></A></LI>
<LI><A HREF="#TOC272"><TT>process_server</TT></A></LI>
<LI><A HREF="#TOC273"><TT>process_alarm</TT></A></LI>
<LI><A HREF="#TOC274"><TT>process_esc</TT></A></LI>
<LI><A HREF="#TOC275"><TT>process_unesc</TT></A></LI>
<LI><A HREF="#TOC276"><TT>process_priority</TT></A></LI>
</MENU>
<LI><A HREF="#TOC277">Time-slot functions</A></LI>
<MENU>
<LI><A HREF="#TOC278"><TT>year_range_empty</TT></A></LI>
<LI><A HREF="#TOC279"><TT>year_range_fill</TT></A></LI>
<LI><A HREF="#TOC280"><TT>year_slot_clear</TT></A></LI>
<LI><A HREF="#TOC281"><TT>year_slot_set</TT></A></LI>
<LI><A HREF="#TOC282"><TT>year_slot_filled</TT></A></LI>
<LI><A HREF="#TOC283"><TT>day_range_empty</TT></A></LI>
<LI><A HREF="#TOC284"><TT>day_range_fill</TT></A></LI>
<LI><A HREF="#TOC285"><TT>day_slot_clear</TT></A></LI>
<LI><A HREF="#TOC286"><TT>day_slot_set</TT></A></LI>
<LI><A HREF="#TOC287"><TT>day_slot_filled</TT></A></LI>
<LI><A HREF="#TOC288"><TT>date_to_day</TT></A></LI>
<LI><A HREF="#TOC289"><TT>time_to_min</TT></A></LI>
</MENU>
<LI><A HREF="#TOC290">String-handling functions</A></LI>
<MENU>
<LI><A HREF="#TOC291"><TT>strdupl</TT></A></LI>
<LI><A HREF="#TOC292"><TT>strfree</TT></A></LI>
<LI><A HREF="#TOC293"><TT>strskp</TT></A></LI>
<LI><A HREF="#TOC294"><TT>strcset</TT></A></LI>
<LI><A HREF="#TOC295"><TT>strpad</TT></A></LI>
<LI><A HREF="#TOC296"><TT>strlwc</TT></A></LI>
<LI><A HREF="#TOC297"><TT>strupc</TT></A></LI>
<LI><A HREF="#TOC298"><TT>strcrop</TT></A></LI>
<LI><A HREF="#TOC299"><TT>stropen</TT></A></LI>
<LI><A HREF="#TOC300"><TT>strclose</TT></A></LI>
<LI><A HREF="#TOC301"><TT>strunique</TT></A></LI>
<LI><A HREF="#TOC302"><TT>strmatch</TT></A></LI>
<LI><A HREF="#TOC303"><TT>strprefixed</TT></A></LI>
<LI><A HREF="#TOC304"><TT>strprefix</TT></A></LI>
<LI><A HREF="#TOC305"><TT>strdefix</TT></A></LI>
<LI><A HREF="#TOC306"><TT>strhash</TT></A></LI>
<LI><A HREF="#TOC307"><TT>strconvch</TT></A></LI>
<LI><A HREF="#TOC308"><TT>xstrcat</TT></A></LI>
<LI><A HREF="#TOC309"><TT>xstrcpy</TT></A></LI>
<LI><A HREF="#TOC310"><TT>lexcmp</TT></A></LI>
<LI><A HREF="#TOC311"><TT>lexncmp</TT></A></LI>
<LI><A HREF="#TOC312"><TT>lexwcmp</TT></A></LI>
<LI><A HREF="#TOC313"><TT>soundex</TT></A></LI>
<LI><A HREF="#TOC314"><TT>soundexn</TT></A></LI>
<LI><A HREF="#TOC315"><TT>strt2descr</TT></A></LI>
<LI><A HREF="#TOC316"><TT>descr2strt</TT></A></LI>
<LI><A HREF="#TOC317"><TT>strtfree</TT></A></LI>
<LI><A HREF="#TOC318"><TT>strcntch</TT></A></LI>
<LI><A HREF="#TOC319"><TT>strlookup</TT></A></LI>
<LI><A HREF="#TOC320"><TT>strreformat</TT></A></LI>
<LI><A HREF="#TOC321"><TT>removechars</TT></A></LI>
<LI><A HREF="#TOC322"><TT>replacechrswith</TT></A></LI>
<LI><A HREF="#TOC323"><TT>insertstring</TT></A></LI>
<LI><A HREF="#TOC324"><TT>insertchar</TT></A></LI>
<LI><A HREF="#TOC325"><TT>leftfill</TT></A></LI>
<LI><A HREF="#TOC326"><TT>rightfill</TT></A></LI>
<LI><A HREF="#TOC327"><TT>trim</TT></A></LI>
<LI><A HREF="#TOC328"><TT>ltrim</TT></A></LI>
<LI><A HREF="#TOC329"><TT>searchreplace</TT></A></LI>
<LI><A HREF="#TOC330"><TT>deletestring</TT></A></LI>
<LI><A HREF="#TOC331"><TT>getstrfld</TT></A></LI>
<LI><A HREF="#TOC332"><TT>setstrfld</TT></A></LI>
<LI><A HREF="#TOC333"><TT>getstrfldlen</TT></A></LI>
<LI><A HREF="#TOC334"><TT>findstrinfile</TT></A></LI>
<LI><A HREF="#TOC335"><TT>getequval</TT></A></LI>
<LI><A HREF="#TOC336"><TT>matchtable</TT></A></LI>
<LI><A HREF="#TOC337"><TT>stringreplace</TT></A></LI>
<LI><A HREF="#TOC338"><TT>wordwrapstr</TT></A></LI>
<LI><A HREF="#TOC339"><TT>stricstr</TT></A></LI>
<LI><A HREF="#TOC340"><TT>strtempcmp</TT></A></LI>
<LI><A HREF="#TOC341"><TT>istoken</TT></A></LI>
<LI><A HREF="#TOC342"><TT>eatstr</TT></A></LI>
<LI><A HREF="#TOC343"><TT>eatstrpast</TT></A></LI>
<LI><A HREF="#TOC344"><TT>movestrpast</TT></A></LI>
<LI><A HREF="#TOC345"><TT>eatchar</TT></A></LI>
<LI><A HREF="#TOC346"><TT>isoneoftokens</TT></A></LI>
</MENU>
<LI><A HREF="#TOC347">TCP/IP, UDP/IP socket functions</A></LI>
<MENU>
<LI><A HREF="#TOC348"><TT>sock_init</TT></A></LI>
<LI><A HREF="#TOC349"><TT>sock_term</TT></A></LI>
<LI><A HREF="#TOC350"><TT>passive_TCP</TT></A></LI>
<LI><A HREF="#TOC351"><TT>passive_UDP</TT></A></LI>
<LI><A HREF="#TOC352"><TT>passive_socket</TT></A></LI>
<LI><A HREF="#TOC353"><TT>create_socket</TT></A></LI>
<LI><A HREF="#TOC354"><TT>connect_TCP</TT></A></LI>
<LI><A HREF="#TOC355"><TT>connect_UDP</TT></A></LI>
<LI><A HREF="#TOC356"><TT>connect_TCP_fast</TT></A></LI>
<LI><A HREF="#TOC357"><TT>connect_UDP_fast</TT></A></LI>
<LI><A HREF="#TOC358"><TT>connect_socket</TT></A></LI>
<LI><A HREF="#TOC359"><TT>connect_to_peer</TT></A></LI>
<LI><A HREF="#TOC360"><TT>address_end_point</TT></A></LI>
<LI><A HREF="#TOC361"><TT>build_sockaddr</TT></A></LI>
<LI><A HREF="#TOC362"><TT>socket_localaddr</TT></A></LI>
<LI><A HREF="#TOC363"><TT>socket_peeraddr</TT></A></LI>
<LI><A HREF="#TOC364"><TT>socket_nodelay</TT></A></LI>
<LI><A HREF="#TOC365"><TT>socket_is_alive</TT></A></LI>
<LI><A HREF="#TOC366"><TT>socket_error</TT></A></LI>
<LI><A HREF="#TOC367"><TT>accept_socket</TT></A></LI>
<LI><A HREF="#TOC368"><TT>connect_error</TT></A></LI>
<LI><A HREF="#TOC369"><TT>get_sock_addr</TT></A></LI>
<LI><A HREF="#TOC370"><TT>get_peer_addr</TT></A></LI>
<LI><A HREF="#TOC371"><TT>read_TCP</TT></A></LI>
<LI><A HREF="#TOC372"><TT>write_TCP</TT></A></LI>
<LI><A HREF="#TOC373"><TT>read_UDP</TT></A></LI>
<LI><A HREF="#TOC374"><TT>write_UDP</TT></A></LI>
<LI><A HREF="#TOC375"><TT>close_socket</TT></A></LI>
<LI><A HREF="#TOC376"><TT>sock_select</TT></A></LI>
<LI><A HREF="#TOC377"><TT>get_hostname</TT></A></LI>
<LI><A HREF="#TOC378"><TT>get_hostaddr</TT></A></LI>
<LI><A HREF="#TOC379"><TT>get_hostaddrs</TT></A></LI>
<LI><A HREF="#TOC380"><TT>sock_ntoa</TT></A></LI>
<LI><A HREF="#TOC381"><TT>sockmsg</TT></A></LI>
<LI><A HREF="#TOC382"><TT>winsock_last_error</TT></A></LI>
<LI><A HREF="#TOC383"><TT>socket_is_permitted</TT></A></LI>
<LI><A HREF="#TOC384"><TT>get_host_file</TT></A></LI>
<LI><A HREF="#TOC385"><TT>get_name_server</TT></A></LI>
</MENU>
<LI><A HREF="#TOC386">Symbol-table functions</A></LI>
<MENU>
<LI><A HREF="#TOC387"><TT>sym_create_table_</TT></A></LI>
<LI><A HREF="#TOC388"><TT>sym_delete_table</TT></A></LI>
<LI><A HREF="#TOC389"><TT>sym_empty_table</TT></A></LI>
<LI><A HREF="#TOC390"><TT>sym_merge_tables</TT></A></LI>
<LI><A HREF="#TOC391"><TT>sym_lookup_symbol</TT></A></LI>
<LI><A HREF="#TOC392"><TT>sym_create_symbol_</TT></A></LI>
<LI><A HREF="#TOC393"><TT>sym_assume_symbol_</TT></A></LI>
<LI><A HREF="#TOC394"><TT>sym_delete_symbol</TT></A></LI>
<LI><A HREF="#TOC395"><TT>sym_exec_all</TT></A></LI>
<LI><A HREF="#TOC396"><TT>sym_hash</TT></A></LI>
<LI><A HREF="#TOC397"><TT>sym_get_name</TT></A></LI>
<LI><A HREF="#TOC398"><TT>sym_get_value</TT></A></LI>
<LI><A HREF="#TOC399"><TT>sym_get_number</TT></A></LI>
<LI><A HREF="#TOC400"><TT>sym_get_boolean</TT></A></LI>
<LI><A HREF="#TOC401"><TT>sym_set_value</TT></A></LI>
<LI><A HREF="#TOC402"><TT>sym_sort_table</TT></A></LI>
<LI><A HREF="#TOC403"><TT>symb2strt_</TT></A></LI>
<LI><A HREF="#TOC404"><TT>strt2symb_</TT></A></LI>
<LI><A HREF="#TOC405"><TT>symb2descr_</TT></A></LI>
<LI><A HREF="#TOC406"><TT>descr2symb_</TT></A></LI>
</MENU>
<LI><A HREF="#TOC407">System-level functions (assertions,...)</A></LI>
<MENU>
<LI><A HREF="#TOC408"><TT>sys_assert</TT></A></LI>
<LI><A HREF="#TOC409"><TT>sys_name</TT></A></LI>
</MENU>
<LI><A HREF="#TOC410">HTTP and CGI Support functions</A></LI>
<MENU>
<LI><A HREF="#TOC411"><TT>http_escape</TT></A></LI>
<LI><A HREF="#TOC412"><TT>http_escape_size</TT></A></LI>
<LI><A HREF="#TOC413"><TT>http_escape_hex</TT></A></LI>
<LI><A HREF="#TOC414"><TT>http_unescape</TT></A></LI>
<LI><A HREF="#TOC415"><TT>http_unescape_hex</TT></A></LI>
<LI><A HREF="#TOC416"><TT>http_query2strt</TT></A></LI>
<LI><A HREF="#TOC417"><TT>http_query2symb</TT></A></LI>
<LI><A HREF="#TOC418"><TT>http_query2descr</TT></A></LI>
<LI><A HREF="#TOC419"><TT>http_encode_meta</TT></A></LI>
<LI><A HREF="#TOC420"><TT>encode_meta_char</TT></A></LI>
<LI><A HREF="#TOC421"><TT>http_decode_meta</TT></A></LI>
<LI><A HREF="#TOC422"><TT>decode_meta_charn</TT></A></LI>
<LI><A HREF="#TOC423"><TT>cgi_parse_query_vars</TT></A></LI>
<LI><A HREF="#TOC424"><TT>cgi_parse_file_vars</TT></A></LI>
<LI><A HREF="#TOC425"><TT>http_multipart_decode</TT></A></LI>
<LI><A HREF="#TOC426"><TT>is_full_url</TT></A></LI>
<LI><A HREF="#TOC427"><TT>build_full_url</TT></A></LI>
<LI><A HREF="#TOC428"><TT>http_time_str</TT></A></LI>
<LI><A HREF="#TOC429"><TT>cgi_get_input</TT></A></LI>
<LI><A HREF="#TOC430"><TT>cgi_fld_by_name</TT></A></LI>
<LI><A HREF="#TOC431"><TT>cgi_fld_by_index</TT></A></LI>
<LI><A HREF="#TOC432"><TT>cgi_fld_len_by_index</TT></A></LI>
<LI><A HREF="#TOC433"><TT>displayform</TT></A></LI>
</MENU>
<LI><A HREF="#TOC434">Environment variable functions</A></LI>
<MENU>
<LI><A HREF="#TOC435"><TT>env_get_string</TT></A></LI>
<LI><A HREF="#TOC436"><TT>env_get_number</TT></A></LI>
<LI><A HREF="#TOC437"><TT>env_get_boolean</TT></A></LI>
<LI><A HREF="#TOC438"><TT>env2descr</TT></A></LI>
<LI><A HREF="#TOC439"><TT>descr2env</TT></A></LI>
<LI><A HREF="#TOC440"><TT>env2symb</TT></A></LI>
<LI><A HREF="#TOC441"><TT>symb2env</TT></A></LI>
<LI><A HREF="#TOC442"><TT>env_copy</TT></A></LI>
</MENU>
<LI><A HREF="#TOC443">String token manipulation functions.</A></LI>
<MENU>
<LI><A HREF="#TOC444"><TT>tok_split</TT></A></LI>
<LI><A HREF="#TOC445"><TT>tok_split_rich</TT></A></LI>
<LI><A HREF="#TOC446"><TT>tok_free</TT></A></LI>
<LI><A HREF="#TOC447"><TT>tok_push</TT></A></LI>
<LI><A HREF="#TOC448"><TT>tok_size</TT></A></LI>
<LI><A HREF="#TOC449"><TT>tok_text_size</TT></A></LI>
<LI><A HREF="#TOC450"><TT>tok_subst</TT></A></LI>
</MENU>
<LI><A HREF="#TOC451">Linked-list functions</A></LI>
<MENU>
<LI><A HREF="#TOC452"><TT>tree_init</TT></A></LI>
<LI><A HREF="#TOC453"><TT>tree_insert</TT></A></LI>
<LI><A HREF="#TOC454"><TT>tree_delete</TT></A></LI>
<LI><A HREF="#TOC455"><TT>tree_find_eq</TT></A></LI>
<LI><A HREF="#TOC456"><TT>tree_find_lt</TT></A></LI>
<LI><A HREF="#TOC457"><TT>tree_find_le</TT></A></LI>
<LI><A HREF="#TOC458"><TT>tree_find_gt</TT></A></LI>
<LI><A HREF="#TOC459"><TT>tree_find_ge</TT></A></LI>
<LI><A HREF="#TOC460"><TT>tree_traverse</TT></A></LI>
<LI><A HREF="#TOC461"><TT>tree_first</TT></A></LI>
<LI><A HREF="#TOC462"><TT>tree_last</TT></A></LI>
<LI><A HREF="#TOC463"><TT>tree_next</TT></A></LI>
<LI><A HREF="#TOC464"><TT>tree_prev</TT></A></LI>
</MENU>
<LI><A HREF="#TOC465">Tracing functions</A></LI>
<MENU>
<LI><A HREF="#TOC466"><TT>enable_trace</TT></A></LI>
<LI><A HREF="#TOC467"><TT>disable_trace</TT></A></LI>
<LI><A HREF="#TOC468"><TT>push_trace</TT></A></LI>
<LI><A HREF="#TOC469"><TT>pop_trace</TT></A></LI>
<LI><A HREF="#TOC470"><TT>set_trace_file</TT></A></LI>
<LI><A HREF="#TOC471"><TT>trace</TT></A></LI>
</MENU>
<LI><A HREF="#TOC472">Process user id (uid) and group id (gid) functions</A></LI>
<MENU>
<LI><A HREF="#TOC473"><TT>get_uid_name</TT></A></LI>
<LI><A HREF="#TOC474"><TT>get_gid_name</TT></A></LI>
<LI><A HREF="#TOC475"><TT>set_uid_user</TT></A></LI>
<LI><A HREF="#TOC476"><TT>set_uid_root</TT></A></LI>
<LI><A HREF="#TOC477"><TT>set_gid_user</TT></A></LI>
<LI><A HREF="#TOC478"><TT>set_gid_root</TT></A></LI>
<LI><A HREF="#TOC479"><TT>set_uid_gid</TT></A></LI>
<LI><A HREF="#TOC480"><TT>get_login</TT></A></LI>
</MENU>
<LI><A HREF="#TOC481">XML (Extensible Markup Language) access functions</A></LI>
<MENU>
<LI><A HREF="#TOC482"><TT>xml_create</TT></A></LI>
<LI><A HREF="#TOC483"><TT>xml_new</TT></A></LI>
<LI><A HREF="#TOC484"><TT>xml_modify_value</TT></A></LI>
<LI><A HREF="#TOC485"><TT>xml_rename</TT></A></LI>
<LI><A HREF="#TOC486"><TT>xml_item_name</TT></A></LI>
<LI><A HREF="#TOC487"><TT>xml_item_value</TT></A></LI>
<LI><A HREF="#TOC488"><TT>xml_free</TT></A></LI>
<LI><A HREF="#TOC489"><TT>xml_attach_child</TT></A></LI>
<LI><A HREF="#TOC490"><TT>xml_attach_sibling</TT></A></LI>
<LI><A HREF="#TOC491"><TT>xml_detach</TT></A></LI>
<LI><A HREF="#TOC492"><TT>xml_first_child</TT></A></LI>
<LI><A HREF="#TOC493"><TT>xml_last_child</TT></A></LI>
<LI><A HREF="#TOC494"><TT>xml_next_sibling</TT></A></LI>
<LI><A HREF="#TOC495"><TT>xml_prev_sibling</TT></A></LI>
<LI><A HREF="#TOC496"><TT>xml_parent</TT></A></LI>
<LI><A HREF="#TOC497"><TT>xml_put_attr_ic</TT></A></LI>
<LI><A HREF="#TOC498"><TT>xml_attr_ic</TT></A></LI>
<LI><A HREF="#TOC499"><TT>xml_attr_name</TT></A></LI>
<LI><A HREF="#TOC500"><TT>xml_attr_value</TT></A></LI>
<LI><A HREF="#TOC501"><TT>xml_get_attr_ic</TT></A></LI>
<LI><A HREF="#TOC502"><TT>xml_free_attr</TT></A></LI>
<LI><A HREF="#TOC503"><TT>xml_first_attr</TT></A></LI>
<LI><A HREF="#TOC504"><TT>xml_last_attr</TT></A></LI>
<LI><A HREF="#TOC505"><TT>xml_next_attr</TT></A></LI>
<LI><A HREF="#TOC506"><TT>xml_prev_attr</TT></A></LI>
<LI><A HREF="#TOC507"><TT>xml_changed</TT></A></LI>
<LI><A HREF="#TOC508"><TT>xml_refresh</TT></A></LI>
</MENU>
<LI><A HREF="#TOC509">XML serialisation functions</A></LI>
<MENU>
<LI><A HREF="#TOC510"><TT>xml_save_file</TT></A></LI>
<LI><A HREF="#TOC511"><TT>xml_save_string</TT></A></LI>
<LI><A HREF="#TOC512"><TT>xml_error</TT></A></LI>
<LI><A HREF="#TOC513"><TT>xml_seems_to_be</TT></A></LI>
<LI><A HREF="#TOC514"><TT>xml_load_file</TT></A></LI>
<LI><A HREF="#TOC515"><TT>xml_load_string</TT></A></LI>
</MENU>
</MENU>

<H2><A NAME="TOC1">What Is The SFL</A></H2>

<H3><A NAME="TOC2">Origins</A></H3>

<P>At iMatix we develop portable free and commercial software. We work in
ANSI C to cover the widest range possible. A major part of our toolkit has
always been our subroutine library. This was initially written for MS-DOS in
1991 but has developed into a more ambitious project since then.

<P>From the outset, we ignored commercial libraries. Our software is usually
Open Source and using a commercial library would have been a problem. We
looked for free libraries, but found only specialised and mostly
non-portable collections of functions. So, we built our own. We hope you
like it. We certainly use it all the time.

<H3><A NAME="TOC3">Objectives</A></H3>

<P>When we designed the SFL, we had certain things in mind:

<UL>
<LI>Portability: we are lazy, and don't have much time. So, we want to do
our editing and testing on the fastest PC possible, then move the results to
a 'real' system (UNIX, VMS, whatever) recompile, and test. Obviously, some
code cannot be tested fully on all systems - we don't have sockets under
MS-DOS - but this approach works for most projects. The SFL
<EM>encapsulates</EM> non-portable aspects so that application programs do
not need to know about specific systems.

<LI>Building servers, i.e. programs that run in the background, for a long
time, without intervention from a user or operator. Servers have specific
needs, and must be extremely robust, since they must run for long periods.
The SFL provides many functions that are specifically meant for this type of
program.

<LI>Functionality: the classic purpose of any library. If a problem has a
clean, tested, documented, and portable solution, we will use that instead
of re-inventing it. The SFL provides a stable home for code that might
otherwise float around in various projects.

<LI>Discipline: we make our code public, and expect people to read it. We
actually include the code for each function as part of its documentation.
This forces us to be crystal clear.

<LI>Hubris: we think our code is so great that it should live for ever. So,
we take great pains to make it useful, clean, efficient, and well-packaged,
so you'll think so too.
</UL>

<H3><A NAME="TOC4">Portability</A></H3>

<P>The SFL is in use on at least these systems:
<UL>
<LI>MS-Windows (MSVC, Borland, Watcom, gcc)
<LI>MS-DOS (MSVC, Borland Turbo-C)
<LI>OS/2 (EMX)
<LI>Linux
<LI>IBM RS/6000 AIX
<LI>Sun SunOS
<LI>Sun Solaris
<LI>HP HP/UX
<LI>Digital UNIX
<LI>FreeBSD
<LI>NetBSD
<LI>SCO OpenServer
<LI>SCO UnixWare
<LI>Digital OpenVMS
</UL>

<P>Some recent functions may not have been tested or implemented across all
platforms. Some functions are empty on some platforms. Since the SFL is
continually improving and enlarging, there are always newer functions that
are less tested, and possibly less than 100% portable. Our intention is that
the transparency of the SFL makes these functions easy to test and improve.

<H2><A NAME="TOC5">Installing The SFL</A></H2>

<H3><A NAME="TOC6">Availability and Distribution</A></H3>

<P>We supply the SFL as two archives: a source kit and a documentation kit
(in HTML). These files are available for download by HTTP from our
<A href="http://www.imatix.com/">website</A> on a permanent basis. You need to recompile the SFL for
your specific system, using an ANSI C compiler. We don't provide binary kits
for several reasons:
<UL>
<LI>With one source archive and one documentation archive, the
SFL is easier to distribute.
<LI>The SFL changes rapidly - a source distribution is simpler.
<LI>You can pick and choose the functions you want.
<LI>The sources are the primary source of documentation.
<LI>The license terms are such that the sources must be supplied
or be available in any case.
</UL>

<H4>Getting The Source Archive</H4>

<P>The SFL source archive is supplied as a <A href="/pub/sfl/src/sflsrc21.zip">zip file</A>
and a <A href="/pub/sfl/src/sflsrc21.tgz">GNU gzipped tar file</A>.  These are the files in
the /pub/sfl/src directory:
<PRE>
<A href="/pub/sfl/src/sflsrc20.tgz">sflsrc20.tgz </A>   383249 100/04/01 16:25:11  Gzip/tar archive
<A href="/pub/sfl/src/sflsrc20.zip">sflsrc20.zip </A>   482192 100/04/01 16:25:01  ZIP archive
<A href="/pub/sfl/src/sflsrc21.tgz">sflsrc21.tgz </A>   332405 99/08/27 16:53:46  Gzip/tar archive
<A href="/pub/sfl/src/sflsrc21.zip">sflsrc21.zip </A>   478117 99/12/30 14:08:19  ZIP archive
</PRE>

<P>If you have trouble accessing the iMatix site, send us an
<A href="mailto:info@imatix.com">e-mail</A> and we'll send you the SFL archives by return
e-mail.

<H4>Getting The The Documentation Kit</H4>

<P>The SFL documentation is supplied as HTML files, available on-line or
off-line as a <A href="/pub/sfl/doc/sfldoc21.zip">single .zip file</A> that you can install on a hard
disk for rapid access, and also as a <A href="/pub/sfl/doc/sfldoc21.tgz">gzipped tar file</A>.
These are the files in the /pub/sfl/doc directory:
<PRE>
<A href="/pub/sfl/doc/sflbig20.tgz">sflbig20.tgz </A>   206059 100/04/01 16:25:14  Gzip/tar archive
<A href="/pub/sfl/doc/sflbig20.zip">sflbig20.zip </A>   207473 100/04/01 16:24:54  ZIP archive
<A href="/pub/sfl/doc/sflbig21.tgz">sflbig21.tgz </A>   199270 99/08/27 16:53:48  Gzip/tar archive
<A href="/pub/sfl/doc/sflbig21.zip">sflbig21.zip </A>   200592 99/08/27 16:53:31  ZIP archive
<A href="/pub/sfl/doc/sfldoc20.tgz">sfldoc20.tgz </A>   254613 100/04/01 16:25:42  Gzip/tar archive
<A href="/pub/sfl/doc/sfldoc20.zip">sfldoc20.zip </A>   685112 100/04/01 16:24:53  ZIP archive
<A href="/pub/sfl/doc/sfldoc21.tgz">sfldoc21.tgz </A>   246972 99/08/27 16:54:35  Gzip/tar archive
<A href="/pub/sfl/doc/sfldoc21.zip">sfldoc21.zip </A>   663278 99/08/27 16:53:30  ZIP archive
</PRE>

<P>We recommend that you unzip or gunzip/detar the archive into a
subdirectory.  Point your browser at the <TT>index.htm</TT> file.
We use relative addressing in all HTML documents, so that links
work just as well on a local hard-disk as on-line on our website.
In a windowing environment is it easy and useful to create an icon
that runs a Web browser on this file.

<HR>
<H3><A NAME="TOC7">Installation for UNIX Systems</A></H3>

<P>To install the SFL on a UNIX system you need to:
<OL>
<LI>Download the source archive and decompress it.
<LI>Run the 'build' script to compile the SFL sources and build
the libsfl.a archive file.
<LI>Optionally, install the libsfl.a file in the /usr/lib
directory.
<LI>Optionally, install the SFL header file(s) in the /usr/include
directory.
</OL>

<H4>Decompressing The Source Archive</H4>

<P>To unzip the <A href="/pub/sfl/src/sflsrc21.zip">source .zip file</A>, you need the Infozip
<A href="http://quest.jpl.nasa.gov/Info-Zip/Info-Zip.html">unzip</A> tool:
<PRE>$ mkdir temp
$ mv sflsrc21.zip temp
$ cd temp
$ unzip -a sflsrc21
</PRE>

<P>To decompress the <A href="/pub/sfl/src/sflsrc21.tgz">source archive</A> you need GNU
gzip/gunzip and tar:
<PRE>$ mkdir temp
$ mv sflsrc21.tgz temp
$ cd temp
$ gzip -d sflsrc21.tgz
  or
$ gunzip sflsrc21.tgz
$ tar -xvf sflsrc21.tar
</PRE>

<P>You can also, in extreme cases, unzip the files on a PC and
transfer the individual files to the UNIX system.

<H4>Compiling The SFL Sources</H4>

<P>The SFL source archive includes a script, <TT><B>c</B></TT>,
that you can (and should) use to compile the SFL sources.  This
script invokes the ANSI C compiler to produce an object code file.
It detects the platform and invokes the compiler with the
necessary switches for ANSI C compilation.  On some systems this
is the normal behaviour for the <B>cc</B> command.  On other
systems it is not normal.  You should make the <TT>c</TT> script
executable, (preferrably) install it in a shared directory like
/usr/local/bin, and try it out:
<PRE>$ chmod a+rx c
$ mv c /usr/local/bin
$ c
</PRE>

<P>To compile the SFL sources, use this command:
<PRE>$ chmod +x build
$ ./build
</PRE>

<P>If you get warnings or error messages, this is usually a bad
sign.  Some compilers issue warnings just because you ask for ANSI
compilation.  If you get any other error messages, please let us
know.

<P>You can use individual SFL files simply by specifying them on
the command line when you compile and link a program.  However,
this is usually a pain.  Therefore, the build script creates a
library file called libsfl.a.  The linker can automatically search
this file for the SFL functions.  To install libsfl.a in the
/usr/lib directory, do this:
<PRE>$ mv libsfl.a /usr/lib
</PRE>

<H4>Using The SFL In Your Applications</H4>

<P>To use an SFL function in your applications you must include a
header file that defines the structures, prototypes, and types for
the function API.  The SFL provides three types of header
files:
<OL>
<LI>One header file per function group.  These are provided for
reference; you will normally not use these directly.
<LI>A <A href="sfldoc.htm#uhf">Universal Header File</A> which encapsulates and
replaces all local header files.  Again, this is provided for
reference; you do not normally use this directly.
<LI>A <A href="sfldoc.htm#lhf">Library Header File</A> that contains the Universal
Header File and all the SFL header files in one go.  This is meant
to simplify application programming and installation.
</OL>

<P>We recommend that you install the <TT>sfl.h</TT> file in
/usr/include.  A typical application program starts like this:
<PRE>#include &lt;sfl.h&gt;
</PRE>

<P>To link an application program, use the <TT>c -l</TT> command.
This assumes that libsfl.a is installed /usr/lib.

<HR>
<H3><A NAME="TOC8">Installation for Digital VMS Systems</A></H3>

<P>To install the SFL on a Digital VMS system you need to:
<OL>
<LI>Download the source archive and decompress it.
<LI>Run the 'build.txt' command file to build the libsfl.olb
library file.
<LI>Optionally, install the libsfl.olb file in the SYS$LIBRARY
directory.
<LI>Optionally, install the SFL header file(s) in the SYS$LIBRARY
directory.
</OL>

<H4>Decompressing The Source Archive</H4>

<P>To unzip the <A href="/pub/sfl/src/sflsrc21.zip">source .zip file</A>, you need the Infozip
<A href="http://quest.jpl.nasa.gov/Info-Zip/Info-Zip.html">unzip</A> tool (note that you need the -a switch):
<PRE>$ create/dir [.temp]
$ ren sflsrc21.zip [.temp]
$ set def [.temp]
$ unzip -a sflsrc21
</PRE>

<P>You can also, in extreme cases, unzip the files on a PC and
transfer the individual files to the VMS system.

<H4>Compiling The SFL Sources</H4>

<P>To compile the SFL sources, use this command:
<PRE>$ @build.txt
</PRE>

<P>If you get warnings or error messages, this is a bad sign -
please let us know.

<P>The build.txt command file creates a library file called
libsfl.olb.  You can install this in a central directory like
SYS$LIBRARY if you wish.  You'll need system privileges to do
this.

<H4>Using The SFL In Your Applications</H4>

<P>To use an SFL function in your applications you must include a
header file that defines the structures, prototypes, and types for
the function API.  The SFL provides three types of header
files:
<OL>
<LI>One header file per function group.  These are provided for
reference; you will normally not use these directly.
<LI>A <A href="sfldoc.htm#uhf">Universal Header File</A> which encapsulates and
replaces all local header files.  Again, this is provided for
reference; you do not normally use this directly.
<LI>A <A href="sfldoc.htm#lhf">Library Header File</A> that contains the Universal
Header File and all the SFL header files in one go.  This is meant
to simplify application programming and installation.
</OL>

<P>We recommend that you install the <TT>sfl.h</TT> file in
SYS$LIBRARY.  A typical application program starts like this:
<PRE>#include &lt;sfl.h&gt;
</PRE>

<HR>
<H3><A NAME="TOC9">Installation for Windows</A></H3>

<P>Briefly, either create a static library, and include that in
your project; create a .DLL and call that, or add the files you
want to use to your project and compile them as part of the
application.

<P>With MSVC 4.0, we find it useful to create a main project for the
application in hand, and a subproject for the SFL. We build the SFL as a
static library. If you use MFC, you must compile everything (including MFC)
in single-threaded mode, and use libd.

<P>Under MSVC 1.5x, there is a bug in the project manager that generates
invalid make files: the SFL prelude.h file refers to various non-Windows
include files, within #if statements. The MSVC 1.5x project manager includes
these in the make file; you must manually remove them. One solution is to
edit prelude.h; another is to use a Perl or Awk script to edit the make file
each time you change the project. You could also move to a different 16-bit
compiler. Finally, you can create the make files as empty files in the C
include directory.

<P>To build using the build.bat file with MSVC, you need to increase the
environment space to (e.g. to 16K), and define some variables in the
autoexec.bat file:
<PRE>SET CCNAME=msvc
SET CCDIR=C:\MSDEVSTD
SET INCDEF=C:\MSDEVSTD\INCLUDE
SET LIBDIR=C:\MSDEVSTD\sfl\lib
</PRE>
Where the LIBDIR variable is the directory where you unzipped the SFL stuff.


<HR>
<H3><A NAME="TOC10">Installation for MS-DOS</A></H3>

<P>To install the SFL on a MS-DOS system you need to:
<OL>
<LI>Download the source archive and decompress it.
<LI>Run build.bat to build the libsfl.lib library file.
<LI>Optionally, install the libsfl.lib file in central
directory.
<LI>Optionally, install the SFL header file(s) in a central
directory.
</OL>

<H4>Decompressing The Source Archive</H4>

<P>To unzip the <A href="/pub/sfl/src/sflsrc21.zip">source .zip file</A>, you need the Infozip
<A href="http://quest.jpl.nasa.gov/Info-Zip/Info-Zip.html">unzip</A> tool, or PKzip version 2.04g or later, or a
compatible unzip program.:
<PRE>C:\DOWNLOAD> md temp
C:\DOWNLOAD> copy sflsrc21.zip temp
C:\DOWNLOAD> del sflsrc21.zip
C:\DOWNLOAD> cd temp
C:\DOWNLOAD> unzip sflsrc21
</PRE>

<H4>Compiling The SFL Sources</H4>

<P>To compile under MS-DOS you need a Borland, Microsoft, or Watcom
compiler, or lcc-win32 or djgpp.  Look at the c.bat file, and set the
CCNAME and/or CCDIR environment variables as required.  Then, check that you
can compile a single program. e.g. 'c sflbits'.  When this works, run the
build.bat file to rebuild everything.

<P>The build scripts create a library file called libsfl.lib. You can
install this, and sfl.h, in a central directory if you wish.

<H4>Using The SFL In Your Applications</H4>

<P>To use an SFL function in your applications you must include a
header file that defines the structures, prototypes, and types for
the function API.  The SFL provides three types of header
files:
<OL>
<LI>One header file per function group.  These are provided for
reference; you will normally not use these directly.
<LI>A <A href="sfldoc.htm#uhf">Universal Header File</A> which encapsulates and
replaces all local header files.  Again, this is provided for
reference; you do not normally use this directly.
<LI>A <A href="sfldoc.htm#lhf">Library Header File</A> that contains the Universal
Header File and all the SFL header files in one go.  This is meant
to simplify application programming and installation.
</OL>

<P>We recommend that you install the <TT>sfl.h</TT> file in the
/include directory of your compiler.  A typical application
program starts like this:
<PRE>#include &lt;sfl.h&gt;
</PRE>

<H2><A NAME="TOC11">Using The SFL</A></H2>

<A NAME="uhf">&nbsp;</A>
<H3><A NAME="TOC12">The Universal Header File - prelude.h</A></H3>

<H4>What and Why?</H4>

<P>The Universal Header File a technology that we have developed
to make C applications more easily portable with less effort.  One
of the big difficulties in compiling C code on different platforms
is that header files change their names, locations, and internal
functions from system to system, even on one system over time.

<P>Typically, you may see C programs that start with a rash of
<TT>#ifdef</TT>'s mixed with <TT>#include</TT>'s depending on the
system, compiler, and specific needs of the program.

<P>Since we are basically really lazy, all this unnecessary work
is intolerable.  We would <EM>much</EM> rather make the compiler
work harder.  The systems we develop on (typically MS-DOS with
Turbo-C) are so fast that we can afford to take a really lazy
approach.

<P>So, what we do is this: we include every 'useful' and
'standard' header file that we can think of.  We then include
every 'useful' non-portable file that we've ever needed, in a
clean way, so that application code does not need to 'know' how it
was done.

<P>At the same time we define lots of things that make life
easier.  Generally we don't like macros, since these create
'pseudo languages' that are just more work to learn.  However,
some things (like <TT>#define FOREVER for (;;)</TT>) are so useful
and pretty comonplace, so we stick them in too.

<P>Lastly, we flatten-out the problem called 'what system am I
running on', by providing a set of definitions like
<TT>__UNIX__</TT> and <TT>__UTYPE_SUNOS</TT> that code can use if
it has to.  Again, it can be quite messy to figure-out that we're
compiling on a Brand X, so we need this-and-that header file.  We
hide this so that we can forget about it.

<P>Okay, those are the benefits of this approach.  What are the
costs?  We typically hear these criticisms:
<UL>
<LI>Compilation is a <EM>lot</EM> slower.  True, but when you
create portable applications, you can do 90% of your compiles on a
system that is so fast that this is irrelevant
<LI>Some C programmers may feel they are losing control over which
header files are included, in which order, etc.  True, but it's
the kind of control we don't want.
<LI>We get some comments about 'polluting the namespace'.  We
don't really understand this one.  We try to stay away from
already-defined symbols.
<LI>People don't like the macros we define, like TRUE and FALSE.
This can become a matter of personal choice; we've tried to
provide useful stuff without becoming baroque.
</UL>

<P>We use the Universal Header File in <EM>all</EM> C projects
(not just those based on the SFL).  If it was not for the simple
fact that it has helped us a lot, we'd probably not make it
available.

<H4>Using the Universal Header File</H4>

<P>You should probably read through the <TT>prelude.h</TT> file to
best understand it.  Our usual habit is to comment the code first,
so that it's self-explanatory.  The SFL documentation has a
section on the Universal Header File.  This section is generated
from the code.

<P>When you use the SFL Library Header File (<TT>sfl.h</TT>), you
don't need to include <TT>prelude.h</TT>, since it's already
embedded in <TT>sfl.h</TT>.  This makes application programming
easier (just one header file to include).  If you need to change
<TT>prelude.h</TT>, you can either change <TT>sfl.h</TT> as well,
or rebuild <TT>sfl.h</TT> using the build script.  Better still,
tell us what you want to change, so that we can maintain a single
version of the file.

<A NAME="lhf">&nbsp;</A>
<H3><A NAME="TOC13">The Library Header File - sfl.h</A></H3>

<P>Each module in the SFL consists of a header file and one or
more C source files.  You can choose to include the header files
that you want (this is what the SFL source code does), but this
can quickly become burdensome.  To simplify matters, a single
header file <TT>sfl.h</TT> contains all the individual header
files.  It also contains the Universal Header File.

<H3><A NAME="TOC14">System Notes</A></H3>

<H4>MS-DOS</H4>

<P>Most of the SFL is portable to MS-DOS.  Exceptions are: the
socket i/o functions (sflsock), the user/group ID functions
(sfluid) and the server process functions (sflserv).  These are
all null; you can call any of the functions, but they will return
either an okay feedback (in most cases) or an error feedback (for
the socket functions).  The SFL compiles cleanly with Borland
Turbo C/C++ 1.0 and Microsoft VC++ 4.x and 5.x, and should work
with Borland C/C++ and C++ Builder.

<H4>MS-Windows</H4>

<P>Most of the SFL is portable to Windows 3.x, Windows 95, and
Windows NT.  Exceptions are: the user/group ID functions (sfluid)
and the server process functions (sflserv).  These are all null;
you can call any of the functions, but they will return an okay
feedback.  The SFL compiles cleanly with Microsoft VC++ 4.x and
5.x, and should work with Borland C/C++ and C++ Builder.

<H4>Digital VAX</H4>

<P>The SFL is portable to Digital VMS except for the directory
access functions (sfldir), user/group functions (sfluid) and the
server process functions (sflserv).  The sfldir functions will be
implemented at a later date.  The other functions are null; you
can call any of the functions, but they will return an okay
feedback.  The SFL compiles cleanly with Vax C and Dec C and has
been tested with various releases of these compilers.

<H4>Linux</H4>

<P>The SFL is fully portable to Linux and has been tested with GNU
C.  It should give no compiler warning errors.

<H4>Sun OS and Sun Sparc</H4>

<P>The SFL is fully portable to Sun OS.  You may have trouble
finding an ANSI C compiler, especially on Sparc systems.  People
sometimes install GNU C, using the Sun header files and libraries.
This should work, although we have not tested it recently.
Sometimes the Sun ANSI C compiler is called acc, not cc.  You can
use the CCNAME environment variable to point to the right compiler
name.  Some Sun C compilers give warnings when you use the ANSI
compile mode.  You can ignore these warnings.

<P>See also the warning about 'Other UNIX Systems'; some SunOS
installations show this symptom.

<H4>HP/UX</H4>

<P>The SFL is fully portable to HP/UX.  It should give no compiler
warning errors.

<H4>IBM AIX</H4>

<P>The SFL is fully portable to IBM/AIX.  It should give no
compiler warning errors.

<H4>Digital UNIX</H4>

<P>The SFL is fully portable to Digital UNIX.  It should give no
compiler warning errors.  When compiling on an Alpha system, the
word size is 64 bits.

<H4>Other UNIX Systems</H4>

<P>The directory functions can fail on SVr4 if the &lt;dirent.h&gt;
file does not match the C library.  Recompile with CCDEFINES set to
the value "-D _USE_BSD_DIRENT" and they should work a bit better.
Under Solaris with GCC, you should <EM>not</EM> define this macro.

<H4>OS/2</H4>

<P>The SFL was ported to OS/2 by Ewen McNiell around New Year's
Eve 1996.  It runs under EMX.  The SFL distribution kit includes
an OS/2 build script.  The 'c' script runs under OS/2 as well as
UNIX.

<H3><A NAME="TOC15">To Do List</A></H3>

<UL>
<LI>There are many areas that we've just started to look at, or
have ignored completely.  For instance, the encryption functions
are useful but basic.
<LI>We have not conducted exhaustive tests on all platforms, so
while older routines are certainly very well tested and portable,
some of the newer ones are still doubtful.  What we would really
like (sigh) is an automated test suite that checks-out every
function.
<LI>The bitstring functions in SFLBITS are part of an ongoing
project.  We are building an indexing tool that provides the kind
of fast lookup you find in modern search engines.  The basic idea
is really quite simple.  You number each text block (page, file,
paragraph).  Then you read the text and take each word.  The word
corresponds to a bitstring, with one bit corresponding to each
text block.  So, if you have a million text blocks, the bitstring
is a million bits long.  You set the corresponding bit for that
text block to 1, and save the bitmap.  You repeat this for all
words in all blocks of text.  That's the indexing part.  Now, to
do a lookup, you take the bitstrings that correspond to the words
entered.  Each bitstring is effectively a list of text blocks.
You can AND and OR the bitstrings to come-up with a final result.
Find all the 1's, read the text blocks, and that's it.  Of course
the real work is to make the results useful: you have to filter
junk, false matches, etc.  The bitstring functions currently just
do one thing: they let you store and change really long bitmaps
in a compressed form.
</UL>

<H2><A NAME="TOC16">Contributors and References</A></H2>

<UL>
<LI>The main authors of the SFL were:
Pieter Hintjens &lt;ph@imatix.com&gt;,
Pascal Antonnaux &lt;pascal@imatix.com&gt;,
Jonathan Schultz &lt;jonathan@imatix.com&gt;, and
Ewen McNeill &lt;ewen@imatix.com&gt;.
Scott Beasley &lt;jscottb@InfoAve.Com&gt;
<LI>Many dozens of people helped make the SFL a great library, and
we've stopped trying to list them all.  You know who you are, and
we thank you.
<LI>The xstrcat() function was based on a snippet from Dr Dobb's
Journal, Nov 1992, p. 155.
<LI>The strhash() function was based on an article in Dr Dobb's
Journal, Apr 1996, p. 26.  The original algorithm was by Peter
Weinberger.
<LI>The strmatch() function was based on an algorithm by Leif
Svalgaard &lt;leif@ibm.net&gt;.
<LI>The LZ compression functions were based on work by Kurt Haenen
&lt;ghgaea8@blekul11&gt;.
<LI>The symbol table functions were based on code provided with
MKS Lex and Yacc for MS-DOS.
<LI>The socket i/o functions were originally based on the book
"Internetworking With TCP/IP Volume III: Client-Server Programming
And Applications BSD Socket Version" by Douglas E. Comer and David
L. Stevens, published 1993 by Prentice-Hall Inc. ISBN
0-13-020272-X
<LI>The encryption functions were based on the cryptosystem
library by Andrew Brown &lt;asb@cs.nott.ac.uk&gt;.
<LI>The date_to_days() and days_to_date() functions were based on
work by Robert G. Tantzen (Collected Algorithms of The CACM number
199), translated into C by Nat Howard.
<LI>The memfind() function was based on work by R. Boyer and S.
Moore, CACM 20 762-72, with improvements by R. N. Horspool, A.
Hume, and D. M. Sunday.
<LI>The point-in-shape functions were based on code in the NCSA
HTTPd server.
<LI>The MIME encoding/decoding functions were based on RFC 1123
and RFC 1521.
<LI>The UNIX 'c' script contains code taken from the libwww
installation script.
</UL>

<P>If you want beginners C material to cushion the learning curve,
you might want to try an informative text, "Pointers on C" by Kenneth
A. Reek, ISBN# 0-673-99986-6.

<A NAME="license">&nbsp;</A>

<H2><A NAME="TOC17">The SFL License Agreement</A></H2>

<P>This license agreement covers your use of the iMatix <EM>STANDARD
FUNCTION LIBRARY (SFL)</EM>, its source code, documentation, and executable
files, hereinafter referred to as <EM>"the Product"</EM>.

<P>The Product is Copyright &#169; 1991-2000 iMatix Corporation. You may use
it and distribute it according to this following License Agreement. If you
do not agree with these terms, please remove the Product from your system.
By incorporating the Product in your work or distributing the Product to
others you implicitly agree to these license terms.

<H3>Statement Of Copyright</H3>

<P>The Product is, and remains, Copyright &#169; 1991-2000 iMatix Corporation,
with exception of specific copyrights as noted in the individual source
files.

<H3>Conditions Of Use</H3>

<P>You do not need to provide the source code for the Product as
part of your product.  However, you must do one of these things to
comply with the Product License Agreement:
<OL>
<LI>Provide the source code for Product modules that you use, or

<LI>Make your product freely available according to a license
similar to the GNU General Public License, or the Perl Artistic
License, or
<LI>Add this phrase to the documentation for your product:
<EM>"This product uses parts of the iMatix SFL, Copyright &#169;
1991-2000 iMatix Corporation &lt;http://www.imatix.com&gt;"</EM>.
</OL>

<H3>Rights Of Usage</H3>

<P>You may freely and at no cost use the Product in any project,
commercial, academic, military, or private, so long as you respect
the License Agreement.  The License Agreement does not affect any
software except the Product.  In particular, any application that
uses the Product does not itself fall under the License Agreement.


<P>You may modify any part of the Product, including sources and
documentation, except this License Agreement, which you may not
modify.

<P>You must clearly indicate any modifications at the start of
each source file.  The user of any modified Product code must know
that the source file is not original.

<P>At your discretion, you may rewrite or reuse any part of the
Product so that your derived code is not obviously part of the
Product.  This derived code does not fall under the Product
License Agreement directly, but you must include a credit at the
start of each source file indicating the original authorship and
source of the code, and a statement of copyright as follows:<BR>
<EM>"Parts copyright (c) 1991-2000 iMatix Corporation."</EM>

<H3>Rights Of Distribution</H3>

<P>You may freely distribute the Product, or any subset of the
Product, by any means.  The License, in the form of the file
called "LICENSE.TXT" must accompany any such distribution.

<P>You may charge a fee for distributing the Product, for
providing a warranty on the Product, for making modifications to
the Product, or for any other service provided in relation to the
Product.  You are not required to ask our permission for any of
these activities.

<P>At no time will iMatix associate itself with any distribution
of the Product except that supplied from the Internet site
http://www.imatix.com.

<H3>Disclaimer Of Warranty</H3>

<P>The Product is provided as free software, in the hope that it
will be useful.  It is provided "as-is", without warranty of any
kind, either expressed or implied, including, but not limited to,
the implied warranties of merchantability and fitness for a
particular purpose.  The entire risk as to the quality and
performance of the Product is with you.  Should the Product prove
defective, the full cost of repair, servicing, or correction lies
with you.
<H2><A NAME="TOC18">Universal Header File for C programming</A></H2>
<P>Filename: prelude.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1993/03/29 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 2000/02/11
<BR>Copyright: Copyright (c) 1991-99 iMatix Corporation
<BR>Version: 2.04 <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>2.04 PH</B>  <TD ALIGN="LEFT">Added BeOS
   support <TR><TD ALIGN="LEFT"><B>2.02 PH</B>  <TD
   ALIGN="LEFT">Released with SFL 2.02 </TABLE>
<H3>Synopsis</H3>
<P>This header file encapsulates many generally-useful include
   files and defines lots of good stuff. The intention of this
   header file is to hide the messy #ifdef's that you typically
   need to make real programs compile &amp; run. To use, specify
   as the first include file in your program. The main
   contributors to this file were: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>PH</B>  <TD ALIGN="LEFT">Pieter Hintjens
   &lt;ph@imatix.com&gt; <TR><TD ALIGN="LEFT"><B>EDM</B>  <TD
   ALIGN="LEFT">Ewen McNeill &lt;ewen@imatix.com&gt; <TR><TD
   ALIGN="LEFT"><B>PA</B>  <TD ALIGN="LEFT">Pascal Antonnaux
   &lt;pascal@imatix.com&gt; <TR><TD ALIGN="LEFT"><B>BW</B>  <TD
   ALIGN="LEFT">Bruce Walter &lt;walter@fortean.com&gt; <TR><TD
   ALIGN="LEFT"><B>RJ</B>  <TD ALIGN="LEFT">Rob Judd
   &lt;judd@alphalink.com.au&gt; </TABLE>
<H4>List of Functions</H4>
<UL>
<LI>void <A href="sfldoc.htm#sys_assert">sys assert</A><BR>
   (const char *filename, unsigned line_number);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>prelude.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>ASSERT(f)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>DEBUG</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>DOES_BSDSIGNALS</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>DOES_SNPRINTF</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>DOES_SOCKETS</B>  </TT>
<TD ALIGN="LEFT">/* System supports BSD sockets */
<TR><TD ALIGN="LEFT"><TT><B>DOES_UID</B>  </TT>
<TD ALIGN="LEFT">/* System supports uid functions */
<TR><TD ALIGN="LEFT"><TT><B>EXIT_FAILURE</B>  </TT>
<TD ALIGN="LEFT">1 /* GCC, sometimes. */
<TR><TD ALIGN="LEFT"><TT><B>EXIT_SUCCESS</B>  </TT>
<TD ALIGN="LEFT">0 /* but not defined on SunOs with */
<TR><TD ALIGN="LEFT"><TT><B>FALSE</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>FD_SETSIZE</B>  </TT>
<TD ALIGN="LEFT">1024 /* Max. filehandles/sockets */
<TR><TD ALIGN="LEFT"><TT><B>FOREVER</B>  </TT>
<TD ALIGN="LEFT">for (;;) /* FOREVER { ... } */
<TR><TD ALIGN="LEFT"><TT><B>FORK_CHILD</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>FORK_ERROR</B>  </TT>
<TD ALIGN="LEFT">-1 /* Return codes from fork() */
<TR><TD ALIGN="LEFT"><TT><B>LINE_MAX</B>  </TT>
<TD ALIGN="LEFT">1024 /* Length of line from text file */
<TR><TD ALIGN="LEFT"><TT><B>MSDOS_FILESYSTEM</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>NAMEFOLD</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>O_BINARY</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>O_NDELAY</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>O_NONBLOCK</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>PATHEND</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>PATHFOLD</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>PATHSEP</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>PATH_MAX</B>  </TT>
<TD ALIGN="LEFT">2048 /* if not previously #define'd */
<TR><TD ALIGN="LEFT"><TT><B>PRELUDE_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>SIGABRT</B>  </TT>
<TD ALIGN="LEFT">22 /* Termination by abort() */
<TR><TD ALIGN="LEFT"><TT><B>SIGALRM</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>SIGILL</B>  </TT>
<TD ALIGN="LEFT">4 /* Illegal instruction */
<TR><TD ALIGN="LEFT"><TT><B>SIGINT</B>  </TT>
<TD ALIGN="LEFT">2 /* Ctrl-C sequence */
<TR><TD ALIGN="LEFT"><TT><B>SIGSEGV</B>  </TT>
<TD ALIGN="LEFT">11 /* Segment violation */
<TR><TD ALIGN="LEFT"><TT><B>SIGTERM</B>  </TT>
<TD ALIGN="LEFT">15 /* Kill signal */
<TR><TD ALIGN="LEFT"><TT><B>STDERR_FILENO</B>  </TT>
<TD ALIGN="LEFT">_fileno (stderr)
<TR><TD ALIGN="LEFT"><TT><B>STDIN_FILENO</B>  </TT>
<TD ALIGN="LEFT">_fileno (stdin)
<TR><TD ALIGN="LEFT"><TT><B>STDOUT_FILENO</B>  </TT>
<TD ALIGN="LEFT">_fileno (stdout)
<TR><TD ALIGN="LEFT"><TT><B>TIMEZONE</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>TRUE</B>  </TT>
<TD ALIGN="LEFT">1 /* ANSI standard */
<TR><TD ALIGN="LEFT"><TT><B>_INCLUDE_HPUX_SOURCE</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>_INCLUDE_POSIX_SOURCE</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>_INCLUDE_XOPEN_SOURCE</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__IS_32BIT__</B>  </TT>
<TD ALIGN="LEFT">/* Else assume 32-bit OS/compiler */
<TR><TD ALIGN="LEFT"><TT><B>__IS_64BIT__</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>__MSDOS__</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>__NO_CTYPE</B>  </TT>
<TD ALIGN="LEFT">/* Suppress warnings on tolower() */
<TR><TD ALIGN="LEFT"><TT><B>__OS2__</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__STRICT_ANSI__</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UNIX__</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_AUX</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_BEOS</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_BSDOS</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_DECALPHA</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_FREEBSD</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_GENERIC</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_HPUX</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_IBMAIX</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_IRIX</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_LINUX</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_MIPS</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_NETBSD</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_NEXT</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_QNX</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_SCO</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_SINIX</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_SUNOS</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_SUNSOLARIS</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_UNIXWARE</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__VMS_XOPEN</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__VMS__</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__WINDOWS__</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>bit_clr(x,bit)</B>  </TT>
<TD ALIGN="LEFT">((x) &= ~bit_msk (bit))
<TR><TD ALIGN="LEFT"><TT><B>bit_msk(bit)</B>  </TT>
<TD ALIGN="LEFT">(1 &lt;&lt; (bit))
<TR><TD ALIGN="LEFT"><TT><B>bit_set(x,bit)</B>  </TT>
<TD ALIGN="LEFT">((x) |= bit_msk (bit))
<TR><TD ALIGN="LEFT"><TT><B>bit_tst(x,bit)</B>  </TT>
<TD ALIGN="LEFT">((x) & bit_msk (bit))
<TR><TD ALIGN="LEFT"><TT><B>environ</B>  </TT>
<TD ALIGN="LEFT">_environ
<TR><TD ALIGN="LEFT"><TT><B>local</B>  </TT>
<TD ALIGN="LEFT">static void /* Shorthand for local functions */
<TR><TD ALIGN="LEFT"><TT><B>max(a,b)</B>  </TT>
<TD ALIGN="LEFT">(((a) &gt; (b))? (a): (b))
<TR><TD ALIGN="LEFT"><TT><B>memmove(d,s,l)</B>  </TT>
<TD ALIGN="LEFT">bcopy (s,d,l)
<TR><TD ALIGN="LEFT"><TT><B>min(a,b)</B>  </TT>
<TD ALIGN="LEFT">(((a) &lt; (b))? (a): (b))
<TR><TD ALIGN="LEFT"><TT><B>random(num)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>randomize()</B>  </TT>
<TD ALIGN="LEFT">srand ((unsigned) time (NULL))
<TR><TD ALIGN="LEFT"><TT><B>sleep(a)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>snprintf</B>  </TT>
<TD ALIGN="LEFT">_snprintf
<TR><TD ALIGN="LEFT"><TT><B>strclr(s)</B>  </TT>
<TD ALIGN="LEFT">(*(s) = 0)
<TR><TD ALIGN="LEFT"><TT><B>streq(s1,s2)</B>  </TT>
<TD ALIGN="LEFT">(!strcmp ((s1), (s2)))
<TR><TD ALIGN="LEFT"><TT><B>strerror(n)</B>  </TT>
<TD ALIGN="LEFT">sys_errlist [n]
<TR><TD ALIGN="LEFT"><TT><B>strlast(s)</B>  </TT>
<TD ALIGN="LEFT">((s) [strlen (s) - 1])
<TR><TD ALIGN="LEFT"><TT><B>strneq(s1,s2)</B>  </TT>
<TD ALIGN="LEFT">(strcmp ((s1), (s2)))
<TR><TD ALIGN="LEFT"><TT><B>strnull(s)</B>  </TT>
<TD ALIGN="LEFT">(*(s) == 0)
<TR><TD ALIGN="LEFT"><TT><B>strterm(s)</B>  </TT>
<TD ALIGN="LEFT">((s) [strlen (s)])
<TR><TD ALIGN="LEFT"><TT><B>strused(s)</B>  </TT>
<TD ALIGN="LEFT">(*(s) != 0)
<TR><TD ALIGN="LEFT"><TT><B>tbllast(x)</B>  </TT>
<TD ALIGN="LEFT">(x [tblsize (x) - 1])
<TR><TD ALIGN="LEFT"><TT><B>tblsize(x)</B>  </TT>
<TD ALIGN="LEFT">(sizeof (x) / sizeof ((x) [0]))
<TR><TD ALIGN="LEFT"><TT><B>until(expr)</B>  </TT>
<TD ALIGN="LEFT">while (!(expr)) /* do { ... } until (expr) */
<TR><TD ALIGN="LEFT"><TT><B>vsnprintf</B>  </TT>
<TD ALIGN="LEFT">_vsnprintf
</TABLE>
<H4>List of Type Definitions</H4>
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Type name:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>Bool</B>  </TT>
<TD ALIGN="LEFT">unsigned short
<TR><TD ALIGN="LEFT"><TT><B>byte</B>  </TT>
<TD ALIGN="LEFT">unsigned char
<TR><TD ALIGN="LEFT"><TT><B>dbyte</B>  </TT>
<TD ALIGN="LEFT">unsigned short
<TR><TD ALIGN="LEFT"><TT><B>dword</B>  </TT>
<TD ALIGN="LEFT">unsigned long
<TR><TD ALIGN="LEFT"><TT><B>function</B>  </TT>
<TD ALIGN="LEFT">void (*) (void)
<TR><TD ALIGN="LEFT"><TT><B>gid_t</B>  </TT>
<TD ALIGN="LEFT">int
<TR><TD ALIGN="LEFT"><TT><B>qbyte</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>uid_t</B>  </TT>
<TD ALIGN="LEFT">int
<TR><TD ALIGN="LEFT"><TT><B>word</B>  </TT>
<TD ALIGN="LEFT">unsigned short
</TABLE>
<H2><A NAME="TOC19">Define SFL version</A></H2>
<P>Filename: sflvers.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1996/11/21 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1998/10/02
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Defines the SFL_VERSION constant.
<H4>List of Symbol Definitions</H4>
<P>sflvers.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>SFLVERS_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>SFL_VERSION</B>  </TT>
<TD ALIGN="LEFT">"2.01" /* Main SFL version */
</TABLE>
<H2><A NAME="TOC20">Large bitstring manipulation functions</A></H2>
<P>Filename: sflbits.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1996/05/14 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1997/09/08
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Provides operations to manipulate large bitstrings. The
   bitstrings are compressed. Intended for bit-based index
   techniques, where bitstrings can be millions of bits long.
   These functions are still in development; this is an early
   version that provides basic functionality. Simple tests on
   large bitmaps with random filling show a cost of about 3 bytes
   per bit, after compression. This includes all the indexing
   information.
<H4>List of Functions</H4>
<UL>
<LI>int <A href="sfldoc.htm#bits_init">bits init</A><BR>
   (void);
</LI>
<LI>int <A href="sfldoc.htm#bits_term">bits term</A><BR>
   (void);
</LI>
<LI>BITS * <A href="sfldoc.htm#bits_create">bits create</A><BR>
   (void);
</LI>
<LI>void <A href="sfldoc.htm#bits_destroy">bits destroy</A><BR>
   (BITS *bits);
</LI>
<LI>int <A href="sfldoc.htm#bits_set">bits set</A><BR>
   (BITS *bits, long bit);
</LI>
<LI>int <A href="sfldoc.htm#bits_clear">bits clear</A><BR>
   (BITS *bits, long bit);
</LI>
<LI>int <A href="sfldoc.htm#bits_test">bits test</A><BR>
   (const BITS *bits, long bit);
</LI>
<LI>int <A href="sfldoc.htm#bits_fput">bits fput</A><BR>
   (FILE *file, const BITS *bits);
</LI>
<LI>BITS * <A href="sfldoc.htm#bits_fget">bits fget</A><BR>
   (FILE *file);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflbits.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>BIT_DATASIZE</B>  </TT>
<TD ALIGN="LEFT">500 /* Size of block data part */
<TR><TD ALIGN="LEFT"><TT><B>BIT_INDEXSIZE</B>  </TT>
<TD ALIGN="LEFT">BIT_DATASIZE/2 /* Size of block index part */
<TR><TD ALIGN="LEFT"><TT><B>BIT_MAXBITS</B>  </TT>
<TD ALIGN="LEFT">16384000L /* Max. possible bit number */
<TR><TD ALIGN="LEFT"><TT><B>BIT_MAXBLOCKS</B>  </TT>
<TD ALIGN="LEFT">1024 /* Max. size of bitstring */
<TR><TD ALIGN="LEFT"><TT><B>BIT_SECTSIZE</B>  </TT>
<TD ALIGN="LEFT">8192 /* Size of one bitstring section */
<TR><TD ALIGN="LEFT"><TT><B>SFLBITS_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="bits_init">&nbsp;</A>
<H3><A NAME="TOC21"><TT>bits_init</TT></A></H3>
<PRE>
#include "sflbits.h"
int
bits_init (void)
</PRE>
<H4>Synopsis</H4>
<P>Initialises bitstring functions. You must call this before
   using any other bitstring functions. Returns 0 if okay, -1 if
   there was an error.
<H4>Source Code - (sflbits.c)</H4>
<PRE>
{
    ASSERT (comp_zero == NULL);

    comp_zero = mem_alloc (BIT_SECTSIZE + 1);
    if (!comp_zero)
        return (-1);                    /*  Could not allocate new block     */

    memset (compressed, BIT_SECTSIZE, 0x00);
    comp_zero_size = <A href="sfldoc.htm#compress_bits">compress bits</A> (compressed, comp_zero, BIT_SECTSIZE);
    comp_zero      = mem_realloc (comp_zero, comp_zero_size);

    comp_ones = mem_alloc (BIT_SECTSIZE + 1);
    if (!comp_ones)
      {
        mem_free (comp_ones);
        return (-1);                    /*  Could not allocate new block     */
      }
    memset (compressed, BIT_SECTSIZE, 0xFF);
    comp_ones_size = <A href="sfldoc.htm#compress_bits">compress bits</A> (compressed, comp_ones, BIT_SECTSIZE);
    comp_ones      = mem_realloc (comp_ones, comp_ones_size);

    return (0);
}
</PRE>
<A NAME="bits_term">&nbsp;</A>
<H3><A NAME="TOC22"><TT>bits_term</TT></A></H3>
<PRE>
#include "sflbits.h"
int
bits_term (void)
</PRE>
<H4>Synopsis</H4>
<P>Terminates bitstring functions. You must call this when you are
   finished using the bitstring functions. Returns 0 if okay, -1
   if there was an error.
<H4>Source Code - (sflbits.c)</H4>
<PRE>
{
    mem_free (comp_zero);
    mem_free (comp_ones);
    return (0);
}
</PRE>
<A NAME="bits_create">&nbsp;</A>
<H3><A NAME="TOC23"><TT>bits_create</TT></A></H3>
<PRE>
#include "sflbits.h"
BITS *
bits_create (void)
</PRE>
<H4>Synopsis</H4>
<P>Creates a new bitstring and initialises all bits to zero.
   Returns a BITS handle which you should use in all further
   references to the bitstring.
<H4>Source Code - (sflbits.c)</H4>
<PRE>
{
    BITS
        *bits;                          /*  Newly-created bitstring          */
    BITBLOCK
        *index;                         /*  Newly-created index block        */

    bits = mem_alloc (sizeof (BITS));
    if (bits)
      {
        memset (bits, 0, sizeof (BITS));
        index = mem_alloc (sizeof (BITBLOCK));
        if (index)
          {
            /*  Set all index fields to 0: bitstring is all zeroes           */
            memset (index, 0, sizeof (BITBLOCK));
            index-&gt; left       = 0;
            index-&gt; right      = 0;
            index-&gt; size       = BIT_DATASIZE;
            bits-&gt; block [0]   = index;
            bits-&gt; block_count = 1;
            bits-&gt; free_list   = 0;     /*  No blocks in free list           */
          }
        else
          {
            mem_free (bits);
            bits = NULL;
          }
      }
    return (bits);
}
</PRE>
<A NAME="bits_destroy">&nbsp;</A>
<H3><A NAME="TOC24"><TT>bits_destroy</TT></A></H3>
<PRE>
#include "sflbits.h"
void
bits_destroy (
    BITS *bits)
</PRE>
<H4>Synopsis</H4>
<P>Releases all memory used by a bitstring and deletes the
   bitstring. Do not refer to the bitstring after calling this
   function.
<H4>Source Code - (sflbits.c)</H4>
<PRE>
{
    int
        block_nbr;                      /*  Bitstring block number           */

    ASSERT (bits);

    /*  Free all blocks allocated to bitmap                                  */
    for (block_nbr = 0; block_nbr &lt; bits-&gt; block_count; block_nbr++)
        mem_free (bits-&gt; block [block_nbr]);

    mem_free (bits);
}
</PRE>
<A NAME="bits_set">&nbsp;</A>
<H3><A NAME="TOC25"><TT>bits_set</TT></A></H3>
<PRE>
#include "sflbits.h"
int
bits_set (
    BITS *bits,
    long bit)
</PRE>
<H4>Synopsis</H4>
<P>Sets the specified bit in the bitmap. Returns ?
<H4>Source Code - (sflbits.c)</H4>
<PRE>
{
    int
        index,                          /*  Number of index block            */
        section;                        /*  Number of section in index       */
    dbyte
        bit_nbr;                        /*  Number of bit in section         */

    ASSERT (bits);

    locate_bit  (bits, bit, &amp;index, &amp;section, &amp;bit_nbr);
    get_section (bits, index, section, section_data, TRUE);
    section_data [bit_nbr / 8] |= 1 &lt;&lt; (bit_nbr % 8);
    put_section (bits, index, section, section_data);

    return 0;
}
</PRE>
<A NAME="bits_clear">&nbsp;</A>
<H3><A NAME="TOC26"><TT>bits_clear</TT></A></H3>
<PRE>
#include "sflbits.h"
int
bits_clear (
    BITS *bits,
    long bit)
</PRE>
<H4>Synopsis</H4>
<P>Clears the specified bit in the bitmap. Returns ?
<H4>Source Code - (sflbits.c)</H4>
<PRE>
{
    int
        index,                          /*  Number of index block            */
        section;                        /*  Number of section in index       */
    dbyte
        bit_nbr;                        /*  Number of bit in section         */

    ASSERT (bits);

    locate_bit  (bits, bit, &amp;index, &amp;section, &amp;bit_nbr);
    get_section (bits, index, section, section_data, TRUE);
    section_data [bit_nbr / 8] &amp;= 255 - (1 &lt;&lt; (bit_nbr % 8));
    put_section (bits, index, section, section_data);

    return 0;
}
</PRE>
<A NAME="bits_test">&nbsp;</A>
<H3><A NAME="TOC27"><TT>bits_test</TT></A></H3>
<PRE>
#include "sflbits.h"
int
bits_test (
    const BITS *bits,
    long bit)
</PRE>
<H4>Synopsis</H4>
<P>Tests the specified bit in the bitmap. Returns 1 or 0.
<H4>Source Code - (sflbits.c)</H4>
<PRE>
{
    int
        index,                          /*  Number of index block            */
        section;                        /*  Number of section in index       */
    dbyte
        bit_nbr;                        /*  Number of bit in section         */

    ASSERT (bits);

    locate_bit  (bits, bit, &amp;index, &amp;section, &amp;bit_nbr);
    get_section ((BITS *) bits, index, section, section_data, FALSE);
    if ((section_data [bit_nbr / 8]) &amp; (1 &lt;&lt; (bit_nbr % 8)))
        return (1);
    else
        return (0);
}
</PRE>
<A NAME="bits_fput">&nbsp;</A>
<H3><A NAME="TOC28"><TT>bits_fput</TT></A></H3>
<PRE>
#include "sflbits.h"
int
bits_fput (FILE *file,
    const BITS *bits)
</PRE>
<H4>Synopsis</H4>
<P>Writes the bitstring to the specified file stream. To read the
   bitstring, use the <A href="sfldoc.htm#bits_fget">bits fget</A>() function. The structure of
   the bitstring is:
<H4>Source Code - (sflbits.c)</H4>
<PRE>
{
    int
        block_nbr;                      /*  Bitstring block number           */
    word
        comp_size;                      /*  Size of compressed block         */
    BITBLOCK
        *block_ptr;                     /*  Points to bitstring block        */

    ASSERT (bits);
    ASSERT (file);

    /*  Write bitstring header to file                                       */
    fwrite (&amp;bits-&gt; block_count, sizeof (bits-&gt; block_count), 1, file);
    fwrite (&amp;bits-&gt; free_list,   sizeof (bits-&gt; free_list),   1, file);

    /*  Write bitstring blocks to file                                       */
    for (block_nbr = 0; block_nbr &lt; bits-&gt; block_count; block_nbr++)
      {
        block_ptr = bits-&gt; block [block_nbr];
        comp_size = <A href="sfldoc.htm#compress_block">compress block</A> ((byte *) block_ptr,
                                    compressed, (word) block_ptr-&gt; size);

        fwrite (&amp;comp_size, sizeof (comp_size), 1, file);
        fwrite (compressed, comp_size,          1, file);
      }
    return 0;
}
</PRE>
<A NAME="bits_fget">&nbsp;</A>
<H3><A NAME="TOC29"><TT>bits_fget</TT></A></H3>
<PRE>
#include "sflbits.h"
BITS *
bits_fget (FILE *file)
</PRE>
<H4>Synopsis</H4>
<P>Reads a bitstring from the specified file stream. You must have
   previously written the bitstring using bit_fput (). Returns a
   newly-created bitmap, or NULL if there was insufficient memory.
<H4>Source Code - (sflbits.c)</H4>
<PRE>
{
    int
        block_nbr;                      /*  Bitstring block number           */
    word
        comp_size;                      /*  Size of compressed block         */
    BITBLOCK
        *block_ptr;                     /*  Points to bitstring block        */
    BITS
        *bits;

    ASSERT (file);

    bits = <A href="sfldoc.htm#bits_create">bits create</A> ();              /*  Create a new, empty bitmap       */

    /*  Read bitstring header from file                                      */
    fread (&amp;bits-&gt; block_count, sizeof (bits-&gt; block_count), 1, file);
    fread (&amp;bits-&gt; free_list,   sizeof (bits-&gt; free_list),   1, file);

    /*  Read bitstring blocks from file                                      */
    for (block_nbr = 0; block_nbr &lt; bits-&gt; block_count; block_nbr++)
      {
        block_nbr = alloc_block (bits);
        if (block_nbr == 0)
          {
            <A href="sfldoc.htm#bits_destroy">bits destroy</A> (bits);
            return (NULL);
          }
        fread (&amp;comp_size, sizeof (comp_size), 1, file);
        fread (compressed, comp_size,          1, file);
        block_ptr        = bits-&gt; block [block_nbr];
        block_ptr-&gt; size = <A href="sfldoc.htm#expand_block">expand block</A> (compressed, (byte *) block_ptr,
                                         comp_size);
      }
    return (bits);
}
</PRE>
<H2><A NAME="TOC30">Compression functions</A></H2>
<P>Filename: sflcomp.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1991/05/20 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1997/09/08
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Various compression/decompression functions. The LZ-type
   algorith (LZRW1/KH) was originally written by Kurt Haenen
   &lt;ghgaea8@blekul11&gt; and made portable by P. Hintjens. This
   is a reasonable LZ/RLE algorithm, very fast, but about 30% less
   efficient than a ZIP-type algorithm in terms of space. The RLE
   algorithms are better suited to compressing sparse data. The
   nulls variant is specifically tuned to data that consists
   mostly of binary zeroes. The bits variant is tuned for
   compressing sparse bitmaps.
<H4>List of Functions</H4>
<UL>
<LI>word <A href="sfldoc.htm#compress_block">compress block</A><BR>
   (const byte *source, byte *dest, word source_size);
</LI>
<LI>word <A href="sfldoc.htm#expand_block">expand block</A><BR>
   (const byte *source, byte *dest, word source_size);
</LI>
<LI>word <A href="sfldoc.htm#compress_rle">compress rle</A><BR>
   ( byte *source, byte *dest, word source_size);
</LI>
<LI>word <A href="sfldoc.htm#expand_rle">expand rle</A><BR>
   (const byte *source, byte *dest, word source_size);
</LI>
<LI>word <A href="sfldoc.htm#compress_nulls">compress nulls</A><BR>
   ( byte *source, byte *dest, word source_size);
</LI>
<LI>word <A href="sfldoc.htm#expand_nulls">expand nulls</A><BR>
   (const byte *source, byte *dest, word source_size);
</LI>
<LI>word <A href="sfldoc.htm#compress_bits">compress bits</A><BR>
   ( byte *source, byte *dest, word source_size);
</LI>
<LI>word <A href="sfldoc.htm#expand_bits">expand bits</A><BR>
   (const byte *source, byte *dest, word source_size);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflcomp.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>SFLCOMP_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="compress_block">&nbsp;</A>
<H3><A NAME="TOC31"><TT>compress_block</TT></A></H3>
<PRE>
#include "sflcomp.h"
word
compress_block (
    const byte *src,
    byte *dst,
    word src_size)
</PRE>
<H4>Synopsis</H4>
<P>Takes up to 64Kb of uncompressed data in Source, compresses it
   using a fast LZ/RLE algorithm and places the result in Dest.
   The compression technique is comparable to that used by Zip and
   such tools, but less agressive. It is, however, fast enough to
   use in realtime. Returns the size of the compressed data. To
   decompress the data, use the <A href="sfldoc.htm#expand_block">expand block</A>() function.
<H4>Source Code - (sflcomp.c)</H4>
<PRE>
{
    static short
          Hash [4096];
    short SymbolAddress;
    word  Key;
    word  Size;
    byte  Bit = 0;
    word  Command = 0;
    word  src_index = 0;
    word  dst_size = 3;
    word  HeaderIndex = 1;

    dst [0] = FLAG_COMPRESS;
    for (Key = 0; Key &lt; 4096; Key++)
        Hash [Key] = -1;

    while ((src_index &lt; src_size) &amp;&amp; (dst_size &lt;= src_size))
      {
        if (Bit &gt; 15)
          {
            dst [HeaderIndex]     = (byte) ((Command &gt;&gt; 8) &amp; 0x00ff);
            dst [HeaderIndex + 1] = (byte) ( Command       &amp; 0x00ff);
            HeaderIndex = dst_size;
            dst_size += 2;
            Bit = 0;
          }
        for (Size = 1;; Size++)
            if ((word) (src_index + Size) &gt;= src_size
            || (src [src_index] != src [src_index + Size])
            || (Size &gt;= 0x0fff))
                break;

        if (Size &gt;= 16)
          {
            dst [dst_size++] = 0;
            dst [dst_size++] = (byte) (((word) (Size - 16) &gt;&gt; 8) &amp; 0x00ff);
            dst [dst_size++] = (byte) ((Size - 16) &amp; 0x00ff);
            dst [dst_size++] = src [src_index];
            src_index += Size;
            Command = (Command &lt;&lt; 1) + 1;
          }
        else
        if (get_match (src, src_index, src_size,
                       Hash, &amp;Size, &amp;SymbolAddress) != 0)
          {
            Key = ((src_index - SymbolAddress) &lt;&lt; 4) + (Size - 3);
            dst [dst_size++] = (byte) ((Key &gt;&gt; 8) &amp; 0x00ff);
            dst [dst_size++] = (byte) (Key &amp; 0x00ff);
            src_index += Size;
            Command = (Command &lt;&lt; 1) + 1;
          }
        else
          {
            dst [dst_size++] = src [src_index++];
            Command = (Command &lt;&lt; 1);
          }
        Bit++;
      }
    Command &lt;&lt;= (16 - Bit);
    dst [HeaderIndex]     = (byte) ((Command &gt;&gt; 8) &amp; 0x00ff);
    dst [HeaderIndex + 1] = (byte) ( Command       &amp; 0x00ff);

     if (dst_size &gt; src_size)
      {
         for (dst_size = 0; dst_size &lt; src_size; dst_size++)
             dst [dst_size + 1] = src [dst_size];
         dst [0] = FLAG_COPY;
         return (src_size + 1);
       }
     return (dst_size);
}
</PRE>
<A NAME="expand_block">&nbsp;</A>
<H3><A NAME="TOC32"><TT>expand_block</TT></A></H3>
<PRE>
#include "sflcomp.h"
word
expand_block (
    const byte *src,
    byte *dst,
    word src_size)
</PRE>
<H4>Synopsis</H4>
<P>Expands a block of data previously compressed using the
   <A href="sfldoc.htm#compress_block">compress block</A>() function. The compressed block is passed
   in src; the expanded result in dst. dst must be large enough to
   accomodate the largest possible decompressed block. Returns the
   size of the uncompressed data.
<H4>Source Code - (sflcomp.c)</H4>
<PRE>
{
    word SymbolAddress;
    word ChunkSize;
    word Counter;
    word Command = 0;
    word src_index = 1;
    word dst_size = 0;
    byte Bit = 0;

    if (src [0] == FLAG_COPY)
      {
        for (dst_size = 1; dst_size &lt; src_size; dst_size++)
            dst [dst_size - 1] = src [dst_size];
        return (src_size - 1);
      }
    while (src_index &lt; src_size)
      {
        if (Bit == 0)
          {
            Command  = src [src_index++] &lt;&lt; 8;
            Command += src [src_index++];
            Bit = 16;
          }
        if (Command &amp; 0x8000)
          {
            SymbolAddress =  (word) (src [src_index++] &lt;&lt; 4);
            SymbolAddress += (word) (src [src_index] &gt;&gt; 4);
            if (SymbolAddress)
              {
                ChunkSize = (word) (src [src_index++] &amp; 0x0f) + 3;
                SymbolAddress = dst_size - SymbolAddress;
                for (Counter = 0; Counter &lt; ChunkSize; Counter++)
                    dst [dst_size++] = dst [SymbolAddress++];
              }
            else
              {
                ChunkSize  = (word) (src [src_index++] &lt;&lt; 8);
                ChunkSize += (word) (src [src_index++] + 16);
                for (Counter = 0; Counter &lt; ChunkSize; Counter++)
                    dst [dst_size++] = src [src_index];
                src_index++;
              }
          }
        else
            dst [dst_size++] = src [src_index++];

        Command &lt;&lt;= 1;
        Bit--;
      }
    return (dst_size);
}
</PRE>
<A NAME="compress_rle">&nbsp;</A>
<H3><A NAME="TOC33"><TT>compress_rle</TT></A></H3>
<PRE>
#include "sflcomp.h"
word
compress_rle (
    byte *src,
    byte *dst,
    word src_size)
</PRE>
<H4>Synopsis</H4>
<P>Takes a block of uncompressed data in src, compresses it using
   a RLE algorithm and places the result in dst. To decompress the
   data, use the <A href="sfldoc.htm#expand_rle">expand rle</A> () function. Returns the size of
   the compressed data. The dst buffer should be 10% larger than
   the src buffer. The src buffer must be at least src_size + 1
   bytes long. It may be modified. The compressed data contains
   these strings: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>[01-7F][data...]</B>  <TD ALIGN="LEFT">String
   of uncompressed data, 1 to 127 bytes. <TR><TD
   ALIGN="LEFT"><B>[83-FF][byte]</B>  <TD ALIGN="LEFT">Run of 3 to
   127 identical bytes. <TR><TD
   ALIGN="LEFT"><B>[80][len][byte]</B>  <TD ALIGN="LEFT">Run of
   128 to 255 identical bytes. <TR><TD
   ALIGN="LEFT"><B>[81][lo][hi][byte]</B>  <TD ALIGN="LEFT">Run of
   256 to 2^16 identical bytes. <TR><TD
   ALIGN="LEFT"><B>[82][len]</B>  <TD ALIGN="LEFT">Run of 3 to 255
   spaces. <TR><TD ALIGN="LEFT"><B>[00][len]</B>  <TD
   ALIGN="LEFT">Run of 3 to 255 binary zeroes. </TABLE>
<H4>Source Code - (sflcomp.c)</H4>
<PRE>
{
    word
        dst_size,                       /*  Size of compressed data          */
        src_scan,                       /*  Scan through source data         */
        run_end,                        /*  Points to end of run of bytes    */
        length = 0;                     /*  Size of the run or string        */
    byte
        cur_byte,                       /*  Next byte to process             */
        *header;                        /*  Header of unpacked string        */
    Bool
        have_run;                       /*  TRUE when we have a run          */

    src_scan = 0;                       /*  Start at beginning of source     */
    dst_size = 0;                       /*  No output yet                    */
    header   = NULL;                    /*  No open unpacked string          */
    while (src_scan &lt; src_size)
      {
        cur_byte = src [src_scan++];
        have_run = FALSE;               /*  Unless we find a run             */

        /*  Three identical bytes signals the start of a run                 */
        if (cur_byte == src [src_scan]
        &amp;&amp;  cur_byte == src [src_scan + 1]
        &amp;&amp; (src_scan + 1 &lt; src_size))
          {
            /*  Stick-in a sentinel character to ensure that the run ends    */
            src [src_size] = !cur_byte;
            run_end = src_scan;         /*  src_scan &lt;= src_size             */
            while (src [run_end] == cur_byte)
                run_end++;

            have_run = TRUE;
            if (header)                 /*  If we have a previous unpacked   */
              {                         /*    string, close it               */
                *header = (byte) length;
                header  = NULL;
              }
            length = run_end - src_scan + 1;
            src_scan = run_end;
          }
        if (have_run)
          {
            /*  We compress short runs of spaces and nulls separately        */
            if (length &lt; 256 &amp;&amp; cur_byte == 0)
              {
                dst [dst_size++] = 0x00;
                dst [dst_size++] = (byte) length;
              }
            else
            if (length &lt; 256 &amp;&amp; cur_byte == ' ')
              {
                dst [dst_size++] = 0x82;
                dst [dst_size++] = (byte) length;
              }
            else
            if (length &lt; 128)
              {
                dst [dst_size++] = (byte) length | 0x80;
                dst [dst_size++] = cur_byte;
              }
            else
            if (length &lt; 256)           /*  Short run 128-255 bytes          */
              {
                dst [dst_size++] = 0x80;
                dst [dst_size++] = (byte) length;
                dst [dst_size++] = cur_byte;
              }
            else                        /*  Long run 256-2^16 bytes          */
              {
                dst [dst_size++] = 0x81;
                dst [dst_size++] = (byte) (length &amp; 0xff);
                dst [dst_size++] = (byte) (length &gt;&gt; 8);
                dst [dst_size++] = cur_byte;
              }
          }
        else
          {
            if (!header)                /*  Start new unpacked string if     */
              {                         /*    necessary                      */
                header = &amp;dst [dst_size++];
                length = 0;
              }
            dst [dst_size++] = cur_byte;
            if (++length == 127)        /*  Each string can be up to 127     */
              {                         /*    bytes long (high bit cleared)  */
                *header = (byte) length;
                header  = NULL;
              }
          }
      }
    if (header)                         /*  If we have a previous unpacked   */
      {                                 /*    string, close it               */
        *header = (byte) length;
        header  = NULL;
      }
    return (dst_size);                  /*  Return compressed data size      */
}
</PRE>
<A NAME="expand_rle">&nbsp;</A>
<H3><A NAME="TOC34"><TT>expand_rle</TT></A></H3>
<PRE>
#include "sflcomp.h"
word
expand_rle (
    const byte *src,
    byte *dst,
    word src_size)
</PRE>
<H4>Synopsis</H4>
<P>Expands a block of data previously compressed using the
   <A href="sfldoc.htm#compress_rle">compress rle</A>() function. The compressed block is passed in
   src; the expanded result in dst. Dst must be large enough to
   accomodate the largest possible decompressed block. Returns the
   size of the expanded data.
<H4>Source Code - (sflcomp.c)</H4>
<PRE>
{
    word
        dst_size,                       /*  Size of expanded data            */
        src_scan,                       /*  Scan through source data         */
        length;                         /*  Size of the run or string        */
    byte
        cur_byte;                       /*  Next byte to process             */

    src_scan = 0;
    dst_size = 0;
    while (src_scan &lt; src_size)
      {
        cur_byte = src [src_scan++];

        /*  1 to 127 is uncompressed string of 1 to 127 bytes                */
        if (cur_byte &gt; 0 &amp;&amp; cur_byte &lt; 128)
          {
            length = (word) cur_byte;
            memcpy (dst + dst_size, src + src_scan, length);
            src_scan += length;
            dst_size += length;
          }
        else                            /*  Run of 3 or more bytes           */
          {
            switch (cur_byte)
              {
                case 0x00:              /*  Run of 3-255 zeroes              */
                    length   = src [src_scan++];
                    cur_byte = 0;
                    break;
                case 0x82:              /*  Run of 3-255 spaces              */
                    length   = src [src_scan++];
                    cur_byte = ' ';
                    break;
                case 0x80:              /*  Short run 128-255 bytes          */
                    length   = src [src_scan++];
                    cur_byte = src [src_scan++];
                    break;
                case 0x81:              /*  Long run 256-2^16 bytes          */
                    length   = src [src_scan++];
                    length  += src [src_scan++] &lt;&lt; 8;
                    cur_byte = src [src_scan++];
                    break;
                default:                /*  Run of 3 to 127 bytes            */
                    length = cur_byte &amp; 127;
                    cur_byte = src [src_scan++];
              }
            memset (dst + dst_size, cur_byte, length);
            dst_size += length;
          }
      }
    return (dst_size);                  /*  Return expanded data size        */
}
</PRE>
<A NAME="compress_nulls">&nbsp;</A>
<H3><A NAME="TOC35"><TT>compress_nulls</TT></A></H3>
<PRE>
#include "sflcomp.h"
word
compress_nulls (
    byte *src,
    byte *dst,
    word src_size)
</PRE>
<H4>Synopsis</H4>
<P>Similar to <A href="sfldoc.htm#compress_rle">compress rle</A>(), but optimised towards
   compression of binary zeroes. Use this when you are certain
   that the sparse areas are set to binary zeroes. You must use
   <A href="sfldoc.htm#expand_nulls">expand nulls</A> () to decompress a block compressed with this
   function. Returns the size of the compressed data. The dst
   buffer should be 10% larger than the src buffer. The src buffer
   must be at least src_size + 1 bytes long. It may be modified.
   The compressed data contains these strings: <TABLE BORDER
   NOWRAP> <TR><TD ALIGN="LEFT"><B>[01-7F][data...]</B>  <TD
   ALIGN="LEFT">String of uncompressed data, 1 to 127 bytes.
   <TR><TD ALIGN="LEFT"><B>[82-FF]</B>  <TD ALIGN="LEFT">Run of 2
   to 127 binary zeroes. <TR><TD ALIGN="LEFT"><B>[81][80-FF]</B>
   <TD ALIGN="LEFT">Run of 128 to 255 binary zeroes. <TR><TD
   ALIGN="LEFT"><B>[80][lo][hi]</B>  <TD ALIGN="LEFT">Run of 256
   to 2^16 binary zeroes. <TR><TD
   ALIGN="LEFT"><B>[00][len][byte]</B>  <TD ALIGN="LEFT">Run of 4
   to 255 identical bytes. <TR><TD
   ALIGN="LEFT"><B>[00][00][lo][hi][byte]</B>  <TD
   ALIGN="LEFT">Run of 256 to 2^16 identical bytes. </TABLE>
<H4>Source Code - (sflcomp.c)</H4>
<PRE>
{
    word
        dst_size,                       /*  Size of compressed data          */
        src_scan,                       /*  Scan through source data         */
        run_end,                        /*  Points to end of run of bytes    */
        length = 0;                     /*  Size of the run or string        */
    byte
        cur_byte,                       /*  Next byte to process             */
        *header;                        /*  Header of unpacked string        */
    Bool
        have_run;                       /*  TRUE when we have a run          */

    src_scan = 0;                       /*  Start at beginning of source     */
    dst_size = 0;                       /*  No output yet                    */
    header   = NULL;                    /*  No open unpacked string          */
    while (src_scan &lt; src_size)
      {
        cur_byte = src [src_scan++];
        have_run = FALSE;               /*  Unless we find a run             */

        /*  Two identical bytes may signal the start of a run                */
        if (cur_byte == src [src_scan]
        &amp;&amp;  src_scan &lt; src_size)
          {
            /*  Stick-in a sentinel character to ensure that the run ends    */
            src [src_size] = !cur_byte;
            run_end = src_scan;         /*  src_scan &lt;= src_size             */
            while (src [run_end] == cur_byte)
                run_end++;

            /*  A run is 4+ identical bytes or 2+ nulls                      */
            if ((run_end - src_scan &gt; 2) || cur_byte == 0)
              {
                have_run = TRUE;
                if (header)             /*  If we have a previous unpacked   */
                  {                     /*    string, close it               */
                    *header = (byte) length;
                    header  = NULL;
                  }
                length = run_end - src_scan + 1;
                src_scan = run_end;
              }
          }
        if (have_run)
          {
            if (cur_byte == 0)
              {
                if (length &lt; 128)       /*  2-127 binary zeroes              */
                    dst [dst_size++] = (byte) (length | 0x80);
                else
                if (length &lt; 256)       /*  128-256 binary zeroes            */
                  {
                    dst [dst_size++] = 0x81;
                    dst [dst_size++] = (byte) length;
                  }
                else                    /*  256-2^15 binary zeroes           */
                  {
                    dst [dst_size++] = 0x80;
                    dst [dst_size++] = (byte) (length &amp; 0xff);
                    dst [dst_size++] = (byte) (length &gt;&gt; 8);
                  }
              }
            else
            if (length &lt; 256)           /*  Short run 4-255 bytes            */
              {
                dst [dst_size++] = 0x00;
                dst [dst_size++] = (byte) length;
                dst [dst_size++] = cur_byte;
              }
            else                        /*  Long run 256-2^16 bytes          */
              {
                dst [dst_size++] = 0x00;
                dst [dst_size++] = 0x00;
                dst [dst_size++] = (byte) (length &amp; 0xff);
                dst [dst_size++] = (byte) (length &gt;&gt; 8);
                dst [dst_size++] = cur_byte;
              }
          }
        else
          {
            if (!header)                /*  Start new unpacked string if     */
              {                         /*    necessary                      */
                header = &amp;dst [dst_size++];
                length = 0;
              }
            dst [dst_size++] = cur_byte;
            if (++length == 127)        /*  Each string can be up to 127     */
              {                         /*    bytes long (high bit cleared)  */
                *header = (byte) length;
                header  = NULL;
              }
          }
      }
    if (header)                         /*  If we have a previous unpacked   */
      {                                 /*    string, close it               */
        *header = (byte) length;
        header  = NULL;
      }
    return (dst_size);                  /*  Return compressed data size      */
}
</PRE>
<A NAME="expand_nulls">&nbsp;</A>
<H3><A NAME="TOC36"><TT>expand_nulls</TT></A></H3>
<PRE>
#include "sflcomp.h"
word
expand_nulls (
    const byte *src,
    byte *dst,
    word src_size)
</PRE>
<H4>Synopsis</H4>
<P>Expands a block of data previously compressed using the
   <A href="sfldoc.htm#compress_nulls">compress nulls</A>() function. The compressed block is passed
   in src; the expanded result in dst. Dst must be large enough to
   accomodate the largest possible decompressed block. Returns the
   size of the expanded data.
<H4>Source Code - (sflcomp.c)</H4>
<PRE>
{
    word
        dst_size,                       /*  Size of expanded data            */
        src_scan,                       /*  Scan through source data         */
        length;                         /*  Size of the run or string        */
    byte
        cur_byte;                       /*  Next byte to process             */

    src_scan = 0;
    dst_size = 0;
    while (src_scan &lt; src_size)
      {
        cur_byte = src [src_scan++];

        /*  1 to 127 is uncompressed string of 1 to 127 bytes                */
        if (cur_byte &gt; 0 &amp;&amp; cur_byte &lt; 128)
          {
            length = (word) cur_byte;
            memcpy (dst + dst_size, src + src_scan, length);
            src_scan += length;
            dst_size += length;
          }
        else                            /*  Run of 2 or more bytes           */
          {
            switch (cur_byte)
              {
                case 0x00:              /*  Run of non-zero bytes            */
                    length = src [src_scan++];
                    if (length == 0)    /*  Stored as double-byte            */
                      {
                        length   = src [src_scan++];
                        length  += src [src_scan++] &lt;&lt; 8;
                      }
                    cur_byte = src [src_scan++];
                    break;
                case 0x80:              /*  256-2^16 zeroes                  */
                    length   = src [src_scan++];
                    length  += src [src_scan++] &lt;&lt; 8;
                    cur_byte = 0;
                    break;
                case 0x81:              /*  128 to 255 zeroes                */
                    length   = src [src_scan++];
                    cur_byte = 0;
                    break;
                default:                /*  2 to 127 zeroes                  */
                    length   = cur_byte &amp; 127;
                    cur_byte = 0;
              }
            memset (dst + dst_size, cur_byte, length);
            dst_size += length;
          }
      }
    return (dst_size);                  /*  Return expanded data size        */
}
</PRE>
<A NAME="compress_bits">&nbsp;</A>
<H3><A NAME="TOC37"><TT>compress_bits</TT></A></H3>
<PRE>
#include "sflcomp.h"
word
compress_bits (
    byte *src,
    byte *dst,
    word src_size)
</PRE>
<H4>Synopsis</H4>
<P>Similar to <A href="sfldoc.htm#compress_rle">compress rle</A>(), but optimised towards
   compression of sparse bitmaps. Use this when you are playing
   with large, sparse bitmaps. You must use <A href="sfldoc.htm#expand_bits">expand bits</A> () to
   decompress a block compressed with this function. Returns the
   size of the compressed data. The dst buffer should be 10%
   larger than the src buffer for worst cases. The src buffer must
   be at least src_size + 1 bytes long. It may be modified. The
   compressed data contains these strings: <TABLE BORDER NOWRAP>
   <TR><TD ALIGN="LEFT"><B>[00-07]</B>  <TD ALIGN="LEFT">Single
   byte containing a bit in position 0 to 7. <TR><TD
   ALIGN="LEFT"><B>[08-7F][data...]</B>  <TD ALIGN="LEFT">String
   of uncompressed data, 1 to 120 bytes. <TR><TD
   ALIGN="LEFT"><B>[82-FF]</B>  <TD ALIGN="LEFT">Run of 1 to 126
   binary zeroes. <TR><TD ALIGN="LEFT"><B>[81][00-FD]</B>  <TD
   ALIGN="LEFT">Run of 127 to 380 binary zeroes. <TR><TD
   ALIGN="LEFT"><B>[81][FE][len][byte]</B>  <TD ALIGN="LEFT">Run
   of 4 to 255 identical bytes. <TR><TD
   ALIGN="LEFT"><B>[81][FF][lo][hi][byte]</B>  <TD
   ALIGN="LEFT">Run of 256 to 2^16 identical bytes. <TR><TD
   ALIGN="LEFT"><B>[80][lo][hi]</B>  <TD ALIGN="LEFT">Run of 381
   to 2^16 binary zeroes. </TABLE>
<H4>Source Code - (sflcomp.c)</H4>
<PRE>
{
    word
        dst_size,                       /*  Size of compressed data          */
        src_scan,                       /*  Scan through source data         */
        run_end,                        /*  Points to end of run of bytes    */
        length = 0;                     /*  Size of the run or string        */
    byte
        cur_byte,                       /*  Next byte to process             */
        *header;                        /*  Header of unpacked string        */
    static byte
        single_bits [256];              /*  Bytes with one bit set           */
    static Bool
        initialised = FALSE;            /*  First time flag                  */

    /*  The single_bits table provides a fast lookup for bytes with          */
    /*  one bit set.  The 'interesting' bytes are non-zero in the table      */
    /*  where their value is the output code value (0-7) + 1.                */
    if (!initialised)                   /*  First time?  Initialise          */
      {
        memset (single_bits, 0, 256);
        single_bits [1]   = 1;
        single_bits [2]   = 2;
        single_bits [4]   = 3;
        single_bits [8]   = 4;
        single_bits [16]  = 5;
        single_bits [32]  = 6;
        single_bits [64]  = 7;
        single_bits [128] = 8;
      }

    src_scan = 0;                       /*  Start at beginning of source     */
    dst_size = 0;                       /*  No output yet                    */
    header   = NULL;                    /*  No open unpacked string          */
    while (src_scan &lt; src_size)
      {
        cur_byte = src [src_scan++];

        /*- Look for 1 or more binary zeroes, and compress into a run -------*/

        if (cur_byte == 0)
          {
            src [src_size] = 0xff;      /*  Stop with a sentinel             */
            run_end = src_scan;         /*  src_scan &lt;= src_size             */
            while (src [run_end] == 0)
                run_end++;

            if (header)                 /*  If we have a previous unpacked   */
              {                         /*    string, close it               */
                *header = (byte) length + 7;
                header  = NULL;
              }
            length = run_end - src_scan + 1;
            src_scan = run_end;
            if (length &lt; 127)           /*  1-126 binary zeroes              */
                dst [dst_size++] = (byte) (++length | 0x80);
            else
            if (length &lt; 381)           /*  127-380 binary zeroes            */
              {
                dst [dst_size++] = 0x81;
                dst [dst_size++] = (byte) length - 127;
              }
            else                        /*  381-2^16 binary zeroes           */
              {
                dst [dst_size++] = 0x80;
                dst [dst_size++] = (byte) (length &amp; 0xff);
                dst [dst_size++] = (byte) (length &gt;&gt; 8);
              }
          }
        else

        /*- Next, look for bytes with 1 bit set; we encode these as 1 byte --*/

        if (single_bits [cur_byte])     /*  Single bit value?                */
          {
            dst [dst_size++] = single_bits [cur_byte] - 1;
            if (header)                 /*  If we have a previous unpacked   */
              {                         /*    string, close it               */
                *header = (byte) length + 7;
                header  = NULL;
              }
          }
        else

        /*- Next, look for a run of 4 or more identical (non-zero) bytes ----*/

        if (cur_byte == src [src_scan]
        &amp;&amp;  cur_byte == src [src_scan + 1]
        &amp;&amp;  cur_byte == src [src_scan + 2]
        &amp;&amp; (src_scan &lt; src_size - 2))
          {
            src [src_size] = !cur_byte; /*  Stick in a sentinel byte         */
            run_end = src_scan;         /*  src_scan &lt;= src_size             */
            while (src [run_end] == cur_byte)
                run_end++;

            if (header)                 /*  If we have a previous unpacked   */
              {                         /*    string, close it               */
                *header = (byte) length + 7;
                header  = NULL;
              }
            length = run_end - src_scan + 1;
            src_scan = run_end;

            if (length &lt; 256)           /*  Short run 4-255 bytes            */
              {
                dst [dst_size++] = 0x81;
                dst [dst_size++] = 0xFE;
                dst [dst_size++] = (byte) length;
                dst [dst_size++] = cur_byte;
              }
            else                        /*  Long run 256-2^16 bytes          */
              {
                dst [dst_size++] = 0x81;
                dst [dst_size++] = 0xFF;
                dst [dst_size++] = (byte) (length &amp; 0xff);
                dst [dst_size++] = (byte) (length &gt;&gt; 8);
                dst [dst_size++] = cur_byte;
              }
          }
        else

        /*- Lastly, compress unpackable strings into chunks of 120 bytes ----*/

          {
            if (!header)                /*  Start new unpacked string if     */
              {                         /*    necessary                      */
                header = &amp;dst [dst_size++];
                length = 0;
              }
            dst [dst_size++] = cur_byte;
            if (++length == 120)        /*  Each string can be up to 120     */
              {                         /*    bytes long (high bit cleared)  */
                *header = (byte) length + 7;
                header  = NULL;
              }
          }
      }
    if (header)                         /*  If we have a previous unpacked   */
      {                                 /*    string, close it               */
        *header = (byte) length + 7;
        header  = NULL;
      }
    return (dst_size);                  /*  Return compressed data size      */
}
</PRE>
<A NAME="expand_bits">&nbsp;</A>
<H3><A NAME="TOC38"><TT>expand_bits</TT></A></H3>
<PRE>
#include "sflcomp.h"
word
expand_bits (
    const byte *src,
    byte *dst,
    word src_size)
</PRE>
<H4>Synopsis</H4>
<P>Expands a block of data previously compressed using the
   <A href="sfldoc.htm#compress_bits">compress bits</A>() function. The compressed block is passed in
   src; the expanded result in dst. Dst must be large enough to
   accomodate the largest possible decompressed block. Returns the
   size of the expanded data.
<H4>Source Code - (sflcomp.c)</H4>
<PRE>
{
    word
        dst_size,                       /*  Size of expanded data            */
        src_scan,                       /*  Scan through source data         */
        length;                         /*  Size of the run or string        */
    byte
        cur_byte;                       /*  Next byte to process             */

    src_scan = 0;
    dst_size = 0;
    while (src_scan &lt; src_size)
      {
        cur_byte = src [src_scan++];

        if (cur_byte &lt; 8)               /*  Single bit in position 0 to 7    */
            dst [dst_size++] = 1 &lt;&lt; cur_byte;
        else
        if (cur_byte &lt; 128)             /*  String of 1 to 120 bytes         */
          {
            length = (word) cur_byte - 7;
            memcpy (dst + dst_size, src + src_scan, length);
            src_scan += length;
            dst_size += length;
          }
        else                            /*  Run of 1 or more bytes           */
          {
            switch (cur_byte)
              {
                case 0x80:              /*  381-2^16 binary zeroes           */
                    length   = src [src_scan++];
                    length  += src [src_scan++] &lt;&lt; 8;
                    cur_byte = 0;
                    break;
                case 0x81:
                    length = src [src_scan++];
                    if (length == 0xFE) /*  4-255 non-zero bytes             */
                      {
                        length   = src [src_scan++];
                        cur_byte = src [src_scan++];
                      }
                    else
                    if (length == 0xFF) /*  Run of 256-2^15 non-zero bytes   */
                      {
                        length   = src [src_scan++];
                        length  += src [src_scan++] &lt;&lt; 8;
                        cur_byte = src [src_scan++];
                      }
                    else
                      {
                        length  += 127;
                        cur_byte = 0;   /*  127 to 380 zeroes                */
                      }
                    break;
                default:                /*  1 to 126 zeroes                  */
                    length   = (cur_byte - 1) &amp; 127;
                    cur_byte = 0;
              }
            memset (dst + dst_size, cur_byte, length);
            dst_size += length;
          }
      }
    return (dst_size);                  /*  Return expanded data size        */
}
</PRE>
<H2><A NAME="TOC39">Console output functions</A></H2>
<P>Filename: sflcons.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1997/05/22 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1998/02/08
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Provides redirectable console output: use the <A href="sfldoc.htm#coprintf">coprintf</A>()
   and <A href="sfldoc.htm#coputs">coputs</A>() calls instead of printf() and puts() in a
   real-time application. Then, you can call <A href="sfldoc.htm#console_send">console send</A>() to
   send all console output to a specified function. This is a
   useful way to get output into -- for example -- a GUI window.
<H4>List of Functions</H4>
<UL>
<LI>void <A href="sfldoc.htm#console_send">console send</A><BR>
   (CONSOLE_FCT *console_fct, Bool echo);
</LI>
<LI>void <A href="sfldoc.htm#console_enable">console enable</A><BR>
   (void);
</LI>
<LI>void <A href="sfldoc.htm#console_disable">console disable</A><BR>
   (void);
</LI>
<LI>void <A href="sfldoc.htm#console_set_mode">console set mode</A><BR>
   (int CONSOLE_MODE);
</LI>
<LI>int <A href="sfldoc.htm#console_capture">console capture</A><BR>
   (const char *filename, char mode);
</LI>
<LI>int <A href="sfldoc.htm#coputs">coputs</A><BR>
   (const char *string);
</LI>
<LI>int <A href="sfldoc.htm#coprintf">coprintf</A><BR>
   (const char *format, ...);
</LI>
<LI>int <A href="sfldoc.htm#coputc">coputc</A><BR>
   (int character);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflcons.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>SFLCONS_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<H4>List of Type Definitions</H4>
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Type name:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>CONSOLE_FCT</B>  </TT>
<TD ALIGN="LEFT">void () (const char *)
</TABLE>
<A NAME="console_send">&nbsp;</A>
<H3><A NAME="TOC40"><TT>console_send</TT></A></H3>
<PRE>
#include "sflcons.h"
void
console_send (CONSOLE_FCT *new_console_fct, Bool echo)
</PRE>
<H4>Synopsis</H4>
<P>Redirects console output to a specified CONSOLE_FCT function.
   If the specified address is NULL, redirects back to the stdout
   stream. This is independent of any console capturing in
   progress. If the echo argument is TRUE, console output is also
   sent to stdout.
<H4>Source Code - (sflcons.c)</H4>
<PRE>
{
    console_fct  = new_console_fct;
    console_echo = echo;                /*  Copy to stdout                   */
}
</PRE>
<A NAME="console_enable">&nbsp;</A>
<H3><A NAME="TOC41"><TT>console_enable</TT></A></H3>
<PRE>
#include "sflcons.h"
void
console_enable (void)
</PRE>
<H4>Synopsis</H4>
<P>Enables console output. Use together with <A href="sfldoc.htm#console_disable">console disable</A>()
   to stop and start console output.
<H4>Source Code - (sflcons.c)</H4>
<PRE>
{
    console_active = TRUE;
}
</PRE>
<A NAME="console_disable">&nbsp;</A>
<H3><A NAME="TOC42"><TT>console_disable</TT></A></H3>
<PRE>
#include "sflcons.h"
void
console_disable (void)
</PRE>
<H4>Synopsis</H4>
<P>Disables console output. Use together with <A href="sfldoc.htm#console_enable">console enable</A>()
   to stop and start console output.
<H4>Source Code - (sflcons.c)</H4>
<PRE>
{
    console_active = FALSE;
}
</PRE>
<A NAME="console_set_mode">&nbsp;</A>
<H3><A NAME="TOC43"><TT>console_set_mode</TT></A></H3>
<PRE>
#include "sflcons.h"
void
console_set_mode (int mode)
</PRE>
<H4>Synopsis</H4>
<P>Sets console display mode; the argument can be one of: <TABLE
   BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>CONSOLE PLAIN</B>  <TD
   ALIGN="LEFT">Output text exactly as specified <TR><TD
   ALIGN="LEFT"><B>CONSOLE DATETIME</B>  <TD ALIGN="LEFT">Prefix
   text by "yy/mm/dd hh:mm:ss " <TR><TD ALIGN="LEFT"><B>CONSOLE
   TIME</B>  <TD ALIGN="LEFT">Prefix text by "hh:mm:ss " </TABLE>
   The default is plain output.
<H4>Source Code - (sflcons.c)</H4>
<PRE>
{
    ASSERT (mode == CONSOLE_PLAIN
         || mode == CONSOLE_DATETIME
         || mode == CONSOLE_TIME);

    console_mode = mode;
}
</PRE>
<A NAME="console_capture">&nbsp;</A>
<H3><A NAME="TOC44"><TT>console_capture</TT></A></H3>
<PRE>
#include "sflcons.h"
int
console_capture (const char *filename, char mode)
</PRE>
<H4>Synopsis</H4>
<P>Starts capturing console output to the specified file. If the
   mode is 'w', creates an empty capture file. If the mode is 'a',
   appends to any existing data. Returns 0 if okay, -1 if there
   was an error - in this case you can test the value of errno. If
   the filename is NULL or an empty string, closes any current
   capture file.
<H4>Source Code - (sflcons.c)</H4>
<PRE>
{
    if (console_file)
      {
        <A href="sfldoc.htm#file_close">file close</A> (console_file);
        console_file = NULL;
      }
    if (filename &amp;&amp; *filename)
      {
        ASSERT (mode == 'w' || mode == 'a');
        console_file = <A href="sfldoc.htm#file_open">file open</A> (filename, mode);
        if (console_file == NULL)
            return (-1);
      }
    return (0);
}
</PRE>
<A NAME="coprintf">&nbsp;</A>
<H3><A NAME="TOC45"><TT>coprintf</TT></A></H3>
<PRE>
#include "sflcons.h"
int
coprintf (const char *format, ...)
</PRE>
<H4>Synopsis</H4>
<P>As printf() but sends output to the current console. This is by
   default the stdout device, unless you used <A href="sfldoc.htm#console_send">console send</A>()
   to direct console output to some function. A newline is added
   automatically.
<H4>Source Code - (sflcons.c)</H4>
<PRE>
{
    va_list
        argptr;                         /*  Argument list pointer            */
    int
        fmtsize = 0;                    /*  Size of formatted line           */
    char
        *formatted = NULL,              /*  Formatted line                   */
        *prefixed = NULL;               /*  Prefixed formatted line          */

    if (console_active)
      {
        formatted = mem_alloc (LINE_MAX + 1);
        if (!formatted)
            return (0);
        va_start (argptr, format);      /*  Start variable args processing   */
        vsnprintf (formatted, LINE_MAX, format, argptr);
        va_end (argptr);                /*  End variable args processing     */
        switch (console_mode)
          {
            case CONSOLE_DATETIME:
                xstrcpy_debug ();
                prefixed = <A href="sfldoc.htm#xstrcpy">xstrcpy</A> (NULL, date_str (), " ", time_str (), ": ",
                                    formatted, NULL);
                break;
            case CONSOLE_TIME:
                xstrcpy_debug ();
                prefixed = <A href="sfldoc.htm#xstrcpy">xstrcpy</A> (NULL, time_str (), ": ", formatted, NULL);
                break;
          }
        if (console_file)
          {
            <A href="sfldoc.htm#file_write">file write</A> (console_file, prefixed? prefixed: formatted);
            fflush (console_file);
          }
        if (console_fct)
            (console_fct) (prefixed? prefixed: formatted);

        if (console_echo)
          {
            fprintf (stdout, "%s", prefixed? prefixed: formatted);
            fprintf (stdout, "\n");
            fflush  (stdout);
          }
        if (prefixed)
          {
            fmtsize = strlen (prefixed);
            mem_free (prefixed);
          }
        else
            fmtsize = strlen (formatted);

        mem_free (formatted);
      }
    return (fmtsize);
}
</PRE>
<A NAME="coputs">&nbsp;</A>
<H3><A NAME="TOC46"><TT>coputs</TT></A></H3>
<PRE>
#include "sflcons.h"
int
coputs (const char *string)
</PRE>
<H4>Synopsis</H4>
<P>As puts() but sends output to the current console. This is by
   default the stdout device, unless you used <A href="sfldoc.htm#console_send">console send</A>()
   to direct console output to some function.
<H4>Source Code - (sflcons.c)</H4>
<PRE>
{
    <A href="sfldoc.htm#coprintf">coprintf</A> (string);
    return (1);
}
</PRE>
<A NAME="coputc">&nbsp;</A>
<H3><A NAME="TOC47"><TT>coputc</TT></A></H3>
<PRE>
#include "sflcons.h"
int
coputc (int character)
</PRE>
<H4>Synopsis</H4>
<P>As putc() but sends output to the current console. This is by
   default the stdout device, unless you used <A href="sfldoc.htm#console_send">console send</A>()
   to direct console output to some function.
<H4>Source Code - (sflcons.c)</H4>
<PRE>
{
    char
        buffer [2];

    if (console_active)
      {
        if (console_file)
          {
            putc (character, console_file);
            fflush (console_file);
          }
        if (console_fct)
          {
            buffer [0] = (char) character;
            buffer [1] = '\0';
            (console_fct) (buffer);
          }
        if (console_echo)
          {
            putc (character, stdout);
            fflush  (stdout);
          }
      }
    return (character);
}
</PRE>
<H2><A NAME="TOC48">Conversion functions</A></H2>
<P>Filename: sflconv.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1995/12/17 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1998/10/19
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>These functions provide conversion between a set of datatypes
   (dates, times, numbers, Booleans) and external strings that
   represent the values. The objective is to format datatypes for
   display or printing, and to validate and convert strings
   supplied by the user. Conversion is controlled by a set of
   options specific to each datatype. Additionally, dates and
   times may be formatted using picture strings. The functions
   were written for use in an interactive 'forms' environment.
<H4>List of Functions</H4>
<UL>
<LI>char * <A href="sfldoc.htm#conv_number_str">conv number str</A><BR>
   (const char *number, int flags, char point, int decimals, int
   decimal_format, int width, int sign_format);
</LI>
<LI>char * <A href="sfldoc.htm#conv_str_number">conv str number</A><BR>
   (const char *string, int flags, char point, int decimals, int
   decimal_format, int width);
</LI>
<LI>char * <A href="sfldoc.htm#conv_date_str">conv date str</A><BR>
   (long date, int flags, int format, int order, char datesep, int
   width);
</LI>
<LI>long <A href="sfldoc.htm#conv_str_date">conv str date</A><BR>
   (const char *string, int flags, int format, int order);
</LI>
<LI>int <A href="sfldoc.htm#conv_str_day">conv str day</A><BR>
   (const char *day_name);
</LI>
<LI>char * <A href="sfldoc.htm#conv_time_str">conv time str</A><BR>
   (long time, int flags, char timesep, int width);
</LI>
<LI>long <A href="sfldoc.htm#conv_str_time">conv str time</A><BR>
   (const char *string);
</LI>
<LI>char * <A href="sfldoc.htm#conv_bool_str">conv bool str</A><BR>
   (Bool boolean, int format);
</LI>
<LI>int <A href="sfldoc.htm#conv_str_bool">conv str bool</A><BR>
   (const char *string);
</LI>
<LI>char * <A href="sfldoc.htm#conv_time_pict">conv time pict</A><BR>
   (long time, const char *picture);
</LI>
<LI>char * <A href="sfldoc.htm#conv_date_pict">conv date pict</A><BR>
   (long date, const char *picture);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflconv.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>BOOL_1_0</B>  </TT>
<TD ALIGN="LEFT">4
<TR><TD ALIGN="LEFT"><TT><B>BOOL_TRUE_FALSE</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>BOOL_T_F</B>  </TT>
<TD ALIGN="LEFT">3
<TR><TD ALIGN="LEFT"><TT><B>BOOL_YES_NO</B>  </TT>
<TD ALIGN="LEFT">0 /* Boolean field formatting */
<TR><TD ALIGN="LEFT"><TT><B>BOOL_Y_N</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_BAD_MONTH</B>  </TT>
<TD ALIGN="LEFT">8 /* Unknown month name */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_DATE_OVERFLOW</B>  </TT>
<TD ALIGN="LEFT">5 /* Result too large for output */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_DATE_SIZE</B>  </TT>
<TD ALIGN="LEFT">6 /* Too few or too many digits */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_DECS_HIDDEN</B>  </TT>
<TD ALIGN="LEFT">18 /* Decimals not allowed if hidden */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_DECS_MISSING</B>  </TT>
<TD ALIGN="LEFT">11 /* Not enough decimals supplied */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_DECS_OVERFLOW</B>  </TT>
<TD ALIGN="LEFT">19 /* Too many decimal positions */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_DECS_REJECTED</B>  </TT>
<TD ALIGN="LEFT">17 /* Decimals not allowed if integer */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_INVALID_INPUT</B>  </TT>
<TD ALIGN="LEFT">1 /* Unrecognised char in input */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_MULTIPLE_AM</B>  </TT>
<TD ALIGN="LEFT">4 /* More than one 'am' or 'pm' */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_MULTIPLE_DELIM</B>  </TT>
<TD ALIGN="LEFT">7 /* Too many delimiters */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_MULTIPLE_MONTH</B>  </TT>
<TD ALIGN="LEFT">10 /* More than one month name */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_MULTIPLE_POINT</B>  </TT>
<TD ALIGN="LEFT">16 /* More than one decimal point */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_MULTIPLE_SIGN</B>  </TT>
<TD ALIGN="LEFT">13 /* More than one sign character */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_NOT_BOOLEAN</B>  </TT>
<TD ALIGN="LEFT">3 /* Not a yes/no or true/false value */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_NUM_OVERFLOW</B>  </TT>
<TD ALIGN="LEFT">12 /* Result too large for output */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_OUT_OF_RANGE</B>  </TT>
<TD ALIGN="LEFT">2 /* Value out of valid range */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_REJECT_3_5</B>  </TT>
<TD ALIGN="LEFT">9 /* 3/5 digits in a row not allowed */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_SIGN_BAD_FIN</B>  </TT>
<TD ALIGN="LEFT">15 /* Malformed financial negative */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_SIGN_REJECTED</B>  </TT>
<TD ALIGN="LEFT">14 /* Sign not allowed if unsigned */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_TOO_MANY_DIGITS</B>  </TT>
<TD ALIGN="LEFT">20 /* Too many digits for number */
<TR><TD ALIGN="LEFT"><TT><B>CONV_MAX_DECS</B>  </TT>
<TD ALIGN="LEFT">100 /* Up to 100 decimal positions */
<TR><TD ALIGN="LEFT"><TT><B>CONV_NO_ERRORS</B>  </TT>
<TD ALIGN="LEFT">0 /* No errors */
<TR><TD ALIGN="LEFT"><TT><B>DATE_FORMAT_FIRST</B>  </TT>
<TD ALIGN="LEFT">0 /* Date field formatting */
<TR><TD ALIGN="LEFT"><TT><B>DATE_FORMAT_LAST</B>  </TT>
<TD ALIGN="LEFT">9
<TR><TD ALIGN="LEFT"><TT><B>DATE_MD_COMPACT</B>  </TT>
<TD ALIGN="LEFT">7
<TR><TD ALIGN="LEFT"><TT><B>DATE_MD_DELIM</B>  </TT>
<TD ALIGN="LEFT">8
<TR><TD ALIGN="LEFT"><TT><B>DATE_MD_LAST</B>  </TT>
<TD ALIGN="LEFT">9
<TR><TD ALIGN="LEFT"><TT><B>DATE_MD_SPACE</B>  </TT>
<TD ALIGN="LEFT">9
<TR><TD ALIGN="LEFT"><TT><B>DATE_ORDER_DMY</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>DATE_ORDER_FIRST</B>  </TT>
<TD ALIGN="LEFT">1 /* Values for date_order */
<TR><TD ALIGN="LEFT"><TT><B>DATE_ORDER_LAST</B>  </TT>
<TD ALIGN="LEFT">3
<TR><TD ALIGN="LEFT"><TT><B>DATE_ORDER_MDY</B>  </TT>
<TD ALIGN="LEFT">3
<TR><TD ALIGN="LEFT"><TT><B>DATE_ORDER_YMD</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>DATE_YMD_COMMA</B>  </TT>
<TD ALIGN="LEFT">3
<TR><TD ALIGN="LEFT"><TT><B>DATE_YMD_COMPACT</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>DATE_YMD_DELIM</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>DATE_YMD_LAST</B>  </TT>
<TD ALIGN="LEFT">3
<TR><TD ALIGN="LEFT"><TT><B>DATE_YMD_SPACE</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>DATE_YM_COMPACT</B>  </TT>
<TD ALIGN="LEFT">4
<TR><TD ALIGN="LEFT"><TT><B>DATE_YM_DELIM</B>  </TT>
<TD ALIGN="LEFT">5
<TR><TD ALIGN="LEFT"><TT><B>DATE_YM_LAST</B>  </TT>
<TD ALIGN="LEFT">6
<TR><TD ALIGN="LEFT"><TT><B>DATE_YM_SPACE</B>  </TT>
<TD ALIGN="LEFT">6
<TR><TD ALIGN="LEFT"><TT><B>DECS_DROP_ZEROS</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>DECS_HIDE_ALL</B>  </TT>
<TD ALIGN="LEFT">3
<TR><TD ALIGN="LEFT"><TT><B>DECS_SCIENTIFIC</B>  </TT>
<TD ALIGN="LEFT">4
<TR><TD ALIGN="LEFT"><TT><B>DECS_SHOW_ALL</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>FLAG_D_CENTURY</B>  </TT>
<TD ALIGN="LEFT">8
<TR><TD ALIGN="LEFT"><TT><B>FLAG_D_DD_AS_D</B>  </TT>
<TD ALIGN="LEFT">1 /* Date field flags */
<TR><TD ALIGN="LEFT"><TT><B>FLAG_D_MM_AS_M</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>FLAG_D_MONTH_ABC</B>  </TT>
<TD ALIGN="LEFT">4
<TR><TD ALIGN="LEFT"><TT><B>FLAG_D_ORDER_DMY</B>  </TT>
<TD ALIGN="LEFT">64
<TR><TD ALIGN="LEFT"><TT><B>FLAG_D_ORDER_MDY</B>  </TT>
<TD ALIGN="LEFT">128
<TR><TD ALIGN="LEFT"><TT><B>FLAG_D_ORDER_YMD</B>  </TT>
<TD ALIGN="LEFT">32
<TR><TD ALIGN="LEFT"><TT><B>FLAG_D_UPPER</B>  </TT>
<TD ALIGN="LEFT">16
<TR><TD ALIGN="LEFT"><TT><B>FLAG_N_DECIMALS</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>FLAG_N_LEFT</B>  </TT>
<TD ALIGN="LEFT">4
<TR><TD ALIGN="LEFT"><TT><B>FLAG_N_SIGNED</B>  </TT>
<TD ALIGN="LEFT">1 /* Number field flags */
<TR><TD ALIGN="LEFT"><TT><B>FLAG_N_THOUSANDS</B>  </TT>
<TD ALIGN="LEFT">32
<TR><TD ALIGN="LEFT"><TT><B>FLAG_N_ZERO_BLANK</B>  </TT>
<TD ALIGN="LEFT">16
<TR><TD ALIGN="LEFT"><TT><B>FLAG_N_ZERO_FILL</B>  </TT>
<TD ALIGN="LEFT">8
<TR><TD ALIGN="LEFT"><TT><B>FLAG_T_12_HOUR</B>  </TT>
<TD ALIGN="LEFT">32
<TR><TD ALIGN="LEFT"><TT><B>FLAG_T_CC_AS_C</B>  </TT>
<TD ALIGN="LEFT">8
<TR><TD ALIGN="LEFT"><TT><B>FLAG_T_COMPACT</B>  </TT>
<TD ALIGN="LEFT">16
<TR><TD ALIGN="LEFT"><TT><B>FLAG_T_HH_AS_H</B>  </TT>
<TD ALIGN="LEFT">1 /* Time field flags */
<TR><TD ALIGN="LEFT"><TT><B>FLAG_T_MM_AS_M</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>FLAG_T_SS_AS_S</B>  </TT>
<TD ALIGN="LEFT">4
<TR><TD ALIGN="LEFT"><TT><B>FORMAT_MAX</B>  </TT>
<TD ALIGN="LEFT">80 /* Max. size of formatted field */
<TR><TD ALIGN="LEFT"><TT><B>SFLCONV_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>SIGN_ALL_LEAD</B>  </TT>
<TD ALIGN="LEFT">4
<TR><TD ALIGN="LEFT"><TT><B>SIGN_ALL_TRAIL</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>SIGN_FINANCIAL</B>  </TT>
<TD ALIGN="LEFT">5
<TR><TD ALIGN="LEFT"><TT><B>SIGN_NEG_LEAD</B>  </TT>
<TD ALIGN="LEFT">3
<TR><TD ALIGN="LEFT"><TT><B>SIGN_NEG_TRAIL</B>  </TT>
<TD ALIGN="LEFT">1 /* Number field formatting */
</TABLE>
<A NAME="conv_bool_str">&nbsp;</A>
<H3><A NAME="TOC49"><TT>conv_bool_str</TT></A></H3>
<PRE>
#include "sflconv.h"
char *
conv_bool_str (
    Bool boolean,
    int  format)
</PRE>
<H4>Synopsis</H4>
<P>Converts a Bool value to a string according to the specified
   format: 0 = Yes|No; 1 = Y|N, 2 = True|False, 3 = T|F, 4 = 1|0.
   Returns a pointer to a static string that is overwritten by
   each call.
<H4>Source Code - (sflcvbs.c)</H4>
<PRE>
{
    static char *bool_name [] =
      {
        "Yes",  "No",
        "Y",    "N",
        "True", "False",
        "T",    "F",
        "1",    "0"
      };

    conv_reason = 0;                    /*  No conversion errors so far      */
    return (bool_name [format * 2 + (boolean? 0: 1)]);
}
</PRE>
<A NAME="conv_date_pict">&nbsp;</A>
<H3><A NAME="TOC50"><TT>conv_date_pict</TT></A></H3>
<PRE>
#include "sflconv.h"
char *
conv_date_pict (
    long date,
    const char *picture)
</PRE>
<H4>Synopsis</H4>
<P>Converts a date to a string using a picture. The picture is
   composed of any combination of these formats: <TABLE BORDER
   NOWRAP> <TR><TD ALIGN="LEFT"><B>cc</B>  <TD
   ALIGN="LEFT">century 2 digits, 01-99 <TR><TD
   ALIGN="LEFT"><B>y</B>  <TD ALIGN="LEFT">day of year, 1-366
   <TR><TD ALIGN="LEFT"><B>yy</B>  <TD ALIGN="LEFT">year 2 digits,
   00-99 <TR><TD ALIGN="LEFT"><B>yyyy</B>  <TD ALIGN="LEFT">year 4
   digits, 100-9999 <TR><TD ALIGN="LEFT"><B>m</B>  <TD
   ALIGN="LEFT">month, 1-12 <TR><TD ALIGN="LEFT"><B>mm</B>  <TD
   ALIGN="LEFT">month, 01-12 <TR><TD ALIGN="LEFT"><B>mmm</B>  <TD
   ALIGN="LEFT">month, 3 letters <TR><TD ALIGN="LEFT"><B>mmmm</B>
   <TD ALIGN="LEFT">month, full name <TR><TD
   ALIGN="LEFT"><B>MMM</B>  <TD ALIGN="LEFT">month, 3 letters,
   ucase <TR><TD ALIGN="LEFT"><B>MMMM</B>  <TD ALIGN="LEFT">month,
   full name, ucase <TR><TD ALIGN="LEFT"><B>d</B>  <TD
   ALIGN="LEFT">day, 1-31 <TR><TD ALIGN="LEFT"><B>dd</B>  <TD
   ALIGN="LEFT">day, 01-31 <TR><TD ALIGN="LEFT"><B>ddd</B>  <TD
   ALIGN="LEFT">day of week, Sun-Sat <TR><TD
   ALIGN="LEFT"><B>dddd</B>  <TD ALIGN="LEFT">day of week, Sunday-
   Saturday <TR><TD ALIGN="LEFT"><B>DDD</B>  <TD ALIGN="LEFT">day
   of week, SUN-SAT <TR><TD ALIGN="LEFT"><B>DDDD</B>  <TD
   ALIGN="LEFT">day of week, SUNDAY-SATURDAY <TR><TD
   ALIGN="LEFT"><B>w</B>  <TD ALIGN="LEFT">day of week, 1-7
   (1=Sunday) <TR><TD ALIGN="LEFT"><B>ww</B>  <TD
   ALIGN="LEFT">week of year, 1-53 <TR><TD ALIGN="LEFT"><B>q</B>
   <TD ALIGN="LEFT">year quarter, 1-4 <TR><TD
   ALIGN="LEFT"><B>\x</B>  <TD ALIGN="LEFT">literal character x
   <TR><TD ALIGN="LEFT"><B>other</B>  <TD ALIGN="LEFT">literal
   character </TABLE> Returns the formatted result. This is a
   static string, of at most 80 characters, that is overwritten by
   each call. If date is zero, returns an empty string. The 'm'
   and 'd' formats output a leading space when used at the start
   of the picture. This is to improve alignment of columns of
   dates. The 'm' and 'd' formats also output a space when the
   previous character was a digit; otherwise the date components
   stick together and are illegible.
<H4>Examples</H4>
<PRE>
    puts (conv_date_pict (19951202, "mm d, yy"));
        Dec 2, 95
    puts (conv_date_pict (19951202, "d mmm, yy"));
        2 Dec, 95
</PRE>
<H4>Source Code - (sflcvdp.c)</H4>
<PRE>
{
    static char
        *month_name [] =
          {
            "January", "February", "March", "April", "May", "June", "July",
            "August", "September", "October", "November", "December"
          },
        *day_name [] =
          {
            "Sunday", "Monday", "Tuesday", "Wednesday",
            "Thursday", "Friday", "Saturday"
          },
        formatted [FORMAT_MAX + 1];     /*  Formatted return string          */
    int
        century,                        /*  Century component of date        */
        year,                           /*  Year component of date           */
        month,                          /*  Month component of date          */
        day,                            /*  Day component of date            */
        cursize;                        /*  Size of current component        */
    char
       *dest,                           /*  Store formatted data here        */
        ch,                             /*  Next character in picture        */
        lastch = '0';                   /*  Last character we output         */
    long
        full_date = date;

    conv_reason = 0;                    /*  No conversion errors so far      */

    /*  Zero date is returned as empty string                                */
    if (date == 0)
      {
        strclr (formatted);
        return (formatted);
      }

    <A href="sfldoc.htm#default_century">default century</A> (&amp;full_date);
    century = GET_CENTURY (full_date);
    year    = GET_YEAR    (full_date);
    month   = GET_MONTH   (full_date);
    day     = GET_DAY     (full_date);

    ASSERT (month &gt; 0 &amp;&amp; month &lt;= 12);
    ASSERT (day   &gt; 0 &amp;&amp; day   &lt;= 31);

    /*  Scan through picture, converting each component                      */
    dest = formatted;
    *dest = 0;                          /*  string is empty                  */
    while (*picture)
      {
        /*  Get character and count number of occurences                     */
        ch = *picture++;
        for (cursize = 1; *picture == ch; cursize++)
            picture++;

        switch (ch)
          {
            /*  cc        century 2 digits, 01-99                            */
            case 'c':
                if (cursize == 2)
                    sprintf (dest, "%02d", century);
                break;

            /*  y         day of year, 1-366                                 */
            /*  yy        year 2 digits, 00-99                               */
            /*  yyyy      year 4 digits, 0100-9999                           */
            case 'y':                   /*  y = day of year                  */
                if (cursize == 1)
                    sprintf (dest, "%d", <A href="sfldoc.htm#julian_date">julian date</A> (full_date));
                else
                if (cursize == 2)
                    sprintf (dest, "%02d", year);
                else
                if (cursize == 4)
                    sprintf (dest, "%02d%02d", century, year);
                break;

            /*  m         month, 1-12                                        */
            /*  mm        month, 01-12                                       */
            /*  mmm       month, 3 letters                                   */
            /*  mmmm      month, full name                                   */
            case 'm':
                if (cursize == 1)
                    sprintf (dest, (isdigit (lastch)? "%2d": "%d"), month);
                else
                if (cursize == 2)
                    sprintf (dest, "%02d", month);
                else
                if (cursize == 3)
                  {
                    memcpy (dest, month_name [month - 1], 3);
                    dest [3] = 0;
                  }
                else
                if (cursize == 4)
                    strcpy (dest, month_name [month - 1]);
                break;

            /*  MMM       month, 3-letters, ucase                            */
            /*  MMMM      month, full name, ucase                            */
            case 'M':
                if (cursize == 3)
                  {
                    memcpy (dest, month_name [month - 1], 3);
                    dest [3] = 0;
                    <A href="sfldoc.htm#strupc">strupc</A> (dest);
                  }
                else
                if (cursize == 4)
                  {
                    strcpy (dest, month_name [month - 1]);
                    <A href="sfldoc.htm#strupc">strupc</A> (dest);
                  }
                break;

            /*  d         day, 1-31                                          */
            /*  dd        day, 01-31                                         */
            /*  ddd       day of week, Sun-Sat                               */
            /*  dddd      day of week, Sunday-Saturday                       */
            case 'd':
                if (cursize == 1)
                    sprintf (dest, (isdigit (lastch)? "%2d": "%d"), day);
                else
                if (cursize == 2)
                    sprintf (dest, "%02d", day);
                else
                if (cursize == 3)
                  {
                    memcpy (dest, day_name [<A href="sfldoc.htm#day_of_week">day of week</A> (full_date)], 3);
                    dest [3] = 0;
                  }
                else
                if (cursize == 4)
                    strcpy (dest, day_name [<A href="sfldoc.htm#day_of_week">day of week</A> (full_date)]);
                break;

            /*  DDD       day of week, SUN-SAT                               */
            /*  DDDD      day of week, SUNDAY-SATURDAY                       */
            case 'D':
                if (cursize == 3)
                  {
                    memcpy (dest, day_name [<A href="sfldoc.htm#day_of_week">day of week</A> (full_date)], 3);
                    dest [3] = 0;
                    <A href="sfldoc.htm#strupc">strupc</A> (dest);
                  }
                else
                if (cursize == 4)
                  {
                    strcpy (dest, day_name [<A href="sfldoc.htm#day_of_week">day of week</A> (full_date)]);
                    <A href="sfldoc.htm#strupc">strupc</A> (dest);
                  }
                break;

            /*  w         day of week, 1-7 (1=Sunday)                        */
            /*  ww        week of year, 1-53                                 */
            case 'w':
                if (cursize == 1)
                    sprintf (dest, "%d", <A href="sfldoc.htm#day_of_week">day of week</A> (full_date) + 1);
                else
                if (cursize == 2)
                    sprintf (dest, "%d", <A href="sfldoc.htm#week_of_year">week of year</A> (full_date));
                break;

            /*  q         year quarter, 1-4                                  */
            case 'q':
                if (cursize == 1)
                    sprintf (dest, "%d", <A href="sfldoc.htm#year_quarter">year quarter</A> (full_date));
                break;

            /*  \x        literal character x                                */
            case '\\':
                ch = *picture++;
        }
        if (*dest)                      /*  If something was output,         */
            while (*dest)               /*    skip to end of string          */
                dest++;
        else
            while (cursize--)           /*  Else output ch once or more      */
                *dest++ = ch;           /*    and bump dest pointer          */

        lastch = *(dest - 1);           /*  Get previous character           */
        *dest = 0;                      /*  Terminate the string nicely      */
    }
    return (formatted);
}
</PRE>
<A NAME="conv_date_str">&nbsp;</A>
<H3><A NAME="TOC51"><TT>conv_date_str</TT></A></H3>
<PRE>
#include "sflconv.h"
char *
conv_date_str (
    long date,
    int  flags,
    int  format,
    int  order,
    char datesep,
    int  width)
</PRE>
<H4>Synopsis</H4>
<P>Converts a date to a string. The format argument defines how
   the date is shown: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>DATE YMD COMPACT</B>  <TD ALIGN="LEFT">ddmmyy
   <TR><TD ALIGN="LEFT"><B>DATE YMD SLASH</B>  <TD
   ALIGN="LEFT">dd/mm/yy <TR><TD ALIGN="LEFT"><B>DATE YMD
   SPACE</B>  <TD ALIGN="LEFT">dd mm yy <TR><TD
   ALIGN="LEFT"><B>DATE YMD COMMA</B>  <TD ALIGN="LEFT">dd mm, yy
   (DM,Y or MD,Y or Y,MD) <TR><TD ALIGN="LEFT"><B>DATE YM
   COMPACT</B>  <TD ALIGN="LEFT">mmyy <TR><TD ALIGN="LEFT"><B>DATE
   YM SLASH</B>  <TD ALIGN="LEFT">mm/yy <TR><TD
   ALIGN="LEFT"><B>DATE YM SPACE</B>  <TD ALIGN="LEFT">mm yy
   <TR><TD ALIGN="LEFT"><B>DATE MD COMPACT</B>  <TD
   ALIGN="LEFT">ddmm <TR><TD ALIGN="LEFT"><B>DATE MD SLASH</B>
   <TD ALIGN="LEFT">dd/mm <TR><TD ALIGN="LEFT"><B>DATE MD
   SPACE</B>  <TD ALIGN="LEFT">dd mm </TABLE> The date order
   (year/month/day) is normally supplied in the order argument.
   However, the date flags can override this. The flags are:
   <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>FLAG D DD AS
   D</B>  <TD ALIGN="LEFT">Show day without leading zero <TR><TD
   ALIGN="LEFT"><B>FLAG D MM AS M</B>  <TD ALIGN="LEFT">Show month
   without leading zero <TR><TD ALIGN="LEFT"><B>FLAG D MONTH
   ABC</B>  <TD ALIGN="LEFT">Show month as letters (fullname if
   width &gt; 16) <TR><TD ALIGN="LEFT"><B>FLAG D CENTURY</B>  <TD
   ALIGN="LEFT">Show year as four digits <TR><TD
   ALIGN="LEFT"><B>FLAG D UPPERCASE</B>  <TD ALIGN="LEFT">Month
   name in uppercase <TR><TD ALIGN="LEFT"><B>FLAG D ORDER DMY</B>
   <TD ALIGN="LEFT">Order is DMY for this date <TR><TD
   ALIGN="LEFT"><B>FLAG D ORDER MDY</B>  <TD ALIGN="LEFT">Order is
   MDY for this date <TR><TD ALIGN="LEFT"><B>FLAG D ORDER YMD</B>
   <TD ALIGN="LEFT">Order is YMD for this date </TABLE> Returns a
   pointer to a static area holding the string, or NULL if there
   was an error (for instance, formatted date greater than width).
<H4>Source Code - (sflcvds.c)</H4>
<PRE>
{
    static char *format_table [] = {
        "ymd",    "dmy",    "mdy",      /*  DATE_YMD_COMPACT                 */
        "y/m/d",  "d/m/y",  "m/d/y",    /*  DATE_YMD_DELIM                   */
        "y m d",  "d m y",  "m d y",    /*  DATE_YMD_SPACE                   */
        "y, m d", "d m, y", "m d, y",   /*  DATE_YMD_COMMA                   */
        "ym",     "my",     "my",       /*  DATE_YM_COMPACT                  */
        "y/m",    "m/y",    "m/y",      /*  DATE_YM_DELIM                    */
        "y m",    "m y",    "m y",      /*  DATE_YM_SPACE                    */
        "md",     "dm",     "md",       /*  DATE_MD_COMPACT                  */
        "m/d",    "d/m",    "m/d",      /*  DATE_MD_DELIM                    */
        "m d",    "d m",    "m d"       /*  DATE_MD_SPACE                    */
    };
    char
        *format_ptr,                    /*  Scan through format string       */
        delim [2],                      /*  Delimiter character              */
        picture [14],                   /*  Largest picture: dd mmmm, yyyy   */
        ch;                             /*  Next char in format string       */
    int
        index,
        date_order = order;             /*  Order to use                     */

    ASSERT (format &gt;= DATE_FORMAT_FIRST &amp;&amp; format &lt;= DATE_FORMAT_LAST);
    ASSERT (order  &gt;= DATE_ORDER_FIRST  &amp;&amp; order  &lt;= DATE_ORDER_LAST);

    conv_reason = 0;                    /*  No conversion errors so far      */

    if (flags &amp; FLAG_D_ORDER_YMD)
        date_order = DATE_ORDER_YMD;
    else
    if (flags &amp; FLAG_D_ORDER_DMY)
        date_order = DATE_ORDER_DMY;
    else
    if (flags &amp; FLAG_D_ORDER_MDY)
        date_order = DATE_ORDER_MDY;

    /*  Get index into table                                                 */
    index = format * 3 + date_order - 1;

    /*  Now build-up picture according to format string                      */
    strclr (picture);
    for (format_ptr = format_table [index]; *format_ptr; format_ptr++)
      {
        ch = *format_ptr;
        switch (ch)
          {
            case 'y':
                strcat (picture, flags &amp; FLAG_D_CENTURY? "yyyy": "yy");
                break;

            case 'm':
                if (flags &amp; FLAG_D_MONTH_ABC)
                    if (width &gt; 16)
                        strcat (picture, flags &amp; FLAG_D_UPPER? "MMMM": "mmmm");
                    else
                        strcat (picture, flags &amp; FLAG_D_UPPER? "MMM": "mmm");
                else
                    strcat (picture, flags &amp; FLAG_D_MM_AS_M? "m": "mm");
                break;

            case 'd':
                strcat (picture, flags &amp; FLAG_D_DD_AS_D? "d": "dd");
                break;

            case '/':
                ch = datesep;           /*  Use supplied date separator      */
            default:
                delim [0] = ch;
                delim [1] = 0;
                strcat (picture, delim);
          }
      }
    format_ptr = <A href="sfldoc.htm#conv_date_pict">conv date pict</A> (date, picture);
    if (strlen (format_ptr) &gt; (unsigned) width)
      {
        conv_reason = CONV_ERR_DATE_OVERFLOW;
        return (NULL);
      }
    else
        return (format_ptr);
}
</PRE>
<A NAME="conv_number_str">&nbsp;</A>
<H3><A NAME="TOC52"><TT>conv_number_str</TT></A></H3>
<PRE>
#include "sflconv.h"
char *
conv_number_str (
    const char *number,                 /*  Number to convert                */
    int   flags,                        /*  Number formatting flags          */
    char  dec_point,                    /*  Decimal point: '.' or ','        */
    int   decimals,                     /*  Number of decimals, or 0         */
    int   dec_format,                   /*  How are decimals shown?          */
    int   width,                        /*  Output field width, or 0         */
    int   sign_format                   /*  How are negatives shown?         */
)
</PRE>
<H4>Synopsis</H4>
<P>Converts a number to a string. The number format is defined
   largely by the flags argument, which can specify various values
   defined in sflconv.h: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>FLAG N SIGNED</B>  <TD ALIGN="LEFT">Show signed
   number, using sign_format argument. <TR><TD
   ALIGN="LEFT"><B>FLAG N DECIMALS</B>  <TD ALIGN="LEFT">Show
   decimals, using dec_format argument. <TR><TD
   ALIGN="LEFT"><B>FLAG N LEFT</B>  <TD ALIGN="LEFT">Left-justify
   number; no effect if width is 0. <TR><TD ALIGN="LEFT"><B>FLAG N
   ZERO FILL</B>  <TD ALIGN="LEFT">Right-justfified, with leading
   zeroes. <TR><TD ALIGN="LEFT"><B>FLAG N ZERO BLANK</B>  <TD
   ALIGN="LEFT">Show zero as empty string or spaces (width &gt;
   0). <TR><TD ALIGN="LEFT"><B>FLAG N THOUSANDS</B>  <TD
   ALIGN="LEFT">Show number with thousands separators. </TABLE>
   Sign formats: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>SIGN NEG TRAIL</B>  <TD ALIGN="LEFT">Negative
   numbers only: 123- <TR><TD ALIGN="LEFT"><B>SIGN ALL TRAIL</B>
   <TD ALIGN="LEFT">All non-zero numbers: 123- 123+ <TR><TD
   ALIGN="LEFT"><B>SIGN NEG LEAD</B>  <TD ALIGN="LEFT">Negative
   numbers only: -123 <TR><TD ALIGN="LEFT"><B>SIGN ALL LEAD</B>
   <TD ALIGN="LEFT">All non-zero numbers: -123 +123 <TR><TD
   ALIGN="LEFT"><B>SIGN FINANCIAL</B>  <TD ALIGN="LEFT">Negative
   numbers only: (123) </TABLE> Decimal formats: <TABLE BORDER
   NOWRAP> <TR><TD ALIGN="LEFT"><B>DECS SHOW ALL</B>  <TD
   ALIGN="LEFT">123.10, 123.00, 0.95 <TR><TD ALIGN="LEFT"><B>DECS
   DROP ZEROS</B>  <TD ALIGN="LEFT">123.1, 123, 0.95 <TR><TD
   ALIGN="LEFT"><B>DECS HIDE ALL</B>  <TD ALIGN="LEFT">123, 123, 0
   <TR><TD ALIGN="LEFT"><B>DECS PERCENTAGE</B>  <TD
   ALIGN="LEFT">12300, 12300, 95 <TR><TD ALIGN="LEFT"><B>DECS
   SCIENTIFIC</B>  <TD ALIGN="LEFT">1.231e2, 1.23e2, 9.5e-1
   </TABLE> The input number string may contain leading zeros and
   a leading sign character (space, '+', '-') if signed. These are
   examples of valid 8-digit numbers: "1234" "00001234" "12345678"
   "+12345678". If the flag FLAG_N_DECIMALS is set, the last X
   digits are taken to be decimals, where X is the value of the
   decimals argument. If the number contains a decimal point
   (always '.'), this is taken to indicate the start of the
   decimal part. The formatted number is placed within a field of
   specified width. If the number is right-justfied, this means it
   may have leading spaces. If the field width is 0, the number
   will never have leading spaces. Returns a pointer to the
   formatted string, or NULL if the specified width is too small
   for formatted number or the supplied number does not contain
   enough digits.
<H4>Source Code - (sflcvns.c)</H4>
<PRE>
{
    static char
        formatted [FORMAT_MAX + 1],     /*  Formatted return string          */
        zero [CONV_MAX_DECS + 2];       /*  Default value if needed          */
    int
        sep_stop,                       /*  Where we put next sep_char       */
        dec_stop,                       /*  Where we put decimal point       */
        decs_wanted = decimals,         /*  Number of decimals wanted        */
        decs_seen,                      /*  Number of decimals output        */
        sign_pos,                       /*  Where we put sign, if any        */
        digits;                         /*  Number of digits read so far     */
    char
       *dest,                           /*  Store formatted number here      */
        sign_char,                      /*  Number's sign: ' ', '+', '-'     */
        sep_char,                       /*  Thousands separator '.' or ','   */
        drop_zero,                      /*  We suppress this char            */
        ch;                             /*  Next character in picture        */
    Bool
        have_zero;                      /*  TRUE if whole number is zero     */

    ASSERT (width &lt;= FORMAT_MAX);
    ASSERT (dec_point == '.' || dec_point == ',');

    conv_reason = 0;                    /*  No conversion errors so far      */

    /*  ---------------------------------   Prepare to copy digits  ---------*/

    if (decs_wanted &gt; CONV_MAX_DECS)
      {
        conv_reason = CONV_ERR_DECS_OVERFLOW;
        return (NULL);                  /*  Error - too many decimals        */
      }
    /*  If value is empty, use "0" with enough decimals as default value     */
    /*  We allow one whole digit and as many decimals as needed.             */
    if (strnull (number))
      {
        <A href="sfldoc.htm#strpad">strpad</A> (zero, '0', decs_wanted + 1);
        number = zero;
      }

    /*  Pick-up sign character if present                                    */
    if (*number == ' ' || *number == '+' || *number == '-')
        sign_char = *number++;
    else
        sign_char = ' ';

    /*  While leading zero is '0' we blank-out zeros in the number           */
    drop_zero = (char) (flags &amp; FLAG_N_ZERO_FILL? ' ': '0');

    /*  Prepare for decimals                                                 */
    if ((flags &amp; FLAG_N_DECIMALS) == 0)
        decs_wanted = 0;

    if (strchr (number, '.'))
        dec_stop = (int) (strchr (number, '.') - (char *) number);
    else
        dec_stop = strlen (number) - decs_wanted;

    if (dec_stop &lt; 1)
      {
        conv_reason = CONV_ERR_DECS_MISSING;
        return (NULL);                  /*  Error - too few decimals         */
      }

    /*  Prepare for thousands-separators if FLAG_N_THOUSANDS                 */
    if ((flags &amp; FLAG_N_THOUSANDS) &amp;&amp; !(flags &amp; FLAG_N_ZERO_FILL))
      {
        /*  Get number of whole digits, allowing for decimals &amp; dec sign     */
        sep_char = (char) (dec_point == '.'? ',': '.');
        sep_stop = (dec_stop - (decs_wanted? decs_wanted + 1: 0)) % 3;
        if (sep_stop == 0)
            sep_stop = 3;               /*  Get into range 1..3              */
      }
    else
      {
        sep_char = ' ';
        sep_stop = 0;                   /*  No thousands separators          */
      }

    /*  ---------------------------------   Copy the digits  ----------------*/

    digits    = 0;                      /*  No digits loaded yet             */
    decs_seen = 0;                      /*  No decimals output yet           */
    have_zero = TRUE;                   /*  Assume number is zero            */
    dest      = formatted;              /*  Format number                    */
    while (*number)                     /*    until we hit the terminator    */
      {
        ch = *number++;
        if (ch == '.')
            continue;                   /*  Ignore '.' in number             */

        digits++;

        if (ch == drop_zero &amp;&amp; digits &lt; dec_stop)
            ch = ' ';
        else
        if (isdigit (ch))
          {
            drop_zero = ' ';
            if (ch &gt; '0')
                have_zero = FALSE;
          }
        if (ch != ' ' || (width &gt; 0 &amp;&amp; !(flags &amp; FLAG_N_LEFT)))
          {
            *dest++ = ch;               /*  Output this digit                */
            if (digits &gt; dec_stop)
                decs_seen++;            /*  Count the decimal digit          */
            else
            if (digits == dec_stop)     /*  Handle decimal stop              */
              {                         /*    with optional point            */
                if (flags &amp; FLAG_N_DECIMALS)
                    *dest++ = dec_point;
                sep_stop = 0;           /*  And kill further thousand seps   */
              }
          }
        /*  Output thousands separator unless we are in blank area           */
        if (digits == sep_stop)
          {
            if (ch != ' ')
                *dest++ = sep_char;
            sep_stop += 3;
          }
      }
    *dest = 0;                          /*  Terminate the string nicely      */
    /*  ---------------------------------   Post-format the result  ---------*/

    if (decs_wanted &gt; 0)
      {
        /*  Output trailing decimal zeroes if not supplied                   */
        if (decs_seen == 0)
            *dest++ = dec_point;
        while (decs_seen &lt; decs_wanted)
          {
            *dest++ = '0';
            decs_seen++;
          }
        /*  Drop all decimals if format is DEC_HIDE_ALL                      */
        if (dec_format == DECS_HIDE_ALL)
            while (*dest != dec_point)
                dest--;                 /*  Drop-off trailing zero           */
        else
        /*  Drop trailing decimal zeroes if format is DEC_DROP_ZEROS         */
        if (dec_format == DECS_DROP_ZEROS)
            while (*dest != dec_point)
              {
                if (*(dest - 1) &gt; '0')
                    break;
                else
                    dest--;             /*  Drop-off trailing zero           */
              }
        *dest = 0;                      /*  Terminate the string nicely      */
      }

    /*  Justify within width if width &gt; 0                                    */
    sign_pos = 0;                       /*  Sign normally comes at start     */
    digits   = strlen (formatted);
    if (flags &amp; FLAG_N_SIGNED)
      {
        digits++;                       /*  Allow for eventual sign          */
        if (sign_format == SIGN_FINANCIAL)
            digits++;                   /*  Sign shown like (123)            */
      }
    while (digits &lt; width)
      {
        if (flags &amp; FLAG_N_LEFT &amp;&amp; !(flags &amp; FLAG_N_ZERO_FILL))
            strcat (formatted, " ");
        else
          {
            <A href="sfldoc.htm#stropen">stropen</A> (formatted, FALSE); /*  Insert blank at start of string  */
            if (flags &amp; FLAG_N_ZERO_FILL)
                formatted [0] = '0';
            else
                sign_pos++;             /*  Skip leading space               */
          }
        digits++;
      }

    /*  Format sign if FLAG_N_SIGNED                                         */
    if (flags &amp; FLAG_N_SIGNED)
      {
        if (sign_format == SIGN_NEG_LEAD
        ||  sign_format == SIGN_ALL_LEAD
        ||  sign_format == SIGN_FINANCIAL)
            <A href="sfldoc.htm#stropen">stropen</A> (formatted, FALSE);

        if (sign_format == SIGN_NEG_TRAIL
        ||  sign_format == SIGN_ALL_TRAIL
        ||  sign_format == SIGN_FINANCIAL)
            strcat (formatted, " ");

        if (!have_zero)                 /*  Zero has no sign                 */
            switch (sign_format)
              {
                case SIGN_NEG_LEAD:
                    if (sign_char != '-')
                        break;          /*  Fall through if negative sign    */
                case SIGN_ALL_LEAD:
                    formatted [sign_pos] = sign_char;
                    break;

                case SIGN_NEG_TRAIL:
                    if (sign_char != '-')
                        break;          /*  Fall through if negative sign    */
                case SIGN_ALL_TRAIL:
                    strlast (formatted) = sign_char;
                    break;

                case SIGN_FINANCIAL:
                    if (sign_char == '-')
                      {
                        formatted [0]       = '(';
                        strlast (formatted) = ')';
                      }
                    break;
              }
      }

    /*  If all zeroes, return a blank string if FLAG_N_ZERO_BLANK            */
    if ((flags &amp; FLAG_N_ZERO_BLANK) &amp;&amp; have_zero)
      {
        memset (formatted, ' ', width);
        formatted [width] = 0;
      }

    if (width &gt; 0 &amp;&amp; (strlen (formatted) &gt; (size_t) width))
      {
        conv_reason = CONV_ERR_NUM_OVERFLOW;
        return (NULL);                  /*  Overflow -- number too large     */
      }
    else
        return (formatted);
}
</PRE>
<A NAME="conv_str_bool">&nbsp;</A>
<H3><A NAME="TOC53"><TT>conv_str_bool</TT></A></H3>
<PRE>
#include "sflconv.h"
int
conv_str_bool (
    const char *string)
</PRE>
<H4>Synopsis</H4>
<P>Converts a string to a Bool. Accepts T/Y/1 as TRUE, F/N/0 as
   FALSE, ignoring case. Looks only at the first letter of the
   string. Returns 1 for TRUE, 0 for FALSE, -1 if the string was
   not valid.
<H4>Source Code - (sflcvsb.c)</H4>
<PRE>
{
    char
        ch;

    ch = tolower (string [0]);
    conv_reason = 0;                    /*  No conversion errors so far      */
    if (ch == 'y' || ch == 't' || ch == '1')
        return (1);
    else
    if (ch == 'n' || ch == 'f' || ch == '0')
        return (0);
    else
      {
        conv_reason = CONV_ERR_NOT_BOOLEAN;
        return (-1);
      }
}
</PRE>
<A NAME="conv_str_date">&nbsp;</A>
<H3><A NAME="TOC54"><TT>conv_str_date</TT></A></H3>
<PRE>
#include "sflconv.h"
long
conv_str_date (
    const char *string,
    int  flags,
    int  format,
    int  order)
</PRE>
<H4>Synopsis</H4>
<P>Converts a string to a date. The supposed format of the date is
   defined by the format argument, which can be one of: <TABLE
   BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>DATE YMD COMPACT</B>
   <TD ALIGN="LEFT">Year month day. <TR><TD ALIGN="LEFT"><B>DATE
   YMD DELIM</B>  <TD ALIGN="LEFT">Year month day. <TR><TD
   ALIGN="LEFT"><B>DATE YMD SPACE</B>  <TD ALIGN="LEFT">Year month
   day. <TR><TD ALIGN="LEFT"><B>DATE YMD COMMA</B>  <TD
   ALIGN="LEFT">Year month day. <TR><TD ALIGN="LEFT"><B>DATE YM
   COMPACT</B>  <TD ALIGN="LEFT">Year and month only; day is zero.
   <TR><TD ALIGN="LEFT"><B>DATE YM DELIM</B>  <TD
   ALIGN="LEFT">Year and month only; day is zero. <TR><TD
   ALIGN="LEFT"><B>DATE YM SPACE</B>  <TD ALIGN="LEFT">Year and
   month only; day is zero. <TR><TD ALIGN="LEFT"><B>DATE MD
   COMPACT</B>  <TD ALIGN="LEFT">Month and day only; year is zero.
   <TR><TD ALIGN="LEFT"><B>DATE MD DELIM</B>  <TD
   ALIGN="LEFT">Month and day only; year is zero. <TR><TD
   ALIGN="LEFT"><B>DATE MD SPACE</B>  <TD ALIGN="LEFT">Month and
   day only; year is zero. </TABLE> The date order must be one of:
   <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>DATE ORDER
   YMD</B>  <TD ALIGN="LEFT">Year month day. <TR><TD
   ALIGN="LEFT"><B>DATE ORDER DMY</B>  <TD ALIGN="LEFT">Day month
   year. <TR><TD ALIGN="LEFT"><B>DATE ORDER MDY</B>  <TD
   ALIGN="LEFT">Month day year. </TABLE> You can override the
   order using these flags: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>FLAG D ORDER YMD</B>  <TD ALIGN="LEFT">Year
   month day. <TR><TD ALIGN="LEFT"><B>FLAG D ORDER DMY</B>  <TD
   ALIGN="LEFT">Day month year. <TR><TD ALIGN="LEFT"><B>FLAG D
   ORDER MDY</B>  <TD ALIGN="LEFT">Month day year. </TABLE>
   Returns the date as a long integer, YYYYMMDD. The conversion is
   pretty relaxed and allows strings like: 010195, 1-1-95, 1-Jan-
   95, 1jan95, 01jan95, 1 1 95, etc. The input string must be
   null-terminated. Returns -1 in case of an invalid date or
   format. If the short formats (DATE_DM_..., DATE_YM_...) are
   used, the missing field is always set to 0 and cannot be
   supplied in the string. If the date was empty, i.e. contains no
   usable digits, returns 0.
<H4>Source Code - (sflcvsd.c)</H4>
<PRE>
{
    static
        char *month_name [] =
          {
            "jan", "feb", "mar", "apr", "may", "jun",
            "jul", "aug", "sep", "oct", "nov", "dec"
          };

    static byte
        month_days [] =
          {
            31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
          },
        order_ptr [][3] =               /*  Year, Month, Day pointers        */
          {                             /*    for various orders &amp; formats   */
          /*  YY MM DD   YYYY MM DD     YY MM       YYYY MM            MM DD */
            { 0, 2, 4 }, { 0, 4, 6 }, { 0, 2, 99 }, { 0, 4, 99 }, { 99, 0, 2 },
            { 4, 2, 0 }, { 4, 2, 0 }, { 2, 0, 99 }, { 2, 0, 99 }, { 99, 2, 0 },
            { 4, 0, 2 }, { 4, 0, 2 }, { 2, 0, 99 }, { 2, 0, 99 }, { 99, 0, 2 },
          };

    char
        date_digits   [9],              /*  8 digits of date                 */
        month_letters [4] = "???",      /*  3 characters of month            */
        ch;                             /*  Next character in date           */
    long
        feedback;                       /*  Returned date; -1 = error        */
    int
        digits,                         /*  Number of digits in string       */
        delimiters,                     /*  Number of delimiters in date     */
        digitseq,                       /*  Number of digits in sequence     */
        count,                          /*  Number of month letters          */
        year,                           /*  Date year value                  */
        month,                          /*  Date month value                 */
        day,                            /*  Date day value                   */
        order_index,                    /*  Index into order table           */
        y_ptr,                          /*  Where is year in date?           */
        m_ptr,                          /*  Where is month in date?          */
        d_ptr,                          /*  Where is day in date?            */
        date_order = order;             /*  Actual date order                */
    Bool
        had_month;                      /*  Did we already get a month?      */

    ASSERT (format &gt;= DATE_FORMAT_FIRST &amp;&amp; format &lt;= DATE_FORMAT_LAST);
    ASSERT (order  &gt;= DATE_ORDER_FIRST  &amp;&amp; order  &lt;= DATE_ORDER_LAST);

    conv_reason = 0;                    /*  No conversion errors so far      */
    if (flags &amp; FLAG_D_ORDER_YMD)
        date_order = DATE_ORDER_YMD;
    else
    if (flags &amp; FLAG_D_ORDER_DMY)
        date_order = DATE_ORDER_DMY;
    else
    if (flags &amp; FLAG_D_ORDER_MDY)
        date_order = DATE_ORDER_MDY;

    /*  Collect date digits                                                  */
    digits     = 0;                     /*  Nothing collected so far         */
    digitseq   = 0;                     /*  No digits in sequence            */
    feedback   = 0;                     /*  No errors so far                 */
    delimiters = 0;                     /*  We allow up to 2 delimiters      */
    had_month  = FALSE;                 /*  True after 3-letter month seen   */

    do
      {
        ch = *string++;
        if (isdigit (ch))
          {
            if (digits &lt; 8)
              {
                digitseq++;
                date_digits [digits++] = ch;
              }
            else
              {
                conv_reason = CONV_ERR_DATE_SIZE;
                feedback = -1;          /*  Too many digits                  */
              }
          }
        else
          {
            /*  Fill-up to even number of digits                             */
            if (digits &gt; (digits / 2) * 2)
              {
                date_digits [digits] = date_digits [digits - 1];
                date_digits [digits - 1] = '0';
                digits++;
              }
            /*  3 or 5 in a row is not allowed                               */
            if (digitseq == 3 || digitseq == 5)
              {
                conv_reason = CONV_ERR_REJECT_3_5;
                feedback = -1;
              }
            digitseq = 0;

            /*  If a letter, try to match against a month                    */
            if (isalpha (ch))
              {
                if (had_month)
                  {
                    conv_reason = CONV_ERR_MULTIPLE_MONTH;
                    feedback = -1;
                  }
                else
                  {
                    for (count = 0; isalpha (ch); )
                      {
                        if (count &lt; 3)
                            month_letters [count++] = (char) tolower (ch);
                        ch = *string++;
                      }
                    string--;           /*  Move back to char after month    */
                    if (count &lt; 3)
                      {
                        conv_reason = CONV_ERR_BAD_MONTH;
                        feedback = -1;  /*  Too few letters                  */
                      }
                    month_letters [3] = 0;
                    for (count = 0; count &lt; 12; count++)
                        if (streq (month_letters, month_name [count]))
                          {
                            count++;
                            date_digits [digits++] = (char) (count / 10 + '0');
                            date_digits [digits++] = (char) (count % 10 + '0');
                            had_month = TRUE;
                            break;
                          }
                    if (!had_month)
                      {
                        conv_reason = CONV_ERR_BAD_MONTH;
                        feedback = -1;  /*  Month not found                  */
                      }
                  }
              }
            else
            if (ispunct (ch))           /*  Skip any delimiter               */
                if ((++delimiters &gt; 2)
                ||  (format &gt; DATE_YMD_LAST &amp;&amp; delimiters &gt; 1))
                  {
                    conv_reason = CONV_ERR_MULTIPLE_DELIM;
                    feedback = -1;      /*  Multiple delimiters              */
                  }
          }
      }
    until (ch == 0);

    /*  Return zero date if empty                                            */
    if (digits == 0)
        return (feedback);

    /*  Calculate offset in date_digits for various date order &amp; formats     */
    order_index = (date_order - 1) * 5; /*  Each row has 5 items             */

    if (format &lt;= DATE_YMD_LAST)
      {
        if (digits == 6)
            ;   /* nothing */
        else
        if (digits == 8)
            order_index += 1;
      }
    else
    if (format &lt;= DATE_YM_LAST)
      {
        date_digits [digits++] = '0';
        date_digits [digits++] = '0';
        if (digits == 6)
            order_index += 2;
        else
        if (digits == 8)
            order_index += 3;
        else
          {
            conv_reason = CONV_ERR_DATE_SIZE;
            return (-1);                /*  Error - bad date size            */
          }
      }
    else
    if (format &lt;= DATE_MD_LAST)
      {
        date_digits [digits++] = '0';
        date_digits [digits++] = '0';
        if (digits == 6)
            order_index += 4;
        else
          {
            conv_reason = CONV_ERR_DATE_SIZE;
            return (-1);                /*  Error - bad date size            */
          }
      }

    /*  Decode order to pick-up offset of day/month/year in date_digits      */
    y_ptr = order_ptr [order_index][0];
    m_ptr = order_ptr [order_index][1];
    d_ptr = order_ptr [order_index][2];

#   define DIGIT(x) (date_digits [(x)] - '0')
    if (y_ptr != 99)
      {
        year = DIGIT (y_ptr) * 10 + DIGIT (y_ptr + 1);
        if (digits == 8)
            year = DIGIT (y_ptr + 2) * 10 + DIGIT (y_ptr + 3) + year * 100;

        if (year &lt; 50)
            year += 2000;
        else
        if (year &lt; 100)
            year += 1900;
      }
    else
        year = 0;

    if (m_ptr != 99)
      {
        month = DIGIT (m_ptr) * 10 + DIGIT (m_ptr + 1);
        if (month == 0 || month &gt; 12)
          {
            conv_reason = CONV_ERR_OUT_OF_RANGE;
            feedback = -1;
          }
      }
    else
        month = 0;

    if (d_ptr != 99)
      {
        day = DIGIT (d_ptr) * 10 + DIGIT (d_ptr + 1);
        if ((day == 0 || day &gt; (int) month_days [month - 1])
        ||  (month == 2 &amp;&amp; day == 29 &amp;&amp; !<A href="sfldoc.htm#leap_year">leap year</A> (year)))
          {
            conv_reason = CONV_ERR_OUT_OF_RANGE;
            feedback = -1;
          }
      }
    else
        day = 0;

    if (feedback == 0)
        feedback = year * 10000L + month * 100 + day;

    return (feedback);
}
</PRE>
<A NAME="conv_str_day">&nbsp;</A>
<H3><A NAME="TOC55"><TT>conv_str_day</TT></A></H3>
<PRE>
#include "sflconv.h"
int
conv_str_day (
    const char *string)
</PRE>
<H4>Synopsis</H4>
<P>Converts a string to a day. The string contains a day name in
   English. Only the first three letters of the name are
   significant. Returns a value 0..6 for Sunday to Saturday, or -1
   if the name is not a valid day.
<H4>Source Code - (sflcvsd.c)</H4>
<PRE>
{
    static
        char *day_name [] =
          { "sun", "mon", "tue", "wed", "thu", "fri", "sat" };
    int
        day;
    char
        day_comp [4];

    /*  Get up to three letters of day name and convert to lower case        */
    strncpy (day_comp, string, 3);
    day_comp [3] = '\0';
    <A href="sfldoc.htm#strlwc">strlwc</A> (day_comp);

    /*  I don't like magic constants, but "7" is pretty safe for now         */
    for (day = 0; day &lt; 7; day++)
        if (streq (day_name [day], day_comp))
            break;

    return (day &gt;= 7? -1: day);
}
</PRE>
<A NAME="conv_str_number">&nbsp;</A>
<H3><A NAME="TOC56"><TT>conv_str_number</TT></A></H3>
<PRE>
#include "sflconv.h"
char *
conv_str_number (
    const char *string,                 /*  String to convert                */
    int   flags,                        /*  Number field flags               */
    char  dec_point,                    /*  Decimal point: '.' or ','        */
    int   decimals,                     /*  Number of decimals, or 0         */
    int   dec_format,                   /*  How are decimals shown           */
    int   width                         /*  Output field width, > 0          */
)
</PRE>
<H4>Synopsis</H4>
<P>Converts a string to a number. The number format is defined by
   one or more of these flags (you add them to get a flags
   argument): <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>FLAG N
   SIGNED</B>  <TD ALIGN="LEFT">Number is signed. <TR><TD
   ALIGN="LEFT"><B>FLAG N DECIMALS</B>  <TD ALIGN="LEFT">Number
   has decimals. <TR><TD ALIGN="LEFT"><B>FLAG N ZERO FILL</B>  <TD
   ALIGN="LEFT">Number has leading zeros. <TR><TD
   ALIGN="LEFT"><B>FLAG N THOUSANDS</B>  <TD ALIGN="LEFT">Number
   has thousands-separators. </TABLE> The input string may contain
   digits, decimal point, thousand separators and a sign character
   or indicator. Formatting characters are only accepted if they
   correspond to the number format. A blank string is accepted as
   zero. A space following digits ends the number; anything
   further is ignored. Returns a string of width digits, including
   leading sign if that is required. Zeroes are signed with a
   space. Width must be at least 1. If the flag FLAG_N_DECIMALS is
   set, the last X digits are decimals, where X is the value of
   the decimals argument. Decimals are then accepted or rejected
   depending on the dec_format: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>DECS SHOW ALL</B>  <TD ALIGN="LEFT">Accept
   decimals. <TR><TD ALIGN="LEFT"><B>DECS DROP ZEROS</B>  <TD
   ALIGN="LEFT">Accept decimals. <TR><TD ALIGN="LEFT"><B>DECS HIDE
   ALL</B>  <TD ALIGN="LEFT">Reject decimals. <TR><TD
   ALIGN="LEFT"><B>DECS SCIENTIFIC</B>  <TD ALIGN="LEFT">Accept
   decimals. </TABLE> If the flag FLAG_N_SIGNED is set, accepts a
   leading or trailing sign, or a financial negative like this:
   (123). Returns a pointer to the formatted string, or null if
   the string was rejected. These are the possible reasons for
   rejection: <UL> <LI>- input number is too large for specified
   width; <LI>- input number is signed when no sign is allowed;
   <LI>- input number decimals when none are allowed; <LI>- input
   number has more decimals than are allowed; <LI>- more than one
   sign character in number; <LI>- malformed financial negative
   '(123)'; <LI>- more than one decimal point in number; <LI>-
   thousand seps when FLAG_N_THOUSANDS is cleared or
   FLAG_N_ZERO_FILL <LI>is set (this overrides FLAG_N_THOUSANDS);
   <LI>- junk in input string (unrecognised character). </UL>
<H4>Source Code - (sflcvsn.c)</H4>
<PRE>
{
    static char
        number [FORMAT_MAX + 1];        /*  Cleaned-up return string         */
    int
        digits,                         /*  Number of digits read so far     */
        decs_wanted = decimals;         /*  Number of decimals wanted        */
    char
       *dest,                           /*  Store formatted number here      */
        sign_char,                      /*  Number's sign: ' ', '+', '-'     */
        sep_char,                       /*  Thousands separator '.' or ','   */
        decs_seen,                      /*  Number of decimals output        */
        ch;                             /*  Next character in picture        */
    Bool
        have_point,                     /*  Have we seen a decimal point     */
        have_zero,                      /*  TRUE if number is all zero       */
        end_loop;                       /*  Flag to break out of scan loop   */

    ASSERT (width &lt;= FORMAT_MAX);
    ASSERT (width &gt; 0);
    ASSERT (dec_point == '.' || dec_point == ',');

    conv_reason = 0;                    /*  No conversion errors so far      */

    /*  ---------------------------------   Prepare to copy digits  ---------*/

    if ((flags &amp; FLAG_N_THOUSANDS) &amp;&amp; !(flags &amp; FLAG_N_ZERO_FILL))
        sep_char = dec_point == '.'? ',': '.';
    else
        sep_char = ' ';                 /*  Reject any thousands separator   */

    /*  ---------------------------------   Copy the digits  ----------------*/

    digits     = 0;                     /*  No digits loaded yet             */
    decs_seen  = 0;                     /*  No decimals output yet           */
    sign_char  = ' ';                   /*  Final sign character '+' or '-'  */
    end_loop   = FALSE;                 /*  Flag to break out of scan loop   */
    have_point = FALSE;                 /*  No decimal point seen            */
    have_zero  = TRUE;                  /*  So far, it's zero                */

    dest = number;                      /*  Scan through number              */
    while (*string)
      {
        ch = *string++;
        switch (ch)
          {
            case '9':
            case '8':
            case '7':
            case '6':
            case '5':
            case '4':
            case '3':
            case '2':
            case '1':
                have_zero = FALSE;
            case '0':
                digits++;
                *dest++ = ch;
                if (have_point)
                    ++decs_seen;
                break;

            case '-':
            case '+':
            case '(':
                if (sign_char != ' ')
                  {
                    conv_reason = CONV_ERR_MULTIPLE_SIGN;
                    return (NULL);      /*  More than one sign char          */
                  }
                else
                if (flags &amp; FLAG_N_SIGNED)
                    sign_char = ch;
                else
                  {
                    conv_reason = CONV_ERR_SIGN_REJECTED;
                    return (NULL);      /*  Number may not be signed         */
                  }
                break;

            case ')':
                if (sign_char == '(')
                    sign_char = '-';
                else
                  {
                    conv_reason = CONV_ERR_SIGN_BAD_FIN;
                    return (NULL);      /*  Malformed financial negative     */
                  }
                break;

            case ' ':                   /*  Space ends number after digits   */
                end_loop = (digits &gt; 0);
                break;

            default:
                if (ch == dec_point)
                  {
                    if (have_point)
                      {
                        conv_reason = CONV_ERR_MULTIPLE_POINT;
                        return (NULL);  /*  More than one decimal point      */
                      }
                    else
                    if (flags &amp; FLAG_N_DECIMALS)
                        have_point = TRUE;
                    else
                      {
                        conv_reason = CONV_ERR_DECS_REJECTED;
                        return (NULL);  /*  No decimals are allowed          */
                      }
                  }
                else
                if (ch != sep_char)     /*  We allow sep chars anywhere      */
                  {
                    conv_reason = CONV_ERR_INVALID_INPUT;
                    return (NULL);      /*    else we have junk              */
                  }
          }
        if (end_loop)
            break;
      }

    /*  ---------------------------------   Post-format the result  ---------*/

    if (flags &amp; FLAG_N_DECIMALS)
      {
        ASSERT (width &gt; decs_wanted);   /*  At least decimals + 1 digit      */

        if (dec_format == DECS_HIDE_ALL)
          {
            if (have_point)
              {
                conv_reason = CONV_ERR_DECS_HIDDEN;
                return (NULL);          /*  No decimals are allowed          */
              }
          }
        while (decs_seen &lt; decs_wanted) /*  Supply missing decimals          */
          {
            digits++;
            *dest++ = '0';
            decs_seen++;
          }
        if (decs_seen &gt; decs_wanted)
          {
            conv_reason = CONV_ERR_DECS_OVERFLOW;
            return (NULL);              /*  More decimals than allowed       */
          }
      }
    else
        decs_wanted = 0;

    *dest = 0;                          /*  Terminate the string nicely      */
    if (digits &gt; width)
      {
        conv_reason = CONV_ERR_TOO_MANY_DIGITS;
        return (NULL);                  /*  Overflow -- number too large     */
      }

    /*  Supply leading zeroes                                                */
    if (digits &lt; width)
      {
        /*  Shift number and null to right of field                          */
        memmove (number + (width - digits), number, digits + 1);
        memset  (number, '0', width - digits);
      }

    /*  Store sign if necessary                                              */
    if (flags &amp; FLAG_N_SIGNED)
      {
        ASSERT (width &gt; 1);             /*  At least sign + 1 digit          */
        if (number [0] != '0')
          {
            conv_reason = CONV_ERR_TOO_MANY_DIGITS;
            return (NULL);              /*  Overflow -- no room for sign     */
          }
        if (sign_char == '(')
          {
            conv_reason = CONV_ERR_SIGN_BAD_FIN;
            return (NULL);              /*  Malformed financial negative     */
          }
        else
        if (sign_char == ' ')
            sign_char = '+';

        if (have_zero)
            number [0] = ' ';           /*  Store sign                       */
        else
            number [0] = sign_char;
      }

    return (number);
}
</PRE>
<A NAME="conv_str_time">&nbsp;</A>
<H3><A NAME="TOC57"><TT>conv_str_time</TT></A></H3>
<PRE>
#include "sflconv.h"
/*  We supply the dialog file as the source
long
conv_str_time (const char *p_string)
</PRE>
<H4>Synopsis</H4>
<P>Converts a string to a time. The string must have this format:
   hour[&lt;delim&gt;minute[&lt;delim&gt;second[&lt;delim&gt;centi
   ]]][a[m]|p[m]] Any non-digit is accepted as delimiter. Each
   component may be one or two digits. The input string must be
   null-terminated. Returns -1 in case of an invalid date or
   format. If the string was empty (contains no usable digits,
   returns 0. The am/pm indicator can occur one anywhere in the
   string.
<H4>Source Code - (sflcvst.c)</H4>
<PRE>
{

After-Init:
    (--) Ok                                 -&gt; Expect-Hour
          + Get-Next-Component

Expect-Hour:
    (--) Number                             -&gt; Expect-Minute
          + Have-Hour
          + Get-Next-Component
    (--) Am-Pm                              -&gt; Expect-Hour
          + Have-Am-Pm-Indicator
          + Get-Next-Component

Expect-Minute:
    (--) Number                             -&gt; Expect-Second
          + Have-Minute
          + Get-Next-Component
    (--) Am-Pm                              -&gt; Expect-Minute
          + Have-Am-Pm-Indicator
          + Get-Next-Component

Expect-Second:
    (--) Number                             -&gt; Expect-Centisecond
          + Have-Second
          + Get-Next-Component
    (--) Am-Pm                              -&gt; Expect-Second
          + Have-Am-Pm-Indicator
          + Get-Next-Component

Expect-Centisecond:
    (--) Number                             -&gt; Allow-Am-Pm
          + Have-Centisecond
          + Get-Next-Component
    (--) Am-Pm                              -&gt; Expect-Centisecond
          + Have-Am-Pm-Indicator
          + Get-Next-Component

Allow-Am-Pm:
    (--) Am-Pm                              -&gt; Expect-Finished
          + Have-Am-Pm-Indicator
          + Get-Next-Component

Expect-Finished:
    (--) Finished                           -&gt;
          + Have-Complete-Time
          + Terminate-The-Program

Defaults:
    (--) Number                             -&gt;
          + Have-Invalid-Time
          + Terminate-The-Program
    (--) Am-Pm                              -&gt;
          + Have-Invalid-Time
          + Terminate-The-Program
    (--) Finished                           -&gt;
          + Have-Complete-Time
          + Terminate-The-Program
    (--) Delimiter                          -&gt;
          + Have-Delimiter
          + Get-Next-Component
    (--) Error                              -&gt;
          + Have-Invalid-Time
          + Terminate-The-Program
}
</PRE>
<A NAME="conv_time_pict">&nbsp;</A>
<H3><A NAME="TOC58"><TT>conv_time_pict</TT></A></H3>
<PRE>
#include "sflconv.h"
char *
conv_time_pict (
    long time,
    const char *picture)
</PRE>
<H4>Synopsis</H4>
<P>Converts a time to a string using a picture. The picture is
   composed of any combination of these formats: <TABLE BORDER
   NOWRAP> <TR><TD ALIGN="LEFT"><B>h</B>  <TD ALIGN="LEFT">hour,
   0-23 <TR><TD ALIGN="LEFT"><B>hh</B>  <TD ALIGN="LEFT">hour, 00-
   23 <TR><TD ALIGN="LEFT"><B>m</B>  <TD ALIGN="LEFT">minute, 0-59
   <TR><TD ALIGN="LEFT"><B>mm</B>  <TD ALIGN="LEFT">minute, 00-59
   <TR><TD ALIGN="LEFT"><B>s</B>  <TD ALIGN="LEFT">second, 0-59
   <TR><TD ALIGN="LEFT"><B>ss</B>  <TD ALIGN="LEFT">second, 00-59
   <TR><TD ALIGN="LEFT"><B>c</B>  <TD ALIGN="LEFT">centisecond, 0-
   99 <TR><TD ALIGN="LEFT"><B>cc</B>  <TD
   ALIGN="LEFT">centisecond, 00-99 <TR><TD ALIGN="LEFT"><B>a</B>
   <TD ALIGN="LEFT">a/p indicator - use 12-hour clock <TR><TD
   ALIGN="LEFT"><B>aa</B>  <TD ALIGN="LEFT">am/pm indicator - use
   12-hour clock <TR><TD ALIGN="LEFT"><B>A</B>  <TD
   ALIGN="LEFT">A/P indicator - use 12-hour clock <TR><TD
   ALIGN="LEFT"><B>AA</B>  <TD ALIGN="LEFT">AM/PM indicator - use
   12-hour clock <TR><TD ALIGN="LEFT"><B>\x</B>  <TD
   ALIGN="LEFT">literal character x <TR><TD
   ALIGN="LEFT"><B>other</B>  <TD ALIGN="LEFT">literal character
   </TABLE> Returns the formatted result. This is a static string,
   of at most 80 characters, that is overwritten by each call. If
   time is zero, returns an empty string. The 'h', 'm', 's', and
   'c' formats output a leading space when used at the start of
   the picture. This is to improve the alignment of a column of
   times. If the previous character was a digit, these formats
   also output a space in place of the leading zero.
<H4>Source Code - (sflcvtp.c)</H4>
<PRE>
{
    static char
        formatted [FORMAT_MAX + 1];     /*  Formatted return string          */
    int
        hour,                           /*  Hour component of time           */
        minute,                         /*  Minute component of time         */
        second,                         /*  Second component of time         */
        centi,                          /*  1/100 sec component of time      */
        cursize;                        /*  Size of current component        */
    char
       *dest,                           /*  Store formatted data here        */
        ch,                             /*  Next character in picture        */
        lastch = '0';                   /*  Last character we output         */
    Bool
        pm;                             /*  TRUE when hour &gt;= 12             */

    conv_reason = 0;                    /*  No conversion errors so far      */

    /*  Zero time is returned as empty string                                */
    if (time == 0)
      {
        strclr (formatted);
        return (formatted);
      }

    hour    = GET_HOUR   (time);
    minute  = GET_MINUTE (time);
    second  = GET_SECOND (time);
    centi   = GET_CENTI  (time);

    /*  If am/pm component specified, use 12-hour clock                      */
    if (hour &gt;= 12)
      {
        pm = TRUE;
        if (strpbrk (picture, "aA") &amp;&amp; hour &gt; 12)
            hour -= 12;
      }
    else
        pm = FALSE;

    ASSERT (hour   &gt;= 0 &amp;&amp; hour   &lt; 24);
    ASSERT (minute &gt;= 0 &amp;&amp; minute &lt; 60);
    ASSERT (second &gt;= 0 &amp;&amp; second &lt; 60);

    /*  Scan through picture, converting each component                      */
    dest = formatted;
    *dest = 0;                          /*  string is empty                  */
    while (*picture)
      {
        /*  Get character and count number of occurences                     */
        ch = *picture++;
        for (cursize = 1; *picture == ch; cursize++)
            picture++;

        switch (ch)
          {
            /*  h         hour,  0-23                                        */
            /*  hh        hour, 00-23                                        */
            case 'h':
                if (cursize == 1)
                    sprintf (dest, (isdigit (lastch)? "%2d": "%d"), hour);
                else
                if (cursize == 2)
                    sprintf (dest, "%02d", hour);
                break;

            /*  m         minute,  0-59                                      */
            /*  mm        minute, 00-59                                      */
            case 'm':
                if (cursize == 1)
                    sprintf (dest, (isdigit (lastch)? "%2d": "%d"), minute);
                else
                if (cursize == 2)
                    sprintf (dest, "%02d", minute);
                break;

            /*  s         second,  0-59                                      */
            /*  ss        second, 00-59                                      */
            case 's':
                if (cursize == 1)
                    sprintf (dest, (isdigit (lastch)? "%2d": "%d"), second);
                else
                if (cursize == 2)
                    sprintf (dest, "%02d", second);
                break;

            /*  c         centisecond,  0-99                                 */
            /*  cc        centisecond, 00-99                                 */
            case 'c':
                if (cursize == 1)
                    sprintf (dest, (isdigit (lastch)? "%2d": "%d"), centi);
                else
                if (cursize == 2)
                    sprintf (dest, "%02d", centi);
                break;

            /*  a         a/p indicator                                      */
            /*  aa        am/pm indicator                                    */
            case 'a':
                strncat (dest, (pm? "pm": "am"), cursize);
                dest [cursize] = 0;
                break;

            /*  A         A/P indicator                                      */
            /*  AA        AM/PM indicator                                    */
            case 'A':
                strncat (dest, (pm? "PM": "AM"), cursize);
                dest [cursize] = 0;
                break;

            /*  \x        literal character x                                */
            case '\\':
                ch = *picture++;
        }
        if (*dest)                      /*  If something was output,         */
            while (*dest)               /*    skip to end of string          */
                dest++;
        else
            while (cursize--)           /*  Else output ch once or more      */
                *dest++ = ch;           /*    and bump dest pointer          */

        lastch = *(dest - 1);           /*  Get previous character           */
        *dest = 0;                      /*  Terminate the string nicely      */
    }
    return (formatted);
}
</PRE>
<A NAME="conv_time_str">&nbsp;</A>
<H3><A NAME="TOC59"><TT>conv_time_str</TT></A></H3>
<PRE>
#include "sflconv.h"
char *
conv_time_str (
    long time,
    int  flags,
    char timesep,
    int  width)
</PRE>
<H4>Synopsis</H4>
<P>Converts a time to a string. The flags and width control the
   resulting string. You can use one or more of these flags added
   together: <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>FLAG T
   HH AS H</B>  <TD ALIGN="LEFT">Suppress leading zeroes on the
   hours. <TR><TD ALIGN="LEFT"><B>FLAG T MM AS M</B>  <TD
   ALIGN="LEFT">Suppress leading zeroes on the minutes. <TR><TD
   ALIGN="LEFT"><B>FLAG T SS AS S</B>  <TD ALIGN="LEFT">Suppress
   leading zeroes on the seconds. <TR><TD ALIGN="LEFT"><B>FLAG T
   CC AS C</B>  <TD ALIGN="LEFT">Suppress leading zeroes on the
   centiseconds. <TR><TD ALIGN="LEFT"><B>FLAG T COMPACT</B>  <TD
   ALIGN="LEFT">Show without delimiters. <TR><TD
   ALIGN="LEFT"><B>FLAG T 12 HOUR</B>  <TD ALIGN="LEFT">Append
   am/pm indicator. </TABLE> Returns a pointer to a static area
   holding the string, or NULL if there was an error. If no flags
   are used, the width argument gives these results (shown as a
   picture, which is how conv_time_str works - see
   conv_time_pict): <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>4 or less</B>  <TD ALIGN="LEFT">Error. <TR><TD
   ALIGN="LEFT"><B>5 to 7</B>  <TD ALIGN="LEFT">"hh:mm" <TR><TD
   ALIGN="LEFT"><B>8 to 10</B>  <TD ALIGN="LEFT">"hh:mm:ss"
   <TR><TD ALIGN="LEFT"><B>11 or more</B>  <TD
   ALIGN="LEFT">"hh:mm:ss:cc" </TABLE> If FLAG_T_COMPACT is used,
   width gives these results: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>3 or less</B>  <TD ALIGN="LEFT">Error. <TR><TD
   ALIGN="LEFT"><B>4 to 5</B>  <TD ALIGN="LEFT">"hhmm" <TR><TD
   ALIGN="LEFT"><B>6 to 7</B>  <TD ALIGN="LEFT">"hhmmss" <TR><TD
   ALIGN="LEFT"><B>8 or more</B>  <TD ALIGN="LEFT">"hhmmsscc"
   </TABLE> If FLAG_T_12_HOUR is used, width gives these results:
   <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>5 or less</B>
   <TD ALIGN="LEFT">Error. <TR><TD ALIGN="LEFT"><B>6 to 8</B>  <TD
   ALIGN="LEFT">"hh:mma" <TR><TD ALIGN="LEFT"><B>9 to 11</B>  <TD
   ALIGN="LEFT">"hh:mm:ssa" <TR><TD ALIGN="LEFT"><B>12 or more</B>
   <TD ALIGN="LEFT">"hh:mm:ss:cca" </TABLE> If FLAG_T_COMPACT and
   FLAG_T_12_HOUR are used, width gives these results: <TABLE
   BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>4 or less</B>  <TD
   ALIGN="LEFT">Error. <TR><TD ALIGN="LEFT"><B>5 to 6</B>  <TD
   ALIGN="LEFT">"hhmma" <TR><TD ALIGN="LEFT"><B>7 to 8</B>  <TD
   ALIGN="LEFT">"hhmmssa" <TR><TD ALIGN="LEFT"><B>9 or more</B>
   <TD ALIGN="LEFT">"hhmmsscca" </TABLE>
<H4>Source Code - (sflcvts.c)</H4>
<PRE>
{
    char
        delim [2],                      /*  Delimiter string, ":" or ""      */
        picture [13];                   /*  Largest picture: hh:mm:ss:cca    */
    int
        delim_len;
    int
        space_left = width;

    conv_reason = 0;                    /*  No conversion errors so far      */
    if (flags &amp; FLAG_T_COMPACT)
      {
        delim [0] = 0;
        delim_len = 0;
      }
    else
      {
        delim [0] = timesep;
        delim [1] = 0;
        delim_len = 1;
      }
    if (flags &amp; FLAG_T_12_HOUR)
        space_left--;                   /*  Subtract 1 if eventual "a"       */

    /*  Build-up date picture components until we run out of space           */
    strcpy (picture, (flags &amp; FLAG_T_HH_AS_H? "h": "hh"));
    space_left -= 2;

    if (space_left &gt;= delim_len + 2)
      {
        strcat (picture, delim);
        strcat (picture, (flags &amp; FLAG_T_MM_AS_M? "m": "mm"));
        space_left -= delim_len + 2;
      }
    else
        return (NULL);                  /*  Error - space_left is too small  */

    if (space_left &gt;= delim_len + 2)
      {
        strcat (picture, delim);
        strcat (picture, (flags &amp; FLAG_T_SS_AS_S? "s": "ss"));
        space_left -= delim_len + 2;
      }

    if (space_left &gt;= delim_len + 2)
      {
        strcat (picture, delim);
        strcat (picture, (flags &amp; FLAG_T_CC_AS_C? "c": "cc"));
        space_left -= delim_len + 2;
      }

    /*  Append "a" (or "aa" if space) if 12-hour clock wanted                */
    if (flags &amp; FLAG_T_12_HOUR)
        strcat (picture, (space_left == 0? "a": "aa"));

    return (<A href="sfldoc.htm#conv_time_pict">conv time pict</A> (time, picture));
}
</PRE>
<H2><A NAME="TOC60">Encryption and decryption functions</A></H2>
<P>Filename: sflcryp.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1996/01/23 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1997/09/08
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>The encryption/decryption functions were based on the
   cryptosystem library by Andrew Brown <A
   HREF=mailto:"asb@cs.nott.ac.uk">asb@cs.nott.ac.uk</A>, cleaned-
   up for portability. Thanks for a great package. IDEA is
   registered as the international patent WO 91/18459 "Device for
   Converting a Digital Block and the Use thereof". For commercial
   use of IDEA, you should contact: ASCOM TECH AG Freiburgstrasse
   370 CH-3018 Bern, Switzerland
<H3>Notes</H3>
<PRE>
    Description of IDEA cipher
    --------------------------
    The IDEA cipher operates on 64 bit (8 byte) blocks, using a 128 bit (16
    byte) key. IDEA has found itself famous through its inclusion in the
    well-known PGP package. The following is from the introduction to chapter
    3 of the thesis that presented the cipher.

    The block cipher IDEA (International Data Encryption Algorithm) is based
    on the new design concept of "mixing operations from different algebraic
    groups". The required "confusion" was achieved by successively using three
    "incompatible" group operations on pairs of 16-bit subblocks and the cipher
    structure was chosen to provide the necessary "diffusion". The cipher
    structure was further chosen to facilitate both hardware and software
    implementations. The IDEA cipher is an improved version of PES and was
    developed to increase security against differential cryptanalysis.

    Description of MDC cipher
    -------------------------
    This is a method for turning a hash function, here MD5, into a fast
    secret-key encryption. Based on a suggestion by Phil Karn in sci.crypt, 13
    Feb 1992. See also his comments from sci.crypt, 23 Mar 1992. The method is
    a variant of that described in Zheng, Matsumoto and Imai, Crypto 89. See
    also, "A New Class of Cryptosystems Based on Interconnection Networks" by
    michaelp@terpsichore.informatic.rwth-aachen.de

    Description of DES cipher
    -------------------------
    DES is the well known U.S. Data Encryption Standard cipher.
    DES encrypts data in 64 bit blocks, using a 64 bit key -- of which
    56 bits are used in the encipherment process.
</PRE>
<H4>List of Functions</H4>
<UL>
<LI>Bool <A href="sfldoc.htm#crypt_encode">crypt encode</A><BR>
   (byte *buffer, word buffer_size, int algorithm, const byte
   *key);
</LI>
<LI>Bool <A href="sfldoc.htm#crypt_decode">crypt decode</A><BR>
   (byte *buffer, word buffer_size, int algorithm, const byte
   *key);
</LI>
<LI>qbyte <A href="sfldoc.htm#calculate_crc">calculate crc</A><BR>
   (byte *block, size_t length);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflcryp.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>CRYPT_DES</B>  </TT>
<TD ALIGN="LEFT">2 /* DES algorithm */
<TR><TD ALIGN="LEFT"><TT><B>CRYPT_IDEA</B>  </TT>
<TD ALIGN="LEFT">0 /* IDEA algorithm */
<TR><TD ALIGN="LEFT"><TT><B>CRYPT_MAX_BLOCK_SIZE</B>  </TT>
<TD ALIGN="LEFT">32 /* Largest block size, in bytes */
<TR><TD ALIGN="LEFT"><TT><B>CRYPT_MDC</B>  </TT>
<TD ALIGN="LEFT">1 /* MDC algorithm */
<TR><TD ALIGN="LEFT"><TT><B>CRYPT_TOP</B>  </TT>
<TD ALIGN="LEFT">4 /* We support 4 algorithms */
<TR><TD ALIGN="LEFT"><TT><B>CRYPT_XOR</B>  </TT>
<TD ALIGN="LEFT">3 /* A basic XOR algorithm */
<TR><TD ALIGN="LEFT"><TT><B>SFLCRYP_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="crypt_encode">&nbsp;</A>
<H3><A NAME="TOC61"><TT>crypt_encode</TT></A></H3>
<PRE>
#include "sflcryp.h"
Bool
crypt_encode (
    byte *buffer,                       /*  Data to encrypt, in-place        */
    word  buffer_size,                  /*  Amount of data to encrypt        */
    int   algorithm,                    /*  What type of encryption          */
    const byte *key)                    /*  Encryption key                   */
</PRE>
<H4>Synopsis</H4>
<P>Encrypt a buffer with the specified algorithm and specified
   key. Returns TRUE if the buffer is encrypted sucessfully. The
   buffer is encrypted in-place. The algorithm can be one of:
   <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>CRYPT IDEA</B>
   <TD ALIGN="LEFT">Use IDEA encryption. <TR><TD
   ALIGN="LEFT"><B>CRYPT MDC</B>  <TD ALIGN="LEFT">Use MDC
   encryption. <TR><TD ALIGN="LEFT"><B>CRYPT DES</B>  <TD
   ALIGN="LEFT">Use DES encryption. <TR><TD ALIGN="LEFT"><B>CRYPT
   XOR</B>  <TD ALIGN="LEFT">Use XOR encryption. </TABLE> The
   minimum buffer size, and key size depends on the algorithm:
   <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>CRYPT IDEA</B>
   <TD ALIGN="LEFT">Buffer is at least 8 bytes long, key is 16
   bytes. <TR><TD ALIGN="LEFT"><B>CRYPT MDC</B>  <TD
   ALIGN="LEFT">Buffer is at least 8 bytes long, key is 8 bytes.
   <TR><TD ALIGN="LEFT"><B>CRYPT DES</B>  <TD ALIGN="LEFT">Buffer
   is at least 32 bytes long, key is 16 bytes. <TR><TD
   ALIGN="LEFT"><B>CRYPT XOR</B>  <TD ALIGN="LEFT">Buffer is at
   least 16 bytes long, key is 16 bytes. </TABLE> Use
   <A href="sfldoc.htm#crypt_decode">crypt decode</A>() with the same algorithm and key to decrypt
   the buffer. The buffer size must be a multiple of the minimum
   size shown above. If you specify a buffer size of zero the
   function does nothing but returns TRUE. For portability, the
   buffer size is limited to 64k.
<H4>Source Code - (sflcryp.c)</H4>
<PRE>
{
    return (crypt_data (buffer, buffer_size, algorithm, key, TRUE));
}
</PRE>
<A NAME="crypt_decode">&nbsp;</A>
<H3><A NAME="TOC62"><TT>crypt_decode</TT></A></H3>
<PRE>
#include "sflcryp.h"
Bool
crypt_decode (
    byte *buffer,                       /*  Data to decrypt, in-place        */
    word  buffer_size,                  /*  Amount of data to decrypt        */
    int   algorithm,                    /*  What type of decryption          */
    const byte *key)                    /*  Decryption key                   */
</PRE>
<H4>Synopsis</H4>
<P>Decrypt a buffer that was produced by <A href="sfldoc.htm#crypt_encode">crypt encode</A>(). You
   must (obviously, I reckon) use the same algorithm and key as
   was used to encrypt the data. Returns TRUE if the buffer is
   decrypted okay. The buffer is encrypted in-place. The algorithm
   can be one of: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>CRYPT IDEA</B>  <TD ALIGN="LEFT">Use IDEA
   encryption. <TR><TD ALIGN="LEFT"><B>CRYPT MDC</B>  <TD
   ALIGN="LEFT">Use MDC encryption. <TR><TD ALIGN="LEFT"><B>CRYPT
   DES</B>  <TD ALIGN="LEFT">Use DES encryption. <TR><TD
   ALIGN="LEFT"><B>CRYPT XOR</B>  <TD ALIGN="LEFT">Use XOR
   encryption. </TABLE> The minimum buffer size, and key size
   depends on the algorithm: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>CRYPT IDEA</B>  <TD ALIGN="LEFT">Buffer is at
   least 8 bytes long, key is 16 bytes. <TR><TD
   ALIGN="LEFT"><B>CRYPT MDC</B>  <TD ALIGN="LEFT">Buffer is at
   least 8 bytes long, key is 8 bytes. <TR><TD
   ALIGN="LEFT"><B>CRYPT DES</B>  <TD ALIGN="LEFT">Buffer is at
   least 32 bytes long, key is 16 bytes. <TR><TD
   ALIGN="LEFT"><B>CRYPT XOR</B>  <TD ALIGN="LEFT">Buffer is at
   least 16 bytes long, key is 16 bytes. </TABLE> The buffer size
   must be a multiple of the minimum size shown above. If you
   specify a buffer size of zero the function does nothing but
   returns TRUE.
<H4>Source Code - (sflcryp.c)</H4>
<PRE>
{
    return (crypt_data (buffer, buffer_size, algorithm, key, FALSE));
}
</PRE>
<A NAME="calculate_crc">&nbsp;</A>
<H3><A NAME="TOC63"><TT>calculate_crc</TT></A></H3>
<PRE>
#include "sflcryp.h"
qbyte
calculate_crc (byte *block, size_t length)
</PRE>
<H4>Synopsis</H4>
<P>Calculates the 32-bit CCITT CRC for a memory block. The CRC
   calculation is rapid, since the function uses a pre-calculated
   table. Returns the 32-bit CRC.
<H4>Source Code - (sflcryp.c)</H4>
<PRE>
{
    size_t
        offset;
    word
        this_word;
    qbyte
        crc_value;                      /*  Running CRC value                */

    crc_value = 0xFFFFFFFFL;
    for (offset = 0; offset &lt; length; offset++)
    {
        this_word = block [offset];
        this_word = this_word ^ (dbyte) (crc_value &amp; 255);
        crc_value = (crc_value &gt;&gt; 8) ^ crc_table [this_word];
    }
    return (crc_value ^ 0xFFFFFFFFL);
}
</PRE>
<H2><A NAME="TOC64">Date and time functions</A></H2>
<P>Filename: sfldate.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1996/01/05 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1998/08/05
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Includes functions to get the current date/time, calculate the
   day or week, week of year and leap year. Dates and times are
   each stored in a 32-bit long value of 8 digits: dates are
   CCYYMMDD; times are HHMMSSCC. You can compare dates and times
   directly - e.g. if (date_wanted &gt;= date_now).
<H4>List of Functions</H4>
<UL>
<LI>long <A href="sfldoc.htm#date_now">date now</A><BR>
   (void);
</LI>
<LI>long <A href="sfldoc.htm#time_now">time now</A><BR>
   (void);
</LI>
<LI>Bool <A href="sfldoc.htm#leap_year">leap year</A><BR>
   (int year);
</LI>
<LI>int <A href="sfldoc.htm#julian_date">julian date</A><BR>
   (long date);
</LI>
<LI>int <A href="sfldoc.htm#day_of_week">day of week</A><BR>
   (long date);
</LI>
<LI>int <A href="sfldoc.htm#week_of_year">week of year</A><BR>
   (long date);
</LI>
<LI>int <A href="sfldoc.htm#year_quarter">year quarter</A><BR>
   (long date);
</LI>
<LI>long <A href="sfldoc.htm#next_weekday">next weekday</A><BR>
   (long date);
</LI>
<LI>long <A href="sfldoc.htm#prev_weekday">prev weekday</A><BR>
   (long date);
</LI>
<LI>word <A href="sfldoc.htm#pack_date">pack date</A><BR>
   (long date);
</LI>
<LI>word <A href="sfldoc.htm#pack_time">pack time</A><BR>
   (long time);
</LI>
<LI>long <A href="sfldoc.htm#unpack_date">unpack date</A><BR>
   (word packdate);
</LI>
<LI>long <A href="sfldoc.htm#unpack_time">unpack time</A><BR>
   (word packtime);
</LI>
<LI>long <A href="sfldoc.htm#default_century">default century</A><BR>
   (long *date);
</LI>
<LI>long <A href="sfldoc.htm#date_to_days">date to days</A><BR>
   (long date);
</LI>
<LI>long <A href="sfldoc.htm#days_to_date">days to date</A><BR>
   (long days);
</LI>
<LI>time_t <A href="sfldoc.htm#date_to_timer">date to timer</A><BR>
   (long date, long time);
</LI>
<LI>long <A href="sfldoc.htm#timer_to_date">timer to date</A><BR>
   (time_t time_secs);
</LI>
<LI>long <A href="sfldoc.htm#timer_to_time">timer to time</A><BR>
   (time_t time_secs);
</LI>
<LI>long <A href="sfldoc.htm#timer_to_gmdate">timer to gmdate</A><BR>
   (time_t time_secs);
</LI>
<LI>long <A href="sfldoc.htm#timer_to_gmtime">timer to gmtime</A><BR>
   (time_t time_secs);
</LI>
<LI>long <A href="sfldoc.htm#time_to_csecs">time to csecs</A><BR>
   (long time);
</LI>
<LI>long <A href="sfldoc.htm#csecs_to_time">csecs to time</A><BR>
   (long csecs);
</LI>
<LI>void <A href="sfldoc.htm#future_date">future date</A><BR>
   (long *date, long *time, long days, long csecs);
</LI>
<LI>void <A href="sfldoc.htm#past_date">past date</A><BR>
   (long *date, long *time, long days, long csecs);
</LI>
<LI>void <A href="sfldoc.htm#date_diff">date diff</A><BR>
   (long date1, long time1, long date2, long time2, long *days,
   long *csecs);
</LI>
<LI>Bool <A href="sfldoc.htm#valid_date">valid date</A><BR>
   (long date);
</LI>
<LI>Bool <A href="sfldoc.htm#valid_time">valid time</A><BR>
   (long time);
</LI>
<LI>Bool <A href="sfldoc.htm#date_is_future">date is future</A><BR>
   (long date, long time);
</LI>
<LI>Bool <A href="sfldoc.htm#date_is_past">date is past</A><BR>
   (long date, long time);
</LI>
<LI>char * <A href="sfldoc.htm#timezone_string">timezone string</A><BR>
   (void);
</LI>
<LI>void <A href="sfldoc.htm#local_to_gmt">local to gmt</A><BR>
   (long date, long time, long *gmdate, long *gmtime);
</LI>
<LI>void <A href="sfldoc.htm#gmt_to_local">gmt to local</A><BR>
   (long gmdate, long gmtime, long *date, long *time);
</LI>
<LI>struct tm * <A href="sfldoc.htm#safe_localtime">safe localtime</A><BR>
   (const time_t *time_secs);
</LI>
<LI>struct tm * <A href="sfldoc.htm#safe_gmtime">safe gmtime</A><BR>
   (const time_t *time_secs);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sfldate.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>DAY_FRIDAY</B>  </TT>
<TD ALIGN="LEFT">5
<TR><TD ALIGN="LEFT"><TT><B>DAY_MONDAY</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>DAY_SATURDAY</B>  </TT>
<TD ALIGN="LEFT">6
<TR><TD ALIGN="LEFT"><TT><B>DAY_SUNDAY</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>DAY_THURSDAY</B>  </TT>
<TD ALIGN="LEFT">4
<TR><TD ALIGN="LEFT"><TT><B>DAY_TUESDAY</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>DAY_WEDNESDAY</B>  </TT>
<TD ALIGN="LEFT">3
<TR><TD ALIGN="LEFT"><TT><B>GET_CCYEAR(d)</B>  </TT>
<TD ALIGN="LEFT">(int) ( (d) / 10000L)
<TR><TD ALIGN="LEFT"><TT><B>GET_CENTI(t)</B>  </TT>
<TD ALIGN="LEFT">(int) ( (t) % 100)
<TR><TD ALIGN="LEFT"><TT><B>GET_CENTURY(d)</B>  </TT>
<TD ALIGN="LEFT">(int) ( (d) / 1000000L)
<TR><TD ALIGN="LEFT"><TT><B>GET_DAY(d)</B>  </TT>
<TD ALIGN="LEFT">(int) ( (d) % 100)
<TR><TD ALIGN="LEFT"><TT><B>GET_HOUR(t)</B>  </TT>
<TD ALIGN="LEFT">(int) ( (t) / 1000000L)
<TR><TD ALIGN="LEFT"><TT><B>GET_MINUTE(t)</B>  </TT>
<TD ALIGN="LEFT">(int) (((t) % 1000000L) / 10000L)
<TR><TD ALIGN="LEFT"><TT><B>GET_MONTH(d)</B>  </TT>
<TD ALIGN="LEFT">(int) (((d) % 10000L) / 100)
<TR><TD ALIGN="LEFT"><TT><B>GET_SECOND(t)</B>  </TT>
<TD ALIGN="LEFT">(int) (((t) % 10000L) / 100)
<TR><TD ALIGN="LEFT"><TT><B>GET_YEAR(d)</B>  </TT>
<TD ALIGN="LEFT">(int) (((d) % 1000000L) / 10000L)
<TR><TD ALIGN="LEFT"><TT><B>INTERVAL_CENTI</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>INTERVAL_DAY</B>  </TT>
<TD ALIGN="LEFT">8640000L
<TR><TD ALIGN="LEFT"><TT><B>INTERVAL_HOUR</B>  </TT>
<TD ALIGN="LEFT">360000L
<TR><TD ALIGN="LEFT"><TT><B>INTERVAL_MIN</B>  </TT>
<TD ALIGN="LEFT">6000
<TR><TD ALIGN="LEFT"><TT><B>INTERVAL_SEC</B>  </TT>
<TD ALIGN="LEFT">100
<TR><TD ALIGN="LEFT"><TT><B>MAKE_DATE(c,y,m,d)</B>  </TT>
<TD ALIGN="LEFT">(long) (c) * 1000000L + <TR><TD ALIGN="LEFT"><TT><B>MAKE_TIME(h,m,s,c)</B>  </TT>
<TD ALIGN="LEFT">(long) (h) * 1000000L + <TR><TD ALIGN="LEFT"><TT><B>SFLDATE_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>timeeq(d1,t1,d2,t2)</B>  </TT>
<TD ALIGN="LEFT">((d1) == (d2) && (t1) == (t2))
<TR><TD ALIGN="LEFT"><TT><B>timege(d1,t1,d2,t2)</B>  </TT>
<TD ALIGN="LEFT">((d1) &gt; (d2) || ((d1) == (d2) && (t1) &gt;= (t2)))
<TR><TD ALIGN="LEFT"><TT><B>timegt(d1,t1,d2,t2)</B>  </TT>
<TD ALIGN="LEFT">((d1) &gt; (d2) || ((d1) == (d2) && (t1) &gt; (t2)))
<TR><TD ALIGN="LEFT"><TT><B>timele(d1,t1,d2,t2)</B>  </TT>
<TD ALIGN="LEFT">((d1) &lt; (d2) || ((d1) == (d2) && (t1) &lt;= (t2)))
<TR><TD ALIGN="LEFT"><TT><B>timelt(d1,t1,d2,t2)</B>  </TT>
<TD ALIGN="LEFT">((d1) &lt; (d2) || ((d1) == (d2) && (t1) &lt; (t2)))
<TR><TD ALIGN="LEFT"><TT><B>timeneq(d1,t1,d2,t2)</B>  </TT>
<TD ALIGN="LEFT">((d1) != (d2) || (t1) != (t2))
</TABLE>
<A NAME="date_now">&nbsp;</A>
<H3><A NAME="TOC65"><TT>date_now</TT></A></H3>
<PRE>
#include "sfldate.h"
long
date_now (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns the current date as a long value (CCYYMMDD). Since most
   system clocks do not return a century, this function assumes
   that all years 80 and above are in the 20th century, and all
   years 00 to 79 are in the 21st century. For best results,
   consume before 1 Jan 2080.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return (<A href="sfldoc.htm#timer_to_date">timer to date</A> (time (NULL)));
}
</PRE>
<A NAME="time_now">&nbsp;</A>
<H3><A NAME="TOC66"><TT>time_now</TT></A></H3>
<PRE>
#include "sfldate.h"
long
time_now (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns the current time as a long value (HHMMSSCC). If the
   system clock does not return centiseconds, these are set to
   zero.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
#if (defined (__TURBOC__))
    /*  The Turbo-C gettime() function returns just what we want             */
    struct time
        time_struct;

    gettime (&amp;time_struct);
    return (MAKE_TIME (time_struct.ti_hour,
                       time_struct.ti_min,
                       time_struct.ti_sec,
                       time_struct.ti_hund));

#elif (defined (__UTYPE_FREEBSD__))
    return (<A href="sfldoc.htm#timer_to_time">timer to time</A> (time (NULL)));

#elif (defined (__UNIX__) || defined (__VMS_XOPEN))
    /*  The BSD gettimeofday function returns seconds and microseconds       */
    struct timeval
        time_struct;

    gettimeofday (&amp;time_struct, 0);
    return (<A href="sfldoc.htm#timer_to_time">timer to time</A> (time_struct.tv_sec)
                         + time_struct.tv_usec / 10000);

#elif (defined (WIN32))
    /*  The Win32 GetLocalTime function returns just what we want            */
    SYSTEMTIME
        time_struct;

    GetLocalTime (&amp;time_struct);
    return (MAKE_TIME (time_struct.wHour,
                       time_struct.wMinute,
                       time_struct.wSecond,
                       time_struct.wMilliseconds / 10));

#else
    /*  Otherwise, just get the time without milliseconds                    */
    return (<A href="sfldoc.htm#timer_to_time">timer to time</A> (time (NULL)));
#endif
}
</PRE>
<A NAME="leap_year">&nbsp;</A>
<H3><A NAME="TOC67"><TT>leap_year</TT></A></H3>
<PRE>
#include "sfldate.h"
Bool
leap_year (int year)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the year is a leap year. You must supply a 4-
   digit value for the year: 90 is taken to mean 90 ad. Handles
   leap centuries correctly.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return ((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0);
}
</PRE>
<A NAME="julian_date">&nbsp;</A>
<H3><A NAME="TOC68"><TT>julian_date</TT></A></H3>
<PRE>
#include "sfldate.h"
int
julian_date (long date)
</PRE>
<H4>Synopsis</H4>
<P>Returns the number of days since 31 December last year. The
   Julian date of 1 January is 1.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    static int
        days [12] = {
        0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334
    };
    int
        julian;

    julian = days [GET_MONTH (date) - 1] + GET_DAY (date);
    if (GET_MONTH (date) &gt; 2 &amp;&amp; <A href="sfldoc.htm#leap_year">leap year</A> (GET_YEAR (date)))
        julian++;

    return (julian);
}
</PRE>
<A NAME="day_of_week">&nbsp;</A>
<H3><A NAME="TOC69"><TT>day_of_week</TT></A></H3>
<PRE>
#include "sfldate.h"
int
day_of_week (long date)
</PRE>
<H4>Synopsis</H4>
<P>Returns the day of the week where 0 is Sunday, 1 is Monday, ...
   6 is Saturday. Uses Zeller's Congurence algorithm.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    int
        year  = GET_CCYEAR (date),
        month = GET_MONTH  (date),
        day   = GET_DAY    (date);

    if (month &gt; 2)
        month -= 2;
    else
      {
        month += 10;
        year--;
      }
    day = ((13 * month - 1) / 5) + day + (year % 100) +
          ((year % 100) / 4) + ((year / 100) / 4) - 2 *
           (year / 100) + 77;

    return (day - 7 * (day / 7));
}
</PRE>
<A NAME="next_weekday">&nbsp;</A>
<H3><A NAME="TOC70"><TT>next_weekday</TT></A></H3>
<PRE>
#include "sfldate.h"
long
next_weekday (long date)
</PRE>
<H4>Synopsis</H4>
<P>Returns the date of the next weekday, skipping from Friday to
   Monday.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    long
        days = <A href="sfldoc.htm#date_to_days">date to days</A> (date);

    if (<A href="sfldoc.htm#day_of_week">day of week</A> (date) == 5)        /*  Friday                           */
        days += 3;
    else
    if (<A href="sfldoc.htm#day_of_week">day of week</A> (date) == 6)        /*  Saturday                         */
        days += 2;
    else
        days += 1;                      /*  Sunday to Thursday               */

    return (<A href="sfldoc.htm#days_to_date">days to date</A> (days));
}
</PRE>
<A NAME="prev_weekday">&nbsp;</A>
<H3><A NAME="TOC71"><TT>prev_weekday</TT></A></H3>
<PRE>
#include "sfldate.h"
long
prev_weekday (long date)
</PRE>
<H4>Synopsis</H4>
<P>Returns the date of the previous weekday, skipping from Monday
   to Friday.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    long
        days = <A href="sfldoc.htm#date_to_days">date to days</A> (date);

    if (<A href="sfldoc.htm#day_of_week">day of week</A> (date) == 1)        /*  Monday                           */
        days -= 3;
    else
    if (<A href="sfldoc.htm#day_of_week">day of week</A> (date) == 0)        /*  Sunday                           */
        days -= 2;
    else
        days -= 1;                      /*  Tuesday to Saturday              */

    return (<A href="sfldoc.htm#days_to_date">days to date</A> (days));
}
</PRE>
<A NAME="week_of_year">&nbsp;</A>
<H3><A NAME="TOC72"><TT>week_of_year</TT></A></H3>
<PRE>
#include "sfldate.h"
int
week_of_year (long date)
</PRE>
<H4>Synopsis</H4>
<P>Returns the week of the year, where 1 is the first full week.
   Week 0 may or may not exist in any year. Uses a Lillian date
   algorithm to calculate the week of the year.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    long
        year = GET_CCYEAR (date) - 1501,
        day  = year * 365 + year / 4 - 29872L + 1
             - year / 100 + (year - 300) / 400;

    return ((<A href="sfldoc.htm#julian_date">julian date</A> (date) + (int) ((day + 4) % 7)) / 7);
}
</PRE>
<A NAME="year_quarter">&nbsp;</A>
<H3><A NAME="TOC73"><TT>year_quarter</TT></A></H3>
<PRE>
#include "sfldate.h"
int
year_quarter (long date)
</PRE>
<H4>Synopsis</H4>
<P>Returns the year quarter, 1 to 4, depending on the month
   specified.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return ((GET_MONTH (date) - 1) / 3 + 1);
}
</PRE>
<A NAME="default_century">&nbsp;</A>
<H3><A NAME="TOC74"><TT>default_century</TT></A></H3>
<PRE>
#include "sfldate.h"
long
default_century (long *date)
</PRE>
<H4>Synopsis</H4>
<P>Supplies a default century for the year if necessary. If the
   year is 51 to 99, the century is set to 19. If the year is 0 to
   50, the century is set to 20. Returns the adjusted date.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    if (GET_CENTURY (*date) == 0)
        *date += (GET_YEAR (*date) &gt; 50? 19000000L: 20000000L);
    return (*date);
}
</PRE>
<A NAME="pack_date">&nbsp;</A>
<H3><A NAME="TOC75"><TT>pack_date</TT></A></H3>
<PRE>
#include "sfldate.h"
word
pack_date (long date)
</PRE>
<H4>Synopsis</H4>
<P>Packs the date into a single unsigned short word. Use this
   function to store dates when memory space is at a premium. The
   packed date can be used correctly in comparisons. Returns the
   packed date. The date must be later than 31 December 1979.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return (word) (((GET_CCYEAR (date) - 1980) &lt;&lt; 9) +
                    (GET_MONTH  (date) &lt;&lt; 5) +
                     GET_DAY    (date));
}
</PRE>
<A NAME="pack_time">&nbsp;</A>
<H3><A NAME="TOC76"><TT>pack_time</TT></A></H3>
<PRE>
#include "sfldate.h"
word
pack_time (long time)
</PRE>
<H4>Synopsis</H4>
<P>Packs the time into a single unsigned short word. Use this
   function to store times when memory space is at a premium. The
   packed time can be used correctly in comparisons. Returns the
   packed time. Seconds are stored with 2-second accuracy and
   centiseconds are lost.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return (word) ((GET_HOUR   (time) &lt;&lt; 11) +
                   (GET_MINUTE (time) &lt;&lt; 5)  +
                   (GET_SECOND (time) &gt;&gt; 1));
}
</PRE>
<A NAME="unpack_date">&nbsp;</A>
<H3><A NAME="TOC77"><TT>unpack_date</TT></A></H3>
<PRE>
#include "sfldate.h"
long
unpack_date (word packdate)
</PRE>
<H4>Synopsis</H4>
<P>Converts a packed date back into a long value.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    int year;

    year = ((word) (packdate &amp; 0xfe00) &gt;&gt; 9) + 80;
    return (MAKE_DATE (year &gt; 80? 19: 20,
                       year,
                       (word) (packdate &amp; 0x01e0) &gt;&gt; 5,
                       (word) (packdate &amp; 0x001f)));
}
</PRE>
<A NAME="unpack_time">&nbsp;</A>
<H3><A NAME="TOC78"><TT>unpack_time</TT></A></H3>
<PRE>
#include "sfldate.h"
long
unpack_time (word packtime)
</PRE>
<H4>Synopsis</H4>
<P>Converts a packed time back into a long value.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return (MAKE_TIME ((word) (packtime &amp; 0xf800) &gt;&gt; 11,
                       (word) (packtime &amp; 0x07e0) &gt;&gt; 5,
                       (word) (packtime &amp; 0x001f) &lt;&lt; 1, 0));
}
</PRE>
<A NAME="date_to_days">&nbsp;</A>
<H3><A NAME="TOC79"><TT>date_to_days</TT></A></H3>
<PRE>
#include "sfldate.h"
long
date_to_days (long date)
</PRE>
<H4>Synopsis</H4>
<P>Converts the date into a number of days since a distant but
   unspecified epoch. You can use this function to calculate
   differences between dates, and forward dates. Use
   <A href="sfldoc.htm#days_to_date">days to date</A>() to calculate the reverse function. Author:
   Robert G. Tantzen, translated from the Algol original in
   Collected Algorithms of the CACM (algorithm 199). Original
   translation into C by Nat Howard, posted to Usenet 5 Jul 1985.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    long
        year    = GET_YEAR    (date),
        century = GET_CENTURY (date),
        month   = GET_MONTH   (date),
        day     = GET_DAY     (date);

    if (month &gt; 2)
        month -= 3;
    else
      {
        month += 9;
        if (year)
            year--;
        else
          {
            year = 99;
            century--;
          }
      }
    return ((146097L * century)    / 4L +
            (1461L   * year)       / 4L +
            (153L    * month + 2L) / 5L +
                       day   + 1721119L);
}
</PRE>
<A NAME="days_to_date">&nbsp;</A>
<H3><A NAME="TOC80"><TT>days_to_date</TT></A></H3>
<PRE>
#include "sfldate.h"
long
days_to_date (long days)
</PRE>
<H4>Synopsis</H4>
<P>Converts a number of days since some distant but unspecified
   epoch into a date. You can use this function to calculate
   differences between dates, and forward dates. Use
   <A href="sfldoc.htm#date_to_days">date to days</A>() to calculate the reverse function. Author:
   Robert G. Tantzen, translated from the Algol original in
   Collected Algorithms of the CACM (algorithm 199). Original
   translation into C by Nat Howard, posted to Usenet 5 Jul 1985.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    long
        century,
        year,
        month,
        day;

    days   -= 1721119L;
    century = (4L * days - 1L) / 146097L;
    days    =  4L * days - 1L  - 146097L * century;
    day     =  days / 4L;

    year    = (4L * day + 3L) / 1461L;
    day     =  4L * day + 3L  - 1461L * year;
    day     = (day + 4L) / 4L;

    month   = (5L * day - 3L) / 153L;
    day     =  5L * day - 3   - 153L * month;
    day     = (day + 5L) / 5L;

    if (month &lt; 10)
        month += 3;
    else
      {
        month -= 9;
        if (year++ == 99)
          {
            year = 0;
            century++;
          }
      }
    return (MAKE_DATE (century, year, month, day));
}
</PRE>
<A NAME="date_to_timer">&nbsp;</A>
<H3><A NAME="TOC81"><TT>date_to_timer</TT></A></H3>
<PRE>
#include "sfldate.h"
time_t
date_to_timer (long date, long time)
</PRE>
<H4>Synopsis</H4>
<P>Converts the supplied date and time into a time_t timer value.
   This is the number of non-leap seconds since 00:00:00 GMT Jan
   1, 1970. Function was rewritten by Bruce Walter <A
   HREF=mailto:"walter@fortean.com">walter@fortean.com</A>. If the
   input date and time are invalid, returns 0.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    struct tm
        time_struct;
    time_t
        timer;

    time_struct.tm_sec   = GET_SECOND (time);
    time_struct.tm_min   = GET_MINUTE (time);
    time_struct.tm_hour  = GET_HOUR   (time);
    time_struct.tm_mday  = GET_DAY    (date);
    time_struct.tm_mon   = GET_MONTH  (date) - 1;
    time_struct.tm_year  = GET_CCYEAR (date) - 1900;
    time_struct.tm_isdst = -1;
    timer = mktime (&amp;time_struct);
    if (timer == -1)
        return (0);
    else
        return (timer);
}
</PRE>
<A NAME="timer_to_date">&nbsp;</A>
<H3><A NAME="TOC82"><TT>timer_to_date</TT></A></H3>
<PRE>
#include "sfldate.h"
long
timer_to_date (time_t time_secs)
</PRE>
<H4>Synopsis</H4>
<P>Converts the supplied timer value into a long date value. Dates
   are stored as long values: CCYYMMDD. If the supplied value is
   zero, returns zero. The timer value is assumed to be UTC (GMT).
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    struct tm
        *time_struct;

    if (time_secs == 0)
        return (0);
    else
      {
        /*  Convert into a long value CCYYMMDD                               */
        time_struct = <A href="sfldoc.htm#safe_localtime">safe localtime</A> (&amp;time_secs);
        time_struct-&gt; tm_year += 1900;
        return (MAKE_DATE (time_struct-&gt; tm_year / 100,
                           time_struct-&gt; tm_year % 100,
                           time_struct-&gt; tm_mon + 1,
                           time_struct-&gt; tm_mday));
      }
}
</PRE>
<A NAME="timer_to_time">&nbsp;</A>
<H3><A NAME="TOC83"><TT>timer_to_time</TT></A></H3>
<PRE>
#include "sfldate.h"
long
timer_to_time (time_t time_secs)
</PRE>
<H4>Synopsis</H4>
<P>Converts the supplied timer value into a long time value. Times
   are stored as long values: HHMMSS00. Since the timer value does
   not hold centiseconds, these are set to zero. If the supplied
   value was zero, returns zero. The timer value is assumed to be
   UTC (GMT).
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    struct tm
        *time_struct;

    if (time_secs == 0)
        return (0);
    else
      {
        /*  Convert into a long value HHMMSS00                               */
        time_struct = <A href="sfldoc.htm#safe_localtime">safe localtime</A> (&amp;time_secs);
        return (MAKE_TIME (time_struct-&gt; tm_hour,
                           time_struct-&gt; tm_min,
                           time_struct-&gt; tm_sec,
                           0));
      }
}
</PRE>
<A NAME="timer_to_gmdate">&nbsp;</A>
<H3><A NAME="TOC84"><TT>timer_to_gmdate</TT></A></H3>
<PRE>
#include "sfldate.h"
long
timer_to_gmdate (time_t time_secs)
</PRE>
<H4>Synopsis</H4>
<P>Converts the supplied timer value into a long date value in
   Greenwich Mean Time (GMT). Dates are stored as long values:
   CCYYMMDD. If the supplied value is zero, returns zero.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    struct tm
        *time_struct;

    if (time_secs == 0)
        return (0);
    else
      {
        /*  Convert into a long value CCYYMMDD                               */
        time_struct = <A href="sfldoc.htm#safe_gmtime">safe gmtime</A> (&amp;time_secs);
        if (time_struct == NULL)        /*  If gmtime is not implemented     */
            time_struct = <A href="sfldoc.htm#safe_localtime">safe localtime</A> (&amp;time_secs);

        time_struct-&gt; tm_year += 1900;
        return (MAKE_DATE (time_struct-&gt; tm_year / 100,
                           time_struct-&gt; tm_year % 100,
                           time_struct-&gt; tm_mon + 1,
                           time_struct-&gt; tm_mday));
      }
}
</PRE>
<A NAME="timer_to_gmtime">&nbsp;</A>
<H3><A NAME="TOC85"><TT>timer_to_gmtime</TT></A></H3>
<PRE>
#include "sfldate.h"
long
timer_to_gmtime (time_t time_secs)
</PRE>
<H4>Synopsis</H4>
<P>Converts the supplied timer value into a long time value in
   Greenwich Mean Time (GMT). Times are stored as long values:
   HHMMSS00. On most systems the clock does not return
   centiseconds, so these are set to zero. If the supplied value
   is zero, returns zero.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    struct tm
        *time_struct;

    if (time_secs == 0)
        return (0);
    else
      {
        /*  Convert into a long value HHMMSS00                               */
        time_struct = <A href="sfldoc.htm#safe_gmtime">safe gmtime</A> (&amp;time_secs);
        if (time_struct == NULL)        /*  If gmtime is not implemented     */
            time_struct = <A href="sfldoc.htm#safe_localtime">safe localtime</A> (&amp;time_secs);

        return (MAKE_TIME (time_struct-&gt; tm_hour,
                           time_struct-&gt; tm_min,
                           time_struct-&gt; tm_sec,
                           0));
      }
}
</PRE>
<A NAME="time_to_csecs">&nbsp;</A>
<H3><A NAME="TOC86"><TT>time_to_csecs</TT></A></H3>
<PRE>
#include "sfldate.h"
long
time_to_csecs (long time)
</PRE>
<H4>Synopsis</H4>
<P>Converts a time (HHMMSSCC) into a number of centiseconds.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return ((long) (GET_HOUR   (time) * (long) INTERVAL_HOUR)
          + (long) (GET_MINUTE (time) * (long) INTERVAL_MIN)
          + (long) (GET_SECOND (time) * (long) INTERVAL_SEC)
          + (long) (GET_CENTI  (time)));
}
</PRE>
<A NAME="csecs_to_time">&nbsp;</A>
<H3><A NAME="TOC87"><TT>csecs_to_time</TT></A></H3>
<PRE>
#include "sfldate.h"
long
csecs_to_time (long csecs)
</PRE>
<H4>Synopsis</H4>
<P>Converts a number of centiseconds (&lt; INTERVAL_DAY) into a
   time value (HHMMSSCC).
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    long
        hour,
        min,
        sec;

    ASSERT (csecs &lt; INTERVAL_DAY);

    hour  = csecs / INTERVAL_HOUR;
    csecs = csecs % INTERVAL_HOUR;
    min   = csecs / INTERVAL_MIN;
    csecs = csecs % INTERVAL_MIN;
    sec   = csecs / INTERVAL_SEC;
    csecs = csecs % INTERVAL_SEC;
    return (MAKE_TIME (hour, min, sec, csecs));
}
</PRE>
<A NAME="future_date">&nbsp;</A>
<H3><A NAME="TOC88"><TT>future_date</TT></A></H3>
<PRE>
#include "sfldate.h"
void
future_date (long *date, long *time, long days, long csecs)
</PRE>
<H4>Synopsis</H4>
<P>Calculates a future date and time from the date and time
   specified, plus an interval specified in days and 1/100th
   seconds. The date can be any date since some distant epoch
   (around 1600). If the date and time arguments are both zero,
   the current date and time are used. Either date and time
   arguments may be null.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    long
        dummy_date = 0,
        dummy_time = 0;

    if (date == NULL)
        date = &amp;dummy_date;
    if (time == NULL)
        time = &amp;dummy_time;

    /*  Set date and time to NOW if necessary                                */
    if (*date == 0 &amp;&amp; *time == 0)
      {
        *date = <A href="sfldoc.htm#date_now">date now</A> ();
        *time = <A href="sfldoc.htm#time_now">time now</A> ();
      }

    /*  Get future date in days and centiseconds                             */
    days  = <A href="sfldoc.htm#date_to_days">date to days</A>  (*date) + days;
    csecs = <A href="sfldoc.htm#time_to_csecs">time to csecs</A> (*time) + csecs;

    /*  Normalise overflow in centiseconds                                   */
    while (csecs &gt;= INTERVAL_DAY)
      {
        days++;
        csecs -= INTERVAL_DAY;
      }

    /*  Convert date and time back into organised values                     */
    *date = <A href="sfldoc.htm#days_to_date">days to date</A>  (days);
    *time = <A href="sfldoc.htm#csecs_to_time">csecs to time</A> (csecs);
}
</PRE>
<A NAME="past_date">&nbsp;</A>
<H3><A NAME="TOC89"><TT>past_date</TT></A></H3>
<PRE>
#include "sfldate.h"
void
past_date (long *date, long *time, long days, long csecs)
</PRE>
<H4>Synopsis</H4>
<P>Calculates a past date and time from the date and time
   specified, minus an interval specified in days and 1/100th
   seconds. The date can be any date since some distant epoch
   (around 1600). If the date and time arguments are both zero,
   the current date and time are used. Either date and time
   arguments may be null.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    long
        dummy_date = 0,
        dummy_time = 0;

    if (date == NULL)
        date = &amp;dummy_date;
    if (time == NULL)
        time = &amp;dummy_time;

    /*  Set date and time to NOW if necessary                                */
    if (*date == 0 &amp;&amp; *time == 0)
      {
        *date = <A href="sfldoc.htm#date_now">date now</A> ();
        *time = <A href="sfldoc.htm#time_now">time now</A> ();
      }
    /*  Get past date in days and centiseconds                               */
    days  = <A href="sfldoc.htm#date_to_days">date to days</A>  (*date) - days;
    csecs = <A href="sfldoc.htm#time_to_csecs">time to csecs</A> (*time) - csecs;

    /*  Normalise underflow in centiseconds                                  */
    while (csecs &lt; 0)
      {
        days--;
        csecs += INTERVAL_DAY;
      }

    /*  Convert date and time back into organised values                     */
    *date = <A href="sfldoc.htm#days_to_date">days to date</A>  (days);
    *time = <A href="sfldoc.htm#csecs_to_time">csecs to time</A> (csecs);
}
</PRE>
<A NAME="date_diff">&nbsp;</A>
<H3><A NAME="TOC90"><TT>date_diff</TT></A></H3>
<PRE>
#include "sfldate.h"
void
date_diff (
    long date1, long time1,             /*  Date and time                    */
    long date2, long time2,             /*    minus this date and time       */
    long *days, long *csecs             /*  Gives these values               */
)
</PRE>
<H4>Synopsis</H4>
<P>Calculates the difference between two date/time values, and
   returns the difference as a number of days and a number of
   centiseconds. The date can be any date since some distant epoch
   (around 1600). The calculation is date1:time1 - date2:time2.
   The returned values may be negative.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    *days  = <A href="sfldoc.htm#date_to_days">date to days</A>  (date1) - <A href="sfldoc.htm#date_to_days">date to days</A>  (date2);
    *csecs = <A href="sfldoc.htm#time_to_csecs">time to csecs</A> (time1) - <A href="sfldoc.htm#time_to_csecs">time to csecs</A> (time2);
}
</PRE>
<A NAME="valid_date">&nbsp;</A>
<H3><A NAME="TOC91"><TT>valid_date</TT></A></H3>
<PRE>
#include "sfldate.h"
Bool
valid_date (long date)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the date is valid or zero; returns FALSE if the
   date is not valid.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    int
        month,
        day;
    Bool
        feedback;
    static byte
        month_days [] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

    month = GET_MONTH (date);
    day   = GET_DAY   (date);

    if (date == 0)
        feedback = TRUE;                /*  Zero date is okay                */
    else
    if (month &lt; 1 || month &gt; 12)
        feedback = FALSE;               /*  Month out of range               */
    else
    if ((day &lt; 1 || day &gt; month_days [month - 1])
    ||  (month == 2 &amp;&amp; day == 29 &amp;&amp; !<A href="sfldoc.htm#leap_year">leap year</A> (GET_YEAR (date))))
        feedback = FALSE;               /*  Day out of range                 */
    else
        feedback = TRUE;                /*  Zero date is okay                */

    return (feedback);
}
</PRE>
<A NAME="valid_time">&nbsp;</A>
<H3><A NAME="TOC92"><TT>valid_time</TT></A></H3>
<PRE>
#include "sfldate.h"
Bool
valid_time (long time)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the time is valid or zero; returns FALSE if the
   time is not valid.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return (GET_SECOND (time) &lt; 60
        &amp;&amp;  GET_MINUTE (time) &lt; 60
        &amp;&amp;  GET_HOUR   (time) &lt; 24);
}
</PRE>
<A NAME="date_is_future">&nbsp;</A>
<H3><A NAME="TOC93"><TT>date_is_future</TT></A></H3>
<PRE>
#include "sfldate.h"
Bool
date_is_future (long date, long time)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the specified date and time are in the future.
   Returns FALSE if the date and time are in the past, or the
   present (which will be the past by the time you've read this).
   Date is specified as a YYYYMMDD value; time as HHMMSSCC.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return (date  &gt; <A href="sfldoc.htm#date_now">date now</A> ()
        || (date == <A href="sfldoc.htm#date_now">date now</A> () &amp;&amp; time &gt; <A href="sfldoc.htm#time_now">time now</A> ()));
}
</PRE>
<A NAME="date_is_past">&nbsp;</A>
<H3><A NAME="TOC94"><TT>date_is_past</TT></A></H3>
<PRE>
#include "sfldate.h"
Bool
date_is_past (long date, long time)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the specified date and time are in the past.
   Returns FALSE if the date and time are in the future or present
   (which despite any assertion to the contrary, is not the past.
   Although that may change soon). Date is specified as YYYYMMDD;
   time as HHMMSSCC.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return (date  &lt; <A href="sfldoc.htm#date_now">date now</A> ()
        || (date == <A href="sfldoc.htm#date_now">date now</A> () &amp;&amp; time &lt; <A href="sfldoc.htm#time_now">time now</A> ()));
}
</PRE>
<A NAME="timezone_string">&nbsp;</A>
<H3><A NAME="TOC95"><TT>timezone_string</TT></A></H3>
<PRE>
#include "sfldate.h"
char *
timezone_string (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns a static string containing the time zone as a 4-digit
   number, with a leading '+' or '-' character. GMT is represented
   as "+0000"; Central European Time is "+1000". If the system
   does not support the timezone, returns "+0000".
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
#if (defined (TIMEZONE))
    static char
        formatted_string [10];          /*  -nnnn plus null                  */
    int
        minutes;                        /*  TIMEZONE is in seconds           */

    minutes = 0 - (int) (TIMEZONE / 60);
    snprintf (formatted_string, sizeof (formatted_string),
              "%03d%02d", minutes / 60, abs (minutes % 60));
    if (*formatted_string == '0')
        *formatted_string = '+';
    return  (formatted_string);
#else
    return ("+0000");
#endif
}
</PRE>
<A NAME="local_to_gmt">&nbsp;</A>
<H3><A NAME="TOC96"><TT>local_to_gmt</TT></A></H3>
<PRE>
#include "sfldate.h"
void
local_to_gmt (long date, long time, long *gmt_date, long *gmt_time)
</PRE>
<H4>Synopsis</H4>
<P>Converts the specified date and time to GMT. Returns the GMT
   date and time in two arguments.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    time_t
        time_value;

    time_value = <A href="sfldoc.htm#date_to_timer">date to timer</A>   (date, time);
    *gmt_date  = <A href="sfldoc.htm#timer_to_gmdate">timer to gmdate</A> (time_value);
    *gmt_time  = <A href="sfldoc.htm#timer_to_gmtime">timer to gmtime</A> (time_value);
}
</PRE>
<A NAME="gmt_to_local">&nbsp;</A>
<H3><A NAME="TOC97"><TT>gmt_to_local</TT></A></H3>
<PRE>
#include "sfldate.h"
void
gmt_to_local (long gmt_date, long gmt_time, long *date, long *time)
</PRE>
<H4>Synopsis</H4>
<P>Converts the specified GMT date and time to the local time.
   Returns the local date and time in two arguments. If the
   supplied value is out of range, returns 00:00 on 1 January,
   1970 (19700101).
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    time_t
        time_value;
    struct tm
        *time_struct;

    /*  Convert from GMT                                                     */
    time_value  = <A href="sfldoc.htm#date_to_timer">date to timer</A> (gmt_date, gmt_time) - TIMEZONE;
    time_struct = <A href="sfldoc.htm#safe_localtime">safe localtime</A> (&amp;time_value);
    if (time_struct-&gt; tm_isdst)
      {
        time_value  += 3600;            /*  Adjust for daylight savings      */
        time_struct = localtime (&amp;time_value);
      }
    time_struct-&gt; tm_year += 1900;
    *date = MAKE_DATE (time_struct-&gt; tm_year / 100,
                       time_struct-&gt; tm_year % 100,
                       time_struct-&gt; tm_mon + 1,
                       time_struct-&gt; tm_mday);
    *time = MAKE_TIME (time_struct-&gt; tm_hour,
                       time_struct-&gt; tm_min,
                       time_struct-&gt; tm_sec,
                       0);
}
</PRE>
<A NAME="safe_localtime">&nbsp;</A>
<H3><A NAME="TOC98"><TT>safe_localtime</TT></A></H3>
<PRE>
#include "sfldate.h"
struct tm
*safe_localtime (const time_t *time_secs)
</PRE>
<H4>Synopsis</H4>
<P>Handles time_t values that exceed 2038. The standard C
   localtime() function fails on most systems when the date passes
   2038.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    qbyte
        adjusted_time;
    struct tm
        *time_struct;
    int
        adjust_years = 0;

    adjusted_time = (qbyte) *time_secs;
    while (adjusted_time &gt; LONG_MAX)
      {
        adjust_years  += 20;
        adjusted_time -= 631152000;     /*  Number of seconds in 20 years    */
      }
    time_struct = localtime ((const time_t *) &amp;adjusted_time);
    ASSERT (time_struct);               /*  MUST be valid now...             */
    time_struct-&gt; tm_year += adjust_years;

    return (time_struct);
}
</PRE>
<A NAME="safe_gmtime">&nbsp;</A>
<H3><A NAME="TOC99"><TT>safe_gmtime</TT></A></H3>
<PRE>
#include "sfldate.h"
struct tm
*safe_gmtime (const time_t *time_secs)
</PRE>
<H4>Synopsis</H4>
<P>Handles time_t values that exceed 2038. The standard C gmtime()
   function fails on most systems when the date passes 2038.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    qbyte
        adjusted_time;
    struct tm
        *time_struct;
    int
        adjust_years = 0;

    adjusted_time = (qbyte) *time_secs;
    while (adjusted_time &gt; LONG_MAX)
      {
        adjust_years  += 20;
        adjusted_time -= 631152000;     /*  Nbr seconds in 20 years          */
      }
    time_struct = gmtime ((const time_t *) &amp;adjusted_time);
    if (time_struct)                    /*  gmtime may be unimplemented      */
        time_struct-&gt; tm_year += adjust_years;

    return (time_struct);
}
</PRE>
<H2><A NAME="TOC100">External data representation functions</A></H2>
<P>Filename: sflexdr.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1996/06/25 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1997/09/08
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Provides functions to read and write data in a portable format
   that is suitable for transmission to other systems. The
   principle is similar to the ONC XDR standard used in RPC, but
   somewhat simpler. The streams produced by these functions are
   not compatible with ONC XDR.
<H4>List of Functions</H4>
<UL>
<LI>int <A href="sfldoc.htm#exdr_write">exdr write</A><BR>
   (byte *buffer, const char *format, ...);
</LI>
<LI>int <A href="sfldoc.htm#exdr_writed">exdr writed</A><BR>
   (DESCR *buffer, const char *format, ...);
</LI>
<LI>int <A href="sfldoc.htm#exdr_read">exdr read</A><BR>
   (const byte *buffer, const char *format, ...);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflexdr.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>SFLEXDR_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="exdr_write">&nbsp;</A>
<H3><A NAME="TOC101"><TT>exdr_write</TT></A></H3>
<PRE>
#include "sflexdr.h"
int
exdr_write (byte *buffer, const char *format, ...)
</PRE>
<H4>Synopsis</H4>
<P>Accepts a list of data items, prepares them according to the
   format string, and stores the result in the buffer. The buffer
   may be transmitted to another system, then decoded using
   exdr_read. Assumes nothing about system word sizes, etc.
   However, does assume that both systems use ASCII. If the buffer
   address is NULL, does not store the data items, but counts the
   effective size and returns that. The null-terminated format
   string can contain these sequences: <TABLE BORDER NOWRAP>
   <TR><TD ALIGN="LEFT"><B>c</B>  <TD ALIGN="LEFT">Single
   character value (may be multibyte) <TR><TD
   ALIGN="LEFT"><B>b</B>  <TD ALIGN="LEFT">Single byte value
   <TR><TD ALIGN="LEFT"><B>w,d</B>  <TD ALIGN="LEFT">Double byte
   value (16-bit short integer) <TR><TD ALIGN="LEFT"><B>q,l</B>
   <TD ALIGN="LEFT">Quad-byte value (32-bit long integer) <TR><TD
   ALIGN="LEFT"><B>s</B>  <TD ALIGN="LEFT">Null-terminated string
   (address of string), or NULL <TR><TD ALIGN="LEFT"><B>B</B>  <TD
   ALIGN="LEFT">Bool value (16-bit short integer) <TR><TD
   ALIGN="LEFT"><B>m</B>  <TD ALIGN="LEFT">Memory descriptor size
   (16-bit integer), &gt;= 0 <TR><TD ALIGN="LEFT"><B>M</B>  <TD
   ALIGN="LEFT">Memory descriptor body (pointer to block), or NULL
   <TR><TD ALIGN="LEFT"><B>h</B>  <TD ALIGN="LEFT">Huge memory
   descriptor size (31-bit integer), &gt;= 0 <TR><TD
   ALIGN="LEFT"><B>H</B>  <TD ALIGN="LEFT">Huge memory descriptor
   body (pointer), or NULL </TABLE> Each format sequence
   corresponds to one item in the list. The buffer must be large
   enough to hold the formatted result. Returns the size of the
   formatted data. Ignores invalid format characters; you can
   insert hyphens or spaces freely. Strings may be specified as
   (void *) NULL - they are stored as empty strings. Memory blocks
   may be specified as 0 and (void *) NULL together. Note that if
   you do not use the (void *) typecast when calling
   <A href="sfldoc.htm#exdr_write">exdr write</A>(), your code will fail on systems where an int
   is not the same size as a void *. Huge memory blocks cannot be
   more than 2^31 bytes large (2Gb) or 2^16 bytes if size_t is 16
   bits large.
<H4>Source Code - (sflexdr.c)</H4>
<PRE>
{
    va_list
        argptr;                         /*  Argument list pointer            */
    byte
        byte_value,                     /*  Byte value from arguments        */
        *target,                        /*  Pointer into target buffer       */
        *block;                         /*  Source block for 'M' type        */
    char
        *string;                        /*  Source string for 's' type       */
    dbyte
        dbyte_value;                    /*  Network format dbyte value       */
    qbyte
        memory_size = 0,                /*  Memory descriptor size value     */
        qbyte_value;                    /*  Network format qbyte value       */

    ASSERT (format);
    va_start (argptr, format);          /*  Start variable arguments list    */
    target = buffer;

    while (*format)
      {
        switch (*format++)
          {
            case 'c':                   /*  Character                        */
            case 'b':                   /*  Single byte                      */
                byte_value = (byte) va_arg (argptr, int);
                if (buffer)
                    *(byte *) target = byte_value;
                target += 1;
                break;

            case 'd':                   /*  Signed short integer             */
            case 'w':                   /*  Unsigned short integer           */
            case 'B':                   /*  Bool                             */
                dbyte_value = htons ((short) va_arg (argptr, int));
                if (buffer)
                  {
                    *(byte *) target++ = *((byte *) &amp;dbyte_value);
                    *(byte *) target++ = *((byte *) &amp;dbyte_value + 1);
                  }
                else
                    target += 2;
                break;

            case 'l':                   /*  Signed long (32-bit)             */
            case 'q':                   /*  4-byte unsigned value            */
                qbyte_value = htonl (va_arg (argptr, qbyte));
                if (buffer)
                  {
                    *(byte *) target++ = *((byte *) &amp;qbyte_value);
                    *(byte *) target++ = *((byte *) &amp;qbyte_value + 1);
                    *(byte *) target++ = *((byte *) &amp;qbyte_value + 2);
                    *(byte *) target++ = *((byte *) &amp;qbyte_value + 3);
                  }
                else
                    target += 4;
                break;

            case 's':                   /*  Null-terminated string           */
                string = va_arg (argptr, char *);
                if (string)
                  {
                    if (buffer)
                        strcpy ((char *) target, string);
                    target += strlen (string) + 1;
                  }
                else                    /*  Store NULL as single null byte   */
                  {
                    if (buffer)
                        *(byte *) target++ = 0;
                    else
                        target += 1;
                  }
                break;

            case 'm':                   /*  Memory descriptor size           */
                memory_size = va_arg (argptr, int);
                dbyte_value = htons ((dbyte) memory_size);
                if (buffer)
                  {
                    *(byte *) target++ = *((byte *) &amp;dbyte_value);
                    *(byte *) target++ = *((byte *) &amp;dbyte_value + 1);
                  }
                else
                    target += 2;
                break;
            case 'M':                   /*  Memory descriptor body           */
                block = va_arg (argptr, byte *);
                if (block)
                  {
                    if (buffer)
                        memcpy (target, block, (size_t) memory_size);
                    target += (size_t) memory_size;
                  }
                else
                    ASSERT (memory_size == 0);
                break;

            case 'h':                   /*  Huge memory descriptor size       */
                memory_size = va_arg (argptr, qbyte);
                qbyte_value = htonl (memory_size);
                if (buffer)
                  {
                    *(byte *) target++ = *((byte *) &amp;qbyte_value);
                    *(byte *) target++ = *((byte *) &amp;qbyte_value + 1);
                    *(byte *) target++ = *((byte *) &amp;qbyte_value + 2);
                    *(byte *) target++ = *((byte *) &amp;qbyte_value + 3);
                  }
                else
                    target += 4;
                break;
            case 'H':                   /*  Huge memory descriptor body       */
                block = va_arg (argptr, byte *);
                if (block)
                  {
                    if (buffer)
                        memcpy (target, block, (size_t) memory_size);
                    target += (size_t) memory_size;
                  }
                else
                    ASSERT (memory_size == 0);
                break;
          }
      }
    va_end (argptr);                    /*  End variable arguments list      */
    return ((int) (target - buffer));
}
</PRE>
<A NAME="exdr_writed">&nbsp;</A>
<H3><A NAME="TOC102"><TT>exdr_writed</TT></A></H3>
<PRE>
#include "sflexdr.h"
int
exdr_writed (DESCR *buffer, const char *format, ...)
</PRE>
<H4>Synopsis</H4>
<P>As <A href="sfldoc.htm#exdr_write">exdr write</A>(), but accepts a DESCR buffer. This is more
   secure. Aborts with an error if the formatted data would be too
   long for the buffer, if compiled with DEBUG. The buffer address
   cannot be NULL.
<H4>Source Code - (sflexdr.c)</H4>
<PRE>
{
    va_list
        argptr;                         /*  Argument list pointer            */
    byte
        *target,                        /*  Pointer into target buffer       */
        *block;                         /*  Source block for 'M' type        */
    char
        *string;                        /*  Source string for 's' type       */
    dbyte
        dbyte_value;                    /*  Network format dbyte value       */
    qbyte
        memory_size = 0,                /*  Memory descriptor size value     */
        qbyte_value;                    /*  Network format qbyte value       */
    size_t
        used_size;                      /*  Current buffer data size         */

    ASSERT (buffer);
    ASSERT (format);
    va_start (argptr, format);          /*  Start variable arguments list    */
    target = buffer-&gt; data;

    while (*format)
      {
        used_size = (size_t) (target - buffer-&gt; data);
        switch (*format++)
          {
            case 'c':                   /*  Character                        */
            case 'b':                   /*  Single byte                      */
                *(byte *) target = (byte) va_arg (argptr, int);
                ASSERT (used_size + 1 &lt;= buffer-&gt; size);
                target += 1;
                break;

            case 'd':                   /*  Signed short integer             */
            case 'w':                   /*  Unsigned short integer           */
            case 'B':                   /*  Bool                             */
                dbyte_value = htons ((short) va_arg (argptr, int));
                ASSERT (used_size + 2 &lt;= buffer-&gt; size);
                *(byte *) target++ = *((byte *) &amp;dbyte_value);
                *(byte *) target++ = *((byte *) &amp;dbyte_value + 1);
                break;

            case 'l':                   /*  Signed long (32-bit)             */
            case 'q':                   /*  4-byte unsigned value            */
                qbyte_value = htonl (va_arg (argptr, qbyte));
                ASSERT (used_size + 4 &lt;= buffer-&gt; size);
                *(byte *) target++ = *((byte *) &amp;qbyte_value);
                *(byte *) target++ = *((byte *) &amp;qbyte_value + 1);
                *(byte *) target++ = *((byte *) &amp;qbyte_value + 2);
                *(byte *) target++ = *((byte *) &amp;qbyte_value + 3);
                break;

            case 's':                   /*  Null-terminated string           */
                string = va_arg (argptr, char *);
                if (string)
                  {
                    ASSERT (used_size + strlen (string) + 1 &lt;= buffer-&gt; size);
                    strcpy ((char *) target, string);
                    target += strlen (string) + 1;
                  }
                else                    /*  Store NULL as single null byte   */
                  {
                    ASSERT (used_size + 1 &lt;= buffer-&gt; size);
                    *(byte *) target++ = 0;
                  }
                break;

            case 'm':                   /*  Memory descriptor size           */
                memory_size = va_arg (argptr, int);
                ASSERT (used_size + 2 + memory_size &lt;= buffer-&gt; size);
                dbyte_value = htons ((dbyte) memory_size);
                *(byte *) target++ = *((byte *) &amp;dbyte_value);
                *(byte *) target++ = *((byte *) &amp;dbyte_value + 1);
                break;
            case 'M':                   /*  Memory descriptor body           */
                block = va_arg (argptr, byte *);
                if (block)
                  {
                    memcpy (target, block, (size_t) memory_size);
                    target += (size_t) memory_size;
                  }
                else
                    ASSERT (memory_size == 0);
                break;

            case 'h':                   /*  Huge memory descriptor size      */
                memory_size = va_arg (argptr, qbyte);
                ASSERT (used_size + 4 + memory_size &lt;= buffer-&gt; size);
                qbyte_value = htonl (memory_size);
                *(byte *) target++ = *((byte *) &amp;qbyte_value);
                *(byte *) target++ = *((byte *) &amp;qbyte_value + 1);
                *(byte *) target++ = *((byte *) &amp;qbyte_value + 2);
                *(byte *) target++ = *((byte *) &amp;qbyte_value + 3);
                break;
            case 'H':                   /*  Huge memory descriptor body      */
                block = va_arg (argptr, byte *);
                if (block)
                  {
                    memcpy (target, block, (size_t) memory_size);
                    target += (size_t) memory_size;
                  }
                else
                    ASSERT (memory_size == 0);
                break;
          }
      }
    va_end (argptr);                    /*  End variable arguments list      */
    return ((int) (target - buffer-&gt; data));
}
</PRE>
<A NAME="exdr_read">&nbsp;</A>
<H3><A NAME="TOC103"><TT>exdr_read</TT></A></H3>
<PRE>
#include "sflexdr.h"
int
exdr_read (const byte *buffer, const char *format, ...)
</PRE>
<H4>Synopsis</H4>
<P>Unpacks a buffer prepared by <A href="sfldoc.htm#exdr_write">exdr write</A>() into as set of
   data items as specified by a format string. See
   <A href="sfldoc.htm#exdr_write">exdr write</A>() for the syntax of the format string. Each
   format sequence corresponds to one item in in the list which
   must be specified as an address. Target strings and memory
   blocks must be large enough to hold the returned data: target
   strings and blocks can also be null, in which case the function
   calls mem_alloc to allocate heap memory. Note that you must
   supply a pointer to the string or memory block address, not the
   address itself. It is a common error to pass the address of a
   static block - see the example below for the *right* way to do
   it. Any of the argument addresses can be NULL, in which case
   that field is ignored. This is useful to get a few selected
   fields out of a message. Errors in the argument list can cause
   memory corruption and unpredictable program results. If a
   memory allocation fails, all previous memory allocations are
   "rolled back" and the function returns the value -1. Return
   codes: 0 - normal -1 - memory allocation failed
<H4>Examples</H4>
<PRE>
    char *string = NULL;
    byte buffer [1000];
    byte *buffaddr = buffer;
    int value, length;
    exdr_read (buffer, "qdsmM", NULL, &value, &string, &length, &buffaddr);
</PRE>
<H4>Source Code - (sflexdr.c)</H4>
<PRE>
{
    MEMTRN
        *memtrn;                        /*  Memory transaction               */
    va_list
        argptr;                         /*  Argument list pointer            */
    void
        *target;                        /*  Source data item address         */
    dbyte
        string_size,                    /*  String size                      */
        dbyte_value;                    /*  Network format dbyte value       */
    qbyte
        memory_size = 0,                /*  Memory descriptor size value     */
        qbyte_value;                    /*  Network format qbyte value       */

    ASSERT (buffer);
    ASSERT (format);
    memtrn = <A href="sfldoc.htm#mem_new_trans">mem new trans</A> ();

    va_start (argptr, format);          /*  Start variable arguments list    */
    while (*format)
      {
        target = va_arg (argptr, void *);
        switch (*format++)
          {
            case 'c':                   /*  Character                        */
            case 'b':                   /*  Single byte                      */
                if (target)
                    *(byte *) target = *(byte *) buffer;
                buffer += 1;
                break;

            case 'd':                   /*  Signed short integer             */
            case 'w':                   /*  Unsigned short integer           */
            case 'B':                   /*  Bool                             */
                *((byte *) &amp;dbyte_value)     = *(byte *) buffer++;
                *((byte *) &amp;dbyte_value + 1) = *(byte *) buffer++;
                if (target)
                    *(dbyte *) target = ntohs (dbyte_value);
                break;

            case 'l':                   /*  Signed long (32-bit)             */
            case 'q':                   /*  4-byte unsigned value            */
                *((byte *) &amp;qbyte_value)     = *(byte *) buffer++;
                *((byte *) &amp;qbyte_value + 1) = *(byte *) buffer++;
                *((byte *) &amp;qbyte_value + 2) = *(byte *) buffer++;
                *((byte *) &amp;qbyte_value + 3) = *(byte *) buffer++;
                if (target)
                    *(qbyte *) target = ntohl (qbyte_value);
                break;

            case 's':                   /*  Null-terminated string           */
                string_size = strlen ((char *) buffer) + 1;
                if (target)
                  {
                    if (*(byte **) target == NULL)
                        *(byte **) target = mem_alloc (string_size);
                    if (*(byte **) target)
                        memcpy (*(byte **) target, buffer, string_size);
                    else
                      {
                        <A href="sfldoc.htm#mem_rollback">mem rollback</A> (memtrn);
                        return (-1);
                      }
                  }
                buffer += string_size;
                break;

            case 'm':                   /*  Memory descriptor size           */
                *((byte *) &amp;dbyte_value)     = *(byte *) buffer++;
                *((byte *) &amp;dbyte_value + 1) = *(byte *) buffer++;
                memory_size = ntohs (dbyte_value);
                if (target)
                    *(dbyte *) target = (dbyte) memory_size;
                break;
            case 'M':                   /*  Memory descriptor body           */
                if (target &amp;&amp; memory_size &gt; 0)
                  {
                    if (*(byte **) target == NULL)
                        *(byte **) target = mem_alloc ((size_t) memory_size);
                    if (*(byte **) target)
                        memcpy (*(byte **) target, buffer,
                                 (size_t) memory_size);
                    else
                      {
                        <A href="sfldoc.htm#mem_rollback">mem rollback</A> (memtrn);
                        return (-1);
                      }
                  }
                buffer += (size_t) memory_size;
                break;

            case 'h':                   /*  Huge memory descriptor size      */
                *((byte *) &amp;qbyte_value)     = *(byte *) buffer++;
                *((byte *) &amp;qbyte_value + 1) = *(byte *) buffer++;
                *((byte *) &amp;qbyte_value + 2) = *(byte *) buffer++;
                *((byte *) &amp;qbyte_value + 3) = *(byte *) buffer++;
                memory_size = ntohl (qbyte_value);
                if (target)
                    *(qbyte *) target = memory_size;
                break;
            case 'H':                   /*  Huge memory descriptor body      */
                if (target &amp;&amp; memory_size &gt; 0)
                  {
                    if (*(byte **) target == NULL)
                        *(byte **) target = mem_alloc ((size_t) memory_size);
                    if (*(byte **) target)
                        memcpy (*(byte **) target, buffer,
                                 (size_t) memory_size);
                    else
                      {
                        <A href="sfldoc.htm#mem_rollback">mem rollback</A> (memtrn);
                        return (-1);
                      }
                  }
                buffer += (size_t) memory_size;
                break;
          }
      }
    va_end (argptr);                    /*  End variable arguments list      */
    <A href="sfldoc.htm#mem_commit">mem commit</A> (memtrn);
    return (0);
}
</PRE>
<H2><A NAME="TOC104">Fast string searching functions</A></H2>
<P>Filename: sflfind.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1996/04/24 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1998/05/03
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Searches for a pattern within a string or block of memory using
   a variant of the Boyer-Moore algorithm (improved by Horspool
   and Sunday). As fast or faster than the normal Boyer-Moore
   algorithm for most search strings, and much simpler. Includes a
   basic function for searching blocks of memory with known sizes,
   plus an envelope that searches null-delimited strings. Provides
   the option of repeatedly searching for the same pattern without
   re-parsing the pattern each time. Original algorithm published
   by BOYER, R., and S. MOORE 1977, "A Fast String Searching
   Algorithm." CACM, 20, 762-72. Simplifications by HORSPOOL, R.
   N. 1980, "Practical Fast Searching in Strings." Software -
   Practice and Experience, 10, 501-06. More improvements by HUME,
   A., and D. M. SUNDAY 1991, "Fast String Searching." AT&amp;T
   Bell Labs Computing Science Technical Report No. 156.
   Implemented in C by P. Hintjens. <A href="sfldoc.htm#strfind_r">strfind r</A>() and
   <A href="sfldoc.htm#memfind_r">memfind r</A>(), are reentrant versions of <A href="sfldoc.htm#strfind">strfind</A>() and
   <A href="sfldoc.htm#memfind">memfind</A>() for single searches, and <A href="sfldoc.htm#strfind_rb">strfind rb</A>() and
   <A href="sfldoc.htm#memfind_rb">memfind rb</A>() are reentrant versions of <A href="sfldoc.htm#strfind">strfind</A>() and
   <A href="sfldoc.htm#memfind">memfind</A>() supporting repeat searches against the same
   pattern.
<H4>List of Functions</H4>
<UL>
<LI>char * <A href="sfldoc.htm#strfind">strfind</A><BR>
   (const char *string, const char *pattern, Bool repeat_find);
</LI>
<LI>char * <A href="sfldoc.htm#strfind_r">strfind r</A><BR>
   (const char *string, const char *pattern);
</LI>
<LI>char * <A href="sfldoc.htm#strfind_rb">strfind rb</A><BR>
   (const char *string, const char *pattern, size_t *shift, Bool
   *repeat_find);
</LI>
<LI>void * <A href="sfldoc.htm#memfind">memfind</A><BR>
   (const void *block, size_t block_size, const void *pattern,
   size_t pattern_size, Bool repeat_find);
</LI>
<LI>void * <A href="sfldoc.htm#memfind_r">memfind r</A><BR>
   (const void *block, size_t block_size, const void *pattern,
   size_t pattern_size);
</LI>
<LI>void * <A href="sfldoc.htm#memfind_rb">memfind rb</A><BR>
   (const void *block, size_t block_size, const void *pattern,
   size_t pattern_size, size_t *shift, Bool *repeat_find);
</LI>
<LI>char * <A href="sfldoc.htm#txtfind">txtfind</A><BR>
   (const char *string, const char *pattern);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflfind.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>SFLFIND_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="strfind">&nbsp;</A>
<H3><A NAME="TOC105"><TT>strfind</TT></A></H3>
<PRE>
#include "sflfind.h"
char *
strfind (const char *string,            /*  String containing data           */
         const char *pattern,           /*  Pattern to search for            */
         Bool repeat_find)              /*  Same pattern as last time        */
</PRE>
<H4>Synopsis</H4>
<P>Searches for a pattern in a string using the Boyer-Moore-
   Horspool-Sunday algorithm. The string and pattern are null-
   terminated strings. Returns a pointer to the pattern if found
   within the string, or NULL if the pattern was not found. If you
   repeatedly scan for the same pattern, use the repeat_find
   argument. If this is TRUE, the function does not re-parse the
   pattern. You must of course call the function with repeat_find
   equal to FALSE the first time. This function is meant to handle
   character data, and is most effective when you work with large
   strings. To search binary data use <A href="sfldoc.htm#memfind">memfind</A>(). Will not work
   on multibyte characters.
<H4>Examples</H4>
<PRE>
    char *result;

    result = strfind ("abracadabra", "cad", FALSE);
    if (result)
        puts (result);
</PRE>
<H4>Source Code - (sflfind.c)</H4>
<PRE>
{
    static size_t
        searchbuf [256];                /*  Fixed search buffer              */

    ASSERT (string);                    /*  Expect non-NULL pointers, but    */
    ASSERT (pattern);                   /*  fall through if not debugging    */

    return (char *) <A href="sfldoc.htm#memfind_rb">memfind rb</A> (string,    strlen (string),
                                pattern,   strlen (pattern),
                                searchbuf, &amp;repeat_find);
}
</PRE>
<A NAME="strfind_r">&nbsp;</A>
<H3><A NAME="TOC106"><TT>strfind_r</TT></A></H3>
<PRE>
#include "sflfind.h"
char *
strfind_r (const char *string,          /*  String containing data           */
           const char *pattern)         /*  Pattern to search for            */
</PRE>
<H4>Synopsis</H4>
<P>Searches for a pattern in a string using the Boyer-Moore-
   Horspool-Sunday algorithm. The string and pattern are null-
   terminated strings. Returns a pointer to the pattern if found
   within the string, or NULL if the pattern was not found. This
   function is meant to handle character data, and is most
   effective when you work with large strings. To search binary
   data use <A href="sfldoc.htm#memfind">memfind</A>(). Will not work on multibyte characters.
   Reentrant.
<H4>Examples</H4>
<PRE>
    char *result;

    result = strfind_r ("abracadabra", "cad");
    if (result)
        puts (result);
</PRE>
<H4>Source Code - (sflfind.c)</H4>
<PRE>
{
    size_t
        searchbuf [256];                /*  One-time search buffer           */
    Bool
        secondtime = FALSE;             /*  Search buffer init needed        */

    ASSERT (string);                    /*  Expect non-NULL pointers, but    */
    ASSERT (pattern);                   /*  fall through if not debugging    */

    return (char *) <A href="sfldoc.htm#memfind_rb">memfind rb</A> (string,    strlen (string),
                                pattern,   strlen (pattern),
                                searchbuf, &amp;secondtime);
}
</PRE>
<A NAME="strfind_rb">&nbsp;</A>
<H3><A NAME="TOC107"><TT>strfind_rb</TT></A></H3>
<PRE>
#include "sflfind.h"
char *
strfind_rb (const char *string,         /*  String containing data           */
            const char *pattern,        /*  Pattern to search for            */
            size_t     *shift,          /*  Working buffer between searches  */
            Bool       *repeat_find)    /*  Flag for first/later search      */
</PRE>
<H4>Synopsis</H4>
<P>Searches for a pattern in a string using the Boyer-Moore-
   Horspool-Sunday algorithm. The string and pattern are null-
   terminated strings. Returns a pointer to the pattern if found
   within the string, or NULL if the pattern was not found.
   Supports more efficient repeat searches (for the same pattern),
   through a supplied search buffer. The search buffer must be
   long enough to contain 256 (2**8) size_t entries. On the first
   call repeat_find must be set to FALSE. After the search buffer
   has been initialised, repeat_find will be set to TRUE by the
   function, avoiding the search buffer initialisation on later
   calls. This function is most effective when repeated searches
   are made for the same pattern in one or more strings. This
   function is meant to handle character data, and is most
   effective when you work with large strings. To search binary
   data use <A href="sfldoc.htm#memfind">memfind</A>(). Will not work on multibyte characters.
   Reentrant.
<H4>Examples</H4>
<PRE>
    char   *result;
    Bool   repeat_search = FALSE;
    size_t searchbuf[256];

    result = strfind_rb ("abracadabra", "cad", searchbuf, &repeat_search);
    if (result)
      {
        puts (result);
        result = strfind_rb ("cad/cam", "cad", searchbuf, &repeat_search);
        if (result)
            puts (result);
      }
</PRE>
<H4>Source Code - (sflfind.c)</H4>
<PRE>
{
    ASSERT (string);                    /*  Expect non-NULL pointers, but    */
    ASSERT (pattern);                   /*  fall through if not debugging    */
    ASSERT (shift);
    ASSERT (repeat_find);

    return (char *) <A href="sfldoc.htm#memfind_rb">memfind rb</A> (string,    strlen (string),
                                pattern,   strlen (pattern),
                                shift,     repeat_find);
}
</PRE>
<A NAME="memfind">&nbsp;</A>
<H3><A NAME="TOC108"><TT>memfind</TT></A></H3>
<PRE>
#include "sflfind.h"
void *
memfind (const void  *block,            /*  Block containing data            */
         size_t       block_size,       /*  Size of block in bytes           */
         const void  *pattern,          /*  Pattern to search for            */
         size_t       pattern_size,     /*  Size of pattern block            */
         Bool         repeat_find)      /*  Same pattern as last time        */
</PRE>
<H4>Synopsis</H4>
<P>Searches for a pattern in a block of memory using the Boyer-
   Moore-Horspool-Sunday algorithm. The block and pattern may
   contain any values; you must explicitly provide their lengths.
   Returns a pointer to the pattern if found within the block, or
   NULL if the pattern was not found. If you repeatedly scan for
   the same pattern, use the repeat_find argument. If this is
   TRUE, the function does not re-parse the pattern. This function
   is meant to handle binary data. If you need to search strings,
   use the strfind_r or <A href="sfldoc.htm#strfind_rb">strfind rb</A>() functions. Non-Reentrant.
<H4>Source Code - (sflfind.c)</H4>
<PRE>
{
    static size_t
        searchbuf [256];                /*  Static shared search buffer      */

    ASSERT (block);                     /*  Expect non-NULL pointers, but    */
    ASSERT (pattern);                   /*  full through if not debugging    */

    return <A href="sfldoc.htm#memfind_rb">memfind rb</A> (block, block_size, pattern, pattern_size,
                       searchbuf, &amp;repeat_find);
}
</PRE>
<A NAME="memfind_r">&nbsp;</A>
<H3><A NAME="TOC109"><TT>memfind_r</TT></A></H3>
<PRE>
#include "sflfind.h"
void *
memfind_r (const void  *block,          /*  Block containing data            */
           size_t       block_size,     /*  Size of block in bytes           */
           const void  *pattern,        /*  Pattern to search for            */
           size_t       pattern_size)   /*  Size of pattern block            */
</PRE>
<H4>Synopsis</H4>
<P>Searches for a pattern in a block of memory using the Boyer-
   Moore-Horspool-Sunday algorithm. The block and pattern may
   contain any values; you must explicitly provide their lengths.
   Returns a pointer to the pattern if found within the block, or
   NULL if the pattern was not found. This function is meant to
   handle binary data, for a single search for a given pattern. If
   you need to search strings, use the <A href="sfldoc.htm#strfind_r">strfind r</A>() or
   <A href="sfldoc.htm#strfind_rb">strfind rb</A>() functions. If you want to do efficient
   repeated searches for one pattern, use <A href="sfldoc.htm#memfind_rb">memfind rb</A>().
   Reentrant.
<H4>Source Code - (sflfind.c)</H4>
<PRE>
{
    size_t
        searchbuf [256];                /*  One-time search buffer           */
    Bool
        secondtime  = FALSE;

    ASSERT (block);                     /*  Expect non-NULL pointers, but    */
    ASSERT (pattern);                   /*  full through if not debugging    */

    return <A href="sfldoc.htm#memfind_rb">memfind rb</A> (block, block_size, pattern, pattern_size,
                       searchbuf, &amp;secondtime);
}
</PRE>
<A NAME="memfind_rb">&nbsp;</A>
<H3><A NAME="TOC110"><TT>memfind_rb</TT></A></H3>
<PRE>
#include "sflfind.h"
void *
memfind_rb (const void  *in_block,      /*  Block containing data            */
            size_t       block_size,    /*  Size of block in bytes           */
            const void  *in_pattern,    /*  Pattern to search for            */
            size_t       pattern_size,  /*  Size of pattern block            */
            size_t      *shift,         /*  Shift table (search buffer)      */
            Bool        *repeat_find)   /*  TRUE: search buffer already init */
</PRE>
<H4>Synopsis</H4>
<P>Searches for a pattern in a block of memory using the Boyer-
   Moore-Horspool-Sunday algorithm. The block and pattern may
   contain any values; you must explicitly provide their lengths.
   Returns a pointer to the pattern if found within the block, or
   NULL if the pattern was not found. On the first search with a
   given pattern, *repeat_find should be FALSE. It will be set to
   TRUE after the shift table is initialised, allowing the
   initialisation phase to be skipped on subsequent searches.
   shift must point to an array big enough to hold 256 (8**2)
   size_t values. This function is meant to handle binary data,
   for repeated searches for the same pattern. If you need to
   search strings, use the <A href="sfldoc.htm#strfind_r">strfind r</A>() or <A href="sfldoc.htm#strfind_rb">strfind rb</A>()
   functions. If you wish to search for a pattern only once
   consider using <A href="sfldoc.htm#memfind_r">memfind r</A>(). Reentrant.
<H4>Source Code - (sflfind.c)</H4>
<PRE>
{
    size_t
        byte_nbr,                       /*  Distance through block           */
        match_size;                     /*  Size of matched part             */
    const byte
        *match_base = NULL,             /*  Base of match of pattern         */
        *match_ptr  = NULL,             /*  Point within current match       */
        *limit      = NULL;             /*  Last potiental match point       */
    const byte
        *block   = (byte *) in_block,   /*  Concrete pointer to block data   */
        *pattern = (byte *) in_pattern; /*  Concrete pointer to search value */

    ASSERT (block);                     /*  Expect non-NULL pointers, but    */
    ASSERT (pattern);                   /*  fail gracefully if not debugging */
    ASSERT (shift);                     /*  NULL repeat_find =&gt; is false     */
    if (block == NULL || pattern == NULL || shift == NULL)
        return (NULL);

    /*  Pattern must be smaller or equal in size to string                   */
    if (block_size &lt; pattern_size)
        return (NULL);                  /*  Otherwise it's not found         */

    if (pattern_size == 0)              /*  Empty patterns match at start    */
        return ((void *)block);

    /*  Build the shift table unless we're continuing a previous search      */

    /*  The shift table determines how far to shift before trying to match   */
    /*  again, if a match at this point fails.  If the byte after where the  */
    /*  end of our pattern falls is not in our pattern, then we start to     */
    /*  match again after that byte; otherwise we line up the last occurence */
    /*  of that byte in our pattern under that byte, and try match again.    */

    if (!repeat_find || !*repeat_find)
      {
        for (byte_nbr = 0; byte_nbr &lt; 256; byte_nbr++)
            shift [byte_nbr] = pattern_size + 1;
        for (byte_nbr = 0; byte_nbr &lt; pattern_size; byte_nbr++)
            shift [(byte) pattern [byte_nbr]] = pattern_size - byte_nbr;

        if (repeat_find)
            *repeat_find = TRUE;
      }

    /*  Search for the block, each time jumping up by the amount             */
    /*  computed in the shift table                                          */

    limit = block + (block_size - pattern_size + 1);
    ASSERT (limit &gt; block);

    for (match_base = block;
         match_base &lt; limit;
         match_base += shift [*(match_base + pattern_size)])
      {
        match_ptr  = match_base;
        match_size = 0;

        /*  Compare pattern until it all matches, or we find a difference    */
        while (*match_ptr++ == pattern [match_size++])
          {
            ASSERT (match_size &lt;= pattern_size &amp;&amp;
                    match_ptr == (match_base + match_size));

            /*  If we found a match, return the start address                */
            if (match_size &gt;= pattern_size)
              return ((void*)(match_base));

          }
      }
    return (NULL);                      /*  Found nothing                    */
}
</PRE>
<A NAME="txtfind">&nbsp;</A>
<H3><A NAME="TOC111"><TT>txtfind</TT></A></H3>
<PRE>
#include "sflfind.h"
char *
txtfind (const char *string,            /*  String containing data           */
         const char *pattern)           /*  Pattern to search for            */
</PRE>
<H4>Synopsis</H4>
<P>Searches for a case-insensitive text pattern in a string using
   the Boyer-Moore-Horspool-Sunday algorithm. The string and
   pattern are null-terminated strings. Returns a pointer to the
   pattern if found within the string, or NULL if the pattern was
   not found. Will match strings irrespective of case. To match
   exact strings, use <A href="sfldoc.htm#strfind">strfind</A>(). Will not work on multibyte
   characters.
<H4>Examples</H4>
<PRE>
    char *result;

    result = txtfind ("AbracaDabra", "cad");
    if (result)
        puts (result);
</PRE>
<H4>Source Code - (sflfind.c)</H4>
<PRE>
{
    size_t
        shift [256];                    /*  Shift distance for each value    */
    size_t
        string_size,
        pattern_size,
        byte_nbr,                       /*  Index into byte array            */
        match_size;                     /*  Size of matched part             */
    const char
        *match_base = NULL,             /*  Base of match of pattern         */
        *match_ptr  = NULL,             /*  Point within current match       */
        *limit      = NULL;             /*  Last potiental match point       */

    ASSERT (string);                    /*  Expect non-NULL pointers, but    */
    ASSERT (pattern);                   /*  fail gracefully if not debugging */
    if (string == NULL || pattern == NULL)
        return (NULL);

    string_size  = strlen (string);
    pattern_size = strlen (pattern);

    /*  Pattern must be smaller or equal in size to string                   */
    if (string_size &lt; pattern_size)
        return (NULL);                  /*  Otherwise it cannot be found     */

    if (pattern_size == 0)              /*  Empty string matches at start    */
        return (char *) string;

    /*  Build the shift table                                                */

    /*  The shift table determines how far to shift before trying to match   */
    /*  again, if a match at this point fails.  If the byte after where the  */
    /*  end of our pattern falls is not in our pattern, then we start to     */
    /*  match again after that byte; otherwise we line up the last occurence */
    /*  of that byte in our pattern under that byte, and try match again.    */

    for (byte_nbr = 0; byte_nbr &lt; 256; byte_nbr++)
        shift [byte_nbr] = pattern_size + 1;

    for (byte_nbr = 0; byte_nbr &lt; pattern_size; byte_nbr++)
        shift [(byte) tolower (pattern [byte_nbr])] = pattern_size - byte_nbr;

    /*  Search for the string.  If we don't find a match, move up by the     */
    /*  amount we computed in the shift table above, to find location of     */
    /*  the next potiental match.                                            */

    limit = string + (string_size - pattern_size + 1);
    ASSERT (limit &gt; string);

    for (match_base = string;
         match_base &lt; limit;
         match_base += shift [(byte) tolower (*(match_base + pattern_size))])
      {
        match_ptr  = match_base;
        match_size = 0;

        /*  Compare pattern until it all matches, or we find a difference    */
        while (tolower (*match_ptr++) == tolower (pattern [match_size++]))
          {
            ASSERT (match_size &lt;= pattern_size &amp;&amp;
                    match_ptr == (match_base + match_size));

            /*  If we found a match, return the start address                */
            if (match_size &gt;= pattern_size)
                return ((char *)(match_base));
          }
      }
    return (NULL);                      /*  Found nothing                    */
}
</PRE>
<H2><A NAME="TOC112">File-access functions</A></H2>
<P>Filename: sflfile.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1992/10/25 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1999/11/08
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Provides functions to read and write files with explicit new-
   line/carriage-return control; to find files on a path; to copy
   files, check files' protection, etc.
<H4>List of Functions</H4>
<UL>
<LI>FILE * <A href="sfldoc.htm#file_open">file open</A><BR>
   (const char *filename, char mode);
</LI>
<LI>FILE * <A href="sfldoc.htm#file_locate">file locate</A><BR>
   (const char *path, const char *name, const char *ext);
</LI>
<LI>int <A href="sfldoc.htm#file_close">file close</A><BR>
   (FILE *stream);
</LI>
<LI>Bool <A href="sfldoc.htm#file_read">file read</A><BR>
   (FILE *stream, char *string);
</LI>
<LI>Bool <A href="sfldoc.htm#file_readn">file readn</A><BR>
   (FILE *stream, char *string, int line_max);
</LI>
<LI>char * <A href="sfldoc.htm#file_write">file write</A><BR>
   (FILE *stream, const char *string);
</LI>
<LI>int <A href="sfldoc.htm#file_copy">file copy</A><BR>
   (const char *dest, const char *src, char mode);
</LI>
<LI>int <A href="sfldoc.htm#file_concat">file concat</A><BR>
   (const char *dest, const char *src);
</LI>
<LI>int <A href="sfldoc.htm#file_rename">file rename</A><BR>
   (const char *oldname, const char *newname);
</LI>
<LI>int <A href="sfldoc.htm#file_delete">file delete</A><BR>
   (const char *filename);
</LI>
<LI>char * <A href="sfldoc.htm#file_where">file where</A><BR>
   (char mode, const char *path, const char *name, const char
   *ext);
</LI>
<LI>char * <A href="sfldoc.htm#file_where_ext">file where ext</A><BR>
   (char mode, const char *path, const char *name, const char
   **ext);
</LI>
<LI>Bool <A href="sfldoc.htm#file_exists">file exists</A><BR>
   (const char *filename);
</LI>
<LI>Bool <A href="sfldoc.htm#file_cycle">file cycle</A><BR>
   (const char *filename, int how);
</LI>
<LI>Bool <A href="sfldoc.htm#file_cycle_needed">file cycle needed</A><BR>
   (const char *filename, int how);
</LI>
<LI>Bool <A href="sfldoc.htm#file_has_changed">file has changed</A><BR>
   (const char *filename, long old_date, long old_time);
</LI>
<LI>Bool <A href="sfldoc.htm#safe_to_extend">safe to extend</A><BR>
   (const char *filename);
</LI>
<LI>char * <A href="sfldoc.htm#default_extension">default extension</A><BR>
   (char *dest, const char *src, const char *ext);
</LI>
<LI>char * <A href="sfldoc.htm#fixed_extension">fixed extension</A><BR>
   (char *dest, const char *src, const char *ext);
</LI>
<LI>char * <A href="sfldoc.htm#strip_extension">strip extension</A><BR>
   (char *filename);
</LI>
<LI>char * <A href="sfldoc.htm#add_extension">add extension</A><BR>
   (char *dest, const char *src, const char *ext);
</LI>
<LI>char * <A href="sfldoc.htm#strip_file_path">strip file path</A><BR>
   (char *filename);
</LI>
<LI>char * <A href="sfldoc.htm#strip_file_name">strip file name</A><BR>
   (char *filename);
</LI>
<LI>char * <A href="sfldoc.htm#get_new_filename">get new filename</A><BR>
   (const char *filename);
</LI>
<LI>Bool <A href="sfldoc.htm#file_is_readable">file is readable</A><BR>
   (const char *filename);
</LI>
<LI>Bool <A href="sfldoc.htm#file_is_writeable">file is writeable</A><BR>
   (const char *filename);
</LI>
<LI>Bool <A href="sfldoc.htm#file_is_executable">file is executable</A><BR>
   (const char *filename);
</LI>
<LI>Bool <A href="sfldoc.htm#file_is_directory">file is directory</A><BR>
   (const char *filename);
</LI>
<LI>Bool <A href="sfldoc.htm#file_is_program">file is program</A><BR>
   (const char *filename);
</LI>
<LI>Bool <A href="sfldoc.htm#file_is_legal">file is legal</A><BR>
   (const char *filename);
</LI>
<LI>char * <A href="sfldoc.htm#file_exec_name">file exec name</A><BR>
   (const char *filename);
</LI>
<LI>long <A href="sfldoc.htm#get_file_size">get file size</A><BR>
   (const char *filename);
</LI>
<LI>time_t <A href="sfldoc.htm#get_file_time">get file time</A><BR>
   (const char *filename);
</LI>
<LI>long <A href="sfldoc.htm#get_file_lines">get file lines</A><BR>
   (const char *filename);
</LI>
<LI>DESCR * <A href="sfldoc.htm#file_slurp">file slurp</A><BR>
   (const char *filename);
</LI>
<LI>DESCR * <A href="sfldoc.htm#file_slurpl">file slurpl</A><BR>
   (const char *filename);
</LI>
<LI>dbyte <A href="sfldoc.htm#file_set_eoln">file set eoln</A><BR>
   (char *dest, const char *src, dbyte src_size, Bool add_cr);
</LI>
<LI>char * <A href="sfldoc.htm#get_tmp_file_name">get tmp file name</A><BR>
   (const char *path, qbyte *index, const char *ext);
</LI>
<LI>int <A href="sfldoc.htm#file_fhredirect">file fhredirect</A><BR>
   (int source, int dest);
</LI>
<LI>void <A href="sfldoc.htm#file_fhrestore">file fhrestore</A><BR>
   (int source, int dest);
</LI>
<LI>FILE * <A href="sfldoc.htm#ftmp_open">ftmp open</A><BR>
   (char **pathname);
</LI>
<LI>void <A href="sfldoc.htm#ftmp_close">ftmp close</A><BR>
   (FILE *tempstream);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflfile.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>FILE_DIR_MAX</B>  </TT>
<TD ALIGN="LEFT">64 /* Max size of directory name */
<TR><TD ALIGN="LEFT"><TT><B>FILE_NAME_MAX</B>  </TT>
<TD ALIGN="LEFT">160 /* Max size of filename */
<TR><TD ALIGN="LEFT"><TT><B>FOPEN_APPEND_BINARY</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>FOPEN_APPEND_TEXT</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>FOPEN_READ_BINARY</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>FOPEN_READ_TEXT</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>FOPEN_WRITE_BINARY</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>FOPEN_WRITE_TEXT</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>SFLFILE_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>file_lines(f)</B>  </TT>
<TD ALIGN="LEFT">get_file_lines(f) /* Changed 98/07/23 */
</TABLE>
<A NAME="file_open">&nbsp;</A>
<H3><A NAME="TOC113"><TT>file_open</TT></A></H3>
<PRE>
#include "sflfile.h"
FILE *
file_open (
    const char *filename,               /*  Name of file to open             */
    char mode)                          /*  'r', 'w', or 'a'                 */
</PRE>
<H4>Synopsis</H4>
<P>opens a text file for reading or writing. Use in combination
   with the <A href="sfldoc.htm#file_read">file read</A>() and <A href="sfldoc.htm#file_write">file write</A>() functions. These
   functions handle end-of-line sequences using a heuristic that
   works as follows. ... (at this point the author went for a pint
   of beer and has not been seen since. We're hoping that the old
   version - following - is ok.)Opens the specified file for input
   or output. If you use the file_read / file_write functions you
   must open the file using this function. This set of functions
   lets you read files without concern for the line format (CRLF
   or LF). Mode should be one of 'r' 'w' 'a'. Returns a FILE
   pointer if the file is opened correctly; else NULL. Sets the
   global variable file_crlf to FALSE on all systems except MS-DOS
   (and Windows by inheritence) where it is set to TRUE by
   default. When opening a file in append mode, automatically
   removes any Ctrl-Z character under MS-DOS or OS/2.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
#if (defined (MSDOS_FILESYSTEM))
    if (system_devicename (filename))
        return (NULL);                  /*  Not allowed on device names      */

    file_crlf = TRUE;
#   if (defined (WIN32))
    SetErrorMode (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);
#   endif
#   else

    ASSERT (filename);
    file_crlf = FALSE;
#endif

    if (mode == 'r')
        return (fopen (filename, FOPEN_READ_BINARY));
    else
    if (mode == 'w')
        return (fopen (filename, FOPEN_WRITE_BINARY));
    else
    if (mode == 'a'
    &amp;&amp;  <A href="sfldoc.htm#safe_to_extend">safe to extend</A> (filename))
        return (fopen (filename, FOPEN_APPEND_BINARY));
    else
        return (NULL);                  /*  Invalid mode                     */
}
</PRE>
<A NAME="file_locate">&nbsp;</A>
<H3><A NAME="TOC114"><TT>file_locate</TT></A></H3>
<PRE>
#include "sflfile.h"
FILE *
file_locate (
    const char *path,
    const char *name,
    const char *ext)
</PRE>
<H4>Synopsis</H4>
<P>Combines the functions of <A href="sfldoc.htm#file_where">file where</A>() and file_open when
   you want to read a file. Searches for a file on a specified
   path, opens the file if found, and returns a FILE * for the
   open file. Returns NULL if the file was not found or could not
   be opened for reading.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    char
        *filename;

    ASSERT (name);
    filename = <A href="sfldoc.htm#file_where">file where</A> ('r', path, name, ext);
    if (filename)
        return (<A href="sfldoc.htm#file_open">file open</A> (filename, 'r'));
    else
        return (NULL);
}
</PRE>
<A NAME="file_close">&nbsp;</A>
<H3><A NAME="TOC115"><TT>file_close</TT></A></H3>
<PRE>
#include "sflfile.h"
int
file_close (
    FILE *stream)
</PRE>
<H4>Synopsis</H4>
<P>Closes an open file stream. Returns 0 if okay, -1 if there was
   an error. For now, equivalent to fclose, and supplied because
   it looks nice when you use <A href="sfldoc.htm#file_open">file open</A>() and <A href="sfldoc.htm#file_close">file close</A>()
   together.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    if (stream)
        return (fclose (stream));
    else
        return (0);
}
</PRE>
<A NAME="file_read">&nbsp;</A>
<H3><A NAME="TOC116"><TT>file_read</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_read (
    FILE *stream,
    char *string)
</PRE>
<H4>Synopsis</H4>
<P>Reads a line of text delimited by newline from the stream. The
   string must be LINE_MAX + 1 long. Places a null byte in place
   of the newline character. Expands tab characters to every 8th
   column. Returns TRUE when there is more input waiting; FALSE
   when the last line of the file has been read. Sets the global
   variable file_crlf to TRUE if CR was found in the file. This
   variable is by default FALSE. It is also used by file_write.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    int
        ch,                             /*  Character read from file         */
        cnbr;                           /*  Index into returned string       */

    ASSERT (stream);
    ASSERT (string);

    cnbr = 0;                           /*  Start at the beginning...        */
    memset (string, ' ', LINE_MAX);     /*    and prepare entire line        */
    for (;;)
      {
        ch = fgetc (stream);            /*  Get next character from file     */
        if (ch == '\t')                 /*  Jump if tab                      */
            cnbr = ((cnbr &gt;&gt; 3) &lt;&lt; 3) + 8;
        else
        if (ch == '\r')                 /*  Found carriage-return            */
            file_crlf = TRUE;           /*    Set flag and ignore CR         */
        else
        if ((ch == '\n')                /*  Have end of line                 */
        ||  (ch == EOF)                 /*    or end of file                 */
        ||  (ch == 26))                 /*    or MS-DOS Ctrl-Z               */
          {
            string [cnbr] = '\0';       /*  Terminate string                 */
            return (ch == '\n' || cnbr);    /*  and return TRUE/FALSE        */
          }
        else
        if (cnbr &lt; LINE_MAX)
            string [cnbr++] = (char) ch;    /*  Else add char to string      */

        if (cnbr &gt;= LINE_MAX)           /*  Return in any case if line is    */
          {                             /*    too long - the line will be    */
            string [LINE_MAX] = '\0';   /*    cut into pieces                */
            return (TRUE);
          }
      }
}
</PRE>
<A NAME="file_readn">&nbsp;</A>
<H3><A NAME="TOC117"><TT>file_readn</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_readn (
    FILE *stream,
    char *string,
    int   line_max)
</PRE>
<H4>Synopsis</H4>
<P>Works as <A href="sfldoc.htm#file_read">file read</A>() but with a maximum line-length
   specified by the caller. The supplied buffer must be at least
   as large as the specified line_max + 1.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    int
        ch,                             /*  Character read from file         */
        cnbr;                           /*  Index into returned string       */

    ASSERT (stream);
    ASSERT (string);

    cnbr = 0;                           /*  Start at the beginning...        */
    memset (string, ' ', line_max);     /*    and prepare entire line        */
    for (;;)
      {
        ch = fgetc (stream);            /*  Get next character from file     */
        if (ch == '\t')                 /*  Jump if tab                      */
            cnbr = ((cnbr &gt;&gt; 3) &lt;&lt; 3) + 8;
        else
        if (ch == '\r')                 /*  Found carriage-return            */
            file_crlf = TRUE;           /*    Set flag and ignore CR         */
        else
        if ((ch == '\n')                /*  Have end of line                 */
        ||  (ch == EOF)                 /*    or end of file                 */
        ||  (ch == 26))                 /*    or MS-DOS Ctrl-Z               */
          {
            string [cnbr] = '\0';       /*  Terminate string                 */
            return (ch == '\n' || cnbr);    /*  and return TRUE/FALSE        */
          }
        else
        if (cnbr &lt; line_max)
            string [cnbr++] = (char) ch;    /*  Else add char to string      */

        if (cnbr &gt;= line_max)           /*  Return in any case if line is    */
          {                             /*    too long - the line will be    */
            string [line_max] = '\0';   /*    cut into pieces                */
            return (TRUE);
          }
      }
}
</PRE>
<A NAME="file_write">&nbsp;</A>
<H3><A NAME="TOC118"><TT>file_write</TT></A></H3>
<PRE>
#include "sflfile.h"
char *
file_write (
    FILE *stream,
    const char *string)
</PRE>
<H4>Synopsis</H4>
<P>Writes a line of text to the specified output stream. If the
   variable file_crlf is TRUE, adds a carriage-return to the line
   being written to the output stream. This variable is supplied
   so that you can either ignore crlf issues (do nothing), or
   handle them explicitly (play with file_crlf). Returns the
   string written, or NULL if no data could be written to the
   file.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    ASSERT (stream);
    ASSERT (string);

    fputs (string, stream);
    if (file_crlf)
        fputc ('\r', stream);

    if (fputc ('\n', stream) == EOF)
        return (NULL);
    else
        return ((char *) string);
}
</PRE>
<A NAME="file_copy">&nbsp;</A>
<H3><A NAME="TOC119"><TT>file_copy</TT></A></H3>
<PRE>
#include "sflfile.h"
int
file_copy (
    const char *dest,
    const char *src,
    char mode)
</PRE>
<H4>Synopsis</H4>
<P>Copies a file called src to one called dest. The dest file may
   not already exist. If mode is 'b', copies a binary file; if
   mode is 't', copies a text file. This distinction only applies
   to MS-DOS file systems; on other platforms the two modes are
   equivalent. Returns 0 if no problems occurred, -1 if an error
   occurred, 1 if the destination file already exists.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    FILE *inf, *outf;
    char *buffer,
         openmode [3] = "??";
    size_t chars_read;                  /*  Amount read from stream          */
    int  feedback = 0;

    ASSERT (dest);
    ASSERT (src);
    if (<A href="sfldoc.htm#file_exists">file exists</A> (dest))
        return (1);                     /*  Cancel: dest already exists      */

#   if (defined (MSDOS_FILESYSTEM))
    if (system_devicename (dest) || system_devicename (src))
        return (-1);                    /*  Not allowed on device names      */
#   endif
#   if (defined (MSDOS_FILESYSTEM))
    openmode [1] = mode;
#   else
    openmode [1] = 0;
#   endif
    openmode [0] = 'r';
    if ((inf = fopen (src, openmode)) == NULL)
        return (-1);                    /*  Input file not found             */

    if ((buffer = mem_alloc (SHRT_MAX)) == NULL)
        feedback = -1;                  /*  Insufficient memory for buffer   */
    else
      {
        openmode [0] = 'w';
        if ((outf = fopen (dest, openmode)) == NULL)
          {
            mem_free (buffer);
            return (-1);                /*  Could not create output file     */
          }
        while ((chars_read = fread (buffer, 1, SHRT_MAX, inf)) != 0)
            if (fwrite (buffer, 1, chars_read, outf) != chars_read)
              {
                feedback = -1;
                break;
              }
        fclose (outf);
        mem_free (buffer);
      }
    fclose (inf);
    return (feedback);
}
</PRE>
<A NAME="file_concat">&nbsp;</A>
<H3><A NAME="TOC120"><TT>file_concat</TT></A></H3>
<PRE>
#include "sflfile.h"
int
file_concat (
    const char *src,
    const char *dest)
</PRE>
<H4>Synopsis</H4>
<P>Copies the contents of src onto dest. If dest does not exist,
   it is created. Returns 0 if the concatenation operation
   succeeded, or -1 if some error occurred.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    FILE *inf, *outf;
    char *buffer;
    size_t chars_read;                  /*  Amount read from stream          */
    int  feedback = 0;

    ASSERT (src);
    ASSERT (dest);

#   if (defined (MSDOS_FILESYSTEM))
    if (system_devicename (dest) || system_devicename (src))
        return (-1);                    /*  Not allowed on device names      */
#   endif
    if ((inf = fopen (src, FOPEN_READ_BINARY)) == NULL)
        return (-1);                    /*  Input file not found             */

    if ((buffer = mem_alloc (SHRT_MAX)) == NULL)
        feedback = -1;                  /*  Insufficient memory for buffer   */
    else
      {
        if ((outf = fopen (dest, FOPEN_APPEND_BINARY)) == NULL)
          {
            mem_free (buffer);
            return (-1);                /*  Could not create output file     */
          }
        while ((chars_read = fread (buffer, 1, SHRT_MAX, inf)) != 0)
            if (fwrite (buffer, 1, chars_read, outf) != chars_read)
              {
                feedback = -1;
                break;
              }
        fclose (outf);
        mem_free (buffer);
      }
    fclose (inf);
    return (feedback);
}
</PRE>
<A NAME="file_rename">&nbsp;</A>
<H3><A NAME="TOC121"><TT>file_rename</TT></A></H3>
<PRE>
#include "sflfile.h"
int
file_rename (
    const char *oldname,
    const char *newname)
</PRE>
<H4>Synopsis</H4>
<P>Renames a file from oldname to newname. Returns 0 if okay, or -
   1 if there was an error. Does not overwrite existing files.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
#   if (defined (MSDOS_FILESYSTEM))
    char *dos_newname;
    int   feedback;

    ASSERT (oldname);
    ASSERT (newname);

    if (system_devicename (oldname) || system_devicename (newname))
        return (-1);                    /*  Not allowed on device names      */

    dos_newname = mem_strdup (newname);
    <A href="sfldoc.htm#strconvch">strconvch</A> (dos_newname, '/', '\\');
    feedback = rename (oldname, dos_newname);
    mem_free (dos_newname);
    return (feedback);

#   else
    ASSERT (oldname);
    ASSERT (newname);

    return (rename (oldname, newname));
#   endif
}
</PRE>
<A NAME="file_delete">&nbsp;</A>
<H3><A NAME="TOC122"><TT>file_delete</TT></A></H3>
<PRE>
#include "sflfile.h"
int
file_delete (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Deletes the specified file. Returns 0 if okay, -1 in case of an
   error.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
#if (defined (__VMS__))
    ASSERT (filename);
    return (remove (filename));

#elif (defined (WIN32))
    int
        rc;

    ASSERT (filename);
    if (system_devicename (filename))
        return (-1);                    /*  Not allowed on device names      */

    rc = !DeleteFile (filename);
    if (rc &amp;&amp; errno == EACCES)
      {
        /*  Under WinNT and Win95, a delete of a freshly-created file can
         *  sometimes fail with a permission error which passes after a
         *  short delay.  Ugly but it seems to work.
         */
        Sleep (200);
        rc = !DeleteFile (filename);
      }
    return (rc);
#else

    ASSERT (filename);
    return (unlink (filename));
#endif
}
</PRE>
<A NAME="file_exists">&nbsp;</A>
<H3><A NAME="TOC123"><TT>file_exists</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_exists (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the file exists, or FALSE if it does not.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    ASSERT (filename);
    return (file_mode (filename) &gt; 0);
}
</PRE>
<A NAME="file_where">&nbsp;</A>
<H3><A NAME="TOC124"><TT>file_where</TT></A></H3>
<PRE>
#include "sflfile.h"
char *
file_where (
    char mode,
    const char *path,
    const char *name,
    const char *ext)
</PRE>
<H4>Synopsis</H4>
<P>Scans a user-specified path symbol for a specific file, and
   returns the fully-specified filename. Also adds an extension if
   this is required. The mode argument can be one of: r, w, a, or
   s for read, write, append, or static. The function tries to
   locate existing files somewhere on the path. New files are
   always created in the current directory. Static files are
   created in the first directory on the path. The path argument
   is only used when more is r, a, or s. If the path is NULL or
   empty, it is ignored. Otherwise, the path is translated as an
   environment variable, and cut into a list of directory names.
   The path is cut up as follows: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>MS-DOS</B>  <TD ALIGN="LEFT">directory names
   separated by ';'. ;; means current. <TR><TD
   ALIGN="LEFT"><B>OS/2</B>  <TD ALIGN="LEFT">directory names
   separated by ';'. ;; means current. <TR><TD
   ALIGN="LEFT"><B>Unix</B>  <TD ALIGN="LEFT">directory names
   separated by ':'. :: means current. <TR><TD
   ALIGN="LEFT"><B>VMS</B>  <TD ALIGN="LEFT">directory names
   separated by ','. " ", means current. <TR><TD
   ALIGN="LEFT"><B>Other</B>  <TD ALIGN="LEFT">single directory
   name. </TABLE> When the mode is 'r' or 'a', searches the
   current directory before considering the path value. When the
   path cannot be translated, and is not null or empty, it is used
   as a literal value. The name argument is the filename with or
   without extension. It will be prefixed by the path and suffixed
   by the extension, if required. The ext argument is a default or
   mandatory extension. If ext starts with a dot, it is mandatory
   and always used. Otherwise it is used only if the name does not
   already have an extension. If ext is NULL or empty, it is
   ignored. The total length of a name including path, name,
   extension, and any delimiters is FILE_NAME_MAX. Names are
   truncated if too long. The maximum size of one directory
   component is FILE_DIR_MAX chars. All parameters are case-
   sensitive; the precise effect of this depends on the system. On
   MS-DOS, filenames are always folded to uppercase, but the path
   must be supplied in uppercase correctly. On UNIX, all
   parameters are case sensitive. On VMS, path and filenames are
   folded into uppercase. Returns a pointer to a static character
   array containing the filename; if mode is 'r' and the file does
   not exist, returns NULL. If the mode is 'w', 'a', or 's',
   always returns a valid filename. Under VMS, all filenames are
   handled in POSIX mode, i.e. /disk/path/file instead of
   $disk:[path]file.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    const char
        *pathptr;                       /*  End of directory in path         */
    char
        *curdir;
    Bool
        search_curdir = TRUE;           /*  Look in current directory?       */

    ASSERT (name);
    if (ext != NULL &amp;&amp; *ext)            /*  Append extension if not null     */
      {                                 /*    to get name + ext into         */
        if (ext [0] == '.')             /*    work_name.                     */
            <A href="sfldoc.htm#fixed_extension">fixed extension</A> (work_name, name, ext);
        else
            <A href="sfldoc.htm#default_extension">default extension</A> (work_name, name, ext);
      }
    else
        strcpy (work_name, name);
#if (NAMEFOLD == TRUE)
    <A href="sfldoc.htm#strupc">strupc</A> (work_name);                 /*  Fold to uppercase if needed      */
#endif

    if (path != NULL &amp;&amp; *path)          /*  Get value of path, or NULL       */
      {
        pathptr = getenv (path);        /*  Translate path symbol            */
        if (pathptr == NULL)
          {
            pathptr = path;             /*  If not found, use literally      */
            search_curdir = FALSE;      /*  Path now takes priority          */
          }
#if (PATHFOLD == TRUE)                  /*  Fold to uppercase if necessary   */
        if (pathptr)
          {
            ASSERT (strlen (pathptr) &lt; PATH_MAX);
            strcpy (path_name, pathptr);
            <A href="sfldoc.htm#strupc">strupc</A> (path_name);
            pathptr = path_name;        /*  Redirect to uppercase version    */
          }
#endif
      }
    else
        pathptr = NULL;

#if (defined (MSDOS_FILESYSTEM))
    /*  Normalise the path value by changing any slashes to backslashes      */
    if (pathptr)
      {
        if (pathptr != path_name)
          {
            strcpy (path_name, pathptr);
            pathptr = path_name;
          }
        <A href="sfldoc.htm#strconvch">strconvch</A> (path_name, '/', '\\');
      }
#endif

    /*  Take care of 'w' and 's' options first                               */
    if (mode == 'w')                    /*  Create output file locally       */
        return (work_name);

    if (mode == 's')                    /*  Get specific directory name      */
      {
        if (fully_specified (work_name))
            strncpy (full_name, work_name, sizeof (full_name));
        else
        if (pathptr &amp;&amp; <A href="sfldoc.htm#file_is_directory">file is directory</A> (pathptr))
            build_next_path (full_name, pathptr, work_name);
        else
#if (defined (MSDOS_FILESYSTEM))
            build_next_path (full_name, ".\\", work_name);
#else
            build_next_path (full_name, "./", work_name);
#endif
        return (full_name);
      }

    /*  If file exists as defined, prefix with current directory if not an   */
    /*  absolute filename, then return the resulting filename                */
    if (search_curdir &amp;&amp; <A href="sfldoc.htm#file_exists">file exists</A> (work_name))
      {
        if (fully_specified (work_name))
            strncpy (full_name, work_name, sizeof (full_name));
        else
          {
            curdir = <A href="sfldoc.htm#get_curdir">get curdir</A> ();
            snprintf (full_name, sizeof (full_name), "%s%s", curdir, work_name);
            mem_free (curdir);
          }
#if (defined (MSDOS_FILESYSTEM))
        <A href="sfldoc.htm#strconvch">strconvch</A> (full_name, '/', '\\');
#endif
        return (full_name);             /*  Then return path + name + ext    */
      }
    if (!pathptr)                       /*  Now we need a path               */
        return (NULL);                  /*   - if none defined, give up      */

    for (;;)                            /*  Try each path component          */
      {
        pathptr = build_next_path (full_name, pathptr, work_name);
        if (<A href="sfldoc.htm#file_exists">file exists</A> (full_name))
            return (full_name);         /*  Until we find one,               */

        if (*pathptr == '\0')           /*    or we come to the end of       */
          {                             /*    the path                       */
            if (mode == 'r')
                return (NULL);          /*  Input file was not found...      */
            else
                return (full_name);
          }
      }
}
</PRE>
<A NAME="file_where_ext">&nbsp;</A>
<H3><A NAME="TOC125"><TT>file_where_ext</TT></A></H3>
<PRE>
#include "sflfile.h"
char *
file_where_ext (
    char mode,
    const char *path,
    const char *name,
    const char **ext)
</PRE>
<H4>Synopsis</H4>
<P>Scans a user-specified path symbol for a specific file, and
   returns the fully-specified filename. Can also scan a series of
   file extensions while looking for the file in the path. The
   extensions are scanned in each directory in the path prior to
   moving on to the next directory. The mode argument can be one
   of: r, w, a, or s for read, write, append, or static. The
   function tries to locate existing files somewhere on the path.
   New files are always created in the current directory. Static
   files are created in the first directory on the path. The path
   argument is only used when mode is r, a, or s. If the path is
   NULL or empty, it is ignored. Otherwise, the path is translated
   as an environment variable. If the path cannot be translated,
   it is used as a literal value. The path is then cut into a list
   of directory names, as follows: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>MS-DOS</B>  <TD ALIGN="LEFT">directory names
   separated by ';'. ;; means current. <TR><TD
   ALIGN="LEFT"><B>OS/2</B>  <TD ALIGN="LEFT">directory names
   separated by ';'. ;; means current. <TR><TD
   ALIGN="LEFT"><B>Unix</B>  <TD ALIGN="LEFT">directory names
   separated by ':'. :: means current. <TR><TD
   ALIGN="LEFT"><B>VMS</B>  <TD ALIGN="LEFT">directory names
   separated by ','. " ", means current. <TR><TD
   ALIGN="LEFT"><B>Other</B>  <TD ALIGN="LEFT">single directory
   name. </TABLE> When the mode is 'r' or 'a', it searches the
   current directory before considering the path value. The name
   argument is the filename with or without extension. It will be
   prefixed by the path and suffixed by the extension, if
   required. The ext argument is an array of default or mandatory
   extensions. If the extension starts with a dot, it is mandatory
   and will override any existing extension. Otherwise it is used
   only if the name does not already have an extension. The
   filename will be tried as supplied if ext is NULL, or if it has
   an extension, and one or more of the entries is a default
   extension. The first extension, if any, is always used in 'w'
   mode and 's' mode. The last path component and extension will
   be used in 'a' mode, if either is supplied. The total length of
   a name including path, name, extension, and any delimiters is
   FILE_NAME_MAX. Names are truncated if too long. The maximum
   size of one directory component is FILE_DIR_MAX chars. All
   parameters are case-sensitive; the precise effect of this
   depends on the system. On MS-DOS, filenames are always folded
   to uppercase, but the path must be supplied in uppercase
   correctly. On UNIX, all parameters are case sensitive. On VMS,
   path and filenames are folded into uppercase. Returns a pointer
   to a static character array containing the filename; if mode is
   'r' and the file does not exist, returns NULL. If the mode is
   'w', 'a', or 's', always returns a valid filename. Under VMS,
   all filenames are handled in POSIX mode, i.e. /disk/path/file
   instead of $disk:[path]file.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    const char
        *pathptr;                       /*  End of directory in path         */
    const char
        **extptr;                       /*  Pointer to next extension        */
    char
        *curdir;
    Bool
        search_curdir = TRUE;           /*  Look in current directory?       */

    ASSERT (name);
    if (!name)
        return NULL;

    if (path != NULL &amp;&amp; *path)          /*  Get value of path, or NULL       */
      {
        pathptr = getenv (path);        /*  Translate path symbol            */
        if (pathptr == NULL)
          {
            pathptr = path;             /*  If not found, use literally      */
            search_curdir = FALSE;      /*  Path now takes priority          */
          }
#if (PATHFOLD == TRUE)                  /*  Fold to uppercase if necessary   */
        if (pathptr)
          {
            ASSERT (strlen (pathptr) &lt; PATH_MAX);
            strcpy (path_name, pathptr);
            <A href="sfldoc.htm#strupc">strupc</A> (path_name);
            pathptr = path_name;        /*  Redirect to uppercase version    */
          }
#endif
      }
    else
        pathptr = NULL;

#if (defined (MSDOS_FILESYSTEM))
    /*  Normalise the path value by changing any slashes to backslashes      */
    if (pathptr)
      {
        if (pathptr != path_name)
          {
            strcpy (path_name, pathptr);
            pathptr = path_name;
          }
        <A href="sfldoc.htm#strconvch">strconvch</A> (path_name, '/', '\\');
      }
#endif

    /*  Take care of 'w' and 's' options first                               */
    if (mode == 'w')                    /*  Create output file locally       */
      {
        if (ext != NULL &amp;&amp; ext [0] != NULL)
            <A href="sfldoc.htm#add_extension">add extension</A> (work_name, name, ext [0]);
        else
            strcpy (work_name, name);
#if (NAMEFOLD == TRUE)
        <A href="sfldoc.htm#strupc">strupc</A> (work_name);             /*  Fold to uppercase if needed      */
#endif

        return (work_name);
      }

    if (mode == 's')                    /*  Get specific directory name      */
      {
        if (ext != NULL &amp;&amp; ext [0] != NULL)
            <A href="sfldoc.htm#add_extension">add extension</A> (work_name, name, ext [0]);
        else
            strcpy (work_name, name);
#if (NAMEFOLD == TRUE)
        <A href="sfldoc.htm#strupc">strupc</A> (work_name);             /*  Fold to uppercase if needed      */
#endif

        if (fully_specified (work_name))
            strcpy (full_name, work_name);
        else
        if (pathptr &amp;&amp; <A href="sfldoc.htm#file_is_directory">file is directory</A> (pathptr))
            build_next_path (full_name, pathptr, work_name);
        else
#if (defined (MSDOS_FILESYSTEM))
            build_next_path (full_name, ".\\", work_name);
#else
            build_next_path (full_name, "./", work_name);
#endif
        return (full_name);
      }

    /*  If file exists as defined (with one of the extensions), prefix with  */
    /*  current directory if not an absolute filename, then return the       */
    /*  resulting filename                                                   */
    if (search_curdir)
      {
        extptr = ext;
        do
          {
            if (extptr != NULL &amp;&amp; *extptr != NULL)
                <A href="sfldoc.htm#add_extension">add extension</A> (work_name, name, *extptr);
            else
                strcpy (work_name, name);
#if (NAMEFOLD == TRUE)
            <A href="sfldoc.htm#strupc">strupc</A> (work_name);         /*  Fold to uppercase if needed      */
#endif

            if (<A href="sfldoc.htm#file_exists">file exists</A> (work_name))
              {
                if (fully_specified (work_name))
                    strcpy (full_name, work_name);
                else
                  {
                    curdir = <A href="sfldoc.htm#get_curdir">get curdir</A> ();
                    snprintf (full_name, sizeof (full_name),
			                 "%s%s", curdir, work_name);
                    mem_free (curdir);
                  }
#if (defined (MSDOS_FILESYSTEM))
                <A href="sfldoc.htm#strconvch">strconvch</A> (full_name, '/', '\\');
#endif
                return (full_name);     /*  Then return path + name + ext    */
              }

            if (extptr)
                extptr++;
          }
         while (extptr != NULL &amp;&amp; *extptr != NULL);
      }

    if (!pathptr)                       /*  We need a path to look further   */
        return (NULL);                  /*   - if none defined, give up      */

    for (;;)                            /*  Try each path component          */
      {                                 /*   - and extension within that     */
        const char *savedptr = pathptr;
        extptr = ext;

        do
          {
            const char *extension = NULL;

            if (extptr != NULL &amp;&amp; *extptr != NULL)
                extension = *extptr;

            pathptr = build_next_path_ext (full_name, savedptr,
                                           name,      extension);

            if (<A href="sfldoc.htm#file_exists">file exists</A> (full_name))
                return (full_name);     /*  Until we find one that matches   */

            if (extptr)
                extptr++;
          }
        while (extptr != NULL &amp;&amp; *extptr != NULL);

        if (*pathptr == '\0')           /*    or we come to the end of       */
          {                             /*    the path                       */
            if (mode == 'r')
                return (NULL);          /*  Input file was not found...      */
            else
                return (full_name);
          }
      }
}
</PRE>
<A NAME="file_cycle">&nbsp;</A>
<H3><A NAME="TOC126"><TT>file_cycle</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_cycle (
    const char *filename,
    int how)
</PRE>
<H4>Synopsis</H4>
<P>Cycles the file: if the file already exists, renames the
   existing file. This function tries to rename the file using the
   date of creation of the file; if this fails because an existing
   file had the same name, generates a guaranteed unique file
   name. Returns TRUE if the cycle operation succeeded, or FALSE
   if it failed (e.g. due to a protection problem). The how
   argument must be one of: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>CYCLE ALWAYS</B>  <TD ALIGN="LEFT">Cycle file
   unconditionally <TR><TD ALIGN="LEFT"><B>CYCLE HOURLY</B>  <TD
   ALIGN="LEFT">Cycle file if hour has changed <TR><TD
   ALIGN="LEFT"><B>CYCLE DAILY</B>  <TD ALIGN="LEFT">Cycle file if
   day has changed <TR><TD ALIGN="LEFT"><B>CYCLE WEEKLY</B>  <TD
   ALIGN="LEFT">Cycle file if week has changed <TR><TD
   ALIGN="LEFT"><B>CYCLE MONTHLY</B>  <TD ALIGN="LEFT">Cycle file
   if month has changed <TR><TD ALIGN="LEFT"><B>CYCLE NEVER</B>
   <TD ALIGN="LEFT">Don't cycle the file </TABLE>
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    long
        file_date;                      /*  Datestamp of file                */
    char
        *point,
        *insert_at;                     /*  Where we start messing name      */
    int
        unique_nbr;                     /*  To generate a unique name        */

    ASSERT (filename);

    /*  If no cycling needed, do nothing                                     */
    if (!<A href="sfldoc.htm#file_cycle_needed">file cycle needed</A> (filename, how))
        return (TRUE);                  /*  No errors, nothing in fact       */

    file_date = <A href="sfldoc.htm#timer_to_date">timer to date</A> (<A href="sfldoc.htm#get_file_time">get file time</A> (filename));
    strcpy (full_name, filename);
    point = strrchr (full_name, '.');
    if (point)
      {
        strcpy (work_name, point);      /*  Save extension, if any           */
        *point = '\0';                  /*    and truncate original name     */
      }
    else
        strclr (work_name);

    /*  We leave up to 2 original letters of the filename, then stick-in     */
    /*  the 6-digit timestamp.                                               */
    insert_at = strrchr (full_name, '/');
#if (defined (MSDOS_FILESYSTEM))
    if (!insert_at)
        insert_at = strrchr (full_name, '\\');
#endif
    if (insert_at)
        insert_at++;                    /*  Bump past slash, if found        */
    else
        insert_at = full_name;

    if (*insert_at)                     /*  Bump insert_at twice, to leave   */
        insert_at++;                    /*    up to 2 letters before we      */
    if (*insert_at)                     /*    stick-in the date stamp        */
        insert_at++;

    /*  Format new name for file and make sure it does not already exist     */
    sprintf (insert_at, "%06d", (int) (file_date % 1000000L));
    strcat  (insert_at, work_name);
    if (<A href="sfldoc.htm#file_exists">file exists</A> (full_name))
      {
        point = strrchr (full_name, '.') + 1;
        for (unique_nbr = 0; unique_nbr &lt; 1000; unique_nbr++)
          {
            sprintf (point, "%03d", unique_nbr);
            if (!<A href="sfldoc.htm#file_exists">file exists</A> (full_name))
                break;
          }
      }
    if (<A href="sfldoc.htm#file_exists">file exists</A> (full_name))
        return (FALSE);                 /*  We give up!                      */

    if (<A href="sfldoc.htm#file_rename">file rename</A> (filename, full_name))
        return (FALSE);                 /*  No permission                    */
    else
        return (TRUE);                  /*  Okay, it worked                  */
}
</PRE>
<A NAME="file_cycle_needed">&nbsp;</A>
<H3><A NAME="TOC127"><TT>file_cycle_needed</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_cycle_needed (
    const char *filename,
    int how)
</PRE>
<H4>Synopsis</H4>
<P>Checks whether the file should be cycled or not. Returns TRUE
   if the file needs to be cycled, FALSE if not. The how argument
   must be one of: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>CYCLE ALWAYS</B>  <TD ALIGN="LEFT">Cycle file
   unconditionally <TR><TD ALIGN="LEFT"><B>CYCLE HOURLY</B>  <TD
   ALIGN="LEFT">Cycle file if hour has changed <TR><TD
   ALIGN="LEFT"><B>CYCLE DAILY</B>  <TD ALIGN="LEFT">Cycle file if
   day has changed <TR><TD ALIGN="LEFT"><B>CYCLE WEEKLY</B>  <TD
   ALIGN="LEFT">Cycle file if week has changed <TR><TD
   ALIGN="LEFT"><B>CYCLE MONTHLY</B>  <TD ALIGN="LEFT">Cycle file
   if month has changed <TR><TD ALIGN="LEFT"><B>CYCLE NEVER</B>
   <TD ALIGN="LEFT">Don't cycle the file </TABLE> If the specified
   file does not exist or is not accessible, returns FALSE.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    long
        curr_time,                      /*  Current time                     */
        curr_date,                      /*  Current date                     */
        file_date,                      /*  Timestamp of file                */
        file_time;                      /*  Datestamp of file                */
    Bool
        cycle;                          /*  Do we want to cycle the file?    */

    ASSERT (filename);
    if (!<A href="sfldoc.htm#file_exists">file exists</A> (filename))        /*  Not found - nothing more to do   */
        return (FALSE);

    file_time = <A href="sfldoc.htm#timer_to_time">timer to time</A> (<A href="sfldoc.htm#get_file_time">get file time</A> (filename));
    file_date = <A href="sfldoc.htm#timer_to_date">timer to date</A> (<A href="sfldoc.htm#get_file_time">get file time</A> (filename));
    curr_time = <A href="sfldoc.htm#time_now">time now</A> ();
    curr_date = <A href="sfldoc.htm#date_now">date now</A> ();

    switch (how)
      {
        case CYCLE_ALWAYS:
            cycle = TRUE;
            break;
        case CYCLE_HOURLY:
            cycle = GET_HOUR (file_time) != GET_HOUR (curr_time);
            break;
        case CYCLE_DAILY:
            cycle = GET_DAY (file_date) != GET_DAY (curr_date);
            break;
        case CYCLE_WEEKLY:
            cycle = <A href="sfldoc.htm#week_of_year">week of year</A> (file_date) != <A href="sfldoc.htm#week_of_year">week of year</A> (curr_date);
            break;
        case CYCLE_MONTHLY:
            cycle = GET_MONTH (file_date) != GET_MONTH (curr_date);
            break;
        case CYCLE_NEVER:
            cycle = FALSE;
            break;
        default:
            cycle = FALSE;
      }
    return (cycle);
}
</PRE>
<A NAME="file_has_changed">&nbsp;</A>
<H3><A NAME="TOC128"><TT>file_has_changed</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_has_changed (
    const char *filename,
    long old_date,
    long old_time)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the file has changed since it was last read.
   The calling program must supply the date and time of the file
   as it was read. If the file is not present or accessible,
   returns FALSE.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    long
        file_date,                      /*  Timestamp of file                */
        file_time;                      /*  Datestamp of file                */

    ASSERT (filename);
    if (!<A href="sfldoc.htm#file_exists">file exists</A> (filename))        /*  Not found - nothing more to do   */
        return (FALSE);

    file_time = <A href="sfldoc.htm#timer_to_time">timer to time</A> (<A href="sfldoc.htm#get_file_time">get file time</A> (filename));
    file_date = <A href="sfldoc.htm#timer_to_date">timer to date</A> (<A href="sfldoc.htm#get_file_time">get file time</A> (filename));
    if (file_date  &gt; old_date
    || (file_date == old_date &amp;&amp; file_time &gt; old_time))
        return (TRUE);
    else
        return (FALSE);
}
</PRE>
<A NAME="safe_to_extend">&nbsp;</A>
<H3><A NAME="TOC129"><TT>safe_to_extend</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
safe_to_extend (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Handles system-specific case of extending a file that may not
   be in a valid state for such an operation. Returns TRUE if the
   extend can go ahead; returns FALSE if the extend cannot be
   permitted. Under MS-DOS and Windows, if the last byte in the
   file is Ctrl-Z (26) the file is truncated by 1 position to
   remove this character.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
#if (defined (MSDOS_FILESYSTEM))
    int  handle;                        /*  Opened file handle               */
    char endoffile;                     /*  Last character in file           */

    ASSERT (filename);

    if (system_devicename (filename))
        return (FALSE);                 /*  Not allowed on device names      */

    handle = open (filename, O_RDWR + O_BINARY, S_IREAD | S_IWRITE);
    if (handle)                         /*  If not found, ignore             */
      {
        lseek (handle, -1, SEEK_END);
        read  (handle, &amp;endoffile, 1);
        if (endoffile == 26)
            chsize (handle, filelength (handle) - 1);

        close (handle);
      }
#endif
    return (TRUE);
}
</PRE>
<A NAME="default_extension">&nbsp;</A>
<H3><A NAME="TOC130"><TT>default_extension</TT></A></H3>
<PRE>
#include "sflfile.h"
char *
default_extension (
    char *dest,
    const char *src,
    const char *ext)
</PRE>
<H4>Synopsis</H4>
<P>Copies src to dest and adds ext if necessary. Returns dest.
   Dest must be large enough for a fully-formatted filename;
   define it as char [FILE_NAME_MAX + 1]. The ext argument can
   start with or without a dot. If ext is null or empty, does
   nothing.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    int len, i;
    char *ptr;

    ASSERT (dest);
    ASSERT (src);

    if (dest != src)                    /*  Copy src to dest if not same     */
        strcpy (dest, src);

    if (ext != NULL &amp;&amp; *ext != 0)
      {
        len = strlen (dest);
        for (i = len - 1, ptr = dest + i; i &gt;= 0; i--, ptr--)
            if (*ptr == '\\' || *ptr == '/' || *ptr == '.')
                break;

        if (i &lt; 0 || *ptr != '.')
          {
            if (*ext != '.')
              {
                dest [len++] = '.';
                dest [len] = '\0';
              }
            strcat (dest + len, ext);
          }
      }
    return (dest);
}
</PRE>
<A NAME="fixed_extension">&nbsp;</A>
<H3><A NAME="TOC131"><TT>fixed_extension</TT></A></H3>
<PRE>
#include "sflfile.h"
char *
fixed_extension (
    char *dest,
    const char *src,
    const char *ext)
</PRE>
<H4>Synopsis</H4>
<P>Copies src to dest and enforces ext extension. Returns dest.
   Dest must be large enough for a fully-formatted filename;
   define it as char [FILE_NAME_MAX + 1]. The ext argument can
   start with or without a dot. If ext is null or empty, does
   nothing.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    ASSERT (dest);
    ASSERT (src);

    if (dest != src)                    /*  Copy src to dest if not same     */
        strcpy (dest, src);

    <A href="sfldoc.htm#strip_extension">strip extension</A> (dest);
    return (<A href="sfldoc.htm#default_extension">default extension</A> (dest, dest, ext));
}
</PRE>
<A NAME="strip_extension">&nbsp;</A>
<H3><A NAME="TOC132"><TT>strip_extension</TT></A></H3>
<PRE>
#include "sflfile.h"
char *
strip_extension (
    char *name)
</PRE>
<H4>Synopsis</H4>
<P>Removes dot and extension from the name, if any was present. If
   the name contained multiple extensions, removes the last one
   only. Returns name.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    char *dot, *slash;

    ASSERT (name);

    dot   = strrchr (name, '.');        /*  Find dot in name, if any         */
    slash = strrchr (name, '\\');       /*  Find last slash (DOS or Unix)    */
    if (slash == NULL)
        slash = strrchr (name, '/');
    if (dot &gt; slash)
        *dot = 0;                       /*  If we had a dot, truncate name   */

    return (name);
}
</PRE>
<A NAME="add_extension">&nbsp;</A>
<H3><A NAME="TOC133"><TT>add_extension</TT></A></H3>
<PRE>
#include "sflfile.h"
char *
add_extension (
    char *dest,
    const char *src,
    const char *ext)
</PRE>
<H4>Synopsis</H4>
<P>Copies src to dest and adds ext if necessary. If extension
   starts with "." then it will be added, in place of any existing
   extension. If extension does not start with "." it will be
   added only if there is no existing extension. If ext is null or
   empty, just copies src into dest if required. Dest must be
   large enough for a fully-formatted filename; define it as char
   [FILE_NAME_MAX + 1].
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    char
        *result;

    ASSERT (dest);
    ASSERT (src);
    if (!src || !dest)
        return (NULL);

    if (!ext || *ext == '\0')
      {
        if (dest != src)                /*  Copy src to dest if not same     */
            strcpy (dest, src);

        result = dest;
      }
    else
        if (*ext == '.')
            result = <A href="sfldoc.htm#fixed_extension">fixed extension</A> (dest, src, ext);
        else
            result = <A href="sfldoc.htm#default_extension">default extension</A> (dest, src, ext);

    return (result);
}
</PRE>
<A NAME="strip_file_path">&nbsp;</A>
<H3><A NAME="TOC134"><TT>strip_file_path</TT></A></H3>
<PRE>
#include "sflfile.h"
char
*strip_file_path (
    char *name)
</PRE>
<H4>Synopsis</H4>
<P>Removes the leading path from the filename, if any path was
   present. Returns name. The path can be specified using the
   local operating system syntax; under MS-DOS, / and \ are
   interchangeable.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    char *path_end;

    ASSERT (name);

    path_end = strrchr (name, PATHEND); /*  Find end of path, if any         */
#if (defined (MSDOS_FILESYSTEM))
    if (path_end == NULL)
        path_end = strrchr (name, '/');
#endif
    if (path_end != NULL)
        memmove (name, path_end + 1, strlen (path_end));
    return (name);
}
</PRE>
<A NAME="strip_file_name">&nbsp;</A>
<H3><A NAME="TOC135"><TT>strip_file_name</TT></A></H3>
<PRE>
#include "sflfile.h"
char
*strip_file_name (
    char *name)
</PRE>
<H4>Synopsis</H4>
<P>Returns the path for a fully-qualified filename. The path is
   cleaned-up and resolved. The returned string is held in a
   static area that should be copied directly after calling this
   function. The returned path does not end in '/' unless that is
   the entire path. If the supplied name contains no path, the
   returned path is ".".
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    char *path_end;

    ASSERT (name);
    ASSERT (strlen (name) &lt;= LINE_MAX);

    strcpy (work_name, name);
    path_end = strrchr (work_name, PATHEND);
#if (defined (MSDOS_FILESYSTEM))
    if (path_end == NULL)
        path_end = strrchr (work_name, '/');
#endif
    if (path_end == NULL)
        return (".");
    else
      {
        path_end [1] = '\0';
        return (<A href="sfldoc.htm#clean_path">clean path</A> (work_name));
      }
}
</PRE>
<A NAME="get_new_filename">&nbsp;</A>
<H3><A NAME="TOC136"><TT>get_new_filename</TT></A></H3>
<PRE>
#include "sflfile.h"
char *
get_new_filename (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Appends a numeric suffix (_001, _002,...) to the filename until
   it is unique. Returns a freshly-allocated string containing the
   new filename.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    char
        suffix [8],
        *new_name;
    int
        counter;

    for (counter = 0; ; counter++)
      {
        sprintf (suffix, "_%03d", counter);
        new_name = <A href="sfldoc.htm#xstrcpy">xstrcpy</A> (NULL, filename, suffix, NULL);
        if (!<A href="sfldoc.htm#file_exists">file exists</A> (new_name))
            return (new_name);
        else
            mem_free (new_name);
      }
    return (NULL);
}
</PRE>
<A NAME="file_is_readable">&nbsp;</A>
<H3><A NAME="TOC137"><TT>file_is_readable</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_is_readable (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the current process can read the specified file
   or directory. The filename may end in a slash (/ or \) only if
   it is a directory.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    ASSERT (filename);
    if (<A href="sfldoc.htm#file_is_directory">file is directory</A> (filename))
        return ((file_mode (<A href="sfldoc.htm#clean_path">clean path</A> (filename)) &amp; S_IREAD) != 0);
    else
    if (strlast (filename) == '/')
        return (FALSE);
    else
        return ((file_mode (filename) &amp; S_IREAD) != 0);
}
</PRE>
<A NAME="file_is_writeable">&nbsp;</A>
<H3><A NAME="TOC138"><TT>file_is_writeable</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_is_writeable (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the current process can write the specified
   file or directory. The filename may end in a slash (/ or \)
   only if it is a directory.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    ASSERT (filename);

    if (<A href="sfldoc.htm#file_is_directory">file is directory</A> (filename))
        return ((file_mode (<A href="sfldoc.htm#clean_path">clean path</A> (filename)) &amp; S_IWRITE) != 0);
    else
    if (strlast (filename) == '/')
        return (FALSE);
    else
        return ((file_mode (filename) &amp; S_IREAD) != 0);
}
</PRE>
<A NAME="file_is_executable">&nbsp;</A>
<H3><A NAME="TOC139"><TT>file_is_executable</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_is_executable (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the current process can execute the specified
   file. Directories are _not_ considered to be executable. Under
   DOS, Windows, appends ".com", ".exe", and ".bat" to the
   filename, in that order, to build a possible executable
   filename. If this fails, opens the file (if it exists) and
   examines the first few bytes of the file: if these are "#!", or
   '/'*! or "MZ" then the file is assumed to be executable. #! is
   a standard mechanism under Unix for indicating executable
   files. Note that <A href="sfldoc.htm#process_create">process create</A>() uses a compatible
   mechanism to launch the correct interpreter for such
   'executable' scripts. NOTE: '/'*! is provided for REXX. [XXX]
   Under OS/2 appends ".exe" and ".cmd" to the filename, in that
   order, to be a possible executable filename. If this fails, it
   opens the file (if it exists) and examines the first few bytes
   of the file: if these are "#!" then the file is assumed to be
   executable. NOTE: REXX scripts MUST be in files named
   script.cmd in order to be found. BAT files are not considered,
   nor are COM files, since at present process_create does not
   support launching DOS processes. Under VMS, appends .exe and
   .com, in that order to build a possible executable filename.
   Does not search the PATH symbol; the filename must be specified
   with a path if necessary.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
#if (defined (__UNIX__))
    ASSERT (filename);

    return ((file_mode (filename) &amp; S_IEXEC) != 0
         &amp;&amp; (file_mode (filename) &amp; S_IFDIR) == 0);

#elif (defined (MSDOS_FILESYSTEM))
    Bool
        executable;                     /*  Return code                      */
    FILE
        *stream;                        /*  Opened file stream               */
    char
        input_char = 0,                 /*  First and second bytes of file   */
        *extension;                     /*  File extension, if any           */

    ASSERT (filename);

    /*  Find file extension; if not found, set extension to empty string     */
    extension = strrchr (filename, '.');
    if (extension == NULL
    ||  strchr (extension, '/')         /*  If last '.' is part of the path  */
    ||  strchr (extension, '\\'))       /*  then the filename has no ext.    */
        extension = "";

    /*  Windows: If extension is .exe/.com/.bat, the file is an executable   */
    /*  OS/2:    If the extension is .exe/.cmd, the file is an executable    */
#if (defined ( __OS2__))
    if (<A href="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".exe") == 0
    ||  <A href="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".cmd") == 0)
#else /* DOS, WINDOWS */
    if (<A href="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".com") == 0
    ||  <A href="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".exe") == 0
    ||  <A href="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".bat") == 0)
#endif
        executable = <A href="sfldoc.htm#file_exists">file exists</A> (filename);
    else
    /*  Windows: If the extension is empty, try .com, .exe, .bat             */
    /*  OS/2:    If the extension is empty, try .exe, .cmd                   */
    if (strnull (extension)
#if (defined( __OS2__))
    &amp;&amp; (<A href="sfldoc.htm#file_exists">file exists</A> (<A href="sfldoc.htm#default_extension">default extension</A> (work_name, filename, "exe"))
    ||  <A href="sfldoc.htm#file_exists">file exists</A> (<A href="sfldoc.htm#default_extension">default extension</A> (work_name, filename, "cmd"))))
#else /* DOS, WINDOWS */
    &amp;&amp; (<A href="sfldoc.htm#file_exists">file exists</A> (<A href="sfldoc.htm#default_extension">default extension</A> (work_name, filename, "com"))
    ||  <A href="sfldoc.htm#file_exists">file exists</A> (<A href="sfldoc.htm#default_extension">default extension</A> (work_name, filename, "exe"))
    ||  <A href="sfldoc.htm#file_exists">file exists</A> (<A href="sfldoc.htm#default_extension">default extension</A> (work_name, filename, "bat"))))
#endif
        executable = TRUE;              /*  Executable file found            */
    else
      {
        /*  Look for magic header at start of file                           */
        stream = <A href="sfldoc.htm#file_open">file open</A> (filename, 'r');
        if (stream)
          {
            input_char = fgetc (stream);
            executable = ((input_char == '#' &amp;&amp; fgetc (stream) == '!')
#   if (defined (__WINDOWS__))
                       || (input_char == '/' &amp;&amp; fgetc (stream) == '*'
                                             &amp;&amp; fgetc (stream) == '!')
                       || (input_char == 'M' &amp;&amp; fgetc (stream) == 'Z')
#   endif
                       );
            <A href="sfldoc.htm#file_close">file close</A> (stream);
          }
        else
            executable = FALSE;
      }
    return (executable);

#elif (defined (__VMS__))
    Bool
        executable;                     /*  Return code                      */
    char
        *extension;                     /*  File extension, if any           */

    ASSERT (filename);

    /*  Find file extension, if any                                          */
    extension = strrchr (filename, '.');
    if ((file_mode (filename) &amp; S_IEXEC) != 0)
        executable = TRUE;
    else
    /*  If the extension is empty, try .exe and .com                         */
    if (!extension)
      {
        <A href="sfldoc.htm#default_extension">default extension</A> (work_name, filename, "exe");
        if ((file_mode (work_name) &amp; S_IEXEC) != 0)
            executable = TRUE;
        else
          {
            <A href="sfldoc.htm#default_extension">default extension</A> (work_name, filename, "com");
            if ((file_mode (work_name) &amp; S_IEXEC) != 0)
                executable = TRUE;
            else
                executable = FALSE;
          }
      }
    else
        executable = FALSE;

    return (executable);

#else
    return (FALSE);                     /*  Not supported on this system     */
#endif
}
</PRE>
<A NAME="file_is_program">&nbsp;</A>
<H3><A NAME="TOC140"><TT>file_is_program</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_is_program (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the specified filename is an executable program
   on the PATH. Under DOS, and Windows, appends ".exe", ".com" to
   the file, in that order, to build an executable filename, then
   searches the PATH definition for the executable filename. Under
   OS/2, appends ".exe" to the file to build an executable
   filename, then searches the PATH definition for the executable
   filename. If the filename already has a path specifier, will
   not use the PATH definition. Under VMS, appends "exe" and "com"
   to the file, in that order, to build an executable filename.
   Searches the PATH if necessary.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    Bool
        executable = FALSE;             /*  Return code                      */

#if (defined (__UNIX__))
    char
        *found_file;

    ASSERT (filename);

    found_file = <A href="sfldoc.htm#file_where">file where</A> ('r', "PATH", filename, "");
    if (found_file &amp;&amp; (file_mode (found_file) &amp; S_IEXEC))
        executable = TRUE;              /*  Executable file found            */

#elif (defined (__VMS__))
    char
        *found_file;

    ASSERT (filename);

    found_file = <A href="sfldoc.htm#file_where">file where</A> ('r', "PATH", filename, "");
    if (!found_file)
        found_file = <A href="sfldoc.htm#file_where">file where</A> ('r', "PATH", filename, ".exe");
    if (!found_file)
        found_file = <A href="sfldoc.htm#file_where">file where</A> ('r', "PATH", filename, ".com");

    if (found_file &amp;&amp; (file_mode (found_file) &amp; S_IEXEC))
        executable = TRUE;              /*  Executable file found            */

#elif (defined (MSDOS_FILESYSTEM))
    char
        *path;                          /*  What path do we search?          */

    ASSERT (filename);
    /*  If the filename already contains a path, don't look at PATH          */
    if (strchr (filename, '/') || strchr (filename, '\\'))
        path = NULL;
    else
        path = "PATH";

#   if (defined (__WINDOWS__))
    if (<A href="sfldoc.htm#file_where">file where</A> ('r', path, filename, ".exe")
    ||  <A href="sfldoc.htm#file_where">file where</A> ('r', path, filename, ".com")
    ||  <A href="sfldoc.htm#file_where">file where</A> ('r', path, filename, ".bat"))
        executable = TRUE;              /*  Executable file found            */

#   else /* OS/2 */
    if (<A href="sfldoc.htm#file_where">file where</A> ('r', path, filename, ".exe"))
        executable = TRUE;
#   endif
#endif

    return (executable);
}
</PRE>
<A NAME="file_is_directory">&nbsp;</A>
<H3><A NAME="TOC141"><TT>file_is_directory</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_is_directory (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the specified file is a directory. The filename
   may end in a slash (/ or \). Under MS-DOS/OS2/Windows, a
   directory name may consist solely of a disk-drive specifier.
   Under VMS the directory may optionally take the extension
   '.dir'.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    char
        *dir_name;
    Bool
        rc;

    ASSERT (filename);

    dir_name = mem_strdup (<A href="sfldoc.htm#clean_path">clean path</A> (filename));
#if (defined (__VMS__))
    if (!<A href="sfldoc.htm#file_exists">file exists</A> (dir_name))
        <A href="sfldoc.htm#default_extension">default extension</A> (dir_name, dir_name, "dir");
#endif
    rc = (file_mode (dir_name) &amp; S_IFDIR) != 0;
    mem_free (dir_name);
    return (rc);
}
</PRE>
<A NAME="file_is_legal">&nbsp;</A>
<H3><A NAME="TOC142"><TT>file_is_legal</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_is_legal (
    const char *arg_filename)
</PRE>
<H4>Synopsis</H4>
<P>Checks whether the specified file is 'legal', which is a
   system-dependent definition. Under 32-bit Windows, a legal file
   is one who's name is not a shortened 8.3 version of a long
   name. This can be used to bypass filename-based security
   schemes. On other systems, the notion of 'illegal' is not
   defined. Returns TRUE if the file exists and is legal. Returns
   FALSE otherwise.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
#if (defined (WIN32))
    static WIN32_FIND_DATA
        found;
    HANDLE
        handle;
    char
        *filename,                      /*  Our copy of arg_filename         */
        *slash,                         /*  Position of '\' in filename      */
        *component;                     /*  Component to compare             */
    Bool
        feedback;                       /*  Function feedback                */

    /*  For each path component of the filename, check that the long form
     *  of the name is the same as the short form.  We scan backwards
     *  from the end of the filename, get the full pathname, and compare
     *  the last component each time:
     *
     *      aaa\bbb\ccc\name.ext    name.ext
     *      aaa\bbb\ccc             ccc
     *      aaa\bbb                 bbb
     *      aaa                     aaa
     */

    if (system_devicename (arg_filename))
        return (FALSE);                 /*  Not allowed on device names      */

    filename = mem_strdup (arg_filename);
    feedback = TRUE;                    /*  Assume we match everything       */
    <A href="sfldoc.htm#strconvch">strconvch</A> (filename, '/', '\\');
    if (strlast (filename) == '\\')
        strlast (filename) = '\0';      /*  Drop any trailing slash          */

    do
      {
        slash     = strrchr (filename, '\\');
        component = slash? slash + 1: filename;
        handle    = FindFirstFile (filename, &amp;found);

        if (handle != INVALID_HANDLE_VALUE
        &amp;&amp;  <A href="sfldoc.htm#lexcmp">lexcmp</A> (component, found.cFileName))
          {
            feedback = FALSE;
            break;
          }
        FindClose (handle);
        if (slash)
          {
            *slash = '\0';              /*  Cut filename at slash            */
            if (filename [1] == ':'
            &amp;&amp;  filename [2] == '\0')   /*  We're at a disk specifier        */
                break;                  /*    which is okay by now           */
          }
      }
    while (slash &amp;&amp; *filename);
    mem_free (filename);
    return (feedback);

#else
    return (TRUE);               /*  On other OSes, all filenames are legal  */
#endif
}
</PRE>
<A NAME="file_exec_name">&nbsp;</A>
<H3><A NAME="TOC143"><TT>file_exec_name</TT></A></H3>
<PRE>
#include "sflfile.h"
char *
file_exec_name (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>If the specified filename is an executable program, formats a
   filename including any required extension and returns a static
   string with that value. If the specified filename is not an
   executable program, returns NULL. Under DOS, and Windows,
   appends ".com", ".exe", and ".bat" to the filename, in that
   order, to build a possible executable filename. Under OS/2,
   appends ".exe", and ".cmd" to the filename, in that order, to
   build a possible executable filename. If this fails, returns
   NULL. Does not search the PATH symbol; the filename must be
   specified with a path if necessary. The returned filename (if
   not NULL) points to a static string.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
#if (defined (__UNIX__) || defined (__VMS__))
    ASSERT (filename);

    strcpy (exec_name, filename);

    if (file_mode (exec_name) &amp; S_IEXEC)
        return (exec_name);
    else
        return (NULL);

#elif (defined (MSDOS_FILESYSTEM))
    char
        *extension;                     /*  File extension, if any           */

    ASSERT (filename);

    /*  Find file extension; if not found, set extension to empty string     */
    extension = strrchr (filename, '.');
    if (extension == NULL
    ||  strchr (extension, '/')         /*  If last '.' is part of the path  */
    ||  strchr (extension, '\\'))       /*  then the filename has no ext.    */
        extension = "";

    /*  Windows: If extension is .exe/.com/.bat, the file is an executable   */
    /*  OS/2:    If extension is .exe/.cmd, the file is executable           */
#   if (defined (__OS2__))
    if (<A href="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".exe") == 0
    ||  <A href="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".cmd") == 0
#   else /* DOS, WINDOWS */
    if (<A href="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".com") == 0
    ||  <A href="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".exe") == 0
    ||  <A href="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".bat") == 0
#     if (defined (__WINDOWS__))
    ||  is_exe_file (filename)
#     endif
#   endif
    )
      {
        strcpy (exec_name, filename);
        return (exec_name);
      }
    else
    /*  Windows: If the extension is empty, try .com, .exe, .bat             */
    /*  OS/2:    If the extension is empty, try .exe, .cmd                   */
    if (strnull (extension)
#   if (defined (__OS2__))
    &amp;&amp; (<A href="sfldoc.htm#file_exists">file exists</A> (<A href="sfldoc.htm#default_extension">default extension</A> (exec_name, filename, "exe"))
    ||  <A href="sfldoc.htm#file_exists">file exists</A> (<A href="sfldoc.htm#default_extension">default extension</A> (exec_name, filename, "cmd"))))
#   else /* DOS, WINDOWS */
    &amp;&amp; (<A href="sfldoc.htm#file_exists">file exists</A> (<A href="sfldoc.htm#default_extension">default extension</A> (exec_name, filename, "com"))
    ||  <A href="sfldoc.htm#file_exists">file exists</A> (<A href="sfldoc.htm#default_extension">default extension</A> (exec_name, filename, "exe"))
    ||  <A href="sfldoc.htm#file_exists">file exists</A> (<A href="sfldoc.htm#default_extension">default extension</A> (exec_name, filename, "bat"))))
#   endif
        return (exec_name);             /*  Executable file found            */
    else
        return (NULL);
#else
    return (NULL);                      /*  Not supported on this system     */
#endif
}
</PRE>
<A NAME="get_file_size">&nbsp;</A>
<H3><A NAME="TOC144"><TT>get_file_size</TT></A></H3>
<PRE>
#include "sflfile.h"
long
get_file_size (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Returns the size, in bytes, of the specified file or directory.
   The size of a directory is not a portable concept. If there is
   an error, returns -1.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    struct stat
        stat_buf;

    ASSERT (filename);

#   if (defined (MSDOS_FILESYSTEM))
    if (system_devicename (filename))
        return (-1);                    /*  Not allowed on device names      */
#   endif
    if (stat ((char *) filename, &amp;stat_buf) == 0)
        return ((long) stat_buf.st_size);
    else
        return (-1);
}
</PRE>
<A NAME="get_file_time">&nbsp;</A>
<H3><A NAME="TOC145"><TT>get_file_time</TT></A></H3>
<PRE>
#include "sflfile.h"
time_t
get_file_time (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Returns the modification time of the specified file or
   directory. The returned time is suitable for feeding to
   localtime().
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
#if (defined (WIN32_NOT_IMPLEMENTED))
    /*  This code has been disactivated because it returns incorrect
        values depending on the seasonal clock change.
     */
    unsigned long thi,tlo;
    double  dthi,dtlo;
    double  secs_since_1601, secs_time_t;
    double  delta = 11644473600.;
    double  two_to_32 = 4294967296.;
    HANDLE  handle;
    FILETIME creation, last_access, last_write;

    handle = CreateFile (filename, GENERIC_READ, FILE_SHARE_WRITE,
                         NULL, OPEN_EXISTING, 0, 0);
    if (handle == INVALID_HANDLE_VALUE)
        return (0);
    GetFileTime (handle, &amp;creation, &amp;last_access, &amp;last_write);
    CloseHandle (handle);
    thi = last_write.dwHighDateTime;
    tlo = last_write.dwLowDateTime;
    dthi = (double) thi;
    dtlo = (double) tlo;
    secs_since_1601 = (dthi * two_to_32 + dtlo) / 1.0e7;
    secs_time_t     = secs_since_1601 - delta;
    return ((time_t) secs_time_t);

#else
    struct stat
        stat_buf;

    ASSERT (filename);

#   if (defined (MSDOS_FILESYSTEM))
    if (system_devicename (filename))
        return (0);                     /*  Not allowed on device names      */
#   endif
    if (stat ((char *) filename, &amp;stat_buf) == 0)
        return (stat_buf.st_mtime &gt; 0? stat_buf.st_mtime: 0);
    else
        return (0);
#endif
}
</PRE>
<A NAME="get_file_lines">&nbsp;</A>
<H3><A NAME="TOC146"><TT>get_file_lines</TT></A></H3>
<PRE>
#include "sflfile.h"
long
get_file_lines (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Reads an entire file, and returns the number of lines in the
   file. The file should be normal text. Returns 0 if the file
   cannot be opened for reading. May be a bit slow on large files.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    long
        file_size;
    FILE
        *file_stream;
    int
        ch;

    ASSERT (filename);

    file_stream = <A href="sfldoc.htm#file_open">file open</A> (filename, 'r');
    if (file_stream == NULL)
        return (0);

    file_size = 0;
    while ((ch = fgetc (file_stream)) != EOF)
        if (ch == '\n')
            file_size++;

    fclose (file_stream);
    return (file_size);
}
</PRE>
<A NAME="file_slurp">&nbsp;</A>
<H3><A NAME="TOC147"><TT>file_slurp</TT></A></H3>
<PRE>
#include "sflfile.h"
DESCR *
file_slurp (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Reads an entire file, and returns a DESCR containing the file
   data. The file is read as binary data. The returned DESCR
   should be freed using the mem_free() call. if the file is &gt;
   64K long, only the first 64K bytes are read into memory. This
   is to stop really silly things from happening. Returns NULL if
   the file cannot be found. Appends a null byte to the data in
   any case.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    return (file_load_data (filename, 65535UL));
}
</PRE>
<A NAME="file_slurpl">&nbsp;</A>
<H3><A NAME="TOC148"><TT>file_slurpl</TT></A></H3>
<PRE>
#include "sflfile.h"
DESCR *
file_slurpl (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Reads an entire file, and returns a DESCR containing the file
   data. The file is read as binary data. The returned DESCR
   should be freed using the mem_free() call. Does not impose any
   limit on the size of the file (unlike <A href="sfldoc.htm#file_slurp">file slurp</A>() which
   stops at 64K bytes). Returns NULL if the file cannot be found.
   Appends a null byte to the data in any case.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    return (file_load_data (filename, 0));
}
</PRE>
<A NAME="file_set_eoln">&nbsp;</A>
<H3><A NAME="TOC149"><TT>file_set_eoln</TT></A></H3>
<PRE>
#include "sflfile.h"
dbyte
file_set_eoln (char *dst, const char *src, dbyte src_size, Bool add_cr)
</PRE>
<H4>Synopsis</H4>
<P>Formats any end-of-line sequences in the buffer according to
   the value of the add_cr argument. If this is TRUE, all end-of-
   lines (LF or CRLF or LFCR) are represented by a CRLF sequence.
   If FALSE, all end-of-lines are represented by LF by itself. The
   target buffer must be large enough to accomodate the resulting
   line (twice the size of the source data). Returns the size of
   the resulting data in the target buffer not counting the final
   trailing null byte. The input data does not need to be null-
   terminated, but the output data is terminated with an extra
   null in any case.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    char
        *srcptr,                        /*  Current character in src         */
        *dstptr,                        /*  Current character in dst         */
        *last;                          /*  Last character in src            */

    ASSERT (src);
    ASSERT (dst);

    srcptr = (char *) src;
    dstptr = dst;
    last   = (char *) src + src_size;

    while (*srcptr &amp;&amp; srcptr &lt; last)
      {
        if (*srcptr == '\n')
          {
            if (add_cr)
                *dstptr++ = '\r';
            *dstptr++ = '\n';
          }
        else
        if (*srcptr != '\r' &amp;&amp; *srcptr != 26)
            *dstptr++ = *srcptr;
        srcptr++;
      }
    *dstptr = '\0';
    return ((dbyte) (dstptr - dst));
}
</PRE>
<A NAME="get_tmp_file_name">&nbsp;</A>
<H3><A NAME="TOC150"><TT>get_tmp_file_name</TT></A></H3>
<PRE>
#include "sflfile.h"
char *
get_tmp_file_name (const char *path, qbyte *index, const char *ext)
</PRE>
<H4>Synopsis</H4>
<P>Get a temporary file name. The filename is allocated as a fresh
   string, which the calling program must free when finished.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    char
        index_str [9],                  /*  Formatted 8-hex digit value      */
        *filename = NULL;
    do
      {
        mem_strfree (&amp;filename);
        sprintf (index_str, "%08lX", *index);
        if (path)
            filename = <A href="sfldoc.htm#xstrcpy">xstrcpy</A> (NULL, path, "/", index_str, ".", ext, NULL);
        else
            filename = <A href="sfldoc.htm#xstrcpy">xstrcpy</A> (NULL, index_str, ".", ext, NULL);
        (*index)++;
      }
    while (<A href="sfldoc.htm#file_exists">file exists</A> (filename));
    return (filename);
}
</PRE>
<A NAME="file_fhredirect">&nbsp;</A>
<H3><A NAME="TOC151"><TT>file_fhredirect</TT></A></H3>
<PRE>
#include "sflfile.h"
int
file_fhredirect (int source, int dest)
</PRE>
<H4>Synopsis</H4>
<P>Duplicates the dest file handle to a safe location (saves a
   backup copy of it. Then duplicates the source file handle into
   the dest. Returns the backup of the original dest, which can be
   used to undo the redirection later. Returns -1 if there were
   errors.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    int
        dupe_file_handle = 0;

    dupe_file_handle = dup (dest);
    if (dupe_file_handle &lt; 0)
        return (-1);                    /*  Cannot acomplish redirection     */

    /*  Let dup2() close dest (if open) if duplication suceeds               */
    if (dup2 (source, dest) &lt; 0)
      {
        close (dupe_file_handle);       /*  Close unneeded duplicate         */
        return (-1);                    /*  Cannot accomplish redirection    */
      }
    return (dupe_file_handle);          /*  Return copy of file handle       */
}
</PRE>
<A NAME="file_fhrestore">&nbsp;</A>
<H3><A NAME="TOC152"><TT>file_fhrestore</TT></A></H3>
<PRE>
#include "sflfile.h"
void
file_fhrestore (int source, int dest)
</PRE>
<H4>Synopsis</H4>
<P>Restores a file handle redirection done by
   <A href="sfldoc.htm#file_fhredirect">file fhredirect</A>(). Supply the saved file handle (returned
   by file_fhdirect()) and the same destination file handle.
   Ignores a source less than zero (invalid or not set).
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    if (source &gt;= 0)
      {
        dup2 (source, dest);
        if (source != dest)
           close (source);
      }
}
</PRE>
<A NAME="ftmp_open">&nbsp;</A>
<H3><A NAME="TOC153"><TT>ftmp_open</TT></A></H3>
<PRE>
#include "sflfile.h"
FILE *
ftmp_open (char **pathname)
</PRE>
<H4>Synopsis</H4>
<P>Creates a temporary file, like the tmpfile() function, but
   without the problem under some systems where tmpfile() will try
   to create temporary files on read-only drives. If the pathname
   argument is not null, allocates a copy of the full filename
   used for the temporary file and passes this back in the
   pathname argument.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    static qbyte
        file_number = 0;                /*  We generate unique file names    */
    FILE
        *tempstream;
    char
        *tempdir,
        *tempfile;
    FTMPITEM
        *tempitem;

#if (defined (MSDOS_FILESYSTEM))
    tempdir = <A href="sfldoc.htm#env_get_string">env get string</A>  ("TEMP", NULL);
    if (!tempdir)
        tempdir = <A href="sfldoc.htm#env_get_string">env get string</A>  ("TMP", NULL);
    if (!tempdir)
        tempdir = ".";

#elif (defined (__UNIX__))
    tempdir = <A href="sfldoc.htm#env_get_string">env get string</A>  ("TMPDIR", NULL);
    if (!tempdir)
        tempdir = "/tmp";

#else
    tempdir = <A href="sfldoc.htm#env_get_string">env get string</A>  ("TMPDIR", NULL);
    if (!tempdir)
        tempdir = ".";
#endif
    if (file_number == 0)
      {
        randomize ();
        file_number = random (32767);
      }
    tempfile = <A href="sfldoc.htm#get_tmp_file_name">get tmp file name</A> (tempdir, &amp;file_number, "tmp");
    if (pathname)
        *pathname = mem_strdup (tempfile);

    tempstream = fopen (tempfile, "wb");
    if (tempstream)
      {
        list_create (tempitem, sizeof (FTMPITEM));
        list_relink_before (&amp;ftmplist, tempitem);
        tempitem-&gt; stream   = tempstream;
        tempitem-&gt; filename = tempfile;
      }
    else
        mem_free (tempfile);

    return (tempstream);
}
</PRE>
<A NAME="ftmp_close">&nbsp;</A>
<H3><A NAME="TOC154"><TT>ftmp_close</TT></A></H3>
<PRE>
#include "sflfile.h"
void
ftmp_close (FILE *tempstream)
</PRE>
<H4>Synopsis</H4>
<P>Closes a temporary file created by <A href="sfldoc.htm#ftmp_open">ftmp open</A>(). The file is
   closed and deleted.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    FTMPITEM
        *tempitem;

    ASSERT (tempstream);
    fclose (tempstream);

    /*  Find the matching tempitem node and release all resources            */
    FORLIST (tempitem, ftmplist)
      {
        if (tempitem-&gt; stream == tempstream)
          {
            <A href="sfldoc.htm#file_delete">file delete</A> (tempitem-&gt; filename);
            mem_free (tempitem-&gt; filename);
            <A href="sfldoc.htm#list_unlink">list unlink</A> (tempitem);
            mem_free (tempitem);
            break;
          }
      }
}
</PRE>
<H2><A NAME="TOC155">Fortune-cookie functions</A></H2>
<P>Filename: sflfort.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1999/08/16 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1999/08/27
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Provides functions to create compressed or simple fortune
   cookie files, and functions to read from such files.
<H4>List of Functions</H4>
<UL>
<LI>int <A href="sfldoc.htm#fortune_build">fortune build</A><BR>
   (const char *in, const char *out, Bool compress);
</LI>
<LI>char * <A href="sfldoc.htm#fortune_read">fortune read</A><BR>
   (const char *fortune_file);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflfort.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>SFLFORT_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="fortune_build">&nbsp;</A>
<H3><A NAME="TOC156"><TT>fortune_build</TT></A></H3>
<PRE>
#include "sflfort.h"
int
fortune_build (
    const char *infile,                 /*  Name of file to compress         */
    const char *outfile,                /*  Output file, created             */
    Bool        compress)               /*  Compress yes/no                  */
</PRE>
<H4>Synopsis</H4>
<P>Builds an indexed fortune file from a formatted text file. The
   text file contains paragraphs separated by lines containing
   '%%'. If okay, returns 0, else returns -1, see errno for the
   cause.
<H4>Source Code - (sflfort.c)</H4>
<PRE>
{
    char
        line [LINE_MAX + 1];            /*  Line from input file             */
    int
        block_nbr;
    long
        offset;

    inbuf   = mem_alloc (BLOCK_SIZE);
    outbuf  = mem_alloc (BLOCK_SIZE);
    sizes   = mem_alloc (MAX_BLOCKS * sizeof (int));
    input   = <A href="sfldoc.htm#file_open">file open</A> (infile, 'r');
    scratch = <A href="sfldoc.htm#ftmp_open">ftmp open</A> (NULL);

    if (!inbuf || !outbuf || !sizes || !input || !scratch)
      {
        mem_free (inbuf);
        mem_free (outbuf);
        mem_free (sizes);
        return (-1);
      }

    nbr_blocks = 0;
    nbr_paras  = 0;                     /*  Number of paragraphs in block    */
    insize     = 2;                     /*  Leave room for nbr_paras         */

    while (<A href="sfldoc.htm#file_read">file read</A> (input, line))
      {
        if (streq (line, "%%"))
            have_end_of_paragraph (compress);
        else
          {
            memcpy (inbuf + insize, line, strlen (line));
            insize += strlen (line);
            inbuf [insize++] = '\n';
          }
      }
    have_end_of_paragraph (compress);
    if (nbr_paras)
        have_end_of_block (compress);

    fclose (input);                     /*  Finished with input file         */

    output = fopen (outfile, "wb");
    fprintf (output, "IFF%s -- http://www.imatix.com/ --\n%c",
                     compress? "CMP": "TXT", 26);

    output_dbyte = htons (nbr_blocks);
    fwrite (&amp;output_dbyte, 2, 1, output);
    offset = ftell (output) + nbr_blocks * 4;

    for (block_nbr = 0; block_nbr &lt; nbr_blocks; block_nbr++)
      {
        output_qbyte = htonl (offset);
        fwrite (&amp;output_qbyte, 4, 1, output);
        offset += sizes [block_nbr];
      }
    fseek (scratch, 0, SEEK_SET);       /*  Back to start of scratch file    */
    while ((outsize = fread (outbuf, 1, BLOCK_SIZE, scratch)) != 0)
        fwrite (outbuf, 1, outsize, output);

    <A href="sfldoc.htm#file_close">file close</A> (output);
    <A href="sfldoc.htm#ftmp_close">ftmp close</A> (scratch);
    mem_free (sizes);
    mem_free (inbuf);
    mem_free (outbuf);

    return (0);                         /*  No errors                        */
}
</PRE>
<A NAME="fortune_read">&nbsp;</A>
<H3><A NAME="TOC157"><TT>fortune_read</TT></A></H3>
<PRE>
#include "sflfort.h"
char *
fortune_read (const char *fortune_file)
</PRE>
<H4>Synopsis</H4>
<P>Reads a random paragraph from the specified fortune file. The
   fortune file is located in the current directory or on the
   current path. The paragraph of text is returned in a freshly-
   allocated block of memory that you should free afterwards using
   mem_free(). Returns NULL if the fortune file could not be
   opened.
<H4>Source Code - (sflfort.c)</H4>
<PRE>
{
    static Bool
        first_time = TRUE;
    FILE
        *fortunes;                      /*  FFF input stream                 */
    byte
        *inbuf,                         /*  Block read from file             */
        *outbuf;                        /*  And after decompression          */
    int
        nbr_blocks,                     /*  Number of blocks in data file    */
        nbr_paras,                      /*  Number of paragraphs in block    */
        paragraph;
    dbyte
        input_dbyte,
        block_size;                     /*  Size of current block            */
    qbyte
        input_qbyte,
        block_offset;                   /*  Offset of block in file          */
    char
        *para_start;                    /*  Start of paragraph               */
    Bool
        compressed;                     /*  Compressed fortune data?         */

    /*  Initialise random-number generator if necessary                      */
    if (first_time)
      {
        randomize ();
        first_time = FALSE;
      }

    /*  Look for fortunes file                                               */
    fortunes = <A href="sfldoc.htm#file_locate">file locate</A> ("PATH", fortune_file, NULL);
    if (fortunes == NULL)
        return (NULL);

    /*  Allocate working buffers                                             */
    inbuf  = mem_alloc (BLOCK_SIZE);
    outbuf = mem_alloc (BLOCK_SIZE);
    if (inbuf == NULL || outbuf == NULL)
      {
        mem_free (inbuf);
        mem_free (outbuf);
        return (NULL);
      }

    /*  Indexed Fortune File format starts with IFFCMP or IFFTXT             */
    <A href="sfldoc.htm#file_read">file read</A> (fortunes, (char *) inbuf);
    if (memcpy (inbuf, "IFFTXT", 6) == 0)
        compressed = FALSE;
    else
        compressed = TRUE;

    while (fgetc (fortunes) != 26);     /*  Skip past file header            */

    /*  Get total number of blocks in file                                   */
    fread (&amp;input_dbyte, 2, 1, fortunes);
    nbr_blocks = ntohs (input_dbyte);

    /*  Look at random block address in Toc                                  */
    fseek (fortunes, random (nbr_blocks) * 4, SEEK_CUR);
    fread (&amp;input_qbyte, 4, 1, fortunes);
    block_offset = ntohl (input_qbyte);

    /*  Go read, then decompress the block                                   */
    fseek (fortunes, block_offset, SEEK_SET);
    fread (&amp;input_dbyte, 2, 1, fortunes);
    block_size = ntohs (input_dbyte);

    if (compressed)
      {
        fread (inbuf, 1, block_size, fortunes);
        <A href="sfldoc.htm#expand_block">expand block</A> (inbuf, outbuf, block_size);
      }
    else
        fread (outbuf, 1, block_size, fortunes);

    /*  Chose random paragraph from block                                    */
    input_dbyte = *(dbyte *) outbuf;
    nbr_paras   = ntohs (input_dbyte);
    paragraph   = random (nbr_paras);
    para_start  = (char *) outbuf + 2;
    while (paragraph--)
        para_start = strchr (para_start, '\0') + 1;

    para_start = mem_strdup (para_start);

    /*  Release allocated memory                                             */
    fclose (fortunes);
    mem_free (inbuf);
    mem_free (outbuf);

    return (para_start);
}
</PRE>
<H2><A NAME="TOC158">Initialisation file access functions</A></H2>
<P>Filename: sflini.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1994/01/08 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1999/10/26
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Provides functions to read an initialisation file that follows
   the MS-Windows style, i.e. consists of [Sections] followed by
   keyword = value lines.
<H4>List of Functions</H4>
<UL>
<LI>Bool <A href="sfldoc.htm#ini_find_section">ini find section</A><BR>
   (FILE *inifile, char *section, Bool top);
</LI>
<LI>Bool <A href="sfldoc.htm#ini_scan_section">ini scan section</A><BR>
   (FILE *inifile, char **keyword, char **value);
</LI>
<LI>SYMTAB * <A href="sfldoc.htm#ini_dyn_load">ini dyn load</A><BR>
   (SYMTAB *symtab, const char *filename);
</LI>
<LI>SYMTAB * <A href="sfldoc.htm#ini_dyn_loade">ini dyn loade</A><BR>
   (SYMTAB *symtab, const char *filename);
</LI>
<LI>int <A href="sfldoc.htm#ini_dyn_save">ini dyn save</A><BR>
   (SYMTAB *symtab, const char *filename);
</LI>
<LI>Bool <A href="sfldoc.htm#ini_dyn_changed">ini dyn changed</A><BR>
   (SYMTAB *symtab);
</LI>
<LI>Bool <A href="sfldoc.htm#ini_dyn_refresh">ini dyn refresh</A><BR>
   (SYMTAB *symtab);
</LI>
<LI>char * <A href="sfldoc.htm#ini_dyn_value">ini dyn value</A><BR>
   (SYMTAB *symtab, const char *section, const char *keyword,
   const char *default_value);
</LI>
<LI>char * <A href="sfldoc.htm#ini_dyn_values">ini dyn values</A><BR>
   (SYMTAB *symtab, const char *section, const char *keyword,
   const char *default_value);
</LI>
<LI>char * <A href="UNDEF">ini dyn assume</A><BR>
   (SYMTAB *symtab, const char *section, const char *keyword,
   const char *default_value);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflini.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>SLFINI_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="ini_find_section">&nbsp;</A>
<H3><A NAME="TOC159"><TT>ini_find_section</TT></A></H3>
<PRE>
#include "sflini.h"
Bool
ini_find_section (
    FILE *inifile,
    char *section,
    Bool top)
</PRE>
<H4>Synopsis</H4>
<P> Finds a specific section in the ini file. An ini file contains
   lines as shown below. The section name can be any mix of upper
   or lowercase. You should open the ini file using file_open
   before you call this function. If the 'top' argument is TRUE,
   repositions to the start of the file before reading, else reads
   from the current file offset. Returns TRUE if the section was
   found, and positions on the line that follows the section.
   Returns FALSE if the section was not found, and positions at
   the end of the file.
<H4>Examples</H4>
<PRE>
    ;   comments like this, or
    #   comments like this if you prefer
    !   Text is echoed to console using trace()
    [Section]
        keyword = key_value; comments
        keyword = "key_value"; comments
        keyword = 'key_value'; comments
        ...
    [Section]
        keyword = key_value; comments
        ...
</PRE>
<H4>Source Code - (sflini.c)</H4>
<PRE>
{
    char
        *first;

    ASSERT (inifile != NULL);
    ASSERT (section != NULL);

    if (top)                            /*  Reposition at top if wanted      */
        fseek (inifile, 0, SEEK_SET);

    /*  Read through file until we find what we are looking for              */
    while (<A href="sfldoc.htm#file_read">file read</A> (inifile, iniline))
      {
        first = <A href="sfldoc.htm#strskp">strskp</A> (iniline);       /*  Skip leading spaces              */

        if (*first == ';' || *first == '#' || *first == 0)
            continue;                   /*  Comment line                     */
        else
        if (*first == '!')
          {
            first = <A href="sfldoc.htm#strskp">strskp</A> (first + 1);
            <A href="sfldoc.htm#trace">trace</A> (first);
          }
        else
        if (sscanf (first, "[%[^]]", ini_section) == 1
        &amp;&amp;  <A href="sfldoc.htm#lexcmp">lexcmp</A> (ini_section, section) == 0)
            return (TRUE);
      }
    return (FALSE);
}
</PRE>
<A NAME="ini_scan_section">&nbsp;</A>
<H3><A NAME="TOC160"><TT>ini_scan_section</TT></A></H3>
<PRE>
#include "sflini.h"
Bool
ini_scan_section (
    FILE *inifile,
    char **keyword,
    char **value)
</PRE>
<H4>Synopsis</H4>
<P> Scans the current section of the ini file, and returns a
   keyword and value if such was found. Returns the address of
   these values in the supplied arguments. The addresses point to
   static values that are overwritten with each call. Returns TRUE
   when a keyword/value pair is found. Returns FALSE if a new
   section name or end of file is found. In the first case, sets
   the keyword to the section name; in the second case sets the
   keyword to NULL. Ignores blank and comment lines, and lines
   that look like junk. Keyword and section names are returned as
   lower-case; values are returned exactly as specified in the ini
   file.
<H4>Source Code - (sflini.c)</H4>
<PRE>
{
    int
        remaining;                      /*  Space remaining in line buffer   */
    char
        *first,
        *valueptr,
        *lineptr;

    /*  Read through file until we find what we are looking for              */
    while (<A href="sfldoc.htm#file_read">file read</A> (inifile, iniline))
      {
        <A href="sfldoc.htm#strcrop">strcrop</A> (iniline);
        if (strnull (iniline))
            continue;                   /*  Skip empty lines                 */

        /*  Calculate space remaining in buffer after this line; we need to
         *  know this later if we start reading continuation lines.
         */
        remaining = LINE_MAX - strlen (iniline);

        first = <A href="sfldoc.htm#strskp">strskp</A> (iniline);       /*  Skip leading spaces              */
        if (*first == ';' || *first == '#' || *first == 0)
            continue;                   /*  Comment line                     */
        else
        if (*first == '!')
          {
            first = <A href="sfldoc.htm#strskp">strskp</A> (first + 1);
            <A href="sfldoc.htm#trace">trace</A> (first);
          }
        else                            /*  Have name = value                */
        if ((valueptr = strchr (first, '=')) != NULL)
          {
            *valueptr++ = '\0';
            strcpy (ini_keyword, <A href="sfldoc.htm#strcrop">strcrop</A> (<A href="sfldoc.htm#strlwc">strlwc</A> (first)));
            while (*valueptr == ' ')
                valueptr++;             /*    and leading spaces             */

            if (*valueptr == '"')
              {                         /*  Have value in quotes             */
                /*  Get continuation lines as necessary and possible         */
                first = &amp;strlast (valueptr);
                while (*first == '-' &amp;&amp; remaining &gt; 0)
                  {
                    if (!<A href="sfldoc.htm#file_readn">file readn</A> (inifile, first, remaining))
                        break;                  /*  Abrubt end of file       */
                    <A href="sfldoc.htm#strcrop">strcrop</A> (first);
                    remaining -= strlen (first) - 1;
                    first     += strlen (first) - 1;
                  }
                /*  Now find closing quote and terminate value there         */
                for (lineptr = valueptr + 1; *lineptr; lineptr++)
                  {
                    if (*lineptr == '\\')
                        lineptr++;      /*  Ignore next char                 */
                    else
                    if (*lineptr == '"')
                      {
                        lineptr [1] = '\0';
                        break;          /*  Closing quote, end of value      */
                      }
                  }
              }
            else
              {                         /*  Have unquoted value              */
                <A href="sfldoc.htm#strconvch">strconvch</A> (valueptr, ';', '\0');
                <A href="sfldoc.htm#strconvch">strconvch</A> (valueptr, '#', '\0');
              }
            <A href="sfldoc.htm#strcrop">strcrop</A> (valueptr);
            strcpy (ini_value, valueptr);
            *keyword = ini_keyword;
            *value   = ini_value;
            return (TRUE);              /*  Found keyword = value            */
          }
        else
        if (sscanf (first, "[%[^]]", ini_section) == 1)
          {
            *keyword = <A href="sfldoc.htm#strlwc">strlwc</A> (ini_section);
            *value   = NULL;
            return (FALSE);             /*  New section name                 */
          }
        else
        if (streq (first, "[]"))        /*  Allow empty section names        */
          {
            strcpy (ini_section, "");
            *keyword = ini_section;
            *value   = NULL;
            return (FALSE);             /*  New section name                 */
          }
      }
    *keyword = NULL;
    return (FALSE);                     /*  End of file                      */
}
</PRE>
<A NAME="ini_dyn_load">&nbsp;</A>
<H3><A NAME="TOC161"><TT>ini_dyn_load</TT></A></H3>
<PRE>
#include "sflini.h"
SYMTAB *
ini_dyn_load (
    SYMTAB *load_symtab,
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Loads the contents of an .ini file into a symbol table. If no
   symbol table is specified, creates a new symbol table. The ini
   file data is loaded as a set of symbols and values, where the
   symbol name is built from the section name and keyword like
   this: "section:keyword". The symbol name is always stored in
   lowercase, with no trailing spaces. If the same keyword occurs
   several times in a section, earlier symbols are overwritten.
   Ignores all comments and blank lines. Returns NULL if there is
   not enough memory. Stores these control variables in the symbol
   table if the table was freshly created or the file was loaded:
   <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>filename</B>  <TD
   ALIGN="LEFT">Name of input file <TR><TD
   ALIGN="LEFT"><B>filetime</B>  <TD ALIGN="LEFT">Time of input
   file, as 8-digit string "HHMMSSCC" <TR><TD
   ALIGN="LEFT"><B>filedate</B>  <TD ALIGN="LEFT">Date of input
   file, as 8-digit string "YYYYMMDD" </TABLE> Also creates a
   symbol for each section, with name equal to the section name,
   and value equal to an empty string. Looks for the .ini file on
   the current PATH. The table is sorted after loading.
<H4>Source Code - (sflini.c)</H4>
<PRE>
{
    FILE
        *inifile;
    SYMTAB
        *symtab,                        /*  Symbol table to populate         */
        *envtab;                        /*  Environment, as symbol table     */
    char
        *section = NULL,                /*  Filled as we scan through        */
        *keyword = NULL,                /*    the ini file                   */
        *value   = NULL,
        *fromptr,
        *toptr,
        *section_end;                   /*  Null byte at end of section      */

    ASSERT (filename);
    inifile = <A href="sfldoc.htm#file_locate">file locate</A> ("PATH", filename, NULL);

    if (load_symtab)                    /*  Use specified symbol table       */
        symtab = load_symtab;           /*    or create a new one            */
    else
      {
        symtab = <A href="sfldoc.htm#sym_create_table">sym create table</A> ();
        if (symtab == NULL)
            return (NULL);              /*  Quit if insufficient memory      */
      }
    /*  Store control variables in symbol table                              */
    if (inifile || load_symtab == NULL)
      {
        <A href="sfldoc.htm#sym_assume_symbol">sym assume symbol</A> (symtab, "filename", filename);
        snprintf (iniline, sizeof (iniline), "%ld",
	 	           <A href="sfldoc.htm#timer_to_date">timer to date</A> (<A href="sfldoc.htm#get_file_time">get file time</A> (filename)));
        <A href="sfldoc.htm#sym_assume_symbol">sym assume symbol</A> (symtab, "filedate", iniline);
        snprintf (iniline, sizeof (iniline), "%ld",
		           <A href="sfldoc.htm#timer_to_time">timer to time</A> (<A href="sfldoc.htm#get_file_time">get file time</A> (filename)));
        <A href="sfldoc.htm#sym_assume_symbol">sym assume symbol</A> (symtab, "filetime", iniline);
      }
    if (!inifile)
        return (symtab);                /*  File not found; empty table      */

    /*  Now load the ini file, starting from the beginning                   */
    envtab = <A href="sfldoc.htm#env2symb">env2symb</A> ();
    fseek (inifile, 0, SEEK_SET);
    FOREVER
      {
        if (<A href="sfldoc.htm#ini_scan_section">ini scan section</A> (inifile, &amp;keyword, &amp;value))
          {
            if (section)
              {
                section_end = strchr (section, '\0');
                ASSERT (section_end);
                <A href="sfldoc.htm#xstrcat">xstrcat</A> (section, ":", keyword, NULL);
                value = <A href="sfldoc.htm#tok_subst">tok subst</A> (value, envtab);

                /*  Handle value in quotes                                   */
                if (*value == '"')
                  {
                    /*  Unescape value if necessary                          */
                    if (strchr (value, '\\'))
                      {
                        toptr = value;
                        for (fromptr = value; *fromptr; fromptr++)
                          {
                            if (*fromptr == '\\')
                              {
                                fromptr++;
                                if (*fromptr == 'n')
                                    *toptr++ = '\n';
                                else
                                    *toptr++ = *fromptr;
                              }
                            else
                                *toptr++ = *fromptr;
                          }
                        *toptr = '\0';
                      }
                    strlast (value) = '\0';
                    <A href="sfldoc.htm#sym_assume_symbol">sym assume symbol</A> (symtab, section, value + 1);
                  }
                else
                    <A href="sfldoc.htm#sym_assume_symbol">sym assume symbol</A> (symtab, section, value);

                mem_strfree (&amp;value);
                *section_end = '\0';
              }
          }
        else
        if (keyword)                    /*  Found new section                */
          {
            section = keyword;
            <A href="sfldoc.htm#sym_assume_symbol">sym assume symbol</A> (symtab, section, "");
          }
        else
            break;
      }
    <A href="sfldoc.htm#file_close">file close</A> (inifile);
    <A href="sfldoc.htm#sym_delete_table">sym delete table</A> (envtab);
    <A href="sfldoc.htm#sym_sort_table">sym sort table</A> (symtab, NULL);      /*  Sort table by symbol name        */
    return (symtab);
}
</PRE>
<A NAME="ini_dyn_loade">&nbsp;</A>
<H3><A NAME="TOC162"><TT>ini_dyn_loade</TT></A></H3>
<PRE>
#include "sflini.h"
SYMTAB *
ini_dyn_loade (
    SYMTAB *load_symtab,
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Loads the contents of an .ini file into a symbol table, as for
   <A href="sfldoc.htm#ini_dyn_load">ini dyn load</A>(), but requires that the .ini file exists.
   Returns a loaded symbol table if the file was present, and NULL
   otherwise.
<H4>Source Code - (sflini.c)</H4>
<PRE>
{
    ASSERT (filename);
    if (<A href="sfldoc.htm#file_locate">file locate</A> ("PATH", filename, NULL))
        return (<A href="sfldoc.htm#ini_dyn_load">ini dyn load</A> (load_symtab, filename));
    else
        return (NULL);
}
</PRE>
<A NAME="ini_dyn_save">&nbsp;</A>
<H3><A NAME="TOC163"><TT>ini_dyn_save</TT></A></H3>
<PRE>
#include "sflini.h"
int
ini_dyn_save (
    SYMTAB *symtab,
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Saves a symbol table to the specified file. The symbol table
   entries must be formatted as "section:name=value" - see
   <A href="sfldoc.htm#ini_dyn_load">ini dyn load</A>(). Scans the ini file for a line containing
   only "#*END", then writes the symbol data to the file from that
   point. Returns the number of symbols saved, or -1 if there was
   an error. As a side-effect, sorts the table on the symbol name.
<H4>Source Code - (sflini.c)</H4>
<PRE>
{
    FILE
        *inifile,
        *wrkfile;
    SYMBOL
        *symbol;                        /*  Next symbol in table             */
    Bool
        header_found;                   /*  Did we find a file header?       */
    int
        count;                          /*  How many symbols did we save?    */
    char
        *colon,                         /*  Points to ':' in symbol name     */
        *outchar,                       /*  Output character pointer         */
        *valchar;                       /*  Symbol value character pointer   */

    ASSERT (filename);
    ASSERT (symtab);

    /*  Copy ini file header to temporary file                               */
    wrkfile = <A href="sfldoc.htm#ftmp_open">ftmp open</A> (NULL);
    header_found = FALSE;
    if ((inifile = <A href="sfldoc.htm#file_open">file open</A> (filename, 'r')) != NULL)
      {
        while (<A href="sfldoc.htm#file_read">file read</A> (inifile, iniline))
          {
            if (streq (iniline, "#*END"))
              {
                header_found = TRUE;
                break;
              }
            <A href="sfldoc.htm#file_write">file write</A> (wrkfile, iniline);
          }
        <A href="sfldoc.htm#file_close">file close</A> (inifile);
      }
    /*  Now rewrite ini file                                                 */
    if ((inifile = <A href="sfldoc.htm#file_open">file open</A> (filename, 'w')) == NULL)
      {
        <A href="sfldoc.htm#ftmp_close">ftmp close</A> (wrkfile);
        return (-1);                    /*  No permission to write file      */
      }
    if (header_found)
      {
        fseek (wrkfile, 0, SEEK_SET);
        while (<A href="sfldoc.htm#file_read">file read</A> (wrkfile, iniline))
            <A href="sfldoc.htm#file_write">file write</A> (inifile, iniline);
      }
    <A href="sfldoc.htm#ftmp_close">ftmp close</A> (wrkfile);               /*  Finished with temporary file     */

    /*  Output ini file values                                               */
    <A href="sfldoc.htm#file_write">file write</A> (inifile, "#*END");
    strclr (ini_section);               /*  Current section                  */
    count = 0;

    <A href="sfldoc.htm#sym_sort_table">sym sort table</A> (symtab, NULL);      /*  Sort table by symbol name        */
    for (symbol = symtab-&gt; symbols; symbol; symbol = symbol-&gt; next)
      {
        /*  Output symbols formatted as key:name                             */
        colon = strrchr (symbol-&gt; name, ':');
        if (colon)
          {
            memcpy (ini_value, symbol-&gt; name, colon - symbol-&gt; name);
            ini_value [colon - symbol-&gt; name] = '\0';
            strcpy (ini_keyword, colon + 1);

            /*  If we start a new section, output the section header         */
            *ini_value   = toupper (*ini_value);
            *ini_keyword = toupper (*ini_keyword);
            if (strneq (ini_section, ini_value))
              {
                strcpy (ini_section, ini_value);
                snprintf (iniline, sizeof (iniline), "[%s]", ini_section);
                <A href="sfldoc.htm#file_write">file write</A> (inifile, "");
                <A href="sfldoc.htm#file_write">file write</A> (inifile, iniline);
              }
            /*  We always put quotes around values when writing              */
            snprintf (iniline, sizeof (iniline), "    %s = \"", ini_keyword);
            outchar = iniline + strlen (iniline);
            for (valchar = symbol-&gt; value; *valchar; valchar++)
              {
                /*  If line is too long, break it                            */
                if (outchar - iniline &gt; 75)
                  {
                    *outchar++ = '-';
                    *outchar++ = '\0';
                    <A href="sfldoc.htm#file_write">file write</A> (inifile, iniline);
                    strclr (iniline);
                    outchar = iniline;
                    continue;
                  }
                /*  Escape ", \, ( and newlines. We escape ( so that $(xxx)
                 *  in the value is not replaced on input.
                 */
                if (*valchar == '\n')
                  {
                    *outchar++ = '\\';
                    *outchar++ = 'n';
                  }
                else
                if (*valchar == '"'
                ||  *valchar == '\\'
                ||  *valchar == '(')
                  {
                    *outchar++ = '\\';
                    *outchar++ = *valchar;
                  }
                else
                    *outchar++ = *valchar;
              }
            *outchar++ = '"';
            *outchar++ = '\0';
            <A href="sfldoc.htm#file_write">file write</A> (inifile, iniline);
          }
      }
    <A href="sfldoc.htm#file_close">file close</A> (inifile);
    return (count);
}
</PRE>
<A NAME="ini_dyn_changed">&nbsp;</A>
<H3><A NAME="TOC164"><TT>ini_dyn_changed</TT></A></H3>
<PRE>
#include "sflini.h"
Bool
ini_dyn_changed (
    SYMTAB *symtab)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the ini file loaded into the specified table
   has in the meantime been changed. Returns FALSE if not.
<H4>Source Code - (sflini.c)</H4>
<PRE>
{
    char
        *filename;

    ASSERT (symtab);

    /*  Date, time, and name of original ini file are in the table           */
    filename = <A href="sfldoc.htm#sym_get_value">sym get value</A> (symtab, "filename", NULL);
    if (filename
    &amp;&amp;  <A href="sfldoc.htm#file_has_changed">file has changed</A> (filename,
                          <A href="sfldoc.htm#sym_get_number">sym get number</A> (symtab, "filedate", 0),
                          <A href="sfldoc.htm#sym_get_number">sym get number</A> (symtab, "filetime", 0)))
        return (TRUE);
    else
        return (FALSE);
}
</PRE>
<A NAME="ini_dyn_refresh">&nbsp;</A>
<H3><A NAME="TOC165"><TT>ini_dyn_refresh</TT></A></H3>
<PRE>
#include "sflini.h"
Bool
ini_dyn_refresh (
    SYMTAB *symtab)
</PRE>
<H4>Synopsis</H4>
<P>Refreshes a symbol table created by <A href="sfldoc.htm#ini_dyn_load">ini dyn load</A>(). If the
   original file (as specified by the 'filename' symbol) has been
   modified, reloads the whole ini file. You would typically call
   this function at regular intervals to permit automatic
   reloading of an ini file in an application. Returns TRUE if the
   ini file was actually reloaded, or FALSE if the file had not
   changed or could not be accessed, or if the symbol table was
   incorrectly created. If the symbol table is reloaded from the
   ini file, all previous symbols are deleted.
<H4>Source Code - (sflini.c)</H4>
<PRE>
{
    char
        *filename;

    ASSERT (symtab);
    if (<A href="sfldoc.htm#ini_dyn_changed">ini dyn changed</A> (symtab))
      {
        filename = mem_strdup (<A href="sfldoc.htm#sym_get_value">sym get value</A> (symtab, "filename", NULL));
        <A href="sfldoc.htm#sym_empty_table">sym empty table</A> (symtab);       /*  Delete previous table contents   */
        <A href="sfldoc.htm#ini_dyn_load">ini dyn load</A> (symtab, filename);
        mem_free (filename);
        return (TRUE);
      }
    return (FALSE);
}
</PRE>
<A NAME="ini_dyn_value">&nbsp;</A>
<H3><A NAME="TOC166"><TT>ini_dyn_value</TT></A></H3>
<PRE>
#include "sflini.h"
char *
ini_dyn_value (
    SYMTAB *symtab,
    const char *section,
    const char *keyword,
    const char *default_value)
</PRE>
<H4>Synopsis</H4>
<P>Finds a section:keyword in the symbol table and returns a
   pointer to its value. Returns the default value if the symbol
   is not defined in the table. The default value may be NULL. The
   specified section and keyword can be in any case; they are
   converted internally to lowercase to match the symbol table. If
   the keyword is empty or NULL, no ':keyword' is appended to the
   section name.
<H4>Source Code - (sflini.c)</H4>
<PRE>
{
    ASSERT (section);
    if (keyword &amp;&amp; *keyword)
        snprintf (ini_keyword, sizeof (ini_keyword), "%s:%s", section, keyword);
    else
        strncpy  (ini_keyword, section, sizeof (ini_keyword));

    <A href="sfldoc.htm#strlwc">strlwc</A> (ini_keyword);
    return (<A href="sfldoc.htm#sym_get_value">sym get value</A> (symtab, ini_keyword, default_value));
}
</PRE>
<A NAME="ini_dyn_values">&nbsp;</A>
<H3><A NAME="TOC167"><TT>ini_dyn_values</TT></A></H3>
<PRE>
#include "sflini.h"
char **
ini_dyn_values (
    SYMTAB *symtab,
    const char *section,
    const char *keyword,
    const char *default_value)
</PRE>
<H4>Synopsis</H4>
<P>Finds a section:keyword in the symbol table and returns a
   pointer to a string table containing the values, delimited by
   commas. When finished with the string table you should call
   <A href="sfldoc.htm#tok_free">tok free</A>() to free the memory allocated for it. The default
   value may not be NULL. Returns a pointer to a table of string
   tokens (see <A href="sfldoc.htm#tok_split">tok split</A>()), or NULL if there was insufficient
   memory. The specified section and keyword can be in any case;
   they are converted internally to lowercase to match the symbol
   table. If the keyword is empty or NULL, no ':keyword' is
   appended to the section name.
<H4>Source Code - (sflini.c)</H4>
<PRE>
{
    ASSERT (section);
    ASSERT (default_value);

    if (keyword &amp;&amp; *keyword)
        snprintf (ini_keyword, sizeof (ini_keyword), "%s:%s", section, keyword);
    else
        strncpy  (ini_keyword, section, sizeof (ini_keyword));

    <A href="sfldoc.htm#strlwc">strlwc</A> (ini_keyword);
    strcpy (iniline, <A href="sfldoc.htm#sym_get_value">sym get value</A> (symtab, ini_keyword, default_value));
    <A href="sfldoc.htm#strconvch">strconvch</A> (iniline, ',', ' ');
    return (<A href="sfldoc.htm#tok_split">tok split</A> (iniline));
}
</PRE>
<A NAME="srcdoc">&nbsp;</A>
<H3><A NAME="TOC168"><TT>srcdoc W (sflini.c 649): function ini_dyn_default not known</TT></A></H3>
<PRE>
#include "(unknown)"
char *
ini_dyn_default (
    SYMTAB *symtab,
    const char *section,
    const char *keyword,
    const char *default_value)
</PRE>
<H4>Synopsis</H4>
<P>As ini_dyn_value, but creates an entry with the default value
   if none already exists.
<H4>Source Code - (sflini.c)</H4>
<PRE>
{
    ASSERT (section);
    if (keyword &amp;&amp; *keyword)
        snprintf (ini_keyword, sizeof (ini_keyword), "%s:%s", section, keyword);
    else
        strncpy  (ini_keyword, section, sizeof (ini_keyword));

    <A href="sfldoc.htm#strlwc">strlwc</A> (ini_keyword);
    if (!<A href="sfldoc.htm#sym_lookup_symbol">sym lookup symbol</A> (symtab, ini_keyword))
        <A href="sfldoc.htm#sym_assume_symbol">sym assume symbol</A> (symtab, ini_keyword, default_value);

    return (<A href="sfldoc.htm#sym_get_value">sym get value</A> (symtab, ini_keyword, default_value));
}
</PRE>
<H2><A NAME="TOC169">Multilanguage support</A></H2>
<P>Filename: sfllang.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1997/06/04 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1998/05/31
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Provides hard-coded multilanguage dictionaries for dates and
   numbers, The hard-coded dictionaries work with most European
   languages.
<H4>List of Functions</H4>
<UL>
<LI>int <A href="sfldoc.htm#set_userlang">set userlang</A><BR>
   (int language);
</LI>
<LI>int <A href="sfldoc.htm#set_userlang_str">set userlang str</A><BR>
   (const char *language);
</LI>
<LI>int <A href="sfldoc.htm#get_userlang">get userlang</A><BR>
   (void);
</LI>
<LI>char * <A href="sfldoc.htm#get_userlang_str">get userlang str</A><BR>
   (void);
</LI>
<LI>int <A href="sfldoc.htm#set_accents">set accents</A><BR>
   (Bool accents);
</LI>
<LI>Bool <A href="sfldoc.htm#get_accents">get accents</A><BR>
   (void);
</LI>
<LI>char * <A href="sfldoc.htm#get_units_name">get units name</A><BR>
   (int units);
</LI>
<LI>char * <A href="sfldoc.htm#get_tens_name">get tens name</A><BR>
   (int tens);
</LI>
<LI>char * <A href="sfldoc.htm#get_day_name">get day name</A><BR>
   (int day);
</LI>
<LI>char * <A href="sfldoc.htm#get_day_abbrev">get day abbrev</A><BR>
   (int day, Bool upper);
</LI>
<LI>char * <A href="sfldoc.htm#get_month_name">get month name</A><BR>
   (int month);
</LI>
<LI>char * <A href="sfldoc.htm#get_month_abbrev">get month abbrev</A><BR>
   (int month, Bool upper);
</LI>
<LI>char * <A href="sfldoc.htm#timestamp_string">timestamp string</A><BR>
   (char *buffer, const char *pattern);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sfllang.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>SFLLANG_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>USERLANG_TOP</B>  </TT>
<TD ALIGN="LEFT">USERLANG_SV + 1
</TABLE>
<A NAME="set_userlang">&nbsp;</A>
<H3><A NAME="TOC170"><TT>set_userlang</TT></A></H3>
<PRE>
#include "sfllang.h"
int
set_userlang (int language)
</PRE>
<H4>Synopsis</H4>
<P>Sets language used for date and numeric translation. The valid
   user languages are: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>USERLANG DEFAULT</B>  <TD ALIGN="LEFT">Default
   language (use hard-coded values) <TR><TD
   ALIGN="LEFT"><B>USERLANG DA</B>  <TD ALIGN="LEFT">Danish
   <TR><TD ALIGN="LEFT"><B>USERLANG DE</B>  <TD
   ALIGN="LEFT">German <TR><TD ALIGN="LEFT"><B>USERLANG EN</B>
   <TD ALIGN="LEFT">English <TR><TD ALIGN="LEFT"><B>USERLANG
   ES</B>  <TD ALIGN="LEFT">Castillian Spanish <TR><TD
   ALIGN="LEFT"><B>USERLANG FB</B>  <TD ALIGN="LEFT">Belgian or
   Swiss French <TR><TD ALIGN="LEFT"><B>USERLANG FR</B>  <TD
   ALIGN="LEFT">French <TR><TD ALIGN="LEFT"><B>USERLANG IS</B>
   <TD ALIGN="LEFT">Icelandic <TR><TD ALIGN="LEFT"><B>USERLANG
   IT</B>  <TD ALIGN="LEFT">Italian <TR><TD
   ALIGN="LEFT"><B>USERLANG NL</B>  <TD ALIGN="LEFT">Dutch <TR><TD
   ALIGN="LEFT"><B>USERLANG NO</B>  <TD ALIGN="LEFT">Norwegian
   <TR><TD ALIGN="LEFT"><B>USERLANG PO</B>  <TD
   ALIGN="LEFT">Portuguese <TR><TD ALIGN="LEFT"><B>USERLANG SV</B>
   <TD ALIGN="LEFT">Swedish </TABLE> Returns 0 if okay, -1 if an
   unsupported language was specified.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    /*  Order of this table is not critical                                  */
    static struct {
        int  language;
        char **units;
        char **tens;
        char **days;
        char **months;
    } languages [] =
    {
        { USERLANG_DEFAULT, EN_units, EN_tens, EN_days, EN_months },
        { USERLANG_DA,      DA_units, DA_tens, EN_days, DA_months },
        { USERLANG_DE,      DE_units, DE_tens, EN_days, DE_months },
        { USERLANG_EN,      EN_units, EN_tens, EN_days, EN_months },
        { USERLANG_ES,      ES_units, ES_tens, EN_days, ES_months },
        { USERLANG_FB,      FR_units, FB_tens, FR_days, FR_months },
        { USERLANG_FR,      FR_units, FR_tens, FR_days, FR_months },
        { USERLANG_IS,      IS_units, IS_tens, EN_days, IS_months },
        { USERLANG_IT,      IT_units, IT_tens, EN_days, IT_months },
        { USERLANG_NL,      NL_units, NL_tens, NL_days, NL_months },
        { USERLANG_NO,      NO_units, NO_tens, EN_days, NO_months },
        { USERLANG_PO,      PO_units, PO_tens, EN_days, PO_months },
        { USERLANG_SV,      SV_units, SV_tens, EN_days, SV_months },
        { -1,               NULL,     NULL,    NULL,    NULL      }
    };

    int
        index;

    for (index = 0; languages [index].language != -1; index++)
        if (languages [index].language == language)
          {
            user_language = language;
            units_table   = languages [index].units;
            tens_table    = languages [index].tens;
            day_table     = languages [index].days;
            month_table   = languages [index].months;
            return (0);
          }
    return (-1);
}
</PRE>
<A NAME="set_userlang_str">&nbsp;</A>
<H3><A NAME="TOC171"><TT>set_userlang_str</TT></A></H3>
<PRE>
#include "sfllang.h"
int
set_userlang_str (const char *language)
</PRE>
<H4>Synopsis</H4>
<P>Sets language used for date and numeric translation, using a
   string representation of the language. The valid user languages
   are: <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>""</B>  <TD
   ALIGN="LEFT">Default language (use hard-coded values) <TR><TD
   ALIGN="LEFT"><B>"--"</B>  <TD ALIGN="LEFT">Alternative form for
   default language <TR><TD ALIGN="LEFT"><B>"DA"</B>  <TD
   ALIGN="LEFT">Danish <TR><TD ALIGN="LEFT"><B>"DE"</B>  <TD
   ALIGN="LEFT">German <TR><TD ALIGN="LEFT"><B>"EN"</B>  <TD
   ALIGN="LEFT">English <TR><TD ALIGN="LEFT"><B>"ES"</B>  <TD
   ALIGN="LEFT">Castillian Spanish <TR><TD
   ALIGN="LEFT"><B>"FB"</B>  <TD ALIGN="LEFT">Belgian or Swiss
   French <TR><TD ALIGN="LEFT"><B>"FR"</B>  <TD
   ALIGN="LEFT">French <TR><TD ALIGN="LEFT"><B>"IS"</B>  <TD
   ALIGN="LEFT">Icelandic <TR><TD ALIGN="LEFT"><B>"IT"</B>  <TD
   ALIGN="LEFT">Italian <TR><TD ALIGN="LEFT"><B>"NL"</B>  <TD
   ALIGN="LEFT">Dutch <TR><TD ALIGN="LEFT"><B>"NO"</B>  <TD
   ALIGN="LEFT">Norwegian <TR><TD ALIGN="LEFT"><B>"PO"</B>  <TD
   ALIGN="LEFT">Portuguese <TR><TD ALIGN="LEFT"><B>"SV"</B>  <TD
   ALIGN="LEFT">Swedish </TABLE> Returns 0 if okay, -1 if an
   unsupported language was specified.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    int
        index;

    if (strnull (language))
        return (<A href="sfldoc.htm#set_userlang">set userlang</A> (USERLANG_DEFAULT));

    for (index = 0; index &lt; USERLANG_TOP; index++)
        if (streq (language, language_str [index]))
            return (<A href="sfldoc.htm#set_userlang">set userlang</A> (index));

    return (-1);
}
</PRE>
<A NAME="get_userlang">&nbsp;</A>
<H3><A NAME="TOC172"><TT>get_userlang</TT></A></H3>
<PRE>
#include "sfllang.h"
int
get_userlang (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns the current user language code.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    return (user_language);
}
</PRE>
<A NAME="get_userlang_str">&nbsp;</A>
<H3><A NAME="TOC173"><TT>get_userlang_str</TT></A></H3>
<PRE>
#include "sfllang.h"
char *
get_userlang_str (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns the current user language as a 2-character string.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    return (language_str [user_language]);
}
</PRE>
<A NAME="set_accents">&nbsp;</A>
<H3><A NAME="TOC174"><TT>set_accents</TT></A></H3>
<PRE>
#include "sfllang.h"
int
set_accents (Bool accents)
</PRE>
<H4>Synopsis</H4>
<P>Enables or disables native-language accents. If enabled,
   accented characters in translated words are produced in the
   current system character set, if possible. Otherwise, suitable
   translations are made into the 26-letter English alphabet. By
   default, accents are enabled.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    use_accents = accents;
    return (0);
}
</PRE>
<A NAME="get_accents">&nbsp;</A>
<H3><A NAME="TOC175"><TT>get_accents</TT></A></H3>
<PRE>
#include "sfllang.h"
Bool
get_accents (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if accents are enabled, FALSE if not.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    return (use_accents);
}
</PRE>
<A NAME="get_units_name">&nbsp;</A>
<H3><A NAME="TOC176"><TT>get_units_name</TT></A></H3>
<PRE>
#include "sfllang.h"
char *
get_units_name (int units)
</PRE>
<H4>Synopsis</H4>
<P>Returns the name for the specified units, which is a value from
   zero to 19. Accented characters are formatted according to the
   current accents setting.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    ASSERT (units &gt;= 0 &amp;&amp; units &lt;= 19);
    return (handle_accents (units_table [units]));
}
</PRE>
<A NAME="get_tens_name">&nbsp;</A>
<H3><A NAME="TOC177"><TT>get_tens_name</TT></A></H3>
<PRE>
#include "sfllang.h"
char *
get_tens_name (int tens)
</PRE>
<H4>Synopsis</H4>
<P>Returns the name for the specified tens, which is a value from
   10 to 90; it is rounded as required. Accented characters are
   formatted according to the current accents setting.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    ASSERT (tens &gt;= 10 &amp;&amp; tens &lt; 100);
    return (handle_accents (tens_table [tens / 10 - 1]));
}
</PRE>
<A NAME="get_day_name">&nbsp;</A>
<H3><A NAME="TOC178"><TT>get_day_name</TT></A></H3>
<PRE>
#include "sfllang.h"
char *
get_day_name (int day)
</PRE>
<H4>Synopsis</H4>
<P>Returns the name for the specified day, which must be a value
   from 0 (Sunday) to 6 (Saturday). Accented characters are
   formatted according to the current accents setting.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    ASSERT (day &gt;= 0 &amp;&amp; day &lt;= 6);
    return (handle_accents (day_table [day]));
}
</PRE>
<A NAME="get_day_abbrev">&nbsp;</A>
<H3><A NAME="TOC179"><TT>get_day_abbrev</TT></A></H3>
<PRE>
#include "sfllang.h"
char *
get_day_abbrev (int day, Bool upper)
</PRE>
<H4>Synopsis</H4>
<P>Returns the abbreviation for the specified day, which must be a
   value from 0 (Sunday) to 6 (Saturday). The abbreviation (3
   letters) is converted into uppercase if the 'upper' argument is
   true. Accented characters are formatted according to the
   current accents setting.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    char
        abbrev [4];

    ASSERT (day &gt;= 0 &amp;&amp; day &lt;= 6);

    strncpy (abbrev, day_table [day], 3);
    abbrev [3] = '\0';
    if (upper)
        <A href="sfldoc.htm#strupc">strupc</A> (abbrev);
    return (handle_accents (abbrev));
}
</PRE>
<A NAME="get_month_name">&nbsp;</A>
<H3><A NAME="TOC180"><TT>get_month_name</TT></A></H3>
<PRE>
#include "sfllang.h"
char *
get_month_name (int month)
</PRE>
<H4>Synopsis</H4>
<P>Returns the name for the specified month, which must be a value
   from 1 to 12. Accented characters are handled as per the
   current accents setting.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    ASSERT (month &gt;= 1 &amp;&amp; month &lt;= 12);
    return (handle_accents (month_table [month - 1]));
}
</PRE>
<A NAME="get_month_abbrev">&nbsp;</A>
<H3><A NAME="TOC181"><TT>get_month_abbrev</TT></A></H3>
<PRE>
#include "sfllang.h"
char *
get_month_abbrev (int month, Bool upper)
</PRE>
<H4>Synopsis</H4>
<P>Returns the abbreviation for the specified month, which must be
   a value from 1 to 12. The abbreviation (3 letters) is converted
   into uppercase if the 'upper' argument is true. Accented
   characters are formatted according to the current accents
   setting.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    char
        abbrev [4];

    ASSERT (month &gt;= 1 &amp;&amp; month &lt;= 12);

    strncpy (abbrev, month_table [month - 1], 3);
    abbrev [3] = '\0';
    if (upper)
        <A href="sfldoc.htm#strupc">strupc</A> (abbrev);

    return (handle_accents (abbrev));
}
</PRE>
<A NAME="timestamp_string">&nbsp;</A>
<H3><A NAME="TOC182"><TT>timestamp_string</TT></A></H3>
<PRE>
#include "sfllang.h"
char *
timestamp_string (char *buffer, const char *pattern)
</PRE>
<H4>Synopsis</H4>
<P>Formats a timestamp according to a user-supplied pattern. The
   result is returned in a buffer supplied by the caller; if this
   argument is NULL, allocates a buffer and returns that (the
   caller must then free the buffer using mem_free()). The pattern
   consists of arbitrary text mixed with insertion symbols
   indicated by '%': <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>%y</B>  <TD ALIGN="LEFT">day of year, 001-366
   <TR><TD ALIGN="LEFT"><B>%yy</B>  <TD ALIGN="LEFT">year 2
   digits, 00-99 <TR><TD ALIGN="LEFT"><B>%yyyy</B>  <TD
   ALIGN="LEFT">year 4 digits, 0100-9999 <TR><TD
   ALIGN="LEFT"><B>%mm</B>  <TD ALIGN="LEFT">month, 01-12 <TR><TD
   ALIGN="LEFT"><B>%mmm</B>  <TD ALIGN="LEFT">month, Jan <TR><TD
   ALIGN="LEFT"><B>%mmmm</B>  <TD ALIGN="LEFT">month, January
   <TR><TD ALIGN="LEFT"><B>%MMM</B>  <TD ALIGN="LEFT">month, JAN
   <TR><TD ALIGN="LEFT"><B>%MMMM</B>  <TD ALIGN="LEFT">month,
   JANUARY <TR><TD ALIGN="LEFT"><B>%dd</B>  <TD ALIGN="LEFT">day,
   01-31 <TR><TD ALIGN="LEFT"><B>%ddd</B>  <TD ALIGN="LEFT">day of
   week, Sun <TR><TD ALIGN="LEFT"><B>%dddd</B>  <TD
   ALIGN="LEFT">day of week, Sunday <TR><TD
   ALIGN="LEFT"><B>%DDD</B>  <TD ALIGN="LEFT">day of week, SUN
   <TR><TD ALIGN="LEFT"><B>%DDDD</B>  <TD ALIGN="LEFT">day of
   week, SUNDAY <TR><TD ALIGN="LEFT"><B>%w</B>  <TD
   ALIGN="LEFT">day of week, 1-7 (1=Sunday) <TR><TD
   ALIGN="LEFT"><B>%ww</B>  <TD ALIGN="LEFT">week of year, 01-53
   <TR><TD ALIGN="LEFT"><B>%q</B>  <TD ALIGN="LEFT">year quarter,
   1-4 <TR><TD ALIGN="LEFT"><B>%h</B>  <TD ALIGN="LEFT">hour, 00-
   23 <TR><TD ALIGN="LEFT"><B>%m</B>  <TD ALIGN="LEFT">minute, 00-
   59 <TR><TD ALIGN="LEFT"><B>%s</B>  <TD ALIGN="LEFT">second, 00-
   59 <TR><TD ALIGN="LEFT"><B>%c</B>  <TD
   ALIGN="LEFT">centisecond, 00-99 <TR><TD ALIGN="LEFT"><B>%%</B>
   <TD ALIGN="LEFT">literal character % </TABLE>
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    long
        date,                           /*  Current date                     */
        time;                           /*    and time                       */
    int
        century,                        /*  Century component of date        */
        year,                           /*  Year component of date           */
        month,                          /*  Month component of date          */
        day,                            /*  Day component of date            */
        hour,                           /*  Hour component of time           */
        minute,                         /*  Minute component of time         */
        second,                         /*  Second component of time         */
        centi,                          /*  1/100 sec component of time      */
        cursize;                        /*  Size of current component        */
    char
       *dest,                           /*  Store formatted data here        */
        ch;                             /*  Next character in picture        */

    date = <A href="sfldoc.htm#date_now">date now</A> ();
    time = <A href="sfldoc.htm#time_now">time now</A> ();

    century = GET_CENTURY (date);
    year    = GET_YEAR    (date);
    month   = GET_MONTH   (date);
    day     = GET_DAY     (date);
    hour    = GET_HOUR    (time);
    minute  = GET_MINUTE  (time);
    second  = GET_SECOND  (time);
    centi   = GET_CENTI   (time);

    if (buffer == NULL)
        buffer = mem_alloc (strlen (pattern) * 2);

    /*  Scan through picture, converting each component                      */
    dest = buffer;
    *dest = 0;                          /*  String is empty                  */
    while (*pattern)
      {
        ch = *pattern++;
        if (ch == '%' &amp;&amp; *pattern)
          {
            ch = *pattern++;            /*  Count size of pattern after %    */
            for (cursize = 1; *pattern == ch; cursize++)
                pattern++;
          }
        else
          {
            *dest++ = ch;               /*  Something else - store and next  */
            *dest = 0;                  /*  Terminate the string nicely      */
            continue;
          }

        /*  Now process pattern itself                                       */
        switch (ch)
          {
            case 'y':
                if (cursize == 1)       /*  y     day of year, 001-366       */
                    sprintf (dest, "%03d", <A href="sfldoc.htm#julian_date">julian date</A> (date));
                else
                if (cursize == 2)       /*  yy    year 2 digits, 00-99       */
                    sprintf (dest, "%02d", year);
                else
                if (cursize == 4)       /*  yyyy  year 4 digits, 0100-9999   */
                    sprintf (dest, "%02d%02d", century, year);
                break;

            case 'm':
                if (cursize == 1)       /*  m     minute, 00-59              */
                    sprintf (dest, "%02d", minute);
                else
                if (cursize == 2)       /*  mm    month, 01-12               */
                    sprintf (dest, "%02d", month);
                else
                if (cursize == 3)       /*  mmm   month, 3 letters           */
                    strcpy (dest, <A href="sfldoc.htm#get_month_abbrev">get month abbrev</A> (month, FALSE));
                else
                if (cursize == 4)       /*  mmmm  month, full name           */
                    strcpy (dest, <A href="sfldoc.htm#get_month_name">get month name</A> (month));
                break;

            case 'M':
                if (cursize == 3)       /*  MMM   month, 3-letters, ucase    */
                    strcpy (dest, <A href="sfldoc.htm#get_month_abbrev">get month abbrev</A> (month, TRUE));
                else
                if (cursize == 4)       /*  MMMM  month, full name, ucase    */
                  {
                    strcpy (dest, <A href="sfldoc.htm#get_month_name">get month name</A> (month));
                    <A href="sfldoc.htm#strupc">strupc</A> (dest);
                  }
                break;

            case 'd':
                if (cursize == 2)       /*  dd    day, 01-31                 */
                    sprintf (dest, "%02d", day);
                else
                if (cursize == 3)       /*  ddd   day of week, Sun           */
                    strcpy (dest, <A href="sfldoc.htm#get_day_abbrev">get day abbrev</A> (<A href="sfldoc.htm#day_of_week">day of week</A> (date), FALSE));
                else
                if (cursize == 4)       /*  dddd  day of week, Sunday        */
                    strcpy (dest, <A href="sfldoc.htm#get_day_name">get day name</A> (<A href="sfldoc.htm#day_of_week">day of week</A> (date)));
                break;

            case 'D':
                if (cursize == 3)       /*  DDD   day of week, SUN           */
                    strcpy (dest, <A href="sfldoc.htm#get_day_abbrev">get day abbrev</A> (<A href="sfldoc.htm#day_of_week">day of week</A> (date), TRUE));
                else
                if (cursize == 4)       /*  DDDD  day of week, SUNDAY        */
                  {
                    strcpy (dest, <A href="sfldoc.htm#get_day_name">get day name</A> (<A href="sfldoc.htm#day_of_week">day of week</A> (date)));
                    <A href="sfldoc.htm#strupc">strupc</A> (dest);
                  }
                break;

            case 'w':
                if (cursize == 1)       /*  w     day of week, 1-7 (1=Sun)   */
                    sprintf (dest, "%d", <A href="sfldoc.htm#day_of_week">day of week</A> (date) + 1);
                else
                if (cursize == 2)       /*  ww    week of year, 01-53        */
                    sprintf (dest, "%d", <A href="sfldoc.htm#week_of_year">week of year</A> (date));
                break;

            case 'q':
                if (cursize == 1)       /*  q     year quarter, 1-4          */
                    sprintf (dest, "%d", <A href="sfldoc.htm#year_quarter">year quarter</A> (date));
                break;

            case 'h':
                if (cursize == 1)       /*  h     hour, 00-23                */
                    sprintf (dest, "%02d", hour);
                break;

            case 's':
                if (cursize == 1)       /*  s     second, 00-59              */
                    sprintf (dest, "%02d", second);
                break;

            case 'c':
                if (cursize == 1)       /*  c     centisecond, 00-99         */
                    sprintf (dest, "%02d", centi);
                break;

            case '%':
                if (cursize == 1)       /*  %     literal '%'                */
                    strcpy (dest, "%");
                break;
        }
        if (*dest)                      /*  If something was output,         */
            while (*dest)               /*    skip to end of string          */
                dest++;
        else
          {
            while (cursize--)           /*  Else output ch once or more      */
                *dest++ = ch;           /*    and bump dest pointer          */
            *dest = 0;                  /*  Terminate the string nicely      */
          }
    }
    return (buffer);
}
</PRE>
<H2><A NAME="TOC183">Line buffering functions</A></H2>
<P>Filename: sfllbuf.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1997/09/07 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1997/09/08
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Provides circular line buffering functions. A line buffer is a
   data structure that holds a fixed amount of data in a serial
   fashion; the oldest data gets discarded as new data is added.
<H4>List of Functions</H4>
<UL>
<LI>LINEBUF * <A href="sfldoc.htm#linebuf_create">linebuf create</A><BR>
   (size_t maxsize);
</LI>
<LI>void <A href="sfldoc.htm#linebuf_destroy">linebuf destroy</A><BR>
   (LINEBUF *buffer);
</LI>
<LI>void <A href="sfldoc.htm#linebuf_reset">linebuf reset</A><BR>
   (LINEBUF *buffer);
</LI>
<LI>void <A href="sfldoc.htm#linebuf_append">linebuf append</A><BR>
   (LINEBUF *buffer, const char *line);
</LI>
<LI>char * <A href="sfldoc.htm#linebuf_first">linebuf first</A><BR>
   (LINEBUF *buffer, DESCR *line);
</LI>
<LI>char * <A href="sfldoc.htm#linebuf_next">linebuf next</A><BR>
   (LINEBUF *buffer, DESCR *line, const char *cur);
</LI>
<LI>char * <A href="sfldoc.htm#linebuf_last">linebuf last</A><BR>
   (LINEBUF *buffer, DESCR *line);
</LI>
<LI>char * <A href="sfldoc.htm#linebuf_prev">linebuf prev</A><BR>
   (LINEBUF *buffer, DESCR *line, const char *cur);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sfllbuf.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>SFLLBUF_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="linebuf_create">&nbsp;</A>
<H3><A NAME="TOC184"><TT>linebuf_create</TT></A></H3>
<PRE>
#include "sfllbuf.h"
LINEBUF *
linebuf_create (size_t maxsize)
</PRE>
<H4>Synopsis</H4>
<P>Creates a new line buffer with the specified size. The size
   must be at least LINE_MAX + 1 characters long. Returns the
   address of the newly-created buffer, or NULL if there was
   insufficient memory. The fresh line buffer is set to empty
   (tail == head).
<H4>Source Code - (sfllbuf.c)</H4>
<PRE>
{
    LINEBUF
        *buffer;

    ASSERT (maxsize &gt; LINE_MAX);

    buffer = mem_alloc (sizeof (LINEBUF));
    if (!buffer)
        return (NULL);

    buffer-&gt; data = mem_alloc (maxsize);
    if (!buffer-&gt; data)
      {
        free (buffer);
        return (NULL);
      }

    buffer-&gt; head = buffer-&gt; data;
    buffer-&gt; tail = buffer-&gt; data;
    buffer-&gt; top  = buffer-&gt; data + maxsize;
    buffer-&gt; size = maxsize;
    return (buffer);
}
</PRE>
<A NAME="linebuf_destroy">&nbsp;</A>
<H3><A NAME="TOC185"><TT>linebuf_destroy</TT></A></H3>
<PRE>
#include "sfllbuf.h"
void
linebuf_destroy (LINEBUF *buffer)
</PRE>
<H4>Synopsis</H4>
<P>Destroys a line buffer and frees its memory.
<H4>Source Code - (sfllbuf.c)</H4>
<PRE>
{
    ASSERT (buffer);

    mem_free (buffer-&gt; data);
    mem_free (buffer);
}
</PRE>
<A NAME="linebuf_reset">&nbsp;</A>
<H3><A NAME="TOC186"><TT>linebuf_reset</TT></A></H3>
<PRE>
#include "sfllbuf.h"
void
linebuf_reset (LINEBUF *buffer)
</PRE>
<H4>Synopsis</H4>
<P>Resets a line buffer; i.e. empties it of all data. This is done
   simply by setting the tail and head to the start of the buffer.
<H4>Source Code - (sfllbuf.c)</H4>
<PRE>
{
    ASSERT (buffer);
    buffer-&gt; head = buffer-&gt; data;
    buffer-&gt; tail = buffer-&gt; data;
}
</PRE>
<A NAME="linebuf_append">&nbsp;</A>
<H3><A NAME="TOC187"><TT>linebuf_append</TT></A></H3>
<PRE>
#include "sfllbuf.h"
void
linebuf_append (LINEBUF *buffer, const char *line)
</PRE>
<H4>Synopsis</H4>
<P>Appends a line to the line buffer. If the buffer was full, the
   oldest line is lost. Updates the buffer head and tail as
   needed.
<H4>Source Code - (sfllbuf.c)</H4>
<PRE>
{
    int
        length,                         /*  Size of line to insert           */
        room_left,                      /*  Space left between head and top  */
        tail_old,                       /*  Offset of tail into buffer       */
        head_old,                       /*  Offset of head before insert     */
        head_new;                       /*  Offset of head after insert      */
    char
        *linedata;                      /*  Address of data to store         */

    ASSERT (buffer);
    ASSERT (line);

    linedata  = (char *) line;
    length    = strlen (line) + 1;      /*  Include trailing null            */
    room_left = (int) (buffer-&gt; top - buffer-&gt; head);

    /*  We need to make space for the new line; we calculate the new head
     *  and if the tail falls between the old and new head, it must be moved
     *  up to the next line start.  We compare 'ints' not 'char *' because
     *  they can be negative.
     */
    tail_old = (int) (buffer-&gt; tail - buffer-&gt; data);
    head_old = (int) (buffer-&gt; head - buffer-&gt; data);
    if (head_old &gt; tail_old)            /*  Shift head_old down to get it    */
        head_old -= buffer-&gt; size;      /*    somewhere before tail_old      */
    head_new = head_old + length;       /*  And calculate head_new           */

    /*  If the line is too large for the remaining space, copy what we can   */
    if (length &gt; room_left)
      {
        memcpy (buffer-&gt; head, linedata, room_left);
        linedata += room_left;
        length   -= room_left;
        buffer-&gt; head = buffer-&gt; data;  /*  Bump head to start of buffer     */
      }
    /*  Copy rest of line to buffer                                          */
    memcpy (buffer-&gt; head, linedata, length);
    buffer-&gt; head += length;            /*  Bump head past string            */
    if (buffer-&gt; head == buffer-&gt; top)  /*    and maybe wrap-around          */
        buffer-&gt; head = buffer-&gt; data;

    ASSERT (buffer-&gt; head &lt;= buffer-&gt; top);

    if (head_old &lt;  tail_old            /*  If tail falls between head_old   */
    &amp;&amp;  tail_old &lt;= head_new)           /*    and/on head_new, bump it up    */
        buffer-&gt; tail = start_next_line (buffer, buffer-&gt; head);
}
</PRE>
<A NAME="linebuf_first">&nbsp;</A>
<H3><A NAME="TOC188"><TT>linebuf_first</TT></A></H3>
<PRE>
#include "sfllbuf.h"
char *
linebuf_first (LINEBUF *buffer, DESCR *descr)
</PRE>
<H4>Synopsis</H4>
<P>Fetches the oldest line in the buffer. Returns a pointer that
   may be used in calls to <A href="sfldoc.htm#linebuf_next">linebuf next</A>(). Returns NULL if the
   buffer is empty. The line is stored in the supplied descriptor,
   and is truncated if the descriptor is too small.
<H4>Source Code - (sfllbuf.c)</H4>
<PRE>
{
    ASSERT (buffer);
    ASSERT (descr);

    return (<A href="sfldoc.htm#linebuf_next">linebuf next</A> (buffer, descr, buffer-&gt; tail));
}
</PRE>
<A NAME="linebuf_next">&nbsp;</A>
<H3><A NAME="TOC189"><TT>linebuf_next</TT></A></H3>
<PRE>
#include "sfllbuf.h"
char *
linebuf_next (LINEBUF *buffer, DESCR *descr, const char *curline)
</PRE>
<H4>Synopsis</H4>
<P>Fetches the next line in the buffer, using the pointer that was
   returned by <A href="sfldoc.htm#linebuf_first">linebuf first</A>(). Returns NULL if there are no
   more lines in the buffer, or a pointer for further calls. The
   line is stored in the supplied descriptor, and is truncated if
   the descriptor is too small.
<H4>Source Code - (sfllbuf.c)</H4>
<PRE>
{
    ASSERT (buffer);
    ASSERT (descr);
    ASSERT (curline);

    if (curline == buffer-&gt; head)
        return (NULL);                  /*  We're at the end                 */
    else
        return (get_line (buffer, descr, curline));
}
</PRE>
<A NAME="linebuf_last">&nbsp;</A>
<H3><A NAME="TOC190"><TT>linebuf_last</TT></A></H3>
<PRE>
#include "sfllbuf.h"
char *
linebuf_last (LINEBUF *buffer, DESCR *descr)
</PRE>
<H4>Synopsis</H4>
<P>Fetches the newest line in the buffer. Returns a pointer that
   may be used in calls to <A href="sfldoc.htm#linebuf_next">linebuf next</A>(). Returns NULL if the
   buffer is empty. The line is stored in the supplied descriptor,
   and is truncated if the descriptor is too small.
<H4>Source Code - (sfllbuf.c)</H4>
<PRE>
{
    ASSERT (buffer);
    ASSERT (descr);

    return (<A href="sfldoc.htm#linebuf_prev">linebuf prev</A> (buffer, descr, buffer-&gt; head));
}
</PRE>
<A NAME="linebuf_prev">&nbsp;</A>
<H3><A NAME="TOC191"><TT>linebuf_prev</TT></A></H3>
<PRE>
#include "sfllbuf.h"
char *
linebuf_prev (LINEBUF *buffer, DESCR *descr, const char *curline)
</PRE>
<H4>Synopsis</H4>
<P>Fetches the previous line in the buffer, using the pointer that
   was returned by <A href="sfldoc.htm#linebuf_last">linebuf last</A>(). Returns NULL if there are
   no more lines in the buffer, or a pointer for further calls.
   The line is stored in the supplied descriptor, and is truncated
   if the descriptor is too small.
<H4>Source Code - (sfllbuf.c)</H4>
<PRE>
{
    ASSERT (buffer);
    ASSERT (descr);
    ASSERT (curline);

    if (curline == buffer-&gt; tail)
        return (NULL);                  /*  We're at the start               */
    else
      {
        /*  We're pointing to the byte after the line's null byte            */
        buffer_dec (curline);           /*  Bump down to null                */
        ASSERT (*curline == '\0');

        do
          {
            buffer_dec (curline);       /*  And now look for previous null   */
            if (*curline == '\0')
              {
                buffer_inc (curline);   /*  Bump up to start of string       */
                break;
              }
          }
        until (curline == buffer-&gt; tail);

        get_line (buffer, descr, curline);
        return ((char *) curline);
      }
}
</PRE>
<H2><A NAME="TOC192">Linked-list functions</A></H2>
<P>Filename: sfllist.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1997/07/28 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1998/07/26
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Provides functions to maintain doubly-linked lists. You can use
   these functions to work with lists of any structure. To make
   this work, all structures must start with two pointers, "void
   *next, *prev;". When you want to attach a linked-list to
   another structure, declare the list head as a list. You can
   then refer to this variable when you attach items to the list
   head. The code sets the global list_unsafe to TRUE whenever it
   is changing a list.
<H4>List of Functions</H4>
<UL>
<LI>void * <A href="sfldoc.htm#list_relink">list relink</A><BR>
   (void *left, void *list, void *right);
</LI>
<LI>void * <A href="sfldoc.htm#list_unlink">list unlink</A><BR>
   ( void *list );
</LI>
<LI>void * <A href="sfldoc.htm#list_add">list add</A><BR>
   (LIST *list, void *data, size_t size);
</LI>
<LI>void <A href="sfldoc.htm#list_remove">list remove</A><BR>
   (LIST *list, void *data, size_t size);
</LI>
<LI>void <A href="sfldoc.htm#list_sort">list sort</A><BR>
   (void *list, NODE_COMPARE comp);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sfllist.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>FORLIST(node,root)</B>  </TT>
<TD ALIGN="LEFT">for ((node) = (root).next; <TR><TD ALIGN="LEFT"><TT><B>SFLLIST_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>list_create(node,size)</B>  </TT>
<TD ALIGN="LEFT">if (((node) = mem_alloc (size)) != NULL) <TR><TD ALIGN="LEFT"><TT><B>list_destroy(list)</B>  </TT>
<TD ALIGN="LEFT">while (!list_empty(list)) <TR><TD ALIGN="LEFT"><TT><B>list_empty(list)</B>  </TT>
<TD ALIGN="LEFT">((list)-&gt; prev == (list))
<TR><TD ALIGN="LEFT"><TT><B>list_pop(list,item)</B>  </TT>
<TD ALIGN="LEFT">list_remove (list, <TR><TD ALIGN="LEFT"><TT><B>list_push(list,item)</B>  </TT>
<TD ALIGN="LEFT">list_add (list, <TR><TD ALIGN="LEFT"><TT><B>list_queue(list,item)</B>  </TT>
<TD ALIGN="LEFT">list_add (((LIST *)list)-&gt; prev, <TR><TD ALIGN="LEFT"><TT><B>list_relink_after(l,a)</B>  </TT>
<TD ALIGN="LEFT">(list_relink (a, l, ((LIST *) a)-&gt; next))
<TR><TD ALIGN="LEFT"><TT><B>list_relink_before(l,b)</B>  </TT>
<TD ALIGN="LEFT">(list_relink (((LIST *) b)-&gt; prev, l, b))
<TR><TD ALIGN="LEFT"><TT><B>list_reset(list)</B>  </TT>
<TD ALIGN="LEFT">(list)-&gt; prev = (list)-&gt; next = (list)
</TABLE>
<H4>List of Type Definitions</H4>
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Type name:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>NODE_COMPARE</B>  </TT>
<TD ALIGN="LEFT">Bool (*) (LIST *t1, LIST *t2)
</TABLE>
<A NAME="list_unlink">&nbsp;</A>
<H3><A NAME="TOC193"><TT>list_unlink</TT></A></H3>
<PRE>
#include "sfllist.h"
void *
list_unlink (
    void *list)
</PRE>
<H4>Synopsis</H4>
<P>Unlinks the list from any list it may be in. Returns list.
<H4>Source Code - (sfllist.c)</H4>
<PRE>
{
    list_unsafe = TRUE;

    /*  Join together next and previous nodes */
    ((LIST *) ((LIST *) list)-&gt; prev)-&gt; next = ((LIST *) list)-&gt; next;
    ((LIST *) ((LIST *) list)-&gt; next)-&gt; prev = ((LIST *) list)-&gt; prev;

    /*  The list is now empty */
    list_reset ((LIST *) list);

    list_unsafe = FALSE;
    return (list);
}
</PRE>
<A NAME="list_relink">&nbsp;</A>
<H3><A NAME="TOC194"><TT>list_relink</TT></A></H3>
<PRE>
#include "sfllist.h"
void *
list_relink (
    void *left,
    void *list,
    void *right)
</PRE>
<H4>Synopsis</H4>
<P>Links the list into a linked list. This is a general-purpose
   function that can be used to attach and remove lists anywhere
   in a list. Sets the global variable 'list_unsafe' while the
   list is being changed. Returns the address of list.
<H4>Source Code - (sfllist.c)</H4>
<PRE>
{
    LIST *swap;

    list_unsafe = TRUE;
    swap = ((LIST *) left)-&gt; next;      /*  Exchange left pointers           */
           ((LIST *) left)-&gt; next = list;
    ((LIST *) ((LIST *) list)-&gt; prev)-&gt; next = swap;

    swap = ((LIST *) right)-&gt; prev;     /*  Exchange right pointers          */
           ((LIST *) right)-&gt; prev = ((LIST *) list)-&gt; prev;
                                     ((LIST *) list)-&gt; prev = swap;

    list_unsafe = FALSE;
    return (list);
}
</PRE>
<A NAME="list_add">&nbsp;</A>
<H3><A NAME="TOC195"><TT>list_add</TT></A></H3>
<PRE>
#include "sfllist.h"
void *
list_add (LIST *list, void *data, size_t size)
</PRE>
<H4>Synopsis</H4>
<P>Creates a node at the head of a list of a specified size and
   copies the specified data into it. Use with the stack &amp;
   queue macros list_push and list_queue.
<H4>Source Code - (sfllist.c)</H4>
<PRE>
{
    LIST
        *node;

    node = mem_alloc (sizeof (LIST) + size);
    if (node)
      {
        list_reset (node);
        list_relink_after (node, list);
        memcpy ((char *) node + sizeof (LIST), (char *) data, size);
      }
    return node;
}
</PRE>
<A NAME="list_remove">&nbsp;</A>
<H3><A NAME="TOC196"><TT>list_remove</TT></A></H3>
<PRE>
#include "sfllist.h"
void
list_remove (LIST *list, void *data, size_t size)
</PRE>
<H4>Synopsis</H4>
<P>Removes the node at the head of a list, copying the specified
   amount of data to the specified data block. This size must be
   exactly equal to the size of the data block. The list may not
   be empty. Use this with the macro list_pop.
<H4>Source Code - (sfllist.c)</H4>
<PRE>
{
LIST
    *node;

    ASSERT (!list_empty (list));

    node = list-&gt; next;
    ASSERT (mem_size (node) - sizeof (LIST) == size);

    memcpy ((char *) data, (char *) node + sizeof (LIST), size);
    <A href="sfldoc.htm#list_unlink">list unlink</A> (node);
    mem_free (node);
}
</PRE>
<A NAME="list_sort">&nbsp;</A>
<H3><A NAME="TOC197"><TT>list_sort</TT></A></H3>
<PRE>
#include "sfllist.h"
void list_sort (void *list, NODE_COMPARE comp)
</PRE>
<H4>Synopsis</H4>
<P>Sorts a list using the "comb-sort" algorithm.
<H4>Source Code - (sfllist.c)</H4>
<PRE>
{
    int
        jump_size,
        i;
    LIST
        *base,
        *swap,
        *temp;
    Bool
        swapped;

    jump_size = 0;
    FORLIST (base, * (LIST *) list)
        jump_size++;

    swapped = TRUE;
    while ((jump_size &gt; 1) || swapped)
      {
        jump_size = (10 * jump_size + 3) / 13;
        base = ((LIST *) list)-&gt; next;
        swap = base;
        for (i = 0; i &lt; jump_size; i++)
            swap = swap-&gt; next;

        swapped = FALSE;
        while (swap != (LIST *) list)
          {
            if ((*comp) (base, swap))
              {
                temp = base-&gt; prev;
                <A href="sfldoc.htm#list_unlink">list unlink</A> (base);
                list_relink_after (base, swap);
                <A href="sfldoc.htm#list_unlink">list unlink</A> (swap);
                list_relink_after (swap, temp);
                temp = base;
                base = swap;
                swap = temp;
                swapped = TRUE;
              }
            base = base-&gt; next;
            swap = swap-&gt; next;
          }
      }
}
</PRE>
<H2><A NAME="TOC198">SMTP mailer function</A></H2>
<P>Filename: sflmail.h
<BR>Package: standard function library (sfl)
<BR>Written: 06/18/97 Scott Beasley (jscottb@infoave.com)
<BR>Revised: 1999/07/06
<BR>Copyright: Copyright (C) 1991-2000 Scott Beasley and iMatix
   Corporation
<H3>Synopsis</H3>
<P>Functions to format and send SMTP messages. Messages can
   contain attachments, and be sent with "cc"'s "bcc"'s as well as
   the normal "to" receivers.
<H4>List of Functions</H4>
<UL>
<LI>int <A href="sfldoc.htm#smtp_send_mail_ex">smtp send mail ex</A><BR>
   (SMTP *smtp);
</LI>
<LI>int <A href="sfldoc.htm#smtp_send_mail">smtp send mail</A><BR>
   (char *strSmtpServer, char *strMessageBody, char *strSubject,
   char *strSenderUserId, char *strFullSenderUserId, char
   *strDestUserIds, char *strFullDestUserIds, char *strCcUserIds,
   char *strFullCcUserIds, char *strBccUserIds, char
   *strFullBccUserIds, char *strRetPathUserId, char
   *strRrcpUserId, char *strMsgComment, char *strMailerName, char
   *strBinFiles, char *strTxtFiles, char *strDebugFile );
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflmail.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_sflmail_included</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="smtp_send_mail_ex">&nbsp;</A>
<H3><A NAME="TOC199"><TT>smtp_send_mail_ex</TT></A></H3>
<PRE>
#include "sflmail.h"
int smtp_send_mail_ex (
   SMTP *smtp)
</PRE>
<H4>Synopsis</H4>
<P>Format and send a SMTP message. This function gives you the
   options of sneding to multi receivers, CC's, Bcc's and also
   send UUencoded attachments. Receivers and files are ";" or ","
   terminated. NOTE: The sock_init function should be called
   before use of this function.
<H4>Source Code - (sflmail.c)</H4>
<PRE>
{
   FILE *fpin;
   int iCnt;
   sock_t iSocket;
   char strOut[514], strFile[256], strRetBuff[513];
   char strUUEFile[256], *strRcptUserIds;
   int iOld_ip_nonblock = ip_nonblock, rcptUserIdsLen;

   /*  Make sure we block on socket accesses                                 */
   ip_nonblock = FALSE;

   /* Open up the SMTP port (25 most of the time). */
   iSocket = <A href="sfldoc.htm#connect_socket">connect socket</A> (smtp-&gt;strSmtpServer,
                             "smtp", "tcp", NULL,
                             smtp-&gt;connect_retry_cnt,
                             smtp-&gt;retry_wait_time);

   if (getreply (iSocket, smtp) &gt; 400 || iSocket &lt; 0)
       return -1;

   /* Format a SMTP meassage header.  */
   /* Just say hello to the mail server. */
   <A href="sfldoc.htm#xstrcpy">xstrcpy</A> (strOut, "HELO ", <A href="sfldoc.htm#get_hostname">get hostname</A> (), "\n", NULL);
   smtp_send_data (iSocket, strOut);
   if (getreply (iSocket, smtp) &gt; 400)
       return -2;

   /* Tell the mail server who the message is from. */
   <A href="sfldoc.htm#xstrcpy">xstrcpy</A> (strOut, "MAIL FROM:&lt;", smtp-&gt;strSenderUserId, "&gt;\n", NULL);
   smtp_send_data (iSocket, strOut);
   if (getreply (iSocket, smtp) &gt; 400)
       return -3;

   rcptUserIdsLen = (strlen (smtp-&gt;strDestUserIds) +
                     strlen (smtp-&gt;strCcUserIds) +
		     strlen (smtp-&gt;strBccUserIds) + 3);

   strRcptUserIds = (char *) malloc (rcptUserIdsLen);
   snprintf (strRcptUserIds, rcptUserIdsLen, "%s;%s;%s",
	     smtp-&gt;strDestUserIds, smtp-&gt;strCcUserIds, smtp-&gt;strBccUserIds);

   /* The following tells the mail server who to send it to. */
   iCnt = 0;
   while (1)
     {
       <A href="sfldoc.htm#getstrfld">getstrfld</A> (strRcptUserIds, iCnt++, 0, ",;", strRetBuff);

       if (*strRetBuff)
         {
           <A href="sfldoc.htm#xstrcpy">xstrcpy</A> (strOut, "RCPT TO:&lt;", strRetBuff, "&gt;\r\n", NULL);
           smtp_send_data (iSocket, strOut);
           if (getreply (iSocket, smtp) &gt; 400)
               return -4;
         }

       else
           break;
     }

   free (strRcptUserIds);

   /* Now give it the Subject and the message to send. */
   smtp_send_data (iSocket, "DATA\r\n");
   if (getreply (iSocket, smtp) &gt; 400)
       return -5;

   /* Set the date and time of the message. */
   <A href="sfldoc.htm#xstrcpy">xstrcpy</A> ( strOut, "Date: ", <A href="sfldoc.htm#encode_mime_time">encode mime time</A> (<A href="sfldoc.htm#date_now">date now</A> (), <A href="sfldoc.htm#time_now">time now</A> ()),
             " \r\n", NULL );

   /* The following shows all who it was sent to. */
   if ( smtp-&gt;strFullDestUserIds &amp;&amp; *smtp-&gt;strFullDestUserIds )
    {
       <A href="sfldoc.htm#replacechrswith">replacechrswith</A> (smtp-&gt;strFullDestUserIds, ";", ',');
       <A href="sfldoc.htm#xstrcpy">xstrcpy</A> (strOut, "To: ", smtp-&gt;strFullDestUserIds, "\r\n", NULL);
     }
   else
    {
       <A href="sfldoc.htm#replacechrswith">replacechrswith</A> (smtp-&gt;strDestUserIds, ";", ',');
       <A href="sfldoc.htm#xstrcpy">xstrcpy</A> (strOut, "To: ", smtp-&gt;strDestUserIds, "\r\n", NULL);
    }

   /* Set up the Reply-To path. */
   if (!smtp-&gt;strRetPathUserId || !*smtp-&gt;strRetPathUserId)
       smtp-&gt;strRetPathUserId = smtp-&gt;strSenderUserId;

   if ( strstr( smtp-&gt;strRetPathUserId, "&lt;" ) != NULL &amp;&amp;
        strstr( smtp-&gt;strRetPathUserId, "&gt;" ) != NULL )
     {
       <A href="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Reply-To:", smtp-&gt;strRetPathUserId, "\r\n", NULL);
     }
   else
     {
       <A href="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Reply-To:&lt;", smtp-&gt;strRetPathUserId, "&gt;\r\n", NULL);
     }

   if ( smtp-&gt;strFullSenderUserId &amp;&amp; *smtp-&gt;strFullSenderUserId )
     {
       <A href="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Sender:", smtp-&gt;strFullSenderUserId, "\r\n", NULL);
       <A href="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "From:", smtp-&gt;strFullSenderUserId, "\r\n", NULL);
     }
   else
     {
       <A href="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Sender:", smtp-&gt;strSenderUserId, "\r\n", NULL);
       <A href="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "From:", smtp-&gt;strSenderUserId, "\r\n", NULL);
     }
   smtp_send_data (iSocket, strOut);

   *strOut = '\0';

   /* Post any CC's. */
   if (smtp-&gt;strFullCcUserIds &amp;&amp; *smtp-&gt;strFullCcUserIds)
     {
       <A href="sfldoc.htm#replacechrswith">replacechrswith</A> (smtp-&gt;strFullCcUserIds, ";", ',');
       <A href="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Cc:", smtp-&gt;strFullCcUserIds, "\r\n", NULL );
     }
   else
   if (smtp-&gt;strCcUserIds &amp;&amp; *smtp-&gt;strCcUserIds)
     {
       <A href="sfldoc.htm#replacechrswith">replacechrswith</A> (smtp-&gt;strCcUserIds, ";", ',');
       <A href="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Cc:", smtp-&gt;strCcUserIds, "\r\n", NULL );
     }

   /* Post any BCC's. */
   if (smtp-&gt;strFullBccUserIds &amp;&amp; *smtp-&gt;strFullBccUserIds)
     {
       <A href="sfldoc.htm#replacechrswith">replacechrswith</A> (smtp-&gt;strFullBccUserIds, ";", ',');
       <A href="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Bcc:", smtp-&gt;strFullBccUserIds, "\r\n", NULL);
     }
   else
   if (smtp-&gt;strBccUserIds &amp;&amp; *smtp-&gt;strBccUserIds)
     {
       <A href="sfldoc.htm#replacechrswith">replacechrswith</A> (smtp-&gt;strBccUserIds, ";", ',');
       <A href="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Bcc:", smtp-&gt;strBccUserIds, "\r\n", NULL);
     }
   /* Post any Return-Receipt-To. */
   if (smtp-&gt;strRrcpUserId &amp;&amp; *smtp-&gt;strRrcpUserId)
       <A href="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Return-Receipt-To:", smtp-&gt;strRrcpUserId, "&gt;\r\n",
                NULL);

   if (smtp-&gt;strMailerName &amp;&amp; *smtp-&gt;strMailerName)
       <A href="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "X-Mailer: ", smtp-&gt;strMailerName, "\r\n", NULL);
   else
       strcat (strOut, "X-Mailer: sflmail function\r\n");

   /* Set the mime version. */
   strcat (strOut, "MIME-Version: 1.0\r\n");
   strcat (strOut,
   "Content-Type: Multipart/Mixed; boundary=Message-Boundary-21132\r\n");

   smtp_send_data (iSocket, strOut);

   /* Write out any message comment included. */
   <A href="sfldoc.htm#xstrcpy">xstrcpy</A> (strOut, "Comments: ", smtp-&gt;strMsgComment, "\r\n", NULL);

   /* Send the subject and message body. */
   <A href="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Subject:", smtp-&gt;strSubject, "\n\r\n", NULL);
   smtp_send_data (iSocket, strOut);

   /* Keep rfc822 in mind with all the sections. */
   if (smtp-&gt;strMessageBody &amp;&amp; *smtp-&gt;strMessageBody)
     {
       strcat (strOut, "\r\n--Message-Boundary-21132\r\n");
       strcat (strOut, "Content-Type: text/plain; charset=US-ASCII\r\n");
       strcat (strOut, "Content-Transfer-Encoding: 7BIT\r\n");
       strcat (strOut, "Content-description: Body of message\r\n\r\n");
       smtp_send_data (iSocket, strOut);
       smtp_send_data (iSocket, smtp-&gt;strMessageBody);
       smtp_send_data (iSocket, "\r\n");
     }

   /* Include any Text type files and Attach them to the message. */
   if (smtp-&gt;strTxtFiles &amp;&amp; *smtp-&gt;strTxtFiles)
     {
       iCnt = 0;
       while (1)
         {
           <A href="sfldoc.htm#getstrfld">getstrfld</A> (smtp-&gt;strTxtFiles, iCnt++, 0, ",;", strFile);
           <A href="sfldoc.htm#trim">trim</A> (strFile);
           if (*strFile)
             {
               fpin = fopen (strFile, "rb");
               if (!fpin)
                 {
                   strcpy (smtp-&gt;strlast_smtp_message, strFile);
                   return -6;
                 }

               strcpy (strOut, "\r\n--Message-Boundary-21132\r\n");
               strcat (strOut,
                       "Content-Type: text/plain; charset=US-ASCII\r\n");
               strcat (strOut, "Content-Transfer-Encoding: 7BIT\r\n");
               <A href="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Content-Disposition: attachment; filename=",
                        getfilename (strFile), "\r\n\n", NULL);
               smtp_send_data (iSocket, strOut);
               while (!feof (fpin))
                 {
                   memset (strRetBuff, 0, 513);
                   fread (strRetBuff, sizeof (char), 512, fpin);
                   smtp_send_data (iSocket, strRetBuff);
                 }

               fclose (fpin);
             }
           else
               break;
         }
     }

   /* Attach any bin files to the message. */
   if (smtp-&gt;strBinFiles &amp;&amp; *smtp-&gt;strBinFiles)
     {
       iCnt = 0;
       while (1)
         {
           <A href="sfldoc.htm#getstrfld">getstrfld</A> (smtp-&gt;strBinFiles, iCnt++, 0, ",;", strFile);
           <A href="sfldoc.htm#trim">trim</A> (strFile);
           if (*strFile)
             {
               strcpy (strUUEFile, strFile);
               if (strchr (strUUEFile, '.'))
                   *((strchr (strUUEFile, '.')))= (char)NULL;
               strcat (strUUEFile, ".uue");
               uuencode (strFile, strUUEFile, smtp-&gt;strlast_smtp_message);
               fpin = fopen (strUUEFile, "rb");
               if (!fpin)
                 {
                   return -6;
                 }

               strcpy (strOut, "\r\n--Message-Boundary-21132\r\n");
               <A href="sfldoc.htm#xstrcat">xstrcat</A> (strOut,
                        "Content-Type: application/octet-stream; name=",
               getfilename (strFile), "\r\n", NULL);
               strcat (strOut, "Content-Transfer-Encoding: x-uuencode\r\n");
               <A href="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Content-Disposition: attachment; filename=",
                        getfilename (strFile), "\r\n\n", NULL);
               smtp_send_data (iSocket, strOut);
               while (!feof (fpin))
                 {
                   memset (strRetBuff, 0, 513);
                   fread (strRetBuff, sizeof (char), 512, fpin);
                   smtp_send_data (iSocket, strRetBuff);
                 }

               fclose (fpin);

               if ( !smtp-&gt;debug )
                  unlink (strUUEFile);
             }
           else
               break;
         }
     }

   /* This ends the message. */
   smtp_send_data (iSocket, ".\r\n");
   if (getreply (iSocket, smtp) &gt; 400)
        return -7;

   /* Now log off the SMTP port. */
   smtp_send_data (iSocket, "QUIT\n");
   if (getreply (iSocket, smtp) &gt; 400)
        return -8;

   /*
      Clean-up.
   */
   /* Close the port up. */
   <A href="sfldoc.htm#close_socket">close socket</A> (iSocket);

   /* If a clean send, then reset and leave. */
   ip_nonblock = iOld_ip_nonblock;

   return 0;
}
</PRE>
<A NAME="smtp_send_mail">&nbsp;</A>
<H3><A NAME="TOC200"><TT>smtp_send_mail</TT></A></H3>
<PRE>
#include "sflmail.h"
int smtp_send_mail (
   char *strSmtpServer,
   char *strMessageBody,
   char *strSubject,
   char *strSenderUserId,
   char *strFullSenderUserId,
   char *strDestUserIds,
   char *strFullDestUserIds,
   char *strCcUserIds,
   char *strFullCcUserIds,
   char *strBccUserIds,
   char *strFullBccUserIds,
   char *strRetPathUserId,
   char *strRrcpUserId,
   char *strMsgComment,
   char *strMailerName,
   char *strBinFiles,
   char *strTxtFiles,
   char *strDebugFile )
</PRE>
<H4>Synopsis</H4>
<P>Format and send a SMTP message, by calling the
   smtp_send_mail_ex function. This function is kept to be
   compatable with previous versions of smtp_send_mail,
   smtp_send_mail_ex should now be used, this will be deleted
   soon.
<H4>Source Code - (sflmail.c)</H4>
<PRE>
{
   SMTP smtp;

   smtp.strSmtpServer = strSmtpServer;
   smtp.strMessageBody = strMessageBody;
   smtp.strSubject = strSubject;
   smtp.strSenderUserId = strSenderUserId;
   smtp.strFullSenderUserId = strFullSenderUserId;
   smtp.strDestUserIds = strDestUserIds;
   smtp.strFullDestUserIds = strFullDestUserIds;
   smtp.strCcUserIds = strCcUserIds;
   smtp.strFullCcUserIds = strFullCcUserIds;
   smtp.strBccUserIds = strBccUserIds;
   smtp.strFullBccUserIds = strFullBccUserIds;
   smtp.strRetPathUserId = strRetPathUserId;
   smtp.strRrcpUserId = strRrcpUserId;
   smtp.strMsgComment = strMsgComment;
   smtp.strMailerName = strMailerName;
   smtp.strBinFiles = strBinFiles;
   smtp.strTxtFiles = strTxtFiles;
   smtp.connect_retry_cnt = 3;
   smtp.retry_wait_time = 0;
   smtp.debug = 0;
   smtp.strDebugFile = strDebugFile;

   return <A href="sfldoc.htm#smtp_send_mail_ex">smtp send mail ex</A> (&amp;smtp);
}
</PRE>
<H2><A NAME="TOC201">Mathematic functions</A></H2>
<P>Filename: sflmath.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1996/05/12 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1997/09/08
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Provides miscellaneous mathematical functions, including
   calculation of points within areas.
<H4>List of Functions</H4>
<UL>
<LI>int <A href="sfldoc.htm#point_in_rect">point in rect</A><BR>
   (const FPOINT *point, const FPOINT *coords);
</LI>
<LI>int <A href="sfldoc.htm#point_in_circle">point in circle</A><BR>
   (const FPOINT *point, const FPOINT *coords);
</LI>
<LI>int <A href="sfldoc.htm#point_in_poly">point in poly</A><BR>
   (const FPOINT *point, const FPOINT *coords, int nb_point);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflmath.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>SFLMATH_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="point_in_rect">&nbsp;</A>
<H3><A NAME="TOC202"><TT>point_in_rect</TT></A></H3>
<PRE>
#include "sflmath.h"
int
point_in_rect (const FPOINT *point, const FPOINT *coords)
</PRE>
<H4>Synopsis</H4>
<P>Checks if the requested FPOINT is within the specified
   rectangle. Returns TRUE or FALSE appropriately.
<H4>Source Code - (sflmath.c)</H4>
<PRE>
{
    return ((point-&gt; x &gt;= coords [0].x &amp;&amp; point-&gt; x &lt;= coords [1].x)
         &amp;&amp; (point-&gt; y &gt;= coords [0].y &amp;&amp; point-&gt; y &lt;= coords [1].y));
}
</PRE>
<A NAME="point_in_circle">&nbsp;</A>
<H3><A NAME="TOC203"><TT>point_in_circle</TT></A></H3>
<PRE>
#include "sflmath.h"
int
point_in_circle (const FPOINT *point, const FPOINT *coords)
</PRE>
<H4>Synopsis</H4>
<P>Checks if the requested FPOINT is within the specified circle.
   Returns TRUE or FALSE appropriately.
<H4>Source Code - (sflmath.c)</H4>
<PRE>
{
    double
        circle_radius,
        distance_from_centre;

    circle_radius        = ((coords [0].y - coords [1].y) *
                            (coords [0].y - coords [1].y)) +
                           ((coords [0].x - coords [1].x)  *
                            (coords [0].x - coords [1].x));

    distance_from_centre = ((coords [0].y - point-&gt; y) *
                            (coords [0].y - point-&gt; y)) +
                           ((coords [0].x - point-&gt; x) *
                            (coords [0].x - point-&gt; x));
    return (distance_from_centre &lt;= circle_radius);
}
</PRE>
<A NAME="point_in_poly">&nbsp;</A>
<H3><A NAME="TOC204"><TT>point_in_poly</TT></A></H3>
<PRE>
#include "sflmath.h"
int
point_in_poly (const FPOINT *point, const FPOINT *pgon, int nbpoints)
</PRE>
<H4>Synopsis</H4>
<P>Checks if the requested FPOINT is within the specified polygon.
   Returns TRUE or FALSE.
<H4>Source Code - (sflmath.c)</H4>
<PRE>
{
    int
        inside_flag,
        xflag0,
        crossings;
    const double
        *stop;
    double
        *p,
        tx,
        ty,
        y;

    crossings = 0;

    tx = point-&gt; x;
    ty = point-&gt; y;
    y  = pgon [nbpoints - 1].y;

    p = (double *) pgon + 1;
    if ((y &gt;= ty) != (*p &gt;= ty))
      {
        if ((xflag0 = (pgon [nbpoints - 1].x &gt;= tx)) ==
                (*(double *) pgon &gt;= tx))
          {
            if (xflag0)
               crossings++;
          }
        else
            crossings += (pgon [nbpoints - 1].x - (y - ty) *
                         (*(double *) pgon - pgon [nbpoints - 1].x) /
                         (*p - y)) &gt;= tx;
      }
     stop = &amp;pgon [nbpoints].y;
     for (y = *p, p += 2; p &lt;= stop; y = *p, p += 2)
       {
         if (y &gt;= ty)
           {
             while ((p &lt; stop) &amp;&amp; (*p &gt;= ty))
                 p += 2;
             if (p &gt;= stop)
                break;
             if ((xflag0 = (*(p - 3) &gt;= tx)) == (*(p - 1) &gt;= tx))
               {
                 if (xflag0)
                    crossings++;
               }
             else
                 crossings += (*(p - 3) - (*(p - 2) - ty) *
                              (*(p - 1) - *(p - 3)) /
                              (*p - *(p - 2))) &gt;= tx;
           }
         else
           {
             while ((p &lt; stop) &amp;&amp; (*p &lt; ty))
                p += 2;
             if (p &gt;= stop)
                break;
             if ((xflag0 = (*(p - 3) &gt;= tx)) == (*(p - 1) &gt;= tx))
               {
                 if (xflag0)
                    crossings++;
               }
             else
                 crossings += (*(p - 3) - (*(p - 2) - ty) *
                              (*(p - 1) -  *(p - 3)) /
                              (*p - *(p - 2))) &gt;= tx;
           }
       }
     inside_flag = crossings &amp; 0x01;
     return (inside_flag);
}
</PRE>
<H2><A NAME="TOC205">Message-file access functions</A></H2>
<P>Filename: sflmesg.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1992/10/25 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1997/09/08
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Provides functions to read and format messages from a message
   file. The intention of such a file is to provide a single
   location for all error messages: you can easier translate these
   into foreign languages, and you can control the consistency of
   an application's error messages.
<H4>List of Functions</H4>
<UL>
<LI>int <A href="sfldoc.htm#open_message_file">open message file</A><BR>
   (const char *filename);
</LI>
<LI>void <A href="sfldoc.htm#close_message_file">close message file</A><BR>
   (void);
</LI>
<LI>void <A href="sfldoc.htm#print_message">print message</A><BR>
   (int msgid, ...);
</LI>
<LI>char * <A href="sfldoc.htm#message_text">message text</A><BR>
   (int msgid);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflmesg.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>ERROR_ANY</B>  </TT>
<TD ALIGN="LEFT">0000 /* Generic error message */
<TR><TD ALIGN="LEFT"><TT><B>SFLMESG_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="open_message_file">&nbsp;</A>
<H3><A NAME="TOC206"><TT>open_message_file</TT></A></H3>
<PRE>
#include "sflmesg.h"
int
open_message_file (const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Opens the specified error message file for reading. Returns 0
   if the file exists and is readable, otherwise returns -1. Use
   this function before calling <A href="sfldoc.htm#print_message">print message</A>(). You can keep
   just one message file open at once; this function closes any
   previously-opened message file. This was done on purpose: it is
   common to open a message file for an entire application in the
   main function, then refer to it at other points in the code. It
   is a pain to pass file handles around the entire application,
   and global variables are generally a bad idea.
<H4>Source Code - (sflmesg.c)</H4>
<PRE>
{
    int feedback;

    <A href="sfldoc.htm#close_message_file">close message file</A> ();
    msgfile = <A href="sfldoc.htm#file_open">file open</A> (filename, 'r');

    if (msgfile)
        feedback = 0;
    else
        feedback = -1;

    return (feedback);
}
</PRE>
<A NAME="close_message_file">&nbsp;</A>
<H3><A NAME="TOC207"><TT>close_message_file</TT></A></H3>
<PRE>
#include "sflmesg.h"
void
close_message_file (void)
</PRE>
<H4>Synopsis</H4>
<P>Closes the currently open message file, if any. Does not return
   anything.
<H4>Source Code - (sflmesg.c)</H4>
<PRE>
{
    if (msgfile)
      {
        <A href="sfldoc.htm#file_close">file close</A> (msgfile);
        msgfile = NULL;
      }
}
</PRE>
<A NAME="print_message">&nbsp;</A>
<H3><A NAME="TOC208"><TT>print_message</TT></A></H3>
<PRE>
#include "sflmesg.h"
void
print_message (int msgid, ...)
</PRE>
<H4>Synopsis</H4>
<P>Scans the message file for a message with the specified id.
   Each line in the message file should start with a four-digit
   id, then a space, then the message to print. The message can
   include format specifiers using '%'. Values for each format are
   passed after the msgid. Returns nothing. The message file must
   be sorted by ascending message id's. Make sure you call
   <A href="sfldoc.htm#open_message_file">open message file</A> () before this function. Prints the
   message on stderr.
<H4>Source Code - (sflmesg.c)</H4>
<PRE>
{
    va_list argptr;                     /*  Argument list pointer            */

    read_msg (msgid);                   /*  Retrieve message into msgline    */
    va_start (argptr, msgid);           /*  Start variable arguments list    */
    vfprintf (stderr, msgline, argptr);
    va_end   (argptr);                  /*  End variable arguments list      */
    fprintf  (stderr, "\n");
    fflush   (stderr);
}
</PRE>
<A NAME="message_text">&nbsp;</A>
<H3><A NAME="TOC209"><TT>message_text</TT></A></H3>
<PRE>
#include "sflmesg.h"
char *
message_text (int msgid)
</PRE>
<H4>Synopsis</H4>
<P>Works like <A href="sfldoc.htm#print_message">print message</A>(), but returns a pointer to the
   raw message rather than printing it. The message text is stored
   in a static area that is overwritten by each call. If msgid is
   -1, retrieves the next message sequentially, ignoring any
   numbering. This is only valid after previously reading a
   message. Places "." in the message if no more are found.
<H4>Source Code - (sflmesg.c)</H4>
<PRE>
{
    read_msg (msgid);                   /*  Retrieve message into msgline    */
    return (msgline);
}
</PRE>
<H2><A NAME="TOC210">Memory allocation functions</A></H2>
<P>Filename: sflmem.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1996/06/08 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1999/12/28
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Encapsulated memory allocation functions. Based on an article
   by Jim Schimandle in DDJ August 1990. Provides 'safe' versions
   of malloc(), realloc(), free(), and strdup(). These functions
   protect the programmer from errors in calling memory
   allocation/free routines. When these calls are used, the
   allocation routines in this module add a data structure to the
   top of allocated memory blocks which tags them as legal memory
   blocks. When the free routine is called, the memory block to be
   freed is checked for legality. If the block is not legal, the
   memory list is dumped to stderr and the program is terminated.
   Some of these functions are called through macros that add the
   filename and line number of the call, for tracing. Do not call
   these functions directly.
<H4>List of Functions</H4>
<UL>
<LI>void * <A href="sfldoc.htm#mem_alloc_">mem alloc </A><BR>
   (MEMTRN *trn, size_t size, const char *source_file, size_t
   source_line);
</LI>
<LI>void * <A href="sfldoc.htm#mem_realloc_">mem realloc </A><BR>
   (void *block, size_t size, const char *source_file, size_t
   source_line);
</LI>
<LI>void <A href="sfldoc.htm#mem_free_">mem free </A><BR>
   (void *block, const char *source_file, size_t source_line);
</LI>
<LI>char * <A href="sfldoc.htm#mem_strdup_">mem strdup </A><BR>
   (MEMTRN *trn, const char *string, const char *source_file,
   size_t source_line);
</LI>
<LI>void <A href="sfldoc.htm#mem_strfree_">mem strfree </A><BR>
   (char **string, const char *source_file, size_t source_line);
</LI>
<LI>DESCR * <A href="sfldoc.htm#mem_descr_">mem descr </A><BR>
   (MEMTRN *trn, const void *block, size_t size, const char
   *source_file, size_t source_line);
</LI>
<LI>MEMTRN * <A href="sfldoc.htm#mem_new_trans_">mem new trans </A><BR>
   (const char *source_file, size_t source_line);
</LI>
<LI>void <A href="sfldoc.htm#mem_commit_">mem commit </A><BR>
   (MEMTRN *trn, const char *source_file, size_t source_line);
</LI>
<LI>void <A href="sfldoc.htm#mem_rollback_">mem rollback </A><BR>
   (MEMTRN *trn, const char *source_file, size_t source_line);
</LI>
<LI>void <A href="sfldoc.htm#mem_checkall_">mem checkall </A><BR>
   (const char *source_file, size_t source_line);
</LI>
<LI>void <A href="sfldoc.htm#mem_check_">mem check </A><BR>
   (const void *block, const char *source_file, size_t
   source_line);
</LI>
<LI>void <A href="sfldoc.htm#mem_assert_">mem assert </A><BR>
   (const char *source_file, size_t source_line);
</LI>
<LI>size_t <A href="sfldoc.htm#mem_size_">mem size </A><BR>
   (const void *block, const char *source_file, size_t
   source_line);
</LI>
<LI>long <A href="sfldoc.htm#mem_used">mem used</A><BR>
   (void);
</LI>
<LI>long <A href="sfldoc.htm#mem_allocs">mem allocs</A><BR>
   (void);
</LI>
<LI>long <A href="sfldoc.htm#mem_frees">mem frees</A><BR>
   (void);
</LI>
<LI>void <A href="sfldoc.htm#mem_freeall">mem freeall</A><BR>
   (void);
</LI>
<LI>void <A href="sfldoc.htm#mem_display">mem display</A><BR>
   (FILE *save_to);
</LI>
<LI>int <A href="sfldoc.htm#mem_scavenger">mem scavenger</A><BR>
   (scavenger scav_fct, void *scav_arg);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflmem.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>SFLMEM_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>mem_alloc(n)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_assert()</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_check(p)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_checkall()</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_commit(t)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_descr(p,n)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_free(p)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_new_trans()</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_realloc(p,n)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_rollback(t)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_size(p)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_strdup(s)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_strfree(ps)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>memt_alloc(t,n)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>memt_descr(t,p,n)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>memt_strdup(t,s)</B>  </TT>
<TD ALIGN="LEFT">(various)
</TABLE>
<H4>List of Type Definitions</H4>
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Type name:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>MEMHDR</B>  </TT>
<TD ALIGN="LEFT">struct _MEMHDR
<TR><TD ALIGN="LEFT"><TT><B>MEMTRN</B>  </TT>
<TD ALIGN="LEFT">struct _MEMTRN
<TR><TD ALIGN="LEFT"><TT><B>scavenger</B>  </TT>
<TD ALIGN="LEFT">Bool (*) (void *)
</TABLE>
<A NAME="mem_alloc_">&nbsp;</A>
<H3><A NAME="TOC211"><TT>mem_alloc_</TT></A></H3>
<PRE>
#include "sflmem.h"
void *
mem_alloc_ (
    MEMTRN     *trn,                    /*  Associated transaction           */
    size_t      size,                   /*  Desired size of memory block     */
    const char *filename,               /*  Name of source file making call  */
    size_t      lineno                  /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Allocates a memory block. Use the mem_alloc() macro to call
   this function! Use <A href="sfldoc.htm#mem_free_">mem free </A>() to free blocks allocated
   with this function. Returns a pointer to the allocated memory
   block, or NULL if there was not enough memory available. The
   supplied source file name is assumed to be in a static area.
   The requested block size must be greater than zero bytes.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    MEMHDR
       *ptr;                            /*  Allocated memory block           */

    /*  Allocate block with extra space for the header                       */
    ASSERT (size &gt; 0);                  /*  Cannot allocate zero bytes!      */

    ptr = malloc (RESERVE_SIZE + size);
    if (ptr == NULL)                    /*  If nothing free, do a hunt       */
      {                                 /*    and try again...               */
        mem_scavenge ();
        ptr = malloc (RESERVE_SIZE + size);
        if (ptr == NULL)
            return (NULL);              /*  Really in trouble now!           */
      }
#   if (defined (MEM_TRACE))
    <A href="sfldoc.htm#trace">trace</A> ("%s (%ld): alloc %d bytes-&gt;%p",
            filename? filename: "-", (long) lineno, size, ptr);
#   endif

    ptr-&gt; tag  = MEMTAG;                /*  Initialise block header          */
    ptr-&gt; size = size;                  /*  Size of block                    */
    ptr-&gt; file = filename;              /*  Who allocated it                 */
    ptr-&gt; line = lineno;                /*    and where                      */

    if (!trn)                           /*  If no transaction then use the   */
        trn = &amp;mem_list;                /*  main block list                  */

    list_reset (ptr);                   /*  Set up new block as list         */
    list_relink_before (ptr,            /*  Add to list of blocks            */
                        &amp;trn-&gt; memhdr);

    mem_total += size;                  /*  Keep count of space used         */
    mem_alloc_count += 1;               /*    and number of allocations      */

    return (HDR_2_CLIENT (ptr));        /*   and return client address       */
}
</PRE>
<A NAME="mem_realloc_">&nbsp;</A>
<H3><A NAME="TOC212"><TT>mem_realloc_</TT></A></H3>
<PRE>
#include "sflmem.h"
void *
mem_realloc_ (
    void       *client_ptr,             /*  Block of memory to reallocate    */
    size_t      size,                   /*  Desired size of memory block     */
    const char *filename,               /*  Name of source file making call  */
    size_t      lineno                  /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Reallocates a memory block, which remains part of the same
   transaction. Use the mem_realloc() macro to call this function!
   Accepts a pointer to a memory block and the desired size of the
   new memory block. Returns the address of the new memory block,
   or NULL if there was not enough memory available. If the
   specified block was not correctly allocated, dumps the memory
   allocation list and exits. The desired size must be greater
   than zero.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    MEMHDR
        *ptr,
        *next;

    ASSERT (client_ptr);
    ASSERT (size &gt; 0);

    /*  Check that block is valid                                            */
    ptr = CLIENT_2_HDR (client_ptr);
    if (ptr-&gt; tag != MEMTAG)
        mem_tag_err (ptr, filename, lineno);

    /*  Invalidate header                                                    */
    ptr-&gt; tag = MEMUNTAG;

    mem_total -= ptr-&gt; size;
    mem_free_count += 1;

    next = ptr-&gt; next;                  /*  Save where we were linked        */
    <A href="sfldoc.htm#list_unlink">list unlink</A> (ptr);                  /*     and unlink                    */

    /*  Reallocate memory block                                              */
    ptr = (MEMHDR *) realloc (ptr, RESERVE_SIZE + size);
    if (ptr == NULL)                    /*  If nothing free, do a hunt       */
      {                                 /*    and try again...               */
        mem_scavenge ();
        ptr = (MEMHDR *) realloc (ptr, RESERVE_SIZE + size);
        if (ptr == NULL)
            return (NULL);              /*  Really in trouble now!           */
      }

#   if (defined (MEM_TRACE))
    <A href="sfldoc.htm#trace">trace</A> ("%s (%ld): realloc %d bytes -&gt;%p",
            filename? filename: "-", (long) lineno, size, ptr);
#   endif

    /*  Update header                                                        */
    ptr-&gt; tag  = MEMTAG;
    ptr-&gt; size = size;
    ptr-&gt; file = filename;
    ptr-&gt; line = lineno;

    list_reset (ptr);                   /*  Set up block as list             */
    list_relink_before (ptr, next);     /*  And link where old block was     */

    mem_total += size;                  /*  Keep count of space used         */
    mem_alloc_count += 1;               /*    and number of allocations      */

    return (HDR_2_CLIENT (ptr));
}
</PRE>
<A NAME="mem_strdup_">&nbsp;</A>
<H3><A NAME="TOC213"><TT>mem_strdup_</TT></A></H3>
<PRE>
#include "sflmem.h"
char *
mem_strdup_ (
    MEMTRN     *trn,                    /*  Associated transaction           */
    const char *string,                 /*  String to copy                   */
    const char *filename,               /*  Name of source file making call  */
    size_t      lineno                  /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Saves a string in dynamic memory. Use the mem_strdup macro to
   call this function! The caller is responsible for freeing the
   space allocated when it is no longer needed. Returns a pointer
   to the allocated string, which holds a copy of the parameter
   string. Returns NULL if there was insufficient heap storage
   available to allocate the string, or if the original string was
   itself NULL.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    char *copy;
    size_t str_len;

    if (string)                         /*  If string not null, copy it      */
      {
        str_len = strlen (string) + 1;
        copy = <A href="sfldoc.htm#mem_alloc_">mem alloc </A> (trn, str_len, filename, lineno);
        if (copy)
            strncpy (copy, string, str_len);
      }
    else
        copy = NULL;                    /*  Just pass-through a NULL         */

    return (copy);
}
</PRE>
<A NAME="mem_strfree_">&nbsp;</A>
<H3><A NAME="TOC214"><TT>mem_strfree_</TT></A></H3>
<PRE>
#include "sflmem.h"
void
mem_strfree_ (
    char **string,                      /*  Address of string to free        */
    const char *filename,               /*  Name of source file making call  */
    size_t lineno                       /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Releases memory occupied by a string. Use the mem_strfree()
   macro to call this function! Call this function to free strings
   allocated using <A href="sfldoc.htm#mem_strdup_">mem strdup </A>(). Accepts the address of a
   char pointer as argument: if the pointer is not null, the
   string is freed, and the pointer is set to null. Returns the
   address of the modified pointer.
<H4>Examples</H4>
<PRE>
    char
        *string1 = NULL,
        *string2 = NULL;
    string1 = mem_strdup ("This is a string");
    mem_strfree (&string1);
    mem_strfree (&string2);
</PRE>
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    ASSERT (string);
    if (*string)
      {
        <A href="sfldoc.htm#mem_free_">mem free </A> (*string, filename, lineno);
        *string = NULL;
      }
}
</PRE>
<A NAME="mem_free_">&nbsp;</A>
<H3><A NAME="TOC215"><TT>mem_free_</TT></A></H3>
<PRE>
#include "sflmem.h"
void
mem_free_ (
    void *client_ptr,                   /*  Block of memory to free          */
    const char *filename,               /*  Name of source file making call  */
    size_t lineno                       /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Releases memory previously allocated by <A href="sfldoc.htm#mem_alloc_">mem alloc </A>(),
   <A href="sfldoc.htm#mem_realloc_">mem realloc </A>(), or <A href="sfldoc.htm#mem_strdup_">mem strdup </A>(). Use the mem_free()
   macro to call this function! If the specified block was not
   correctly allocated, dumps the memory allocation list and
   exits. If you specify a null address, does nothing.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    MEMHDR
       *ptr;

    if (client_ptr == NULL)             /*  Do nothing if address is null    */
        return;

    /*  Check for valid block                                                */
    ptr = CLIENT_2_HDR (client_ptr);
    if (ptr-&gt; tag != MEMTAG)
        mem_tag_err (ptr, filename, lineno);

#   if (defined (MEM_TRACE))
    <A href="sfldoc.htm#trace">trace</A> ("%s (%ld): free=%p",
           filename? filename: "-", (long) lineno, ptr);
#   endif
#   if (defined (DEBUG))
    memset (client_ptr, 0, ptr-&gt; size);
#   endif

    /*  Invalidate header                                                    */
    ptr-&gt; tag = MEMUNTAG;
    mem_total -= ptr-&gt; size;
    mem_free_count += 1;

    /*  Remove block from list, inlining code from <A href="sfldoc.htm#list_unlink">list unlink</A>()             */
    ((LIST *) ((LIST *) ptr)-&gt; prev)-&gt; next = ((LIST *) ptr)-&gt; next;
    ((LIST *) ((LIST *) ptr)-&gt; next)-&gt; prev = ((LIST *) ptr)-&gt; prev;

    free (ptr);
}
</PRE>
<A NAME="mem_assert_">&nbsp;</A>
<H3><A NAME="TOC216"><TT>mem_assert_</TT></A></H3>
<PRE>
#include "sflmem.h"
void
mem_assert_ (
    const char *filename,               /*  Name of source file making call  */
    size_t lineno                       /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Checks that all allocated memory was freed. Use the mem_assert
   macro to call this function! If any memory is still left
   allocated, displays the memory list on stderr and aborts.
   Generally we use this function at the end of a program, after
   deallocating all memory. If any memory has not been allocated,
   we get a nice list and an abort. Our principle is that any
   memory allocation must be matched by a free somewhere in the
   code.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    FILE
        *trace_file;

    if (mem_total != 0
    ||  !list_empty (&amp;tr_list))
      {
        fflush  (stdout);
        fprintf (stderr, "Clean-memory assertion failed - %s (%ld)\n",
                          filename? filename: "&lt;Unknown&gt;", (long) lineno);
        fprintf (stderr, "Details are in memtrace.lst\n");
        trace_file = fopen ("memtrace.lst", "w");
        <A href="sfldoc.htm#mem_display">mem display</A> (trace_file);
        fclose (trace_file);
        abort ();
      }
}
</PRE>
<A NAME="mem_checkall_">&nbsp;</A>
<H3><A NAME="TOC217"><TT>mem_checkall_</TT></A></H3>
<PRE>
#include "sflmem.h"
void
mem_checkall_ (
    const char *filename,               /*  Name of source file making call  */
    size_t lineno                       /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Checks all allocated memory blocks; if any block was corrupted,
   aborts with an error message, else does nothing.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    MEMTRN
        *trn;

#   if (defined (MEM_TRACE))
    <A href="sfldoc.htm#trace">trace</A> ("%s (%ld): check all memory",
           filename? filename: "-", (long) lineno);
#   endif

    mem_check_list ((MEMHDR *) &amp;mem_list.memhdr, filename, lineno);
    trn = tr_list.next;
    while (trn != (MEMTRN *) &amp;tr_list)
      {
        mem_check_list ((MEMHDR *) &amp;trn-&gt; memhdr, filename, lineno);
        trn = trn-&gt; next;
      }
}
</PRE>
<A NAME="mem_check_">&nbsp;</A>
<H3><A NAME="TOC218"><TT>mem_check_</TT></A></H3>
<PRE>
#include "sflmem.h"
void
mem_check_ (
    const void *client_ptr,             /*  Block of memory to free          */
    const char *filename,               /*  Name of source file making call  */
    size_t      lineno                  /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Checks that a block of memory has not been corrupted. If the
   block is corrupted, aborts with an error message, else does
   nothing.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    MEMHDR
       *ptr;

    if (client_ptr == NULL)             /*  Do nothing if address is null    */
        return;

    /*  Check for valid block                                                */
    ptr = CLIENT_2_HDR (client_ptr);
    if (ptr-&gt; tag != MEMTAG)
        mem_tag_err (ptr, filename, lineno);
}
</PRE>
<A NAME="mem_descr_">&nbsp;</A>
<H3><A NAME="TOC219"><TT>mem_descr_</TT></A></H3>
<PRE>
#include "sflmem.h"
DESCR *
mem_descr_ (
    MEMTRN     *trn,                    /*  Associated transaction           */
    const void *data_block,             /*  Block of memory to copy          */
    size_t      data_size,              /*  Size of memory block             */
    const char *filename,               /*  Name of source file making call  */
    size_t      lineno                  /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Allocates a DESCR block for a specified block of data. Use the
   mem_descr macro to call this function! Returns a pointer to an
   allocated DESCR block, or NULL if there was not enough memory.
   The DESCR block is allocated as a single block, consisting of
   the DESCR block plus the data. To free the entire block you
   need one call to mem_free(). If the data_block argument is not
   null, its contents are copied into the newly allocated memory.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    DESCR
        *descr;

    descr = <A href="sfldoc.htm#mem_alloc_">mem alloc </A> (trn, data_size + sizeof (DESCR), filename, lineno);
    if (descr == NULL)
        return (NULL);

#   if (defined (MEM_TRACE))
    <A href="sfldoc.htm#trace">trace</A> ("%s (%ld): allocate descr=%p",
           filename? filename: "-", (long) lineno, descr);
#   endif

    /*  Fill-in descriptor block unless it is NULL                           */
    descr-&gt; size = data_size;
    descr-&gt; data = (byte *) descr + sizeof (DESCR);
    if (data_block)
        memcpy (descr-&gt; data, data_block, data_size);

    return (descr);
}
</PRE>
<A NAME="mem_new_trans_">&nbsp;</A>
<H3><A NAME="TOC220"><TT>mem_new_trans_</TT></A></H3>
<PRE>
#include "sflmem.h"
MEMTRN *
mem_new_trans_(
    const char *filename,               /*  Name of source file making call  */
    size_t lineno                       /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Allocates a transaction block. Use the <A href="sfldoc.htm#mem_new_trans">mem new trans</A>()
   macro to call this function. Use mem_commit to save or
   <A href="sfldoc.htm#mem_rollback">mem rollback</A>() to delete the transaction. Returns a pointer
   to the allocated transaction block, or NULL if there was not
   enough memory available. The supplied source file name is
   assumed to be in a static area.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    MEMTRN
       *trn;                            /*  Allocated transaction block      */

    /*  Allocate block                                                       */
    trn = malloc (MEMTRN_SIZE);
    if (trn == NULL)
        return (NULL);

#   if (defined (MEM_TRACE))
    <A href="sfldoc.htm#trace">trace</A> ("%s (%ld): new transaction",
           filename? filename: "-", (long) lineno);
#   endif

    trn-&gt; file = (char *) filename;     /*  Who allocated it                 */
    trn-&gt; line = lineno;                /*    and where                      */
    list_reset (&amp;trn-&gt; memhdr);         /*  No memory blocks yet             */

    list_reset (trn);                   /*  Only 1 item in list              */
    list_relink_before (trn, &amp;tr_list);  /*  Add to list of transactions      */
    return (trn);                       /*   and return address              */
}
</PRE>
<A NAME="mem_commit_">&nbsp;</A>
<H3><A NAME="TOC221"><TT>mem_commit_</TT></A></H3>
<PRE>
#include "sflmem.h"
void
mem_commit_ (
    MEMTRN *trn,
    const char *filename,               /*  Name of source file making call  */
    size_t lineno                       /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Commits all blocks allocated to a given transaction.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    LIST
       *ptr;

#   if (defined (MEM_TRACE))
    <A href="sfldoc.htm#trace">trace</A> ("%s (%ld): commit transaction",
           filename? filename: "-", (long) lineno);
#   endif

    ptr = &amp;trn-&gt; memhdr;
    if (!list_empty (ptr))              /*  Are there any blocks to commit?  */
      {
        list_relink_before (ptr,        /*  Relink list into main list       */
                            &amp;mem_list. memhdr);
        <A href="sfldoc.htm#list_unlink">list unlink</A> (ptr);
      }

    mem_del_trans (trn);
}
</PRE>
<A NAME="mem_rollback_">&nbsp;</A>
<H3><A NAME="TOC222"><TT>mem_rollback_</TT></A></H3>
<PRE>
#include "sflmem.h"
void
mem_rollback_ (
    MEMTRN *trn,
    const char *filename,               /*  Name of source file making call  */
    size_t lineno                       /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Rolls back allocations for a particular transaction. This frees
   up all blocks allocated by calls to mem_alloc, mem_realloc and
   mem_strdup since the last call to mem_commit. Note that for
   blocks allocated with mem_realloc, this is not really a
   rollback but a free. The <A href="sfldoc.htm#mem_rollback">mem rollback</A>() function must be
   used with some care... if you forget to do a <A href="sfldoc.htm#mem_commit">mem commit</A>(),
   a later <A href="sfldoc.htm#mem_rollback">mem rollback</A>() will do damage to your memory space.
   The general rule is to start your processing with
   <A href="sfldoc.htm#mem_commit">mem commit</A>(), then do work, and call <A href="sfldoc.htm#mem_rollback">mem rollback</A>()
   when there is an error. Finally, call <A href="sfldoc.htm#mem_commit">mem commit</A>() at the
   end.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
#   if (defined (MEM_TRACE))
    <A href="sfldoc.htm#trace">trace</A> ("%s (%ld): rollback transaction",
           filename? filename: "-", (long) lineno);
#   endif

    mem_free_list ((MEMHDR *) &amp;trn-&gt; memhdr);
    mem_del_trans (trn);
}
</PRE>
<A NAME="mem_size_">&nbsp;</A>
<H3><A NAME="TOC223"><TT>mem_size_</TT></A></H3>
<PRE>
#include "sflmem.h"
size_t
mem_size_ (
    const void *client_ptr,             /*  Block of memory to free          */
    const char *filename,               /*  Name of source file making call  */
    size_t lineno                       /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Returns the size in bytes of a memory block.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    MEMHDR
       *ptr;

    if (client_ptr == NULL)             /*  Do nothing if address is null    */
        return 0;

    /*  Check for valid block                                                */
    ptr = CLIENT_2_HDR (client_ptr);
    if (ptr-&gt; tag != MEMTAG)
        mem_tag_err (ptr, filename, lineno);

    return (ptr-&gt; size);
}
</PRE>
<A NAME="mem_used">&nbsp;</A>
<H3><A NAME="TOC224"><TT>mem_used</TT></A></H3>
<PRE>
#include "sflmem.h"
long
mem_used (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns the number of bytes currently allocated using the
   memory management system. The value returned is simply the sum
   of the size requests to allocation routines. It does not
   reflect any overhead required by the memory management system.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    return (mem_total);
}
</PRE>
<A NAME="mem_allocs">&nbsp;</A>
<H3><A NAME="TOC225"><TT>mem_allocs</TT></A></H3>
<PRE>
#include "sflmem.h"
long
mem_allocs (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns the number of blocks allocated in total. Use this to
   get an idea of the activity of the memory management system.
   When program ends cleanly, <A href="sfldoc.htm#mem_allocs">mem allocs</A> () should be equal to
   <A href="sfldoc.htm#mem_frees">mem frees</A>().
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    return (mem_alloc_count);
}
</PRE>
<A NAME="mem_frees">&nbsp;</A>
<H3><A NAME="TOC226"><TT>mem_frees</TT></A></H3>
<PRE>
#include "sflmem.h"
long
mem_frees (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns the number of blocks freed in total. Use this to get an
   idea of the activity of the memory management system. When
   program ends cleanly, <A href="sfldoc.htm#mem_allocs">mem allocs</A> () should be equal to
   <A href="sfldoc.htm#mem_frees">mem frees</A>().
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    return (mem_free_count);
}
</PRE>
<A NAME="mem_display">&nbsp;</A>
<H3><A NAME="TOC227"><TT>mem_display</TT></A></H3>
<PRE>
#include "sflmem.h"
void
mem_display (
    FILE *fp                            /*  File to dump display to          */
)
</PRE>
<H4>Synopsis</H4>
<P>Displays the contents of the memory allocation list.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    MEMTRN
        *trn;

    fprintf (fp, "Index   Size  File(Line) - total size %lu\n", mem_total);
    mem_display_list ((MEMHDR *) &amp;mem_list.memhdr, fp);

    trn = tr_list.next;
    while (trn != (MEMTRN *) &amp;tr_list)
      {
        fprintf (fp, "* Transaction %s (%ld)",
                 trn-&gt; file? trn-&gt; file: "&lt;Unknown&gt;", (long) trn-&gt; line);
        fprintf (fp, "\n");
        mem_display_list ((MEMHDR *) &amp;trn-&gt; memhdr, fp);

        trn = trn-&gt; next;
      }
    fflush (fp);
}
</PRE>
<A NAME="mem_scavenger">&nbsp;</A>
<H3><A NAME="TOC228"><TT>mem_scavenger</TT></A></H3>
<PRE>
#include "sflmem.h"
int
mem_scavenger (
    scavenger scav_fct,                 /*  File to dump display to          */
    void    * scav_arg
)
</PRE>
<H4>Synopsis</H4>
<P>Registers a memory scavenger function. A memory scavenger
   function is an application function that is invoked by
   <A href="sfldoc.htm#mem_alloc_">mem alloc </A>() when memory is exhausted, so that unused
   application objects can be released. This allows you to
   allocate large amounts of memory -- for instance for caches --
   and then release them when memory runs short. When you register
   a scavenger function you may provide a void * argument; this is
   passed back to the scavenger if it is ever invoked. The
   scavenger function returns TRUE if it could release some
   memory, otherwise it returns FALSE. Note that there is no way
   to unregister such a function. Furthermore, a scavenger
   function should not itself allocate any new memory, unless it
   can definitely free excess memory first. Scavenger functions
   are called in an unspecified order. Returns 0 if the scavenger
   function could be registered, -1 if not. There is no limit to
   the number of scavenger functions you can register, except
   available memory. The same scavenger function can be registered
   several times.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    SCAVFCT
        *scavfct;                       /*  Allocated registry function      */

    /*  Allocate an SCAVFCT block and attach it to the scavfcts list         */
    list_create (scavfct, sizeof (SCAVFCT));
    if (scavfct == NULL)
        return (-1);
    list_relink_before (scavfct, &amp;scavfcts);

    scavfct-&gt; scav_fct = scav_fct;
    scavfct-&gt; scav_arg = scav_arg;
    return (0);
}
</PRE>
<A NAME="mem_freeall">&nbsp;</A>
<H3><A NAME="TOC229"><TT>mem_freeall</TT></A></H3>
<PRE>
#include "sflmem.h"
void
mem_freeall (void)
</PRE>
<H4>Synopsis</H4>
<P>Frees all allocated memory. This function is rather brutal and
   can do strange things to an application. It can be useful when
   you are trying to recover control in a crashed application, and
   need to free all allocated memory before restarting it.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    MEMTRN
        *trn;

    mem_free_list ((MEMHDR *) &amp;mem_list.memhdr);
    while (!list_empty (&amp;tr_list))
      {
        trn = tr_list.next;
        mem_free_list ((MEMHDR *) &amp;trn-&gt; memhdr);
        mem_del_trans (trn);
      }
}
</PRE>
<H2><A NAME="TOC230">MIME support functions</A></H2>
<P>Filename: sflmime.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 1996/03/28 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 1998/11/18
<BR>Copyright: Copyright (c) 1996-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Provides various functions that support MIME encoding and
   decoding. See RFC 1521 for details.
<H3>Notes</H3>
<PRE>
    Extract from RFC1521 for Base64 Content-Transfer-Encoding
    ---------------------------------------------------------

    The Base64 Content-Transfer-Encoding is designed to represent
    arbitrary sequences of octets in a form that need not be humanly
    readable.  The encoding and decoding algorithms are simple, but the
    encoded data are consistently only about 33 percent larger than the
    unencoded data.  This encoding is virtually identical to the one used
    in Privacy Enhanced Mail (PEM) applications, as defined in RFC 1421.
    The base64 encoding is adapted from RFC 1421, with one change: base64
    eliminates the "*" mechanism for embedded clear text.

    A 65-character subset of US-ASCII is used, enabling 6 bits to be
    represented per printable character. (The extra 65th character, "=",
    is used to signify a special processing function.)

    \NOTE: This subset has the important property that it is
    represented identically in all versions of ISO 646, including US
    ASCII, and all characters in the subset are also represented
    identically in all versions of EBCDIC.  Other popular encodings,
    such as the encoding used by the uuencode utility and the base85
    encoding specified as part of Level 2 PostScript, do not share
    these properties, and thus do not fulfill the portability
    requirements a binary transport encoding for mail must meet.

    The encoding process represents 24-bit groups of input bits as output
    strings of 4 encoded characters. Proceeding from left to right, a
    24-bit input group is formed by concatenating 3 8-bit input groups.
    These 24 bits are then treated as 4 concatenated 6-bit groups, each
    of which is translated into a single digit in the base64 alphabet.
    When encoding a bit stream via the base64 encoding, the bit stream
    must be presumed to be ordered with the most-significant-bit first.

    That is, the first bit in the stream will be the high-order bit in
    the first byte, and the eighth bit will be the low-order bit in the
    first byte, and so on.

    Each 6-bit group is used as an index into an array of 64 printable
    characters. The character referenced by the index is placed in the
    output string. These characters, identified in Table 1, below, are
    selected so as to be universally representable, and the set excludes
    characters with particular significance to SMTP (e.g., ".", CR, LF)
    and to the encapsulation boundaries defined in this document (e.g.,
    "-").

                      Table 1: The Base64 Alphabet

      Value Encoding  Value Encoding  Value Encoding  Value Encoding
           0 A            17 R            34 i            51 z
           1 B            18 S            35 j            52 0
           2 C            19 T            36 k            53 1
           3 D            20 U            37 l            54 2
           4 E            21 V            38 m            55 3
           5 F            22 W            39 n            56 4
           6 G            23 X            40 o            57 5
           7 H            24 Y            41 p            58 6
           8 I            25 Z            42 q            59 7
           9 J            26 a            43 r            60 8
          10 K            27 b            44 s            61 9
          11 L            28 c            45 t            62 +
          12 M            29 d            46 u            63 /
          13 N            30 e            47 v
          14 O            31 f            48 w         (pad) =
          15 P            32 g            49 x
          16 Q            33 h            50 y

    The output stream (encoded bytes) must be represented in lines of no
    more than 76 characters each.  All line breaks or other characters
    not found in Table 1 must be ignored by decoding software.  In base64
    data, characters other than those in Table 1, line breaks, and other
    white space probably indicate a transmission error, about which a
    warning message or even a message rejection might be appropriate
    under some circumstances.

    Special processing is performed if fewer than 24 bits are available
    at the end of the data being encoded.  A full encoding quantum is
    always completed at the end of a body.  When fewer than 24 input bits
    are available in an input group, zero bits are added (on the right)
    to form an integral number of 6-bit groups.  Padding at the end of
    the data is performed using the '=' character.  Since all base64
    input is an integral number of octets, only the following cases can
    \arise: (1) the final quantum of encoding input is an integral
    multiple of 24 bits; here, the final unit of encoded output will be
    an integral multiple of 4 characters with no "=" padding, (2) the
    final quantum of encoding input is exactly 8 bits; here, the final
    unit of encoded output will be two characters followed by two "="
    padding characters, or (3) the final quantum of encoding input is
    exactly 16 bits; here, the final unit of encoded output will be three
    characters followed by one "=" padding character.

    Because it is used only for padding at the end of the data, the
    occurrence of any '=' characters may be taken as evidence that the
    end of the data