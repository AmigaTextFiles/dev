<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libSPS++: /Storage/projects/sps/sps_timer.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>/Storage/projects/sps/sps_timer.cpp</h1><div class="fragment"><pre>00001 <span class="preprocessor">#include &lt;<a class="code" href="sps__timer_8h.html">sps/sps_timer.h</a>&gt;</span>
00002 <span class="preprocessor">#include &lt;<a class="code" href="sps__types_8h.html">sps/sps_types.h</a>&gt;</span>
00003 <span class="preprocessor">#include &lt;<a class="code" href="sps__exception_8h.html">sps/sps_exception.h</a>&gt;</span>
00004 
00005 <span class="preprocessor">#include &lt;proto/exec.h&gt;</span>
00006 <span class="preprocessor">#include &lt;proto/timer.h&gt;</span>
00007 
00008 SPS_Timer::SPS_Timer() 
00009     : m_TimerPort(NULL)
00010     , m_TimerRequest(NULL)
00011     , ITimer(NULL)   
00012 {
00013     <span class="keywordflow">try</span> {
00014         m_TimerPort = reinterpret_cast&lt;struct MsgPort*&gt;(IExec-&gt;AllocSysObject(ASOT_PORT, NULL));
00015         <span class="keywordflow">if</span> ( !m_TimerPort ) {
00016             Throw1( <span class="stringliteral">"Cannot allocate timer port "</span> );
00017         }
00018         m_TimerRequest = reinterpret_cast&lt;struct timerequest*&gt;(
00019                                 IExec-&gt;AllocSysObjectTags(ASOT_IOREQUEST,
00020                                                           ASOIOR_ReplyPort, m_TimerPort,
00021                                                           ASOIOR_Size,      <span class="keyword">sizeof</span>(<span class="keyword">struct</span> timerequest),
00022                                                           TAG_DONE));
00023         <span class="keywordflow">if</span> (!m_TimerRequest) {
00024             Throw1( <span class="stringliteral">"Cannot creater time request"</span> );
00025         }
00026         <span class="keywordflow">if</span> ( IExec-&gt;OpenDevice(<span class="stringliteral">"timer.device"</span>, UNIT_WAITUNTIL, reinterpret_cast&lt;struct IORequest*&gt;(m_TimerRequest), 0)) {
00027             Throw1( <span class="stringliteral">"Cannot open timer.device"</span> );
00028         }
00029         
00030         <span class="keyword">struct </span>Library *TimerBase = &amp;m_TimerRequest-&gt;tr_node.io_Device-&gt;dd_Library;
00031         <span class="keywordflow">if</span> (!TimerBase) {
00032             Throw1( <span class="stringliteral">"No TimerBase (huh?)"</span> );
00033         }
00034         ITimer = (<span class="keyword">struct </span>TimerIFace *)IExec-&gt;GetInterface( TimerBase, <span class="stringliteral">"main"</span>, 1, 0 );
00035         <span class="keywordflow">if</span> ( !ITimer ) {
00036             Throw1( <span class="stringliteral">"No Timer Interface."</span> );
00037         }
00038     } <span class="keywordflow">catch</span> ( ... ) {
00039         <span class="comment">// make sure we clean us up on error</span>
00040         this-&gt;~SPS_Timer();
00041         <span class="comment">// and pass it on to our creator</span>
00042         <span class="keywordflow">throw</span>;
00043     }
00044 }
00045 
00046 SPS_Timer::~SPS_Timer()
00047 {
00048     <span class="keywordflow">if</span> ( m_TimerRequest )  {
00049         <span class="comment">// we have to use at least one IO Request, or WaitIO() will crash. </span>
00050         this-&gt;Delay( 1 );
00051         <span class="comment">// clean up the device</span>
00052         <span class="keywordflow">if</span> (!IExec-&gt;CheckIO(reinterpret_cast&lt;struct IORequest*&gt;(m_TimerRequest))) {
00053             IExec-&gt;AbortIO(reinterpret_cast&lt;struct IORequest*&gt;(m_TimerRequest));
00054         }
00055         IExec-&gt;WaitIO(reinterpret_cast&lt;struct IORequest*&gt;(m_TimerRequest));
00056         
00057         IExec-&gt;CloseDevice( reinterpret_cast&lt;struct IORequest*&gt;(m_TimerRequest) );
00058         IExec-&gt;FreeSysObject(ASOT_IOREQUEST, static_cast&lt;void*&gt;(m_TimerRequest));
00059         m_TimerRequest = NULL;
00060     }
00061     <span class="keywordflow">if</span> ( m_TimerPort ) {
00062         IExec-&gt;FreeSysObject(ASOT_PORT, static_cast&lt;void*&gt;(m_TimerPort));
00063         m_TimerPort = NULL;
00064     }
00065     ITimer = NULL; <span class="comment">// local timer iface!    </span>
00066 }
00067 
00068 <span class="comment">/* wait for given time in ms */</span>    
00069 <span class="keywordtype">void</span> SPS_Timer::Delay( uint32 ms )
00070 {
00071     WaitWithTimeout( 0, ms );
00072 }
00073 
00074 <span class="keywordtype">void</span> SPS_Timer::MicroDelay( <span class="keywordtype">double</span> ticks )
00075 {
00076     uint32 tv_secs   = static_cast&lt;uint32&gt;(ticks / 1000.0);
00077     uint32 tv_micro  = static_cast&lt;uint32&gt;((ticks * 1000.0) - (tv_secs * 1000 * 1000));
00078 
00079     m_TimerRequest-&gt;tr_node.io_Command = TR_ADDREQUEST;
00080     m_TimerRequest-&gt;tr_time.tv_secs    = tv_secs;
00081     m_TimerRequest-&gt;tr_time.tv_micro   = tv_micro;
00082 
00083     <span class="comment">// the new time is the current time + the wait time</span>
00084     <span class="keyword">struct </span>timeval current_time;
00085     ITimer-&gt;GetSysTime(&amp;current_time);
00086     ITimer-&gt;AddTime(&amp;m_TimerRequest-&gt;tr_time, &amp;current_time );
00087 
00088     <span class="comment">// clear signal</span>
00089     IExec-&gt;SetSignal( 0, 1L &lt;&lt; m_TimerPort-&gt;mp_SigBit );
00090     <span class="comment">// request a timeout</span>
00091     IExec-&gt;SendIO(reinterpret_cast&lt;struct IORequest*&gt;(m_TimerRequest));
00092 
00093     <span class="comment">// wait for timer &amp; other sigs</span>
00094     IExec-&gt;Wait( 1L &lt;&lt; m_TimerPort-&gt;mp_SigBit );
00095 }
00096 
00097 uint32 SPS_Timer::WaitWithTimeout( uint32 sigs, uint32 ms )
00098 {  
00099     <span class="keywordflow">if</span> ( ms &gt; 0 &amp;&amp; m_TimerPort &amp;&amp; m_TimerRequest ) {
00100 
00101         uint32 tv_secs   = (ms / 1000);
00102         uint32 tv_micro  = (ms * 1000) - (tv_secs * 1000 * 1000);
00103 
00104         m_TimerRequest-&gt;tr_node.io_Command = TR_ADDREQUEST;
00105         m_TimerRequest-&gt;tr_time.tv_secs    = tv_secs;
00106         m_TimerRequest-&gt;tr_time.tv_micro   = tv_micro;
00107 
00108         <span class="comment">// the new time is the current time + the wait time</span>
00109         <span class="keyword">struct </span>timeval current_time;
00110         ITimer-&gt;GetSysTime(&amp;current_time);
00111         ITimer-&gt;AddTime(&amp;m_TimerRequest-&gt;tr_time, &amp;current_time );
00112 
00113         <span class="comment">// clear signal</span>
00114         IExec-&gt;SetSignal(0, 1L &lt;&lt; m_TimerPort-&gt;mp_SigBit );
00115         <span class="comment">// request a timeout</span>
00116         IExec-&gt;SendIO(reinterpret_cast&lt;struct IORequest*&gt;(m_TimerRequest));
00117 
00118         <span class="comment">// wait for timer &amp; other sigs</span>
00119         sigs = IExec-&gt;Wait( 1L &lt;&lt; m_TimerPort-&gt;mp_SigBit | sigs );
00120     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( sigs ) {
00121         sigs = IExec-&gt;Wait( sigs );
00122     }
00123     <span class="keywordflow">return</span> sigs;
00124 }
00125 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Sep 1 18:05:20 2006 for libSPS++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
