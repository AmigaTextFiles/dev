<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libSPS++: /Storage/projects/sps/sps_thread.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>/Storage/projects/sps/sps_thread.cpp</h1><div class="fragment"><pre>00001 <span class="preprocessor">#include &lt;sps/sps_thread.h&gt;</span>
00002 <span class="preprocessor">#include &lt;<a class="code" href="sps__types_8h.html">sps/sps_types.h</a>&gt;</span>
00003 
00004 <span class="preprocessor">#include &lt;proto/exec.h&gt;</span>
00005 <span class="preprocessor">#include &lt;proto/dos.h&gt;</span>
00006 
00007 
00008 SPS_Thread::SPS_Thread() 
00009     : m_Task(NULL)
00010     , m_Parent(IExec-&gt;FindTask(NULL))
00011 {
00012     m_InternalScopeLock = static_cast&lt;struct SignalSemaphore*&gt;(IExec-&gt;AllocSysObject(ASOT_SEMAPHORE, NULL));
00013     m_InternalSignal    = IExec-&gt;AllocSignal( -1 );
00014 }
00015 
00016 SPS_Thread::~SPS_Thread()
00017 {
00018     <a class="code" href="sps__types_8h.html#a0">_D</a>(<span class="stringliteral">"SPS_Thread::~SPS_Thread() - Wait Semaphore.\n"</span>);
00019 
00020     <span class="comment">// and wait until it is cleared (only if we have a thread!)</span>
00021     <span class="keywordflow">if</span> ( m_Task ) {
00022         IExec-&gt;ObtainSemaphore( m_InternalScopeLock );  <span class="comment">// wait for thread to return</span>
00023         IExec-&gt;ReleaseSemaphore( m_InternalScopeLock ); <span class="comment">// and unlock us again</span>
00024     }
00025     IExec-&gt;FreeSysObject(ASOT_SEMAPHORE, static_cast&lt;void*&gt;(m_InternalScopeLock));
00026     IExec-&gt;FreeSignal( m_InternalSignal );
00027 
00028     <a class="code" href="sps__types_8h.html#a0">_D</a>(<span class="stringliteral">"SPS_Thread::~SPS_Thread() - Done.\n"</span>);
00029 }
00030 
00031 <span class="keyword">struct </span>Task * SPS_Thread::Create( <span class="keyword">const</span> <span class="keywordtype">char</span> * name, int32 pri, uint32 stack )
00032 {
00033     <span class="comment">// don't create it twice!</span>
00034     <span class="keywordflow">if</span> (m_Task) {
00035         <span class="keywordflow">return</span> m_Task;
00036     }
00037     <span class="comment">// warning! m_Task is not safe within the thread function! Only used inside the creater context!</span>
00038     <span class="keywordflow">if</span> ( (m_Task = (Task*)IDOS-&gt;CreateNewProcTags(NP_Name,     name,
00039                                                   NP_Entry,    (ULONG)(&amp;EntryStub),
00040                                                   NP_Priority, pri,
00041                                                   NP_StackSize,stack,
00042                                                   NP_Child,    <span class="keyword">true</span>,
00043                                                   NP_UserData, <span class="keyword">this</span>,
00044                                                   TAG_DONE,    TAG_DONE)) != NULL )
00045     {
00046         <span class="comment">/* a CTRL-C interrupts the wait, but does not terminate the thread! */</span>
00047         <span class="keywordflow">if</span> ( IExec-&gt;Wait( (1&lt;&lt;m_InternalSignal) | SIGBREAKF_CTRL_C | SIGBREAKF_CTRL_E ) &amp; SIGBREAKF_CTRL_E ) {
00048             <span class="comment">// if task init fails (OnEntry() returns false) -&gt; we get a CTRL-E,</span>
00049 
00050             <span class="comment">// wait until the thread ran thru it's clean up code (m_Task will be set to NULL by the task)</span>
00051             IExec-&gt;ObtainSemaphore( m_InternalScopeLock );
00052             IExec-&gt;ReleaseSemaphore( m_InternalScopeLock );
00053             m_Task = NULL;
00054         }
00055     }
00056     <span class="keywordflow">return</span> m_Task;
00057 }
00058 
00059 <span class="keywordtype">void</span> SPS_Thread::Destroy()
00060 {
00061     <a class="code" href="sps__types_8h.html#a0">_D</a>(<span class="stringliteral">"SPS_Thread::Destroy() - Enter.\n"</span>);
00062     <span class="keywordflow">if</span> (m_Task)
00063     {
00064         <span class="comment">//kill the thread</span>
00065         this-&gt;Signal( SIGBREAKF_CTRL_C );
00066 
00067         <span class="comment">// and wait until it is cleared</span>
00068         IExec-&gt;ObtainSemaphore( m_InternalScopeLock );  <span class="comment">// wait for thread to return</span>
00069         IExec-&gt;ReleaseSemaphore( m_InternalScopeLock ); <span class="comment">// and unlock us again</span>
00070         <span class="comment">/**************/</span>
00071         m_Task = NULL;                          <span class="comment">// now it's save to set the handle to NULL</span>
00072         <span class="comment">/**************/</span>
00073     }
00074     <a class="code" href="sps__types_8h.html#a0">_D</a>(<span class="stringliteral">"SPS_Thread::Destroy() - Out.\n"</span>);
00075 }
00076 
00077 <span class="keywordtype">void</span> SPS_Thread::Signal( uint32 sig <span class="comment">/* = SIGBREAKF_CTRL_C */</span>)
00078 {
00079     <span class="keywordflow">if</span> (m_Task) IExec-&gt;Signal( m_Task, sig );
00080 }
00081 
00082 <span class="keywordtype">void</span> SPS_Thread::EntryStub( <span class="keywordtype">void</span> )
00083 {
00084     <span class="comment">/* Warning! Do not use m_Task here!! */</span>
00085     <span class="keyword">struct </span>Task *task = IExec-&gt;FindTask( NULL );
00086     <span class="comment">/* dynamic cast is not 100% safe here and only valid if tc_UserData contains some form</span>
00087 <span class="comment">     * of an C++ object (! no POD data!) */</span>
00088     SPS_Thread *thread_object = dynamic_cast&lt;SPS_Thread*&gt;((SPS_Thread*)task-&gt;tc_UserData);
00089     <span class="keywordflow">if</span> (thread_object) {
00090         thread_object-&gt;ThreadEntry();
00091     }
00092 }
00093 
00094 <span class="keywordtype">void</span> SPS_Thread::ThreadEntry( <span class="keywordtype">void</span> )
00095 {
00096     <span class="comment">// lock the main, so we can savely terminate</span>
00097     IExec-&gt;ObtainSemaphore( m_InternalScopeLock );
00098     <span class="comment">// WARNING! Do not access m_Task form within the Entry function!!! Main process might clear this while we are running!!!</span>
00099     <span class="keyword">struct </span>Task* task = IExec-&gt;FindTask( NULL ); 
00100 
00101     <a class="code" href="sps__types_8h.html#a0">_D</a>(<span class="stringliteral">"SPS_Thread::ThreadEntry( [%s@%08x] ) - In.\n"</span>, task-&gt;tc_Node.ln_Name, (uint32)task );
00102 
00103     <span class="comment">// allocate resource if needed. (this is also available by the DOS.lib now)</span>
00104     <span class="keywordflow">if</span> ( OnEntry() ) {
00105         <span class="comment">// signal that we are alive</span>
00106         <span class="keywordflow">if</span> ( m_Parent ) {
00107             IExec-&gt;Signal( m_Parent, 1 &lt;&lt; m_InternalSignal );
00108 
00109             <span class="comment">// run the thread</span>
00110             Run();
00111         }
00112 
00113     } <span class="keywordflow">else</span> {
00114         <span class="comment">// we failed. Need to wakeup the parent and terminate</span>
00115         <span class="keywordflow">if</span> ( m_Parent ) {
00116             IExec-&gt;Signal( m_Parent, SIGBREAKF_CTRL_E );
00117         }
00118     }
00119 
00120     <span class="comment">// and clean it up again - even if we've failed before</span>
00121     OnExit( );
00122     <a class="code" href="sps__types_8h.html#a0">_D</a>(<span class="stringliteral">"SPS_Thread::ThreadEntry( [%s@%08x] ) - Out.\n"</span>, task-&gt;tc_Node.ln_Name, (uint32)task );
00123 
00124     <span class="comment">// unlock after we have freed everything after Run()</span>
00125     IExec-&gt;ReleaseSemaphore( m_InternalScopeLock );
00126 }
00127 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Sep 1 18:05:20 2006 for libSPS++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
