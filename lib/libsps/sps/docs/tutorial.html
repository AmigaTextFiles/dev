<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <title>libsps++</title>
</head>

<body text="#000000" bgcolor="#FFFFFF" link="#CC6600" vlink="#51188E" alink="#FF0000">

<H1>libSPS++</H1>
<H4>An AmigaOS4.x C++ Multi-Threading Library</H4>
<br>
Document History:<br>
<table border="0" cellpadding="0" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td width="4%" valign="top">v1.0</td><td width="8%" valign="top">09.10.2006</td><td width="13%" valign="top">Jürgen Schober</td><td width="75%" valign="top">Initial Document</td>
    </tr>
  </tbody>
</table>

<br>
<H3><A NAME="Index">Table of contets</A></H3>
<p>
<OL>
    <LI><A HREF="#P1">Introduction</A>
    <LI><A HREF="#P2">Requirements</A>
    <LI><A HREF="#P3">Messages</A>
    <OL>
        <LI><A HREF="#P3.1">The class SPS_Message</A>
        <LI><A HREF="#P3.2">SPS_ExecMessage</A>
        <LI><A HREF="#P3.3">An Example Message</A>
    </OL>
    <LI><A HREF="#P4">Threads</A>
    <OL>
        <LI><A HREF="#P4.1">SPS_Thread Basics</A>
        <LI><A HREF="#P4.2">Implementation</A>
        <OL>
            <LI><A HREF="#P4.2.1">OnEntry()</A>
            <LI><A HREF="#P4.2.2">OnExit()</A>
            <LI><A HREF="#P4.2.3">Run()</A>
        </OL>
        <LI><A HREF="#P4.3">Thread Terminiation</A>
        <LI><A HREF="#P4.4">A simple Thread</A>
        <OL>
            <LI><A HREF="#P4.4.1">SendMessage()</A>
            <LI><A HREF="#P4.4.2">Async vc. Sync Messages</A>
            <LI><A HREF="#P4.4.3">A Warning!</A>
        </OL>
        <LI><A HREF="#P4.5">Thread Construction and Destruction</A>
        <OL>
            <LI><A HREF="#P4.5.1">OnEntry() - Thread Constructor</A>
            <LI><A HREF="#P4.5.2">OnExit() - Thread Destructor</A>
            <LI><A HREF="#P4.5.3">Run() - The Thread Main Loop</A>
        </OL>
        <LI><A HREF="#P4.6">Notes about SPS_Threads</A>
    </OL>
    <LI><A HREF="#P5">Hooks</A>
    <LI><A HREF="#P6">Main</A>
    <LI><A HREF="#A">Appendix</A>
    <OL>
        <LI><A HREF="#A1">The SPS_Timer</A>
        <OL>
            <LI><A HREF="#A1.1">Delay Methods</A>
            <LI><A HREF="#A1.2">WaitWithTimeout</A>
        </OL>
        <LI><A HREF="#A2">SPS_Exception</A>
        <LI><A HREF="#A3">Macros</A>
        <LI><A HREF="#A4">Doxygen</A>
    </OL>
</OL>
<p>

<H3><A NAME="P1">1. Introduction</A></H3>
<p>
The libsps++.a is a spin off from another project I was actually working on, the SambaPM. SambaPM will
be releases as a separate archive later.
<p>
SambaPM is a highly multithreaded application. Using Amiga tasks and processes is kind of complicated,
in my opinion. Other operating system offer way more elegant solutions then the AmigaOS does with its plain
C interface (eventhough the C interface is very flexible and powerfull).
<p>
SambaPM is written in C++, an thus I added my own C++ multihreaded library to it. This project contains a thread class,
message classes and some other common used functions. Later I was working on another project, where it turned out I
could easily re-use the functionality used in SambaPM. I began to strip out these functions and the result
is the libsps++.a, a multithreading C++ link library.
<p>
The library offers a class to easily create and run (child) threads, send messages
without the need to know what a "struct Message" is, can implement hooks without a "struct Hook" and add some more
functions thru a timer class (Delay, WaitWithTimeout(). In addition, full exception handling is provided thru the
SPS_Exception class. Further more, OPEN_IFACE() and CLOSE_IFACE() macros make it much easier to handle AmigaOS 4 interfaces,
usually this becomes a one liner now.
<p>
SPS_Threads and SPS_Hooks are implemented thru inheritance and provide virtual
entry points for either of their entry points (thread entry and hook entry).
<p>
SPS_Messages are implemented thru a template class and hide the complex mechanism of AmigaOS struct Message data structures,
but allow you to simply attach a data-only block as a template to the message. Also, the message provides a simple
interface to send a message without the need to handle and wait for a reply messages. Both, synchronous and asynchronous sending
is supported thru one common interface.


<!-- ######### Paragraph 2 ############# -->

<H3><A NAME="P2">2. Requirements</A></H3>
<p>
To use the libsps++.a, we need to link the application against the libspsp++.a (obsiously) and we
also need to include several header files. All include files can be found in a
subdirectory called "sps".
<p>
These files are available:
<p>
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
002: <font color="#000080">#include</font> <font color="#FF0000">&lt;sps/sps_exception.h&gt;</font>
003: <font color="#000080">#include</font> <font color="#FF0000">&lt;sps/sps_thread.h&gt;</font>
004: <font color="#000080">#include</font> <font color="#FF0000">&lt;sps/sps_timer.h&gt;</font>
005: <font color="#000080">#include</font> <font color="#FF0000">&lt;sps/sps_message.h&gt;</font>
006: <font color="#000080">#include</font> <font color="#FF0000">&lt;sps/sps_hook.h&gt;</font>
      </tt></pre></td>
    </tr>
  </tbody>
</table>
<p>
<table border="0" cellpadding="0" cellspacing="2">
  <tbody>
   <tr><td><LI>sps_message.h</td><td></td><td>Message related functions (message objects rather then dump structs)</td></tr>
   <tr><td><LI>sps_thread.h</td><td></td><td>Thread specific code</td></tr>
   <tr><td><LI>sps_hook.h</td><td></td><td>C++ hooks to completely replace the struct Hook setup.</td></tr>
   <tr><td><LI>sps_exception.h</td><td></td><td>All exception specific functions</td></tr>
   <tr><td><LI>sps_timer.h</td><td></td><td>A timer helper class which provides functions like
                    Delay(), MicroDelay() and WaitWithTimeout() without the need
                    to worry about the timer device and libraries, etc.</td></tr>
   <tr><td cellspan="2"><br>And additionally<br><br></td></tr>
   <tr><td><LI>sps_types.h</LI></td><td></td><td>Macros for opening and closing interfaces and libraries under OS4</td></tr>
  </tbody>
</table>
<table border="0" cellpadding="0" cellspacing="2">
  <tbody>
  </tbody>
</table>
<p>
Your searchpath should include the directory, where the sps headers are installed. The headers are usually installed in
a subdirectory ./sps/, the path for the AmigaOS4 SDK is sdk:local/common/include.
<p>
The code also needs to be linked against the libsps++.a. Currently only the newlib version is included as a binary, but a
clib2 version can easily be build from the included source code.

<!-- ######### Paragraph 3 ############# -->

<H3><A NAME="P3">3. Messages</A></H3>
<br>
SPS allows you to use message "objects" rather then just data structures. It
also simplifies the process of initialising a struct Message by allowing a
SPS_Message beeing abstract from an exec type struct Message. What this means is,
that you do not need to embedd or derive your new Message from an Exec struct Message,
rather define any type of data structure - or even a class - you want to transport the
data with. As already mentioned, the message body does not necessarily need to be
a dump data structure, it can also be a class.
<p>
This concept has some limitations, however. Every message is packed into and therefore must be derived from
a class SPS_Message and must share its interface. Two template implementations are
available, both are basically identically, but offer a different functionality
on sending messages. These two standard classes should be sufficient to transport
whatever you want to send. The template contains the actual body, and thus is flexible.
<p>

<H4><A NAME="P3.1">3.1 The class SPS_Message</A></H4>
<p>
The SPS_Message interface provides methods to send data to AmigaOS message ports
and also provides a synchronisation mechanism for synchronous or asynchronous
messages, actually this is embedded into the class and the application programmer does
not need to worry if he/she has to wait for a reply message or not - no matter if the
message is sent synchronously or asynchronously.
<p>
The interface also provides a method to check if a received message was
send synchronously or asynchronously.
<p>
That said, a receiver might handle both, synchronous and asynchronous message
which in fact share the exact same data. A sender can send a message thru both methods,
synchronous or asynchronous.
<p>
The data are packed into an abstract template member, called the Body. The body
can be a POD or NON-POD data (incl. classes, not just simple data structs).
<p>
Because the data are a member of an SPS_Message, the message framework always
remains the same, even if the data change.
<p>
Please note: This does not solve the problem, that the receiver MUST know the
datatype of the Body. The sender and receiver must match! If you want
to abstract this, the application must take care of it (e.g. thru type keys
and/or union). The SPS_Message does not contain any type information of its
body! (However, when using RTTI, a dynamic_cast<> is possible - but will fail,
if the received data are no object at all (e.g. if the object does not contain any
class information, e.g. system structures and the like)).
<p>
When sending a SPS_Message (or to be more specific a SPS_SyncMessageT<> or
SPS_AsyncMessageT<>), the receiver must expect a SPS_Message of some kind. It is
not legal to cast this message to a simple Exec message (well, technically one
can do that). This limits the use of SPS_Messages to some degree because a
thread waiting for a SPS_Message is limited to just receiving SPS_Messages. You cannot mix
other struct Messages with SPS_Messages (but this usually applies to any ibc message in AmigaOS).
<p>

<H4><A NAME="P3.2">3.2 SPS_ExecMessage</A></H4>
<p>
To solve this problem at least partially a special exec message type is
available which provides the same simple interface for the sender as
SPS_Messages, but allows the receiver to handle the message as a standard exec
message. The SPS_ExecMessage<> offers the same interface like the SPS_Message above,
but the message data itself must be derived (or contain) a struct Message
header. This header does not need to be initialized and a reply port is not
required, instead this is generated by the SPS_ExecMessage. Instead of sending
the whole SPS_ExecMessage, only the body is sent and this message can (e.g.)
still be used for inter process messages (do not send a SPS_Message to another
process! SPS_Message should only be used within a process and between threads).
<p>
The downside here is, however, that the receiver will receive a standard exec Message,
rather then the SPS_ExecMessage. This is just a temporary framework, which uses
a C++ constructor to initialize a message header and body and offers a simple Send() method.
<p>
Also SPS_ExecMessages are always sent synchronously.


<H4><A NAME="P3.3">3.3 An Example Message</A></H4>
<p>
Lets start with a simple message body:
<br>
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
021: <font color="#0000FF">class</font><B> MyMessage</b>
022: <font color="#000000">{</font>
023: <font color="#0000FF">public</font>:
024:     <font color="#000000">MyMessage</font>() <font color="#000000">{</font><font color="#000000">}</font>
025: 
026:     <font color="#9A1900">/* create a new message */</font>
027:     <font color="#000000">MyMessage</font>( <font color="#0000FF">const</font> <font color="#33CC00">char</font>* msg )
028:         : <font color="#000000">m_Message</font>( msg )
029:     <font color="#000000">{</font><font color="#000000">}</font>
030:     <font color="#9A1900">/* copy the message */</font>
031:     <font color="#000000">MyMessage</font>( <font color="#0000FF">const</font> MyMessage&amp; msg )
032:         : <font color="#000000">m_Message</font>( msg.m_Message.<font color="#000000">c_str</font>() )
033:     <font color="#000000">{</font><font color="#000000">}</font>
034: 
035:     <font color="#9A1900">/*! some message body */</font>
036:     std::string m_Message;     
037: <font color="#000000">}</font>;
      </tt></pre></td>
    </tr>
  </tbody>
</table>
<br>
This message class is a simple data kind of structure. Some goodies, though:
<p>
<UL>
<LI>It is a class, and thus can offer interfaces to the data (for the experts here: a struct in C++ can do that, too).</LI>
<LI>we can use complex data members, in our case a STL string object.</LI>
</UL>
<p>
Before we continue, we have to talk about threads. We need to send the message
between entities. We need threads.

<!-- ######### Paragraph 4 ############# -->

<H3><A NAME="P4">4. Threads</A></H3>
<p>
Before we continue with how to use SPS_Messages, we need to know how to create a
thread. We define a child as "child thread" and the application as a "process".
Usually an application will most likely create child threads. Cloning of a
thread or process is not supported. Also, detaching of a thread or process is
not supported.


<H4><A NAME="P4.1">4.1 SPS Thread Basics</A></H4>
<p>
The SPS_Thread is implemented as a DOS child "Process". The term "Process" here
is used in the AmigaOS context in contrary to a Task. A process under AmigaOS
allows to use dos.library resources, while a task does not. Tasks are therefore
miminalistic threads, processes are complexer and add more overhead - usually when created and
scheduled. However, on AmigaOS4, it is recommended to use dos processes
rather then exec task despite the minimal bigger overhead compared to the
greater functionality.
<p>
New in AmigaOS4 is the possibility to create a DOS "child process", which is
actually attached to a main process and which synchronises the exit case of the
application with its child processes. In a general term, this behaves now like a
"process" and "thread" in other operating systems. This is, the application is
the "process", other "tasks" are threads and run within this "process". The AmigaOS 4
is still a linear 32bit memory model (even though it now supports pageing), but per
process memory spaces are not supported (yet). This said, to the outside world around
the process, both, process and thread might apear as equal (e.g. in a flat task list).
<p>
Within this documentation we refer to "process" as the application and "thread"
as the child "dos-Process".
<p>
Under AmigaOS this boundary is not that strict, as already mentioned above. However,
we define this strictly this way, eventhough, there is no way to re-enforce it.


<H4><A NAME="P4.2">4.2 Implementation</A></H4>
<p>
The SPS_Thread implementation is a wrapper class which implements a dos.library
"child process". It offers virtual entry points for the thread function and does
not require a static entry functions any more (well, yes, internally there is one
hidden generic static C-style entry function). Further more, the thread class
offers virtual functions on entry and exit of the thread (these are kind of a
thread context based contructor/destructor pair). The intressting part here is,
that the 'this' pointer, and therefore the thread object is available to the thread
at this time already.
<p>
A side note: the AmigaOS4.x dos.library offers entry and exit funtions itself, however, those
are not used because we need the object context within the entry and exit
functions. Also, the entry method (SPS_Thread::OnEntry()) blocks the main
process uppon return - and might fail! Thus, the main process can react, if a
thread can be run successfully and can handle errors accordingly. Also, because the
OnEntry() is synchronized with the main process, exception handling is allowed
within the method.


<H4><A NAME="P4.2.1">4.2.1 OnEntry()</A></H4>
<p>
OnEntry() must return true, if the thread could be started sucessfully and will
return false, otherwise. The SPS_Thread::Create() method waits uppon the return
of OnEntry() and thus guarantees that the thread has initialized its resources.
e.g. if you want to send message to the thread, you might want to create a
message port, but must assure, when the main process send the message, the port
exists. By creating the the message port inside the OnEntry() method, it is
guaranteed that the thread has a valid message port after SPS_Thread::Create()
returns.

<H4><A NAME="P4.2.2">4.2.2 OnExit()</A></H4>
<p>
Additionally, an OnExit() method exists which allows you to delete resources
(e.g. the message port) again, when the thread terminates. A warning,
though! The OnExit() method will always be called, even if the OnEntry() method
fails. So, better make sure, all resources (pointers etc.) are initialzed (it is
save to do this in OnEntry() or even in the class constructor). Further more,
OnExit() is not (!) synchronized with the main process! See below how this still
can be considered safe.

<H4><A NAME="P4.2.3">4.2.3 Run()</A></H4>
<p>
Finally the threaded code itself will be implemented by overloading the
SPS_Thread::Run() method. You can use a loop here or even run it once (kind of a
worker thread). A spcific removeing of the thread is not necessary, returning
from Run() (and probably implementing OnExit()) is sufficient.


<H3><A NAME="P4.3">4.3 Thread Termination</A></H3>
<p>
If you want to terminate a thread in an controled way (e.g. you know when
your ports are removed etc.) you should call a SPS_Thread::Destroy() at the very
end of your usage. That sends a CTRL-C signal to the thread and allows you to
automatically terminate a possible input (or whatever) loop.
<p>
A thread offers a Signal() method, which does actually the same as a
IExec->Signal(), however, the default parameter is set to SIGBREAKF_CTRL_C which
in fact is supposed to function as a Kill() function. Signal() is a virtual
method and can be adopted to your needs.
<p>
Automatic thread termination thru the destructor is not (!) build in (due to the
way how C++ inheritance works) and thus, you must make sure, that you send a
loop termination to the thread. There is no automatic "KILL" signal available,
which breaks the code on termination! You have to do this on an application
level!
<p>
It is safe to call SPS_Thread::Destroy() even if the thread hasn't been created
yet (or at all). Thus, I'd recommend one call to much doesn't hurt.


<H3><A NAME="P4.4">4.4 A simple Thread</A></H3>
<p>
Below we find a simple example thread:
<br>
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
040: <font color="#0000FF">class</font> <B>MyThread</B> : <font color="#0000FF">public</font> <A HREF="sps_thread.h">SPS_Thread</A>
041: <font color="#000000">{</font>
042: <font color="#0000FF">public</font>:
043:     <font color="#000000">MyThread</font>()
044:         : <font color="#000000">m_MessagePort</font>( NULL )
045:         , <font color="#000000">m_Timer</font>( NULL )
046:     <font color="#000000">{</font><font color="#000000">}</font>
047:     <font color="#0000FF">virtual</font> ~<font color="#000000">MyThread</font>() <font color="#000000">{</font>
048:     <font color="#000000">}</font>
049: 
050:     <font color="#9A1900">/*! send a message to the thread */</font>
051:     <font color="#33CC00">void</font> <font color="#000000">SendMessage</font>( <font color="#0000FF">const</font> MyMessage* msg, <font color="#33CC00">bool</font> sync = <font color="#0000FF">true</font> );
052: 
053: <font color="#0000FF">protected</font>:
054:     <font color="#9A1900">/*! set us up */</font>
055:     <font color="#0000FF">virtual</font> <font color="#33CC00">bool</font> <font color="#000000">OnEntry</font>();
056:     <font color="#9A1900">/*! an our main part */</font>
057:     <font color="#0000FF">virtual</font> <font color="#33CC00">void</font> <font color="#000000">Run</font>( );
058:     <font color="#9A1900">/*! clean us up  */</font>
059:     <font color="#0000FF">virtual</font> <font color="#33CC00">void</font> <font color="#000000">OnExit</font>();
060: 
061: <font color="#0000FF">protected</font>:
062:     <font color="#9A1900">/*! message port to send thread command messages */</font>
063:     <font color="#0000FF">struct</font> MsgPort *m_MessagePort;
064:     <font color="#9A1900">/*! a SPS_Timer object */</font>
065:     SPS_Timer      *m_Timer;
066: <font color="#000000">}</font>;
067: 
      </tt></pre></td>
    </tr>
  </tbody>
</table>
<br>
Our thread does not do a lot. It just sits there and waits for signals and
messages. The Signals used are standard system signals, CTRL-E and CTRL-C
and additionally a SPS_Message is processed.
<p>
A received CTRL-E signal is used to bounce back to its parent and simply sends
another CTRL-E back to it.
<p>
The CTRL-C is used to terminate the thread loop.
<P>
A SPS_Message is used to demonstrate a complex message passing system. The
thread can handle synchronous and asynchronous messages. To simplify sending of
messages, in our example, a helper method is available, which hides the SPS_Messages.


<H4><A NAME="P4.4.1">4.4.1 SendMessage()</A></H4>
<p>
This is a helper method which allows you to send a MyMessage body only, without
the need to know how SPS_Messages work.
<br>
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
069: <font color="#33CC00">void</font> MyThread::<font color="#000000"><B>SendMessage</B></font>( <font color="#0000FF">const</font> MyMessage* msg, <font color="#33CC00">bool</font> sync <font color="#9A1900">/* = true */</font> )
070: <font color="#000000">{</font>
071:     <font color="#9A1900">/* SPS_[A]SyncMessageT&lt;BODY&gt; have two ways to attach the data:</font>
072: <font color="#9A1900">     * The method GetBody() returns a ref to the Body and you may modify the data directly.</font>
073: <font color="#9A1900">     * Or, the second method is a copy c'tor which allows you to pass the body on to the</font>
074: <font color="#9A1900">     * message c'tor. In this case, the message MUST support a copy-c'tor. */</font>
075:     <font color="#0000FF">if</font> ( m_MessagePort ) <font color="#000000">{</font>
076:         <font color="#9A1900">/* we can send sync and async messages here */</font>
077:         <font color="#0000FF">if</font> ( sync ) <font color="#000000">{</font>
078:             <font color="#9A1900">// a sync message can be created local on the stack. Send() will return</font>
079:             <font color="#9A1900">// when the thread is done reading the message</font>
080:             SPS_SyncMessageT&lt;<font color="#0000FF">const</font> MyMessage*&gt; sps_msg;
081:             sps_msg.<font color="#000000">GetBody</font>() = msg; <font color="#9A1900">// just use a pointer</font>
082:             sps_msg.<font color="#000000">Send</font>( m_MessagePort );
083: 
084: 
085:         <font color="#000000">}</font> <font color="#0000FF">else</font> <font color="#000000">{</font>
086:             <font color="#9A1900">// in case of an async message, we return immediately but the thread</font>
087:             <font color="#9A1900">// must delete the message - however, we must copy the body</font>
088:             SPS_AsyncMessageT<font color="#FF0000">&lt;MyMessage&gt;</font> *sps_msg = <font color="#0000FF">new</font> <font color="#000000">SPS_AsyncMessageT</font><font color="#FF0000">&lt;MyMessage&gt;</font>( *msg );
089:             sps_msg-&gt;<font color="#000000">Send</font>( m_MessagePort );
090:         <font color="#000000">}</font>
091:     <font color="#000000">}</font>
092: <font color="#000000">}</font>
093: 
      </tt></pre></td>
    </tr>
  </tbody>
</table>
<br>

<H4><A NAME="P4.4.2">4.4.2 Async vs. Sync Messages</A></H4>
<p>
SendMessage takes a class MyMessage and based on the sync parameter packs it in
either a SPS_SyncMessageT<MyMessage*> or a SPS_AsyncMessageT<MyMessage>. Please
note the pointer in the sync message and the object in the async message.
<p>
The reason is simple. For a sync message we only pass the reference of the
message body to the thread. We have to wait until the thread sends a reply back
to us anyway and thus, the data are safe until SPS_Message::Send() returns.
SPS_Message::Send() takes care, if you send a sync or async message, an
additional WaitPort( msg.mn_ReplyPort ) is not required.
<p>
Analog the asynchronous method. However, here we must allocate the memory for
the message itself and also copy the message body before we send the message.
This is necessary, because SPS_AsyncMessageT<>::Send() returns immedidately and
does not wait until the thread sends a reply. In fact, our thread does not send
a reply at all if it receives an asynchronous message. After we have "fired" the
message, the thread owns it - and needs to clean up the mess.
<p>
Also note the parameter in the SPS_AsyncMessageT<>( *msg ). This requires your message
class to implement a copy constructor. The data are copied when the
SPS_AsyncMessageT is created. A copy-c'tor save some time to create a default
object and copy the data again (which is still possible).
<p>
Both async and sync message have pro and con arguments. While async messages
might be slower (due to the fact that data need to be created and copied), this
might also apply for sync messages if you do not want to lock down the caller
too long. Then, usually the receiver copies the data and calls a reply to
release the caller. But within this time, both, parent and child are actually
suspended and wait for each other (means, nothing can be done at that time).
Async messages do not delay any thread (the copy does not block anything), but
the copy takes time (time in the sence of <1ms). Also, a fully async behaviour
sometimes requires a stronger design then sync behaviour.

<H4><A NAME="P4.4.3">4.4.3 A WARNING!</A></H4>
<p>
One big warning though! The SPS_Message contains code, not just data! This is very
important to understand. The code itself is always statically linked into the
application. This code might change. Never (!!!) send a SPS_Message from one
application to another. This will execute a different code in the other
appliation which might not be the same, thus the app might (and will!) crash.

<H3><A NAME="P4.5">4.5 Thread Construction and Destruction</A></H3>
<p>
<H4><A NAME="P4.5.1">4.5.1 OnEntry() - Thread Constructor</A></H4>
<p>
We talked about the OnEntry() method before. This is a virtual method, which gets
called when a thread gets created and the thread starts to run. OnEntry() is
synchronized with SPS_Thread::Create() and guarnatees that the thread can
initialize its data when Create() returns. Thus, e.g. a SendMessage() like in
this example above is save to call without extensive checkings.
<p>
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
098: <font color="#33CC00">bool</font> MyThread::<font color="#000000"><B>OnEntry</B></font>()
099: <font color="#000000">{</font>
100:     <font color="#33CC00">bool</font> result = <font color="#0000FF">false</font>;
101:     <font color="#0000FF">try</font> <font color="#000000">{</font>
102:         m_MessagePort = <font color="#0000FF">static_cast</font>&lt;<font color="#0000FF">struct</font> MsgPort*&gt;(IExec-&gt;<font color="#000000">AllocSysObject</font>(ASOT_PORT, NULL));
103:         <font color="#0000FF">if</font> (!m_MessagePort) <font color="#000000">{</font>
104:             <font color="#0000FF">throw</font> <font color="#000000">Exc1</font>( <font color="#FF0000">"Cannot create message port."</font> );
105:         <font color="#000000">}</font>
106: 
107:         m_Timer = <font color="#0000FF">new</font> SPS_Timer;
108:         <font color="#0000FF">if</font> ( !m_Timer ) <font color="#000000">{</font>
109:             <font color="#000000">Throw1</font>( <font color="#FF0000">"Bug! No SPS_Timer!"</font> );
110:         <font color="#000000">}</font>
111:         <font color="#9A1900">// if we reach that point, we have a valid thread</font>
112:         result = <font color="#0000FF">true</font>;
113: 
114:         std::cout &lt;&lt; <font color="#FF0000">"MyThread::OnEntry"</font> &lt;&lt; std::endl;
115:     <font color="#000000">}</font> <font color="#0000FF">catch</font> ( SPS_Exception &amp;ex ) <font color="#000000">{</font>
116:         <font color="#9A1900">// the SPS_Exception is thread safe!</font>
117:         ex.<font color="#000000">Warn</font>();
118:     <font color="#000000">}</font> <font color="#0000FF">catch</font> ( ... ) <font color="#000000">{</font>
119:         <font color="#9A1900">// always make sure we catch the unexpected!</font>
120:     <font color="#000000">}</font>
121:     <font color="#0000FF">return</font> result;
122: <font color="#000000">}</font>
123: 
      </tt></pre></td>
    </tr>
  </tbody>
</table>
<br>
Our thread creates another object we did not talk about yet. A <A HREF="#A1">SPS_Timer</A> object.
This is a simple class which uses the timerdevice for some common used
functions. See more about the SPS_Timer below.

<H4><A NAME="P4.5.2">4.5.2 OnExit() - Thread Destructor</A></H4>
<p>
OnExit() is called after Run() (the thread main function) has returned. It
allows you to free allocated resources from the thread after the thread
terminates. This method is still called within the thread context.
<p>
No synchronisation is performed directly by OnExit(), however, if you terminate
a thread thru the SPS_Thread::Destroy() method, Destroy() will not return before
the thread is completely removed (and OnExit() returns). This can also be used
to synchronize the main and the child thread. E.g. SendMessage() checks for a
valid MessagePort. No Sempahore locking is performed, so we might run into a
potential error here (e.g. the thread terminates because Run() exits, but the
main still trys to send another message).
<p>
If Destroy() is called, it will block the main thread until the child is
removed, and the message port is deleted. After that point, an invalid message
port will be intercepted by SendMessage() itself.
<p>
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>

124: <font color="#33CC00">void</font> MyThread::<font color="#000000"><B>OnExit</B></font>()
125: <font color="#000000">{</font>
126:     std::cout &lt;&lt; <font color="#FF0000">"MyThread::OnExit()"</font> &lt;&lt; std::endl;
127: 
128:     <font color="#9A1900">/* we also must free the message port from within the thread */</font>
129:     <font color="#0000FF">if</font> ( m_MessagePort ) <font color="#000000">{</font>
130:         IExec-&gt;<font color="#000000">FreeSysObject</font>(ASOT_PORT, <font color="#0000FF">static_cast</font><font color="#FF0000">&lt;void*&gt;</font>(m_MessagePort));
131:         m_MessagePort = NULL;
132:     <font color="#000000">}</font>
133:     <font color="#0000FF">if</font> ( m_Timer ) <font color="#0000FF">delete</font> m_Timer;
134:     m_Timer = NULL;
135: <font color="#000000">}</font>
136: 

      </tt></pre></td>
    </tr>
  </tbody>
</table>
<br>
OnExit() also deletes our SPS_Timer object.

<H4><A NAME="P4.5.3">4.5.3 Run() - The Thread Main Loop</A></H4>
<p>
The virtual method SPS_Thread::Run() is effectively the main loop of the thread.
In our example we implement an event loop and process some signals and a
SPS_Message. We have to take this a little bit appart and comment on the
separate entities here.
<p>
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
137: <font color="#33CC00">void</font> MyThread::<font color="#000000"><B>Run</B></font>()
138: <font color="#000000">{</font>
139:     <font color="#33CC00">bool</font> out = <font color="#0000FF">false</font>;
140:     int32 sig;
141:     <font color="#0000FF">do</font> <font color="#000000">{</font></tt></pre></td>
    </tr>
  </tbody>
</table>
WaitWithTimeout() adds a new function which the exec.library does not provide
natively. It waits for signals an messages to arrive, but also allows you to
define a time in ms after which the Wait() will be broken. In case of a timeout,
the timer signal will be set. To check for a timer signal, use
SPS_Timer::GetSigMask(). This allows you to process a timeout event.
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
142:         <font color="#9A1900">/* wait for a message to arrive. 5000 ms (5sec) timeout! Demonstrate what a timer can do */</font>
143:         sig = m_Timer-&gt;<font color="#000000">WaitWithTimeout</font>( SIGBREAKF_CTRL_E | SIGBREAKF_CTRL_C | (<font color="#CC33CC">1</font> &lt;&lt; m_MessagePort-&gt;mp_SigBit), <font color="#CC33CC">5000</font> );
144:         <font color="#0000FF">if</font> ( (sig &amp; SIGBREAKF_CTRL_E) == SIGBREAKF_CTRL_E ) <font color="#000000">{</font>
145:             std::cout &lt;&lt; <font color="#FF0000">"MyThread reveived a CTRL-E signal."</font> &lt;&lt; std::endl;
146:             IExec-&gt;<font color="#000000">SetSignal</font>( <font color="#CC33CC">0</font>, <font color="#CC33CC">0</font> );
147:             <font color="#0000FF">if</font> ( m_Parent ) <font color="#000000">{</font>
148:                 <font color="#9A1900">/* bounce it back */</font>
149:                 IExec-&gt;<font color="#000000">Signal</font>( m_Parent, SIGBREAKF_CTRL_E );
150:             <font color="#000000">}</font></tt></pre></td>
    </tr>
  </tbody>
</table>
OK, in our example, the parent thread (or someone else) did send us an CTRL-E
signal. We just forward this signal to the parent. That's all.
<p>
The more complex part comes below: We received an SPS_Message.
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
151:         <font color="#000000">}</font> <font color="#0000FF">else</font> <font color="#0000FF">if</font> ( sig &amp; (<font color="#CC33CC">1</font> &lt;&lt; m_MessagePort-&gt;mp_SigBit) ) <font color="#000000">{</font>
152:             std::cout &lt;&lt; <font color="#FF0000">"MyThread reveived a message signal."</font> &lt;&lt; std::endl;
153:             <font color="#9A1900">// OK, that's interessting. We got an SPS_Message</font></tt></pre></td>
    </tr>
  </tbody>
</table>
Now, that's interessting. We got an SPS_Message. Note, we do not use and
SPS_SyncMessageT<> or SPS_AsyncMessageT<> at this point, because we simply don't
know yet, what we'll get. However, both, SPS_SyncMessageT<> and
SPS_AsyncMessageT<> share one interface. Thus a down cast to SPS_Message is
valid.
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
154:             SPS_Message *_msg;
155:             <font color="#0000FF">while</font> ( (_msg  = <font color="#0000FF">static_cast</font><font color="#FF0000">&lt;SPS_Message*&gt;</font>( IExec-&gt;<font color="#000000">GetMsg</font>( m_MessagePort ) )) != NULL ) <font color="#000000">{</font></tt></pre></td>
    </tr>
  </tbody>
</table>
Thru SPS_Message::IsSync() we check, if our sender did send us a synchronous
message:
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
157:                 <font color="#0000FF">if</font> ( _msg-&gt;<font color="#000000">IsSync</font>() ) <font color="#000000">{</font> <font color="#9A1900">// OK, this one was synchronous ...</font>
158: 
159:                     <font color="#9A1900">/* Now cast the message again */</font>
160:                     SPS_SyncMessageT<font color="#FF0000">&lt;MyMessage*&gt;</font> *msg = <font color="#0000FF">static_cast</font><font color="#FF0000">&lt;SPS_SyncMessageT&lt;MyMessage*&gt;*&gt;</font>( _msg );
161:                     <font color="#9A1900">/* now we have to get the data from the message */</font>
162:                     MyMessage *body = msg-&gt;<font color="#000000">GetBody</font>();
163: 
164:                     <font color="#9A1900">/* do something with the body */</font>
165:                     std::cout &lt;&lt; <font color="#FF0000">"Synchronous Message received: "</font> &lt;&lt; body-&gt;m_Message &lt;&lt; std::endl;</tt></pre></td>
    </tr>
  </tbody>
</table>
This delay will also block our sender for the amount of time we give here and
until we can call Reply();
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
167:                     <font color="#9A1900">/* delay the response by 2secs */</font>
168:                     m_Timer-&gt;<font color="#000000">Delay</font>( <font color="#CC33CC">2000</font> ); 
169: 
170:                     <font color="#9A1900">/* and we can send it back */</font>
171:                     msg-&gt;<font color="#000000">Reply</font>();
172: 
173:                 <font color="#000000">}</font> <font color="#0000FF">else</font> <font color="#000000">{</font> <font color="#9A1900">// ... that one isn't</font></tt></pre></td>
    </tr>
  </tbody>
</table>
The second case means, we have received an asyncronous message:
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
174: 
175:                     <font color="#9A1900">/* Now cast the message again */</font>
176:                     SPS_AsyncMessageT<font color="#FF0000">&lt;MyMessage&gt;</font> *msg = <font color="#0000FF">static_cast</font><font color="#FF0000">&lt;SPS_AsyncMessageT&lt;MyMessage&gt;*&gt;</font>( _msg );
177:                     <font color="#9A1900">/* now we have to get the data from the message */</font>
178:                     MyMessage &amp;body = msg-&gt;<font color="#000000">GetBody</font>(); <font color="#9A1900">// no need to copy, we own it!</font>
179: 
180:                     <font color="#9A1900">/* do something with the body */</font>
181:                     std::cout &lt;&lt; <font color="#FF0000">"Asynchronous Message received: "</font> &lt;&lt; body.m_Message &lt;&lt; std::endl;
182: 
183:                     <font color="#9A1900">/* no need to Reply, just free it */</font>
184:                     <font color="#0000FF">delete</font> msg;
185:                 <font color="#000000">}</font></tt></pre></td>
    </tr>
  </tbody>
</table>
Please note: The sync message uses a pointer to the message body, while the
asynchronous message contains the whole message object.
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
186:             <font color="#000000">}</font>
      </tt></pre></td>
    </tr>
  </tbody>
</table>
A little bit of termination stuff. A CTRL-C terminates us. That's all.
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
187:         <font color="#000000">}</font> <font color="#0000FF">else</font> <font color="#0000FF">if</font> ( (sig &amp; SIGBREAKF_CTRL_C) == SIGBREAKF_CTRL_C ) <font color="#000000">{</font>
188:             std::cout &lt;&lt; <font color="#FF0000">"MyThread reveived a CTRL-C signal."</font> &lt;&lt; std::endl;
189:             out = <font color="#0000FF">true</font>;</tt></pre></td>
    </tr>
  </tbody>
</table>
And a timeout handler. We know, if the signal is none of the above, it can only
mean we got a time out event.
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
190:         <font color="#000000">}</font> <font color="#0000FF">else</font> <font color="#000000">{</font>
191:             <font color="#9A1900">// got a timeout!</font>
192:             <font color="#0000FF">if</font> ( m_Parent ) <font color="#000000">{</font>
193:                 <font color="#9A1900">/* bounce it back */</font>
194:                 IExec-&gt;<font color="#000000">Signal</font>( m_Parent, SIGBREAKF_CTRL_D );
195:             <font color="#000000">}</font>
196:         <font color="#000000">}</font>
197: 
198:     <font color="#000000">}</font> <font color="#0000FF">while</font> (!out) ;
199: <font color="#000000">}</font> </tt></pre></td>
    </tr>
  </tbody>
</table>
<br>

<H4><A NAME="P4.6">4.6 Notes about SPS_Threads</A></H4>
<p>
Another warning! Do not use exception within OnExit() or Run(). A try/catch
block works in a global scope and performs absolute jumps. A throw in the main
process can therefore end in the catch of the thread!
<p>
It is safe to use try/catch in OnEntry(), because this call is syncronized with
the main process, and multiple threads cannot throw an exception at the same
time. If you create threads in threads, though, this might become a complex
story.
<p>
One more hint: Our SPS_Thread does not use any parameters to be called. The
reason ? Its not needed. If you want to implement some kind of worker threads,
implement them like functor objects, creating a temporary thread object and pass
the data to its constructor. This is a little bit more overhead but will give
you the same result. You can even hide the Create() (and even the Destroy() - if
the class will not be derived any more) method inside the c'tor and d'tor pair.
<p>
This would simple look like this:
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
<font color="#0000FF">class</font> MyWorker : <font color="#0000FF">public</font> SPS_Thread
<font color="#000000">{</font>
<font color="#0000FF">public</font>:
    <font color="#000000">MyWorker( </font><font color="#0000ff">const </font><font color="#000000">MyData& data ); </font>
    <font color="#000000">...</font>
<font color="#000000">};</font></tt></pre></td>
    </tr>
  </tbody>
</table>
<p>
and in the app:
<p>
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
    <font color="#000000">MyWorker *worker = </font><font color="#0000FF">new</font> MyWorker( data );</tt></pre></td>
    </tr>
  </tbody>
</table>
<p>
Looks similar to a function call, but isn't. The worker will start, process the
data passed to it and return (you still need to free the mem somewhere);
The thread could be started from within the constructor and the work on the data will start immediately.
The thread will terminate itself when done. The application will synchronize itself on exit.
However, you still need to call a delete on the thread. When you do, you can call a Destroy()
right before you call the delete - or, in this specific case, call the Destroy() from within the
worker threads destructor (as long as you don't derive the class again). Calling Destroy() explicitly
will remove all doubts, though.
<p>
You should always call Destroy() in some way (either explicit or within the class) to make sure, the
object is not deleted before the thread has ended. Destroy() takes care of it and can be called, even
when the thread has returned already (e.g. the worker thread returned from Run() before we call the
d'tor).
<p>
The thread will never delete itself! This must still be done within the application (the only exception would be
a custom implementation which calls Destroy() in its d'tor. This would allow to create a SPS_Thread on
the stack).

<!-- ######### Paragraph 5 ############# -->

<H3><A NAME="P5">5. Hooks</A></H3>
<p>
Now something completely different. As a little goody, the libsps++.a contains a
class SPS_Hook. This is a nice add on for messages and threads and allows you to
create a "Hook Object" and simply implement a virtual OnEntry() method rather
then fidleing around with struct Hook and how to set up a callback function,
process data or trying to understand what a struct Hook actually does.
<p>
Please note: A SPS_Hook is not derived from a struct Hook and therefore a C
style cast from class SPS_Hook* to struct Hook* will fail. However, a casting
operator is implemented and allows you to static cast a SPS_Hook reference (not
a pointer!!) to a struct Hook pointer (!). Such a hook can be used wherever
AmigaOS hooks are used (e.g. as render hook for a MUI class). Becaus our hook is
an object, we contain already private data and a object pointer is available as
a this pointer.
<p>
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
207: <font color="#0000FF">class</font> <B>MyHook</B> : <font color="#0000FF">public</font> SPS_Hook
208: <font color="#000000">{</font>
209: <font color="#0000FF">public</font>:
210:     <font color="#000000">MyHook</font>( <font color="#33CC00">bool</font> sync = <font color="#0000FF">true</font> )
211:         : <font color="#000000">m_Self</font>( <font color="#FF0000">"MyHook"</font> )
212:         , <font color="#000000">m_Sync</font>( sync )
213:     <font color="#000000">{</font> <font color="#000000">}</font>
214:     <font color="#0000FF">virtual</font> ~<font color="#000000">MyHook</font>() <font color="#000000">{</font><font color="#000000">}</font>
215: 
216: <font color="#0000FF">protected</font>:
217:         <font color="#9A1900">/*! This is the virtual HookEntry */</font>
218:         <font color="#0000FF">virtual</font> int32 <font color="#000000">OnEntry</font>(APTR object, APTR message);
219: 
220:     <font color="#9A1900">/* just some data */</font>
221:     std::string m_Self;
222:     <font color="#9A1900">/* send a sync or async message ? */</font>
223:     <font color="#33CC00">bool</font>        m_Sync; 
224: <font color="#000000">}</font>;</tt></pre></td>
    </tr>
  </tbody>
</table>
<br>
In our example, we abuse the hook a little bit and do not send messages directly thru the main
application, but use a hook instead. This is an overkill but should give you an
idea, how SPS_Hooks work.
<p>
OnEntry() is the h_Entry funtion (kind of) which we would have had to set in the original struct
Hook. However, we don't have to bother with the Hook itself, but simply
implement this virtual method. The parameters are the same as for a standard
hook entry function. A pointer to the object passed thru IUtilty->CallHookPkt()
and the same for the message which also gets attached thru CallHookPkt().
<p>
One thing, though. The Hook itself gets lost. And this has a reason. Actually, you have
the Hook still there - as a member of the SPS_Hook base class. However, it
serves no real purpose and might only lead to misunderstandings and is therefore
removed.
<br>
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
226: int32 MyHook::<font color="#000000"><B>OnEntry</B></font>( APTR object, APTR message )
227: <font color="#000000">{</font>
228:     <font color="#0000FF">const</font> MyMessage *msg = <font color="#0000FF">static_cast</font>&lt;<font color="#0000FF">const</font> MyMessage*&gt;( message );
229:     MyThread *thread     = <font color="#0000FF">static_cast</font><font color="#FF0000">&lt;MyThread*&gt;</font>( object );
230: 
231:     <font color="#9A1900">/* demonstrate that we have a valid this pointer here */</font>
232:     std::cout &lt;&lt; <font color="#FF0000">"Hook called! Hook&lt;"</font> &lt;&lt; m_Self &lt;&lt; <font color="#FF0000">"&gt; with message '"</font> &lt;&lt; msg-&gt;m_Message &lt;&lt; <font color="#FF0000">"'"</font> &lt;&lt; std::endl;
233: 
234:     thread-&gt;<font color="#000000">SendMessage</font>( msg, m_Sync );
235: 
236:     <font color="#0000FF">return</font> <font color="#CC33CC">0</font>;
237: <font color="#000000">}</font></tt></pre></td>
    </tr>
  </tbody>
</table>
<br>

<!-- ######### Paragraph 6 ############# -->

<H3><A NAME="P6">6. Main</A></H3>
<p>
There is not much to say about the main process itself. It implements the main
entry function, creates the thread and handles some events. It also uses
SPS_Exceptions to handle errors within the app. At the end, we terminate the app
and throw and exception just for fun.
<p>
<table border="1" cellpadding="10" width="100%" bgcolor="#F0F0F0">
  <tbody>
    <tr>
      <td><pre><tt>
242: <font color="#33CC00">int</font> <font color="#000000"><B>main</B></font>( <font color="#33CC00">int</font> argc, <font color="#33CC00">char</font>** argv )
243: <font color="#000000">{</font>
244:     <font color="#9A1900">/* a thread object - construct outside the try/catch block! */</font>
245:     MyThread myThread;
246: 
247:     <font color="#0000FF">try</font> <font color="#000000">{</font>
248:         std::cout &lt;&lt; <font color="#FF0000">"libsps++.a example"</font> &lt;&lt; std::endl;
249: 
250:         <font color="#9A1900">/* create and run the thread */</font>
251:         <font color="#0000FF">if</font> (myThread.<font color="#000000">Create</font>( <font color="#FF0000">"SPS_ExampleThread"</font> ) == NULL) <font color="#000000">{</font>
252:             <font color="#9A1900">/* exit in case we couldn't start the thread */</font>
253:             <font color="#000000">Throw1</font>(<font color="#FF0000">"Thread creation error!"</font>);
254:         <font color="#000000">}</font>
255: 
256:         std::cout &lt;&lt; <font color="#FF0000">"Press CTRL-E to send message to the thread."</font> &lt;&lt; std::endl;
257:         std::cout &lt;&lt; <font color="#FF0000">"Press CTRL-F to send (forward) a signal to the thread."</font> &lt;&lt; std::endl;
258:         std::cout &lt;&lt; <font color="#FF0000">"Press CTRL-C to quit."</font> &lt;&lt; std::endl;
259:         std::cout &lt;&lt; <font color="#FF0000">"Press (Receive) CTRL-D from thread at timeout (5sec)."</font> &lt;&lt; std::endl;
260: 
261:         <font color="#9A1900">/* some local vars */</font>
262:         int32 sig = <font color="#CC33CC">0</font>;
263:         <font color="#33CC00">bool</font> out  = <font color="#0000FF">false</font>;
264:         <font color="#33CC00">bool</font> send_sync = <font color="#0000FF">true</font>;
265: 
266:         <font color="#0000FF">do</font> <font color="#000000">{</font>
267: 
268:             std::cout &lt;&lt; std::flush;
269: 
270:             <font color="#9A1900">// Wait until someone terms us</font>
271:             sig = IExec-&gt;<font color="#000000">Wait</font>( SIGBREAKF_CTRL_C | SIGBREAKF_CTRL_D | SIGBREAKF_CTRL_E | SIGBREAKF_CTRL_F );
272:             <font color="#0000FF">if</font> ( (sig &amp; SIGBREAKF_CTRL_C) == SIGBREAKF_CTRL_C ) <font color="#000000">{</font>
273:                 <font color="#9A1900">// our exit condition</font>
274:                 IExec-&gt;<font color="#000000">SetSignal</font>( <font color="#CC33CC">0</font>, <font color="#CC33CC">0</font> );
275:                 std::cout &lt;&lt; <font color="#FF0000">"Got CTRL-C. Exiting!"</font> &lt;&lt; std::endl;
276:                 out = <font color="#0000FF">true</font>;
277:             <font color="#000000">}</font>
278:             <font color="#0000FF">else</font> <font color="#0000FF">if</font> ( (sig &amp; SIGBREAKF_CTRL_E) == SIGBREAKF_CTRL_E ) <font color="#000000">{</font>
279:                 std::cout &lt;&lt; <font color="#FF0000">"Got a CTRL-E signal. Send a message to the thread."</font> &lt;&lt; std::endl;
280:                 <font color="#9A1900">/* this is nasty. But cool ;) A little bit of an overkill, I admit</font>
281: <font color="#9A1900">                 * We let a the hook send a message to the thread. */</font>
282:                 MyMessage <font color="#000000">msg</font>( <font color="#FF0000">"BounceBack!"</font> );
283: 
284:                 <font color="#9A1900">/* a demo hook - pretty fine to create it on a local scope */</font>
285:                 MyHook <font color="#000000">myHook</font>(  send_sync );
286: 
287:                 IUtility-&gt;<font color="#000000">CallHookPkt</font>( <font color="#0000FF">static_cast</font><font color="#FF0000">&lt;Hook*&gt;</font>( myHook ),   <font color="#9A1900">// do not de-ref myHook! Must call casting op!</font>
288:                                        <font color="#000000">static_cast</font><font color="#FF0000">&lt;APTR&gt;</font>( &amp;myThread ), <font color="#9A1900">// the Object*</font>
289:                                        <font color="#000000">static_cast</font><font color="#FF0000">&lt;APTR&gt;</font>( &amp;msg ) );    <font color="#9A1900">// the Msg</font>
290:                 send_sync = <font color="#0000FF">true</font>;
291:             <font color="#000000">}</font>
292:             <font color="#0000FF">else</font> <font color="#0000FF">if</font> ( (sig &amp; SIGBREAKF_CTRL_F) == SIGBREAKF_CTRL_F ) <font color="#000000">{</font>
293:                <font color="#9A1900">// rebound message. Let it bounce to the thread and back as a CTRL-E again</font>
294:                 std::cout &lt;&lt; <font color="#FF0000">"Got a \"rebound\" message. Signal thread and get a CTRL-E back!"</font> &lt;&lt; std::endl;
295:                 IExec-&gt;<font color="#000000">SetSignal</font>( <font color="#CC33CC">0</font>, <font color="#CC33CC">0</font> );
296:                 <font color="#9A1900">/* we'll get a CTRL-E back, and switch to async message */</font>
297:                 send_sync = <font color="#0000FF">false</font>;
298:                 myThread.<font color="#000000">Signal</font>( SIGBREAKF_CTRL_E  ); 
299:             <font color="#000000">}</font>
300:             <font color="#0000FF">else</font> <font color="#0000FF">if</font> ( (sig &amp; SIGBREAKF_CTRL_D) == SIGBREAKF_CTRL_D ) <font color="#000000">{</font>
301:                 <font color="#9A1900">// just a sinal from the thread</font>
302:                 IExec-&gt;<font color="#000000">SetSignal</font>( <font color="#CC33CC">0</font>, <font color="#CC33CC">0</font> );
303:                 std::cout &lt;&lt; <font color="#FF0000">"Got a CTRL-D signal. Most probably a timeout message from the thread!"</font> &lt;&lt; std::endl;
304:             <font color="#000000">}</font>
305: 
306:         <font color="#000000">}</font> <font color="#0000FF">while</font> (!out) ;
307: 
308:         <font color="#9A1900">/* just show, that we can do exceptions ;) */</font>
309:         <font color="#000000">Throw1</font>( <font color="#FF0000">"Application Exiting!"</font> );
310:     <font color="#000000">}</font>
311:     <font color="#0000FF">catch</font> ( SPS_Exception &amp;ex ) <font color="#000000">{</font>
312:         ex.<font color="#000000">Warn</font>( <font color="#FF0000">"Note! We got an Exception."</font>, <font color="#FF0000">"I know!"</font> );
313:     <font color="#000000">}</font>
314:     <font color="#0000FF">catch</font> ( ... ) <font color="#000000">{</font>
315:         std::cout &lt;&lt; <font color="#FF0000">"Got unknown exception"</font> &lt;&lt; std::endl;
316:     <font color="#000000">}</font>
317: 
318:     <font color="#9A1900">/* we destroy the thread - even if Create() would probably have failed. */</font>
319:     myThread.<font color="#000000">Destroy</font>();
320:     <font color="#0000FF">return</font> <font color="#CC33CC">0</font>;
321: <font color="#000000">}</font>
322: </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
Well, that's it.

<!-- ######### Paragraph A1 ############# -->

<H3><A NAME="A">A. Appendix</A></H3>

<H3><A NAME="A1">A1. The SPS_Timer</A></H3>
<p>
What I din't talk about in detail, yet, is the SPS_Timer. But this is fairly simple.
It does not offer much. Some methods to delay some stuff and it also implements a
WaitWithTimeout() method as an IExec->Wait() replacement.
<p>
The SPS_Timer is NOT (!) thread safe, and will never be. But, it is small and
efficient. You shouldn't share SPS_Timers across threads anyway. Simply create a
SPS_Timer for every thread you need it. You can create as many as you want. Even
on a local scope. A c'tor call should take about 150µs on a 700MHz G3 (range
machine) - this is less then about 1/4 of a ms!

<H4><A NAME="A1.1">A1.1 Delay Methods</A></H4>
<p>
Two delay methods are available. One, SPS_Timer::Delay( uint32 ), is a common interface type which expects a
time to wait in ms. The second one, SPS_Timer::MicroDelay( double ), works similar, but expects the time in ms as
a double (floating point) number rather as an integer. This allows you to wait
for a fraction of a ms. 0.150ms is still accurate (this is 150µs).

<H4><A NAME="A1.2">A1.2 WaitWithTimeout</A></H4>
<p>
This is a function analog to IExec->Wait(). It expects the same parameter like
its exec brother but adds an additional timeout paramter to it. The time is the
time WaitWithTimeout() waits, until it returns - even if no signal arrives. You
can check if the method returns with a timeout by checking its return value
against a SPS_Timer::GetSigMask() bit set.
<p>
If you pass in a 0 as a timeout, the method will behave exactly like
IExec->Wait() and will not return before it receives a signal.
<p>
The SPS_Timer c'tor uses exceptions, so make sure you put it into a try/catch
block when you create the timer. In case of a thread, crate it inside OnEntry()
not inside Run().

<H3><A NAME="A2">A2. SPS_Excpetion</A></H3>
<p>
The SPS_Exception is a thread safe class which allows you to throw an exception
for various cases. It can output error messages to the console, a file or the
serial debug out. It can also open an Intuition warning Requestor and lets you
specify the error text, error code, the Window header and the button text(s).
<p>
Some error codes are predefined and translate in to a human readable form.


<H3><A NAME="A3">A3. sps_types.h</A></H3>
<p>
Almost forgotten, but then, not.
<p>
Here you'll find two macros which will simplify the handling of libraries and
interfaces a lot. OPEN_IFACE and CLOSE_IFACE. In case you do not use libauto or
the needed lib is not in there, these macros help you to open the iface (and the
library).
<p>
OPEN_IFACE expects a macro type interface name as its first parameter, the
library string as a second one and the third parameter is the library version.
<p>
This "macro type" interface name is limited. It is the common part, the library
shares with the interface, e.g. in case of the utility.library, this would be
UtilityBase and IUtility share Utility. This is not a valid type, but will be
macro processed and both, UtilityBase and IUtility will be generated by the
macro.
<p>
The library base and interface structures are not (!) created by the macro. Your
code must declare both some where incl. its storage.
<p>
Sometimes, the library and the interface do not match. This is not really a
problem, the library base is "virtual" anyway and not really needed. It's only
used to open the IFace. That means, it can have any name you want. Just make
sure it matches somewhat with the interface.
<p>
If a library has multiple interfaces, that would mean, well, bad luck. You need
a separate lib base for each interface (e.g. check application interface).
<p>
Also, the macro can only open the "main" interface, no sub interfaces. Again,
check the application.library (OPEN_IFACE cannot be used with it).
<p>
Per default, OPEN_IFACE implements error handling thru SPS_Exceptions. You can
turn that off by defining _NO_EXCEPTIONS before you include sps_types.h. But
that leaves you alone with the validation of you interface pointers.
<p>
CLOSE_IFACE works analog. It uses the same "macro type" as an interface and
closes the interface and the library. It sets both to NULL, be warned!

<H3><A NAME="A4">A4. Doxygen</A></H3>
<p>
A more comprehensive source code documentation is available as hmtl generated
doxygen documentation here: <A HREF="html/index.html">html/index.html</A>
(The doxygen documentation is not completed yet. ASAP).
</body>
</html>

