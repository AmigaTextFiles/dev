@database "extras"
@master "Ram_Disk:extras.doc"

@Node Main "extras.doc"
    @{" --history--() " Link "--history--()"}
    @{" AddHotKey() " Link "AddHotKey()"}
    @{" AllocProgressMeterA() " Link "AllocProgressMeterA()"}
    @{" ArgYesNo() " Link "ArgYesNo()"}
    @{" boopsi_GetGInfo() " Link "boopsi_GetGInfo()"}
    @{" Busy() " Link "Busy()"}
    @{" CopyString() " Link "CopyString()"}
    @{" db_EntryToNN() " Link "db_EntryToNN()"}
    @{" db_GetEntryData() " Link "db_GetEntryData()"}
    @{" db_NextEntry() " Link "db_NextEntry()"}
    @{" EnqueueName() " Link "EnqueueName()"}
    @{" ex_CloseLibs() " Link "ex_CloseLibs()"}
    @{" ex_OpenLibs() " Link "ex_OpenLibs()"}
    @{" EZReq() " Link "EZReq()"}
    @{" FindLine() " Link "FindLine()"}
    @{" FreeProgressMeter() " Link "FreeProgressMeter()"}
    @{" ftos() " Link "ftos()"}
    @{" gui_GhostRect() " Link "gui_GhostRect()"}
    @{" gui_MaxStrFontLen() " Link "gui_MaxStrFontLen()"}
    @{" gui_StrFontLen() " Link "gui_StrFontLen()"}
    @{" gui_StrLength() " Link "gui_StrLength()"}
    @{" IsWhiteSpace() " Link "IsWhiteSpace()"}
    @{" key_Shifted() " Link "key_Shifted()"}
    @{" key_Unshifted() " Link "key_Unshifted()"}
    @{" MultiAllocMemA() " Link "MultiAllocMemA()"}
    @{" MultiAllocPooledA() " Link "MultiAllocPooledA()"}
    @{" MultiAllocVecA() " Link "MultiAllocVecA()"}
    @{" MultiFreeMemA() " Link "MultiFreeMemA()"}
    @{" MultiFreePooledA() " Link "MultiFreePooledA()"}
    @{" MultiFreeVecA() " Link "MultiFreeVecA()"}
    @{" NextNNStr() " Link "NextNNStr()"}
    @{" nns_AddNNStr() " Link "nns_AddNNStr()"}
    @{" nns_GetNNData() " Link "nns_GetNNData()"}
    @{" nns_NNStrLen() " Link "nns_NNStrLen()"}
    @{" NNString_Overview() " Link "NNString_Overview()"}
    @{" NotBusy() " Link "NotBusy()"}
    @{" OBSOLETE--datasheet--() " Link "OBSOLETE--datasheet--()"}
    @{" OBSOLETE_CheckInnerWindowSize() " Link "OBSOLETE_CheckInnerWindowSize()"}
    @{" OBSOLETE_CheckWindowSize() " Link "OBSOLETE_CheckWindowSize()"}
    @{" OBSOLETE_GetGUIScale() " Link "OBSOLETE_GetGUIScale()"}
    @{" OBSOLETE_LG_AddGadgets() " Link "OBSOLETE_LG_AddGadgets()"}
    @{" OBSOLETE_LG_CreateGadgets() " Link "OBSOLETE_LG_CreateGadgets()"}
    @{" OBSOLETE_LG_FreeGadgets() " Link "OBSOLETE_LG_FreeGadgets()"}
    @{" OBSOLETE_LG_GetGadget() " Link "OBSOLETE_LG_GetGadget()"}
    @{" OBSOLETE_LG_GetGadgetAttrs() " Link "OBSOLETE_LG_GetGadgetAttrs()"}
    @{" OBSOLETE_LG_RemoveGadgets() " Link "OBSOLETE_LG_RemoveGadgets()"}
    @{" OBSOLETE_LG_SetGadgetAttrs() " Link "OBSOLETE_LG_SetGadgetAttrs()"}
    @{" OBSOLETE_MakeGadgets() " Link "OBSOLETE_MakeGadgets()"}
    @{" OBSOLETEDrawBevelBoxes() " Link "OBSOLETEDrawBevelBoxes()"}
    @{" PD_PackData() " Link "PD_PackData()"}
    @{" PD_UnpackData() " Link "PD_UnpackData()"}
    @{" PhraseInStr() " Link "PhraseInStr()"}
    @{" ProcessTagList() " Link "ProcessTagList()"}
    @{" RenderText() " Link "RenderText()"}
    @{" str_Strip() " Link "str_Strip()"}
    @{" StrIStr() " Link "StrIStr()"}
    @{" tag_AddTag() " Link "tag_AddTag()"}
    @{" tag_AddTags() " Link "tag_AddTags()"}
    @{" tag_AllocTags() " Link "tag_AllocTags()"}
    @{" tag_ClearNumTags() " Link "tag_ClearNumTags()"}
    @{" tag_ClearTags() " Link "tag_ClearTags()"}
    @{" tag_CountUserTags() " Link "tag_CountUserTags()"}
    @{" tag_FreeTags() " Link "tag_FreeTags()"}
    @{" tag_RemTag() " Link "tag_RemTag()"}
    @{" tag_TagDone() " Link "tag_TagDone()"}
    @{" tag_TagMore() " Link "tag_TagMore()"}
    @{" thread_EndThread() " Link "thread_EndThread()"}
    @{" thread_PutTMsg() " Link "thread_PutTMsg()"}
    @{" thread_PutTMsg_Sync() " Link "thread_PutTMsg_Sync()"}
    @{" thread_PutTMsg_TagList() " Link "thread_PutTMsg_TagList()"}
    @{" thread_StartThread() " Link "thread_StartThread()"}
    @{" UpdateProgressMeterA() " Link "UpdateProgressMeterA()"}
    @{" nns_ProcessNNStr() " Link "nns_ProcessNNStr()"}
@EndNode

@Node "--history--()" "extras.lib/--history--"

@{b}   Versions@{ub}
       1.3 - thread_ functions made usable.

@EndNode

@Node "AddHotKey()" "extras.lib/AddHotKey"

@{b}   NAME@{ub}
       AddHotKey -- Add a hotkey to a Broker.

@{b}   SYNOPSIS@{ub}
       cxobj = AddHotKey(Broker,BrokerPort,@{"HotKey" Link "amiga_lib/HotKey()"},ID)

       CxObj *AddHotKey(CxObj *,struct MsgPort *,STRPTR,ULONG)

@{b}   FUNCTION@{ub}
       Creates a hotkey for a broker.

@{b}   INPUTS@{ub}
       Broker     - Broker CxObj to attach hotkey to. 
       BrokerPort - Broker's MsgPort.
       @{"HotKey" Link "amiga_lib/HotKey()"}     - Null terminated string.
       ID         - Hot keys ID. 
       
@{b}   RESULT@{ub}
       pointer to a CxObj.

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}
@{b}    requires commodities.library to be opened. @{ub}
@{b}     commodities library already has HotKey()@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "AllocProgressMeterA()" "extras.lib/AllocProgressMeterA"

@{b}   NAME@{ub}
       AllocProgressMeterA -- @{"Allocate" Link "exec/Allocate()"} and initialize a progressmeter.
       AllocProgressMeter -- varargs stub for AllocProgressMeterA().

@{b}   SYNOPSIS@{ub}
       meter = AllocProgressMeterA(TagList)

       ProgressMeter AllocProgressMeterA( struct TagItem *);

       meter = AllocProgressMeterA(Tag, ... )

       ProgressMeter AllocProgressMeterA( Tag, ...);

@{b}   FUNCTION@{ub}
       This function allocates and initializes a ProgressMeter.

@{b}   INPUTS@{ub}
       TagList - 
         One of the following two are required.
         PM_Screen - The screen to place the meter on.
                     (struct Screen *)
         PM_ParentWindow - The parent window of the meter.
                           (struct Window *)
                           
         PM_MsgPort    - Already existing msgport to send the meter's
                         window events through. (Not implemented)

         PM_TextAttr   - Font to use in the meter. defaults to the
                         screen font. (struct TextAttr *)

         PM_LeftEdge   - Defaults to be centered on PM_ParentWindow
         PM_TopEdge    - or PMScreen.
         PM_MinWidth   - Set the minimum width of the meter's
                         window.
         PM_MinHeight  - Set the minimum height of the meter's
                         window (Not implemented).

         PM_WinTitle   - Meter's Window title. (STRPTR) 

         PM_LowText    - default "0%"   (STRPTR)  
         PM_HighText   - default "100%" (STRPTR)

         PM_MeterFormat - A @{"printf" Link "amiga_lib/printf()"} style format string used inside the meter.
                          default "%ld%%". (STRPTR) 
         PM_MeterType   - How PM_MeterFormat is used, 
                            PM_TYPE_PERCENTAGE - uses the percentage of
                              where PM_MeterValue is between PM_LowValue and
                              PM_HighValue for the argument of 
                              PM_MeterFormat.
                            PM_TYPE_NUMBER - Uses the meter's value for the 
                              argument of PM_MeterFormat.
                            PM_TYPE_STRING - Doens't process the meter's 
                              value simply displays the text from 
                              PM_MeterFormat
         PM_MeterLabel    - The label above the meter.  default NULL 
         PM_MinMeterWidth - The minimum meter bar width, the default minimum
                            is 80

         PM_MeterPen      - default fillpen 
         PM_MeterBgPen    - default backgroundpen 
         PM_FormatPen     - default highlight text 
         PM_MeterLabelPen - default highlight text 
         PM_LowTextPen    - default text pen 
         PM_HighTextPen   - default text pen 

         PM_MeterValue    - (IS) default   0 (LONG) 
         PM_LowValue      - (IS) default   0 (LONG)  
         PM_HighValue     - (IS) default 100 (LONG)

         PM_Ticks         -  Ticks to draw under the meter box
                               defaults to 0 for none 

         PM_CancelButton - Create a Cancel button? (BOOL)
         PM_CancelText   - @{"Text" Link "graphics/Text()"} for cancel button. default "Cancel". (STRPTR)
         PM_QueryCancel  - (S) The number of time the user
                           has pressed the cancel button since the last
                           PM_QueryCancel (ULONG *)  

         the following three are not implemented 
         PM_CancelID - Creates an IDCMP_GADGETUP event when the Cancel button
                       is clicked. IntuiMessage->IAddress will be a pointer
                       to a gadget whose GadgetID is taken from this tag.
                       To be used in conjunctoin with the PM_MsgPort tag.
         PM_CancelSigNum  - Sets a signal when the Cancel button is clicked 
         PM_CancelSigTask - Task to signal (struct Task *)    

@{b}   RESULT@{ub}
       returns a pointer to a ProgressMeter. or NULL on failure.

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}
@{b}     requires diskfont, exec, gadtools, graphics, intuition & utility@{ub}
@{b}     libraries to be open.@{ub}

@{b}   BUGS@{ub}
       Currently uses SmartRefresh window.

@{b}   SEE ALSO@{ub}
       @{"FreeProgressMeter()" Link "FreeProgressMeter()"}, @{"UpdateProgressMeterA()" Link "UpdateProgressMeterA()"}

@EndNode

@Node "ArgYesNo()" "extras.lib/ArgYesNo"

@{b}   NAME@{ub}
       ArgYesNo - Get a boolean tooltype value.

@{b}   SYNOPSIS@{ub}
       yes = ArgYesNo(TTypes,Entry,DefVal)

       BOOL ArgYesNo(UBYTE **, STRPTR, DefVal);

@{b}   FUNCTION@{ub}
       This function returns the value of a boolean tooltype.

@{b}   INPUTS@{ub}
       TTypes - a ToolTypes array returned by @{"ArgArrayInit()" Link "amiga_lib/ArgArrayInit()"}
       Entry - the entry to search for.
       DefVal - the default boolean value.

@{b}   RESULT@{ub}
       This function only considers the first letter of the
       of the value for the tooltype.  If the first letter
       of the value for the tooltype is 'Y' 'y' 'T' or 't'
       then this function returns 1, if the function finds
       'N' 'n' 'F' or 'f' then it returns 0, if this function
       finds any other character or cannot find the tooltype,
       then the function returns the DefVal.

@{b}   NOTES@{ub}
       must link with amiga.lib

@{b}   SEE ALSO@{ub}
@{b}     @{"amiga.lib/ArgArrayInit()" Link "amiga_lib/ArgArrayInit()"}, @{"amiga.lib/ArgString()" Link "amiga_lib/ArgString()"},@{ub}
@{b}     @{"amiga.lib/ArgInt()" Link "amiga_lib/ArgInt()"}, amiga.lib/ArgArrayDone()@{ub}
@EndNode

@Node "boopsi_GetGInfo()" "extras.lib/boopsi_GetGInfo"

@{b}   NAME@{ub}
       boopsi_GetGInfo -- Get the GadgetInfo pointer from common BOOPSI messa
ges

@{b}   SYNOPSIS@{ub}
       ginfo = boopsi_GetGInfo(Message)

       struct GadgetInfo *boopsi_GetGInfo(Msg);

@{b}   FUNCTION@{ub}
       Gets the pointer to the GadgetInfo structure from a BOOPSI
       message.

@{b}   INPUTS@{ub}
       Message - BOOPSI message pointer.

@{b}   RESULT@{ub}
       pointer to GadgetInfo structure or NULL.

@{b}   NOTES@{ub}
       Only handles OM_SET, OM_UPDATE, OM_NOTIFY, GM_HITTEST,
       GM_RENDER, GM_GOACTIVE, GM_HANDLEINPUT, GM_GOINACTIVE
       and GM_LAYOUT methods.

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "Busy()" "extras.lib/Busy"

@{b}   NAME@{ub}
       Busy -- displays busy pointer.

@{b}   SYNOPSIS@{ub}
       Busy(Window)

       void Busy(struct Window *);

@{b}   FUNCTION@{ub}
       Blocks input to a window by opening a requester.

@{b}   INPUTS@{ub}
       Window - 

@{b}   RESULT@{ub}
       None.

@{b}   NOTES@{ub}
       requires intuition.library to be open.

       This does not change the Window's IDCMP flags, so
       unless you change them your still going to receive
       input events.
       This function does nothing in WB versions less than
       3.0

@{b}   SEE ALSO@{ub}
       @{"NotBusy()" Link "NotBusy()"}

@EndNode

@Node "CopyString()" "extras.lib/CopyString"

@{b}   NAME@{ub}
       CopyString -- Copy a string

@{b}   SYNOPSIS@{ub}
       newstring = CopyString(Source, MemFlags)

       STRPTR CopyString(STRPTR, ULONG);

@{b}   FUNCTION@{ub}
       Allocates memory using @{"AllocVec" Link "exec/AllocVec()"} and copies a string.

@{b}   INPUTS@{ub}
       Source - the source string to copy
       MemFlags - Memory flags see @{"exec.library/AllocVec()" Link "exec/AllocVec()"}

@{b}   RESULT@{ub}
       String pointer or NULL. 

@{b}   NOTES@{ub}
       newstring must be freed with @{"FreeVec" Link "exec/FreeVec()"}.

@{b}   SEE ALSO@{ub}
@{b}     @{"exec.library/AllocVec()" Link "exec/AllocVec()"}, exec.library/FreeVec()@{ub}

@EndNode

@Node "db_EntryToNN()" "extras.lib/db_EntryToNN"

@{b}   NAME@{ub}
       db_EntryToNN -- Retrieve data from an ENTRY of a database.

@{b}   SYNOPSIS@{ub}
       STRPTR db_EntryToNN(BPTR File, STRPTR EntryName)

@{b}   FUNCTION@{ub}
       Get data from a Database, see @{"db_GetEntryData()" Link "db_GetEntryData()"}.
       All the data in the entry is put into an NNString.
       The data can then be parsed with @{"nns_GetNNData()" Link "nns_GetNNData()"}

@EndNode

@Node "db_GetEntryData()" "extras.lib/db_GetEntryData"

@{b}   NAME@{ub}
       db_GetEntryData -- Retrieve data from an ENTRY of a database.

@{b}   SYNOPSIS@{ub}
       db_GetEntryDataA(File, EntryName, Items) -- NOT implemented --

       BOOL db_GetEntryDataA(BPTR, STRPTR struct EItem *);

       db_GetEntryData(File, EntryName, Items, ... )

       BOOL db_GetEntryData(BPTR, STRPTR, STRPTR, ... );

@{b}   FUNCTION@{ub}
       Retrieve data from a simple ENTRY based database.

@{b}   INPUTS@{ub}
       File - an AmigaDOS BPTR to a file.
       Name - an array of struct Etems, the last struct EItem should have
              it's Name field set to NULL. (see example)
@{b}   RESULT@{ub}
       returns 0 on failure, possibly due to EOF, improper file format, or
       lack of memory.  
    
       To support multiple occurances of an item Name in an Entry, this 
       function returns NNStrings.  The strings are stored end to end in 
       the order that they were read from the file.

       On success, each EItem.ReturnString either points to an NNString,
       or NULL if no data for that Name was found.

       On failure, all EItem.ReturnStrings are NULL, and any data collected
       is freed.

@{b}   EXAMPLE@{ub}
       STRPTR title,desc;
       BPTR File;

       if(db_GetEntryData(File,"ENTRY",
                            "TITLE"  ,&title,
                            "DESC"   ,&desc,
                               0))
       {
         if(title)
         {
           printf("%s - ",title);
           FreeVec(title);
         }

         if(desc)
         {
           printf("%s\n");
           FreeVec(desc);
         }
       }


@{b}   NOTES@{ub}
       The database file format is an ASCII text file, and consists
       of "ENTRY"'s, that look like this:

       <ENTRYNAME>
       {
         <ITEMNAME> = <data>
         <ITEMNAME> = <data>
       }

       an example file format from above might be:

       ENTRY
       {
         TITLE=Cows 'R Us
         DESC=All you want to know about beef.
       }

       case of <ENTRYNAME> and <ITEMNAMES> is not important.
       the equal sign is required.
       
@{b}   HISTORY@{ub}
       This code probably isn't all that usefull, but it was the
       code behind the database of now defunct Tampa Bay Amiga Group's
       Amiga Support Directory.  Unfortunately, TBAG died before the
       ASD could begine to grow, and I haven't used this code since.

@{b}   BUGS@{ub}
       Not reentrant.

@{b}   SEE ALSO@{ub}
       nns_ProcessNNStr, @{"nns_AddNNStr()" Link "nns_AddNNStr()"}, nns_NextNNStr(), @{"db_EntryToNN()" Link "db_EntryToNN()"}

@EndNode

@Node "db_NextEntry()" "extras.lib/db_NextEntry"

@{b}   NAME@{ub}
       db_NextEntry - Find the next entry in a database file.

@{b}   SYNOPSIS@{ub}
       error = db_NextEntry(File, EntryName, Buffer, BufferSize)
       
       LONG db_NextEntry(BPTR, STRPTR, STRPTR, ULONG);

@{b}   FUNCTION@{ub}
       Seeks for the next entry in a database file.

@{b}   INPUTS@{ub}
       File - AmigaDos file handle.
       EntryName - the name of the entry, usually "ENTRY".
              case is insignificant.
       Buffer - a buffer for reading data from a file.
       BufferSize - the size of the buffer.

@{b}   RESULT@{ub}
       returns 0 on failure.  on success the file is positioned
       inside the entry.

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}
       This function is mainly used for other lib functions

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "EnqueueName()" "extras.lib/EnqueueName"

@{b}   NAME@{ub}
       EnqueueName -- Place a Node in a sorted List.

@{b}   SYNOPSIS@{ub}
       EnqueueName(List,Node)

       void EnqueueName(struct List *,struct Node*)

@{b}   FUNCTION@{ub}
       Place a Node in a sorted List prioritized by Node.ln_Name 
       and ln_Pri.

@{b}   INPUTS@{ub}
       List - pointer to a List to place Node into.
       Node - pointer to a Node to be placed in the List.

@{b}   RESULT@{ub}
       None.

@{b}   NOTES@{ub}
       The List must be presorted by ln_Name and ln_Pri.
       Every node must have its ln_Name field pointing to
       a NULL terminated string.

@EndNode

@Node "ex_CloseLibs()" "extras.lib/ex_CloseLibs"

@{b}   NAME@{ub}
       ex_CloseLibs -- close multiple libraries.

@{b}   SYNOPSIS@{ub}
       ex_CloseLibs(Libs)

       void ex_CloseLibs(struct Libs *);

@{b}   FUNCTION@{ub}
       @{"Close" Link "dos/Close()"} multiple libraries using the same array of
       struct Libs as used in OpenLibs.

@{b}   INPUTS@{ub}
       Libs - A pointer to an array of struct Libs.

@{b}   RESULT@{ub}
       none.

@{b}   NOTES@{ub}
       exec.library must already be opened.(usually done by the 
       compiler's startup code)

       revision 1.1
         corrected autodoc.
         now openes ExecBase on it's own.
       revision 1.2
         renamed to ex_CloseLib due to conflict with reaction.lib

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}
       @{"ex_OpenLibs()" Link "ex_OpenLibs()"}
@EndNode

@Node "ex_OpenLibs()" "extras.lib/ex_OpenLibs"

@{b}   NAME@{ub}
       ex_OpenLibs -- attempt to open multiple libraries.

@{b}   SYNOPSIS@{ub}
       success = ex_OpenLibs(Argc,ProgName,ErrorStr,
                   LibVerFmt,ButtonText,Libs)

       BOOL ex_OpenLibs(ULONG Argc, STRPTR ProgName, STRPTR ErrorString, 
              STRPTR LibVerFmt, STRPTR ButtonText, struct Libs *Libs);

@{b}   FUNCTION@{ub}
       Attempt to open multiple Libraries.  If any library
       fails to open, a requester is opened to notify the 
       user listing all of the libraries that failed to open. 

@{b}   INPUTS@{ub}
       Argc       - argc from main()
       ProgName   - pointer to a string containing the 
                   program's name.
       ErrorStr   - error string.  May be NULL.  Defaults to
                   "The following libraries are required:\n";
       LibVerFmt  - @{"printf" Link "amiga_lib/printf()"} style format string.  Defaults to 
                    "  %s version %ld\n"
       ButtonText - If a requester is used to display an error
                    message, this text is used in the button.
                    Defaults to "Ok"
       Libs       - an array of libraries to open.

@{b}   RESULT@{ub}
       return 0 on failure and non-zero on success.

@{b}   EXAMPLE@{ub}
       struct IntuitionBase *IntuitionBase;
       struct GfxBase *GfxBase;
       struct Library *GadToolsBase;
       
       struct Libs MyLibs[]=
       {
         &IntuitionBase,"intuition.library"    ,37, 0,
         &GfxBase      ,"graphics.library"     ,37, 0,
         &GadToolsBase ,"gadtools.library"     ,37, 0,
         &LocaleBase   ,"datatypes.library"    ,39, OLF_OPTIONAL,
         0,0,0
       };

       void main(int argc, char **argv) 
       {
         if(ex_OpenLibs(arcg,"MyProgram",0,0,0,MyLibs))
         {
           ...
           CloseLibs(MyLibs);
         }
       }

@{b}   NOTES@{ub}
       On error, this function will automatically display an 
       intuition requester if Argc=0 or print error information 
       out to STDIO if Argc>0.

       exec.library must already be open.(usually done by the 
       compiler's startup code)

       revision 1.1
         autodoc fix
         now opens exec.library on it's own.
       revision 1.2
         renamed to ex_OpenLib due to conflict with reaction.lib

       

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}
       @{"ex_CloseLibs()" Link "ex_CloseLibs()"}
@EndNode

@Node "EZReq()" "extras.lib/EZReq"

@{b}   NAME@{ub}
       EZReq -- create an Intuition EasyRequest.

@{b}   SYNOPSIS@{ub}
       retval = EZReq(Win, IDCMP_ptr, Title, @{"Text" Link "graphics/Text()"},
                       ButtonText,Arg,...)

       LONG EZReq(struct Window *, ULONG *, STRPTR, STRPTR, 
                  STRPTR, ULONG, ...);

@{b}   FUNCTION@{ub}
       This function provides an easier method to use the 
       @{"intuition/EasyRequestArgs()" Link "intuition/EasyRequestArgs()"} function.

@{b}   INPUTS@{ub}
       Win -
       IDCMP_ptr - 
       Title -
       @{"Text" Link "graphics/Text()"} -
       ButtonText -
       Arg -

@{b}   RESULT@{ub}

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}
       requires the exec.library to be open, automatically opens
       intuition.library.

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "FindLine()" "extras.lib/FindLine"

@{b}   NAME@{ub}
       FindLine - find the next matching line in a file.

@{b}   SYNOPSIS@{ub}






@{b}   FUNCTION@{ub}


@{b}   INPUTS@{ub}

@{b}   RESULT@{ub}

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "FreeProgressMeter()" "extras.lib/FreeProgressMeter"

@{b}   NAME@{ub}
       FreeProgressMeter -- @{"Close" Link "dos/Close()"} a PregressMeter.

@{b}   SYNOPSIS@{ub}
       FreeProgressMeter(PM)

       void FreeProgressMeter(ProgressMeter );

@{b}   FUNCTION@{ub}
       @{"Close" Link "dos/Close()"} and deallocated a ProgressMeter.

@{b}   INPUTS@{ub}
       PM - pointer to an existing ProgressMeter or NULL.

@{b}   RESULT@{ub}
       none.

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}
@{b}     requires diskfont, exec, gadtools, graphics, intuition & utility@{ub}
@{b}     libraries to be open.@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}
       @{"AllocProgressMeterA()" Link "AllocProgressMeterA()"}, @{"UpdateProgressMeterA()" Link "UpdateProgressMeterA()"}

@EndNode

@Node "ftos()" "extras.lib/ftos"

@{b}   NAME@{ub}
       ftos - Convert a float to a string

@{b}   SYNOPSIS@{ub}






@{b}   FUNCTION@{ub}


@{b}   INPUTS@{ub}

@{b}   RESULT@{ub}

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "gui_GhostRect()" "extras.lib/gui_GhostRect"

@{b}   NAME@{ub}
       GhostRect -- Cover a rectangular are with 
                    a ghosted pattern.

@{b}   SYNOPSIS@{ub}
       gui_GhostRect(RP, Pen, X0, Y0, X1, Y1)

       void gui_GhostRect(struct RastPort *, ULONG, 
            WORD, WORD, WORD, WORD); 

@{b}   FUNCTION@{ub}
       Covers a rectangular area with a ghosted pattern
       using the specified pen number.

@{b}   INPUTS@{ub}
       RP - Pointer to a RastPort.
       Pen - the pen number to use for the pattern.
       X0 - left edge 
       Y0 - top edge
       X1 - right edge
       Y1 - bottom edge

@EndNode

@Node "gui_MaxStrFontLen()" "extras.lib/gui_MaxStrFontLen"

@{b}   NAME@{ub}
       gui_MaxStrFontLen - get the maximum pixel length of a
       string containg N characters. 

@{b}   SYNOPSIS@{ub}
       length=gui_MaxStrFontLen(Font, Chars, LowChar, HighChar)

       LONG gui_MaxStrFontLen(struct TextFont *, ULONG, UBYTE, UBYTE);

@{b}   FUNCTION@{ub}
       This function returns the maximum number of pixels
       a string with a certain number of characters could
       occupy.

@{b}   INPUTS@{ub}
       Font - struct TextFont * previously opened by 
              @{"OpenFont()" Link "graphics/OpenFont()"} or @{"OpenDiskFont()" Link "diskfont/OpenDiskFont()"}.
       Chars - the max number characters in a string.
       LowChar - the ASCII number of lowest character
                 that could be in a string.
       HighChar - the ASCII number of the highest character
                  that could be in a string.

@{b}   EXAMPLE@{ub}
        find the longest pixel length of a number 
        upto 3 digits 
       long maxnumberlen;
       struct TextFont *tf;

       maxnumberlen=gui_MaxStrFontLen(tf,3,'0','9');

@{b}   RESULT@{ub}
       the pixel length or 0 if the Font parameter
       is NULL.

@EndNode

@Node "gui_StrFontLen()" "extras.lib/gui_StrFontLen"

@{b}   NAME@{ub}
       gui_StrFontLen - get the pixel length of a string.

@{b}   SYNOPSIS@{ub}
       length=gui_StrFontLen(Font, Str)

       LONG gui_StrFontLen(struct TextFont *,STRPTR);

@{b}   FUNCTION@{ub}
       This function returns the number of pixels a string
       would occupy if rendered in the specified Font.

@{b}   INPUTS@{ub}
       Font - struct TextFont * previously opened by 
              @{"OpenFont()" Link "graphics/OpenFont()"} or @{"OpenDiskFont()" Link "diskfont/OpenDiskFont()"}.
       Str - a pointer to a null terminated string.

@{b}   RESULT@{ub}
       the pixel length of the string or 0 if either parameter
       is NULL.

@EndNode

@Node "gui_StrLength()" "extras.lib/gui_StrLength"

@{b}   NAME@{ub}
       gui_StrLength -- Get the pixel length of a string.

@{b}   SYNOPSIS@{ub}
       Len = gui_StrLength(Tags)
       
       LONG gui_StrLength(Tag, ... );

@{b}   FUNCTION@{ub}
       Find the length of a given string.  If multiple strings
       are given, returns the longest length.

@{b}   INPUTS@{ub}
       Tags 
         SL_TextFont - (struct TextFont *)The font the string will
           be rendered in. (required)
         SL_IgnoreChars - (STRPTR) Null terminated string of characters
           to ignore from the length calculation, useful for underscores
           in gadget text, etc.
         SL_String - (STRPTR) String to size.

@{b}   RESULT@{ub}
       Length in pixels of longest string.

@{b}   EXAMPLE@{ub}
         *find length of button text without the "_" 
         len= gui_StrLength(SL_TextFont     ,TF,
                        SL_String       ,"_Button",
                        SL_IgnoreChars  ,"_",
                        TAG_DONE);

         * find maximum length of red, green and blue without "_"
         len= gui_StrLength(SL_TextFont     ,TF,
                        SL_String       ,"_Red",
                        SL_String       ,"_Green",
                        SL_String       ,"_Blue",
                        SL_IgnoreChars  ,"_",
                        TAG_DONE);

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "IsWhiteSpace()" "extras.lib/IsWhiteSpace"

@{b}   NAME@{ub}
       IsWhiteSpace -- Is a character a "white-space"

@{b}   SYNOPSIS@{ub}
       IsWhiteSpace(Char)

       BOOL IsWhiteSpace(char);

@{b}   FUNCTION@{ub}
       Indicate whether or not a character is a "white-space"

@{b}   INPUTS@{ub}
       Char - a letter.

@{b}   RESULT@{ub}
       non-0 if Char is " "(space), "\t"(tab), or "\n"(cr)

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "key_Shifted()" "extras.lib/key_Shifted"

@{b}   NAME@{ub}
       key_Shifted -- Get shifted character of suppied character

@{b}   SYNOPSIS@{ub}
       shiftedchar = key_Shifted(character)

       ULONG key_Shifted(char);

@{b}   FUNCTION@{ub}
       Returns the shifted character for the supplied character.
       For example (on the USA keymap) 
         key_Shifted('#') = '#' 
         key_Shifted('3') = '#'

@{b}   NOTE@{ub}
       This function was previously KeyShifted()

@{b}   SEE ALSO@{ub}
       Key_Unshifted()

@EndNode

@Node "key_Unshifted()" "extras.lib/key_Unshifted"

@{b}   NAME@{ub}
       key_Unshifted -- Get unshifted character of suppied character

@{b}   SYNOPSIS@{ub}
       unshiftedchar = key_Unshifted(character)

       ULONG key_Unshifted(char);

@{b}   FUNCTION@{ub}
       Returns the unshifted character for the supplied character.
       For example (on the USA keymap) 
         key_Unshifted('#') = '3' 
         key_Unshifted('3') = '3'

@{b}   NOTE@{ub}
       This function was previously KeyUnshifted()

@{b}   SEE ALSO@{ub}
       KeyShifted()

@EndNode

@Node "MultiAllocMemA()" "extras.lib/MultiAllocMemA"

@{b}   NAME@{ub}
       MultiAllocMemA -- Multiple @{"AllocMem" Link "exec/AllocMem()"}.
       MultiAllocMem -- varargs stub.

@{b}   SYNOPSIS@{ub}
       succes = MultiAllocMemA(Flags, MemTagList)

       BOOL MultiAllocMem(ULONG, struct MemTag *);

       succes = MultiAllocMemA(Flags, MemTag)

       BOOL MultiAllocMemA(Flags, ULONG, ...);

@{b}   FUNCTION@{ub}
       Attempt to allocate one or more memory chunks
       using @{"AllocMem" Link "exec/AllocMem()"}.

@{b}   INPUTS@{ub}
       Flags - MA_FAILSIZE0: fail all allocations if any
               have a size of 0.  if your application will be
               allocating memory of dynamic sizes, and if
               you want allocations of 0 bytes to fail, then
               set this flag.
       MemTag - pointer to an array of struct MemTag.
                  vt_Ptr is the address of a pointer.
                  vt_Size is the size of the allocation.
                  vt_MemFlags are the exec memory (MEMF_) flags. 
                Last tag should have vt_Ptr = NULL.
                 
@{b}   RESULT@{ub}
       zero if it couldn't allocate the requested memory. or non-zero
       on success. vt_Ptrs will be point to a allocated 
       memory chunk or NULL.  

@{b}   EXAMPLE@{ub}
       EX1:
         struct foo *bar;
         STRPTR dest;
         APTR cow;

        if( MultiAllocMem(0,
                           &bar,  sizeof(struct foo),  MEMF_CLEAR,
                           &dest, 25,                  MEMF_PUBLIC,
                           &cow,  100,                 MEMF_FAST|MEMF_PUBLIC,
                           0))
         {
           ...
           MultiFreeMem(3,
                           bar  ,sizeof(struct foo),
                           dest ,25,
                           cow  ,100);
         }

       EX2: This will never fail.
         APTR foo;
         if(MultiAllocMem(0,
                           &foo,0,MEMF_CLEAR,
                           0)
         {...}

       EX3: This will always fail.
         APTR foo;
         if(MultiAllocMem(MA_FAILSIZE0,
                           &foo,0,MEMF_CLEAR,
                           0)
         {...}

@{b}   NOTES@{ub}
       requires exec.library to be open.

       if the MA_FAILSIZE0 Flag is not set, 0 byte allocations
       will pass even though no memory will be allocated for that.
       entry and mt_Ptr will be set to 0.

       The memory allocated may be freed individually with 
       @{"exec.library/FreeMem()" Link "exec/FreeMem()"}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}
       @{"MultiAllocVecA()" Link "MultiAllocVecA()"}, @{"MultiFreeVecA()" Link "MultiFreeVecA()"}, @{"MultiFreeMemA()" Link "MultiFreeMemA()"},
       @{"MultiAllocPooledA()" Link "MultiAllocPooledA()"}, @{"MultiFreePooledA()" Link "MultiFreePooledA()"},
       @{"exec.library/AllocVec()" Link "exec/AllocVec()"}, @{"exec.library/FreeVec()" Link "exec/FreeVec()"}
       @{"exec.library/AllocMem()" Link "exec/AllocMem()"}, @{"exec.library/FreeMem()" Link "exec/FreeMem()"}
       @{"exec.library/AllocPooled()" Link "exec/AllocPooled()"}, @{"exec.library/FreePooled()" Link "exec/FreePooled()"}
@EndNode

@Node "MultiAllocPooledA()" "extras.lib/MultiAllocPooledA"

@{b}   NAME@{ub}
       MultiAllocPooledA -- Multiple @{"AllocPooled" Link "exec/AllocPooled()"}.
       MultiAllocPooled -- varargs stub.

@{b}   SYNOPSIS@{ub}
       succes = MultiAllocPooledA(Flags, PoolTagList)

       BOOL MultiAllocPooled(ULONG, struct PoolTag*);

       succes = MultiAllocPooledA(Flags, PoolTag)

       BOOL MultiAllocPooledA(Flags, ULONG, ...);

@{b}   FUNCTION@{ub}
       Attempt to allocate one or more memory chunks
       using @{"AllocPooled" Link "exec/AllocPooled()"}.

@{b}   INPUTS@{ub}
       Flags - MA_FAILSIZE0: fail all allocations if any
               have a size of 0.  if your application will be
               allocating memory of dynamic sizes, and if
               you want allocations of 0 bytes to fail, then
               set this flag.
       PoolTag - pointer to an array of struct PoolTag.
                  pt_Ptr is the address of a pointer.
                  pt_Size is the size of the allocation.
                Last tag should have vt_Ptr = NULL.
                 
@{b}   RESULT@{ub}
       zero if it couldn't allocate the requested memory. or non-zero
       on success. In either case, vt_Ptrs will be point to a allocated 
       memory chunk or NULL.  

@{b}   EXAMPLE@{ub}
       EX1:
         APTR pool;
         struct foo *bar;
         STRPTR dest;
         APTR cow;

         if(pool=CreatePool(MEMF_ANY,300,300))
         {
           if( MultiAllocPooled(pool,0,
                           &bar,  sizeof(struct foo),
                           &dest, 50,       
                           &cow,  100,
                           0))
           {
             ...
             MultiFreePooled(pool,3,
                               bar,  sizeof(struct foo),
                               dest, 50,
                               cow,  100);
           }
           DeletePool(pool);
         }

       EX2: This will never fail.
         if(MultiAllocPooled(pool,0,
                           &foo, 0,
                           0)
         {...}

       EX3: This will always fail.
         if(MultiAllocPooled(pool,MA_FAILSIZE0,
                           &foo, 0,
                           0)
         {...}

@{b}   NOTES@{ub}
       requires exec.library to be open.

       if the MA_FAILSIZE0 flag is not set, 0 byte allocations
       will pass even though no memory will be allocated for that.
       entry and mt_Ptr will be set to 0.

       The memory allocated may be freed individually with 
       @{"exec.library/FreePooled()" Link "exec/FreePooled()"}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}
       @{"MultiFreeVecA()" Link "MultiFreeVecA()"}, @{"MultiAllocMemA()" Link "MultiAllocMemA()"},@{"MultiFreeMemA()" Link "MultiFreeMemA()"},
       @{"MultiFreePooledA()" Link "MultiFreePooledA()"},
       @{"exec.library/AllocVec()" Link "exec/AllocVec()"}, @{"exec.library/FreeVec()" Link "exec/FreeVec()"}
       @{"exec.library/AllocMem()" Link "exec/AllocMem()"}, @{"exec.library/FreeMem()" Link "exec/FreeMem()"}
       @{"exec.library/AllocPooled()" Link "exec/AllocPooled()"}, @{"exec.library/FreePooled()" Link "exec/FreePooled()"}
@EndNode

@Node "MultiAllocVecA()" "extras.lib/MultiAllocVecA"

@{b}   NAME@{ub}
       MultiAllocVecA -- Multiple @{"AllocVec" Link "exec/AllocVec()"}.
       MultiAllocVec -- varargs stub.

@{b}   SYNOPSIS@{ub}
       succes = MultiAllocVecA(Flags, VecTagList)

       BOOL MultiAllocVec(ULONG, struct VecTag *);

       succes = MultiAllocVecA(Flags, VecTag)

       BOOL MultiAllocVecA(Flags, ULONG, ...);

@{b}   FUNCTION@{ub}
       Attempt to allocate one or more memory chunks
       using @{"AllocVec" Link "exec/AllocVec()"}.

@{b}   INPUTS@{ub}
       Flags - MA_FAILSIZE0: fail all allocations if any
               have a size of 0.  if your application will be
               allocating memory of dynamic sizes, and if
               you want allocations of 0 bytes to fail, then
               set this flag.
       VecTag - pointer to an array of struct VecTag.
                  vt_Ptr is the address of a pointer.
                  vt_Size is the size of the allocation.
                  vt_MemFlags are the exec memory (MEMF_) flags. 
                Last tag should have vt_Ptr = NULL.
                 
@{b}   RESULT@{ub}
       zero if it couldn't allocate the requested memory. or non-zero
       on success. In either case, vt_Ptrs will be point to a allocated 
       memory chunk or NULL.  

@{b}   EXAMPLE@{ub}
       EX1:
         struct foo *bar;
         STRPTR dest;
         APTR cow;

        if( MultiAllocVec(0,
                           &bar,  sizeof(struct foo),  MEMF_CLEAR,
                           &dest, strlen(str)+1,       MEMF_PUBLIC,
                           &cow,  100,                 MEMF_FAST|MEMF_PUBLIC,
                           0))
         {
           ...
           MultiFreeVec(3,bar,dest,cow);
         }

       EX2: This will never fail.
         APTR foo;
         if(MultiAllocVec(0,
                           &foo,0,MEMF_CLEAR,
                           0)
         {...}

       EX3: This will always fail.
         APTR foo;
         if(MultiAllocVec(MA_FAILSIZE0,
                           &foo,0,MEMF_CLEAR,
                           0)
         {...}

@{b}   NOTES@{ub}
       requires exec.library to be open.

       if the MA_FAILSIZE0 flag is not set, 0 byte allocations
       will pass even though no memory will be allocated for that.
       entry and mt_Ptr will be set to 0.

       The memory allocated may be freed individually with 
       @{"exec.library/FreeVec()" Link "exec/FreeVec()"}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}
       @{"MultiFreeVecA()" Link "MultiFreeVecA()"}, @{"MultiAllocMemA()" Link "MultiAllocMemA()"},@{"MultiFreeMemA()" Link "MultiFreeMemA()"},
       @{"MultiAllocPooledA()" Link "MultiAllocPooledA()"},@{"MultiFreePooledA()" Link "MultiFreePooledA()"},
       @{"exec.library/AllocVec()" Link "exec/AllocVec()"}, @{"exec.library/FreeVec()" Link "exec/FreeVec()"}
       @{"exec.library/AllocMem()" Link "exec/AllocMem()"}, @{"exec.library/FreeMem()" Link "exec/FreeMem()"}
       @{"exec.library/AllocPooled()" Link "exec/AllocPooled()"}, @{"exec.library/FreePooled()" Link "exec/FreePooled()"}
@EndNode

@Node "MultiFreeMemA()" "extras.lib/MultiFreeMemA"

@{b}   NAME@{ub}
       MultiFreeMemA -- Free multiple memory chunks.
       MultiFreeMem -- varargs stub.

@{b}   SYNOPSIS@{ub}
       MultiFreeMemA(Args, FreeTagList)

       void MultiFreeMemA(ULONG, struct FreeTag *);

       MultiFreeMem(Args, FreeTag, ... )

       void MultiFreeMem(ULONG, ULONG, ... );

@{b}   FUNCTION@{ub}
       Free multiple memory blocks allocated with @{"MultiAllocMemA()" Link "MultiAllocMemA()"}
       or @{"exec.library/AllocMem()" Link "exec/AllocMem()"}. 

@{b}   INPUTS@{ub}
       Args - Number of blocks that are to be freed.
       FreeTagList - An array of FreeTags. may be NULL.
                       ft_Ptr - contains a pointer to a
                                memory block or NULL.
                       ft_Size - the size of the block.

@{b}   RESULT@{ub}
       none.

@{b}   NOTES@{ub}
       requires exec.library to be open.

@{b}   SEE ALSO@{ub}
       @{"MultiAllocVecA()" Link "MultiAllocVecA()"}, @{"MultiFreeVecA()" Link "MultiFreeVecA()"}, @{"MultiAllocMemA()" Link "MultiAllocMemA()"},
       @{"MultiAllocPooledA()" Link "MultiAllocPooledA()"}, @{"MultiFreePooledA()" Link "MultiFreePooledA()"},
       @{"exec.library/AllocVec()" Link "exec/AllocVec()"}, @{"exec.library/FreeVec()" Link "exec/FreeVec()"}
       @{"exec.library/AllocMem()" Link "exec/AllocMem()"}, @{"exec.library/FreeMem()" Link "exec/FreeMem()"}
       @{"exec.library/AllocPooled()" Link "exec/AllocPooled()"}, @{"exec.library/FreePooled()" Link "exec/FreePooled()"}

@EndNode

@Node "MultiFreePooledA()" "extras.lib/MultiFreePooledA"

@{b}   NAME@{ub}
       MultiFreePooledA -- Free multiple memory chunks.
       MultiFreePooled -- varargs stub.

@{b}   SYNOPSIS@{ub}
       MultiFreePooledA(Pool, Args, FreeTagList)

       void MultiFreePooledA(APTR, ULONG, struct FreeTag *);

       MultiFreePooled(Pool, Args, FreeTag, ... )

       void MultiFreePooled(APTR, ULONG, ULONG, ... );

@{b}   FUNCTION@{ub}
       Free multiple memory blocks allocated with @{"MultiAllocPooledA()" Link "MultiAllocPooledA()"}
       or @{"exec.library/AllocPooled()" Link "exec/AllocPooled()"}. 

@{b}   INPUTS@{ub}
       Args - Number of blocks that are to be freed.
       FreeTagList - An array of FreeTags. may be NULL.
                       ft_Ptr - contains a pointer to a
                                memory block or NULL.
                       ft_Size - the size of the block.

@{b}   RESULT@{ub}
       none.

@{b}   NOTES@{ub}
       requires exec.library to be open.

@{b}   SEE ALSO@{ub}
       @{"MultiAllocVecA()" Link "MultiAllocVecA()"}, @{"MultiFreeVecA()" Link "MultiFreeVecA()"}, @{"MultiAllocMemA()" Link "MultiAllocMemA()"},
       @{"MultiAllocPooledA()" Link "MultiAllocPooledA()"}, MultiFreePooledA(),
       @{"exec.library/AllocVec()" Link "exec/AllocVec()"}, @{"exec.library/FreeVec()" Link "exec/FreeVec()"}
       @{"exec.library/AllocMem()" Link "exec/AllocMem()"}, @{"exec.library/FreeMem()" Link "exec/FreeMem()"}
       @{"exec.library/AllocPooled()" Link "exec/AllocPooled()"}, @{"exec.library/FreePooled()" Link "exec/FreePooled()"}

@EndNode

@Node "MultiFreeVecA()" "extras.lib/MultiFreeVecA"

@{b}   NAME@{ub}
       MultiFreeVecA -- Free multiple memory chunks.
       MultiFreeVec -- varargs stub.

@{b}   SYNOPSIS@{ub}
       MultiFreeVecA(Args,MemBlockList)

       MultiFreeVecA(ULONG, APTR *);

       MultiFreeVec(Args, MemBlock)

       void MultiFreeVec(ULONG, ULONG, ... );

@{b}   FUNCTION@{ub}
       Free multiple memory blocks allocated with @{"MultiAllocVecA()" Link "MultiAllocVecA()"}
       or @{"exec.library/AllocVec()" Link "exec/AllocVec()"}. 

@{b}   INPUTS@{ub}
       Args - Number of blocks that are to be freed.
       MemBlockList - An array of pointers to memory
                      blocks to be freed or NULL.

@{b}   RESULT@{ub}
       none.

@{b}   NOTES@{ub}
       requires exec.library to be open.

@{b}   SEE ALSO@{ub}
       @{"MultiAllocVecA()" Link "MultiAllocVecA()"}, MultiFreeVecA(), @{"MultiAllocMemA()" Link "MultiAllocMemA()"}, @{"MultiFreeMemA()" Link "MultiFreeMemA()"},
       @{"MultiAllocPooledA()" Link "MultiAllocPooledA()"}, @{"MultiFreePooledA()" Link "MultiFreePooledA()"},
       @{"exec.library/AllocVec()" Link "exec/AllocVec()"}, @{"exec.library/FreeVec()" Link "exec/FreeVec()"}
       @{"exec.library/AllocMem()" Link "exec/AllocMem()"}, @{"exec.library/FreeMem()" Link "exec/FreeMem()"}
       @{"exec.library/AllocPooled()" Link "exec/AllocPooled()"}, @{"exec.library/FreePooled()" Link "exec/FreePooled()"}
@EndNode

@Node "NextNNStr()" "extras.lib/NextNNStr"

@{b}   NAME@{ub}
       NextNNStr -- Get the next string in a double NULL terminted
                    string array (aka NNString).

@{b}   SYNOPSIS@{ub}
       nextstring=NextNNStr(NNString)

       STRPTR NextNNStr(STRPTR);

@{b}   FUNCTION@{ub}
       returns a pointer to the next string contained in a 
       double NULL teminated string array, or NULL.

@{b}   INPUTS@{ub}
       NNString - A pointer to some part of a double NULL string.

@{b}   RESULT@{ub}
       Pointer to the next string or NULL if there is no string.

@{b}   EXAMPLE@{ub}
       ** this example steps through an NNString. **

       STRPTR NNString;
       STRPTR str;

       for(str=NNString; str; str=NextNNStr(str))
       {
         printf("%s\n",str);
       }

       The above can be simplified by using the ProcessNNStr macro
       defined in extras/nnstring.h

       STRPTR NNString;
       STRPTR str;

       ProcessNNStr(NNString,str)
       {
         printf("%s\n",str);
       }

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}
       NNString AddNNStr() ProcessNNStr, extras/macros.h

@EndNode

@Node "nns_AddNNStr()" "extras.lib/nns_AddNNStr"

@{b}   NAME@{ub}
       nns_AddNNStr -- append a normal string to a NNString.

@{b}   SYNOPSIS@{ub}
       NewNNStr=nns_AddNNStr(NNStr,New)

       STRPTR nns_AddNNStr(STRPTR, STRPTR);

@{b}   FUNCTION@{ub}
       

@{b}   INPUTS@{ub}
       NNStr - an existing NNString or NULL, if NULL
           the function converts str into an NNString.
       New - a regular NULL terminated string.

@{b}   RESULT@{ub}
       A new NNString or NULL, NNStr *WILL* be freed
       regardless of result.  if New is NULL, NNStr will
       be returned.

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "nns_GetNNData()" "extras.lib/nns_GetNNData"

@{b}   NAME@{ub}
       nns_GetNNData -- Find data in a NNString

@{b}   SYNOPSIS@{ub}
       STRPTR GetNNData(STRPTR NNStr, STRPTR Name, STRPTR DefVal);

@{b}   FUNCTION@{ub}
       Retrieves data from a NNString.

       nnstr="TITLE=Joe\0COLOR=Green\0TITLE=Test\0\0"

       t=GetNNData(nnstr,"TITLE","None");

       t will equal "Joe\0Test\0\0"

@{b}   SEE ALSO@{ub}

@EndNode

@Node "nns_NNStrLen()" "extras.lib/nns_NNStrLen"

@{b}   NAME@{ub}
       nns_NNStrLen -- Return the length of an NNString.

@{b}   SYNOPSIS@{ub}
       length=nns_NNStrLen(NNStr)

       LONG nns_NNStrLen(STRPTR);

@{b}   FUNCTION@{ub}
       Returns the length in bytes of an NNString, including the
       trailing NULLs. 

@{b}   INPUTS@{ub}
       NNStr - NNString pointer.

@{b}   RESULT@{ub}
       Size of NNStr include NULLs.

@{b}   SEE ALSO@{ub}

@EndNode

@Node "NNString_Overview()" "extras.lib/NNString_Overview"

@{b}   FUNCTION@{ub}
       An NNString is an array of strings, stored end to end, ending
       with a double NULL.  Individual strings are seperated by NULLs.

@{b}   EXAMPLE@{ub}
       An NNString representing this array of strings:
       "Cow" "Dog" "Barn"
       would look like this:
       "Cow\0Dog\0Barn\0\0"

@{b}   SEE ALSO@{ub}
       @{"NextNNStr()" Link "NextNNStr()"}, ProcessNNStr, GetEntryData(), AddNNStr(), 
       NNStrLen()

@EndNode

@Node "NotBusy()" "extras.lib/NotBusy"

@{b}   NAME@{ub}
       NotBusy -- displays busy pointer.

@{b}   SYNOPSIS@{ub}
       NotBusy(Window)

       void NotBusy(struct Window *);

@{b}   FUNCTION@{ub}
       Removes the busy pointer for the specified
       window.

@{b}   INPUTS@{ub}
       Window - the window to remove the busy pointer
                from.

@{b}   RESULT@{ub}
       None.

@{b}   NOTES@{ub}
       requires intuition.library to be open.

       This does not change the Window's IDCMP flags.
       This function does nothing in WB versions less than
       3.0

@{b}   SEE ALSO@{ub}
       @{"Busy()" Link "Busy()"}

@EndNode

@Node "OBSOLETE--datasheet--()" "extras.lib/OBSOLETE--datasheet--"

@{b}   NOTES@{ub}
       I deem some functions obsolete.

       All the GadTools layout code and support Functions are obsolete,
       due to OS3.5 being released with Reaction/ClassAct. 
 
       I found it easier to convert a gui than to maintain it with my code :)
       They remain in the archive and in the .lib's only because some program
s
       still need them to compile.

@EndNode

@Node "OBSOLETE_CheckInnerWindowSize()" "extras.lib/OBSOLETE_CheckInnerWindowSizeras.lib/OBSOLETE_CheckInnerWindowSize"

@{b}   OBSOLETE@{ub}
       Since OS3.5 uses Reaction/ClassAct - this code is obsolete

@{b}   NAME@{ub}
       CheckInnerWindowSize - See if a window will fit on a screen.

@{b}   SYNOPSIS@{ub}
       windowfits = CheckInnerWindowSize(Scr, Width, Height,
                                     XScale, YScale)

       BOOL CheckInnerWindoeSize(struct Screen *, WORD, WORD, 
                                    float, float);

@{b}   FUNCTION@{ub}
       This function checks to see if a window with the specified
       inner dimensions will fit on a screen.

@{b}   INPUTS@{ub}
       Scr - the Screen the window is destine for.
       Width -  the base inner width of the window.
       Height - the base inner height of the window.
       XScale - the proposed x scale of the window.
       YScale - the proposed y scale of the window.

@{b}   RESULT@{ub}
       Returns TRUE if the window will fit, and FALSE if not.
       if the XScale or YScale is <=0 it will also fail.

@{b}   SEE ALSO@{ub}
       GetGUIScale(), CheckWindowSize()


@EndNode

@Node "OBSOLETE_CheckWindowSize()" "extras.lib/OBSOLETE_CheckWindowSize"

@{b}   OBSOLETE@{ub}
       Since OS3.5 uses Reaction/ClassAct - this code is obsolete

@{b}   NAME@{ub}
       CheckWindowSize - See if a window will fit on a screen.

@{b}   SYNOPSIS@{ub}
       windowfits = CheckWindowSize(Scr, Width, Height,
                                     XScale, YScale)

       BOOL CheckWindowSize(struct Screen *, WORD, WORD, 
                                    float, float);

@{b}   FUNCTION@{ub}
       This function checks to see if a window will fit on a screen.

@{b}   INPUTS@{ub}
       Scr - the Screen the window is destine for.
       Width - the base width of the window.
       Height - the base height of the window.
       XScale - the proposed x scale of the window.
       YScale - the proposed y scale of the window.

@{b}   RESULT@{ub}
       Returns TRUE if the window will fit, and FALSE if not.
       if the XScale or YScale is <=0 it will also fail.

@{b}   SEE ALSO@{ub}
       GetGUIScale(), CheckInnerWindowSize()

@EndNode

@Node "OBSOLETE_GetGUIScale()" "extras.lib/OBSOLETE_GetGUIScale"

@{b}   OBSOLETE@{ub}
       Since OS3.5 uses Reaction/ClassAct - this code is obsolete

@{b}   NAME@{ub}
       GetGUIScale -- Find the appropriate scale for an
                      interface.

@{b}   SYNOPSIS@{ub}
       success = GetGUIScale(TAttr, Strings, &XScale, &YScale)

       BOOL GetGUIScale(struct TextAttr *, struct GUI_String *,
                        float *, float *);

@{b}   FUNCTION@{ub}
       This function figures out the minimum size an interface
       should be so that all of the Strings will fit.

@{b}   INPUTS@{ub}
       TAttr - The TextAttr to be used for the strings.
       Strings - A NULL terminated array of GUI_String containing
                 the Strings to used in the interface and the maximum
                 size each string can be before the interface needs
                 to be enlarged.
       XScale - the address of a float to contain the X scale factor.
       YScale - the address of a float to contain the Y scale factor. 

@{b}   RESULT@{ub}
       This function returns non-zero on success, and will have the X &
       YScale values set apropriately.  Returns NULL on failure if the
       font specified in TAttr can not be opened, and X & YScale will be
       set to -1.

@{b}   NOTES@{ub}
       requires diskfont.library to be open.

       The reason this function sets X & YScale to -1 on failure is to
       also cause CheckWindowSize() and CheckInnerWindowSize to fail.
       This way you can simply:
       GetGUIScale(ta,strings,&xscale,&yscale)
       if(!CheckWindwoWidth(scr,winwidth,winheight,xscale,yscale))
       { ... revert to topaz.8 ... 
       }

       The GUI_String specifies the maximum size a string can be before
       the interface should be scaled horizontally.  For example, if you
       have a BUTTON_KIND gadget that is 100 pixels wide, then you may
       want to set the maximum size for the string in that gadget to 90.  
       (ie.
            struct GUI_String gs[]=
            {
              "Button Text", 90,
              0,0
            };
       )

@{b}   SEE ALSO@{ub}
       MakeGadgets()

@EndNode

@Node "OBSOLETE_LG_AddGadgets()" "extras.lib/OBSOLETE_LG_AddGadgets"

@{b}   OBSOLETE@{ub}
       Since OS3.5 uses Reaction/ClassAct - this code is obsolete

@{b}   NAME@{ub}
       LG_AddGadgets - Add gadgets to a window.

@{b}   SYNOPSIS@{ub}






@{b}   FUNCTION@{ub}


@{b}   INPUTS@{ub}

@{b}   RESULT@{ub}

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "OBSOLETE_LG_CreateGadgets()" "extras.lib/OBSOLETE_LG_CreateGadgets"

@{b}   OBSOLETE@{ub}
       Since OS3.5 uses Reaction/ClassAct - this code is obsolete

@{b}   NAME@{ub}
       LG_CreateGadgets -- Create multiple Gadtools gadgets.

@{b}   SYNOPSIS@{ub}
       gcontrol = LG_CreateGadgets(Tags)

       struct LG_Control *LG_CreateGadgets(Tag Tags, ...);

@{b}   FUNCTION@{ub}
       Creates multiple Gadtools, with some layout options.

@{b}   INPUTS@{ub}
       Tags (see <extras/layougtgt.h>)

         LG_LeftEdge, LG_XPos - Position of gadget
         LG_TopEdge,  LG_YPos - Position of gadget
             The position of the gadget will depend on these attributes
             and the LG_Justification attribute.  Also see the relational
             macros in <extras/layoutgt.h>
         LG_Width  - Gadget width
         LG_Height - Gadget height

           for the following see the NewGadget structure in 
           @{"<libraries/gadtools.h>" Link "sc:includesc:includelibraries/gadtools.h/Main" 0}
         LG_GadgetText
         LG_TextAttr
         LG_GadgetID
         LG_Flags
         LG_VisualInfo
         LG_UserData
         LG_GadgetKind
         LG_GadgetTags
         LG_GadgetTagList

         LG_OffsetX - global offset from left of window
         LG_OffsetY - global offset from top of window 
            These two set to topleft of the domain.
            Also these will be added to LG_UseScreenOffsets
            or LG_UseWindowOffsets if set.

         LG_LabelFlags - see LGLF_ 

         LG_ScaleX - Multiply gadget width and position by these.
                     (percent * 65536)
         LG_ScaleY - Multiply gadget height and position by these.
                     (percent * 65536)

         LG_Justification - Sets the "handle" of the gadget.

         LG_UseScreenOffsets - Sets global offsets based on Window border 
                           dimensions specified in the Screen structure
         LG_UseWindowOffsets - Sets global offsets based on Window border 
                           dimensions

         LG_EraseRemoved - If set gadgets erase themselves when they are 
                           removed using LG_RemoveGadgets

         LG_KeyClass  - Not used 
         LG_KeyString - A string of characters that "activate" that 
              gadget, if not specified, LG_CreateGadget() will scan 
              the gadget label for the appropriate string.  This 
              attribute is cleared after each LG_CreateGadget
               attribute
         LG_ErrorCode - Not used

         LG_Bounds - set offsets or domain area for gadgets
         LG_BoundsLeft   - Left of domain. (Alias for LG_OffsetX)
         LG_BoundsTop    - Top of domain.  (Alias for LG_OffsetY)
         LG_BoundsWidth  - Width of domain.
         LG_BoundsHeight - Height of domain.

         LG_RelHorizGap - Gap between certain relative operations
         LG_RelVertGap  - Gap between certain relative operations

         LG_HorizCells - Sets the number of columns in a table.
         LG_VertCells - Sets the number of rows in a table. 
           Sets the number of cells in a table.  The table's pixel size
           is the current LG_Bound size.  These attributes work in 
           conjunction with the LG_REL_CELL_ macros defined in 
           <extras/layoutgt.h>
           
         LG_SkipGadgets - Skip the next ti_Data LG_CreateGadgets and 
           all Tags in between.

@{b}   RESULT@{ub}
       returns NULL on failure, or a pointer the LG_Control structure 
       defined in <extras/layoutgt.h>

@{b}   EXAMPLE@{ub}
       See the supplied example, if there are any.

@{b}   NOTES@{ub}
       Gadgets created by LG_CreateGadgets() Must be freed using 
       LG_FreeGadgets OR Removed from it's Window using 
       LG_RemoveGadgets *BEFORE* the window is closed

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}
       LG_FreeGadgets, LG_RemoveGadgets, LG_AddGadgets, LG_RemoveGadgets,

@EndNode

@Node "OBSOLETE_LG_FreeGadgets()" "extras.lib/OBSOLETE_LG_FreeGadgets"

@{b}   OBSOLETE@{ub}
       Since OS3.5 uses Reaction/ClassAct - this code is obsolete

@{b}   NAME@{ub}
       LG_FreeGadgets - free gadgets allocated be LG_CreateGadgets.

@{b}   SYNOPSIS@{ub}
       LG_FeeeGadgets(Control)

       void LG_FreeGadgets(struct LG_Control);

@{b}   FUNCTION@{ub}
       deallocates gadgets ans support structures allocated by 
        LG_CreateGadget

@{b}   INPUTS@{ub}
       Con - pointer to structure returned by LG_CreateGadgets.

@{b}   RESULT@{ub}

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}
       Gadgets created by LG_CreateGadgets() Must be freed using 
       LG_FreeGadgets OR Removed from it's Window using 
       LG_RemoveGadgets *BEFORE* the window is closed

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "OBSOLETE_LG_GetGadget()" "extras.lib/OBSOLETE_LG_GetGadget"

@{b}   OBSOLETE@{ub}
       Since OS3.5 uses Reaction/ClassAct - this code is obsolete

@{b}   NAME@{ub}
       LG_GetGadget - get a gadget pointer using Gadget ID.

@{b}   SYNOPSIS@{ub}






@{b}   FUNCTION@{ub}


@{b}   INPUTS@{ub}

@{b}   RESULT@{ub}

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "OBSOLETE_LG_GetGadgetAttrs()" "extras.lib/OBSOLETE_LG_GetGadgetAttrs"

@{b}   OBSOLETE@{ub}
       Since OS3.5 uses Reaction/ClassAct - this code is obsolete

@{b}   NAME@{ub}
       LG_GetGadgetAttrs

@{b}   SYNOPSIS@{ub}






@{b}   FUNCTION@{ub}


@{b}   INPUTS@{ub}

@{b}   RESULT@{ub}

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "OBSOLETE_LG_RemoveGadgets()" "extras.lib/OBSOLETE_LG_RemoveGadgets"

@{b}   OBSOLETE@{ub}
       Since OS3.5 uses Reaction/ClassAct - this code is obsolete

@{b}   NAME@{ub}
       LG_RemoveGadgets - remove gadgets from a window.

@{b}   SYNOPSIS@{ub}






@{b}   FUNCTION@{ub}


@{b}   INPUTS@{ub}

@{b}   RESULT@{ub}

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "OBSOLETE_LG_SetGadgetAttrs()" "extras.lib/OBSOLETE_LG_SetGadgetAttrs"

@{b}   OBSOLETE@{ub}
       Since OS3.5 uses Reaction/ClassAct - this code is obsolete

@{b}   NAME@{ub}
       LG_SetGadgetAttrs - set gadget attrs.

@{b}   SYNOPSIS@{ub}






@{b}   FUNCTION@{ub}


@{b}   INPUTS@{ub}

@{b}   RESULT@{ub}

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "OBSOLETE_MakeGadgets()" "extras.lib/OBSOLETE_MakeGadgets"

@{b}   OBSOLETE@{ub}
       Since OS3.5 uses Reaction/ClassAct - this code is obsolete

@{b}   NAME@{ub}
       MakeGadgets -- Minimal layout Gadtools gadgets.

@{b}   SYNOPSIS@{ub}
       Gadget = MakeGedgets(Scr, VisualInfo, NumGadgets, NewGads, 
               NewGadTags, NewGadKinds, Gadgets, TextAttr, XScale,
               YScale)

       struct Gadget * MakeGadgets(struct Screen *,APTR ,ULONG,
               struct NewGadgets *, ULONG *, ULONG *,
               struct Gadget **, struct TextAttr *, float, float);

@{b}   FUNCTION@{ub}
       This function will create Gadgets from an array of
       Gadtools NewGadgets, scaling the gadgets to the size
       specified.

@{b}   INPUTS@{ub}
       Scr - This is the screen that the window containing these
                gadgets are destine for.  This is only used to get
                the WBorX values used to offset the gadgets from
                the window border.  *Set this to NULL if the gadgets
                are destine for a GimmeZeroZero window*.
       VisualInfo - VisualInfo pointer from gadtools/GetVisualInfo().
       NumGadgets - the number of gadgets to process.
       NewGads - array of struct NewGadget.
       NewGadTags - array of ULONGS to be processed as TagItems.
             All the gadget's tags are in this single array.
             (In the same fashion as GadToolsBox) 
             Individual tag arrays are NULL(TAG_DONE) terminated,
             And you may use TAG_MORE for additional Tags per gadget,
             but the array still must be NULL terminated.
       NewGadKinds - array of ULONGs, (BUTTON_KIND etc.)
       Gadgets - (struct Gadget **) Pointer to an array of
             Gadget pointers.  The Gadgets created by this
             function can be referenced by the ng_GadgetID of
             the source NewGadget.
       TextAttr - (struct TextAttr *) This TextAttr to used for
             gadgets whose ng_TextAttr is NULL.
       XScale - the x factor to scale the gadgets.
       YScale - the y factor to scale the gadgets.
             
@{b}   RESULT@{ub}
       returns a pointer to the context from @{"CreateContext()" Link "gadtools/CreateContext()"}
       or NULL on failure.

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}
       requires diskfont, gadtools & utility libraries to
       be open.

       This function has a special flag for NewGadget->ng_Flags,
       NG_FITLABEL.  This flag tells the function to adjust the
       ng_LeftEdge and/or Width if the PLACETEXT_LEFT or RIGHT
       flags are set, and the ng_TopEdge and/or Height if the
       PLACETEXT_ABOVE or BELOW flags are set, so that the 
       ng_GadgetText will fit inside the area specified for the
       gadget.  You must also specify one of the PLACETEXT_?
       values or this will not work.

       For GimmeZeroZero windows set Scr to NULL.
       
       This function will not modify any of the arrays 
       (ie. NewGads, NewGadTags), this way if you have
       an interface that opens & closes multiple times
       (like commodities) you will not have to reinitialize
       the arrays.

       Every ng_GadgetID should be unique and none may have a
       larger value than the number of elements in the array
       pointed to by Gadgets.

       GTLV_ShowSelected works differently with this function.
       specify -1l for the display only gadget, specify the 
       gadget _id_ of the string gadget for the editable gadget
       (the string gadget must be created before the listview).
       Gadtools wants a NULL or poiner to a gadget for this value
       but this is taken care by this function. 

       Gadgets created by this function can be freed with a 
       call to @{"FreeGadgets()" Link "gadtools/FreeGadgets()"}.

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}
       GetGUIScale()
@EndNode

@Node "OBSOLETEDrawBevelBoxes()" "extras.lib/OBSOLETEDrawBevelBoxes"

@{b}   NAME@{ub}
       DrawBevelBoxes -- draw a series of scaled bevel boxws.

@{b}   SYNOPSIS@{ub}
       DrawBevelBoxes(Window, VisualInfo, BBoxes, NumBoxes,
             XScale, YScale);  

       void DrawBevelBoxes(struct Window *, APTR, 
             struct BevelBox *, LONG, float, float);

@{b}   FUNCTION@{ub}
       Draws a series of scaled boxes.

@{b}   INPUTS@{ub}
       Win - the Window to draw the bevel boxes in.
       VI - VisualInfo previously obtained by 
            @{"gadtools.library/GetVisualInfoA()" Link "gadtools/GetVisualInfoA()"}
       BBoxes - pointer to an array of struct BevelBox.
       NumBoxes - the number of entries in the array.
       XScale - 
       YScale - 

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "PD_PackData()" "extras.lib/PD_PackData"

@{b}   NAME@{ub}
       PD_PackData -- Pack supplied data into a memory block.

@{b}   SYNOPSIS@{ub}
       packeddata = PD_PackData(Tags)

       struct PackedData *PD_PackData(Tag Tags, ... )

@{b}   FUNCTION@{ub}
       Packs supplied data into a memory block, suitable for writing
       to disk.

@{b}   INPUTS@{ub}
       Tags - a TagList.
           PD_Version - Adds a ULONG into the memory block.
                 Sets the version of the data.

           PD_BYTE - Adds a BYTE into the memory block.
           PD_UBYTE - Adds a UBYTE into the memory block.

           PD_WORD - Adds a WORD into the memory block. 
           PD_UWORD - Adds a UWORD into the memory block.

           PD_LONG - Adds a LONG into the memory block.
           PD_ULONG - Adds a ULONG into the memory block.

           PD_STRPTR - Adds a NULL terminated string into the memory block.
                 NULL pointers are supported

           PD_APTRSize - Adds the ULONG into the memory block,
                 Sets size for subsequent PD_APTRs.
           PD_APTR - Adds data into the memory block.  Size 
                 of data is set by previous PD_APTRSize.
                 if NULL, PD_APtrSize bytes are still written but are
                 unset.

           PD_BufferSize - Set the size of subsequent PD_Buffers
                 This tag does not add data to buffer.

           PD_Buffer     - Adds size of buffer, ULONG, followed by
                 data pointed to by ti_Data. 
                 See note for PD_UnpackData(()
           
           PD_MemoryFlags - Sets MemoryFlags for allocating 


@{b}   RESULT@{ub}

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}
@{b}     Except for BYTEs, data is UWORD aligned, pads are inserted as needed.@{ub}

@{b}     PackedData->pd_Data@{ub}
     {
       ULONG privatelength
       {private bytes}
       user data
     }     


@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "PD_UnpackData()" "extras.lib/PD_UnpackData"

@{b}   NAME@{ub}
       PD_UnpackData -- Unpack memory block.

@{b}   SYNOPSIS@{ub}
       success = PD_UnpackData(Tags)

       BOOL *PD_UnpackData(Tag Tags, ... )

@{b}   FUNCTION@{ub}
       Packs supplied data into a memory block, suitable for writing
       to disk.

@{b}   INPUTS@{ub}
       Tags - a TagList.
           For most tags, ti_Data is a storage pointer, if NULL the 
           data is parsed but not stored.

           PD_Version   - (ULONG *) Reads the version of the data.

           PD_IfVersion - (ULONG) Once PD_Version has been read, you can
               this tag to stop data processing if PD_Version is lower than
               the value of this tag. 

           PD_BYTE - (BYTE *) @{"Read" Link "dos/Read()"} a BYTE
           PD_UBYTE -(UBYTE *)

           PD_WORD - (WORD *) @{"Read" Link "dos/Read()"} a WORD
           PD_UWORD -(UWORD *)

           PD_LONG - (LONG *) @{"Read" Link "dos/Read()"} a LONG
           PD_ULONG -(LONG *)

           PD_STRPTR - (STRPTR *) AllocVec()s Memory for new STRPTR
               if PD_FreeSTRPTR is set, existing STRPTR is FreeVec()ed.

           PD_APTRSize - (ULONG *) Reads the amount of bytes that subsequent
               PD_APTRs read from the packed data.

           PD_APTR - Reads data from the memory block.  Size 
                 of data is set by previous PD_APTRSize.
                 if NULL, PD_APtrSize bytes are still written but are
                 unset.

           PD_BufferSize - (ULONG) Set data size for subsequent PD_Struct 
                 reads. This tag does not read any data, you must specify 
                 the size of your Buffer.

           PD_Buffer - (APTR) Data is copied to existing memory, the amount 
                 of data copied will be the lesser of PD_BufferSize or the
                 size stored in the packed data block.
           
           PD_MemoryFlags - Sets MemoryFlags for allocating 


@{b}   RESULT@{ub}

@{b}   EXAMPLE@{ub}
       PD_UnpackData(pd,
           PD_Version,     &dataversion, // store version number
           PD_BYTE,        &byte1,
           PD_BYTE,        0,            // byte not stored.
           PD_STRPTR,      &string,

           PD_IfVersion,   1, /* the following will only be read id PD_Versio
n >= 1 */
           PD_APTRSize,    10,
           PD_APTR,        &memchunk1,
           PD_APTR,        &memchunk2,
      
           PD_IfVersion,   2, /* the following will only be read id PD_Versio
n >= 2 */
           PD_STRUCT(mystruct),
      
           TAG_DONE,       0))

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "PhraseInStr()" "extras.lib/PhraseInStr"

@{b}   NAME@{ub}
       PhraseInStr -- Find a phrase or word in a string.

@{b}   SYNOPSIS@{ub}
       str = PhraseInStr(InStr, Phrase)

       STRPTR PhraseInStr(STRPTR , Phrase)

@{b}   FUNCTION@{ub}
       Locates a phrase or word in a string.

@{b}   INPUTS@{ub}
       InStr - String to search in.
       Phrase to search for.

@{b}   RESULT@{ub}
       returns pointer to phrase in InStr or NULL.

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}
       case insensitive.

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "ProcessTagList()" "extras.lib/ProcessTagList"

@{b}   NAME@{ub}
       ProcessTagList -- Macro to process a taglist

@{b}   SYNOPSIS@{ub}
       ProcessTagList(TagList, Tag, TState)

       TState=TagList; 
       while(Tag=NextTagItem(&TState))

@{b}   EXAMPLE@{ub}
       void SomeFunc(struct TagItem *TagList)
       {
         struct TagItem *tag, *tstate;

         ProcessTagList(TagList,tag,tstate)
         {
           seitch(tag->ti_Tag)
           {
             case GA_Left:
               ...
               break;
             etc...
           }
         }
       }

@EndNode

@Node "RenderText()" "extras.lib/RenderText"

@{b}   NAME@{ub}
       RenderTextA -- @{"Write" Link "dos/Write()"} text into a RastPort.
       RenderText -- varargs stub.

@{b}   SYNOPSIS@{ub}
       reserved = RenderTextA( RP, String, TagList)

       LONG RenderTextA( struct RastPort *, STRPTR, 
                         struct TagItem *);

       reserved = RenderText( RP, String, Tags, ... )

       LONG RenderText( struct RastPort *, STRPTR, 
                        Tag, ...);

@{b}   FUNCTION@{ub}
       Writes text into a Rastport, basically an interface
       to the @{"graphics.library/Text()" Link "graphics/Text()"} function.

@{b}   INPUTS@{ub}
       RP - rastport to write to.
       String - the string to write.
       TagList - an array of TagItems.
         RT_Baseline - baseline of the cursor. 
                       default RastPort->cp_y
         RT_XPos     - horizontal position of the cursor.
                       default RastPort->cp_x
         RT_MaxWidth - maximum pixel length of text, excess
                       characters will be clipped.
         RT_Justification - RTJ_???  (default _LEFT)
         RT_TextFont - struct TextFont * from @{"OpenFont()" Link "graphics/OpenFont()"}
         RT_Strlen   - number of characters in string.
         RT_TextLength - (ULONG *) Width in pixels of printed texted.


@{b}   RESULT@{ub}
       Number of characters drawn.

@{b}   BUGS@{ub}
       RenderText does not reset a RastPort's TextFont
       after using RT_TextFont. 

@{b}   SEE ALSO@{ub}
       mlr_rendertext.image image class.

@EndNode

@Node "str_Strip()" "extras.lib/str_Strip"

@{b}   NAME@{ub}
       str_Strip - @{"Remove" Link "exec/Remove()"} leading and trailing white spaces.

@{b}   SYNOPSIS@{ub}
       str_Strip(Str)       

       void Strip(STRPTR);

@{b}   FUNCTION@{ub}
       This function removes leading and trailing whites-paces
       from a string.  White-spaces are determined by the 
       @{"IsWhiteSpace()" Link "IsWhiteSpace()"} function.

@{b}   INPUTS@{ub}
       Str - a null terminated string pointer.

@{b}   RESULT@{ub}
       none.

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}
       Modifies existing string memory.

@{b}   BUGS@{ub}
       Will not work on NNStr used by other some functions in 
       the extras.lib.

@{b}   SEE ALSO@{ub}
       @{"IsWhiteSpace()" Link "IsWhiteSpace()"}.

@EndNode

@Node "StrIStr()" "extras.lib/StrIStr"

@{b}   NAME@{ub}
       StrIStr -- search for a string in another string, case 
                  insenseitive.

@{b}   SYNOPSIS@{ub}
       StrIStr(InStr,SearchStr)

       STRPTR StrIStr(STRPTR InStr,STRPTR SearchStr);

@{b}   FUNCTION@{ub}
       Seach for a string inside another, case insensitive.

@{b}   INPUTS@{ub}
       InStr - the string to search in.
       SearchStr - the string to search for.

@{b}   RESULT@{ub}
       returns a pointer in InStr that matches SearchStr, or NULL
       if no match was found.

@EndNode

@Node "tag_AddTag()" "extras.lib/tag_AddTag"

@{b}   NAME@{ub}
       tag_AddTag -- Add a tag toa taglist.

@{b}   SYNOPSIS@{ub}
       ok = tag_AddTag(TagList, Tag, Data)

       BOOL tag_AddTag(struct TagItem *, ULONG, ULONG);

@{b}   FUNCTION@{ub}
       Add a tag pair to a taglist created with @{"tag_AllocTags()" Link "tag_AllocTags()"}

@{b}   INPUTS@{ub}
       TagList - TagList created with @{"tag_AllocTags()" Link "tag_AllocTags()"}
       Tag - ti_Tag value
       Data - ti_Data value

@{b}   RESULT@{ub}
       non zero if the tag was added.
       failure can be due to under sized taglist.

@{b}   EXAMPLE@{ub}
       see @{"tag_AllocTags()" Link "tag_AllocTags()"}

@{b}   NOTES@{ub}
       Don't tag_AddTag TAG_IGNORE, TAG_DONE, TAG_MORE, TAG_SKIP.
       This function will only effect the specified TagList, and 
       not any other lists referenced by TAG_MORE.
       This function overwrites existing same tags.

@{b}   SEE ALSO@{ub}
       @{"tag_AllocTags()" Link "tag_AllocTags()"}

@EndNode

@Node "tag_AddTags()" "extras.lib/tag_AddTags"

@{b}   NAME@{ub}
       tag_AddTags -- Add a taglist to a taglist.

@{b}   SYNOPSIS@{ub}
       ok = tag_AddTags(TagList, Tag, Data)

       BOOL tag_AddTags(struct TagItem *, ULONG, ULONG);

@{b}   FUNCTION@{ub}
       Add a taglist to a taglist created with @{"tag_AllocTags()" Link "tag_AllocTags()"}

@{b}   INPUTS@{ub}
       TagList - TagList created with @{"tag_AllocTags()" Link "tag_AllocTags()"}
       NewTags - Tags to add to TagList

@{b}   RESULT@{ub}
       non zero if the tag was added.
       failure can be due to under sized taglist.

@{b}   EXAMPLE@{ub}
       see @{"tag_AllocTags()" Link "tag_AllocTags()"}

@{b}   NOTES@{ub}
       This function will only effect the specified TagList, and 
       not any other lists referenced by TAG_MORE.
       This function overwrites existing same tags.

@{b}   SEE ALSO@{ub}
       @{"tag_AllocTags()" Link "tag_AllocTags()"}

@EndNode

@Node "tag_AllocTags()" "extras.lib/tag_AllocTags"

@{b}   NAME@{ub}
       tag_AllocTags -- @{"Allocate" Link "exec/Allocate()"} blank Tag List

@{b}   SYNOPSIS@{ub}
       taglist = tag_AllocTags(TagCount)

       struct TagItem *tag_AllocTags(ULONG);

@{b}   FUNCTION@{ub}
       @{"Allocate" Link "exec/Allocate()"} tag space for use with other tag_? functions.

@{b}   INPUTS@{ub}
       TagCount - Number of blank tags to allocate.

@{b}   RESULT@{ub}
       An empty tag space ending with TAG_DONE, or NULL.

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "tag_ClearNumTags()" "extras.lib/tag_ClearNumTags"

@{b}   NAME@{ub}
       tag_ClearTags -- Clear a TagList

@{b}   SYNOPSIS@{ub}
       void tag_ClearTags(TagList, TagCount)

       tag_ClearTags(struct TagItem *, ULONG);

@{b}   FUNCTION@{ub}
       Clears the TagList of all data.

@{b}   INPUTS@{ub}
       TagList - Allocated with @{"tag_AllocTags()" Link "tag_AllocTags()"}
       TagCount - Number of blank tags to allocate.

@{b}   EXAMPLE@{ub}
       see @{"tag_AllocTags()" Link "tag_AllocTags()"}

@{b}   NOTES@{ub}
       This function is called by @{"tag_AllocTags()" Link "tag_AllocTags()"}, so
       the taglist is cleared when allocated.
       This function will only effect the specified TagList, and 
       not any other lists referenced by TAG_MORE.

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}
       see @{"tag_AllocTags()" Link "tag_AllocTags()"}

@EndNode

@Node "tag_ClearTags()" "extras.lib/tag_ClearTags"

@{b}   NAME@{ub}
       tag_ClearTags -- Clear a TagList

@{b}   SYNOPSIS@{ub}
       void tag_ClearTags(TagList)

       tag_ClearTags(struct TagItem *);

@{b}   FUNCTION@{ub}
       Clears the TagList of all data.

@{b}   INPUTS@{ub}
       TagList - Allocated with @{"tag_AllocTags()" Link "tag_AllocTags()"}

@{b}   EXAMPLE@{ub}
       see @{"tag_AllocTags()" Link "tag_AllocTags()"}

@{b}   NOTES@{ub}
       This function will only effect the specified TagList, and 
       not any other lists referenced by TAG_MORE.

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}
       see @{"tag_AllocTags()" Link "tag_AllocTags()"}

@EndNode

@Node "tag_CountUserTags()" "extras.lib/tag_CountUserTags"

@{b}   NAME@{ub}
       tag_CountUserTags -- number of user tags

@{b}   SYNOPSIS@{ub}
       ULONG tag_CountUserTags(TagList)

       tag_CountUserTags(struct TagItem *);

@{b}   FUNCTION@{ub}
       Count the number of user tags.

@{b}   INPUTS@{ub}
       TagList - Allocated with @{"tag_AllocTags()" Link "tag_AllocTags()"}.

@EndNode

@Node "tag_FreeTags()" "extras.lib/tag_FreeTags"

@{b}   NAME@{ub}
       tag_FreeTags -- Clear a TagList

@{b}   SYNOPSIS@{ub}
       void tag_FreeTags(TagList)

       tag_FreeTags(struct TagItem *);

@{b}   FUNCTION@{ub}
       Frees the TagList.

@{b}   INPUTS@{ub}
       TagList - Allocated with @{"tag_AllocTags()" Link "tag_AllocTags()"}.

@{b}   EXAMPLE@{ub}
       see @{"tag_AllocTags()" Link "tag_AllocTags()"}

@{b}   SEE ALSO@{ub}
       see @{"tag_AllocTags()" Link "tag_AllocTags()"}

@EndNode

@Node "tag_RemTag()" "extras.lib/tag_RemTag"

@{b}   NAME@{ub}
       tag_RemTag -- Removea a tag to a taglist.

@{b}   SYNOPSIS@{ub}
       ok = tag_RemTag(TagList, Tag)

       BOOL tag_RemTag(struct TagItem *, ULONG);

@{b}   FUNCTION@{ub}
       Find and remove a tag from a taglist.

@{b}   INPUTS@{ub}
       TagList - TagList created with @{"tag_AllocTags()" Link "tag_AllocTags()"}
       Tag - ti_Tag value

@{b}   RESULT@{ub}
       non zero if the tag was found and removed.

@{b}   EXAMPLE@{ub}
       see @{"tag_AllocTags()" Link "tag_AllocTags()"}

@{b}   NOTES@{ub}
       Don't tag_AddTag TAG_IGNORE, TAG_DONE, TAG_MORE, TAG_SKIP.
       This function will only effect the specified TagList, and 
       not any other lists referenced by TAG_MORE.

@{b}   SEE ALSO@{ub}
       @{"tag_AllocTags()" Link "tag_AllocTags()"}

@EndNode

@Node "tag_TagDone()" "extras.lib/tag_TagDone"

@{b}   NAME@{ub}
       tag_TagDone -- End the TagList with TagDone

@{b}   SYNOPSIS@{ub}
       void tag_FreeTags(TagList)

       tag_FreeTags(struct TagItem *);

@{b}   FUNCTION@{ub}
       Ends the taglist with TAG_MORE and link the list to MoreTags

@{b}   INPUTS@{ub}
       TagList - Allocated with @{"tag_AllocTags()" Link "tag_AllocTags()"}.

@{b}   EXAMPLE@{ub}
       see @{"tag_AllocTags()" Link "tag_AllocTags()"}

@{b}   SEE ALSO@{ub}
       see @{"tag_AllocTags()" Link "tag_AllocTags()"}

@EndNode

@Node "tag_TagMore()" "extras.lib/tag_TagMore"

@{b}   NAME@{ub}
       tag_TagMore -- End the TagList with TagMore

@{b}   SYNOPSIS@{ub}
       void tag_FreeTags(TagList, MoreTags)

       tag_FreeTags(struct TagItem *, struct TagItem *);

@{b}   FUNCTION@{ub}
       Ends the taglist with TAG_MORE and link the list to MoreTags

@{b}   INPUTS@{ub}
       TagList - Allocated with @{"tag_AllocTags()" Link "tag_AllocTags()"}.
       MoreTags - Tags to link

@{b}   EXAMPLE@{ub}
       see @{"tag_AllocTags()" Link "tag_AllocTags()"}

@{b}   SEE ALSO@{ub}
       see @{"tag_AllocTags()" Link "tag_AllocTags()"}

@EndNode

@Node "thread_EndThread()" "extras.lib/thread_EndThread"

@{b}   NAME@{ub}
       thread_EndThread -- end a thread.

@{b}   SYNOPSIS@{ub}






@{b}   FUNCTION@{ub}


@{b}   INPUTS@{ub}

@{b}   RESULT@{ub}

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}
       Note, this function waits for a reply.

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "thread_PutTMsg()" "extras.lib/thread_PutTMsg"

@{b}   NAME@{ub}
       thread_PutTMsg --

@{b}   SYNOPSIS@{ub}
       success=thread_PutTMsg(Thread, Msg)

       BOOL thread_PutTMsg(struct Thread *, struct ThreadMessage *)

@{b}   FUNCTION@{ub}
       Send a message to the thread, this function does not
       wait for a reply.  You must supply a reply port for
       your message.

@{b}   INPUTS@{ub}
       Thread - to send message to
       Msg - Message to send.

@{b}   RESULT@{ub}
       Non-zero if message successfully sent.     

@{b}   NOTES@{ub}
       Note, this function does not wait for a reply.

@EndNode

@Node "thread_PutTMsg_Sync()" "extras.lib/thread_PutTMsg_Sync"

@{b}   NAME@{ub}
       thread_PutTMsg_Sync -- Send a ThreadMessage to a thread.

@{b}   SYNOPSIS@{ub}
       success=thread_PutTMsg_Sync(Thread, Msg)

       BOOL thread_PutTMsg_Sync(Thread, struct ThreadMessage);

@{b}   FUNCTION@{ub}
       Send a message to the thread, this function will
       wait for a reply.  The messages reply port will be changed.

@{b}   INPUTS@{ub}
       Thread - to send message to
       Msg - Message to send.

@{b}   RESULT@{ub}
       Non-zero if message successfully sent.

@{b}   NOTES@{ub}
       Note, this function waits for a reply.
       replyport is changed

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "thread_PutTMsg_TagList()" "extras.lib/thread_PutTMsg_TagList"

@{b}   NAME@{ub}
       thread_PutTMsg_TagList -- Send a TagListTMsg to a thread (varargs)

@{b}   SYNOPSIS@{ub}
       RetVal = thread_PutTMsg_TagList(Thread, Command, Tags ... )

       ULONG thread_PutTMsg_TagList(struct Thread, ULONG, Tag, ...);

@{b}   FUNCTION@{ub}
       Sends a message to the task, using the TMsg_TagList structure.
       Waits for a reply, then returns tm_RetVal.

@{b}   INPUTS@{ub}
       Thread - (struct Thread *)
       Command - Command ID.
       Tag - 

@{b}   RESULT@{ub}
       returns zero on failure, otherwise returns value of TMsg_TagList.tm_Re
tVal.

@{b}   NOTES@{ub}
       Note, this function waits for a reply.

@EndNode

@Node "thread_StartThread()" "extras.lib/thread_StartThread"

@{b}   NAME@{ub}
       thread_StartThread -- Create a thread.

@{b}   SYNOPSIS@{ub}
       Thread thread_StartThread(Tags)

       struct Thread *thread_StartThread(Tag, ... );

@{b}   FUNCTION@{ub}
       Creates and starts a new thread (Process).

@{b}   INPUTS@{ub}
       Tags - TagList (on stack)
         TA_Name - Name of thread, defaults to "Thread".
         TA_Stack - Stacksize, default 8192.
         TA_Priority - default -1
         TA_MsgHandler - Function to handle thread messages.
         TA_UserData - (APTR)
         TA_A6 - (struct Library *) 

@{b}   RESULT@{ub}
       Pointer to the newly created Thread, or NULL on failure.
       The Thread stucture is ReadOnly, except for
         t_Node, UserData and ThreadData

@{b}   NOTES@{ub}
       It's suggested that ThreadData be used store local data
       for the Thread.

@{b}   BUGS@{ub}
       1.3 - Made functional, some timing issues caused crashes.

@{b}   SEE ALSO@{ub}

@EndNode

@Node "UpdateProgressMeterA()" "extras.lib/UpdateProgressMeterA"

@{b}   NAME@{ub}
       UpdateProgressMeterA -- Change ProgressMeter attributes.
       UpdateProgressMeter -- varargs stub.

@{b}   SYNOPSIS@{ub}
       numProcessed UpdateProgressMeterA(PM,TagList)

       LONG UpdateProgressMeterA(ProgressMeter ,struct TagItem *);

       numProcessed UpdateProgressMeter(PM,FirstTag)

       LONG UpdateProgressMeter(ProgressMeter , Tag, ...);

@{b}   FUNCTION@{ub}
       Updates a ProgressMeter's attributes  and refreshes
       it as neccessary.

@{b}   INPUTS@{ub}
       PM - Pointer to an existing ProgressMeter or NULL.
       TagList - TagList of attributes to change or NULL.
           Only these four tags are processed.
             PM_QueryCancel
             PM_MeterValue
             PM_LowValue
             PM_HighValue

@{b}   RESULT@{ub}
       returns the number of tags processed.

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}
@{b}     requires diskfont, exec, gadtools, graphics, intuition & utility@{ub}
@{b}     libraries to be open.@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}
@{b}     @{"AllocProgressMeterA()" Link "AllocProgressMeterA()"}, @{"FreeProgressMeter()" Link "FreeProgressMeter()"} @{ub}

@EndNode

@Node "nns_ProcessNNStr()" "Macro/nns_ProcessNNStr"

@{b}   NAME@{ub}
       nns_ProcessNNStr(NNStr, Str)

@{b}   SYNOPSIS@{ub}
       nns_ProcessNNStr(NNStr, Str)

@{b}   FUNCTION@{ub}

@{b}   INPUTS@{ub}

@{b}   RESULT@{ub}

@{b}   EXAMPLE@{ub}
       STRPTR NNStr, str;
       
       ProcessNNStr(NNStr,str)
       {
         printf("%s\n",str);
       }

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

