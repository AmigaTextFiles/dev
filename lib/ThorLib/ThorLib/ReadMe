ThorLib:	A collection of junk^H^H^H^H useful library functions for the SAS/C
		and other Amiga compilers.

This link library contains multiple support functions I wrote over the years
which I found useful in multiple projects. 

The link library is designed mostly for the SAS/C and its calling conventions,
though other compilers or even assemblers may use the function provided they
follow the same convention. In particular, SAS/C expects a name-mangling
convention of function names as follows:

Names starting with underscores use standard calling conventions with
parameters on the stack. The function name visible in C is the same name with
the initial underscore removed.

Names starting with the "at" @ sign use registerized paameter calling
conventions where the first two integer arguments are placed in registers d0
and d1, and the first two pointer arguments are placed in registers a0 and a1.
All remaining parameters are placed on the stack.

The result code is expected in d0 in all cases.

Similar support functions can be found in the amiga.lib, though sometimes with
less suitable calling conventions or less error checking. The functions here
have been proven useful over the years in multiple projects and are made
available to all Amiga programmers in the hope of being useful.

-------------------------------------------------------------------------------

REXX support functions:

thor/rexxsuport.h:	multiple functions to ease interfacing with ARexx

	extern char *PortName;
	Set this to the name of your rexx interface port. It is automatically
	extended by a period and a number to make it unique.

	extern char *RXExtension;
	the file name extension for rexx scripts that are to be launched
	from this program.

	extern struct MsgPort *RexxPort;
	the rexx startup code will fill this variable with the pointer to
	the message port to be used for communication with your program.

	extern UWORD RexxCount;
	counts the number of pending rexx requests. Your program must NOT
	quit until this count reaches zero.

	struct MsgPort *OpenRexx(void);
	starts Rexx interfacing, and creates a MsgPort for ARexx communication.

	void CloseRexx(void);
	closes the Rexx interface.

	RexxArg *AllocRexxArg(char *);
	create a Rexx argument from a string.

	void FreeRexxArg(RexxArg *);
	releases a Rexx argument

	FailCode SetRexxResult(char *result,struct Message *rexxmsg);
	set the result code of an incomming Rexx request. The
	return code is ignored if the initiator of the Rexx message
	identified that the return code is not needed/expected.

	BOOL CheckMessage(struct Message *msg);
	Checks whether the message comes from Rexx, returns TRUE
	if so.

	FailCode EvaluateRexxVar(char *var,char *result,struct Message *msg);
	Evaluates the contents of a Rexx variable, places the result in the
	buffer pointed to by "result". Requires the rexx message that 
	initiated the request.

	FailCode SetRexxVar(char *var,struct Message *msg,char *contents);
	sets the contents of the variable or stem variable "var" to 
	contents, requires also the rexx message that started the request.

	struct Message *RunRexx(char *script);
	start a rexx script in background. Due to a limitation of the rexx
	interpreter, the script name must not contain spaces.

	FailCode ParseRexxMsg(RexxParser parser,struct Message *rexx);
	Parse an incoming request through a parser. Returns an error
	code or RXF_REXXRETURN if the message is a returing query of
	the progrma itself. If so, call EndRexx() to free the IOhandles
	and retrieve the return code.
	Otherwise, the parser will be called. Once it returns, the
	message is still valid and must be replied with ReplyRexx, except
	   i)   the returncode is RXF_REXXRETURN, in which case you should call 
		EndRexx to free the message and the IO-channels
	   ii)  the returncode is RXF_PUSHEDBACK, to reply it later on.
		It is up to you when to do this

	void SetReturnCode(LONG ret,struct Message *rexxmsg);
	Set the return code of a message, overridden by ReplyRexx.
	Use this if you MUST use ReplyMsg instead of ReplyRexxMsg().

	void SetReturn2Code(LONG ret,struct Message *rexxmsg);
	As the above, sets the secondary return code.

	ReplyRexxMsg(struct Message *rexxmsg,FailCode retval);
	Reply a rexx message, set its return code. Call this when a
	rexx query has been handled.

	FailCode EndRexx(struct Message *rexxmsg);
	if a request to the rexx interpreter returns, call this once
	the outgoing rexx query returns to release the resources associated
	with the query.

	void SetValueStemI(char *stem,char *ext,struct Message *rexxmsg,int value);
	Sets the stem variable "stem.ext" from the rexx message to an integer
	value.

	void SetValueStemD(char *stem,char *ext,struct Message *rexxmsg,double value);
	Sets the stem variable "stem.ext" from the rexx message to a double value.

	void SetValueStemL(char *stem,char *ext,struct Message *rexxmsg,Lixed value);
	Sets the stem variable "stem.ext" from the rexx message to a long fixed-point
	number.

	void SetValueStemS(char *stem,char *ext,struct Message *rexxmsg,char *value);
	Sets the stem variable "stem.ext" from the rexx message to a given string.

	FailCode GetValueStemI(char *stem,char *ext,struct Message *msg,int *to);
	Interprets the contents of the stem variable "stem.ext" as an integer and
	returns it in "to". 

	FailCode GetValueStemD(char *stem,char *ext,struct Message *msg,double *to);
	Interprets the contents of the stem variable "stem.ext" as double precision
	number and returns it in "to".

	FailCode GetValueStemL(char *stem,char *ext,struct Message *msg,Lixed *to);
	Interprets the contents of the stem variable "stem.ext" as long fixed point
	number and returns it in "to".

	FailCode GetValueStemS(char *stem,char *ext,struct Message *msg,char *to);
	Extracts the contents of the stem variable "stem.ext" and returns it in
	a character array.

	FailCode GetValueStemB(char *stem,char *ext,struct Message *msg,BOOL *to);
	Interprets the contents of the stem variable "stem.ext" as a boolean and
	returns it in "to".

	char *FailText(FailCode fail);
	returns a standard error message from a rexx error code.


thor/bool.h:	conversions from BOOL to string and vice versa,
		most suitable for REXX

	char *GetBOOLString(BOOL yesno):
	converts a bool to a string.

	FailCode CheckBOOL(char *bl)
	converts a string to a bool. Understands most basic
	conventions, "ON"/"OFF","YES"/"NO","1","0","J"/"N",
	"Y"/"N"

thor/animtools.h	helper functions to setup and run the GELs system
			of the graphics library.

	struct newOb;
	a helper structure used to create either a Bob or a VSprite,
	contains the dimensions, position, plane mask, hit-mask and
	me-mask, as well as the image data and the colors of the object.

	struct newAnimComp;
	a helper structure to create a new animation component, including
	a callback used when the animcomp is displayed, the initial
	velocity and timer, and flags.

	struct newAnimSeq;
	a data structure that holds information for a complete animation
	sequence.

	struct AllGels;
	a helper structure that includes all the initial objects the GELs
	system requires for initiating an animation.

	struct GelsInfo *setupGelSys(struct RastPort *rPort, BYTE reserved);
	setup the GELs system for a given RastPort.

	void cleanupGelSys(struct GelsInfo *gInfo, struct RastPort *rPort);
	shut down the GELs system.

	struct VSprite *makeVSprite(struct newOb);
	create a VSprite from a newOb helper.

	struct Bob *makeBob(NEWOB *nob);
	create a Bob from a newOb helper.

	struct AnimComp *makeComp(struct newOb *nob, struct newAnimComp *nAnimComp);
	create an animation component from a new object helper and
	and animation helper.

	struct AnimComp *makeSeq(struct newOb *nob, struct newAnimSeq *nAnimSeq);
	creates an animation sequence from a new object helper and a new
	animation sequence helper.

	void freeVSprite(struct VSprite *vsprite);
	free all resources of a VSprite created by makeVSprite().

	void freeBob(struct Bob *bob,LONG rasdepth);
	free all resources of a Bob created by makeBob().

	void freeComp(struct AnimComp *myComp,LONG rasdepth);
	free all resources of an animation component created by 
	makeComp().

	void freeOb(struct AnimOb *headOb, LONG rasdepth);
	free all resources of an animation object.

thor/arpaslrequest.h	generic helper functions for creating requesters either
			by ASL (for Os 2 and beyond) or arp (for Os 1.3)

	struct ARPASLFileRequester;
	a structure to be used to show a file requester through either ASL
	or arp.

	ULONG ArpRequest(struct ARPASLFileRequester *);
	show a file requester through either ASL or arp. Returns non-null
	on succes, or 0 on failure. The selected file is then in fr_File/
	fr_Dir of the above structure.


thor/buildmenu.h	a simplified menu builder for intuition menus
 
	struct MenuCommand;
	a helper structure defining an entry in a menu: Either
	a menu, a menu item or a subitem.

	typedef CmdFetcher;
	a callback function that fills and returns one MenuCommand 
	structure after another to create a menu. This callback
	is called iteratively by the menu builder.

	typedef TextFetcher;
	a callback function that returns the menu texts one after
	another.

	struct MenuBuilder;
	the setup function to control the menu builder. This includes
	the callbacks, the screen where to place the menu on (for the
	font) and the pens.

	struct Menu *BuildMenuStructs(struct MenuBuilder *mb);
	construct an intuition menu from the menu builder and the call-
	in functions within.

	void FreeMenuStructs(struct MenuBuilder *mb);
	release a menu constructed through the menu builder.

thor/conversions.h	high-precision conversions between various 
			number formats. The conversions in this
			block are capable of converting NANs and INFs,
			as well as denormalized numbers correctly.

	typedef shortfloat;
	IEEE single precision number

	typedef doublefloat;
	IEEE double precision number

	typedef extendedfloat;
	IEEE extended precision floating point number

	typedef packedfloat;
	IEEE packed decimal floating point number

	typedef fastfloat;
	mathFFP fast floating point number

	void DToX(doublefloat *in,extendedfloat out);
	convert double precision to extended precision

	void XToD(extendedfloat in,doublefloat *out);
	convert extended precision to double precision

	void SToX(shortfloat *in,extendedfloat out);
	convert single precision to extended precision

	void XToS(extendedfloat in,shortfloat *out);
	convert extended precision to single precision

	void PToX(packedfloat in,extendedfloat out);
	convert packed decimal to extended precision

	void XToP(extendedfloat in,packedfloat out);
	convert extended precision to packed decimal

	short XToFFP(extendedfloat in,fastfloat *out);
	convert extended precision to fast floating point

	BOOL AToInt(char *s,long *final);
	convert ASCII string to integer, return FALSE
	on failure.

	void IntToA(char *buffer,long number);
	convert an integer to an ASCII string

	BOOL AToI(char *s,long *final);
	identical to AToInt.

	void IToA(char *buffer,long number);
	identical to IntToA

	BOOL StrToL(char *in,char **np,int *result, int base);
	convert ASCII all bases (decimal,binary,octal,hex) to
	binary. If the base is given, use this basis, if zero,
	guess from the format. Binary is indicated by a leading "%",
	octal by a leading § or 0, hex with leading 0x or $.

	BOOL AToLixed(char *s,Lixed *final);
	convert an ASCII string to a long fixed point number,
	return FALSE on error.

	void LixedToA(char *buffer,Lixed number);
	convert a fixed point number to an ASCII string.

	BOOL AToX(char **s,extendedfloat final);
	high-precision conversion from an ASCII string
	to an extended precision number, advance the pointer
	to the number to the first non-parseable digit.

	void XToA(extendedfloat in,char *s);
	high-precision conversion from extended precision
	floating point to ASCII.

	LONG AToXMain(UBYTE **src,extendedfloat dest);
	parse the mantissa without a sign and without
	exponent of an ASCII representation of a floating
	point number to an extended precision IEEE number.

	BOOL XPowTen(extendedfloat number,LONG pow);
	compute number*10^pow in extended precision, does
	not require an FPU.
	
	LONG XToAMain(extendedfloat number,UBYTE *dst,UWORD digits);
	convert the mantissa of an an extended precision 
	number to ASCII with "digits" significant digits, returns
	the exponent to the base of ten.

	BOOL AToDouble(char *s,double *final);
	convert ASCII to IEEE double precision.

	void DoubleToA(char *buffer,double number);
	convert IEEE double precision to ASCII.

	double atof(char *num);
	convert ASCII to double. 
	Only available if _OVERLOAD_STDLIB_ is defined.

	char *ecvtr(int *index,int *sign,char *output,double *in,int digits);
	convert an IEEE double precision number to ASCII, returning
	the sign in *sign and the position of the decimal dot in "index",
	with the given number of digits. Uses XToAMain, is aware of INFs
	and NANs. Only available if _OVERLOAD_STDLIB_ is defined.

thor/ecvt.h		non-reentrant version of ecvtr.

	char *ecvt(double value,int digits,int *index,int *sign)
	calls ecvtr() from above on a static buffer.

thor/fixed.h		fixed-point number support

	Fixed
	a unsigned fixed point type of 16 bit length representing
	numbers between 0 and 0.9999 linearly scaled.


	Lixed
	a signed 32-bit fixed point type able to represent numbers
	between -32768 and 32767.9999

	LCIR
	a macro to convert double precision to Lixed

thor/iffservice.h	various IFF reader functions to interpret
			ILBM images with the iffparse.library.

	void GetIFFError(LONG error,char *out);
	return a human-readable error description form an
	IFF error code.


	struct IFFHandle *SetupIFFAs(char *filename,BOOL write,LONG *error);
	setup an IFF parser using the ThorIO I/O library.

	void CleanupIFF(struct IFFHandle *iff);
	close an IFF handle opened for reading through ThorIO.

	void Correct_CAMG(ULONG *modeid,width,height,depth);
	best-guess CAMG cleanup for obsolete DPaint CAMG chunk variations

	FULLC(a)
	a macro to get an 16 fixed point color from 8 bit input

	FULLF(a)
	a macro to get a 16 bit fixed point color from 4 bit input

	FORM_ID,ILBM_ID,BMHD_ID,CAMG_ID,CMAP_ID_BODY_ID,CRNG_ID_DRNG_ID
	defines of standard ILMB chunks

	PrepBuf()
	setup second level cache management setup around the IFF reader

	LONG ReadBuf(struct IFFHandle *iff,register char *dest,register ULONG len);
	read buffered through the IFF handle into a buffer.

	LONG WriteBuf(struct IFFHandle *iff,register char *source,register ULONG len);
	write buffered through the IFF handle to a buffer.

	LONG FlushBuf(struct IFFHandle *iff);
	flush the 2nd level buffer around an IFF buffer.

	struct BodyBM;
	structure describing the layout of the screen for the IFF
	reader and writer. Includes the height of the screen, the image,
	width and bytes per row, depth of screen and file, a mask which
	planes to fill and the plane pointers.

	LONG WriteBodyCompressed(struct IFFHandle *iff,struct BodyBM *bb);
	write a screen as BODY chunk compressed through an IFF handle.

	LONG WriteBodyUnCompressed(struct IFFHandle *iff,struct BodyBM *bb);
	write a screen as BODY chunk uncompressed through an IFF handle.

	LONG ReadBodyCompressed(struct IFFHandle *iff,struct BodyBM *bb);
	read a screen from a compressed IFF BODY chunk.

	LONG ReadBodyUnCompressed(struct IFFHandle *iff,struct BodyBM *bb);
	read a screen from an uncompressed IFF BODY chunk.

	LONG SaveCMAP(struct IFFHandle *iff,struct Screen *scr);
	save the color map of the screen in an CMAP chunk.

	LONG SaveScreenCAMG(struct IFFHandle *iff,struct Screen *scr);
	save the screen ID as CAMG chunk.

	WriteBlock(source,length)
	a macro for writing a block of bytes through "iff".

	Push(type,size)
	push the begining of a block through "iff"

	ReadBlock(dest,length)
	a macro to read a block to dest memory from "iff"

	typedef Masking;
	a type to identify the masking in the file (if any), can be:
	mskNone: 		no masking
	mskHasMask:     	a bitplane mask is present
	mskHasTransparentColor:	a transparent color is present
	mskLasso:		a boundary is present
	
	typedef Compression;
	a type indicating the compression type, can be:
	cmpNone:	no compression
	cmpByteRun1:	run-length compression

	typedef BitMapHeader;
	the type of the IFF BMHD chunk contents

	typdef ColorRegister;
	8-bit RGB color triples.

	typedef CRange;
	type identifying the color cycling range
	of DPaint I to DPaint III

	typdef DRange;
	more flexible color cycling range introduced
	by DPaint IV

thor/IntSupport.h		various support functions for integer
				numbers


	UWORD lbint(register ULONG x);
	returns ceil(log_2(x)), i.e. an upper
	approximation of the logarithm to the base
	of two of the number.

	ULONG sqrtlower(LONG x);
	returns floor(sqrt(x)), i.e. a lower
	approximation of the square root of x.

	ULONG sqrtint(LONG x);
	returns ceil(sqrt(x)), i.e. an upper
	approximation of the square root of x.

	void MakeRational(int *p,int *q);
	find a rational approximation of *p/*q with
	small nomiators and denominators. This is useful
	to compute the factors of a "scaler" that are
	not "too wierd" to avoid staircasing in the
	scaled graphics.

	int GCD(int a,int b);
	compute the greatest common divisor of two integers

	The following are random generators. They are fast, but
	do not necessarily provide "good quality" of randomness.

	ULONG FastRand(void);
	fast random generator with autoseed based on a timer.

	UWORD RangeRand(UWORD limit);
	random generator for numbers between 0 and limit-1.
	NOTE: this is a simple scaled version of FastRand().
	Due to scaling, not all numbers have exactly equal
	probability.
	AVOID if this is a problem.

	extern int seed;
	seed for the random generator, to be defined somewhere
	in your code. Does not need to be set.

thor/lixedsupport.h		Support functions for long fixed
				point numbers

	Lixed lxmul(Lixed a,Lixed b);
	multiply two long fixed-point numbers.
	
	Lixed lxdiv(Lixed a,Lixed b);
	divide a by b in fixed-point.

	int lxint(Lixed n);
	compute round(n), i.e. round to the nearest
	integer.

thor/longlong.h			64-bit math support for SAS/C

	typdef longlong;
	a signed 64-bit integer type.

	longlong addll(longlong a,longlong b);
	returns a+b

	longlong subll(longlong a,longlong b);
	returns a-b

	longlong mulll(longlong a,longlong b);
	returns a*b

	longlong divll(longlong a,longlong b);
	returns a/b

	longlong remll(longlong a,longlong b);
	returns a%b

	longlong negll(longlong a);
	returns -a

	longlong l2ll(long a);
	converts a signed 32-bit integer to a 64 bit integer.

	longlong ul2ll(unsigned long a);
	converts an unsigned 32-bit integer to a 64-bit
	integer

	longlong maxll(longlong a,longlong b);
	computes max(a,b)

	longlong minll(longlong a,longlong b);
	computes min(a,b)

	longlong absll(longlong a);
	computes the absolute value of a

	longlong cmpll(longlong a,longlong b);
	returns +1 if a>b, -1 if a<b, 0 if a=b


	longlong shlll(longlong a,unsigned short bits);
	returns a << b

	longlong shrll(longlong a,unsigned short bits);
	returns a >> b

	long ll2l(longlong a);
	converts a to a 32-bit signed integer.

thor/newlist.h			Initialize an Exec list

	void NewList(struct List *);
	identical to amiga.lib NewList(), except
	that it uses registerized parameters.

thor/privatevecs.h		AllocVec/FreeVec for V33

	This module contains AllocVec() and FreeVec()
	replacement functions for the obsolete V33 and V34
	exec.library.

	void *PrivateAllocVec(ULONG size,ULONG reqments);
	AllocVec() look-alike for V33

	void PrivateFreeVec(void *mem);
	FreeVec() look-alike for V33

thor/stringsupport.h		string support functions

	#define UStrCmp(a,b)
	case-insensitive string comparision, identical
	to the utility-library Stricmp()


thor/ThorIO.h			high-performance buffered I/O
				replacing the dos.library
				buffered I/O.

	This module includes buffered I/O functions that
	look similar to the dos.library "raw" functions Read()
	and Write(). Unlike the buffered I/O counterparts of
	the dos.library, no "Flush" is needed between seeking,
	reading and writing, the library handles this itself.
	Performance is in general better than that of the 
	dos.library due to a smaller overhead.

	typedef FileHandle;
	abstract file as handled by this library.

	Modes for opening the files (Atari users: These
	are identical to the CIO flags of the Atari Os).
	Multiple modes can be or'd together.
	Record-oriented I/O reads or writes data up to an
	"end of block" marker (or two of them) that are
	defined in the file handle. This is typically a LF
	or CR character for line-based I/O

	FHMOD_APPEND		append to the end of the file
	FHMOD_READ		read from the file
	FHMOD_WRITE		write to the file
	FHMOD_RECORD		record-oriented I/O
	FHMOD_NONUL		do not write ASCII 0 

	FileHandle *FOpen(char *name,UBYTE mode,UWORD buffersize);
	open a file in one of the above modes using a given
	buffer size.

	BOOL FClose(FileHandle *fh);
	flush buffers, close a file.

	LONG FFlush(FileHandle *fh);
	flushes the internal buffer

	LONG FRead(FileHandle *fh,void *buffer,ULONG len);
	read a block or a record from a file to a buffer,
	return the number of bytes read.

	LONG FWrite(FileHandle *fh,void *buffer,ULONG len);
	write a block or a record from a buffer to a file,
	return the number of bytes written.

	LONG FSeek(FileHandle *fh,LONG offset,LONG mode);
	seek in a file forwards or backwards, where mode
	is negative for backwards seeking, positive for
	forwards seeking or zero to set the absolute position.
	(NON-ANSI convention!)

	#define FTell(file)
	return the file position as 32-bit integer.

thor/tinyio.h		various minimalistic I/O
			helper functions


	void tinyprintf(char *,...);
	print formatted to stdout, using
	the syntax of RawDoFmt()

	void tinyvprintf(char *,void *); 
	print formatted to stdout using the
	arguments pointed to by the second
	pointer.

	void tinysprintf(char *,char *,...);
	print formatted to a string using the
	syntax of RawDoFmt().

	void tinyvsprintf(char *,char *,void *);
	print formatted into a string using
	the arguments pointed to by the second
	pointer.

	#ifdef USE_TINYIO

	if this define is set, then the C-functions
	printf,vprintf,sprintf and vsprintf are
	replaced by the above functions.



