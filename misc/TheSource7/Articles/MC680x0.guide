@database MC680x0.guide
@node Main "MC680x0 Reference"

Instrction types:
	@{ "Move Instructions            " link MovesInst }
	@{ "Mathematical Instructions    " link Math  }
	@{ "Logic Instructions           " link Logic }
	@{ "Flow Control Instructions    " link Flow  }
	@{ "Shift and Rotate Instructions" link Shift }
	@{ "Bit Manipulation Instructions" link Bit   }
	@{ "Miscellaneous Instructions   " link Misc  }
@endnode

***********************************************************

@node MoveIns
Normal:
	@{ "MOVE " link Move  } @{ "MOVEA" link Movea } @{ "MOVEC" link Movec } @{ "MOVEM" link Movem } @{ "MOVEP" link Movep } @{ "MOVEQ" link Moveq } @{ "MOVES" link Moves }

	@{ "MOVE to CCR  " link MoveToCCR    } @{ "MOVE from CCR" link MoveFromCCR  }
	@{ "MOVE to SR   " link MoveToSR     } @{ "MOVE from SR " link MoveFromSR   }
	@{ "MOVE USP     " link MoveUSP  }

Special:
	@{ "LEA  " link Lea   } @{ "PEA  " link Pea   }
@endnode

***********************************************************

@node Math

Integer:
	@{ "ADD " link Add  } @{ "ADDI" link Addi } @{ "ADDQ" link Addq } @{ "ADDA" link Adda } @{ "SUB " link Sub  } @{ "SUBI" link Subi } @{ "SUBQ" link Subq } @{ "SUBA" link Suba }
	@{ "DIVS" link Divs } @{ "DIVU" link Divu } @{ "MULS" link Mul  } @{ "MULU" link Mul  }
	@{ "EXT " link Ext  }
	@{ "NEG " link Neg  }
	@{ "CMP " link Cmp  } @{ "CMPI" link Cmpi } @{ "CMPA" link Cmpa }

Multi-Precision Integer:
	@{ "ABCD" link Abcd } @{ "ADDX" link Addx } @{ "SBCD" link Sbcd } @{ "SUBX" link Subx }
	@{ "NBCD" link Nbcd }
	@{ "CMPM" link Cmpm }

@endnode

***********************************************************

@node Logic
Bit-wise:
	@{ "AND " link And } @{ "ANDI" link Andi } @{ "ANDI to CCR" link AndiCCR } @{ "ANDI to SR" link AndiSR }
	@{ "EOR " link Eor } @{ "EORI" link Eori } @{ "EORI to CCR" link EoriCCR } @{ "EORI to SR" link EoriSR }
	@{ "OR  " link Or  } @{ "ORI " link Ori  } @{ "ORI  to CCR" link OriCCR } @{ "ORI  to SR" link OriSR }

Byte-wise:
	@{ "TST " link Tst } @{ "TAS " link Tas }
	@{ "Scc " link Scc }
	@{ "NOT " link Not }
@endnode

***********************************************************

@node Flow
Subroutine:
	@{ "BSR    " link Bsr     } @{ "JSR    " link Jsr     }
	@{ "RTS    " link Rts     } @{ "RTD    " link Rtd     } @{ "RTR    " link Rtr     }

Local:
	@{ "BRA    " line Bra     } @{ "JMP    " link Jmp     }

Conditional:
	@{ "Bcc    " link Bcc     } @{ "DBcc   " link Dbcc    }

System:
	@{ "ILLEGAL" link Illegal } @{ "BKPT   " link Bkpt    }
	@{ "TRAP   " link Trap    } @{ "TRAPV  " link Trapv   }
	@{ "RESET  " link Reset   } @{ "STOP   " link Stop    }
	@{ "RTE    " link Rte     }
@endnode

***********************************************************

@node Misc
Stack Frame Maintainance:
	@{ "LINK" link Link } @{ "UNLK" link Unlk }

Processor:
	@{ "NOP " link Nop  }
@endnode

***********************************************************

@node Shift
Shifts:
	@{ "ASd " link ASd  } @{ "LSd " link Lsd  }

Rotates:
	@{ "ROd " link Rod  } @{ "ROXd" link Roxd }
@endnode

***********************************************************

@node Bit
Single Bit:
	@{ "BCHG  " link Bchg   } @{ "BCLR  " link Bclr   } @{ "BSET  " link Bset   } @{ "BTST  " link Btst   }

Bit Field:
	@{ "BFCHG " link BFCHG  } @{ "BFCLR " link Bfclr  } @{ "BFSET " link Bfset  }
	@{ "BFINS " link Bfins  } @{ "BFEXTS" link bfexts } @{ "BFEXTU" link Bfextu }
	@{ "BFFFO " link Bfffo  } @{ "BFTST " link Bftst  }
@endnode

***********************************************************

@node Abcd
@{b}NAME@{ub}
	ABCD -- Add binary coded decimal

@{b}SYNOPSIS@{ub}
	ABCD	Dy,Dx
	ABCD	-(Ay),-(Ax)

	Size = (Byte)

@{b}FUNCTION@{ub}
	Adds the source operand to the destination operand along with
	the extend bit, and stores the result in the destination location.  The
	addition is performed using binary coded decimal arithmetic.  The
	operands, which are packed BCD numbers, can be addressed in two dif-
	ferent ways:

	1. Data register to data register: The operands are contained in the
	   data registers specified in the instruction.

	2. Memory to memory: The operands are addressed with the predecrement
	   addressing mode using the address registers specified in the
	   instruction.

	This operation is a byte operation only.

	Normally the Z condition code bit is set via programming before the
	start of an operation.  That allows successful tests for zero results
	upon completion of multiple-precision operations.

@{b}RESULT@{ub}
	X - Set the same as the carry bit.
	N - Undefined
	Z - Cleared if the result is non-zero. Unchanged otherwise.
	V - Undefined
	C - Set if a decimal carry was generated.  Cleared otherwise.

@{b}SEE ALSO@{ub}
	@{ "ADD " link Add  } @{ "ADDI" link Addi } @{ "ADDQ" link Addq }
	@{ "ADDX" link Addx }
	@{ "SUB " link Sub  } @{ "SUBI" link Subi } @{ "SUBQ" link Subq }
	@{ "SBCD" link Sbcd } @{ "SUBX" link Subx }
@endnode

***********************************************************

@node Add
@{b}NAME@{ub}
	ADD -- Add integer

@{b}SYNOPSIS@{ub}
	ADD	<ea>,Dn
	ADD	Dn,<ea>

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	Adds the source operand to the destination operand using
	binary addition, and stores the result in the destination location.
	The size of the operation may be specified as byte, word, or long.
	The mode of the instruction indicates which operand is the source and
	which is the destination as well as the operand size.

@{b}RESULT@{ub}
	X - Set the same as the carry bit.
	N - Set if the result is negative.  Cleared otherwise.
	Z - Set if the result is zero.  Cleared otherwise.
	V - Set if an overflow is generated.  Cleared otherwise.
	C - Set if a carry is generated.  Cleared otherwise.

@{b}SEE ALSO@{ub}
	@{ "ADDI" link Addi } @{ "ADDQ" link Addq } @{ "ADDX" link Addx }
	@{ "SUB " link Sub  } @{ "SUBI" link Subi } @{ "SUBQ" link Subq }
	@{ "SUBX" link Subx }
@endnode

***********************************************************

@node Adda
@{b}NAME@{ub}
	ADDA -- Add address

@{b}SYNOPSIS@{ub}
	ADDA	<ea>,An

	Size = (Word, Long)

@{b}FUNCTION@{ub}
	Adds the source operand to the destination address register,
	and stores the result in the destination address register.  The size
	of the operation may be specified as word or long.  The entire
	destination operand is used regardless of the operation size.

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
	@{ "ADDQ" link Addq } @{ "SUBQ" link Subq } @{ "SUBA" link Suba }
@endnode

***********************************************************

@node Addi
@{b}NAME@{ub}
	ADDI -- Add immediate

@{b}SYNOPSIS@{ub}
	ADDI	#<data>,<ea>

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	Adds the immediate data to the destination operand, and
	stores the result in the destination location.  The size of the
	operation may be specified as byte, word, or long.  The size of the
	immediate data matches the operation size.

@{b}RESULT@{ub}
	X - Set the same as the carry bit.
	N - Set if the result is negative.  Cleared otherwise.
	Z - Set if the result is zero.  Cleared otherwise.
	V - Set if an overflow is generated.  Cleared otherwise.
	C - Set if a carry is generated.  Cleared otherwise.

@{b}SEE ALSO@{ub}
	@{ "ADD " link Add  } @{ "ADDQ" link Addq } @{ "ADDX" link Addx }
	@{ "SUB " link Sub  } @{ "SUBI" link Subi } @{ "SUBQ" link Subq }
	@{ "SUBX" link Subx }
@endnode

***********************************************************

@node Addq
@{b}NAME@{ub}
	ADDQ -- Add 3-bit immediate quick


@{b}SYNOPSIS@{ub}
	ADDQ	#<data>,<ea>

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	Adds the immediate value of 1 to 8 to the operand at the
	destination location.  The size of the operation may be specified as
	byte, word, or long.  When adding to address registers, the condition
	codes are not altered, and the entire destination address register is
	used regardless of the operation size.

@{b}RESULT@{ub}
	X - Set the same as the carry bit.
	N - Set if the result is negative.  Cleared otherwise.
	Z - Set if the result is zero.  Cleared otherwise.
	V - Set if an overflow is generated.  Cleared otherwise.
	C - Set if a carry is generated.  Cleared otherwise.

@{b}SEE ALSO@{ub}
	@{ "ADD " link Add  } @{ "ADDI" link Addi }
	@{ "SUB " link Sub  } @{ "SUBI" link Subi } @{ "SUBQ" link Subq }
@endnode

***********************************************************

@node Addx
@{b}NAME@{ub}
	ADDX -- Add integer with extend

@{b}SYNOPSIS@{ub}
	ADDX	Dy,Dx
	ADDX	-(Ay),-(Ax)

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	Adds the source operand to the destination operand along with
	the extend bit, and stores the result in the destination location.  The
	addition is performed using binary coded decimal arithmetic.  The
	operands, which are packed BCD numbers, can be addressed in two dif-
	ferent ways:

	1. Data register to data register: The operands are contained in the
	   data registers specified in the instruction.

	2. Memory to memory: The operands are addressed with the predecrement
	   addressing mode using the address registers specified in the
	   instruction.

	The size of operation can be specified as byte, word, or long.

	Normally the Z condition code bit is set via programming before the
	start of an operation.  That allows successful tests for zero results
	upon completion of multiple-precision operations.

@{b}RESULT@{ub}
	X - Set the same as the carry bit.
	N - Set if the result is negative.  Cleared otherwise.
	Z - Cleared if the result is non-zero. Unchanged otherwise.
	V - Set if an overflow is generated.  Cleared otherwise.
	C - Set if a carry is generated.  Cleared otherwise.

@{b}SEE ALSO@{ub}
	@{ "ADD" link Add  } @{ "ADDI" link Addi }
	@{ "SUB" link Sub  } @{ "SUBI" link Subi } @{ "SUBX" link Subx }
@endnode

***********************************************************

@node And
@{b}NAME@{ub}
	AND -- Logical AND

@{b}SYNOPSIS@{ub}
	AND	<ea>,Dn
	AND	Dn,<ea>

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	Performs a bit-wise AND operation with the source operand and
	the destination operand and stores the result in the destination.  The
	size of ther operation can be specified as byte, word, or long.  The
	contents of an address register may not be used as an operand.

@{b}RESULT@{ub}
	X - Not affected
	N - Set if the most-significant bit of the result was set. Cleared
	    otherwise.
	Z - Set if the result was zero.  Cleared otherwise.
	V - Always cleared.
	C - Always cleared.

@{b}SEE ALSO@{ub}
	@{ "ANDI" link Andi }
@endnode

***********************************************************

@node Andi
@{b}NAME@{ub}
	ANDI -- Logical AND immediate

@{b}SYNOPSIS@{ub}
	ANDI	#<data>,<ea>

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	Performs a bit-wise AND operation with the immediate data and
	the destination operand and stores the result in the destination.  The
	size of ther operation can be specified as byte, word, or long.  The
	size of the immediate data matches the operation size.

@{b}RESULT@{ub}
	X - Not affected
	N - Set if the most-significant bit of the result was set. Cleared
	    otherwise.
	Z - Set if the result was zero.  Cleared otherwise.
	V - Always cleared.
	C - Always cleared.

@{b}SEE ALSO@{ub}
	@{ "AND " link And } @{ "ANDI to CCR" link AndiCCR } @{ "ANDI to SR" link AndiSR }
@endnode

***********************************************************

@node AndiCCR
@{b}NAME@{ub}
	ANDI to CCR -- Logical AND immediate to condition code register

@{b}SYNOPSIS@{ub}
	ANDI	#<data>,CCR

	Size = (Byte)

@{b}FUNCTION@{ub}
	Performs a bit-wise AND operation with the immediate data and
	the lower byte of the status register.

@{b}RESULT@{ub}
	X - Cleared if bit 4 of immed. operand is zero. Unchaned otherwise.
	N - Cleared if bit 3 of immed. operand is zero. Unchaned otherwise.
	Z - Cleared if bit 2 of immed. operand is zero. Unchaned otherwise.
	V - Cleared if bit 1 of immed. operand is zero. Unchaned otherwise.
	C - Cleared if bit 0 of immed. operand is zero. Unchaned otherwise.

@{b}SEE ALSO@{ub}
	@{ "AND " link And } @{ "ANDI" link Andi } @{ "ANDI to SR" link AndiSR }
@endnode

***********************************************************

@node AndiSR
@{b}NAME@{ub}
	ANDI to SR -- Logical AND immediate to status register (privileged)

@{b}SYNOPSIS@{ub}
	ANDI	#<data>,SR

	Size = (Word)

@{b}FUNCTION@{ub}
	Performs a bit-wise AND operation with the immediate data and
	the status register.  All implemented bits of the status register are
	affected.

@{b}RESULT@{ub}
	X - Cleared if bit 4 of immed. operand is zero. Unchaned otherwise.
	N - Cleared if bit 3 of immed. operand is zero. Unchaned otherwise.
	Z - Cleared if bit 2 of immed. operand is zero. Unchaned otherwise.
	V - Cleared if bit 1 of immed. operand is zero. Unchaned otherwise.
	C - Cleared if bit 0 of immed. operand is zero. Unchaned otherwise.

@{b}SEE ALSO@{ub}
	@{ "AND " link And } @{ "ANDI" link Andi } @{ "ANDI to CCR" link AndiCCR }
@endnode

***********************************************************

@node Asd
@{b}NAME@{ub}
	ASL, ASR -- Arithmetic shift left and arithmetic shift right

	ASd	#<data>,Dy
	ASd	<ea>
	where `d' is the direction, L or R

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}


@{b}RESULT@{ub}
	X - Set according to the list bit shifted out of the operand.
	    Unaffected for a shift count of zero.
	N - Set if the most-significant bit of the result is set.  Cleared
	    otherwise.
	Z - Set if the result is zero.  Cleared otherwise.
	V - Set if the most significant bit is changed at any time during the
	    shift operation.  Cleared otherwise.
	C - Set according to the list bit shifted out of the operand.
	    Cleared for a shift count of zero.

@{b}SEE ALSO@{ub}
	@{ "ROd " link Rod } @{ "ROXd" link Roxd }
@endnode

***********************************************************

@node Bcc
@{b}NAME@{ub}
	Bcc -- Conditional branch

@{b}SYNOPSIS@{ub}
	Bcc	<label>

	Size = (Byte, Word)

@{b}FUNCTION@{ub}

  CC  carry clear	C'		LS low or same		C+Z
  CS  carry set		C		LT less than		N'·V+N'V
  EQ  equal		Z		MI  minus		N
  GE  greater or equal	N·V+N'V'	NE  not equal		Z'
  GT  greater than	N·V·Z'+N'V'·Z'	PL  plus		N'
  HI  high		C'·Z'		VC  overflow clear	V'
  LE  less or equal	Z+N'·V+N'V	VS  overflow set	V

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
	@{ "BRA " link Bra } @{ "DBcc" link Dbcc } @{ "Scc " link Scc }
@endnode

***********************************************************

@node Bchg
@{b}NAME@{ub}
	BCHG -- Bit change

@{b}SYNOPSIS@{ub}
	BCHG	Dn,<ea>
	BCHG	#<data>,<ea>

	Size = (Byte, Long)

@{b}FUNCTION@{ub}
	Tests a bit in the destination operand and sets the Z
	condition code appropriately, then inverts the bit in the destination.
	If the destination is a data register, any of the 32 bits can be
	specifice by the modulo 32 number.  When the distination is a memory
	location, the operation must be a byte operation, and therefore the
	bit number is modulo 8.  In all cases, bit zero is the least
	significant bit.  The bit number for this operation may be specified
	in either of two ways:

	1. Immediate -- The bit number is specified as immediate data.
	2. Register  -- The specified data register contains the bit number.

@{b}RESULT@{ub}
	X - not affected
	N - not affected
	Z - Set if the bit tested is zero.  Cleared otherwise.
	V - not affected
	C - not affected

@{b}SEE ALSO@{ub}
	@{ "BCLR " link Bclr  } @{ "BSET " link Bset  } @{ "BTST " link Btst  }
	@{ "EOR  " link Eor   } @{ "BFCHG" link Bfchg }
@endnode

***********************************************************

@node Bclr
@{b}NAME@{ub}
	BCLR -- Bit clear

@{b}SYNOPSIS@{ub}
	BCLR	Dn,<ea>
	BCLR	#<data>,<ea>

	Size = (Byte, Long)

@{b}FUNCTION@{ub}
	Tests a bit in the destination operand and sets the Z
	condition code appropriately, then clears the bit in the destination.
	If the destination is a data register, any of the 32 bits can be
	specifice by the modulo 32 number.  When the distination is a memory
	location, the operation must be a byte operation, and therefore the
	bit number is modulo 8.  In all cases, bit zero is the least
	significant bit.  The bit number for this operation may be specified
	in either of two ways:

	1. Immediate -- The bit number is specified as immediate data.
	2. Register  -- The specified data register contains the bit number.

@{b}RESULT@{ub}
	X - not affected
	N - not affected
	Z - Set if the bit tested is zero.  Cleared otherwise.
	V - not affected
	C - not affected

@{b}SEE ALSO@{ub}
	@{ "BCHG " link Bchg  } @{ "BSET " link Bset  } @{ "BTST " link Btst  }
	@{ "AND  " link And   } @{ "BFCLR" link Bfclr }
@endnode

***********************************************************

@node Bkpt
@{b}NAME@{ub}
	BKPT -- Break-point

@{b}SYNOPSIS@{ub}
	BKPT	#<data>

@{b}FUNCTION@{ub}
	This instruction is used to support the program breakpoint
	function for debug monitors and real-time hardware emulators, and
	the operation will be dependent on the implementation.  Execution of
	this instruction will cause the MC68010 to run a breakpoint
	acknowledge bus cycle and zeros on all address lines, but an
	MC68020 will place the immediate data on lines A2, A3, and A4, and
	zeros on lines A0 and A1.

	Whether the breakpoint acknowledge cycle is terminaled with
	(DTACK)', (BERR)', or (VPA)' the processor always takes an illegal
	instruction exception.  During exception processing, a debug monitor
	can distinguish eight different software breakpoints by decoding the
	field in the BKPT instruction.

	For the MC68000 and the MC68HC000, this instruction causes an illegal
	instruction exception, but does not run the breakpoint acknowledge
	bus cycle.

	There are two possible responses on an MC68020: normal and exception.
	The normal response is an operation word (typically the instruction
	the BKPT originally replaced) on the data lines with the (DSACKx)'
	signal asserted.  The operation word is the executed in place of the
	breakpoint instruction.

	For the exception response, a bus error signal will cause the MC68020
	to take an illegal instruction execpetion, just as an MC68010 or
	MC68000 would do.

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
	@{ "ILLEGAL   " link Illegal    }
	@{ "Exceptions" link Exceptions }
@endnode

***********************************************************

@node Bra
@{b}NAME@{ub}
	BRA -- Unconditional branch

@{b}SYNOPSIS@{ub}
	BRA	<label>

	Size = (Byte, Word)
	Size = (Byte, Word, Long)	(68020+)

@{b}FUNCTION@{ub}
	Program execution continues at location (PC) + displacement.
	The PC contains the address of the instruction word of the BRA
	instruction puls two.  The displacement is a twos complement integer
	that represents the relative distance in bytes from the current PC
	to the destination PC.

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
	@{ "JMP" link Jmp } @{ "Bcc" link Bcc }
@endnode

***********************************************************

@node Bset
@{b}NAME@{ub}
	BSET -- Bit set

@{b}SYNOPSIS@{ub}
	BCLR	Dn,<ea>
	BCLR	#<data>,<ea>

	Size = (Byte, Long)

@{b}FUNCTION@{ub}
	Tests a bit in the destination operand and sets the Z
	condition code appropriately, then sets the bit in the destination.
	If the destination is a data register, any of the 32 bits can be
	specifice by the modulo 32 number.  When the distination is a memory
	location, the operation must be a byte operation, and therefore the
	bit number is modulo 8.  In all cases, bit zero is the least
	significant bit.  The bit number for this operation may be specified
	in either of two ways:

	1. Immediate -- The bit number is specified as immediate data.
	2. Register  -- The specified data register contains the bit number.

@{b}RESULT@{ub}
	X - not affected
	N - not affected
	Z - Set if the bit tested is zero.  Cleared otherwise.
	V - not affected
	C - not affected

@{b}SEE ALSO@{ub}
	@{ "BCHG " link Bchg  } @{ "BCLR " link Bclr  } @{ "BTST " link Btst  }
	@{ "OR   " link Or    } @{ "BFSET" link Bfset } @{ "BFINS" link Bfins }
@endnode

***********************************************************

@node Bsr
@{b}NAME@{ub}
	BSR -- Branch to subroutine

@{b}SYNOPSIS@{ub}
	BSR	<label>

	Size = (Byte, Word)
	Size = (Byte, Word, Long)	(68020+)

@{b}FUNCTION@{ub}
	Pushes the long word address of the instruction immediately
	following the BSR instruction onto the system stack.  The PC contains
	the address of the instruction word plus two.  Program execution
	continues at location (PC) + displacement.

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
	@{ "JSR" link Jsr } @{ "BRA" link Bra }
	@{ "RTS" link Rts } @{ "RTD" link Rts } @{ "RTR" link Rts } 
@endnode

***********************************************************

@node Btst
@{b}NAME@{ub}
	BTST -- Bit test

@{b}SYNOPSIS@{ub}
	BTST	Dn,<ea>
	BTST	#<data>,<ea>

	Size = (Byte, Long)

@{b}FUNCTION@{ub}
	Tests a bit in the destination operand and sets the Z
	condition code appropriately.  If the destination is a data register,
	any of the 32 bits can be specified by the modulo 32 number.  When
	the distination is a memory location, the operation must be a byte
	operation, and therefore the bit number is modulo 8.  In all cases,
	bit zero is the least significant bit.  The bit number for this
	operation may be specified in either of two ways:

	1. Immediate -- The bit number is specified as immediate data.
	2. Register  -- The specified data register contains the bit number.

@{b}RESULT@{ub}
	X - not affected
	N - not affected
	Z - Set if the bit tested is zero.  Cleared otherwise.
	V - not affected
	C - not affected

@{b}SEE ALSO@{ub}
	@{ "BFTST" link Bftst } @{ "BFFFO" link Bfffo }
@endnode

***********************************************************

@node Chk
@{b}NAME@{ub}
	CHK -- Check bounds

@{b}SYNOPSIS@{ub}
	CHK	<ea>,Dn

	Size = (Word)

@{b}FUNCTION@{ub}
	Compares the value in the data register specified to
	zero and to the upper bound.  The upper bound is a twos complement
	integer.  If the register value is less than zero or greater than
	the upper bound, a CHK instruction, vector number 6, occours.

@{b}RESULT@{ub}
	X - Not affected
	N - Set if Dn < 0; cleared if Dn > <ea>.  Undefined otherwise.
	Z - Undefined.
	V - Undefined.
	C - Undefined.

@{b}SEE ALSO@{ub}
	@{ "CMP " link Cmp  } @{ "CMPI" link Cmpi } @{ "CMPA" link Cmpa }
	@{ "CHK2" link Chk2 }
@endnode

***********************************************************

@node Clr
@{b}NAME@{ub}
	CLR -- Clear

@{b}SYNOPSIS@{ub}
	CLR	<ea>

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	Clears the destination operand to zero.

	On an MC68000 and MC68HC000, a CLR instruction does both a
	read and a write to the destination.  Because of this, this
	instruction should never be used on custom chip registers.

@{b}RESULT@{ub}
	X - Not affected
	N - Always cleared
	Z - Always set
	V - Always cleared
	C - Always cleared

@{b}SEE ALSO@{ub}
	@{ "MOVE " link Move  } @{ "MOVEQ" link Moveq }
	@{ "BCLR " link Bclr  } @{ "BFCLR" link Bfclr }
@endnode

***********************************************************

@node Cmp
@{b}NAME@{ub}
	CMP -- Compare

@{b}SYNOPSIS@{ub}
	CMP	<ea>,Dn

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	Subtracts the source operand from the destination data
	register and sets the condition codes according to the result.  The
	data register is NOT changed.

@{b}RESULT@{ub}
	X - Not affected
	N - Set if the result is negative.  Cleared otherwise.
	Z - Set if the result is zero.  Cleared otherwise.
	V - Set if an overflow occours.  Cleared otherwise.
	C - Set if a borrow occours.  Cleared otherwise.

@{b}SEE ALSO@{ub}
	@{ "CMPI" link Cmpi } @{ "CMPA" link Cmpa } @{ "CMPM" link Cmpm } @{ "CMP2" link Cmp2 }
	@{ "TST " link Tst  } @{ "CHK " link Chk  } @{ "CHK2" link Chk2 }
@endnode

***********************************************************

@node Cmpa
@{b}NAME@{ub}
	CMPA -- Compare address

@{b}SYNOPSIS@{ub}
	CMPA	<ea>,An

	Size = (Word, Long)

@{b}FUNCTION@{ub}
	Subtracts the source operand from the destination address
	register and sets the condition codes according to the result.  The
	address register is NOT changed.  Word sized source operands are
	sign extended to long for comparison.

@{b}RESULT@{ub}
	X - Not affected
	N - Set if the result is negative.  Cleared otherwise.
	Z - Set if the result is zero.  Cleared otherwise.
	V - Set if an overflow occours.  Cleared otherwise.
	C - Set if a borrow occours.  Cleared otherwise.

@{b}SEE ALSO@{ub}
	@{ "CMP " link Cmp  } @{ "CMPI" link Cmpi } @{ "CMP2" link Cmp2 }
@endnode

***********************************************************

@node Cmpi
@{b}NAME@{ub}
	CMPI -- Compare immediate

@{b}SYNOPSIS@{ub}
	CMP	#<data>,<ea>

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	Subtracts the source operand from the destination operand
	and sets the condition codes according to the result.  The destination
	is NOT changed.  The size of the immediate data matches the operation
	size.

@{b}RESULT@{ub}
	X - Not affected
	N - Set if the result is negative.  Cleared otherwise.
	Z - Set if the result is zero.  Cleared otherwise.
	V - Set if an overflow occours.  Cleared otherwise.
	C - Set if a borrow occours.  Cleared otherwise.

@{b}SEE ALSO@{ub}
	@{ "CMP " link Cmp  } @{ "CMPA" link Cmpa } @{ "CMPM" link Cmpm } @{ "CMP2" link Cmp2 }
	@{ "TST " link Tst  } @{ "CHK " link Chk  } @{ "CHK2" link Chk2 }
@endnode

***********************************************************

@node Cmpm
@{b}NAME@{ub}
	CMPM -- Compare memory

@{b}SYNOPSIS@{ub}
	CMPM	(Ay)+,(Ax)+

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	Subtracts the source operand from the destination operand
	and sets the condition codes according to the result.  The destination
	operand is NOT changed.  Operands are always addressed with the
	postincrement mode.

@{b}RESULT@{ub}
	X - Not affected
	N - Set if the result is negative.  Cleared otherwise.
	Z - Set if the result is zero.  Cleared otherwise.
	V - Set if an overflow occours.  Cleared otherwise.
	C - Set if a borrow occours.  Cleared otherwise.

@{b}SEE ALSO@{ub}
	@{ "CMP " link Cmp  } @{ "CMPI" link Cmpi } @{ "CMPA" link Cmpa } @{ "CMP2" link Cmp2 }
	@{ "TST " link Tst  } @{ "CHK " link Chk  } @{ "CHK2" link Chk2 }
@endnode

***********************************************************

@node Dbcc
@{b}NAME@{ub}
	DBcc -- Decrement and branch conditionally

@{b}SYNOPSIS@{ub}
	DBcc	Dn,<label>

	Size = (Word)

@{b}FUNCTION@{ub}
	Controls a loop of instructions.  The parameters are: a
	condition code, a data register (counter), and a displacement value.
	The insctruction first tests the condition (for termination); if it
	is true, no operation is performed.  If the termination condition is
	not true, the low-order 16 bits of the counter are decremented by
	one.  If the result is -1, execution continues at the next
	instruction, otherwise, execution continues at the specified
	address.

	Condition code `cc' specifies one of the following:

  CC  carry clear	C'		LS low or same		C+Z
  CS  carry set		C		LT less than		N'·V+N'V
  EQ  equal		Z		MI  minus		N
  GE  greater or equal	N·V+N'V'	NE  not equal		Z'
  GT  greater than	N·V·Z'+N'V'·Z'	PL  plus		N'
  HI  high		C'·Z'		VC  overflow clear	V'
  LE  less or equal	Z+N'·V+N'V	VS  overflow set	V


	Keep the following in mind when using DBcc instructions:
	1. A DBcc acts as the UNTIL loop contruct in high level
	   languages. E.g., DBMI would be "decrement and branch until
	   minus".
	2. Most assemblers accept DBRA or DBF for use when no condition
	   is required for termination of a loop.

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
	@{ "Bcc" link Bcc } @{ "Scc" link Scc }
@endnode

***********************************************************

@node Divs
@{b}NAME@{ub}
	DIVS, DIVSL -- Signed divide

@{b}SYNOPSIS@{ub}
	DIVS.W	<ea>,Dn     32/16 -> 16r:16q
	DIVS.L	<ea>,Dq     32/32 -> 32q      (68020+)
	DIVS.L	<ea>,Dr:Dq  64/32 -> 32r:32q  (68020+)
	DIVSL.L	<ea>,Dr:Dq  32/32 -> 32r:32q  (68020+)

	Size = (Word, Long)

@{b}FUNCTION@{ub}
	Divides the signed destination operand by the signed source
	operand and stores the signed result in the destination.

	The instruction has a word form and three long forms.  For the
	word form, the destination operand is a long word and the source
	operand is a word.  The resultant quotient is placed in the lower
	word of the destination and the resultant remainder is placed in the
	upper word of the destination.  The sign of the remainder is the
	same as the sign of the dividend.

	In the first long form, the destination and the source are both
	long words.  The quotient is placed in the longword of the destination
	and the remaineder is discarded.

	The second long form has the destination as a quadword (eight bytes),
	specified by any two data registers, and the source is a long word.
	The resultant remainder and quotient are both long words and are
	placed in the destination registers.

	The final long form has both the source and the destination as long
	words and the resultant quotient and remainder as long words.

@{b}RESULT@{ub}
	X - Not affected
	N - Set if the quotient is negative, cleared otherwise. Undefined if
	    overflow or divide by zero occurs.
	Z - Set if the quotient is zero, cleared otherwise. Undefined if
	    overflow or divide by zero occurs.
	V - Set if overflow occurs, cleared otherwise. Undefined if divide by
	    zero occurs.
	C - Always cleared.

	Notes:
	1. If divide by zero occurs, an exception occurs.
	2. If overflow occurs, neither operand is affected.

@{b}SEE ALSO@{ub}
	@{ "DIVU" link Divu } @{ "MULS" link Muls } @{ "MULU" link Mulu }
	@{ "Exceptions" link Exceptions }
@endnode

***********************************************************

@node Divu
@{b}NAME@{ub}
	DIVU, DIVUL -- Unsigned divide

@{b}SYNOPSIS@{ub}
	DIVU.W	<ea>,Dn     32/16 -> 16r:16q
	DIVU.L	<ea>,Dq     32/32 -> 32q      (68020+)
	DIVU.L	<ea>,Dr:Dq  64/32 -> 32r:32q  (68020+)
	DIVUL.L	<ea>,Dr:Dq  32/32 -> 32r:32q  (68020+)

	Size = (Word, Long)

@{b}FUNCTION@{ub}
	Divides the unsigned destination operand by the unsigned
	source operand and stores the unsigned result in the destination.

	The instruction has a word form and three long forms.  For the
	word form, the destination operand is a long word and the source
	operand is a word.  The resultant quotient is placed in the lower
	word of the destination and the resultant remainder is placed in the
	upper word of the destination.  The sign of the remainder is the
	same as the sign of the dividend.

	In the first long form, the destination and the source are both
	long words.  The quotient is placed in the longword of the destination
	and the remaineder is discarded.

	The second long form has the destination as a quadword (eight bytes),
	specified by any two data registers, and the source is a long word.
	The resultant remainder and quotient are both long words and are
	placed in the destination registers.

	The final long form has both the source and the destination as long
	words and the resultant quotient and remainder as long words.

@{b}RESULT@{ub}

	X - Not affected
	N - See below.
	Z - Set if the quotient is zero, cleared otherwise. Undefined if
	    overflow or divide by zero occurs.
	V - Set if overflow occurs, cleared otherwise. Undefined if divide by
	    zero occurs.
	C - Always cleared.

	Notes:
	1. If divide by zero occurs, an exception occurs.
	2. If overflow occurs, neither operand is affected.

	According to the Motorola data books, the N flag is set if the
	quotient is negative, but in an unsigned divide, this seems to
	be impossible.

@{b}SEE ALSO@{ub}
	@{ "DIVS" link Divs } @{ "MULS" link Muls } @{ "MULU" link Mulu }
	@{ "Exceptions" link Exceptions }
@endnode

***********************************************************

@node Eor
@{b}NAME@{ub}
	EOR -- Exclusive logical OR

@{b}SYNOPSIS@{ub}
	EOR	Dn,<ea>

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	Performs an exclusive OR operation on the destination operand
	with the source operand.

@{b}RESULT@{ub}
	X - Not Affected
	N - Set to the value of the most significant bit.
	Z - Set if the result is zero.
	V - Always cleared
	C - Always cleared
	
@{b}SEE ALSO@{ub}
	@{"EORI" link Eori} @{"BCHG" link Bchg}
@endnode

***********************************************************

@node Eori
@{b}NAME@{ub}
	EORI -- Exclusive OR immediate

@{b}SYNOPSIS@{ub}
	EORI	#<data>,<ea>

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	Performs an exclusive OR operation on the destination operand
	with the source operand.

@{b}RESULT@{ub}
	X - Not Affected
	N - Set to the value of the most significant bit.
	Z - Set if the result is zero.
	V - Always cleared
	C - Always cleared
	
@{b}SEE ALSO@{ub}
	@{ "EOR " link Eor  } @{ "EORI to CCR" link EoriCCR } @{ "EORI to SR" link EoriSR }
	@{ "BCHG" link Bchg }

@endnode

***********************************************************

@node EoriCCR
@{b}NAME@{ub}
	EORI to CCR -- Exclusive OR immediate to the condition code register

@{b}SYNOPSIS@{ub}
	EORI	#<data>,CCR

	Size = (Byte)

@{b}FUNCTION@{ub}
	Performs an exclusive OR operation on the condition codes
	register with the source operand.

@{b}RESULT@{ub}
	X - Changed if bit 4 of the source is set, cleared otherwise.
	N - Changed if bit 3 of the source is set, cleared otherwise.
	Z - Changed if bit 2 of the source is set, cleared otherwise.
	V - Changed if bit 1 of the source is set, cleared otherwise.
	C - Changed if bit 0 of the source is set, cleared otherwise.
	
@{b}SEE ALSO@{ub}
	@{ "EOR " link Eor  } @{ "EORI" link Eori } @{ "EORI to SR" link EoriSR }
@endnode

***********************************************************

@node EoriSR
@{b}NAME@{ub}
	EORI to SR -- Exclusive OR immediated to the status register (privileged)

@{b}SYNOPSIS@{ub}
	EORI	#<data>,SR

	Size = (Word)

@{b}FUNCTION@{ub}
	Performs an exclusive OR operation on the status register
	with the source operand.

@{b}RESULT@{ub}
	X - Changed if bit 4 of the source is set, cleared otherwise.
	N - Changed if bit 3 of the source is set, cleared otherwise.
	Z - Changed if bit 2 of the source is set, cleared otherwise.
	V - Changed if bit 1 of the source is set, cleared otherwise.
	C - Changed if bit 0 of the source is set, cleared otherwise.
	
@{b}SEE ALSO@{ub}
	@{"EOR " link Eor } @{"EORI" link Eori} @{"EORI to CCR" link EoriCCR}
@endnode

***********************************************************

@node Exg
@{b}NAME@{ub}
	EXG -- Register exchange

@{b}SYNOPSIS@{ub}
	EXG	Rx,Ry

	Size = (Long)

@{b}FUNCTION@{ub}
	Exchanges the contents of any two registers.

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
	@{ "SWAP" link Swap }
@endnode

***********************************************************

@node Ext
@{b}NAME@{ub}
	EXT, EXTB -- Sign extend

@{b}SYNOPSIS@{ub}
	EXT.W	Dn	Extend byte to word
	EXT.L	Dn	Extend word to long word
	EXTB.L	Dn	Extend byte to long word	(68020+)

	Size = (Word, Long)

@{b}FUNCTION@{ub}
	Extends a byte to a word, or a word to a long word in a data
	register by copying the sign bit through the upper bits.  If the
	operation is from byte to word, bit 7 is copied to bits 8 through
	15.  If the operation is from word to long word, bit 15 is copied
	to bits 16 through 31.  The EXTB copies bit 7 to bits 8 through 31.

@{b}RESULT@{ub}
	X - Not affected
	N - Set if the result is negative.  Cleared otherwise.
	Z - Set if the result is zero.  Cleared otherwise.
	V - Always cleared
	C - Always cleared

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Illegal
@{b}NAME@{ub}
	ILLEGAL -- Illegal processor instruction

@{b}SYNOPSIS@{ub}
	ILLEGAL

@{b}FUNCTION@{ub}
	This instruction forces an Illegal Instruction exception,
	vector number 4.  All other illegal instruction bit patterns,
	including, but not limited to, $fxxx and $axxx, are reserved for
	future expansion.

@{b}RESULT@{ub}
	None.


@{b}SEE ALSO@{ub}
	@{ "BKPT      " link Bkpt }
	@{ "Exceptions" link Exceptions }
@endnode

***********************************************************

@node Jmp
@{b}NAME@{ub}
	JMP -- Unconditional far jump

@{b}SYNOPSIS@{ub}
	JMP	<ea>

@{b}FUNCTION@{ub}
	Program execution continues at the address specified by
	the operand.

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
	@{ "BRA" link Bra } @{ "JSR" link Jsr }
@endnode

***********************************************************

@node Jsr
@{b}NAME@{ub}
	JSR -- Jump to far subroutine

@{b}SYNOPSIS@{ub}
	JSR	<ea>

@{b}FUNCTION@{ub}
	Pushes the long word address of the instruction immediately
	following the JSR instruction onto the stack.  The PC contains
	the address of the instruction word plus two.  Program execution
	continues at location specified by <ea>.

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
	@{ "BSR" link Jsr } @{ "BRA" link Bra }
	@{ "RTS" link Rts } @{ "RTD" link Rts } @{ "RTR" link Rts } 
@endnode

***********************************************************

@node Lea
@{b}NAME@{ub}
	LEA -- Load effective address

@{b}SYNOPSIS@{ub}
	LEA	<ea>,An

	Size = (Long)

@{b}FUNCTION@{ub}
	Places the specified address into the destination address
	register.  Note:  All 32 bits of An are affected by this instruction.

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
	@{ "MOVEA" link Movea } @{ "ADDA " link Adda  } @{ "SUBA " link Suba  }
@endnode

***********************************************************

@node Link
@{b}NAME@{ub}
	LINK -- Create local stack frame

@{b}SYNOPSIS@{ub}
	LINK	An,#<data>

	Size = (Word)
	Size = (Word, Long)		(68020+)

@{b}FUNCTION@{ub}
	This instruction saves the specified address register onto
	the stack, then places the new stack pointer in that register.  It
	then adds the specificed immediate data to the stack pointer.  To
	allocate space on the stack for a local data area, a negative value
	should be used for the second operand.

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
	@{ "UNLK              " link Unlk       }
	@{ "Local Stack Frames" link LocalStack }
@endnode

***********************************************************

@node LsD
@{b}NAME@{ub}
	LSL, LSR -- Logical shift left and logical shift right

@{b}SYNOPSIS@{ub}
	LSd	Dx,Dy
	LSd	#<data>,Dy
	LSd	<ea>
	where @{b}d@{ub} is directoin, L or R

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	Shift the bits of the operand in the specified direction.
	The carry bit set set to the last bit shifted out of the operand.
	The shift count for the shifting of a register may be specified in
	two different ways:

	1. Immediate - the shift count is specified in the instruction (shift
	               range 1-8).
	2. Register  - the shift count is contained in a data register
	               specified in the instruction (shift count mod 64)

	For a register, the size may be byte, word, or long, but for a memory
	location, the size must be a word.  The shift count is also restricted
	to one for a memory location.

@{b}RESULT@{ub}
	X - Set according to the last bit shifted out of the operand.
	N - Set if the result is negative.  Cleared otherwise.
	Z - Set if the result is zero.  Cleared otherwise.
	V - Always cleared
	C - Set according to the last bit shifted out of the operand.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node MOVE
@{b}NAME@{ub}
	MOVE -- Source -> Destination

@{b}SYNOPSIS@{ub}
	MOVE	<ea>,<ea>

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	Move the content of the source to the destination location.
	The data is examied as it is moved, and the condition codes
	set accordingly.

@{b}RESULT@{ub}
	X - Not affected.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero.  Cleared otherwise.
	V - Always cleared.
	C - Always cleared.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Movea
@{b}NAME@{ub}
	MOVEA -- Source -> Destination

@{b}SYNOPSIS@{ub}
	MOVEA	<ea>,An

	Size = (Word, Long)

@{b}FUNCTION@{ub}
	Move the content of the source to the destination address
	register.  Word sized operands are sign extended to 32 bits
	before the operation is done.

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
	@{"MOVE" Link Move} @{"LEA " Link Lea}
@endnode

***********************************************************

@node MoveFromCCR
@{b}NAME@{ub}
	MOVE from CCR -- CCR -> Destination

@{b}SYNOPSIS@{ub}
	MOVE	CCR,<ea>

	Size = (Word)

@{b}FUNCTION@{ub}
	The content of the status register is moved to the
	destination location.  The source operand is a word,
	but only the low order byte contains the condition
	codes.  The high order byte is set to all zeros.

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node MoveToCCR
@{b}NAME@{ub}
	MOVE to CCR -- Source -> CCR

@{b}SYNOPSIS@{ub}
	MOVE	<ea>,CCR

	Size = (Word)

@{b}FUNCTION@{ub}
	The content of the source operand is moved to the
	condition codes.  The source operand is a word, but
	only the low order byte is used to update the condition
	codes.  The high order byte is ignored.

@{b}RESULT@{ub}
	X - Set the same as bit 4 of the source operand.
	N - Set the same as bit 3 of the source operand.
	Z - Set the same as bit 2 of the source operand.
	V - Set the same as bit 1 of the source operand.
	C - Set the same as bit 0 of the source operand.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node MoveFromSR
@{b}NAME@{ub}
	MOVE from SR -- Move from status register (privileged)

@{b}SYNOPSIS@{ub}
	MOVE	SR,<ea>

	Size = (Word)

@{b}FUNCTION@{ub}
	The content of the status register is moved to the
	destination location.  The operand size is a word.

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node MoveToSR
@{b}NAME@{ub}
	MOVE to SR -- Move to status register (privileged)

@{b}SYNOPSIS@{ub}
	MOVE	<ea>,SR

	Size = (Word)

@{b}FUNCTION@{ub}
	The content of the source operand is moved to the
	status register.  The source operand size is a word
	and all bits of the status register are affected.

@{b}RESULT@{ub}

	X - Set the same as bit 4 of the source operand.
	N - Set the same as bit 3 of the source operand.
	Z - Set the same as bit 2 of the source operand.
	V - Set the same as bit 1 of the source operand.
	C - Set the same as bit 0 of the source operand.

@{b}SEE ALSO@{ub}
	@{"MOVE to CCR" Link MoveToCCR}
@endnode

***********************************************************

@node MoveUSP
@{b}NAME@{ub}
	MOVE USP -- Move to/from user stack pointer (privileged)

@{b}SYNOPSIS@{ub}
	MOVE	USP,An
	MOVE	An,USP

	Size = (Long)

@{b}FUNCTION@{ub}
	The contents of the user stack pointer are transferred
	either to or from the specified address register.

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Movec
@{b}NAME@{ub}
	MOVEC -- Move to/from control register

@{b}SYNOPSIS@{ub}
	MOVEC	Rc,Rn
	MOVEC	Rn,Rc

	Size = (Long)

@{b}FUNCTION@{ub}
	Copy the contents of the specified control register
	to the specified general register or copy from the
	general register to the control register.  This is
	always a 32-bit transfer even though the the control
	register may be implemented with fewer bits.

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Movem
@{b}NAME@{ub}
	MOVEM -- Move multiple registers

@{b}SYNOPSIS@{ub}
	MOVEM	register list,<ea>
	MOVEM	<ea>,register list

	Size = (Word, Long)

@{b}FUNCTION@{ub}
	Registers in the register list are either moved to or
	fetched from consecutive memory locations at the specified
	address.  Data can be either word or long word, but if
	the register list is destination and the size is word,
	each register is filled with the source word sign extended
	to 32-bits.

	Also, in the case that the register list is the destination,
	register indirect with predecrement is not a valid source
	mode.  If the register list is the source, then the
	destination may not be register indirect with postincrement.

		MOVEM.L	D0/D1/A0,(A2)+		; invalid
		MOVEM.W	-(A1),D5/D7/A4		; invalid

	The register list is accessed with D0 first through D7, followed
	by A0 through A7.

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Movep
@{b}NAME@{ub}
	MOVEP -- Move peripheral data

@{b}SYNOPSIS@{ub}
	MOVEP	Dx,(d,Ay)
	MOVEP	(d,Ay),Dx

	Size = (Word, Long)

@{b}FUNCTION@{ub}
	Data is transferred between a data register and ever-other
	byte of memory at the selected address. Example:

		LEA	port0,A0	; A0 -> $FFFFFFFFFFFFFFFF
		MOVEQ	#0,D0
		MOVEP.L	D0,(0,A0)	; A0 -> $FF00FF00FF00FF00
		MOVE.L	#$55554444,D0
		MOVEP.L	D0,(1,A0)	; A0 -> $FF55FF55FF44FF44

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Moveq
@{b}NAME@{ub}
	MOVEQ -- Move signed 8-bit data quick

@{b}SYNOPSIS@{ub}
	MOVEQ	#<data:8>,Dn

	Size = (Long)

@{b}FUNCTION@{ub}
	Move signed 8-bit data to the specified data register.
	The specified data is sign extended to 32-bits before
	it is moved to the register

@{b}RESULT@{ub}
	X - Not affected.
	N - Set if the result is negative.  Cleared otherwise.
	Z - Set if the result is zero.  Cleared otherwise.
	V - Always cleared.
	C - Always cleared.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Moves
@{b}NAME@{ub}
	MOVES -- Move address space (privileged)

@{b}SYNOPSIS@{ub}
	MOVES	Rn,<ea>
	MOVES	<ea>,Rn

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node MUL
@{b}NAME@{ub}
	MULS -- Signed multiply
	MULU -- Unsigned multiply

@{b}SYNOPSIS@{ub}
	MULS.W	<ea>,Dn		16*16->32
	MULS.L	<ea>,Dn		32*32->32	68020+
	MULS.L	<ea>,Dh:Dl	32*32->64	68020+

	MULU.W	<ea>,Dn		16*16->32
	MULU.L	<ea>,Dn		32*32->32	68020+
	MULU.L	<ea>,Dh:Dl	32*32->64	68020+

	Size = (Word)
	Size = (Word, Long)			68020+

@{b}FUNCTION@{ub}
	Multiply two signed (MULS) or unsigned (MULU) integers
	to produce either a signed or unsigned, respectivly,
	result.

	This instruction has three forms.  They are basically
	word, long word, and quad word.  The first version is
	the only one available on a processore lower than a
	68020.  It will multiply two 16-bit integers are produce
	a 32-bit result.  The second will multiply two 32-bit
	integers and produce a 32-bit result.

	The third form needs some special consideration.  It
	will multiply two 32-bit integers, specified by <ea>
	and Dl, the result is (sign) extended to 64-bits with
	the low order 32 being placed in Dl and the high order
	32 being placed in Dh.

@{b}RESULT@{ub}
	X - Not affected.
	N - Set if the result is negative.  Cleared otherwise.
	Z - Set if the result is zero.  Cleared otherwise.
	V - Set if overflow.  Cleared otherwise.
	C - Always cleared.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node NBCD
@{b}NAME@{ub}
	NBCD -- Negate binary coded decimal with extend

@{b}SYNOPSIS@{ub}
	NBCD	<ea>

	Size = (Byte)

@{b}FUNCTION@{ub}
	The specified BCD number and the extend bit are subtracted
	from zero.  Therefore, if the extend bit is set a nines
	complement is performed, else a tens complement is performed.
	The result is placed back in the specified <ea>.

	It can be use full to set the zero flag before performing
	this operation so that multi precision operations can
	be correctly tested for zero.

@{b}RESULT@{ub}
	X - Set the same as the carry bit.
	N - Undefined.
	Z - Cleared it the result is non-zero, unchanged otherwise.
	V - Undefined.
	C - Set if a borrow was generated, cleared otherwise.

@{b}SEE ALSO@{ub}
	@{"NEG" Link Neg} @{"NEGX" Link Negx}
@endnode

***********************************************************

@node Neg
@{b}NAME@{ub}
	NEG -- Negate

@{b}SYNOPSIS@{ub}
	NEG	<ea>

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	The operand specified by <ea> is subtracted from
	zero. The result is stored in <ea>.

@{b}RESULT@{ub}
	X - Set the same as the carry bit.
	N - Set if the result is negative, otherwise cleared.
	Z - Set if the result is zero, otherwise cleared.
	V - Set if overflow, otherwise cleared.
	C - Cleared if the result is zero, otherwise set.

@{b}SEE ALSO@{ub}
	@{"NBCD" Link Nbcd} @{"NEGX" Link Negx}
@endnode

***********************************************************

@node Negx
@{b}NAME@{ub}
	NEGX -- Negate with extend

@{b}SYNOPSIS@{ub}
	NEGX	<ea>

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	Perform an operation similar to a @{B}NEG@{ub}, with the
	exception that the operand and the extend bit are both
	subtracted from zero.  The result then being place in
	the given ea.

	As with @{b}ADDX@{ub}, @{b}SUBX@{ub}, @{b}ABCD@{ub},
	@{b}SBCD@{ub}, and @{b}NBCD@{ub}, it can be useful to set
	the zero flag before performing this operation so that
	multi precision operations can be tested for zero.

@{b}RESULT@{ub}
	X - Set the same as the carry bit.
	N - Set if the result is negative, otherwise cleared.
	Z - Cleared if the result is non-zero, otherwise unchanged.
	V - Set if an overflow is generated, cleared otherwise.
	C - Set if a borrow is generated, otherwise cleared.

@{b}SEE ALSO@{ub}
	@{"NEG" Link Neg} @{"NBCD" Link Nbcd} @{"ADDX" Link Addx} @{"SUBX" Link Subx}
@endnode

***********************************************************

@node Nop
@{b}NAME@{ub}
	NOP -- No operation

@{b}SYNOPSIS@{ub}
	NOP

@{b}FUNCTION@{ub}
	Nothing happens! Well, sort of.  This instruction will
	basically wait until all pending bus activity is
	completed.  This allows synchronization of the pipeline
	and prevents instruction overlap.

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Not
@{b}NAME@{ub}
	NOT -- Logical complement

@{b}SYNOPSIS@{ub}
	NOT	<ea>

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	All bits of the specified operand are inverted and placed
	back in the operand.

@{b}RESULT@{ub}
	X - Not affected.
	N - Set if the result is negative, otherwise cleared.
	Z - Set if the result is zero, otherwise cleared.
	V - Always cleared.
	C - Always cleared.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Or
@{b}NAME@{ub}
	OR -- Logical OR

@{b}SYNOPSIS@{ub}
	OR	Dn,<ea>

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	Performs an OR operation on the destination operand
	with the source operand.

@{b}RESULT@{ub}
	X - Not Affected
	N - Set to the value of the most significant bit.
	Z - Set if the result is zero.
	V - Always cleared
	C - Always cleared
	
@{b}SEE ALSO@{ub}
	@{"ORI" link Ori} @{"BSET" link Bset}
@endnode

***********************************************************

@node Ori
@{b}NAME@{ub}
	ORI -- Logical OR immediate

@{b}SYNOPSIS@{ub}
	ORI	#<data>,<ea>

	Size = (Byte, Word, Long)

@{b}FUNCTION@{ub}
	Performs an OR operation on the destination operand
	with the source operand.

@{b}RESULT@{ub}
	X - Not Affected
	N - Set to the value of the most significant bit.
	Z - Set if the result is zero.
	V - Always cleared
	C - Always cleared
	
@{b}SEE ALSO@{ub}
	@{ "OR  " link Eor  } @{ "ORI to CCR" link oriCCR } @{ "ORI to SR" link oriSR }
	@{ "BSET" link Bchg }

@endnode

***********************************************************

@node OriCCR
@{b}NAME@{ub}
	ORI to CCR -- Logical OR immediate to the condition code register

@{b}SYNOPSIS@{ub}
	ORI	#<data>,CCR

	Size = (Byte)

@{b}FUNCTION@{ub}
	Performs an OR operation on the condition codes
	register with the source operand.

@{b}RESULT@{ub}
	X - Set if bit 4 of the source is set, cleared otherwise.
	N - Set if bit 3 of the source is set, cleared otherwise.
	Z - Set if bit 2 of the source is set, cleared otherwise.
	V - Set if bit 1 of the source is set, cleared otherwise.
	C - Set if bit 0 of the source is set, cleared otherwise.
	
@{b}SEE ALSO@{ub}
	@{ "OR " link or  } @{ "ORI" link ori } @{ "ORI to SR" link oriSR }
@endnode

***********************************************************

@node OriSR
@{b}NAME@{ub}
	ORI to SR -- Logical OR immediated to the status register (privileged)

@{b}SYNOPSIS@{ub}
	ORI	#<data>,SR

	Size = (Word)

@{b}FUNCTION@{ub}
	Performs an OR operation on the status register with
	the source operand, and leaves the result in the status
	register.

@{b}RESULT@{ub}
	X - Set if bit 4 of the source is set, cleared otherwise.
	N - Set if bit 3 of the source is set, cleared otherwise.
	Z - Set if bit 2 of the source is set, cleared otherwise.
	V - Set if bit 1 of the source is set, cleared otherwise.
	C - Set if bit 0 of the source is set, cleared otherwise.
	
@{b}SEE ALSO@{ub}
	@{"OR " link or } @{"ORI" link Eori} @{"ORI to CCR" link oriCCR}
@endnode

***********************************************************

@node
@{b}NAME@{ub}
	PACK -- Pack binary coded decimal	(68020+)

@{b}SYNOPSIS@{ub}
	PACK	-(Ax),-(Ay),#<adjustment>
	PACK	Dx,Dy,#<adjustment>

@{b}FUNCTION@{ub}
	Convert byte-per-digit unpacked BCD to packed two-digit-
	per-byte BCD.

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node
@{b}NAME@{ub}
	PEA -- Push effective address

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node
@{b}NAME@{ub}
	RESET -- Reset external devices

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node ROd
@{b}NAME@{ub}
	ROL, ROR -- Rotate left and rotate right

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	X -
	N -
	Z -
	V -
	C -

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Roxd
@{b}NAME@{ub}
	ROXL, ROXD -- Rotate left with extend and rotate right with extend

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	X -
	N -
	Z -
	V -
	C -

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Rtd
@{b}NAME@{ub}
	RTD -- Return and deallocate parameter stack frame	(68010+)

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Rte
@{b}NAME@{ub}
	RTE -- Return from exception

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Rtm
@{b}NAME@{ub}
	RTM -- Return from process module	(68020 only)

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Rtr
@{b}NAME@{ub}
	RTR -- Return and restore condition code register

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Rts
@{b}NAME@{ub}
	RTS -- Return from subroutine

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Sbcd
@{b}NAME@{ub}
	SBCD -- Subtract binary coded decimal with extend

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	X -
	N -
	Z -
	V -
	C -

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Scc
@{b}NAME@{ub}
	Scc -- Conditional set

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Stop
@{b}NAME@{ub}
	STOP -- Stop processor execution (privileged)

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Sub
@{b}NAME@{ub}
	SUB -- Subtract

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	X -
	N -
	Z -
	V -
	C -

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Suba
@{b}NAME@{ub}
	SUBA -- Subtract address

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Subi
@{b}NAME@{ub}
	SUBI -- Subtract immediate

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	X -
	N -
	Z -
	V -
	C -

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Subq
@{b}NAME@{ub}
	SUBQ -- Subtract 3-bit immediate quick

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	X -
	N -
	Z -
	V -
	C -

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Subx
@{b}NAME@{ub}
	SUBX -- Subtract with extend

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	X -
	N -
	Z -
	V -
	C -

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Swap
@{b}NAME@{ub}
	SWAP -- Swap register upper and lower words

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	X -
	N -
	Z -
	V -
	C -

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Tas
@{b}NAME@{ub}
	TAS -- Test and set operand

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	X -
	N -
	Z -
	V -
	C -

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Trap
@{b}NAME@{ub}
	TRAP -- Initiate processor trap

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Trapcc
@{b}NAME@{ub}
	TRAPcc -- Conditional trap		(68020+)
	TRAPv  -- Trap on overflow

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Tst
@{b}NAME@{ub}
	TST -- Test operand for zero

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	X -
	N -
	Z -
	V -
	C -

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Unlk
@{b}NAME@{ub}
	UNLK -- Free stack frame created by LINK

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Unpk
@{b}NAME@{ub}
	UNPK -- Unpack binary coded decimal	(68020+)

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node Exceptions
@{b}NAME@{ub}
	Processor exception initiation and handling

@{b}SYNOPSIS@{ub}

@{b}FUNCTION@{ub}

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
@endnode

***********************************************************

@node LocalStack
@{b}NAME@{ub}
	Local stack frame maintaince

@{b}SYNOPSIS@{ub}
		LINK	An,#<data>
		...
		UNLK	An
		RTS

@{b}FUNCTION@{ub}
	The use of a local stack frame is critically important to the
	programmer who wishes to write re-entrant or recursive functions.
	The creation of a local stack frame on the MC680x0 family is done
	through the use of the LINK and UNLK instructions.  The LINK
	instruction saves the frame pointer onto the stack, and places a
	pointer to the new stack frame in it.  The UNLK instruction
	restores the old stack frame.  For example:

		link	a5,#-8		; a5 is chosen to be the frame
					; pointer.  8 bytes of local stack
					; frame are allocated.
		...
		unlk	a5		; a5, the old frame pointer, and the
					; old SP are restored.

	Since the LINK and UNLK instructions maintain both the frame pointer
	and the stack pointer, the following code segment is perfectly
	legal:

		link	a5,#-4

		movem.l	d0-a4,-(sp)
		pea	(500).w
		move.l	d2,-(sp)
		bsr.b	Routine

		unlk	a5
		rts

@{b}RESULT@{ub}
	None.

@{b}SEE ALSO@{ub}
	@{ "LINK" link Link } @{ "UNLK" link Unlk }
@endnode

***********************************************************
