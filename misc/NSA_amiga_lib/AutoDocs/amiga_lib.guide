@DATABASE "amiga_lib.guide"
@AUTHOR AmiS <amis@amiga.org.ru> © 1998-2002
@INDEX ".Index.guide/Main"
@WORDWRAP
@$VER: amiga_lib 40.15 autodocs 1.2
@HELP help

@NODE Help "Copyright 1998-2002 AmiS"
 @{fg shine}amiga_lib 40.15@{fg text}  Version 1.2
 This is a NewStyle Autodocs for Amiga Developer Community.

 Designed 1999-2002 by @{fg shine}AmiS@{fg text}
 Send your bug report to @{fg fill}amis@amiga.org.ru@{fg text}

@ENDNODE

@NODE Main "amiga.lib"
@PREV Main
@{jcenter}@{b} A @{ub}@{" B " LINK MainB 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" H " LINK MainH 0}@{" I " LINK MainI 0}@{" N " LINK MainN 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" T " LINK MainT 0}@{" pools.lib " LINK MainPools 0}
@{jcenter}
@{u}@{b}amiga.lib@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}A@{ub}@{lindent 4}
@{lindent 27}@{" ACrypt()         " LINK "ACrypt"}  - encrypt a password  @{fg shine}(V37)@{fg text}@{lindent 4}
@{lindent 27}@{" AddTOF()         " LINK "AddTOF"}  - add a task to the VBlank interrupt server chain.@{lindent 4}
@{lindent 27}@{" afp()            " LINK "afp"}  - convert ASCII string variable into fast floating point@{lindent 4}
@{lindent 27}@{" ArgArrayDone()   " LINK "ArgArrayDone"}  - release the memory allocated by @{fg fill}ArgArrayInit()@{fg text}.  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 27}@{" ArgArrayInit()   " LINK "ArgArrayInit"}  - allocate and initialize a tooltype array.  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 27}@{" ArgInt()         " LINK "ArgInt"}  - return an integer value from a ToolTypes array.  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 27}@{" ArgString()      " LINK "ArgString"}  - return a string pointer from a ToolTypes array.  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 27}@{" arnd()           " LINK "arnd"}  - ASCII round of the provided floating point string
@ENDNODE

@NODE MainB "amiga.lib"
@{jcenter}@{" A " LINK Main 0}@{b} B @{ub}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" H " LINK MainH 0}@{" I " LINK MainI 0}@{" N " LINK MainN 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" T " LINK MainT 0}@{" pools.lib " LINK MainPools 0}
@{jcenter}
@{u}@{b}amiga.lib@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}B@{ub}@{lindent 4}
@{lindent 27}@{" BeginIO()        " LINK "BeginIO"}  - initiate asynchronous device I/O
@ENDNODE

@NODE MainC "amiga.lib"
@{jcenter}@{" A " LINK Main 0}@{" B " LINK MainB 0}@{b} C @{ub}@{" D " LINK MainD 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" H " LINK MainH 0}@{" I " LINK MainI 0}@{" N " LINK MainN 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" T " LINK MainT 0}@{" pools.lib " LINK MainPools 0}
@{jcenter}
@{u}@{b}amiga.lib@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}C@{ub}@{lindent 4}
@{lindent 27}@{" CallHook()       " LINK "CallHook"}  - invoke a hook given a message on the stack.@{lindent 4}
@{lindent 27}@{" CallHookA()      " LINK "CallHookA"}  - invoke a hook given a pointer to a message.@{lindent 4}
@{lindent 27}@{" CheckRexxMsg()   " LINK "CheckRexxMsg"}  - check if a RexxMsg is from ARexx@{lindent 4}
@{lindent 27}@{" CoerceMethod()   " LINK "CoerceMethod"}  - perform method on coerced object.@{lindent 4}
@{lindent 27}@{" CoerceMethodA()  " LINK "CoerceMethodA"}  - perform method on coerced object.@{lindent 4}
@{lindent 27}@{" CreateExtIO()    " LINK "CreateExtIO"}  - create an IORequest structure@{lindent 4}
@{lindent 27}@{" CreatePort()     " LINK "CreatePort"}  - allocate and initialize a new message port@{lindent 4}
@{lindent 27}@{" CreateStdIO()    " LINK "CreateStdIO"}  - create an IOStdReq structure@{lindent 4}
@{lindent 27}@{" CreateTask()     " LINK "CreateTask"}  - create task with given name, priority, stacksize@{lindent 4}
@{lindent 27}@{" CxCustom()       " LINK "CxCustom"}  - create a custom commodity object.  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 27}@{" CxDebug()        " LINK "CxDebug"}  - create a commodity debug object.  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 27}@{" CxFilter()       " LINK "CxFilter"}  - create a commodity filter object.  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 27}@{" CxSender()       " LINK "CxSender"}  - create a commodity sender object.  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 27}@{" CxSignal()       " LINK "CxSignal"}  - create a commodity signaller object.  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 27}@{" CxTranslate()    " LINK "CxTranslate"}  - create a commodity translator object.  @{fg shine}(V36)@{fg text}
@ENDNODE

@NODE MainD "amiga.lib"
@{jcenter}@{" A " LINK Main 0}@{" B " LINK MainB 0}@{" C " LINK MainC 0}@{b} D @{ub}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" H " LINK MainH 0}@{" I " LINK MainI 0}@{" N " LINK MainN 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" T " LINK MainT 0}@{" pools.lib " LINK MainPools 0}
@{jcenter}
@{u}@{b}amiga.lib@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}D@{ub}@{lindent 4}
@{lindent 27}@{" dbf()            " LINK "dbf"}  - convert FFP dual-binary number to FFP format@{lindent 4}
@{lindent 27}@{" DeleteExtIO()    " LINK "DeleteExtIO"}  - return memory allocated for extended IO request@{lindent 4}
@{lindent 27}@{" DeletePort()     " LINK "DeletePort"}  - free a message port created by @{fg fill}CreatePort()@{fg text}@{lindent 4}
@{lindent 27}@{" DeleteStdIO()    " LINK "DeleteStdIO"}  - return memory allocated for IOStdReq@{lindent 4}
@{lindent 27}@{" DeleteTask()     " LINK "DeleteTask"}  - delete a task created with CreateTask()@{lindent 4}
@{lindent 27}@{" DoMethod()       " LINK "DoMethod"}  - perform method on object.@{lindent 4}
@{lindent 27}@{" DoMethodA()      " LINK "DoMethodA"}  - perform method on object.@{lindent 4}
@{lindent 27}@{" DoSuperMethod()  " LINK "DoSuperMethod"}  - perform method on object coerced to superclass.@{lindent 4}
@{lindent 27}@{" DoSuperMethodA() " LINK "DoSuperMethodA"}  - perform method on object coerced to superclass.
@ENDNODE

@NODE MainF "amiga.lib"
@{jcenter}@{" A " LINK Main 0}@{" B " LINK MainB 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{b} F @{ub}@{" G " LINK MainG 0}@{" H " LINK MainH 0}@{" I " LINK MainI 0}@{" N " LINK MainN 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" T " LINK MainT 0}@{" pools.lib " LINK MainPools 0}
@{jcenter}
@{u}@{b}amiga.lib@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}F@{ub}@{lindent 4}
@{lindent 27}@{" FastRand()       " LINK "FastRand"}  - quickly generate a somewhat random integer@{lindent 4}
@{lindent 27}@{" fpa()            " LINK "fpa"}  - convert fast floating point into ASCII string equivalent@{lindent 4}
@{lindent 27}@{" FreeIEvents()    " LINK "FreeIEvents"}  - free a chain of input events allocated by @{fg fill}InvertString()@{fg tetx}.  @{fg shine}(V36)@{fg text}
@ENDNODE

@NODE MainG "amiga.lib"
@{jcenter}@{" A " LINK Main 0}@{" B " LINK MainB 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" F " LINK MainF 0}@{b} G @{ub}@{" H " LINK MainH 0}@{" I " LINK MainI 0}@{" N " LINK MainN 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" T " LINK MainT 0}@{" pools.lib " LINK MainPools 0}
@{jcenter}
@{u}@{b}amiga.lib@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}G@{ub}@{lindent 4}
@{lindent 27}@{" GetRexxVar()     " LINK "GetRexxVar"}  - gets the value of a variable from a running ARexx program
@ENDNODE

@NODE MainH "amiga.lib"
@{jcenter}@{" A " LINK Main 0}@{" B " LINK MainB 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{b} H @{ub}@{" I " LINK MainI 0}@{" N " LINK MainN 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" T " LINK MainT 0}@{" pools.lib " LINK MainPools 0}
@{jcenter}
@{u}@{b}amiga.lib@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}H@{ub}@{lindent 4}
@{lindent 27}@{" HookEntry()      " LINK "HookEntry"}  - assembler to HLL conversion stub for hook entry.@{lindent 4}
@{lindent 27}@{" HotKey()         " LINK "HotKey"}  - create a commodity triad.  @{fg shine}(V36)@{fg text}
@ENDNODE

@NODE MainI "amiga.lib"
@{jcenter}@{" A " LINK Main 0}@{" B " LINK MainB 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" H " LINK MainH 0}@{b} I @{ub}@{" N " LINK MainN 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" T " LINK MainT 0}@{" pools.lib " LINK MainPools 0}
@{jcenter}
@{u}@{b}amiga.lib@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}I@{ub}@{lindent 4}
@{lindent 27}@{" InvertString()   " LINK "InvertString"}  - produce input events that would generate the given string.  @{fg shine}(V36)@{fg text}
@ENDNODE

@NODE MainN "amiga.lib"
@{jcenter}@{" A " LINK Main 0}@{" B " LINK MainB 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" H " LINK MainH 0}@{" I " LINK MainI 0}@{b} N @{ub}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" T " LINK MainT 0}@{" pools.lib " LINK MainPools 0}
@{jcenter}
@{u}@{b}amiga.lib@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}N@{ub}@{lindent 4}
@{lindent 27}@{" NewList()        " LINK "NewList"}  - prepare a list structure for use
@ENDNODE

@NODE MainP "amiga.lib"
@{jcenter}@{" A " LINK Main 0}@{" B " LINK MainB 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" H " LINK MainH 0}@{" I " LINK MainI 0}@{" N " LINK MainN 0}@{b} P @{ub}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" T " LINK MainT 0}@{" pools.lib " LINK MainPools 0}
@{jcenter}
@{u}@{b}amiga.lib@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}P@{ub}@{lindent 4}
@{lindent 27}@{" printf()         " LINK "printf"}  - print a formatted output line to the standard output.
@ENDNODE

@NODE MainR "amiga.lib"
@{jcenter}@{" A " LINK Main 0}@{" B " LINK MainB 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" H " LINK MainH 0}@{" I " LINK MainI 0}@{" N " LINK MainN 0}@{" P " LINK MainP 0}@{b} R @{ub}@{" S " LINK MainS 0}@{" T " LINK MainT 0}@{" pools.lib " LINK MainPools 0}
@{jcenter}
@{u}@{b}amiga.lib@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}R@{ub}@{lindent 4}
@{lindent 27}@{" RangeRand()      " LINK "RangeRand"}  - generate a random number within a specific integer range@{lindent 4}
@{lindent 27}@{" RemTOF()         " LINK "RemTOF"}  - remove a task from the VBlank interrupt server chain.
@ENDNODE

@NODE MainS "amiga.lib"
@{jcenter}@{" A " LINK Main 0}@{" B " LINK MainB 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" H " LINK MainH 0}@{" I " LINK MainI 0}@{" N " LINK MainN 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{b} S @{ub}@{" T " LINK MainT 0}@{" pools.lib " LINK MainPools 0}
@{jcenter}
@{u}@{b}amiga.lib@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}S@{ub}@{lindent 4}
@{lindent 27}@{" SetRexxVar()     " LINK "SetRexxVar"}  - sets the value of a variable of a running ARexx program@{lindent 4}
@{lindent 27}@{" SetSuperAttrs()  " LINK "SetSuperAttrs"}  - invoke OM_SET method on superclass with varargs.@{lindent 4}
@{lindent 27}@{" sprintf()        " LINK "sprintf"}  - format a C-like string into a string buffer.@{lindent 4}
@{lindent 27}@{" stdio()          " LINK "stdio"}  - fclose(), fgetc(), fprintf(), fputc(), fputs(), getchar(), printf(), putchar(), puts()
@ENDNODE

@NODE MainT "amiga.lib"
@{jcenter}@{" A " LINK Main 0}@{" B " LINK MainB 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" H " LINK MainH 0}@{" I " LINK MainI 0}@{" N " LINK MainN 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{b} T @{ub}@{" pools.lib " LINK MainPools 0}
@{jcenter}
@{u}@{b}amiga.lib@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}T@{ub}@{lindent 4}
@{lindent 27}@{" TimeDelay()      " LINK "TimeDelay"}  - return after a period of time has elapsed.
@ENDNODE

@NODE MainPools "pools.lib"
@NEXT MainPools
@{jcenter}@{" A " LINK Main 0}@{" B " LINK MainB 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" H " LINK MainH 0}@{" I " LINK MainI 0}@{" N " LINK MainN 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" T " LINK MainT 0}@{b} pools.lib @{ub}
@{jcenter}
@{u}@{b}pools.lib@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}Pools@{ub}@{lindent 4}
@{lindent 27}@{" LibAllocPooled() " LINK "LibAllocPooled"}  - allocate memory with the pool manager  @{fg shine}(V33)@{fg text}@{lindent 4}@{lindent 4}
@{lindent 27}@{" LibCreatePool()  " LINK "LibCreatePool"}  - generate a private memory pool header  @{fg shine}(V33)@{fg text}@{lindent 4}@{lindent 4}
@{lindent 27}@{" LibDeletePool()  " LINK "LibDeletePool"}  - drain an entire memory pool  @{fg shine}(V33)@{fg text}@{lindent 4}@{lindent 4}
@{lindent 27}@{" LibFreePooled()  " LINK "LibFreePooled"}  - free pooled memory   @{fg shine}(V33)@{fg text}
@ENDNODE

@NODE "ACrypt" "amiga.lib/ACrypt()"
@PREV ACrypt
@{jcenter}
@{u}@{b}ACrypt()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ACrypt - Encrypt a password  @{fg shine}(V37)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
newpass = ACcrypt( buffer, password, username )

STRPTR ACrypt( STRPTR, STRPTR, STRPTR);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function takes a buffer of at least 12 characters in length, an unencrypted password and the user's name (as known to the host system) and returns an encrypted password in the passed buffer. This is a one-way encryption. Normally, the user's encrypted password is stored in a file for future password comparison.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 21}buffer     - a pointer to a buffer at least 12 bytes in length.@{lindent 8}
@{lindent 21}password   - a pointer to an unencrypted password string.@{lindent 8}
@{lindent 21}username   - a pointer to the user's name.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 21}newpass    - a pointer to the passed buffer if successful, NULL upon failure. The encrypted password placed in the buffer will be be eleven (11) characters in length and will be NULL-terminated.
@{lindent 4}
@{fg shine}@{b}EXAMPLE@{ub}@{fg text}@{lindent 8}

@{"UBYTE" LINK "include:exec/types.h/MAIN" 21} *pw, *getpassword();
@{"UBYTE" LINK "include:exec/types.h/MAIN" 21} *user = "alf";
@{"UBYTE" LINK "include:exec/types.h/MAIN" 21} *newpass;
@{"UBYTE" LINK "include:exec/types.h/MAIN" 21} buffer[16];         /* size >= 12 */

pw = getpassword();   /* your own function */

if((newpass = ACrypt(buffer, pw, user)) != NULL)
{
    @{"printf" LINK "printf" 0}("pw = %s\\n", newpass); /* newpass = &buffer[0] */
}
else
{
    @{"printf" LINK "printf" 0}("ACrypt failed\\n");
}
@{lindent 4}
@{fg shine}@{b}NOTES@{ub}@{fg text}@{lindent 8}
This function first appeared in later @{fg shine}V39@{fg text} versions of amiga.lib, but works under @{fg shine}V37@{fg text} and up.
@ENDNODE

@NODE "AddTOF" "amiga.lib/AddTOF()"
@{jcenter}
@{u}@{b}AddTOF()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
AddTOF - add a task to the VBlank interrupt server chain.
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
AddTOF(i,p,a);

VOID AddTOF(struct @{"Isrvstr" LINK "include:graphics/graphint.h/MAIN" 17} *, APTR, APTR);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Adds a task to the vertical-blanking interval interrupt server chain. This prevents C programmers from needing to write an assembly language stub to do this function.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 12}i - pointer to an initialized Isrvstr structure@{lindent 8}
@{lindent 12}p - pointer to the C-code routine that this server is to call each time TOF happens@{lindent 8}
@{lindent 12}a - pointer to the first longword in an array of longwords that is to be used as the arguments passed to your routine pointed to by p.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"RemTOF()" LINK "RemTOF" 0}, <@{"graphics/graphint.h" LINK "include:graphics/graphint.h/MAIN" 0}>
@ENDNODE

@NODE "afp" "amiga.lib/afp()"
@{jcenter}
@{u}@{b}afp()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
afp - Convert ASCII string variable into fast floating point
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
ffp_value = afp(string);
@{lindent 4}
@{fg shine}@{b} FUNCTION@{ub}@{fg text}@{lindent 8}
Accepts the address of the ASCII string in C format that is converted into an FFP floating point number.

The string is expected in this Format:

{S}{digits}{'.'}{digits}{'E'}{S}{digits}
<*******MANTISSA*******><***EXPONENT***>


Syntax rules:
Both signs are optional and are '+' or '-'. The mantissa must be present. The exponent need not be present. The mantissa may lead with a decimal point. The mantissa need not have a decimal point.
Examples: All of these values represent the number fourty-two.
@{lindent 16}
     42            .042e3
     42.          +.042e+03
    +42.          0.000042e6
0000042.00       420000e-4
             420000.00e-0004
@{lindent 8}
Floating point range:
Fast floating point supports the value zero and non-zero values within the following bounds -
@{lindent 16}
                18                             20
 9.22337177 x 10   > +number >  5.42101070 x 10
                18                             -20
-9.22337177 x 10   > -number > -2.71050535 x 10
@{lindent 8}
Precision:
This conversion results in a 24 bit precision with guaranteed error less than or equal to one-half least significant bit.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
string - Pointer to the ASCII string to be converted.
@{lindent 4}
@{fg shine}@{b}OUTPUTS@{ub}@{fg text}@{lindent 8}
string - points to the character which terminated the scan
equ - fast floating point equivalent
@ENDNODE

@NODE "ArgArrayDone" "amiga.lib/ArgArrayDone()"
@{jcenter}
@{u}@{b}ArgArrayDone()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ArgArrayDone - release the memory allocated by a previous call to @{"ArgArrayInit()" LINK "ArgArrayInit" 0}.  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
ArgArrayDone();

VOID ArgArrayDone(VOID);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function frees memory and does cleanup required after a call to @{"ArgArrayInit()" LINK "ArgArrayInit" 0}. Don't call this until you are done using the ToolTypes argument strings.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"ArgArrayInit()" LINK "ArgArrayInit" 0}
@ENDNODE

@NODE "ArgArrayInit" "amiga.lib/ArgArrayInit()"
@{jcenter}
@{u}@{b}ArgArrayInit()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ArgArrayInit - allocate and initialize a tooltype array.  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
ttypes = ArgArrayInit(argc,argv);

@{"UBYTE" LINK "include:exec/types.h/MAIN" 21} **ArgArrayInit(LONG,@{"UBYTE" LINK "include:exec/types.h/MAIN" 21} **);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function returns a null-terminated array of strings suitable for sending to @{"icon.library/FindToolType()" LINK "icon.guide/FindToolType" 0}. This array will be the ToolTypes array of the program's icon, if it was started from Workbench. It will just be 'argv' if the program was started from a shell.

Pass ArgArrayInit() your startup arguments received by main().

ArgArrayInit() requires that icon.library be open (even if the caller was started from a shell, so that the function @{"FindToolType()" LINK "icon.guide/FindToolType" 0} can be used) and may call @{"GetDiskObject()" LINK "icon.guide/GetDiskObject" 0}, so clean up is necessary when the strings are no longer needed. The function @{"ArgArrayDone()" LINK "ArgArrayDone" 0} does just that.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 15}argc - the number of arguments in argv, 0 when started from Workbench@{lindent 8}
@{lindent 15}argv - an array of pointers to the program's arguments, or the Workbench startup message when started from WB.
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
@{lindent 17}ttypes - the initialized argument array or NULL if it could not be allocated
@{lindent 4}
@{fg shine}@{b}EXAMPLE@{ub}@{fg text}@{lindent 8}
Use of these routines facilitates the use of ToolTypes or command-line arguments to control end-user parameters in Commodities applications. For example, a filter used to trap a keystroke for popping up a window might be created by something like this:
@{lindent 12}
char   *ttypes  = ArgArrayInit(argc, argv);
@{"CxObj" LINK "include:libraries/commodities.h/MAIN" 74}   *filter = UserFilter(ttypes, "POPWINDOW", "alt f1");

... with ...

@{"CxObj" LINK "include:libraries/commodities.h/MAIN" 74} *UserFilter(char **tt, char *action_name, char *default_descr)
{
    char *desc;

    desc = @{"FindToolType" LINK "icon.guide/FindToolType" 0}(tt,action_name);

    return(@{"CxFilter" LINK "CxFilter" 0}((ULONG)(desc ? desc : default_descr)));
}
@{lindent 8}
In this way the user can assign "alt f2" to the action by entering a tooltype in the program's icon of the form:
@{lindent 12}
POPWINDOW=alt f2
@{lindent 8}
or by starting the program from the CLI like so:
@{lindent 12}
myprogram "POPWINDOW=alt f2"
@{lindent 4}
@{fg shine}@{b}NOTE@{ub}@{fg text}@{lindent 8}
Your program must open icon.library and set up IconBase before calling this routine. In addition IconBase must remain valid until after @{"ArgArrayDone()" LINK "ArgArrayDone" 0} has been called!
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"ArgArrayDone()" LINK "ArgArrayDone" 0}, @{"ArgString()" LINK "ArgString" 0}, @{"ArgInt()" LINK "ArgInt" 0}, @{"icon.library/FindToolType()" LINK "icon.guide/FindToolType" 0}
@ENDNODE

@NODE "ArgInt" "amiga.lib/ArgInt()"
@{jcenter}
@{u}@{b}ArgInt()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ArgInt - return an integer value from a ToolTypes array.  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
value = ArgInt(tt,entry,defaultval)

LONG ArgInt(@{"UBYTE" LINK "include:exec/types.h/MAIN" 21} **,STRPTR,LONG);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function looks in the ToolTypes array 'tt' returned by @{"ArgArrayInit()" LINK "ArgArrayInit" 0} for 'entry' and returns the value associated with it. 'tt' is in standard ToolTypes format such as:
@{lindent 12}
ENTRY=Value
@{lindent 8}
The Value string is passed to atoi() and the result is returned by this function.

If 'entry' is not found, the integer 'defaultval' is returned.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
tt - a ToolTypes array as returned by @{"ArgArrayInit()" LINK "ArgArrayInit" 0}
entry - the entry in the ToolTypes array to search for
@{lindent 21}defaultval - the value to return in case 'entry' is not found within the ToolTypes array
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
@{lindent 16}value - the value associated with 'entry', or defaultval if 'entry' is not in the ToolTypes array
@{lindent 4}
@{fg shine}@{b}NOTES@{ub}@{fg text}@{lindent 8}
This function requires that dos.library @{fg shine}V36@{fg text} or higher be opened.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"ArgArrayInit()" LINK "ArgArrayInit" 0}
@ENDNODE

@NODE "ArgString" "amiga.lib/ArgString()"
@{jcenter}
@{u}@{b}ArgString()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ArgString - return a string pointer from a ToolTypes array.  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
string = ArgString(tt,entry,defaultstring)

STRPTR ArgString(@{"UBYTE" LINK "include:exec/types.h/MAIN" 21} **,STRPTR,STRPTR);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function looks in the ToolTypes array 'tt' returned by @{"ArgArrayInit()" LINK "ArgArrayInit" 0} for 'entry' and returns the value associated with it. 'tt' is in standard ToolTypes format such as:
@{lindent 12}
ENTRY=Value
@{lindent 8}
This function returns a pointer to the Value string.

If 'entry' is not found, 'defaultstring' is returned.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
tt - a ToolTypes array as returned by @{"ArgArrayInit()" LINK "ArgArrayInit" 0}
entry - the entry in the ToolTypes array to search for
@{lindent 24}defaultstring - the value to return in case 'entry' is not found within the ToolTypes array
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
@{lindent 16}value - the value associated with 'entry', or defaultstring if 'entry' is not in the ToolTypes array
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"ArgArrayInit()" LINK "ArgArrayInit" 0}
@ENDNODE

@NODE "arnd" "amiga.lib/arnd()"
@{jcenter}
@{u}@{b}arnd()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
arnd - ASCII round of the provided floating point string
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
arnd(place, exp, &string[0]);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Accepts an ASCII string representing an FFP floating point number, the binary representation of the exponent of said floating point number and the number of places to round to. A rounding process is initiated, either to the left or right of the decimal place and the result placed back at the input address defined by &string[0].
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 16}place - integer representing number of decimal places to round to@{lindent 8}
@{lindent 14}exp - integer representing exponent value of the ASCII string@{lindent 8}
@{lindent 21}&string[0] - address where rounded ASCII string is to be placed (16 bytes)
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
&string[0] - rounded ASCII string
@ENDNODE

@NODE "BeginIO" "amiga.lib/BeginIO()"
@{jcenter}
@{u}@{b}BeginIO()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
BeginIO - initiate asynchronous device I/O
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
BeginIO(ioReq)

VOID BeginIO(struct @{"IORequest" LINK "include:exec/io.h/MAIN" 17} *);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function takes an @{"IORequest" LINK "include:exec/io.h/MAIN" 17}, and passes it directly to the "BeginIO" vector of the proper device. This is equivalent to @{"SendIO()" LINK "exec.guide/SendIO" 0}, except that io_Flags is not cleared. A good understanding of Exec device I/O is required to properly use this function.

This function does not wait for the I/O to complete.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 16}ioReq - an initialized and opened @{"IORequest" LINK "include:exec/io.h/MAIN" 17} structure with the io_Flags field set to a reasonable value (set to 0 if you do not require io_Flags).
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"exec.library/DoIO()" LINK "exec.guide/DoIO" 0}, @{"exec.library/SendIO()" LINK "exec.guide/SendIO" 0}, @{"exec.library/WaitIO()" LINK "exec.guide/WaitIO" 0}
@ENDNODE

@NODE "CallHook" "amiga.lib/CallHook()"
@{jcenter}
@{u}@{b}CallHook()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CallHook - Invoke a hook given a message on the stack.
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
result = CallHook( hookPtr, obj, ... )

ULONG CallHook( struct @{"HOOK" LINK "include:utility/hooks.h/MAIN"} *, Object *, ... );
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Like @{"CallHookA()" LINK "CallHookA" 0}, CallHook() invoke a hook on the supplied hook-specific data (an "object") and a parameter packet ("message"). However, CallHook() allows you to build the message on your stack.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
hookPtr - A system-standard hook
obj - hook-specific data object
@{lindent 14}... - The hook-specific message you wish to send. The hook is expecting a pointer to the message, so a pointer into your stack will be sent.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
result - a hook-specific result.
@{lindent 4}
@{fg shine}@{b}NOTES@{ub}@{fg text}@{lindent 8}
This function first appeared in the @{fg shine}V37@{fg text} release of amiga.lib. However, it does not depend on any particular version of the OS, and works fine even in @{fg shine}V34@{fg text}.
@{lindent 4}
@{fg shine}@{b}EXAMPLE@{ub}@{fg text}@{lindent 8}
If your hook's message was
@{lindent 12}
struct myMessage
{
    ULONG mm_FirstGuy;
    ULONG mm_SecondGuy;
    ULONG mm_ThirdGuy;
};
@{lindent 8}
You could write:
@{lindent 12}
result = CallHook( hook, obj, firstguy, secondguy, thirdguy );
@{lindent 8}
as a shorthand for:
@{lindent 12}
struct myMessage msg;

msg.mm_FirstGuy = firstguy;
msg.mm_SecondGuy = secondguy;
msg.mm_ThirdGuy = thirdguy;

result = @{"CallHookA" LINK "CallHookA" 0}( hook, obj, &msg );
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CallHookA()" LINK "CallHookA" 0}, @{"utility.library/CallHookPkt()" LINK "utility.guide/CallHookPkt" 0}, <@{"utility/hooks.h" LINK "include:utility/hooks.h/MAIN" 0}>
@ENDNODE

@NODE "CallHookA" "amiga.lib/CallHookA()"
@{jcenter}
@{u}@{b}CallHookA()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CallHookA - Invoke a hook given a pointer to a message.
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
result = CallHookA( hookPtr, obj, message )

ULONG @{"CallHook" LINK "CallHook" 0}( struct @{"HOOK" LINK "include:utility/hooks.h/MAIN"} *, Object *, APTR );
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Invoke a hook on the supplied hook-specific data (an "object") and a parameter packet ("message"). This function is equivalent to @{"utility.library/CallHookPkt()" LINK "utility.guide/CallHookPkt" 0}.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
hookPtr - A system-standard hook
obj - hook-specific data object
message - The hook-specific message you wish to send
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
result - a hook-specific result.
@{lindent 4}
@{fg shine}@{b}NOTES@{ub}@{fg text}@{lindent 8}
This function first appeared in the @{fg shine}V37@{fg text} release of amiga.lib. However, it does not depend on any particular version of the OS, and works fine even in @{fg shine}V34@{fg text}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CallHook()" LINK "CallHook" 0}, @{"utility.library/CallHookPkt()" LINK "utility.guide/CallHookPkt" 0}, <@{"utility/hooks.h" LINK "include:utility/hooks.h/MAIN" 0}>
@ENDNODE

@NODE "CheckRexxMsg" "amiga.lib/CheckRexxMsg()"
@{jcenter}
@{u}@{b}CheckRexxMsg()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CheckRexxMsg - Check if a @{"RexxMsg" LINK "include:rexx/storage.h/MAIN" 97} is from ARexx
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
result = CheckRexxMsg(message)
D0                      A0

BOOL CheckRexxMsg(struct @{"RexxMsg" LINK "include:rexx/storage.h/MAIN" 97} *);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function checks to make sure that the message is from ARexx directly. It is required when using the Rexx Variable Interface routines (RVI) that the message be from ARexx.

While this function is new in the @{fg shine}V37@{fg text} amiga.lib, it is safe to call it in all versions of the operating system. It is also PURE code, thus usable in resident/pure executables.
@{lindent 4}
@{fg shine}@{b}NOTE@{ub}@{fg text}@{lindent 8}
This is a stub in amiga.lib. It is only available via amiga.lib. The stub has two labels. One, _CheckRexxMsg, takes the arguments from the stack. The other, CheckRexxMsg, takes the arguments in registers.
@{lindent 4}
@{fg shine}@{b}EXAMPLE@{ub}@{fg text}@{lindent 8}
if (CheckRexxMsg(rxmsg))
{
    /* Message is one from ARexx */
}
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
message - a pointer to the @{"RexxMsg" LINK "include:rexx/storage.h/MAIN" 97} in question
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
result  - a boolean - TRUE if message is from ARexx.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"GetRexxVar()" LINK "GetRexxVar" 0}, @{"SetRexxVar()" LINK "SetRexxVar" 0}
@ENDNODE

@NODE "CoerceMethod" "amiga.lib/CoerceMethod()"
@{jcenter}
@{u}@{b}CoerceMethod()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CoerceMethod - Perform method on coerced object.
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
result = CoerceMethod( cl, obj, MethodID, ... )

ULONG CoerceMethod( struct @{"IClass" LINK "include:intuition/classes.h/MAIN" 25} *, Object *, ULONG, ... );
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Boopsi support function that invokes the supplied message on the specified object, as though it were the specified class. Equivalent to @{"CoerceMethodA()" LINK "CoerceMethodA" 0}, but allows you to build the message on the stack.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
cl - pointer to boopsi class to receive the message
obj - pointer to boopsi object
... - method-specific message built on the stack
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
result - class and message-specific result.
@{lindent 4}
@{fg shine}@{b}NOTES@{ub}@{fg text}@{lindent 8}
This function first appears in the @{fg shine}V37@{fg text} release of amiga.lib. While it intrinsically does not require any particular release of the system software to operate, it is designed to work with the boopsi subsystem of Intuition, which was only introduced in @{fg shine}V36@{fg text}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CoerceMethodA()" LINK "CoerceMethodA" 0}, @{"DoMethodA()" LINK "DoMethodA" 0}, @{"DoSuperMethodA()" LINK "DoSuperMethodA" 0}, <@{"intuition/classusr.h" LINK "include:intuition/classusr.h/MAIN" 0}>
ROM Kernel Manual boopsi section
@ENDNODE

@NODE "CoerceMethodA" "amiga.lib/CoerceMethodA()"
@{jcenter}
@{u}@{b}CoerceMethodA()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CoerceMethodA - Perform method on coerced object.
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
result = CoerceMethodA( cl, obj, msg )

ULONG CoerceMethodA( struct @{"IClass" LINK "include:intuition/classes.h/MAIN" 25} *, Object *, Msg );
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Boopsi support function that invokes the supplied message on the specified object, as though it were the specified class.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
cl - pointer to boopsi class to receive the message
obj - pointer to boopsi object
msg - pointer to method-specific message to send
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
result - class and message-specific result.
@{lindent 4}
@{fg shine}@{b}NOTES@{ub}@{fg text}@{lindent 8}
This function first appears in the @{fg shine}V37@{fg text} release of amiga.lib. While it intrinsically does not require any particular release of the system software to operate, it is designed to work with the boopsi subsystem of Intuition, which was only introduced in @{fg shine}V36@{fg text}.
Some early example code may refer to this function as CM().
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CoerceMethod()" LINK "CoerceMethod" 0}, @{"DoMethodA()" LINK "DoMethodA" 0}, @{"DoSuperMethodA()" LINK "DoSuperMethodA" 0}, <@{"intuition/classusr.h" LINK "include:intuition/classusr.h/MAIN" 0}>
ROM Kernel Manual boopsi section
@ENDNODE

@NODE "CreateExtIO" "amiga.lib/CreateExtIO()"
@{jcenter}
@{u}@{b}CreateExtIO()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CreateExtIO - create an @{"IORequest" LINK "include:exec/io.h/MAIN" 17} structure
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
ioReq = CreateExtIO(port,ioSize);

struct @{"IORequest" LINK "include:exec/io.h/MAIN" 17} *CreateExtIO(struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *, ULONG);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Allocates memory for and initializes a new IO request block of a user-specified number of bytes. The number of bytes MUST be the size of a legal @{"IORequest" LINK "include:exec/io.h/MAIN" 17} (or extended @{"IORequest" LINK "include:exec/io.h/MAIN" 17}) or very nasty things will happen.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 15}port - an already initialized message port to be used for this IO request's reply port. If this is NULL this function fails.@{lindent 8}
ioSize - the size of the IO request to be created.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
ioReq - a new IO Request block, or NULL if there was not enough memory
@{lindent 4}
@{fg shine}@{b}EXAMPLE@{ub}@{fg text}@{lindent 8}
if (ioReq = CreateExtIO(@{"CreatePort" LINK "CreatePort" 0}(NULL,0),sizeof(struct @{"IOExtTD" LINK "include:devices/trackdisk.h/MAIN" 116})))
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"DeleteExtIO()" LINK "DeleteExtIO" 0}, @{"CreatePort()" LINK "CreatePort" 0}, @{"exec.library/CreateMsgPort()" LINK "exec.guide/CreateMsgPort" 0}
@ENDNODE

@NODE "CreatePort" "amiga.lib/CreatePort()"
@{jcenter}
@{u}@{b}CreatePort()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CreatePort - Allocate and initialize a new message port
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
port = CreatePort(name,pri)

struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *CreatePort(STRPTR,LONG);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Allocates and initializes a new message port. The message list of the new port will be prepared for use (via @{"NewList()" LINK "NewList" 0}). A signal bit will be allocated, and the port will be set to signal your task when a message arrives (PA_SIGNAL).

You *must* use @{"DeletePort()" LINK "DeletePort" 0} to delete ports created with CreatePort()!
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 15}name - public name of the port, or NULL if the port is not named. The name string is not copied. Most ports do not need names, see notes below on this.@{lindent 8}
@{lindent 15}pri  - Priority used for insertion into the public port list, normally 0.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 15}port - a new @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} structure ready for use, or NULL if the port could not be created due to not enough memory or no available signal bit.
@{lindent 4}
@{fg shine}@{b}NOTE@{ub}@{fg text}@{lindent 8}
In most cases, ports should not be named. Named ports are used for rendez-vous between tasks. Everytime a named port needs to be located, the list of all named ports must be traversed. The more named ports there are, the longer this list traversal takes. Thus, unless you really need to, do not name your ports, which will keep them off of the named port list and improve system performance.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
With versions of amiga.lib prior to @{fg shine}V37.14@{fg text}, this function would not fail even though it couldn't allocate a signal bit. The port would be returned with no signal allocated.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"DeletePort()" LINK "DeletePort" 0}, @{"exec.library/FindPort()" LINK "exec.guide/FindPort" 0}, <@{"exec/ports.h" LINK "include:exec/ports.h/MAIN" 0}>, @{"exec.library/CreateMsgPort()" LINK "exec.guide/CreateMsgPort" 0}
@ENDNODE

@NODE "CreateStdIO" "amiga.lib/CreateStdIO()"
@{jcenter}
@{u}@{b}CreateStdIO()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CreateStdIO - create an @{"IOStdReq" LINK "include:exec/io.h/MAIN" 26} structure
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
ioReq = CreateStdIO(port);

struct @{"IOStdReq" LINK "include:exec/io.h/MAIN" 26} *CreateStdIO(struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Allocates memory for and initializes a new @{"IOStdReq" LINK "include:exec/io.h/MAIN" 26} structure.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 15}port - an already initialized message port to be used for this IO request's reply port. If this is NULL this function fails.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 16}ioReq - a new @{"IOStdReq" LINK "include:exec/io.h/MAIN" 26} structure, or NULL if there was not enough memory
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"DeleteStdIO()" LINK "DeleteStdIO" 0}, @{"CreateExtIO()" LINK "CreateExtIO" 0}, @{"exec.library/CreateIORequest()" LINK "exec.guide/CreateIORequest" 0}
@ENDNODE

@NODE "CreateTask" "amiga.lib/CreateTask()"
@{jcenter}
@{u}@{b}CreateTask()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CreateTask - Create task with given name, priority, stacksize
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
task = CreateTask(name,pri,initPC,stackSize)

struct @{"Task" LINK "include:exec/tasks.h/MAIN" 23} *CreateTask(STRPTR,LONG,funcEntry,ULONG);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function simplifies program creation of sub-tasks by dynamically allocating and initializing required structures and stack space, and adding the task to Exec's task list with the given name and priority. A tc_MemEntry list is provided so that all stack and structure memory allocated by CreateTask() is automatically deallocated when the task is removed.

An Exec task may not call dos.library functions or any function which might cause the loading of a disk-resident library, device, or file (since such functions are indirectly calls to dos.library). Only AmigaDOS Processes may call AmigaDOS; see the @{"dos.library/CreateProc()" LINK "dos.guide/CreateProc" 0} or the @{"dos.library/CreateNewProc()" LINK "dos.guide/CreateNewProc" 0} functions for more information.

If other tasks or processes will need to find this task by name, provide a complex and unique name to avoid conflicts.

If your compiler provides automatic insertion of stack-checking code, you may need to disable this feature when compiling sub-task code since the stack for the subtask is at a dynamically allocated location.  If your compiler requires 68000 registers to contain particular values for base relative addressing, you may need to save these registers from your main process, and restore them in your initial subtask code.

The function entry initPC is generally provided as follows:

In C:
@{lindent 12}
extern void functionName();
char *tname = "unique name";
task = CreateTask(tname, 0L, functionName, 4000L);
@{lindent 8}
In assembler:
@{lindent 12}
PEA     startLabel
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name - a null-terminated name string
@{lindent 14}pri - an Exec task priority between -128 and 127, normally 0@{lindent 8}
@{lindent 20}funcEntry - the address of the first executable instruction of the subtask code@{lindent 8}
@{lindent 20}stackSize - size in bytes of stack for the subtask. Don't cut it too close - system function stack usage may change.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 15}task - a pointer to the newly created task, or NULL if there was not enough memory.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Under exec.library @{fg shine}V37@{fg text} or beyond, the @{"AddTask()" LINK "exec.guide/AddTask" 0} function used internally by CreateTask() can fail whereas it couldn't fail in previous versions of Exec. Prior to amiga.lib @{fg shine}V37.14@{fg text}, this function did not check for failure of @{"AddTask()" LINK "exec.guide/AddTask" 0} and thus might return a pointer to a task structure even though the task was not actually added to the system.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"DeleteTask()" LINK "DeleteTask" 0}, @{"exec.library/FindTask()" LINK "exec.library/FindTask" 0}
@ENDNODE

@NODE "CxCustom" "amiga.lib/CxCustom()"
@{jcenter}
@{u}@{b}CxCustom()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CxCustom - create a custom commodity object.  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
customObj = CxCustom(action,id);

@{"CxObj" LINK "include:libraries/commodities.h/MAIN" 74} *CxCustom(LONG(*)(),LONG);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function creates a custom commodity object. The action of this object on receiving a commodity message is to call a function of the application programmer's choice.

The function provided ('action') will be passed a pointer to the actual commodities message (in commodities private data space), and will actually execute as part of the input handler system task. Among other things, the value of 'id' can be recovered from the message by using the function @{"CxMsgID()" LINK "commodities.guide/CxMsgID" 0}.

The purpose of this function is two-fold. First, it allows programmers to create Commodities Exchange objects with functionality that was not imagined or chosen for inclusion by the designers. Secondly, this is the only way to act synchronously with Commodities.

This function is a C-language macro for @{"CreateCxObj()" LINK "commodities.guide/CreateCxObj" 0}, defined in <@{"libraries/commodities.h" LINK "include:libraries/commodities.h/MAIN" 0}>.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
action - a function to call whenever a message reaches the object
id - a message id to assign to the object
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
@{lindent 20}customObj - a pointer to the new custom object, or NULL if it could not be created.
@{lindent 4}
@{fg shine}@{b}EE ALSO@{ub}@{fg text}@{lindent 8}
@{"commodities.library/CreateCxObj()" LINK "commodities.guide/CreateCxObj" 0}, @{"commodities.library/CxMsgID()" LINK "commodities.guide/CxMsgID" 0}
@ENDNODE

@NODE "CxDebug" "amiga.lib/CxDebug()"
@{jcenter}
@{u}@{b}CxDebug()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CxDebug - create a commodity debug object.  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
debugObj = CxDebug(id);

@{"CxObj" LINK "include:libraries/commodities.h/MAIN" 74} *CxDebug(LONG);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function creates a Commodities debug object. The action of this object on receiving a Commodities message is to print out information about the Commodities message through the serial port (using the @{"kprintf()" LINK "debug.lib/kprintf" 0} routine). The value of 'id' will also be displayed.

Note that this is a synchronous occurrence (the printing is done by the input device task). If screen or file output is desired, using a sender object instead of a debug object is necessary, since such output is best done by your application process.

This function is a C-language macro for @{"CreateCxObj()" LINK "commodities.guide/CreateCxObj" 0}, defined in <@{"libraries/commodities.h" LINK "include:libraries/commodities.h/MAIN" 0}>.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 13}id - the id to assign to the debug object, this value is output whenever the debug object sends data to the serial port.
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
@{lindent 19}debugObj - a pointer to the debug object, or NULL if it could not be created.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"commodities.library/CreateCxObj()" LINK "commodities.guide/CreateCxObj" 0}, @{"CxSender()" LINK "CxSender" 0}, @{"debug.lib/kprintf()"  LINK "debug.lib/kprintf" 0}
@ENDNODE

@NODE "CxFilter" "amiga.lib/CxFilter()"
@{jcenter}
@{u}@{b}CxFilter()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CxFilter - create a commodity filter object.  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
filterObj = CxFilter(description);

@{"CxObj" LINK "include:libraries/commodities.h/MAIN" 74} *CxFilter(STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Creates an input event filter object that matches the 'description' string. If 'description' is NULL, the filter will not match any messages.

A filter may be modified by the functions @{"SetFilter()" LINK "commodities.guide/SetFilter" 0}, using a description string, and @{"SetFilterIX()" LINK "commodities.guide/SetFilterIX" 0}, which takes a binary Input Expression as a parameter.

This function is a C-language macro for @{"CreateCxObj()" LINK "commodities.guide/CreateCxObj" 0}, defined in <@{"libraries/commodities.h" LINK "include:libraries/commodities.h/MAIN" 0}>.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 22}description - the description string in the same format as strings expected by @{"commodities.library/SetFilter()" LINK "commodities.guide/SetFilter" 0}
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
@{lindent 20}filterObj - a pointer to the filter object, or NULL if there was not enough memory. If there is a problem in the description string, the internal error code of the filter object will be set to so indicate. This error code may be interrogated using the function @{"CxObjError()" LINK "commodities.guide/CxObjError" 0}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"commodities.library/CreateCxObj()" LINK "commodities.guide/CreateCxObj" 0}, @{"commodities.library/SetFilter()" LINK "commodities.guide/SetFilter" 0}, @{"commodities.library/SetFilterIX()" LINK "commodities.guide/SetFilterIX" 0}, @{"commodities.library/CxObjError()" LINK "commodities.guide/CxObjError" 0}
@ENDNODE

@NODE "CxSender" "amiga.lib/CxSender()"
@{jcenter}
@{u}@{b}CxSender()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CxSender - create a commodity sender object.  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
senderObj = CxSender(port,id)

@{"CxObj" LINK "include:libraries/commodities.h/MAIN" 74} *CxSender(struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *,LONG);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function creates a Commodities sender object. The action of this object on receiving a Commodities message is to copy the Commodities message into a standard Exec Message, to put the value 'id' in the message as well, and to send the message off to the message port 'port'.

The value 'id' is used so that an application can monitor messages from several senders at a single port. It can be retrieved from the Exec message by using the function @{"CxMsgID()" LINK "commodities.guide/CxMsgID" 0}. The value can be a simple integer ID, or a pointer to some application data structure.

Note that Exec messages sent by sender objects arrive asynchronously at the destination port. Do not assume anything about the status of the Commodities message which was copied into the Exec message you received.

All Exec messages sent to your ports must be replied. Messages may be replied after the sender object has been deleted.

This function is a C-language macro for @{"CreateCxObj()" LINK "commodities.guide/CreateCxObj" 0}, defined in <@{"libraries/commodities.h" LINK "include:libraries/commodities.h/MAIN" 0}>.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
port - the port for the sender to send messages to
id - the id of the messages sent by the sender
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
senderObj - a pointer to the sender object, or NULL if it could not be created.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"commodities.library/CreateCxObj()" LINK "commodities.guide/CreateCxObj" 0}, @{"commodities.library/CxMsgID()" LINK "commodities.guide/CxMsgID" 0}, @{"exec.library/PutMsg()" LINK "exec.guide/PutMsg" 0}, @{"exec.library/ReplyMsg()" LINK "exec.guide/ReplyMsg" 0}
@ENDNODE

@NODE "CxSignal" "amiga.lib/CxSignal()"
@{jcenter}
@{u}@{b}CxSignal()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CxSignal - create a commodity signaller object.  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
signalerObj = CxSignal(task,signal);

@{"CxObj" LINK "include:libraries/commodities.h/MAIN" 74} *CxSignal(struct @{"Task" LINK "include:exec/tasks.h/MAIN" 23} *,LONG);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function creates a Commodities signal object. The action of this object on receiving a Commodities message is to send the 'signal' to the 'task'. The caller is responsible for allocating the signal and determining the proper task ID.

Note that 'signal' is the signal value as returned by @{"AllocSignal()" LINK "exec.guide/AllocSignal" 0}, not the mask made from that value.

This function is a C-language macro for @{"CreateCxObj()" LINK "commodities.guide/CreateCxObj" 0}, defined in <@{"libraries/commodities.h" LINK "include:libraries/commodities.h/MAIN" 0}>.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
task - the task for the signaller to signal
signal - the signal bit number for the signaller to send
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
signallerObj - a pointer to the signaller object, or NULL if it could not be created.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"commodities.library/CreateCxObj()" LINK "commodities.guide/CreateCxObj" 0}, @{"exec.library/FindTask()" LINK "exec.guide/FindTask" 0}, @{"exec.library/Signal()" LINK "exec.guide/Signal" 0}, @{"exec.library/AllocSignal()" LINK "exec.guide/AllocSignal" 0},
@ENDNODE

@NODE "CxTranslate" "amiga.lib/CxTranslate()"
@{jcenter}
@{u}@{b}CxTranslate()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CxTranslate - create a commodity translator object.  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
translatorObj = CxTranslate(ie);

@{"CxObj" LINK "include:libraries/commodities.h/MAIN" 74} *CxTranslate(struct @{"InputEvent" LINK "include:devices/inputevent.h/MAIN" 256} *);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function creates a Commodities 'translator' object. The action of this object on receiving a Commodities message is to replace that message in the commodities network with a chain of Commodities input messages.

There is one new Commodities input message generated for each input event in the linked list starting at 'ie' (and NULL terminated). The routing information of the new input messages is copied from the input message they replace.

The linked list of input events associated with a translator object can be changed using the @{"SetTranslate()" LINK "commodities.guide/SetTranslate" 0} function.

If 'ie' is NULL, the null translation occurs: that is, the original commodities input message is disposed, and no others are created to take its place.

This function is a C-language macro for @{"CreateCxObj()" LINK "commodities.guide/CreateCxObj" 0}, defined in <@{"libraries/commodities.h" LINK "include:libraries/commodities.h/MAIN" 0}>.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
ie - the input event list used as replacement by the translator
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
@{lindent 24}translatorObj - a pointer to the translator object, or NULL if it could not be created.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"commodities.library/CreateCxObj()" LINK "commodities.guide/CreateCxObj" 0}, @{"commodities.library/SetTranslate()" LINK "commodities.guide/SetTranslate" 0}
@ENDNODE

@NODE "dbf" "amiga.lib/dbf()"
@{jcenter}
@{u}@{b}dbf()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
dbf - convert FFP dual-binary number to FFP format
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
fnum = dbf(exp, mant);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Accepts a dual-binary format (described below) floating point
number and converts it to an FFP format floating point number.
The dual-binary format is defined as:
@{lindent 12}
exp bit  16     = sign (0=>positive, 1=>negative)
@{lindent 30}exp bits 15-0   = binary integer representing the base ten (10) exponent@{lindent 12}
man             = binary integer mantissa
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
exp - binary integer representing sign and exponent
mant - binary integer representing the mantissa
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
fnum - converted FFP floating point format number
@ENDNODE

@NODE "DeleteExtIO" "amiga.lib/DeleteExtIO()"
@{jcenter}
@{u}@{b}DeleteExtIO()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
DeleteExtIO - return memory allocated for extended IO request
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
DeleteExtIO(ioReq);

VOID DeleteExtIO(struct @{"IORequest" LINK "include:exec/io.h/MAIN" 17} *);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Frees up an IO request as allocated by @{"CreateExtIO()" LINK "CreateExtIO" 0}.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
ioReq - the @{"IORequest" LINK "include:exec/io.h/MAIN" 17} block to be freed, or NULL.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CreateExtIO()" LINK "CreateExtIO" 0}
@ENDNODE

@NODE "DeletePort" "amiga.lib/DeletePort()"
@{jcenter}
@{u}@{b}DeletePort()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
DeletePort - free a message port created by @{"CreatePort()" LINK "CreatePort" 0}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
DeletePort(port)

VOID DeletePort(struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Frees a message port created by @{"CreatePort()" LINK "CreatePort" 0}. All messages that may have been attached to this port must have already been replied before this function is called.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
port - message port to delete
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CreatePort()" LINK "CreatePort" 0}
@ENDNODE

@NODE "DeleteStdIO" "amiga.lib/DeleteStdIO()"
@{jcenter}
@{u}@{b}DeleteStdIO()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
DeleteStdIO - return memory allocated for @{"IOStdReq" LINK "include:exec/io.h/MAIN" 26}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
DeleteStdIO(ioReq);

VOID DeleteStdIO(struct @{"IOStdReq" LINK "include:exec/io.h/MAIN" 26} *);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Frees up an @{"IOStdReq" LINK "include:exec/io.h/MAIN" 26} as allocated by @{"CreateStdIO()" LINK "CreateStdIO" 0}.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
ioReq - the @{"IORequest" LINK "include:exec/io.h/MAIN" 17} block to be freed, or NULL.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CreateStdIO()" LINK "CreateStdIO" 0}, @{"DeleteExtIO()" LINK "DeleteExtIO" 0}, @{"exec.library/CreateIORequest()" LINK "exec.guide/CreateIORequest" 0}
@ENDNODE

@NODE "DeleteTask" "amiga.lib/DeleteTask()"
@{jcenter}
@{u}@{b}DeleteTask()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
DeleteTask - delete a task created with @{"CreateTask()" LINK "CreateTask" 0}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
DeleteTask(task)

VOID DeleteTask(struct @{"Task" LINK "include:exec/tasks.h/MAIN" 23} *);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function simply calls @{"exec.library/RemTask()" LINK "exec.guide/RemTask" 0}, deleting a task from the Exec task lists and automatically freeing any stack and structure memory allocated for it by @{"CreateTask()" LINK "CreateTask" 0}.

Before deleting a task, you must first make sure that the task is not currently executing any system code which might try to signal the task after it is gone.

This can be accomplished by stopping all sources that might reference the doomed task, then causing the subtask to execute a @{"Wait" LINK "exec.guide/Wait" 0}(0L). Another option is to have the task call DeleteTask()/@{"RemTask()" LINK "exec.guide/RemTask" 0} on itself.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
task - task to remove from the system
@{lindent 4}
@{fg shine}@{b}NOTE@{ub}@{fg text}@{lindent 8}
This function simply calls @{"exec.library/RemTask()" LINK "exec.guide/RemTask" 0}, so you can call @{"RemTask()" LINK "exec.guide/RemTask" 0} directly instead of calling this function.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CreateTask()" LINK "CreateTask" 0}, @{"exec.library/RemTask()" LINK "exec.guide/RemTask" 0}
@ENDNODE

@NODE "DoMethod" "amiga.lib/DoMethod()"
@{jcenter}
@{u}@{b}DoMethod()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
DoMethod - Perform method on object.
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
result = DoMethod( obj, MethodID, ... )

ULONG DoMethod( Object *, ULONG, ... );
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Boopsi support function that invokes the supplied message on the specified object. The message is invoked on the object's true class. Equivalent to @{"DoMethodA()" LINK "DoMethodA" 0}, but allows you to build the message on the stack.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
obj - pointer to boopsi object
MethodID - which method to send (see <@{"intuition/classusr.h" LINK "include:intuition/classusr.h/MAIN" 0}>)
... - method-specific message built on the stack
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
result - specific to the message and the object's class.
@{lindent 4}
@{fg shine}@{b}NOTES@{ub}@{fg text}@{lindent 8}
This function first appears in the @{fg shine}V37@{fg text} release of amiga.lib. While it intrinsically does not require any particular release of the system software to operate, it is designed to work with the boopsi subsystem of Intuition, which was only introduced in @{fg shine}V36@{fg text}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"DoMethodA()" LINK "DoMethodA" 0}, @{"CoerceMethodA()" LINK "CoerceMethodA" 0}, @{"DoSuperMethodA()" LINK "DoSuperMethodA" 0}, <@{"intuition/classusr.h" LINK "include:intuition/classusr.h/MAIN" 0}>
ROM Kernel Manual boopsi section
@ENDNODE

@NODE "DoMethodA" "amiga.lib/DoMethodA()"
@{jcenter}
@{u}@{b}DoMethodA()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
DoMethodA - Perform method on object.
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
result = DoMethodA( obj, msg )

ULONG DoMethodA( Object *, Msg );
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Boopsi support function that invokes the supplied message on the specified object. The message is invoked on the object's true class.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
obj - pointer to boopsi object
msg - pointer to method-specific message to send
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
result - specific to the message and the object's class.
@{lindent 4}
@{fg shine}@{b}NOTES@{ub}@{fg text}@{lindent 8}
This function first appears in the @{fg shine}V37@{fg text} release of amiga.lib. While it intrinsically does not require any particular release of the system software to operate, it is designed to work with the boopsi subsystem of Intuition, which was only introduced in @{fg shine}V36@{fg text}.
Some early example code may refer to this function as DM().
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"DoMethod()" LINK "DoMethod" 0}, @{"CoerceMethodA()" LINK "CoerceMethodA" 0}, @{"DoSuperMethodA()" LINK "DoSuperMethodA" 0}, <@{"intuition/classusr.h" LINK "include:intuition/classusr.h/MAIN" 0}>
ROM Kernel Manual boopsi section
@ENDNODE

@NODE "DoSuperMethod" "amiga.lib/DoSuperMethod()"
@{jcenter}
@{u}@{b}DoSuperMethod()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
DoSuperMethod - Perform method on object coerced to superclass.
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
result = DoSuperMethod( cl, obj, MethodID, ... )

ULONG DoSuperMethod( struct @{"IClass" LINK "include:intuition/classes.h/MAIN" 25} *, Object *, ULONG, ... );
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Boopsi support function that invokes the supplied message on the specified object, as though it were the superclass of the specified class. Equivalent to @{"DoSuperMethodA()" LINK "DoSuperMethodA" 0}, but allows you to build the message on the stack.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 13}cl - pointer to boopsi class whose superclass is to receive the message@{lindent 8}
obj - pointer to boopsi object
... - method-specific message built on the stack
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
result - class and message-specific result.
@{lindent 4}
@{fg shine}@{b}NOTES@{ub}@{fg text}@{lindent 8}
This function first appears in the @{fg shine}V37@{fg text} release of amiga.lib. While it intrinsically does not require any particular release of the system software to operate, it is designed to work with the boopsi subsystem of Intuition, which was only introduced in @{fg shine}V36@{fg text}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CoerceMethodA()" LINK "CoerceMethodA" 0}, @{"DoMethodA()" LINK "DoMethodA" 0}, @{"DoSuperMethodA()" LINK "DoSuperMethodA" 0}, <@{"intuition/classusr.h" LINK "include:intuition/classusr.h/MAIN" 0}>
ROM Kernel Manual boopsi section
@ENDNODE

@NODE "DoSuperMethodA" "amiga.lib/DoSuperMethodA()"
@{jcenter}
@{u}@{b}DoSuperMethodA()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
DoSuperMethodA - Perform method on object coerced to superclass.
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
result = DoSuperMethodA( cl, obj, msg )

ULONG DoSuperMethodA( struct @{"IClass" LINK "include:intuition/classes.h/MAIN" 25} *, Object *, Msg );
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Boopsi support function that invokes the supplied message on the specified object, as though it were the superclass of the specified class.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 13}cl - pointer to boopsi class whose superclass is to receive the message@{lindent 8}
obj - pointer to boopsi object
msg - pointer to method-specific message to send
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
result - class and message-specific result.
@{lindent 4}
@{fg shine}@{b}NOTES@{ub}@{fg text}@{lindent 8}
This function first appears in the @{fg shine}V37@{fg text} release of amiga.lib. While it intrinsically does not require any particular release of the system software to operate, it is designed to work with the boopsi subsystem of Intuition, which was only introduced in @{fg shine}V36@{fg text}.
Some early example code may refer to this function as DSM().
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CoerceMethodA()" LINK "CoerceMethodA" 0}, @{"DoMethodA()" LINK "DoMethodA" 0}, @{"DoSuperMethod()" LINK "DoSuperMethod" 0}, <@{"intuition/classusr.h" LINK "include:intuition/classusr.h/MAIN" 0}>
ROM Kernel Manual boopsi section
@ENDNODE

@NODE "FastRand" "amiga.lib/FastRand()"
@{jcenter}
@{u}@{b}FastRand()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
FastRand - quickly generate a somewhat random integer
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
number = FastRand(seed);

ULONG FastRand(ULONG);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Seed value is taken from stack, shifted left one position, exclusive-or'ed with hex value $1D872B41 and returned.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
seed - a 32-bit integer
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
number - new random seed, a 32-bit value
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"RangeRand()" LINK "RangeRand" 0}
@ENDNODE

@NODE "fpa" "amiga.lib/fpa()"
@{jcenter}
@{u}@{b}fpa()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
fpa - convert fast floating point into ASCII string equivalent
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
exp = fpa(fnum, &string[0]);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Accepts an FFP number and the address of the ASCII string where it's converted output is to be stored. The number is converted to a NULL terminated ASCII string in and stored at the address provided. Additionally, the base ten (10) exponent in binary form is returned.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fnum       - Motorola Fast Floating Point number
@{lindent 21}&string[0] - address for output of converted ASCII character string (16 bytes)
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
&string[0] - converted ASCII character string
exp        - integer exponent value in binary form
@ENDNODE

@NODE "FreeIEvents" "amiga.lib/FreeIEvents()"
@{jcenter}
@{u}@{b}FreeIEvents()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
FreeIEvents - free a chain of input events allocated by @{"InvertString()" LINK "InvertString" 0}.  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
FreeIEvents(events)

VOID FreeIEvents(struct @{"InputEvent" LINK "include:devices/inputevent.h/MAIN" 256} *);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function frees a linked list of input events as obtained from @{"InvertString()" LINK "InvertString" 0}.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
vents - the list of input events to free, may be NULL.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"InvertString()" LINK "InvertString" 0}
@ENDNODE

@NODE "GetRexxVar" "amiga.lib/GetRexxVar()"
@{jcenter}
@{u}@{b}GetRexxVar()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
GetRexxVar - Gets the value of a variable from a running ARexx program
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
error = GetRexxVar(message,varname,bufpointer)
D0,A1                A0      A1     (C-only)

LONG GetRexxVar(struct @{"RexxMsg" LINK "include:rexx/storage.h/MAIN" 97} *,char *,char **);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function will attempt to extract the value of the symbol varname from the ARexx script that sent the message. When called from C, a pointer to the extracted value will be placed in the pointer pointed to by bufpointer. (*bufpointer will be the pointer to the value)

When called from assembly, the pointer will be returned in A1.

The value string returned *MUST* *NOT* be modified.

While this function is new in the @{fg shine}V37@{fg text} amiga.lib, it is safe to call it in all versions of the operating system. It is also PURE code, thus usable in resident/pure executables.
@{lindent 4}
@{fg shine}@{b}NOTE@{ub}@{fg text}@{lindent 8}
This is a stub in amiga.lib. It is only available via amiga.lib. The stub has two labels.  One, _GetRexxVar, takes the arguments from the stack. The other, GetRexxVar, takes the arguments in registers.

This routine does a @{"CheckRexxMsg()" LINK "CheckRexxMsg" 0} on the message.
@{lindent 4}
@{fg shine}@{b}EXAMPLE@{ub}@{fg text}@{lindent 8}

char    *value;

/* Message is one from ARexx */
if (!GetRexxVar(rxmsg,"TheVar",&value))
{
        /* The value was gotten and now is pointed to by value */
        @{"printf" LINK "printf" 0}("Value of TheVar is %s\\n",value);
}
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
message     - A message gotten from an ARexx script
varname     - The name of the variable to extract
bufpointer  - (For C only) A pointer to a string pointer.
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
@{lindent 30}error                 0 for success, otherwise an error code.
(Other codes may exists, these are documented)
3  = Insufficient Storage
9  = String too long
10 = invalid message
@{lindent 8}
A1(Assembly only)     Pointer to the string.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"SetRexxVar()" LINK "SetRexxVar" 0}, @{"CheckRexxMsg()" LINK "CheckRexxMsg" 0}
@ENDNODE

@NODE "HookEntry" "amiga.lib/HookEntry()"
@{jcenter}
@{u}@{b}HookEntry()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
HookEntry - Assembler to HLL conversion stub for hook entry.
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
result = HookEntry( struct @{"HOOK" LINK "include:utility/hooks.h/MAIN"} *, Object *, APTR )
D0                  A0             A2        A1
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
By definition, a standard hook entry-point must receive the hook in A0, the object in A2, and the message in A1. If your hook entry-point is written in a high-level language and is expecting its parameters on the stack, then HookEntry() will put the three parameters on the stack and invoke the function stored in the hook h_SubEntry field.

This function is only useful to hook implementers, and is never called from C.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
hook - pointer to hook being invoked
object - pointer to hook-specific data
msg - pointer to hook-specific message
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
result - a hook-specific result.
@{lindent 4}
@{fg shine}@{b}NOTES@{ub}@{fg text}@{lindent 8}
This function first appeared in the @{fg shine}V37@{fg text} release of amiga.lib. However, it does not depend on any particular version of the OS, and works fine even in @{fg shine}V34@{fg text}.
@{lindent 4}
@{fg shine}@{b}EXAMPLE@{ub}@{fg text}@{lindent 8}
If your hook dispatcher is this:

dispatch( struct @{"HOOK" LINK "include:utility/hooks.h/MAIN"} *hookPtr, Object *obj, APTR msg )
{
    ...
}

Then when you initialize your hook, you would say:

myhook.h_Entry = HookEntry;     /* amiga.lib stub */
myhook.h_SubEntry = dispatch;   /* HLL entry */
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CallHook()" LINK "CallHook" 0}, @{"CallHookA()" LINK "CallHookA" 0}, <@{"utility/hooks.h" LINK "include:utility/hooks.h/MAIN" 0}>
       
@ENDNODE

@NODE "HotKey" "amiga.lib/HotKey()"
@{jcenter}
@{u}@{b}HotKey()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
HotKey - create a commodity triad.  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
filterObj = Hotkey(description,port,id);

@{"CxObj" LINK "include:libraries/commodities.h/MAIN" 74} *HotKey(STRPTR,struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *,LONG);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function creates a triad of commodity objects to accomplish a high-level function.

The three objects are a filter, which is created to match by the call @{"CxFilter" LINK "CxFilter" 0}(description), a sender created by the call @{"CxSender" LINK "CxSender" 0}(port,id), and a translator which is created by @{"CxTranslate" LINK "CxTranslate" 0}(NULL), so that it swallows any commodity input event messages that are passed down by the filter.

This is the simple way to get a message sent to your program when the user performs a particular input action.

It is strongly recommended that the ToolTypes environment be used to allow the user to specify the input descriptions for your application's hotkeys.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 22}description - the description string to use for the filter in the same format as accepted by @{"commodities.library/SetFilter()" LINK "include:commodities.guide/SetFilter" 0}@{lindent 8}
port - port for the sender to send messages to.
id - id of the messages sent by the sender
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
@{lindent 20}filterObj - a pointer to a filter object, or NULL if it could not be created.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CxFilter()" LINK "CxFilter" 0}, @{"CxSender()" LINK "CxSender" 0}, @{"CxTranslate()" LINK "CxTranslate" 0}, @{"commodities.library/CxObjError()" LINK "commodities.guide/CxObjError" 0}, @{"commodities.library/SetFilter()" LINK "commodities.guide/SetFilter" 0}
@ENDNODE

@NODE "InvertString" "amiga.lib/InvertString()"
@{jcenter}
@{u}@{b}InvertString()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
InvertString - produce input events that would generate the given string.  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
events = InvertString(str,km)

struct @{"InputEvent" LINK "include:devices/inputevent.h/MAIN" 256} *InvertString(STRPTR,struct @{"KeyMap" LINK "include:devices/keymap.h/MAIN" 20} *);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function returns a linked list of input events which would translate into the string using the supplied keymap (or the system default keymap if 'km' is NULL).

'str' is null-terminated and may contain:
   - ANSI character codes
   - backslash escaped characters:
        \n   -   CR
        \r   -   CR
        \t   -   TAB
        \0   -   illegal, do not use!
        \\   -   backslash
@{lindent 13}   - a text description of an input event as used by @{"ParseIX()" LINK "commodities.guide/ParseIX" 0}, enclosed in angle brackets.

An example is:
  abc<alt f1>\\nhi there.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
str - null-terminated string to convert to input events
@{lindent 13}km - keymap to use for the conversion, or NULL to use the default keymap.
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
@{lindent 17}events - a chain of input events, or NULL if there was a problem. The most likely cause of failure is an illegal description enclosed in angled brackets.

This chain should eventually be freed using @{"FreeIEvents()" LINK "FreeIEvents" 0}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"commodities.library/ParseIX()" LINK "commodities.guide/ParseIX" 0}, @{"FreeIEvents()" LINK "FreeIEvents" 0}
@ENDNODE

@NODE "NewList" "amiga.lib/NewList()"
@{jcenter}
@{u}@{b}NewList()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
NewList - prepare a list structure for use
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
NewList(list)

VOID NewList(struct @{"List" LINK "include:exec/lists.h/MAIN" 19} *);
VOID NewList(struct @{"MinList" LINK "include:exec/lists.h/MAIN" 30} *);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Perform the magic needed to prepare a List header structure for use; the list will be empty and ready to use. (If the list is the full featured type, you may need to initialize lh_Type afterwards)

Assembly programmers may want to use the NEWLIST macro instead.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
list - pointer to a List or @{"MinList" LINK "include:exec/lists.h/MAIN" 30}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
<@{"exec/lists.h" LINK "include:exec/lists.h/MAIN" 0}>
@ENDNODE

@NODE "printf" "amiga.lib/printf()"
@{jcenter}
@{u}@{b}printf()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
printf - print a formatted output line to the standard output.
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
printf(formatstring [,value [,values] ] );
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Format the output in accordance with specifications in the format string.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
formatString - a C-language-like NULL-terminated format string, with the following supported % options:
@{lindent 12}
%[flags][width][.limit][length]type

@{lindent 22}  $     - must follow the arg_pos value, if specified@{lindent 12}
@{lindent 22}flags   - only one allowed. '-' specifies left justification.@{lindent 12}
@{lindent 22}width   - field width. If the first character is a '0', the field is padded with leading 0s.@{lindent 12}
@{lindent 22}.       - must precede the field width value, if specified@{lindent 12}
@{lindent 22}limit   - maximum number of characters to output from a string. (only valid for %s or %b).@{lindent 12}
@{lindent 22}length  - size of input data defaults to word (16-bit) for types c, d, u and x, 'l' changes this to long (32-bit).@{lindent 12}
@{lindent 22}type    - supported types are:@{lindent 16}
@{lindent 20}b - BSTR, data is 32-bit BPTR to byte count followed by a byte string. A NULL BPTR is treated as an empty string. @{fg shine}(V36)@{fg text}@{lindent 16}
d - signed decimal
u - unsigned decimal
x - hexadecimal with hex digits in uppercase
X - hexadecimal with hex digits in lowercase
@{lindent 20}s - string, a 32-bit pointer to a NULL-terminated byte string. A NULL pointer is treated as an empty string.@{lindent 16}
c - character
@{lindent 12}
@{lindent 23}value(s) - numeric variables or addresses of null-terminated strings to be added to the format information.
@{lindent 4}
@{fg shine}@{b}NOTE@{ub}@{fg text}@{lindent 8}
The global "_stdout" must be defined, and contain a pointer to a legal AmigaDOS file handle. Using the standard Amiga startup module sets this up. In other cases you will need to define stdout, and assign it to some reasonable value (like what the @{"dos.library/Output()" LINK "dos.guide/Output" 0} call returns). This code would set it up:
@{lindent 12}
ULONG stdout;
stdout=@{"Output()" LINK "dos.guide/Output" 0};
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
This function will crash if the resulting stream after parameter substitution is longer than 140 bytes.
@ENDNODE

@NODE "RangeRand" "amiga.lib/RangeRand()"
@{jcenter}
@{u}@{b}RangeRand()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
RangeRand - generate a random number within a specific integer range
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
number = RangeRand(maxValue);

UWORD RangeRand(UWORD);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
RangeRand() accepts a value from 0 to 65535, and returns a value within that range.

maxValue is passed on stack as a 32-bit integer but used as though it is only a 16-bit integer. Variable named RangeSeed is available beginning with @{fg shine}V33@{fg text} that contains the global seed value passed from call to call and thus can be changed in a program by declaring:
@{lindent 12}
extern ULONG RangeSeed;
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 19}maxValue - the returned random number will be in the range [0..maxValue-1]
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
number - pseudo random number in the range of [0..maxValue-1].
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FastRand()" LINK "FastRand" 0}
@ENDNODE

@NODE "RemTOF" "amiga.lib/RemTOF()"
@{jcenter}
@{u}@{b}RemTOF()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
RemTOF - remove a task from the VBlank interrupt server chain.
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
RemTOF(i);

VOID RemTOF(struct @{"Isrvstr" LINK "include:graphics/graphint.h/MAIN" 17} *);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Removes a task from the vertical-blanking interval interrupt server chain.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
i - pointer to an Isrvstr structure
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"AddTOF()" LINK "AddTOF" 0}, <@{"graphics/graphint.h" LINK "include:graphics/graphint.h/MAIN" 0}>
@ENDNODE

@NODE "SetRexxVar" "amiga.lib/SetRexxVar()"
@{jcenter}
@{u}@{b}SetRexxVar()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SetRexxVar - Sets the value of a variable of a running ARexx program
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
error = SetRexxVar(message,varname,value,length)
D0                   A0      A1      D0    D1

LONG SetRexxVar(struct @{"RexxMsg" LINK "include:rexx/storage.h/MAIN" 97} *,char *,char *,ULONG);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function will attempt to the the value of the symbol varname in the ARexx script that sent the message.

While this function is new in the @{fg shine}V37@{fg text} amiga.lib, it is safe to call it in all versions of the operating system. It is also PURE code, thus usable in resident/pure executables.
@{lindent 4}
@{fg shine}@{b}NOTE@{ub}@{fg text}@{lindent 8}
This is a stub in amiga.lib. It is only available via amiga.lib. The stub has two labels. One, _SetRexxVar, takes the arguments from the stack. The other, SetRexxVar, takes the arguments in registers.

This routine does a @{"CheckRexxMsg()" LINK "CheckRexxMsg" 0} on the message.
@{lindent 4}
@{fg shine}@{b}EXAMPLE@{ub}@{fg text}@{lindent 8}

char    *value;

/* Message is one from ARexx */
if (!SetRexxVar(rxmsg,"TheVar","25 Dollars",10))
{
    /* The value of TheVar will now be "25 Dollars" */
}
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
message   - A message gotten from an ARexx script
varname   - The name of the variable to set
value     - A string that will be the new value of the variable
length    - The length of the value string
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
@{lindent 18}error     0 for success, otherwise an error code.
(Other codes may exists, these are documented)
3  = Insufficient Storage
9  = String too long
10 = invalid message
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CheckRexxMsg()" LINK "CheckRexxMsg" 0}
@ENDNODE

@NODE "SetSuperAttrs" "amiga.lib/SetSuperAttrs()"
@{jcenter}
@{u}@{b}SetSuperAttrs()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SetSuperAttrs - Invoke OM_SET method on superclass with varargs.
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
result = SetSuperAttrs( cl, obj, tag, ... )

ULONG SetSuperAttrs( struct @{"IClass" LINK "include:intuition/classes.h/MAIN" 25} *, Object *, ULONG, ... );
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Boopsi support function which invokes the OM_SET method on the superclass of the supplied class for the supplied object. Allows the ops_AttrList to be supplied on the stack (i.e. in a varargs way). The equivalent non-varargs function would simply be
@{lindent 12}
@{"DoSuperMethod" LINK "DoSuperMethod" 0}( cl, obj, OM_SET, taglist, NULL );
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 13}cl - pointer to boopsi class whose superclass is to receive the OM_SET message@{lindent 8}
obj - pointer to boopsi object
tag - list of tag-attribute pairs, ending in TAG_DONE
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
result - class and message-specific result.
@{lindent 4}
@{fg shine}@{b}NOTES@{ub}@{fg text}@{lindent 8}
This function first appears in the @{fg shine}V37@{fg text} release of amiga.lib. While it intrinsically does not require any particular release of the system software to operate, it is designed to work with the boopsi subsystem of Intuition, which was only introduced in @{fg shine}V36@{fg text}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CoerceMethodA()" LINK "CoerceMethodA" 0}, @{"DoMethodA()" LINK "DoMethodA" 0}, @{"DoSuperMethodA()" LINK "DoSuperMethodA" 0}, <@{"intuition/classusr.h" LINK "include:intuition/classusr.h/MAIN" 0}>
ROM Kernel Manual boopsi section
@ENDNODE

@NODE "sprintf" "amiga.lib/sprintf()"
@{jcenter}
@{u}@{b}sprintf()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
sprintf - format a C-like string into a string buffer.
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
sprintf(destination formatstring [,value [, values] ] );
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Performs string formatting identical to printf, but directs the output into a specific destination in memory. This uses the ROM version of printf (@{"exec.library/RawDoFmt()" LINK "exec.guide/RawDoFmt" 0}), so it is very small.

Assembly programmers can call this by placing values on the stack, followed by a pointer to the formatstring, followed by a pointer to the destination string.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 22}destination - the address of an area in memory into which the formatted output is to be placed.@{lindent 8}
@{lindent 23}formatstring - pointer to a null terminated string describing the desired output formatting (see @{"printf()" LINK "printf" 0} for a description of this string).@{lindent 8}
@{lindent 19}value(s) - numeric information to be formatted into the output stream.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"printf()" LINK "printf" 0}, @{"exec.library/RawDoFmt()" LINK "exec.guide/RawDoFmt" 0}
@ENDNODE

@NODE "stdio" "amiga.lib/stdio()"
@{jcenter}
@{u}@{b}stdio()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAMES@{ub}@{fg text}@{lindent 8}
fclose  - close a file
fgetc   - get a character from a file
fprintf - format data to file (see @{"printf()" LINK "printf" 0})
fputc   - put character to file
fputs   - write string to file
getchar - get a character from stdin
printf  - put format data to stdout (see @{"exec.library/RawDoFmt" LINK "exec.guide/RawDoFmt" 0})
putchar - put character to stdout
puts    - put string to stdout, followed by newline
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
These functions work much like the standard C functions of the same names. The file I/O functions all use non-buffered AmigaDOS files, and must not be mixed with the file I/O of any C compiler. The names of these functions match those found in many standard C libraries, when a name conflict occurs, the function is generally taken from the FIRST library that was specified on the linker's command line. Thus to use these functions, specify the amiga.lib library first.

To get a suitable AmigaDOS @{"FileHandle" LINK "include:dos/dosextens.h/MAIN" 88}, the @{"dos.library/Open()" LINK "dos.guide/Open" 0} or @{"dos.library/Output()" LINK "dos.guide/Output" 0} functions must be used.

All of the functions that write to stdout expect an appropriate @{"FileHandle" LINK "include:dos/dosextens.h/MAIN" 88} to have been set up ahead of time. Depending on your C compiler and options, this may have been done by the startup code. Or it can be done manually

@{lindent 12}From C:
extern ULONG stdout;
/* Remove the extern if startup code did not define stdout */
stdout=@{"Output()" LINK "dos.guide/Output" 0};
@{lindent 8}
@{lindent 12}From assembly:
XDEF    _stdout
DC.L    _stdout ;<- Place result of @{"dos.library/Output()" LINK "dos.guide/Output" 0} here.
@ENDNODE

@NODE "TimeDelay" "amiga.lib/TimeDelay()"
@{jcenter}
@{u}@{b}TimeDelay()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
TimeDelay - Return after a period of time has elapsed.
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
Error = TimeDelay( Unit, Seconds, MicroSeconds )
D0                  D0     D1          D2

LONG TimeDelay( LONG, ULONG, ULONG );
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Waits for the period of time specified before returning to the the caller.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
Unit - timer.device unit to open for this command.
@{lindent 18}Seconds - The seconds field of a timerequest is filled with this value. Check the documentation for what a particular timer.device unit expects there.@{lindent 8}
@{lindent 23}MicroSeconds - The microseconds field of a timerequest is filled with this value. Check the documentation for what a particular timer.device units expects there.
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
Error - will be zero if all went well; otherwise, non-zero.
@{lindent 4}
@{fg shine}@{b}NOTES@{ub}@{fg text}@{lindent 8}
Two likely reasons for failures are invalid unit numbers or no more free signal bits for this task.

While this function first appears in @{fg shine}V37@{fg text} amiga.lib, it works on Kickstart @{fg shine}V33@{fg text} and higher.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"timer.device/TR_ADDREQUEST" LINK "timer.guide/TR_ADDREQUEST" 0}, timer.device/TR_WAITUNTIL, timer.device/WaitUnitl()
@ENDNODE

@NODE "LibAllocPooled" "pools.lib/LibAllocPooled()"
@{jcenter}
@{u}@{b}LibAllocPooled()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
LibAllocPooled - Allocate memory with the pool manager  @{fg shine}(V33)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
memory=LibAllocPooled(poolHeader,memSize)
d0                      a0         d0

void *LibAllocPooled(void *,ULONG);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function is a copy of the pool functions in @{fg shine}V39@{fg text} and up of EXEC. In fact, if you are running in @{fg shine}V39@{fg text}, this function will notice and call the EXEC function. This function works in @{fg shine}V33@{fg text} and up (1.2) Amiga system.

The C code interface is _LibAllocPooled() and takes its arguments from the stack just like the C code interface for @{"AllocPooled()" LINK "exec.guide/AllocPooled" 0} in amiga.lib. The assembly code interface is with the symbol _AsmAllocPooled: and takes the parameters in registers with the additional parameter of @{"ExecBase" LINK "include:exec/execbase.h/MAIN" 33} being in a6 which can be used from SAS/C 6 by a prototype of:

@{lindent 36}void * __asm AsmAllocPooled(register __a0 void *, register __d0 ULONG, register __a6 struct @{"ExecBase" LINK "include:exec/execbase.h/MAIN" 33} *);
@{lindent 8}
Allocate memSize bytes of memory, and return a pointer. NULL is returned if the allocation fails.

Doing a @{"LibDeletePool()" LINK "LibDeletePool" 0} on the pool will free all of the puddles and thus all of the allocations done with LibAllocPooled() in that pool. (No need to @{"LibFreePooled()" LINK "LibFreePooled" 0} each allocation)
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
memSize - the number of bytes to allocate
poolHeader - a specific private pool header.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
A pointer to the memory, or NULL. The memory block returned is long word aligned.
@{lindent 4}
@{fg shine}@{b}NOTES@{ub}@{fg text}@{lindent 8}
The pool function do not protect an individual pool from multiple accesses. The reason is that in most cases the pools will be used by a single task. If your pool is going to be used by more than one task you must Semaphore protect the pool from having more than one task trying to allocate within the same pool at the same time. Warning: @{"Forbid()" LINK "exec.guide/Forbid" 0} protection *will not work* in the future. *Do NOT* assume that we will be able to make it work in the future. LibAllocPooled() may well break a @{"Forbid()" LINK "exec.guide/Forbid" 0} and as such can only be protected by a semaphore.

To track sizes yourself, the following code can be used:

*Assumes a6=@{"ExecBase" LINK "include:exec/execbase.h/MAIN" 33}*

;
; Function to do AllocVecPooled(Pool,memSize)
;
AllocVecPooled: addq.l  #4,d0           ; Get space for tracking
                move.l  d0,-(sp)        ; Save the size
                jsr     LibAllocPooled  ; Call pool...
                move.l  (sp)+,d1        ; Get size back...
                tst.l   d0              ; Check for error
                beq.s   avp_fail        ; If NULL, failed!
                move.l  d0,a0           ; Get pointer...
                move.l  d1,(a0)+        ; Store size
                move.l  a0,d0           ; Get result
avp_fail:       rts                     ; return

;
; Function to do LibFreeVecPooled(pool,memory)
;
FreeVecPooled:  move.l  -(a1),d0        ; Get size / ajust pointer
                jmp     @{"LibFreePooled" LINK "LibFreePooled" 0}
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FreePooled()" LINK "exec.guide/FreePooled" 0}, @{"CreatePool()" LINK "exec.guide/CreatePool" 0}, @{"DeletePool()" LINK "exec.guide/DeletePool" 0}, @{"LibFreePooled()" LINK "LibFreePooled" 0}, @{"LibCreatePool()" LINK "LibCreatePool" 0}, @{"LibDeletePool()" LINK "LibDeletePool" 0}
@ENDNODE

@NODE "LibCreatePool" "pools.lib/LibCreatePool()"
@{jcenter}
@{u}@{b}LibCreatePool()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
LibCreatePool - Generate a private memory pool header  @{fg shine}(V33)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
newPool=LibCreatePool(memFlags,puddleSize,threshSize)
a0                       d0        d1         d2

void *LibCreatePool(ULONG,ULONG,ULONG);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function is a copy of the pool functions in @{fg shine}V39@{fg text} and up of EXEC. In fact, if you are running in @{fg shine}V39@{fg text}, this function will notice and call the EXEC function. This function works in @{fg shine}V33@{fg text} and up (1.2) Amiga system.

The C code interface is _LibCreatePool() and takes its arguments from the stack just like the C code interface for @{"CreatePool()" LINK "exec.guide/CreatePool" 0} in amiga.lib. The assembly code interface is with the symbol _AsmCreatePool: and takes the parameters in registers with the additional parameter of @{"ExecBase" LINK "include:exec/execbase.h/MAIN" 33} being in a6 which can be used from SAS/C 6 by a prototype of:

@{lindent 35}void * __asm AsmCreatePool(register __d0 ULONG, register __d1 ULONG, register __d2 ULONG, register __a6 struct @{"ExecBase" LINK "include:exec/execbase.h/MAIN" 33} *);
@{lindent 8}
Allocate and prepare a new memory pool header. Each pool is a separate tracking system for memory of a specific type. Any number of pools may exist in the system.

Pools automatically expand and shrink based on demand. Fixed sized "puddles" are allocated by the pool manager when more total memory is needed. Many small allocations can fit in a single puddle. Allocations larger than the threshSize are allocation in their own puddles.

At any time individual allocations may be freed. Or, the entire pool may be removed in a single step.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
memFlags - a memory flags specifier, as taken by @{"AllocMem()" LINK "exec.guide/AllocMem" 0}.
puddleSize - the size of Puddles...
@{lindent 21}threshSize - the largest allocation that goes into normal puddles This *MUST* be less than or equal to puddleSize (LibCreatePool() will fail if it is not)
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
The address of a new pool header, or NULL for error.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"DeletePool()" LINK "exec.guide/DeletePool" 0}, @{"AllocPooled()" LINK "exec.guide/AllocPooled" 0}, @{"FreePooled()" LINK "exec.guide/FreePooled" 0}, exec/memory.i, @{"LibDeletePool()" LINK "LibDeletePool" 0}, @{"LibAllocPooled()" LINK "LibAllocPooled" 0}, @{"LibFreePooled()" LINK "LibFreePooled" 0}
@ENDNODE

@NODE "LibDeletePool" "pools.lib/LibDeletePool()"
@{jcenter}
@{u}@{b}LibDeletePool()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
LibDeletePool -  Drain an entire memory pool  @{fg shine}(V33)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
LibDeletePool(poolHeader)
                 a0

void LibDeletePool(void *);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function is a copy of the pool functions in @{fg shine}V39@{fg text} and up of EXEC. In fact, if you are running in @{fg shine}V39@{fg text}, this function will notice and call the EXEC function. This function works in @{fg shine}V33@{fg text} and up (1.2) Amiga system.

The C code interface is _LibDeletePool() and takes its arguments from the stack just like the C code interface for @{"DeletePool()" LINK "exec.guide/DeletePool" 0} in amiga.lib. The assembly code interface is with the symbol _AsmDeletePool: and takes the parameters in registers with the additional parameter of @{"ExecBase" LINK "include:exec/execbase.h/MAIN" 33} being in a6 which can be used from SAS/C 6 by a prototype of:

@{lindent 33}void __asm AsmDeletePool(register __a0 void *, register __a6 struct @{"ExecBase" LINK "include:exec/execbase.h/MAIN" 33} *);
@{lindent 8}
Frees all memory in all puddles of the specified pool header, then deletes the pool header. Individual free calls are not needed.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
poolHeader - as returned by @{"LibCreatePool()" LINK "LibCreatePool" 0}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CreatePool()" LINK "exec.guide/CreatePool" 0}, @{"AllocPooled()" LINK "exec.guide/AllocPooled" 0}, @{"FreePooled()" LINK "exec.guide/FreePooled" 0}, @{"LibCreatePool()" LINK "LibCreatePool" 0}, @{"LibAllocPooled()" LINK "LibAllocPooled" 0}, @{"LibFreePooled()" LINK "LibFreePooled" 0}
@ENDNODE

@NODE "LibFreePooled" "pools.lib/LibFreePooled()"
@{jcenter}
@{u}@{b}LibFreePooled()@{ub}@{uu}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
LibFreePooled - Free pooled memory   @{fg shine}(V33)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
LibFreePooled(poolHeader,memory,memSize)
                a0         a1     d0

void LibFreePooled(void *,void *,ULONG);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function is a copy of the pool functions in @{fg shine}V39@{fg text} and up of EXEC. In fact, if you are running in @{fg shine}V39@{fg text}, this function will notice and call the EXEC function. This function works in @{fg shine}V33@{fg text} and up (1.2) Amiga system.

The C code interface is _LibFreePooled() and takes its arguments from the stack just like the C code interface for @{"FreePooled()" LINK "exec.guide/FreePooled" 0} in amiga.lib. The assembly code interface is with the symbol _AsmFreePooled: and takes the parameters in registers with the additional parameter of @{"ExecBase" LINK "include:exec/execbase.h/MAIN" 33} being in a6 which can be used from SAS/C 6 by a prototype of:

@{lindent 33}void __asm AsmFreePooled(register __a0 void *, register __a1 void *,  register __d0 ULONG,  register __a6 struct @{"ExecBase" LINK "include:exec/execbase.h/MAIN" 33} *);
@{lindent 8}
Deallocates memory allocated by @{"LibAllocPooled()" LINK "LibAllocPooled" 0}. The size of the allocation *MUST* match the size given to @{"LibAllocPooled()" LINK "LibAllocPooled" 0}. The reason the pool functions do not track individual allocation sizes is because many of the uses of pools have small allocation sizes and the tracking of the size would be a large overhead.

Only memory allocated by @{"LibAllocPooled()" LINK "LibAllocPooled" 0} may be freed with this function!

Doing a @{"LibDeletePool()" LINK "LibDeletePool" 0} on the pool will free all of the puddles and thus all of the allocations done with @{"LibAllocPooled()" LINK "LibAllocPooled" 0} in that pool. (No need to LibFreePooled() each allocation)
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
memory - pointer to memory allocated by @{"AllocPooled()" LINK "exec.guide/AllocPooled" 0}.
poolHeader - a specific private pool header.
@{lindent 4}
@{fg shine}@{b}NOTES@{ub}@{fg text}@{lindent 8}
The pool function do not protect an individual pool from multiple accesses. The reason is that in most cases the pools will be used by a single task. If your pool is going to be used by more than one task you must Semaphore protect the pool from having more than one task trying to allocate within the same pool at the same time. Warning: @{"Forbid()" LINK "exec.guide/Forbid" 0} protection *will not work* in the future. *Do NOT* assume that we will be able to make it work in the future. LibFreePooled() may well break a @{"Forbid()" LINK "exec.guide/Forbid" 0} and as such can only be protected by a semaphore.

To track sizes yourself, the following code can be used:

*Assumes a6=@{"ExecBase" LINK "include:exec/execbase.h/MAIN" 33}*

;
; Function to do AllocVecPooled(Pool,memSize)
;
AllocVecPooled: addq.l  #4,d0           ; Get space for tracking
                move.l  d0,-(sp)        ; Save the size
                jsr     @{"LibAllocPooled" LINK "LibAllocPooled" 0}  ; Call pool...
                move.l  (sp)+,d1        ; Get size back...
                tst.l   d0              ; Check for error
                beq.s   avp_fail        ; If NULL, failed!
                move.l  d0,a0           ; Get pointer...
                move.l  d1,(a0)+        ; Store size
                move.l  a0,d0           ; Get result
avp_fail:       rts                     ; return

;
; Function to do LibFreeVecPooled(pool,memory)
;
FreeVecPooled:  move.l  -(a1),d0        ; Get size / ajust pointer
                jmp     LibFreePooled
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"AllocPooled()" LINK "exec.guide/AllocPooled" 0}, @{"CreatePool()" LINK "exec.guide/CreatePool" 0}, @{"DeletePool()" LINK "exec.guide/DeletePool" 0}, @{"LibAllocPooled()" LINK "LibAllocPooled" 0}, @{"LibCreatePool()" LINK "LibCreatePool" 0}, @{"LibDeletePool()" LINK "LibDeletePool" 0}
@ENDNODE

