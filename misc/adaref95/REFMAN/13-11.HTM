<html>
<head>
<title>Ada 95 RM - 13.11 Storage Management</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="13-10.htm"><img src="left.gif" alt="Prev"></a> | <a href="13.htm"><img src="up.gif" alt="Up"></a> | <a href="13-12.htm"><img src="right.gif" alt="Next"></a> | <a href="13-10.htm"><img src="back.gif" alt="Back"></a> | <a href="13-11-01.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>

<h2><a name="0">13.11 Storage Management</a>
 -- <a href="toc13-11.htm">TOC</a>
</h2>
<dl><dt><a name="1">(1)</a><dd>Each access-to-object type has an associated storage pool.  The storage
allocated by an allocator comes from the pool; instances of Unchecked_Deallocation return storage to the pool.  Several access types can share the
same pool.
<dt><a name="2">(2)</a><dd>A storage pool is a variable of a type in the class rooted at Root_Storage_Pool, which is an abstract limited controlled type.  By default, the
implementation chooses a standard storage pool for each access type.  The
user may define new pool types, and may override the choice of pool for an
access type by specifying Storage_Pool for the type.
</dl><h5 align="center">Legality Rules</h5>
<dl><dt><a name="3">(3)</a><dd>If Storage_Pool is specified for a given access type, Storage_Size shall
not be specified for it.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="4">(4)</a><dd>The following language-defined library package exists:
</dl><pre><a name="5">(5)</a>
       with Ada.Finalization;
       with System.Storage_Elements;
       package System.Storage_Pools is
           pragma Preelaborate(System.Storage_Pools);
<a name="6">(6)</a>
           type Root_Storage_Pool is
               abstract new Ada.Finalization.Limited_Controlled with private;
<a name="7">(7)</a>
           procedure Allocate(
             Pool : in out Root_Storage_Pool;
             Storage_Address : out Address;
             Size_In_Storage_Elements : in Storage_Elements.Storage_Count;
             Alignment : in Storage_Elements.Storage_Count) is abstract;
<a name="8">(8)</a>
           procedure Deallocate(
             Pool : in out Root_Storage_Pool;
             Storage_Address : in Address;
             Size_In_Storage_Elements : in Storage_Elements.Storage_Count;
             Alignment : in Storage_Elements.Storage_Count) is abstract;
<a name="9">(9)</a>
           function Storage_Size(Pool : Root_Storage_Pool)
               return Storage_Elements.Storage_Count is abstract;
<a name="10">(10)</a>
       private
          ... <em>-- not specified by the language</em>
       end System.Storage_Pools;
</pre><dl><dt><a name="11">(11)</a><dd>A storage pool type (or pool type) is a descendant of Root_Storage_Pool.
The elements of a storage pool are the objects allocated in the pool by
allocators.
<dt><a name="12">(12)</a><dd>For every access subtype S, the following attributes are defined:
<dt><a name="13">(13)</a><dd>S'Storage_Pool
<ul>Denotes the storage pool of the type of S. The type of this
attribute is Root_Storage_Pool'Class.
</ul><dt><a name="14">(14)</a><dd>S'Storage_Size
<ul>Yields the result of calling Storage_Size(S'Storage_Pool),
which is intended to be a measure of the number of storage
elements reserved for the pool.  The type of this attribute
is universal_integer.
</ul><dt><a name="15">(15)</a><dd>Storage_Size or Storage_Pool may be specified for a non-derived
access-to-object type via an attribute_definition_clause; the name in a
Storage_Pool clause shall denote a variable.
<dt><a name="16">(16)</a><dd>An allocator of type T allocates storage from T's storage pool.  If the
storage pool is a user-defined object, then the storage is allocated by
calling Allocate, passing T'Storage_Pool as the Pool parameter.  The Size_In_Storage_Elements parameter indicates the number of storage elements to be
allocated, and is no more than D'Max_Size_In_Storage_Elements, where D is the
designated subtype.  The Alignment parameter is D'Alignment.  The result
returned in the Storage_Address parameter is used by the allocator as the
address of the allocated storage, which is a contiguous block of memory of
Size_In_Storage_Elements storage elements.  Any exception propagated by
Allocate is propagated by the allocator.
<dt><a name="17">(17)</a><dd>If Storage_Pool is not specified for a type defined by an access_to_object_definition, then the implementation chooses a standard storage pool
for it in an implementation-defined manner.  In this case, the exception
Storage_Error is raised by an allocator if there is not enough storage.  It
is implementation defined whether or not the implementation provides
user-accessible names for the standard pool type(s).
<dt><a name="18">(18)</a><dd>If Storage_Size is specified for an access type, then the Storage_Size
of this pool is at least that requested, and the storage for the pool is
reclaimed when the master containing the declaration of the access type is
left.  If the implementation cannot satisfy the request, Storage_Error is
raised at the point of the attribute_definition_clause.  If neither Storage_Pool nor Storage_Size are specified, then the meaning of Storage_Size is
implementation defined.
<dt><a name="19">(19)</a><dd>If Storage_Pool is specified for an access type, then the specified pool
is used.
<dt><a name="20">(20)</a><dd>The effect of calling Allocate and Deallocate for a standard storage
pool directly (rather than implicitly via an allocator or an instance of
Unchecked_Deallocation) is unspecified.
</dl><h5 align="center">Erroneous Execution</h5>
<dl><dt><a name="21">(21)</a><dd>If Storage_Pool is specified for an access type, then if Allocate can
satisfy the request, it should allocate a contiguous block of memory, and
return the address of the first storage element in Storage_Address.  The
block should contain Size_In_Storage_Elements storage elements, and should be
aligned according to Alignment.  The allocated storage should not be used for
any other purpose while the pool element remains in existence.  If the
request cannot be satisfied, then Allocate should propagate an exception
(such as Storage_Error).  If Allocate behaves in any other manner, then the
program execution is erroneous.
</dl><h5 align="center">Documentation Requirements</h5>
<dl><dt><a name="22">(22)</a><dd>An implementation shall document the set of values that a user-defined
Allocate procedure needs to accept for the Alignment parameter.  An
implementation shall document how the standard storage pool is chosen, and
how storage is allocated by standard storage pools.
</dl><h5 align="center">Implementation Advice</h5>
<dl><dt><a name="23">(23)</a><dd>An implementation should document any cases in which it dynamically
allocates heap storage for a purpose other than the evaluation of an
allocator.
<dt><a name="24">(24)</a><dd>A default (implementation-provided) storage pool for an access-to-
constant type should not have overhead to support deallocation of individual
objects.
<dt><a name="25">(25)</a><dd>A storage pool for an anonymous access type should be created at the
point of an allocator for the type, and be reclaimed when the designated
object becomes inaccessible.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="26">(26)</a><dd><ul>(23) A user-defined storage pool type can be obtained by extending the
Root_Storage_Pool type, and overriding the primitive subprograms
Allocate, Deallocate, and Storage_Size.  A user-defined storage pool can
then be obtained by declaring an object of the type extension.  The user
can override Initialize and Finalize if there is any need for
non-trivial initialization and finalization for a user-defined pool
type.  For example, Finalize might reclaim blocks of storage that are
allocated separately from the pool object itself.
</ul><dt><a name="27">(27)</a><dd><ul>(24) The writer of the user-defined allocation and deallocation
procedures, and users of allocators for the associated access type, are
responsible for dealing with any interactions with tasking.  In
particular:
</ul><dt><a name="28">(28)</a><dd><ul><ul><li>If the allocators are used in different tasks, they require
mutual exclusion.
</ul></ul><dt><a name="29">(29)</a><dd><ul><ul><li>If they are used inside protected objects, they cannot
block.
</ul></ul><dt><a name="30">(30)</a><dd><ul><ul><li>If they are used by interrupt handlers <a href="C-03.htm">(see C.3</a>, ``Interrupt
Support''), the mutual exclusion mechanism has to work
properly in that context.
</ul></ul><dt><a name="31">(31)</a><dd><ul>(25) The primitives Allocate, Deallocate, and Storage_Size are declared
as abstract <a href="03-09-03.htm">(see 3.9.3)</a>, and therefore they have to be overridden when a
new (non-abstract) storage pool type is declared.
</ul></dl><h5 align="center">Examples</h5>
<dl><dt><a name="32">(32)</a><dd>To associate an access type with a storage pool object, the user first
declares a pool object of some type derived from Root_Storage_Pool.  Then,
the user defines its Storage_Pool attribute, as follows:
</dl><pre><a name="33">(33)</a>
       Pool_Object : Some_Storage_Pool_Type;
<a name="34">(34)</a>
       type T is access Designated;
       for T'Storage_Pool use Pool_Object;
</pre><dl><dt><a name="35">(35)</a><dd>Another access type may be added to an existing storage pool, via:
</dl><pre><a name="36">(36)</a>
       for T2'Storage_Pool use T'Storage_Pool;
</pre><dl><dt><a name="37">(37)</a><dd>The semantics of this is implementation defined for a standard storage
pool.
<dt><a name="38">(38)</a><dd>As usual, a derivative of Root_Storage_Pool may define additional
operations.  For example, presuming that Mark_Release_Pool_Type has two
additional operations, Mark and Release, the following is a possible use:
</dl><pre><a name="39">(39)</a>
       type Mark_Release_Pool_Type
          (Pool_Size : Storage_Elements.Storage_Count;
           Block_Size : Storage_Elements.Storage_Count)
               is new Root_Storage_Pool with limited private;
<a name="40">(40)</a>
       ...
<a name="41">(41)</a>
       MR_Pool : Mark_Release_Pool_Type (Pool_Size =&gt; 2000,
                                         Block_Size =&gt; 100);
<a name="42">(42)</a>
       type Acc is access ...;
       for Acc'Storage_Pool use MR_Pool;
       ...
<a name="43">(43)</a>
       Mark(MR_Pool);
       ... <em>-- Allocate objects using ``new Designated(...)''.</em>
       Release(MR_Pool); <em>-- Reclaim the storage.</em>
</pre><hr><h3>Subclauses</h3>
<ol>
<li><a href="13-11-01.htm">The Max_Size_In_Storage_Elements Attribute</a>
<li><a href="13-11-02.htm">Unchecked Storage Deallocation</a>
<li><a href="13-11-03.htm">Pragma Controlled</a>
</ol>
<p>
<hr>
<h4><a href="13-10.htm"><img src="left.gif" alt="Prev"></a> | <a href="13.htm"><img src="up.gif" alt="Up"></a> | <a href="13-12.htm"><img src="right.gif" alt="Next"></a> | <a href="13-10.htm"><img src="back.gif" alt="Back"></a> | <a href="13-11-01.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
