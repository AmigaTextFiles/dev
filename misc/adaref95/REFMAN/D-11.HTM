<html>
<head>
<title>Ada 95 RM - D.11 Asynchronous Task Control</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="D-10.htm"><img src="left.gif" alt="Prev"></a> | <a href="D.htm"><img src="up.gif" alt="Up"></a> | <a href="D-12.htm"><img src="right.gif" alt="Next"></a> | <a href="D-10.htm"><img src="back.gif" alt="Back"></a> | <a href="D-12.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>

<h2><a name="0">D.11 Asynchronous Task Control</a></h2>
<dl><dt><a name="1">(1)</a><dd>This clause introduces a language-defined package to do asynchronous
suspend/resume on tasks.  It uses a conceptual held priority value to
represent the task's held state.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="2">(2)</a><dd>The following language-defined library package exists:
</dl><pre><a name="3">(3)</a>
       with Ada.Task_Identification;
       package Ada.Asynchronous_Task_Control is
         procedure Hold(T : in Ada.Task_Identification.Task_ID);
         procedure Continue(T : in Ada.Task_Identification.Task_ID);
         function Is_Held(T : Ada.Task_Identification.Task_ID)
          return Boolean;
       end Ada.Asynchronous_Task_Control;
</pre><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="4">(4)</a><dd>After the Hold operation has been applied to a task, the task becomes
held.  For each processor there is a conceptual idle task, which is always
ready.  The base priority of the idle task is below System.Any_Priority'First.  The held priority is a constant of the type integer whose
value is below the base priority of the idle task.
<dt><a name="5">(5)</a><dd>The Hold operation sets the state of T to held.  For a held task:  the
task's own base priority does not constitute an inheritance source <a href="D-01.htm">(see D.1)</a>,
and the value of the held priority is defined to be such a source instead.
<dt><a name="6">(6)</a><dd>The Continue operation resets the state of T to not-held; T's active
priority is then reevaluated as described in <a href="D-01.htm">D.1</a>.  This time, T's base
priority is taken into account.
<dt><a name="7">(7)</a><dd>The Is_Held function returns True if and only if T is in the held state.
<dt><a name="8">(8)</a><dd>As part of these operations, a check is made that the task identified by
T is not terminated.  Tasking_Error is raised if the check fails.  Program_Error is raised if the value of T is Null_Task_ID.
</dl><h5 align="center">Erroneous Execution</h5>
<dl><dt><a name="9">(9)</a><dd>If any operation in this package is called with a parameter T that
specifies a task object that no longer exists, the execution of the program
is erroneous.
</dl><h5 align="center">Implementation Permissions</h5>
<dl><dt><a name="10">(10)</a><dd>An implementation need not support Asynchronous_Task_Control if it is
infeasible to support it in the target environment.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="11">(11)</a><dd><ul>(33) It is a consequence of the priority rules that held tasks cannot be
dispatched on any processor in a partition (unless they are inheriting
priorities) since their priorities are defined to be below the priority
of any idle task.
</ul><dt><a name="12">(12)</a><dd><ul>(34) The effect of calling Get_Priority and Set_Priority on a Held task
is the same as on any other task.
</ul><dt><a name="13">(13)</a><dd><ul>(35) Calling Hold on a held task or Continue on a non-held task has no
effect.
</ul><dt><a name="14">(14)</a><dd><ul>(36) The rules affecting queuing are derived from the above rules, in
addition to the normal priority rules:
</ul><dt><a name="15">(15)</a><dd><ul><ul><li>When a held task is on the ready queue, its priority is so
low as to never reach the top of the queue as long as there
are other tasks on that queue.
</ul></ul><dt><a name="16">(16)</a><dd><ul><ul><li>If a task is executing in a protected action, inside a
rendezvous, or is inheriting priorities from other sources
(e.g.  when activated), it continues to execute until it is
no longer executing the corresponding construct.
</ul></ul><dt><a name="17">(17)</a><dd><ul><ul><li>If a task becomes held while waiting (as a caller) for a
rendezvous to complete, the active priority of the accepting
task is not affected.
</ul></ul><dt><a name="18">(18)</a><dd><ul><ul><li>If a task becomes held while waiting in a selective_accept,
and a entry call is issued to one of the open entries, the
corresponding accept body executes.  When the rendezvous
completes, the active priority of the accepting task is
lowered to the held priority (unless it is still inheriting
from other sources), and the task does not execute until
another Continue.
</ul></ul><dt><a name="19">(19)</a><dd><ul><ul><li>The same holds if the held task is the only task on a
protected entry queue whose barrier becomes open.  The
corresponding entry body executes.
</ul></ul></dl><p>
<hr>
<h4><a href="D-10.htm"><img src="left.gif" alt="Prev"></a> | <a href="D.htm"><img src="up.gif" alt="Up"></a> | <a href="D-12.htm"><img src="right.gif" alt="Next"></a> | <a href="D-10.htm"><img src="back.gif" alt="Back"></a> | <a href="D-12.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
