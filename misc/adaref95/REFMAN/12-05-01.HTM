<html>
<head>
<title>Ada 95 RM - 12.5.1 Formal Private and Derived Types</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><img src="noleft.gif" alt="____"> | <a href="12-05.htm"><img src="up.gif" alt="Up"></a> | <a href="12-05-02.htm"><img src="right.gif" alt="Next"></a> | <a href="12-05.htm"><img src="back.gif" alt="Back"></a> | <a href="12-05-02.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>
<h3><a name="0">12.5.1 Formal Private and Derived Types</a></h3>
<dl><dt><a name="1">(1)</a><dd>The class determined for a formal private type can be either limited or
nonlimited, and either tagged or untagged; no more specific class is known
for such a type.  The class determined for a formal derived type is the
derivation class rooted at the ancestor type.
</dl><h5 align="center"><a name="syntax">Syntax</a></h5>
<pre><a name="2">(2)</a>
       formal_private_type_definition ::= [[abstract] tagged] [limited] private
<a name="3">(3)</a>
       formal_derived_type_definition ::= [abstract] new subtype_mark [with private]
</pre><h5 align="center">Legality Rules</h5>
<dl><dt><a name="4">(4)</a><dd>If a generic formal type declaration has a known_discriminant_part, then
it shall not include a default_expression for a discriminant.
<dt><a name="5">(5)</a><dd>The ancestor subtype of a formal derived type is the subtype denoted by
the subtype_mark of the formal_derived_type_definition.  For a formal derived
type declaration, the reserved words with private shall appear if and only if
the ancestor type is a tagged type; in this case the formal derived type is a
private extension of the ancestor type and the ancestor shall not be a
class-wide type.  Similarly, the optional reserved word abstract shall appear
only if the ancestor type is a tagged type.
<dt><a name="6">(6)</a><dd>If the formal subtype is definite, then the actual subtype shall also be
definite.
<dt><a name="7">(7)</a><dd>For a generic formal derived type with no discriminant_part:
<dt><a name="8">(8)</a><dd><ul><li>If the ancestor subtype is constrained, the actual subtype shall
be constrained, and shall be statically compatible with the
ancestor;
</ul><dt><a name="9">(9)</a><dd><ul><li>If the ancestor subtype is an unconstrained access or composite
subtype, the actual subtype shall be unconstrained.
</ul><dt><a name="10">(10)</a><dd><ul><li>If the ancestor subtype is an unconstrained discriminated
subtype, then the actual shall have the same number of
discriminants, and each discriminant of the actual shall
correspond to a discriminant of the ancestor, in the sense of
<a href="03-07.htm">3.7</a>.
</ul><dt><a name="11">(11)</a><dd>The declaration of a formal derived type shall not have a known_discriminant_part.  For a generic formal private type with a known_discriminant_part:
<dt><a name="12">(12)</a><dd><ul><li>The actual type shall be a type with the same number of
discriminants.
</ul><dt><a name="13">(13)</a><dd><ul><li>The actual subtype shall be unconstrained.
</ul><dt><a name="14">(14)</a><dd><ul><li>The subtype of each discriminant of the actual type shall
statically match the subtype of the corresponding discriminant of
the formal type.
</ul><dt><a name="15">(15)</a><dd>For a generic formal type with an unknown_discriminant_part, the actual
may, but need not, have discriminants, and may be definite or indefinite.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="16">(16)</a><dd>The class determined for a formal private type is as follows:
</dl><pre><a name="17">(17)</a>
       Type Definition                    Determined Class

       limited private                    the class of all types
       private                            the class of all nonlimited types
       tagged limited private             the class of all tagged types
       tagged private                     the class of all nonlimited tagged types
</pre><dl><dt><a name="18">(18)</a><dd>The presence of the reserved word abstract determines whether the actual
type may be abstract.
<dt><a name="19">(19)</a><dd>A formal private or derived type is a private or derived type,
respectively.  A formal derived tagged type is a private extension.  A formal
private or derived type is abstract if the reserved word abstract appears in
its declaration.
<dt><a name="20">(20)</a><dd>If the ancestor type is a composite type that is not an array type, the
formal type inherits components from the ancestor type (including
discriminants if a new discriminant_part is not specified), as for a derived
type defined by a derived_type_definition <a href="03-04.htm">(see 3.4)</a>.
<dt><a name="21">(21)</a><dd>For a formal derived type, the predefined operators and inherited
user-defined subprograms are determined by the ancestor type, and are
implicitly declared at the earliest place, if any, within the immediate scope
of the formal type, where the corresponding primitive subprogram of the
ancestor is visible <a href="07-03-01.htm">(see 7.3.1)</a>.  In an instance, the copy of such an
implicit declaration declares a view of the corresponding primitive
subprogram of the ancestor, even if this primitive has been overridden for
the actual type.  In the case of a formal private extension, however, the tag
of the formal type is that of the actual type, so if the tag in a call is
statically determined to be that of the formal type, the body executed will
be that corresponding to the actual type.
<dt><a name="22">(22)</a><dd>For a prefix S that denotes a formal indefinite subtype, the following
attribute is defined:
<dt><a name="23">(23)</a><dd>S'Definite
<ul>S'Definite yields True if the actual subtype corresponding to
S is definite; otherwise it yields False.  The value of this
attribute is of the predefined type Boolean.
</ul><p><dt><dd><ul>NOTES</ul>
<dt><a name="24">(24)</a><dd><ul>(9) In accordance with the general rule that the actual type shall
belong to the class determined for the formal <a href="12-05.htm">(see 12.5</a>, ``Formal
Types''):
</ul><dt><a name="25">(25)</a><dd><ul><ul><li>If the formal type is nonlimited, then so shall be the
actual;
</ul></ul><dt><a name="26">(26)</a><dd><ul><ul><li>For a formal derived type, the actual shall be in the class
rooted at the ancestor subtype.
</ul></ul><dt><a name="27">(27)</a><dd><ul>(10) The actual type can be abstract only if the formal type is abstract
<a href="03-09-03.htm">(see 3.9.3)</a>.
</ul><dt><a name="28">(28)</a><dd><ul>(11) If the formal has a discriminant_part, the actual can be either
definite or indefinite.  Otherwise, the actual has to be definite.
</ul></dl><hr>
<h4><img src="noleft.gif" alt="____"> | <a href="12-05.htm"><img src="up.gif" alt="Up"></a> | <a href="12-05-02.htm"><img src="right.gif" alt="Next"></a> | <a href="12-05.htm"><img src="back.gif" alt="Back"></a> | <a href="12-05-02.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
