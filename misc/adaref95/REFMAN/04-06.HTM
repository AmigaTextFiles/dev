<html>
<head>
<title>Ada 95 RM - 4.6 Type Conversions</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="04-05.htm"><img src="left.gif" alt="Prev"></a> | <a href="04.htm"><img src="up.gif" alt="Up"></a> | <a href="04-07.htm"><img src="right.gif" alt="Next"></a> | <a href="04-05-06.htm"><img src="back.gif" alt="Back"></a> | <a href="04-07.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>

<h2><a name="0">4.6 Type Conversions</a></h2>
<dl><dt><a name="1">(1)</a><dd>Explicit type conversions, both value conversions and view conversions,
are allowed between closely related types as defined below.  This clause also
defines rules for value and view conversions to a particular subtype of a
type, both explicit ones and those implicit in other constructs.
</dl><h5 align="center"><a name="syntax">Syntax</a></h5>
<pre><a name="2">(2)</a>
       type_conversion ::=
           subtype_mark(expression)
         | subtype_mark(name)
</pre><dl><dt><a name="3">(3)</a><dd>The target subtype of a type_conversion is the subtype denoted by the
subtype_mark.  The operand of a type_conversion is the expression or name
within the parentheses; its type is the operand type.
<dt><a name="4">(4)</a><dd>One type is convertible to a second type if a type_conversion with the
first type as operand type and the second type as target type is legal
according to the rules of this clause.  Two types are convertible if each is
convertible to the other.
<dt><a name="5">(5)</a><dd>A type_conversion whose operand is the name of an object is called a view
conversion if its target type is tagged, or if it appears as an actual
parameter of mode out or in out; other type_conversions are called value
conversions.
</dl><h5 align="center">Name Resolution Rules</h5>
<dl><dt><a name="6">(6)</a><dd>The operand of a type_conversion is expected to be of any type.
<dt><a name="7">(7)</a><dd>The operand of a view conversion is interpreted only as a name; the
operand of a value conversion is interpreted as an expression.
</dl><h5 align="center">Legality Rules</h5>
<dl><dt><a name="8">(8)</a><dd>If the target type is a numeric type, then the operand type shall be a
numeric type.
<dt><a name="9">(9)</a><dd>If the target type is an array type, then the operand type shall be an
array type.  Further:
<dt><a name="10">(10)</a><dd><ul><li>The types shall have the same dimensionality;
</ul><dt><a name="11">(11)</a><dd><ul><li>Corresponding index types shall be convertible; and
</ul><dt><a name="12">(12)</a><dd><ul><li>The component subtypes shall statically match.
</ul><dt><a name="13">(13)</a><dd>If the target type is a general access type, then the operand type shall
be an access-to-object type.  Further:
<dt><a name="14">(14)</a><dd><ul><li>If the target type is an access-to-variable type, then the
operand type shall be an access-to-variable type;
</ul><dt><a name="15">(15)</a><dd><ul><li>If the target designated type is tagged, then the operand
designated type shall be convertible to the target designated
type;
</ul><dt><a name="16">(16)</a><dd><ul><li>If the target designated type is not tagged, then the designated
types shall be the same, and either the designated subtypes shall
statically match or the target designated subtype shall be
discriminated and unconstrained; and
</ul><dt><a name="17">(17)</a><dd><ul><li>The accessibility level of the operand type shall not be
statically deeper than that of the target type.    In addition to
the places where Legality Rules normally apply <a href="12-03.htm">(see 12.3)</a>, this
rule applies also in the private part of an instance of a generic
unit.
</ul><dt><a name="18">(18)</a><dd>If the target type is an access-to-subprogram type, then the operand
type shall be an access-to-subprogram type.  Further:
<dt><a name="19">(19)</a><dd><ul><li>The designated profiles shall be subtype-conformant.
</ul><dt><a name="20">(20)</a><dd><ul><li>The accessibility level of the operand type shall not be
statically deeper than that of the target type.    In addition to
the places where Legality Rules normally apply <a href="12-03.htm">(see 12.3)</a>, this
rule applies also in the private part of an instance of a generic
unit.  If the operand type is declared within a generic body, the
target type shall be declared within the generic body.
</ul><dt><a name="21">(21)</a><dd>If the target type is not included in any of the above four cases, there
shall be a type that is an ancestor of both the target type and the operand
type.  Further, if the target type is tagged, then either:
<dt><a name="22">(22)</a><dd><ul><li>The operand type shall be covered by or descended from the target
type; or
</ul><dt><a name="23">(23)</a><dd><ul><li>The operand type shall be a class-wide type that covers the
target type.
</ul><dt><a name="24">(24)</a><dd>In a view conversion for an untagged type, the target type shall be
convertible (back) to the operand type.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="25">(25)</a><dd>A type_conversion that is a value conversion denotes the value that is
the result of converting the value of the operand to the target subtype.
<dt><a name="26">(26)</a><dd>A type_conversion that is a view conversion denotes a view of the object
denoted by the operand.  This view is a variable of the target type if the
operand denotes a variable; otherwise it is a constant of the target type.
<dt><a name="27">(27)</a><dd>The nominal subtype of a type_conversion is its target subtype.
</dl><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="28">(28)</a><dd>For the evaluation of a type_conversion that is a value conversion, the
operand is evaluated, and then the value of the operand is converted to a
corresponding value of the target type, if any.  If there is no value of the
target type that corresponds to the operand value, Constraint_Error is
raised; this can only happen on conversion to a modular type, and only when
the operand value is outside the base range of the modular type.  Additional
rules follow:
<dt><a name="29">(29)</a><dd><ul><li>Numeric Type Conversion
</ul><dt><a name="30">(30)</a><dd><ul><ul><li>If the target and the operand types are both integer
types, then the result is the value of the target type
that corresponds to the same mathematical integer as the
operand.
</ul></ul><dt><a name="31">(31)</a><dd><ul><ul><li>If the target type is a decimal fixed point type, then the
result is truncated (toward 0) if the value of the operand
is not a multiple of the small of the target type.
</ul></ul><dt><a name="32">(32)</a><dd><ul><ul><li>If the target type is some other real type, then the
result is within the accuracy of the target type <a href="G-02.htm">(see G.2</a>,
``Numeric Performance Requirements'', for implementations
that support the Numerics Annex).
</ul></ul><dt><a name="33">(33)</a><dd><ul><ul><li>If the target type is an integer type and the operand type
is real, the result is rounded to the nearest integer
(away from zero if exactly halfway between two integers).
</ul></ul><dt><a name="34">(34)</a><dd><ul><li>Enumeration Type Conversion
</ul><dt><a name="35">(35)</a><dd><ul><ul><li>The result is the value of the target type with the same
position number as that of the operand value.
</ul></ul><dt><a name="36">(36)</a><dd><ul><li>Array Type Conversion
</ul><dt><a name="37">(37)</a><dd><ul><ul><li>If the target subtype is a constrained array subtype, then
a check is made that the length of each dimension of the
value of the operand equals the length of the
corresponding dimension of the target subtype.  The bounds
of the result are those of the target subtype.
</ul></ul><dt><a name="38">(38)</a><dd><ul><ul><li>If the target subtype is an unconstrained array subtype,
then the bounds of the result are obtained by converting
each bound of the value of the operand to the
corresponding index type of the target type.    For each
nonnull index range, a check is made that the bounds of
the range belong to the corresponding index subtype.
</ul></ul><dt><a name="39">(39)</a><dd><ul><ul><li>In either array case, the value of each component of the
result is that of the matching component of the operand
value <a href="04-05-02.htm">(see 4.5.2)</a>.
</ul></ul><dt><a name="40">(40)</a><dd><ul><li>Composite (Non-Array) Type Conversion
</ul><dt><a name="41">(41)</a><dd><ul><ul><li>The value of each nondiscriminant component of the result
is that of the matching component of the operand value.
</ul></ul><dt><a name="42">(42)</a><dd><ul><ul><li>The tag of the result is that of the operand.    If the
operand type is class-wide, a check is made that the tag
of the operand identifies a (specific) type that is
covered by or descended from the target type.
</ul></ul><dt><a name="43">(43)</a><dd><ul><ul><li>For each discriminant of the target type that corresponds
to a discriminant of the operand type, its value is that
of the corresponding discriminant of the operand value;
if it corresponds to more than one discriminant of the
operand type, a check is made that all these discriminants
are equal in the operand value.
</ul></ul><dt><a name="44">(44)</a><dd><ul><ul><li>For each discriminant of the target type that corresponds
to a discriminant that is specified by the derived_type_definition for some ancestor of the operand type (or if
class-wide, some ancestor of the specific type identified
by the tag of the operand), its value in the result is
that specified by the derived_type_definition.
</ul></ul><dt><a name="45">(45)</a><dd><ul><ul><li>For each discriminant of the operand type that corresponds
to a discriminant that is specified by the derived_type_definition for some ancestor of the target type, a check
is made that in the operand value it equals the value
specified for it.
</ul></ul><dt><a name="46">(46)</a><dd><ul><ul><li>For each discriminant of the result, a check is made that
its value belongs to its subtype.
</ul></ul><dt><a name="47">(47)</a><dd><ul><li>Access Type Conversion
</ul><dt><a name="48">(48)</a><dd><ul><ul><li>For an access-to-object type, a check is made that the
accessibility level of the operand type is not deeper than
that of the target type.
</ul></ul><dt><a name="49">(49)</a><dd><ul><ul><li>If the target type is an anonymous access type, a check is
made that the value of the operand is not null; if the
target is not an anonymous access type, then the result is
null if the operand value is null.
</ul></ul><dt><a name="50">(50)</a><dd><ul><ul><li>If the operand value is not null, then the result
designates the same object (or subprogram) as is
designated by the operand value, but viewed as being of
the target designated subtype (or profile); any checks
associated with evaluating a conversion to the target
designated subtype are performed.
</ul></ul><dt><a name="51">(51)</a><dd>After conversion of the value to the target type, if the target subtype
is constrained, a check is performed that the value satisfies this
constraint.
<dt><a name="52">(52)</a><dd>For the evaluation of a view conversion, the operand name is evaluated,
and a new view of the object denoted by the operand is created, whose type is
the target type; if the target type is composite, checks are performed as
above for a value conversion.
<dt><a name="53">(53)</a><dd>The properties of this new view are as follows:
<dt><a name="54">(54)</a><dd><ul><li>If the target type is composite, the bounds or discriminants (if
any) of the view are as defined above for a value conversion;
each nondiscriminant component of the view denotes the matching
component of the operand object; the subtype of the view is
constrained if either the target subtype or the operand object is
constrained, or if the operand type is a descendant of the target
type, and has discriminants that were not inherited from the
target type;
</ul><dt><a name="55">(55)</a><dd><ul><li>If the target type is tagged, then an assignment to the view
assigns to the corresponding part of the object denoted by the
operand; otherwise, an assignment to the view assigns to the
object, after converting the assigned value to the subtype of the
object (which might raise Constraint_Error);
</ul><dt><a name="56">(56)</a><dd><ul><li>Reading the value of the view yields the result of converting the
value of the operand object to the target subtype (which might
raise Constraint_Error), except if the object is of an access
type and the view conversion is passed as an out parameter; in
this latter case, the value of the operand object is used to
initialize the formal parameter without checking against any
constraint of the target subtype <a href="06-04-01.htm">(see 6.4.1)</a>.
</ul><dt><a name="57">(57)</a><dd>If an Accessibility_Check fails, Program_Error is raised.  Any other
check associated with a conversion raises Constraint_Error if it fails.
<dt><a name="58">(58)</a><dd>Conversion to a type is the same as conversion to an unconstrained
subtype of the type.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="59">(59)</a><dd><ul>(20) In addition to explicit type_conversions, type conversions are
performed implicitly in situations where the expected type and the
actual type of a construct differ, as is permitted by the type
resolution rules <a href="08-06.htm">(see 8.6)</a>.  For example, an integer literal is of the
type universal_integer, and is implicitly converted when assigned to a
target of some specific integer type.  Similarly, an actual parameter of
a specific tagged type is implicitly converted when the corresponding
formal parameter is of a class-wide type.
</ul><dt><a name="60">(60)</a><dd><ul>Even when the expected and actual types are the same, implicit
subtype conversions are performed to adjust the array bounds (if any) of
an operand to match the desired target subtype, or to raise Constraint_Error if the (possibly adjusted) value does not satisfy the constraints
of the target subtype.
</ul><dt><a name="61">(61)</a><dd><ul>(21) A ramification of the overload resolution rules is that the operand
of an (explicit) type_conversion cannot be the literal null, an
allocator, an aggregate, a string_literal, a character_literal, or an
attribute_reference for an Access or Unchecked_Access attribute.
Similarly, such an expression enclosed by parentheses is not allowed.  A
qualified_expression <a href="04-07.htm">(see 4.7)</a> can be used instead of such a type_conversion.
</ul><dt><a name="62">(62)</a><dd><ul>(22) The constraint of the target subtype has no effect for a type_conversion of an elementary type passed as an out parameter.  Hence, it
is recommended that the first subtype be specified as the target to
minimize confusion (a similar recommendation applies to renaming and
generic formal in out objects).
</ul></dl><h5 align="center">Examples</h5>
<dl><dt><a name="63">(63)</a><dd><em>Examples of numeric type conversion:
</em>
</dl><pre><a name="64">(64)</a>
       Real(2*J)      <em>--  value is converted to floating point</em>
       Integer(1.6)   <em>--  value is 2</em>
       Integer(-0.4)  <em>--  value is 0</em>
</pre><dl><dt><a name="65">(65)</a><dd><em>Example of conversion between derived types:
</em>
</dl><pre><a name="66">(66)</a>
       type A_Form is new B_Form;
<a name="67">(67)</a>
       X : A_Form;
       Y : B_Form;
<a name="68">(68)</a>
       X := A_Form(Y);
       Y := B_Form(X);  <em>--  the reverse conversion</em>
</pre><dl><dt><a name="69">(69)</a><dd><em>Examples of conversions between array types:
</em>
</dl><pre><a name="70">(70)</a>
       type Sequence is array (Integer range &lt;&gt;) of Integer;
       subtype Dozen is Sequence(1 .. 12);
       Ledger : array(1 .. 100) of Integer;
<a name="71">(71)</a>
       Sequence(Ledger)            <em>--  bounds are those of Ledger</em>
       Sequence(Ledger(31 .. 42))  <em>--  bounds are 31 and 42</em>
       Dozen(Ledger(31 .. 42))     <em>--  bounds are those of Dozen</em>
</pre><p>
<hr>
<h4><a href="04-05.htm"><img src="left.gif" alt="Prev"></a> | <a href="04.htm"><img src="up.gif" alt="Up"></a> | <a href="04-07.htm"><img src="right.gif" alt="Next"></a> | <a href="04-05-06.htm"><img src="back.gif" alt="Back"></a> | <a href="04-07.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
