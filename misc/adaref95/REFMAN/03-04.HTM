<html>
<head>
<title>Ada 95 RM - 3.4 Derived Types and Classes</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="03-03.htm"><img src="left.gif" alt="Prev"></a> | <a href="03.htm"><img src="up.gif" alt="Up"></a> | <a href="03-05.htm"><img src="right.gif" alt="Next"></a> | <a href="03-03-02.htm"><img src="back.gif" alt="Back"></a> | <a href="03-04-01.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>

<h2><a name="0">3.4 Derived Types and Classes</a>
 -- <a href="toc03-04.htm">TOC</a>
</h2>
<dl><dt><a name="1">(1)</a><dd>A derived_type_definition defines a new type (and its first subtype)
whose characteristics are derived from those of a parent type.
</dl><h5 align="center"><a name="syntax">Syntax</a></h5>
<pre><a name="2">(2)</a>
       derived_type_definition ::= [abstract] new parent_subtype_indication [record_extension_part]
</pre><h5 align="center">Legality Rules</h5>
<dl><dt><a name="3">(3)</a><dd>The parent_subtype_indication defines the parent subtype; its type is the
parent type.
<dt><a name="4">(4)</a><dd>A type shall be completely defined <a href="03-11-01.htm">(see 3.11.1)</a> prior to being specified
as the parent type in a derived_type_definition -- the full_type_declarations
for the parent type and any of its subcomponents have to precede the derived_type_definition.
<dt><a name="5">(5)</a><dd>If there is a record_extension_part, the derived type is called a record
extension of the parent type.  A record_extension_part shall be provided if
and only if the parent type is a tagged type.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="6">(6)</a><dd>The first subtype of the derived type is unconstrained if a known_discriminant_part is provided in the declaration of the derived type, or if
the parent subtype is unconstrained.  Otherwise, the constraint of the first
subtype corresponds to that of the parent subtype in the following sense: it
is the same as that of the parent subtype except that for a range constraint
(implicit or explicit), the value of each bound of its range is replaced by
the corresponding value of the derived type.
<dt><a name="7">(7)</a><dd>The characteristics of the derived type are defined as follows:
<dt><a name="8">(8)</a><dd><ul><li>Each class of types that includes the parent type also includes
the derived type.
</ul><dt><a name="9">(9)</a><dd><ul><li>If the parent type is an elementary type or an array type, then
the set of possible values of the derived type is a copy of the
set of possible values of the parent type.  For a scalar type,
the base range of the derived type is the same as that of the
parent type.
</ul><dt><a name="10">(10)</a><dd><ul><li>If the parent type is a composite type other than an array type,
then the components, protected subprograms, and entries that are
declared for the derived type are as follows:
</ul><dt><a name="11">(11)</a><dd><ul><ul><li>The discriminants specified by a new known_discriminant_part, if there is one; otherwise, each discriminant of the
parent type (implicitly declared in the same order with
the same specifications) --   in the latter case, the
discriminants are said to be inherited, or if unknown in
the parent, are also unknown in the derived type;
</ul></ul><dt><a name="12">(12)</a><dd><ul><ul><li>Each nondiscriminant component, entry, and protected
subprogram of the parent type, implicitly declared in the
same order with the same declarations;    these
components, entries, and protected subprograms are said to
be inherited;
</ul></ul><dt><a name="13">(13)</a><dd><ul><ul><li>Each component declared in a record_extension_part, if
any.
</ul></ul><dt><a name="14">(14)</a><dd><ul>Declarations of components, protected subprograms, and
entries, whether implicit or explicit, occur immediately within
the declarative region of the type, in the order indicated above,
following the parent subtype_indication.
</ul><dt><a name="15">(15)</a><dd><ul><li>The derived type is limited if and only if the parent type is
limited.
</ul><dt><a name="16">(16)</a><dd><ul><li>For each predefined operator of the parent type, there is a
corresponding predefined operator of the derived type.
</ul><dt><a name="17">(17)</a><dd><ul><li>For each user-defined primitive subprogram (other than a
user-defined equality operator -- see below) of the parent type
that already exists at the place of the derived_type_definition,
there exists a corresponding inherited primitive subprogram of
the derived type with the same defining name.  Primitive
user-defined equality operators of the parent type are also
inherited by the derived type, except when the derived type is a
nonlimited record extension, and the inherited operator would
have a profile that is type conformant with the profile of the
corresponding predefined equality operator; in this case, the
user-defined equality operator is not inherited, but is rather
incorporated into the implementation of the predefined equality
operator of the record extension <a href="04-05-02.htm">(see 4.5.2)</a>.
</ul><dt><a name="18">(18)</a><dd><ul>The profile of an inherited subprogram (including an
inherited enumeration literal) is obtained from the profile of
the corresponding (user-defined) primitive subprogram of the
parent type, after systematic replacement of each subtype of its
profile <a href="06-01.htm">(see 6.1)</a> that is of the parent type with a corresponding
subtype of the derived type.  For a given subtype of the parent
type, the corresponding subtype of the derived type is defined as
follows:
</ul><dt><a name="19">(19)</a><dd><ul><ul><li>If the declaration of the derived type has neither a
known_discriminant_part nor a record_extension_part, then
the corresponding subtype has a constraint that
corresponds (as defined above for the first subtype of the
derived type) to that of the given subtype.
</ul></ul><dt><a name="20">(20)</a><dd><ul><ul><li>If the derived type is a record extension, then the
corresponding subtype is the first subtype of the derived
type.
</ul></ul><dt><a name="21">(21)</a><dd><ul><ul><li>If the derived type has a new known_discriminant_part but
is not a record extension, then the corresponding subtype
is constrained to those values that when converted to the
parent type belong to the given subtype <a href="04-06.htm">(see 4.6)</a>.
</ul></ul><dt><a name="22">(22)</a><dd><ul>The same formal parameters have default_expressions in the
profile of the inherited subprogram.  Any type mismatch due to
the systematic replacement of the parent type by the derived type
is handled as part of the normal type conversion associated with
parameter passing -- <a href="06-04-01.htm">see 6.4.1</a>.
</ul><dt><a name="23">(23)</a><dd>If a primitive subprogram of the parent type is visible at the place of
the derived_type_definition, then the corresponding inherited subprogram is
implicitly declared immediately after the derived_type_definition.  Otherwise, the inherited subprogram is implicitly declared later or not at all, as
explained <a href="07-03-01.htm">in 7.3.1</a>.
<dt><a name="24">(24)</a><dd>A derived type can also be defined by a private_extension_declaration
<a href="07-03.htm">(see 7.3)</a> or a formal_derived_type_definition <a href="12-05-01.htm">(see 12.5.1)</a>.  Such a derived
type is a partial view of the corresponding full or actual type.
<dt><a name="25">(25)</a><dd>All numeric types are derived types, in that they are implicitly derived
from a corresponding root numeric type <a href="03-05-04.htm">(see 3.5.4</a> and <a href="03-05-06.htm">3.5.6)</a>.
</dl><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="26">(26)</a><dd>The elaboration of a derived_type_definition creates the derived type
and its first subtype, and consists of the elaboration of the subtype_indication and the record_extension_part, if any.  If the subtype_indication
depends on a discriminant, then only those expressions that do not depend on
a discriminant are evaluated.
<dt><a name="27">(27)</a><dd>For the execution of a call on an inherited subprogram, a call on the
corresponding primitive subprogram of the parent type is performed; the
normal conversion of each actual parameter to the subtype of the
corresponding formal parameter <a href="06-04-01.htm">(see 6.4.1)</a> performs any necessary type
conversion as well.  If the result type of the inherited subprogram is the
derived type, the result of calling the parent's subprogram is converted to
the derived type.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="28">(28)</a><dd><ul>(10) Classes are closed under derivation -- any class that contains a
type also contains its derivatives.  Operations available for a given
class of types are available for the derived types in that class.
</ul><dt><a name="29">(29)</a><dd><ul>(11) Evaluating an inherited enumeration literal is equivalent to
evaluating the corresponding enumeration literal of the parent type, and
then converting the result to the derived type.  This follows from their
equivalence to parameterless functions.
</ul><dt><a name="30">(30)</a><dd><ul>(12) A generic subprogram is not a subprogram, and hence cannot be a
primitive subprogram and cannot be inherited by a derived type.  On the
other hand, an instance of a generic subprogram can be a primitive
subprogram, and hence can be inherited.
</ul><dt><a name="31">(31)</a><dd><ul>(13) If the parent type is an access type, then the parent and the
derived type share the same storage pool; there is a null access value
for the derived type and it is the implicit initial value for the type.
See <a href="03-10.htm">3.10</a>.
</ul><dt><a name="32">(32)</a><dd><ul>(14) If the parent type is a boolean type, the predefined relational
operators of the derived type deliver a result of the predefined type
Boolean <a href="04-05-02.htm">(see 4.5.2)</a>.  If the parent type is an integer type, the right
operand of the predefined exponentiation operator is of the predefined
type Integer <a href="04-05-06.htm">(see 4.5.6)</a>.
</ul><dt><a name="33">(33)</a><dd><ul>(15) Any discriminants of the parent type are either all inherited, or
completely replaced with a new set of discriminants.
</ul><dt><a name="34">(34)</a><dd><ul>(16) For an inherited subprogram, the subtype of a formal parameter of
the derived type need not have any value in common with the first
subtype of the derived type.
</ul><dt><a name="35">(35)</a><dd><ul>(17) If the reserved word abstract is given in the declaration of a
type, the type is abstract <a href="03-09-03.htm">(see 3.9.3)</a>.
</ul></dl><h5 align="center">Examples</h5>
<dl><dt><a name="36">(36)</a><dd><em>Examples of derived type declarations:
</em>
</dl><pre><a name="37">(37)</a>
       type Local_Coordinate is new Coordinate;   <em>--  two different types</em>
       type Midweek is new Day range Tue .. Thu;  <em>--  <a href="03-05-01.htm">see 3.5.1</a></em>
       type Counter is new Positive;              <em>--  same range as Positive</em>
<a name="38">(38)</a>
       type Special_Key is new Key_Manager.Key;   <em>--  <a href="07-03-01.htm">see 7.3.1</a></em>
         <em>-- the inherited subprograms have the following specifications:</em>
         <em>--         procedure Get_Key(K : out Special_Key);</em>
         <em>--         function "&lt;"(X,Y : Special_Key) return Boolean;</em>
</pre><hr><h3>Subclauses</h3>
<ol>
<li><a href="03-04-01.htm">Derivation Classes</a>
</ol>
<p>
<hr>
<h4><a href="03-03.htm"><img src="left.gif" alt="Prev"></a> | <a href="03.htm"><img src="up.gif" alt="Up"></a> | <a href="03-05.htm"><img src="right.gif" alt="Next"></a> | <a href="03-03-02.htm"><img src="back.gif" alt="Back"></a> | <a href="03-04-01.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
