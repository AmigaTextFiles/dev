<html>
<head>
<title>Ada 95 RM - 7.3 Private Types and Private Extensions</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="07-02.htm"><img src="left.gif" alt="Prev"></a> | <a href="07.htm"><img src="up.gif" alt="Up"></a> | <a href="07-04.htm"><img src="right.gif" alt="Next"></a> | <a href="07-02.htm"><img src="back.gif" alt="Back"></a> | <a href="07-03-01.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>

<h2><a name="0">7.3 Private Types and Private Extensions</a>
 -- <a href="toc07-03.htm">TOC</a>
</h2>
<dl><dt><a name="1">(1)</a><dd>The declaration (in the visible part of a package) of a type as a private
type or private extension serves to separate the characteristics that can be
used directly by outside program units (that is, the logical properties) from
other characteristics whose direct use is confined to the package (the
details of the definition of the type itself).  <a href="03-09-01.htm">See 3.9.1</a> for an overview of
type extensions.
</dl><h5 align="center"><a name="syntax">Syntax</a></h5>
<pre><a name="2">(2)</a>
       private_type_declaration ::=
          type defining_identifier [discriminant_part] is [[abstract] tagged] [limited] private;
<a name="3">(3)</a>
       private_extension_declaration ::=
          type defining_identifier [discriminant_part] is
            [abstract] new ancestor_subtype_indication with private;
</pre><h5 align="center">Legality Rules</h5>
<dl><dt><a name="4">(4)</a><dd>A private_type_declaration or private_extension_declaration declares a
partial view of the type; such a declaration is allowed only as a
declarative_item of the visible part of a package, and it requires a
completion, which shall be a full_type_declaration that occurs as a
declarative_item of the private part of the package.  The view of the type
declared by the full_type_declaration is called the full view.  A generic
formal private type or a generic formal private extension is also a partial
view.
<dt><a name="5">(5)</a><dd>A type shall be completely defined before it is frozen <a href="03-11-01.htm">(see 3.11.1</a> and
13.14).  Thus, neither the declaration of a variable of a partial view of a
type, nor the creation by an allocator of an object of the partial view are
allowed before the full declaration of the type.  Similarly, before the full
declaration, the name of the partial view cannot be used in a generic_instantiation or in a representation item.
<dt><a name="6">(6)</a><dd>A private type is limited if its declaration includes the reserved word
limited; a private extension is limited if its ancestor type is limited.  If
the partial view is nonlimited, then the full view shall be nonlimited.  If a
tagged partial view is limited, then the full view shall be limited.  On the
other hand, if an untagged partial view is limited, the full view may be
limited or nonlimited.
<dt><a name="7">(7)</a><dd>If the partial view is tagged, then the full view shall be tagged.  On
the other hand, if the partial view is untagged, then the full view may be
tagged or untagged.  In the case where the partial view is untagged and the
full view is tagged, no derivatives of the partial view are allowed within
the immediate scope of the partial view; derivatives of the full view are
allowed.
<dt><a name="8">(8)</a><dd>The ancestor subtype of a private_extension_declaration is the subtype
defined by the ancestor_subtype_indication; the ancestor type shall be a
specific tagged type.  The full view of a private extension shall be derived
(directly or indirectly) from the ancestor type.  In addition to the places
where Legality Rules normally apply <a href="12-03.htm">(see 12.3)</a>, the requirement that the
ancestor be specific applies also in the private part of an instance of a
generic unit.
<dt><a name="9">(9)</a><dd>If the declaration of a partial view includes a known_discriminant_part,
then the full_type_declaration shall have a fully conforming (explicit)
known_discriminant_part <a href="06-03-01.htm">(see 6.3.1</a>, ``Conformance Rules'').  The ancestor
subtype may be unconstrained; the parent subtype of the full view is required
to be constrained <a href="03-07.htm">(see 3.7)</a>.
<dt><a name="10">(10)</a><dd>If a private extension inherits known discriminants from the ancestor
subtype, then the full view shall also inherit its discriminants from the
ancestor subtype, and the parent subtype of the full view shall be
constrained if and only if the ancestor subtype is constrained.
<dt><a name="11">(11)</a><dd>If a partial view has unknown discriminants, then the full_type_declaration may define a definite or an indefinite subtype, with or without
discriminants.
<dt><a name="12">(12)</a><dd>If a partial view has neither known nor unknown discriminants, then the
full_type_declaration shall define a definite subtype.
<dt><a name="13">(13)</a><dd>If the ancestor subtype of a private extension has constrained
discriminants, then the parent subtype of the full view shall impose a
statically matching constraint on those discriminants.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="14">(14)</a><dd>A private_type_declaration declares a private type and its first
subtype.  Similarly, a private_extension_declaration declares a private
extension and its first subtype.
<dt><a name="15">(15)</a><dd>A declaration of a partial view and the corresponding full_type_declaration define two views of a single type.  The declaration of a partial
view together with the visible part define the operations that are available
to outside program units; the declaration of the full view together with the
private part define other operations whose direct use is possible only within
the declarative region of the package itself.  Moreover, within the scope of
the declaration of the full view, the characteristics of the type are
determined by the full view; in particular, within its scope, the full view
determines the classes that include the type, which components, entries, and
protected subprograms are visible, what attributes and other predefined
operations are allowed, and whether the first subtype is static.  <a href="07-03-01.htm">See 7.3.1</a>.
<dt><a name="16">(16)</a><dd>A private extension inherits components (including discriminants unless
there is a new discriminant_part specified) and user-defined primitive
subprograms from its ancestor type, in the same way that a record extension
inherits components and user-defined primitive subprograms from its parent
type <a href="03-04.htm">(see 3.4)</a>.
</dl><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="17">(17)</a><dd>The elaboration of a private_type_declaration creates a partial view of
a type.  The elaboration of a private_extension_declaration elaborates the
ancestor_subtype_indication, and creates a partial view of a type.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="18">(18)</a><dd><ul>(5) The partial view of a type as declared by a private_type_declaration
is defined to be a composite view <a href="03-02.htm">(in 3.2)</a>.  The full view of the type
might or might not be composite.  A private extension is also composite,
as is its full view.
</ul><dt><a name="19">(19)</a><dd><ul>(6) Declaring a private type with an unknown_discriminant_part is a way
of preventing clients from creating uninitialized objects of the type;
they are then forced to initialize each object by calling some operation
declared in the visible part of the package.  If such a type is also
limited, then no objects of the type can be declared outside the scope
of the full_type_declaration, restricting all object creation to the
package defining the type.  This allows complete control over all
storage allocation for the type.  Objects of such a type can still be
passed as parameters, however.
</ul><dt><a name="20">(20)</a><dd><ul>(7) The ancestor type specified in a private_extension_declaration and
the parent type specified in the corresponding declaration of a record
extension given in the private part need not be the same -- the parent
type of the full view can be any descendant of the ancestor type.  In
this case, for a primitive subprogram that is inherited from the
ancestor type and not overridden, the formal parameter names and default
expressions (if any) come from the corresponding primitive subprogram of
the specified ancestor type, while the body comes from the corresponding
primitive subprogram of the parent type of the full view.  <a href="03-09-02.htm">See 3.9.2</a>.
</ul></dl><h5 align="center">Examples</h5>
<dl><dt><a name="21">(21)</a><dd><em>Examples of private type declarations:
</em>
</dl><pre><a name="22">(22)</a>
       type Key is private;
       type File_Name is limited private;
</pre><dl><dt><a name="23">(23)</a><dd><em>Example of a private extension declaration:
</em>
</dl><pre><a name="24">(24)</a>
       type List is new Ada.Finalization.Controlled with private;
</pre><hr><h3>Subclauses</h3>
<ol>
<li><a href="07-03-01.htm">Private Operations</a>
</ol>
<p>
<hr>
<h4><a href="07-02.htm"><img src="left.gif" alt="Prev"></a> | <a href="07.htm"><img src="up.gif" alt="Up"></a> | <a href="07-04.htm"><img src="right.gif" alt="Next"></a> | <a href="07-02.htm"><img src="back.gif" alt="Back"></a> | <a href="07-03-01.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
