<html>
<head>
<title>Ada 95 RM - B.3 Interfacing with C</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="B-02.htm"><img src="left.gif" alt="Prev"></a> | <a href="B.htm"><img src="up.gif" alt="Up"></a> | <a href="B-04.htm"><img src="right.gif" alt="Next"></a> | <a href="B-02.htm"><img src="back.gif" alt="Back"></a> | <a href="B-03-01.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>

<h2><a name="0">B.3 Interfacing with C</a>
 -- <a href="tocB-03.htm">TOC</a>
</h2>
<dl><dt><a name="1">(1)</a><dd>The facilities relevant to interfacing with the C language are the
package Interfaces.C and its children; and support for the Import, Export,
and Convention pragmas with convention_identifier C.
<dt><a name="2">(2)</a><dd>The package Interfaces.C contains the basic types, constants and
subprograms that allow an Ada program to pass scalars and strings to C
functions.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="3">(3)</a><dd>The library package Interfaces.C has the following declaration:
</dl><pre><a name="4">(4)</a>
       package Interfaces.C is
          pragma Pure(C);
<a name="5">(5)</a>
          <em>-- Declarations based on C's &lt;limits.h&gt;</em>
<a name="6">(6)</a>
          CHAR_BIT  : constant := implementation-defined;  <em>-- typically 8</em>
          SCHAR_MIN : constant := implementation-defined;  <em>-- typically -128</em>
          SCHAR_MAX : constant := implementation-defined;  <em>-- typically 127</em>
          UCHAR_MAX : constant := implementation-defined;  <em>-- typically 255</em>
<a name="7">(7)</a>
          <em>-- Signed and Unsigned Integers</em>
          type int   is range implementation-defined;
          type short is range implementation-defined;
          type long  is range implementation-defined;
<a name="8">(8)</a>
          type signed_char is range SCHAR_MIN .. SCHAR_MAX;
          for signed_char'Size use CHAR_BIT;
<a name="9">(9)</a>
          type unsigned       is mod implementation-defined;
          type unsigned_short is mod implementation-defined;
          type unsigned_long  is mod implementation-defined;
<a name="10">(10)</a>
          type unsigned_char is mod (UCHAR_MAX+1);
          for unsigned_char'Size use CHAR_BIT;
<a name="11">(11)</a>
          subtype plain_char is implementation-defined;
<a name="12">(12)</a>
          type ptrdiff_t is range implementation-defined;
<a name="13">(13)</a>
          type size_t is mod implementation-defined;
<a name="14">(14)</a>
          <em>-- Floating Point</em>
<a name="15">(15)</a>
          type C_float     is digits implementation-defined;
<a name="16">(16)</a>
          type double      is digits implementation-defined;
<a name="17">(17)</a>
          type long_double is digits implementation-defined;
<a name="18">(18)</a>
          <em>-- Characters and Strings</em>
<a name="19">(19)</a>
          type char is &lt;implementation-defined character type&gt;;
<a name="20">(20)</a>
          nul : constant char := char'First;
<a name="21">(21)</a>
          function To_C   (Item : in Character) return char;
<a name="22">(22)</a>
          function To_Ada (Item : in char) return Character;
<a name="23">(23)</a>
          type char_array is array (size_t range &lt;&gt;) of aliased char;
          pragma Pack(char_array);
          for char_array'Component_Size use CHAR_BIT;
<a name="24">(24)</a>
          function Is_Nul_Terminated (Item : in char_array) return Boolean;
<a name="25">(25)</a>
          function To_C   (Item       : in String;
                           Append_Nul : in Boolean := True)
             return char_array;
<a name="26">(26)</a>
          function To_Ada (Item     : in char_array;
                           Trim_Nul : in Boolean := True)
             return String;
<a name="27">(27)</a>
          procedure To_C (Item       : in String;
                          Target     : out char_array;
                          Count      : out size_t;
                          Append_Nul : in Boolean := True);
<a name="28">(28)</a>
          procedure To_Ada (Item     : in char_array;
                            Target   : out String;
                            Count    : out Natural;
                            Trim_Nul : in Boolean := True);
<a name="29">(29)</a>
          <em>-- Wide Character and Wide String</em>
<a name="30">(30)</a>
          type wchar_t is implementation-defined;
<a name="31">(31)</a>
          wide_nul : constant wchar_t := wchar_t'First;
<a name="32">(32)</a>
          function To_C   (Item : in Wide_Character) return wchar_t;
          function To_Ada (Item : in wchar_t       ) return Wide_Character;
<a name="33">(33)</a>
          type wchar_array is array (size_t range &lt;&gt;) of aliased wchar_t;
<a name="34">(34)</a>
          pragma Pack(wchar_array);
<a name="35">(35)</a>
          function Is_Nul_Terminated (Item : in wchar_array) return Boolean;
<a name="36">(36)</a>
          function To_C   (Item       : in Wide_String;
                           Append_Nul : in Boolean := True)
             return wchar_array;
<a name="37">(37)</a>
          function To_Ada (Item     : in wchar_array;
                           Trim_Nul : in Boolean := True)
             return Wide_String;
<a name="38">(38)</a>
          procedure To_C (Item       : in  Wide_String;
                          Target     : out wchar_array;
                          Count      : out size_t;
                          Append_Nul : in  Boolean := True);
<a name="39">(39)</a>
          procedure To_Ada (Item     : in  wchar_array;
                            Target   : out Wide_String;
                            Count    : out Natural;
                            Trim_Nul : in  Boolean := True);
<a name="40">(40)</a>
          Terminator_Error : exception;
<a name="41">(41)</a>
       end Interfaces.C;
</pre><dl><dt><a name="42">(42)</a><dd>Each of the types declared in Interfaces.C is C-compatible.
<dt><a name="43">(43)</a><dd>The types int, short, long, unsigned, ptrdiff_t, size_t, double, char,
and wchar_t correspond respectively to the C types having the same names.
The types signed_char, unsigned_short, unsigned_long, unsigned_char, C_float,
and long_double correspond respectively to the C types signed char, unsigned
short, unsigned long, unsigned char, float, and long double.
<dt><a name="44">(44)</a><dd>The type of the subtype plain_char is either signed_char or unsigned_char, depending on the C implementation.
</dl><pre><a name="45">(45)</a>
       function To_C   (Item : in Character) return char;
       function To_Ada (Item : in char     ) return Character;
</pre><dl><dt><a name="46">(46)</a><dd><ul>The functions To_C and To_Ada map between the Ada type Character
and the C type char.
</ul></dl><pre><a name="47">(47)</a>
       function Is_Nul_Terminated (Item : in char_array) return Boolean;
</pre><dl><dt><a name="48">(48)</a><dd><ul>The result of Is_Nul_Terminated is True if Item contains nul,
and is False otherwise.
</ul></dl><pre><a name="49">(49)</a>
       function To_C   (Item : in String;     Append_Nul : in Boolean := True)
          return char_array;

       function To_Ada (Item : in char_array; Trim_Nul   : in Boolean := True)
          return String;
</pre><dl><dt><a name="50">(50)</a><dd><ul>The result of To_C is a char_array value of length Item'Length
(if Append_Nul is False) or Item'Length+1 (if Append_Nul is True).
The lower bound is 0.  For each component Item(I), the corresponding
component in the result is To_C applied to Item(I).  The value nul is
appended if Append_Nul is True.
</ul><dt><a name="51">(51)</a><dd><ul>The result of To_Ada is a String whose length is Item'Length (if
Trim_Nul is False) or the length of the slice of Item preceding the
first nul (if Trim_Nul is True).  The lower bound of the result is 1.
If Trim_Nul is False, then for each component Item(I) the
corresponding component in the result is To_Ada applied to Item(I).
If Trim_Nul is True, then for each component Item(I) before the first
nul the corresponding component in the result is To_Ada applied to
Item(I).  The function propagates Terminator_Error if Trim_Nul is
True and Item does not contain nul.
</ul></dl><pre><a name="52">(52)</a>
       procedure To_C (Item       : in String;
                       Target     : out char_array;
                       Count      : out size_t;
                       Append_Nul : in Boolean := True);

       procedure To_Ada (Item     : in char_array;
                         Target   : out String;
                         Count    : out Natural;
                         Trim_Nul : in Boolean := True);
</pre><dl><dt><a name="53">(53)</a><dd><ul>For procedure To_C, each element of Item is converted (via the
To_C function) to a char, which is assigned to the corresponding
element of Target.  If Append_Nul is True, nul is then assigned to
the next element of Target.  In either case, Count is set to the
number of Target elements assigned.  If Target is not long enough,
Constraint_Error is propagated.
</ul><dt><a name="54">(54)</a><dd><ul>For procedure To_Ada, each element of Item (if Trim_Nul is
False) or each element of Item preceding the first nul (if Trim_Nul
is True) is converted (via the To_Ada function) to a Character, which
is assigned to the corresponding element of Target.  Count is set to
the number of Target elements assigned.  If Target is not long
enough, Constraint_Error is propagated.  If Trim_Nul is True and Item
does not contain nul, then Terminator_Error is propagated.
</ul></dl><pre><a name="55">(55)</a>
       function Is_Nul_Terminated (Item : in wchar_array) return Boolean;
</pre><dl><dt><a name="56">(56)</a><dd><ul>The result of Is_Nul_Terminated is True if Item contains wide_nul, and is False otherwise.
</ul></dl><pre><a name="57">(57)</a>
       function To_C   (Item : in Wide_Character) return wchar_t;
       function To_Ada (Item : in wchar_t       ) return Wide_Character;
</pre><dl><dt><a name="58">(58)</a><dd><ul>To_C and To_Ada provide the mappings between the Ada and C wide
character types.
</ul></dl><pre><a name="59">(59)</a>
       function To_C   (Item       : in Wide_String;
                        Append_Nul : in Boolean := True)
          return wchar_array;

       function To_Ada (Item     : in wchar_array;
                        Trim_Nul : in Boolean := True)
          return Wide_String;

       procedure To_C (Item       : in Wide_String;
                       Target     : out wchar_array;
                       Count      : out size_t;
                       Append_Nul : in Boolean := True);

       procedure To_Ada (Item     : in wchar_array;
                         Target   : out Wide_String;
                         Count    : out Natural;
                         Trim_Nul : in Boolean := True);
</pre><dl><dt><a name="60">(60)</a><dd><ul>The To_C and To_Ada subprograms that convert between Wide_String
and wchar_array have analogous effects to the To_C and To_Ada
subprograms that convert between String and char_array, except that
wide_nul is used instead of nul.
</ul></dl><h5 align="center">Implementation Requirements</h5>
<dl><dt><a name="61">(61)</a><dd>An implementation shall support pragma Convention with a C
convention_identifier for a C-eligible type <a href="B-01.htm">(see B.1)</a>
</dl><h5 align="center">Implementation Permissions</h5>
<dl><dt><a name="62">(62)</a><dd>An implementation may provide additional declarations in the C interface
packages.
</dl><h5 align="center">Implementation Advice</h5>
<dl><dt><a name="63">(63)</a><dd>An implementation should support the following interface correspondences
between Ada and C.
<dt><a name="64">(64)</a><dd><ul><li>An Ada procedure corresponds to a void-returning C function.
</ul><dt><a name="65">(65)</a><dd><ul><li>An Ada function corresponds to a non-void C function.
</ul><dt><a name="66">(66)</a><dd><ul><li>An Ada in scalar parameter is passed as a scalar argument to a C
function.
</ul><dt><a name="67">(67)</a><dd><ul><li>An Ada in parameter of an access-to-object type with designated
type T is passed as a t* argument to a C function, where t is the
C type corresponding to the Ada type T.
</ul><dt><a name="68">(68)</a><dd><ul><li>An Ada access T parameter, or an Ada out or in out parameter of
an elementary type T, is passed as a t* argument to a C function,
where t is the C type corresponding to the Ada type T. In the
case of an elementary out or in out parameter, a pointer to a
temporary copy is used to preserve by-copy semantics.
</ul><dt><a name="69">(69)</a><dd><ul><li>An Ada parameter of a record type T, of any mode, is passed as a
t* argument to a C function, where t is the C struct
corresponding to the Ada type T.
</ul><dt><a name="70">(70)</a><dd><ul><li>An Ada parameter of an array type with component type T, of any
mode, is passed as a t* argument to a C function, where t is the
C type corresponding to the Ada type T.
</ul><dt><a name="71">(71)</a><dd><ul><li>An Ada parameter of an access-to-subprogram type is passed as a
pointer to a C function whose prototype corresponds to the
designated subprogram's specification.
</ul><p><dt><dd><ul>NOTES</ul>
<dt><a name="72">(72)</a><dd><ul>(9) Values of type char_array are not implicitly terminated with nul.
If a char_array is to be passed as a parameter to an imported C function
requiring nul termination, it is the programmer's responsibility to
obtain this effect.
</ul><dt><a name="73">(73)</a><dd><ul>(10) To obtain the effect of C's sizeof(item_type), where Item_Type is
the corresponding Ada type, evaluate the expression: size_t(Item_Type'Size/CHAR_BIT).
</ul><dt><a name="74">(74)</a><dd><ul>(11) There is no explicit support for C's union types.  Unchecked
conversions can be used to obtain the effect of C unions.
</ul><dt><a name="75">(75)</a><dd><ul>(12) A C function that takes a variable number of arguments can
correspond to several Ada subprograms, taking various specific numbers
and types of parameters.
</ul></dl><h5 align="center">Examples</h5>
<dl><dt><a name="76">(76)</a><dd><em>Example of using the Interfaces.C package:
</em>
</dl><pre><a name="77">(77)</a>
       <em>--Calling the C Library Function strcpy</em>
       with Interfaces.C;
       procedure Test is
          package C renames Interfaces.C;
          use type C.char_array;
          <em>-- Call &lt;string.h&gt;strcpy:</em>
          <em>-- C definition of strcpy:  char *strcpy(char *s1, const char *s2);</em>
          <em>--    This function copies the string pointed to by s2 (including the terminating null character)</em>
          <em>--     into the array pointed to by s1.  If copying takes place between objects that overlap,</em>
          <em>--     the behavior is undefined.  The strcpy function returns the valueof s1.</em>
<a name="78">(78)</a>
          <em>-- Note: since the C function's return value is of no interest, the Ada interface is a procedure</em>
          procedure Strcpy (Target : out C.char_array;
                            Source : in  C.char_array);
<a name="79">(79)</a>
          pragma Import(C, Strcpy, "strcpy");
<a name="80">(80)</a>
          Chars1 :  C.char_array(1..20);
          Chars2 :  C.char_array(1..20);
<a name="81">(81)</a>
       begin
          Chars2(1..6) := "qwert" &amp; C.nul;
<a name="82">(82)</a>
          Strcpy(Chars1, Chars2);
<a name="83">(83)</a>
       <em>-- Now Chars1(1..6) = "qwert" &amp; C.Nul</em>
<a name="84">(84)</a>
       end Test;
</pre><hr><h3>Subclauses</h3>
<ol>
<li><a href="B-03-01.htm">The Package Interfaces.C.Strings</a>
<li><a href="B-03-02.htm">The Generic Package Interfaces.C.Pointers</a>
</ol>
<p>
<hr>
<h4><a href="B-02.htm"><img src="left.gif" alt="Prev"></a> | <a href="B.htm"><img src="up.gif" alt="Up"></a> | <a href="B-04.htm"><img src="right.gif" alt="Next"></a> | <a href="B-02.htm"><img src="back.gif" alt="Back"></a> | <a href="B-03-01.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
