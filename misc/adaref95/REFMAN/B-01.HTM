<html>
<head>
<title>Ada 95 RM - B.1 Interfacing Pragmas</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><img src="noleft.gif" alt="____"> | <a href="B.htm"><img src="up.gif" alt="Up"></a> | <a href="B-02.htm"><img src="right.gif" alt="Next"></a> | <a href="B.htm"><img src="back.gif" alt="Back"></a> | <a href="B-02.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>

<h2><a name="0">B.1 Interfacing Pragmas</a></h2>
<dl><dt><a name="1">(1)</a><dd>A pragma Import is used to import an entity defined in a foreign language
into an Ada program, thus allowing a foreign-language subprogram to be called
from Ada, or a foreign-language variable to be accessed from Ada.  In
contrast, a pragma Export is used to export an Ada entity to a foreign
language, thus allowing an Ada subprogram to be called from a foreign
language, or an Ada object to be accessed from a foreign language.  The
pragmas Import and Export are intended primarily for objects and subprograms,
although implementations are allowed to support other entities.
<dt><a name="2">(2)</a><dd>A pragma Convention is used to specify that an Ada entity should use the
conventions of another language.  It is intended primarily for types and
``callback'' subprograms.  For example, ``pragma Convention(Fortran,
Matrix);'' implies that Matrix should be represented according to the
conventions of the supported Fortran implementation, namely column-major
order.
<dt><a name="3">(3)</a><dd>A pragma Linker_Options is used to specify the system linker parameters
needed when a given compilation unit is included in a partition.
</dl><h5 align="center"><a name="syntax">Syntax</a></h5>
<dl><dt><a name="4">(4)</a><dd><ul><li>An interfacing pragma is a representation pragma that is one of the
pragmas Import, Export, or Convention.  Their forms, together with that
of the related pragma Linker_Options, are as follows:
</ul></dl><pre><a name="5">(5)</a>
         pragma Import(
             [Convention =&gt;] convention_identifier, [Entity =&gt;] local_name
          [, [External_Name =&gt;] string_expression] [, [Link_Name =&gt;] string_expression]);
<a name="6">(6)</a>
         pragma Export(
             [Convention =&gt;] convention_identifier, [Entity =&gt;] local_name
          [, [External_Name =&gt;] string_expression] [, [Link_Name =&gt;] string_expression]);
<a name="7">(7)</a>
         pragma Convention([Convention =&gt;] convention_identifier,[Entity =&gt;] local_name);
<a name="8">(8)</a>
         pragma Linker_Options(string_expression);
</pre><dl><dt><a name="9">(9)</a><dd><ul><li>A pragma Linker_Options is allowed only at the place of a
declarative_item.
</ul></dl><h5 align="center">Name Resolution Rules</h5>
<dl><dt><a name="10">(10)</a><dd>The expected type for a string_expression in an interfacing pragma or in
pragma Linker_Options is String.
</dl><h5 align="center">Legality Rules</h5>
<dl><dt><a name="11">(11)</a><dd>The convention_identifier of an interfacing pragma shall be the name of
a convention.  The convention names are implementation defined, except for
certain language-defined ones, such as Ada and Intrinsic, as explained in
<a href="06-03-01.htm">6.3.1</a>, ``Conformance Rules''.  Additional convention names generally
represent the calling conventions of foreign languages, language
implementations, or specific run-time models.  The convention of a callable
entity is its calling convention.
<dt><a name="12">(12)</a><dd>If L is a convention_identifier for a language, then a type T is said to
be compatible with convention L, (alternatively, is said to be an
L-compatible type) if any of the following conditions are met:
<dt><a name="13">(13)</a><dd><ul><li>T is declared in a language interface package corresponding to L
and is defined to be L-compatible <a href="B-03.htm">(see B.3</a>, <a href="B-03-01.htm">B.3.1</a>, <a href="B-03-02.htm">B.3.2</a>, <a href="B-04.htm">B.4</a>,
<a href="B-05.htm">B.5)</a>,
</ul><dt><a name="14">(14)</a><dd><ul><li>Convention L has been specified for T in a pragma Convention, and
T is eligible for convention L; that is:
</ul><dt><a name="15">(15)</a><dd><ul><ul><li>T is an array type with either an unconstrained or
statically-constrained first subtype, and its component
type is L-compatible,
</ul></ul><dt><a name="16">(16)</a><dd><ul><ul><li>T is a record type that has no discriminants and that only
has components with statically-constrained subtypes, and
each component type is L-compatible,
</ul></ul><dt><a name="17">(17)</a><dd><ul><ul><li>T is an access-to-object type, and its designated type is
L-compatible,
</ul></ul><dt><a name="18">(18)</a><dd><ul><ul><li>T is an access-to-subprogram type, and its designated
profile's parameter and result types are all L-compatible.
</ul></ul><dt><a name="19">(19)</a><dd><ul><li>T is derived from an L-compatible type,
</ul><dt><a name="20">(20)</a><dd><ul><li>The implementation permits T as an L-compatible type.
</ul><dt><a name="21">(21)</a><dd>If pragma Convention applies to a type, then the type shall either be
compatible with or eligible for the convention specified in the pragma.
<dt><a name="22">(22)</a><dd>A pragma Import shall be the completion of a declaration.
Notwithstanding any rule to the contrary, a pragma Import may serve as the
completion of any kind of (explicit) declaration if supported by an
implementation for that kind of declaration.  If a completion is a pragma
Import, then it shall appear in the same declarative_part, package_specification, task_definition or protected_definition as the declaration.
For a library unit, it shall appear in the same compilation, before any
subsequent compilation_units other than pragmas.  If the local_name denotes
more than one entity, then the pragma Import is the completion of all of
them.
<dt><a name="23">(23)</a><dd>An entity specified as the Entity argument to a pragma Import (or pragma
Export) is said to be imported (respectively, exported).
<dt><a name="24">(24)</a><dd>The declaration of an imported object shall not include an explicit
initialization expression.  Default initializations are not performed.
<dt><a name="25">(25)</a><dd>The type of an imported or exported object shall be compatible with the
convention specified in the corresponding pragma.
<dt><a name="26">(26)</a><dd>For an imported or exported subprogram, the result and parameter types
shall each be compatible with the convention specified in the corresponding
pragma.
<dt><a name="27">(27)</a><dd>The external name and link name string_expressions of a pragma Import or
Export, and the string_expression of a pragma Linker_Options, shall be
static.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="28">(28)</a><dd>Import, Export, and Convention pragmas are representation pragmas that
specify the convention aspect of representation.  In addition, Import and
Export pragmas specify the imported and exported aspects of representation,
respectively.
<dt><a name="29">(29)</a><dd>An interfacing pragma is a program unit pragma when applied to a program
unit <a href="10-01-05.htm">(see 10.1.5)</a>.
<dt><a name="30">(30)</a><dd>An interfacing pragma defines the convention of the entity denoted by
the local_name.  The convention represents the calling convention or
representation convention of the entity.  For an access-to-subprogram type,
it represents the calling convention of designated subprograms.  In addition:
<dt><a name="31">(31)</a><dd><ul><li>A pragma Import specifies that the entity is defined externally
(that is, outside the Ada program).
</ul><dt><a name="32">(32)</a><dd><ul><li>A pragma Export specifies that the entity is used externally.
</ul><dt><a name="33">(33)</a><dd><ul><li>A pragma Import or Export optionally specifies an entity's
external name, link name, or both.
</ul><dt><a name="34">(34)</a><dd>An external name is a string value for the name used by a foreign
language program either for an entity that an Ada program imports, or for
referring to an entity that an Ada program exports.
<dt><a name="35">(35)</a><dd>A link name is a string value for the name of an exported or imported
entity, based on the conventions of the foreign language's compiler in
interfacing with the system's linker tool.
<dt><a name="36">(36)</a><dd>The meaning of link names is implementation defined.  If neither a link
name nor the Address attribute of an imported or exported entity is
specified, then a link name is chosen in an implementation-defined manner,
based on the external name if one is specified.
<dt><a name="37">(37)</a><dd>Pragma Linker_Options has the effect of passing its string argument as a
parameter to the system linker (if one exists), if the immediately enclosing
compilation unit is included in the partition being linked.  The
interpretation of the string argument, and the way in which the string
arguments from multiple Linker_Options pragmas are combined, is
implementation defined.
</dl><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="38">(38)</a><dd>Notwithstanding what this International Standard says elsewhere, the
elaboration of a declaration denoted by the local_name of a pragma Import
does not create the entity.  Such an elaboration has no other effect than to
allow the defining name to denote the external entity.
</dl><h5 align="center">Implementation Advice</h5>
<dl><dt><a name="39">(39)</a><dd>If an implementation supports pragma Export to a given language, then it
should also allow the main subprogram to be written in that language.  It
should support some mechanism for invoking the elaboration of the Ada library
units included in the system, and for invoking the finalization of the
environment task.  On typical systems, the recommended mechanism is to
provide two subprograms whose link names are "adainit" and "adafinal".
Adainit should contain the elaboration code for library units.  Adafinal
should contain the finalization code.  These subprograms should have no
effect the second and subsequent time they are called.
<dt><a name="40">(40)</a><dd>Automatic elaboration of preelaborated packages should be provided when
pragma Export is supported.
<dt><a name="41">(41)</a><dd>For each supported convention L other than Intrinsic, an implementation
should support Import and Export pragmas for objects of L-compatible types
and for subprograms, and pragma Convention for L-eligible types and for
subprograms, presuming the other language has corresponding features.  Pragma
Convention need not be supported for scalar types.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="42">(42)</a><dd><ul>(1) Implementations may place restrictions on interfacing pragmas; for
example, requiring each exported entity to be declared at the library
level.
</ul><dt><a name="43">(43)</a><dd><ul>(2) A pragma Import specifies the conventions for accessing external
entities.  It is possible that the actual entity is written in assembly
language, but reflects the conventions of a particular language.  For
example, pragma Import(Ada, ...) can be used to interface to an assembly
language routine that obeys the Ada compiler's calling conventions.
</ul><dt><a name="44">(44)</a><dd><ul>(3) To obtain ``call-back'' to an Ada subprogram from a foreign language
environment, pragma Convention should be specified both for the
access-to-subprogram type and the specific subprogram(s) to which
'Access is applied.
</ul><dt><a name="45">(45)</a><dd><ul>(4) It is illegal to specify more than one of Import, Export, or
Convention for a given entity.
</ul><dt><a name="46">(46)</a><dd><ul>(5) The local_name in an interfacing pragma can denote more than one
entity in the case of overloading.  Such a pragma applies to all of the
denoted entities.
</ul><dt><a name="47">(47)</a><dd><ul>(6) See also <a href="13-08.htm">13.8</a>, ``Machine Code Insertions''.
</ul><dt><a name="48">(48)</a><dd><ul>(7) If both External_Name and Link_Name are specified for an Import or
Export pragma, then the External_Name is ignored.
</ul><dt><a name="49">(49)</a><dd><ul>(8) An interfacing pragma might result in an effect that violates Ada
semantics.
</ul></dl><h5 align="center">Examples</h5>
<dl><dt><a name="50">(50)</a><dd><em>Example of interfacing pragmas:
</em>
</dl><pre><a name="51">(51)</a>
       package Fortran_Library is
         function Sqrt (X : Float) return Float;
         function Exp  (X : Float) return Float;
       private
         pragma Import(Fortran, Sqrt);
         pragma Import(Fortran, Exp);
       end Fortran_Library;
</pre><p>
<hr>
<h4><img src="noleft.gif" alt="____"> | <a href="B.htm"><img src="up.gif" alt="Up"></a> | <a href="B-02.htm"><img src="right.gif" alt="Next"></a> | <a href="B.htm"><img src="back.gif" alt="Back"></a> | <a href="B-02.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
