<html>
<head>
<title>Ada 95 RM - 7.6.1 Completion and Finalization</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><img src="noleft.gif" alt="____"> | <a href="07-06.htm"><img src="up.gif" alt="Up"></a> | <img src="noright.gif" alt="____"> | <a href="07-06.htm"><img src="back.gif" alt="Back"></a> | <a href="08.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>
<h3><a name="0">7.6.1 Completion and Finalization</a></h3>
<dl><dt><a name="1">(1)</a><dd>This subclause defines completion and leaving of the execution of
constructs and entities.  A master is the execution of a construct that
includes finalization of local objects after it is complete (and after
waiting for any local tasks -- <a href="09-03.htm">see 9.3)</a>, but before leaving.  Other
constructs and entities are left immediately upon completion.
</dl><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="2">(2)</a><dd>The execution of a construct or entity is complete when the end of that
execution has been reached, or when a transfer of control <a href="05-01.htm">(see 5.1)</a> causes it
to be abandoned.  Completion due to reaching the end of execution, or due to
the transfer of control of an exit_, return_, goto_, or requeue_statement or
of the selection of a terminate_alternative is normal completion.  Completion
is abnormal otherwise -- when control is transferred out of a construct due
to abort or the raising of an exception.
<dt><a name="3">(3)</a><dd>After execution of a construct or entity is complete, it is left, meaning
that execution continues with the next action, as defined for the execution
that is taking place.  Leaving an execution happens immediately after its
completion, except in the case of a master:  the execution of a task_body, a
block_statement, a subprogram_body, an entry_body, or an accept_statement.  A
master is finalized after it is complete, and before it is left.
<dt><a name="4">(4)</a><dd>For the finalization of a master, dependent tasks are first awaited, as
explained <a href="09-03.htm">in 9.3</a>.  Then each object whose accessibility level is the same as
that of the master is finalized if the object was successfully initialized
and still exists.  These actions are performed whether the master is left by
reaching the last statement or via a transfer of control.  When a transfer of
control causes completion of an execution, each included master is finalized
in order, from innermost outward.
<dt><a name="5">(5)</a><dd>For the finalization of an object:
<dt><a name="6">(6)</a><dd><ul><li>If the object is of an elementary type, finalization has no
effect;
</ul><dt><a name="7">(7)</a><dd><ul><li>If the object is of a controlled type, the Finalize procedure is
called;
</ul><dt><a name="8">(8)</a><dd><ul><li>If the object is of a protected type, the actions defined <a href="09-04.htm">in 9.4</a>
are performed;
</ul><dt><a name="9">(9)</a><dd><ul><li>If the object is of a composite type, then after performing the
above actions, if any, every component of the object is finalized
in an arbitrary order, except as follows:  if the object has a
component with an access discriminant constrained by a per-object
expression, this component is finalized before any components
that do not have such discriminants; for an object with several
components with such a discriminant, they are finalized in the
reverse of the order of their component_declarations.
</ul><dt><a name="10">(10)</a><dd>Immediately before an instance of Unchecked_Deallocation reclaims the
storage of an object, the object is finalized.  If an instance of Unchecked_Deallocation is never applied to an object created by an allocator, the
object will still exist when the corresponding master completes, and it will
be finalized then.
<dt><a name="11">(11)</a><dd>The order in which the finalization of a master performs finalization of
objects is as follows:  Objects created by declarations in the master are
finalized in the reverse order of their creation.  For objects that were
created by allocators for an access type whose ultimate ancestor is declared
in the master, this rule is applied as though each such object that still
exists had been created in an arbitrary order at the first freezing point
<a href="13-14.htm">(see 13.14)</a> of the ultimate ancestor type.
<dt><a name="12">(12)</a><dd>The target of an assignment statement is finalized before copying in the
new value, as explained <a href="07-06.htm">in 7.6</a>.
<dt><a name="13">(13)</a><dd>The anonymous objects created by function calls and by aggregates are
finalized no later than the end of the innermost enclosing declarative_item
or statement; if that is a compound_statement, they are finalized before
starting the execution of any statement within the compound_statement.
</dl><h5 align="center">Bounded (Run-Time) Errors</h5>
<dl><dt><a name="14">(14)</a><dd>It is a bounded error for a call on Finalize or Adjust to propagate an
exception.  The possible consequences depend on what action invoked the
Finalize or Adjust operation:
<dt><a name="15">(15)</a><dd><ul><li>For a Finalize invoked as part of an assignment_statement,
Program_Error is raised at that point.
</ul><dt><a name="16">(16)</a><dd><ul><li>For an Adjust invoked as part of an assignment operation, any
other adjustments due to be performed are performed, and then
Program_Error is raised.
</ul><dt><a name="17">(17)</a><dd><ul><li>For a Finalize invoked as part of a call on an instance of
Unchecked_Deallocation, any other finalizations due to be
performed are performed, and then Program_Error is raised.
</ul><dt><a name="18">(18)</a><dd><ul><li>For a Finalize invoked by the transfer of control of an exit_,
return_, goto_, or requeue_statement, Program_Error is raised no
earlier than after the finalization of the master being finalized
when the exception occurred, and no later than the point where
normal execution would have continued.  Any other finalizations
due to be performed up to that point are performed before raising
Program_Error.
</ul><dt><a name="19">(19)</a><dd><ul><li>For a Finalize invoked by a transfer of control that is due to
raising an exception, any other finalizations due to be performed
for the same master are performed; Program_Error is raised
immediately after leaving the master.
</ul><dt><a name="20">(20)</a><dd><ul><li>For a Finalize invoked by a transfer of control due to an abort
or selection of a terminate alternative, the exception is
ignored; any other finalizations due to be performed are
performed.
</ul><p><dt><dd><ul>NOTES</ul>
<dt><a name="21">(21)</a><dd><ul>(18) The rules of <a href="10.htm">Section 10</a> imply that immediately prior to partition
termination, Finalize operations are applied to library-level controlled
objects (including those created by allocators of library-level access
types, except those already finalized).  This occurs after waiting for
library-level tasks to terminate.
</ul><dt><a name="22">(22)</a><dd><ul>(19) A constant is only constant between its initialization and
finalization.  Both initialization and finalization are allowed to
change the value of a constant.
</ul><dt><a name="23">(23)</a><dd><ul>(20) Abort is deferred during certain operations related to controlled
types, as explained <a href="09-08.htm">in 9.8</a>.  Those rules prevent an abort from causing a
controlled object to be left in an ill-defined state.
</ul><dt><a name="24">(24)</a><dd><ul>(21) The Finalize procedure is called upon finalization of a controlled
object, even if Finalize was called earlier, either explicitly or as
part of an assignment; hence, if a controlled type is visibly controlled
(implying that its Finalize primitive is directly callable), or is
nonlimited (implying that assignment is allowed), its Finalize procedure
should be designed to have no ill effect if it is applied a second time
to the same object.
</ul></dl><hr>
<h4><img src="noleft.gif" alt="____"> | <a href="07-06.htm"><img src="up.gif" alt="Up"></a> | <img src="noright.gif" alt="____"> | <a href="07-06.htm"><img src="back.gif" alt="Back"></a> | <a href="08.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
