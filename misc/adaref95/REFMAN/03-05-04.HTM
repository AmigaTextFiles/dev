<html>
<head>
<title>Ada 95 RM - 3.5.4 Integer Types</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="03-05-03.htm"><img src="left.gif" alt="Prev"></a> | <a href="03-05.htm"><img src="up.gif" alt="Up"></a> | <a href="03-05-05.htm"><img src="right.gif" alt="Next"></a> | <a href="03-05-03.htm"><img src="back.gif" alt="Back"></a> | <a href="03-05-05.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>
<h3><a name="0">3.5.4 Integer Types</a></h3>
<dl><dt><a name="1">(1)</a><dd>An integer_type_definition defines an integer type; it defines either a
signed integer type, or a modular integer type.  The base range of a signed
integer type includes at least the values of the specified range.  A modular
type is an integer type with all arithmetic modulo a specified positive
modulus; such a type corresponds to an unsigned type with wrap-around
semantics.
</dl><h5 align="center"><a name="syntax">Syntax</a></h5>
<pre><a name="2">(2)</a>
       integer_type_definition ::= signed_integer_type_definition | modular_type_definition
<a name="3">(3)</a>
       signed_integer_type_definition ::= range static_simple_expression .. static_simple_expression
<a name="4">(4)</a>
       modular_type_definition ::= mod static_expression
</pre><h5 align="center">Name Resolution Rules</h5>
<dl><dt><a name="5">(5)</a><dd>Each simple_expression in a signed_integer_type_definition is expected to
be of any integer type; they need not be of the same type.  The expression in
a modular_type_definition is likewise expected to be of any integer type.
</dl><h5 align="center">Legality Rules</h5>
<dl><dt><a name="6">(6)</a><dd>The simple_expressions of a signed_integer_type_definition shall be
static, and their values shall be in the range System.Min_Int .. System.Max_Int.
<dt><a name="7">(7)</a><dd>The expression of a modular_type_definition shall be static, and its
value (the modulus) shall be positive, and shall be no greater than
System.Max_Binary_Modulus if a power of 2, or no greater than System.Max_Nonbinary_Modulus if not.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="8">(8)</a><dd>The set of values for a signed integer type is the (infinite) set of
mathematical integers, though only values of the base range of the type are
fully supported for run-time operations.  The set of values for a modular
integer type are the values from 0 to one less than the modulus, inclusive.
<dt><a name="9">(9)</a><dd>A signed_integer_type_definition defines an integer type whose base range
includes at least the values of the simple_expressions and is symmetric about
zero, excepting possibly an extra negative value.  A signed_integer_type_definition also defines a constrained first subtype of the type, with a range
whose bounds are given by the values of the simple_expressions, converted to
the type being defined.
<dt><a name="10">(10)</a><dd>A modular_type_definition defines a modular type whose base range is
from zero to one less than the given modulus.  A modular_type_definition also
defines a constrained first subtype of the type with a range that is the same
as the base range of the type.
<dt><a name="11">(11)</a><dd>There is a predefined signed integer subtype named Integer, declared in
the visible part of package Standard.  It is constrained to the base range of
its type.
<dt><a name="12">(12)</a><dd>Integer has two predefined subtypes, declared in the visible part of
package Standard:
</dl><pre><a name="13">(13)</a>
       subtype Natural  is Integer range 0 .. Integer'Last;
       subtype Positive is Integer range 1 .. Integer'Last;
</pre><dl><dt><a name="14">(14)</a><dd>A type defined by an integer_type_definition is implicitly derived from
root_integer, an anonymous predefined (specific) integer type, whose base
range is System.Min_Int .. System.Max_Int.  However, the base range of the
new type is not inherited from root_integer, but is instead determined by the
range or modulus specified by the integer_type_definition.  Integer literals
are all of the type universal_integer, the universal type <a href="03-04-01.htm">(see 3.4.1)</a> for the
class rooted at root_integer, allowing their use with the operations of any
integer type.
<dt><a name="15">(15)</a><dd>The position number of an integer value is equal to the value.
<dt><a name="16">(16)</a><dd>For every modular subtype S, the following attribute is defined:
<dt><a name="17">(17)</a><dd>S'Modulus
<ul>S'Modulus yields the modulus of the type of S, as a value of
the type universal_integer.
</ul></dl><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="18">(18)</a><dd>The elaboration of an integer_type_definition creates the integer type
and its first subtype.
<dt><a name="19">(19)</a><dd>For a modular type, if the result of the execution of a predefined
operator <a href="04-05.htm">(see 4.5)</a> is outside the base range of the type, the result is
reduced modulo the modulus of the type to a value that is within the base
range of the type.
<dt><a name="20">(20)</a><dd>For a signed integer type, the exception Constraint_Error is raised by
the execution of an operation that cannot deliver the correct result because
it is outside the base range of the type.  For any integer type, Constraint_Error is raised by the operators "/", "rem", and "mod" if the right operand
is zero.
</dl><h5 align="center">Implementation Requirements</h5>
<dl><dt><a name="21">(21)</a><dd>In an implementation, the range of Integer shall include the range
-2**15+1 .. +2**15-1.
<dt><a name="22">(22)</a><dd>If Long_Integer is predefined for an implementation, then its range
shall include the range -2**31+1 .. +2**31-1.
<dt><a name="23">(23)</a><dd>System.Max_Binary_Modulus shall be at least 2**16.
</dl><h5 align="center">Implementation Permissions</h5>
<dl><dt><a name="24">(24)</a><dd>For the execution of a predefined operation of a signed integer type,
the implementation need not raise Constraint_Error if the result is outside
the base range of the type, so long as the correct result is produced.
<dt><a name="25">(25)</a><dd>An implementation may provide additional predefined signed integer
types, declared in the visible part of Standard, whose first subtypes have
names of the form Short_Integer, Long_Integer, Short_Short_Integer, Long_Long_Integer, etc.  Different predefined integer types are allowed to have
the same base range.  However, the range of Integer should be no wider than
that of Long_Integer.  Similarly, the range of Short_Integer (if provided)
should be no wider than Integer.  Corresponding recommendations apply to any
other predefined integer types.  There need not be a named integer type
corresponding to each distinct base range supported by an implementation.
The range of each first subtype should be the base range of its type.
<dt><a name="26">(26)</a><dd>An implementation may provide nonstandard integer types, descendants of
root_integer that are declared outside of the specification of package
Standard, which need not have all the standard characteristics of a type
defined by an integer_type_definition.  For example, a nonstandard integer
type might have an asymmetric base range or it might not be allowed as an
array or loop index (a very long integer).  Any type descended from a
nonstandard integer type is also nonstandard.  An implementation may place
arbitrary restrictions on the use of such types; it is implementation defined
whether operators that are predefined for ``any integer type'' are defined
for a particular nonstandard integer type.  In any case, such types are not
permitted as explicit_generic_actual_parameters for formal scalar types --
<a href="12-05-02.htm">see 12.5.2</a>.
<dt><a name="27">(27)</a><dd>For a one's complement machine, the high bound of the base range of a
modular type whose modulus is one less than a power of 2 may be equal to the
modulus, rather than one less than the modulus.  It is implementation defined
for which powers of 2, if any, this permission is exercised.
</dl><h5 align="center">Implementation Advice</h5>
<dl><dt><a name="28">(28)</a><dd>An implementation should support Long_Integer in addition to Integer if
the target machine supports 32-bit (or longer) arithmetic.  No other named
integer subtypes are recommended for package Standard.  Instead, appropriate
named integer subtypes should be provided in the library package Interfaces
<a href="B-02.htm">(see B.2)</a>.
<dt><a name="29">(29)</a><dd>An implementation for a two's complement machine should support modular
types with a binary modulus up to System.Max_Int*2+2.  An implementation
should support a nonbinary modulus up to Integer'Last.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="30">(30)</a><dd><ul>(25) Integer literals are of the anonymous predefined integer type
universal_integer.  Other integer types have no literals.  However, the
overload resolution rules <a href="08-06.htm">(see 8.6</a>, ``The Context of Overload
Resolution'') allow expressions of the type universal_integer whenever
an integer type is expected.
</ul><dt><a name="31">(31)</a><dd><ul>(26) The same arithmetic operators are predefined for all signed integer
types defined by a signed_integer_type_definition <a href="04-05.htm">(see 4.5</a>, ``Operators
and Expression Evaluation'').  For modular types, these same operators
are predefined, plus bit-wise logical operators (and, or, xor, and not).
In addition, for the unsigned types declared in the language-defined
package Interfaces <a href="B-02.htm">(see B.2)</a>, functions are defined that provide
bit-wise shifting and rotating.
</ul><dt><a name="32">(32)</a><dd><ul>(27) Modular types match a generic_formal_parameter_declaration of the
form "type T is mod &lt;&gt;;"; signed integer types match "type T is range
&lt;&gt;;" <a href="12-05-02.htm">(see 12.5.2)</a>.
</ul></dl><h5 align="center">Examples</h5>
<dl><dt><a name="33">(33)</a><dd><em>Examples of integer types and subtypes:
</em>
</dl><pre><a name="34">(34)</a>
       type Page_Num  is range 1 .. 2_000;
       type Line_Size is range 1 .. Max_Line_Size;
<a name="35">(35)</a>
       subtype Small_Int   is Integer   range -10 .. 10;
       subtype Column_Ptr  is Line_Size range 1 .. 10;
       subtype Buffer_Size is Integer   range 0 .. Max;
<a name="36">(36)</a>
       type Byte        is mod 256; <em>-- an unsigned byte</em>
       type Hash_Index  is mod 97;  <em>-- modulus is prime</em>
</pre><hr>
<h4><a href="03-05-03.htm"><img src="left.gif" alt="Prev"></a> | <a href="03-05.htm"><img src="up.gif" alt="Up"></a> | <a href="03-05-05.htm"><img src="right.gif" alt="Next"></a> | <a href="03-05-03.htm"><img src="back.gif" alt="Back"></a> | <a href="03-05-05.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
