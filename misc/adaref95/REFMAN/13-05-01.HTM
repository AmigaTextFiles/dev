<html>
<head>
<title>Ada 95 RM - 13.5.1 Record Representation Clauses</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><img src="noleft.gif" alt="____"> | <a href="13-05.htm"><img src="up.gif" alt="Up"></a> | <a href="13-05-02.htm"><img src="right.gif" alt="Next"></a> | <a href="13-05.htm"><img src="back.gif" alt="Back"></a> | <a href="13-05-02.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>
<h3><a name="0">13.5.1 Record Representation Clauses</a></h3>
<dl><dt><a name="1">(1)</a><dd>A record_representation_clause specifies the storage representation of
records and record extensions, that is, the order, position, and size of
components (including discriminants, if any).
</dl><h5 align="center"><a name="syntax">Syntax</a></h5>
<pre><a name="2">(2)</a>
       record_representation_clause ::=
           for first_subtype_local_name use
             record [mod_clause]
               {component_clause}
             end record;
<a name="3">(3)</a>
       component_clause ::=
           component_local_name at position range first_bit .. last_bit;
<a name="4">(4)</a>
       position ::= static_expression
<a name="5">(5)</a>
       first_bit ::= static_simple_expression
<a name="6">(6)</a>
       last_bit ::= static_simple_expression
</pre><h5 align="center">Name Resolution Rules</h5>
<dl><dt><a name="7">(7)</a><dd>Each position, first_bit, and last_bit is expected to be of any integer
type.
</dl><h5 align="center">Legality Rules</h5>
<dl><dt><a name="8">(8)</a><dd>The first_subtype_local_name of a record_representation_clause shall
denote a specific nonlimited record or record extension subtype.
<dt><a name="9">(9)</a><dd>If the component_local_name is a direct_name, the local_name shall denote
a component of the type.  For a record extension, the component shall not be
inherited, and shall not be a discriminant that corresponds to a discriminant
of the parent type.  If the component_local_name has an attribute_designator,
the direct_name of the local_name shall denote either the declaration of the
type or a component of the type, and the attribute_designator shall denote an
implementation-defined implicit component of the type.
<dt><a name="10">(10)</a><dd>The position, first_bit, and last_bit shall be static expressions.  The
value of position and first_bit shall be nonnegative.  The value of last_bit
shall be no less than first_bit - 1.
<dt><a name="11">(11)</a><dd>At most one component_clause is allowed for each component of the type,
including for each discriminant (component_clauses may be given for some,
all, or none of the components).  Storage places within a component_list
shall not overlap, unless they are for components in distinct variants of the
same variant_part.
<dt><a name="12">(12)</a><dd>A name that denotes a component of a type is not allowed within a
record_representation_clause for the type, except as the component_local_name
of a component_clause.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="13">(13)</a><dd>A record_representation_clause (without the mod_clause) specifies the
layout.  The storage place attributes <a href="13-05-02.htm">(see 13.5.2)</a> are taken from the values
of the position, first_bit, and last_bit expressions after normalizing those
values so that first_bit is less than Storage_Unit.
<dt><a name="14">(14)</a><dd>A record_representation_clause for a record extension does not override
the layout of the parent part; if the layout was specified for the parent
type, it is inherited by the record extension.
</dl><h5 align="center">Implementation Permissions</h5>
<dl><dt><a name="15">(15)</a><dd>An implementation may generate implementation-defined components (for
example, one containing the offset of another component).  An implementation
may generate names that denote such implementation-defined components; such
names shall be implementation-defined attribute_references.  An implementation may allow such implementation-defined names to be used in record_representation_clauses.  An implementation can restrict such component_clauses in any manner it sees fit.
<dt><a name="16">(16)</a><dd>If a record_representation_clause is given for an untagged derived type,
the storage place attributes for all of the components of the derived type
may differ from those of the corresponding components of the parent type,
even for components whose storage place is not specified explicitly in the
record_representation_clause.
</dl><h5 align="center">Implementation Advice</h5>
<dl><dt><a name="17">(17)</a><dd>The recommended level of support for record_representation_clauses is:
<dt><a name="18">(18)</a><dd><ul><li>An implementation should support storage places that can be
extracted with a load, mask, shift sequence of machine code, and
set with a load, shift, mask, store sequence, given the available
machine instructions and run-time model.
</ul><dt><a name="19">(19)</a><dd><ul><li>A storage place should be supported if its size is equal to the
Size of the component subtype, and it starts and ends on a
boundary that obeys the Alignment of the component subtype.
</ul><dt><a name="20">(20)</a><dd><ul><li>If the default bit ordering applies to the declaration of a given
type, then for a component whose subtype's Size is less than the
word size, any storage place that does not cross an aligned word
boundary should be supported.
</ul><dt><a name="21">(21)</a><dd><ul><li>An implementation may reserve a storage place for the tag field
of a tagged type, and disallow other components from overlapping
that place.
</ul><dt><a name="22">(22)</a><dd><ul><li>An implementation need not support a component_clause for a
component of an extension part if the storage place is not after
the storage places of all components of the parent type, whether
or not those storage places had been specified.
</ul><p><dt><dd><ul>NOTES</ul>
<dt><a name="23">(23)</a><dd><ul>(12) If no component_clause is given for a component, then the choice of
the storage place for the component is left to the implementation.  If
component_clauses are given for all components, the record_representation_clause completely specifies the representation of the
type and will be obeyed exactly by the implementation.
</ul></dl><h5 align="center">Examples</h5>
<dl><dt><a name="24">(24)</a><dd><em>Example of specifying the layout of a record type:
</em>
</dl><pre><a name="25">(25)</a>
       Word : constant := 4;  <em>--  storage element is byte, 4 bytes per word</em>
<a name="26">(26)</a>
       type State         is (A,M,W,P);
       type Mode          is (Fix, Dec, Exp, Signif);
<a name="27">(27)</a>
       type Byte_Mask     is array (0..7)  of Boolean;
       type State_Mask    is array (State) of Boolean;
       type Mode_Mask     is array (Mode)  of Boolean;
<a name="28">(28)</a>
       type Program_Status_Word is
         record
             System_Mask        : Byte_Mask;
             Protection_Key     : Integer range 0 .. 3;
             Machine_State      : State_Mask;
             Interrupt_Cause    : Interruption_Code;
             Ilc                : Integer range 0 .. 3;
             Cc                 : Integer range 0 .. 3;
             Program_Mask       : Mode_Mask;
             Inst_Address       : Address;
       end record;
<a name="29">(29)</a>
       for Program_Status_Word use
         record
             System_Mask      at 0*Word range 0  .. 7;
             Protection_Key   at 0*Word range 10 .. 11; <em>-- bits 8,9 unused</em>
             Machine_State    at 0*Word range 12 .. 15;
             Interrupt_Cause  at 0*Word range 16 .. 31;
             Ilc              at 1*Word range 0  .. 1;  <em>-- second word</em>
             Cc               at 1*Word range 2  .. 3;
             Program_Mask     at 1*Word range 4  .. 7;
             Inst_Address     at 1*Word range 8  .. 31;
         end record;
<a name="30">(30)</a>
       for Program_Status_Word'Size use 8*System.Storage_Unit;
       for Program_Status_Word'Alignment use 8;
</pre><dl><p><dt><dd><ul>NOTES</ul>
<dt><a name="31">(31)</a><dd><ul>(13) Note on the example:  The record_representation_clause defines the
record layout.  The Size clause guarantees that (at least) eight storage
elements are used for objects of the type.  The Alignment clause
guarantees that aliased, imported, or exported objects of the type will
have addresses divisible by eight.
</ul></dl><hr>
<h4><img src="noleft.gif" alt="____"> | <a href="13-05.htm"><img src="up.gif" alt="Up"></a> | <a href="13-05-02.htm"><img src="right.gif" alt="Next"></a> | <a href="13-05.htm"><img src="back.gif" alt="Back"></a> | <a href="13-05-02.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
