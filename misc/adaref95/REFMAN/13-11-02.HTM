<html>
<head>
<title>Ada 95 RM - 13.11.2 Unchecked Storage Deallocation</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="13-11-01.htm"><img src="left.gif" alt="Prev"></a> | <a href="13-11.htm"><img src="up.gif" alt="Up"></a> | <a href="13-11-03.htm"><img src="right.gif" alt="Next"></a> | <a href="13-11-01.htm"><img src="back.gif" alt="Back"></a> | <a href="13-11-03.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>
<h3><a name="0">13.11.2 Unchecked Storage Deallocation</a></h3>
<dl><dt><a name="1">(1)</a><dd>Unchecked storage deallocation of an object designated by a value of an
access type is achieved by a call to an instance of the generic procedure
Unchecked_Deallocation.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="2">(2)</a><dd>The following language-defined generic library procedure exists:
</dl><pre><a name="3">(3)</a>
       generic
          type Object(&lt;&gt;) is limited private;
          type Name   is access  Object;
       procedure Ada.Unchecked_Deallocation(X : in out Name);
       pragma Convention(Intrinsic, Ada.Unchecked_Deallocation);
       pragma Preelaborate(Ada.Unchecked_Deallocation);
</pre><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="4">(4)</a><dd>Given an instance of Unchecked_Deallocation declared as follows:
</dl><pre><a name="5">(5)</a>
       procedure Free is
           new Ada.Unchecked_Deallocation(
               object_subtype_name, access_to_variable_subtype_name);
</pre><dl><dt><a name="6">(6)</a><dd>Procedure Free has the following effect:
<dt><a name="7">(7)</a><dd><ul><li>After executing Free(X), the value of X is null.
</ul><dt><a name="8">(8)</a><dd><ul><li>Free(X), when X is already equal to null, has no effect.
</ul><dt><a name="9">(9)</a><dd><ul><li>Free(X), when X is not equal to null first performs finalization,
as described <a href="07-06.htm">in 7.6</a>.  It then deallocates the storage occupied by
the object designated by X. If the storage pool is a user-defined
object, then the storage is deallocated by calling Deallocate,
passing access_to_variable_subtype_name'Storage_Pool as the Pool
parameter.  Storage_Address is the value returned in the Storage_Address parameter of the corresponding Allocate call.  Size_In_Storage_Elements and Alignment are the same values passed to the
corresponding Allocate call.  There is one exception: if the
object being freed contains tasks, the object might not be
deallocated.
</ul><dt><a name="10">(10)</a><dd>After Free(X), the object designated by X, and any subcomponents
thereof, no longer exist; their storage can be reused for other purposes.
</dl><h5 align="center">Bounded (Run-Time) Errors</h5>
<dl><dt><a name="11">(11)</a><dd>It is a bounded error to free a discriminated, unterminated task object.
The possible consequences are:
<dt><a name="12">(12)</a><dd><ul><li>No exception is raised.
</ul><dt><a name="13">(13)</a><dd><ul><li>Program_Error or Tasking_Error is raised at the point of the
deallocation.
</ul><dt><a name="14">(14)</a><dd><ul><li>Program_Error or Tasking_Error is raised in the task the next
time it references any of the discriminants.
</ul><dt><a name="15">(15)</a><dd>In the first two cases, the storage for the discriminants (and for any
enclosing object if it is designated by an access discriminant of the task)
is not reclaimed prior to task termination.
</dl><h5 align="center">Erroneous Execution</h5>
<dl><dt><a name="16">(16)</a><dd>Evaluating a name that denotes a nonexistent object is erroneous.  The
execution of a call to an instance of Unchecked_Deallocation is erroneous if
the object was created other than by an allocator for an access type whose
pool is Name'Storage_Pool.
</dl><h5 align="center">Implementation Advice</h5>
<dl><dt><a name="17">(17)</a><dd>For a standard storage pool, Free should actually reclaim the storage.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="18">(18)</a><dd><ul>(26) The rules here that refer to Free apply to any instance of
Unchecked_Deallocation.
</ul><dt><a name="19">(19)</a><dd><ul>(27) Unchecked_Deallocation cannot be instantiated for an access-to-
constant type.  This is implied by the rules of <a href="12-05-04.htm">12.5.4</a>.
</ul></dl><hr>
<h4><a href="13-11-01.htm"><img src="left.gif" alt="Prev"></a> | <a href="13-11.htm"><img src="up.gif" alt="Up"></a> | <a href="13-11-03.htm"><img src="right.gif" alt="Next"></a> | <a href="13-11-01.htm"><img src="back.gif" alt="Back"></a> | <a href="13-11-03.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
