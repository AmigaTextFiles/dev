<html>
<head>
<title>Ada 95 RM - 4.5.2 Relational Operators and Membership Tests</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="04-05-01.htm"><img src="left.gif" alt="Prev"></a> | <a href="04-05.htm"><img src="up.gif" alt="Up"></a> | <a href="04-05-03.htm"><img src="right.gif" alt="Next"></a> | <a href="04-05-01.htm"><img src="back.gif" alt="Back"></a> | <a href="04-05-03.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>
<h3><a name="0">4.5.2 Relational Operators and Membership Tests</a></h3>
<dl><dt><a name="1">(1)</a><dd>The equality operators = (equals) and /= (not equals) are predefined for
nonlimited types.  The other relational_operators are the ordering operators
&lt; (less than), &lt;= (less than or equal), &gt; (greater than), and &gt;= (greater
than or equal).  The ordering operators are predefined for scalar types, and
for discrete array types, that is, one-dimensional array types whose
components are of a discrete type.
<dt><a name="2">(2)</a><dd>A membership test, using in or not in, determines whether or not a value
belongs to a given subtype or range, or has a tag that identifies a type that
is covered by a given type.  Membership tests are allowed for all types.
</dl><h5 align="center">Name Resolution Rules</h5>
<dl><dt><a name="3">(3)</a><dd>The tested type of a membership test is the type of the range or the type
determined by the subtype_mark.  If the tested type is tagged, then the
simple_expression shall resolve to be of a type that covers or is covered by
the tested type; if untagged, the expected type for the simple_expression is
the tested type.
</dl><h5 align="center">Legality Rules</h5>
<dl><dt><a name="4">(4)</a><dd>For a membership test, if the simple_expression is of a tagged class-wide
type, then the tested type shall be (visibly) tagged.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="5">(5)</a><dd>The result type of a membership test is the predefined type Boolean.
<dt><a name="6">(6)</a><dd>The equality operators are predefined for every specific type T that is
not limited, and not an anonymous access type, with the following
specifications:
</dl><pre><a name="7">(7)</a>
       function "=" (Left, Right : T) return Boolean
       function "/="(Left, Right : T) return Boolean
</pre><dl><dt><a name="8">(8)</a><dd>The ordering operators are predefined for every specific scalar type T,
and for every discrete array type T, with the following specifications:
</dl><pre><a name="9">(9)</a>
       function "&lt;" (Left, Right : T) return Boolean
       function "&lt;="(Left, Right : T) return Boolean
       function "&gt;" (Left, Right : T) return Boolean
       function "&gt;="(Left, Right : T) return Boolean
</pre><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="10">(10)</a><dd>For discrete types, the predefined relational operators are defined in
terms of corresponding mathematical operations on the position numbers of the
values of the operands.
<dt><a name="11">(11)</a><dd>For real types, the predefined relational operators are defined in terms
of the corresponding mathematical operations on the values of the operands,
subject to the accuracy of the type.
<dt><a name="12">(12)</a><dd>Two access-to-object values are equal if they designate the same object,
or if both are equal to the null value of the access type.
<dt><a name="13">(13)</a><dd>Two access-to-subprogram values are equal if they are the result of the
same evaluation of an Access attribute_reference, or if both are equal to the
null value of the access type.  Two access-to-subprogram values are unequal
if they designate different subprograms.  It is unspecified whether two
access values that designate the same subprogram but are the result of
distinct evaluations of Access attribute_references are equal or unequal.
<dt><a name="14">(14)</a><dd>For a type extension, predefined equality is defined in terms of the
primitive (possibly user-defined) equals operator of the parent type and of
any tagged components of the extension part, and predefined equality for any
other components not inherited from the parent type.
<dt><a name="15">(15)</a><dd>For a private type, if its full type is tagged, predefined equality is
defined in terms of the primitive equals operator of the full type; if the
full type is untagged, predefined equality for the private type is that of
its full type.
<dt><a name="16">(16)</a><dd>For other composite types, the predefined equality operators (and
certain other predefined operations on composite types -- <a href="04-05-01.htm">see 4.5.1</a> and <a href="04-06.htm">4.6)</a>
are defined in terms of the corresponding operation on matching components,
defined as follows:
<dt><a name="17">(17)</a><dd><ul><li>For two composite objects or values of the same non-array type,
matching components are those that correspond to the same
component_declaration or discriminant_specification;
</ul><dt><a name="18">(18)</a><dd><ul><li>For two one-dimensional arrays of the same type, matching
components are those (if any) whose index values match in the
following sense: the lower bounds of the index ranges are defined
to match, and the successors of matching indices are defined to
match;
</ul><dt><a name="19">(19)</a><dd><ul><li>For two multidimensional arrays of the same type, matching
components are those whose index values match in successive index
positions.
</ul><dt><a name="20">(20)</a><dd>The analogous definitions apply if the types of the two objects or
values are convertible, rather than being the same.
<dt><a name="21">(21)</a><dd>Given the above definition of matching components, the result of the
predefined equals operator for composite types (other than for those
composite types covered earlier) is defined as follows:
<dt><a name="22">(22)</a><dd><ul><li>If there are no components, the result is defined to be True;
</ul><dt><a name="23">(23)</a><dd><ul><li>If there are unmatched components, the result is defined to be
False;
</ul><dt><a name="24">(24)</a><dd><ul><li>Otherwise, the result is defined in terms of the primitive equals
operator for any matching tagged components, and the predefined
equals for any matching untagged components.
</ul><dt><a name="25">(25)</a><dd>The predefined "/=" operator gives the complementary result to the
predefined "=" operator.
<dt><a name="26">(26)</a><dd>For a discrete array type, the predefined ordering operators correspond
to lexicographic order using the predefined order relation of the component
type:  A null array is lexicographically less than any array having at least
one component.  In the case of nonnull arrays, the left operand is
lexicographically less than the right operand if the first component of the
left operand is less than that of the right; otherwise the left operand is
lexicographically less than the right operand only if their first components
are equal and the tail of the left operand is lexicographically less than
that of the right (the tail consists of the remaining components beyond the
first and can be null).
<dt><a name="27">(27)</a><dd>For the evaluation of a membership test, the simple_expression and the
range (if any) are evaluated in an arbitrary order.
<dt><a name="28">(28)</a><dd>A membership test using in yields the result True if:
<dt><a name="29">(29)</a><dd><ul><li>The tested type is scalar, and the value of the simple_expression
belongs to the given range, or the range of the named subtype; or
</ul><dt><a name="30">(30)</a><dd><ul><li>The tested type is not scalar, and the value of the simple_expression satisfies any constraints of the named subtype, and,
if the type of the simple_expression is class-wide, the value has
a tag that identifies a type covered by the tested type.
</ul><dt><a name="31">(31)</a><dd>Otherwise the test yields the result False.
<dt><a name="32">(32)</a><dd>A membership test using not in gives the complementary result to the
corresponding membership test using in.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="33">(33)</a><dd><ul>(13) No exception is ever raised by a membership test, by a predefined
ordering operator, or by a predefined equality operator for an
elementary type, but an exception can be raised by the evaluation of the
operands.  A predefined equality operator for a composite type can only
raise an exception if the type has a tagged part whose primitive equals
operator propagates an exception.
</ul><dt><a name="34">(34)</a><dd><ul>(14) If a composite type has components that depend on discriminants,
two values of this type have matching components if and only if their
discriminants are equal.  Two nonnull arrays have matching components if
and only if the length of each dimension is the same for both.
</ul></dl><h5 align="center">Examples</h5>
<dl><dt><a name="35">(35)</a><dd><em>Examples of expressions involving relational operators and membership
tests:
</em>
</dl><pre><a name="36">(36)</a>
       X /= Y
<a name="37">(37)</a>
       "" &lt; "A" and "A" &lt; "Aa"     <em>--  True</em>
       "Aa" &lt; "B" and "A" &lt; "A  "  <em>--  True</em>
<a name="38">(38)</a>
       My_Car = null               <em>-- true if My_Car has been set to null <a href="03-10-01.htm">(see 3.10.1)</a></em>
       My_Car = Your_Car           <em>-- true if we both share the same car</em>
       My_Car.all = Your_Car.all   <em>-- true if the two cars are identical</em>
<a name="39">(39)</a>
       N not in 1 .. 10            <em>-- range membership test</em>
       Today in Mon .. Fri         <em>-- range membership test</em>
       Today in Weekday            <em>-- subtype membership test <a href="03-05-01.htm">(see 3.5.1)</a></em>
       Archive in Disk_Unit        <em>-- subtype membership test <a href="03-08-01.htm">(see 3.8.1)</a></em>
       Tree.all in Addition'Class  <em>-- class membership test <a href="03-09-01.htm">(see 3.9.1)</a></em>
</pre><hr>
<h4><a href="04-05-01.htm"><img src="left.gif" alt="Prev"></a> | <a href="04-05.htm"><img src="up.gif" alt="Up"></a> | <a href="04-05-03.htm"><img src="right.gif" alt="Next"></a> | <a href="04-05-01.htm"><img src="back.gif" alt="Back"></a> | <a href="04-05-03.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
