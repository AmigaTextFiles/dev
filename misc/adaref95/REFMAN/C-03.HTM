<html>
<head>
<title>Ada 95 RM - C.3 Interrupt Support</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="C-02.htm"><img src="left.gif" alt="Prev"></a> | <a href="C.htm"><img src="up.gif" alt="Up"></a> | <a href="C-04.htm"><img src="right.gif" alt="Next"></a> | <a href="C-02.htm"><img src="back.gif" alt="Back"></a> | <a href="C-03-01.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>

<h2><a name="0">C.3 Interrupt Support</a>
 -- <a href="tocC-03.htm">TOC</a>
</h2>
<dl><dt><a name="1">(1)</a><dd>This clause specifies the language-defined model for hardware interrupts
in addition to mechanisms for handling interrupts.
</dl><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="2">(2)</a><dd>An interrupt represents a class of events that are detected by the
hardware or the system software.  Interrupts are said to occur.  An
occurrence of an interrupt is separable into generation and delivery.
Generation of an interrupt is the event in the underlying hardware or system
that makes the interrupt available to the program.  Delivery is the action
that invokes part of the program as response to the interrupt occurrence.
Between generation and delivery, the interrupt occurrence (or interrupt) is
pending.  Some or all interrupts may be blocked.  When an interrupt is
blocked, all occurrences of that interrupt are prevented from being
delivered.  Certain interrupts are reserved.  The set of reserved interrupts
is implementation defined.  A reserved interrupt is either an interrupt for
which user-defined handlers are not supported, or one which already has an
attached handler by some other implementation-defined means.  Program units
can be connected to non-reserved interrupts.  While connected, the program
unit is said to be attached to that interrupt.  The execution of that program
unit, the interrupt handler, is invoked upon delivery of the interrupt
occurrence.
<dt><a name="3">(3)</a><dd>While a handler is attached to an interrupt, it is called once for each
delivered occurrence of that interrupt.  While the handler executes, the
corresponding interrupt is blocked.
<dt><a name="4">(4)</a><dd>While an interrupt is blocked, all occurrences of that interrupt are
prevented from being delivered.  Whether such occurrences remain pending or
are lost is implementation defined.
<dt><a name="5">(5)</a><dd>Each interrupt has a default treatment which determines the system's
response to an occurrence of that interrupt when no user-defined handler is
attached.  The set of possible default treatments is implementation defined,
as is the method (if one exists) for configuring the default treatments for
interrupts.
<dt><a name="6">(6)</a><dd>An interrupt is delivered to the handler (or default treatment) that is
in effect for that interrupt at the time of delivery.
<dt><a name="7">(7)</a><dd>An exception propagated from a handler that is invoked by an interrupt
has no effect.
<dt><a name="8">(8)</a><dd>If the Ceiling_Locking policy <a href="D-03.htm">(see D.3)</a> is in effect, the interrupt
handler executes with the active priority that is the ceiling priority of the
corresponding protected object.
</dl><h5 align="center">Implementation Requirements</h5>
<dl><dt><a name="9">(9)</a><dd>The implementation shall provide a mechanism to determine the minimum
stack space that is needed for each interrupt handler and to reserve that
space for the execution of the handler. This space should accommodate nested
invocations of the handler where the system permits this.
<dt><a name="10">(10)</a><dd>If the hardware or the underlying system holds pending interrupt
occurrences, the implementation shall provide for later delivery of these
occurrences to the program.
<dt><a name="11">(11)</a><dd>If the Ceiling_Locking policy is not in effect, the implementation shall
provide means for the application to specify whether interrupts are to be
blocked during protected actions.
</dl><h5 align="center">Documentation Requirements</h5>
<dl><dt><a name="12">(12)</a><dd>The implementation shall document the following items:
<dt><a name="13">(13)</a><dd><ul><li>For each interrupt, which interrupts are blocked from delivery
when a handler attached to that interrupt executes (either as a
result of an interrupt delivery or of an ordinary call on a
procedure of the corresponding protected object).
</ul><dt><a name="14">(14)</a><dd><ul><li>Any interrupts that cannot be blocked, and the effect of
attaching handlers to such interrupts, if this is permitted.
</ul><dt><a name="15">(15)</a><dd><ul><li>Which run-time stack an interrupt handler uses when it executes
as a result of an interrupt delivery; if this is configurable,
what is the mechanism to do so; how to specify how much space to
reserve on that stack.
</ul><dt><a name="16">(16)</a><dd><ul><li>Any implementation- or hardware-specific activity that happens
before a user-defined interrupt handler gets control (e.g.,
reading device registers, acknowledging devices).
</ul><dt><a name="17">(17)</a><dd><ul><li>Any timing or other limitations imposed on the execution of
interrupt handlers.
</ul><dt><a name="18">(18)</a><dd><ul><li>The state (blocked/unblocked) of the non-reserved interrupts when
the program starts; if some interrupts are unblocked, what is the
mechanism a program can use to protect itself before it can
attach the corresponding handlers.
</ul><dt><a name="19">(19)</a><dd><ul><li>Whether the interrupted task is allowed to resume execution
before the interrupt handler returns.
</ul><dt><a name="20">(20)</a><dd><ul><li>The treatment of interrupt occurrences that are generated while
the interrupt is blocked; i.e., whether one or more occurrences
are held for later delivery, or all are lost.
</ul><dt><a name="21">(21)</a><dd><ul><li>Whether predefined or implementation-defined exceptions are
raised as a result of the occurrence of any interrupt, and the
mapping between the machine interrupts (or traps) and the
predefined exceptions.
</ul><dt><a name="22">(22)</a><dd><ul><li>On a multi-processor, the rules governing the delivery of an
interrupt to a particular processor.
</ul></dl><h5 align="center">Implementation Permissions</h5>
<dl><dt><a name="23">(23)</a><dd>If the underlying system or hardware does not allow interrupts to be
blocked, then no blocking is required as part of the execution of subprograms
of a protected object whose one of its subprograms is an interrupt handler.
<dt><a name="24">(24)</a><dd>In a multi-processor with more than one interrupt subsystem, it is
implementation defined whether (and how) interrupt sources from separate
subsystems share the same Interrupt_ID type <a href="C-03-02.htm">(see C.3.2)</a>.  In particular, the
meaning of a blocked or pending interrupt may then be applicable to one
processor only.
<dt><a name="25">(25)</a><dd>Implementations are allowed to impose timing or other limitations on the
execution of interrupt handlers.
<dt><a name="26">(26)</a><dd>Other forms of handlers are allowed to be supported, in which case, the
rules of this subclause should be adhered to.
<dt><a name="27">(27)</a><dd>The active priority of the execution of an interrupt handler is allowed
to vary from one occurrence of the same interrupt to another.
</dl><h5 align="center">Implementation Advice</h5>
<dl><dt><a name="28">(28)</a><dd>If the Ceiling_Locking policy is not in effect, the implementation
should provide means for the application to specify which interrupts are to
be blocked during protected actions, if the underlying system allows for a
finer-grain control of interrupt blocking.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="29">(29)</a><dd><ul>(1) The default treatment for an interrupt can be to keep the interrupt
pending or to deliver it to an implementation-defined handler.  Examples
of actions that an implementation-defined handler is allowed to perform
include aborting the partition, ignoring (i.e., discarding occurrences
of) the interrupt, or queuing one or more occurrences of the interrupt
for possible later delivery when a user-defined handler is attached to
that interrupt.
</ul><dt><a name="30">(30)</a><dd><ul>(2) It is a bounded error to call Task_Identification.Current_Task <a href="C-07-01.htm">(see C.7.1)</a> from an interrupt handler.
</ul><dt><a name="31">(31)</a><dd><ul>(3) The rule that an exception propagated from an interrupt handler has
no effect is modeled after the rule about exceptions propagated out of
task bodies.
</ul></dl><hr><h3>Subclauses</h3>
<ol>
<li><a href="C-03-01.htm">Protected Procedure Handlers</a>
<li><a href="C-03-02.htm">The Package Interrupts</a>
</ol>
<p>
<hr>
<h4><a href="C-02.htm"><img src="left.gif" alt="Prev"></a> | <a href="C.htm"><img src="up.gif" alt="Up"></a> | <a href="C-04.htm"><img src="right.gif" alt="Next"></a> | <a href="C-02.htm"><img src="back.gif" alt="Back"></a> | <a href="C-03-01.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
