<html>
<head>
<title>Ada 95 RM - B.4 Interfacing with COBOL</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="B-03.htm"><img src="left.gif" alt="Prev"></a> | <a href="B.htm"><img src="up.gif" alt="Up"></a> | <a href="B-05.htm"><img src="right.gif" alt="Next"></a> | <a href="B-03-02.htm"><img src="back.gif" alt="Back"></a> | <a href="B-05.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>

<h2><a name="0">B.4 Interfacing with COBOL</a></h2>
<dl><dt><a name="1">(1)</a><dd>The facilities relevant to interfacing with the COBOL language are the
package Interfaces.COBOL and support for the Import, Export and Convention
pragmas with convention_identifier COBOL.
<dt><a name="2">(2)</a><dd>The COBOL interface package supplies several sets of facilities:
<dt><a name="3">(3)</a><dd><ul><li>A set of types corresponding to the native COBOL types of the
supported COBOL implementation (so-called ``internal COBOL
representations''), allowing Ada data to be passed as parameters
to COBOL programs
</ul><dt><a name="4">(4)</a><dd><ul><li>A set of types and constants reflecting external data
representations such as might be found in files or databases,
allowing COBOL-generated data to be read by an Ada program, and
Ada-generated data to be read by COBOL programs
</ul><dt><a name="5">(5)</a><dd><ul><li>A generic package for converting between an Ada decimal type
value and either an internal or external COBOL representation
</ul></dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="6">(6)</a><dd>The library package Interfaces.COBOL has the following declaration:
</dl><pre><a name="7">(7)</a>
       package Interfaces.COBOL is
          pragma Preelaborate(COBOL);
<a name="8">(8)</a>
       <em>-- Types and operations for internal data representations</em>
<a name="9">(9)</a>
          type Floating      is digits implementation-defined;
          type Long_Floating is digits implementation-defined;
<a name="10">(10)</a>
          type Binary      is range implementation-defined;
          type Long_Binary is range implementation-defined;
<a name="11">(11)</a>
          Max_Digits_Binary      : constant := implementation-defined;
          Max_Digits_Long_Binary : constant := implementation-defined;
<a name="12">(12)</a>
          type Decimal_Element  is mod implementation-defined;
          type Packed_Decimal is array (Positive range &lt;&gt;) of Decimal_Element;
          pragma Pack(Packed_Decimal);
<a name="13">(13)</a>
          type COBOL_Character is implementation-defined character type;
<a name="14">(14)</a>
          Ada_To_COBOL : array (Character) of COBOL_Character := implementation-defined;
<a name="15">(15)</a>
          COBOL_To_Ada : array (COBOL_Character) of Character := implementation-defined;
<a name="16">(16)</a>
          type Alphanumeric is array (Positive range &lt;&gt;) of COBOL_Character;
          pragma Pack(Alphanumeric);
<a name="17">(17)</a>
          function To_COBOL (Item : in String) return Alphanumeric;
          function To_Ada   (Item : in Alphanumeric) return String;
<a name="18">(18)</a>
          procedure To_COBOL (Item       : in String;
                              Target     : out Alphanumeric;
                              Last       : out Natural);
<a name="19">(19)</a>
          procedure To_Ada (Item     : in Alphanumeric;
                            Target   : out String;
                            Last     : out Natural);
<a name="20">(20)</a>
          type Numeric is array (Positive range &lt;&gt;) of COBOL_Character;
          pragma Pack(Numeric);
<a name="21">(21)</a>
       <em>-- Formats for COBOL data representations</em>
<a name="22">(22)</a>
          type Display_Format is private;
<a name="23">(23)</a>
          Unsigned             : constant Display_Format;
          Leading_Separate     : constant Display_Format;
          Trailing_Separate    : constant Display_Format;
          Leading_Nonseparate  : constant Display_Format;
          Trailing_Nonseparate : constant Display_Format;
<a name="24">(24)</a>
          type Binary_Format is private;
<a name="25">(25)</a>
          High_Order_First  : constant Binary_Format;
          Low_Order_First   : constant Binary_Format;
          Native_Binary     : constant Binary_Format;
<a name="26">(26)</a>
          type Packed_Format is private;
<a name="27">(27)</a>
          Packed_Unsigned   : constant Packed_Format;
          Packed_Signed     : constant Packed_Format;
<a name="28">(28)</a>
       <em>-- Types for external representation of COBOL binary data</em>
<a name="29">(29)</a>
          type Byte is mod 2**COBOL_Character'Size;
          type Byte_Array is array (Positive range &lt;&gt;) of Byte;
          pragma Pack (Byte_Array);
<a name="30">(30)</a>
          Conversion_Error : exception;
<a name="31">(31)</a>
          generic
             type Num is delta &lt;&gt; digits &lt;&gt;;
          package Decimal_Conversions is
<a name="32">(32)</a>
             <em>-- Display Formats: data values are represented as Numeric</em>
<a name="33">(33)</a>
             function Valid (Item   : in Numeric;
                             Format : in Display_Format) return Boolean;
<a name="34">(34)</a>
             function Length (Format : in Display_Format) return Natural;
<a name="35">(35)</a>
             function To_Decimal (Item   : in Numeric;
                                  Format : in Display_Format) return Num;
<a name="36">(36)</a>
             function To_Display (Item   : in Num;
                                  Format : in Display_Format) return Numeric;
<a name="37">(37)</a>
             <em>-- Packed Formats: data values are represented as Packed_Decimal</em>
<a name="38">(38)</a>
             function Valid (Item   : in Packed_Decimal;
                             Format : in Packed_Format) return Boolean;
<a name="39">(39)</a>
             function Length (Format : in Packed_Format) return Natural;
<a name="40">(40)</a>
             function To_Decimal (Item   : in Packed_Decimal;
                                  Format : in Packed_Format) return Num;
<a name="41">(41)</a>
             function To_Packed (Item   : in Num;
                                 Format : in Packed_Format) return Packed_Decimal;
<a name="42">(42)</a>
             <em>-- Binary Formats: external data values are represented as Byte_Array</em>
<a name="43">(43)</a>
             function Valid (Item   : in Byte_Array;
                             Format : in Binary_Format) return Boolean;
<a name="44">(44)</a>
             function Length (Format : in Binary_Format) return Natural;
             function To_Decimal (Item   : in Byte_Array;
                                  Format : in Binary_Format) return Num;
<a name="45">(45)</a>
             function To_Binary (Item   : in Num;
                               Format : in Binary_Format) return Byte_Array;
<a name="46">(46)</a>
             <em>-- Internal Binary formats: data values are of type Binary or Long_Binary</em>
<a name="47">(47)</a>
             function To_Decimal (Item : in Binary)      return Num;
             function To_Decimal (Item : in Long_Binary) return Num;
<a name="48">(48)</a>
             function To_Binary      (Item : in Num)  return Binary;
             function To_Long_Binary (Item : in Num)  return Long_Binary;
<a name="49">(49)</a>
          end Decimal_Conversions;
<a name="50">(50)</a>
       private
          ... <em>-- not specified by the language</em>
       end Interfaces.COBOL;
</pre><dl><dt><a name="51">(51)</a><dd>Each of the types in Interfaces.COBOL is COBOL-compatible.
<dt><a name="52">(52)</a><dd>The types Floating and Long_Floating correspond to the native types in
COBOL for data items with computational usage implemented by floating point.
The types Binary and Long_Binary correspond to the native types in COBOL for
data items with binary usage, or with computational usage implemented by
binary.
<dt><a name="53">(53)</a><dd>Max_Digits_Binary is the largest number of decimal digits in a numeric
value that is represented as Binary.  Max_Digits_Long_Binary is the largest
number of decimal digits in a numeric value that is represented as Long_Binary.
<dt><a name="54">(54)</a><dd>The type Packed_Decimal corresponds to COBOL's packed-decimal usage.
<dt><a name="55">(55)</a><dd>The type COBOL_Character defines the run-time character set used in the
COBOL implementation.  Ada_To_COBOL and COBOL_To_Ada are the mappings between
the Ada and COBOL run-time character sets.
<dt><a name="56">(56)</a><dd>Type Alphanumeric corresponds to COBOL's alphanumeric data category.
<dt><a name="57">(57)</a><dd>Each of the functions To_COBOL and To_Ada converts its parameter based
on the mappings Ada_To_COBOL and COBOL_To_Ada, respectively.  The length of
the result for each is the length of the parameter, and the lower bound of
the result is 1.  Each component of the result is obtained by applying the
relevant mapping to the corresponding component of the parameter.
<dt><a name="58">(58)</a><dd>Each of the procedures To_COBOL and To_Ada copies converted elements
from Item to Target, using the appropriate mapping (Ada_To_COBOL or COBOL_To_Ada, respectively).  The index in Target of the last element assigned is
returned in Last (0 if Item is a null array).  If Item'Length exceeds
Target'Length, Constraint_Error is propagated.
<dt><a name="59">(59)</a><dd>Type Numeric corresponds to COBOL's numeric data category with display
usage.
<dt><a name="60">(60)</a><dd>The types Display_Format, Binary_Format, and Packed_Format are used in
conversions between Ada decimal type values and COBOL internal or external
data representations.  The value of the constant Native_Binary is either
High_Order_First or Low_Order_First, depending on the implementation.
</dl><pre><a name="61">(61)</a>
       function Valid (Item   : in Numeric;
                       Format : in Display_Format) return Boolean;
</pre><dl><dt><a name="62">(62)</a><dd><ul>The function Valid checks that the Item parameter has a value
consistent with the value of Format.  If the value of Format is other
than Unsigned, Leading_Separate, and Trailing_Separate, the effect is
implementation defined.  If Format does have one of these values, the
following rules apply:
</ul><dt><a name="63">(63)</a><dd><ul><ul><li>Format=Unsigned: if Item comprises zero or more leading
space characters followed by one or more decimal digit
characters then Valid returns True, else it returns
False.
</ul></ul><dt><a name="64">(64)</a><dd><ul><ul><li>Format=Leading_Separate: if Item comprises zero or more
leading space characters, followed by a single occurrence
of the plus or minus sign character, and then one or more
decimal digit characters, then Valid returns True, else
it returns False.
</ul></ul><dt><a name="65">(65)</a><dd><ul><ul><li>Format=Trailing_Separate: if Item comprises zero or more
leading space characters, followed by one or more decimal
digit characters and finally a plus or minus sign
character, then Valid returns True, else it returns
False.
</ul></ul></dl><pre><a name="66">(66)</a>
       function Length (Format : in Display_Format) return Natural;
</pre><dl><dt><a name="67">(67)</a><dd><ul>The Length function returns the minimal length of a Numeric
value sufficient to hold any value of type Num when represented as
Format.
</ul></dl><pre><a name="68">(68)</a>
       function To_Decimal (Item   : in Numeric;
                            Format : in Display_Format) return Num;
</pre><dl><dt><a name="69">(69)</a><dd><ul>Produces a value of type Num corresponding to Item as
represented by Format.  The number of digits after the assumed radix
point in Item is Num'Scale.  Conversion_Error is propagated if the
value represented by Item is outside the range of Num.
</ul></dl><pre><a name="70">(70)</a>
       function To_Display (Item   : in Num;
                            Format : in Display_Format) return Numeric;
</pre><dl><dt><a name="71">(71)</a><dd><ul>This function returns the Numeric value for Item, represented in
accordance with Format.  Conversion_Error is propagated if Num is
negative and Format is Unsigned.
</ul></dl><pre><a name="72">(72)</a>
       function Valid (Item   : in Packed_Decimal;
                       Format : in Packed_Format) return Boolean;
</pre><dl><dt><a name="73">(73)</a><dd><ul>This function returns True if Item has a value consistent with
Format, and False otherwise.  The rules for the formation of Packed_Decimal values are implementation defined.
</ul></dl><pre><a name="74">(74)</a>
       function Length (Format : in Packed_Format) return Natural;
</pre><dl><dt><a name="75">(75)</a><dd><ul>This function returns the minimal length of a Packed_Decimal
value sufficient to hold any value of type Num when represented as
Format.
</ul></dl><pre><a name="76">(76)</a>
       function To_Decimal (Item   : in Packed_Decimal;
                            Format : in Packed_Format) return Num;
</pre><dl><dt><a name="77">(77)</a><dd><ul>Produces a value of type Num corresponding to Item as
represented by Format.  Num'Scale is the number of digits after the
assumed radix point in Item.  Conversion_Error is propagated if the
value represented by Item is outside the range of Num.
</ul></dl><pre><a name="78">(78)</a>
       function To_Packed (Item   : in Num;
                           Format : in Packed_Format) return Packed_Decimal;
</pre><dl><dt><a name="79">(79)</a><dd><ul>This function returns the Packed_Decimal value for Item,
represented in accordance with Format.  Conversion_Error is
propagated if Num is negative and Format is Packed_Unsigned.
</ul></dl><pre><a name="80">(80)</a>
       function Valid (Item   : in Byte_Array;
                       Format : in Binary_Format) return Boolean;
</pre><dl><dt><a name="81">(81)</a><dd><ul>This function returns True if Item has a value consistent with
Format, and False otherwise.
</ul></dl><pre><a name="82">(82)</a>
       function Length (Format : in Binary_Format) return Natural;
</pre><dl><dt><a name="83">(83)</a><dd><ul>This function returns the minimal length of a Byte_Array value
sufficient to hold any value of type Num when represented as Format.
</ul></dl><pre><a name="84">(84)</a>
       function To_Decimal (Item   : in Byte_Array;
                            Format : in Binary_Format) return Num;
</pre><dl><dt><a name="85">(85)</a><dd><ul>Produces a value of type Num corresponding to Item as
represented by Format.  Num'Scale is the number of digits after the
assumed radix point in Item.  Conversion_Error is propagated if the
value represented by Item is outside the range of Num.
</ul></dl><pre><a name="86">(86)</a>
       function To_Binary (Item   : in Num;
                           Format : in Binary_Format) return Byte_Array;
</pre><dl><dt><a name="87">(87)</a><dd><ul>This function returns the Byte_Array value for Item, represented
in accordance with Format.
</ul></dl><pre><a name="88">(88)</a>
       function To_Decimal (Item : in Binary)      return Num;

       function To_Decimal (Item : in Long_Binary) return Num;
</pre><dl><dt><a name="89">(89)</a><dd><ul>These functions convert from COBOL binary format to a
corresponding value of the decimal type Num.  Conversion_Error is
propagated if Item is too large for Num.
</ul></dl><pre><a name="90">(90)</a>
       function To_Binary      (Item : in Num)  return Binary;

       function To_Long_Binary (Item : in Num)  return Long_Binary;
</pre><dl><dt><a name="91">(91)</a><dd><ul>These functions convert from Ada decimal to COBOL binary format.
Conversion_Error is propagated if the value of Item is too large to
be represented in the result type.
</ul></dl><h5 align="center">Implementation Requirements</h5>
<dl><dt><a name="92">(92)</a><dd>An implementation shall support pragma Convention with a COBOL
convention_identifier for a COBOL-eligible type <a href="B-01.htm">(see B.1)</a>.
</dl><h5 align="center">Implementation Permissions</h5>
<dl><dt><a name="93">(93)</a><dd>An implementation may provide additional constants of the private types
Display_Format, Binary_Format, or Packed_Format.
<dt><a name="94">(94)</a><dd>An implementation may provide further floating point and integer types
in Interfaces.COBOL to match additional native COBOL types, and may also
supply corresponding conversion functions in the generic package Decimal_Conversions.
</dl><h5 align="center">Implementation Advice</h5>
<dl><dt><a name="95">(95)</a><dd>An Ada implementation should support the following interface
correspondences between Ada and COBOL.
<dt><a name="96">(96)</a><dd><ul><li>An Ada access T parameter is passed as a ``BY REFERENCE'' data
item of the COBOL type corresponding to T.
</ul><dt><a name="97">(97)</a><dd><ul><li>An Ada in scalar parameter is passed as a ``BY CONTENT'' data
item of the corresponding COBOL type.
</ul><dt><a name="98">(98)</a><dd><ul><li>Any other Ada parameter is passed as a ``BY REFERENCE'' data item
of the COBOL type corresponding to the Ada parameter type; for
scalars, a local copy is used if necessary to ensure by-copy
semantics.
</ul><p><dt><dd><ul>NOTES</ul>
<dt><a name="99">(99)</a><dd><ul>(15) An implementation is not required to support pragma Convention for
access types, nor is it required to support pragma Import, Export or
Convention for functions.
</ul><dt><a name="100">(100)</a><dd><ul>(16) If an Ada subprogram is exported to COBOL, then a call from COBOL
call may specify either ``BY CONTENT'' or ``BY REFERENCE''.
</ul></dl><h5 align="center">Examples</h5>
<dl><dt><a name="101">(101)</a><dd><em>Examples of Interfaces.COBOL:
</em>
</dl><pre><a name="102">(102)</a>
       with Interfaces.COBOL;
       procedure Test_Call is
<a name="103">(103)</a>
          <em>-- Calling a foreign COBOL program</em>
          <em>-- Assume that a COBOL program PROG has the following declaration</em>
          <em>--  in its LINKAGE section:</em>
          <em>--  01 Parameter-Area</em>
          <em>--     05 NAME   PIC X(20).</em>
          <em>--     05 SSN    PIC X(9).</em>
          <em>--     05 SALARY PIC 99999V99 USAGE COMP.</em>
          <em>-- The effect of PROG is to update SALARY based on some algorithm</em>
<a name="104">(104)</a>
          package COBOL renames Interfaces.COBOL;
<a name="105">(105)</a>
          type Salary_Type is delta 0.01 digits 7;
<a name="106">(106)</a>
          type COBOL_Record is
             record
                Name   : COBOL.Numeric(1..20);
                SSN    : COBOL.Numeric(1..9);
                Salary : COBOL.Binary;  <em>-- Assume Binary = 32 bits</em>
             end record;
          pragma Convention (COBOL, COBOL_Record);
<a name="107">(107)</a>
          procedure Prog (Item : in out COBOL_Record);
          pragma Import (COBOL, Prog, "PROG");
<a name="108">(108)</a>
          package Salary_Conversions is
             new COBOL.Decimal_Conversions(Salary_Type);
<a name="109">(109)</a>
          Some_Salary : Salary_Type := 12_345.67;
          Some_Record : COBOL_Record :=
             (Name   =&gt; "Johnson, John       ",
              SSN    =&gt; "111223333",
              Salary =&gt; Salary_Conversions.To_Binary(Some_Salary));
<a name="110">(110)</a>
       begin
          Prog (Some_Record);
          ...
       end Test_Call;
<a name="111">(111)</a>
       with Interfaces.COBOL;
       with COBOL_Sequential_IO; <em>-- Assumed to be supplied by implementation</em>
       procedure Test_External_Formats is
<a name="112">(112)</a>
          <em>-- Using data created by a COBOL program</em>
          <em>-- Assume that a COBOL program has created a sequential file with</em>
          <em>--  the following record structure, and that we need to</em>
          <em>--  process the records in an Ada program</em>
          <em>--  01 EMPLOYEE-RECORD</em>
          <em>--     05 NAME    PIC X(20).</em>
          <em>--     05 SSN     PIC X(9).</em>
          <em>--     05 SALARY  PIC 99999V99 USAGE COMP.</em>
          <em>--     05 ADJUST  PIC S999V999 SIGN LEADING SEPARATE.</em>
          <em>-- The COMP data is binary (32 bits), high-order byte first</em>
<a name="113">(113)</a>
          package COBOL renames Interfaces.COBOL;
<a name="114">(114)</a>
          type Salary_Type      is delta 0.01  digits 7;
          type Adjustments_Type is delta 0.001 digits 6;
<a name="115">(115)</a>
          type COBOL_Employee_Record_Type is  <em>-- External representation</em>
             record
                Name    : COBOL.Alphanumeric(1..20);
                SSN     : COBOL.Alphanumeric(1..9);
                Salary  : COBOL.Byte_Array(1..4);
                Adjust  : COBOL.Numeric(1..7);  <em>-- Sign and 6 digits</em>
             end record;
          pragma Convention (COBOL, COBOL_Employee_Record_Type);
<a name="116">(116)</a>
          package COBOL_Employee_IO is
             new COBOL_Sequential_IO(COBOL_Employee_Record_Type);
          use COBOL_Employee_IO;
<a name="117">(117)</a>
          COBOL_File : File_Type;
<a name="118">(118)</a>
          type Ada_Employee_Record_Type is  <em>-- Internal representation</em>
             record
                Name    : String(1..20);
                SSN     : String(1..9);
                Salary  : Salary_Type;
                Adjust  : Adjustments_Type;
             end record;
<a name="119">(119)</a>
          COBOL_Record : COBOL_Employee_Record_Type;
          Ada_Record   : Ada_Employee_Record_Type;
<a name="120">(120)</a>
          package Salary_Conversions is
             new COBOL.Decimal_Conversions(Salary_Type);
          use Salary_Conversions;
<a name="121">(121)</a>
          package Adjustments_Conversions is
             new COBOL.Decimal_Conversions(Adjustments_Type);
          use Adjustments_Conversions;
<a name="122">(122)</a>
       begin
          Open (COBOL_File, Name =&gt; "Some_File");
<a name="123">(123)</a>
          loop
            Read (COBOL_File, COBOL_Record);
<a name="124">(124)</a>
            Ada_Record.Name := To_Ada(COBOL_Record.Name);
            Ada_Record.SSN  := To_Ada(COBOL_Record.SSN);
            Ada_Record.Salary :=
               To_Decimal(COBOL_Record.Salary, COBOL.High_Order_First);
            Ada_Record.Adjust :=
               To_Decimal(COBOL_Record.Adjust, COBOL.Leading_Separate);
            ... <em>-- Process Ada_Record</em>
          end loop;
       exception
          when End_Error =&gt; ...
       end Test_External_Formats;
</pre><p>
<hr>
<h4><a href="B-03.htm"><img src="left.gif" alt="Prev"></a> | <a href="B.htm"><img src="up.gif" alt="Up"></a> | <a href="B-05.htm"><img src="right.gif" alt="Next"></a> | <a href="B-03-02.htm"><img src="back.gif" alt="Back"></a> | <a href="B-05.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
