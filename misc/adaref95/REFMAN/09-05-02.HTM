<html>
<head>
<title>Ada 95 RM - 9.5.2 Entries and Accept Statements</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="09-05-01.htm"><img src="left.gif" alt="Prev"></a> | <a href="09-05.htm"><img src="up.gif" alt="Up"></a> | <a href="09-05-03.htm"><img src="right.gif" alt="Next"></a> | <a href="09-05-01.htm"><img src="back.gif" alt="Back"></a> | <a href="09-05-03.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>
<h3><a name="0">9.5.2 Entries and Accept Statements</a></h3>
<dl><dt><a name="1">(1)</a><dd>Entry_declarations, with the corresponding entry_bodies or accept_statements, are used to define potentially queued operations on tasks and
protected objects.
</dl><h5 align="center"><a name="syntax">Syntax</a></h5>
<pre><a name="2">(2)</a>
       entry_declaration ::=
          entry defining_identifier [(discrete_subtype_definition)] parameter_profile;
<a name="3">(3)</a>
       accept_statement ::=
          accept entry_direct_name [(entry_index)] parameter_profile [do
            handled_sequence_of_statements
          end [entry_identifier]];
<a name="4">(4)</a>
       entry_index ::= expression
<a name="5">(5)</a>
       entry_body ::=
         entry defining_identifier  entry_body_formal_part  entry_barrier is
           declarative_part
         begin
           handled_sequence_of_statements
         end [entry_identifier];
<a name="6">(6)</a>
       entry_body_formal_part ::= [(entry_index_specification)] parameter_profile
<a name="7">(7)</a>
       entry_barrier ::= when condition
<a name="8">(8)</a>
       entry_index_specification ::= for defining_identifier in discrete_subtype_definition
</pre><dl><dt><a name="9">(9)</a><dd><ul><li>If an entry_identifier appears at the end of an accept_statement, it
shall repeat the entry_direct_name.  If an entry_identifier appears at
the end of an entry_body, it shall repeat the defining_identifier.
</ul><dt><a name="10">(10)</a><dd><ul>An entry_declaration is allowed only in a protected or task
declaration.
</ul></dl><h5 align="center">Name Resolution Rules</h5>
<dl><dt><a name="11">(11)</a><dd>In an accept_statement, the expected profile for the entry_direct_name
is that of the entry_declaration; the expected type for an entry_index is
that of the subtype defined by the discrete_subtype_definition of the
corresponding entry_declaration.
<dt><a name="12">(12)</a><dd>Within the handled_sequence_of_statements of an accept_statement, if a
selected_component has a prefix that denotes the corresponding entry_declaration, then the entity denoted by the prefix is the accept_statement,
and the selected_component is interpreted as an expanded name <a href="04-01-03.htm">(see 4.1.3)</a>;
the selector_name of the selected_component has to be the identifier for some
formal parameter of the accept_statement.
</dl><h5 align="center">Legality Rules</h5>
<dl><dt><a name="13">(13)</a><dd>An entry_declaration in a task declaration shall not contain a
specification for an access parameter <a href="03-10.htm">(see 3.10)</a>.
<dt><a name="14">(14)</a><dd>For an accept_statement, the innermost enclosing body shall be a task_body, and the entry_direct_name shall denote an entry_declaration in the
corresponding task declaration; the profile of the accept_statement shall
conform fully to that of the corresponding entry_declaration.  An accept_statement shall have a parenthesized entry_index if and only if the
corresponding entry_declaration has a discrete_subtype_definition.
<dt><a name="15">(15)</a><dd>An accept_statement shall not be within another accept_statement that
corresponds to the same entry_declaration, nor within an asynchronous_select
inner to the enclosing task_body.
<dt><a name="16">(16)</a><dd>An entry_declaration of a protected unit requires a completion, which
shall be an entry_body, and every entry_body shall be the completion of an
entry_declaration of a protected unit.  The profile of the entry_body shall
conform fully to that of the corresponding declaration.
<dt><a name="17">(17)</a><dd>An entry_body_formal_part shall have an entry_index_specification if and
only if the corresponding entry_declaration has a discrete_subtype_definition.  In this case, the discrete_subtype_definitions of the entry_declaration and the entry_index_specification shall fully conform to one
another <a href="06-03-01.htm">(see 6.3.1)</a>.
<dt><a name="18">(18)</a><dd>A name that denotes a formal parameter of an entry_body is not allowed
within the entry_barrier of the entry_body.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="19">(19)</a><dd>The parameter modes defined for parameters in the parameter_profile of
an entry_declaration are the same as for a subprogram_declaration and have
the same meaning <a href="06-02.htm">(see 6.2)</a>.
<dt><a name="20">(20)</a><dd>An entry_declaration with a discrete_subtype_definition <a href="03-06.htm">(see 3.6)</a>
declares a family of distinct entries having the same profile, with one such
entry for each value of the entry index subtype defined by the discrete_subtype_definition.  A name for an entry of a family takes the form of an
indexed_component, where the prefix denotes the entry_declaration for the
family, and the index value identifies the entry within the family.  The term
single entry is used to refer to any entry other than an entry of an entry
family.
<dt><a name="21">(21)</a><dd>In the entry_body for an entry family, the entry_index_specification
declares a named constant whose subtype is the entry index subtype defined by
the corresponding entry_declaration; the value of the named entry index
identifies which entry of the family was called.
</dl><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="22">(22)</a><dd>For the elaboration of an entry_declaration for an entry family, if the
discrete_subtype_definition contains no per-object expressions <a href="03-08.htm">(see 3.8)</a>,
then the discrete_subtype_definition is elaborated.  Otherwise, the
elaboration of the entry_declaration consists of the evaluation of any
expression of the discrete_subtype_definition that is not a per-object
expression (or part of one).  The elaboration of an entry_declaration for a
single entry has no effect.
<dt><a name="23">(23)</a><dd>The actions to be performed when an entry is called are specified by the
corresponding accept_statements (if any) for an entry of a task unit, and by
the corresponding entry_body for an entry of a protected unit.
<dt><a name="24">(24)</a><dd>For the execution of an accept_statement, the entry_index, if any, is
first evaluated and converted to the entry index subtype; this index value
identifies which entry of the family is to be accepted.  Further execution of
the accept_statement is then blocked until a caller of the corresponding
entry is selected <a href="09-05-03.htm">(see 9.5.3)</a>, whereupon the handled_sequence_of_statements,
if any, of the accept_statement is executed, with the formal parameters
associated with the corresponding actual parameters of the selected entry
call.  Upon completion of the handled_sequence_of_statements, the accept_statement completes and is left.  When an exception is propagated from the
handled_sequence_of_statements of an accept_statement, the same exception is
also raised by the execution of the corresponding entry_call_statement.
<dt><a name="25">(25)</a><dd>The above interaction between a calling task and an accepting task is
called a rendezvous.  After a rendezvous, the two tasks continue their
execution independently.
<dt><a name="26">(26)</a><dd>An entry_body is executed when the condition of the entry_barrier
evaluates to True and a caller of the corresponding single entry, or entry of
the corresponding entry family, has been selected <a href="09-05-03.htm">(see 9.5.3)</a>.  For the
execution of the entry_body, the declarative_part of the entry_body is
elaborated, and the handled_sequence_of_statements of the body is executed,
as for the execution of a subprogram_body.  The value of the named entry
index, if any, is determined by the value of the entry index specified in the
entry_name of the selected entry call (or intermediate requeue_statement --
<a href="09-05-04.htm">see 9.5.4)</a>.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="27">(27)</a><dd><ul>(22) A task entry has corresponding accept_statements (zero or more),
whereas a protected entry has a corresponding entry_body (exactly one).
</ul><dt><a name="28">(28)</a><dd><ul>(23) A consequence of the rule regarding the allowed placements of
accept_statements is that a task can execute accept_statements only for
its own entries.
</ul><dt><a name="29">(29)</a><dd><ul>(24) A return_statement <a href="06-05.htm">(see 6.5)</a> or a requeue_statement <a href="09-05-04.htm">(see 9.5.4)</a> may
be used to complete the execution of an accept_statement or an entry_body.
</ul><dt><a name="30">(30)</a><dd><ul>(25) The condition in the entry_barrier may reference anything visible
except the formal parameters of the entry.  This includes the entry
index (if any), the components (including discriminants) of the
protected object, the Count attribute of an entry of that protected
object, and data global to the protected unit.
</ul><dt><a name="31">(31)</a><dd><ul>The restriction against referencing the formal parameters within an
entry_barrier ensures that all calls of the same entry see the same
barrier value.  If it is necessary to look at the parameters of an entry
call before deciding whether to handle it, the entry_barrier can be
``when True'' and the caller can be requeued (on some private entry)
when its parameters indicate that it cannot be handled immediately.
</ul></dl><h5 align="center">Examples</h5>
<dl><dt><a name="32">(32)</a><dd><em>Examples of entry declarations:
</em>
</dl><pre><a name="33">(33)</a>
       entry Read(V : out Item);
       entry Seize;
       entry Request(Level)(D : Item);  <em>--  a family of entries</em>
</pre><dl><dt><a name="34">(34)</a><dd><em>Examples of accept statements:
</em>
</dl><pre><a name="35">(35)</a>
       accept Shut_Down;
<a name="36">(36)</a>
       accept Read(V : out Item) do
          V := Local_Item;
       end Read;
<a name="37">(37)</a>
       accept Request(Low)(D : Item) do
          ...
       end Request;
</pre><hr>
<h4><a href="09-05-01.htm"><img src="left.gif" alt="Prev"></a> | <a href="09-05.htm"><img src="up.gif" alt="Up"></a> | <a href="09-05-03.htm"><img src="right.gif" alt="Next"></a> | <a href="09-05-01.htm"><img src="back.gif" alt="Back"></a> | <a href="09-05-03.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
