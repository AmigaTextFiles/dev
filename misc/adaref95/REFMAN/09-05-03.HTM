<html>
<head>
<title>Ada 95 RM - 9.5.3 Entry Calls</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="09-05-02.htm"><img src="left.gif" alt="Prev"></a> | <a href="09-05.htm"><img src="up.gif" alt="Up"></a> | <a href="09-05-04.htm"><img src="right.gif" alt="Next"></a> | <a href="09-05-02.htm"><img src="back.gif" alt="Back"></a> | <a href="09-05-04.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>
<h3><a name="0">9.5.3 Entry Calls</a></h3>
<dl><dt><a name="1">(1)</a><dd>An entry_call_statement (an entry call) can appear in various contexts.
A simple entry call is a stand-alone statement that represents an
unconditional call on an entry of a target task or a protected object.  Entry
calls can also appear as part of select_statements <a href="09-07.htm">(see 9.7)</a>.
</dl><h5 align="center"><a name="syntax">Syntax</a></h5>
<pre><a name="2">(2)</a>
       entry_call_statement ::= entry_name [actual_parameter_part];
</pre><h5 align="center">Name Resolution Rules</h5>
<dl><dt><a name="3">(3)</a><dd>The entry_name given in an entry_call_statement shall resolve to denote
an entry.  The rules for parameter associations are the same as for
subprogram calls <a href="06-04.htm">(see 6.4</a> and <a href="06-04-01.htm">6.4.1)</a>.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="4">(4)</a><dd>The entry_name of an entry_call_statement specifies (explicitly or
implicitly) the target object of the call, the entry or entry family, and the
entry index, if any <a href="09-05.htm">(see 9.5)</a>.
</dl><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="5">(5)</a><dd>Under certain circumstances (detailed below), an entry of a task or
protected object is checked to see whether it is open or closed:
<dt><a name="6">(6)</a><dd><ul><li>An entry of a task is open if the task is blocked on an accept_statement that corresponds to the entry <a href="09-05-02.htm">(see 9.5.2)</a>, or on a
selective_accept <a href="09-07-01.htm">(see 9.7.1)</a> with an open accept_alternative that
corresponds to the entry; otherwise it is closed.
</ul><dt><a name="7">(7)</a><dd><ul><li>An entry of a protected object is open if the condition of the
entry_barrier of the corresponding entry_body evaluates to True;
otherwise it is closed.  If the evaluation of the condition
propagates an exception, the exception Program_Error is
propagated to all current callers of all entries of the protected
object.
</ul><dt><a name="8">(8)</a><dd>For the execution of an entry_call_statement, evaluation of the name and
of the parameter associations is as for a subprogram call <a href="06-04.htm">(see 6.4)</a>.  The
entry call is then issued:  For a call on an entry of a protected object, a
new protected action is started on the object <a href="09-05-01.htm">(see 9.5.1)</a>.  The named entry
is checked to see if it is open; if open, the entry call is said to be
selected immediately, and the execution of the call proceeds as follows:
<dt><a name="9">(9)</a><dd><ul><li>For a call on an open entry of a task, the accepting task becomes
ready and continues the execution of the corresponding accept_statement <a href="09-05-02.htm">(see 9.5.2)</a>.
</ul><dt><a name="10">(10)</a><dd><ul><li>For a call on an open entry of a protected object, the
corresponding entry_body is executed <a href="09-05-02.htm">(see 9.5.2)</a> as part of the
protected action.
</ul><dt><a name="11">(11)</a><dd>If the accept_statement or entry_body completes other than by a requeue
<a href="09-05-04.htm">(see 9.5.4)</a>, return is made to the caller (after servicing the entry queues
-- see below); any necessary assigning back of formal to actual parameters
occurs, as for a subprogram call <a href="06-04-01.htm">(see 6.4.1)</a>; such assignments take place
outside of any protected action.
<dt><a name="12">(12)</a><dd>If the named entry is closed, the entry call is added to an entry queue
(as part of the protected action, for a call on a protected entry), and the
call remains queued until it is selected or cancelled; there is a separate
(logical) entry queue for each entry of a given task or protected object
(including each entry of an entry family).
<dt><a name="13">(13)</a><dd>When a queued call is selected, it is removed from its entry queue.
Selecting a queued call from a particular entry queue is called servicing the
entry queue.  An entry with queued calls can be serviced under the following
circumstances:
<dt><a name="14">(14)</a><dd><ul><li>When the associated task reaches a corresponding accept_statement, or a selective_accept with a corresponding open
accept_alternative;
</ul><dt><a name="15">(15)</a><dd><ul><li>If after performing, as part of a protected action on the
associated protected object, an operation on the object other
than a call on a protected function, the entry is checked and
found to be open.
</ul><dt><a name="16">(16)</a><dd>If there is at least one call on a queue corresponding to an open entry,
then one such call is selected according to the entry queuing policy in
effect (see below), and the corresponding accept_statement or entry_body is
executed as above for an entry call that is selected immediately.
<dt><a name="17">(17)</a><dd>The entry queuing policy controls selection among queued calls both for
task and protected entry queues.  The default entry queuing policy is to
select calls on a given entry queue in order of arrival.  If calls from two
or more queues are simultaneously eligible for selection, the default entry
queuing policy does not specify which queue is serviced first.  Other entry
queuing policies can be specified by pragmas <a href="D-04.htm">(see D.4)</a>.
<dt><a name="18">(18)</a><dd>For a protected object, the above servicing of entry queues continues
until there are no open entries with queued calls, at which point the
protected action completes.
<dt><a name="19">(19)</a><dd>For an entry call that is added to a queue, and that is not the
triggering_statement of an asynchronous_select <a href="09-07-04.htm">(see 9.7.4)</a>, the calling task
is blocked until the call is cancelled, or the call is selected and a
corresponding accept_statement or entry_body completes without requeuing.  In
addition, the calling task is blocked during a rendezvous.
<dt><a name="20">(20)</a><dd>An attempt can be made to cancel an entry call upon an abort <a href="09-08.htm">(see 9.8)</a>
and as part of certain forms of select_statement <a href="09-07-02.htm">(see 9.7.2</a>, <a href="09-07-03.htm">9.7.3</a>, and
<a href="09-07-04.htm">9.7.4)</a>.  The cancellation does not take place until a point (if any) when the
call is on some entry queue, and not protected from cancellation as part of a
requeue <a href="09-05-04.htm">(see 9.5.4)</a>; at such a point, the call is removed from the entry
queue and the call completes due to the cancellation.  The cancellation of a
call on an entry of a protected object is a protected action, and as such
cannot take place while any other protected action is occurring on the
protected object.  Like any protected action, it includes servicing of the
entry queues (in case some entry barrier depends on a Count attribute).
<dt><a name="21">(21)</a><dd>A call on an entry of a task that has already completed its execution
raises the exception Tasking_Error at the point of the call; similarly, this
exception is raised at the point of the call if the called task completes its
execution or becomes abnormal before accepting the call or completing the
rendezvous <a href="09-08.htm">(see 9.8)</a>.  This applies equally to a simple entry call and to an
entry call as part of a select_statement.
</dl><h5 align="center">Implementation Permissions</h5>
<dl><dt><a name="22">(22)</a><dd>An implementation may perform the sequence of steps of a protected
action using any thread of control; it need not be that of the task that
started the protected action.  If an entry_body completes without requeuing,
then the corresponding calling task may be made ready without waiting for the
entire protected action to complete.
<dt><a name="23">(23)</a><dd>When the entry of a protected object is checked to see whether it is
open, the implementation need not reevaluate the condition of the
corresponding entry_barrier if no variable or attribute referenced by the
condition (directly or indirectly) has been altered by the execution (or
cancellation) of a protected procedure or entry call on the object since the
condition was last evaluated.
<dt><a name="24">(24)</a><dd>An implementation may evaluate the conditions of all entry_barriers of a
given protected object any time any entry of the object is checked to see if
it is open.
<dt><a name="25">(25)</a><dd>When an attempt is made to cancel an entry call, the implementation need
not make the attempt using the thread of control of the task (or interrupt)
that initiated the cancellation; in particular, it may use the thread of
control of the caller itself to attempt the cancellation, even if this might
allow the entry call to be selected in the interim.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="26">(26)</a><dd><ul>(26) If an exception is raised during the execution of an entry_body, it
is propagated to the corresponding caller <a href="11-04.htm">(see 11.4)</a>.
</ul><dt><a name="27">(27)</a><dd><ul>(27) For a call on a protected entry, the entry is checked to see if it
is open prior to queuing the call, and again thereafter if its Count
attribute <a href="09-09.htm">(see 9.9)</a> is referenced in some entry barrier.
</ul><dt><a name="28">(28)</a><dd><ul>(28) In addition to simple entry calls, the language permits timed,
conditional, and asynchronous entry calls <a href="09-07-02.htm">(see 9.7.2</a>, <a href="09-07-03.htm">9.7.3</a>, and <a href="09-07-04.htm">see 9.7.4)</a>.
</ul><dt><a name="29">(29)</a><dd><ul>(29) The condition of an entry_barrier is allowed to be evaluated by an
implementation more often than strictly necessary, even if the
evaluation might have side effects.  On the other hand, an
implementation need not reevaluate the condition if nothing it
references was updated by an intervening protected action on the
protected object, even if the condition references some global variable
that might have been updated by an action performed from outside of a
protected action.
</ul></dl><h5 align="center">Examples</h5>
<dl><dt><a name="30">(30)</a><dd><em>Examples of entry calls:
</em>
</dl><pre><a name="31">(31)</a>
       Agent.Shut_Down;                      <em>--  <a href="09-01.htm">see 9.1</a></em>
       Parser.Next_Lexeme(E);                <em>--  <a href="09-01.htm">see 9.1</a></em>
       Pool(5).Read(Next_Char);              <em>--  <a href="09-01.htm">see 9.1</a></em>
       Controller.Request(Low)(Some_Item);   <em>--  <a href="09-01.htm">see 9.1</a></em>
       Flags(3).Seize;                       <em>--  <a href="09-04.htm">see 9.4</a></em>
</pre><hr>
<h4><a href="09-05-02.htm"><img src="left.gif" alt="Prev"></a> | <a href="09-05.htm"><img src="up.gif" alt="Up"></a> | <a href="09-05-04.htm"><img src="right.gif" alt="Next"></a> | <a href="09-05-02.htm"><img src="back.gif" alt="Back"></a> | <a href="09-05-04.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
