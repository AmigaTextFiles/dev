<html>
<head>
<title>Ada 95 RM - C.7.2 The Package Task_Attributes</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="C-07-01.htm"><img src="left.gif" alt="Prev"></a> | <a href="C-07.htm"><img src="up.gif" alt="Up"></a> | <img src="noright.gif" alt="____"> | <a href="C-07-01.htm"><img src="back.gif" alt="Back"></a> | <a href="D.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>
<h3><a name="0">C.7.2 The Package Task_Attributes</a></h3>
<h5 align="center">Static Semantics</h5>
<dl><dt><a name="1">(1)</a><dd>The following language-defined generic library package exists:
</dl><pre><a name="2">(2)</a>
       with Ada.Task_Identification; use Ada.Task_Identification;
       generic
          type Attribute is private;
          Initial_Value : in Attribute;
       package Ada.Task_Attributes is
<a name="3">(3)</a>
          type Attribute_Handle is access all Attribute;
<a name="4">(4)</a>
          function Value(T : Task_ID := Current_Task)
            return Attribute;
<a name="5">(5)</a>
          function Reference(T : Task_ID := Current_Task)
            return Attribute_Handle;
<a name="6">(6)</a>
          procedure Set_Value(Val : in Attribute;
                                    T : in Task_ID := Current_Task);
          procedure Reinitialize(T : in Task_ID := Current_Task);
<a name="7">(7)</a>
       end Ada.Task_Attributes;
</pre><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="8">(8)</a><dd>When an instance of Task_Attributes is elaborated in a given active
partition, an object of the actual type corresponding to the formal type
Attribute is implicitly created for each task (of that partition) that exists
and is not yet terminated.  This object acts as a user-defined attribute of
the task.  A task created previously in the partition and not yet terminated
has this attribute from that point on.  Each task subsequently created in the
partition will have this attribute when created.  In all these cases, the
initial value of the given attribute is Initial_Value.
<dt><a name="9">(9)</a><dd>The Value operation returns the value of the corresponding attribute of
T.
<dt><a name="10">(10)</a><dd>The Reference operation returns an access value that designates the
corresponding attribute of T.
<dt><a name="11">(11)</a><dd>The Set_Value operation performs any finalization on the old value of
the attribute of T and assigns Val to that attribute <a href="05-02.htm">(see 5.2</a> and <a href="07-06.htm">7.6)</a>.
<dt><a name="12">(12)</a><dd>The effect of the Reinitialize operation is the same as Set_Value where
the Val parameter is replaced with Initial_Value.
<dt><a name="13">(13)</a><dd>For all the operations declared in this package, Tasking_Error is raised
if the task identified by T is terminated.  Program_Error is raised if the
value of T is Null_Task_ID.
</dl><h5 align="center">Erroneous Execution</h5>
<dl><dt><a name="14">(14)</a><dd>It is erroneous to dereference the access value returned by a given call
on Reference after a subsequent call on Reinitialize for the same task
attribute, or after the associated task terminates.
<dt><a name="15">(15)</a><dd>If a value of Task_ID is passed as a parameter to any of the operations
declared in this package and the corresponding task object no longer exists,
the execution of the program is erroneous.
</dl><h5 align="center">Implementation Requirements</h5>
<dl><dt><a name="16">(16)</a><dd>The implementation shall perform each of the above operations for a
given attribute of a given task atomically with respect to any other of the
above operations for the same attribute of the same task.
<dt><a name="17">(17)</a><dd>When a task terminates, the implementation shall finalize all attributes
of the task, and reclaim any other storage associated with the attributes.
</dl><h5 align="center">Documentation Requirements</h5>
<dl><dt><a name="18">(18)</a><dd>The implementation shall document the limit on the number of attributes
per task, if any, and the limit on the total storage for attribute values per
task, if such a limit exists.
<dt><a name="19">(19)</a><dd>In addition, if these limits can be configured, the implementation shall
document how to configure them.
</dl><h5 align="center">Metrics</h5>
<dl><dt><a name="20">(20)</a><dd>The implementation shall document the following metrics: A task calling
the following subprograms shall execute in a sufficiently high priority as to
not be preempted during the measurement period.  This period shall start just
before issuing the call and end just after the call completes.  If the
attributes of task T are accessed by the measurement tests, no other task
shall access attributes of that task during the measurement period.  For all
measurements described here, the Attribute type shall be a scalar whose size
is equal to the size of the predefined integer size.  For each measurement,
two cases shall be documented: one where the accessed attributes are of the
calling task (that is, the default value for the T parameter is used), and
the other, where T identifies another, non-terminated, task.
<dt><a name="21">(21)</a><dd>The following calls (to subprograms in the Task_Attributes package)
shall be measured:
<dt><a name="22">(22)</a><dd><ul><li>a call to Value, where the return value is Initial_Value;
</ul><dt><a name="23">(23)</a><dd><ul><li>a call to Value, where the return value is not equal to Initial_Value;
</ul><dt><a name="24">(24)</a><dd><ul><li>a call to Reference, where the return value designates a value
equal to Initial_Value;
</ul><dt><a name="25">(25)</a><dd><ul><li>a call to Reference, where the return value designates a value
not equal to Initial_Value;
</ul><dt><a name="26">(26)</a><dd><ul><li>a call to Set_Value where the Val parameter is not equal to
Initial_Value and the old attribute value is equal to Initial_Value.
</ul><dt><a name="27">(27)</a><dd><ul><li>a call to Set_Value where the Val parameter is not equal to
Initial_Value and the old attribute value is not equal to
Initial_Value.
</ul></dl><h5 align="center">Implementation Permissions</h5>
<dl><dt><a name="28">(28)</a><dd>An implementation need not actually create the object corresponding to a
task attribute until its value is set to something other than that of
Initial_Value, or until Reference is called for the task attribute.
Similarly, when the value of the attribute is to be reinitialized to that of
Initial_Value, the object may instead be finalized and its storage reclaimed,
to be recreated when needed later.  While the object does not exist, the
function Value may simply return Initial_Value, rather than implicitly
creating the object.
<dt><a name="29">(29)</a><dd>An implementation is allowed to place restrictions on the maximum number
of attributes a task may have, the maximum size of each attribute, and the
total storage size allocated for all the attributes of a task.
</dl><h5 align="center">Implementation Advice</h5>
<dl><dt><a name="30">(30)</a><dd>Some implementations are targeted to domains in which memory use at run
time must be completely deterministic.  For such implementations, it is
recommended that the storage for task attributes will be pre-allocated
statically and not from the heap.  This can be accomplished by either placing
restrictions on the number and the size of the task's attributes, or by using
the pre-allocated storage for the first N attribute objects, and the heap for
the others.  In the latter case, N should be documented.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="31">(31)</a><dd><ul>(12) An attribute always exists (after instantiation), and has the
initial value.  It need not occupy memory until the first operation that
potentially changes the attribute value.  The same holds true after
Reinitialize.
</ul><dt><a name="32">(32)</a><dd><ul>(13) The result of the Reference function should be used with care; it
is always safe to use that result in the task body whose attribute is
being accessed.  However, when the result is being used by another task,
the programmer must make sure that the task whose attribute is being
accessed is not yet terminated.  Failing to do so could make the program
execution erroneous.
</ul><dt><a name="33">(33)</a><dd><ul>(14) As specified <a href="C-07-01.htm">in C.7.1</a>, if the parameter T (in a call on a
subprogram of an instance of this package) identifies a nonexistent
task, the execution of the program is erroneous.
</ul></dl><hr>
<h4><a href="C-07-01.htm"><img src="left.gif" alt="Prev"></a> | <a href="C-07.htm"><img src="up.gif" alt="Up"></a> | <img src="noright.gif" alt="____"> | <a href="C-07-01.htm"><img src="back.gif" alt="Back"></a> | <a href="D.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
