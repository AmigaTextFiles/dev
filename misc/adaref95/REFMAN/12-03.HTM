<html>
<head>
<title>Ada 95 RM - 12.3 Generic Instantiation</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="12-02.htm"><img src="left.gif" alt="Prev"></a> | <a href="12.htm"><img src="up.gif" alt="Up"></a> | <a href="12-04.htm"><img src="right.gif" alt="Next"></a> | <a href="12-02.htm"><img src="back.gif" alt="Back"></a> | <a href="12-04.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>

<h2><a name="0">12.3 Generic Instantiation</a></h2>
<dl><dt><a name="1">(1)</a><dd>An instance of a generic unit is declared by a generic_instantiation.
</dl><h5 align="center"><a name="syntax">Syntax</a></h5>
<pre><a name="2">(2)</a>
       generic_instantiation ::=
            package defining_program_unit_name is
                new generic_package_name [generic_actual_part];
          | procedure defining_program_unit_name is
                new generic_procedure_name [generic_actual_part];
          | function defining_designator is
                new generic_function_name [generic_actual_part];
<a name="3">(3)</a>
       generic_actual_part ::=
          (generic_association {, generic_association})
<a name="4">(4)</a>
       generic_association ::=
          [generic_formal_parameter_selector_name =&gt;] explicit_generic_actual_parameter
<a name="5">(5)</a>
       explicit_generic_actual_parameter ::= expression | variable_name
          | subprogram_name | entry_name | subtype_mark
          | package_instance_name
</pre><dl><dt><a name="6">(6)</a><dd><ul><li>A generic_association is named or positional according to whether or
not the generic_formal_parameter_selector_name is specified.  Any
positional associations shall precede any named associations.
</ul><dt><a name="7">(7)</a><dd>The generic actual parameter is either the explicit_generic_actual_parameter given in a generic_parameter_association for each formal, or the
corresponding default_expression or default_name if no generic_parameter_association is given for the formal.  When the meaning is clear from context,
the term ``generic actual,'' or simply ``actual,'' is used as a synonym for
``generic actual parameter'' and also for the view denoted by one, or the
value of one.
</dl><h5 align="center">Legality Rules</h5>
<dl><dt><a name="8">(8)</a><dd>In a generic_instantiation for a particular kind of program unit
(package, procedure, or function), the name shall denote a generic unit of
the corresponding kind (generic package, generic procedure, or generic
function, respectively).
<dt><a name="9">(9)</a><dd>The generic_formal_parameter_selector_name of a generic_association shall
denote a generic_formal_parameter_declaration of the generic unit being
instantiated.  If two or more formal subprograms have the same defining name,
then named associations are not allowed for the corresponding actuals.
<dt><a name="10">(10)</a><dd>A generic_instantiation shall contain at most one generic_association
for each formal.  Each formal without an association shall have a default_expression or subprogram_default.
<dt><a name="11">(11)</a><dd>In a generic unit Legality Rules are enforced at compile time of the
generic_declaration and generic body, given the properties of the formals.
In the visible part and formal part of an instance, Legality Rules are
enforced at compile time of the generic_instantiation, given the properties
of the actuals.  In other parts of an instance, Legality Rules are not
enforced; this rule does not apply when a given rule explicitly specifies
otherwise.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="12">(12)</a><dd>A generic_instantiation declares an instance; it is equivalent to the
instance declaration (a package_declaration or subprogram_declaration)
immediately followed by the instance body, both at the place of the
instantiation.
<dt><a name="13">(13)</a><dd>The instance is a copy of the text of the template.  Each use of a
formal parameter becomes (in the copy) a use of the actual, as explained
below.  An instance of a generic package is a package, that of a generic
procedure is a procedure, and that of a generic function is a function.
<dt><a name="14">(14)</a><dd>The interpretation of each construct within a generic declaration or
body is determined using the overloading rules when that generic declaration
or body is compiled.  In an instance, the interpretation of each (copied)
construct is the same, except in the case of a name that denotes the generic_declaration or some declaration within the generic unit; the corresponding
name in the instance then denotes the corresponding copy of the denoted
declaration.  The overloading rules do not apply in the instance.
<dt><a name="15">(15)</a><dd>In an instance, a generic_formal_parameter_declaration declares a view
whose properties are identical to those of the actual, except as specified in
12.4, ``Formal Objects'' and <a href="12-06.htm">12.6</a>, ``Formal Subprograms''.  Similarly, for a
declaration within a generic_formal_parameter_declaration, the corresponding
declaration in an instance declares a view whose properties are identical to
the corresponding declaration within the declaration of the actual.
<dt><a name="16">(16)</a><dd>Implicit declarations are also copied, and a name that denotes an
implicit declaration in the generic denotes the corresponding copy in the
instance.  However, for a type declared within the visible part of the
generic, a whole new set of primitive subprograms is implicitly declared for
use outside the instance, and may differ from the copied set if the
properties of the type in some way depend on the properties of some actual
type specified in the instantiation.  For example, if the type in the generic
is derived from a formal private type, then in the instance the type will
inherit subprograms from the corresponding actual type.
<dt><a name="17">(17)</a><dd>These new implicit declarations occur immediately after the type
declaration in the instance, and override the copied ones.  The copied ones
can be called only from within the instance; the new ones can be called only
from outside the instance, although for tagged types, the body of a new one
can be executed by a call to an old one.
<dt><a name="18">(18)</a><dd>In the visible part of an instance, an explicit declaration overrides an
implicit declaration if they are homographs, as described <a href="08-03.htm">in 8.3</a>.  On the
other hand, an explicit declaration in the private part of an instance
overrides an implicit declaration in the instance, only if the corresponding
explicit declaration in the generic overrides a corresponding implicit
declaration in the generic.  Corresponding rules apply to the other kinds of
overriding described <a href="08-03.htm">in 8.3</a>.
</dl><h5 align="center">Post-Compilation Rules</h5>
<dl><dt><a name="19">(19)</a><dd>Recursive generic instantiation is not allowed in the following sense:
if a given generic unit includes an instantiation of a second generic unit,
then the instance generated by this instantiation shall not include an
instance of the first generic unit (whether this instance is generated
directly, or indirectly by intermediate instantiations).
</dl><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="20">(20)</a><dd>For the elaboration of a generic_instantiation, each generic_association
is first evaluated.  If a default is used, an implicit generic_association is
assumed for this rule.  These evaluations are done in an arbitrary order,
except that the evaluation for a default actual takes place after the
evaluation for another actual if the default includes a name that denotes the
other one.  Finally, the instance declaration and body are elaborated.
<dt><a name="21">(21)</a><dd>For the evaluation of a generic_association the generic actual parameter
is evaluated.  Additional actions are performed in the case of a formal
object of mode in <a href="12-04.htm">(see 12.4)</a>.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="22">(22)</a><dd><ul>(5) If a formal type is not tagged, then the type is treated as an
untagged type within the generic body.  Deriving from such a type in a
generic body is permitted; the new type does not get a new tag value,
even if the actual is tagged.  Overriding operations for such a derived
type cannot be dispatched to from outside the instance.
</ul></dl><h5 align="center">Examples</h5>
<dl><dt><a name="23">(23)</a><dd><em>Examples of generic instantiations <a href="12-01.htm">(see 12.1)</a>:
</em>
</dl><pre><a name="24">(24)</a>
       procedure Swap is new Exchange(Elem =&gt; Integer);
       procedure Swap is new Exchange(Character);  <em>--  Swap is overloaded</em>
       function Square is new Squaring(Integer);   <em>--  "*" of Integer used by default</em>
       function Square is new Squaring(Item =&gt; Matrix, "*" =&gt; Matrix_Product);
       function Square is new Squaring(Matrix, Matrix_Product); <em>-- same as previous</em>
<a name="25">(25)</a>
       package Int_Vectors is new On_Vectors(Integer, Table, "+");
</pre><dl><dt><a name="26">(26)</a><dd><em>Examples of uses of instantiated units:
</em>
</dl><pre><a name="27">(27)</a>
       Swap(A, B);
       A := Square(A);
<a name="28">(28)</a>
       T : Table(1 .. 5) := (10, 20, 30, 40, 50);
       N : Integer := Int_Vectors.Sigma(T);  <em>--  150 <a href="12-02.htm">(see 12.2</a>, ``Generic Bodies''for the body of Sigma)</em>
<a name="29">(29)</a>
       use Int_Vectors;
       M : Integer := Sigma(T);  <em>--  150</em>
</pre><p>
<hr>
<h4><a href="12-02.htm"><img src="left.gif" alt="Prev"></a> | <a href="12.htm"><img src="up.gif" alt="Up"></a> | <a href="12-04.htm"><img src="right.gif" alt="Next"></a> | <a href="12-02.htm"><img src="back.gif" alt="Back"></a> | <a href="12-04.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
