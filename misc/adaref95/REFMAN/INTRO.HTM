<html>
<head><title> Ada 95 RM - Introduction </title></head>
<body>
<h1>Ada 95 Reference Manual</h1>
<h2>Introduction</h2>
<ul>
<li> <a href=#goals>Design Goals</a>
<li> <a href=#summary>Language Summary</a>
<li> <a href=#changes>Language Changes</a>
<li> <a href=#comments>Instructions for Comment Submission</a>
<li> <a href=#acks>Acknowledgments</a>
</ul>
<p>
<hr>
<dl>
<dt><a name=1>(1)</a><dd>This is the Ada Reference Manual.
<dt><a name=2>(2)</a><dd>Other available Ada documents include:
<dt><a name=3>(3)</a><dd><ul><li>Rationale for the Ada Programming Language -- 1995 edition, which
gives an introduction to the new features of Ada, and explains
the rationale behind them.  Programmers should read this first.
</ul><dt><a name=4>(4)</a><dd><ul><li>Changes to Ada -- 1987 to 1995.  This document lists in detail
the changes made to the 1987 edition of the standard.
</ul><dt><a name=5>(5)</a><dd><ul><li>The Annotated Ada Reference Manual (AARM).  The AARM contains all
of the text in the RM95, plus various annotations.  It is
intended primarily for compiler writers, validation test writers,
and others who wish to study the fine details.  The annotations
include detailed rationale for individual rules and explanations
of some of the more arcane interactions among the rules.
</ul></dl>
<h3> <a name=goals>Design Goals</a> </h3>
<dl>
<dt><a name=6>(6)</a><dd>Ada was originally designed with three overriding concerns:  program
reliability and maintenance, programming as a human activity, and efficiency.
This revision to the language was designed to provide greater flexibility and
extensibility, additional control over storage management and synchroniza-
tion, and standardized packages oriented toward supporting important
application areas, while at the same time retaining the original emphasis on
reliability, maintainability, and efficiency.
<dt><a name=7>(7)</a><dd>The need for languages that promote reliability and simplify maintenance
is well established.  Hence emphasis was placed on program readability over
ease of writing.  For example, the rules of the language require that program
variables be explicitly declared and that their type be specified.  Since the
type of a variable is invariant, compilers can ensure that operations on
variables are compatible with the properties intended for objects of the
type.  Furthermore, error-prone notations have been avoided, and the syntax
of the language avoids the use of encoded forms in favor of more English-like
constructs.  Finally, the language offers support for separate compilation of
program units in a way that facilitates program development and maintenance,
and which provides the same degree of checking between units as within a
unit.
<dt><a name=8>(8)</a><dd>Concern for the human programmer was also stressed during the design.
Above all, an attempt was made to keep to a relatively small number of
underlying concepts integrated in a consistent and systematic way while
continuing to avoid the pitfalls of excessive involution.  The design
especially aims to provide language constructs that correspond intuitively to
the normal expectations of users.
<dt><a name=9>(9)</a><dd>Like many other human activities, the development of programs is becoming
ever more decentralized and distributed.  Consequently, the ability to
assemble a program from independently produced software components continues
to be a central idea in the design.  The concepts of packages, of private
types, and of generic units are directly related to this idea, which has
ramifications in many other aspects of the language.  An allied concern is
the maintenance of programs to match changing requirements; type extension
and the hierarchical library enable a program to be modified while minimizing
disturbance to existing tested and trusted components.
<dt><a name=10>(10)</a><dd>No language can avoid the problem of efficiency.  Languages that require
over-elaborate compilers, or that lead to the inefficient use of storage or
execution time, force these inefficiencies on all machines and on all
programs.  Every construct of the language was examined in the light of
present implementation techniques.  Any proposed construct whose
implementation was unclear or that required excessive machine resources was
rejected.
</dl>
<h3> <a name=summary>Language Summary</a> </h3>
<dl>
<dt><a name=11>(11)</a><dd>An Ada program is composed of one or more program units.  Program units
may be subprograms (which define executable algorithms), packages (which
define collections of entities), task units (which define concurrent
computations), protected units (which define operations for the coordinated
sharing of data between tasks), or generic units (which define parameterized
forms of packages and subprograms).  Each program unit normally consists of
two parts:  a specification, containing the information that must be visible
to other units, and a body, containing the implementation details, which need
not be visible to other units.  Most program units can be compiled
separately.
<dt><a name=12>(12)</a><dd>This distinction of the specification and body, and the ability to
compile units separately, allows a program to be designed, written, and
tested as a set of largely independent software components.
<dt><a name=13>(13)</a><dd>An Ada program will normally make use of a library of program units of
general utility.  The language provides means whereby individual
organizations can construct their own libraries.  All libraries are
structured in a hierarchical manner; this enables the logical decomposition
of a subsystem into individual components.  The text of a separately compiled
program unit must name the library units it requires.
<dt><a name=14>(14)</a><dd>Program Units
<dt><a name=15>(15)</a><dd>A subprogram is the basic unit for expressing an algorithm.  There are
two kinds of subprograms: procedures and functions.  A procedure is the means
of invoking a series of actions.  For example, it may read data, update
variables, or produce some output.  It may have parameters, to provide a
controlled means of passing information between the procedure and the point
of call.  A function is the means of invoking the computation of a value.  It
is similar to a procedure, but in addition will return a result.
<dt><a name=16>(16)</a><dd>A package is the basic unit for defining a collection of logically
related entities.  For example, a package can be used to define a set of type
declarations and associated operations.  Portions of a package can be hidden
from the user, thus allowing access only to the logical properties expressed
by the package specification.
<dt><a name=17>(17)</a><dd>Subprogram and package units may be compiled separately and arranged in
hierarchies of parent and child units giving fine control over visibility of
the logical properties and their detailed implementation.
<dt><a name=18>(18)</a><dd>A task unit is the basic unit for defining a task whose sequence of
actions may be executed concurrently with those of other tasks.  Such tasks
may be implemented on multicomputers, multiprocessors, or with interleaved
execution on a single processor.  A task unit may define either a single
executing task or a task type permitting the creation of any number of
similar tasks.
<dt><a name=19>(19)</a><dd>A protected unit is the basic unit for defining protected operations for
the coordinated use of data shared between tasks.  Simple mutual exclusion is
provided automatically, and more elaborate sharing protocols can be defined.
A protected operation can either be a subprogram or an entry.  A protected
entry specifies a Boolean expression (an entry barrier) that must be true
before the body of the entry is executed.  A protected unit may define a
single protected object or a protected type permitting the creation of
several similar objects.
<dt><a name=20>(20)</a><dd>Declarations and Statements
<dt><a name=21>(21)</a><dd>The body of a program unit generally contains two parts: a declarative
part, which defines the logical entities to be used in the program unit, and
a sequence of statements, which defines the execution of the program unit.
<dt><a name=22>(22)</a><dd>The declarative part associates names with declared entities.  For
example, a name may denote a type, a constant, a variable, or an exception.
A declarative part also introduces the names and parameters of other nested
subprograms, packages, task units, protected units, and generic units to be
used in the program unit.
<dt><a name=23>(23)</a><dd>The sequence of statements describes a sequence of actions that are to
be performed.  The statements are executed in succession (unless a transfer
of control causes execution to continue from another place).
<dt><a name=24>(24)</a><dd>An assignment statement changes the value of a variable.  A procedure
call invokes execution of a procedure after associating any actual parameters
provided at the call with the corresponding formal parameters.
<dt><a name=25>(25)</a><dd>Case statements and if statements allow the selection of an enclosed
sequence of statements based on the value of an expression or on the value of
a condition.
<dt><a name=26>(26)</a><dd>The loop statement provides the basic iterative mechanism in the
language.  A loop statement specifies that a sequence of statements is to be
executed repeatedly as directed by an iteration scheme, or until an exit
statement is encountered.
<dt><a name=27>(27)</a><dd>A block statement comprises a sequence of statements preceded by the
declaration of local entities used by the statements.
<dt><a name=28>(28)</a><dd>Certain statements are associated with concurrent execution.  A delay
statement delays the execution of a task for a specified duration or until a
specified time.  An entry call statement is written as a procedure call
statement; it requests an operation on a task or on a protected object,
blocking the caller until the operation can be performed.  A called task may
accept an entry call by executing a corresponding accept statement, which
specifies the actions then to be performed as part of the rendezvous with the
calling task.  An entry call on a protected object is processed when the
corresponding entry barrier evaluates to true, whereupon the body of the
entry is executed.  The requeue statement permits the provision of a service
as a number of related activities with preference control.  One form of the
select statement allows a selective wait for one of several alternative
rendezvous.  Other forms of the select statement allow conditional or timed
entry calls and the asynchronous transfer of control in response to some
triggering event.
<dt><a name=29>(29)</a><dd>Execution of a program unit may encounter error situations in which
normal program execution cannot continue.  For example, an arithmetic
computation may exceed the maximum allowed value of a number, or an attempt
may be made to access an array component by using an incorrect index value.
To deal with such error situations, the statements of a program unit can be
textually followed by exception handlers that specify the actions to be taken
when the error situation arises.  Exceptions can be raised explicitly by a
raise statement.
<dt><a name=30>(30)</a><dd>Data Types
<dt><a name=31>(31)</a><dd>Every object in the language has a type, which characterizes a set of
values and a set of applicable operations.  The main classes of types are
elementary types (comprising enumeration, numeric, and access types) and
composite types (including array and record types).
<dt><a name=32>(32)</a><dd>An enumeration type defines an ordered set of distinct enumeration
literals, for example a list of states or an alphabet of characters.  The
enumeration types Boolean, Character, and Wide_Character are predefined.
<dt><a name=33>(33)</a><dd>Numeric types provide a means of performing exact or approximate
numerical computations.  Exact computations use integer types, which denote
sets of consecutive integers.  Approximate computations use either fixed
point types, with absolute bounds on the error, or floating point types, with
relative bounds on the error.  The numeric types Integer, Float, and Duration
are predefined.
<dt><a name=34>(34)</a><dd>Composite types allow definitions of structured objects with related
components.  The composite types in the language include arrays and records.
An array is an object with indexed components of the same type.  A record is
an object with named components of possibly different types.  Task and
protected types are also forms of composite types.  The array types String
and Wide_String are predefined.
<dt><a name=35>(35)</a><dd>Record, task, and protected types may have special components called
discriminants which parameterize the type.  Variant record structures that
depend on the values of discriminants can be defined within a record type.
<dt><a name=36>(36)</a><dd>Access types allow the construction of linked data structures.  A value
of an access type represents a reference to an object declared as aliased or
to an object created by the evaluation of an allocator.  Several variables of
an access type may designate the same object, and components of one object
may designate the same or other objects.  Both the elements in such linked
data structures and their relation to other elements can be altered during
program execution.  Access types also permit references to subprograms to be
stored, passed as parameters, and ultimately dereferenced as part of an
indirect call.
<dt><a name=37>(37)</a><dd>Private types permit restricted views of a type.  A private type can be
defined in a package so that only the logically necessary properties are made
visible to the users of the type.  The full structural details that are
externally irrelevant are then only available within the package and any
child units.
<dt><a name=38>(38)</a><dd>From any type a new type may be defined by derivation.  A type, together
with its derivatives (both direct and indirect) form a derivation class.
Class-wide operations may be defined that accept as a parameter an operand of
any type in a derivation class.  For record and private types, the
derivatives may be extensions of the parent type.  Types that support these
object-oriented capabilities of class-wide operations and type extension must
be tagged, so that the specific type of an operand within a derivation class
can be identified at run time.  When an operation of a tagged type is applied
to an operand whose specific type is not known until run time, implicit
dispatching is performed based on the tag of the operand.
<dt><a name=39>(39)</a><dd>The concept of a type is further refined by the concept of a subtype,
whereby a user can constrain the set of allowed values of a type.  Subtypes
can be used to define subranges of scalar types, arrays with a limited set of
index values, and records and private types with particular discriminant
values.
<dt><a name=40>(40)</a><dd>Other Facilities
<dt><a name=41>(41)</a><dd>Representation clauses can be used to specify the mapping between types
and features of an underlying machine.  For example, the user can specify
that objects of a given type must be represented with a given number of bits,
or that the components of a record are to be represented using a given
storage layout.  Other features allow the controlled use of low level,
nonportable, or implementation-dependent aspects, including the direct
insertion of machine code.
<dt><a name=42>(42)</a><dd>The predefined environment of the language provides for input-output and
other capabilities (such as string manipulation and random number generation)
by means of standard library packages.  Input-output is supported for values
of user-defined as well as of predefined types.  Standard means of
representing values in display form are also provided.  Other standard
library packages are defined in annexes of the standard to support systems
with specialized requirements.
<dt><a name=43>(43)</a><dd>Finally, the language provides a powerful means of parameterization of
program units, called generic program units.  The generic parameters can be
types and subprograms (as well as objects and packages) and so allow general
algorithms and data structures to be defined that are applicable to all types
of a given class.
</dl>
<h3> <a name=changes>Language Changes</a> </h3>
<dl>
<dt><a name=44>(44)</a><dd>This International Standard replaces the first edition of 1987.  In this
edition, the following major language changes have been incorporated:
<dt><a name=45>(45)</a><dd><ul><li>Support for standard 8-bit and 16-bit character sets.  See
<a href=02.htm>Section 2</a>, <a href=03-05-02.htm>3.5.2</a>, <a href=03-06-03.htm>3.6.3</a>, <a href=A-01.htm>A.1</a>, <a href=A-03.htm>A.3</a>, and <a href=A-04.htm>A.4</a>.
</ul><dt><a name=46>(46)</a><dd><ul><li>Object-oriented programming with run-time polymorphism.  See the
discussions of classes, derived types, tagged types, record
extensions, and private extensions in clauses <a href=03-04.htm>3.4</a>, <a href=03-09.htm>3.9</a>, and <a href=07-03.htm>7.3</a>.
See also the new forms of generic formal parameters that are
allowed by <a href=12-05-01.htm>12.5.1</a>, ``Formal Private and Derived Types'' and <a href=12-07.htm>12.7</a>,
``Formal Packages''.
</ul><dt><a name=47>(47)</a><dd><ul><li>Access types have been extended to allow an access value to
designate a subprogram or an object declared by an object
declaration (as opposed to just a heap-allocated object).  See
<a href=03-10.htm>3.10</a>.
</ul><dt><a name=48>(48)</a><dd><ul><li>Efficient data-oriented synchronization is provided via protected
types.  See <a href=09.htm>Section 9</a>.
</ul><dt><a name=49>(49)</a><dd><ul><li>The library units of a library may be organized into a hierarchy
of parent and child units.  See <a href=10.htm>Section 10</a>.
</ul><dt><a name=50>(50)</a><dd><ul><li>Additional support has been added for interfacing to other
languages.  See <a href=B.htm>Annex B</a>.
</ul><dt><a name=51>(51)</a><dd><ul><li>The Specialized Needs Annexes have been added to provide specific
support for certain application areas:
</ul><dt><a name=52>(52)</a><dd><ul><ul><li><a href=C.htm>Annex C</a>, ``Systems Programming''
</ul></ul><dt><a name=53>(53)</a><dd><ul><ul><li><a href=D.htm>Annex D</a>, ``Real-Time Systems''
</ul></ul><dt><a name=54>(54)</a><dd><ul><ul><li><a href=E.htm>Annex E</a>, ``Distributed Systems''
</ul></ul><dt><a name=55>(55)</a><dd><ul><ul><li><a href=F.htm>Annex F</a>, ``Information Systems''
</ul></ul><dt><a name=56>(56)</a><dd><ul><ul><li><a href=G.htm>Annex G</a>, ``Numerics''
</ul></ul><dt><a name=57>(57)</a><dd><ul><ul><li><a href=H.htm>Annex H</a>, ``Safety and Security''
</ul></ul></dl>
<h3> <a name=comments>Instructions for Comment Submission</a> </h3>
<dl>
<dt><a name=58>(58)</a><dd>Informal comments on this International Standard may be sent via e-mail
to ada-comment@sw-eng.falls-church.va.us.  If appropriate, the Project Editor
will initiate the defect correction procedure.
<dt><a name=59>(59)</a><dd>Comments should use the following format:
</dl><pre><a name=60>(60)</a>
          !topic Title summarizing comment
          !reference RM95-ss.ss(pp)
          !from Author Name yy-mm-dd
          !keywords keywords related to topic
          !discussion

          text of discussion
</pre><dl><dt><a name=61>(61)</a><dd>where ss.ss is the section, clause or subclause number, pp is the
paragraph number where applicable, and yy-mm-dd is the date the comment was
sent.  The date is optional, as is the !keywords line.
<dt><a name=62>(62)</a><dd>Multiple comments per e-mail message are acceptable.  Please use a
descriptive ``Subject'' in your e-mail message.
<dt><a name=63>(63)</a><dd>When correcting typographical errors or making minor wording
suggestions, please put the correction directly as the topic of the comment;
use square brackets [ ] to indicate text to be omitted and curly braces { }
to indicate text to be added, and provide enough context to make the nature
of the suggestion self-evident or put additional information in the body of
the comment, for example:
</dl><pre><a name=64>(64)</a>
          !topic [c]{C}haracter
          !topic it[']s meaning is not defined
</pre><dl><dt><a name=65>(65)</a><dd>Formal requests for interpretations and for reporting defects in this
International Standard may be made in accordance with the ISO/IEC JTC1
Directives and the ISO/IEC JTC1/SC22 policy for interpretations.  National
Bodies may submit a Defect Report to ISO/IEC JTC1/SC22 for resolution under
the JTC1 procedures.  A response will be provided and, if appropriate, a
Technical Corrigendum will be issued in accordance with the procedures.
</dl>
<h3> <a name=acks>Acknowledgements</a> </h3>
<dl>
<dt><a name=66>(66)</a><dd>This International Standard was prepared by the Ada 9X Mapping/Revision
Team based at Intermetrics, Inc., which has included:  W. Carlson, Program
Manager; T. Taft, Technical Director; J. Barnes (consultant); B. Brosgol
(consultant); R. Duff (Oak Tree Software); M. Edwards; C. Garrity;
R. Hilliard; O. Pazy (consultant); D. Rosenfeld; L. Shafer; W. White;
M. Woodger.
<dt><a name=67>(67)</a><dd>The following consultants to the Ada 9X Project contributed to the
Specialized Needs Annexes:  T. Baker (Real-Time/Systems Programming -- SEI,
FSU); K. Dritz (Numerics -- Argonne National Laboratory); A. Gargaro
(Distributed Systems -- Computer Sciences); J. Goodenough (Real-Time/Systems
Programming -- SEI); J. McHugh (Secure Systems -- consultant); B. Wichmann
(Safety-Critical Systems -- NPL: UK).
<dt><a name=68>(68)</a><dd>This work was regularly reviewed by the Ada 9X Distinguished Reviewers
and the members of the Ada 9X Rapporteur Group (XRG):  E. Ploedereder,
Chairman of DRs and XRG (University of Stuttgart: Germany); B. Bardin
(Hughes); J. Barnes (consultant: UK); B. Brett (DEC); B. Brosgol
(consultant); R. Brukardt (RR Software); N. Cohen (IBM); R. Dewar (NYU);
G. Dismukes (TeleSoft); A. Evans (consultant); A. Gargaro (Computer
Sciences); M. Gerhardt (ESL); J. Goodenough (SEI); S. Heilbrunner (University
of Salzburg: Austria); P. Hilfinger (UC/Berkeley); B. Kaellberg (CelsiusTech:
Sweden); M. Kamrad II (Unisys); J. van Katwijk (Delft University of
Technology: The Netherlands); V. Kaufman (Russia); P. Kruchten (Rational);
R. Landwehr (CCI: Germany); C. Lester (Portsmouth Polytechnic: UK);
L. Mansson (TELIA Research: Sweden); S. Michell (Multiprocessor Toolsmiths:
Canada); M. Mills (US Air Force); D. Pogge (US Navy); K. Power (Boeing);
O. Roubine (Verdix: France); A. Strohmeier (Swiss Fed Inst of Technology:
Switzerland); W. Taylor (consultant: UK); J. Tokar (Tartan); E. Vasilescu
(Grumman); J. Vladik (Prospeks s.r.o.:  Czech Republic); S. Van Vlierberghe
(OFFIS: Belgium).
<dt><a name=69>(69)</a><dd>Other valuable feedback influencing the revision process was provided by
the Ada 9X Language Precision Team (Odyssey Research Associates), the Ada 9X
User/Implementer Teams (AETECH, Tartan, TeleSoft), the Ada 9X Implementation
Analysis Team (New York University) and the Ada community-at-large.
<dt><a name=70>(70)</a><dd>Special thanks go to R. Mathis, Convenor of ISO/IEC JTC1/SC22 Working
Group 9.
<dt><a name=71>(71)</a><dd>The Ada 9X Project was sponsored by the Ada Joint Program Office.
Christine M. Anderson at the Air Force Phillips Laboratory (Kirtland AFB, NM)
was the project manager.
Changes
<dt><a name=72>(72)</a><dd>The International Standard is the same as this version of the Reference
Manual, except:
<dt><a name=73>(73)</a><dd><ul><li>This list of Changes is not included in the International
Standard.
</ul><dt><a name=74>(74)</a><dd><ul><li>The ``Acknowledgements'' page is not included in the
International Standard.
</ul><dt><a name=75>(75)</a><dd><ul><li>The text in the running headers and footers on each page is
slightly different in the International Standard.
</ul><dt><a name=76>(76)</a><dd><ul><li>The title page(s) are different in the International Standard.
</ul><dt><a name=77>(77)</a><dd><ul><li>This document is formatted for 8.5-by-11-inch paper, whereas the
International Standard is formatted for A4 paper (210-by-297mm);
thus, the page breaks are in different places.
</ul></dl><hr>
<h4>   <a href=toc.htm>TOC --</a> / <a href=toc-l1.htm>--.--</a> / <a href=toc-l2.htm>--.--.--</a> | <a href=index.htm>Index</a> | <a href=search.htm>Search</a> | <a href=syntax.htm>Syntax</a> | <a href=help.htm>Help</a></h4>

<p>
<a href=http://lglwww.epfl.ch/Ada/><img src=la-icon.gif alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href=author.htm>Magnus Kempe</a>
 -- <a href=mailto:Magnus.Kempe@di.epfl.ch>Magnus.Kempe@di.epfl.ch</a><br>
<a href=cright.htm>Copyright statement</a><br>
Page last generated: 95-03-12
</address>

</body>
</html>
