<html>
<head>
<title>Ada 95 RM - 13.3 Representation Attributes</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="13-02.htm"><img src="left.gif" alt="Prev"></a> | <a href="13.htm"><img src="up.gif" alt="Up"></a> | <a href="13-04.htm"><img src="right.gif" alt="Next"></a> | <a href="13-02.htm"><img src="back.gif" alt="Back"></a> | <a href="13-04.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>

<h2><a name="0">13.3 Representation Attributes</a></h2>
<dl><dt><a name="1">(1)</a><dd>The values of certain implementation-dependent characteristics can be
obtained by interrogating appropriate representation attributes.  Some of
these attributes are specifiable via an attribute_definition_clause.
</dl><h5 align="center"><a name="syntax">Syntax</a></h5>
<pre><a name="2">(2)</a>
       attribute_definition_clause ::=
             for local_name'attribute_designator use expression;
           | for local_name'attribute_designator use name;
</pre><h5 align="center">Name Resolution Rules</h5>
<dl><dt><a name="3">(3)</a><dd>For an attribute_definition_clause that specifies an attribute that
denotes a value, the form with an expression shall be used.  Otherwise, the
form with a name shall be used.
<dt><a name="4">(4)</a><dd>For an attribute_definition_clause that specifies an attribute that
denotes a value or an object, the expected type for the expression or name is
that of the attribute.  For an attribute_definition_clause that specifies an
attribute that denotes a subprogram, the expected profile for the name is the
profile required for the attribute.  For an attribute_definition_clause that
specifies an attribute that denotes some other kind of entity, the name shall
resolve to denote an entity of the appropriate kind.
</dl><h5 align="center">Legality Rules</h5>
<dl><dt><a name="5">(5)</a><dd>An attribute_designator is allowed in an attribute_definition_clause only
if this International Standard explicitly allows it, or for an
implementation-defined attribute if the implementation allows it.  Each
specifiable attribute constitutes an aspect of representation.
<dt><a name="6">(6)</a><dd>For an attribute_definition_clause that specifies an attribute that
denotes a subprogram, the profile shall be mode conformant with the one
required for the attribute, and the convention shall be Ada.  Additional
requirements are defined for particular attributes.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="7">(7)</a><dd>A Size clause is an attribute_definition_clause whose attribute_designator is Size.  Similar definitions apply to the other specifiable
attributes.
<dt><a name="8">(8)</a><dd>A storage element is an addressable element of storage in the machine.  A
word is the largest amount of storage that can be conveniently and
efficiently manipulated by the hardware, given the implementation's run-time
model.  A word consists of an integral number of storage elements.
<dt><a name="9">(9)</a><dd>The following attributes are defined:
<dt><a name="10">(10)</a><dd>For a prefix X that denotes an object, program unit, or label:
<dt><a name="11">(11)</a><dd>X'Address
<ul>Denotes the address of the first of the storage elements
allocated to X. For a program unit or label, this value
refers to the machine code associated with the corresponding
body or statement.  The value of this attribute is of type
System.Address.
</ul><dt><a name="12">(12)</a><dd><ul>Address may be specified for stand-alone objects and for
program units via an attribute_definition_clause.
</ul></dl><h5 align="center">Erroneous Execution</h5>
<dl><dt><a name="13">(13)</a><dd>If an Address is specified, it is the programmer's responsibility to
ensure that the address is valid; otherwise, program execution is erroneous.
</dl><h5 align="center">Implementation Advice</h5>
<dl><dt><a name="14">(14)</a><dd>For an array X, X'Address should point at the first component of the
array, and not at the array bounds.
<dt><a name="15">(15)</a><dd>The recommended level of support for the Address attribute is:
<dt><a name="16">(16)</a><dd><ul><li>X'Address should produce a useful result if X is an object that
is aliased or of a by-reference type, or is an entity whose
Address has been specified.
</ul><dt><a name="17">(17)</a><dd><ul><li>An implementation should support Address clauses for imported
subprograms.
</ul><dt><a name="18">(18)</a><dd><ul><li>Objects (including subcomponents) that are aliased or of a
by-reference type should be allocated on storage element
boundaries.
</ul><dt><a name="19">(19)</a><dd><ul><li>If the Address of an object is specified, or it is imported or
exported, then the implementation should not perform optimizations based on assumptions of no aliases.
</ul><p><dt><dd><ul>NOTES</ul>
<dt><a name="20">(20)</a><dd><ul>(1) The specification of a link name in a pragma Export <a href="B-01.htm">(see B.1)</a> for a
subprogram or object is an alternative to explicit specification of its
link-time address, allowing a link-time directive to place the
subprogram or object within memory.
</ul><dt><a name="21">(21)</a><dd><ul>(2) The rules for the Size attribute imply, for an aliased object X,
that if X'Size = Storage_Unit, then X'Address points at a storage
element containing all of the bits of X, and only the bits of X.
</ul></dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="22">(22)</a><dd>For a prefix X that denotes a subtype or object:
<dt><a name="23">(23)</a><dd>X'Alignment
<ul>The Address of an object that is allocated under control of
the implementation is an integral multiple of the Alignment
of the object (that is, the Address modulo the Alignment is
zero).  The offset of a record component is a multiple of the
Alignment of the component.  For an object that is not
allocated under control of the implementation (that is, one
that is imported, that is allocated by a user-defined
allocator, whose Address has been specified, or is designated
by an access value returned by an instance of Unchecked_Conversion), the implementation may assume that the Address
is an integral multiple of its Alignment.  The implementation
shall not assume a stricter alignment.
</ul><dt><a name="24">(24)</a><dd><ul>The value of this attribute is of type universal_integer, and nonnegative; zero means that the object is not
necessarily aligned on a storage element boundary.
</ul><dt><a name="25">(25)</a><dd><ul>Alignment may be specified for first subtypes and
stand-alone objects via an attribute_definition_clause; the
expression of such a clause shall be static, and its value
nonnegative.  If the Alignment of a subtype is specified,
then the Alignment of an object of the subtype is at least as
strict, unless the object's Alignment is also specified.  The
Alignment of an object created by an allocator is that of the
designated subtype.
</ul><dt><a name="26">(26)</a><dd><ul>If an Alignment is specified for a composite subtype or
object, this Alignment shall be equal to the least common
multiple of any specified Alignments of the subcomponent
subtypes, or an integer multiple thereof.
</ul></dl><h5 align="center">Erroneous Execution</h5>
<dl><dt><a name="27">(27)</a><dd>Program execution is erroneous if an Address clause is given that
conflicts with the Alignment.
<dt><a name="28">(28)</a><dd>If the Alignment is specified for an object that is not allocated under
control of the implementation, execution is erroneous if the object is not
aligned according to the Alignment.
</dl><h5 align="center">Implementation Advice</h5>
<dl><dt><a name="29">(29)</a><dd>The recommended level of support for the Alignment attribute for
subtypes is:
<dt><a name="30">(30)</a><dd><ul><li>An implementation should support specified Alignments that are
factors and multiples of the number of storage elements per word,
subject to the following:
</ul><dt><a name="31">(31)</a><dd><ul><li>An implementation need not support specified Alignments for
combinations of Sizes and Alignments that cannot be easily loaded
and stored by available machine instructions.
</ul><dt><a name="32">(32)</a><dd><ul><li>An implementation need not support specified Alignments that are
greater than the maximum Alignment the implementation ever
returns by default.
</ul><dt><a name="33">(33)</a><dd>The recommended level of support for the Alignment attribute for objects
is:
<dt><a name="34">(34)</a><dd><ul><li>Same as above, for subtypes, but in addition:
</ul><dt><a name="35">(35)</a><dd><ul><li>For stand-alone library-level objects of statically constrained
subtypes, the implementation should support all Alignments
supported by the target linker.  For example, page alignment is
likely to be supported for such objects, but not for subtypes.
</ul><p><dt><dd><ul>NOTES</ul>
<dt><a name="36">(36)</a><dd><ul>(3) Alignment is a subtype-specific attribute.
</ul><dt><a name="37">(37)</a><dd><ul>(4) The Alignment of a composite object is always equal to the least
common multiple of the Alignments of its components, or a multiple
thereof.
</ul><dt><a name="38">(38)</a><dd><ul>(5) A component_clause, Component_Size clause, or a pragma Pack can
override a specified Alignment.
</ul></dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="39">(39)</a><dd>For a prefix X that denotes an object:
<dt><a name="40">(40)</a><dd>X'Size
<ul>Denotes the size in bits of the representation of the object.
The value of this attribute is of the type universal_integer.
</ul><dt><a name="41">(41)</a><dd><ul>Size may be specified for stand-alone objects via an
attribute_definition_clause; the expression of such a clause
shall be static and its value nonnegative.
</ul></dl><h5 align="center">Implementation Advice</h5>
<dl><dt><a name="42">(42)</a><dd>The recommended level of support for the Size attribute of objects is:
<dt><a name="43">(43)</a><dd><ul><li>A Size clause should be supported for an object if the specified
Size is at least as large as its subtype's Size, and corresponds
to a size in storage elements that is a multiple of the object's
Alignment (if the Alignment is nonzero).
</ul></dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="44">(44)</a><dd>For every subtype S:
<dt><a name="45">(45)</a><dd>S'Size
<ul>If S is definite, denotes the size (in bits) that the
implementation would choose for the following objects of
subtype S:
</ul><dt><a name="46">(46)</a><dd><ul><ul><li>A record component of subtype S when the record
type is packed.
</ul></ul><dt><a name="47">(47)</a><dd><ul><ul><li>The formal parameter of an instance of Unchecked_Conversion that converts from subtype S to some
other subtype.
</ul></ul><dt><a name="48">(48)</a><dd><ul>If S is indefinite, the meaning is implementation
defined.  The value of this attribute is of the type
universal_integer.    The Size of an object is at least as
large as that of its subtype, unless the object's Size is
determined by a Size clause, a component_clause, or a
Component_Size clause.  Size may be specified for first
subtypes via an attribute_definition_clause; the expression
of such a clause shall be static and its value nonnegative.
</ul></dl><h5 align="center">Implementation Requirements</h5>
<dl><dt><a name="49">(49)</a><dd>In an implementation, Boolean'Size shall be 1.
</dl><h5 align="center">Implementation Advice</h5>
<dl><dt><a name="50">(50)</a><dd>If the Size of a subtype is specified, and allows for efficient
independent addressability <a href="09-10.htm">(see 9.10)</a> on the target architecture, then the
Size of the following objects of the subtype should equal the Size of the
subtype:
<dt><a name="51">(51)</a><dd><ul><li>Aliased objects (including components).
</ul><dt><a name="52">(52)</a><dd><ul><li>Unaliased components, unless the Size of the component is
determined by a component_clause or Component_Size clause.
</ul><dt><a name="53">(53)</a><dd>A Size clause on a composite subtype should not affect the internal
layout of components.
<dt><a name="54">(54)</a><dd>The recommended level of support for the Size attribute of subtypes is:
<dt><a name="55">(55)</a><dd><ul><li>The Size (if not specified) of a static discrete or fixed point
subtype should be the number of bits needed to represent each
value belonging to the subtype using an unbiased representation,
leaving space for a sign bit only if the subtype contains
negative values.  If such a subtype is a first subtype, then an
implementation should support a specified Size for it that
reflects this representation.
</ul><dt><a name="56">(56)</a><dd><ul><li>For a subtype implemented with levels of indirection, the Size
should include the size of the pointers, but not the size of what
they point at.
</ul><p><dt><dd><ul>NOTES</ul>
<dt><a name="57">(57)</a><dd><ul>(6) Size is a subtype-specific attribute.
</ul><dt><a name="58">(58)</a><dd><ul>(7) A component_clause or Component_Size clause can override a specified
Size.  A pragma Pack cannot.
</ul></dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="59">(59)</a><dd>For a prefix T that denotes a task object (after any implicit
dereference):
<dt><a name="60">(60)</a><dd>T'Storage_Size
<ul>Denotes the number of storage elements reserved for the task.
The value of this attribute is of the type universal_integer.
The Storage_Size includes the size of the task's stack, if
any.  The language does not specify whether or not it
includes other storage associated with the task (such as the
``task control block'' used by some implementations.)  If a
pragma Storage_Size is given, the value of the Storage_Size
attribute is at least the value specified in the pragma.
</ul><dt><a name="61">(61)</a><dd>A pragma Storage_Size specifies the amount of storage to be reserved for
the execution of a task.
</dl><h5 align="center">Syntax</h5>
<dl><dt><a name="62">(62)</a><dd><ul>The form of a pragma Storage_Size is as follows:
</ul></dl><pre><a name="63">(63)</a>
         pragma Storage_Size(expression);
</pre><dl><dt><a name="64">(64)</a><dd><ul>A pragma Storage_Size is allowed only immediately within a task_definition.
</ul></dl><h5 align="center">Name Resolution Rules</h5>
<dl><dt><a name="65">(65)</a><dd>The expression of a pragma Storage_Size is expected to be of any integer
type.
</dl><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="66">(66)</a><dd>A pragma Storage_Size is elaborated when an object of the type defined
by the immediately enclosing task_definition is created.  For the elaboration
of a pragma Storage_Size, the expression is evaluated; the Storage_Size
attribute of the newly created task object is at least the value of the
expression.
<dt><a name="67">(67)</a><dd>At the point of task object creation, or upon task activation, Storage_Error is raised if there is insufficient free storage to accommodate the
requested Storage_Size.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="68">(68)</a><dd>For a prefix X that denotes an array subtype or array object (after any
implicit dereference):
<dt><a name="69">(69)</a><dd>X'Component_Size
<ul>Denotes the size in bits of components of the type of X. The
value of this attribute is of type universal_integer.
</ul><dt><a name="70">(70)</a><dd><ul>Component_Size may be specified for array types via an
attribute_definition_clause; the expression of such a clause
shall be static, and its value nonnegative.
</ul></dl><h5 align="center">Implementation Advice</h5>
<dl><dt><a name="71">(71)</a><dd>The recommended level of support for the Component_Size attribute is:
<dt><a name="72">(72)</a><dd><ul><li>An implementation need not support specified Component_Sizes that
are less than the Size of the component subtype.
</ul><dt><a name="73">(73)</a><dd><ul><li>An implementation should support specified Component_Sizes that
are factors and multiples of the word size.  For such Component_Sizes, the array should contain no gaps between components.  For
other Component_Sizes (if supported), the array should contain no
gaps between components when packing is also specified; the
implementation should forbid this combination in cases where it
cannot support a no-gaps representation.
</ul></dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="74">(74)</a><dd>For every subtype S of a tagged type T (specific or class-wide), the
following attribute is defined:
<dt><a name="75">(75)</a><dd>S'External_Tag
<ul>S'External_Tag denotes an external string representation for
S'Tag; it is of the predefined type String.  External_Tag may
be specified for a specific tagged type via an attribute_definition_clause; the expression of such a clause shall be
static.  The default external tag representation is
implementation defined.  <a href="03-09-02.htm">See 3.9.2</a> and <a href="13-13-02.htm">13.13.2</a>.
</ul></dl><h5 align="center">Implementation Requirements</h5>
<dl><dt><a name="76">(76)</a><dd>In an implementation, the default external tag for each specific tagged
type declared in a partition shall be distinct, so long as the type is
declared outside an instance of a generic body.  If the compilation unit in
which a given tagged type is declared, and all compilation units on which it
semantically depends, are the same in two different partitions, then the
external tag for the type shall be the same in the two partitions.  What it
means for a compilation unit to be the same in two different partitions is
implementation defined.  At a minimum, if the compilation unit is not
recompiled between building the two different partitions that include it, the
compilation unit is considered the same in the two partitions.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="77">(77)</a><dd><ul>(8) The following language-defined attributes are specifiable, at least
for some of the kinds of entities to which they apply:  Address, Size,
Component_Size, Alignment, External_Tag, Small, Bit_Order, Storage_Pool,
Storage_Size, Write, Output, Read, Input, and Machine_Radix.
</ul><dt><a name="78">(78)</a><dd><ul>(9) It follows from the general rules <a href="13-01.htm">in 13.1</a> that if one writes ``for
X'Size use Y;'' then the X'Size attribute_reference will return Y
(assuming the implementation allows the Size clause).  The same is true
for all of the specifiable attributes except Storage_Size.
</ul></dl><h5 align="center">Examples</h5>
<dl><dt><a name="79">(79)</a><dd><em>Examples of attribute definition clauses:
</em>
</dl><pre><a name="80">(80)</a>
       Byte : constant := 8;
       Page : constant := 2**12;
<a name="81">(81)</a>
       type Medium is range 0 .. 65_000;
       for Medium'Size use 2*Byte;
       for Medium'Alignment use 2;
       Device_Register : Medium;
       for Device_Register'Size use Medium'Size;
       for Device_Register'Address use System.Storage_Elements.To_Address(16#FFFF_0020#);
<a name="82">(82)</a>
       type Short is delta 0.01 range -100.0 .. 100.0;
       for Short'Size use 15;
<a name="83">(83)</a>
       for Car_Name'Storage_Size use <em>-- specify access type's storage pool size</em>
               2000*((Car'Size/System.Storage_Unit) +1); <em>-- approximately 2000 cars</em>
<a name="84">(84)</a>
       function My_Read(Stream : access Ada.Streams.Root_Stream_Type'Class)
         return T;
       for T'Read use My_Read; <em>-- <a href="13-13-02.htm">see 13.13.2</a></em>
</pre><dl><p><dt><dd><ul>NOTES</ul>
<dt><a name="85">(85)</a><dd><ul>(10) Notes on the examples:  In the Size clause for Short, fifteen bits
is the minimum necessary, since the type definition requires Short'Small
&lt;= 2**(-7).
</ul></dl><p>
<hr>
<h4><a href="13-02.htm"><img src="left.gif" alt="Prev"></a> | <a href="13.htm"><img src="up.gif" alt="Up"></a> | <a href="13-04.htm"><img src="right.gif" alt="Next"></a> | <a href="13-02.htm"><img src="back.gif" alt="Back"></a> | <a href="13-04.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
