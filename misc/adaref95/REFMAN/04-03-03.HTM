<html>
<head>
<title>Ada 95 RM - 4.3.3 Array Aggregates</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="04-03-02.htm"><img src="left.gif" alt="Prev"></a> | <a href="04-03.htm"><img src="up.gif" alt="Up"></a> | <img src="noright.gif" alt="____"> | <a href="04-03-02.htm"><img src="back.gif" alt="Back"></a> | <a href="04-04.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>
<h3><a name="0">4.3.3 Array Aggregates</a></h3>
<dl><dt><a name="1">(1)</a><dd>In an array_aggregate, a value is specified for each component of an
array, either positionally or by its index.  For a positional_array_aggregate, the components are given in increasing-index order, with a final
others, if any, representing any remaining components.  For a named_array_aggregate, the components are identified by the values covered by the
discrete_choices.
</dl><h5 align="center"><a name="syntax">Syntax</a></h5>
<pre><a name="2">(2)</a>
       array_aggregate ::=
         positional_array_aggregate | named_array_aggregate
<a name="3">(3)</a>
       positional_array_aggregate ::=
           (expression, expression {, expression})
         | (expression {, expression}, others =&gt; expression)
<a name="4">(4)</a>
       named_array_aggregate ::=
           (array_component_association {, array_component_association})
<a name="5">(5)</a>
       array_component_association ::=
           discrete_choice_list =&gt; expression
</pre><dl><dt><a name="6">(6)</a><dd>An n-dimensional array_aggregate is one that is written as n levels of
nested array_aggregates (or at the bottom level, equivalent string_literals).
For the multidimensional case (n &gt;= 2) the array_aggregates (or equivalent
string_literals) at the n-1 lower levels are called subaggregates of the
enclosing n-dimensional array_aggregate.  The expressions of the bottom level
subaggregates (or of the array_aggregate itself if one-dimensional) are
called the array component expressions of the enclosing n-dimensional array_aggregate.
</dl><h5 align="center">Name Resolution Rules</h5>
<dl><dt><a name="7">(7)</a><dd>The expected type for an array_aggregate (that is not a subaggregate)
shall be a single nonlimited array type.  The component type of this array
type is the expected type for each array component expression of the array_aggregate.
<dt><a name="8">(8)</a><dd>The expected type for each discrete_choice in any discrete_choice_list of
a named_array_aggregate is the type of the corresponding index; the
corresponding index for an array_aggregate that is not a subaggregate is the
first index of its type; for an (n-m)-dimensional subaggregate within an
array_aggregate of an n-dimensional type, the corresponding index is the
index in position m+1.
</dl><h5 align="center">Legality Rules</h5>
<dl><dt><a name="9">(9)</a><dd>An array_aggregate of an n-dimensional array type shall be written as an
n-dimensional array_aggregate.
<dt><a name="10">(10)</a><dd>An others choice is allowed for an array_aggregate only if an applicable
index constraint applies to the array_aggregate.  An applicable index
constraint is a constraint provided by certain contexts where an array_aggregate is permitted that can be used to determine the bounds of the array
value specified by the aggregate.  Each of the following contexts (and none
other) defines an applicable index constraint:
<dt><a name="11">(11)</a><dd><ul><li>For an explicit_actual_parameter, an explicit_generic_actual_parameter, the expression of a return_statement, the initialization expression in an object_declaration, or a default_expression
(for a parameter or a component), when the nominal subtype of the
corresponding formal parameter, generic formal parameter,
function result, object, or component is a constrained array
subtype, the applicable index constraint is the constraint of the
subtype;
</ul><dt><a name="12">(12)</a><dd><ul><li>For the expression of an assignment_statement where the name
denotes an array variable, the applicable index constraint is the
constraint of the array variable;
</ul><dt><a name="13">(13)</a><dd><ul><li>For the operand of a qualified_expression whose subtype_mark
denotes a constrained array subtype, the applicable index
constraint is the constraint of the subtype;
</ul><dt><a name="14">(14)</a><dd><ul><li>For a component expression in an aggregate, if the component's
nominal subtype is a constrained array subtype, the applicable
index constraint is the constraint of the subtype;
</ul><dt><a name="15">(15)</a><dd><ul><li>For a parenthesized expression, the applicable index constraint
is that, if any, defined for the expression.
</ul><dt><a name="16">(16)</a><dd>The applicable index constraint applies to an array_aggregate that
appears in such a context, as well as to any subaggregates thereof.  In the
case of an explicit_actual_parameter (or default_expression) for a call on a
generic formal subprogram, no applicable index constraint is defined.
<dt><a name="17">(17)</a><dd>The discrete_choice_list of an array_component_association is allowed to
have a discrete_choice that is a nonstatic expression or that is a discrete_range that defines a nonstatic or null range, only if it is the single
discrete_choice of its discrete_choice_list, and there is only one array_component_association in the array_aggregate.
<dt><a name="18">(18)</a><dd>In a named_array_aggregate with more than one discrete_choice, no two
discrete_choices are allowed to cover the same value <a href="03-08-01.htm">(see 3.8.1)</a>; if there is
no others choice, the discrete_choices taken together shall exactly cover a
contiguous sequence of values of the corresponding index type.
<dt><a name="19">(19)</a><dd>A bottom level subaggregate of a multidimensional array_aggregate of a
given array type is allowed to be a string_literal only if the component type
of the array type is a character type; each character of such a string_literal shall correspond to a defining_character_literal of the component
type.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="20">(20)</a><dd>A subaggregate that is a string_literal is equivalent to one that is a
positional_array_aggregate of the same length, with each expression being the
character_literal for the corresponding character of the string_literal.
</dl><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="21">(21)</a><dd>The evaluation of an array_aggregate of a given array type proceeds in
two steps:
<dt><a name="22">(22)</a><dd><ul><li>Any discrete_choices of this aggregate and of its subaggregates
are evaluated in an arbitrary order, and converted to the
corresponding index type;
</ul><dt><a name="23">(23)</a><dd><ul><li>The array component expressions of the aggregate are evaluated in
an arbitrary order and their values are converted to the
component subtype of the array type; an array component
expression is evaluated once for each associated component.
</ul><dt><a name="24">(24)</a><dd>The bounds of the index range of an array_aggregate (including a
subaggregate) are determined as follows:
<dt><a name="25">(25)</a><dd><ul><li>For an array_aggregate with an others choice, the bounds are
those of the corresponding index range from the applicable index
constraint;
</ul><dt><a name="26">(26)</a><dd><ul><li>For a positional_array_aggregate (or equivalent string_literal)
without an others choice, the lower bound is that of the
corresponding index range in the applicable index constraint, if
defined, or that of the corresponding index subtype, if not; in
either case, the upper bound is determined from the lower bound
and the number of expressions (or the length of the string_literal);
</ul><dt><a name="27">(27)</a><dd><ul><li>For a named_array_aggregate without an others choice, the bounds
are determined by the smallest and largest index values covered
by any discrete_choice_list.
</ul><dt><a name="28">(28)</a><dd>For an array_aggregate, a check is made that the index range defined by
its bounds is compatible with the corresponding index subtype.
<dt><a name="29">(29)</a><dd>For an array_aggregate with an others choice, a check is made that no
expression is specified for an index value outside the bounds determined by
the applicable index constraint.
<dt><a name="30">(30)</a><dd>For a multidimensional array_aggregate, a check is made that all
subaggregates that correspond to the same index have the same bounds.
<dt><a name="31">(31)</a><dd>The exception Constraint_Error is raised if any of the above checks
fail.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="32">(32)</a><dd><ul>(10) In an array_aggregate, positional notation may only be used with
two or more expressions; a single expression in parentheses is
interpreted as a parenthesized_expression.  A named_array_aggregate,
such as (1 =&gt; X), may be used to specify an array with a single
component.
</ul></dl><h5 align="center">Examples</h5>
<dl><dt><a name="33">(33)</a><dd><em>Examples of array aggregates with positional associations:
</em>
</dl><pre><a name="34">(34)</a>
       (7, 9, 5, 1, 3, 2, 4, 8, 6, 0)
       Table'(5, 8, 4, 1, others =&gt; 0)  <em>--  <a href="03-06.htm">see 3.6</a></em>
</pre><dl><dt><a name="35">(35)</a><dd><em>Examples of array aggregates with named associations:
</em>
</dl><pre><a name="36">(36)</a>
       (1 .. 5 =&gt; (1 .. 8 =&gt; 0.0))      <em>--  two-dimensional</em>
       (1 .. N =&gt; new Cell)             <em>--  N new cells, in particular for N = 0</em>
<a name="37">(37)</a>
       Table'(2 | 4 | 10 =&gt; 1, others =&gt; 0)
       Schedule'(Mon .. Fri =&gt; True,  others =&gt; False)  <em>--  <a href="03-06.htm">see 3.6</a></em>
       Schedule'(Wed | Sun  =&gt; False, others =&gt; True)
       Vector'(1 =&gt; 2.5)                                <em>--  single-component vector</em>
</pre><dl><dt><a name="38">(38)</a><dd><em>Examples of two-dimensional array aggregates:
</em>
</dl><pre><a name="39">(39)</a>
       <em>-- Three aggregates for the same value of subtype Matrix(1..2,1..3) <a href="03-06.htm">(see 3.6)</a>:</em>
<a name="40">(40)</a>
       ((1.1, 1.2, 1.3), (2.1, 2.2, 2.3))
       (1 =&gt; (1.1, 1.2, 1.3), 2 =&gt; (2.1, 2.2, 2.3))
       (1 =&gt; (1 =&gt; 1.1, 2 =&gt; 1.2, 3 =&gt; 1.3), 2 =&gt; (1 =&gt; 2.1, 2 =&gt; 2.2, 3 =&gt; 2.3))
</pre><dl><dt><a name="41">(41)</a><dd><em>Examples of aggregates as initial values:
</em>
</dl><pre><a name="42">(42)</a>
       A : Table := (7, 9, 5, 1, 3, 2, 4, 8, 6, 0);        <em>-- A(1)=7, A(10)=0</em>
       B : Table := (2 | 4 | 10 =&gt; 1, others =&gt; 0);        <em>-- B(1)=0, B(10)=1</em>
       C : constant Matrix := (1 .. 5 =&gt; (1 .. 8 =&gt; 0.0)); <em>-- C'Last(1)=5, C'Last(2)=8</em>
<a name="43">(43)</a>
       D : Bit_Vector(M .. N) := (M .. N =&gt; True);         <em>-- <a href="03-06.htm">see 3.6</a></em>
       E : Bit_Vector(M .. N) := (others =&gt; True);
       F : String(1 .. 1) := (1 =&gt; 'F');  <em>-- a one component aggregate: same as "F"</em>
</pre><hr>
<h4><a href="04-03-02.htm"><img src="left.gif" alt="Prev"></a> | <a href="04-03.htm"><img src="up.gif" alt="Up"></a> | <img src="noright.gif" alt="____"> | <a href="04-03-02.htm"><img src="back.gif" alt="Back"></a> | <a href="04-04.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
