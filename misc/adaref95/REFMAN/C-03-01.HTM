<html>
<head>
<title>Ada 95 RM - C.3.1 Protected Procedure Handlers</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><img src="noleft.gif" alt="____"> | <a href="C-03.htm"><img src="up.gif" alt="Up"></a> | <a href="C-03-02.htm"><img src="right.gif" alt="Next"></a> | <a href="C-03.htm"><img src="back.gif" alt="Back"></a> | <a href="C-03-02.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>
<h3><a name="0">C.3.1 Protected Procedure Handlers</a></h3>
<h5 align="center"><a name="syntax">Syntax</a></h5>
<dl><dt><a name="1">(1)</a><dd><ul><li>The form of a pragma Interrupt_Handler is as follows:
</ul></dl><pre><a name="2">(2)</a>
         pragma Interrupt_Handler(handler_name);
</pre><dl><dt><a name="3">(3)</a><dd><ul><li>The form of a pragma Attach_Handler is as follows:
</ul></dl><pre><a name="4">(4)</a>
         pragma Attach_Handler(handler_name, expression);
</pre><h5 align="center">Name Resolution Rules</h5>
<dl><dt><a name="5">(5)</a><dd>For the Interrupt_Handler and Attach_Handler pragmas, the handler_name
shall resolve to denote a protected procedure with a parameterless profile.
<dt><a name="6">(6)</a><dd>For the Attach_Handler pragma, the expected type for the expression is
Interrupts.Interrupt_ID <a href="C-03-02.htm">(see C.3.2)</a>.
</dl><h5 align="center">Legality Rules</h5>
<dl><dt><a name="7">(7)</a><dd>The Attach_Handler pragma is only allowed immediately within the
protected_definition where the corresponding subprogram is declared.  The
corresponding protected_type_declaration or single_protected_declaration
shall be a library level declaration.
<dt><a name="8">(8)</a><dd>The Interrupt_Handler pragma is only allowed immediately within a
protected_definition.  The corresponding protected_type_declaration shall be
a library level declaration.  In addition, any object_declaration of such a
type shall be a library level declaration.
</dl><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="9">(9)</a><dd>If the pragma Interrupt_Handler appears in a protected_definition, then
the corresponding procedure can be attached dynamically, as a handler, to
interrupts <a href="C-03-02.htm">(see C.3.2)</a>.  Such procedures are allowed to be attached to
multiple interrupts.
<dt><a name="10">(10)</a><dd>The expression in the Attach_Handler pragma as evaluated at object
creation time specifies an interrupt.  As part of the initialization of that
object, if the Attach_Handler pragma is specified, the handler procedure is
attached to the specified interrupt.  A check is made that the corresponding
interrupt is not reserved.  Program_Error is raised if the check fails, and
the existing treatment for the interrupt is not affected.
<dt><a name="11">(11)</a><dd>If the Ceiling_Locking policy <a href="D-03.htm">(see D.3)</a> is in effect then upon the
initialization of a protected object that either an Attach_Handler or
Interrupt_Handler pragma applies to one of its procedures, a check is made
that the ceiling priority defined in the protected_definition is in the range
of System.Interrupt_Priority.  If the check fails, Program_Error is raised.
<dt><a name="12">(12)</a><dd>When a protected object is finalized, for any of its procedures that are
attached to interrupts, the handler is detached.  If the handler was attached
by a procedure in the Interrupts package or if no user handler was previously
attached to the interrupt, the default treatment is restored.  Otherwise,
that is, if an Attach_Handler pragma was used, the previous handler is
restored.
<dt><a name="13">(13)</a><dd>When a handler is attached to an interrupt, the interrupt is blocked
(subject to the Implementation Permission <a href="C-03.htm">in C.3)</a> during the execution of
every protected action on the protected object containing the handler.
</dl><h5 align="center">Erroneous Execution</h5>
<dl><dt><a name="14">(14)</a><dd>If the Ceiling_Locking policy <a href="D-03.htm">(see D.3)</a> is in effect and an interrupt is
delivered to a handler, and the interrupt hardware priority is higher than
the ceiling priority of the corresponding protected object, the execution of
the program is erroneous.
</dl><h5 align="center">Metrics</h5>
<dl><dt><a name="15">(15)</a><dd>The following metric shall be documented by the implementation:
<dt><a name="16">(16)</a><dd><ul><li>The worst case overhead for an interrupt handler that is a
parameterless protected procedure, in clock cycles.  This is the
execution time not directly attributable to the handler procedure
or the interrupted execution.  It is estimated as C - (A+B),
where A is how long it takes to complete a given sequence of
instructions without any interrupt, B is how long it takes to
complete a normal call to a given protected procedure, and C is
how long it takes to complete the same sequence of instructions
when it is interrupted by one execution of the same procedure
called via an interrupt.
</ul></dl><h5 align="center">Implementation Permissions</h5>
<dl><dt><a name="17">(17)</a><dd>When the pragmas Attach_Handler or Interrupt_Handler apply to a
protected procedure, the implementation is allowed to impose implementation--
defined restrictions on the corresponding protected_type_declaration and
protected_body.
<dt><a name="18">(18)</a><dd>An implementation may use a different mechanism for invoking a protected
procedure in response to a hardware interrupt than is used for a call to that
protected procedure from a task.
<dt><a name="19">(19)</a><dd>Notwithstanding what this subclause says elsewhere, the Attach_Handler
and Interrupt_Handler pragmas are allowed to be used for other,
implementation defined, forms of interrupt handlers.
</dl><h5 align="center">Implementation Advice</h5>
<dl><dt><a name="20">(20)</a><dd>Whenever possible, the implementation should allow interrupt handlers to
be called directly by the hardware.
<dt><a name="21">(21)</a><dd>Whenever practical, the implementation should detect violations of any
implementation-defined restrictions before run time.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="22">(22)</a><dd><ul>(4) The Attach_Handler pragma can provide static attachment of handlers
to interrupts if the implementation supports preelaboration of protected
objects.  (See <a href="C-04.htm">C.4</a>.)
</ul><dt><a name="23">(23)</a><dd><ul>(5) The ceiling priority of a protected object that one of its
procedures is attached to an interrupt should be at least as high as the
highest processor priority at which that interrupt will ever be
delivered.
</ul><dt><a name="24">(24)</a><dd><ul>(6) Protected procedures can also be attached dynamically to interrupts
via operations declared in the predefined package Interrupts.
</ul><dt><a name="25">(25)</a><dd><ul>(7) An example of a possible implementation-defined restriction is
disallowing the use of the standard storage pools within the body of a
protected procedure that is an interrupt handler.
</ul></dl><hr>
<h4><img src="noleft.gif" alt="____"> | <a href="C-03.htm"><img src="up.gif" alt="Up"></a> | <a href="C-03-02.htm"><img src="right.gif" alt="Next"></a> | <a href="C-03.htm"><img src="back.gif" alt="Back"></a> | <a href="C-03-02.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
