<html>
<head>
<title>Ada 95 RM - 7.3.1 Private Operations</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><img src="noleft.gif" alt="____"> | <a href="07-03.htm"><img src="up.gif" alt="Up"></a> | <img src="noright.gif" alt="____"> | <a href="07-03.htm"><img src="back.gif" alt="Back"></a> | <a href="07-04.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>
<h3><a name="0">7.3.1 Private Operations</a></h3>
<dl><dt><a name="1">(1)</a><dd>For a type declared in the visible part of a package or generic package,
certain operations on the type do not become visible until later in the
package -- either in the private part or the body.  Such private operations
are available only inside the declarative region of the package or generic
package.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="2">(2)</a><dd>The predefined operators that exist for a given type are determined by
the classes to which the type belongs.  For example, an integer type has a
predefined "+" operator.  In most cases, the predefined operators of a type
are declared immediately after the definition of the type; the exceptions are
explained below.  Inherited subprograms are also implicitly declared
immediately after the definition of the type, except as stated below.
<dt><a name="3">(3)</a><dd>For a composite type, the characteristics <a href="07-03.htm">(see 7.3)</a> of the type are
determined in part by the characteristics of its component types.  At the
place where the composite type is declared, the only characteristics of
component types used are those characteristics visible at that place.  If
later within the immediate scope of the composite type additional
characteristics become visible for a component type, then any corresponding
characteristics become visible for the composite type.  Any additional
predefined operators are implicitly declared at that place.
<dt><a name="4">(4)</a><dd>The corresponding rule applies to a type defined by a derived_type_definition, if there is a place within its immediate scope where additional
characteristics of its parent type become visible.
<dt><a name="5">(5)</a><dd>For example, an array type whose component type is limited private
becomes nonlimited if the full view of the component type is nonlimited and
visible at some later place within the immediate scope of the array type.  In
such a case, the predefined "=" operator is implicitly declared at that
place, and assignment is allowed after that place.
<dt><a name="6">(6)</a><dd>Inherited primitive subprograms follow a different rule.  For a derived_type_definition, each inherited primitive subprogram is implicitly declared
at the earliest place, if any, within the immediate scope of the type_declaration, but after the type_declaration, where the corresponding
declaration from the parent is visible.  If there is no such place, then the
inherited subprogram is not declared at all.  An inherited subprogram that is
not declared at all cannot be named in a call and cannot be overridden, but
for a tagged type, it is possible to dispatch to it.
<dt><a name="7">(7)</a><dd>For a private_extension_declaration, each inherited subprogram is
declared immediately after the private_extension_declaration if the
corresponding declaration from the ancestor is visible at that place.
Otherwise, the inherited subprogram is not declared for the private
extension, though it might be for the full type.
<dt><a name="8">(8)</a><dd>The Class attribute is defined for tagged subtypes <a href="03-09.htm">in 3.9</a>.  In addition,
for every subtype S of an untagged private type whose full view is tagged,
the following attribute is defined:
<dt><a name="9">(9)</a><dd>S'Class
<ul>Denotes the class-wide subtype corresponding to the full view
of S. This attribute is allowed only from the beginning of
the private part in which the full view is declared, until
the declaration of the full view.  After the full view, the
Class attribute of the full view can be used.
</ul><p><dt><dd><ul>NOTES</ul>
<dt><a name="10">(10)</a><dd><ul>(8) Because a partial view and a full view are two different views of
one and the same type, outside of the defining package the
characteristics of the type are those defined by the visible part.
Within these outside program units the type is just a private type or
private extension, and any language rule that applies only to another
class of types does not apply.  The fact that the full declaration might
implement a private type with a type of a particular class (for example,
as an array type) is relevant only within the declarative region of the
package itself including any child units.
</ul><dt><a name="11">(11)</a><dd><ul>The consequences of this actual implementation are, however, valid
everywhere.  For example: any default initialization of components takes
place; the attribute Size provides the size of the full view;
finalization is still done for controlled components of the full view;
task dependence rules still apply to components that are task objects.
</ul><dt><a name="12">(12)</a><dd><ul>(9) Partial views provide assignment (unless the view is limited),
membership tests, selected components for the selection of discriminants
and inherited components, qualification, and explicit conversion.
</ul><dt><a name="13">(13)</a><dd><ul>(10) For a subtype S of a partial view, S'Size is defined <a href="13-03.htm">(see 13.3)</a>.
For an object A of a partial view, the attributes A'Size and A'Address
are defined <a href="13-03.htm">(see 13.3)</a>.  The Position, First_Bit, and Last_Bit
attributes are also defined for discriminants and inherited components.
</ul></dl><h5 align="center">Examples</h5>
<dl><dt><a name="14">(14)</a><dd><em>Example of a type with private operations:
</em>
</dl><pre><a name="15">(15)</a>
       package Key_Manager is
          type Key is private;
          Null_Key : constant Key; <em>-- a deferred constant declaration <a href="07-04.htm">(see 7.4)</a></em>
          procedure Get_Key(K : out Key);
          function "&lt;" (X, Y : Key) return Boolean;
       private
          type Key is new Natural;
          Null_Key : constant Key := Key'First;
       end Key_Manager;
<a name="16">(16)</a>
       package body Key_Manager is
          Last_Key : Key := Null_Key;
          procedure Get_Key(K : out Key) is
          begin
             Last_Key := Last_Key + 1;
             K := Last_Key;
          end Get_Key;
<a name="17">(17)</a>
          function "&lt;" (X, Y : Key) return Boolean is
          begin
             return Natural(X) &lt; Natural(Y);
          end "&lt;";
       end Key_Manager;
</pre><dl><p><dt><dd><ul>NOTES</ul>
<dt><a name="18">(18)</a><dd><ul>(11) Notes on the example:  Outside of the package Key_Manager, the
operations available for objects of type Key include assignment, the
comparison for equality or inequality, the procedure Get_Key and the
operator "&lt;"; they do not include other relational operators such as
"&gt;=", or arithmetic operators.
</ul><dt><a name="19">(19)</a><dd><ul>The explicitly declared operator "&lt;" hides the predefined operator
"&lt;" implicitly declared by the full_type_declaration.  Within the body
of the function, an explicit conversion of X and Y to the subtype
Natural is necessary to invoke the "&lt;" operator of the parent type.
Alternatively, the result of the function could be written as not (X &gt;=
Y), since the operator "&gt;=" is not redefined.
</ul><dt><a name="20">(20)</a><dd><ul>The value of the variable Last_Key, declared in the package body,
remains unchanged between calls of the procedure Get_Key.  (See also the
NOTES of <a href="07-02.htm">7.2</a>.)
</ul></dl><hr>
<h4><img src="noleft.gif" alt="____"> | <a href="07-03.htm"><img src="up.gif" alt="Up"></a> | <img src="noright.gif" alt="____"> | <a href="07-03.htm"><img src="back.gif" alt="Back"></a> | <a href="07-04.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
