<html>
<head>
<title>Ada 95 RM - 3.10 Access Types</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="03-09.htm"><img src="left.gif" alt="Prev"></a> | <a href="03.htm"><img src="up.gif" alt="Up"></a> | <a href="03-11.htm"><img src="right.gif" alt="Next"></a> | <a href="03-09-03.htm"><img src="back.gif" alt="Back"></a> | <a href="03-10-01.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>

<h2><a name="0">3.10 Access Types</a>
 -- <a href="toc03-10.htm">TOC</a>
</h2>
<dl><dt><a name="1">(1)</a><dd>A value of an access type (an access value) provides indirect access to
the object or subprogram it designates.  Depending on its type, an access
value can designate either subprograms, objects created by allocators <a href="04-08.htm">(see 4.8)</a>, or more generally aliased objects of an appropriate type.
</dl><h5 align="center"><a name="syntax">Syntax</a></h5>
<pre><a name="2">(2)</a>
       access_type_definition ::=
           access_to_object_definition
         | access_to_subprogram_definition
<a name="3">(3)</a>
       access_to_object_definition ::=
           access [general_access_modifier] subtype_indication
<a name="4">(4)</a>
       general_access_modifier ::= all | constant
<a name="5">(5)</a>
       access_to_subprogram_definition ::=
           access [protected] procedure parameter_profile
         | access [protected] function  parameter_and_result_profile
<a name="6">(6)</a>
       access_definition ::= access subtype_mark
</pre><h5 align="center">Static Semantics</h5>
<dl><dt><a name="7">(7)</a><dd>There are two kinds of access types, access-to-object types, whose values
designate objects, and access-to-subprogram types, whose values designate
subprograms.  Associated with an access-to-object type is a storage pool;
several access types may share the same storage pool.  A storage pool is an
area of storage used to hold dynamically allocated objects (called pool
elements) created by allocators; storage pools are described further <a href="13-11.htm">in 13.11</a>, ``Storage Management''.
<dt><a name="8">(8)</a><dd>Access-to-object types are further subdivided into pool-specific access
types, whose values can designate only the elements of their associated
storage pool, and general access types, whose values can designate the
elements of any storage pool, as well as aliased objects created by
declarations rather than allocators, and aliased subcomponents of other
objects.
<dt><a name="9">(9)</a><dd>A view of an object is defined to be aliased if it is defined by an
object_declaration or component_definition with the reserved word aliased, or
by a renaming of an aliased view.  In addition, the dereference of an
access-to-object value denotes an aliased view, as does a view conversion
<a href="04-06.htm">(see 4.6)</a> of an aliased view.  Finally, the current instance of a limited
type, and a formal parameter or generic formal object of a tagged type are
defined to be aliased.  Aliased views are the ones that can be designated by
an access value.  If the view defined by an object_declaration is aliased,
and the type of the object has discriminants, then the object is constrained;
if its nominal subtype is unconstrained, then the object is constrained by
its initial value.  Similarly, if the object created by an allocator has
discriminants, the object is constrained, either by the designated subtype,
or by its initial value.
<dt><a name="10">(10)</a><dd>An access_to_object_definition defines an access-to-object type and its
first subtype; the subtype_indication defines the designated subtype of the
access type.  If a general_access_modifier appears, then the access type is a
general access type.  If the modifier is the reserved word constant, then the
type is an access-to-constant type; a designated object cannot be updated
through a value of such a type.  If the modifier is the reserved word all,
then the type is an access-to-variable type; a designated object can be both
read and updated through a value of such a type.  If no general_access_modifier appears in the access_to_object_definition, the access type is a
pool-specific access-to-variable type.
<dt><a name="11">(11)</a><dd>An access_to_subprogram_definition defines an access-to-subprogram type
and its first subtype; the parameter_profile or parameter_and_result_profile
defines the designated profile of the access type.  There is a calling
convention associated with the designated profile; only subprograms with this
calling convention can be designated by values of the access type.  By
default, the calling convention is ``protected'' if the reserved word
protected appears, and ``Ada'' otherwise.  See <a href="B.htm">Annex B</a> for how to override
this default.
<dt><a name="12">(12)</a><dd>An access_definition defines an anonymous general access-to-variable
type; the subtype_mark denotes its designated subtype.  An access_definition
is used in the specification of an access discriminant <a href="03-07.htm">(see 3.7)</a> or an access
parameter <a href="06-01.htm">(see 6.1)</a>.
<dt><a name="13">(13)</a><dd>For each (named) access type, there is a literal null which has a null
access value designating no entity at all.  The null value of a named access
type is the default initial value of the type.  Other values of an access
type are obtained by evaluating an attribute_reference for the Access or
Unchecked_Access attribute of an aliased view of an object or non-intrinsic
subprogram, or, in the case of a named access-to-object type, an allocator,
which returns an access value designating a newly created object <a href="03-10-02.htm">(see 3.10.2)</a>.
<dt><a name="14">(14)</a><dd>All subtypes of an access-to-subprogram type are constrained.  The first
subtype of a type defined by an access_type_definition or an access_to_object_definition is unconstrained if the designated subtype is an
unconstrained array or discriminated type; otherwise it is constrained.
</dl><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="15">(15)</a><dd>A composite_constraint is compatible with an unconstrained access
subtype if it is compatible with the designated subtype.  An access value
satisfies a composite_constraint of an access subtype if it equals the null
value of its type or if it designates an object whose value satisfies the
constraint.
<dt><a name="16">(16)</a><dd>The elaboration of an access_type_definition creates the access type and
its first subtype.  For an access-to-object type, this elaboration includes
the elaboration of the subtype_indication, which creates the designated
subtype.
<dt><a name="17">(17)</a><dd>The elaboration of an access_definition creates an anonymous general
access-to-variable type (this happens as part of the initialization of an
access parameter or access discriminant).
<p><dt><dd><ul>NOTES</ul>
<dt><a name="18">(18)</a><dd><ul>(77) Access values are called ``pointers'' or ``references'' in some
other languages.
</ul><dt><a name="19">(19)</a><dd><ul>(78) Each access-to-object type has an associated storage pool; several
access types can share the same pool.  An object can be created in the
storage pool of an access type by an allocator <a href="04-08.htm">(see 4.8)</a> for the access
type.  A storage pool (roughly) corresponds to what some other languages
call a ``heap.''  <a href="13-11.htm">See 13.11</a> for a discussion of pools.
</ul><dt><a name="20">(20)</a><dd><ul>(79) Only index_constraints and discriminant_constraints can be applied
to access types <a href="03-06-01.htm">(see 3.6.1</a> and <a href="03-07-01.htm">3.7.1)</a>.
</ul></dl><h5 align="center">Examples</h5>
<dl><dt><a name="21">(21)</a><dd><em>Examples of access-to-object types:
</em>
</dl><pre><a name="22">(22)</a>
       type Peripheral_Ref is access Peripheral;  <em>--  <a href="03-08-01.htm">see 3.8.1</a></em>
       type Binop_Ptr is access all Binary_Operation'Class;
                                                  <em>-- general access-to-class-wide,<a href="03-09-01.htm">see 3.9.1</a></em>
</pre><dl><dt><a name="23">(23)</a><dd><em>Example of an access subtype:
</em>
</dl><pre><a name="24">(24)</a>
       subtype Drum_Ref is Peripheral_Ref(Drum);  <em>--  <a href="03-08-01.htm">see 3.8.1</a></em>
</pre><dl><dt><a name="25">(25)</a><dd><em>Example of an access-to-subprogram type:
</em>
</dl><pre><a name="26">(26)</a>
       type Message_Procedure is access procedure (M : in String := "Error!");
       procedure Default_Message_Procedure(M : in String);
       Give_Message : Message_Procedure := Default_Message_Procedure'Access;
       ...
       procedure Other_Procedure(M : in String);
       ...
       Give_Message := Other_Procedure'Access;
       ...
       Give_Message("File not found.");  <em>-- call with parameter (.all is optional)</em>
       Give_Message.all;                 <em>-- call with no parameters</em>
</pre><hr><h3>Subclauses</h3>
<ol>
<li><a href="03-10-01.htm">Incomplete Type Declarations</a>
<li><a href="03-10-02.htm">Operations of Access Types</a>
</ol>
<p>
<hr>
<h4><a href="03-09.htm"><img src="left.gif" alt="Prev"></a> | <a href="03.htm"><img src="up.gif" alt="Up"></a> | <a href="03-11.htm"><img src="right.gif" alt="Next"></a> | <a href="03-09-03.htm"><img src="back.gif" alt="Back"></a> | <a href="03-10-01.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
