<html>
<head>
<title>Ada 95 RM - E.4 Remote Subprogram Calls</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="E-03.htm"><img src="left.gif" alt="Prev"></a> | <a href="E.htm"><img src="up.gif" alt="Up"></a> | <a href="E-05.htm"><img src="right.gif" alt="Next"></a> | <a href="E-03.htm"><img src="back.gif" alt="Back"></a> | <a href="E-04-01.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>

<h2><a name="0">E.4 Remote Subprogram Calls</a>
 -- <a href="tocE-04.htm">TOC</a>
</h2>
<dl><dt><a name="1">(1)</a><dd>A remote subprogram call is a subprogram call that invokes the execution
of a subprogram in another partition.  The partition that originates the
remote subprogram call is the calling partition, and the partition that
executes the corresponding subprogram body is the called partition.  Some
remote procedure calls are allowed to return prior to the completion of
subprogram execution. These are called asynchronous remote procedure calls.
<dt><a name="2">(2)</a><dd>There are three different ways of performing a remote subprogram call:
<dt><a name="3">(3)</a><dd><ul><li>As a direct call on a (remote) subprogram explicitly declared in
a remote call interface;
</ul><dt><a name="4">(4)</a><dd><ul><li>As an indirect call through a value of a remote
access-to-subprogram type;
</ul><dt><a name="5">(5)</a><dd><ul><li>As a dispatching call with a controlling operand designated by a
value of a remote access-to-class-wide type.
</ul><dt><a name="6">(6)</a><dd>The first way of calling corresponds to a static binding between the
calling and the called partition.  The latter two ways correspond to a
dynamic binding between the calling and the called partition.
<dt><a name="7">(7)</a><dd>A remote call interface library unit <a href="E-02-03.htm">(see E.2.3)</a> defines the remote
subprograms or remote access types used for remote subprogram calls.
</dl><h5 align="center">Legality Rules</h5>
<dl><dt><a name="8">(8)</a><dd>In a dispatching call with two or more controlling operands, if one
controlling operand is designated by a value of a remote access-to-class-wide
type, then all shall be.
</dl><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="9">(9)</a><dd>For the execution of a remote subprogram call, subprogram parameters (and
later the results, if any) are passed using a stream-oriented representation
<a href="13-13-01.htm">(see 13.13.1)</a> which is suitable for transmission between partitions.  This
action is called marshalling. Unmarshalling is the reverse action of
reconstructing the parameters or results from the stream-oriented
representation.  Marshalling is performed initially as part of the remote
subprogram call in the calling partition; unmarshalling is done in the called
partition.  After the remote subprogram completes, marshalling is performed
in the called partition, and finally unmarshalling is done in the calling
partition.
<dt><a name="10">(10)</a><dd>A calling stub is the sequence of code that replaces the subprogram body
of a remotely called subprogram in the calling partition. A receiving stub is
the sequence of code (the ``wrapper'') that receives a remote subprogram call
on the called partition and invokes the appropriate subprogram body.
<dt><a name="11">(11)</a><dd>Remote subprogram calls are executed at most once, that is, if the
subprogram call returns normally, then the called subprogram's body was
executed exactly once.
<dt><a name="12">(12)</a><dd>The task executing a remote subprogram call blocks until the subprogram
in the called partition returns, unless the call is asynchronous. For an
asynchronous remote procedure call, the calling task can become ready before
the procedure in the called partition returns.
<dt><a name="13">(13)</a><dd>If a construct containing a remote call is aborted, the remote
subprogram call is cancelled.  Whether the execution of the remote subprogram
is immediately aborted as a result of the cancellation is implementation
defined.
<dt><a name="14">(14)</a><dd>If a remote subprogram call is received by a called partition before the
partition has completed its elaboration, the call is kept pending until the
called partition completes its elaboration (unless the call is cancelled by
the calling partition prior to that).
<dt><a name="15">(15)</a><dd>If an exception is propagated by a remotely called subprogram, and the
call is not an asynchronous call, the corresponding exception is reraised at
the point of the remote subprogram call.  For an asynchronous call, if the
remote procedure call returns prior to the completion of the remotely called
subprogram, any exception is lost.
<dt><a name="16">(16)</a><dd>The exception Communication_Error <a href="E-05.htm">(see E.5)</a> is raised if a remote call
cannot be completed due to difficulties in communicating with the called
partition.
<dt><a name="17">(17)</a><dd>All forms of remote subprogram calls are potentially blocking operations
<a href="09-05-01.htm">(see 9.5.1)</a>.
<dt><a name="18">(18)</a><dd>In a remote subprogram call with a formal parameter of a class-wide
type, a check is made that the tag of the actual parameter identifies a
tagged type declared in a declared-pure or shared passive library unit, or in
the visible part of a remote types or remote call interface library unit.
Program_Error is raised if this check fails.
<dt><a name="19">(19)</a><dd>In a dispatching call with two or more controlling operands that are
designated by values of a remote access-to-class-wide type, a check is made
(in addition to the normal Tag_Check -- <a href="11-05.htm">see 11.5)</a> that all the remote
access-to-class-wide values originated from Access attribute_references that
were evaluated by tasks of the same active partition.  Constraint_Error is
raised if this check fails.
</dl><h5 align="center">Implementation Requirements</h5>
<dl><dt><a name="20">(20)</a><dd>The implementation of remote subprogram calls shall conform to the PCS
interface as defined by the specification of the language-defined package
System.RPC <a href="E-05.htm">(see E.5)</a>.  The calling stub shall use the Do_RPC procedure unless
the remote procedure call is asynchronous in which case Do_APC shall be used.
On the receiving side, the corresponding receiving stub shall be invoked by
the RPC-receiver.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="21">(21)</a><dd><ul>(6) A given active partition can both make and receive remote subprogram
calls.  Thus, an active partition can act as both a client and a server.
</ul><dt><a name="22">(22)</a><dd><ul>(7) If a given exception is propagated by a remote subprogram call, but
the exception does not exist in the calling partition, the exception can
be handled by an others choice or be propagated to and handled by a
third partition.
</ul></dl><hr><h3>Subclauses</h3>
<ol>
<li><a href="E-04-01.htm">Pragma Asynchronous</a>
<li><a href="E-04-02.htm">Example of Use of a Remote Access-to-Class-Wide Type</a>
</ol>
<p>
<hr>
<h4><a href="E-03.htm"><img src="left.gif" alt="Prev"></a> | <a href="E.htm"><img src="up.gif" alt="Up"></a> | <a href="E-05.htm"><img src="right.gif" alt="Next"></a> | <a href="E-03.htm"><img src="back.gif" alt="Back"></a> | <a href="E-04-01.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
