<html>
<head>
<title>Ada 95 RM - B.3.2 The Generic Package Interfaces.C.Pointers</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="B-03-01.htm"><img src="left.gif" alt="Prev"></a> | <a href="B-03.htm"><img src="up.gif" alt="Up"></a> | <img src="noright.gif" alt="____"> | <a href="B-03-01.htm"><img src="back.gif" alt="Back"></a> | <a href="B-04.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>
<h3><a name="0">B.3.2 The Generic Package Interfaces.C.Pointers</a></h3>
<dl><dt><a name="1">(1)</a><dd>The generic package Interfaces.C.Pointers allows the Ada programmer to
perform C-style operations on pointers.  It includes an access type Pointer,
Value functions that dereference a Pointer and deliver the designated array,
several pointer arithmetic operations, and ``copy'' procedures that copy the
contents of a source pointer into the array designated by a destination
pointer.  As <a href="C.htm">in C</a>, it treats an object Ptr of type Pointer as a pointer to
the first element of an array, so that for example, adding 1 to Ptr yields a
pointer to the second element of the array.
<dt><a name="2">(2)</a><dd>The generic allows two styles of usage: one in which the array is
terminated by a special terminator element; and another in which the
programmer needs to keep track of the length.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="3">(3)</a><dd>The generic library package Interfaces.C.Pointers has the following
declaration:
</dl><pre><a name="4">(4)</a>
       generic
          type Index is (&lt;&gt;);
          type Element is private;
          type Element_Array is array (Index range &lt;&gt;) of aliased Element;
          Default_Terminator : Element;
       package Interfaces.C.Pointers is
          pragma Preelaborate(Pointers);
<a name="5">(5)</a>
          type Pointer is access all Element;
<a name="6">(6)</a>
          function Value(Ref        : in Pointer;
                         Terminator : in Element := Default_Terminator)
             return Element_Array;
<a name="7">(7)</a>
          function Value(Ref    : in Pointer;
                         Length : in ptrdiff_t)
             return Element_Array;
<a name="8">(8)</a>
          Pointer_Error : exception;
<a name="9">(9)</a>
          <em>-- C-style Pointer arithmetic</em>
<a name="10">(10)</a>
          function "+" (Left : in Pointer;   Right : in ptrdiff_t) return Pointer;
          function "+" (Left : in ptrdiff_t; Right : in Pointer)   return Pointer;
          function "-" (Left : in Pointer;   Right : in ptrdiff_t) return Pointer;
          function "-" (Left : in Pointer;   Right : in Pointer)   return ptrdiff_t;
<a name="11">(11)</a>
          procedure Increment (Ref : in out Pointer);
          procedure Decrement (Ref : in out Pointer);
<a name="12">(12)</a>
          pragma Convention (Intrinsic, "+");
          pragma Convention (Intrinsic, "-");
          pragma Convention (Intrinsic, Increment);
          pragma Convention (Intrinsic, Decrement);
<a name="13">(13)</a>
          function Virtual_Length (Ref        : in Pointer;
                                   Terminator : in Element := Default_Terminator)
             return ptrdiff_t;
<a name="14">(14)</a>
          procedure Copy_Terminated_Array (Source     : in Pointer;
                                           Target     : in Pointer;
                                           Limit      : in ptrdiff_t := ptrdiff_t'Last;
                                           Terminator : in Element :=  Default_Terminator);
<a name="15">(15)</a>
          procedure Copy_Array (Source  : in Pointer;
                                Target  : in Pointer;
                                Length  : in ptrdiff_t);
<a name="16">(16)</a>
       end Interfaces.C.Pointers;
</pre><dl><dt><a name="17">(17)</a><dd>The type Pointer is C-compatible and corresponds to one use of C's
``Element *''.  An object of type Pointer is interpreted as a pointer to the
initial Element in an Element_Array.  Two styles are supported:
<dt><a name="18">(18)</a><dd><ul><li>Explicit termination of an array value with Default_Terminator (a
special terminator value);
</ul><dt><a name="19">(19)</a><dd><ul><li>Programmer-managed length, with Default_Terminator treated simply
as a data element.
</ul></dl><pre><a name="20">(20)</a>
       function Value(Ref        : in Pointer;
                      Terminator : in Element := Default_Terminator)
          return Element_Array;
</pre><dl><dt><a name="21">(21)</a><dd><ul>This function returns an Element_Array whose value is the array
pointed to by Ref, up to and including the first Terminator; the
lower bound of the array is Index'First.  Interfaces.C.Strings.Dereference_Error is propagated if Ref is null.
</ul></dl><pre><a name="22">(22)</a>
       function Value(Ref    : in Pointer;
                      Length : in ptrdiff_t)
          return Element_Array;
</pre><dl><dt><a name="23">(23)</a><dd><ul>This function returns an Element_Array comprising the first
Length elements pointed to by Ref.  The exception Interfaces.C.Strings.Dereference_Error is propagated if Ref is null.
</ul><dt><a name="24">(24)</a><dd>The "+" and "-" functions perform arithmetic on Pointer values, based on
the Size of the array elements.  In each of these functions, Pointer_Error is
propagated if a Pointer parameter is null.
</dl><pre><a name="25">(25)</a>
       procedure Increment (Ref : in out Pointer);
</pre><dl><dt><a name="26">(26)</a><dd><ul>Equivalent to Ref := Ref+1.
</ul></dl><pre><a name="27">(27)</a>
       procedure Decrement (Ref : in out Pointer);
</pre><dl><dt><a name="28">(28)</a><dd><ul>Equivalent to Ref := Ref-1.
</ul></dl><pre><a name="29">(29)</a>
       function Virtual_Length (Ref        : in Pointer;
                                Terminator : in Element := Default_Terminator)
          return ptrdiff_t;
</pre><dl><dt><a name="30">(30)</a><dd><ul>Returns the number of Elements, up to the one just before the
first Terminator, in Value(Ref, Terminator).
</ul></dl><pre><a name="31">(31)</a>
       procedure Copy_Terminated_Array (Source     : in Pointer;
                                        Target     : in Pointer;
                                        Limit      : in ptrdiff_t := ptrdiff_t'Last;
                                        Terminator : in Element := Default_Terminator);
</pre><dl><dt><a name="32">(32)</a><dd><ul>This procedure copies Value(Source, Terminator) into the array
pointed to by Target; it stops either after Terminator has been
copied, or the number of elements copied is Limit, whichever occurs
first.  Dereference_Error is propagated if either Source or Target is
null.
</ul></dl><pre><a name="33">(33)</a>
       procedure Copy_Array (Source  : in Pointer;
                             Target  : in Pointer;
                             Length  : in ptrdiff_t);
</pre><dl><dt><a name="34">(34)</a><dd><ul>This procedure copies the first Length elements from the array
pointed to by Source, into the array pointed to by Target.
Dereference_Error is propagated if either Source or Target is null.
</ul></dl><h5 align="center">Erroneous Execution</h5>
<dl><dt><a name="35">(35)</a><dd>It is erroneous to dereference a Pointer that does not designate an
aliased Element.
<dt><a name="36">(36)</a><dd>Execution of Value(Ref, Terminator) is erroneous if Ref does not
designate an aliased Element in an Element_Array terminated by Terminator.
<dt><a name="37">(37)</a><dd>Execution of Value(Ref, Length) is erroneous if Ref does not designate
an aliased Element in an Element_Array containing at least Length Elements
between the designated Element and the end of the array, inclusive.
<dt><a name="38">(38)</a><dd>Execution of Virtual_Length(Ref, Terminator) is erroneous if Ref does
not designate an aliased Element in an Element_Array terminated by
Terminator.
<dt><a name="39">(39)</a><dd>Execution of Copy_Terminated_Array(Source, Target, Limit, Terminator) is
erroneous in either of the following situations:
<dt><a name="40">(40)</a><dd><ul><li>Execution of both Value(Source,Terminator) and
Value(Source,Limit) are erroneous, or
</ul><dt><a name="41">(41)</a><dd><ul><li>Copying writes past the end of the array containing the Element
designated by Target.
</ul><dt><a name="42">(42)</a><dd>Execution of Copy_Array(Source, Target, Length) is erroneous if either
Value(Source, Length) is erroneous, or copying writes past the end of the
array containing the Element designated by Target.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="43">(43)</a><dd><ul>(14) To compose a Pointer from an Element_Array, use 'Access on the
first element.  For example (assuming appropriate instantiations):
</ul></dl><pre><a name="44">(44)</a>
          Some_Array   : Element_Array(0..5) ;
          Some_Pointer : Pointer := Some_Array(0)'Access;
</pre><h5 align="center">Examples</h5>
<dl><dt><a name="45">(45)</a><dd><em>Example of Interfaces.C.Pointers:
</em>
</dl><pre><a name="46">(46)</a>
       with Interfaces.C.Pointers;
       with Interfaces.C.Strings;
       procedure Test_Pointers is
          package C renames Interfaces.C;
          package Char_Ptrs is
             new C.Pointers (Index              =&gt; C.size_t,
                             Element            =&gt; C.char,
                             Element_Array      =&gt; C.char_array,
                             Default_Terminator =&gt; C.nul);
<a name="47">(47)</a>
          use type Char_Ptrs.Pointer;
          subtype Char_Star is Char_Ptrs.Pointer;
<a name="48">(48)</a>
          procedure Strcpy (Target_Ptr, Source_Ptr : Char_Star) is
             Target_Temp_Ptr : Char_Star := Target_Ptr;
             Source_Temp_Ptr : Char_Star := Source_Ptr;
             Element : C.char;
          begin
             if Target_Temp_Ptr = null or Source_Temp_Ptr = null then
                raise C.Strings.Dereference_Error;
             end if;
<a name="49">(49)</a>
             loop
                Element             := Source_Temp_Ptr.all;
                Target_Temp_Ptr.all := Element;
                exit when Element = C.nul;
                Char_Ptrs.Increment(Target_Temp_Ptr);
                Char_Ptrs.Increment(Source_Temp_Ptr);
             end loop;
          end Strcpy;
       begin
          ...
       end Test_Pointers;
</pre><hr>
<h4><a href="B-03-01.htm"><img src="left.gif" alt="Prev"></a> | <a href="B-03.htm"><img src="up.gif" alt="Up"></a> | <img src="noright.gif" alt="____"> | <a href="B-03-01.htm"><img src="back.gif" alt="Back"></a> | <a href="B-04.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
