<html>
<head>
<title>Ada 95 RM - B.3.1 The Package Interfaces.C.Strings</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><img src="noleft.gif" alt="____"> | <a href="B-03.htm"><img src="up.gif" alt="Up"></a> | <a href="B-03-02.htm"><img src="right.gif" alt="Next"></a> | <a href="B-03.htm"><img src="back.gif" alt="Back"></a> | <a href="B-03-02.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>
<h3><a name="0">B.3.1 The Package Interfaces.C.Strings</a></h3>
<dl><dt><a name="1">(1)</a><dd>The package Interfaces.C.Strings declares types and subprograms allowing
an Ada program to allocate, reference, update, and free C-style strings.  In
particular, the private type chars_ptr corresponds to a common use of ``char
*'' in C programs, and an object of this type can be passed to a subprogram
to which pragma Import(C,...) has been applied, and for which ``char *'' is
the type of the argument of the C function.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="2">(2)</a><dd>The library package Interfaces.C.Strings has the following declaration:
</dl><pre><a name="3">(3)</a>
       package Interfaces.C.Strings is
          pragma Preelaborate(Strings);
<a name="4">(4)</a>
          type char_array_access is access all char_array;
<a name="5">(5)</a>
          type chars_ptr is private;
<a name="6">(6)</a>
          type chars_ptr_array is array (size_t range &lt;&gt;) of chars_ptr;
<a name="7">(7)</a>
          Null_Ptr : constant chars_ptr;
<a name="8">(8)</a>
          function To_Chars_Ptr (Item      : in char_array_access;
                                 Nul_Check : in Boolean := False)
             return chars_ptr;
<a name="9">(9)</a>
          function New_Char_Array (Chars   : in char_array) return chars_ptr;
<a name="10">(10)</a>
          function New_String (Str : in String) return chars_ptr;
<a name="11">(11)</a>
          procedure Free (Item : in out chars_ptr);
<a name="12">(12)</a>
          Dereference_Error : exception;
<a name="13">(13)</a>
          function Value (Item : in chars_ptr) return char_array;
<a name="14">(14)</a>
          function Value (Item : in chars_ptr; Length : in size_t)
             return char_array;
<a name="15">(15)</a>
          function Value (Item : in chars_ptr) return String;
<a name="16">(16)</a>
          function Value (Item : in chars_ptr; Length : in size_t)
             return String;
<a name="17">(17)</a>
          function Strlen (Item : in chars_ptr) return size_t;
<a name="18">(18)</a>
          procedure Update (Item   : in chars_ptr;
                            Offset : in size_t;
                            Chars  : in char_array;
                            Check  : in Boolean := True);
<a name="19">(19)</a>
          procedure Update (Item   : in chars_ptr;
                            Offset : in size_t;
                            Str    : in String;
                            Check  : in Boolean := True);
<a name="20">(20)</a>
          Update_Error : exception;
<a name="21">(21)</a>
       private
          ... <em>-- not specified by the language</em>
       end Interfaces.C.Strings;
</pre><dl><dt><a name="22">(22)</a><dd>The type chars_ptr is C-compatible and corresponds to the use of C's
``char *'' for a pointer to the first char in a char array terminated by nul.
When an object of type chars_ptr is declared, its value is by default set to
Null_Ptr, unless the object is imported <a href="B-01.htm">(see B.1)</a>.
</dl><pre><a name="23">(23)</a>
       function To_Chars_Ptr (Item      : in char_array_access;
                              Nul_Check : in Boolean := False)
          return chars_ptr;
</pre><dl><dt><a name="24">(24)</a><dd><ul>If Item is null, then To_Chars_Ptr returns Null_Ptr.  Otherwise,
if Nul_Check is True and Item.all does not contain nul, then the
function propagates Terminator_Error; if Nul_Check is True and
Item.all does contain nul, To_Chars_Ptr performs a pointer conversion
with no allocation of memory.
</ul></dl><pre><a name="25">(25)</a>
       function New_Char_Array (Chars   : in char_array) return chars_ptr;
</pre><dl><dt><a name="26">(26)</a><dd><ul>This function returns a pointer to an allocated object
initialized to Chars(Chars'First .. Index) &amp; nul, where
</ul><dt><a name="27">(27)</a><dd><ul><ul><li>Index = Chars'Last if Chars does not contain nul, or
</ul></ul><dt><a name="28">(28)</a><dd><ul><ul><li>Index is the smallest size_t value I such that Chars(I+1)
= nul.
</ul></ul><p><dd><ul>Storage_Error is propagated if the allocation fails.</ul></dl><pre><a name="29">(29)</a>
       function New_String (Str : in String) return chars_ptr;
</pre><dl><dt><a name="30">(30)</a><dd><ul>This function is equivalent to New_Char_Array(To_C(Str)).
</ul></dl><pre><a name="31">(31)</a>
       procedure Free (Item : in out chars_ptr);
</pre><dl><dt><a name="32">(32)</a><dd><ul>If Item is Null_Ptr, then Free has no effect.  Otherwise, Free
releases the storage occupied by Value(Item), and resets Item to
Null_Ptr.
</ul></dl><pre><a name="33">(33)</a>
       function Value (Item : in chars_ptr) return char_array;
</pre><dl><dt><a name="34">(34)</a><dd><ul>If Item = Null_Ptr then Value propagates Dereference_Error.
Otherwise Value returns the prefix of the array of chars pointed to
by Item, up to and including the first nul.  The lower bound of the
result is 0.  If Item does not point to a nul-terminated string, then
execution of Value is erroneous.
</ul></dl><pre><a name="35">(35)</a>
       function Value (Item : in chars_ptr; Length : in size_t)
          return char_array;
</pre><dl><dt><a name="36">(36)</a><dd><ul>If Item = Null_Ptr then Value(Item) propagates Dereference_Error.  Otherwise Value returns the shorter of two arrays:  the first
Length chars pointed to by Item, and Value(Item).  The lower bound of
the result is 0.
</ul></dl><pre><a name="37">(37)</a>
       function Value (Item : in chars_ptr) return String;
</pre><dl><dt><a name="38">(38)</a><dd><ul>Equivalent to To_Ada(Value(Item), Trim_Nul=&gt;True).
</ul></dl><pre><a name="39">(39)</a>
       function Value (Item : in chars_ptr; Length : in size_t)
          return String;
</pre><dl><dt><a name="40">(40)</a><dd><ul>Equivalent to To_Ada(Value(Item, Length), Trim_Nul=&gt;True).
</ul></dl><pre><a name="41">(41)</a>
       function Strlen (Item : in chars_ptr) return size_t;
</pre><dl><dt><a name="42">(42)</a><dd><ul>Returns Val'Length-1 where Val = Value(Item); propagates
Dereference_Error if Item = Null_Ptr.
</ul></dl><pre><a name="43">(43)</a>
       procedure Update (Item   : in chars_ptr;
                         Offset : in size_t;
                         Chars  : in char_array;
                         Check  : Boolean := True);
</pre><dl><dt><a name="44">(44)</a><dd><ul>This procedure updates the value pointed to by Item, starting at
position Offset, using Chars as the data to be copied into the array.
Overwriting the nul terminator, and skipping with the Offset past the
nul terminator, are both prevented if Check is True, as follows:
</ul><dt><a name="45">(45)</a><dd><ul><ul><li>Let N = Strlen(Item).  If Check is True, then:
</ul></ul><dt><a name="46">(46)</a><dd><ul><ul><ul><li>If Offset+Chars'Length&gt;N, propagate Update_Error.
</ul></ul></ul><dt><a name="47">(47)</a><dd><ul><ul><ul><li>Otherwise, overwrite the data in the array pointed
to by Item, starting at the char at position
Offset, with the data in Chars.
</ul></ul></ul><dt><a name="48">(48)</a><dd><ul><ul><li>If Check is False, then processing is as above, but with
no check that Offset+Chars'Length&gt;N.
</ul></ul></dl><pre><a name="49">(49)</a>
       procedure Update (Item   : in chars_ptr;
                         Offset : in size_t;
                         Str    : in String;
                         Check  : in Boolean := True);
</pre><dl><dt><a name="50">(50)</a><dd><ul>Equivalent to Update(Item, Offset, To_C(Str), Check).
</ul></dl><h5 align="center">Erroneous Execution</h5>
<dl><dt><a name="51">(51)</a><dd>Execution of any of the following is erroneous if the Item parameter is
not null_ptr and Item does not point to a nul-terminated array of chars.
<dt><a name="52">(52)</a><dd><ul><li>a Value function not taking a Length parameter,
</ul><dt><a name="53">(53)</a><dd><ul><li>the Free procedure,
</ul><dt><a name="54">(54)</a><dd><ul><li>the Strlen function.
</ul><dt><a name="55">(55)</a><dd>Execution of Free(X) is also erroneous if the chars_ptr X was not
returned by New_Char_Array or New_String.
<dt><a name="56">(56)</a><dd>Reading or updating a freed char_array is erroneous.
<dt><a name="57">(57)</a><dd>Execution of Update is erroneous if Check is False and a call with Check
equal to True would have propagated Update_Error.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="58">(58)</a><dd><ul>(13) New_Char_Array and New_String might be implemented either through
the allocation function from the C environment (``malloc'') or through
Ada dynamic memory allocation (``new''). The key points are
</ul><dt><a name="59">(59)</a><dd><ul><ul><li>the returned value (a chars_ptr) is represented as a C
``char *'' so that it may be passed to C functions;
</ul></ul><dt><a name="60">(60)</a><dd><ul><ul><li>the allocated object should be freed by the programmer via a
call of Free, not by a called C function.
</ul></ul></dl><hr>
<h4><img src="noleft.gif" alt="____"> | <a href="B-03.htm"><img src="up.gif" alt="Up"></a> | <a href="B-03-02.htm"><img src="right.gif" alt="Next"></a> | <a href="B-03.htm"><img src="back.gif" alt="Back"></a> | <a href="B-03-02.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
