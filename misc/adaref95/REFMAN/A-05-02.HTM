<html>
<head>
<title>Ada 95 RM - A.5.2 Random Number Generation</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="A-05-01.htm"><img src="left.gif" alt="Prev"></a> | <a href="A-05.htm"><img src="up.gif" alt="Up"></a> | <a href="A-05-03.htm"><img src="right.gif" alt="Next"></a> | <a href="A-05-01.htm"><img src="back.gif" alt="Back"></a> | <a href="A-05-03.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>
<h3><a name="0">A.5.2 Random Number Generation</a></h3>
<dl><dt><a name="1">(1)</a><dd>Facilities for the generation of pseudo-random floating point numbers are
provided in the package Numerics.Float_Random; the generic package
Numerics.Discrete_Random provides similar facilities for the generation of
pseudo-random integers and pseudo-random values of enumeration types.  For
brevity, pseudo-random values of any of these types are called random
numbers.
<dt><a name="2">(2)</a><dd>Some of the facilities provided are basic to all applications of random
numbers.  These include a limited private type each of whose objects serves
as the generator of a (possibly distinct) sequence of random numbers; a
function to obtain the ``next'' random number from a given sequence of random
numbers (that is, from its generator); and subprograms to initialize or
reinitialize a given generator to a time-dependent state or a state denoted
by a single integer.
<dt><a name="3">(3)</a><dd>Other facilities are provided specifically for advanced applications.
These include subprograms to save and restore the state of a given generator;
a private type whose objects can be used to hold the saved state of a
generator; and subprograms to obtain a string representation of a given
generator state, or, given such a string representation, the corresponding
state.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="4">(4)</a><dd>The library package Numerics.Float_Random has the following declaration:
</dl><pre><a name="5">(5)</a>
       package Ada.Numerics.Float_Random is
<a name="6">(6)</a>
          <em>-- Basic facilities</em>
<a name="7">(7)</a>
          type Generator is limited private;
<a name="8">(8)</a>
          subtype Uniformly_Distributed is Float range 0.0 .. 1.0;
          function Random (Gen : Generator) return Uniformly_Distributed;
<a name="9">(9)</a>
          procedure Reset (Gen       : in Generator;
                           Initiator : in Integer);
          procedure Reset (Gen       : in Generator);
<a name="10">(10)</a>
          <em>-- Advanced facilities</em>
<a name="11">(11)</a>
          type State is private;
<a name="12">(12)</a>
          procedure Save  (Gen        : in  Generator;
                           To_State   : out State);
          procedure Reset (Gen        : in  Generator;
                           From_State : in  State);
<a name="13">(13)</a>
          Max_Image_Width : constant := implementation-defined integer value;
<a name="14">(14)</a>
          function Image (Of_State    : State)  return String;
          function Value (Coded_State : String) return State;
<a name="15">(15)</a>
       private
          ... <em>-- not specified by the language</em>
       end Ada.Numerics.Float_Random;
</pre><dl><dt><a name="16">(16)</a><dd>The generic library package Numerics.Discrete_Random has the following
declaration:
</dl><pre><a name="17">(17)</a>
       generic
          type Result_Subtype is (&lt;&gt;);
       package Ada.Numerics.Discrete_Random is
<a name="18">(18)</a>
          <em>-- Basic facilities</em>
<a name="19">(19)</a>
          type Generator is limited private;
<a name="20">(20)</a>
          function Random (Gen : Generator) return Result_Subtype;
<a name="21">(21)</a>
          procedure Reset (Gen       : in Generator;
                           Initiator : in Integer);
          procedure Reset (Gen       : in Generator);
<a name="22">(22)</a>
          <em>-- Advanced facilities</em>
<a name="23">(23)</a>
          type State is private;
<a name="24">(24)</a>
          procedure Save  (Gen        : in  Generator;
                           To_State   : out State);
          procedure Reset (Gen        : in  Generator;
                           From_State : in  State);
<a name="25">(25)</a>
          Max_Image_Width : constant := implementation-defined integer value;
<a name="26">(26)</a>
          function Image (Of_State    : State)  return String;
          function Value (Coded_State : String) return State;
<a name="27">(27)</a>
       private
          ... <em>-- not specified by the language</em>
       end Ada.Numerics.Discrete_Random;
</pre><dl><dt><a name="28">(28)</a><dd>An object of the limited private type Generator is associated with a
sequence of random numbers.  Each generator has a hidden (internal) state,
which the operations on generators use to determine the position in the
associated sequence.  All generators are implicitly initialized to an
unspecified state that does not vary from one program execution to another;
they may also be explicitly initialized, or reinitialized, to a
time-dependent state, to a previously saved state, or to a state uniquely
denoted by an integer value.
<dt><a name="29">(29)</a><dd>An object of the private type State can be used to hold the internal
state of a generator.  Such objects are only needed if the application is
designed to save and restore generator states or to examine or manufacture
them.
<dt><a name="30">(30)</a><dd>The operations on generators affect the state and therefore the future
values of the associated sequence.  The semantics of the operations on
generators and states are defined below.
</dl><pre><a name="31">(31)</a>
       function Random (Gen : Generator) return Uniformly_Distributed;
       function Random (Gen : Generator) return Result_Subtype;
</pre><dl><dt><a name="32">(32)</a><dd><ul>Obtains the ``next'' random number from the given generator,
relative to its current state, according to an implementation-defined
algorithm.  The result of the function in Numerics.Float_Random is
delivered as a value of the subtype Uniformly_Distributed, which is a
subtype of the predefined type Float having a range of 0.0 .. 1.0.
The result of the function in an instantiation of Numerics.Discrete_Random is delivered as a value of the generic formal subtype Result_Subtype.
</ul></dl><pre><a name="33">(33)</a>
       procedure Reset (Gen       : in Generator;
                        Initiator : in Integer);
       procedure Reset (Gen       : in Generator);
</pre><dl><dt><a name="34">(34)</a><dd><ul>Sets the state of the specified generator to one that is an
unspecified function of the value of the parameter Initiator (or to a
time-dependent state, if only a generator parameter is specified).
The latter form of the procedure is known as the time-dependent Reset
procedure.
</ul></dl><pre><a name="35">(35)</a>
       procedure Save  (Gen        : in  Generator;
                        To_State   : out State);
       procedure Reset (Gen        : in  Generator;
                        From_State : in  State);
</pre><dl><dt><a name="36">(36)</a><dd><ul>Save obtains the current state of a generator.  Reset gives a
generator the specified state.  A generator that is reset to a state
previously obtained by invoking Save is restored to the state it had
when Save was invoked.
</ul></dl><pre><a name="37">(37)</a>
       function Image (Of_State    : State)  return String;
       function Value (Coded_State : String) return State;
</pre><dl><dt><a name="38">(38)</a><dd><ul>Image provides a representation of a state coded (in an
implementation-defined way) as a string whose length is bounded by
the value of Max_Image_Width.  Value is the inverse of Image:
Value(Image(S)) = S for each state S that can be obtained from a
generator by invoking Save.
</ul></dl><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="39">(39)</a><dd>Instantiation of Numerics.Discrete_Random with a subtype having a null
range raises Constraint_Error.
<dt><a name="40">(40)</a><dd>Invoking Value with a string that is not the image of any generator
state raises Constraint_Error.
</dl><h5 align="center">Implementation Requirements</h5>
<dl><dt><a name="41">(41)</a><dd>A sufficiently long sequence of random numbers obtained by successive
calls to Random is approximately uniformly distributed over the range of the
result subtype.
<dt><a name="42">(42)</a><dd>The Random function in an instantiation of Numerics.Discrete_Random is
guaranteed to yield each value in its result subtype in a finite number of
calls, provided that the number of such values does not exceed 2**15.
<dt><a name="43">(43)</a><dd>Other performance requirements for the random number generator, which
apply only in implementations conforming to the Numerics Annex, and then only
in the ``strict'' mode defined there <a href="G-02.htm">(see G.2)</a>, are given <a href="G-02-05.htm">in G.2.5</a>.
</dl><h5 align="center">Documentation Requirements</h5>
<dl><dt><a name="44">(44)</a><dd>No one algorithm for random number generation is best for all
applications.  To enable the user to determine the suitability of the random
number generators for the intended application, the implementation shall
describe the algorithm used and shall give its period, if known exactly, or a
lower bound on the period, if the exact period is unknown.  Periods that are
so long that the periodicity is unobservable in practice can be described in
such terms, without giving a numerical bound.
<dt><a name="45">(45)</a><dd>The implementation also shall document the minimum time interval between
calls to the time-dependent Reset procedure that are guaranteed to initiate
different sequences, and it shall document the nature of the strings that
Value will accept without raising Constraint_Error.
</dl><h5 align="center">Implementation Advice</h5>
<dl><dt><a name="46">(46)</a><dd>Any storage associated with an object of type Generator should be
reclaimed on exit from the scope of the object.
<dt><a name="47">(47)</a><dd>If the generator period is sufficiently long in relation to the number
of distinct initiator values, then each possible value of Initiator passed to
Reset should initiate a sequence of random numbers that does not, in a
practical sense, overlap the sequence initiated by any other value.  If this
is not possible, then the mapping between initiator values and generator
states should be a rapidly varying function of the initiator value.
<p><dt><dd><ul>NOTES</ul>
<dt><a name="48">(48)</a><dd><ul>(14) If two or more tasks are to share the same generator, then the
tasks have to synchronize their access to the generator as for any
shared variable <a href="09-10.htm">(see 9.10)</a>.
</ul><dt><a name="49">(49)</a><dd><ul>(15) Within a given implementation, a repeatable random number sequence
can be obtained by relying on the implicit initialization of generators
or by explicitly initializing a generator with a repeatable initiator
value.  Different sequences of random numbers can be obtained from a
given generator in different program executions by explicitly
initializing the generator to a time-dependent state.
</ul><dt><a name="50">(50)</a><dd><ul>(16) A given implementation of the Random function in Numerics.Float_Random may or may not be capable of delivering the values 0.0 or 1.0.
Portable applications should assume that these values, or values
sufficiently close to them to behave indistinguishably from them, can
occur.  If a sequence of random integers from some fixed range is
needed, the application should use the Random function in an appropriate
instantiation of Numerics.Discrete_Random, rather than transforming the
result of the Random function in Numerics.Float_Random.  However, some
applications with unusual requirements, such as for a sequence of random
integers each drawn from a different range, will find it more convenient
to transform the result of the floating point Random function.  For
M&gt;=1, the expression
</ul></dl><pre><a name="51">(51)</a>
          Integer(Float(M) * Random(G)) mod M
</pre><dl><dt><a name="52">(52)</a><dd><ul>transforms the result of Random(G) to an integer uniformly
distributed over the range 0 .. M-1; it is valid even if Random delivers
0.0 or 1.0.  Each value of the result range is possible, provided that M
is not too large.  Exponentially distributed (floating point) random
numbers with mean and standard deviation 1.0 can be obtained by the
transformation
</ul></dl><pre><a name="53">(53)</a>
          -Log(Random(G) + Float'Model_Small))
</pre><dl><dt><a name="54">(54)</a><dd><ul>where Log comes from Numerics.Elementary_Functions <a href="A-05-01.htm">(see A.5.1)</a>; in
this expression, the addition of Float'Model_Small avoids the exception
that would be raised were Log to be given the value zero, without
affecting the result (in most implementations) when Random returns a
nonzero value.
</ul></dl><h5 align="center">Examples</h5>
<dl><dt><a name="55">(55)</a><dd><em>Example of a program that plays a simulated dice game:
</em>
</dl><pre><a name="56">(56)</a>
       with Ada.Numerics.Discrete_Random;
       procedure Dice_Game is
          subtype Die is Integer range 1 .. 6;
          subtype Dice is Integer range 2*Die'First .. 2*Die'Last;
          package Random_Die is new Ada.Numerics.Discrete_Random (Die);
          use Random_Die;
          G : Generator;
          D : Dice;
       begin
          Reset (G);  <em>-- Start the generator in a unique state in each run</em>
          loop
             <em>-- Roll a pair of dice; sum and process the results</em>
             D := Random(G) + Random(G);
             ...
          end loop;
       end Dice_Game;
</pre><dl><dt><a name="57">(57)</a><dd><em>Example of a program that simulates coin tosses:
</em>
</dl><pre><a name="58">(58)</a>
       with Ada.Numerics.Discrete_Random;
       procedure Flip_A_Coin is
          type Coin is (Heads, Tails);
          package Random_Coin is new Ada.Numerics.Discrete_Random (Coin);
          use Random_Coin;
          G : Generator;
       begin
          Reset (G);  <em>-- Start the generator in a unique state in each run</em>
          loop
             <em>-- Toss a coin and process the result</em>
             case Random(G) is
                 when Heads =&gt;
                    ...
                 when Tails =&gt;
                    ...
             end case;
          ...
          end loop;
       end Flip_A_Coin;
</pre><dl><dt><a name="59">(59)</a><dd><em>Example of a parallel simulation of a physical system, with a separate
generator of event probabilities in each task:
</em>
</dl><pre><a name="60">(60)</a>
       with Ada.Numerics.Float_Random;
       procedure Parallel_Simulation is
          use Ada.Numerics.Float_Random;
          task type Worker is
             entry Initialize_Generator (Initiator : in Integer);
             ...
          end Worker;
          W : array (1 .. 10) of Worker;
          task body Worker is
             G : Generator;
             Probability_Of_Event : Uniformly_Distributed;
          begin
             accept Initialize_Generator (Initiator : in Integer) do
                Reset (G, Initiator);
             end Initialize_Generator;
             loop
                ...
                Probability_Of_Event := Random(G);
                ...
             end loop;
          end Worker;
       begin
          <em>-- Initialize the generators in the Worker tasks to different states</em>
          for I in W'Range loop
             W(I).Initialize_Generator (I);
          end loop;
          ... <em>-- Wait for the Worker tasks to terminate</em>
       end Parallel_Simulation;
</pre><dl><p><dt><dd><ul>NOTES</ul>
<dt><a name="61">(61)</a><dd><ul>(17) Notes on the last example:  Although each Worker task initializes
its generator to a different state, those states will be the same in
every execution of the program.  The generator states can be initialized
uniquely in each program execution by instantiating Ada.Numerics.Discrete_Random for the type Integer in the main procedure, resetting
the generator obtained from that instance to a time-dependent state, and
then using random integers obtained from that generator to initialize
the generators in each Worker task.
</ul></dl><hr>
<h4><a href="A-05-01.htm"><img src="left.gif" alt="Prev"></a> | <a href="A-05.htm"><img src="up.gif" alt="Up"></a> | <a href="A-05-03.htm"><img src="right.gif" alt="Next"></a> | <a href="A-05-01.htm"><img src="back.gif" alt="Back"></a> | <a href="A-05-03.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
