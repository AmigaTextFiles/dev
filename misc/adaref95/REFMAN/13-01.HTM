<html>
<head>
<title>Ada 95 RM - 13.1 Representation Items</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><img src="noleft.gif" alt="____"> | <a href="13.htm"><img src="up.gif" alt="Up"></a> | <a href="13-02.htm"><img src="right.gif" alt="Next"></a> | <a href="13.htm"><img src="back.gif" alt="Back"></a> | <a href="13-02.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>

<h2><a name="0">13.1 Representation Items</a></h2>
<dl><dt><a name="1">(1)</a><dd>There are three kinds of representation items:  representation_clauses,
component_clauses, and representation pragmas.  Representation items specify
how the types and other entities of the language are to be mapped onto the
underlying machine.  They can be provided to give more efficient
representation or to interface with features that are outside the domain of
the language (for example, peripheral hardware).  Representation items also
specify other specifiable properties of entities.  A representation item
applies to an entity identified by a local_name, which denotes an entity
declared local to the current declarative region, or a library unit declared
immediately preceding a representation pragma in a compilation.
</dl><h5 align="center"><a name="syntax">Syntax</a></h5>
<pre><a name="2">(2)</a>
       representation_clause ::= attribute_definition_clause
             | enumeration_representation_clause
             | record_representation_clause
             | at_clause
<a name="3">(3)</a>
       local_name ::= direct_name
             | direct_name'attribute_designator
             | library_unit_name
</pre><dl><dt><a name="4">(4)</a><dd><ul><li>A representation pragma is allowed only at places where a
representation_clause or compilation_unit is allowed.
</ul></dl><h5 align="center">Name Resolution Rules</h5>
<dl><dt><a name="5">(5)</a><dd>In a representation item, if the local_name is a direct_name, then it
shall resolve to denote a declaration (or, in the case of a pragma, one or
more declarations) that occurs immediately within the same declarative_region
as the representation item.  If the local_name has an attribute_designator,
then it shall resolve to denote an implementation-defined component <a href="13-05-01.htm">(see 13.5.1)</a> or a class-wide type implicitly declared immediately within the same
declarative_region as the representation item.  A local_name that is a
library_unit_name (only permitted in a representation pragma) shall resolve
to denote the library_item that immediately precedes (except for other
pragmas) the representation pragma.
</dl><h5 align="center">Legality Rules</h5>
<dl><dt><a name="6">(6)</a><dd>The local_name of a representation_clause or representation pragma shall
statically denote an entity (or, in the case of a pragma, one or more
entities) declared immediately preceding it in a compilation, or within the
same declarative_part, package_specification, task_definition, protected_definition, or record_definition as the representation item.  If a local_name
denotes a local callable entity, it may do so through a local subprogram_renaming_declaration (as a way to resolve ambiguity in the presence of
overloading); otherwise, the local_name shall not denote a renaming_declaration.
<dt><a name="7">(7)</a><dd>The representation of an object consists of a certain number of bits (the
size of the object).  These are the bits that are normally read or updated by
the machine code when loading, storing, or operating-on the value of the
object.  This includes some padding bits, when the size of the object is
greater than the size of its subtype.  Such padding bits are considered to be
part of the representation of the object, rather than being gaps between
objects, if these bits are normally read and updated.
<dt><a name="8">(8)</a><dd>A representation item directly specifies an aspect of representation of
the entity denoted by the local_name, except in the case of a type-related
representation item, whose local_name shall denote a first subtype, and which
directly specifies an aspect of the subtype's type.  A representation item
that names a subtype is either subtype-specific (Size and Alignment clauses)
or type-related (all others).  Subtype-specific aspects may differ for
different subtypes of the same type.
<dt><a name="9">(9)</a><dd>A representation item that directly specifies an aspect of a subtype or
type shall appear after the type is completely defined <a href="03-11-01.htm">(see 3.11.1)</a>, and
before the subtype or type is frozen <a href="13-14.htm">(see 13.14)</a>.  If a representation item
is given that directly specifies an aspect of an entity, then it is illegal
to give another representation item that directly specifies the same aspect
of the entity.
<dt><a name="10">(10)</a><dd>For an untagged derived type, no type-related representation items are
allowed if the parent type is a by-reference type, or has any user-defined
primitive subprograms.
<dt><a name="11">(11)</a><dd>Representation aspects of a generic formal parameter are the same as
those of the actual.  A type-related representation item is not allowed for a
descendant of a generic formal untagged type.
<dt><a name="12">(12)</a><dd>A representation item that specifies the Size for a given subtype, or
the size or storage place for an object (including a component) of a given
subtype, shall allow for enough storage space to accommodate any value of the
subtype.
<dt><a name="13">(13)</a><dd>A representation item that is not supported by the implementation is
illegal, or raises an exception at run time.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="14">(14)</a><dd>If two subtypes statically match, then their subtype-specific aspects
(Size and Alignment) are the same.
<dt><a name="15">(15)</a><dd>A derived type inherits each type-related aspect of its parent type that
was directly specified before the declaration of the derived type, or (in the
case where the parent is derived) that was inherited by the parent type from
the grandparent type.  A derived subtype inherits each subtype-specific
aspect of its parent subtype that was directly specified before the
declaration of the derived type, or (in the case where the parent is derived)
that was inherited by the parent subtype from the grandparent subtype, but
only if the parent subtype statically matches the first subtype of the parent
type.  An inherited aspect of representation is overridden by a subsequent
representation item that specifies the same aspect of the type or subtype.
<dt><a name="16">(16)</a><dd>Each aspect of representation of an entity is as follows:
<dt><a name="17">(17)</a><dd><ul><li>If the aspect is specified for the entity, meaning that it is
either directly specified or inherited, then that aspect of the
entity is as specified, except in the case of Storage_Size, which
specifies a minimum.
</ul><dt><a name="18">(18)</a><dd><ul><li>If an aspect of representation of an entity is not specified, it
is chosen by default in an unspecified manner.
</ul></dl><h5 align="center">Dynamic Semantics</h5>
<dl><dt><a name="19">(19)</a><dd>For the elaboration of a representation_clause, any evaluable constructs
within it are evaluated.
</dl><h5 align="center">Implementation Permissions</h5>
<dl><dt><a name="20">(20)</a><dd>An implementation may interpret aspects of representation in an
implementation-defined manner.  An implementation may place implementation--
defined restrictions on representation items.  A recommended level of support
is specified for representation items and related features in each subclause.
These recommendations are changed to requirements for implementations that
support the Systems Programming Annex <a href="C-02.htm">(see C.2</a>, ``Required Representation
Support'').
</dl><h5 align="center">Implementation Advice</h5>
<dl><dt><a name="21">(21)</a><dd>The recommended level of support for all representation items is
qualified as follows:
<dt><a name="22">(22)</a><dd><ul><li>An implementation need not support representation items
containing nonstatic expressions, except that an implementation
should support a representation item for a given entity if each
nonstatic expression in the representation item is a name that
statically denotes a constant declared before the entity.
</ul><dt><a name="23">(23)</a><dd><ul><li>An implementation need not support a specification for the Size
for a given composite subtype, nor the size or storage place for
an object (including a component) of a given composite subtype,
unless the constraints on the subtype and its composite
subcomponents (if any) are all static constraints.
</ul><dt><a name="24">(24)</a><dd><ul><li>An aliased component, or a component whose type is by-reference,
should always be allocated at an addressable location.
</ul></dl><p>
<hr>
<h4><img src="noleft.gif" alt="____"> | <a href="13.htm"><img src="up.gif" alt="Up"></a> | <a href="13-02.htm"><img src="right.gif" alt="Next"></a> | <a href="13.htm"><img src="back.gif" alt="Back"></a> | <a href="13-02.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
