<html>
<head>
<title>Ada 95 RM - A.4.3 Fixed-Length String Handling</title>
<link rev="made" href="mailto:Magnus.Kempe@di.epfl.ch">
</head>

<body>
<h4><a href="A-04-02.htm"><img src="left.gif" alt="Prev"></a> | <a href="A-04.htm"><img src="up.gif" alt="Up"></a> | <a href="A-04-04.htm"><img src="right.gif" alt="Next"></a> | <a href="A-04-02.htm"><img src="back.gif" alt="Back"></a> | <a href="A-04-04.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<hr>
<h3><a name="0">A.4.3 Fixed-Length String Handling</a></h3>
<dl><dt><a name="1">(1)</a><dd>The language-defined package Strings.Fixed provides string-handling
subprograms for fixed-length strings; that is, for values of type
Standard.String.  Several of these subprograms are procedures that modify the
contents of a String that is passed as an out or an in out parameter; each
has additional parameters to control the effect when the logical length of
the result differs from the parameter's length.
<dt><a name="2">(2)</a><dd>For each function that returns a String, the lower bound of the returned
value is 1.
<dt><a name="3">(3)</a><dd>The basic model embodied in the package is that a fixed-length string
comprises significant characters and possibly padding (with space characters)
on either or both ends.  When a shorter string is copied to a longer string,
padding is inserted, and when a longer string is copied to a shorter one,
padding is stripped.  The Move procedure in Strings.Fixed, which takes a
String as an out parameter, allows the programmer to control these effects.
Similar control is provided by the string transformation procedures.
</dl><h5 align="center">Static Semantics</h5>
<dl><dt><a name="4">(4)</a><dd>The library package Strings.Fixed has the following declaration:
</dl><pre><a name="5">(5)</a>
       with Ada.Strings.Maps;
       package Ada.Strings.Fixed is
          pragma Preelaborate(Fixed);
<a name="6">(6)</a>
       <em>-- "Copy" procedure for strings of possibly different lengths</em>
<a name="7">(7)</a>
          procedure Move (Source  : in  String;
                          Target  : out String;
                          Drop    : in  Truncation := Error;
                          Justify : in  Alignment  := Left;
                          Pad     : in  Character  := Space);
<a name="8">(8)</a>
       <em>-- Search subprograms</em>
<a name="9">(9)</a>
          function Index (Source   : in String;
                          Pattern  : in String;
                          Going    : in Direction := Forward;
                          Mapping  : in Maps.Character_Mapping
                                       := Maps.Identity)
             return Natural;
<a name="10">(10)</a>
          function Index (Source   : in String;
                          Pattern  : in String;
                          Going    : in Direction := Forward;
                          Mapping  : in Maps.Character_Mapping_Function)
             return Natural;
<a name="11">(11)</a>
          function Index (Source : in String;
                          Set    : in Maps.Character_Set;
                          Test   : in Membership := Inside;
                          Going  : in Direction  := Forward)
             return Natural;
<a name="12">(12)</a>
          function Index_Non_Blank (Source : in String;
                                    Going  : in Direction := Forward)
             return Natural;
<a name="13">(13)</a>
          function Count (Source   : in String;
                          Pattern  : in String;
                          Mapping  : in Maps.Character_Mapping
                                        := Maps.Identity)
             return Natural;
<a name="14">(14)</a>
          function Count (Source   : in String;
                          Pattern  : in String;
                          Mapping  : in Maps.Character_Mapping_Function)
             return Natural;
<a name="15">(15)</a>
          function Count (Source   : in String;
                          Set      : in Maps.Character_Set)
             return Natural;
<a name="16">(16)</a>
          procedure Find_Token (Source : in String;
                                Set    : in Maps.Character_Set;
                                Test   : in Membership;
                                First  : out Positive;
                                Last   : out Natural);
<a name="17">(17)</a>
       <em>-- String translation subprograms</em>
<a name="18">(18)</a>
          function Translate (Source  : in String;
                              Mapping : in Maps.Character_Mapping)
             return String;
<a name="19">(19)</a>
          procedure Translate (Source  : in out String;
                               Mapping : in Maps.Character_Mapping);
<a name="20">(20)</a>
          function Translate (Source  : in String;
                              Mapping : in Maps.Character_Mapping_Function)
             return String;
<a name="21">(21)</a>
          procedure Translate (Source  : in out String;
                               Mapping : in Maps.Character_Mapping_Function);
<a name="22">(22)</a>
       <em>-- String transformation subprograms</em>
<a name="23">(23)</a>
          function Replace_Slice (Source   : in String;
                                  Low      : in Positive;
                                  High     : in Natural;
                                  By       : in String)
             return String;
<a name="24">(24)</a>
          procedure Replace_Slice (Source   : in out String;
                                   Low      : in Positive;
                                   High     : in Natural;
                                   By       : in String;
                                   Drop     : in Truncation := Error;
                                   Justify  : in Alignment  := Left;
                                   Pad      : in Character  := Space);
<a name="25">(25)</a>
          function Insert (Source   : in String;
                           Before   : in Positive;
                           New_Item : in String)
             return String;
<a name="26">(26)</a>
          procedure Insert (Source   : in out String;
                            Before   : in Positive;
                            New_Item : in String;
                            Drop     : in Truncation := Error);
<a name="27">(27)</a>
          function Overwrite (Source   : in String;
                              Position : in Positive;
                              New_Item : in String)
             return String;
<a name="28">(28)</a>
          procedure Overwrite (Source   : in out String;
                               Position : in Positive;
                               New_Item : in String;
                               Drop     : in Truncation := Right);
<a name="29">(29)</a>
          function Delete (Source  : in String;
                           From    : in Positive;
                           Through : in Natural)
             return String;
<a name="30">(30)</a>
          procedure Delete (Source  : in out String;
                            From    : in Positive;
                            Through : in Natural;
                            Justify : in Alignment := Left;
                            Pad     : in Character := Space);
<a name="31">(31)</a>
        <em>--String selector subprograms</em>
          function Trim (Source : in String;
                         Side   : in Trim_End)
             return String;
<a name="32">(32)</a>
          procedure Trim (Source  : in out String;
                          Side    : in Trim_End;
                          Justify : in Alignment := Left;
                          Pad     : in Character := Space);
<a name="33">(33)</a>
          function Trim (Source : in String;
                         Left   : in Maps.Character_Set;
                         Right  : in Maps.Character_Set)
             return String;
<a name="34">(34)</a>
          procedure Trim (Source  : in out String;
                          Left    : in Maps.Character_Set;
                          Right   : in Maps.Character_Set;
                          Justify : in Alignment := Strings.Left;
                          Pad     : in Character := Space);
<a name="35">(35)</a>
          function Head (Source : in String;
                         Count  : in Natural;
                         Pad    : in Character := Space)
             return String;
<a name="36">(36)</a>
          procedure Head (Source  : in out String;
                          Count   : in Natural;
                          Justify : in Alignment := Left;
                          Pad     : in Character := Space);
<a name="37">(37)</a>
          function Tail (Source : in String;
                         Count  : in Natural;
                         Pad    : in Character := Space)
             return String;
<a name="38">(38)</a>
          procedure Tail (Source  : in out String;
                          Count   : in Natural;
                          Justify : in Alignment := Left;
                          Pad     : in Character := Space);
<a name="39">(39)</a>
       <em>--String constructor functions</em>
<a name="40">(40)</a>
          function "*" (Left  : in Natural;
                        Right : in Character) return String;
<a name="41">(41)</a>
          function "*" (Left  : in Natural;
                        Right : in String) return String;
<a name="42">(42)</a>
       end Ada.Strings.Fixed;
</pre><dl><dt><a name="43">(43)</a><dd>The effects of the above subprograms are as follows.
</dl><pre><a name="44">(44)</a>
       procedure Move (Source  : in  String;
                       Target  : out String;
                       Drop    : in  Truncation := Error;
                       Justify : in  Alignment  := Left;
                       Pad     : in  Character  := Space);
</pre><dl><dt><a name="45">(45)</a><dd><ul>The Move procedure copies characters from Source to Target.  If
Source has the same length as Target, then the effect is to assign
Source to Target.  If Source is shorter than Target then:
</ul><dt><a name="46">(46)</a><dd><ul><ul><li>If Justify=Left, then Source is copied into the first
Source'Length characters of Target.
</ul></ul><dt><a name="47">(47)</a><dd><ul><ul><li>If Justify=Right, then Source is copied into the last
Source'Length characters of Target.
</ul></ul><dt><a name="48">(48)</a><dd><ul><ul><li>If Justify=Center, then Source is copied into the middle
Source'Length characters of Target.  In this case, if the
difference in length between Target and Source is odd,
then the extra Pad character is on the right.
</ul></ul><dt><a name="49">(49)</a><dd><ul><ul><li>Pad is copied to each Target character not otherwise
assigned.
</ul></ul><dt><a name="50">(50)</a><dd><ul>If Source is longer than Target, then the effect is based on
Drop.
</ul><dt><a name="51">(51)</a><dd><ul><ul><li>If Drop=Left, then the rightmost Target'Length characters
of Source are copied into Target.
</ul></ul><dt><a name="52">(52)</a><dd><ul><ul><li>If Drop=Right, then the leftmost Target'Length characters
of Source are copied into Target.
</ul></ul><dt><a name="53">(53)</a><dd><ul><ul><li>If Drop=Error, then the effect depends on the value of
the Justify parameter and also on whether any characters
in Source other than Pad would fail to be copied:
</ul></ul><dt><a name="54">(54)</a><dd><ul><ul><ul><li>If Justify=Left, and if each of the rightmost
Source'Length-Target'Length characters in Source
is Pad, then the leftmost Target'Length characters
of Source are copied to Target.
</ul></ul></ul><dt><a name="55">(55)</a><dd><ul><ul><ul><li>If Justify=Right, and if each of the leftmost
Source'Length-Target'Length characters in Source
is Pad, then the rightmost Target'Length
characters of Source are copied to Target.
</ul></ul></ul><dt><a name="56">(56)</a><dd><ul><ul><ul><li>Otherwise, Length_Error is propagated.
</ul></ul></ul></dl><pre><a name="57">(57)</a>
       function Index (Source   : in String;
                       Pattern  : in String;
                       Going    : in Direction := Forward;
                       Mapping  : in Maps.Character_Mapping
                                     := Maps.Identity)
          return Natural;

       function Index (Source   : in String;
                       Pattern  : in String;
                       Going    : in Direction := Forward;
                       Mapping  : in Maps.Character_Mapping_Function)
          return Natural;
</pre><dl><dt><a name="58">(58)</a><dd><ul>Each Index function searches for a slice of Source, with length
Pattern'Length, that matches Pattern with respect to Mapping; the
parameter Going indicates the direction of the lookup.  If Going =
Forward, then Index returns the smallest index I such that the slice
of Source starting at I matches Pattern.  If Going = Backward, then
Index returns the largest index I such that the slice of Source
starting at I matches Pattern.  If there is no such slice, then 0 is
returned.  If Pattern is the null string then Pattern_Error is
propagated.
</ul></dl><pre><a name="59">(59)</a>
       function Index (Source : in String;
                       Set    : in Maps.Character_Set;
                       Test   : in Membership := Inside;
                       Going  : in Direction  := Forward)
          return Natural;
</pre><dl><dt><a name="60">(60)</a><dd><ul>Index searches for the first or last occurrence of any of a set
of characters (when Test=Inside), or any of the complement of a set
of characters (when Test=Outside).  It returns the smallest index I
(if Going=Forward) or the largest index I (if Going=Backward) such
that Source(I) satisfies the Test condition with respect to Set; it
returns 0 if there is no such Character in Source.
</ul></dl><pre><a name="61">(61)</a>
       function Index_Non_Blank (Source : in String;
                                 Going  : in Direction := Forward)
          return Natural;
</pre><dl><dt><a name="62">(62)</a><dd><ul>Returns Index(Source, Maps.To_Set(Space), Outside, Going)
</ul></dl><pre><a name="63">(63)</a>
       function Count (Source   : in String;
                       Pattern  : in String;
                       Mapping  : in Maps.Character_Mapping
                                    := Maps.Identity)
          return Natural;

       function Count (Source   : in String;
                       Pattern  : in String;
                       Mapping  : in Maps.Character_Mapping_Function)
          return Natural;
</pre><dl><dt><a name="64">(64)</a><dd><ul>Returns the maximum number of nonoverlapping slices of Source
that match Pattern with respect to Mapping.  If Pattern is the null
string then Pattern_Error is propagated.
</ul></dl><pre><a name="65">(65)</a>
       function Count (Source   : in String;
                       Set      : in Maps.Character_Set)
          return Natural;
</pre><dl><dt><a name="66">(66)</a><dd><ul>Returns the number of occurrences in Source of characters that
are in Set.
</ul></dl><pre><a name="67">(67)</a>
       procedure Find_Token (Source : in String;
                             Set    : in Maps.Character_Set;
                             Test   : in Membership;
                             First  : out Positive;
                             Last   : out Natural);
</pre><dl><dt><a name="68">(68)</a><dd><ul>Find_Token returns in First and Last the indices of the
beginning and end of the first slice of Source all of whose elements
satisfy the Test condition, and such that the elements (if any)
immediately before and after the slice do not satisfy the Test
condition.  If no such slice exists, then the value returned for Last
is zero, and the value returned for First is Source'First.
</ul></dl><pre><a name="69">(69)</a>
       function Translate (Source  : in String;
                           Mapping : in Maps.Character_Mapping)
          return String;

       function Translate (Source  : in String;
                           Mapping : in Maps.Character_Mapping_Function)
          return String;
</pre><dl><dt><a name="70">(70)</a><dd><ul>Returns the string S whose length is Source'Length and such that
S(I) is the character to which Mapping maps the corresponding element
of Source, for I in 1..Source'Length.
</ul></dl><pre><a name="71">(71)</a>
       procedure Translate (Source  : in out String;
                            Mapping : in Maps.Character_Mapping);

       procedure Translate (Source  : in out String;
                            Mapping : in Maps.Character_Mapping_Function);
</pre><dl><dt><a name="72">(72)</a><dd><ul>Equivalent to Source := Translate(Source, Mapping).
</ul></dl><pre><a name="73">(73)</a>
       function Replace_Slice (Source   : in String;
                               Low      : in Positive;
                               High     : in Natural;
                               By       : in String)
          return String;
</pre><dl><dt><a name="74">(74)</a><dd><ul>If Low &gt; Source'Last+1, or High &lt; Source'First-1, then Index_Error is propagated.  Otherwise, if High &gt;= Low then the returned
string comprises Source(Source'First..Low-1) &amp; By &amp;
Source(High+1..Source'Last), and if High &lt; Low then the returned
string is Insert(Source, Before=&gt;Low, New_Item=&gt;By).
</ul></dl><pre><a name="75">(75)</a>
       procedure Replace_Slice (Source   : in out String;
                                Low      : in Positive;
                                High     : in Natural;
                                By       : in String;
                                Drop     : in Truncation := Error;
                                Justify  : in Alignment  := Left;
                                Pad      : in Character  := Space);
</pre><dl><dt><a name="76">(76)</a><dd><ul>Equivalent to Move(Replace_Slice(Source, Low, High, By), Source,
Drop, Justify, Pad).
</ul></dl><pre><a name="77">(77)</a>
       function Insert (Source   : in String;
                        Before   : in Positive;
                        New_Item : in String)
          return String;
</pre><dl><dt><a name="78">(78)</a><dd><ul>Propagates Index_Error if Before is not in Source'First ..
Source'Last+1; otherwise returns Source(Source'First..Before-1) &amp;
New_Item &amp; Source(Before..Source'Last), but with lower bound 1.
</ul></dl><pre><a name="79">(79)</a>
       procedure Insert (Source   : in out String;
                         Before   : in Positive;
                         New_Item : in String;
                         Drop     : in Truncation := Error);
</pre><dl><dt><a name="80">(80)</a><dd><ul>Equivalent to Move(Insert(Source, Before, New_Item), Source,
Drop).
</ul></dl><pre><a name="81">(81)</a>
       function Overwrite (Source   : in String;
                           Position : in Positive;
                           New_Item : in String)
          return String;
</pre><dl><dt><a name="82">(82)</a><dd><ul>Propagates Index_Error if Position is not in Source'First ..
Source'Last+1; otherwise returns the string obtained from Source by
consecutively replacing characters starting at Position with
corresponding characters from New_Item.  If the end of Source is
reached before the characters in New_Item are exhausted, the
remaining characters from New_Item are appended to the string.
</ul></dl><pre><a name="83">(83)</a>
       procedure Overwrite (Source   : in out String;
                            Position : in Positive;
                            New_Item : in String;
                            Drop     : in Truncation := Right);
</pre><dl><dt><a name="84">(84)</a><dd><ul>Equivalent to Move(Overwrite(Source, Position, New_Item),
Source, Drop).
</ul></dl><pre><a name="85">(85)</a>
       function Delete (Source  : in String;
                        From    : in Positive;
                        Through : in Natural)
          return String;
</pre><dl><dt><a name="86">(86)</a><dd><ul>If From &lt;= Through, the returned string is Replace_Slice(Source,
From, Through, ""), otherwise it is Source.
</ul></dl><pre><a name="87">(87)</a>
       procedure Delete (Source  : in out String;
                         From    : in Positive;
                         Through : in Natural;
                         Justify : in Alignment := Left;
                         Pad     : in Character := Space);
</pre><dl><dt><a name="88">(88)</a><dd><ul>Equivalent to Move(Delete(Source, From, Through), Source,
Justify =&gt; Justify, Pad =&gt; Pad).
</ul></dl><pre><a name="89">(89)</a>
       function Trim (Source : in String;
                      Side   : in Trim_End)
         return String;
</pre><dl><dt><a name="90">(90)</a><dd><ul>Returns the string obtained by removing from Source all leading
Space characters (if Side = Left), all trailing Space characters (if
Side = Right), or all leading and trailing Space characters (if Side
= Both).
</ul></dl><pre><a name="91">(91)</a>
       procedure Trim (Source  : in out String;
                       Side    : in Trim_End;
                       Justify : in Alignment := Left;
                       Pad     : in Character := Space);
</pre><dl><dt><a name="92">(92)</a><dd><ul>Equivalent to Move(Trim(Source, Side), Source, Justify=&gt;Justify,
Pad=&gt;Pad).
</ul></dl><pre><a name="93">(93)</a>
       function Trim (Source : in String;
                      Left   : in Maps.Character_Set;
                      Right  : in Maps.Character_Set)
          return String;
</pre><dl><dt><a name="94">(94)</a><dd><ul>Returns the string obtained by removing from Source all leading
characters in Left and all trailing characters in Right.
</ul></dl><pre><a name="95">(95)</a>
       procedure Trim (Source  : in out String;
                       Left    : in Maps.Character_Set;
                       Right   : in Maps.Character_Set;
                       Justify : in Alignment := Strings.Left;
                       Pad     : in Character := Space);
</pre><dl><dt><a name="96">(96)</a><dd><ul>Equivalent to Move(Trim(Source, Left, Right), Source, Justify =&gt;
Justify, Pad=&gt;Pad).
</ul></dl><pre><a name="97">(97)</a>
       function Head (Source : in String;
                      Count  : in Natural;
                      Pad    : in Character := Space)
          return String;
</pre><dl><dt><a name="98">(98)</a><dd><ul>Returns a string of length Count.  If Count &lt;= Source'Length,
the string comprises the first Count characters of Source.  Otherwise
its contents are Source concatenated with Count-Source'Length Pad
characters.
</ul></dl><pre><a name="99">(99)</a>
       procedure Head (Source  : in out String;
                       Count   : in Natural;
                       Justify : in Alignment := Left;
                       Pad     : in Character := Space);
</pre><dl><dt><a name="100">(100)</a><dd><ul>Equivalent to Move(Head(Source, Count, Pad), Source,
Drop=&gt;Error, Justify=&gt;Justify, Pad=&gt;Pad).
</ul></dl><pre><a name="101">(101)</a>
       function Tail (Source : in String;
                      Count  : in Natural;
                      Pad    : in Character := Space)
          return String;
</pre><dl><dt><a name="102">(102)</a><dd><ul>Returns a string of length Count.  If Count &lt;= Source'Length,
the string comprises the last Count characters of Source.  Otherwise
its contents are Count-Source'Length Pad characters concatenated with
Source.
</ul></dl><pre><a name="103">(103)</a>
       procedure Tail (Source  : in out String;
                       Count   : in Natural;
                       Justify : in Alignment := Left;
                       Pad     : in Character := Space);
</pre><dl><dt><a name="104">(104)</a><dd><ul>Equivalent to Move(Tail(Source, Count, Pad), Source,
Drop=&gt;Error, Justify=&gt;Justify, Pad=&gt;Pad).
</ul></dl><pre><a name="105">(105)</a>
       function "*" (Left  : in Natural;
                     Right : in Character) return String;

       function "*" (Left  : in Natural;
                     Right : in String) return String;
</pre><dl><dt><a name="106">(106)</a><dd><ul>These functions replicate a character or string a specified
number of times.  The first function returns a string whose length is
Left and each of whose elements is Right.  The second function
returns a string whose length is Left*Right'Length and whose value is
the null string if Left = 0 and is (Left-1)*Right &amp; Right otherwise.
</ul><p><dt><dd><ul>NOTES</ul>
<dt><a name="107">(107)</a><dd><ul>(9) In the Index and Count functions taking Pattern and Mapping
parameters, the actual String parameter passed to Pattern should
comprise characters occurring as target characters of the mapping.
Otherwise the pattern will not match.
</ul><dt><a name="108">(108)</a><dd><ul>(10) In the Insert subprograms, inserting at the end of a string is
obtained by passing Source'Last+1 as the Before parameter.
</ul><dt><a name="109">(109)</a><dd><ul>(11) If a null Character_Mapping_Function is passed to any of the string
handling subprograms, Constraint_Error is propagated.
</ul></dl><hr>
<h4><a href="A-04-02.htm"><img src="left.gif" alt="Prev"></a> | <a href="A-04.htm"><img src="up.gif" alt="Up"></a> | <a href="A-04-04.htm"><img src="right.gif" alt="Next"></a> | <a href="A-04-02.htm"><img src="back.gif" alt="Back"></a> | <a href="A-04-04.htm"><img src="forward.gif" alt="Forward"></a><br>   <a href="toc.htm">TOC --</a> / <a href="toc-l1.htm">--.--</a> / <a href="toc-l2.htm">--.--.--</a> | <a href="index.htm">Index</a> | <a href="search.htm">Search</a> | <a href="syntax.htm">Syntax</a> | <a href="help.htm">Help</a></h4>

<p>
<a href="http://lglwww.epfl.ch/Ada/"><img src="la-icon.gif" alt="Ada WWW Home"></a>
 -- Email comments, additions, corrections, gripes, kudos, etc. to:
<address>
<a href="author.htm">Magnus Kempe</a>
 -- <a href="mailto:Magnus.Kempe@di.epfl.ch">Magnus.Kempe@di.epfl.ch</a><br>
<a href="cright.htm">Copyright statement</a><br>
Page last generated: 95-03-12
</address>
</body>
</html>
