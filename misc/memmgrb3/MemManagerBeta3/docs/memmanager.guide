@database memmanager
@author Robert Ennals
@(c) 1996 Robert Ennals

@node main "MemManager by Robert Ennals"

MemManager

by Robert Ennals (ennals@aol.com)


Version 3.13 beta


Note : This is a public beta release of MemManager.

Although you are free to use and distrubute it, you should bear in mind that
not all features have been implemented yet (eg resource tracking and memory
protection) and there may be some bugs in it. Any bug reports should be sent
to me at ennals@aol.com.

@{"Release notes" link beta}


Contents

Users

@{"Introduction     " link intro}
@{"Features         " link features}
@{"Setup            " link setup}
@{"User Licence     " link userlicence}

Developers

@{"Functions        " link functions}
@{"Usage            " link usage}
@{"Tips             " link tips}
@{"Developer Licence" link devlicence}

Misc

@{"MemManager compared with other systems         " link compare}
@{"Example of MemManager beating MMU based systems" link examplemmufail}
@{"How MemManager provides resource tracking      " link restrack}
@{"How MemManager provides memory protection      " link protect}
@{"About the author                               " link author}
@{"How MemManager was created                     " link creation}

@{"Patches planned to make the OS take advantage of MemManager" link patch}


@endnode

@node beta "Release notes"

Beta Notes

This is the third public beta of MemManager. Not all features have been
implemented, and there may be some bugs. The final version (non beta) will
have more features and will run faster.

The beta version can still be used in your programs and I encourage you to
do so, but you should bear in mind that it is not yet completely finished.


* MemManager is now free

As of this version, the registration system has been dropped and MemManager
has been made totally free. It was decided that a forced registration system
was unworkable. Click {"here" link devlicence} for more information.


* VMemPatch

Several bugs have ben fixed over previous beta releases, including several
with the vmempatch program. VmemPatch may still be unstable so please report
any strange things it does.

If something does not work with the patch installed, try it without.

VmemPatch is not required for MemManager to run. All it currently does is to
make MemManager free memory when other tasks need it.


* C includes have been improved

The C include files for MemManager have been improved. If you want to make
further improvements for them, or adapt them to be usable with a compiler
they currently do not support then please do and mail me your improvements.

Note also that memmanager.lib has beem dropped from the distribution. This
was because many people got confused by it's not working on all compilers
(it was a DICE lib). Any compilers that need libs will come with utils to
generate them anyway.


* Back down to one library

testmemmanager.library has been dropped as the forced registration system
has been removed thus making it obselete. This also has the nice effect of
making the MemManager distribution smaller :-))


@endnode

@node intro "An Introduction to MemManager"
				
An Introduction to MemManager.


MemManager allows programers to use several advanced memory management
methods in theri programs while not requiring any specific hardware.

MemManager cannot give memory management features to programs that are not
written to use it, but adapting a program to use MemManager is very
easy :-))

Perhaps the most significant feature is virtual memory objects. These allow
programs to use more memory than the machine they are running on has by
paging unused memory to disk.

To see the full list of features click @{"here" link features}.

A patch for allocmem is provided to allow memmanager to cooperate with
tasks that allocate mem outside MemManager. If memory gets low MemManager
will give up some memory to allow other allocations to succeed.

Although virtual memory systems have existed before MemManager (eg VMM and
GigaMem) these have all been MMU based, requiring special hardware and
having several @{"disadvantages" link compare} over MemManager.


It is very easy for programmers to use the MemManager library in their
programs. It should be possible to add memmanager features to an existing
program in a matter of minutes. All you need to do is to replace some exec
functions with MemManager ones and tell MemManager when you need to have
memory lcoked.

@endnode

@node features "Features of MemManager"

Features of MemManager

* Virtual Memory
    Allocate more memory than is present on a machine by moving unlocked
    memory to disk.

* Diposable Memory
    Make full use of all available memory. Disposable memory blocks are
    freed when memory gets low.

* Memory Priorities
    Allow MemManager to make intelligent descisions about what to remove
    from memory.

* Memory Hierachies
    Specify a strict memory hierachy. Allows control over the order in which
    blocks are removed from memory.

* MMU not required (except for Memory Protection).
    Works on ANY Amiga (hard disk recommended for Virtual memory).
    This allows programmers to use the features of MemManager without
    stopping their programs from running on all machines.


Features not yet implemented

* @{"Memory Protection" link protect}
    Uses the MMU to prevent tasks from accessing memory they haven't locked.

* @{"Resource Tracking" link restrack}
    When a task crashes, all MemManager blocks allocated by that tasks and
    not published to or locked by other tasks is freed automatically.

* ChipToFast
    Swaps chip ram blocks into fast memory when they are unlocked.

* VMem pools
    A VMem equivalent of the memory pools of exec.library. To be used for
    allocation of small sized items.

@{"MemManager compared with other systems" link compare}

@endnode

@node setup "Setting up MemManager to work on your machine"

Setting up MemManager to work on your machine.


There are only two things you need to do to make MemManager work on your
machine. Add VMemPatch (available in this distibution) to your user-startup
file and assign VMemTemp: to somewhere to put temporary files.

Note that vmemPatch may have bugs in it, so if you eperience problems with
MemManager, try it without vmempatch.

    

The location of VMemTemp: MUST be an uncompressed hard disk or equivalent.
Do not assign it to any of the following:


* Do NOT assign it to Ram:

The RAM disk is stored in memory, thus moving memory into Ram: in low memory
situations will not help. Doing this is likely to cause a deadlock and
should NOT be done.


* Do NOT assign it to a compressed drive

Disk compressers need to allocate memory, often quite a lot of it in order
to compress files to be written to them. Seeing as files will usually be
saved to VMemTemp: in low memory situations unpredictable things may happen.
If you use compression with your hard disk then ensure that anything written
to VMemTemp: will not be compressed.

If you use a directory specific compressor then don't compress the directory
VMemTemp: is assigned to.

If you use EPU then turn off SAVE compression for the drive and compress
files manually instead.

Note that MemManager is not alone in not using compressed drives for
temporary files. Windows cannot do this either.

Besides being a little unsafe, using a compressed drive for temporary files
will also significantly slow down the working of MemManager.



You can assign VMemTemp: to network drives, but each machine must store it's
temporary files in a different directory or you will experience filename
conflicts.

You can assign VMemTemp: to a removable media, but if you do so you must not
remove it.



MemManager automatically deletes all files with the suffix ".mem" when it is
started so that if your machine crashed earlier and left temporary files in
VMemTemp: they do not continue to take up disk space.

@endnode

@node userlicence "User Licence for MemManager"

User Licence for MemManager


MemManager is completely free for users.
The memmanager library may not be distributed without the rest of the
MemManager distribution (including this doc and the developer info) without
my (Robert Ennals) permission.

I cannot be held responsible for any damage that MemManager may cause (not
that it will).

@endnode
    
@node devlicence "Developer Licence for MemManager"

Developer Licence for MemManager


The forced registration process used in previous beta versions of MemManager
has now been dropped as it became clear that it was not going to be
workable.

Developers are free to use MemManager in their programs in whatever way they
like. The only restrictiona ae the following:

* MemManager should be mentioned on the first page of any AmigaGuide
    documentation. Include a message such as "Myprogram uses MemManager by
    Robert Ennals"

* MemManager should be mentioned in the about requester if relevent.

* MemManager should be mentioned in any adverts for products that use it.

* If you write a program that uses MemManager then you should inform
    {"me" link Author}. I like to know what people are doing with
    MemManager.



Although no donations are required to be able to use MemManager in ypour
programs, they are very welcome. Click {"here" link Author} for information
on how you may do this.

The more support I receive for MemManager, the better it will become!


@endnode

@node functions "Functions"

Functions

For information on the functions in memmanager.library please refer to the
memmanager Autodoc. This can be read in a text editor, an AutoDoc browser,
or be converted to a guide file (with utils on AmiNet) and read with
MultiView or AmigaGuide.

The following is a brief summary of what they do. Read the autodoc for more
info.


CreateVMem - Create a vmemblock
RemoveVMem - Remove a vmemblock
LockVMem - lock a vmem block into memory
UnlockVMem - unlock a block
DefineVMemHierachy - specify what you be removed from memory first.
ClearVMemHierachy - remove items from their hierachies
ChangeVMemPri - Change the priority of vmem (usually 0)
ChangeVMemType - Change the type of vmem
Publish - Turn off memory protection and resource tracking (make public)
Protect - Turn back on memory protection and resource tracking for a block.


@endnode

@node Usage "Usage"

How to use memmanager.library


Usually you use of an object will follow the following pattern.
(in fake code)

    BEGIN subroutine
	CreateVMem
	    LOOP
		LockVMem
		[use memory object]
		UnlockVMem
	    END LOOP
	RemoveVMem
    END

Generally you should use CreateVMem as where you would use AllocMem. You use
RemoveVMem where you would use FreeMem, and you lock memory whenever you
need to use it.

Try to always have as little memory locked as possible. If you are certain
to need an object very soon, don't lock it, but give it a high priority.


You should use DefineVMemHierachy and ChangeVMemPri to tell MemManager which
objects should be removed from memory first. Use DefineVMemHierachy for
differentiating between your own objects of the same priority and use
ChangeVMemPri for making your objects more or less important than objects
owned by other tasks. Although you can also use ChangeVmemPri for
differentiating between your own objects, DefineVMemHierachy is usually
better for this.

The most common use of ChangeVMemPriority is to make an object low priority
after it has ben converted to disposable with ChanageVMemType.

@endnode

@node tips "Tips"

Tips


This section is likely to grow with future versions of this document.


> Make full use of disposable memory

Never throw data away if you might need it again. Instead make it disposable
and give it a low priority (and perhaps put it in a hierachy). Let
memmanager decide what needs throwing away.

In a perfect situation, where disposable memory is being well used, all your
memory will be in use most of the time.

Examples of things to make disposable (there are many others)
    * Font Caches
    * Undo data (in a hierachy to make newer data superior)
    * Zoom views of objects (eg in a DTP program)
    * Unedited text buffers and images.
    * Anything you can recalculate or is already on disk.


> Lock as little as possible

The less you lock, the less likely it is that all physical memory will be
used up. Only have locked what you are working on at the current time and
things that have been made public.

You may think that all your users have enough memory for you to have x bytes
locked, but they might be running your program at the same time as many
other things. Locking and unlocking is very quick (only a few cycles) if
a block is in memory so there is no excuse for having too much locked.


> Make use of Hierachies

Hierachies let you help memmanager decide what to remove from memory first.
Correct use of hierachies can speed of some programs massively. The hierachy
should reflect how likely you are to lock an object soon. Eg if you are
going through several blocks in order, those you will reach first should be
first in the hierachy and those you have finished with should be at the end.


> Don't allocate lots of very small vmem objects.

MemManager needs to set away some space for the header data of every block
you use, so if you allocate very small objects you will be wasting space. if
you need to allocate lots of very small objects of the same size then
allocate space for an array of them and use that.

Future versions of memmanager should have a system called vmem pools that
will do this sort of thing automatically, but for the time being allocating
arrays is the best method.


> Always Publish vmem blocks before giving out pointer to them

Publishing a block turns off things like memory protection and resource
tracking and makes your memory block equivalent to public memory as
allocated with exec.library/AllocMem.

Protect the vmem block again once you are sure that no other tasks have
pointers to it.


> Use MemManager in BOOPSI objects

MemManager can be used to handle the instance data of objects. If objects
require quite a bit of instance data, or you lump the instance data of
several objects into larger blocks then this can give very good results.


> If you can't work out how to do something ask me

I (Robert Ennals) will be more than wiling to help you with any problems or
suggest a good way to use hierachies for a situation.

Click @{"here" link author} for information on how to contact me.


@endnode

@node compare "MemManager compared with MMU based systems"

Besides MemManager there are some other systems that offer Virtual Memory.
Perhaps the most well known of these are GigaMem and VMM. These systems
require an MMU.

To understand why MemManager is better than MMU based systems I must first
explain MMU based systems work. People without programming experience may
wish to skip this description.

@{"How MMU based systems work" link howmmu}


MemManager works in a very different way to MMU based systems.

MemManager requires programs that use it to use functions from the
MemManager library in order to allocate memory blocks, lock memory blocks
into memory and decide what should be paged out first.

This allows much better performance as the system can make better judgements
as to what to page out of memory.

Click @{"here" link examplemmufail} for an example of prioritised memory
blocks giving better performance.



Advantages of MemManager over MMU based systems

* Works on ANY Amiga, not just one with an MMU.
* Makes much better judgetments about swapping to disk and so give better
performance.
* Memory protection (needs MMU for that)
* Resource tracking
* Disposable memory


The only advantage of MMU based systems is that they don't require the
programmer to know about the systems in order to take advantage of them.


@endnode

@node howmmu "How MMU based systems work"

How MMU based systems work (VMM GigaMem etc)

MMU based systems work by using the MMU (Memory Management Unit) contained
in some processors such as the 68030 (not the EC version common in 1200
accelerators), 68040 and 68060 (which has a different MMU that can cause
problems).

The MMU can be used to translate an abstract address space into a physical
address space and do trigger events if certain memory areas are accessed. In
laymans terms this means that the pointers to memory blocks held by programs
can point to areas outside the machines real memory and then be translated
to the address where the object actually is in memory when a program
attempts to use this memory.

The absolute address space can use the full positive address space of a 32
bit long (negative numbers reserved for control codes) which is effectively
a 31 bit address space or 2 Gigabytes (thus the name GigaMem).


* When memory is allocated it is given an address in the abstract address
space. This address is not a position in physical memory (as is normally the
case) but an address within an imaginary 2Gb address space.

* If a program then attempts to access this memory (eg to read to it)
it will ask the CPU for the memory. the CPu will then give the address to
the MMU so that the MMU can return the address in the Physical address
space (memory) that corresponds to the address given to it in the abstract
address space (virtual memory).

* The MMU will then check a table it has of addresses, usually organised
into 4 or 8 kilobyte chunks. If the address is marked as being in memory
then the MMU will give the CPU that address in memory. If the address is
marked as being stored on disk then the data will be retrieved from disk
into memory and the address of the data in memory will be given to the CPU.

@endnode

@node examplemmufail "Example of MemManager beating MMU based systems"

In many situations, allowing programs to prioritise memory or organise it
into hierachies can increase performance massively.

As MMU based systems do not know what programs are doing with memory they
have to use *dumb* algorithms to decide what to remove from memory. The most
common is last in last out (LILO). This simply means that the last object
retrived into memory is the last to be removed from it.

With MemManager priorities can be given to memory blocks to reflect how much
we are likely to need them.


Let us take an example.

Quite a common operation is searching. Often you will search from the
beginning of a file to the end. Let us say that the file we wish to search
has been split up into 8 blocks and that only 6 of these blocks will fit
into memory at a time.

In this situation a MemManager programmer will reduce the priority of memory
blocks after they have used them so as to stop them taking memory away from
blocks about to be needed. This is very easy to do using the MemManager
library.

I will represent the memory blocks as a list of eight numbers, highest
priority on the left, lowest priority on the right. We will assume that the
starting situation is that emmediately after the same operation.

Each line represent the situation after a memory swap.


LILO method (used in VMM and GigaMem)
***********
		      
876543 (initial state)
187654
218765
321876
432187
543218
654321
765432
876543

This requires 8 disk swaps :-((


MemManager method (reducing priority of items after use)
*****************

876543 (initial state)
187654
287654
387654

This requires only 4 disk swaps :-))



Note that the MMU based systems would have taken just as long if the user
had had 8 times less memory free! MemManager makes much better use of
available memory than other systems.

Also note that this difference would have been much greater if say there had
been 100 blocks and 99 fit in memory at a time.


@endnode

@node restrack "How MemManager provides Resource Tracking"

How MemManager provides Resource Tracking of memory


Memory Resource Tracking is a system whereby, if a task crashes, any memory
owned solely by that task is automatically deallocated, thus saving physical
memory, and disk space (if stored in a temporary file).


The idea has been around for some time on the Amiga, but before MemManager
it wasn't possible to do it safely. The problem was thatonce a program has
allocated memory, they could have passed pointers to it to other tasks. Thus
if the memory was deallocated these other tasks would fall over. As it is
ompossible to know what pointers a task has given to other tasks, safe
resource tracking of memory was deemed to be imposible with the normal
methods of memory handling on the Amiga.


MemManager solves this problem by knowing more about the memory blocks
involved. When a task allocated some memory, it is noted as having been
allocated by that task. If they wish to pass a pointer to the handle to the
memory block, so that other tasks may lock it then that is perfectly safe.
If a task wishes to pass a pointer into the memory block then they must
publish that memory block using the memmanager.library function Publish.

When a task crashes or terminates, memmanager will free all memory locks
held by that task on memory blocks that haven't been published. Then it will
will free all memory blocks allocated by that task and locked by no other
tasks. Although these blocks are freed, the handle structure is not freed,
but is marked internally as being dead. Thus if another task attempts to
lock this memory block they will fail (lockVMem returns null) and should
take appropriate action to stop what they were doing with it.

Note that publishing a memory block will turn memory protection and resource
tracking off for that block. This is essential if you are giving pointers to
memory blocks to other tasks. If you do give pointers to memory blocks to
other tasks, don't forget to keep a lock on them until you are sure the
other task will have done with them. Pointers into memory that is unlocked
are not valid. If the other tasks to be using memory are your own then you
will normally pass around handles to memory objects rather than pointers to
them so that memory protection and resource tracking can remain active


@endnode

@node protect "How MemManager provides Memory Protection"

How MemManager provides Memory Protection.

Note that although this feature is not yet available, the functions needed
to take advantage of it are already present in the memmanager library as
they are also used for resource tracking.


Memory protection is a system which prevents tasks accessing memory which
they do not have rights to be accessing. This is most useful in preventing
crashes that might otherwise be caused by tasks writing into other program's
memory. Memory protection does not stop programs from falling over, but it
does make it less likely that they will take other tasks down with them.


The idea of Memory Protection is not new, but before MemManager it has
always been difficult to implement on the Amiga. The problem is knowing what
tasks are allowed to access what memory. A task may allocate a block of
memory and then give a pointer to it to another task. How do you decide who
should be accessing what??


The solution used by MemManager is locks. If a task gains a lock on some
memory then it can write to it, but if it does not have a lock then the
memory is protected from being written to by that task. If you wish to pass
a pointer to a memory block to other tasks then you must make it public by
using the Publish command from memmanager.library. Also make sure that all
public memory is locked. Do not unlock it until you are sure that pointers
to the memory are not being used by other tasks and you have Protected it.

Memory that has been made public with the Publish command, is equivalent to
memory allocated through exec.library with the MEMF_Public flag.


Plans are being made to patch many standard amiga OS functions to take
advantage of memory protection. We hope to be able to patch exec.library and
dos.library to protect programs from accesses from tasks other than
themselves and tasks started by themselves. This should stop many crashes.

@endnode

@node Author "About the Author"

About the Author


My name is Robert Ennals. At the time of writing I am an English student.

I can be contacted as follows.

email:  ennals@aol.com
	    This email address may change soon. If this address does not
	    respond, obtain a more recent version of this document. The
	    latest version should always contain my correct address.

phone:  England-(01)81-941-5201

  url:  http;//members.aol.com/ennals/index.html

snail:  19 Belgrade Road
	Hampton
	Middx
	TW12 2AZ
	England


Please feel free to send me suggestions, bug reports, comments etc.

Donations to support the MemManager project are also welcome, both from
users and developers.



Here are some other projects of mine on the Amiga


* TaskBar - The first and still the best Win95 TaskBar clone on the Amiga!
	(Very popular. Released on several magazines)

* T - A Visual Programming Language (not like Visual Basic)
	(not yet released but fully designed)

* Sultan - Object Orientated Quasi-Functional programming language
	(still being designed)

* SmartClasses - A collection of BOOPSI base classes
	(not yet released)

* SmartFile - A replacement for workbench
	(not yet released)

* Threads - A special module for the Cyclone M2 compiler to make writing
	multithreaded applications easy.
 
+ various other programs


@endnode

@node creation "How MemManager was created"

How MemManager was created


All the programs in the MemManager distribution (memmanager.library,
vmempatch etc) were written in the Cyclone M2 compiler by Marcel Timmermans
making use of it's inline assembler.

At the time of writing Cyclone has not been released so I had better give a
little description of it.

Cyclone is a Modula2 compiler that can compile all standard M2 code, but it
also has many extras features, such as objects and exceptions. Here are some
of it's features.

* Real C style optimisations
* Function inlining
* Peephole optimiser
* Very fast compiler (memmanager.library compiles in under a second)
* Produces very small, fast code (note how small memmanager.library is)
* Excellent library linker
* Object Orientated (C++ style)
* Exceptions (C++ style)
* Will probably be released as freeware (incredible!!)

I am lucky enough to be able to use Cyclone before it is released because I
am a beta tester and am developing some modules for it. Amongst other things
I wrote the thread support.


All programs, documentation, and support files were written in GoldED 3 by
Dietmar Eilert.

@endnode

@node patch "Patches to make the OS take advantage of MemManager"

Patches to make the OS take advantage of MemManager


> Patching AllocMem so that MemManager purges blocks when memory gets low.

This is pretty essential and the patch is included in this distribution. it
uses the memmanager.library function PurgeVMem (see autodoc).
This patch has had problems before and may be unstable so if you experience
problems with this beta release of MemManager vmemPatch is probably the
cause.


> Patching DOS IO functions to give disposable buffers for files

If data has been read before it will be in a dipsosable buffer. Useful for
ultra fast operations with huge files :-))


> Patching LoadSeg to give protected memory

May be done when protection is implemented, but will require patching some
other stuff too in order to work.


> Any other patches you come up with

If you want them - write them :-)))
Email me with your own ideas. Either ones you want me to do, or ones you are
considering doing yourself.



@endnode
