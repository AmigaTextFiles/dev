TABLE OF CONTENTS

memmanager.library/--background--
memmanager.library/ChangeVMemPri
memmanager.library/ChangeVMemType
memmanager.library/ClearVMemHierachy
memmanager.library/CreateVMem
memmanager.library/DefineVMemHierachy
memmanager.library/LockVMem
memmanager.library/Protect
memmanager.library/Publish
memmanager.library/PurgeVMem
memmanager.library/RemoveVMem
memmanager.library/UnlockVMem

memmanager.library/--background--          memmanager.library/--background--

VERSION
    This is the autodoc for memmanager.library v3.
    If later versions of memmanager.library than v3 are available
    then you need to get the latest version of this file.


PURPOSE
    MemManager.library provides many things, including

    * Virtual Memory
    * Disposable Memory
    * Prioritised Memory
    * Memory Hierachies
    * Protected Memory
    * Resource Tracking

LICENSE
    As of v3 MemManager is free. Anybody can use it in their programs.
    Gifts are appreciated however. See the AmigaGuide documentation to learn
    how to contact the author.


memmanager.library/ChangeVMemPri            memmanager.library/ChangeVMemPri

    NAME
	ChangeVMemPri

    SYNOPSIS
	ChangeVMemPri( obj , mempri )
		       A1    D0

	void ChangeVMemPri( APTR , LONG )

    FUNCTION
	Change the priority of a memory object. Higher priority objects are
	less likely to be removed from memory than low priority objects.
	
	Often you will call this function if you have finished with an object
	or are soon to need an object. Eg the active document in a text
	editor will have the highest priority.

    INPUTS
	obj     - A VMem Object created wih CreateVMem
	mempri  - The new priority for the memory block.

    NOTE
	The normal priority for an memory object is 0.

	Only raise the priority above 0 for objects you are likely to need
	in the near future.

	Use negative priorities for objects you aren't likely to need
	for a while or for unimportant disposable memory.

	See the amigaguide documentation for memmanager for tips on what
	priorities to use when.


	Here is a rough guideline on use of priorities

	-96 to -127 - special circumstances
	-64 to -95  - memory that is unimportant (often disposable)
	-32 to -63  - memory very unlikely to be needed soon.
	-1  to -31  - memory not likely to be needed for a while
	 0          - default priority (most objects are normally this)
	 1  to  31  - memory likely to be needed soon
	 32 to  63  - memory currently being used (but not locked)
	 64 to  95  - memory that should only be removed from memory
			in extreme circumstances
	 96 to  127 - special circumstances


	For more complex hierachies of object priorities or making some
	objects explicitly inferior to others use CreateVMemHierachy.

    SEE ALSO
	CreateVMem, ChangeVMemType, CreateVMemHierachy


memmanager.library/ChangeVMemType          memmanager.library/ChangeVMemType

    NAME
	ChangeVMemType

    SYNOPSIS
	ChangeVMemType( obj , vmemflags)
			A1    D0

	void ChangeVMemType( APTR , LONG )

    FUNCTION
	Changes the type of a VMem object to that specified by the new
	vmemflags. See CreateVMem for a list of vmemflags currently
	supported by memmanager.library.

    INPUTS
	obj         - a vmem object, as created by CreateVMem
	vmemflags   - a set of vmemflags, as given to CreateVMem

    WARNING
	Objects MUST be locked when you change their priority.
	Not locking objects can cause unpredictable results, such as if
	you changed a diposable object that had been disposed into paged
	memory.

    SEE ALSO
	CreateVMem, ChangeVMemPri


memmanager.library/ClearVMemHierachy    memmanager.library/ClearVMemHierachy

    NAME
	ClearVMemHierachy

    SYNOPSIS
	ClearVMemHierachy( hierachy )
			   A1

	void ClearVMemHierachy( APTR )

    FUNCTION
	Removes vmem objects from the hierachy system.

    INPUTS
	hierachy - a pointer to a null terminated array of vmem object
		pointers (as returned by CreateVMem)

    NOTE
	You can pass it the same array of objects you gave to
	DefineVMemHierachy when you placed a list of objects into a
	hierachy, or specify a few objects from a larger hierachy. For
	example you could declare an hierachy of 10 objects and then remove
	four objects from it.

    SEE ALSO
	DefineVMemHierachy, CreateVMem


memmanager.library/CreateVMem                  memmanager.library/CreateVMem

    NAME
	CreateVMem

    SYNOPSIS
	obj = CreateVMemObject( memsize , memflags , initpri , vmemflags )
	D0                      D0        D1         D2        D3

	APTR CreateVMemObject( LONG , LONG , LONG , LONG )

    FUNCTION
	Create a vmem object of type specified by the paramaters.

    INPUTS
	memsize     - size of memory block in bytes. As given to AllocMem
	memflags    - physical memory flags for the type of memory that
			should hold the object when it is in memory.
			As given to AllocMem
	initpri     - mem object priority (usually 0).
			See ChangeVMemPriority and the MemManager.guide
			developer documentation (included in distribution)
			for more information on chosing a priority.
	vmemflags   - type of vmem. eg paged, disposable etc

    RETURN
	A pointer to a vmem object handle. The structure of this handle is
	secret as it is likely to be changed in future versions.

    NOTE
	Currently the following vmem flags have been defined

	paged - Specifies that the memory can be swapped to disk if memory
	    gets low.
	disposable - Specifies that the memory will be disposed of if memory
	    gets low.

	And not yet implemented

	chiptofast - If chip memory is low and there is fast memory free, the
	    memory block will be moved to fast mem. Only relent when memflags
	    specifies that the memory is chip memory.


	Note that all memory types are protected and resource tracked. See the
	file MemManager.guide (in the developer archive) for information on
	MemManager Memory Protection and Resource Tracking.


	Memory objects should be freed when they have been finsihed with using
	RemoveVMem.

    SEE ALSO
	RemoveVMem, LockVMem, ChangeVMemType, ChangeVMemPri


memmanager.library/DefineVMemHierachy   memmanager.library/DefineVMemHierachy

    NAME
	DefineVMemHierachy

    SYNOPSIS
	DefineVMemHierachy( hierachy )
			    A1

	void DefineVMemHierachy( APTR )

    FUNCTION
	Create a VMem hierachy containing the objects gievn in the supplied
	array, listed from most important to least important.

	VMemHierachies are very useful for telling MemManager that one object
	is more important than another. Objects at the end of the list will
	always be removed from memory before those at the beginning.

    INPUTS
	hierachy    - a null terminated array of pointers to vmem handles.
			(as returned by CreateVMem)

    NOTE
	To see examples of how VMemHierachies can be useful, see the
	MemManager developer documentation.

	Hierachies can be cleared using ClearVMemHierachy.


    SEE ALSO
	CreateVMem, ClearVMemHierachy


memmanager.library/LockVMem                      memmanager.library/LockVMem

    NAME
	LockVMem

    SYNOPSIS
	address = LockVMem( obj )
	D0                  A1

	APTR LockVMem( APTR )

    FUNCTION
	Locks a vmem object into memory and returns a pointer to it. This
	pointer can then be used just like a pointer to a conventional
	memory block until you release it again with UnLockVMem at which
	point the pointer becomes invalid.

    INPUTS
	obj - pointer to a vmemhandle as returned by CreateVMem

    RETURN
	A pointer to a memory block that you can then work with.

    NOTE
	If a memory block cannot be brought into memory this function will
	return null. There are several reasons why this mights happen:

	    * The memory block was disposable and has been disposed

	    * The memory block belonged to a task that has terminated
		and has been disposed of by the resource tracker.

	    * Due to low memory conditions MemManager was unable to
		reserve memory for the object.
		This could happen if tasks lock to much memory or
		non - memmanager tasks allocate a lot a memory with AllocMem

	    * Due to a disk error the temporary file could not be retreived.

	Try to have locks on as little memory as possible. If yuo are going
	to be locking an object a lot then you should give it a high
	priority.


	Note that LockVMem also tells the Memory Protection system
	(not implemented at time of writing) that your task is allowed to
	read from that block.


    WARNING
	You must not give pointers to vmem memory blocks to other tasks (eg
	by sending a message or writing to a file) without Publishing them
	first with Publish.

	If you don't do this the Memory Protection will stop the other task
	from accessing your memory block.

	It is however ok to pass pointers to vmem handles without using
	Publish and loosing the advantages of memory protection and resource
	tracking.

    SEE ALSO
	UnLockVMem, Publish, ChangeVMemPri, CreateVMem


memmanager.library/Protect                        memmanager.library/Protect

    NAME
	Protect

    SYNOPSIS
	Protect( obj )
		 A1

	void Protect( APTR )

    FUNCTION
	Turns protection back on for an object which has had it's protection
	turned off with Publish. One call to Protect is required for every
	call to Publish.

    INPUTS
	obj - pointer to a vmem handle as returned by CreateVMem

    SEE ALSO
	Publish, CreateVMem


memmanager.library/Publish                        memmanager.library/Publish

    NAME
	Publish

    SYNOPSIS
	Publish( obj )
		 A1

	void Publish( APTR )

    FUNCTION
	Turn off Memory Protection and Resource Tracking for a memory block
	so that it can be used by other tasks without them having to lock it.
	
    INPUTS
	obj - pointer to a vmem handle as returned by CreateVMem

    NOTE
	This function MUST be used before passing a pointer to a memory block
	or the Memory Protection system will stop the task using the memory
	and the Resource tracker may free the memory while other tasks are
	using it.

	If you are passing pointers to vmem handles between tasks then you
	do not need to publish the memory blocks.

	Protection can be turned back on for a memory block using Protect.

	If you are passing pointers into memory blocks to non memmanager
	aware tasks then make sure that you keep the memory object locked
	until you are sure that the other task has finished with it.


    SEE ALSO
	Protect, LockVMem, UnLockVMem, CreateVMem


memmanager.library/PurgeVMem                    memmanager.library/PurgeVMem

    NAME
	PurgeVMem

    SYNOPSIS
	PurgeVMem( memflags )
		   D1

	void PurgeVMem( LONG )

    FUNCTION
	Ask MemManager to remove an object from memory so as to give more
	available memory of the type specified.

    INPUTS
	memflags - a set of mem flags, as given to exec.library/AllocMem.

    NOTE
	This function is in the library so that the AllocMem patch can call
	it. It is not intended that programmers should use this function
	themselves. There is no reason why you shouldn't call it, but it
	is unlikely that you will want to.


memmanager.library/RemoveVMem                  memmanager.library/RemoveVMem

    NAME
	RemoveVMem

    SYNOPSIS
	RemoveVMem( obj )
		    A1

	void RemoveVMem ( APTR )

    FUNCTION
	Removes a vmem item created by CreateVMem from the system. This is
	the vmem equivalent of exec.library/FreeMem. If the vmem block
	was in physical memory then that memory will be freed. if it was
	on disk then the temporary file will be deleted.

    INPUTS
	obj - A pointer to a vmem handle as returned by CreateVMem

    SEE ALSO
	CreateVMem


memmanager.library/UnlockVMem                  memmanager.library/UnlockVMem

    NAME
	UnlockVMem

    SYNOPSIS
	UnlockVMem( obj )
		    A1

	void UnlockVMem( APTR )

    FUNCTION
	Unlocks a vmem object allowing it to be removed from addressable
	memory. One call to UnlockVMem is required for every call to LockVMem
	in order for the vmem object to be unlocked.

    INPUTS
	obj - a pointer toa vmem handle as returned by CreateVMem

    SEE ALSO
	LockVMem, CreateVMem, Publish, Protect

  
