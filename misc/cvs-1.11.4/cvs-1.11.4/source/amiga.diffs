Index: diff/system.h
===================================================================
RCS file: /cvs/ccvs/diff/system.h,v
retrieving revision 1.8
diff -c -r1.8 system.h
*** diff/system.h	24 Sep 2002 20:09:12 -0000	1.8
--- diff/system.h	8 Jan 2003 17:05:49 -0000
***************
*** 27,32 ****
--- 27,36 ----
  #include <sys/types.h>
  #include <sys/stat.h>
  
+ #if defined(AMIGA) && defined(__SASC)
+ typedef int ssize_t;
+ #endif /* AMIGA */
+ 
  /* Note that PARAMS is just internal to the diff library; diffrun.h
     has its own mechanism, which will hopefully be less likely to
     conflict with the library's caller's namespace.  */
***************
*** 280,290 ****
    }
  #endif
  
  /* these come from CVS's lib/system.h, but I wasn't sure how to include that
   * properly or even if I really should
   */
  #ifndef CVS_OPENDIR
! #define CVS_OPENDIR opendir
  #endif
  #ifndef CVS_READDIR
  #define CVS_READDIR readdir
--- 284,298 ----
    }
  #endif
  
+ #ifdef AMIGA
+ #include "amiga.h"
+ #endif /* AMIGA */
+ 
  /* these come from CVS's lib/system.h, but I wasn't sure how to include that
   * properly or even if I really should
   */
  #ifndef CVS_OPENDIR
! #define CVS_OPENDIR amiga_opendir
  #endif
  #ifndef CVS_READDIR
  #define CVS_READDIR readdir
Index: lib/getopt.c
===================================================================
RCS file: /cvs/ccvs/lib/getopt.c,v
retrieving revision 1.5
diff -c -r1.5 getopt.c
*** lib/getopt.c	2 Jan 1997 19:07:41 -0000	1.5
--- lib/getopt.c	8 Jan 2003 17:05:50 -0000
***************
*** 66,71 ****
--- 66,75 ----
  #include <stdlib.h>
  #endif	/* GNU C library.  */
  
+ #ifdef AMIGA
+ #include <stdlib.h>
+ #endif /* AMIGA */
+ 
  /* This version of `getopt' appears to the caller like standard Unix `getopt'
     but it behaves differently for the user, since it allows the user
     to intersperse the options with the other arguments.
Index: lib/getopt.h
===================================================================
RCS file: /cvs/ccvs/lib/getopt.h,v
retrieving revision 1.5
diff -c -r1.5 getopt.h
*** lib/getopt.h	28 Apr 2002 14:20:40 -0000	1.5
--- lib/getopt.h	8 Jan 2003 17:05:50 -0000
***************
*** 121,127 ****
--- 121,131 ----
     exactly why), and there is no particular need to prototype it.
     We really shouldn't be trampling on the system's namespace at all by
     declaring getopt() but that is a bigger issue.  */
+ #ifdef AMIGA
+ extern int getopt (int argc, char * const *argv, const char *optstring);
+ #else
  extern int getopt ();
+ #endif
  
  extern int getopt_long (int argc, char *const *argv, const char *shortopts,
  		        const struct option *longopts, int *longind);
Index: lib/regex.c
===================================================================
RCS file: /cvs/ccvs/lib/regex.c,v
retrieving revision 1.12
diff -c -r1.12 regex.c
*** lib/regex.c	8 Aug 2002 19:55:42 -0000	1.12
--- lib/regex.c	8 Jan 2003 17:05:58 -0000
***************
*** 144,151 ****
--- 144,156 ----
  
  static char re_syntax_table[CHAR_SET_SIZE];
  
+ #ifdef AMIGA
+ static void
+ init_syntax_once (void)
+ #else
  static void
  init_syntax_once ()
+ #endif /* AMIGA */
  {
     register int c;
     static int done = 0;
***************
*** 358,364 ****
  #define false 0
  #define true 1
  
! static int re_match_2_internal ();
  
  /* These are the command codes that appear in compiled regular
     expressions.	 Some opcodes are followed by argument bytes.  A
--- 363,376 ----
  #define false 0
  #define true 1
  
! #ifdef AMIGA
! static int re_match_2_internal(struct re_pattern_buffer *bufp, const char *string1,
!                                int size1, const char *string2, int size2, int pos,
!                                struct re_registers *regs, int stop);
! #else
! static int re_match_2_internal ()
! #endif /* AMiGA */
! 
  
  /* These are the command codes that appear in compiled regular
     expressions.	 Some opcodes are followed by argument bytes.  A
***************
*** 540,548 ****
  
  #ifdef DEBUG
  static void
  extract_number (dest, source)
!     int *dest;
      unsigned char *source;
  {
    int temp = SIGN_EXTEND_CHAR (*(source + 1));
    *dest = *source & 0377;
--- 552,564 ----
  
  #ifdef DEBUG
  static void
+ #ifdef AMIGA
+ extract_number (int *dest, unsigned char *source)
+ #else
  extract_number (dest, source)
! 		int *dest;
      unsigned char *source;
+ #endif /* AMIGA */
  {
    int temp = SIGN_EXTEND_CHAR (*(source + 1));
    *dest = *source & 0377;
***************
*** 567,575 ****
--- 583,595 ----
  
  #ifdef DEBUG
  static void
+ #ifdef AMIGA
+ extract_number_and_incr (int *destination, unsigned char **source)
+ #else
  extract_number_and_incr (destination, source)
      int *destination;
      unsigned char **source;
+ #endif /* AMIGA */
  {
    extract_number (destination, *source);
    *source += 2;
***************
*** 1530,1539 ****
--- 1550,1561 ----
  
  /* Subroutine declarations and macros for regex_compile.  */
  
+ #ifndef AMIGA
  static void store_op1 (), store_op2 ();
  static void insert_op1 (), insert_op2 ();
  static boolean at_begline_loc_p (), at_endline_loc_p ();
  static boolean group_in_compile_stack ();
+ #endif /* AMIGA */
  
  /* Fetch the next character in the uncompiled pattern---translating it
     if necessary.  Also cast from a signed character in the constant
***************
*** 1686,1698 ****
--- 1708,1733 ----
  } compile_stack_elt_t;
  
  
+ #ifdef AMIGA
+ typedef struct compile_stack_type
+ #else
  typedef struct
+ #endif /* AMIGA */
  {
    compile_stack_elt_t *stack;
    unsigned size;
    unsigned avail;			/* Offset of next open position.  */
  } compile_stack_type;
  
+ #ifdef AMIGA
+ static void store_op1(re_opcode_t op, unsigned char *loc, int arg);
+ static void store_op2(re_opcode_t op, unsigned char *loc, int arg1, int arg2);
+ static void insert_op1(re_opcode_t op, unsigned char *loc, int arg, unsigned char *end);
+ static void insert_op2(re_opcode_t op, unsigned char *loc, int arg1, int arg2, unsigned char *end);
+ static boolean at_begline_loc_p(const char *pattern, const char *p, reg_syntax_t syntax);
+ static boolean at_endline_loc_p(const char *p, const char *pend, int syntax);
+ static boolean group_in_compile_stack(compile_stack_type compile_stack, unsigned regnum);
+ #endif /* AMIGA */
  
  #define INIT_COMPILE_STACK_SIZE 32
  
***************
*** 1808,1815 ****
     but don't make them smaller.	 */
  
  static
! regex_grow_registers (num_regs)
!      int num_regs;
  {
    if (num_regs > regs_allocated_size)
      {
--- 1843,1849 ----
     but don't make them smaller.	 */
  
  static
! regex_grow_registers(int num_regs) /* AMiGA */
  {
    if (num_regs > regs_allocated_size)
      {
***************
*** 1856,1866 ****
--- 1890,1906 ----
    } while (0)
  
  static reg_errcode_t
+ #ifdef AMIGA
+ regex_compile (const char *pattern, int size,
+                reg_syntax_t syntax,
+                struct re_pattern_buffer *bufp) /* AMiGA */
+ #else
  regex_compile (pattern, size, syntax, bufp)
       const char *pattern;
       int size;
       reg_syntax_t syntax;
       struct re_pattern_buffer *bufp;
+ #endif
  {
    /* We fetch characters from PATTERN here.  Even though PATTERN is
       `char *' (i.e., signed), we declare these variables as unsigned, so
***************
*** 3936,3945 ****
  
  /* Declarations and macros for re_match_2.  */
  
  static int bcmp_translate ();
  static boolean alt_match_null_string_p (),
! 	       common_op_match_null_string_p (),
! 	       group_match_null_string_p ();
  
  /* This converts PTR, a pointer into one of the search strings `string1'
     and `string2' into an offset from the beginning of that string.  */
--- 3976,3992 ----
  
  /* Declarations and macros for re_match_2.  */
  
+ #ifndef AMIGA
  static int bcmp_translate ();
  static boolean alt_match_null_string_p (),
! 	common_op_match_null_string_p (),
! 	group_match_null_string_p ();
! #else
! static int bcmp_translate(unsigned char *s1, unsigned char *s2, int len, RE_TRANSLATE_TYPE translate);
! static boolean alt_match_null_string_p(unsigned char *p, unsigned char *end, register_info_type *reg_info);
! static boolean common_op_match_null_string_p(unsigned char **p, unsigned char *end, register_info_type *reg_info);
! static boolean group_match_null_string_p(unsigned char **p, unsigned char *end, register_info_type *reg_info);
! #endif /* AMIGA */
  
  /* This converts PTR, a pointer into one of the search strings `string1'
     and `string2' into an offset from the beginning of that string.  */
Index: lib/regex.h
===================================================================
RCS file: /cvs/ccvs/lib/regex.h,v
retrieving revision 1.6
diff -c -r1.6 regex.h
*** lib/regex.h	28 Apr 2002 14:20:40 -0000	1.6
--- lib/regex.h	8 Jan 2003 17:05:59 -0000
***************
*** 485,493 ****
  #ifdef _REGEX_RE_COMP
  /* 4.2 bsd compatibility.  */
  /* CVS: don't use prototypes: they may conflict with system headers.  */
  extern char *re_comp _RE_ARGS (());
  extern int re_exec _RE_ARGS (());
! #endif
  
  /* POSIX compatibility.  */
  /* CVS - DRP
--- 485,499 ----
  #ifdef _REGEX_RE_COMP
  /* 4.2 bsd compatibility.  */
  /* CVS: don't use prototypes: they may conflict with system headers.  */
+ #ifdef AMIGA
+ extern char *re_comp _RE_ARGS((const char *s));
+ extern int re_exec _RE_ARGS((const char *s));
+ #else
  extern char *re_comp _RE_ARGS (());
  extern int re_exec _RE_ARGS (());
! #endif /* AMIGA */
! 
! #endif /* _REGEX_RE_COMP */
  
  /* POSIX compatibility.  */
  /* CVS - DRP
Index: lib/sighandle.c
===================================================================
RCS file: /cvs/ccvs/lib/sighandle.c,v
retrieving revision 1.7
diff -c -r1.7 sighandle.c
*** lib/sighandle.c	23 Feb 2000 10:11:25 -0000	1.7
--- lib/sighandle.c	8 Jan 2003 17:06:00 -0000
***************
*** 65,71 ****
  
  /* Define linked list of signal handlers structure */
  struct SIG_hlist {
! 	RETSIGTYPE		(*handler)();
  	struct SIG_hlist	*next;
  };
  
--- 65,76 ----
  
  /* Define linked list of signal handlers structure */
  struct SIG_hlist {
! 
!   #ifdef AMIGA
! 	RETSIGTYPE				(*handler)(int sig);
!   #else
! 	RETSIGTYPE				(*handler)();
!   #endif /* AMIGA */
  	struct SIG_hlist	*next;
  };
  
Index: lib/system.h
===================================================================
RCS file: /cvs/ccvs/lib/system.h,v
retrieving revision 1.43
diff -c -r1.43 system.h
*** lib/system.h	16 Sep 2002 14:36:55 -0000	1.43
--- lib/system.h	8 Jan 2003 17:06:01 -0000
***************
*** 385,403 ****
     can hang their own definitions.  */
  
  #ifndef CVS_ACCESS
! #define CVS_ACCESS access
  #endif
  
  #ifndef CVS_CHDIR
! #define CVS_CHDIR chdir
  #endif
  
  #ifndef CVS_CREAT
! #define CVS_CREAT creat
  #endif
  
  #ifndef CVS_FOPEN
! #define CVS_FOPEN fopen
  #endif
  
  #ifndef CVS_FDOPEN
--- 385,403 ----
     can hang their own definitions.  */
  
  #ifndef CVS_ACCESS
! #define CVS_ACCESS amiga_access
  #endif
  
  #ifndef CVS_CHDIR
! #define CVS_CHDIR amiga_chdir
  #endif
  
  #ifndef CVS_CREAT
! #define CVS_CREAT amiga_creat
  #endif
  
  #ifndef CVS_FOPEN
! #define CVS_FOPEN amiga_fopen
  #endif
  
  #ifndef CVS_FDOPEN
***************
*** 405,415 ****
  #endif
  
  #ifndef CVS_MKDIR
! #define CVS_MKDIR mkdir
  #endif
  
  #ifndef CVS_OPEN
! #define CVS_OPEN open
  #endif
  
  #ifndef CVS_READDIR
--- 405,415 ----
  #endif
  
  #ifndef CVS_MKDIR
! #define CVS_MKDIR amiga_mkdir
  #endif
  
  #ifndef CVS_OPEN
! #define CVS_OPEN amiga_open
  #endif
  
  #ifndef CVS_READDIR
***************
*** 421,450 ****
  #endif
  
  #ifndef CVS_OPENDIR
! #define CVS_OPENDIR opendir
  #endif
  
  #ifndef CVS_RENAME
! #define CVS_RENAME rename
  #endif
  
  #ifndef CVS_RMDIR
! #define CVS_RMDIR rmdir
  #endif
  
  #ifndef CVS_STAT
! #define CVS_STAT stat
  #endif
  
  /* Open question: should CVS_STAT be lstat by default?  We need
     to use lstat in order to handle symbolic links correctly with
     the PreservePermissions option. -twp */
  #ifndef CVS_LSTAT
! #define CVS_LSTAT lstat
  #endif
  
  #ifndef CVS_UNLINK
! #define CVS_UNLINK unlink
  #endif
  
  /* Wildcard matcher.  Should be case-insensitive if the system is.  */
--- 421,450 ----
  #endif
  
  #ifndef CVS_OPENDIR
! #define CVS_OPENDIR amiga_opendir
  #endif
  
  #ifndef CVS_RENAME
! #define CVS_RENAME amiga_rename
  #endif
  
  #ifndef CVS_RMDIR
! #define CVS_RMDIR amiga_rmdir
  #endif
  
  #ifndef CVS_STAT
! #define CVS_STAT amiga_stat
  #endif
  
  /* Open question: should CVS_STAT be lstat by default?  We need
     to use lstat in order to handle symbolic links correctly with
     the PreservePermissions option. -twp */
  #ifndef CVS_LSTAT
! #define CVS_LSTAT amiga_stat
  #endif
  
  #ifndef CVS_UNLINK
! #define CVS_UNLINK amiga_unlink
  #endif
  
  /* Wildcard matcher.  Should be case-insensitive if the system is.  */
***************
*** 476,481 ****
--- 476,489 ----
  extern void fnfold (char *FILENAME);
  
  #endif /* defined (__CYGWIN32__) || defined (WIN32) */
+ 
+ #ifdef AMIGA
+ #include "amiga.h"
+ 
+ #define FOLD_FN_CHAR(c) amiga_fold_fn_char(c)
+ #define FILENAMES_CASE_INSENSITIVE 1
+ #define ISDIRSEP(c) ((c) == ':' || (c) == '/')
+ #endif /* AMIGA */
  
  /* Some file systems are case-insensitive.  If FOLD_FN_CHAR is
     #defined, it maps the character C onto its "canonical" form.  In a
Index: lib/xgetwd.c
===================================================================
RCS file: /cvs/ccvs/lib/xgetwd.c,v
retrieving revision 1.5
diff -c -r1.5 xgetwd.c
*** lib/xgetwd.c	29 Nov 1997 22:52:35 -0000	1.5
--- lib/xgetwd.c	8 Jan 2003 17:06:01 -0000
***************
*** 29,36 ****
--- 29,41 ----
  /* Amount by which to increase buffer size when allocating more space. */
  #define PATH_INCR 32
  
+ #ifdef AMIGA
+ char *xmalloc(size_t);
+ char *xrealloc(void *ptr, size_t bytes);
+ #else
  char *xmalloc ();
  char *xrealloc ();
+ #endif /* AMIGA */
  
  /* Return the current directory, newly allocated, arbitrarily long.
     Return NULL and set errno on error. */
Index: lib/xtime.h
===================================================================
RCS file: /cvs/ccvs/lib/xtime.h,v
retrieving revision 1.1
diff -c -r1.1 xtime.h
*** lib/xtime.h	15 Feb 2001 02:53:07 -0000	1.1
--- lib/xtime.h	8 Jan 2003 17:06:01 -0000
***************
*** 27,32 ****
--- 27,36 ----
  #   endif /* !HAVE_SYS_TIME_H */
  # endif /* !TIME_WITH_SYS_TIME */
  
+ # ifdef timezone
+ #   undef timezone /* needed for sgi */
+ # endif /* timezone */
+ 
  # ifdef HAVE_SYS_TIMEB_H
  #   include <sys/timeb.h>
  # else /* HAVE_SYS_TIMEB_H */
***************
*** 45,54 ****
      short		dstflag;	/* Field not used		*/
  };
  # endif /* !HAVE_SYS_TIMEB_H */
- 
- # ifdef timezone
- #   undef timezone /* needed for sgi */
- # endif /* timezone */
  
  # if !defined(HAVE_FTIME) && !defined(HAVE_TIMEZONE)
  extern long timezone;
--- 49,54 ----
Index: src/admin.c
===================================================================
RCS file: /cvs/ccvs/src/admin.c,v
retrieving revision 1.80
diff -c -r1.80 admin.c
*** src/admin.c	28 Dec 2002 17:56:59 -0000	1.80
--- src/admin.c	8 Jan 2003 17:06:02 -0000
***************
*** 147,153 ****
--- 147,155 ----
      int err;
  #ifdef CVS_ADMIN_GROUP
      struct group *grp;
+ #ifndef AMIGA
      struct group *getgrnam();
+ #endif /* AMIGA */
  #endif
      struct admin_data admin_data;
      int c;
Index: src/buffer.c
===================================================================
RCS file: /cvs/ccvs/src/buffer.c,v
retrieving revision 1.21
diff -c -r1.21 buffer.c
*** src/buffer.c	7 Dec 2002 14:26:24 -0000	1.21
--- src/buffer.c	8 Jan 2003 17:06:04 -0000
***************
*** 1418,1424 ****
--- 1418,1430 ----
  	}
  
  # ifdef SHUTDOWN_SERVER
+ #ifdef AMIGA
+ 	if (current_parsed_root->method == server_method)
+ 	    SHUTDOWN_SERVER_INPUT(fileno(bc->fp));
+   else
+ #else
  	if (current_parsed_root->method != server_method)
+ #endif /* AMIGA */
  # endif
  # ifndef NO_SOCKET_TO_FD
  	{
***************
*** 1446,1452 ****
--- 1452,1462 ----
  	 * SHUTDOWN_SERVER_OUTPUT
  	 */
  	if (current_parsed_root->method == server_method)
+ #ifdef AMIGA
+ 	    SHUTDOWN_SERVER_OUTPUT(fileno(bc->fp));
+ #else
  	    SHUTDOWN_SERVER ( fileno (bc->fp) );
+ #endif /* AMIGA */
  	else
  # endif
  # ifndef NO_SOCKET_TO_FD
Index: src/client.c
===================================================================
RCS file: /cvs/ccvs/src/client.c,v
retrieving revision 1.317
diff -c -r1.317 client.c
*** src/client.c	28 Dec 2002 17:56:59 -0000	1.317
--- src/client.c	8 Jan 2003 17:06:10 -0000
***************
*** 799,805 ****
--- 799,811 ----
  
  	/* shutdown() socket */
  # ifdef SHUTDOWN_SERVER
+ #ifdef AMIGA
+ 	if (current_parsed_root->method == server_method)
+ 	    SHUTDOWN_SERVER_INPUT(n->socket);
+   else
+ #else
  	if (current_parsed_root->method != server_method)
+ #endif /* AMIGA */
  # endif
  	if (shutdown (n->socket, 0) < 0)
  	{
***************
*** 816,822 ****
--- 822,832 ----
  	 * SHUTDOWN_SERVER_OUTPUT
  	 */
  	if (current_parsed_root->method == server_method)
+ #ifdef AMIGA
+ 	    SHUTDOWN_SERVER_OUTPUT(n->socket);
+ #else
  	    SHUTDOWN_SERVER (n->socket);
+ #endif /* AMIGA */
  	else
  # endif
  	if (shutdown (n->socket, 1) < 0)
***************
*** 3488,3494 ****
  
      memcpy (buf, data, nread);
  
!     return nread;
  }
  
  /*
--- 3498,3504 ----
  
      memcpy (buf, data, nread);
  
!     return (size_t)nread; /* AMiGA */
  }
  
  /*
***************
*** 3799,3807 ****
--- 3809,3821 ----
  	   same.  */
  	if (tofd == fromfd)
  	{
+ #ifdef AMIGA
+        fprintf(stderr,"HELP! dup() called!\n");
+ #else
  	    fromfd = dup (tofd);
  	    if (fromfd < 0)
  		error (1, errno, "cannot dup net connection");
+ #endif /* AMIGA */
  	}
  
  	/* These will use binary mode on systems which have it.  */
Index: src/cvs.h
===================================================================
RCS file: /cvs/ccvs/src/cvs.h,v
retrieving revision 1.235
diff -c -r1.235 cvs.h
*** src/cvs.h	28 Dec 2002 17:56:59 -0000	1.235
--- src/cvs.h	8 Jan 2003 17:06:12 -0000
***************
*** 57,62 ****
--- 57,66 ----
  #include <strings.h>
  #endif
  
+ #ifdef AMIGA
+ #include "amiga.h"
+ #endif /* AMIGA */
+ 
  #ifdef SERVER_SUPPORT
  /* If the system doesn't provide strerror, it won't be declared in
     string.h.  */
Index: src/entries.c
===================================================================
RCS file: /cvs/ccvs/src/entries.c,v
retrieving revision 1.46
diff -c -r1.46 entries.c
*** src/entries.c	9 Mar 2001 18:21:40 -0000	1.46
--- src/entries.c	8 Jan 2003 17:06:13 -0000
***************
*** 340,345 ****
--- 340,348 ----
  	if ((cp = strchr (user, '/')) == NULL)
  	    continue;
  	*cp++ = '\0';
+ #ifdef AMIGA
+   if(!(*user)) continue; /* AMIGA: This is to prevent trouble with "D/////" entries */
+ #endif
  	vn = cp;
  	if ((cp = strchr (vn, '/')) == NULL)
  	    continue;
Index: src/filesubr.c
===================================================================
RCS file: /cvs/ccvs/src/filesubr.c,v
retrieving revision 1.59
diff -c -r1.59 filesubr.c
*** src/filesubr.c	24 Sep 2002 20:10:38 -0000	1.59
--- src/filesubr.c	8 Jan 2003 17:06:15 -0000
***************
*** 110,115 ****
--- 110,119 ----
      t.actime = sb.st_atime;
      t.modtime = sb.st_mtime;
      (void) utime (to, &t);
+ 
+     #ifdef AMIGA
+     chmod((char *)to, sb.st_mode);
+     #endif /* AMIGA */
  }
  
  /* FIXME-krp: these functions would benefit from caching the char * &
***************
*** 426,431 ****
--- 430,436 ----
   * removal of all of the files in the directory.  Return -1 on error
   * (in which case errno is set).
   */
+ #ifndef AMIGA
  int
  unlink_file_dir (f)
      const char *f;
***************
*** 466,471 ****
--- 471,477 ----
  
      return CVS_UNLINK (f);
  }
+ #endif /* AMIGA */
  
  /* Remove a directory and everything it contains.  Returns 0 for
   * success, -1 for failure (in which case errno is set).
***************
*** 579,585 ****
  	nchars -= nread;
      } while (nchars != 0);
  
!     return bp - buf;
  } 
  
      
--- 585,591 ----
  	nchars -= nread;
      } while (nchars != 0);
  
!     return (size_t)(bp - buf); /* AMiGA */
  } 
  
      
***************
*** 620,625 ****
--- 626,632 ----
  	return result;
      }
  
+ #ifndef AMIGA
      /* If FILE1 and FILE2 are devices, they are equal if their device
         numbers match. */
      if (S_ISBLK (sb1.st_mode) || S_ISCHR (sb1.st_mode))
***************
*** 634,639 ****
--- 641,647 ----
  	       file1, file2);
  #endif
      }
+ #endif /* AMIGA */
  
      if ((fd1 = open (file1, O_RDONLY)) < 0)
  	error (1, errno, "cannot open file %s for comparing", file1);
***************
*** 683,688 ****
--- 691,697 ----
      return (ret);
  }
  
+ #ifndef AMIGA
  /* Generate a unique temporary filename.  Returns a pointer to a newly
   * malloc'd string containing the name.  Returns successfully or not at
   * all.
***************
*** 706,711 ****
--- 715,721 ----
  	error (0, errno, "Failed to close temporary file %s", fn);
      return fn;
  }
+ #endif /* AMIGA */
  
  /* Generate a unique temporary filename and return an open file stream
   * to the truncated file by that name
***************
*** 738,743 ****
--- 748,754 ----
   * NFS locking thing, but until I hear of more problems, I'm not going to
   * bother.
   */
+ #ifndef AMIGA
  FILE *cvs_temp_file (filename)
      char **filename;
  {
***************
*** 844,850 ****
--- 855,863 ----
      *filename = fn;
      return fp;
  }
+ #endif /* AMIGA */
  
+ #ifndef AMIGA
  /* Return non-zero iff FILENAME is absolute.
     Trivial under Unix, but more complicated under other systems.  */
  int
***************
*** 853,858 ****
--- 866,872 ----
  {
      return filename[0] == '/';
  }
+ #endif /* AMIGA */
  
  /*
   * Return a string (dynamically allocated) with the name of the file to which
***************
*** 892,898 ****
      return tfile;
  }
  
! 
  /* Return a pointer into PATH's last component.  */
  char *
  last_component (path)
--- 906,912 ----
      return tfile;
  }
  
! #ifndef AMIGA
  /* Return a pointer into PATH's last component.  */
  char *
  last_component (path)
***************
*** 905,910 ****
--- 919,925 ----
      else
          return path;
  }
+ #endif /* AMIGA */
  
  /* Return the home directory.  Returns a pointer to storage
     managed by this function or its callees (currently getenv).
***************
*** 970,979 ****
--- 985,999 ----
      const char *file;
  {
      char *path = xmalloc (strlen (dir) + 1 + strlen(file) + 1);
+     #ifdef AMIGA
+     if(dir[strlen(dir)-1] == ':') sprintf(path, "%s%s", dir, file);
+     else
+     #endif /* AMIGA */
      sprintf (path, "%s/%s", dir, file);
      return path;
  }
  
+ #ifndef AMIGA
  /* See cvs.h for description.  On unix this does nothing, because the
     shell expands the wildcards.  */
  void
***************
*** 989,994 ****
--- 1009,1015 ----
      for (i = 0; i < argc; ++i)
  	(*pargv)[i] = xstrdup (argv[i]);
  }
+ #endif /* AMIGA */
  
  #ifdef SERVER_SUPPORT
  /* Case-insensitive string compare.  I know that some systems
Index: src/find_names.c
===================================================================
RCS file: /cvs/ccvs/src/find_names.c,v
retrieving revision 1.30
diff -c -r1.30 find_names.c
*** src/find_names.c	24 Sep 2001 15:16:05 -0000	1.30
--- src/find_names.c	8 Jan 2003 17:06:15 -0000
***************
*** 225,231 ****
  
  	if (entries == NULL && tmpentries != NULL)
  	    Entries_Close (tmpentries);
!     }
  
      /* look for sub-dirs in the repository */
      if ((which & W_REPOS) && repository)
--- 225,231 ----
  
  	if (entries == NULL && tmpentries != NULL)
  	    Entries_Close (tmpentries);
! 	}
  
      /* look for sub-dirs in the repository */
      if ((which & W_REPOS) && repository)
Index: src/hash.c
===================================================================
RCS file: /cvs/ccvs/src/hash.c,v
retrieving revision 1.32
diff -c -r1.32 hash.c
*** src/hash.c	9 Jun 2000 20:54:01 -0000	1.32
--- src/hash.c	8 Jan 2003 17:06:15 -0000
***************
*** 21,28 ****
--- 21,32 ----
  
  /* hash function */
  static int
+ #ifdef AMIGA
+ hashp (const char *key)
+ #else
  hashp (key)
      const char *key;
+ #endif /* AMIGA */
  {
      unsigned int h = 0;
      unsigned int g;
***************
*** 38,44 ****
  	    h = (h ^ (g >> 24)) ^ g;
      }
  
!     return (h % HASHSIZE);
  }
  
  /*
--- 42,48 ----
  	    h = (h ^ (g >> 24)) ^ g;
      }
  
!     return (int)(h % HASHSIZE); /* AMiGA */
  }
  
  /*
***************
*** 184,190 ****
  freenode_mem (p)
      Node *p;
  {
!     if (p->delproc != (void (*) ()) NULL)
  	p->delproc (p);			/* call the specified delproc */
      else
      {
--- 188,194 ----
  freenode_mem (p)
      Node *p;
  {
!     if (p->delproc != (void (*) (void *)) NULL) /* AMiGA */
  	p->delproc (p);			/* call the specified delproc */
      else
      {
***************
*** 196,202 ****
  
      /* to be safe, re-initialize these */
      p->key = p->data = (char *) NULL;
!     p->delproc = (void (*) ()) NULL;
  }
  
  /*
--- 200,206 ----
  
      /* to be safe, re-initialize these */
      p->key = p->data = (char *) NULL;
!     p->delproc = (void (*) (void *)) NULL; /* AMiGA */
  }
  
  /*
Index: src/hash.h
===================================================================
RCS file: /cvs/ccvs/src/hash.h,v
retrieving revision 1.14
diff -c -r1.14 hash.h
*** src/hash.h	9 Jun 2000 20:54:01 -0000	1.14
--- src/hash.h	8 Jan 2003 17:06:15 -0000
***************
*** 11,16 ****
--- 11,20 ----
   */
  #define HASHSIZE	151
  
+ #ifdef AMIGA
+ #undef NT_UNKNOWN
+ #endif /* AMIGA */
+ 
  /*
   * Types of nodes
   */
***************
*** 31,37 ****
      struct node *hashprev;
      char *key;
      char *data;
!     void (*delproc) ();
  };
  typedef struct node Node;
  
--- 35,41 ----
      struct node *hashprev;
      char *key;
      char *data;
!     void (*delproc) (void *); /* AMiGA */
  };
  typedef struct node Node;
  
Index: src/login.c
===================================================================
RCS file: /cvs/ccvs/src/login.c,v
retrieving revision 1.70
diff -c -r1.70 login.c
*** src/login.c	23 May 2002 18:13:17 -0000	1.70
--- src/login.c	8 Jan 2003 17:06:16 -0000
***************
*** 26,32 ****
--- 26,34 ----
     varadic, believe it or not).  On Cray, getpass will be declared
     in either stdlib.h or unistd.h.  */
  #ifndef _CRAY
+ #ifndef AMIGA
  extern char *GETPASS ();
+ #endif
  #endif
  
  #ifndef CVS_PASSWORD_FILE 
Index: src/main.c
===================================================================
RCS file: /cvs/ccvs/src/main.c,v
retrieving revision 1.172
diff -c -r1.172 main.c
*** src/main.c	4 Oct 2002 19:56:01 -0000	1.172
--- src/main.c	8 Jan 2003 17:06:18 -0000
***************
*** 18,24 ****
--- 18,26 ----
  #ifdef HAVE_WINSOCK_H
  #include <winsock.h>
  #else
+ #ifndef AMIGA
  extern int gethostname ();
+ #endif /* AMIGA */
  #endif
  
  char *program_name;
***************
*** 99,105 ****
      char *nick1;
      char *nick2;
      
!     int (*func) ();		/* Function takes (argc, argv) arguments. */
      unsigned long attr;		/* Attributes. */
  } cmds[] =
  
--- 101,111 ----
      char *nick1;
      char *nick2;
      
!     #ifdef AMIGA
!     int (*func) (int argc, char ** argv);
!     #else
!     int (*func) (); 	/* Function takes (argc, argv) arguments. */
!     #endif /* AMIGA */
      unsigned long attr;		/* Attributes. */
  } cmds[] =
  
***************
*** 544,552 ****
--- 550,566 ----
  		(void) fputs ("\n", stdout);
  		version (0, (char **) NULL);    
  		(void) fputs ("\n", stdout);
+ #ifndef AMIGA
  		(void) fputs ("\
  Copyright (c) 1989-2002 Brian Berliner, david d `zoo' zuhn, \n\
                          Jeff Polk, and other authors\n", stdout);
+ #else
+ 		(void) fputs ("\
+ Copyright (c) 1989-2002 Brian Berliner, david d `zoo' zuhn, \n\
+                         Jeff Polk, and other authors\n\
+ ported by:\n\
+ Copyright (c) 2001-2003 Olaf `olsen' Barthel and Jens Langner\n", stdout);
+ #endif /* AMIGA */
  		(void) fputs ("\n", stdout);
  		(void) fputs ("CVS may be copied only under the terms of the GNU General Public License,\n", stdout);
  		(void) fputs ("a copy of which can be found with the CVS distribution kit.\n", stdout);
Index: src/parseinfo.c
===================================================================
RCS file: /cvs/ccvs/src/parseinfo.c,v
retrieving revision 1.37
diff -c -r1.37 parseinfo.c
*** src/parseinfo.c	7 Dec 2002 14:26:24 -0000	1.37
--- src/parseinfo.c	8 Jan 2003 17:06:18 -0000
***************
*** 44,49 ****
--- 44,61 ----
  	return (1);
      }
  
+     /* This should be interesting. If this is a remote repository,
+      * then trying to open it locally is not going to provide for
+      * a lot of useful information. So we're going to skip it. It's
+      * causing trouble with the Amiga implementation, too.
+      */
+     #ifdef AMIGA
+     {
+ 	if (current_parsed_root->isremote)
+ 	    return (1);
+     }
+     #endif /* AMIGA */
+ 
      /* find the info file and open it */
      infopath = xmalloc (strlen (current_parsed_root->directory)
  			+ strlen (infofile)
Index: src/root.c
===================================================================
RCS file: /cvs/ccvs/src/root.c,v
retrieving revision 1.58
diff -c -r1.58 root.c
*** src/root.c	7 Dec 2002 14:26:24 -0000	1.58
--- src/root.c	8 Jan 2003 17:06:19 -0000
***************
*** 416,427 ****
--- 416,435 ----
      }
      else
      {
+ #ifdef AMIGA
+   /* On Amiga-systems a valid path could have a ":" which would cause the normal
+      cvs to think that this is a port specification, so therefore anything that doesn`t
+      start with a valid :method: specification is a local_method per default.
+   */
+   newroot->method = local_method;
+ #else
  	/* If the method isn't specified, assume EXT_METHOD if the string looks
  	   like a relative path and LOCAL_METHOD otherwise.  */
  
  	newroot->method = ((*cvsroot_copy != '/' && strchr (cvsroot_copy, '/'))
  			  ? ext_method
  			  : local_method);
+ #endif /* AMIGA */
      }
  
  #ifdef CLIENT_SUPPORT
Index: src/run.c
===================================================================
RCS file: /cvs/ccvs/src/run.c,v
retrieving revision 1.33
diff -c -r1.33 run.c
*** src/run.c	24 Jan 2001 03:35:10 -0000	1.33
--- src/run.c	8 Jan 2003 17:06:20 -0000
***************
*** 98,103 ****
--- 98,182 ----
      const char *sterr;
      int flags;
  {
+ #ifdef AMIGA
+     int len,total_len,quotes,escape,result,i,j;
+     char * s;
+     char * arg;
+     char * command;
+ 
+     if (noexec && (flags & RUN_REALLY) == 0)
+    return (0);
+ 
+     total_len = 0;
+     for (i = 0; i < run_argc; i++)
+     {
+         arg = run_argv[i];
+         len = strlen(arg);
+         quotes = 0;
+ 
+         for(j = 0 ; j < len ; j++)
+         {
+            if(arg[j] == ' ' && quotes == 0)
+                quotes = 2;
+            else if (arg[j] == '\"')
+                total_len++;
+         }
+ 
+         total_len += len + quotes + 1;
+     }
+ 
+     command = malloc(total_len+1);
+     if(command == NULL)
+     {
+         errno = ENOMEM;
+         return(-1);
+     }
+ 
+     s = command;
+ 
+     for (i = 0; i < run_argc; i++)
+     {
+         arg = run_argv[i];
+         len = strlen(arg);
+         quotes = escape = 0;
+ 
+         for(j = 0 ; j < len ; j++)
+         {
+            if(arg[j] == ' ')
+                quotes = 1;
+            else if (arg[j] == '\"')
+                escape = 1;
+ 
+            if(quotes == 1 && escape == 1)
+                break;
+         }
+ 
+         if(quotes)
+             (*s++) = '\"';
+ 
+         for(j = 0 ; j < len ; j++)
+         {
+             if(arg[j] == '\"')
+                 (*s++) = '*';
+ 
+             (*s++) = arg[j];
+         }
+ 
+         if(quotes)
+             (*s++) = '\"';
+ 
+         if(i < run_argc-1)
+           (*s++) = ' ';
+     }
+ 
+     (*s) = '\0';
+ 
+     result = system(command);
+     free(command);
+ 
+     return(0);
+ 
+ #else
      int shin, shout, sherr;
      int mode_out, mode_err;
      int status;
***************
*** 345,350 ****
--- 424,431 ----
      if (rerrno)
  	errno = rerrno;
      return (rc);
+ 
+ #endif /* AMIGA */
  }
  
  void
***************
*** 402,407 ****
--- 483,495 ----
       int *tofdp;
       int *fromfdp;
  {
+ #ifdef AMIGA
+     int pid;
+ 
+     pid = amiga_piped_child(command,tofdp,fromfdp);
+ 
+     return(pid);
+ #else
      int pid;
      int to_child_pipe[2];
      int from_child_pipe[2];
***************
*** 447,452 ****
--- 535,541 ----
      *tofdp = to_child_pipe[1];
      *fromfdp = from_child_pipe[0];
      return pid;
+ #endif /* AMIGA */
  }
  
  
***************
*** 454,461 ****
--- 543,552 ----
  close_on_exec (fd)
       int fd;
  {
+ #ifndef AMIGA
  #ifdef F_SETFD
      if (fcntl (fd, F_SETFD, 1))
  	error (1, errno, "can't set close-on-exec flag on %d", fd);
  #endif
+ #endif /* AMIGA */
  }
Index: zlib/zconf.h
===================================================================
RCS file: /cvs/ccvs/zlib/zconf.h,v
retrieving revision 1.1.1.3
diff -c -r1.1.1.3 zconf.h
*** zlib/zconf.h	11 Mar 2002 22:11:55 -0000	1.1.1.3
--- zlib/zconf.h	8 Jan 2003 17:06:22 -0000
***************
*** 276,279 ****
--- 276,283 ----
  #   pragma map(inflate_trees_free,"INTRFR")
  #endif
  
+ #ifdef AMIGA
+ #include "amiga.h"
+ #endif /* AMIGA */
+ 
  #endif /* _ZCONF_H */
