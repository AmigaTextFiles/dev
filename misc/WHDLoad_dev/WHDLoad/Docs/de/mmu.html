<HTML>
<HEAD>
<TITLE>WHDLoad und die MMU</TITLE>
<meta name="DC.Language" content="de">
<meta http-equiv="content-language" content="de">
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
<!-- $Id: mmu.html 1.5 2004/04/07 19:46:11 wepl Exp wepl $ -->
</HEAD>
<BODY>
<h3>WHDLoad und die Memory Managment Unit (MMU)</h3>
Eine MMU ist in den folgenden Prozessoren der 68k-Familie enthalten: 68030, 68040, 68060. Es gibt auch so genannte EC-Versionen dieser Prozessoren welche eine fehlerhafte/nicht funktionierende MMU enthalten. Zum Beispiel sind alle A4000/30 nur mit einem 68EC030 ausgestattet. Bei Beschleunigern von Drittanbietern ist das unterschiedlich. In der zugeh&ouml;rigen Dokumentation sollte die Information welche CPU verbaut wurde aber enthalten sein. Soweit bekannt ist, sind alle in Amigas verwendeten 68040/68060 mit einer funktionierenden MMU ausgestattet (weil der Burstmodus und Zorro III das Markieren der IO-Bereiche erfordert). Die Unterscheidung zwischen einer vollst&auml;ndigen CPU und einer EC-Version kann nicht durch Software getroffen werden (zumindest nicht in aktzeptabler Zeit). Deshalb muss der Benutzer dies mittels <a href="#usercontrol">der richtigen Optionen</a> WHDLoad bekannt machen.
<br>F&uuml;r den 68020 existiert eine externe MMU mit dem Namen 68851, diese wird gegenw&auml;rtig von WHDLoad aber nicht unterst&uuml;tzt.
<h4>F&auml;higkeiten einer MMU und deren Verwendung in WHDLoad</h4>
Die Hauptaufgabe der MMU ist die &Uuml;bersetzung von logischen Adressen in physische. Dies wird ben&ouml;tigt zur Realisierung von virtuellem Speicher und zur Separierung von Adressbereichen (z.B. in einem gesch&uuml;tzten Multiprozesssystem). Eine weitere M&ouml;glichkeit ist es, spezielle Eigenschaften wie Supervisor Only, Schreibschutz und Cache-Modus f&uuml;r jeden Speicherbereich getrennt einzustellen (kachelbasierend, wobei WHDLoad eine Kachelgr&ouml;&szlig;e von 4096 Byte verwendet). WHDLoad benutzt keine logische zu physische Adress&uuml;bersetzung. Aber es nutzt die MMU f&uuml;r <a href="#mem">Speicherschutz</a>, <a href="cache.html">CPU-Cache Verwaltung</a> und einige spezielle Sachen (<a href="snoop.html">Snooping</a>, <A HREF="../../Autodoc/whdload.doc">resload_Protect#?</a>).
<h4><a name="mem">Speicherschutz in WHDLoad</a></h4>
Beim Starten durchsucht WHDLoad die Speicherliste und baut einen &Uuml;bersetzungsbaum auf, der den gesamten verf&uuml;gbaren Speicher einschlie&szlig;t. Es markiert die folgenden Bereiche als g&uuml;ltig und zugreifbar: $0...BaseMem (unter Benutzung der Informationen aus dem Slave), $dff000...$dff200 (Custom Register), $bfd000...$bff000 (Cia Register) und den Speicher der vom Slave und von WHDLoad belegt wird. Wenn ein Freezer im Speicher gefunden wurde, wird sein Speicher ebenfalls g&uuml;ltig gesetzt. Anderer Speicher ist als ung&uuml;ltig markiert, damit resultiert jeder Zugriff darauf (Lese- oder Schreibzugriff) in einer Access Fault Exception, welche WHDLoad in einem entsprechenden Fehlerrequester anzeigt.
<h4><a name="usercontrol">Einstellungen des Benutzers zur MMU-Verwaltung durch WHDLoad</a></h4>
Es gibt drei verschiedene Modi wie WHDLoad eine vorhandene MMU verwaltet.<ol>
<li><b>Ignoriere MMU</b>:
<br>In diesem Modus benutzt WHDLoad die MMU nicht und ver&auml;ndert keines der MMU-Register. Dies mag sinnvoll sein, wenn bereits Programme laufen, die die MMU verwenden und deren Funktion aktiv bleiben soll (z.B. ein Freezer wie TK).
<br>Warnung: Da WHDLoad die MMU nicht selber kontrolliert sind viele Probleme m&ouml;glich. Dies k&ouml;nnen Abst&uuml;rze, Fehlfunktionen oder andere unerwartete Verhaltensweisen sein. Nachfolgend eine Auflistung m&ouml;glicher Probleme:
<ul>
<li>Wenn Enforcer/CyberGuard oder ein &auml;hnliches Programm l&auml;uft, wird der Rechner sich aufh&auml;ngen, da WHDLoad bei der Umschaltung zwischen OS und installiertem Programm eine Vielzahl von Hits erzeugt. Diese Hits sind Teil des normalen Ablaufes, keine Fehler.
<li>Neuere Versionen der 68060.library (beginnend mit v41.1) bilden den Speicher $0-$1000 (die erste Kachel) mittels der MMU in den FastMem ab. Im "Ignoriere MMU" Modus bleibt dies intakt. Wenn nun das installierte Programm versucht diesen Speicherbereich f&uuml;r DMA-Aktivit&auml;ten zu verwenden (z.B. eine Copperliste) f&uuml;hrt das zu einem unvohersehbaren Verhalten, weil die CPU den FastMem-Bereich schreibt/liest, wohingegen die DMA auf den ChipMem-Bereich zugreift, der undefinierte Daten enth&auml;lt.
<li>Wenn der noch aktive MMU-Code seinen Exception-Handler ben&ouml;tigt ("Access Fault") muss auch die Option <a href="opt.html#NoTrapHandler">NoTrapHandler/S</a> aktiviert sein. Ansonsten wird jede auftretende Exception von WHDLoad selbst empfangen, welches das installierte Programm mit einem Fehlerrequester beenden wird.
<li>Wenn der noch aktive MMU-Code Speicher innerhalb BaseMem benutzt (Exception-Handler, &Uuml;bersetzungsbaum, ...), wird das zum Absturz f&uuml;hren, da BaseMem w&auml;hrend der Ausf&uuml;hrung des installierten Programmes &uuml;berschrieben wird.
<li>Generell mag jedes Programm welches elementare Funktionen des Systems ver&auml;ndert (unter Benutzung der MMU) mit WHDLoad zu Problemen f&uuml;hren...
</ul>
<li><b>Deaktiviere MMU</b>:<br>
In diesem Modus, welcher nur auf einem 68030 m&ouml;glich ist, schaltet WHDLoad die MMU komplett aus. Keinerlei MMU-Funktionen sind verf&uuml;gbar.
<li><b>Benutze MMU</b>:<br>
In diesem Modus &uuml;bernimmt WHDLoad die komplette Kontrolle &uuml;ber die MMU und realisiert Speicherschutz und CPU-Cache Verwaltung wie oben beschrieben.
</ol>
Auf 68030 ist der Modus <i>Deaktiviere MMU</i> voreingestellt. Auf 68040/68060 ist voreingestellt <i>Benutze MMU</i>. Es gibt zwei Optionen dies zu ver&auml;ndern. <a href="opt.html#MMU">MMU/S</a> schaltet die MMU Benutzung ein (<i>Benutze MMU</i>) und muss auf 68030 verwendet werden um in den Genuss der MMU-Funktionen zu kommen. <a href="opt.html#NoMMU">NoMMU/S</a> schaltet die Verwendung der MMU durch WHDLoad ab (<i>Ignoriere MMU</i>).
<center><p><cite>Ein Enforcer Hit ist ein Enforcer Hit, Punkt.</cite> (Michael Sinz)</p></center>
</BODY>
</HTML>
