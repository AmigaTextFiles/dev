<HTML>
<HEAD>
<TITLE>Korzystanie z resload_Protect#?</TITLE>
<meta name="DC.Language" content="pl">
<meta http-equiv="content-language" content="pl">
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2">
<!-- $Id: prot.html 1.4 2004/01/12 17:18:29 wepl Exp wepl $ -->
</HEAD>
<BODY>
<h3>Korzystanie z resload_Protect#?</h3>
<h4>Teoria</h4>
Istnieje wiele sytuacji, w których mo¿e byæ bardzo u¿yteczne zdobycie
informacji kiedy zainstalowany program próbuje dostaæ siê do specyficznych
obszarów pamiêci.
Przy pomocy funkcji <a href="../../Autodoc/whdload.doc">resload_Protect#?</a>
jest mo¿liwa chrona pewnych obszarów pamiêci przed zapisem i/lub odczytem.
Ochrona oznacza tyle, ¿e ka¿dy dostêp do takiego chronionego obszaru wygeneruje
wyj±tek b³êdu dostêpu, który zostanie wy¶wietlony w stosownym komunikacie.
Je¿eli zadeklarujemy obszar pamiêci jako chroniony, wykorzystanie funkcji
<a href="../../Autodoc/whdload.doc">resload_Protect#?</a> spowoduje, ¿e
WHDLoad zmodyfikuje opisuj±c± stronê pamiêci w drzewo t³umaczeñ MMU.
Od teraz ka¿da próba dostêpu procesora do chronionej strony pamiêci wygeneruje
wyj±tek b³êdu dostêpu. WHDLoad i jego wewnêtrzne procedury zweryfikuj± powód
wyst±pienia wyj±tku. Je¿eli powodem by³ dostêp do chronionej
<a href="mmu.html">strony</a> pamiêci, lecz dostêp nie odpowiada chronionemu
obszarowi, dostêp zostanie zaemulowany i program bêdzie wykonywany dalej.
W przeciwnym wypadku WHDLoad powróci do systemu ze stosownym komunikatem.
Je¿eli dostêp by³ dostêpem do strumienia instrukcji (procesor próbuje
za³adowaæ kod), zawsze nast±pi emulacja. Innymi s³owy funkcja
<a href="../../Autodoc/whdload.doc">resload_Protect#?</a> oddzia³uje tylko
na odczyt i zapis danych. W rzeczywisto¶ci ka¿dy dostêp do chronionej strony
pamiêci (rozmiar strony pamiêci obecnie wynosi $1000) utworzy b³±d dostêpu,
nawet wtedy, gdy chroniony obszar ma rozmiar 1 bajta.
<h4>Przyk³ad</h4>
Je¿eli instalujesz grê przy pomocy pakietu WHDLoad, musisz za³ataæ oryginalny
kod wczytuj±cy gry w taki sposób, aby skorzysta³ on z WHDLoada do wczytywania danych.
Niektóre gry sprawdzaj± sumy kontrolne pewnych obszarów kodu, aby wykryæ,
czy oryginalny kod by³ modyfikowany. Czasami jest je ciê¿ko znale¼æ.
Wykorzystuj±c funkcjê <a href="../../Autodoc/whdload.doc">resload_Protect#?</a>
nie ma nic prostszego. Nale¿y tylko chroniæ bajty, które siê zmienia³o w kodzie
gry. Od teraz ka¿da procedura, która próbuje sprawdziæ sumê kontroln± i odczytuje
Twój zmodyfikowany kod, wygeneruje b³±d dostêpu, a Ty ju¿ bêdziesz wiedzia³,
gdzie ona siê znajduje.
<h4>Ograniczenia</h4>
Nie wolno chroniæ stron pamiêci, na których znajduj± siê punkty SSP. Je¿eli tak
zrobisz, nast±pi &quot;wyj±tek&quot;, którego efektem bêdzie &quot;podwójny b³±d szyny&quot;, gdy¿
procesor nie bêdzie w stanie zapisaæ ramki stosu wyj±tku.
Po &quot;podwójnym b³êdzie szyny&quot; nale¿y wykonaæ reset. WHDload
sprawdza, czy wystêpuj± konflikty pomiêdzy chronionymi obszarami, a SSP,
i w takim przypadku przerywa dzia³anie, lecz to nie pomo¿e, je¶li SSP
zostanie zmieniony pó¼niej.
<ul>
<li>68020 + 68851
<ul>
<li>ten sprzêt nie jest obecnie obs³ugiwany
</ul>
<li>68030
<ul>
<li>Transfery trzybajtowe nie s± obs³ugiwane i wygeneruj± b³±d dostêpu. Takie
transfery maj± miejce przypadku, gdy wystêpuje dostêp do d³ugiego s³owa na nieparzystym adresie
granicy strony pamiêci (np. &quot;<code>tst.l ($fff)</code>&quot; gdzie strona jest na $1000 i jest chroniona).
<li>Blokowane transfery powodowane przez <code>tas</code>, <code>cas</code> lub <code>cas2</code> nie s± obs³ugiwane
i wygeneruj± b³±d dostêpu. Nie jest to du¿ym problemem, gdy¿ blokowane transfery
nie wystêpuj± na Amidze.
</ul>
<li>68040
<ul>
<li>Ten sprzêt nie jest obecnie obs³ugiwany.
</ul>
<li>68060
<ul>
<li>Dostêpy do nieuporz±dkowanych strumieni danych nie s± obs³ugiwane
i wygeneruj± b³±d dostêpu. Nieuporz±dkowany dostêp jest to dostêp, który
rozci±ga siê miêdzy dwoma stronami pamiêci (z czego co najmniej jedna
z nich jest chroniona). Dla przyk³adu &quot;<code>tst.l ($ffe)</code>&quot;
oddzia³uje na stronê $0..$fff i stronê $1000..$1fff. Takie ograniczenie jest
prawdziwym problemem i spowoduje, ¿e wykorzystanie funkcji
resload_Protect stanie siê czasami bezu¿yteczne. Mo¿e w przysz³o¶ci
spróbujê dodaæ obs³ugê tego, lecz bêdzie to bardzo trudne.
<li>Dostêpy do nieuporz±dkowanych strumieni instrukcji nie s± obs³ugiwane
i wygeneruj± Access Fault je¿eli obie strony pamiêci s± chronione. Zazwyczaj
taka sytuacja jest unikana, ale zdarzaj± siê takie przypadki.
<li>Blokowane transfery powodowane przez <code>tas</code> lub <code>cas</code> nie s± obs³ugiwane
i spowoduj± Access Fault. Nie jest to du¿y problem, gdy¿ blokowane
transfery w ¿aden sposób nie s± obs³ugiwane przez amigowy sprzêt
<li>Instrukcje znajduj±ce siê na chronionej stronie pamiêci (i z tej te¿ racji bêd± emulowane)
i próbuj±ce zapewniæ sobie dostêp do rejestru statusu z poziomu nadzorcy
bêd± wykonane nieprawid³owo. Takie instrukcje zawsze rozpoznaj± ¶ledzone bity
jako bity z przypisan± warto¶ci± 1 i priorytetem maski przerwañ jako 7. Jakiekolwiek
zmiany z poziomu nadzorcy pozostan± bez efektu (niezmienione).
<li>Instrukcja <code>movem</code> mo¿e próbowaæ dostêpu do chronionego
obszaru bez wygenerowania b³êdu dostêpu. Jest to mo¿liwe poniewa¿ tylko pierwsza
próba dostêpu (s³owo lub d³ugie s³owo) jest sprawdzane pod k±tem pasowania do chronionego obszaru.
<li>Instrukcja <code>move16</code> i operacje podwójnej precyzji (FPU) nie s± obs³ugiwane
i wygeneruj± b³±d dostêpu.
<li>Instrukcja &quot;<code>move (mem),(mem)</code>&quot; z zachodz±cym na siebie adresem ¼ród³owym
i docelowym generuje b³±d dostêpu z powodu nieuporz±dkowania. Dla przyk³adu
&quot;<code>move.l ($ffc),($ffe)</code>&quot;, gdzie strona $1000..$1fff jest
chroniona, pamiêæ przed wykonaniem zawiera ($ffc)=$11112222, ($1000)=$33334444, a po
wykonaniu $1000 zawiera $11114444 a nie $22224444
</ul>
</ul>
</BODY>
</HTML>
