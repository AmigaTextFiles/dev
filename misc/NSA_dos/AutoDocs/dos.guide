@DATABASE "dos.guide"
@INDEX .Index.guide/Main
@AUTHOR AmiS <amis@amiga.org.ru> © 1998-2002
@WORDWRAP
@$VER: dos.library 40.3 autodocs 1.3
@HELP help

@NODE Help "Copyright 1998-2002 AmiS"
 @{fg shine}dos.library 40.3@{fg text}  Version 1.3
 This is a NewStyle Autodocs for Amiga Developer Community.

 Designed 1999-2002 by @{fg shine}AmiS@{fg text}
 Send your bug report to @{fg fill}amis@amiga.org.ru@{fg text}

@ENDNODE

@NODE Main "dos.library"
@PREV Main
@{jcenter}@{b} A @{ub}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" E " LINK MainE 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" I " LINK MainI 0}@{" L " LINK MainL 0}@{" M " LINK MainM 0}@{" N " LINK MainN 0}@{" O " LINK MainO 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" U " LINK MainU 0}@{" V " LINK MainV 0}@{" W " LINK MainW 0}
@{jcenter}
@{u}@{b}dos.library@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}A@{ub}@{lindent 4}
@{lindent 31}@{" AbortPkt()           " LINK "AbortPkt"}  - aborts an asynchronous packet, if possible.  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" AddBuffers()         " LINK "AddBuffers"}  - changes the number of buffers for a filesystem  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" AddDosEntry()        " LINK "AddDosEntry"}  - add a Dos List entry to the lists  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" AddPart()            " LINK "AddPart"}  - appends a file/dir to the end of a path  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" AddSegment()         " LINK "AddSegment"}  - adds a resident segment to the resident list  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" AllocDosObject()     " LINK "AllocDosObject"}  - creates a dos object  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" AssignAdd()          " LINK "AssignAdd"}  - adds a lock to an assign for multi-directory assigns  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" AssignLate()         " LINK "AssignLate"}  - creates an assignment to a specified path later  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" AssignLock()         " LINK "AssignLock"}  - creates an assignment to a locked object  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" AssignPath()         " LINK "AssignPath"}  - creates an assignment to a specified path  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" AttemptLockDosList() " LINK "AttemptLockDosList"}  - attempt to lock the Dos Lists for use  @{fg shine}(V36)@{fg text}
@ENDNODE

@NODE MainC "dos.library"
@{jcenter}@{" A " LINK Main 0}@{b} C @{ub}@{" D " LINK MainD 0}@{" E " LINK MainE 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" I " LINK MainI 0}@{" L " LINK MainL 0}@{" M " LINK MainM 0}@{" N " LINK MainN 0}@{" O " LINK MainO 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" U " LINK MainU 0}@{" V " LINK MainV 0}@{" W " LINK MainW 0}
@{jcenter}
@{u}@{b}dos.library@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}C@{ub}@{lindent 4}
@{lindent 31}@{" ChangeMode()         " LINK "ChangeMode"}  - change the current mode of a lock or filehandle  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" CheckSignal()        " LINK "CheckSignal"}  - checks for break signals  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" Cli()                " LINK "Cli"}  - returns a pointer to the CLI structure of the process  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" CliInitNewcli()      " LINK "CliInitNewcli"}  - set up a process to be a shell from initial packet@{lindent 4}
@{lindent 31}@{" CliInitRun()         " LINK "CliInitRun"}  - set up a process to be a shell from initial packet@{lindent 4}
@{lindent 31}@{" Close()              " LINK "Close"}  - close an open file@{lindent 4}
@{lindent 31}@{" CompareDates()       " LINK "CompareDates"}  - compares two datestamps  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" CreateDir()          " LINK "CreateDir"}  - create a new directory@{lindent 4}
@{lindent 31}@{" CreateNewProc()      " LINK "CreateNewProc"}  - create a new process  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" CreateProc()         " LINK "CreateProc"}  - create a new process@{lindent 4}
@{lindent 31}@{" CurrentDir()         " LINK "CurrentDir"}  - make a directory lock the current directory
@ENDNODE

@NODE MainD "dos.library"
@{jcenter}@{" A " LINK Main 0}@{" C " LINK MainC 0}@{b} D @{ub}@{" E " LINK MainE 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" I " LINK MainI 0}@{" L " LINK MainL 0}@{" M " LINK MainM 0}@{" N " LINK MainN 0}@{" O " LINK MainO 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" U " LINK MainU 0}@{" V " LINK MainV 0}@{" W " LINK MainW 0}
@{jcenter}
@{u}@{b}dos.library@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}D@{ub}@{lindent 4}
@{lindent 31}@{" DateStamp()          " LINK "DateStamp"}  - obtain the date and time in internal format@{lindent 4}
@{lindent 31}@{" DateToStr()          " LINK "DateToStr"}  - converts a DateStamp to a string  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" Delay()              " LINK "Delay"}  - delay a process for a specified time@{lindent 4}
@{lindent 31}@{" DeleteFile()         " LINK "DeleteFile"}  - delete a file or directory@{lindent 4}
@{lindent 31}@{" DeleteVar()          " LINK "DeleteVar"}  - deletes a local or environment variable  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" DeviceProc()         " LINK "DeviceProc"}  - return the process MsgPort of specific I/O handler@{lindent 4}
@{lindent 31}@{" DoPkt()              " LINK "DoPkt"}  - send a dos packet and wait for reply  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" DupLock()            " LINK "DupLock"}  - duplicate a lock@{lindent 4}
@{lindent 31}@{" DupLockFromFH()      " LINK "DupLockFromFH"}  - gets a lock on an open file  @{fg shine}(V36)@{fg text}
@ENDNODE

@NODE MainE "dos.library"
@{jcenter}@{" A " LINK Main 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{b} E @{ub}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" I " LINK MainI 0}@{" L " LINK MainL 0}@{" M " LINK MainM 0}@{" N " LINK MainN 0}@{" O " LINK MainO 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" U " LINK MainU 0}@{" V " LINK MainV 0}@{" W " LINK MainW 0}
@{jcenter}
@{u}@{b}dos.library@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}E@{ub}@{lindent 4}
@{lindent 31}@{" EndNotify()          " LINK "EndNotify"}  - ends a notification request  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" ErrorReport()        " LINK "ErrorReport"}  - displays a Retry/Cancel requester for an error  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" ExAll()              " LINK "ExAll"}  - examine an entire directory  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" ExAllEnd()           " LINK "ExAllEnd"}  - stop an @{fg fill}ExAll()@{fg text}  @{fg shine}(V39)@{fg text}@{lindent 4}
@{lindent 31}@{" Examine()            " LINK "Examine"}  - examine a directory or file associated with a lock@{lindent 4}
@{lindent 31}@{" ExamineFH()          " LINK "ExamineFH"}  - gets information on an open file  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" Execute()            " LINK "Execute"}  - execute a CLI command@{lindent 4}
@{lindent 31}@{" Exit()               " LINK "Exit"}  - exit from a program@{lindent 4}
@{lindent 31}@{" ExNext()             " LINK "ExNext"}  - examine the next entry in a directory
@ENDNODE 

@NODE MainF "dos.library"
@{jcenter}@{" A " LINK Main 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" E " LINK MainE 0}@{b} F @{ub}@{" G " LINK MainG 0}@{" I " LINK MainI 0}@{" L " LINK MainL 0}@{" M " LINK MainM 0}@{" N " LINK MainN 0}@{" O " LINK MainO 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" U " LINK MainU 0}@{" V " LINK MainV 0}@{" W " LINK MainW 0}
@{jcenter}
@{u}@{b}dos.library@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}F@{ub}@{lindent 4}
@{lindent 31}@{" Fault()              " LINK "Fault"}  - returns the text associated with a DOS error code  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" FGetC()              " LINK "FGetC"}  - read a character from the specified input (buffered)  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" FGets()              " LINK "FGets"}  - reads a line from the specified input (buffered)  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" FilePart()           " LINK "FilePart"}  - returns the last component of a path  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" FindArg()            " LINK "FindArg"}  - find a keyword in a template  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" FindCliProc()        " LINK "FindCliProc"}  - returns a pointer to the requested CLI process  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" FindDosEntry()       " LINK "FindDosEntry"}  - finds a specific Dos List entry  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" FindSegment()        " LINK "FindSegment"}  - finds a segment on the resident list  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" FindVar()            " LINK "FindVar"}  - finds a local variable  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" Flush()              " LINK "Flush"}  - flushes buffers for a buffered filehandle  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" Format()             " LINK "Format"}  - causes a filesystem to initialize itself  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" FPutC()              " LINK "FPutC"}  - write a character to the specified output (buffered)  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" FPuts()              " LINK "FPuts"}  - writes a string the the specified output (buffered)  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" FRead()              " LINK "FRead"}  - reads a number of blocks from an input (buffered)  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" FreeArgs()           " LINK "FreeArgs"}  - free allocated memory after @{fg fill}ReadArgs()@{fg text}  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" FreeDeviceProc()     " LINK "FreeDeviceProc"}  - releases port returned by @{fg fill}GetDeviceProc()@{fg text}  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" FreeDosEntry()       " LINK "FreeDosEntry"}  - frees an entry created by @{fg fill}MakeDosEntry()@{fg text}  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" FreeDosObject()      " LINK "FreeDosObject"}  - frees an object allocated by @{fg fill}AllocDosObject()@{fg text}  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" FWrite()             " LINK "FWrite"}  - writes a number of blocks to an output (buffered)  @{fg shine}(V36)@{fg text}
@ENDNODE 

@NODE MainG "dos.library"
@{jcenter}@{" A " LINK Main 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" E " LINK MainE 0}@{" F " LINK MainF 0}@{b} G @{ub}@{" I " LINK MainI 0}@{" L " LINK MainL 0}@{" M " LINK MainM 0}@{" N " LINK MainN 0}@{" O " LINK MainO 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" U " LINK MainU 0}@{" V " LINK MainV 0}@{" W " LINK MainW 0}
@{jcenter}
@{u}@{b}dos.library@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}G@{ub}@{lindent 4}
@{lindent 31}@{" GetArgStr()          " LINK "GetArgStr"}  - returns the arguments for the process  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" GetConsoleTask()     " LINK "GetConsoleTask"}  - returns the default console for the process  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" GetCurrentDirName()  " LINK "GetCurrentDirName"}  - returns the current directory name  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" GetDeviceProc()      " LINK "GetDeviceProc"}  - finds a handler to send a message to  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" GetFileSysTask()     " LINK "GetFileSysTask"}  - returns the default filesystem for the process  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" GetProgramDir()      " LINK "GetProgramDir"}  - returns a lock on the directory the program was loaded from  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" GetProgramName()     " LINK "GetProgramName"}  - returns the current program name  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" GetPrompt()          " LINK "GetPrompt"}  - returns the prompt for the current process  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" GetVar()             " LINK "GetVar"}  - returns the value of a local or global variable  @{fg shine}(V36)@{fg text}
@ENDNODE 

@NODE MainI "dos.library"
@{jcenter}@{" A " LINK Main 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" E " LINK MainE 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{b} I @{ub}@{" L " LINK MainL 0}@{" M " LINK MainM 0}@{" N " LINK MainN 0}@{" O " LINK MainO 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" U " LINK MainU 0}@{" V " LINK MainV 0}@{" W " LINK MainW 0}
@{jcenter}
@{u}@{b}dos.library@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}I@{ub}@{lindent 4}
@{lindent 31}@{" Info()               " LINK "Info"}  - returns information about the disk@{lindent 4}
@{lindent 31}@{" Inhibit()            " LINK "Inhibit"}  - inhibits access to a filesystem  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" Input()              " LINK "Input"}  - identify the program's initial input file handle@{lindent 4}
@{lindent 31}@{" InternalLoadSeg()    " LINK "InternalLoadSeg"}  - low-level load routine  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" InternalUnLoadSeg()  " LINK "InternalUnLoadSeg"}  - unloads a seglist loaded with @{fg fill}InternalLoadSeg()@{fg text}  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" IoErr()              " LINK "IoErr"}  - return extra information from the system@{lindent 4}
@{lindent 31}@{" IsFileSystem()       " LINK "IsFileSystem"}  - returns whether a Dos handler is a filesystem  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" IsInteractive()      " LINK "IsInteractive"}  - discover whether a file is "interactive"
@ENDNODE 

@NODE MainL "dos.library"
@{jcenter}@{" A " LINK Main 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" E " LINK MainE 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" I " LINK MainI 0}@{b} L @{ub}@{" M " LINK MainM 0}@{" N " LINK MainN 0}@{" O " LINK MainO 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" U " LINK MainU 0}@{" V " LINK MainV 0}@{" W " LINK MainW 0}
@{jcenter}
@{u}@{b}dos.library@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}L@{ub}@{lindent 4}
@{lindent 31}@{" LoadSeg()            " LINK "LoadSeg"}  - scatterload a loadable file into memory@{lindent 4}
@{lindent 31}@{" Lock()               " LINK "Lock"}  - lock a directory or file@{lindent 4}
@{lindent 31}@{" LockDosList()        " LINK "LockDosList"}  - locks the specified Dos Lists for use  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" LockRecord()         " LINK "LockRecord"}  - locks a portion of a file  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" LockRecords()        " LINK "LockRecords"}  - lock a series of records  @{fg shine}(V36)@{fg text}
@ENDNODE 

@NODE MainM "dos.library"
@{jcenter}@{" A " LINK Main 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" E " LINK MainE 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" I " LINK MainI 0}@{" L " LINK MainL 0}@{b} M @{ub}@{" N " LINK MainN 0}@{" O " LINK MainO 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" U " LINK MainU 0}@{" V " LINK MainV 0}@{" W " LINK MainW 0}
@{jcenter}
@{u}@{b}dos.library@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}M@{ub}@{lindent 4}
@{lindent 31}@{" MakeDosEntry()       " LINK "MakeDosEntry"}  - creates a DosList structure  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" MakeLink()           " LINK "MakeLink"}  - creates a filesystem link  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" MatchEnd()           " LINK "MatchEnd"}  - free storage allocated for @{fg fill}MatchFirst()@{fg text}/@{fg fill}MatchNext()@{fg text}  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" MatchFirst()         " LINK "MatchFirst"}  - finds file that matches pattern  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" MatchNext()          " LINK "MatchNext"}  - finds the next file or directory that matches pattern  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" MatchPattern()       " LINK "MatchPattern"}  - checks for a pattern match with a string  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" MatchPatternNoCase() " LINK "MatchPatternNoCase"}  - checks for a pattern match with a string  @{fg shine}(V37)@{fg text}@{lindent 4}
@{lindent 31}@{" MaxCli()             " LINK "MaxCli"}  - returns the highest CLI process number possibly in use  @{fg shine}(V36)@{fg text}
@ENDNODE

@NODE MainN "dos.library"
@{jcenter}@{" A " LINK Main 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" E " LINK MainE 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" I " LINK MainI 0}@{" L " LINK MainL 0}@{" M " LINK MainM 0}@{b} N @{ub}@{" O " LINK MainO 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" U " LINK MainU 0}@{" V " LINK MainV 0}@{" W " LINK MainW 0}
@{jcenter}
@{u}@{b}dos.library@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}N@{ub}@{lindent 4}
@{lindent 31}@{" NameFromFH()         " LINK "NameFromFH"}  - get the name of an open filehandle  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" NameFromLock()       " LINK "NameFromLock"}  - returns the name of a locked object  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" NewLoadSeg()         " LINK "NewLoadSeg"}  - improved version of @{fg fill}LoadSeg()@{fg text} for stacksizes  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" NextDosEntry()       " LINK "NextDosEntry"}  - get the next Dos List entry  @{fg shine}(V36)@{fg text}
@ENDNODE

@NODE MainO "dos.library"
@{jcenter}@{" A " LINK Main 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" E " LINK MainE 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" I " LINK MainI 0}@{" L " LINK MainL 0}@{" M " LINK MainM 0}@{" N " LINK MainN 0}@{b} O @{ub}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" U " LINK MainU 0}@{" V " LINK MainV 0}@{" W " LINK MainW 0}
@{jcenter}
@{u}@{b}dos.library@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}O@{ub}@{lindent 4}
@{lindent 31}@{" Open()               " LINK "Open"}  - open a file for input or output@{lindent 4}
@{lindent 31}@{" OpenFromLock()       " LINK "OpenFromLock"}  - opens a file you have a lock on  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" Output()             " LINK "Output"}  - identify the programs' initial output file handle
@ENDNODE

@NODE MainP "dos.library"
@{jcenter}@{" A " LINK Main 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" E " LINK MainE 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" I " LINK MainI 0}@{" L " LINK MainL 0}@{" M " LINK MainM 0}@{" N " LINK MainN 0}@{" O " LINK MainO 0}@{b} P @{ub}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" U " LINK MainU 0}@{" V " LINK MainV 0}@{" W " LINK MainW 0}
@{jcenter}
@{u}@{b}dos.library@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}P@{ub}@{lindent 4}
@{lindent 31}@{" ParentDir()          " LINK "ParentDir"}  - obtain the parent of a directory or file@{lindent 4}
@{lindent 31}@{" ParentOfFH()         " LINK "ParentOfFH"}  - returns a lock on the parent directory of a file  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" ParsePattern()       " LINK "ParsePattern"}  - create a tokenized string for @{fg fill}MatchPattern()@{fg text}  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" ParsePatternNoCase() " LINK "ParsePatternNoCase"}  - create a tokenized string for @{fg fill}MatchPatternNoCase()@{fg text}  @{fg shine}(V37)@{fg text}@{lindent 4}
@{lindent 31}@{" PathPart()           " LINK "PathPart"}  - returns a pointer to the end of the next-to-last component of a path.  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" PrintFault()         " LINK "PrintFault"}  - returns the text associated with a DOS error code  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" PutStr()             " LINK "PutStr"}  - writes a string the the default output (buffered)  @{fg shine}(V36)@{fg text}
@ENDNODE

@NODE MainR "dos.library"
@{jcenter}@{" A " LINK Main 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" E " LINK MainE 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" I " LINK MainI 0}@{" L " LINK MainL 0}@{" M " LINK MainM 0}@{" N " LINK MainN 0}@{" O " LINK MainO 0}@{" P " LINK MainP 0}@{b} R @{ub}@{" S " LINK MainS 0}@{" U " LINK MainU 0}@{" V " LINK MainV 0}@{" W " LINK MainW 0}
@{jcenter}
@{u}@{b}dos.library@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}R@{ub}@{lindent 4}
@{lindent 31}@{" Read()               " LINK "Read"}  - read bytes of data from a file@{lindent 4}
@{lindent 31}@{" ReadArgs()           " LINK "ReadArgs"}  - parse the command line input  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" ReadItem()           " LINK "ReadItem"}  - reads a single argument/name from command line  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" ReadLink()           " LINK "ReadLink"}  - reads the path for a soft filesystem link  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" Relabel()            " LINK "Relabel"}  - change the volume name of a volume  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" RemAssignList()      " LINK "RemAssignList"}  - remove an entry from a multi-dir assign  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" RemDosEntry()        " LINK "RemDosEntry"}  - removes a Dos List entry from it's list  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" RemSegment()         " LINK "RemSegment"}  - removes a resident segment from the resident list  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" Rename()             " LINK "Rename"}  - rename a directory or file@{lindent 4}
@{lindent 31}@{" ReplyPkt()           " LINK "ReplyPkt"}  - replies a packet to the person who sent it to you  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" RunCommand()         " LINK "RunCommand"}  - runs a program using the current process  @{fg shine}(V36)@{fg text}
@ENDNODE

@NODE MainS "dos.library"
@{jcenter}@{" A " LINK Main 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" E " LINK MainE 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" I " LINK MainI 0}@{" L " LINK MainL 0}@{" M " LINK MainM 0}@{" N " LINK MainN 0}@{" O " LINK MainO 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{b} S @{ub}@{" U " LINK MainU 0}@{" V " LINK MainV 0}@{" W " LINK MainW 0}
@{jcenter}
@{u}@{b}dos.library@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}S@{ub}@{lindent 4}
@{lindent 31}@{" SameDevice()         " LINK "SameDevice"}  - are two locks are on partitions of the device?  @{fg shine}(V37)@{fg text}@{lindent 4}
@{lindent 31}@{" SameLock()           " LINK "SameLock"}  - returns whether two locks are on the same object  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" Seek()               " LINK "Seek"}  - set the current position for reading and writing@{lindent 4}
@{lindent 31}@{" SelectInput()        " LINK "SelectInput"}  - select a filehandle as the default input channel  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" SelectOutput()       " LINK "SelectOutput"}  - select a filehandle as the default output channel  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" SendPkt()            " LINK "SendPkt"}  - sends a packet to a handler  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" SetArgStr()          " LINK "SetArgStr"}  - sets the arguments for the current process  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" SetComment()         " LINK "SetComment"}  - change a files' comment string@{lindent 4}
@{lindent 31}@{" SetConsoleTask()     " LINK "SetConsoleTask"}  - sets the default console for the process  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" SetCurrentDirName()  " LINK "SetCurrentDirName"}  - sets the directory name for the process  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" SetFileDate()        " LINK "SetFileDate"}  - sets the modification date for a file or dir  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" SetFileSize()        " LINK "SetFileSize"}  - sets the size of a file  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" SetFileSysTask()     " LINK "SetFileSysTask"}  - sets the default filesystem for the process  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" SetIoErr()           " LINK "SetIoErr"}  - sets the value returned by @{fg fill}IoErr()@{fg text}  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" SetMode()            " LINK "SetMode"}  - set the current behavior of a handler  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" SetOwner()           " LINK "SetOwner"}  - set owner information for a file or directory  @{fg shine}(V39)@{fg text}@{lindent 4}
@{lindent 31}@{" SetProgramDir()      " LINK "SetProgramDir"}  - sets the directory returned by @{fg fill}GetProgramDir()@{fg text}  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" SetProgramName()     " LINK "SetProgramName"}  - sets the name of the program being run  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" SetPrompt()          " LINK "SetPrompt"}  - sets the CLI/shell prompt for the current process  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" SetProtection()      " LINK "SetProtection"}  - set protection for a file or directory@{lindent 4}
@{lindent 31}@{" SetVar()             " LINK "SetVar"}  - sets a local or environment variable  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" SetVBuf()            " LINK "SetVBuf"}  - set buffering modes and size  @{fg shine}(V39)@{fg text}@{lindent 4}
@{lindent 31}@{" SplitName()          " LINK "SplitName"}  - splits out a component of a pathname into a buffer  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" StartNotify()        " LINK "StartNotify"}  - starts notification on a file or directory  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" StrToDate()          " LINK "StrToDate"}  - converts a string to a DateStamp  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" StrToLong()          " LINK "StrToLong"}  - string to long value (decimal)  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" SystemTagList()      " LINK "SystemTagList"}  - have a shell execute a command line  @{fg shine}(V36)@{fg text}
@ENDNODE

@NODE MainU "dos.library"
@{jcenter}@{" A " LINK Main 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" E " LINK MainE 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" I " LINK MainI 0}@{" L " LINK MainL 0}@{" M " LINK MainM 0}@{" N " LINK MainN 0}@{" O " LINK MainO 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{b} U @{ub}@{" V " LINK MainV 0}@{" W " LINK MainW 0}
@{jcenter}
@{u}@{b}dos.library@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}U@{ub}@{lindent 4}
@{lindent 31}@{" UnGetC()             " LINK "UnGetC"}  - makes a char available for reading again. (buffered)  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" UnLoadSeg()          " LINK "UnLoadSeg"}  - unload a seglist previously loaded by @{fg fill}LoadSeg()@{fg text}@{lindent 4}
@{lindent 31}@{" UnLock()             " LINK "UnLock"}  - unlock a directory or file@{lindent 4}
@{lindent 31}@{" UnLockDosList()      " LINK "UnLockDosList"}  - unlocks the Dos List  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" UnLockRecord()       " LINK "UnLockRecord"}  - unlock a record  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" UnLockRecords()      " LINK "UnLockRecords"}  - unlock a list of records  @{fg shine}(V36)@{fg text}
@ENDNODE

@NODE MainV "dos.library"
@{jcenter}@{" A " LINK Main 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" E " LINK MainE 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" I " LINK MainI 0}@{" L " LINK MainL 0}@{" M " LINK MainM 0}@{" N " LINK MainN 0}@{" O " LINK MainO 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" U " LINK MainU 0}@{b} V @{ub}@{" W " LINK MainW 0}
@{jcenter}
@{u}@{b}dos.library@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}V@{ub}@{lindent 4}
@{lindent 31}@{" VFPrintf()           " LINK "VFPrintf"}  - format and print a string to a file (buffered)  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" VFWritef()           " LINK "VFWritef"}  - write a BCPL formatted string to a file (buffered)  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" VPrintf()            " LINK "VPrintf"}  - format and print string (buffered)  @{fg shine}(V36)@{fg text}
@ENDNODE

@NODE MainW "dos.library"
@NEXT MainW
@{jcenter}@{" A " LINK Main 0}@{" C " LINK MainC 0}@{" D " LINK MainD 0}@{" E " LINK MainE 0}@{" F " LINK MainF 0}@{" G " LINK MainG 0}@{" I " LINK MainI 0}@{" L " LINK MainL 0}@{" M " LINK MainM 0}@{" N " LINK MainN 0}@{" O " LINK MainO 0}@{" P " LINK MainP 0}@{" R " LINK MainR 0}@{" S " LINK MainS 0}@{" U " LINK MainU 0}@{" V " LINK MainV 0}@{b} W @{ub}
@{jcenter}
@{u}@{b}dos.library@{uu}@{ub}
@{jleft}@{lindent 1}
@{b}W@{ub}@{lindent 4}
@{lindent 31}@{" WaitForChar()        " LINK "WaitForChar"}  - determine if chars arrive within a time limit@{lindent 4}
@{lindent 31}@{" WaitPkt()            " LINK "WaitPkt"}  - waits for a packet to arrive at your pr_MsgPort  @{fg shine}(V36)@{fg text}@{lindent 4}
@{lindent 31}@{" Write()              " LINK "Write"}  - write bytes of data to a file@{lindent 4}
@{lindent 31}@{" WriteChars()         " LINK "WriteChars"}  - writes bytes to the the default output (buffered)  @{fg shine}(V36)@{fg text}
@ENDNODE

@NODE "AbortPkt" "dos.library/AbortPkt()"
@PREV AbortPkt
@{jcenter}
@{u}@{b}AbortPkt()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
AbortPkt - Aborts an asynchronous packet, if possible.  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
AbortPkt(port, pkt)
         D1    D2

void AbortPkt(struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *, struct @{"DosPacket" LINK "include:dos/dosextens.h/MAIN" 107} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This attempts to abort a packet sent earlier with @{"SendPkt()" LINK "SendPkt" 0} to a handler. There is no guarantee that any given handler will allow a packet to be aborted, or if it is aborted whether function requested completed first or completely. After calling AbortPkt(), you must wait for the packet to return before reusing it or deallocating it.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
port - port the packet was sent to
pkt  - the packet you wish aborted
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
As of @{fg shine}V37@{fg text}, this function does nothing.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"SendPkt()" LINK "SendPkt" 0}, @{"DoPkt()" LINK "DoPkt" 0}, @{"WaitPkt()" LINK "WaitPkt" 0}
@ENDNODE

@NODE "AddBuffers" "dos.library/AddBuffers()"
@{jcenter}
@{u}@{b}AddBuffers()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
AddBuffers - Changes the number of buffers for a filesystem  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = AddBuffers(filesystem, number)
D0                   D1          D2

BOOL AddBuffers(STRPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Adds buffers to a filesystem. If it succeeds, the number of current buffers is returned in @{"IoErr()" LINK "IoErr" 0}. Note that "number" may be negative. The amount of memory used per buffer, and any limits on the number of buffers, are dependant on the filesystem in question.
If the call succeeds, the number of buffers in use on the filesystem will be returned by @{"IoErr()" LINK "IoErr" 0}.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
filesystem - Name of device to add buffers to (with ':').
number     - Number of buffers to add.  May be negative.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success    - Success or failure of command.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
The @{fg shine}V36@{fg text} ROM filesystem (FFS/OFS) doesn't return the right number of buffers unless preceded by an AddBuffers(fs,-1) (in-use buffers aren't counted). This is fixed in @{fg shine}V37@{fg text}.

The @{fg shine}V37@{fg text} and before ROM filesystem doesn't return success, it returns the number of buffers. The best way to test for this is to consider 0 (FALSE) failure, -1 (DOSTRUE) to mean that @{"IoErr()" LINK "IoErr" 0} will have the number of buffers, and any other positive value to be the number of buffers. It may be fixed in some future ROM revision.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"IoErr()" LINK "IoErr" 0}
@ENDNODE

@NODE "AddDosEntry" "dos.library/AddDosEntry()"
@{jcenter}
@{u}@{b}AddDosEntry()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
AddDosEntry - Add a Dos List entry to the lists  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = AddDosEntry(dlist)
D0                    D1

LONG AddDosEntry(struct @{"DosList" LINK "include:dos/dosextens.h/MAIN" 371} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Adds a device, volume or assign to the dos devicelist. Can fail if it conflicts with an existing entry (such as another assign to the same name or another device of the same name). Volume nodes with different dates and the same name CAN be added, or with names that conflict with devices or assigns. Note: the dos list does NOT have to be locked to call this. Do not access dlist after adding unless you have locked the Dos Device list.

An additional note concerning calling this from within a handler: in order to avoid deadlocks, your handler must either be multi-threaded, or it must attempt to lock the list before calling this function. The code would look something like this:

if (@{"AttemptLockDosList" LINK "AttemptLockDosList" 0}(LDF_xxx|LDF_WRITE))
{
        rc = AddDosEntry(...);
        @{"UnLockDosList" LINK "UnLockDosList" 0}(LDF_xxx|LDF_WRITE);
}

If @{"AttemptLockDosList()" LINK "AttemptLockDosList" 0} fails (i.e. it's locked already), check for messages at your filesystem port (don't wait!) and try the @{"AttemptLockDosList()" LINK "AttemptLockDosList" 0} again.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
dlist   - Device list entry to be added.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/Failure indicator
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"RemDosEntry()" LINK "RemDosEntry" 0}, @{"FindDosEntry()" LINK "FindDosEntry" 0}, @{"NextDosEntry()" LINK "NextDosEntry" 0}, @{"LockDosList()" LINK "LockDosList" 0}, @{"MakeDosEntry()" LINK "MakeDosEntry" 0}, @{"FreeDosEntry()" LINK "FreeDosEntry" 0}, @{"AttemptLockDosList()" LINK "AttemptLockDosList" 0}
@ENDNODE

@NODE "AddPart" "dos.library/AddPart()"
@{jcenter}
@{u}@{b}AddPart()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
AddPart - Appends a file/dir to the end of a path  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = AddPart( dirname, filename, size )
D0                 D1        D2      D3

BOOL AddPart( STRPTR, STRPTR, ULONG )
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function adds a file, directory, or subpath name to a directory path name taking into account any required separator characters. If filename is a fully-qualified path it will totally replace the current value of dirname.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
dirname  - the path to add a file/directory name to.
@{lindent 19}filename - the filename or directory name to add. May be a relative pathname from the current directory (example: foo/bar). Can deal with leading '/'(s), indicating one directory up per '/', or with a ':', indicating it's relative to the root of the appropriate volume.@{lindent 8}
@{lindent 19}size     - size in bytes of the space allocated for dirname. Must not be 0.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 18}success - non-zero for ok, FALSE if the buffer would have overflowed. If an overflow would have occured, dirname will not be changed.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Doesn't check if a subpath is legal (i.e. doesn't check for ':'s) and doesn't handle leading '/'s in 2.0 through 2.02 @{fg shine}(V36)@{fg text}. @{fg shine}V37@{fg text} fixes this, allowing filename to be any path, including absolute.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FilePart()" LINK "FilePart" 0}, @{"PathPart()" LINK "PathPart" 0}
@ENDNODE

@NODE "AddSegment" "dos.library/AddSegment()"
@{jcenter}
@{u}@{b}AddSegment()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
AddSegment - Adds a resident segment to the resident list  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = AddSegment(name, seglist, type)
D0                   D1     D2      D3

BOOL AddSegment(STRPTR, BPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Adds a segment to the Dos resident list, with the specified Seglist and type (stored in seg_UC - normally 0). NOTE: currently unused types may cause it to interpret other registers (d4-?) as additional parameters in the future.

Do NOT build Segment structures yourself!
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name    - name for the segment
seglist - Dos seglist of code for segment
type    - initial usecount, normally 0
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - success or failure
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FindSegment()" LINK "FindSegment" 0}, @{"RemSegment()" LINK "RemSegment" 0}, @{"LoadSeg()" LINK "LoadSeg" 0}
@ENDNODE

@NODE "AllocDosObject" "dos.library/AllocDosObject()"
@{jcenter}
@{u}@{b}AllocDosObject()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
AllocDosObject - Creates a dos object  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
ptr = AllocDosObject(type, tags)
D0                   D1    D2

void *AllocDosObject(ULONG, struct @{"TagItem" LINK "include:utility/tagitem.h/MAIN" 32} *)

ptr = AllocDosObjectTagList(type, tags)
D0                          D1    D2

void *AllocDosObjectTagList(ULONG, struct @{"TagItem" LINK "include:utility/tagitem.h/MAIN" 32} *)

ptr = AllocDosObjectTags(type, Tag1, ...)

void *AllocDosObjectTags(ULONG, ULONG, ...)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Create one of several dos objects, initializes it, and returns it to you. Note the DOS_STDPKT returns a pointer to the sp_Pkt of the structure.

This function may be called by a task for all types and tags defined in the @{fg shine}V37@{fg text} includes (DOS_FILEHANDLE through DOS_RDARGS and ADO_FH_Mode through ADO_PromptLen, respectively). Any future types or tags will be documented as to whether a task may use them.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
type - type of object requested
tags - pointer to taglist with additional information
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
packet - pointer to the object or NULL
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Before @{fg shine}V39@{fg text}, DOS_CLI should be used with care since @{"FreeDosObject()" LINK "FreeDosObject" 0} can't free it.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FreeDosObject()" LINK "FreeDosObject" 0}, <@{"dos/dostags.h" LINK "include:dos/dostags.h/MAIN" 0}>, <@{"dos/dos.h" LINK "include:dos/dos.h/MAIN" 0}>
@ENDNODE

@NODE "AssignAdd" "dos.library/AssignAdd()"
@{jcenter}
@{u}@{b}AssignAdd()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
AssignAdd - Adds a lock to an assign for multi-directory assigns  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = AssignAdd(name,lock)
D0                  D1   D2

BOOL AssignAdd(STRPTR,BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Adds a lock to an assign, making or adding to a multi-directory assign. Note that this only will succeed on an assign created with @{"AssignLock()" LINK "AssignLock" 0}, or an assign created with @{"AssignLate()" LINK "AssignLate" 0} which has been resolved (converted into a @{"AssignLock()" LINK "AssignLock" 0}-assign).

NOTE: you should not use the lock in any way after making this call successfully. It becomes the part of the assign, and will be unlocked by the system when the assign is removed. If you need to keep the lock, pass a lock from @{"DupLock()" LINK "DupLock" 0} to @{"AssignLock()" LINK "AssignLock" 0}.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name - Name of device to assign lock to (without trailing ':')
lock - Lock associated with the assigned name
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure indicator. On failure, the lock is not unlocked.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Lock()" LINK "Lock" 0}, @{"AssignLock()" LINK "AssignLock" 0}, @{"AssignPath()" LINK "AssignPath" 0}, @{"AssignLate()" LINK "AssignLate" 0}, @{"DupLock()" LINK "DupLock" 0}, @{"RemAssignList()" LINK "RemAssignList" 0}
@ENDNODE

@NODE "AssignLate" "dos.library/AssignLate()"
@{jcenter}
@{u}@{b}AssignLate()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
AssignLate - Creates an assignment to a specified path later  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = AssignLate(name,path)
D0                   D1   D2

BOOL AssignLate(STRPTR,STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Sets up a assignment that is expanded upon the FIRST reference to the name. The path (a string) would be attached to the node. When the name is referenced @{"Open" LINK "Open" 0}("FOO:xyzzy"...), the string will be used to determine where to set the assign to, and if the directory can be locked, the assign will act from that point on as if it had been created by @{"AssignLock()" LINK "AssignLock" 0}.

A major advantage is assigning things to unmounted volumes, which will be requested upon access (useful in startup sequences).
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name - Name of device to be assigned (without trailing ':')
path - Name of late assignment to be resolved on the first reference.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure indicator of the operation
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Lock()" LINK "Lock" 0}, @{"AssignAdd()" LINK "AssignAdd" 0}, @{"AssignPath()" LINK "AssignPath" 0}, @{"AssignLock()" LINK "AssignLock" 0},
@ENDNODE

@NODE "AssignLock" "dos.library/AssignLock()"
@{jcenter}
@{u}@{b}AssignLock()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
AssignLock - Creates an assignment to a locked object  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = AssignLock(name,lock)
D0                   D1   D2

BOOL AssignLock(STRPTR,BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Sets up an assign of a name to a given lock. Passing NULL for a lock cancels any outstanding assign to that name. If an assign entry of that name is already on the list, this routine replaces that entry. If an entry is on the list that conflicts with the new assign, then a failure code is returned.

NOTE: you should not use the lock in any way after making this call successfully. It becomes the assign, and will be unlocked by the system when the assign is removed. If you need to keep the lock, pass a lock from @{"DupLock()" LINK "DupLock" 0} to AssignLock().
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name - Name of device to assign lock to (without trailing ':')
lock - Lock associated with the assigned name
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure indicator. On failure, the lock is not unlocked.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Lock()" LINK "Lock" 0}, @{"AssignAdd()" LINK "AssignAdd" 0}, @{"AssignPath()" LINK "AssignPath" 0}, @{"AssignLate()" LINK "AssignLate" 0}, @{"DupLock()" LINK "DupLock" 0}, @{"RemAssignList()" LINK "RemAssignList" 0}
@ENDNODE

@NODE "AssignPath" "dos.library/AssignPath()"
@{jcenter}
@{u}@{b}AssignPath()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
AssignPath - Creates an assignment to a specified path  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = AssignPath(name,path)
D0                   D1   D2

BOOL AssignPath(STRPTR,STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Sets up a assignment that is expanded upon EACH reference to the name. This is implemented through a new device list type (DLT_ASSIGNPATH, or some such). The path (a string) would be attached to the node. When the name is referenced @{"Open" LINK "Open" 0}("FOO:xyzzy"...), the string will be used to determine where to do the open. No permanent lock will be part of it. For example, you could AssignPath() c2: to df2:c, and references to c2: would go to df2:c, even if you change disks.

The other major advantage is assigning things to unmounted volumes, which will be requested upon access (useful in startup sequences).
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name - Name of device to be assigned (without trailing ':')
path - Name of late assignment to be resolved at each reference
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure indicator of the operation
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"AssignAdd()" LINK "AssignAdd" 0}, @{"AssignLock()" LINK "AssignLock" 0}, @{"AssignLate()" LINK "AssignLate" 0}, @{"Open()" LINK "Open" 0}
@ENDNODE

@NODE "AttemptLockDosList" "dos.library/AttemptLockDosList()"
@{jcenter}
@{u}@{b}AttemptLockDosList()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
AttemptLockDosList - Attempt to lock the Dos Lists for use  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
dlist = AttemptLockDosList(flags)
D0                         D1

struct @{"DosList" LINK "include:dos/dosextens.h/MAIN" 371} *AttemptLockDosList(ULONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Locks the dos device list in preparation to walk the list. If the list is 'busy' then this routine will return NULL. See @{"LockDosList()" LINK "LockDosList" 0} for more information.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
flags - Flags stating which types of nodes you want to lock.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
dlist - Pointer to the beginning of the list or NULL. Not a valid node!
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In @{fg shine}V36@{fg text} through @{fg shine}V39.23@{fg text} dos, this would return NULL or 0x00000001 for failure. Fixed in @{fg shine}V39.24@{fg text} dos (after kickstart @{fg shine}39.106@{fg text}).
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"LockDosList()" LINK "LockDosList" 0}, @{"UnLockDosList()" LINK "UnLockDosList" 0}, @{"Forbid()" LINK "exec.guide/Forbid" 0}, @{"NextDosEntry()" LINK "NextDosEntry" 0}
@ENDNODE

@NODE "ChangeMode" "dos.library/ChangeMode()"
@{jcenter}
@{u}@{b}ChangeMode()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ChangeMode - Change the current mode of a lock or filehandle  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = ChangeMode(type, object, newmode)
D0                   D1    D2      D3

BOOL ChangeMode(ULONG, BPTR, ULONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This allows you to attempt to change the mode in use by a lock or filehandle. For example, you could attempt to turn a shared lock into an exclusive lock. The handler may well reject this request. Warning: if you use the wrong type for the object, the system may crash.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
type    - Either CHANGE_FH or CHANGE_LOCK
object  - A lock or filehandle
newmode - The new mode you want
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Boolean
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Did not work in 2.02 or before @{fg shine}(V36)@{fg text}. Works in @{fg shine}V37@{fg text}. In the earlier versions, it can crash the machine.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Lock()" LINK "Lock" 0}, @{"Open()" LINK "Open" 0}
@ENDNODE

@NODE "CheckSignal" "dos.library/CheckSignal()"
@{jcenter}
@{u}@{b}CheckSignal()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CheckSignal - Checks for break signals  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
signals = CheckSignal(mask)
D0                    D1

ULONG CheckSignal(ULONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function checks to see if any signals specified in the mask have been set and if so, returns them. Otherwise it returns FALSE. All signals specified in mask will be cleared.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
mask    - Signals to check for.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
signals - Signals specified in mask that were set.
@ENDNODE

@NODE "Cli" "dos.library/Cli()"
@{jcenter}
@{u}@{b}Cli()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Cli - Returns a pointer to the CLI structure of the process  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
cli_ptr = Cli()
D0

struct @{"CommandLineInterface" LINK "include:dos/dosextens.h/MAIN" 313} *Cli(void)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Returns a pointer to the CLI structure of the current process, or NULL
if the process has no CLI structure.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
cli_ptr - pointer to the CLI structure, or NULL.
@ENDNODE

@NODE "CliInitNewcli" "dos.library/CliInitNewcli()"
@{jcenter}
@{u}@{b}CliInitNewcli()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CliInitNewcli - Set up a process to be a shell from initial packet
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
flags = CliInitNewcli( packet )
D0                     A0

LONG CliInitNewcli( struct @{"DosPacket" LINK "include:dos/dosextens.h/MAIN" 107} * )
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function initializes a process and CLI structure for a new shell, from parameters in an initial packet passed by the system (NewShell or NewCLI, etc). The format of the data in the packet is purposely not defined. The setup includes all the normal fields in the structures that are required for proper operation (current directory, paths, input streams, etc).

It returns a set of flags containing information about what type of shell invocation this is.

Definitions for the values of fn:@{lindent 16}
Bit 31     Set to indicate flags are valid
Bit  3     Set to indicate asynch system call
Bit  2     Set if this is a @{"System()" LINK "SystemTagList" 0} call
Bit  1     Set if user provided input stream
Bit  0     Set if RUN provided output stream
@{lindent 8}
If Bit 31 is 0, then you must check @{"IoErr()" LINK "IoErr" 0} to determine if an error occurred. If @{"IoErr()" LINK "IoErr" 0} returns a pointer to your process, there has been an error, and you should clean up and exit. The packet will have already been returned by CliInitNewcli(). If it isn't a pointer to your process and Bit 31 is 0, reply the packet immediately. (Note: this is different from what you do for @{"CliInitRun()" LINK "CliInitRun" 0}.)

This function is very similar to @{"CliInitRun()" LINK "CliInitRun" 0}.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
packet - the initial packet sent to your process @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27}
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
fn - flags or a pointer
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CliInitRun()" LINK "CliInitRun" 0}, @{"ReplyPkt()" LINK "ReplyPkt" 0}, @{"WaitPkt()" LINK "WaitPkt" 0}, @{"IoErr()" LINK "IoErr" 0}
@ENDNODE

@NODE "CliInitRun" "dos.library/CliInitRun()"
@{jcenter}
@{u}@{b}CliInitRun()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CliInitRun - Set up a process to be a shell from initial packet
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
flags = CliInitRun( packet )
D0                  A0

LONG CliInitRun( struct @{"DosPacket" LINK "include:dos/dosextens.h/MAIN" 107} * )
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function initializes a process and CLI structure for a new shell, from parameters in an initial packet passed by the system (Run, @{"System()" LINK "SystemTagList" 0}, @{"Execute()" LINK "Execute" 0}). The format of the data in the packet is purposely not defined. The setup includes all the normal fields in the structures that are required for proper operation (current directory, paths, input streams, etc).

It returns a set of flags containing information about what type of shell invocation this is.

Definitions for the values of fn:@{lindent 16}
Bit 31     Set to indicate flags are valid
Bit  3     Set to indicate asynch system call
Bit  2     Set if this is a @{"System()" LINK "SystemTagList" 0} call
Bit  1     Set if user provided input stream
Bit  0     Set if RUN provided output stream
@{lindent 8}
If Bit 31 is 0, then you must check @{"IoErr()" LINK "IoErr" 0} to determine if an error occurred.  If @{"IoErr()" LINK "IoErr" 0} returns a pointer to your process, there has been an error, and you should clean up and exit. The packet will have already been returned by @{"CliInitNewcli()" LINK "CliInitNewcli" 0}. If it isn't a pointer to your process and Bit 31 is 0, you should wait before replying the packet until after you've loaded the first command (or when you exit). This helps avoid disk "gronking" with the Run command. (Note: this is different from what you do for @{"CliInitNewcli()" LINK "CliInitNewcli" 0}.)

If Bit 31 is 1, then if Bit 3 is one, @{"ReplyPkt()" LINK "ReplyPkt" 0} the packet immediately (Asynch @{"System()" LINK "SystemTagList" 0}), otherwise wait until your shell exits (Sync @{"System()" LINK "SystemTagList" 0}, @{"Execute()" LINK "Execute" 0}). (Note: this is different from what you do for @{"CliInitNewcli()" LINK "CliInitNewcli" 0}.)

This function is very similar to @{"CliInitNewcli()" LINK "CliInitNewcli" 0}.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
packet - the initial packet sent to your process @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27}
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
fn - flags or a pointer
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CliInitNewcli()" LINK "CliInitNewcli" 0}, @{"ReplyPkt()" LINK "ReplyPkt" 0}, @{"WaitPkt()" LINK "WaitPkt" 0}, @{"System()" LINK "SystemTagList" 0}, @{"Execute()" LINK "Execute" 0}, @{"IoErr()" LINK "IoErr" 0}
@ENDNODE

@NODE "Close" "dos.library/Close()"
@{jcenter}
@{u}@{b}Close()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Close - Close an open file
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = Close( file )
D0               D1

BOOL Close(BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
The file specified by the file handle is closed. You must close all files you explicitly opened, but you must not close inherited file handles that are passed to you (each filehandle must be closed once and ONLY once). If Close() fails, the file handle is still deallocated and should not be used.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
file - BCPL pointer to a file handle
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
@{lindent 18}success - returns if Close() succeeded. Note that it might fail depending on buffering and whatever IO must be done to close a file being written to. NOTE: this return value did not exist before @{fg shine}V36@{fg text}!
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Open()" LINK "Open" 0}, @{"OpenFromLock()" LINK "OpenFromLock" 0}
@ENDNODE

@NODE "CompareDates" "dos.library/CompareDates()"
@{jcenter}
@{u}@{b}CompareDates()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CompareDates - Compares two datestamps  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
result = CompareDates(date1,date2)
D0                    D1    D2

LONG CompareDates(struct @{"DateStamp" LINK "include:dos/dos.h/MAIN" 51} *,struct @{"DateStamp" LINK "include:dos/dos.h/MAIN" 51} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Compares two times for relative magnitide. <0 is returned if date1 is later than date2, 0 if they are equal, or >0 if date2 is later than date1. NOTE: this is NOT the same ordering as strcmp!
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
date1, date2 - DateStamps to compare
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
result -  <0, 0, or >0 based on comparison of two date stamps
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"DateStamp()" LINK "DateStamp" 0}, @{"DateToStr()" LINK "DateToStr" 0}, @{"StrToDate()" LINK "StrToDate" 0}
@ENDNODE

@NODE "CreateDir" "dos.library/CreateDir()"
@{jcenter}
@{u}@{b}CreateDir()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CreateDir - Create a new directory
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
lock = CreateDir( name )
D0                D1

BPTR CreateDir(STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
CreateDir creates a new directory with the specified name. An error is returned if it fails. Directories can only be created on devices which support them, e.g. disks. CreateDir() returns an exclusive lock on the new directory if it succeeds.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name - pointer to a null-terminated string
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
lock - BCPL pointer to a lock or NULL for failure.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Lock()" LINK "Lock" 0}, @{"UnLock()" LINK "UnLock" 0}
@ENDNODE

@NODE "CreateNewProc" "dos.library/CreateNewProc()"
@{jcenter}
@{u}@{b}CreateNewProc()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CreateNewProc - Create a new process  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
process = CreateNewProc(tags)
D0                      D1

struct @{"Process" LINK "include:dos/dosextens.h/MAIN" 36} *CreateNewProc(struct @{"TagItem" LINK "include:utility/tagitem.h/MAIN" 32} *)

process = CreateNewProcTagList(tags)
D0                             D1

struct @{"Process" LINK "include:dos/dosextens.h/MAIN" 36} *CreateNewProcTagList(struct @{"TagItem" LINK "include:utility/tagitem.h/MAIN" 32} *)

process = CreateNewProcTags(Tag1, ...)

struct @{"Process" LINK "include:dos/dosextens.h/MAIN" 36} *CreateNewProcTags(ULONG, ...)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This creates a new process according to the tags passed in. See @{"dos/dostags.h" LINK "include:dos/dostags.h/MAIN" 0} for the tags.

You must specify one of NP_Seglist or NP_Entry. NP_Seglist takes a seglist (as returned by @{"LoadSeg()" LINK "LoadSeg" 0}). NP_Entry takes a function pointer for the routine to call.

There are many options, as you can see by examining @{"dos/dostags.h" LINK "include:dos/dostags.h/MAIN" 0}. The defaults are for a non-CLI process, with copies of your CurrentDir, HomeDir (used for PROGDIR:), priority, consoletask, windowptr, and variables. The input and output filehandles default to opens of NIL:, stack to 4000, and others as shown in dostags.h. This is a fairly reasonable default setting for creating threads, though you may wish to modify it (for example, to give a descriptive name to the process.)

CreateNewProc() is callable from a task, though any actions that require doing Dos I/O (@{"DupLock()" LINK "DupLock" 0} of currentdir, for example) will not occur.

NOTE: if you call CreateNewProc() with both NP_Arguments, you must not specify an NP_Input of NULL. When NP_Arguments is specified, it needs to modify the input filehandle to make @{"ReadArgs()" LINK "ReadArgs" 0} work properly.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
tags - a pointer to a @{"TagItem" LINK "include:utility/tagitem.h/MAIN" 32} array.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 18}process - The created process, or NULL. Note that if it returns NULL, you must free any items that were passed in via tags, such as if you passed in a new current directory with NP_CurrentDir.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In @{fg shine}V36@{fg text}, NP_Arguments was broken in a number of ways, and probably should be avoided (instead you should start a small piece of your own code, which calls @{"RunCommand()" LINK "RunCommand" 0} to run the actual code you wish to run). In @{fg shine}V37@{fg text}, NP_Arguments works, though see the note above.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"LoadSeg()" LINK "LoadSeg" 0}, @{"CreateProc()" LINK "CreateProc" 0}, @{"ReadArgs()" LINK "ReadArgs" 0}, @{"RunCommand()" LINK "RunCommand" 0}, <@{"dos/dostags.h" LINK "include:dos/dostags.h/MAIN" 0}>
@ENDNODE

@NODE "CreateProc" "dos.library/CreateProc()"
@{jcenter}
@{u}@{b}CreateProc()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CreateProc - Create a new process
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
process = CreateProc( name, pri, seglist, stackSize )
D0                    D1    D2   D3       D4

struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *CreateProc(STRPTR, LONG, BPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
CreateProc() creates a new AmigaDOS process of name 'name'. AmigaDOS processes are a superset of exec tasks.

A seglist, as returned by @{"LoadSeg()" LINK "LoadSeg" 0}, is passed as 'seglist'. This represents a section of code which is to be run as a new process. The code is entered at the first hunk in the segment list, which should contain suitable initialization code or a jump to such. A process control structure is allocated from memory and initialized. If you wish to fake a seglist (that will never have DOS @{"UnLoadSeg()" LINK "UnLoadSeg" 0} called on it), use this code:
@{lindent 16}
DS.L    0   ;Align to longword
DC.L    16  ;Segment "length" (faked)
DC.L    0   ;Pointer to next segment
...start of code...
@{lindent 8}
The size of the root stack upon activation is passed as 'stackSize'. 'pri' specifies the required priority of the new process. The result will be the process msgport address of the new process, or zero if the routine failed. The argument 'name' specifies the new process name. A zero return code indicates error.

The seglist passed to CreateProc() is not freed when it exits; it is up to the parent process to free it, or for the code to unload itself.

Under @{fg shine}V36@{fg text} and later, you probably should use @{"CreateNewProc()" LINK "CreateNewProc" 0} instead.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name      - pointer to a null-terminated string
pri       - signed long (range -128 to +127)
seglist   - BCPL pointer to a seglist
stackSize - integer (must be a multiple of 4 bytes)
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
process   - pointer to new process msgport
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CreateNewProc()" LINK "CreateNewProc" 0}, @{"LoadSeg()" LINK "LoadSeg" 0}, @{"UnLoadSeg()" LINK "UnLoadSeg" 0}
@ENDNODE

@NODE "CurrentDir" "dos.library/CurrentDir()"
@{jcenter}
@{u}@{b}CurrentDir()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
CurrentDir - Make a directory lock the current directory
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
oldLock = CurrentDir( lock )
D0                    D1

BPTR CurrentDir(BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
CurrentDir() causes a directory associated with a lock to be made the current directory. The old current directory lock is returned.

A value of zero is a valid result here, this 0 lock represents the root of file system that you booted from.

Any call that has to @{"Open()" LINK "Open" 0} or @{"Lock()" LINK "Lock" 0} files (etc) requires that the current directory be a valid lock or 0.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
lock - BCPL pointer to a lock
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
oldLock - BCPL pointer to a lock
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Lock()" LINK "Lock" 0}, @{"UnLock()" LINK "UnLock" 0}, @{"Open()" LINK "Open" 0}, @{"DupLock()" LINK "DupLock" 0}
@ENDNODE

@NODE "DateStamp" "dos.library/DateStamp()"
@{jcenter}
@{u}@{b}DateStamp()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
DateStamp - Obtain the date and time in internal format
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
ds = DateStamp( ds );
D0              D1

struct @{"DateStamp" LINK "include:dos/dos.h/MAIN" 51} *DateStamp(struct @{"DateStamp" LINK "include:dos/dos.h/MAIN" 51} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
DateStamp() takes a structure of three longwords that is set to the current time. The first element in the vector is a count of the number of days. The second element is the number of minutes elapsed in the day. The third is the number of ticks elapsed in the current minute. A tick happens 50 times a second. DateStamp() ensures that the day and minute are consistent. All three elements are zero if the date is unset. DateStamp() currently only returns even multiples of 50 ticks. Therefore the time you get is always an even number of ticks.

Time is measured from Jan 1, 1978.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
ds - pointer a struct @{"DateStamp" LINK "include:dos/dos.h/MAIN" 51}
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
The array is filled as described and returned (for pre-V36 compabability).
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"DateToStr()" LINK "DateToStr" 0}, @{"StrToDate()" LINK "StrToDate" 0}, @{"SetFileDate()" LINK "SetFileDate" 0}, @{"CompareDates()" LINK "CompareDates" 0}
@ENDNODE

@NODE "DateToStr" "dos.library/DateToStr()"
@{jcenter}
@{u}@{b}DateToStr()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
DateToStr - Converts a DateStamp to a string  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = DateToStr( datetime )
D0                   D1

BOOL DateToStr(struct @{"DateTime" LINK "include:dos/datetime.h/MAIN" 24} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
StamptoStr converts an AmigaDOS @{"DateStamp" LINK "DateStamp" 0} to a human readable ASCII string as requested by your settings in the @{"DateTime" LINK "include:dos/datetime.h/MAIN" 24} structure.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{"DateTime" LINK "include:dos/datetime.h/MAIN" 24} - a pointer to an initialized @{"DateTime" LINK "include:dos/datetime.h/MAIN" 24} structure.

The @{"DateTime" LINK "include:dos/datetime.h/MAIN" 24} structure should be initialized as follows:

dat_Stamp - a copy of the datestamp you wish to convert to ascii.

@{lindent 21}dat_Format - a format byte which specifies the format of the dat_StrDate. This can be any of the following (note: If value used is something other than those below, the default of FORMAT_DOS is used):

 FORMAT_DOS:     AmigaDOS format (dd-mmm-yy).
 FORMAT_INT:     International format (yy-mmm-dd).
 FORMAT_USA:     American format (mm-dd-yy).
 FORMAT_CDN:     Canadian format (dd-mm-yy).
 FORMAT_DEF:     default format for locale.
@{lindent 8}
@{lindent 21}dat_Flags  - a flags byte. The only flag which affects this function is:

@{lindent 38} DTF_SUBST:      If set, a string such as Today, Monday, etc., will be used instead of the dat_Format specification if possible.@{lindent 21}
 DTF_FUTURE:     Ignored by this function.
@{lindent 8}
@{lindent 21}dat_StrDay - pointer to a buffer to receive the day of the week string. (Monday, Tuesday, etc.). If null, this string will not be generated.
@{lindent 8}
@{lindent 22}dat_StrDate - pointer to a buffer to receive the date string, in the format requested by dat_Format, subject to possible modifications by DTF_SUBST. If null, this string will not be generated.
@{lindent 8}
@{lindent 22}dat_StrTime - pointer to a buffer to receive the time of day string. If NULL, this will not be generated.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 18}success - a zero return indicates that the @{"DateStamp" LINK "DateStamp" 0} was invalid, and could not be converted. Non-zero indicates that the call succeeded.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"DateStamp()" LINK "DateStamp" 0}, @{"StrToDate()" LINK "StrToDate" 0}, <@{"dos/datetime.h" LINK "include:dos/datetime.h/MAIN" 0}>
@ENDNODE

@NODE "Delay" "dos.library/Delay()"
@{jcenter}
@{u}@{b}Delay()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Delay - Delay a process for a specified time
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
Delay( ticks )
       D1

void Delay(ULONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
The argument 'ticks' specifies how many ticks (50 per second) to wait before returning control.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
ticks - integer
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Due to a bug in the timer.device in V1.2/V1.3, specifying a timeout of zero for Delay() can cause the unreliable timer & floppy disk operation. This is fixed in @{fg shine}V36@{fg text} and later.
@ENDNODE

@NODE "DeleteFile" "dos.library/DeleteFile()"
@{jcenter}
@{u}@{b}DeleteFile()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
DeleteFile - Delete a file or directory
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = DeleteFile( name )
D0                    D1

BOOL DeleteFile(STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This attempts to delete the file or directory specified by 'name'. An error is returned if the deletion fails. Note that all the files within a directory must be deleted before the directory itself can be deleted.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name - pointer to a null-terminated string
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
success - boolean
@ENDNODE

@NODE "DeleteVar" "dos.library/DeleteVar()"
@{jcenter}
@{u}@{b}DeleteVar()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
DeleteVar - Deletes a local or environment variable  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = DeleteVar( name, flags )
D0                   D1    D2

BOOL DeleteVar(STRPTR, ULONG )
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Deletes a local or environment variable.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 17}name   - pointer to an variable name. Note variable names follow filesystem syntax and semantics.@{lindent 8}
@{lindent 17}flags  - combination of type of var to delete (low 8 bits), and flags to control the behavior of this routine. Currently defined flags include:
@{lindent 18}
GVF_LOCAL_ONLY  - delete a local (to your process) variable.
GVF_GLOBAL_ONLY - delete a global environment variable.

The default is to delete a local variable if found, otherwise a global environment variable if found (only for LV_VAR).
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 18}success - If non-zero, the variable was sucessfully deleted, FALSE indicates failure.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
LV_VAR is the only type that can be global
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"GetVar()" LINK "GetVar" 0}, @{"SetVar()" LINK "SetVar" 0}, @{"FindVar()" LINK "FindVar" 0}, @{"DeleteFile()" LINK "DeleteFile" 0}, <@{"dos/var.h" LINK "include:dos/var.h/MAIN" 0}>
@ENDNODE

@NODE "DeviceProc" "dos.library/DeviceProc()"
@{jcenter}
@{u}@{b}DeviceProc()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
DeviceProc - Return the process @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} of specific I/O handler
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
process = DeviceProc( name )
D0                    D1

struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *DeviceProc (STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
DeviceProc() returns the process identifier of the process which handles the device associated with the specified name. If no process handler can be found then the result is zero. If the name refers to an assign then a directory lock is returned in @{"IoErr()" LINK "IoErr" 0}. This lock should not be @{"UnLock()" LINK "UnLock" 0}ed or @{"Examine()" LINK "Examine" 0}ed (if you wish to do so, @{"DupLock()" LINK "DupLock" 0} it first).
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In @{fg shine}V36@{fg text}, if you try to DeviceProc() something relative to an assign made with @{"AssignPath()" LINK "AssignPath" 0}, it will fail. This is because there's no way to know when to unlock the lock. If you're writing code for @{fg shine}V36@{fg text} or later, it is highly advised you use @{"GetDeviceProc()" LINK "GetDeviceProc" 0} instead, or make your code conditional on @{fg shine}V36@{fg text} to use @{"GetDeviceProc()" LINK "GetDeviceProc" 0}/@{"FreeDeviceProc()" LINK "FreeDeviceProc" 0}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"GetDeviceProc()" LINK "GetDeviceProc" 0}, @{"FreeDeviceProc()" LINK "FreeDeviceProc" 0}, @{"DupLock()" LINK "DupLock" 0}, @{"UnLock()" LINK "UnLock" 0}, @{"Examine()" LINK "Examine" 0}
@ENDNODE

@NODE "DoPkt" "dos.library/DoPkt()"
@{jcenter}
@{u}@{b}DoPkt()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
DoPkt - Send a dos packet and wait for reply  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
result1 = DoPkt(port,action,arg1,arg2,arg3,arg4,arg5)
D0              D1   D2     D3   D4   D5   D6   D7

LONG DoPkt(struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *,LONG,LONG,LONG,LONG,LONG,LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Sends a packet to a handler and waits for it to return. Any secondary return will be available in D1 AND from @{"IoErr()" LINK "IoErr" 0}. DoPkt() will work even if the caller is an exec task and not a process; however it will be slower, and may fail for some additional reasons, such as being unable to allocate a signal. DoPkt() uses your pr_MsgPort for the reply, and will call pr_PktWait. (See BUGS regarding tasks, though).

Only allows 5 arguments to be specified. For more arguments (packets support a maximum of 7) create a packet and use @{"SendPkt()" LINK "SendPkt" 0}/@{"WaitPkt()" LINK "WaitPkt" 0}.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
port    - pr_MsgPort of the handler process to send to.
action  - the action requested of the filesystem/handler
@{lindent 39}arg1, arg2, arg3, arg4, arg5 - arguments, depend on the action, may not be required.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 18}result1 - the value returned in dp_Res1, or FALSE if there was some problem in sending the packet or recieving it.@{lindent 8}
@{lindent 18}result2 - Available from @{"IoErr()" LINK "IoErr" 0} AND in register D1.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Using DoPkt() from tasks doesn't work in @{fg shine}V36@{fg text}. Use @{"AllocDosObject()" LINK "AllocDosObject" 0}, @{"PutMsg()" LINK "exec.guide/PutMsg" 0}, and @{"WaitPort()" LINK "exec.guide/WaitPort" 0}/@{"GetMsg()" LINK "exec.guide/GetMsg" 0} for a workaround, or you can call @{"CreateNewProc()" LINK "CreateNewProc" 0} to start a process to do Dos I/O for you. In @{fg shine}V37@{fg text}, DoPkt() will allocate, use, and free the @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} required.
@{lindent 4}
@{fg shine}@{b}NOTES@{ub}@{fg text}@{lindent 8}
Callable from a task (under @{fg shine}V37@{fg text} and above).
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"AllocDosObject()" LINK "AllocDosObject" 0}, @{"FreeDosObject()" LINK "FreeDosObject" 0}, @{"SendPkt()" LINK "SendPkt" 0}, @{"WaitPkt()" LINK "WaitPkt" 0}, @{"CreateNewProc()" LINK "CreateNewProc" 0}, @{"AbortPkt()" LINK "AbortPkt" 0}
@ENDNODE

@NODE "DupLock" "dos.library/DupLock()"
@{jcenter}
@{u}@{b}DupLock()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
DupLock - Duplicate a lock
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
lock = DupLock( lock )
D0              D1

BPTR DupLock(BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
DupLock() is passed a shared filing system lock. This is the ONLY way to obtain a duplicate of a lock... simply copying is not allowed.

Another lock to the same object is then returned. It is not possible to create a copy of a exclusive lock.

A zero return indicates failure.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
lock - BCPL pointer to a lock
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
newLock - BCPL pointer to a lock
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Lock()" LINK "Lock" 0}, @{"UnLock()" LINK "UnLock" 0}, @{"DupLockFromFH()" LINK "DupLockFromFH" 0}, @{"ParentOfFH()" LINK "ParentOfFH" 0}
@ENDNODE

@NODE "DupLockFromFH" "dos.library/DupLockFromFH()"
@{jcenter}
@{u}@{b}DupLockFromFH()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
DupLockFromFH - Gets a lock on an open file  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
lock = DupLockFromFH(fh)
D0                   D1

BPTR DupLockFromFH(BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Obtain a lock on the object associated with fh. Only works if the file was opened using a non-exclusive mode. Other restrictions may be placed on success by the filesystem.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh   - Opened file for which to obtain the lock
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
lock - Obtained lock or NULL for failure
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"DupLock()" LINK "DupLock" 0}, @{"Lock()" LINK "Lock" 0}, @{"UnLock()" LINK "UnLock" 0}
@ENDNODE

@NODE "EndNotify" "dos.library/EndNotify()"
@{jcenter}
@{u}@{b}EndNotify()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
EndNotify - Ends a notification request  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
EndNotify(notifystructure)
          D1

VOID EndNotify(struct @{"NotifyRequest" LINK "include:dos/notify.h/MAIN" 50} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Removes a notification request. Safe to call even if @{"StartNotify()" LINK "StartNotify" 0} failed. For NRF_SEND_MESSAGE, it searches your port for any messages about the object in question and removes and replies them before returning.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
notifystructure - a structure passed to @{"StartNotify()" LINK "StartNotify" 0}
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"StartNotify()" LINK "StartNotify" 0}, <@{"dos/notify.h" LINK "include:dos/notify.h/MAIN" 0}>
@ENDNODE

@NODE "ErrorReport" "dos.library/ErrorReport()"
@{jcenter}
@{u}@{b}ErrorReport()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ErrorReport - Displays a Retry/Cancel requester for an error  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
status = ErrorReport(code, type, arg1, device)
D0                   D1    D2    D3     D4

BOOL ErrorReport(LONG, LONG, ULONG, struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Based on the request type, this routine formats the appropriate requester to be displayed. If the code is not understood, it returns DOS_TRUE immediately. Returns DOS_TRUE if the user selects CANCEL or if the attempt to put up the requester fails, or if the process pr_WindowPtr is -1. Returns FALSE if the user selects Retry. The routine will retry on DISKINSERTED for appropriate error codes. These return values are the opposite of what @{"AutoRequest" LINK "include:intuition.guide/AutoRequest" 0} returns.

Note: this routine sets @{"IoErr()" LINK "IoErr" 0} to code before returning.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
code   - Error code to put a requester up for.@{lindent 12}

Current valid error codes are:@{lindent 16}

ERROR_DISK_NOT_VALIDATED
ERROR_DISK_WRITE_PROTECTED
ERROR_DISK_FULL
ERROR_DEVICE_NOT_MOUNTED
ERROR_NOT_A_DOS_DISK
ERROR_NO_DISK
ABORT_DISK_ERROR        /* read/write error */
ABORT_BUSY              /* you MUST replace... */@{lindent 8}

type   - Request type:@{lindent 16}

REPORT_LOCK   - arg1 is a lock (BPTR).
REPORT_FH     - arg1 is a filehandle (BPTR).
REPORT_VOLUME - arg1 is a volumenode (C pointer).
@{lindent 32}REPORT_INSERT - arg1 is the string for the volumename (will be split on a ':'). With ERROR_DEVICE_NOT_MOUNTED puts up the "Please insert..." requester.@{lindent 8}

arg1   - variable parameter (see type)
@{lindent 17}device - (Optional) Address of handler task for which report is to be made. Only required for REPORT_LOCK, and only if arg1==NULL.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
status - Cancel/Retry indicator (0 means Retry)
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Fault()" LINK "Fault" 0}, @{"IoErr()" LINK "IoErr" 0}
@ENDNODE

@NODE "ExAll" "dos.library/ExAll()"
@{jcenter}
@{u}@{b}ExAll()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ExAll - Examine an entire directory  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
continue = ExAll(lock, buffer, size, type, control)
D0               D1     D2     D3    D4     D5

BOOL ExAll(BPTR,STRPTR,LONG,LONG,struct @{"ExAllControl" LINK "include:dos/exall.h/MAIN" 69} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Examines an entire directory.

Lock must be on a directory. Size is the size of the buffer supplied. The buffer will be filled with (partial) @{"ExAllData" LINK "include:dos/exall.h/MAIN" 44} structures, as specified by the type field.

Type is a value from those shown below that determines which information is to be stored in the buffer. Each higher value adds a new thing to the list as described in the table below:-
@{lindent 16}
ED_NAME         FileName
ED_TYPE         Type
ED_SIZE         Size in bytes
ED_PROTECTION   Protection bits
ED_DATE         3 longwords of date
@{lindent 32}ED_COMMENT      Comment (will be NULL if no comment) Note: the @{fg shine}V37@{fg text} ROM/disk filesystem returns this incorrectly as a BSTR. See BUGS for a workaround.@{lindent 16}
ED_OWNER        owner user-id and group-id (if supported)  @{fg shine}(V39)@{fg text}
@{lindent 8}
Thus, ED_NAME gives only filenames, and ED_OWNER gives everything.

NOTE: @{fg shine}V37@{fg text} dos.library, when doing ExAll() emulation, and RAM: filesystem will return an error if passed ED_OWNER. If you get ERROR_BAD_NUMBER, retry with ED_COMMENT to get everything but owner info. All filesystems supporting ExAll() must support through ED_COMMENT, and must check Type and return ERROR_BAD_NUMBER if they don't support the type.

The @{fg shine}V37@{fg text} ROM/disk filesystem doesn't fill in the comment field correctly if you specify ED_OWNER. See BUGS for a workaround if you need to use ED_OWNER.

The ead_Next entry gives a pointer to the next entry in the buffer. The last entry will have NULL in ead_Next.

The control structure is required so that FFS can keep track if more than one call to ExAll() is required. This happens when there are more names in a directory than will fit into the buffer. The format of the control structure is as follows:-

NOTE: the control structure MUST be allocated by @{"AllocDosObject" LINK "AllocDosObject" 0}!!!

@{lindent 18}Entries:  This field tells the calling application how many entries are in the buffer after calling ExAll(). Note: make sure your code handles the 0 entries case, including 0 entries with continue non-zero.
@{lindent 8}
@{lindent 18}LastKey:  This field ABSOLUTELY MUST be initialised to 0 before calling ExAll() for the first time. Any other value will cause nasty things to happen. If ExAll() returns non-zero, then this field should not be touched before making the second and subsequent calls to ExAll(). Whenever ExAll() returns non-zero, there are more calls required before all names have been received.

As soon as a FALSE return is received then ExAll() has completed (if @{"IoErr()" LINK "IoErr" 0} returns ERROR_NO_MORE_ENTRIES - otherwise it returns the error that occured, similar to @{"ExNext" LINK "ExNext" 0}.)
@{lindent 8}
MatchString@{lindent 18}
If this field is NULL then all filenames will be returned. If this field is non-null then it is interpreted as a pointer to a string that is used to pattern match all file names before accepting them and putting them into the buffer. The default AmigaDOS caseless pattern match routine is used. This string MUST have been parsed by @{"ParsePatternNoCase()" LINK "ParsePatternNoCase" 0}!
@{lindent 8}
MatchFunc:@{lindent 18}
Contains a pointer to a hook for a routine to decide if the entry will be included in the returned list of entries. The entry is filled out first, and then passed to the hook. If no MatchFunc is to be called then this entry should be NULL. The hook is called with the following parameters (as is standard for hooks):

BOOL = MatchFunc( hookptr, data, typeptr )
                  a0       a1    a2
(a0 = ptr to hook, a1 = ptr to filled in @{"ExAllData" LINK "include:dos/exall.h/MAIN" 44}, a2 = ptr to longword of type).

MatchFunc should return FALSE if the entry is not to be accepted, otherwise return TRUE.
@{lindent 8}
Note that Dos will emulate ExAll() using @{"Examine()" LINK "Examine" 0} and @{"ExNext()" LINK "ExNext" 0} if the handler in question doesn't support the ExAll() packet.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
lock    - Lock on directory to be examined.
@{lindent 18}buffer  - Buffer for data returned (MUST be at least word-aligned, preferably long-word aligned).@{lindent 8}
size    - Size in bytes of 'buffer'.
type    - Type of data to be returned.
@{lindent 18}control - Control data structure (see notes above). MUST have been allocated by @{"AllocDosObject()" LINK "AllocDosObject" 0}!
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 19}continue - Whether or not ExAll is done. If FALSE is returned, either ExAll has completed (@{"IoErr()" LINK "IoErr" 0} == ERROR_NO_MORE_ENTRIES), or an error occurred (check @{"IoErr()" LINK "IoErr" 0}). If non-zero is returned, you MUST call ExAll again until it returns FALSE.
@{lindent 4}
@{fg shine}@{b}EXAMPLE@{ub}@{fg text}@{lindent 8}

eac = @{"AllocDosObject" LINK "AllocDosObject" 0}(DOS_EXALLCONTROL,NULL);
if (!eac) ...
...
eac->eac_LastKey = 0;
do {
    more = ExAll(lock, EAData, sizeof(EAData), ED_FOO, eac);
    if ((!more) && (@{"IoErr()" LINK "IoErr" 0} != ERROR_NO_MORE_ENTRIES)) {
        \\* ExAll failed abnormally *\\
        break;
    }
    if (eac->eac_Entries == 0) {
        \\* ExAll failed normally with no entries *\\
        continue;     \\* ("more" is *usually* zero) *\\
    }
    ead = (struct @{"ExAllData" LINK "include:dos/exall.h/MAIN" 44} *) EAData;
    do {
        \\* use ead here *\\
        ...
        \\* get next ead *\\
        ead = ead->ed_Next;
    } while (ead);

} while (more);
...
@{"FreeDosObject" LINK "FreeDosObject" 0}(DOS_EXALLCONTROL,eac);
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In @{fg shine}V36@{fg text}, there were problems with ExAll (particularily with eac_MatchString, and ed_Next with the ramdisk and the emulation of it in Dos for handlers that do not support the packet. It is advised you only use this under @{fg shine}V37@{fg text} and later.

The @{fg shine}V37@{fg text} ROM/disk filesystem incorrectly returned comments as BSTR's (length plus characters) instead of CSTR's (null-terminated). See the next bug for a way to determine if the filesystem is a @{fg shine}V37@{fg text} ROM/disk filesystem. Fixed in @{fg shine}V39@{fg text}.

The @{fg shine}V37@{fg text} ROM/disk filesystem incorrectly handled values greater than ED_COMMENT. Because of this, ExAll() information is trashed if ED_OWNER is passed to it. Fixed in @{fg shine}V39@{fg text}. To work around this, use the following code to identify if a filesystem is a @{fg shine}V37@{fg text} ROM/disk filesystem:
@{lindent 1}
\// return TRUE if this is a @{fg shine}V37@{fg text} ROM filesystem, which doesn't (really)
\// support ED_OWNER safely

BOOL CheckV37(BPTR lock)
{
       struct @{"FileLock" LINK "include:dos/dosextens.h/MAIN" 455} *l = BADDR(lock);
       struct @{"Resident" LINK "include:exec/resident.h/MAIN" 17} *resident;
       struct @{"DosList" LINK "include:dos/dosextens.h/MAIN" 371} *dl;
       BOOL result = FALSE;

       dl = @{"LockDosList" LINK "LockDosList" 0}(LDF_READ|LDF_DEVICES);

\// if the lock has a volume and no device, we won't find it,
\// so we know it's not a @{fg shine}V37@{fg text} ROM/disk filesystem
       do {
           dl = @{"NextDosEntry" LINK "NextDosEntry" 0}(dl,LDF_READ|LDF_DEVICES);
           if (dl && (dl->dol_Task == l->fl_Task))
           {
\// found the filesystem - test isn't actually required,
\// but we know the filesystem we're looking for will always
\// have a startup msg.  If we needed to examine the message,
\// we would need a bunch of checks to make sure it's not
\// either a small value (like port-handler uses) or a BSTR.
               if (dl->dol_misc.dol_handler.dol_Startup)
               {
\// try to make sure it's the ROM fs or l:FastFileSystem
                       if (resident =
                           FindRomTag(dl->dol_misc.dol_handler.dol_SegList))
                       {
                               if (resident->rt_Version < 39 &&
                                   (strncmp(resident->rt_IdString,"fs 37.",
                                            strlen("fs 37.")) == 0 ||
                                    strncmp(resident->rt_Name,"ffs 37.",
                                            strlen("ffs 37.")) == 0))
                               {
                                       result = TRUE;
                               }
                       }
               }
               break;
           }
       } while (dl);

       @{"UnLockDosList" LINK "UnLockDosList" 0}(LDF_READ|LDF_DEVICES);

       return result;
}

@{lindent 4}
@{fg shine}@{b}EE ALSO@{ub}@{fg text}@{lindent 8}
@{"Examine()" LINK "Examine" 0}, @{"ExNext()" LINK "ExNext" 0}, @{"ExamineFH()" LINK "ExamineFH" 0}, @{"MatchPatternNoCase()" LINK "MatchPatternNoCase" 0}, @{"ParsePatternNoCase()" LINK "ParsePatternNoCase" 0}, @{"AllocDosObject()" LINK "AllocDosObject" 0}, @{"ExAllEnd()" LINK "ExAllEnd" 0}
@ENDNODE

@NODE "ExAllEnd" "dos.library/ExAllEnd()"
@{jcenter}
@{u}@{b}ExAllEnd()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ExAllEnd - Stop an @{"ExAll()" LINK "ExAll" 0}  @{fg shine}(V39)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
ExAllEnd(lock, buffer, size, type, control)
         D1    D2      D3    D4    D5

ExAllEnd(BPTR,STRPTR,LONG,LONG,struct @{"ExAllControl" LINK "include:dos/exall.h/MAIN" 69} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Stops an @{"ExAll()" LINK "ExAll" 0} on a directory before it hits NO_MORE_ENTRIES. The full set of arguments that had been passed to @{"ExAll()" LINK "ExAll" 0} must be passed to ExAllEnd(), so it can handle filesystems that can't abort an @{"ExAll()" LINK "ExAll" 0} directly.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
lock    - Lock on directory to be examined.
@{lindent 18}buffer  - Buffer for data returned (MUST be at least word-aligned, preferably long-word aligned).@{lindent 8}
size    - Size in bytes of 'buffer'.
type    - Type of data to be returned.
@{lindent 18}control - Control data structure (see notes above). MUST have been allocated by @{"AllocDosObject" LINK "AllocDosObject" 0}!
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"ExAll()" LINK "ExAll" 0}, @{"AllocDosObject()" LINK "AllocDosObject" 0}
@ENDNODE

@NODE "Examine" "dos.library/Examine()"
@{jcenter}
@{u}@{b}Examine()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Examine - Examine a directory or file associated with a lock
@{lindent 4}
@{fg shine}@{b}YNOPSIS@{ub}@{fg text}@{lindent 8}
success = Examine( lock, @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60} )
D0                 D1       D2

BOOL Examine(BPTR,struct @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Examine() fills in information in the @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60} concerning the file or directory associated with the lock. This information includes the name, size, creation date and whether it is a file or directory. @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60} must be longword aligned. Examine() gives a return code of zero if it fails.

You may make a local copy of the @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60}, as long as it is never passed to @{"ExNext()" LINK "ExNext" 0}.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
lock      - BCPL pointer to a lock
infoBlock - pointer to a @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60} (MUST be longword aligned)
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
success - boolean
@{lindent 4}
@{fg shine}@{b}SPECIAL NOTE@{ub}@{fg text}@{lindent 8}
@{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60} must be longword-aligned. @{"AllocDosObject()" LINK "AllocDosObject" 0} will allocate them correctly for you.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Lock()" LINK "Lock" 0}, @{"UnLock()" LINK "UnLock" 0}, @{"ExNext()" LINK "ExNext" 0}, @{"ExamineFH()" LINK "ExamineFH" 0}, <@{"dos/dos.h" LINK "include:dos/dos.h/MAIN" 0}>, @{"AllocDosObject()" LINK "AllocDosObject" 0}, @{"ExAll()" LINK "ExAll" 0}
@ENDNODE

@NODE "ExamineFH" "dos.library/ExamineFH()"
@{jcenter}
@{u}@{b}ExamineFH()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ExamineFH - Gets information on an open file  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = ExamineFH(fh, fib)
D0                  D1  D2

BOOL ExamineFH(BPTR, struct @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Examines a filehandle and returns information about the file in the @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60}. There are no guarantees as to whether the fib_Size field will reflect any changes made to the file size it was opened, though filesystems should attempt to provide up-to-date information for it.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh  - Filehandle you wish to examine
fib - @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60}, must be longword aligned.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure indication
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Examine()" LINK "Examine" 0}, @{"ExNext()" LINK "ExNext" 0}, @{"ExAll()" LINK "ExAll" 0}, @{"Open()" LINK "Open" 0}, @{"AllocDosObject()" LINK "AllocDosObject" 0}
@ENDNODE

@NODE "Execute" "dos.library/Execute()"
@{jcenter}
@{u}@{b}Execute()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Execute - Execute a CLI command
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = Execute( commandString, input, output )
D0                 D1             D2     D3

BOOL Execute(STRPTR, BPTR, BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function attempts to execute the string commandString as a Shell command and arguments. The string can contain any valid input that you could type directly in a Shell, including input and output redirection using < and >. Note that Execute() doesn't return until the command(s) in commandstring have returned.

The input file handle will normally be zero, and in this case Execute() will perform whatever was requested in the commandString and then return. If the input file handle is nonzero then after the (possibly empty) commandString is performed subsequent input is read from the specified input file handle until end of that file is reached.

In most cases the output file handle must be provided, and is used by the Shell commands as their output stream unless output redirection was specified. If the output file handle is set to zero then the current window, normally specified as *, is used. Note that programs running under the Workbench do not normally have a current window.

Execute() may also be used to create a new interactive Shell process just like those created with the NewShell command. In order to do this you would call Execute() with an empty commandString, and pass a file handle relating to a new window as the input file handle. The output file handle would be set to zero. The Shell will read commands from the new window, and will use the same window for output. This new Shell window can only be terminated by using the EndCLI command.

Under @{fg shine}V37@{fg text}, if an input filehandle is passed, and it's either interactive or a NIL: filehandle, the pr_ConsoleTask of the new process will be set to that filehandle's process (the same applies to @{"SystemTagList()" LINK "SystemTagList" 0}).

For this command to work the program Run must be present in C: in versions before @{fg shine}V36@{fg text} (except that in 1.3.2 and any later 1.3 versions, the system first checks the resident list for Run).
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
commandString - pointer to a null-terminated string
input         - BCPL pointer to a file handle
output        - BCPL pointer to a file handle
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
@{lindent 18}success - BOOLEAN indicating whether Execute was successful in finding and starting the specified program. Note this is NOT the return code of the command(s).
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"SystemTagList()" LINK "SystemTagList" 0}, NewShell, EndCLI, Run
@ENDNODE

@NODE "Exit" "dos.library/Exit()"
@{jcenter}
@{u}@{b}Exit()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Exit - Exit from a program
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
Exit( returnCode )
      D1

void Exit(LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Exit() is currently for use with programs written as if they were BCPL programs. This function is not normally useful for other purposes.

In general, therefore, please DO NOT CALL THIS FUNCTION!

In order to exit, C programs should use the C language exit() function (note the lower case letter "e"). Assembly programs should place a return code in D0, and execute an RTS instruction with their original stack ptr.
@{lindent 4}
@{fg shine}@{b}IMPLEMENTATION@{ub}@{fg text}@{lindent 8}
The action of Exit() depends on whether the program which called it is running as a command under a CLI or not. If the program is running under the CLI the command finishes and control reverts to the CLI. In this case, returnCode is interpreted as the return code from the program.

If the program is running as a distinct process, Exit() deletes the process and release the space associated with the stack, segment list and process structure.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
returnCode - integer
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CreateProc()" LINK "CreateProc" 0}, @{"CreateNewProc()" LINK "CreateNewProc" 0}
@ENDNODE

@NODE "ExNext" "dos.library/ExNext()"
@{jcenter}
@{u}@{b}ExNext()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ExNext - Examine the next entry in a directory
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = ExNext( lock, @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60} )
D0                D1       D2

BOOL ExNext(BPTR, struct @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This routine is passed a directory lock and a @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60} that have been initialized by a previous call to @{"Examine()" LINK "Examine" 0}, or updated by a previous call to ExNext(). ExNext() gives a return code of zero on failure. The most common cause of failure is reaching the end of the list of files in the owning directory. In this case, @{"IoErr()" LINK "IoErr" 0} will return ERROR_NO_MORE_ENTRIES and a good exit is appropriate.

So, follow these steps to examine a directory:
@{lindent 11}1) Pass a Lock and a @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60} to @{"Examine()" LINK "Examine" 0}. The lock must be on the directory you wish to examine.@{lindent 8}
2) Pass ExNext() the same lock and @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60}.
@{lindent 11}3) Do something with the information returned in the @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60}. Note that the fib_DirEntryType field is positive for directories, negative for files.@{lindent 8}
@{lindent 11}4) Keep calling ExNext() until it returns FALSE. Check @{"IoErr()" LINK "IoErr" 0} to ensure that the reason for failure was ERROR_NO_MORE_ENTRIES.
@{lindent 8}
Note: if you wish to recursively scan the file tree and you find another directory while ExNext()ing you must Lock that directory and @{"Examine()" LINK "Examine" 0} it using a new @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60}. Use of the same @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60} to enter a directory would lose important state information such that it will be impossible to continue scanning the parent directory. While it is permissible to @{"UnLock()" LINK "UnLock" 0} and @{"Lock()" LINK "Lock" 0} the parent directory between ExNext() calls, this is NOT recommended. Important state information is associated with the parent lock, so if it is freed between ExNext() calls this information has to be rebuilt on each new ExNext() call, and will significantly slow down directory scanning.

It is NOT legal to @{"Examine()" LINK "Examine" 0} a file, and then to ExNext() from that @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60}. You may make a local copy of the @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60}, as long as it is never passed back to the operating system.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
lock - BCPL pointer to a lock originally used for the @{"Examine()" LINK "Examine" 0} call
@{lindent 20}infoBlock - pointer to a @{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60} used on the previous @{"Examine()" LINK "Examine" 0} or ExNext() call.
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
success - boolean
@{lindent 4}
@{fg shine}@{b}SPECIAL NOTE@{ub}@{fg text}@{lindent 8}
@{"FileInfoBlock" LINK "include:dos/dos.h/MAIN" 60} must be longword-aligned. @{"AllocDosObject()" LINK "AllocDosObject" 0} will allocate them correctly for you.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Examine()" LINK "Examine" 0}, @{"Lock()" LINK "Lock" 0}, @{"UnLock()" LINK "UnLock" 0}, @{"IoErr()" LINK "IoErr" 0}, @{"ExamineFH()" LINK "ExamineFH" 0}, @{"AllocDosObject()" LINK "AllocDosObject" 0}, @{"ExAll()" LINK "ExAll" 0}
@ENDNODE

@NODE "Fault" "dos.library/Fault()"
@{jcenter}
@{u}@{b}Fault()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Fault - Returns the text associated with a DOS error code  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
len = Fault(code, header, buffer, len)
D0          D1    D2      D3      D4

LONG Fault(LONG, STRPTR, STRPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This routine obtains the error message text for the given error code. The header is prepended to the text of the error message, followed by a colon. Puts a null-terminated string for the error message into the buffer. By convention, error messages should be no longer than 80 characters (+1 for termination), and preferably no more than 60. The value returned by @{"IoErr()" LINK "IoErr" 0} is set to the code passed in. If there is no message for the error code, the message will be "Error code <number>\n".

The number of characters put into the buffer is returned, which will be 0 if the code passed in was 0.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
code   - Error code
header - header to output before error text
buffer - Buffer to receive error message.
len    - Length of the buffer.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
len    - number of characters put into buffer (may be 0)
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"IoErr()" LINK "IoErr" 0}, @{"SetIoErr()" LINK "SetIoErr" 0}, @{"PrintFault()" LINK "PrintFault" 0}
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In older documentation, the return was shown as BOOL success. This was incorrect, it has always returned the length.
@ENDNODE

@NODE "FGetC" "dos.library/FGetC()"
@{jcenter}
@{u}@{b}FGetC()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
FGetC - Read a character from the specified input (buffered)  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
char = FGetC(fh)
D0           D1

LONG FGetC(BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Reads the next character from the input stream. A -1 is returned when EOF or an error is encountered. This call is buffered. Use @{"Flush()" LINK "Flush" 0} between buffered and unbuffered I/O on a filehandle.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh - filehandle to use for buffered I/O
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
char - character read (0-255) or -1
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In @{fg shine}V36@{fg text}, after an EOF was read, EOF would always be returned from FGetC() from then on. Starting in @{fg shine}V37@{fg text}, it tries to read from the handler again each time (unless @{"UnGetC" LINK "UnGetC" 0}(fh,-1) was called).
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FPutC()" LINK "FPutC" 0}, @{"UnGetC()" LINK "UnGetC" 0}, @{"Flush()" LINK "Flush" 0}
@ENDNODE

@NODE "FGets" "dos.library/FGets()"
@{jcenter}
@{u}@{b}FGets()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
FGets - Reads a line from the specified input (buffered)  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
buffer = FGets(fh, buf, len)
D0             D1  D2   D3

STRPTR FGets(BPTR, STRPTR, ULONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This routine reads in a single line from the specified input stopping at a NEWLINE character or EOF. In either event, UP TO the number of len specified bytes minus 1 will be copied into the buffer. Hence if a length of 50 is passed and the input line is longer than 49 bytes, it will return 49 characters. It returns the buffer pointer normally, or NULL if EOF is the first thing read.

If terminated by a newline, the newline WILL be the last character in the buffer. This is a buffered read routine. The string read in IS null-terminated.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh  - filehandle to use for buffered I/O
buf - Area to read bytes into.
len - Number of bytes to read, must be > 0.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
buffer - Pointer to buffer passed in, or NULL for immediate EOF or for an error. If NULL is returnd for an EOF, @{"IoErr()" LINK "IoErr" 0} will return 0.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In @{fg shine}V36@{fg text} and @{fg shine}V37@{fg text}, it copies one more byte than it should if it doesn't hit an EOF or newline. In the example above, it would copy 50 bytes and put a null in the 51st. This is fixed in dos @{fg shine}V39@{fg text}. Workaround for @{fg shine}V36@{fg text}/@{fg shine}V37@{fg text}: pass in buffersize-1.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FRead()" LINK "FRead" 0}, @{"FPuts()" LINK "FPuts" 0}, @{"FGetC()" LINK "FGetC" 0}
@ENDNODE

@NODE "FilePart" "dos.library/FilePart()"
@{jcenter}
@{u}@{b}FilePart()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
FilePart - Returns the last component of a path  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
fileptr = FilePart( path )
D0                  D1

STRPTR FilePart( STRPTR )
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function returns a pointer to the last component of a string path specification, which will normally be the file name. If there is only one component, it returns a pointer to the beginning of the string.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 15}path - pointer to an path string. May be relative to the current directory or the current disk.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
fileptr - pointer to the last component of the path.
@{lindent 4}
@{fg shine}@{b}EXAMPLE@{ub}@{fg text}@{lindent 8}
FilePart("xxx:yyy/zzz/qqq") would return a pointer to the first 'q'.
FilePart("xxx:yyy") would return a pointer to the first 'y').
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"PathPart()" LINK "PathPart" 0}, @{"AddPart()" LINK "AddPart" 0}
@ENDNODE

@NODE "FindArg" "dos.library/FindArg()"
@{jcenter}
@{u}@{b}FindArg()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
FindArg - find a keyword in a template  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
index = FindArg(template, keyword)
D0              D1        D2

LONG FindArg(STRPTR, STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Returns the argument number of the keyword, or -1 if it is not a keyword for the template. Abbreviations are handled.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
keyword  - keyword to search for in template
template - template string to search
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
index - number of entry in template, or -1 if not found
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In earlier published versions of the autodoc, keyword and template were backwards.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"ReadArgs()" LINK "ReadArgs" 0}, @{"ReadItem()" LINK "ReadItem" 0}, @{"FreeArgs()" LINK "FreeArgs" 0}
@ENDNODE

@NODE "FindCliProc" "dos.library/FindCliProc()"
@{jcenter}
@{u}@{b}FindCliProc()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
FindCliProc - returns a pointer to the requested CLI process  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
proc = FindCliProc(num)
D0                 D1

struct @{"Process" LINK "include:dos/dosextens.h/MAIN" 36} *FindCliProc(ULONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This routine returns a pointer to the CLI process associated with the given CLI number. If the process isn't an active CLI process, NULL is returned. NOTE: should normally be called inside a @{"Forbid()" LINK "exec.guide/Forbid" 0}, if you must use this function at all.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
num  - Task number of CLI process (range 1-N)
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
proc - Pointer to given CLI process
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Cli()" LINK "Cli" 0}, @{"Forbid()" LINK "exec.guide/Forbid" 0}, @{"MaxCli()" LINK "MaxCli" 0}
@ENDNODE

@NODE "FindDosEntry" "dos.library/FindDosEntry()"
@{jcenter}
@{u}@{b}FindDosEntry()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
FindDosEntry - Finds a specific Dos List entry  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
newdlist = FindDosEntry(dlist,name,flags)
D0                      D1    D2   D3

struct @{"DosList" LINK "include:dos/dosextens.h/MAIN" 371} *FindDosEntry(struct @{"DosList" LINK "include:dos/dosextens.h/MAIN" 371} *,STRPTR,ULONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Locates an entry on the device list. Starts with the entry dlist. NOTE: must be called with the device list locked, no references may be made to dlist after unlocking.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
dlist    - The device entry to start with.
name     - Name of device entry (without ':') to locate.
@{lindent 19}flags    - Search control flags. Use the flags you passed to @{"LockDosList()" LINK "LockDosList" 0}, or a subset of them. LDF_READ/LDF_WRITE are not required for this call.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
newdlist - The device entry or NULL
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"AddDosEntry()" LINK "AddDosEntry" 0}, @{"RemDosEntry()" LINK "RemDosEntry" 0}, @{"NextDosEntry()" LINK "NextDosEntry" 0}, @{"LockDosList()" LINK "LockDosList" 0}, @{"MakeDosEntry()" LINK "MakeDosEntry" 0}, @{"FreeDosEntry()" LINK "FreeDosEntry" 0}
@ENDNODE

@NODE "FindSegment" "dos.library/FindSegment()"
@{jcenter}
@{u}@{b}FindSegment()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
FindSegment - Finds a segment on the resident list  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
segment = FindSegment(name, start, system)
D0                    D1    D2     D3

struct @{"Segment" LINK "include:dos/dosextens.h/MAIN" 298} *FindSegment(STRPTR, struct @{"Segment" LINK "include:dos/dosextens.h/MAIN" 298} *, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Finds a segment on the Dos resident list by name and type, starting at the segment AFTER 'start', or at the beginning if start is NULL. If system is zero, it will only return nodes with a seg_UC of 0 or more. It does NOT increment the seg_UC, and it does NOT do any locking of the list. You must @{"Forbid()" LINK "exec.guide/Forbid" 0} lock the list to use this call.

To use an entry you have found, you must: if the seg_UC is 0 or more, increment it, and decrement it (under @{"Forbid()" LINK "exec.guide/Forbid" 0}!) when you're done the the seglist.

The other values for seg_UC are:@{lindent 16}
-1   - system module, such as a filesystem or shell
-2   - resident shell command
-999 - disabled internal command, ignore@{lindent 8}
Negative values should never be modified. All other negative values between 0 and -32767 are reserved to AmigaDos and should not be used.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name   - name of segment to find
start  - segment to start the search after
system - true for system segment, false for normal segments
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
segment - the segment found or NULL
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"AddSegment()" LINK "AddSegment" 0}, @{"RemSegment()" LINK "RemSegment" 0}, @{"Forbid()" LINK "exec.guide/Forbid" 0}
@ENDNODE

@NODE "FindVar" "dos.library/FindVar()"
@{jcenter}
@{u}@{b}FindVar()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
FindVar - Finds a local variable  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
var = FindVar( name, type )
D0             D1    D2

struct @{"LocalVar" LINK "include:dos/var.h/MAIN" 24} * FindVar(STRPTR, ULONG )
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Finds a local variable structure.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name - pointer to an variable name. Note variable names follow filesystem syntax and semantics.

type - type of variable to be found (see <@{"dos/var.h" LINK "include:dos/var.h/MAIN" 0}>)
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
var  - pointer to a @{"LocalVar" LINK "include:dos/var.h/MAIN" 24} structure or NULL
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"GetVar()" LINK "GetVar" 0}, @{"SetVar()" LINK "SetVar" 0}, @{"DeleteVar()" LINK "DeleteVar" 0}, <@{"dos/var.h" LINK "include:dos/var.h/MAIN" 0}>
@ENDNODE

@NODE "Flush" "dos.library/Flush()"
@{jcenter}
@{u}@{b}Flush()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Flush - Flushes buffers for a buffered filehandle  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = Flush(fh)
D0              D1

LONG Flush(BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Flushes any pending buffered writes to the filehandle. All buffered writes will also be flushed on @{"Close()" LINK "Close" 0}. If the filehandle was being used for input, it drops the buffer, and tries to @{"Seek()" LINK "Seek" 0} back to the last read position (so subsequent reads or writes will occur at the expected position in the file).
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh - Filehandle to flush.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success or failure.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Before @{fg shine}V37@{fg text} release, Flush() returned a random value. As of @{fg shine}V37@{fg text}, it always returns success (this will be fixed in some future release).

The @{fg shine}V36@{fg text} and @{fg shine}V37@{fg text} releases didn't properly flush filehandles which have never had a buffered IO done on them. This commonly occurs on redirection of input of a command, or when opening a file for input and then calling @{"CreateNewProc()" LINK "CreateNewProc" 0} with NP_Arguments, or when using a new filehandle with @{"SelectInput()" LINK "SelectInput" 0} and then calling @{"RunCommand()" LINK "RunCommand" 0}. This is fixed in @{fg shine}V39@{fg text}. A workaround would be to do @{"FGetC()" LINK "FGetC" 0}, then @{"UnGetC()" LINK "UnGetC" 0}, then Flush().
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FPutC()" LINK "FPutC" 0}, @{"FGetC()" LINK "FGetC" 0}, @{"UnGetC()" LINK "UnGetC" 0}, @{"Seek()" LINK "Seek" 0}, @{"Close()" LINK "Close" 0}, @{"CreateNewProc()" LINK "CreateNewProc" 0}, @{"SelectInput()" LINK "SelectInput" 0}, @{"RunCommand()" LINK "RunCommand" 0}
@ENDNODE

@NODE "Format" "dos.library/Format()"
@{jcenter}
@{u}@{b}Format()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Format - Causes a filesystem to initialize itself  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = Format(filesystem, volumename, dostype)
D0               D1          D2          D3

BOOL Format(STRPTR, STRPTR, ULONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Interface for initializing new media on a device. This causes the filesystem to write out an empty disk structure to the media, which should then be ready for use. This assumes the media has been low-level formatted and verified already.

The filesystem should be inhibited before calling Format() to make sure you don't get an ERROR_OBJECT_IN_USE.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
filesystem - Name of device to be formatted. ':' must be supplied.
volumename - Name for volume (if supported). No ':'.
dostype    - Type of format, if filesystem supports multiple types.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure indicator.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Existed, but was non-functional in @{fg shine}V36@{fg text} dos. (The volumename wasn't converted to a BSTR.) Workaround: require @{fg shine}V37@{fg text}, or under @{fg shine}V36@{fg text} convert volumename to a BPTR to a BSTR before calling Format(). Note: a number of printed packet docs for ACTION_FORMAT are wrong as to the arguments.
@ENDNODE

@NODE "FPutC" "dos.library/FPutC()"
@{jcenter}
@{u}@{b}FPutC()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
FPutC - Write a character to the specified output (buffered)  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
char = FPutC(fh, char)
D0           D1  D2

LONG FPutC(BPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Writes a single character to the output stream. This call is buffered. Use @{"Flush()" LINK "Flush" 0} between buffered and unbuffered I/O on a filehandle. Interactive filehandles are flushed automatically on a newline, return, '\0', or line feed.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh   - filehandle to use for buffered I/O
char - character to write
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
char - either the character written, or EOF for an error.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Older autodocs indicated that you should pass a @{"UBYTE" LINK "include:exec/nodes.h/MAIN" 21}. The correct usage is to pass a LONG in the range 0-255.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FGetC()" LINK "FGetC" 0}, @{"UnGetC()" LINK "UnGetC" 0}, @{"Flush()" LINK "Flush" 0}
@ENDNODE

@NODE "FPuts" "dos.library/FPuts()"
@{jcenter}
@{u}@{b}FPuts()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
FPuts - Writes a string the the specified output (buffered)  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
error = FPuts(fh, str)
D0            D1  D2

LONG FPuts(BPTR, STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This routine writes an unformatted string to the filehandle. No newline is appended to the string. This routine is buffered.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh    - filehandle to use for buffered I/O
str   - Null-terminated string to be written to default output
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 16}error - 0 normally, otherwise -1. Note that this is opposite of most other Dos functions, which return success.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FGets()" LINK "FGets" 0}, @{"FPutC()" LINK "FPutC" 0}, @{"FWrite()" LINK "FWrite" 0}, @{"PutStr()" LINK "PutStr" 0}
@ENDNODE

@NODE "FRead" "dos.library/FRead()"
@{jcenter}
@{u}@{b}FRead()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
FRead - Reads a number of blocks from an input (buffered)  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
count = FRead(fh, buf, blocklen, blocks)
D0            D1  D2   D3        D4

LONG FRead(BPTR, STRPTR, ULONG, ULONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Attempts to read a number of blocks, each blocklen long, into the specified buffer from the input stream. May return less than the number of blocks requested, either due to EOF or read errors. This call is buffered.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh       - filehandle to use for buffered I/O
buf      - Area to read bytes into.
blocklen - number of bytes per block. Must be > 0.
blocks   - number of blocks to read. Must be > 0.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 16}count - Number of blocks read, or 0 for EOF. On an error, the number of blocks actually read is returned.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Doesn't clear @{"IoErr()" LINK "IoErr" 0} before starting. If you want to find out about errors, use @{"SetIoErr()" LINK "SetIoErr" 0}(0L) before calling.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FGetC()" LINK "FGetC" 0}, @{"FWrite()" LINK "FWrite" 0}, @{"FGets()" LINK "FGets" 0}
@ENDNODE

@NODE "FreeArgs" "dos.library/FreeArgs()"
@{jcenter}
@{u}@{b}FreeArgs()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
FreeArgs - Free allocated memory after @{"ReadArgs()" LINK "ReadArgs" 0}  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
FreeArgs(rdargs)
         D1

void FreeArgs(struct @{"RDArgs" LINK "include:dos/rdargs.h/MAIN" 94} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Frees memory allocated to return arguments in from @{"ReadArgs()" LINK "ReadArgs" 0}. If @{"ReadArgs()" LINK "ReadArgs" 0} allocated the @{"RDArgs" LINK "include:dos/rdargs.h/MAIN" 94} structure it will be freed. If NULL is passed in this function does nothing.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
rdargs - structure returned from @{"ReadArgs()" LINK "ReadArgs" 0} or NULL.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"ReadArgs()" LINK "ReadArgs" 0}, @{"ReadItem()" LINK "ReadItem" 0}, @{"FindArg()" LINK "FindArg" 0}
@ENDNODE

@NODE "FreeDeviceProc" "dos.library/FreeDeviceProc()"
@{jcenter}
@{u}@{b}FreeDeviceProc()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
FreeDeviceProc - Releases port returned by @{"GetDeviceProc()" LINK "GetDeviceProc" 0}  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
FreeDeviceProc(devproc)
               D1

void FreeDeviceProc(struct @{"DevProc" LINK "include:dos/dosextens.h/MAIN" 420} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Frees up the structure created by @{"GetDeviceProc()" LINK "GetDeviceProc" 0}, and any associated temporary locks.

Decrements the counter incremented by @{"GetDeviceProc()" LINK "GetDeviceProc" 0}. The counter is in an extension to the 1.3 process structure. After calling FreeDeviceProc(), do not use the port or lock again! It is safe to call FreeDeviceProc(NULL).
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
devproc - A value returned by @{"GetDeviceProc()" LINK "GetDeviceProc" 0}
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Counter not currently active in 2.0.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"GetDeviceProc()" LINK "GetDeviceProc" 0}, @{"DeviceProc()" LINK "DeviceProc" 0}, @{"AssignLock()" LINK "AssignLock" 0}, @{"AssignLate()" LINK "AssignLate" 0}, @{"AssignPath()" LINK "AssignPath" 0}
@ENDNODE

@NODE "FreeDosEntry" "dos.library/FreeDosEntry()"
@{jcenter}
@{u}@{b}FreeDosEntry()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
FreeDosEntry - Frees an entry created by @{"MakeDosEntry()" LINK "MakeDosEntry" 0}  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
FreeDosEntry(dlist)
             D1

void FreeDosEntry(struct @{"DosList" LINK "include:dos/dosextens.h/MAIN" 371} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Frees an entry created by @{"MakeDosEntry()" LINK "MakeDosEntry" 0}. This routine should be eliminated and replaced by a value passed to @{"FreeDosObject()" LINK "FreeDosObject" 0}!
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
dlist - @{"DosList" LINK "include:dos/dosextens.h/MAIN" 371} to free.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"AddDosEntry()" LINK "AddDosEntry" 0}, @{"RemDosEntry()" LINK "RemDosEntry" 0}, @{"FindDosEntry()" LINK "FindDosEntry" 0}, @{"LockDosList()" LINK "LockDosList" 0}, @{"NextDosEntry()" LINK "NextDosEntry" 0}, @{"MakeDosEntry()" LINK "MakeDosEntry" 0}
@ENDNODE

@NODE "FreeDosObject" "dos.library/FreeDosObject()"
@{jcenter}
@{u}@{b}FreeDosObject()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
FreeDosObject - Frees an object allocated by @{"AllocDosObject()" LINK "AllocDosObject" 0}  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
FreeDosObject(type, ptr)
              D1    D2

void FreeDosObject(ULONG, void *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Frees an object allocated by @{"AllocDosObject()" LINK "AllocDosObject" 0}. Do NOT call for objects allocated in any other way.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
type - type passed to @{"AllocDosObject()" LINK "AllocDosObject" 0}
ptr  - ptr returned by @{"AllocDosObject()" LINK "AllocDosObject" 0}
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Before @{fg shine}V39@{fg text}, DOS_CLI objects will only have the struct @{"CommandLineInterface" LINK "include:dos/dosextens.h/MAIN" 313} freed, not the strings it points to. This is fixed in @{fg shine}V39@{fg text} dos. Before @{fg shine}V39@{fg text}, you can workaround this bug by using @{"FreeVec()" LINK "exec.guide/FreeVec" 0} on cli_SetName, cli_CommandFile, cli_CommandName, and cli_Prompt, and then setting them all to NULL. In @{fg shine}V39@{fg text} or above, do NOT use the workaround.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"AllocDosObject()" LINK "AllocDosObject" 0}, @{"FreeVec()" LINK "exec.guide/FreeVec" 0}, <@{"dos/dos.h" LINK "include:dos/dos.h/MAIN" 0}>
@ENDNODE

@NODE "FWrite" "dos.library/FWrite()"
@{jcenter}
@{u}@{b}FWrite()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
FWrite - Writes a number of blocks to an output (buffered)  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
count = FWrite(fh, buf, blocklen, blocks)
D0             D1  D2   D3        D4

LONG FWrite(BPTR, STRPTR, ULONG, ULONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Attempts to write a number of blocks, each blocklen long, from the specified buffer to the output stream. May return less than the number of blocks requested, if there is some error such as a full disk or r/w error. This call is buffered.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh       - filehandle to use for buffered I/O
buf      - Area to write bytes from.
blocklen - number of bytes per block. Must be > 0.
blocks   - number of blocks to write. Must be > 0.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
count - Number of blocks written. On an error, the number of blocks actually written is returned.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Doesn't clear @{"IoErr()" LINK "IoErr" 0} before starting. If you want to find out about errors, use @{"SetIoErr()" LINK "SetIoErr" 0}(0L) before calling.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FPutC()" LINK "FPutC" 0}, @{"FRead()" LINK "FRead" 0}, @{"FPuts()" LINK "FPuts" 0}
@ENDNODE

@NODE "GetArgStr" "dos.library/GetArgStr()"
@{jcenter}
@{u}@{b}GetArgStr()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
GetArgStr - Returns the arguments for the process  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
ptr = GetArgStr()
D0

STRPTR GetArgStr(void)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Returns a pointer to the (null-terminated) arguments for the program (process). This is the same string passed in a0 on startup from CLI.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
ptr - pointer to arguments
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"SetArgStr()" LINK "SetArgStr" 0}, @{"RunCommand()" LINK "RunCommand" 0}
@ENDNODE

@NODE "GetConsoleTask" "dos.library/GetConsoleTask()"
@{jcenter}
@{u}@{b}GetConsoleTask()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
GetConsoleTask - Returns the default console for the process  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
port = GetConsoleTask()
D0

struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *GetConsoleTask(void)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Returns the default console task's port (pr_ConsoleTask) for the current process.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
port - The pr_MsgPort of the console handler, or NULL.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"SetConsoleTask()" LINK "SetConsoleTask" 0}, @{"Open()" LINK "Open" 0}
@ENDNODE

@NODE "GetCurrentDirName" "dos.library/GetCurrentDirName()"
@{jcenter}
@{u}@{b}GetCurrentDirName()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
GetCurrentDirName - returns the current directory name  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = GetCurrentDirName(buf, len)
D0                          D1   D2

BOOL GetCurrentDirName(STRPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Extracts the current directory name from the CLI structure and puts it into the buffer. If the buffer is too small, the name is truncated appropriately and a failure code returned. If no CLI structure is present, a null string is returned in the buffer, and failure from the call (with @{"IoErr()" LINK "IoErr" 0} == ERROR_OBJECT_WRONG_TYPE);
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
buf     - Buffer to hold extracted name
len     - Number of bytes of space in buffer
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure indicator
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In @{fg shine}V36@{fg text}, this routine didn't handle 0-length buffers correctly.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"SetCurrentDirName()" LINK "SetCurrentDirName" 0}
@ENDNODE

@NODE "GetDeviceProc" "dos.library/GetDeviceProc()"
@{jcenter}
@{u}@{b}GetDeviceProc()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
GetDeviceProc - Finds a handler to send a message to  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
devproc = GetDeviceProc(name, devproc)
D0                     D1     D2

struct @{"DevProc" LINK "include:dos/dosextens.h/MAIN" 420} *GetDeviceProc(STRPTR, struct @{"DevProc" LINK "include:dos/dosextens.h/MAIN" 420} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Finds the handler/filesystem to send packets regarding 'name' to. This may involve getting temporary locks. It returns a structure that includes a lock and msgport to send to to attempt your operation. It also includes information on how to handle multiple-directory assigns (by passing the @{"DevProc" LINK "include:dos/dosextens.h/MAIN" 420} back to GetDeviceProc() until it returns NULL).

The initial call to GetDeviceProc() should pass NULL for devproc. If after using the returned @{"DevProc" LINK "include:dos/dosextens.h/MAIN" 420}, you get an ERROR_OBJECT_NOT_FOUND, and (devproc->dvp_Flags & DVPF_ASSIGN) is true, you should call GetDeviceProc() again, passing it the devproc structure. It will either return a modified devproc structure, or NULL (with ERROR_NO_MORE_ENTRIES in @{"IoErr()" LINK "IoErr" 0}).  Continue until it returns NULL.

This call also increments the counter that locks a handler/fs into memory. After calling @{"FreeDeviceProc()" LINK "FreeDeviceProc" 0}, do not use the port or lock again!
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 18}name    - name of the object you wish to access. This can be a relative path ("foo/bar"), relative to the current volume (":foo/bar"), or relative to a device/volume/assign ("foo:bar").@{lindent 8}
devproc - A value returned by GetDeviceProc() before, or NULL
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
devproc - a pointer to a @{"DevProc" LINK "include:dos/dosextens.h/MAIN" 420} structure or NULL
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Counter not currently active in 2.0. In 2.0 and 2.01, you HAD to check DVPF_ASSIGN before calling it again. This was fixed for the 2.02 release of @{fg shine}V36@{fg text}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FreeDeviceProc()" LINK "FreeDeviceProc" 0}, @{"DeviceProc()" LINK "DeviceProc" 0}, @{"AssignLock()" LINK "AssignLock" 0}, @{"AssignLate()" LINK "AssignLate" 0}, @{"AssignPath()" LINK "AssignPath" 0}
@ENDNODE

@NODE "GetFileSysTask" "dos.library/GetFileSysTask()"
@{jcenter}
@{u}@{b}GetFileSysTask()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
GetFileSysTask - Returns the default filesystem for the process  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
port = GetFileSysTask()
D0

struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *GetFileSysTask(void)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Returns the default filesystem task's port (pr_FileSystemTask) for the current process.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
port - The pr_MsgPort of the filesystem, or NULL.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"SetFileSysTask()" LINK "SetFileSysTask" 0}, @{"Open()" LINK "Open" 0}
@ENDNODE

@NODE "GetProgramDir" "dos.library/GetProgramDir()"
@{jcenter}
@{u}@{b}GetProgramDir()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
GetProgramDir - Returns a lock on the directory the program was loaded from  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
lock = GetProgramDir()
D0

BPTR GetProgramDir(void)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Returns a shared lock on the directory the program was loaded from. This can be used for a program to find data files, etc, that are stored with the program, or to find the program file itself. NULL returns are valid, and may occur, for example, when running a program from the resident list. You should NOT unlock the lock.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 15}lock - A lock on the directory the current program was loaded from, or NULL if loaded from resident list, etc.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Should return a lock for things loaded via resident. Perhaps should return currentdir if NULL.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"SetProgramDir()" LINK "SetProgramDir" 0}, @{"Open()" LINK "Open" 0}
@ENDNODE

@NODE "GetProgramName" "dos.library/GetProgramName()"
@{jcenter}
@{u}@{b}GetProgramName()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
GetProgramName - Returns the current program name  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = GetProgramName(buf, len)
D0                       D1   D2

BOOL GetProgramName(STRPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Extracts the program name from the CLI structure and puts it into the buffer. If the buffer is too small, the name is truncated. If no CLI structure is present, a null string is returned in the buffer, and failure from the call (with @{"IoErr()" LINK "IoErr" 0} == ERROR_OBJECT_WRONG_TYPE);
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
buf     - Buffer to hold extracted name
len     - Number of bytes of space in buffer
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure indicator
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"SetProgramName()" LINK "SetProgramName" 0}
@ENDNODE

@NODE "GetPrompt" "dos.library/GetPrompt()"
@{jcenter}
@{u}@{b}GetPrompt()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
GetPrompt - Returns the prompt for the current process  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = GetPrompt(buf, len)
D0                  D1   D2

BOOL GetPrompt(STRPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Extracts the prompt string from the CLI structure and puts it into the buffer. If the buffer is too small, the string is truncated appropriately and a failure code returned. If no CLI structure is present, a null string is returned in the buffer, and failure from the call (with @{"IoErr()" LINK "IoErr" 0} == ERROR_OBJECT_WRONG_TYPE);
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
buf     - Buffer to hold extracted prompt
len     - Number of bytes of space in buffer
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure indicator
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"SetPrompt()" LINK "SetPrompt" 0}
@ENDNODE

@NODE "GetVar" "dos.library/GetVar()"
@{jcenter}
@{u}@{b}GetVar()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
GetVar - Returns the value of a local or global variable  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
len = GetVar( name, buffer, size, flags )
D0            D1     D2     D3    D4

LONG GetVar( STRPTR, STRPTR, LONG, ULONG )
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Gets the value of a local or environment variable. It is advised to only use ASCII strings inside variables, but not required. This stops putting characters into the destination when a \n is hit, unless GVF_BINARY_VAR is specified. (The \n is not stored in the buffer.)
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name   - pointer to a variable name.
@{lindent 17}buffer - a user allocated area which will be used to store the value associated with the variable.@{lindent 8}
size   - length of the buffer region in bytes.
@{lindent 17}flags  - combination of type of var to get value of (low 8 bits), and flags to control the behavior of this routine. Currently defined flags include:
@{lindent 18}
GVF_GLOBAL_ONLY - tries to get a global env variable.
GVF_LOCAL_ONLY  - tries to get a local variable.
GVF_BINARY_VAR  - don't stop at \n
@{lindent 39}GVF_DONT_NULL_TERM - no null termination (only valid for binary variables). @{fg shine}(V37)@{fg text}
@{lindent 18}
The default is to try to get a local variable first, then to try to get a global environment variable.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 14}len - Size of environment variable. -1 indicates that the variable was not defined (if @{"IoErr()" LINK "IoErr" 0} returns ERROR_OBJECT_NOT_FOUND - it returns ERROR_BAD_NUMBER if you specify a size of 0). If the value would overflow the user buffer, the buffer is truncated.  The buffer returned is null-terminated (even if GVF_BINARY_VAR is used, unless GVF_DONT_NULL_TERM is in effect). If it succeeds, len is the number of characters put in the buffer (not including null termination), and @{"IoErr()" LINK "IoErr" 0} will return the the size of the variable (regardless of buffer size).
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
LV_VAR is the only type that can be global. Under @{fg shine}V36@{fg text}, we documented (and it returned) the size of the variable, not the number of characters transferred. For @{fg shine}V37@{fg text} this was changed to the number of characters put in the buffer, and the total size of the variable is put in @{"IoErr()" LINK "IoErr" 0}. GVF_DONT_NULL_TERM only works for local variables under @{fg shine}V37@{fg text}. For @{fg shine}V39@{fg text}, it also works for globals.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"SetVar()" LINK "SetVar" 0}, @{"DeleteVar()" LINK "DeleteVar" 0}, @{"FindVar()" LINK "FindVar" 0}, <@{"dos/var.h" LINK "include:dos/var.h/MAIN" 0}>
@ENDNODE

@NODE "Info" "dos.library/Info()"
@{jcenter}
@{u}@{b}Info()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Info - Returns information about the disk
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = Info( lock, parameterBlock )
D0              D1    D2

BOOL Info(BPTR, struct @{"InfoData" LINK "include:dos/dos.h/MAIN" 146} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Info() can be used to find information about any disk in use. 'lock' refers to the disk, or any file on the disk. The parameter block is returned with information about the size of the disk, number of free blocks and any soft errors.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
lock           - BCPL pointer to a lock
@{lindent 25}parameterBlock - pointer to an @{"InfoData" LINK "include:dos/dos.h/MAIN" 146} structure (longword aligned)
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
success - boolean
@{lindent 4}
@{fg shine}@{b}SPECIAL NOTE:@{ub}@{fg text}@{lindent 8}
Note that @{"InfoData" LINK "include:dos/dos.h/MAIN" 146} structure must be longword aligned.
@ENDNODE

@NODE "Inhibit" "dos.library/Inhibit()"
@{jcenter}
@{u}@{b}Inhibit()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Inhibit - Inhibits access to a filesystem  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = Inhibit(filesystem, flag)
D0                D1          D2

BOOL Inhibit(STRPTR,LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Sends an ACTION_INHIBIT packet to the indicated handler. This stops all activity by the handler until uninhibited. When uninhibited, anything may have happened to the disk in the drive, or there may no longer be one.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
filesystem - Name of device to inhibit (with ':')
flag       - New status. DOSTRUE = inhibited, FALSE = uninhibited
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success    - Success/failure indicator
@ENDNODE

@NODE "Input" "dos.library/Input()"
@{jcenter}
@{u}@{b}Input()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Input - Identify the program's initial input file handle
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
file = Input()
D0

BPTR Input(void)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Input() is used to identify the initial input stream allocated when the program was initiated. Never close the filehandle returned by Input!
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
file - BCPL pointer to a file handle
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Output()" LINK "Output" 0}, @{"SelectInput()" LINK "SelectInput" 0}
@ENDNODE

@NODE "InternalLoadSeg" "dos.library/InternalLoadSeg()"
@{jcenter}
@{u}@{b}InternalLoadSeg()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
InternalLoadSeg - Low-level load routine  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
seglist = InternalLoadSeg(fh,table,functionarray,stack)
D0                        D0 A0    A1            A2

BPTR InternalLoadSeg(BPTR,BPTR,LONG *,LONG *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Loads from fh. Table is used when loading an overlay, otherwise should be NULL. Functionarray is a pointer to an array of functions. Note that the current Seek position after loading may be at any point after the last hunk loaded. The filehandle will not be closed. If a stacksize is encoded in the file, the size will be stuffed in the LONG pointed to by stack. This LONG should be initialized to your default value: InternalLoadSeg() will not change it if no stacksize is found. Clears unused portions of Code and Data hunks (as well as BSS hunks). (This also applies to @{"LoadSeg()" LINK "LoadSeg" 0} and @{"NewLoadSeg()" LINK "NewLoadSeg" 0}).

If the file being loaded is an overlaid file, this will return -(seglist). All other results will be positive.

NOTE to overlay users: InternalLoadSeg() does NOT return seglist in both D0 and D1, as @{"LoadSeg()" LINK "LoadSeg" 0} does. The current ovs.asm uses @{"LoadSeg()" LINK "LoadSeg" 0}, and assumes returns are in D1. We will support this for @{"LoadSeg()" LINK "LoadSeg" 0} ONLY.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh            - Filehandle to load from.
table         - When loading an overlay, otherwise ignored.
functionarray - Array of function to be used for read, alloc, and free.
@{lindent 10}
FuncTable[0] ->  Actual = ReadFunc(readhandle,buffer,length),DOSBase
                 D0                D1         A0     D0      A6
FuncTable[1] ->  Memory = AllocFunc(size,flags), Execbase
                 D0                 D0   D1      a6
FuncTable[2] ->  FreeFunc(memory,size), Execbase
                          A1     D0     a6
@{lindent 8}
stack         - Pointer to storage (ULONG) for stacksize.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
seglist       - Seglist loaded or NULL.  NOT returned in D1!
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Really should use tags.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"LoadSeg()" LINK "LoadSeg" 0}, @{"UnLoadSeg()" LINK "UnLoadSeg" 0}, @{"NewLoadSeg()" LINK "NewLoadSeg" 0}, @{"InternalUnLoadSeg()" LINK "InternalUnLoadSeg" 0}
@ENDNODE

@NODE "InternalUnLoadSeg" "dos.library/InternalUnLoadSeg()"
@{jcenter}
@{u}@{b}InternalUnLoadSeg()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
InternalUnLoadSeg - Unloads a seglist loaded with @{"InternalLoadSeg()" LINK "InternalLoadSeg" 0}  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = InternalUnLoadSeg(seglist,FreeFunc)
D0                          D1       A1

BOOL InternalUnLoadSeg(BPTR,void (*)(STRPTR,ULONG))
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Unloads a seglist using freefunc to free segments. Freefunc is called as for @{"InternalLoadSeg()" LINK "InternalLoadSeg" 0}. NOTE: will call @{"Close()" LINK "Close" 0} for overlaid seglists.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
seglist  - Seglist to be unloaded
FreeFunc - Function called to free memory
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - returns whether everything went OK (since this may close files). Also returns FALSE if seglist was NULL.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Really should use tags
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"LoadSeg()" LINK "LoadSeg" 0}, @{"UnLoadSeg()" LINK "UnLoadSeg" 0}, @{"InternalLoadSeg()" LINK "InternalLoadSeg" 0}, NewUnLoadSeg(), @{"Close()" LINK "Close" 0}
@ENDNODE

@NODE "IoErr" "dos.library/IoErr()"
@{jcenter}
@{u}@{b}IoErr()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
IoErr - Return extra information from the system
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
error = IoErr()
D0

LONG IoErr(void)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Most I/O routines return zero to indicate an error. When this happens (or whatever the defined error return for the routine) this routine may be called to determine more information. It is also used in some routines to pass back a secondary result.

Note: there is no guarantee as to the value returned from IoErr() after a successful operation, unless to specified by the routine.
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
error - integer
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Fault()" LINK "Fault" 0}, @{"PrintFault()" LINK "PrintFault" 0}, @{"SetIoErr()" LINK "SetIoErr" 0}
@ENDNODE

@NODE "IsFileSystem" "dos.library/IsFileSystem()"
@{jcenter}
@{u}@{b}IsFileSystem()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
IsFileSystem - returns whether a Dos handler is a filesystem  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
result = IsFileSystem(name)
D0                    D1

BOOL IsFileSystem(STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Returns whether the device is a filesystem or not. A filesystem supports seperate files storing information. It may also support sub-directories, but is not required to. If the filesystem doesn't support this new packet, IsFileSystem() will use @{"Lock" LINK "Lock" 0}(":",...) as an indicator.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name   - Name of device in question, with trailing ':'.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
result - Flag to indicate if device is a file system
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Lock()" LINK "Lock" 0}
@ENDNODE

@NODE "IsInteractive" "dos.library/IsInteractive()"
@{jcenter}
@{u}@{b}IsInteractive()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
IsInteractive - Discover whether a file is "interactive"
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
status = IsInteractive( file )
D0                      D1

BOOL IsInteractive(BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
The return value 'status' indicates whether the file associated with the file handle 'file' is connected to a virtual terminal.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
file - BCPL pointer to a file handle
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
status - boolean
@ENDNODE

@NODE "LoadSeg" "dos.library/LoadSeg()"
@{jcenter}
@{u}@{b}LoadSeg()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
LoadSeg - Scatterload a loadable file into memory
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
seglist = LoadSeg( name )
D0                 D1

BPTR LoadSeg(STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
The file 'name' should be a load module produced by the linker. LoadSeg() scatterloads the CODE, DATA and BSS segments into memory, chaining together the segments with BPTR's on their first words. The end of the chain is indicated by a zero. There can be any number of segments in a file.  All necessary relocation is handled by LoadSeg().

In the event of an error any blocks loaded will be unloaded and a NULL result returned.

If the module is correctly loaded then the output will be a pointer at the beginning of the list of blocks. Loaded code is unloaded via a call to @{"UnLoadSeg()" LINK "UnLoadSeg" 0}.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name - pointer to a null-terminated string
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
seglist - BCPL pointer to a seglist
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"UnLoadSeg()" LINK "UnLoadSeg" 0}, @{"InternalLoadSeg()" LINK "InternalLoadSeg" 0}, @{"InternalUnLoadSeg()" LINK "InternalUnLoadSeg" 0}, @{"CreateProc()" LINK "CreateProc" 0}, @{"CreateNewProc()" LINK "CreateNewProc" 0}, @{"NewLoadSeg()" LINK "NewLoadSeg" 0}.
@ENDNODE

@NODE "Lock" "dos.library/Lock()"
@{jcenter}
@{u}@{b}Lock()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Lock - Lock a directory or file
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
lock  = Lock( name, accessMode )
D0            D1    D2

BPTR Lock(STRPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
A filing system lock on the file or directory 'name' is returned if possible.

If the accessMode is ACCESS_READ, the lock is a shared read lock; if the accessMode is ACCESS_WRITE then it is an exclusive write lock. Do not use random values for mode.

If Lock() fails (that is, if it cannot obtain a filing system lock on the file or directory) it returns a zero.

Tricky assumptions about the internal format of a lock are unwise, as are any attempts to use the fl_Link or fl_Access fields.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name       - pointer to a null-terminated string
accessMode - integer
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
lock - BCPL pointer to a lock
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"UnLock()" LINK "UnLock" 0}, @{"DupLock()" LINK "DupLock" 0}, @{"ChangeMode()" LINK "ChangeMode" 0}, @{"NameFromLock()" LINK "NameFromLock" 0}, @{"DupLockFromFH()" LINK "DupLockFromFH" 0}
@ENDNODE

@NODE "LockDosList" "dos.library/LockDosList()"
@{jcenter}
@{u}@{b}LockDosList()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
LockDosList - Locks the specified Dos Lists for use  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
dlist = LockDosList(flags)
D0                  D1

struct @{"DosList" LINK "include:dos/dosextens.h/MAIN" 371} *LockDosList(ULONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Locks the dos device list in preparation to walk the list. If the list is 'busy' then this routine will not return until it is available. This routine "nests": you can call it multiple times, and then must unlock it the same number of times. The dlist returned is NOT a valid entry: it is a special value. Note that for 1.3 compatibility, it also does a @{"Forbid()" LINK "exec.guide/Forbid" 0} - this will probably be removed at some future time. The 1.3 @{"Forbid()" LINK "exec.guide/Forbid" 0} locking of this list had some race conditions. The pointer returned by this is NOT an actual @{"DosList" LINK "include:dos/dosextens.h/MAIN" 371} pointer - you should use on of the other DosEntry calls to get actual pointers to @{"DosList" LINK "include:dos/dosextens.h/MAIN" 371} structures (such as @{"NextDosEntry()" LINK "NextDosEntry" 0}), passing the value returned by LockDosList() as the dlist value.

Note for handler writers: you should never call this function with LDF_WRITE, since it can deadlock you (if someone has it read-locked and they're trying to send you a packet). Use @{"AttemptLockDosList()" LINK "AttemptLockDosList" 0} instead, and effectively busy-wait with delays for the list to be available. The other option is that you can spawn a process to add the entry safely.

As an example, here's how you can search for all volumes of a specific name and do something with them:

2.0 way:
@{lindent 16}
dl = LockDosList(LDF_VOLUMES|LDF_READ);
while (dl = @{"FindDosEntry" LINK "FindDosEntry" 0}(dl,name,LDF_VOLUMES))
{@{lindent 24}
Add to list of volumes to process or break out of the while loop. (You could try using it here, but I advise against it for compatability reasons if you are planning on continuing to examine the list.)@{lindent 16}
}

process list of volumes saved above, or current entry if you're only interested in the first one of that name.

@{"UnLockDosList" LINK "UnLockDosList" 0}(LDF_VOLUMES|LDF_READ);
                  /* must not use dl after this! */
@{lindent 8}
1.3/2.0 way:
@{lindent 16}
if (version >= 36)
        dl = LockDosList(LDF_VOLUMES|LDF_READ);
else {
        @{"Forbid()" LINK "exec.guide/Forbid" 0};
        /* tricky! note dol_Next is at offset 0! */
        dl = &(...->di_DeviceList);
}

while (version >= 36 ?
                dl = @{"FindDosEntry" LINK "FindDosEntry" 0}(dl,name,LDF_VOLUMES) :
                dl = yourfindentry(dl,name,DLT_VOLUME))
{@{lindent 24}
Add to list of volumes to process, or break out of the while loop.
Do NOT lock foo1/foo2 here if you will continue to examine the list - it breaks the forbid and the list may change on you.@{lindent 16}
}

process list of volumes saved above, or current entry if you're only interested in the first one of that name.

if (version >= 36)
        @{"UnLockDosList" LINK "UnLockDosList" 0}(LDF_VOLUMES|LDF_READ);
else
        @{"Permit()" LINK "exec.guide/Permit" 0};
/* must not use dl after this! */
...

struct @{"DosList" LINK "include:dos/dosextens.h/MAIN" 371} *
yourfindentry (struct @{"DosList" LINK "include:dos/dosextens.h/MAIN" 371} *dl, STRPTRname, type)
{
/* tricky - depends on dol_Next being at offset 0, and the initial ptr being a ptr to di_DeviceList! */
        while (dl = dl->dol_Next)
        {
            if (dl->dol_Type == type &&
                stricmp(name,BADDR(dl->dol_Name)+1) == 0)
            {
                break;
            }
        }
        return dl;
}
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
flags - Flags stating which types of nodes you want to lock.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
dlist - Pointer to the head of the list. NOT a valid node!
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"AttemptLockDosList()" LINK "AttemptLockDosList" 0}, @{"UnLockDosList()" LINK "UnLockDosList" 0}, @{"Forbid()" LINK "exec.guide/Forbid" 0}, @{"NextDosEntry()" LINK "NextDosEntry" 0}
@ENDNODE

@NODE "LockRecord" "dos.library/LockRecord()"
@{jcenter}
@{u}@{b}LockRecord()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
LockRecord - Locks a portion of a file  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = LockRecord(fh,offset,length,mode,timeout)
D0                   D1 D2     D3     D4   D5

BOOL LockRecord(BPTR,ULONG,ULONG,ULONG,ULONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This locks a portion of a file for exclusive access. Timeout is how long to wait in ticks (1/50 sec) for the record to be available.

Valid modes are:@{lindent 16}
REC_EXCLUSIVE
REC_EXCLUSIVE_IMMED
REC_SHARED
REC_SHARED_IMMED@{lindent 8}
For the IMMED modes, the timeout is ignored.

Record locks are tied to the filehandle used to create them. The same filehandle can get any number of exclusive locks on the same record, for example. These are cooperative locks, they only affect other people calling LockRecord().
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh      - File handle for which to lock the record
offset  - Record start position
length  - Length of record in bytes
mode    - Type of lock requester
timeout - Timeout interval in ticks.  0 is legal.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success or failure
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In 2.0 through 2.02 @{fg shine}(V36)@{fg text}, LockRecord() only worked in the ramdisk. Attempting to lock records on the disk filesystem causes a crash. This was fixed for @{fg shine}V37@{fg text}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"LockRecords()" LINK "LockRecords" 0}, @{"UnLockRecord()" LINK "UnLockRecord" 0}, @{"UnLockRecords()" LINK "UnLockRecords" 0}
@ENDNODE

@NODE "LockRecords" "dos.library/LockRecords()"
@{jcenter}
@{u}@{b}LockRecords()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
LockRecords - Lock a series of records  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = LockRecords(record_array,timeout)
D0                    D1           D2

BOOL LockRecords(struct @{"RecordLock" LINK "include:dos/record.h/MAIN" 26} *,ULONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This locks several records within a file for exclusive access. Timeout is how long to wait in ticks for the records to be available. The wait is applied to each attempt to lock each record in the list. It is recommended that you always lock a set of records in the same order to reduce possibilities of deadlock.

The array of @{"RecordLock" LINK "include:dos/record.h/MAIN" 26} structures is terminated by an entry with rec_FH of NULL.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
record_array - List of records to be locked
timeout - Timeout interval. 0 is legal
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success or failure
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
See @{"LockRecord()" LINK "LockRecord" 0}
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"LockRecord()" LINK "LockRecord" 0}, @{"UnLockRecord()" LINK "UnLockRecord" 0}, @{"UnLockRecords()" LINK "UnLockRecords" 0}
@ENDNODE

@NODE "MakeDosEntry" "dos.library/MakeDosEntry()"
@{jcenter}
@{u}@{b}MakeDosEntry()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
MakeDosEntry - Creates a @{"DosList" LINK "include:dos/dosextens.h/MAIN" 371} structure  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
newdlist = MakeDosEntry(name, type)
D0                      D1    D2

struct @{"DosList" LINK "include:dos/dosextens.h/MAIN" 371} *MakeDosEntry(STRPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Create a @{"DosList" LINK "include:dos/dosextens.h/MAIN" 371} structure, including allocating a name and correctly null-terminating the BSTR. It also sets the dol_Type field, and sets all other fields to 0. This routine should be eliminated and replaced by a value passed to @{"AllocDosObject()" LINK "AllocDosObject" 0}!
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name - name for the device/volume/assign node.
type - type of node.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
newdlist - The new device entry or NULL.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"AddDosEntry()" LINK "AddDosEntry" 0}, @{"RemDosEntry()" LINK "RemDosEntry" 0}, @{"FindDosEntry()" LINK "FindDosEntry" 0}, @{"LockDosList()" LINK "LockDosList" 0}, @{"NextDosEntry()" LINK "NextDosEntry" 0}, @{"FreeDosEntry()" LINK "FreeDosEntry" 0}
@ENDNODE

@NODE "MakeLink" "dos.library/MakeLink()"
@{jcenter}
@{u}@{b}MakeLink()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
MakeLink - Creates a filesystem link  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = MakeLink( name, dest, soft )
D0                  D1    D2    D3

BOOL MakeLink( STRPTR, LONG, LONG )
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Create a filesystem link from 'name' to dest. For "soft-links", dest is a pointer to a null-terminated path string. For "hard-links", dest is a lock (BPTR). 'soft' is FALSE for hard-links, non-zero otherwise.

Soft-links are resolved at access time by a combination of the filesystem (by returning ERROR_IS_SOFT_LINK to dos), and by Dos (using @{"ReadLink()" LINK "ReadLink" 0} to resolve any links that are hit).

Hard-links are resolved by the filesystem in question. A series of hard-links to a file are all equivalent to the file itself. If one of the links (or the original entry for the file) is deleted, the data remains until there are no links left.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name - Name of the link to create
dest - CPTR to path string, or BPTR lock
soft - FALSE for hard-links, non-zero for soft-links
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
Success - boolean
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In @{fg shine}V36@{fg text}, soft-links didn't work in the ROM filesystem. This was fixed for @{fg shine}V37@{fg text}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"ReadLink()" LINK "ReadLink" 0}, @{"Open()" LINK "Open" 0}, @{"Lock()" LINK "Lock" 0}
@ENDNODE

@NODE "MatchEnd" "dos.library/MatchEnd()"
@{jcenter}
@{u}@{b}MatchEnd()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
MatchEnd - Free storage allocated for @{"MatchFirst()" LINK "MatchFirst" 0}/@{"MatchNext()" LINK "MatchNext" 0}  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
MatchEnd(@{"AnchorPath" LINK "include:dos/dosasl.h/MAIN" 51})
         D1

VOID MatchEnd(struct @{"AnchorPath" LINK "include:dos/dosasl.h/MAIN" 51} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Return all storage associated with a given search.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 21}@{"AnchorPath" LINK "include:dos/dosasl.h/MAIN" 51} - Anchor used for @{"MatchFirst()" LINK "MatchFirst" 0}/@{"MatchNext()" LINK "MatchNext" 0} MUST be longword aligned!
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"MatchFirst()" LINK "MatchFirst" 0}, @{"ParsePattern()" LINK "ParsePattern" 0}, @{"Examine()" LINK "Examine" 0}, @{"CurrentDir()" LINK "CurrentDir" 0}, @{"Examine()" LINK "Examine" 0}, @{"MatchNext()" LINK "MatchNext" 0}, @{"ExNext()" LINK "ExNext" 0}, <@{"dos/dosasl.h" LINK "include:dos/dosasl.h/MAIN" 0}>
@ENDNODE

@NODE "MatchFirst" "dos.library/MatchFirst()"
@{jcenter}
@{u}@{b}MatchFirst()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
MatchFirst - Finds file that matches pattern  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
error = MatchFirst(pat, @{"AnchorPath" LINK "include:dos/dosasl.h/MAIN" 51})
D0                 D1   D2

LONG MatchFirst(STRPTR, struct @{"AnchorPath" LINK "include:dos/dosasl.h/MAIN" 51} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Locates the first file or directory that matches a given pattern. MatchFirst() is passed your pattern (you do not pass it through @{"ParsePattern()" LINK "ParsePattern" 0} - MatchFirst() does that for you), and the control structure. MatchFirst() normally initializes your @{"AnchorPath" LINK "include:dos/dosasl.h/MAIN" 51} structure for you, and returns the first file that matched your pattern, or an error. Note that MatchFirst()/@{"MatchNext()" LINK "MatchNext" 0} are unusual for Dos in that they return 0 for success, or the error code (see <@{"dos/dos.h" LINK "include:dos/dos.h/MAIN" 0}>), instead of the application getting the error code from @{"IoErr()" LINK "IoErr" 0}.

When looking at the result of MatchFirst()/@{"MatchNext()" LINK "MatchNext" 0}, the ap_Info field of your @{"AnchorPath" LINK "include:dos/dosasl.h/MAIN" 51} has the results of an @{"Examine()" LINK "Examine" 0} of the object. You normally get the name of the object from fib_FileName, and the directory it's in from ap_Current->an_Lock. To access this object, normally you would temporarily @{"CurrentDir()" LINK "CurrentDir" 0} to the lock, do an action to the file/dir, and then @{"CurrentDir()" LINK "CurrentDir" 0} back to your original directory. This makes certain you affect the right object even when two volumes of the same name are in the system. You can use ap_Buf (with ap_Strlen) to get a name to report to the user.

To initialize the @{"AnchorPath" LINK "include:dos/dosasl.h/MAIN" 51} structure (particularily when reusing it), set ap_BreakBits to the signal bits (CDEF) that you want to take a break on, or NULL, if you don't want to convenience the user. ap_Flags should be set to any flags you need or all 0's otherwise. ap_FoundBreak should be cleared if you'll be using breaks.

If you want to have the FULL PATH NAME of the files you found, allocate a buffer at the END of this structure, and put the size of it into ap_Strlen. If you don't want the full path name, make sure you set ap_Strlen to zero. In this case, the name of the file, and stats are available in the ap_Info, as per usual.

Then call MatchFirst() and then afterwards, @{"MatchNext()" LINK "MatchNext" 0} with this structure. You should check the return value each time (see below) and take the appropriate action, ultimately calling @{"MatchEnd()" LINK "MatchEnd" 0} when there are no more files or you are done. You can tell when you are done by checking for the normal AmigaDOS return code ERROR_NO_MORE_ENTRIES.

Note: patterns with trailing slashes may cause MatchFirst()/@{"MatchNext()" LINK "MatchNext" 0} to return with an ap_Current->an_Lock on the object, and a filename of the empty string ("").

See @{"ParsePattern()" LINK "ParsePattern" 0} for more information on the patterns.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
pat - Pattern to search for
@{"AnchorPath" LINK "include:dos/dosasl.h/MAIN" 51} - Place holder for search. MUST be longword aligned!
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
error - 0 for success or error code. (Opposite of most Dos calls!)
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In @{fg shine}V36@{fg text}, there were a number of bugs with MatchFirst()/@{"MatchNext()" LINK "MatchNext" 0}. One was that if you entered a directory with a name like "df0:l" using DODIR, it would re-lock the full string "df0:l", which can cause problems if the disk has changed. It also had problems with patterns such as #?/abc/def - the ap_Current->an_Lock would not be on the directory def is found in. ap_Buf would be correct, however. It had similar problems with patterns with trailing slashes. These have been fixed for @{fg shine}V37@{fg text} and later.

A bug that has not been fixed for @{fg shine}V37@{fg text} concerns a pattern of a single directory name (such as "l"). If you enter such a directory via DODIR, it re-locks l relative to the current directory. Thus you must not change the current directory before calling @{"MatchNext()" LINK "MatchNext" 0} with DODIR in that situation. If you aren't using DODIR to enter directories you can ignore this. This may be fixed in some upcoming release.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"MatchNext()" LINK "MatchNext" 0}, @{"ParsePattern()" LINK "ParsePattern" 0}, @{"Examine()" LINK "Examine" 0}, @{"CurrentDir()" LINK "CurrentDir" 0}, @{"Examine()" LINK "Examine" 0}, @{"MatchEnd()" LINK "MatchEnd" 0}, @{"ExNext()" LINK "ExNext" 0}, <@{"dos/dosasl.h" LINK "include:dos/dosasl.h/MAIN" 0}>
@ENDNODE

@NODE "MatchNext" "dos.library/MatchNext()"
@{jcenter}
@{u}@{b}MatchNext()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
MatchNext - Finds the next file or directory that matches pattern  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
error = MatchNext(@{"AnchorPath" LINK "include:dos/dosasl.h/MAIN" 51})
D0                D1

LONG MatchNext(struct @{"AnchorPath" LINK "include:dos/dosasl.h/MAIN" 51} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Locates the next file or directory that matches a given pattern. See <@{"dos/dosasl.h" LINK "include:dos/dosasl.h/MAIN" 0}> for more information. Various bits in the flags allow the application to control the operation of MatchNext().

See @{"MatchFirst()" LINK "MatchFirst" 0} for other notes.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{"AnchorPath" LINK "include:dos/dosasl.h/MAIN" 51} - Place holder for search. MUST be longword aligned!
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
error - 0 for success or error code.  (Opposite of most Dos calls)
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
See @{"MatchFirst()" LINK "MatchFirst" 0}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"MatchFirst()" LINK "MatchFirst" 0}, @{"ParsePattern()" LINK "ParsePattern" 0}, @{"Examine()" LINK "Examine" 0}, @{"CurrentDir()" LINK "CurrentDir" 0}, @{"Examine()" LINK "Examine" 0}, @{"MatchEnd()" LINK "MatchEnd" 0}, @{"ExNext()" LINK "ExNext" 0}, <@{"dos/dosasl.h" LINK "include:dos/dosasl.h/MAIN" 0}>
@ENDNODE

@NODE "MatchPattern" "dos.library/MatchPattern()"
@{jcenter}
@{u}@{b}MatchPattern()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
MatchPattern -  Checks for a pattern match with a string  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
match = MatchPattern(pat, str)
D0                   D1   D2

BOOL MatchPattern(STRPTR, STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Checks for a pattern match with a string. The pattern must be a tokenized string output by @{"ParsePattern()" LINK "ParsePattern" 0}. This routine is case-sensitive.

NOTE: this routine is highly recursive. You must have at least 1500 free bytes of stack to call this (it will cut off it's recursion before going any deeper than that and return failure). That's currently enough for about 100 levels deep of #, (, ~, etc.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
pat - Special pattern string to match as returned by @{"ParsePattern()" LINK "ParsePattern" 0}
str - String to match against given pattern
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 16}match - success or failure of pattern match. On failure, @{"IoErr()" LINK "IoErr" 0} will return 0 or ERROR_TOO_MANY_LEVELS (starting with @{fg shine}V37@{fg text} - before that there was no stack checking).
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"ParsePattern()" LINK "ParsePattern" 0}, @{"MatchPatternNoCase()" LINK "MatchPatternNoCase" 0}, @{"MatchFirst()" LINK "MatchFirst" 0}, @{"MatchNext()" LINK "MatchNext" 0}
@ENDNODE

@NODE "MatchPatternNoCase" "dos.library/MatchPatternNoCase()"
@{jcenter}
@{u}@{b}MatchPatternNoCase()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
MatchPatternNoCase -  Checks for a pattern match with a string  @{fg shine}(V37)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
match = MatchPatternNoCase(pat, str)
D0                         D1   D2

BOOL MatchPatternNoCase(STRPTR, STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Checks for a pattern match with a string. The pattern must be a tokenized string output by @{"ParsePatternNoCase()" LINK "ParsePatternNoCase" 0}. This routine is case-insensitive.

NOTE: this routine is highly recursive. You must have at least 1500 free bytes of stack to call this (it will cut off it's recursion before going any deeper than that and return failure). That's currently enough for about 100 levels deep of #, (, ~, etc.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
pat - Special pattern string to match as returned by @{"ParsePatternNoCase()" LINK "ParsePatternNoCase" 0}
str - String to match against given pattern
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 16}match - success or failure of pattern match. On failure, @{"IoErr()" LINK "IoErr" 0} will return 0 or ERROR_TOO_MANY_LEVELS (starting with @{fg shine}V37@{fg text} - before that there was no stack checking).
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
See @{"ParsePatternNoCase()" LINK "ParsePatternNoCase" 0}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"ParsePatternNoCase()" LINK "ParsePatternNoCase" 0}, @{"MatchPattern()" LINK "MatchPattern" 0}, @{"MatchFirst()" LINK "MatchFirst" 0}, @{"MatchNext()" LINK "MatchNext" 0}
@ENDNODE

@NODE "MaxCli" "dos.library/MaxCli()"
@{jcenter}
@{u}@{b}MaxCli()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
MaxCli - returns the highest CLI process number possibly in use  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
number = MaxCli()
D0

LONG MaxCli(void)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Returns the highest CLI number that may be in use. CLI numbers are reused, and are usually as small as possible. To find all CLIs, scan using @{"FindCliProc()" LINK "FindCliProc" 0} from 1 to MaxCLI(). The number returned by MaxCli() may change as processes are created and destroyed.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
number - The highest CLI number that may be in use.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FindCliProc()" LINK "FindCliProc" 0}, @{"Cli()" LINK "Cli" 0}
@ENDNODE

@NODE "NameFromFH" "dos.library/NameFromFH()"
@{jcenter}
@{u}@{b}NameFromFH()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
NameFromFH - Get the name of an open filehandle  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = NameFromFH(fh, buffer, len)
D0                   D1    D2    D3

BOOL NameFromFH(BPTR, STRPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Returns a fully qualified path for the filehandle. This routine is guaranteed not to write more than len characters into the buffer. The name will be null-terminated.  See @{"NameFromLock()" LINK "NameFromLock" 0} for more information.

Note: Older filesystems that don't support @{"ExamineFH()" LINK "ExamineFH" 0} will cause NameFromFH() to fail with ERROR_ACTION_NOT_SUPPORTED.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh     - Lock of object to be examined.
buffer - Buffer to store name.
len    - Length of buffer.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure indicator.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"NameFromLock()" LINK "NameFromLock" 0}, @{"ExamineFH()" LINK "ExamineFH" 0}
@ENDNODE

@NODE "NameFromLock" "dos.library/NameFromLock()"
@{jcenter}
@{u}@{b}NameFromLock()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
NameFromLock - Returns the name of a locked object  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = NameFromLock(lock, buffer, len)
D0                      D1     D2    D3

BOOL NameFromLock(BPTR, STRPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Returns a fully qualified path for the lock. This routine is guaranteed not to write more than len characters into the buffer. The name will be null-terminated. NOTE: if the volume is not mounted, the system will request it (unless of course you set pr_WindowPtr to -1). If the volume is not mounted or inserted, it will return an error. If the lock passed in is NULL, "SYS:" will be returned. If the buffer is too short, an error will be returned, and @{"IoErr()" LINK "IoErr" 0} will return ERROR_LINE_TOO_LONG.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
lock   - Lock of object to be examined.
buffer - Buffer to store name.
len    - Length of buffer.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure indicator.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Should return the name of the boot volume instead of SYS: for a NULL lock.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"NameFromFH()" LINK "NameFromFH" 0}, @{"Lock()" LINK "Lock" 0}
@ENDNODE

@NODE "NewLoadSeg" "dos.library/NewLoadSeg()"
@{jcenter}
@{u}@{b}NewLoadSeg()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
NewLoadSeg - Improved version of @{"LoadSeg()" LINK "LoadSeg" 0} for stacksizes  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
seglist = NewLoadSeg(file, tags)
D0                    D1    D2

BPTR NewLoadSeg(STRPTR, struct @{"TagItem" LINK "include:utility/tagitem.h/MAIN" 32} *)

seglist = NewLoadSegTagList(file, tags)
D0                           D1    D2

BPTR NewLoadSegTagList(STRPTR, struct @{"TagItem" LINK "include:utility/tagitem.h/MAIN" 32} *)

seglist = NewLoadSegTags(file, ...)

BPTR NewLoadSegTags(STRPTR, ...)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Does a @{"LoadSeg()" LINK "LoadSeg" 0} on a file, and takes additional actions based on the tags supplied.

Clears unused portions of Code and Data hunks (as well as BSS hunks). (This also applies to @{"InternalLoadSeg()" LINK "InternalLoadSeg" 0} and @{"LoadSeg()" LINK "LoadSeg" 0}).

NOTE to overlay users: NewLoadSeg() does NOT return seglist in both D0 and D1, as @{"LoadSeg()" LINK "LoadSeg" 0} does. The current ovs.asm uses @{"LoadSeg()" LINK "LoadSeg" 0}, and assumes returns are in D1. We will support this for @{"LoadSeg()" LINK "LoadSeg" 0} ONLY.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
file - Filename of file to load
tags - pointer to tagitem array
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
seglist - Seglist loaded, or NULL
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
No tags are currently defined.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"LoadSeg()" LINK "LoadSeg" 0}, @{"UnLoadSeg()" LINK "UnLoadSeg" 0}, @{"InternalLoadSeg()" LINK "InternalLoadSeg" 0}, @{"InternalUnLoadSeg()" LINK "InternalUnLoadSeg" 0}
@ENDNODE

@NODE "NextDosEntry" "dos.library/NextDosEntry()"
@{jcenter}
@{u}@{b}NextDosEntry()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
NextDosEntry - Get the next Dos List entry  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
newdlist = NextDosEntry(dlist,flags)
D0                       D1    D2

struct @{"DosList" LINK "include:dos/dosextens.h/MAIN" 371} *NextDosEntry(struct @{"DosList" LINK "include:dos/dosextens.h/MAIN" 371} *,ULONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Find the next Dos List entry of the right type. You MUST have locked the types you're looking for. Returns NULL if there are no more of that type in the list.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
dlist    - The current device entry.
flags    - What type of entries to look for.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
newdlist - The next device entry of the right type or NULL.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"AddDosEntry()" LINK "AddDosEntry" 0}, @{"RemDosEntry()" LINK "RemDosEntry" 0}, @{"FindDosEntry()" LINK "FindDosEntry" 0}, @{"LockDosList()" LINK "LockDosList" 0}, @{"MakeDosEntry()" LINK "MakeDosEntry" 0}, @{"FreeDosEntry()" LINK "FreeDosEntry" 0}
@ENDNODE

@NODE "Open" "dos.library/Open()"
@{jcenter}
@{u}@{b}Open()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b} NAME@{ub}@{fg text}@{lindent 8}
Open - Open a file for input or output
@{lindent 4}
@{fg shine}@{b} SYNOPSIS@{ub}@{fg text}@{lindent 8}
file = Open( name, accessMode )
D0           D1    D2

BPTR Open(STRPTR, LONG)
@{lindent 4}
@{fg shine}@{b} FUNCTION@{ub}@{fg text}@{lindent 8}
The named file is opened and a file handle returned. If the accessMode is MODE_OLDFILE, an existing file is opened for reading or writing. If the value is MODE_NEWFILE, a new file is created for writing. MODE_READWRITE opens a file with an shared lock, but creates it if it didn't exist.  Open types are documented in the <@{"dos/dos.h" LINK "include:dos/dos.h/MAIN" 0}> or <@{"libraries/dos.h" LINK "include:libraries/dos.h/MAIN" 0}> include file.

The 'name' can be a filename (optionally prefaced by a device name), a simple device such as NIL:, a window specification such as CON: or RAW: followed by window parameters, or "*", representing the current window. Note that as of @{fg shine}V36@{fg text}, "*" is obsolete, and CONSOLE: should be used instead.

If the file cannot be opened for any reason, the value returned will be zero, and a secondary error code will be available by calling the routine @{"IoErr()" LINK "IoErr" 0}.
@{lindent 4}
@{fg shine}@{b} INPUTS@{ub}@{fg text}@{lindent 8}
name       - pointer to a null-terminated string
accessMode - integer
@{lindent 4}
@{fg shine}@{b} RESULTS@{ub}@{fg text}@{lindent 8}
file - BCPL pointer to a file handle
@{lindent 4}
@{fg shine}@{b} SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Close()" LINK "Close" 0}, @{"ChangeMode()" LINK "ChangeMode" 0}, @{"NameFromFH()" LINK "NameFromFH" 0}, @{"ParentOfFH()" LINK "ParentOfFH" 0}, @{"ExamineFH()" LINK "ExamineFH" 0}
@ENDNODE

@NODE "OpenFromLock" "dos.library/OpenFromLock()"
@{jcenter}
@{u}@{b}OpenFromLock()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
OpenFromLock - Opens a file you have a lock on  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
fh = OpenFromLock(lock)
D0                 D1

BPTR OpenFromLock(BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Given a lock, this routine performs an open on that lock. If the open succeeds, the lock is (effectively) relinquished, and should not be @{"UnLock()" LINK "UnLock" 0}ed or used. If the open fails, the lock is still usable. The lock associated with the file internally is of the same access mode as the lock you gave up - shared is similar to MODE_OLDFILE, exclusive is similar to MODE_NEWFILE.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
lock - Lock on object to be opened.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
fh   - Newly opened file handle or NULL for failure
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In the original @{fg shine}V36@{fg text} autodocs, this was shown (incorrectly) as taking a Mode parameter as well. The prototypes and pragmas were also wrong.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Open()" LINK "Open" 0}, @{"Close()" LINK "Close" 0}, @{"Lock()" LINK "Lock" 0}, @{"UnLock()" LINK "UnLock" 0}
@ENDNODE

@NODE "Output" "dos.library/Output()"
@{jcenter}
@{u}@{b}Output()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Output - Identify the programs' initial output file handle
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
file = Output()
D0

BPTR Output(void)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Output() is used to identify the initial output stream allocated when the program was initiated. Never close the filehandle returned by Output().
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
file - BCPL pointer to a file handle
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Input()" LINK "Input" 0}
@ENDNODE

@NODE "ParentDir" "dos.library/ParentDir()"
@{jcenter}
@{u}@{b}ParentDir()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ParentDir - Obtain the parent of a directory or file
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
newlock = ParentDir( lock )
D0                   D1

BPTR ParentDir(BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
The argument 'lock' is associated with a given file or directory. ParentDir() returns 'newlock' which is associated the parent directory of 'lock'.

Taking the ParentDir() of the root of the current filing system returns a NULL (0) lock. Note this 0 lock represents the root of file system that you booted from (which is, in effect, the parent of all other file system roots.)
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
lock - BCPL pointer to a lock
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
newlock - BCPL pointer to a lock
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Lock()" LINK "Lock" 0}, @{"DupLock()" LINK "DupLock" 0}, @{"UnLock()" LINK "UnLock" 0}, @{"ParentOfFH()" LINK "ParentOfFH" 0}, @{"DupLockFromFH()" LINK "DupLockFromFH" 0}
@ENDNODE

@NODE "ParentOfFH" "dos.library/ParentOfFH()"
@{jcenter}
@{u}@{b}ParentOfFH()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ParentOfFH - returns a lock on the parent directory of a file  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
lock = ParentOfFH(fh)
D0               D1

BPTR ParentOfFH(BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Returns a shared lock on the parent directory of the filehandle.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh   - Filehandle you want the parent of.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
lock - Lock on parent directory of the filehandle or NULL for failure.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
Parent(), @{"Lock()" LINK "Lock" 0}, @{"UnLock()" LINK "UnLock" 0} @{"DupLockFromFH()" LINK "DupLockFromFH" 0}
@ENDNODE

@NODE "ParsePattern" "dos.library/ParsePattern()"
@{jcenter}
@{u}@{b}ParsePattern()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ParsePattern - Create a tokenized string for @{"MatchPattern()" LINK "MatchPattern" 0}  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
IsWild = ParsePattern(Source, Dest, DestLength)
d0                      D1     D2      D3

LONG ParsePattern(STRPTR, STRPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Tokenizes a pattern, for use by @{"MatchPattern()" LINK "MatchPattern" 0}. Also indicates if there are any wildcards in the pattern (i.e. whether it might match more than one item). Note that Dest must be at least 2 times as large as Source plus bytes to be (almost) 100% certain of no buffer overflow. This is because each input character can currently expand to 2 tokens (with one exception that can expand to 3, but only once per string). Note: this implementation may change in the future, so you should handle error returns in all cases, but the size above should still be a reasonable upper bound for a buffer allocation.

The patterns are fairly extensive, and approximate some of the ability of Unix/grep "regular expression" patterns. Here are the available tokens:

@{lindent 16}?       Matches a single character.@{lindent 8}
@{lindent 16}#       Matches the following expression 0 or more times.@{lindent 8}
@{lindent 16}(ab|cd) Matches any one of the items seperated by '|'.@{lindent 8}
@{lindent 16}~       Negates the following expression. It matches all strings that do not match the expression (aka ~(foo) matches all strings that are not exactly "foo").@{lindent 8}
@{lindent 16}[abc]   Character class: matches any of the characters in the class.@{lindent 8}
@{lindent 16}[~bc]   Character class: matches any of the characters not in the class.@{lindent 8}
@{lindent 16}a-z     Character range (only within character classes).@{lindent 8}
@{lindent 16}%       Matches 0 characters always (useful in "(foo|bar|%)").@{lindent 8}
@{lindent 16}*       Synonym for "#?", not available by default in 2.0. Available as an option that can be turned on.@{lindent 8}

"Expression" in the above table means either a single character (ex: "#?"), or an alternation (ex: "#(ab|cd|ef)"), or a character class (ex: "#[a-zA-Z]").
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
source     - unparsed wildcard string to search for.
dest       - output string, gets tokenized version of input.
@{lindent 21}DestLength - length available in destination (should be at least as twice as large as source + 2 bytes).
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 17}IsWild - 1 means there were wildcards in the pattern,
0 means there were no wildcards in the pattern,
-1 means there was a buffer overflow or other error
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In @{fg shine}V37@{fg text} this call didn't always set @{"IoErr()" LINK "IoErr" 0} to something useful on an error. Fixed in @{fg shine}V39@{fg text}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"ParsePatternNoCase()" LINK "ParsePatternNoCase" 0}, @{"MatchPattern()" LINK "MatchPattern" 0}, @{"MatchFirst()" LINK "MatchFirst" 0}, @{"MatchNext()" LINK "MatchNext" 0}
@ENDNODE

@NODE "ParsePatternNoCase" "dos.library/ParsePatternNoCase()"
@{jcenter}
@{u}@{b}ParsePatternNoCase()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ParsePatternNoCase - Create a tokenized string for @{"MatchPatternNoCase()" LINK "MatchPatternNoCase" 0}  @{fg shine}(V37)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
IsWild = ParsePatternNoCase(Source, Dest, DestLength)
d0                            D1     D2      D3

LONG ParsePatternNoCase(STRPTR, STRPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Tokenizes a pattern, for use by @{"MatchPatternNoCase()" LINK "MatchPatternNoCase" 0}. Also indicates if there are any wildcards in the pattern (i.e. whether it might match more than one item). Note that Dest must be at least 2 times as large as Source plus 2 bytes.

For a description of the wildcards, see @{"ParsePattern()" LINK "ParsePattern" 0}.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 21}source     - unparsed wildcard string to search for.@{lindent 8}
@{lindent 21}dest       - output string, gets tokenized version of input.@{lindent 8}
@{lindent 21}DestLength - length available in destination (should be at least as twice as large as source + 2 bytes).
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 17}IsWild - 1 means there were wildcards in the pattern,
0 means there were no wildcards in the pattern,
-1 means there was a buffer overflow or other error
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In @{fg shine}V37@{fg text} this call didn't always set @{"IoErr()" LINK "IoErr" 0} to something useful on an error. Fixed in @{fg shine}V39@{fg text}. In @{fg shine}V37@{fg text}, it didn't properly convert character-classes ([x-y]) to upper case. Workaround: convert the input pattern to upper case using @{"ToUpper()" LINK "utility.guide/ToUpper" 0} from utility.library before calling ParsePatternNoCase(). Fixed in @{fg shine}V39@{fg text} dos.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"ParsePattern()" LINK "ParsePattern" 0}, @{"MatchPatternNoCase()" LINK "MatchPatternNoCase" 0}, @{"MatchFirst()" LINK "MatchFirst" 0}, @{"MatchNext()" LINK "MatchNext" 0}, @{"utility.library/ToUpper()" LINK "utility.guide/ToUpper" 0}
@ENDNODE

@NODE "PathPart" "dos.library/PathPart()"
@{jcenter}
@{u}@{b}PathPart()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
PathPart - Returns a pointer to the end of the next-to-last component of a path.  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
fileptr = PathPart( path )
D0                   D1

STRPTR PathPart( STRPTR )
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This function returns a pointer to the character after the next-to-last component of a path specification, which will normally be the directory name. If there is only one component, it returns a pointer to the beginning of the string. The only real difference between this and @{"FilePart()" LINK "FilePart" 0} is the handling of '/'.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 15}path - pointer to an path string. May be relative to the current irectory or the current disk.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
fileptr - pointer to the end of the next-to-last component of the path.
@{lindent 4}
@{fg shine}@{b}EXAMPLE@{ub}@{fg text}@{lindent 8}
PathPart("xxx:yyy/zzz/qqq") would return a pointer to the last '/'.
PathPart("xxx:yyy") would return a pointer to the first 'y').
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FilePart()" LINK "FilePart" 0}, @{"AddPart()" LINK "AddPart" 0}
@ENDNODE

@NODE "PrintFault" "dos.library/PrintFault()"
@{jcenter}
@{u}@{b}PrintFault()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
PrintFault - Returns the text associated with a DOS error code  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = PrintFault(code, header)
D0                    D1     D2   

BOOL PrintFault(LONG, STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This routine obtains the error message text for the given error code. This is similar to the @{"Fault()" LINK "Fault" 0} function, except that the output is written to the default output channel with buffered output. The value returned by @{"IoErr()" LINK "IoErr" 0} is set to the code passed in.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
code   - Error code
header - header to output before error text
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure code.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"IoErr()" LINK "IoErr" 0}, @{"Fault()" LINK "Fault" 0}, @{"SetIoErr()" LINK "SetIoErr" 0}, @{"Output()" LINK "Output" 0}, @{"FPuts()" LINK "FPuts" 0}
@ENDNODE

@NODE "PutStr" "dos.library/PutStr()"
@{jcenter}
@{u}@{b}PutStr()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
PutStr - Writes a string the the default output (buffered)  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
error = PutStr(str)
D0             D1

LONG PutStr(STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This routine writes an unformatted string to the default output. No newline is appended to the string and any error is returned. This routine is buffered.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
str   - Null-terminated string to be written to default output
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 16}error - 0 for success, -1 for any error.
NOTE: this is opposite most Dos function returns!
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FPuts()" LINK "FPuts" 0}, @{"FPutC()" LINK "FPutC" 0}, @{"FWrite()" LINK "FWrite" 0}, @{"WriteChars()" LINK "WriteChars" 0}
@ENDNODE

@NODE "Read" "dos.library/Read()"
@{jcenter}
@{u}@{b}Read()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Read - Read bytes of data from a file
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
actualLength = Read( file, buffer, length )
D0                   D1    D2      D3

LONG Read(BPTR, void *, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Data can be copied using a combination of Read() and @{"Write()" LINK "Write" 0}. Read() reads bytes of information from an opened file (represented here by the argument 'file') into the buffer given. The argument 'length' is the length of the buffer given.

The value returned is the length of the information actually read. So, when 'actualLength' is greater than zero, the value of 'actualLength' is the the number of characters read. Usually Read will try to fill up your buffer before returning. A value of zero means that end-of-file has been reached. Errors are indicated by a value of -1.

Note: this is an unbuffered routine (the request is passed directly to the filesystem.) Buffered I/O is more efficient for small reads and writes; see @{"FGetC()" LINK "FGetC" 0}.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
file - BCPL pointer to a file handle
buffer - pointer to buffer
length - integer
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
actualLength - integer
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Open()" LINK "Open" 0}, @{"Close()" LINK "Close" 0}, @{"Write()" LINK "Write" 0}, @{"Seek()" LINK "Seek" 0}, @{"FGetC()" LINK "FGetC" 0}
@ENDNODE

@NODE "ReadArgs" "dos.library/ReadArgs()"
@{jcenter}
@{u}@{b}ReadArgs()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ReadArgs - Parse the command line input  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
result = ReadArgs(template, array, rdargs)
D0                   D1      D2      D3

struct @{"RDArgs" LINK "include:dos/rdargs.h/MAIN" 94} * ReadArgs(STRPTR, LONG *, struct @{"RDArgs" LINK "include:dos/rdargs.h/MAIN" 94} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Parses and argument string according to a template. Normally gets the arguments by reading buffered IO from @{"Input()" LINK "Input" 0}, but also can be made to parse a string.  MUST be matched by a call to @{"FreeArgs()" LINK "FreeArgs" 0}.

ReadArgs() parses the commandline according to a template that is passed to it. This specifies the different command-line options and their types. A template consists of a list of options. Options are named in "full" names where possible (for example, "Quick" instead of "Q"). Abbreviations can also be specified by using "abbrev=option" (for example, "Q=Quick").

Options in the template are separated by commas. To get the results of ReadArgs(), you examine the array of longwords you passed to it (one entry per option in the template). This array should be cleared (or initialized to your default values) before passing to ReadArgs(). Exactly what is put in a given entry by ReadArgs() depends on the type of option. The default is a string (a sequence of non-whitespace characters, or delimited by quotes, which will be stripped by ReadArgs()), in which case the entry will be a pointer.

Options can be followed by modifiers, which specify things such as the type of the option. Modifiers are specified by following the option with a '/' and a single character modifier. Multiple modifiers can be specified by using multiple '/'s. Valid modifiers are:

@{lindent 13}/S - Switch. This is considered a boolean variable, and will be set if the option name appears in the command-line. The entry is the boolean (0 for not set, non-zero for set).
@{lindent 8}
@{lindent 13}/K - Keyword. This means that the option will not be filled unless the keyword appears. For example if the template is "Name/K", then unless "Name=<string>" or "Name <string>" appears in the command line, Name will not be filled.
@{lindent 8}
@{lindent 13}/N - Number. This parameter is considered a decimal number, and will be converted by ReadArgs. If an invalid number is specified, an error will be returned. The entry will be a pointer to the longword number (this is how you know if a number was specified).
@{lindent 8}
@{lindent 13}/T - Toggle. This is similar to a switch, but when specified causes the boolean value to "toggle". Similar to /S.
@{lindent 8}
@{lindent 13}/A - Required. This keyword must be given a value during command-line processing, or an error is returned.
@{lindent 8}
@{lindent 13}/F - Rest of line. If this is specified, the entire rest of the line is taken as the parameter for the option, even if other option keywords appear in it.
@{lindent 8}
@{lindent 13}/M - Multiple strings. This means the argument will take any number of strings, returning them as an array of strings. Any arguments not considered to be part of another option will be added to this option. Only one /M should be specified in a template.  Example: for a template "Dir/M,All/S" the command-line "foo bar all qwe" will set the boolean "all", and return an array consisting of "foo", "bar", and "qwe". The entry in the array will be a pointer to an array of string pointers, the last of which will be NULL.

There is an interaction between /M parameters and /A parameters. If there are unfilled /A parameters after parsing, it will grab strings from the end of a previous /M parameter list to fill the /A's. This is used for things like Copy ("From/A/M,To/A").
@{lindent 8}
ReadArgs() returns a struct @{"RDArgs" LINK "include:dos/rdargs.h/MAIN" 94} if it succeeds. This serves as an "anchor" to allow @{"FreeArgs()" LINK "FreeArgs" 0} to free the associated memory. You can also pass in a struct @{"RDArgs" LINK "include:dos/rdargs.h/MAIN" 94} to control the operation of ReadArgs() (normally you pass NULL for the parameter, and ReadArgs() allocates one for you). This allows providing different sources for the arguments, providing your own string buffer space for temporary storage, and extended help text. See <@{"dos/rdargs.h" LINK "include:dos/rdargs.h/MAIN" 0}> for more information on this. Note: if you pass in a struct @{"RDArgs" LINK "include:dos/rdargs.h/MAIN" 94}, you must still call @{"FreeArgs()" LINK "FreeArgs" 0} to release storage that gets attached to it, but you are responsible for freeing the @{"RDArgs" LINK "include:dos/rdargs.h/MAIN" 94} yourself.

If you pass in a @{"RDArgs" LINK "include:dos/rdargs.h/MAIN" 94} structure, you MUST reset (clear or set) RDA_Buffer for each new call to @{"RDArgs" LINK "include:dos/rdargs.h/MAIN" 94}. The exact behavior if you don't do this varies from release to release and case to case; don't count on the behavior!

See BUGS regarding passing in strings.
@{lindent 4}        
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
template - formatting string
array    - array of longwords for results, 1 per template entry
@{lindent 19}rdargs   - optional rdargs structure for options. @{"AllocDosObject()" LINK "AllocDosObject" 0} should be used for allocating them if you pass one in.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
result   - a struct @{"RDArgs" LINK "include:dos/rdargs.h/MAIN" 94} or NULL for failure.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In @{fg shine}V36@{fg text}, there were a couple of minor bugs with certain argument combinations (/M/N returned strings, /T didn't work, and /K and /F interacted). Also, a template with a /K before any non-switch parameter will require the argument name to be given in order for line to be accepted (i.e. "parm/K,xyzzy/A" would require "xyzzy=xxxxx" in order to work - "xxxxx" would not work). If you need to avoid this for @{fg shine}V36@{fg text}, put /K parameters after all non-switch parameters. These problems should be fixed for @{fg shine}V37@{fg text}.

Currently (@{fg shine}V37 @{fg text}and before) it requires any strings passed in to have newlines at the end of the string. This may or may not be fixed in the future.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FindArg()" LINK "FindArg" 0}, @{"ReadItem()" LINK "ReadItem" 0}, @{"FreeArgs()" LINK "FreeArgs" 0}, @{"AllocDosObject()" LINK "AllocDosObject" 0}
@ENDNODE

@NODE "ReadItem" "dos.library/ReadItem()"
@{jcenter}
@{u}@{b}ReadItem()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ReadItem - reads a single argument/name from command line  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
value = ReadItem(buffer, maxchars, input)
D0                D1        D2      D3

LONG ReadItem(STRPTR, LONG, struct @{"CSource" LINK "include:dos/rdargs.h/MAIN" 60} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Reads a "word" from either @{"Input()" LINK "Input" 0} (buffered), or via @{"CSource" LINK "include:dos/rdargs.h/MAIN" 60}, if it is non-NULL (see <@{"dos/rdargs.h" LINK "include:dos/rdargs.h/MAIN" 0}> for more information). Handles quoting and some '*' substitutions (*e and *n) inside quotes (only). See @{"dos/dos.h" LINK "include:dos/dos.h/MAIN" 0} for a listing of values returned by ReadItem() (ITEM_XXXX).  A "word" is delimited by whitespace, quotes, '=', or an EOF.

ReadItem always unreads the last thing read (@{"UnGetC" LINK "UnGetC" 0}(fh,-1)) so the caller can find out what the terminator was.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
buffer   - buffer to store word in.
maxchars - size of the buffer
input    - @{"CSource" LINK "include:dos/rdargs.h/MAIN" 60} input or NULL (uses @{"FGetC" LINK "FGetC" 0}(@{"Input()" LINK "Input" 0}))
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
value - See <@{"dos/dos.h" LINK "include:dos/dos.h/MAIN" 0}> for return values.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Doesn't actually unread the terminator.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"ReadArgs()" LINK "ReadArgs" 0}, @{"FindArg()" LINK "FindArg" 0}, @{"UnGetC()" LINK "UnGetC" 0}, @{"FGetC()" LINK "FGetC" 0}, @{"Input()" LINK "Input" 0}, <@{"dos/dos.h" LINK "include:dos/dos.h/MAIN" 0}>, <@{"dos/rdargs.h" LINK "include:dos/rdargs.h/MAIN" 0}>, @{"FreeArgs()" LINK "FreeArgs" 0}
@ENDNODE

@NODE "ReadLink" "dos.library/ReadLink()"
@{jcenter}
@{u}@{b}ReadLink()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ReadLink - Reads the path for a soft filesystem link  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = ReadLink( port, lock, path, buffer, size)
D0                   D1    D2    D3     D4     D5

BOOL ReadLink( struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *, BPTR, STRPTR, STRPTR, ULONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
ReadLink() takes a lock/name pair (usually from a failed attempt to use them to access an object with packets), and asks the filesystem to find the softlink and fill buffer with the modified path string. You then start the resolution process again by calling @{"GetDeviceProc()" LINK "GetDeviceProc" 0} with the new string from ReadLink().

Soft-links are resolved at access time by a combination of the filesystem (by returning ERROR_IS_SOFT_LINK to dos), and by Dos (using ReadLink() to resolve any links that are hit).
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
port - msgport of the filesystem
lock - lock this path is relative to on the filesystem
path - path that caused the ERROR_IS_SOFT_LINK
buffer - pointer to buffer for new path from handler.
size - size of buffer.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
Success - boolean
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In @{fg shine}V36@{fg text}, soft-links didn't work in the ROM filesystem. This was fixed for @{fg shine}V37@{fg text}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"MakeLink()" LINK "MakeLink" 0}, @{"Open()" LINK "Open" 0}, @{"Lock()" LINK "Lock" 0}, @{"GetDeviceProc()" LINK "GetDeviceProc" 0}
@ENDNODE

@NODE "Relabel" "dos.library/Relabel()"
@{jcenter}
@{u}@{b}Relabel()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Relabel - Change the volume name of a volume  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = Relabel(volumename,name)
D0                    D1      D2

BOOL Relabel(STRPTR,STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Changes the volumename of a volume, if supported by the filesystem.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
volumename - Full name of device to rename (with ':')
newname    - New name to apply to device (without ':')
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success    - Success/failure indicator
@ENDNODE

@NODE "RemAssignList" "dos.library/RemAssignList()"
@{jcenter}
@{u}@{b}RemAssignList()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
RemAssignList - Remove an entry from a multi-dir assign  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = RemAssignList(name,lock)
D0                       D1   D2

BOOL RemAssignList(STRPTR,BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Removes an entry from a multi-directory assign. The entry removed is the first one for which @{"SameLock()" LINK "SameLock" 0} with 'lock' returns that they are on the same object. The lock for the entry in the list is unlocked (not the entry passed in).
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name - Name of device to remove lock from (without trailing ':')
lock - Lock associated with the object to remove from the list
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure indicator.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In @{fg shine}V36@{fg text} through @{fg shine}V39.23@{fg text} dos, it would fail to remove the first lock in the assign. Fixed in @{fg shine}V39.24@{fg text} dos (after the @{fg shine}V39.106@{fg text} kickstart).
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Lock()" LINK "Lock" 0}, @{"AssignLock()" LINK "AssignLock" 0}, @{"AssignPath()" LINK "AssignPath" 0}, @{"AssignLate()" LINK "AssignLate" 0}, @{"DupLock()" LINK "DupLock" 0}, @{"AssignAdd()" LINK "AssignAdd" 0}, @{"UnLock()" LINK "UnLock" 0}
@ENDNODE

@NODE "RemDosEntry" "dos.library/RemDosEntry()"
@{jcenter}
@{u}@{b}RemDosEntry()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
RemDosEntry - Removes a Dos List entry from it's list  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = RemDosEntry(dlist)
D0                     D1

BOOL RemDosEntry(struct @{"DosList" LINK "include:dos/dosextens.h/MAIN" 371} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This removes an entry from the Dos Device list. The memory associated with the entry is NOT freed. NOTE: you must have locked the Dos List with the appropriate flags before calling this routine. Handler writers should see the @{"AddDosEntry()" LINK "AddDosEntry" 0} caveats about locking and use a similar workaround to avoid deadlocks.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
dlist   - Device list entry to be removed.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure indicator
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"AddDosEntry()" LINK "AddDosEntry" 0}, @{"FindDosEntry()" LINK "FindDosEntry" 0}, @{"NextDosEntry()" LINK "NextDosEntry" 0}, @{"LockDosList()" LINK "LockDosList" 0}, @{"MakeDosEntry()" LINK "MakeDosEntry" 0}, @{"FreeDosEntry()" LINK "FreeDosEntry" 0}
@ENDNODE

@NODE "RemSegment" "dos.library/RemSegment()"
@{jcenter}
@{u}@{b}RemSegment()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
RemSegment - Removes a resident segment from the resident list  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = RemSegment(segment)
D0                      D1

BOOL RemSegment(struct @{"Segment" LINK "include:dos/dosextens.h/MAIN" 298} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Removes a resident segment from the Dos resident segment list, unloads it, and does any other cleanup required. Will only succeed if the seg_UC (usecount) is 0.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
segment - the segment to be removed
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - success or failure.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FindSegment()" LINK "FindSegment" 0}, @{"AddSegment()" LINK "AddSegment" 0}
@ENDNODE

@NODE "Rename" "dos.library/Rename()"
@{jcenter}
@{u}@{b}Rename()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Rename - Rename a directory or file
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = Rename( oldName, newName )
D0                  D1       D2

BOOL Rename(STRPTR, STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Rename() attempts to rename the file or directory specified as 'oldName' with the name 'newName'. If the file or directory 'newName' exists, Rename() fails and returns an error. Both 'oldName' and the 'newName' can contain a directory specification. In this case, the file will be moved from one directory to another.

Note: it is impossible to Rename() a file from one volume to another.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
oldName - pointer to a null-terminated string
newName - pointer to a null-terminated string
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
success - boolean
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Relabel()" LINK "Relabel" 0}
@ENDNODE

@NODE "ReplyPkt" "dos.library/ReplyPkt()"
@{jcenter}
@{u}@{b}ReplyPkt()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
ReplyPkt - replies a packet to the person who sent it to you  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
ReplyPkt(packet, result1, result2)
           D1      D2       D3

void ReplyPkt(struct @{"DosPacket" LINK "include:dos/dosextens.h/MAIN" 107} *, LONG, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This returns a packet to the process which sent it to you. In addition, puts your pr_MsgPort address in dp_Port, so using ReplyPkt() again will send the message to you. (This is used in "ping-ponging" packets between two processes). It uses result 1 & 2 to set the dp_Res1 and dp_Res2 fields of the packet.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
packet  - packet to reply, assumed to set up correctly.
result1 - first result
result2 - secondary result
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"DoPkt()" LINK "DoPkt" 0}, @{"SendPkt()" LINK "SendPkt" 0}, @{"WaitPkt()" LINK "WaitPkt" 0}, @{"IoErr()" LINK "IoErr" 0}
@ENDNODE

@NODE "RunCommand" "dos.library/RunCommand()"
@{jcenter}
@{u}@{b}RunCommand()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
RunCommand - Runs a program using the current process  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
rc = RunCommand(seglist, stacksize, argptr, argsize)
D0                D1         D2       D3      D4

LONG RunCommand(BPTR, ULONG, STRPTR, ULONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Runs a command on your process/cli. Seglist may be any language, including BCPL programs. Stacksize is in bytes. argptr is a null-terminated string, argsize is its length. Returns the returncode the program exited with in d0. Returns -1 if the stack couldn't be allocated.

NOTE: the argument string MUST be terminated with a newline to work properly with @{"ReadArgs()" LINK "ReadArgs" 0} and other argument parsers.

RunCommand also takes care of setting up the current input filehandle in such a way that @{"ReadArgs()" LINK "ReadArgs" 0} can be used in the program, and restores the state of the buffering before returning. It also sets the value returned by @{"GetArgStr()" LINK "GetArgStr" 0}, and restores it before returning. NOTE: the setting of the argument string in the filehandle was added in @{fg shine}V37@{fg text}.

It's usually appropriate to set the command name (via @{"SetProgramName()" LINK "SetProgramName" 0}) before calling RunCommand(). RunCommand() sets the value returned by @{"GetArgStr()" LINK "GetArgStr" 0} while the command is running.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
seglist   - Seglist of command to run.
stacksize - Number of bytes to allocate for stack space
argptr    - Pointer to argument command string.
argsize   - Number of bytes in argument command.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
rc        - Return code from executed command. -1 indicates failure 
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"CreateNewProc()" LINK "CreateNewProc" 0}, @{"SystemTagList()" LINK "SystemTagList" 0}, @{"Execute()" LINK "Execute" 0}, @{"GetArgStr()" LINK "GetArgStr" 0}, @{"SetProgramName()" LINK "SetProgramName" 0}, @{"ReadArgs()" LINK "ReadArgs" 0}
@ENDNODE

@NODE "SameDevice" "dos.library/SameDevice()"
@{jcenter}
@{u}@{b}SameDevice()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SameDevice - Are two locks are on partitions of the device?  @{fg shine}(V37)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
same = SameDevice(lock1, lock2)
D0                 D1     D2

BOOL SameDevice( BPTR, BPTR )
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
SameDevice() returns whether two locks refer to partitions that are on the same physical device (if it can figure it out). This may be useful in writing copy routines to take advantage of asynchronous multi-device copies.

Entry existed in @{fg shine}V36@{fg text} and always returned 0.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
lock1, lock2 - locks
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
same - whether they're on the same device as far as Dos can determine.
@ENDNODE

@NODE "SameLock" "dos.library/SameLock()"
@{jcenter}
@{u}@{b}SameLock()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SameLock - returns whether two locks are on the same object  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
value = SameLock(lock1, lock2)
D0                D1     D2

LONG SameLock(BPTR, BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Compares two locks. Returns LOCK_SAME if they are on the same object, LOCK_SAME_VOLUME if on different objects on the same volume, and LOCK_DIFFERENT if they are on different volumes. Always compare for equality or non-equality with the results, in case new return values are added.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
lock1 - 1st lock for comparison
lock2 - 2nd lock for comparison
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
value - LOCK_SAME, LOCK_SAME_VOLUME, or LOCK_DIFFERENT
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Should do more extensive checks for NULL against a real lock, checking to see if the real lock is a lock on the root of the boot volume.

In @{fg shine}V36@{fg text}, it would return LOCK_SAME_VOLUME for different volumes on the same handler. Also, LOCK_SAME_VOLUME was LOCK_SAME_HANDLER (now an obsolete define, see <@{"dos/dos.h" LINK "include:dos/dos.h/MAIN" 0}>).
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
<@{"dos/dos.h" LINK "include:dos/dos.h/MAIN" 0}>
@ENDNODE

@NODE "Seek" "dos.library/Seek()"
@{jcenter}
@{u}@{b}Seek()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Seek - Set the current position for reading and writing
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
oldPosition = Seek( file, position, mode )
D0                  D1    D2        D3

LONG Seek(BPTR, LONG, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Seek() sets the read/write cursor for the file 'file' to the position 'position'. This position is used by both @{"Read()" LINK "Read" 0} and @{"Write()" LINK "Write" 0} as a place to start reading or writing. The result is the current absolute position in the file, or -1 if an error occurs, in which case @{"IoErr()" LINK "IoErr" 0} can be used to find more information. 'mode' can be OFFSET_BEGINNING, OFFSET_CURRENT or OFFSET_END. It is used to specify the relative start position. For example, 20 from current is a position 20 bytes forward from current, -20 is 20 bytes back from current.

So that to find out where you are, seek zero from current. The end of the file is a Seek() positioned by zero from end. You cannot Seek() beyond the end of a file.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
file - BCPL pointer to a file handle
position - integer
mode - integer
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
oldPosition - integer
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
The @{fg shine}V36@{fg text} and @{fg shine}V37@{fg text} ROM filesystem (and @{fg shine}V36@{fg text}/@{fg shine}V37@{fg text} l:fastfilesystem) returns the current position instead of -1 on an error. It sets @{"IoErr()" LINK "IoErr" 0} to 0 on success, and an error code on an error. This bug was fixed in the @{fg shine}V39@{fg text} filesystem.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Read()" LINK "Read" 0}, @{"Write()" LINK "Write" 0}, @{"SetFileSize()" LINK "SetFileSize" 0}
@ENDNODE

@NODE "SelectInput" "dos.library/SelectInput()"
@{jcenter}
@{u}@{b}SelectInput()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SelectInput - Select a filehandle as the default input channel  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
old_fh = SelectInput(fh)
D0                   D1

BPTR SelectInput(BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Set the current input as the default input for the process. This changes the value returned by @{"Input()" LINK "Input" 0}. old_fh should be closed or saved as needed.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh     - Newly default input handle
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
old_fh - Previous default input filehandle
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Input()" LINK "Input" 0}, @{"SelectOutput()" LINK "SelectOutput" 0}, @{"Output()" LINK "Output" 0}
@ENDNODE

@NODE "SelectOutput" "dos.library/SelectOutput()"
@{jcenter}
@{u}@{b}SelectOutput()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SelectOutput - Select a filehandle as the default output channel  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
old_fh = SelectOutput(fh)
D0                    D1

BPTR SelectOutput(BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Set the current output as the default output for the process. This changes the value returned by @{"Output()" LINK "Output" 0}. old_fh should be closed or saved as needed.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh     - Newly desired output handle
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
old_fh - Previous current output
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Output()" LINK "Output" 0}, @{"SelectInput()" LINK "SelectInput" 0}, @{"Input()" LINK "Input" 0}
@ENDNODE

@NODE "SendPkt" "dos.library/SendPkt()"
@{jcenter}
@{u}@{b}SendPkt()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SendPkt - Sends a packet to a handler  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
SendPkt(packet, port, replyport)
         D1     D2      D3

void SendPkt(struct @{"DosPacket" LINK "include:dos/dosextens.h/MAIN" 107} *,struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *,struct @{"MsgPort" LINK "exec/ports.h/MAIN" 27} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Sends a packet to a handler and does not wait. All fields in the packet must be initialized before calling this routine. The packet will be returned to replyport. If you wish to use this with @{"WaitPkt()" LINK "WaitPkt" 0}, use the address of your pr_MsgPort for replyport.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
packet - packet to send, must be initialized and have a message.
port   - pr_MsgPort of handler process to send to.
replyport - @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} for the packet to come back to.
@{lindent 4}
@{fg shine}@{b}NOTES@{ub}@{fg text}@{lindent 8}
Callable from a task.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"DoPkt()" LINK "DoPkt" 0}, @{"WaitPkt()" LINK "WaitPkt" 0}, @{"AllocDosObject()" LINK "AllocDosObject" 0}, @{"FreeDosObject()" LINK "FreeDosObject" 0}, @{"AbortPkt()" LINK "AbortPkt" 0}
@ENDNODE

@NODE "SetArgStr" "dos.library/SetArgStr()"
@{jcenter}
@{u}@{b}SetArgStr()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SetArgStr - Sets the arguments for the current process  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
oldptr = SetArgStr(ptr)
D0                 D1

STRPTR SetArgStr(STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Sets the arguments for the current program. The ptr MUST be reset to it's original value before process exit.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
ptr - pointer to new argument string.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
oldptr - the previous argument string
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"GetArgStr()" LINK "GetArgStr" 0}, @{"RunCommand()" LINK "RunCommand" 0}
@ENDNODE

@NODE "SetComment" "dos.library/SetComment()"
@{jcenter}
@{u}@{b}SetComment()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SetComment - Change a files' comment string
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = SetComment( name, comment )
D0                    D1    D2

BOOL SetComment(STRPTR, STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
SetComment() sets a comment on a file or directory. The comment is a pointer to a null-terminated string of up to 80 characters in the current ROM filesystem (and RAM:). Note that not all filesystems will support comments (for example, NFS usually will not), or the size of comment supported may vary.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name    - pointer to a null-terminated string
comment - pointer to a null-terminated string
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
success - boolean
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Examine()" LINK "Examine" 0}, @{"ExNext()" LINK "ExNext" 0}, @{"SetProtection()" LINK "SetProtection" 0}
@ENDNODE

@NODE "SetConsoleTask" "dos.library/SetConsoleTask()"
@{jcenter}
@{u}@{b}SetConsoleTask()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SetConsoleTask - Sets the default console for the process  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
oldport = SetConsoleTask(port)
D0                        D1

struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *SetConsoleTask(struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Sets the default console task's port (pr_ConsoleTask) for the current process.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
port - The pr_MsgPort of the default console handler for the process
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
oldport - The previous ConsoleTask value.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"GetConsoleTask()" LINK "GetConsoleTask" 0}, @{"Open()" LINK "Open" 0}
@ENDNODE

@NODE "SetCurrentDirName" "dos.library/SetCurrentDirName()"
@{jcenter}
@{u}@{b}SetCurrentDirName()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SetCurrentDirName - Sets the directory name for the process  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = SetCurrentDirName(name)
D0                        D1

BOOL SetCurrentDirName(STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Sets the name for the current dir in the cli structure. If the name is too long to fit, a failure is returned, and the old value is left intact. It is advised that you inform the user of this condition. This routine is safe to call even if there is no CLI structure.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name    - Name of directory to be set.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure indicator
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
This clips to a fixed (1.3 compatible) size.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"GetCurrentDirName()" LINK "GetCurrentDirName" 0}
@ENDNODE

@NODE "SetFileDate" "dos.library/SetFileDate()"
@{jcenter}
@{u}@{b}SetFileDate()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SetFileDate - Sets the modification date for a file or dir  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = SetFileDate(name, date)
D0                     D1    D2

BOOL SetFileDate(STRPTR, struct @{"DateStamp" LINK "include:dos/dos.h/MAIN" 51} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Sets the file date for a file or directory. Note that for the Old File System and the Fast File System, the date of the root directory cannot be set. Other filesystems may not support setting the date for all files/directories.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name - Name of object
date - New modification date
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure indication
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"DateStamp()" LINK "DateStamp" 0}, @{"Examine()" LINK "Examine" 0}, @{"ExNext()" LINK "ExNext" 0}, @{"ExAll()" LINK "ExAll" 0}
@ENDNODE

@NODE "SetFileSize" "dos.library/SetFileSize()"
@{jcenter}
@{u}@{b}SetFileSize()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SetFileSize - Sets the size of a file  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
newsize = SetFileSize(fh, offset, mode)
D0                    D1    D2     D3

LONG SetFileSize(BPTR, LONG, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Changes the file size, truncating or extending as needed. Not all handlers may support this; be careful and check the return code. If the file is extended, no values should be assumed for the new bytes. If the new position would be before the filehandle's current position in the file, the filehandle will end with a position at the end-of-file. If there are other filehandles open onto the file, the new size will not leave any filehandle pointing past the end-of-file. You can check for this by looking at the new size (which would be different than what you requested).

The seek position should not be changed unless the file is made smaller than the current seek position. However, see BUGS.

Do NOT count on any specific values to be in any extended area.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh     - File to be truncated/extended.
offset - Offset from position determined by mode.
mode   - One of OFFSET_BEGINNING, OFFSET_CURRENT, or OFFSET_END.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
newsize - position of new end-of-file or -1 for error.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
The RAM: filesystem and the normal Amiga filesystem act differently in where the file position is left after SetFileSize(). RAM: leaves you at the new end of the file (incorrectly), while the Amiga ROM filesystem leaves the seek position alone, unless the new position is less than the current position, in which case you're left at the new EOF.

The best workaround is to not make any assumptions about the seek position after SetFileSize().   
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Seek()" LINK "Seek" 0}
@ENDNODE

@NODE "SetFileSysTask" "dos.library/SetFileSysTask()"
@{jcenter}
@{u}@{b}SetFileSysTask()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SetFileSysTask - Sets the default filesystem for the process  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
oldport = SetFileSysTask(port)
D0                        D1

struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *SetFileSysTask(struct @{"MsgPort" LINK "include:exec/ports.h/MAIN" 27} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Sets the default filesystem task's port (pr_FileSystemTask) for the current process.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
port - The pr_MsgPort of the default filesystem for the process
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
oldport - The previous FileSysTask value
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"GetFileSysTask()" LINK "GetFileSysTask" 0}, @{"Open()" LINK "Open" 0}
@ENDNODE

@NODE "SetIoErr" "dos.library/SetIoErr()"
@{jcenter}
@{u}@{b}SetIoErr()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SetIoErr - Sets the value returned by @{"IoErr()" LINK "IoErr" 0}  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
oldcode = SetIoErr(code)
D0                  D1

LONG SetIoErr(LONG);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This routine sets up the secondary result (pr_Result2) return code  (returned by the @{"IoErr()" LINK "IoErr" 0} function).
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
code - Code to be returned by a call to @{"IoErr()" LINK "IoErr" 0}.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
oldcode - The previous error code.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"IoErr()" LINK "IoErr" 0}, @{"Fault()" LINK "Fault" 0}, @{"PrintFault()" LINK "PrintFault" 0}
@ENDNODE

@NODE "SetMode" "dos.library/SetMode()"
@{jcenter}
@{u}@{b}SetMode()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SetMode - Set the current behavior of a handler  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = SetMode(fh, mode)
D0                D1  D2

BOOL SetMode(BPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
SetMode() sends an ACTION_SCREEN_MODE packet to the handler in question, normally for changing a CON: handler to raw mode or vice-versa. For CON:, use 1 to go to RAW: mode, 0 for CON: mode.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh   - filehandle
mode - The new mode you want
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Boolean
@ENDNODE

@NODE "SetOwner" "dos.library/SetOwner()"
@{jcenter}
@{u}@{b}SetOwner()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SetOwner - Set owner information for a file or directory  @{fg shine}(V39)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = SetOwner( name, owner_info )
D0                   D1       D2

BOOL SetOwner (STRPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
SetOwner() sets the owner information for the file or directory. This value is a 32-bit value that is normally split into 16 bits of owner user id (bits 31-16), and 16 bits of owner group id (bits 15-0). However, other than returning them as shown by @{"Examine()" LINK "Examine" 0}/@{"ExNext()" LINK "ExNext" 0}/@{"ExAll()" LINK "ExAll" 0}, the filesystem take no interest in the values. These are primarily for use by networking software (clients and hosts), in conjunction with the FIBF_OTR_xxx and FIBF_GRP_xxx protection bits.

This entrypoint did not exist in @{fg shine}V36@{fg text}, so you must open at least @{fg shine}V37@{fg text} dos.library to use it. @{fg shine}V37@{fg text} dos.library will return FALSE to this call.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name       - pointer to a null-terminated string
owner_info - owner uid (31:16) and group id (15:0)
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
success - boolean
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"SetProtection()" LINK "SetProtection" 0}, @{"Examine()" LINK "Examine" 0}, @{"ExNext()" LINK "ExNext" 0}, @{"ExAll()" LINK "ExAll" 0}, <@{"dos/dos.h" LINK "include:dos/dos.h/MAIN" 0}>
@ENDNODE

@NODE "SetProgramDir" "dos.library/SetProgramDir()"
@{jcenter}
@{u}@{b}SetProgramDir()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SetProgramDir - Sets the directory returned by @{"GetProgramDir()" LINK "GetProgramDir" 0}  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
oldlock = SetProgramDir(lock)
D0                       D1

BPTR SetProgramDir(BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Sets a shared lock on the directory the program was loaded from. This can be used for a program to find data files, etc, that are stored with the program, or to find the program file itself. NULL is a valid input. This can be accessed via @{"GetProgramDir()" LINK "GetProgramDir" 0} or by using paths relative to PROGDIR:.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
lock - A lock on the directory the current program was loaded from
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
oldlock - The previous ProgramDir.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"GetProgramDir()" LINK "GetProgramDir" 0}, @{"Open()" LINK "Open" 0}
@ENDNODE

@NODE "SetProgramName" "dos.library/SetProgramName()"
@{jcenter}
@{u}@{b}SetProgramName()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SetProgramName - Sets the name of the program being run  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = SetProgramName(name)
D0                        D1

BOOL SetProgramName(STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Sets the name for the program in the cli structure. If the name is too long to fit, a failure is returned, and the old value is left intact. It is advised that you inform the user if possible of this condition, and/or set the program name to an empty string. This routine is safe to call even if there is no CLI structure.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name    - Name of program to use.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure indicator.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
This clips to a fixed (1.3 compatible) size.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"GetProgramName()" LINK "GetProgramName" 0}
@ENDNODE

@NODE "SetPrompt" "dos.library/SetPrompt()"
@{jcenter}
@{u}@{b}SetPrompt()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SetPrompt - Sets the CLI/shell prompt for the current process  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = SetPrompt(name)
D0                   D1

BOOL SetPrompt(STRPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Sets the text for the prompt in the cli structure. If the prompt is too long to fit, a failure is returned, and the old value is left intact. It is advised that you inform the user of this condition. This routine is safe to call even if there is no CLI structure.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name    - Name of prompt to be set.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure indicator.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
This clips to a fixed (1.3 compatible) size.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"GetPrompt()" LINK "GetPrompt" 0}
@ENDNODE

@NODE "SetProtection" "dos.library/SetProtection()"
@{jcenter}
@{u}@{b}SetProtection()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SetProtection - Set protection for a file or directory
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = SetProtection( name, mask )
D0                       D1    D2

BOOL SetProtection (STRPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
SetProtection() sets the protection attributes on a file or directory. See <@{"dos/dos.h" LINK "include:dos/dos.h/MAIN" 0}> for a listing of protection bits.

Before @{fg shine}V36@{fg text}, the ROM filesystem didn't respect the Read and Write bits. In @{fg shine}V36@{fg text} or later and in the FFS, the Read and Write bits are respected.

The archive bit should be cleared by the filesystem whenever the file is changed. Backup utilities will generally set the bit after backing up each file.

The @{fg shine}V36@{fg text} Shell looks at the execute bit, and will refuse to execute a file if it is set.

Other bits will be defined in the <@{"dos/dos.h" LINK "include:dos/dos.h/MAIN" 0}> include files. Rather than referring to bits by number you should use the definitions in <@{"dos/dos.h" LINK "include:dos/dos.h/MAIN" 0}>.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name - pointer to a null-terminated string
mask - the protection mask required
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
success - boolean
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"SetComment()" LINK "SetComment" 0}, @{"Examine()" LINK "Examine" 0}, @{"ExNext()" LINK "ExNext" 0}, <@{"dos/dos.h" LINK "include:dos/dos.h/MAIN" 0}>
@ENDNODE

@NODE "SetVar" "dos.library/SetVar()"
@{jcenter}
@{u}@{b}SetVar()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SetVar - Sets a local or environment variable  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = SetVar( name, buffer, size, flags ) 
D0                 D1     D2     D3    D4

BOOL SetVar(STRPTR, STRPTR, LONG, ULONG ) 
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Sets a local or environment variable. It is advised to only use ASCII strings inside variables, but not required.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{lindent 17}name   - pointer to an variable name. Note variable names follow filesystem syntax and semantics.@{lindent 8}
@{lindent 17}buffer - a user allocated area which contains a string that is the value to be associated with this variable.@{lindent 8}
@{lindent 17}size   - length of the buffer region in bytes. -1 means buffer contains a null-terminated string.@{lindent 8}
@{lindent 17}flags  - combination of type of var to set (low 8 bits), and flags to control the behavior of this routine. Currently defined flags include:

GVF_LOCAL_ONLY - set a local (to your process) variable.
GVF_GLOBAL_ONLY - set a global environment variable.

The default is to set a local environment variable.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - If non-zero, the variable was sucessfully set, FALSE indicates failure.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
LV_VAR is the only type that can be global
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"GetVar()" LINK "GetVar" 0}, @{"DeleteVar()" LINK "DeleteVar" 0}, @{"FindVar()" LINK "FindVar" 0}, <@{"dos/var.h" LINK "include:dos/var.h/MAIN" 0}>
@ENDNODE

@NODE "SetVBuf" "dos.library/SetVBuf()"
@{jcenter}
@{u}@{b}SetVBuf()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SetVBuf - set buffering modes and size  @{fg shine}(V39)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
error = SetVBuf(fh, buff, type, size)
D0              D1   D2    D3    D4

LONG SetVBuf(BPTR, STRPTR, LONG, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Changes the buffering modes and buffer size for a filehandle. With buff == NULL, the current buffer will be deallocated and a new one of (approximately) size will be allocated. If buffer is non-NULL, it will be used for buffering and must be at least max(size,208) bytes long, and MUST be longword aligned. If size is -1, then only the buffering mode will be changed.

Note that a user-supplied buffer will not be freed if it is later replaced by another SetVBuf() call, nor will it be freed if the filehandle is closed.

Has no effect on the buffersize of filehandles that were not created by @{"AllocDosObject()" LINK "AllocDosObject" 0}.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh   - Filehandle
@{lindent 15}buff - buffer pointer for buffered I/O or NULL. MUST be LONG-aligned!@{lindent 8}
type - buffering mode (see <@{"dos/stdio.h" LINK "include:dos/stdio.h/MAIN" 0}>)
@{lindent 15}size - size of buffer for buffered I/O (sizes less than 208 bytes will be rounded up to 208), or -1.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 16}error - 0 if successful. NOTE: opposite of most dos functions! NOTE: fails if someone has replaced the buffer without using SetVBuf() - @{"RunCommand()" LINK "RunCommand" 0} does this. Remember to check error before freeing user-supplied buffers!
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Not implemented until after @{fg shine}V39@{fg text}. From @{fg shine}V36@{fg text} up to @{fg shine}V39@{fg text}, always returned 0.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FPutC()" LINK "FPutC" 0}, @{"FGetC()" LINK "FGetC" 0}, @{"UnGetC()" LINK "UnGetC" 0}, @{"Flush()" LINK "Flush" 0}, @{"FRead()" LINK "FRead" 0}, @{"FWrite()" LINK "FWrite" 0}, @{"FGets()" LINK "FGets" 0}, @{"FPuts()" LINK "FPuts" 0}, @{"AllocDosObject()" LINK "AllocDosObject" 0}
@ENDNODE

@NODE "SplitName" "dos.library/SplitName()"
@{jcenter}
@{u}@{b}SplitName()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SplitName - splits out a component of a pathname into a buffer  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
newpos = SplitName(name, separator, buf, oldpos, size)
D0                  D1      D2      D3     D4     D5

WORD SplitName(STRPTR, @{"UBYTE" LINK "include:exec/nodes.h/MAIN" 21}, STRPTR, WORD, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This routine splits out the next piece of a name from a given file name. Each piece is copied into the buffer, truncating at size-1 characters. The new position is then returned so that it may be passed in to the next call to splitname. If the separator is not found within 'size' characters, then size-1 characters plus a null will be put into the buffer, and the position of the next separator will be returned.

If a a separator cannot be found, -1 is returned (but the characters from the old position to the end of the string are copied into the buffer, up to a maximum of size-1 characters). Both strings are null-terminated.

This function is mainly intended to support handlers.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
name      - Filename being parsed.
separator - Separator charactor to split by.
buf       - Buffer to hold separated name.
oldpos    - Current position in the file.
size      - Size of buf in bytes (including null termination).
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
newpos    - New position for next call to splitname.  -1 for last one.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In @{fg shine}V36@{fg text} and @{fg shine}V37@{fg text}, path portions greater than or equal to 'size' caused the last character of the portion to be lost when followed by a separator. Fixed for @{fg shine}V39@{fg text} dos. For @{fg shine}V36@{fg text} and @{fg shine}V37@{fg text}, the suggested work-around is to call SplitName() with a buffer one larger than normal (for example, 32 bytes), and then set buf[size-2] to '0' (for example, buf[30] = '\0';).
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FilePart()" LINK "FilePart" 0}, @{"PathPart()" LINK "PathPart" 0}, @{"AddPart()" LINK "AddPart" 0}
@ENDNODE

@NODE "StartNotify" "dos.library/StartNotify()"
@{jcenter}
@{u}@{b}StartNotify()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
StartNotify - Starts notification on a file or directory  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = StartNotify(notifystructure)
D0                          D1

BOOL StartNotify(struct @{"NotifyRequest" LINK "include:dos/notify.h/MAIN" 50} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Posts a notification request.  Do not modify the notify structure while it is active. You will be notified when the file or directory changes. For files, you will be notified after the file is closed. Not all filesystems will support this: applications should NOT require it. In particular, most network filesystems won't support it.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
notifystructure - A filled-in @{"NotifyRequest" LINK "include:dos/notify.h/MAIN" 50} structure
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success/failure of request
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
The @{fg shine}V36@{fg text} floppy/HD filesystem doesn't actually send notifications. The @{fg shine}V36@{fg text} ram handler (ram:) does. This has been fixed for @{fg shine}V37@{fg text}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"EndNotify()" LINK "EndNotify" 0}, <@{"dos/notify.h" LINK "include:dos/notify.h/MAIN" 0}>
@ENDNODE

@NODE "StrToDate" "dos.library/StrToDate()"
@{jcenter}
@{u}@{b}StrToDate()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
StrToDate - Converts a string to a DateStamp  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = StrToDate( datetime )
D0                      D1

BOOL StrToDate( struct @{"DateTime" LINK "include:dos/datetime.h/MAIN" 24} * )
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Converts a human readable ASCII string into an AmigaDOS @{"DateStamp" LINK "DateStamp" 0}.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
@{"DateTime" LINK "include:dos/datetime.h/MAIN" 24} - a pointer to an initialized @{"DateTime" LINK "include:dos/datetime.h/MAIN" 24} structure.

The @{"DateTime" LINK "include:dos/datetime.h/MAIN" 24} structure should be initialized as follows:

dat_Stamp  - ignored on input.

@{lindent 21}dat_Format - a format byte which specifies the format of the dat_StrDat. This can be any of the following (note: If value used  is something other than those below, the default of FORMAT_DOS is used):

FORMAT_DOS:  AmigaDOS format (dd-mmm-yy).
FORMAT_INT:  International format (yy-mmm-dd).
FORMAT_USA:  American format (mm-dd-yy).
FORMAT_CDN:  Canadian format (dd-mm-yy).
FORMAT_DEF:  default format for locale.
@{lindent 8}
@{lindent 20}dat_Flags - a flags byte. The only flag which affects this function is:

DTF_SUBST:   ignored by this function
@{lindent 33}DTF_FUTURE:  If set, indicates that strings such as (stored in dat_StrDate) "Monday" refer to "next" monday. Otherwise, if clear, strings like "Monday" refer to "last" monday.
@{lindent 8}
dat_StrDay - ignored bythis function.

@{lindent 24}dat_StrDate -   pointer to valid string representing the date. This can be a "DTF_SUBST" style string such as "Today" "Tomorrow" "Monday", or it may be a string as specified by the dat_Format byte. This will be converted to the ds_Days portion of the DateStamp. If this pointer is NULL, DateStamp->ds_Days will not be affected.
@{lindent 8}
@{lindent 24}dat_StrTime -   pointer to a buffer which contains the time in the ASCII format hh:mm:ss. This will be converted to the ds_Minutes and ds_Ticks portions of the DateStamp. If this pointer is NULL, ds_Minutes and ds_Ticks will be unchanged.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 18}success - a zero return indicates that a conversion could not be performed. A non-zero return indicates that the DateTime.dat_Stamp variable contains the converted values.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"DateStamp()" LINK "DateStamp" 0}, @{"DateToStr()" LINK "DateToStr" 0}, <@{"dos/datetime.h" LINK "include:dos/datetime.h/MAIN" 0}>
@ENDNODE

@NODE "StrToLong" "dos.library/StrToLong()"
@{jcenter}
@{u}@{b}StrToLong()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
StrToLong - string to long value (decimal)  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
characters = StrToLong(string,value)
D0                       D1    D2

LONG StrToLong(STRPTR, LONG *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Converts decimal string into LONG value. Returns number of characters converted. Skips over leading spaces & tabs (included in count). If no decimal digits are found (after skipping leading spaces & tabs), StrToLong() returns -1 for characters converted, and puts 0 into value.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
string - Input string.
value  - Pointer to long value. Set to 0 if no digits are converted.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
result - Number of characters converted or -1.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Before @{fg shine}V39@{fg text}, if there were no convertible characters it returned the number of leading white-space characters (space and tab in this case).
@ENDNODE

@NODE "SystemTagList" "dos.library/SystemTagList()"
@{jcenter}
@{u}@{b}SystemTagList()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
SystemTagList - Have a shell execute a command line  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
error = SystemTagList(command, tags)
D0                      D1      D2 

LONG SystemTagList(STRPTR, struct @{"TagItem" LINK "include:utility/tagitem.h/MAIN" 32} *)

error = System(command, tags)
D0               D1      D2 

LONG System(STRPTR, struct @{"TagItem" LINK "include:utility/tagitem.h/MAIN" 32} *)

error = SystemTags(command, Tag1, ...)

LONG SystemTags(STRPTR, ULONG, ...)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Similar to @{"Execute()" LINK "Execute" 0}, but does not read commands from the input filehandle. Spawns a Shell process to execute the command, and returns the returncode the command produced, or -1 if the command could not be run for any reason. The input and output filehandles will not be closed by System, you must close them (if needed) after System returns, if you specified them via SYS_Input or SYS_Output.

By default the new process will use your current @{"Input()" LINK "Input" 0} and @{"Output()" LINK "Output" 0} filehandles. Normal Shell command-line parsing will be done including redirection on 'command'. The current directory and path will be inherited from your process. Your path will be used to find the command (if no path is specified).

Note that you may NOT pass the same filehandle for both SYS_Input and SYS_Output. If you want input and output to both be to the same CON: window, pass a SYS_Input of a filehandle on the CON: window, and pass a SYS_Output of NULL. The shell will automatically set the default @{"Output()" LINK "Output" 0} stream to the window you passed via SYS_Input, by opening "*" on that handler.

If used with the SYS_Asynch flag, it WILL close both it's input and output filehandles after running the command (even if these were your @{"Input()" LINK "Input" 0} and @{"Output()" LINK "Output" 0}!)

Normally uses the boot (ROM) shell, but other shells can be specified via SYS_UserShell and SYS_CustomShell. Normally, you should send things written by the user to the UserShell. The UserShell defaults to the same shell as the boot shell.

The tags are passed through to @{"CreateNewProc()" LINK "CreateNewProc" 0} (tags that conflict with SystemTagList() will be filtered out). This allows setting things like priority, etc for the new process. The tags that are currently filtered out are:
@{lindent 16}
NP_Seglist
NP_FreeSeglist
NP_Entry
NP_Input
NP_Output
NP_CloseInput
NP_CloseOutput
NP_HomeDir
NP_Cli
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
command - Program and arguments
@{lindent 18}tags    - see <@{"dos/dostags.h" LINK "include:dos/dostags.h/MAIN" 0}>. Note that both SystemTagList() - specific tags and tags from @{"CreateNewProc()" LINK "CreateNewProc" 0} may be passed.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 18}error   - 0 for success, result from command, or -1. Note that on error, the caller is responsible for any filehandles or other things passed in via tags. -1 will only be returned if dos could not create the new shell. If the command is not found the shell will return an error value, normally RETURN_ERROR.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Execute()" LINK "Execute" 0}, @{"CreateNewProc()" LINK "CreateNewProc" 0}, <@{"dos/dostags.h" LINK "include:dos/dostags.h/MAIN" 0}>, @{"Input()" LINK "Input" 0}, @{"Output()" LINK "Output" 0}
@ENDNODE

@NODE "UnGetC" "dos.library/UnGetC()"
@{jcenter}
@{u}@{b}UnGetC()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
UnGetC - Makes a char available for reading again. (buffered)  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
value = UnGetC(fh, character)
D0             D1      D2

LONG UnGetC(BPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Pushes the character specified back into the input buffer. Every time you use a buffered read routine, you can always push back 1 character. You may be able to push back more, though it is not recommended, since there is no guarantee on how many can be pushed back at a given moment.

Passing -1 for the character will cause the last character read to be pushed back. If the last character read was an EOF, the next character read will be an EOF.

Note: UnGetC can be used to make sure that a filehandle is set up as a read filehandle. This is only of importance if you are writing a shell, and must manipulate the filehandle's buffer.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh        - filehandle to use for buffered I/O
character - character to push back or -1
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
@{lindent 20}value     - character pushed back, or FALSE if the character cannot be pushed back.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
In @{fg shine}V36@{fg text}, UnGetC(fh,-1) after an EOF would not cause the next character read to be an EOF. This was fixed for @{fg shine}V37@{fg text}.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FGetC()" LINK "FGetC" 0}, @{"FPutC()" LINK "FPutC" 0}, @{"Flush()" LINK "Flush" 0}
@ENDNODE

@NODE "UnLoadSeg" "dos.library/UnLoadSeg()"
@{jcenter}
@{u}@{b}UnLoadSeg()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
UnLoadSeg - Unload a seglist previously loaded by @{"LoadSeg()" LINK "LoadSeg" 0}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = UnLoadSeg( seglist )
D0                     D1

BOOL UnLoadSeg(BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Unload a seglist loaded by @{"LoadSeg()" LINK "LoadSeg" 0}. 'seglist' may be zero. Overlaid segments will have all needed cleanup done, including closing files.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
seglist - BCPL pointer to a segment identifier
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
@{lindent 18}success - returns 0 if a NULL seglist was passed or if it failed to close an overlay file. NOTE: this function returned a random value before @{fg shine}V36@{fg text}!
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"LoadSeg()" LINK "LoadSeg" 0}, @{"InternalLoadSeg()" LINK "InternalLoadSeg" 0}, @{"InternalUnLoadSeg()" LINK "InternalUnLoadSeg" 0}
@ENDNODE

@NODE "UnLock" "dos.library/UnLock()"
@{jcenter}
@{u}@{b}UnLock()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
UnLock - Unlock a directory or file
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
UnLock( lock )
         D1

void UnLock(BPTR)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
The filing system lock (obtained from @{"Lock()" LINK "Lock" 0}, @{"DupLock()" LINK "DupLock" 0}, or @{"CreateDir()" LINK "CreateDir" 0}) is removed and deallocated.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
lock - BCPL pointer to a lock
@{lindent 4}
@{fg shine}@{b}NOTE@{ub}@{fg text}@{lindent 8}
passing zero to UnLock() is harmless
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Lock()" LINK "Lock" 0}, @{"DupLock()" LINK "DupLock" 0}, @{"ParentOfFH()" LINK "ParentOfFH" 0}, @{"DupLockFromFH()" LINK "DupLockFromFH" 0}
@ENDNODE

@NODE "UnLockDosList" "dos.library/UnLockDosList()"
@{jcenter}
@{u}@{b}UnLockDosList()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
UnLockDosList - Unlocks the Dos List  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
UnLockDosList(flags)
                D1

void UnLockDosList(ULONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Unlocks the access on the Dos Device List. You MUST pass the same flags you used to lock the list.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
flags - MUST be the same flags passed to @{"LockDosList()" LINK "LockDosList" 0}/@{"AttemptLockDosList()" LINK "AttemptLockDosList" 0}
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"AttemptLockDosList()" LINK "AttemptLockDosList" 0}, @{"LockDosList()" LINK "LockDosList" 0}, @{"Permit()" LINK "exec.guide/Permit" 0}
@ENDNODE

@NODE "UnLockRecord" "dos.library/UnLockRecord()"
@{jcenter}
@{u}@{b}UnLockRecord()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
UnLockRecord - Unlock a record  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = UnLockRecord(fh,offset,length)
D0                     D1   D2     D3

BOOL UnLockRecord(BPTR,ULONG,ULONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This releases the specified lock on a file. Note that you must use the same filehandle you used to lock the record, and offset and length must be the same values used to lock it. Every @{"LockRecord()" LINK "LockRecord" 0} call must be balanced with an UnLockRecord() call.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh      - File handle of locked file
offset  - Record start position
length  - Length of record in bytes
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success - Success or failure.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
See @{"LockRecord()" LINK "LockRecord" 0}
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"LockRecords()" LINK "LockRecords" 0}, @{"LockRecord()" LINK "LockRecord" 0}, @{"UnLockRecords()" LINK "UnLockRecords" 0}
@ENDNODE

@NODE "UnLockRecords" "dos.library/UnLockRecords()"
@{jcenter}
@{u}@{b}UnLockRecords()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
UnLockRecords - Unlock a list of records  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
success = UnLockRecords(record_array)
D0                           D1

BOOL UnLockRecords(struct @{"RecordLock" LINK "include:dos/record.h/MAIN" 26} *)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This releases an array of record locks obtained using @{"LockRecords()" LINK "LockRecords" 0}. You should NOT modify the record_array while you have the records locked. Every @{"LockRecords()" LINK "LockRecords" 0} call must be balanced with an UnLockRecords() call.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
record_array - List of records to be unlocked
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
success      - Success or failure.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
See @{"LockRecord()" LINK "LockRecord" 0}
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"LockRecords()" LINK "LockRecords" 0}, @{"LockRecord()" LINK "LockRecord" 0}, @{"UnLockRecord()" LINK "UnLockRecord" 0}
@ENDNODE

@NODE "VFPrintf" "dos.library/VFPrintf()"
@{jcenter}
@{u}@{b}VFPrintf()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
VFPrintf - format and print a string to a file (buffered)  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
count = VFPrintf(fh, fmt, argv)
D0               D1  D2    D3

LONG VFPrintf(BPTR, STRPTR, LONG *)

count = FPrintf(fh, fmt, ...)

LONG FPrintf(BPTR, STRPTR, ...)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Writes the formatted string and values to the given file. This routine is assumed to handle all internal buffering so that the formatting string and resultant formatted values can be arbitrarily long. Any secondary error code is returned in @{"IoErr()" LINK "IoErr" 0}. This routine is buffered.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh    - Filehandle to write to
fmt   - @{"RawDoFmt()" LINK "exec.guide/RawDoFmt" 0} style formatting string
argv  - Pointer to array of formatting values
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
count - Number of bytes written or -1 (EOF) for an error
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
The prototype for FPrintf() currently forces you to cast the first varargs parameter to LONG due to a deficiency in the program that generates fds, prototypes, and amiga.lib stubs.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"VPrintf()" LINK "VPrintf" 0}, @{"VFWritef()" LINK "VFWritef" 0}, @{"RawDoFmt()" LINK "exec.guide/RawDoFmt" 0}, @{"FPutC()" LINK "FPutC" 0}
@ENDNODE

@NODE "VFWritef" "dos.library/VFWritef()"
@{jcenter}
@{u}@{b}VFWritef()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
VFWritef - write a BCPL formatted string to a file (buffered)  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
count = VFWritef(fh, fmt, argv)
D0               D1  D2    D3

LONG VFWritef(BPTR, STRPTR, LONG *)

count = FWritef(fh, fmt, ...)

LONG FWritef(BPTR, STRPTR, ...)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Writes the formatted string and values to the specified file. This routine is assumed to handle all internal buffering so that the formatting string and resultant formatted values can be arbitrarily long. The formats are in BCPL form. This routine is buffered.

Supported formats are: (Note x is in base 36!)@{lindent 16}
%S  - string (CSTR)
@{lindent 22}%Tx - writes a left-justified string in a field at least x bytes long.@{lindent 16}
@{lindent 22}%C  - writes a single character@{lindent 16}
@{lindent 22}%Ox - writes a number in octal, maximum x characters wide@{lindent 16}
@{lindent 22}%Xx - writes a number in hex, maximum x characters wide@{lindent 16}
@{lindent 22}%Ix - writes a number in decimal, maximum x characters wide@{lindent 16}
@{lindent 22}%N  - writes a number in decimal, any length@{lindent 16}
@{lindent 22}%Ux - writes an unsigned number, maximum x characters wide@{lindent 16}
@{lindent 22}%$  - ignore parameter
@{lindent 8}
Note: 'x' above is actually the character value - '0'.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fh    - filehandle to write to
fmt   - BCPL style formatting string
argv  - Pointer to array of formatting values
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
count - Number of bytes written or -1 for error
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
As of @{fg shine}V37@{fg text}, VFWritef() does NOT return a valid return value. In order to reduce possible errors, the prototypes supplied for the system as of @{fg shine}V37@{fg text} have it typed as VOID.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"VFPrintf()" LINK "VFPrintf" 0}, @{"VFPrintf()" LINK "VFPrintf" 0}, @{"FPutC()" LINK "FPutC" 0}
@ENDNODE

@NODE "VPrintf" "dos.library/VPrintf()"
@{jcenter}
@{u}@{b}VPrintf()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
VPrintf - format and print string (buffered)  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
count = VPrintf(fmt, argv)
D0               D1   D2

LONG VPrintf(STRPTR, LONG *)

count = Printf(fmt, ...)

LONG Printf(STRPTR, ...)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Writes the formatted string and values to @{"Output()" LINK "Output" 0}. This routine is assumed to handle all internal buffering so that the formatting string and resultant formatted values can be arbitrarily long. Any secondary error code is returned in @{"IoErr()" LINK "IoErr" 0}. This routine is buffered.

Note: @{"RawDoFmt()" LINK "exec.guide/RawDoFmt" 0} assumes 16 bit ints, so you will usually need 'l's in your formats (ex: %ld versus %d).
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
fmt   - exec.library @{"RawDoFmt()" LINK "exec.guide/RawDoFmt" 0} style formatting string
argv  - Pointer to array of formatting values
@{lindent 4}   
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
count - Number of bytes written or -1 (EOF) for an error
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
The prototype for Printf() currently forces you to cast the first varargs parameter to LONG due to a deficiency in the program that generates fds, prototypes, and amiga.lib stubs.
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"VFPrintf()" LINK "VFPrintf" 0}, @{"VFWritef()" LINK "VFWritef" 0}, @{"RawDoFmt()" LINK "exec.guide/RawDoFmt" 0}, @{"FPutC()" LINK "FPutC" 0}
@ENDNODE

@NODE "WaitForChar" "dos.library/WaitForChar()"
@{jcenter}
@{u}@{b}WaitForChar()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
WaitForChar - Determine if chars arrive within a time limit
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
status = WaitForChar( file, timeout )
D0                    D1    D2

BOOL WaitForChar(BPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
If a character is available to be read from 'file' within the time (in microseconds) indicated by 'timeout', WaitForChar() returns -1 (TRUE). If a character is available, you can use @{"Read()" LINK "Read" 0} to read it. Note that WaitForChar() is only valid when the I/O stream is connected to a virtual terminal device. If a character is not available within 'timeout', a 0 (FALSE) is returned.
@{lindent 4}
@{fg shine}@{b}BUGS@{ub}@{fg text}@{lindent 8}
Due to a bug in the timer.device in V1.2/V1.3, specifying a timeout of zero for WaitForChar() can cause the unreliable timer & floppy disk operation.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
file - BCPL pointer to a file handle
timeout - integer
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
status - boolean
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Read()" LINK "Read" 0}, @{"FGetC()" LINK "FGetC" 0}
@ENDNODE

@NODE "WaitPkt" "dos.library/WaitPkt()"
@{jcenter}
@{u}@{b}WaitPkt()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
WaitPkt - Waits for a packet to arrive at your pr_MsgPort  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
packet = WaitPkt()
D0

struct @{"DosPacket" LINK "include:dos/dosextens.h/MAIN" 107} *WaitPkt(void);
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Waits for a packet to arrive at your pr_MsgPort. If anyone has installed a packet wait function in pr_PktWait, it will be called. The message will be automatically @{"GetMsg()" LINK "exec.guide/GetMsg" 0}ed so that it is no longer on the port. It assumes the message is a dos packet. It is NOT guaranteed to clear the signal for the port.
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
packet - the packet that arrived at the port (from ln_Name of message).
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"SendPkt()" LINK "SendPkt" 0}, @{"DoPkt()" LINK "DoPkt" 0}, @{"AbortPkt()" LINK "AbortPkt" 0}
@ENDNODE

@NODE "Write" "dos.library/Write()"
@{jcenter}
@{u}@{b}Write()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
Write - Write bytes of data to a file
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
returnedLength =  Write( file, buffer, length )
D0                        D1     D2      D3

LONG Write (BPTR, void *, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
Write() writes bytes of data to the opened file 'file'. 'length' indicates the length of data to be transferred; 'buffer' is a pointer to the buffer. The value returned is the length of information actually written. So, when 'length' is greater than zero, the value of 'length' is the number of characters written. Errors are indicated by a value of -1.

Note: this is an unbuffered routine (the request is passed directly to the filesystem.) Buffered I/O is more efficient for small reads and writes; see @{"FPutC()" LINK "FPutC" 0}.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
file - BCPL pointer to a file handle
buffer - pointer to the buffer
length - integer
@{lindent 4}
@{fg shine}@{b}RESULTS@{ub}@{fg text}@{lindent 8}
returnedLength - integer
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"Read()" LINK "Read" 0}, @{"Seek()" LINK "Seek" 0}, @{"Open()" LINK "Open" 0}, @{"Close()" LINK "Close" 0}, @{"FPutC" LINK "FPutC" 0}
@ENDNODE

@NODE "WriteChars" "dos.library/WriteChars()"
@{jcenter}
@{u}@{b}WriteChars()@{uu}@{ub}
@{jleft}@{lindent 4}
@{fg shine}@{b}NAME@{ub}@{fg text}@{lindent 8}
WriteChars - Writes bytes to the the default output (buffered)  @{fg shine}(V36)@{fg text}
@{lindent 4}
@{fg shine}@{b}SYNOPSIS@{ub}@{fg text}@{lindent 8}
count = WriteChars(buf, buflen)
D0                 D1     D2

LONG WriteChars(STRPTR, LONG)
@{lindent 4}
@{fg shine}@{b}FUNCTION@{ub}@{fg text}@{lindent 8}
This routine writes a number of bytes to the default output. The length is returned. This routine is buffered.
@{lindent 4}
@{fg shine}@{b}INPUTS@{ub}@{fg text}@{lindent 8}
buf    - buffer of characters to write
buflen - number of characters to write
@{lindent 4}
@{fg shine}@{b}RESULT@{ub}@{fg text}@{lindent 8}
count - Number of bytes written.  -1 (EOF) indicates an error
@{lindent 4}
@{fg shine}@{b}SEE ALSO@{ub}@{fg text}@{lindent 8}
@{"FPuts()" LINK "FPuts" 0}, @{"FPutC()" LINK "FPutC" 0}, @{"FWrite()" LINK "FWrite" 0}, @{"PutStr()" LINK "PutStr" 0}
@ENDNODE
