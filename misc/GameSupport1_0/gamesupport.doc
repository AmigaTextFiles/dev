TABLE OF CONTENTS

gamesupport.library/--background--
gamesupport.library/GS_AllocateColors
gamesupport.library/GS_AllocateJoystick
gamesupport.library/GS_DateWidth
gamesupport.library/GS_DrawDate
gamesupport.library/GS_DrawString
gamesupport.library/GS_FormatDate
gamesupport.library/GS_FormatString
gamesupport.library/GS_FreeColors
gamesupport.library/GS_FreeJoystick
gamesupport.library/GS_FreeSprites
gamesupport.library/GS_HappyBlanker
gamesupport.library/GS_InsertScore
gamesupport.library/GS_LoadSprites
gamesupport.library/GS_MemoryAlloc
gamesupport.library/GS_MemoryFree
gamesupport.library/GS_MemoryRealloc
gamesupport.library/GS_NoHappyBlanker
gamesupport.library/GS_ObtainScoreHandle
gamesupport.library/GS_ObtainScores
gamesupport.library/GS_ReleaseScoreHandle
gamesupport.library/GS_ReleaseScores
gamesupport.library/GS_SendJoystick
gamesupport.library/GS_StringWidth
gamesupport.library/GS_TransformUsername
gamesupport.library/GS_WindowSleep
gamesupport.library/GS_WindowWakeup
gamesupport.library/--background--         gamesupport.library/--background--

	gamesupport.library offsers various functions for
	system-compliant, AUISG conforming games.

	Some things should be noted:
	a) don't access gamesupport.library-maintained files (such
	   as high score tables) yourself. gamesupport.library uses
	   various locking techniques to ensure proper operation
	   with respect to multitasking and networked filesystems.

	b) gamesupport.library uses various assigns to let the user
	   override the default location for files. However,
	   strange (although not fatal with respect to overall system
	   operation) things might happen if you change these
	   assigns "in the middle of a game". The intended usage
	   is to setup any required assigns at boottime.

	c) currently AmigaOS V39 (Release 3.0) or newer is required

	d) there is no gamesupport memhandler. This is because you
	   cannot call FreePooled() on a shared memory pool (as used
	   by gamesupport.library) inside a memhandler. One of the
	   many AmigaOS design problems.

	e) gamesupport library ignores the starvation problem.

gamesupport.library/GS_AllocateColors   gamesupport.library/GS_AllocateColors

   NAME
	GS_AllocateColors -- allocate colors in a screen.

   SYNOPSIS
	Success = GS_AllocateColors(Screen, Colors, Distinct)
	  d0                          a0       a1       d0

	ULONG GS_AllocateColors(struct Screen *,struct GS_ColorDef *,ULONG);

   FUNCTION
	Allocate the shared pens required for your program. You pass in
	a table of RGB values, and you get a table of pens to use.
	GS_AllocateColors() attempts to optimize the color search; so the
	result is different from that of a normal for-loop.
	We must call GS_FreeColors() when we're done with the pens.

   INPUTS
	Screen     - the screen we want to open on
	Colors     - the Red, Green and Blue fields must be set by you; they
	             will remain unchanged.
	Distinct   - how many distinct colors to get at most. Pass 0 for
	             no limit.

   RESULT
	Success - TRUE if everything went okay. Colors->DistinctColors
	          will be filled in for you.
	          If FALSE, you can check IoErr(): it returns 0 if we were
	          unable to allocate some or all pens.

    NOTE
	The algorithm has been taken from Xmris 4.02.

   SEE ALSO
	graphics.library/ObtainBestPen(), GameSupport.h, GS_FreeColors()

gamesupport.library/GS_AllocateJoystickamesupport.library/GS_AllocateJoystick

   NAME
	GS_AllocateJoystick -- allocate the joystick

   SYNOPSIS
	success = GS_AllocateJoystick(ReplyPort,ControllerType)
	   d0                            a0           d0

	ULONG GS_AllocateJoystick(struct MsgPort *, UBYTE);

   FUNCTION
	Allocate gameport 1 by assigning it the specified controller
	type.
	If you allocate GPCT_ABSJOYSTICK, the trigger will be set
	to report all joystick events and no timeouts.
	You can use GameSupportBase->Joystick.Request and
	GameSupportBase->Joystick.Event to access the controller.

   INPUTS
	ReplyPort      - the port to use for the device I/O
	ControllerType - the controller type (see <devices/gameport.h>)

   RESULT
	success - TRUE if you got the joystick. FALSE if someone else
	    still owns it. You might want to try again later.

   SEE ALSO
	GS_FreeJoystick(), GS_SendJoystick(), <devices/gameport.h>

gamesupport.library/GS_DateWidth             gamesupport.library/GS_DateWidth

    NAME
	GS_DateWidth -- measure pixel width of a date

    SYNOPSIS
	Width = GS_DateWidth(Template, TimeStamp, RastPort, Locale)
	 d0                    a0          d0        a1       a2

	WORD GS_DateWidth(const char *, ULONG, struct RastPort *,
	                  const struct Locale *);

    FUNCTION
	Measure the pixel width of a date.

    INPUTS
	Template     - the formatting template for FormatDate()
	TimeStamp    - the time/date
	RastPort     - the destination rastport
	Locale       - the locale to use

    NOTE
	If Locale==NULL or locale.library could not be opened,
	a builtin formatter will be used to format the date.
	The following commands are supported by this formatter:
	%a %A %b %B %c %C %d %D %e %h %H %I %m %M %n %p %q %Q
	%r %R %S %t %T %w %x %X %y %Y

gamesupport.library/GS_DrawDate               gamesupport.library/GS_DrawDate

    NAME
	GS_DrawDate -- draw a date into a rastport

    SYNOPSIS
	GS_DrawString(Template, TimeStamp, RastPort, Locale)
	                a0          d0        a1       a2

	void GS_DrawDate(const char *, ULONG, struct RastPort *,
	                 const struct Locale *);

    FUNCTION
	Draw a date into a rastport.

    INPUTS
	Template     - the formatting template for FormatDate()
	TimeStamp    - the time/date
	RastPort     - the destination rastport
	Locale       - the locale to use

    NOTE
	If Locale==NULL or locale.library could not be opened,
	a builtin formatter will be used to format the date.
	The following commands are supported by this formatter:
	%a %A %b %B %c %C %d %D %e %h %H %I %m %M %n %p %q %Q
	%r %R %S %t %T %w %x %X %y %Y

gamesupport.library/GS_DrawString           gamesupport.library/GS_DrawString

    NAME
	GS_DrawString -- draw a string into a rastport

    SYNOPSIS
	GS_DrawString(Template, Parameters, RastPort, Locale)
	                a0          a1        a2        a3

	void GS_DrawString(const char *, const void *, struct RastPort *,
	                   const struct Locale *);

    FUNCTION
	Draw a string into a rastport, using a formatting template.

    INPUTS
	Template     - the formatting template for FormatString()
	Parameters   - the parameter list
	RastPort     - the destination rastport
	Locale       - the locale to use

    NOTE
	If Locale==NULL or locale.library could not be opened,
	RawDoFmt() will be used to format the string.

gamesupport.library/GS_FormatDate           gamesupport.library/GS_FormatDate

    NAME
	GS_FormatDate -- FormatDate() with unlimited string size

    SYNOPSIS
	String = GS_FormatDate(Template, TimeStamp, Length, Locale)
	  d0                      a0         d0       a1      a2

	char *GS_FormatDate(const char *, ULONG, ULONG *,
	                    const struct Locale *);

    FUNCTION
	This function prints a date/time to a string.

    INPUTS
	Locale    - A pointer to a locale
	Template  - A format string for FormatDate()
	TimeStamp - The date/time to output

    NOTE
	If Locale==NULL or locale.library could not be opened,
	a builtin formatter will be used to format the date.
	The following commands are supported by this formatter:
	%a %A %b %B %c %C %d %D %e %h %H %I %m %M %n %p %q %Q
	%r %R %S %t %T %w %x %X %y %Y

    RESULT
	String - the resulting string, or NULL if not enough memory.
	         Call GS_MemoryFree() to free the string.

gamesupport.library/GS_FormatString       gamesupport.library/GS_FormatString

    NAME
	GS_FormatString -- sprintf() with unlimited string size

    SYNOPSIS
	String = GS_FormatString(FormatString, Parameters, Length, Locale)
	  d0                         a0            a1        a2      a3

	char *GS_FormatString(const char *, const void *, ULONG *,
	                      const struct Locale *);

    FUNCTION
	This function works like sprintf(), but it creates it's own
	string. Therefore the length of the resulting string is not
	limited.

    INPUTS
	FormatString - A format string for FormatString()
	Parameters   - The parameter list
	Length       - Optional pointer to an ULONG receiving strlen()
	Locale       - A pointer to a locale

    NOTE
	If Locale==NULL or locale.library could not be opened,
	RawDoFmt() will be used to format the string.

    RESULT
	String - the resulting string, or NULL if not enough memory.
	         Call GS_MemoryFree() to free the string.

gamesupport.library/GS_FreeColors           gamesupport.library/GS_FreeColors

   NAME
	GS_FreeColors -- free pens after we've used them.

   SYNOPSIS
	GS_FreeColors(Screen, Colors)
	                a0      a1

	void GS_FreeColors(struct Screen *, struct GS_ColorDef *);

   FUNCTION
	Free the pens allocated by GS_AllocateColors(). Make sure there's
	no visible graphics with those pens still on the screen; the
	usual thing is to close the window, then call GS_FreeColors(),
	then unlock the screen.
	You can call GS_FreeColors() as often as you want. You must not
	call GS_FreeColors() on an array that had no GS_AllocateColors()
	called on it.

   INPUTS
	Screen     - the screen. Must be the same screen as used for
	             GS_AllocateColors(), of course.
	Colors     - the structure filled in by GS_AllocateColors()

   SEE ALSO
	GS_AllocateColors(), graphics.library/ReleasePen()

gamesupport.library/GS_FreeJoystick       gamesupport.library/GS_FreeJoystick

   NAME
	GS_FreeJoystick -- free the joystick

   SYNOPSIS
	GS_FreeJoystick()

	void GS_FreeJoystick(void);

   FUNCTION
	Free the joystick you have allocated with GS_AllocateJoystick().
	This makes the joystick available for other programs to use.

   NOTE
	You should only hold the joystick while your window is
	active. Remember, this is a non shareable resource!
	So, it seems reasonable to to adopt the idea of a window
	having the focus to the joystick as well: as long as a
	window has the focus, input is directed to that window.

    NOTE
	The joystick is allocated on a per-task basis. The same task
	that successfully called GS_AllocateJoystick must call
	GS_FreeJoystick().

    NOTE
	You may call this function even if you don't own the
	joystick. In this case, nothing happens.

    SEE ALSO
	GS_AllocateJoystick()

gamesupport.library/GS_FreeSprites         gamesupport.library/GS_FreeSprites

   NAME
	GS_FreeSprites -- free sprites loaded with GS_LoadSprites

   SYNOPSIS
	GS_FreeSprites(Sprites, Screen);
	                  a0      a1

	void GS_FreeSprites(struct GS_Sprites *, struct Screen *);

   FUNCTION
	Free the sprites. Call this when you're done with them.
	The recommended usage is to close the window first, to make
	sure that the colors are no longer visible.

   INPUTS
	Sprites - the sprites returned from GS_LoadSprites(). NULL
	          is valid.
	Screen  - the screen that we used to allocate the sprites

   RESULT
	More free memory. More free colors (possibly).

gamesupport.library/GS_HappyBlanker       gamesupport.library/GS_HappyBlanker

    NAME
	GS_HappyBlanker -- keep a screenblanker happy

    SYNOPSIS
	Success = GS_HappyBlanker()
	   d0

	ULONG GS_HappyBlanker(void);

    FUNCTION
	Turn the happy blanker on.
	This means that input events will be sent down the input stream
	to make sure that a screenblanker doesn't suddenly blank the
	screen.
	Turn this on while playing. Turn it off in pause or demo mode.

    RESULT

    SEE ALSO
	GS_NoHappyBlanker()

gamesupport.library/GS_InsertScore         gamesupport.library/GS_InsertScore

   NAME
	GS_InsertScore -- insert a score into the score tables

   SYNOPSIS
	Error = GS_InsertScore(ScoreHandle, Score)
	 d0                        a0         a1

	LONG GS_InsertScore(void *, struct GS_Score *);

   FUNCTION
	Check if we want to insert the new score. If yes, insert
	it. Basically, you are expected to call this function
	whenever a game is finished --- we determine ourselves
	whether we actually want to insert the score.

   INPUTS
	ScoreHandle  - a handle describing the files
	Score        - the new score to insert

   RESULT
	Error - error code (0 for success)
	        In any case, the Score->Name and Score->TimeStamp
	        will be set.

gamesupport.library/GS_LoadSprites         gamesupport.library/GS_LoadSprites

   NAME
	GS_LoadSprites -- load the sprites

   SYNOPSIS
	Sprites = GS_LoadSprites(Gamename,Screen)
	   d0                       a0      a1

	GS_Sprites *GS_LoadSprites(const char *, struct Screen *);

   FUNCTION
	Read a sprite file and return a set of bitmaps.

   INPUTS
	Gamename     - the name of the game. GS_LoadSprites() will append
	               ".sprites" to get the filename
	Screen       - the screen that we want to open on.

   RESULT
	Sprites - a pointer to a (read-only) structure containing
	          the colormap and the image/mask bitmaps.
	          If NULL, IoErr() will return more information.
	          If IoErr()>0, then it is a dos error. <0 means IFF error.

   NOTE
	A normal sprite is returned as a friend-bitmap.
	The mask is a friend-bitmap, too!

   NOTE
	A sprite with no CMAP and depth 1 is not remapped. Instead,
	only a BMF_STANDARD image is returned, so you can pass
	this to BltTemplate().

	Sprites are not shared (because there is no IsFriendBitmap()
	function).

	Sigh. I wish Commodore (or whoever owns the Amiga these days)
	would finally redesign all these broken gfx calls.
	graphics.library is not really something that you could
	show around without being ashamed. :(

gamesupport.library/GS_MemoryAlloc         gamesupport.library/GS_MemoryAlloc

   NAME
	GS_MemoryAlloc -- allocate a block of memory

   SYNOPSIS
	Memory = GS_MemoryAlloc(Size)
	  d0                     d0

	void *GS_MemoryAlloc(ULONG);

   FUNCTION
	Allocate a block of memory. You must call GS_MemoryFree() when
	you don't need the memory any longer.

   INPUTS
	Size - the size of the memory block. 0 will return NULL and
	    ERROR_BAD_NUMBER.

   RESULT
	Memory - a pointer to the allocated memory, or NULL.
	   In case of NULL, IoErr() will be set.

   NOTE
	This is different from malloc(). You are responsible for freeing
	the block!

   SEE ALSO
	GS_MemoryFree()

gamesupport.library/GS_MemoryFree           gamesupport.library/GS_MemoryFree

   NAME
	GS_MemoryFree -- free a memory block.

   SYNOPSIS
	GS_MemoryFree(Memory)
	                a0

	void GS_MemoryFree(void *);

   FUNCTION
	The memory block is returned to the pool.

   INPUTS
	Memory - the memory block. Must have been allocated by
	    MemoryAlloc(). NULL is valid.

   SEE ALSO
	GS_MemoryAlloc()

gamesupport.library/GS_MemoryRealloc     gamesupport.library/GS_MemoryRealloc

   NAME
	GS_MemoryRealloc -- reallocate a block of memory

   SYNOPSIS
	NewMemory = GS_MemoryRealloc(OldMemory,NewSize)
	   d0                           a0        d0

	void *GS_MemoryRealloc(void *, ULONG);

   FUNCTION
	Reallocates a block of memory. This function will free the
	block passed in, allocate a new one and copy the old contents
	to the new block. If the new block is smaller, it copies as
	much as will fit (the rest is lost). If the new block is larger,
	the additional bytes are not initialized. If the new block has
	the same size, why did you call GS_MemoryRealloc()??

   INPUTS
	OldMemory - the old memory block. Must have been allocated by
	    GS_MemoryMalloc() or GS_MemoryRealloc(). NULL is valid:
	    GS_MemoryRealloc(NULL,Size) is equivalent to
	    GS_MemoryMalloc(Size).
	NewSize   - the size of the new block. 0 is valid here; it will
	    return NULL and ERROR_BAD_NUMBER.

   RESULT
	NewMemory - the new memory block. In case of NULL, the old
	    pointer is still valid and must still be freed; in case
	    of non-NULL, you must not use the old pointer anymore.

   SEE ALSO
	GS_MemoryAlloc(), GS_MemoryFree(), realloc()

gamesupport.library/GS_NoHappyBlanker   gamesupport.library/GS_NoHappyBlanker

   NAME
	GS_NoHappyBlanker -- turn the happy blanker off

   SYNOPSIS
	GS_NoHappyBlanker()

	void GS_NoHappyBlanker(void);

   FUNCTION
	Turn off the happy blanker.

   NOTE
	Only call this if GS_HappyBlanker() returned success.

   SEE ALSO
	GS_HappyBlanker()

gamesupport.library/GS_ObtainScoreHandleesupport.library/GS_ObtainScoreHandle

   NAME
	GS_ObtainScoreHandle -- obtain a handle to access score files

   SYNOPSIS
	ScoreHandle = GS_ObtainScoreHandle(ScoreDef, SubPath, UserName)
	     d0                              a0        a1        a2

	void *GS_ObtainScoreHandle(const struct GS_ScoreDef *, const char *,
	                           const char *);

   FUNCTION
	Get a handle for later access to the score files

   INPUTS
	ScoreDef    - an initialized GS_ScoreDef structure.
	SubPath     - an optional path, which can be used if the
	              game keeps several score files.
	UserName    - the user name. NULL or "" specifies the
	              generic ("unknown") user.

   RESULT
	ScoreHandle - a handle to use with the other score functions.
	              NULL for failure.

   NOTE
	UserName and ScoreDef must remain valid and unchanged for the
	lifespan of the handle.

   NOTE
	The current search path is
	    GAMESTUFF:<GameName> scores/<SubPath/>
	    <GameName>:<GameName> scores/<SubPath/>
	    PROGDIR:<GameName> scores/<SubPath/>

gamesupport.library/GS_ObtainScores       gamesupport.library/GS_ObtainScores

    NAME
	GS_ObtainScores -- obtain a score table

    SYNOPSIS
	Scores = GS_ObtainScores(ScoreHandle,ScoreType)
	  d0                        a0         d0

	const GS_ScoreList *GS_ObtainScores(void *, ULONG);

    FUNCTION
	Return a score table.

    INPUTS
	ScoreHandle  - a handle describing the files
	ScoreType    - the file type that we want to read

    RESULT
	Scores - a (read-only) linked list of scores. NULL for no
	         scores.

    NOTE
	This function cannot fail: if we can't read the new scores,
	the old scores are returned instead. This is because the
	only thing we can do with the scores is to display them,
	and it's better to display old scores instead of no scores
	at all.

    SEE ALSO
	GS_ObtainScoreHandle(), GS_ReleaseScores()

gamesupport.library/GS_ReleaseScoreHandleupport.library/GS_ReleaseScoreHandle

   NAME
	GS_ReleaseScoreHandle -- release a score handle

   SYNOPSIS
	GS_ReleaseScoreHandle(ScoreHandle)
	                           a0

	void GS_ReleaseScoreHandle(void *);

   FUNCTION
	Release a handle obtained from GS_ObtainScoreHandle().

   INPUTS
	ScoreHandle - the score handle to release, or NULL

gamesupport.library/GS_ReleaseScores     gamesupport.library/GS_ReleaseScores

    NAME
	GS_ReleaseScores -- release a score table

    SYNOPSIS
	GS_ReleaseScores(ScoreHandle, Scores)
	                   a0           a1

gamesupport.library/GS_SendJoystick       gamesupport.library/GS_SendJoystick

    NAME
	GS_SendJoystick -- send joystick request

    SYNOPSIS
	GS_SendJoystick()

	void GS_SendJoystick(void);

    FUNCTION
	Initialize the GameSupportBase->Joystick.Request request
	as GPD_READEVENT and send it to the gameport device.
	Basically, joystick handling works like this:

	GS_AllocateJoystick()
	GS_SendJoystick()
	while (..)
	  {
	    Wait until GameSupportBase->Joystick.Request arrives at
	      your ReplyPort
	    Process GameSupportBase->Joystick.Event
	    GS_SendJoystick()
	  }
	AbortIO()
	GS_FreeJoystick()

gamesupport.library/GS_StringWidth         gamesupport.library/GS_StringWidth

    NAME
	GS_StringWidth -- measure pixel width of a string

    SYNOPSIS
	Width = GS_StringWidth(Template, Parameters, RastPort, Locale)
	 d0                      a0          a1        a2        a3

	WORD GS_StringWidth(const char *, const void *, struct RastPort *,
	                    const struct Locale *);

    FUNCTION
	Measure the width of the resulting string.

    INPUTS
	Template     - the formatting template for FormatString()
	Parameters   - the parameter list
	RastPort     - the destination rastport
	Locale       - the locale to use

    NOTE
	If Locale==NULL or locale.library could not be opened,
	RawDoFmt() will be used to format the string.

gamesupport.library/GS_TransformUsernameesupport.library/GS_TransformUsername

    NAME
	GS_TransformUsername -- transform username to filename

    SYNOPSIS
	Filename = GS_TransformUsername(Username,OldFilename)
	   d0                              a0         a1

	char *GS_TransformUsername(const char *, char *);

    FUNCTION
	Transform a username into something that most filesystems
	will accept as filename.
	OldFilename is a Filename that was returned from this
	function. If it is non-NULL, OldFilename will be freed
	and a new filename will be returned.

	The intended use for this function is as follows:

	int Success;
	char *Filename;

	Success=FALSE;
	Filename=NULL;
	while (!Success)
	  {
	    Filename=GS_TransformUsername(Username,Filename);
	    if (Filename==NULL)
	      Error();
	    File=OpenFile(Filename);
           if (File does not exist)
	      Success=TRUE;
	    else
	      {
	        FileUsername=ReadUsernameFromFile();
	        if (FileUsername is equal to Username)
	          Success=TRUE;
	      }           
	  }

	Since the returned Filename is not unique, we read the
	Username from the file to check whether we catched the
	correct file. If we didn't, we just try the "next"
	transformation.

    INPUTS
	Username    - the name of the user
	OldFilename - previous Filename, or NULL

    RESULT
	Filename - a string to use as filename. NULL for error.
                  Call GS_MemoryFree(Filename) when done.

gamesupport.library/GS_WindowSleep         gamesupport.library/GS_WindowSleep

    NAME
	GS_WindowSleep -- put window to sleep

    SYNOPSIS
	Success = GS_WindowSleep(Window)
	                          a0

	ULONG GS_WindowSleep(struct Window *);

    FUNCTION
	Put window to sleep.

    INPUTS
	Window - the window.

    RESULT
	Success - TRUE for success (or for a NULL window)

    NOTE
	There are two possible reasons for failure: not enough memory
	available to allocate a requester structure, or the maximum
	number of requesters in the window would be exceeded.

    SEE ALSO
	GS_WindowWakeup()

gamesupport.library/GS_WindowWakeup       gamesupport.library/GS_WindowWakeup

    NAME
	GS_WindowWakeup -- wakeup window

    SYNOPSIS
	GS_WindowWakeup(Window)
	                  a0

	void GS_WindowWakeup(struct Window *);

    FUNCTION
	Undo the effects of GS_WindowSleep().

    INPUTS
	Window - the window

    NOTE
	This function removes the Window->FristRequester requester
	and GS_MemoryFree()s it. So you better make sure it's not
	another requester...

