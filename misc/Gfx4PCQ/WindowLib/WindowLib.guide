@DATABASE "WindowLib"
@$VER: WindowLib.guide 1.00 (12 July 1997)
@(C) THOR Software
@SMARTWRAP
@AUTHOR Thomas Richter
@NODE MAIN "WindowLib Guide"
                        WindowLib Guide

Guide Version 1.00                      WindowLib Version 2.00



Table of Contents


I.      @{"The Licence" link Licence}

                Read This First!


II.     @{"What is it: Overview" link Overview}

                What it does...


III.    @{"Installation" link Installation}


IV.     @{"Usage of the GFX4PCQ package" link Usage}



V.      Function reference

        @{"Screen related functions" link Screens}

        @{"Window related functions" link Windows}

        @{"Drawing functions" link Rastport}

        @{"Menu related functions" link Menu}

        @{"Gadget related functions" link Gadgets}

        @{"Event handling" link IDCMP}

        @{"Console related functions" link Console}

        @{"Copper related functions" link Copper}

        @{"Animation support" link AnimTools}

        @{"Joystick support" link Joystick}



VI.     @{"History and Future" link History}

VII.    @{"Credits" link Credits}

        Thank you, folks!




        © THOR-Software

        Thomas Richter

        Rühmkorffstraße 10A



        12209 Berlin


        Germany



EMail:  thor@einstein.math.tu-berlin.de

WWW:    http://www.math.tu-berlin.de/~thor/thor/index.html


GFX4PCQ (the "WindowLib") is FREEWARE and copyrighted © 1993-1997
by Thomas Richter. No commercial use without perimission of the author. Read
the @{"licence" link Licence}!


@ENDNODE
@NODE Licence "The THOR-Software Licence"
                        The THOR-Software Licence


This License applies to the computer programs known as "GFX4PCQ" and
all programs, source codes and data in this package. The "Program", below,
refers to such program or data set.


The programs and files in this distribution are freely distributable
under the restrictions stated below, but are also Copyright (c)
Thomas Richter.


Distribution of the Program by a commercial organization without written
permission from the author to any third party is prohibited if any payment
is made in connection with such distribution, whether directly
(as in payment for a copy of the Program) or indirectly (as in payment
for some service related to the Program, or payment for some product
or service that includes a copy of the Program "without charge";
these are only examples, and not an exhaustive enumeration of prohibited
activities). However, the following methods of distribution involving
payment shall not in and of themselves be a violation of this restriction:


(i) Posting the Program on a public access information storage and
retrieval service for which a fee is received for retrieving information
(such as an on-line service), provided that the fee is not
content-dependent (i.e., the fee would be the same for retrieving the same
volume of information consisting of random data).



(ii) Distributing the Program on a CD-ROM, provided that the files
containing the Program are reproduced entirely and verbatim on such
CD-ROM, and provided further that all information on such CD-ROM be
redistributable for non-commercial purposes without charge.



Everything in this distribution must be kept together, in original
and unmodified form.




Limitations.

THE PROGRAM IS PROVIDED TO YOU "AS IS," WITHOUT WARRANTY. THERE IS NO
WARRANTY FOR THE PROGRAM, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. THE ENTIRE
RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD
THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
SERVICING, REPAIR OR CORRECTION.



IF YOU DO NOT ACCEPT THIS LICENCE, YOU MUST DELETE ALL FILES CONTAINED IN
THIS ARCHIVE.

@ENDNODE
@NODE Overview "Overview over GFX4PCQ"
GFX4PCQ is a graphics support package for the PCQ Pascal compiler for the
amiga. Its main purpose is to serve as an easy to use interface between
your pascal C source and the graphics functions of the amiga operating
system, designed mainly to be used by the Pascal beginner.


I wrote the first version of GFX4PCQ when I giving a friend of mine a course
in the Pascal programming language. Since most simple Pascal programs
usually presented for teaching purposes are rather boring (calculate the
area of a rectangle, for example) but access to the graphics engine of the
amiga is too difficult for the beginner, I wrote this package as interface
for my friend, being a teacher of arts himself - that's why a set of graphic
functions was the No. 1 choice.


The package consists of this guide - a reference of all functions and, as
main ingredience, a "link library" for the PCQ compiler. This file contains
all the interface functions described in this guide and must be linked to
the object code of your program - don't worry if you don't know what exactly
"linking" or "link library" means, it's not necessary to understand its
usage. This link library is called the "WindowLib" in the following.


I included a lot of examples as well, they may serve as a reference how
certain things are done with the windowlib if you don't like guides like
this one and prefer to see the things in praxis. Most examples draw simple
graphics on the screen, like fractals or other nice objects. Some of them
present the animation engine of the windowlib which is somewhat similar to
the one of the popular AmigaBasic. I included a core of the game "Lander" as
well - feel free to finish this game if you like it. (Would be nice if you
could send me the final result!)

@ENDNODE
@NODE Installation "Installation of GFX4PCQ"

- Unpack this archive to the RAM disk. Since you're reading this guide, this
step should be done already ;-)


- Copy this guide whereever you want to keep it.


- The drawer "LIB" contains a file named "window.o". This is the link
library, or short "WindowLib". Copy this file to the "LIB" drawer of the PCQ
compiler package, the place where the PCQ.lib and other related libraries
are kept. If you installed PCQ correctly, the assign LIB: is pointing to
this directory.


- Copy the contents of the "Examples" directory to where you keep your PCQ
sources. It contains example sources for using the windowlib. All examples
come with the source code, the final executable and a parameter file for the
program "ClickMake", also a product of "THOR - Software" (hence, me ;-). If
you use "ClickMake", these files contain everythink to compile the examples
by a press of a button. If you don't use "ClickMake", you've to compile by
hand or by a standard Makefile or a shell script. More about using the
"WindowLib" is @{"here" link Usage}.


- Copy the contents of the "Include" directory, i.e. the file "windowlib.i"
to the drawer "INCLUDE:Utils" of the PCQ compiler. Quite a lot of similar
files can be found there, as for example "PCQMemory.i" or "Random.i". This
file contains all necessary function definitions for the WindowLib.


The "ClickMake" tool can be found either on my home page, see the
@{"main node" link MAIN} or in the AmiNet.

@ENDNODE
@NODE Usage "How to use the WindowLib"
First, make sure that the windowlib is @{"installed" link Installation} in
your compiler package.


To create a program that uses the windowlib must contain:


- the following include directive near the head of the program:


{$I "INCLUDE:Utils/Windowlib.i"}


This directive will define all functions used by the windowlib, hence will
teach the pascal compiler how to use the library. It's usually unnecessary
to include another graphics related file since most of the stuff is already
present in this file. In special (an as a note to experts), something like


{$I "INCLUDE:Intuition/Intuition.i"}


is NOT necesssary.



- The first command of your main program body should be this command:


InitGraphics;


It is used to initialize the WindowLib and MUST be called before any other
windowlib functions.



- The last command of your main program must be the following:


ExitGraphics;


It is absolutely important that this call is here, it frees all resources
allocated by the WindowLib for you. If you forget to call this one, you
might not only waste memory in the best case, but may find yourself with
useless windows lying around or with the mouse being unuseable, your
computer might also crash in the worst case.


The following rump program summarizes again all points:

@{CODE}
Program Sample; { a dummy program body for GFX4PCQ }

{$I "INCLUDE:Utils/Windowlib.i"}
{ other includes may go here }


{ variable, type and constant definitions go here }


BEGIN
        InitGraphics;           { <- important! }

        { main program goes here. You might use Windowlib calls now. }


        ExitGraphics;           { <- bloody important ! }
END.

@{BODY}


So much for the source code.


To compile your program, you might either:

- compile with ClickMake. This is easiest, but you have to change the
"ClickMake" settings a bit:

        - Click the "Settings" checkmark in the "ClickMake" window.

        The settings window should open now.


        - Select "Make" from the left hand pipeline list.

        - Select "Invoke Linker" from the right hand list.

        - Click into the "Post :" string gadget at the left bottom.

        - Enter there

          "LIB:window.o" and press RETURN.


        - If you want to use a debugger, you may want to change DBug

          pipeline as well:


        - Select "Debug" from the left hand list.

        - Select again "Invoke Linker" from the right list and modify

          the "Post :" gadget as before.


        - Click again on the "Settings" checkmark.


You're now ready to start with your program. Enter the name of your program
as usual and start the editor with "Edit". If you're done, don't forget to
save program and settings with "Save".


If you don't use ClickMake, I can't help you as much as the steps required
to install the WindowLib might be a bit different from environment to
environment.


If you invoke the compiler by hand or use a shell script, everything works
as before except that the link step is a bit different. A line like the
following


Blink <foo> TO <out> LIBRARY PCQ.lib NODEBUG


must be modified to link with the "windowlib" as well:


Blink <foo> LIB:window.o TO <out> LIBRARY PCQ.lib NODEBUG


The only change necessary is that the "LIB:window.o" parameter must be
specified as object source. It does, btw, not matter which linker you use
here. The modification is the same for the SAS linker "SLink", if you use
this one.


If you use the PCQ make utility "PCQ" to create pascal executables, you MUST
use "project files" since "PCQ" itself is not flexible enough to handle
external modules given at the command line - read the "PCQ.doc" file on how
to create such a project file.

The following line must be added to the project file:


External LIB:window.o


If you use the standard unix "Make" utility or the SAS implementation
"SMake", you should be clever enough to make the necessary modifications
yourself, aren't you?


@{B}Additional node:@{UB}


Most windowlib functions abort your program with a runtime error if a
failure condition is detected. These functions do not, for this
reason, return a success/failure indicator - if they return, everything went
well. The error handler of the windowlib tries to close all resources you've
allocated before if a runtime error occures.


@ENDNODE
@NODE Screens "Screen related functions"
Screens are large, usually dragable regions on the monitor. All objects on a
screen share a common set of colors. Screens must contain
@{"windows" link Windows}, you can't draw to them directly. But they serve
as a background on which windows are created and must be created if you want
to draw graphics on them. A typical screen is the workbench screen you get
when you boot your computer with the only exception that you can't change
its colors, at least not from within the windowlib.


@{B}Types used in this section:@{UB}

ScreenPtr       :       A handle to a "screen" you get from
OpenAScreen() and you dispose with CloseAScreen(). Do not care what this
type is, just use it as a handle to the openend screen.


@{B}Functions:@{UB}


@{B}
FUNCTION OpenAScreen(left,top,wdth,hght,dpth,flgs : Integer; tit : String) : ScreenPtr;
@{UB}


Opens a new screen. The "left,top,wdth" and "hght" parameters refer to the
position and dimension of the screen in pixels. "dpth" is the depth of the
screen in bitmaps and selects the number of colors available on this screen.
The available colors are given by 2^depth, i.e. each additional depth
doubles the number of colors, but also the amount of memory needed to hold
the screen. The depth value is usually limited by the chip set installed in
your computer and depending on the type of the screen you want to open.
LORES screens are limited to 5 or 8 "planes", i.e. a depth of 5 or 8. HIRES
screens to 4 or 8 as well.


"flgs" is a flags value to define the screen type. Useful values are
"MON_HIRES" for a 640x200 or "MON_LORES" for a 320x200 screen.


More than one flags value at once is possible - simply "or" the flags
together: "MON_HIRES or MON_LACE" gives an interlaced hires screen of a
resolution of 640x400 pixel for NTSC systems.


"tit" is a title string.


If you specify a screen that is too large to fit in the monitor, your screen
gets "autoscrolled", i.e. only a part of it is visible at a time and you may
scroll the screen with the mouse pointer hitting the boundaries.


@{B}Result:@{UB}

A handle to the new screen or NIL on failure. IT IS REALLY IMPORTANT that
your program handles the failure case, YOU HAVE TO CHECK IF IT'S NIL!



@{B}Notes:@{UB}

-More flags values are available, see the file "INCLUDE:Utils/windowlib.i".

-A PAL screen has a vertical resolution of 256 or 512 pixel instead of 200
or 400. You may also specify MON_PAL or MON_NTSC explicitly to get PAL or
NTSC screens, provided the monitor drivers for PAL and NTSC have been
loaded, see the system manual for more informations.



@{B}
PROCEDURE CloseAScreen(s : ScreenPtr);
@{UB}


Closes a screen opened with OpenAScreen() before. It's a matter of good
style to close all windows of this screen before you close the screen
itself! To NOT touch the window pointers or the screen pointer after you've
closed the screen with this call.



@{B}
PROCEDURE SetColor(s : ScreenPtr;reg,r,g,b : Short);
@{UB}


Selects the color for one of the pens of the screen. "s" is the screen
pointer you got from OpenAScreen(), "reg" is the pen number and may range
from 0 to 2^depth-1. "r,g,b" are the red, green and blue components of the
color to be set into the color register. They range from 0 (minimum) to 15
(maximum).


@{B}
PROCEDURE GetColor(s : ScreenPtr;reg : SHORT;VAR r,g,b : SHORT);
@{UB}


Returns the color of a pen of this screen. "s" is the screen handle you got
from OpenAScreen, "reg" is the pen number. "r,g,b" are set to the red, green
and blue component of the pen register and range from 0 to 15, as before.

@ENDNODE
@NODE Windows "Window related functions"
Windos are very common for the amiga. They act as "container" for graphics,
i.e. drawing operations are always relative to a window. A window is
therefore like a sheet of paper you draw on. @{"Menus" link Menu} and
@{"gadgets" link Gadgets} can be attached to windows, as well as
@{"sprites" link AnimTools}. Windows need a @{"screen" link Screens} to
appear on, usually the workbench screen.


@{B}Types used in this section:@{UB}


ScreenPtr       :       A handle to a "screen" you got from
@{"OpenAScreen()" link Screens}.


WindowPtr       :       A handle to a "window" as result from OpenAWindow()
or OpenScreenWindow(), disposed by CloseAWindow(). Do not make any
asumptions about what this pointer is, use it as a handle.


@{B}Functions:@{UB}


@{B}
FUNCTION OpenScreenWindow(s : ScreenPtr;left,top,wdth,hght,flgs: INTEGER; tit : String) : WindowPtr;
@{UB}


Create a new window on a given screen "s", or on the workbench screen if "s"
is NIL. "left","top","wdth" and "hght" define the position and the
dimensions of the window to create, "flgs" is a flag type parameter
discussed below. "tit" is a string and selects the title of the window.


Some useful flags:

If you want more than one, or them together, like in "WINFLG_SIZEGADGET or
WINFLG_DRAGBAR".


WINFLG_SIZEGADGET       :       Include a sizing gadget. Sizeable windows
shouldn't be used with the windowlib because it's not well prepared to
handle them.



WINFLG_DRAGBAR          :       Make the window dragable. Should be
selected.

WINFLG_DEPTHGADGET      :       Add a depth-arrangement gadget. Should be
selected as well.

WINFLG_CLOSEGADGET      :       Add a close gadget to your window. Please
note that the window will not close automatically if the user selects this
gadget, it's up to you to watch this gadget with the
@{"event" link IDCMP} mechanism.


WINFLG_SIZEBRIGHT       :       The room for the size gadget is taken from
the right border.

WINFLG_SIZEBBOTTOM      :       The sizing gadget uses the bottom border.


The next flags define the refresh mode of the window, i.e. what happens if
parts of the window get destroyed because other windows overlay your window.
The usual mechanism is that the windowlib (or better, the layers subsystem
of the operating system) refreshes the lost window data for you, so there's
no need to handle refresh at all. But if you want, you may handle this
refresh on your own and redraw the window contents manually, see the
@{"event" link IDCMP} chapter. This might be useful to save memory.


WINFLG_SMART_REFRESH    :       The default. Windowlib makes the refresh for
you. You don't need to specify this flag, windowlib will select it for you.

WINFLG_SIMPLE_REFRESH   :       Make the refresh yourself.


WINFLG_BACKDROP         :       Place the window behind all other windows
and behind the dragbar of the screen.


WINFLG_BORDERLESS       :       For windows without borders. To make this
working, don't add a sizing gadget, nor a depth arangement gadget. Set the
window title to NIL.


WINFLG_ACTIVATE         :       Activate the window when it opens, so user
input will be redirected to your window.


@{B}Result:@{UB}

A handle to the new window or NIL if the function failed. IT IS IMPORTANT
that you check the result code OR YOUR PROGRAM WILL CRASH!



@{B}
FUNCTION OpenAWindow(left,top,wdth,hght,flgs: INTEGER; tit : String) : WindowPtr;
@{UB}


Like OpenScreenWindow() except that it opens windows always on the
workbench. This is an old and obsolete version of the window open function
and does exactly the same as OpenScreenWindow with the "s" parameter set to
NIL.


@{B}Result:@{UB}

A handle to the new window or NIL on failure. CHECK THE RETURN CODE!



@{B}
PROCEDURE CloseAWindow(w : WindowPtr);
@{UB}


Close a window, given a handle. Make sure that you don't use the handle
anymore afterwards!

@ENDNODE
@NODE RastPort "Drawing related functions" The next set of functions is used
to create graphics in windows opened by the windowlib. Most functions take a
window handle as input to specify the window they should draw to.


@{B}Types used in this section@{UB}


WindowPtr       :       A handle to a window, a result of
@{"OpenAWindow()" link Windows} or OpenScreenWindow(). All functions need
this handle to specify the window they should draw in.


@{B}Functions:@{UB}


@{B}
PROCEDURE Color(w : WindowPtr; c : Byte);
@{UB}


Selects pen number for the foreground color. This is the primary color for
lines and text. "w" is the window handle, "c" is the pen number to be
selected.



@{B}
PROCEDURE BgColor(w : WindowPtr; c : Byte);
@{UB}


Selects the background drawing pen.


@{B}
PROCEDURE OlColor(w : WindowPtr; c: Byte);
@{UB}


Selects the area outline pen. This color is used for the boundary of filled
ellipses and rectangles if boundary drawing is enabled - see the next call.



@{B}
PROCEDURE Boundary(w : WindowPtr; onoff : Boolean);
@{UB}


Enables or disables the boundary drawing around filled ellipses and
rectangles. Set "onoff" to TRUE to enable the boundary, or to FALSE to
disable it again.



@{B}
PROCEDURE DrawMode(w : WindowPtr; mode : Byte);
@{UB}


Selects the drawing mode for the window "w". "mode" can be the following:


mode=0          :       The background pen is not used but is transparent
instead. The container around text is, for example, transparent. This is the
default mode.


mode=1          :       The background pen is used and non-transparent. The
text container will be drawn in background mode.


mode=2          :       The foreground pen is not used, but all pixels
usually drawn with this pen get inverted. The background pen is transparent.


mode=3          :       Similar to mode 2 except that the background pen
inverts as well.


mode=4          :       Like mode 0 except that the meaning of foreground
and background pens are exchanged.


mode=5          :       Like mode 1, but with foreground and background pen
exchanged.


mode=6          :       The background pen inverts pixels, the foreground
pen is ignored.


mode=7          :       Just like mode 5.



@{B}
PROCEDURE SetDrawPattern(w : WindowPtr; pat : Short);
@{UB}


Selects the pattern for drawing lines. The default is $ffff for "pat" which
means a solid line. Another useful value is $aaaa for a dottet or $f0f0 for
short dashes, $ff00 for long dashes. The way how the line is dotted or
dashed is again under control of the drawing mode defined by the call above,
i.e. wether the gaps between dots are drawn with the background pen - odd
drawing modes - or aren't drawn at all for even drawing modes.


@{B}Note:@{UB} Each bit in the "pat" parameter specifies how the
corresponing point of the line should be drawn. The foreground pen is used
if a bit is on - hence $ffff gives a line in the foreground color - or the
background pen otherwise. Remember that the background pen could be
transparent if the drawing mode selected says so.



@{B}
PROCEDURE SetFillPattern(w: WindowPtr; pat : Address ; power : Byte ; depth : Integer);
@{UB}


Select the fill pattern for filled obstacles like rectangles or ellipses.
"pat" is the address of a pattern array in memory, a pointer to an array of
Shorts. "power" encodes the height of the pattern, but in a quite unusual
way. The actual height of the array is given by "2^power", so "power=1" is a
pattern of height two, whereas "power=4" specifies a pattern of height 16,
since 2^4=16. Hence, only pattern heights of 1,2,4,8,16,32,... etc are
allowed. Each bit in this array represents one pixel in the pattern, the
most significant bit representing the leftmost pixel.

"depth" is the depth of the pattern. Only two possibilities are allowed
here: Set either "depth" to one to use a monochrome pattern drawn with the
pen used for filling the object - usually the foreground pen - or set depth
to the depth of the screen the window is located on. Setting "depth" to zero
implies this as well. The windowlib will use in this case a multi-colored
pattern, where the bitmaps of the pattern are encoded in the array as before
but the size of the array has to be "2^depth" times the size for a
monochrome pattern. The first "2^power"=height entries of the array
represent the pixels of the first bitplane of the pattern, the next
"2^power" entries the second bitplane and so on.


BE WARNED! If you pass an illegal value to SetFillPattern(), the windowlib
will abort your program with a runtime error.


To remove the fill pattern, i.e. enable solid filling again, pass NIL as
"pat" and 0 both as "power" and "depth".


@{B}Notes:@{UB}

- This one is definitely tricky and useful for experts only, I know.

- It is not necessary that the array is in chip mem. This is done by the
windowlib for you.



@{B}
PROCEDURE ClearRaster(w : WindowPtr; color : Byte);
@{UB}


Fill the complete window area with the given color.



@{B}
PROCEDURE ClearWindow(w : WindowPtr);
@{UB}


Fill the window area with the background pen.



@{B}
PROCEDURE SetBitMask(w : WindowPtr; mask : Byte);
@{UB}


Sets a mask that specifies the bitmaps for drawing. If the corresponding bit
in the "mask" parameter is not set, the selected bitmap won't be touched by
the drawing operations.


@{B}Notes:@{UB}

Do not use this call if your program should work correctly with graphic
cards! Your mask value could be either ignored completely or will slow down
your program considerably.



@{B}
PROCEDURE Plot(w : WindowPtr; x,y : Short);
@{UB}


Draw a single dot at the position "x,y" in the window, using the foreground
color. This selects also a start position for a line to be drawn, similar to
"Position()" below.



@{B}
PROCEDURE Position(w : WindowPtr; x,y : Short);
@{UB}


Select the start position of a line to be drawn or of a text to be printed.



@{B}
PROCEDURE DrawTo(w : WindowPtr; x,y : Short);
@{UB}


Draw a line from the position selected by "Plot()" or "Position()" to the
location "x,y" in the window, using the foreground pen and the selected draw
pattern. It selects also "x,y" as start position of a following call to
"DrawTo", i.e. the next line will continue at the end position of this line.



@{B}
PROCEDURE Line(w : WindowPtr; x1,y1,x2,y2 : Short);
@{UB}


Draw a line between the locations "x1,y1" and "x2,y2".



@{B}
PROCEDURE Ellipse(w : WindowPtr; xm,ym,x,y : Short);
@{UB}


Draw an ellipse with its center at "xm","ym" and with radii "x" and "y".
Setting "xm" to "ym" may result in a circle for MON_LORES or "MON_HIRES or
MON_LACE" screens, see @{"here" link Screens}, but this depens also on your
monitor. There's currently no function that draws a circle in all
circumstances.



@{B}
FUNCTION Locate(w : WindowPtr; x,y : Short) : Byte;
@{UB}


Return the color of the point at location "x,y" of the window or "-1" if the
point is outside of the window.


@{B}Note:@{UB} If you're using a simple refresh @{"window" link Windows}, a
-1 might be returned as well if you ask for a pixel currently obscured.



@{B}
PROCEDURE Scroll(w : WindowPtr; x1,y1,x2,y2,dx,dy : Short);
@{UB}


Scroll the rectangle "x1,y1" - "x2,y2" by an amount "dx,dy". Positive "dx"
or "dy" values scroll towards the left or top border of the value (urgh!).


@{B}Note:@{UB} Do not use this function for simple refresh
@{"windows" link Windows}.



@{B}
PROCEDURE Fill(w : WindowPtr; x,y : Short);
@{UB}


Flood fill a framed shape, starting at position "x,y".



@{B}
PROCEDURE PBox(w : WindowPtr; x1,y1,x2,y2 : Short);
@{UB}


Draw a filled rectangle. The coordinates "x1,y1" and "x2,y2" specify an
opposide pair of vertices of this rectangle.

The rectangle will be filled with the foreground pen and framed with the
outline pen if the boundary mode is enabled.



@{B}
PROCEDURE Box(w : WindowPtr; x1,y1,x2,y2 : Short);
@{UB}


Draw a frame, i.e. a non-filled rectangle, specified by the coordinates
"x1,y1" to "x2,y2".



The next functions are used to setup or change the coordinate system of the
window. Windowlib sets usually the origin of the coordinate system into the
upper left corder of the window, just below the drag bar of the window. The
"x" coordinate is running leftwards, "y" downwards.


@{B}Note:@{UB} This coordinate system is a bit different from the system
default coordinates, as setup by "intuition". The origin of ordinary
intuition windows is in the top left edge of the window, ON TOP of the
window frame. You are, for these system windows, allowed to draw over the
boundary artwork of the window. This IS NOT TRUE for windowlib windows, all
drawing operations are properly clipped to the interiour boundary of the
window, leaving the window framing untouched.



@{B}
PROCEDURE SetOffset(w : WindowPtr; x,y : Short);
@{UB}


Shift the origin by an amount "x,y" to the right or bottom. Negative values
move it in the opposide direction.



@{B}
PROCEDURE Clip(w : WindowPtr; x1,y1,x2,y2 : Short);
@{UB}


Setup a clipping rectangle all following drawing operations are clipped to.
Drawing outside of this rectangle is forbidden.



@{B}
PROCEDURE InstallStdClip(w : WindowPtr);
@{UB}


Restore the default clipping rectangle.


The next calls are part of the "Area" subsytem of the windowlib. They allow
drawings of filled polygones like hexagons, triangles and the like. They
work like the following:

The shape to be drawn is recorded initially with the following calls. The
calls itself don't draw anything on the screen, they are only used to record
the vertices of the shapes to be drawn. A single call to "CompleteArea" is
then used to do the job and to map the polygones to the screen.



@{B}
PROCEDURE AddAreaMove(w : WindowPtr; x,y : Short);
@{UB}


Select the location of the first vertex of a polygone and finish the last
one.



@{B}
PROCEDURE AddAreaDraw(w : WindowPtr; x,y : Short);
@{UB}


Specify one edge of the polygone running from the last point set by
"AddAreaMove" or "AddAreaDraw" to the coordinates "x,y".



@{B}
PROCEDURE AddAreaEllipse(w : WindowPtr; xm,ym,x,y : Short);
@{UB}


Add a complete ellipse as a very special polygone to list of polygones to be
drawn. The center is at "xm,ym", the radii are given by "x,y".



@{B}
PROCEDURE CompleteArea(w : WindowPtr);
@{UB}


Do the job and draw all shapes defined by the previous calls to
"AddArea...". The shapes are filled with the current foreground pen, filled
with the current area pattern which is solid by default and framed with the
outline pen if the boundary flag is enabled.



@{B}
PROCEDURE SetAreaSize(w : WindowPtr; size : Short);
@{UB}


This call selects the number of coordinates that can be recorded by the
"Area..." calls above. The default selected by windowlib for you is usually
big enough, so this call is usually superfluous.



@{B}
PROCEDURE PEllipse(w : WindowPtr; xm,ym,x,y : Short);
@{UB}


Draw a filled ellipse around "xm,ym" with radii "x,y". It is filled with the
foreground pen, the area pattern and framed with the outline pen if the
boundary flag is set.


@{B}Note:@{UB} DO NOT call this function within a sequence of "Area..."
calls since this call uses the area functions internally and will confuse
the area machinery for this reason.



@{B}
PROCEDURE Dimensions(w : WindowPtr; VAR sizex,sizey : Short);
@{UB}


Returns the size of the inner rectangle of the window "w". This IS different
from the size you specified for @{"OpenAWindow()" link Windows} since the
window frame eats up some room. DO NOT MAKE any asumptions on how big the
window framing artwork is since this may vary from system to system.




@{B}
PROCEDURE DrawText(w : WindowPtr;text : String);
@{UB}


Draw the text specified by the string "text" at the position selected by a
previous call to "Position". Use the foreground pen for the characters
itself and, depending on the drawing mode, the background pen for the
container box. No container is drawn if the mode is even.



@{B}
FUNCTION GetTextLength(w : WindowPtr;text : String) : Short;
@{UB}


Returns the width of a given string in pixels.



The next two calls select the font and the style for the font used for
drawing text. Again, don't make any asumption about which font is used by
default, this may again vary from system to system.



@{B}
PROCEDURE SetStyle(w : WindowPtr;style : Short);
@{UB}


Selects the text style for drawing. The following numbers can be used for
"style":

0       :       Plain text.

1       :       Underlined.

2       :       Bold.

4       :       Italic, i.e. slanted text.


Underlined/bold and italic style can be combined with each other by adding
the numbers, i.e. 1+2=3 gives underlined bold text.



@{B}
FUNCTION SetWindowFont(w : WindowPtr;name : String;size : Short) : Boolean;
@{UB}


Selects the font for drawing. The "name" argument is the name of the font to
be used, e.g. "topaz.font" or "ruby.font". "size" is the height of the font
to be opened, given in screen pixels.

This call returns "FALSE" if the desired font could not be found for
whatever reason.


@ENDNODE
@NODE Menu "Menu operation with GFX4PCQ"
Menus can be attached to windows. They serve, together with gadgets, as a
user interface by allowing the selection of an action your program should
perform. Your program will notice the selection of a menu by the
@{"event mechanism" link IDCMP} of the windowlib.


@{B}Types used in this section@{UB}


WindowPtr       :       A handle to a window, a result of
@{"OpenAWindow()" link Windows} or OpenScreenWindow(). This handle is needed
to specify the window the menu is attached to.



@{B}Functions:@{UB}


@{B}
PROCEDURE CreateMenu(w : WindowPtr;cmds : Address);
@{UB}


Attach a new menu to the window "w" encoded in the "cmds" array. "cmds" is a
pointer to the first entry of an array of "MenuCommand" records. Each
record, so each entry of this array, looks like the following:

@{CODE}
TYPE
        MenuCommand     =       RECORD
                MenuType        :       BYTE;
                MenuFlags       :       BYTE;
                ShortCut        :       CHAR;
                reserved        :       BYTE;
                MenuText        :       String;
        END;
@{BODY}

"MenuType" is the type of entry this record describes. The following values
can be used here:


MC_MENU         :       The entry is a menu, i.e. a headline of a list of
subitems. It appears on top of the screen with all related items below.


MC_LASTMENU     :       A dummy entry representing the end of the menu. MUST
BE PRESENT, ABSOLUTELY, AND MUST BE THE LAST RECORD OF THE ARRAY.


MC_ITEM         :       The entry is an item of a menu.


MC_LASTITEM     :       A dummy entry representing the end of a item list of
a menu. THIS MUST BE THE LAST ITEM ON A LIST OF ITEMS, and the next record
in the array must be of type MC_MENU or MC_LASTMENU.


MC_SUBITEM      :       The entry is a sub-item of a sub-item list attached
to one of the items.


MC_LASTSUBITEM  :       A dummy entry aborting a list of subitem. Again,
THIS ONE MUST BE PRESENT, and the next record in the array must be of the
MC_ITEM or MC_LASTITEM type.


"MenuFlags" is a flags field, its meaning and interpretation depends on the
type of the record, i.e. the "MenuType" field. The following flags are valid
for MC_MENUs ONLY:


MC_NORMALMENU                   An ordinary menu. The only useful value
here.


If you specify none of the above,i.e. just zero, the menu gets disabled.


The following flags are valid for MC_ITEMS and MC_SUBITEMS ONLY:


MC_BAR                  A separator bar, not selectable.

MC_READONLY             A non-selectable item, serving as information.

MC_NORMAL               An ordinary selectable item or subitem.

MC_OFF                  A usually selectable but temporarely disabled item.

MC_CHECKABLE            A selectable on/off switch with a checkmark.

MC_OFFCHECK             A temporarely disabled on/off switch.


No combinations of the values above are allowed.


"Shortcut" is valid for items and subitems only and represent a convenient
way to reach the menu with one keystroke. The character entered here will be
displayed near the item text, together with an image of the "Amiga" key on
the keyboard. If the corresponding key is pressed together with the the
"Amiga" key, the item gets selected as if it has been selected manually with
the mouse. These shortcuts are most convenient for the advanced user who
prefers the faster keyboard handling to the rather slow mouse. Use the
character '\0' here if you don't want any shortcut.


"reserved" is, like it says, reserved. Set it to zero for the current
version of the windowlib.


"MenuText" is the text to be printed in the menu.


The follwing shows an example definition of this menu command record:

@{CODE}
        menubar : ARRAY[1..8] OF MenuCommand=(
                (MC_MENU,MC_NORMALMENU,'\0',0,"Menu 1"),
                 (MC_ITEM,MC_NORMAL,'\0',0,"Item 1"),
                 (MC_ITEM,MC_NORMAL,'\0',0,"Item 2"),
                 (MC_ITEM,MC_CHECKABLE,'\0',0,"OnOff"),
                 (MC_ITEM,MC_BAR,'\0',0,""),
                 (MC_ITEM,MC_NORMAL,'Q',0,"Exit"),
                 (MC_LASTITEM,0,'\0',0,""),
                (MC_LASTMENU,0,'\0',0,""));
@{BODY}

This defines a menu bar with one menu "Menu 1", with four items, labeled
"Item 1", "Item 2", "OnOff" and "Exit", with a separator bar between the
"Exit" item and the rest. "OnOff" is a menu representing a state, i.e. is
printed with a checkmark near the label and can be toggled on or off by
selecting it. The following line would create and attach the menu to the
window, using the example above:


CreateMenu(w,@menubar);


where "w" is a handle to the window, filled by some code above.


@{B}Notes:@{UB}

- The number of menus, items and subitems is limited. You may create up to
30 menus with up to 62 items, each of them having a maximal amount of 30
subitems. This should be big enough!


- What you see here in action is the automated menu creator of ViNCEd - I'm
using here the same code as in my shell/editor....




@{B}
PROCEDURE DeleteMenu(w : WindowPtr);
@{UB}


Removes the menu attached to the given window.




@{B}
PROCEDURE LastMenu(w : WindowPtr;VAR menu,item,subitem : Short);
@{UB}


Returns the last item selected in the menu. This call is actually part of
the @{"event" link IDCMP} handling mechanism of the windowlib.

"menu", "item" and "subitem" get filled by the number of the last menu item
selected by the user. Menus,item and subitems are counted from the left to
the right and from the top to the bottom, starting from zero. If the
selected item has no subitem, the "subitem" variable is set to -1. If the
user selected only a menu and no item, "item" is set to -1 as well. If the
user viewed the menu but selected no object in the menu, all variables will
be set to "-1".



@{B}
PROCEDURE OnMenuPoint(w : WindowPtr;menu,item,subitem : Short);
@{UB}


Enables a given menu or menu point. The encoding in "menu", "item" and
"subitem" is quite the same as in the "LastMenu" call. Menus are counted
left to right, starting from zero, items and subitems from zero downwards.

If you specify -1 as subitem, the head item is affected, if you specify -1
as item index, the menu gets enabled.



@{B}
PROCEDURE OffMenuPoint(w : WindowPtr;menu,item,subitem : Short);
@{UB}


Quite the same, but disables the object.



@{B}
PROCEDURE CheckMenu(w : WindowPtr;menu,item,subitem : Short;check : Boolean);
@{UB}


Sets the checkmark of a item or subitem to a value given by "check". TRUE
checks the item, FALSE removes the checkmark. Addressing this to a menu
makes no sense at all since menus can't be checked.



@{B}
FUNCTION CheckMarkOfMenu(w : WindowPtr;menu,item,subitem : Short) : Boolean;
@{UB}


Reads the checkmark state of a menu item or subitem. Returns TRUE if the
item is checked, FALSE otherwise. Again, addressing a menu instead of an
item makes no sense at all.


@ENDNODE
@NODE Gadgets "Gadget operations"
Gadgets are another part of a graphical user interface - they may appear as
buttons that start a certain program action, as on/off buttons that can be
pressed or released, as "fields" that can be filled by the user with text or
numbers, hence presenting an eletronic form, or as sliders to select a
number in a very intuitive way. Windowlib gadgets are only a subset of all
gadget types possible, and only the most basic types are present in the
current implementation.


@{B}Types used in this section:@{UB}


WindowPtr       :       The most popular handle to a window, a result of
@{"OpenAWindow()" link Windows} or OpenScreenWindow(). Here needed to
specify the window where a gadget should appear in.


GadgetPtr       :       A handle to a gadget object. Manipulation of
gadgets, as well as creation and deletion works thru this handle. As usual,
don't make any assumption how this handle looks like.


Another notation used in this section is that of a gadget "ID". The
windowlib will assign a unique number to each gadget it creates. This number
is simply choosen by the order in which the gadgets got created. The first
gadget will get the "ID" 1, the next 2 and so forth. The windowlib provides
also functions to convert the ID to the gadget handle and the other way
round.


@{B}Functions:@{UB}


@{B}
FUNCTION CreateTextButton(w : WindowPtr;x,y,xsize,ysize : Short;text : String) : GadgetPtr;
@{UB}


Create a simple "push only" button with a text in it. "w" is the window the
button should appear in, "x,y" is its position. The parameters "xsize" and
"ysize" specify the width and height of the button. Windowlib may choose to
enlarge these values if the text does not fit into the button, so pass here
just "0,0" to make the windowlib choosing the right dimension for you.
"text" is the text to be printed inside of the button.


@{B}Result:@{UB}

A handle to the new gadget.


@{B}Notes:@{UB} This call can't fail. If something got wrong inside of the
gadget creation, your program will be aborted with a runtime error. There's
no need to check the returned pointer for NIL. This goes to all gadget
creation functions as well!



@{B}
FUNCTION CreateTextToggle(w : WindowPtr;x,y,xsize,ysize : Short;text : String) : GadgetPtr;
@{UB}


Just like the call before, but creates a "push & pop" button that represents
an on/off state. Pressing it once pushes it "into" the window, pressing it
again releases the button. The parameters are the same as for the last call.


@{B}Result:@{UB}

A handle to the on-off gadget.



@{B}
PROCEDURE OffButton(g : GadgetPtr);
@{UB}


"Remote-releases" an toggle button given the gadget handle. Can be used to
set the state of a toggle button from within a program.



@{B}
PROCEDURE OnButton(g : GadgetPtr);
@{UB}


Pushes the toggle button "g" into the window, i.e. selects it.



@{B}
PROCEDURE SetToggle(g : GadgetPtr;state : Boolean);
@{UB}


Sets the state of a toggle button, just like the "OffButton()" or
"OnButton()" functions above. The argument "state" must be set to TRUE to
push the button, or FALSE to release it.



@{B}
FUNCTION GetToggle(g : GadgetPtr) : Boolean;
@{UB}


Read the state of a toggle button. Returns TRUE if the button is pushed, or
FALSE if it is released.



@{B}
FUNCTION CreateStringField(w : WindowPtr;x,y,xsize,ysize : Short) : GadgetPtr;
@{UB}


Creates a field where the user may enter text, like file names or other
strings. These gadgets are usually called "string gadgets", windowlib calls
them "StringFields".


"w" the handle of the window where the string field should appear, "x,y" is
its position, "xsize" and "ysize" is the size of the filed on the screen.
The windowlib may increase the size if it is too small to hold the text.


@{B}Result:@{UB}

A handle to the gadget created by this procedure.


@{B}Notes:@{UB}

The amount of characters the string gadget can hold can't be changed. It is,
as all windowlib paramters, "usually big enough".

There's NO function to create a "number only" version of a string field. If
you need one, use this function and check manually if the contents is a
number.



@{B}
FUNCTION ActivateField(g : GadgetPtr) : Boolean;
@{UB}


Activate a given field manually, to allow user input right now.


@{B}Result:@{UB}

Returns FALSE if the field could not be activated. This might happen if, for
example, the window of the field is not activated itself.



@{B}
FUNCTION BufferFromField(g : GadgetPtr) : String;
@{UB}


Returns the contents of a given field, i.e. the string the user entered. Do
NOT write to the string returned, it's not yours! Read it once, and don't
touch it in any way.



@{B}
FUNCTION CreateSlider(w : WindowPtr;x,y,xsize,ysize : Short;vert : Boolean) : GadgetPtr;
@{UB}


Create a slider (system notation: "Prop Gadget"), used to select a numerical
value. "w" is the handle of the window in which the slider will be created,
"x,y" is its position and "xsize" "ysize" its width and height. Set "vert"
to TRUE to get a vertical slider, or to FALSE for a horizontal one.


@{B}Result:@{UB}

A handle to the new slider.


@{B}Notes:@{UB}

Another call to "SetSlider()" is most likely necessary to set the
parameters like its range.



@{B}
PROCEDURE SetSlider(g : GadgetPtr;choices,viewable,first : Short);
@{UB}


Set slider specific parameters. "g" is the handle of the slider, "choices",
"viewable" and "first" encode the size of the slider knob and its position.

Sliders can be used to select a certain amount of items out of a bigger list
of items, like twenty file names that fit into a window out of a list of
hundred. "choices" is the total number of items selectable (100 in our
example), "viewable" the number of items visible at once (20 in the example
given), "first" is the number of the first item in the list currently
visible in the window.


Another example: The slider is used to select parts of a picture that does
not fit into the window completely. The window size is 640 pixels whereas
the picture is 1200 pixels wide. Set "choices" to 1200, "viewable" to 640.
If the picture is scrolled one window to the left, set "first" to 640.


If you want to use your slider to pick one number in a range of zero to n,
set "choices" to the maximum plus one, "viewable" to one and "first" to the
number initally selected.


@{B}Notes:@{UB}

To select a number in a range between a and b, set "choices" to "a-b+1" and
add "a" to the slider position. A similar trick can be used to invert the
slider direction, e.g. to select higher values with a higher slider
position.



@{B}
PROCEDURE SetSliderFirst(g : GadgetPtr;first : Short);
@{UB}


Quite the same as the call given above, but selects only the "first"
parameter of the slider, i.e. selects the position of the knob. It does not
change its size. "choices" and "visible" remain the same.



@{B}
FUNCTION FirstFromSlider(g : GadgetPtr) : Short;
@{UB}


Read the position of a slider, as a number between 0 and "choices"-1.


@{B}Notes:@{UB}

There's no function to read the "choices" and "viewable" parameters of the
slider as they can't get adjusted by the user; you have to remember them
yourself.



@{B}
PROCEDURE DeleteButton(g : GadgetPtr);
@{UB}


Removes a gadget from the window, given the handle to the gadget. This call
removes all types of gadgets, not just button types, so the name is a bit
misleading.


@{B}Notes:@{UB}

Do not use the gadget handle of a deleted gadget anymore.



@{B}
PROCEDURE RefreshButton(g : GadgetPtr);
@{UB}


Redraws a given gadget if you destroyed its outline by accident. The name of
this procedure is again a bit misleading as this call works for all kinds of
gadgets, not just for buttons.





The next two functions are used to convert gadget IDs to gadget handles and
vice versa:



@{B}
FUNCTION IDFromGadget(g : GadgetPtr) : Short;
@{UB}


Given a gadget handle, this function returns the ID of the gadget. IT WILL
ABORT WITH A RUNTIME ERROR if the gadget handle is invalid.



@{B}
FUNCTION GadgetFromID(w : WindowPtr;id : Short) : GadgetPtr;
@{UB}


Given an "ID" and a window handle, this function returns the handle to the
gadget.


@{B}Note:@{UB}

The window handle is necessary since gadget IDs are choosen per window, i.e.
if your program opens two windows and installs gadgets in them, two gadgets
of ID one will exist.



@{B}
FUNCTION LastGadgetID(w : WindowPtr) : Integer;
@{UB}


This function is actually part of the @{"event" link IDCMP} handling
mechanism of the windowlib. It returns the ID of the last gadget selected by
the user.


@ENDNODE
@NODE IDCMP "Event handling functions"
Events form the basis of user interaction with your code. Regardless wether
the user pushes a button, selects a menu, presses a mouse button or resizes
your window, everything will generate an event. Your program might wait for
user interaction, hence might wait for an event in a multitasking friendly
way, i.e. without using any CPU power. Please use these functions for
waiting and no dummy "polling", i.e. looping without doing anything.


The event mechanism works as follows: You tell the windowlib in the first
place which events you're interested in or you aren't any more interested
in. Another function returns the next event in queue of events that occured
between the last time you asked. Another function waits for an event to
occure and returns if something has happened.



The following events are known by the windowlib and can be returned or
requested by the event functions:


NEWSIZE_f       :       The user changed the window size.


REFRESHWINDOW_f :       The window contents must be redrawn. This one is
only send to @{"simple refresh" link Windows} windows.


MOUSEBUTTONS_f  :       A mouse button was pressed.


MOUSEMOVE_f     :       The mouse was moved.


GADGETDOWN_f    :       A button, field or slider is pressed down.


GADGETUP_f      :       The user releases a button, field or slider.


MENUPICK_f      :       The user picked a menu item.


CLOSEWINDOW_f   :       The user pressed the close gadget - it's time to
shut down. Please note again that the window won't close itself!


RAWKEY_f        :       The user pressed a keyboard key.


DISKINSERTED_f  :       A disk was inserted in some drive.


DISKREMOVED_f   :       A disk was removed.


ACTIVEWINDOW_f  :       The window got activated.


INACTIVEWINDOW_f:       The window was deactivated, i.e. a different window
became active.


INTUITICKS_f    :       This is a timer event, it occures approximately
every 1/6th of a second. It can be used to drive continous actions in a
multitasking friendly way. It does not occure if your window is inactive.



@{B}Types used in this section:@{UB}


WindowPtr       :       A handle to a "window" as result from OpenAWindow()
or @{"OpenScreenWindow()" link Windows}, disposed by CloseAWindow(), as
usual.



@{B}Functions:@{UB}


@{B}
PROCEDURE RequestStart(w : WindowPtr;what : Integer);
@{UB}


Request certain events for your window, i.e. tell windowlib that you want to
receive them. "w" is the handle of the window, "what" is an integer formed
by "or"ing all event types together you like to hear.

The following example will make your window listen to menus and gadgets:


RequestStart(window,GADGETUP_f or GADGETDOWN_f or MENUPICK_f);



@{B}
PROCEDURE RequestEnd(w : WindowPtr;what : Integer);
@{UB}


Tell windowlib to ignore certain events again. "what" is again formed by
"or"ing all event types together you don't want to hear any longer.



@{B}
FUNCTION NextRequest(w : WindowPtr) : Integer;
@{UB}


Returns the next event type in the queue of received events, or 0 if nothing
happened.



@{B}
FUNCTION WaitRequest(w : WindowPtr) : Integer;
@{UB}


Returns the next event type, like the call above. If no event is present in
this queue, DO NOT return, but wait until a next event is available. Hence,
a return code of zero is impossible here.


@{B}Notes:@{UB}

Use this function to wait for an event in a multitasking friendly way.



The typical "event loop" of a user interactive program looks like the
following:

@{CODE}
        RequestStart(w,CLOSEWINDOW_f OR GADGETUP_f OR MENUPICK_f OR RAWKEY_f);
        close:=FALSE;
        REPEAT
                t:=WaitRequest(w);

                CASE t OF
                CLOSEWINDOW_f:
                        close:=TRUE;
                GADGETUP_f:
                        BEGIN
                                id:=LastGadgetID(w);
                                HandleGadget(w,id)
                        END;
                MENUPICK_f:
                        BEGIN
                                LastMenu(w,menu,item,subitem);
                                HandleMenu(w,menu,item,subitem)
                        END;
                RAWKEY_f:
                        BEGIN
                                LastKey(w,@buf,qual);
                                HandleInput(w,buf,qual)
                        END;
                END
        UNTIL close;
@{BODY}



The next functions use the event mechanism or parts of it:



@{B}
PROCEDURE Mouse(w : WindowPtr;VAR x,y : Short);
@{UB}


Returns the position of the mouse in the given window.



@{B}
PROCEDURE WaitForClick(w : WindowPtr);
@{UB}


Waits until the user clicks into the given window, i.e. until a left mouse
button press over the window.



@{B}
PROCEDURE WaitLeftClick(w : WindowPtr;VAR x,y : Short);
@{UB}


Waits like above for a mouse button click, and returns the position of the
click.



@{B}
FUNCTION MouseDown(w : WindowPtr; VAR x,y : Short) : Boolean;
@{UB}


Returns the position of the mouse and the state of the left mouse button as
boolean return code. TRUE means that the button is pressed.


@{B}Note:@{UB}

This call may send your task to sleep for 1/6th of a second, necessary to
read the mouse button position in a system friendly way.



@{B}
FUNCTION MouseMove(w : WindowPtr; VAR x,y : Short) : Boolean;
@{UB}


Like the call above, but this one returns only if the button state changes
or the mouse gets moved. It sends your task to sleep otherwise.



@{B}
FUNCTION MouseButton(w : WindowPtr) : Boolean;
@{UB}


Returns the state of the left mouse button. As all calls above, it may send
your task to sleep for 1/6th of a second.


@{B}Note:@{UB}

There's not a single function to read the state of the right (and of the
middle, if you have one) mouse button. I added no function like this on
purpose: The right mouse button is reserved for the menu, and should be used
only for the menu, no discussion!



@{B}
PROCEDURE WaitForClose(w : WindowPtr);
@{UB}


A simple function. Waits until the user presses the close gadget of the
given window. DOES NOT CLOSE THE WINDOW ITSELF, that's your task!



The next ones are rather complex but easy to use. They implement functions
useful in drawing programs, to select parts of a picture or a single point
of the screen, using a crosshair:



@{B}
PROCEDURE SelectPoint(w : WindowPtr; VAR x,y : Short);
@{UB}


Selects a single point of the window, using a crosshair.




@{B}
PROCEDURE DragBox(w : WindowPtr; xanc,yanc : Short; VAR x,y : Short);
@{UB}


Selects a rectangular region of the window, using a crosshair and a
drag-style rectangle, together with the last function. "xanc" and "yanc" is
the "anchor position" of the rectangle, usually the coordinate pair returned
by the function above. "x,y" is the "opposide" vertex of the rectangle when
the user finished his operation.


The following method of selecting a rectangle can be implemented by using
both functions:


Move the mouse to one edge of the rectangle, press the button and hold it
and "drag" the rectangle to select the complete region.


Implementation:

@{CODE}
        SelectPoint(w,x1,y1);
        DragBox(w,x1,y1,x2,y2);
@{BODY}


@{B}Notes:@{UB}

This function doesn't make much sense without calling "SelectPoint" before.



@{B}
PROCEDURE LastKey(w : WindowPtr;text : String;VAR qualifier : Short);
@{UB}


Returns the last key pressed if you requested RAWKEY_f events. "text" is a
string large enough to hold AT LEAST 16 characters. A pointer (!) to an
array of 16 char's will work fine here. "qualifier" is filled with
additional information about the key pressed. It is a bit field with the
following values or'ed together:


QUALIFIER_LSHIFT:       The key was pressed together with the left shift key.

QUALIFIER_RSHIFT:       or with the right shift key.

QUALIFIER_CAPSLOCK:     CAPSLOCK was pressed.

QUALIFIER_CONTROL:      The Ctrl key was pressed.

QUALIFIER_LALT:         The left alt key was held down.

QUALIFIER_RALT:         Ditto, but the right one.

QUALIFIER_LCOMMAND:     The left Amiga key (Commodore key) was pressed.

QUALIFIER_RCOMMAND:     The right Amiga key is pressed down.

QUALIFIER_NUMERICPAD:   The key is located on the numeric key pad.

QUALIFIER_REPEAT:       The key is in auto-repeat state.

QUALIFIER_MIDBUTTON:    The middle mouse button is held down.

QUALIFIER_RBUTTON:      The right mouse button is pressed.

QUALIFIER_LEFTBUTTON:   The left mouse button is pressed.



@{B}Note:@{UB}

Be prepared to recieve only a qualifier and no key at all. This will happen
if the user presses a "qualifier" type key alone.


@ENDNODE
@NODE Console "Console related functions"
The "console" is a (simple though) terminal type program that can be used to
print text and to recieve user input in a simplified way. It understands,
unlike the simple @{"DrawText()" link Rastport} function, a lot of
control codes, like LineFeed or CR, but also so called "CSI sequences" which
perform more complex operations than just scrolling the window. The current
implementation of the console in the windowlib is only partially done, so no
functions to read from the console are present. This is left to a future
release of the windowlib.



@{B}Types used in this section:@{UB}


WindowPtr       :       As usual, a handle to a open
@{"window" link Windows}.



@{B}Functions:@{UB}


@{B}
PROCEDURE Print(w : WindowPtr;text : String);
@{UB}


Prints the string "text" to the console attached to the window "w". A lot of
control sequences can be used, as well as special ASCII control characters
like 07="BEL" to beep the screen or 0A="LF" for a line feed. More details
about the console can be found in the system documentation.



@{B}
PROCEDURE SwitchCursor(w : WindowPtr;onoff : Boolean);
@{UB}


Turns the console cursor on or off, depending on the "onoff" parameter.
"TRUE" enables the cursor, "FALSE" disables it - which is the default.


@ENDNODE
@NODE Copper "GFX4PCQ Copper support functions"
The copper is a graphic coprocessor, part of the custom chip set of the
amiga. Its main purpose is to alter certain hardware registers, mostly the
color registers, while the electron beam of your monitor creates the
picture. It is, therefore, possible to load a color register, i.e. a "pen"
with a new color in the middle of the screen, hence displaying one color on
the top of the screen and a different one at the other half, using THE SAME
pen. Much more colors than usual are possible, as color registers can be
re-used by clever copper usage.


@{B}General note:@{UB}


The copper is a part of the native amiga graphic chip set. Don't expect that
the copper related functions work on a graphics board, don't use them if
your software should run on a computer equipped with such an extension. This
will work with native amiga screen modes ONLY!


@{B}Types used in this section:@{UB}


ScreenPtr       :       This part of the windowlib is screen oriented rather
than window oriented, so a handle to a screen is needed by all functions.
This handle can be obtained from the @{"OpenAScreen()" link Screens}
function. A NIL pointer as a short-hand for the workbench screen IS NOT
LEGAL here.




@{B}Functions:@{UB}


@{B}
PROCEDURE CopperWait(s : ScreenPtr; x,y : Short);
@{UB}


Add a instruction to the copper program, the so called "copper list", to
tell this coprocessor to wait until the electron beam has reached position
"x,y".



@{B}
PROCEDURE CopperSetColor(s : ScreenPtr; reg, r,g,b : Short);
@{UB}


Add a copper instruction to the copper program to set the color register
"reg" to the color given by the red, green and blue components in r,g,b.


@{B}Notes:@{UB}

The following instruction sequence is needed to change the color register
"reg" to "r,g,b" at the screen position "x,y":

@{CODE}
CopperWait(s,x,y);
CopperSetColor(s,reg,r,g,b);
CopperDone(s);
@{BODY}

If you want to change colors at more than one position, make sure that you
add the copper-wait instructions with the positions in increasing order.
This is due to the fact that the electron beam draws the screen in just the
same order!



@{B}
PROCEDURE CopperMove(s : ScreenPtr; register : Integer; value : Short);
@{UB}


Adds a copper instruction to set the hardware-register "register" to a new
"value". There's usually no need to modify anything except the color
registers, so leave this function alone!



@{B}
PROCEDURE CopperDone(s : ScreenPtr);
@{UB}


Complete the current copper program and load it in the copper to make it
visible on the screen. THIS CALL MUST BE USED to "run" your copper program,
so it must be the last call in a sequence of copper-related calls.



@{B}
PROCEDURE CopperQuit(s : ScreenPtr);
@{UB}


Remove, i.e. unload the current copper program in action manually. There's
usually no need to call this procedure since the windowlib will remove the
current copper program anyways if you close the screen. If you want to load
a new, different copper program, just build it with CopperWait() and
CopperSetColor() as usual. The windowlib will unload the old program for
you.



@{B}
PROCEDURE SetCopperSize(s : ScreenPtr; size : Integer);
@{UB}


This call pre-sets the maximal size of a copper program, i.e. tells the
windowlib how much room should be reserved for a new copper program. This
call is not needed unless your copper program gets REALLY big, as the
default setting is usually "big enough".


@ENDNODE
@NODE AnimTools "Animation support"
This part of the windowlib is used to create and control graphic objects
that can be moved around the screen very easely and that do not conflict
with other parts of the graphics drawn so far. Their main application is of
course in games, to display the player figures under control of the user.
These objects are often called "Sprites", the notation we will use in this
section, even though different names have been invented for them, like
"player-missle graphics", "mobs" for "moveable objects", or "gels" for
"graphics elements".


The sprite system of the windowlib knows actually two different types of
"sprites", namely so called "true hardware sprites" and "bob" - short for
"blitter objects". The first type is generated by the video hardware and is
really independent of all other graphics you draw on the screen. Hardware
sprites come always with their own colors, and they come always in a LO-Res
@{"resolution" link Screens}, regardless of the screen type¹. However,
hardware sprites have certain restrictions: They can't be wider than 16
pixels and have only up to four colors, one of them beeing transparent. The
current amiga chipset offers a maximal number of eight hardware sprites, but
two of them are reserved for the system², leaving six for the windowlib. The
windowlib tries to create the illusion that you have an unlimited number of
them, and it is indeed possible to draw more than just six hardware sprites
on the screen provided they don't take up the same horizontal position on
the screen. More restrictions arise if each windowlib "sprite" should come
with its unique colorset, leaving only three hardware-sprites to display an
infinite number of software or windowlib "sprites".

"Bobs" don't have these restrictions. These objects are drawn by the
blitter, another coprocessor onboard. The same video hardware that is used
to display the windows and the usual graphics you draw inside of windows is
utilized to display these objects except that drawing bobs is faster due to
the special blitter hardware³. As a result, bobs share always the colors of
the screens they appear on, as well as the resolution of the screen. They
don't have the restrictions of hardware sprites - they can be as big as you
want them and you can have as many as you want. However, the more you
create, the slower the animation and the more flickering. Drawing four bobs
without any flicker on the screen is simple, more than 16 is almost
impossible. There is in principle a technique to avoid this flicker, namely
"double buffering", but this is not yet implemented in the windowlib.
However, drawing bobs is always slower than drawing hardware sprites.



@{B}Notes:@{UB}


Both, bobs and hardware sprites use special functions of the amiga hardware.
While it MIGHT be possible that a graphics card can simulate the "bobs", it
is rather impropable that the "hardware sprites" work on a non-native amiga
screen. Please do not use this animation engine at all if your program must
stay compatible to graphic boards.


¹ : This is not absolutely true. Hardware sprites on a super-hires screen
appear in "hi-res", not in "lo-res". The improved hardware of the "AGA" or
"AA" chipset does also allow sprites in a "hi-res" resolution, but this
function is not yet implemented in the windowlib - simply because I don't
have the AGA chip set on board.


² : Actually only one of the hardware sprites is reserved for the system,
sprite #0 for the mouse pointer. Sprite #1 is reserved by the windowlib as
well because it shares the same color set as the mouse pointer. Using sprite
#1 for the animation engine as well would yield to strange color effects of
the mouse pointer I want to avoid. Moreover, only four of the
hardware sprites come with their own colors - the sprites with even numbers.
All sprites with odd numbers share the color set with their "even" partner -
leaving only four sprites with unique colors, minus one for the mouse
pointer. The sprite colors are also used for the usual "playfield
graphics" if you open a screen of depth 5 or above, at least with the ECS
chip set. This color mapping can be changed with AGA, but I haven't
implemented this for the reasons I gave above.


³ : This is not necessarily true. A fast processor might be nowadays faster
than the blitter coprocessor. The OS routines used by the windowlib do,
nevertheless, use the blitter to draw bobs.




@{B}Types used in this section:@{UB}


WindowPtr       :       A handle to a "window" as result from OpenAWindow()
or @{"OpenScreenWindow()" link Windows}, disposed by CloseAWindow(). All
sprite functions are relative to a window, even though hardware-sprites are
not bound to the window borders. All sprites positions are, for this reason
relative to the window they belong to. This is for hardware sprites a
simulation made by the windowlib for you - the hardware sprites won't move
immediately if you move the window.


SpritePtr       :       A handle to a sprite, gained from a OpenSprite call.
This handle must be provided for all windowlib functions, do not make any
assumptions how this handle looks like.




@{B}About sprite positioning:@{UB}


As I said above, sprite positions are ALWAYS relative to the window the
sprites appear in. They are, however, not encoded in the usual way as pixel
offset from the coordinate origin of the window. The windowlib sprite
positioning is done in "fixed point" numbers instead. This sounds horrible,
but is in fact very simple: All sprite positions are scaled by a factor of
2^16=65536, so divide by 65536 or $10000 to get the "real" position of a
sprite, or multiply by $10000 to get the sprite position from a ordinary
window position:


Sprite to Window¹       :       window_x:=sprite_x DIV $10000

Window to Sprite        :       sprite_x:=window_x * $10000 or, equivalently

                                sprite_x:=window_x SHL 16;


This mechanism sound like an unnecessary complication, but is very useful
for creating smooth animation without using the rather slow floating point
variables. Scale every² sprite positioning operation by this factor of 65536
and you're fine. Examples for this mechanism can be found in the "Examples"
drawer of this distribution.



@{B}Notes:@{UB}


¹ : Do not replace the division by a right-shift. The shift is unsiged,
whereas the division is signed. The shift will therefore not respect the
proper sign of the position. The current PCQ version is smart enough to
replace the division by $10000 with a proper shift that respects the sign.


² : This is not correct strictly speaking, as mathematicians might have
noticed. Addition and subtraction do, of course, not care about this factor,
but multiplication and division do. These operations are, however, of no
much use for animations.




@{B}Functions:@{UB}


@{B}
FUNCTION OpenSprite(w : WindowPtr;shape : Address; height : Integer; flags : Integer) : SpritePtr;
@{UB}


Build a new sprite in a window "w". "shape" is the description of the sprite
shape in "ASCII Art", as a pointer to the first element of an array of
strings. The following code segment gives an example of a sprite shape
definition:

@{CODE}
TYPE
        LanderArray     =       Array [0..9] of String;

CONST
        Lander  :       LanderArray=(   { the lander itself }
        "      ...       ",
        "     ......     ",
        "    ........    ",
        "   ...+..+...   ",
        "  *..++..++..*  ",
        "   ...+..+...   ",
        "    ........    ",
        "  ..  ***   ..  ",
        " ..  *****   .. ",
        "..            ..");
@{BODY}

Each pixel of the sprite shape is represented as one ASCII character in this
array of strings, the color of the pixel is encoded in the ASCII character
used to represent the pixel. The following encoding sheme is used:

@{CODE}

         (blank space)  =       color 0, i.e. transparent.
        .               =       color 1
        +               =       color 2
        *               =       color 3
        -               =       color 4
        /               =       color 5
        |               =       color 6
        ^               =       color 7
        _               =       color 8
        #               =       color 9

@{BODY}

You may also encode the colors in digits. The symbols "0" to "9" represent
the colors 0 to 9, respectively. The letters "A" to "Z" encode all remaining
colors 10 and up.

The with of the shape is taken from this array automatically, you don't need
to specify it. The height of the array must, however, passed to the
function.


The following line would create the sprite of the shape above:


sprite:=OpenSprite(w,@Lander[0],10,SPRITE_HARDWARE);


Note that we must pass the address of the first string in the array, not the
string itself. The pascal syntax is too restrictive to allow this.


The last parameter, "flags" determinates the type of sprite to be created.
As usual, more that one of the flags below can be passed by or'ing them
together:


SPRITE_HARDWARE         :       The sprite should become a real hardware
sprite. Remember, certain restrictions arise to hardware sprites! They can't
be wider than 16 pixels  - if you pass a wider shape, the windowlib will
abort your program with a runtime error - and they can use colors 0 to 3
ONLY. If you don't set this flag, you get a "bob" instead: "Bobs" can be as
wide as you want, but are slower, flickering if they are too big and share
the colors with the usual playfield.



SPRITE_MUSTDRAWN        :       This flag makes only sense for hardware
sprites. As mentioned above, all windowlib sprites are mapped to the screen
using only six true hardware sprites, so it might happen that some of the
sprites can't be displayed since there's no free hardware sprite left to
display them. If you set this flag, you tell the windowlib to give this
sprite a higher priority in assignment to the hardware sprites and to remove
other sprites to make this one visible. IT DOES NOT MAKE MUCH SENSE to set
this flag for all sprites. If no sprite hardware is available, that's it!
These sprites have only a higher priority of the cost of lower priority
sprites, not more.



SPRITE_SAVEBACK         :       This flag is only useful for bobs. If set,
the windowlib is told to save the background behind the bob in order to
restore it if the bob gets moved. If you don't set this flag, the bob
destroys the background behind it if gets moved - you get the effect of a
drawing brush like in popular painting programs.


SPRITE_OVERLAY          :       Make color zero of the bob transparent. If
this flag is set, the background shines thru the color 0 pixels of the bob,
if you don't set this flag, color zero is explicitly drawn and you'll see a
container box of this color around the bob if it moves over a background of
a different color. This is the "Matte vs. Stamp" flag you might know from
paiting tools.

A hint: If you want hardware sprites, specifiy "SPRITE_HARDWARE". If you
want bobs, the combination "SPRITE_SAVEBACK or SPRITE_OVERLAY" is best.



@{B}Result:@{UB}

A handle to the windowlib sprite. This call can't fail, you're guaranteed to
get the sprite. If there's not enough memory available to hold the sprite,
this function will abort your program with a runtime error.


@{B}Note:@{UB}

Your sprite won't be visible at first. To make it visible, place it
somewhere inside of the window and call to RedrawSprites(). See below for
more hints about this function.



@{B}
PROCEDURE CloseSprite(sp : SpritePtr);
@{UB}


Remove a sprite from the display and free the memory occupied by it. Do not
use the sprite handle afterwards.

@{B}Note:@{UB}

If you want to remove a sprite temporary, use "HideSprite()" and
"ShowSprite()" instead. They are much faster than "OpenSprite()" and
"CloseSprite()".


All following sprite control calls don't have an immediate effect on the
sprite. Instead, all these calls are "buffered" and the actual sprite
mapping is delayed to the next call of "RedrawSprites()" or
"AnimateSprites()". This mechanism is used to make the sprite machinery as
fast as possible since redrawing a sprite is quite slow, also for hardware
sprites. Redrawing of all sprites after each manipulation would yield to a
considerable slow-down of your program; instead, all your changes are
recorded and made at once, with one call.



@{B}
PROCEDURE SetSpriteColor(sp : SpritePtr;reg,r,g,b : Integer);
@{UB}


Set the colors used by the sprite. This works only for hardware sprites, not
for bobs because only hardware sprites come with their own color set.

"sp" is a handle of the sprite you want to set the colors, "reg" is the
color number. Since color 0 is always transparent, "reg" must be a number
between one and three. "r,g,b" are the red, green and blue component of the
new color.



@{B}
PROCEDURE ShareColors(base, add : SpritePtr);
@{UB}


Share the colorset of the "base" sprite and use it for the "add" sprite as
well. All changes to the colorset of the "base" will result in a color
change of the "add" sprite afterwards. Only useful for hardware sprites.


This has two advantages: First, you don't have to load the same colors
twice, hence save three calls to "SetSpriteColor()". Second, the
sprite-to-display mapping routine will select sprites that share the same
colorset for you, leaving more true hardware sprites with unique colors for
other sprites. As a result, more sprites can be displayed if they share the
same colorset.


@{B}Note:@{UB}

Try to share as many sprite colors as possible to get as much sprites as
possible. "OpenSprite()" won't fail if no more sprites are available, but
the additional sprites might vanish from the screen from time to time. Just
loading the identical colors IS NOT ENOUGH! This call SHOULD be used
instead.



@{B}
PROCEDURE OwnColors(sp : SpritePtr);
@{UB}


Just the opposide from the call above. Use a unique colorset for this sprite
instead of sharing it with another sprite.



@{B}
PROCEDURE SetSpriteShape(sp : SpritePtr;shape : Address);
@{UB}


Define a new shape for a sprite, in the same way as shape definition for
"OpenSprite()". The new shape MUST have the same dimension as the original
shape, so no dimensions are passed here.


@{B}Note:@{UB}

Do not use this call. It's usually better and faster to allocate two sprites
in the first place and to make one or the other temporary invisible with
"HideSprite()" and "ShowSprite()".



@{B}
PROCEDURE HideSprite(sp : SpritePtr);
@{UB}


Make the given sprite invisible, as well as all sprites linked to this one
as animation sequence.



@{B}
PROCEDURE ShowSprite(sp : SpritePtr);
@{UB}


Make the sprite visible again, together with all animation frames.


@{B}Note:@{UB}

Please remember that these calls are not immediate, as all other calls
above!



@{B}
PROCEDURE RedrawSprites(w : WindowPtr);
@{UB}


Make all changes made so far visible, map all sprites to the screen and
calculate the new collision masks.



@{B}
PROCEDURE AnimateSprites(w : WindowPtr);
@{UB}


This is the big one. Does the same as RedrawSprites() except that it selects
the next frame of animated sprites, so runs the animation engine as well.



@{B}About creating animation:@{UB}


A rather unique feature of the windowlib function is that of "linking"
sprites together. If you want to create an animation of a working men on the
screen, just drawing the shape and shifting it around the screen is not good
enough - legs and arms have to move in a natural way to create the illusion
of a real person. To create this illusion in an animated movie, different
"frames" of the same person are drawn, with the legs and arms shifted a bit
from frame to frame. If each frame is played after another in a fast way and
the shape as a whole is shifted across the screen, a more relastic picture
of a walking person has been created. This sort of trick is possible with
the windowlib functions:

Create a sprite for each frame, and link each frame to the "master sprite"
with LinkSprite. Do not touch these sprites anymore, use only the master
sprite for placement on the screen. All remaining steps for showing one
frame after another are done by the windowlib for you.



@{B}
PROCEDURE PlaceSprite(sp : SpritePtr; x,y : Integer);
@{UB}


Set the position of the sprite "sp" at position "x,y". Remember that "x" and
"y" are given in "fixed point" number, i.e. have to be scaled by a factor of
65536 or $10000, as described above. It sets also the positions of all
sprites linked to this sprite. There's no need to touch them at all.



@{B}
PROCEDURE LinkSprite(base : SpritePtr; add : SpritePtr);
@{UB}


Link the "add" sprite as another animation frame to the master sprite
"base". The master sprite and "add" will share the same position on the
screen, but only one of them is visible at a time. The "AnimateSprites()"
call keeps track of switching between the animation frames of the master
sprite. All subsequent sprite manipulation except setting the sprite
displacement with "ShiftSprite" and the sprite colors with
"SetSpriteColors()" should go to the "base" sprite instead, do not touch the
"add" sprite anymore.

It is of course possible to add more than one animation frame to the "base"
base sprite, just call "LinkSprite()" again with the next animation frame to
be inserted at the end of the animation sequence.


@{B}Note:@{UB}

DO NOT add a sprite that has been already linked to the same or a different
master sprite. This will abort your program with a runtime error.



@{B}
PROCEDURE UnlinkSprite(add : SpritePtr);
@{UB}


Remove the "add" sprite from an animation sequence and handle it
individually again.


@{B}Note:@{UB}

Do not try to unlink a sprite that is not linked.



@{B}
PROCEDURE SetSpriteTimer(sp : SpritePtr; time : Short);
@{UB}


Set the time how long a sprite beeing part of an animation sequence should
be shown. The time is measured in calls to "AnimateSprites()" and is set by
default to one - so each sprite in an animation sequence is shown for one
call to "AnimateSprites()".



@{B}
PROCEDURE ShiftSprite(sp : SpritePtr; x,y : Integer);
@{UB}


Shift a sprite relative to the base point of the window. The main purpose of
this call is to set an displacement of a sprite which is part of an
animation sequence relative to the master sprite of the sequence, but this
call can be used as well to set the "handle" position of the sprite which is
usually in the top left corner. Sprites linked in an animation sequence
share the same position, but not the same displacement.



The next two calls set the priorities between sprites, i.e. which sprite
should appear in front of another. I'm sorry to say that this works due to
an OS bug only for bobs, the OS does not care about these priorities for
hardware sprites and the order is more or less random. There's also no call
to set the priority of the sprites relative to the background, another flaw
of the OS.



@{B}
PROCEDURE InFrontOf(sp1,sp2 : SpritePtr);
@{UB}


Place the sprite "sp2" in front of "sp1". Please note that the ordering of
the parameters is somewhat misleading.


@{B}Notes:@{UB}

Due to an OS bug this call works for "Bobs" only.


If you want sprites "sp3" and  "sp2" in front of "sp1" and "sp3" in front of
"sp2", use the following calling sequence (the ORDER is important):


@{CODE}
        InFrontOf(sp1,sp2);
        InFrontOf(sp2,sp3);
@{BODY}



@{B}
PROCEDURE Unordered(sp : SpritePtr);
@{UB}


Do not care about the priority of the sprite "sp".


@{B}Note:@{UB}

Does not work for hardware sprites.



The next two calls are part of the collision detection of sprites. I'm again
sorry to say that the implementation of these functions in the OS is very
buggy and in certain points not working as expected. Problem one is that you
can detect collisions between sprites, but not between sprites and other
playfield (i.e. ordinary) graphics. Collision detection between sprites and
the window boundary (or more precise, the
@{"clipping rectangle" link Rastport}) is, however, possible. Another flaw
of this collision stuff is that works only for bobs as expected. The
collision routines are not prepared to handle hardware sprites of LO-Res
resolution on a screen of a different resolution, like HI-Res. To use it
with hardware sprites, a LO-Res screen must be used as well. Interlaced
screens have just the same trouble. I could add a workaround for this OS
flaw in a future release, but the current implementation of the windowlib is
now full of workarounds for quite a lot of OS bugs in the animation
"support" and don't want to add another one.



The collision detection "works" as follows:


Each sprite gets two masks, a "MeMask" and a "HitMask" and one
"CollisionMask" that records the hits got so far. The "HitMask" tells the
sprite about which hits should be detected, whereas the "MeMask"
determinates the hits this object can cause.


On a collision, the "MeMask" of the first object is ANDed with the "HitMask"
of the other object. If the result is non-zero, i.e. the "MeMask" and the
"HitMask" have set bits in common, a collision is detected. On a collision,
the part of the "MeMask" of the first object is and-ed with the
"HitMask" of the second object, the result is "Or"-ed into the collision
mask of the second object.


@{B}Note:@{UB}:

No, this is not a misprint, this operation is assymetric. When sprite "A"
collides with sprite "B", this does not mean that sprite "B" collides with
sprite "A" as well. You are, however, recommended to setup the masks in a
symmetric way or the system collision detection behaves in a strange way and
might "miss" collisions, depending on the vertical positions of the sprites.
This is very strange and we won't go into detail here.



To give an example: The Sprites "player1" and "player2" should detect
collisions with sprites "arrow1" and "arrow2", "player1" with "player2", but
not "arrow1" with "arrow2". We assign the following values to the "MeMask"
to identify the objects uniquely:

@{CODE}
        Sprite          |         MeMask
------------------------+--------------------------
        player1         |           2
        player2         |           4
        arrow1          |           8
        arrow2          |           8
@{BODY}

Note first that we choose powers of two for the "MeMask". This is usually
the only "natural" way to setup the "MeMasks" - remember that all operations
on the masks are binary "And's" and "Or's", so single bits have a
significance, not the decimal number. Note also that both arrows get the
same mask, we do not need to assign different values here because both
behave in the same way to the players. The players, however, need different
"MeMasks" cause we want to detect inter-player collisions. Bit 0 is never
set, it is reserved for border collisions in the "HitMask" - turning it on
for one type of sprites will effectively turn collisions with this sprite
into border collisions - most likely not what you want.


The "HitMasks" must be setup in the following way:

@{CODE}
        Sprite          |         HitMask
------------------------+--------------------------
        player1         |           4+8=12
        player2         |           2+8=10
        arrow1          |           2+4=6
        arrow2          |           2+4=6
@{BODY}

The HitMask is simply the sum of all MeMasks of all objects you allow to
collide with the specific sprite.

Note that it is not sufficient to allow collisions of the players 1 and 2
with the arrows alone, we've also to check for collisions of the arrows with
the players!



@{B}
PROCEDURE SetCollisionMasks(sp : SpritePtr; me, hit : Short);
@{UB}


Sets the "MeMask" and the "HitMask" of the sprite. The "HitMask" bit number
zero, COLLIDE_BORDER, is reserved for sprite to boundary collisions. If set,
your sprite will record collisions with the boundary. To avoid confusion,
don't set this bit in the "MeMask" of any sprite.


@{B}Notes:@{UB}

The name is misleading because this call does not touch the "CollisionMask"
at all, only the "HitMask" and the "MeMask" are affected.


This call sets only the masks of one sprite, not to the sprites linked to
this one as parts of an animation sequence. If you want to check for
collisions between sprites of a complete animation sequence, you have to
setup the masks for all sprites in this sequence in the same way.



@{B}
FUNCTION ReadCollisionMask(sp : SpritePtr; clearit : Boolean) : Integer;
@{UB}


Read the "CollisionMask" of a sprite, i.e. detect the collisions made since
the last call to "RedrawSprites()" or "AnimateSprites()" and the last time
the mask was reset. If "clearit" is set to TRUE, the current collision state
will be erased, if it is FALSE, the collisions will remain active and will
be returned again the next time this procedure is called.


If you set bit 0 of the "HitMask", i.e. the COLLIDE_BORDER bit, the
following bits are set for border collisions: COLLIDE_TOP,
COLLIDE_BOTTOM, COLLIDE_LEFT or COLLIDE_RIGHT for collision with the TOP,
BOTTOM, LEFT or RIGHT border respectively.


@ENDNODE
@NODE Joystick "Joystick support"
The next set of routines is used to read a joystick plugged into the amiga.
This is of course not very related to graphics, but still useful if you want
to write a game.



@{B}A general note:@{UB}


The amiga has two ports, port zero and port one. Port zero is usually
connected to the mouse, leaving port one for the joystick. The joystick
routines work for port zero as well, but they will make the intuition mouse
unuseable because a joystick is now expected as input device, for intuition
as well! The joystick port is given back to the system if your program
aborts, restoring the usual mouse handling as well. You might also tell the
windowlib that you're done with port 0, by calling the "FreeJoystick()"
procedure explicitly. This is not necessary for port 1, as it is not used by
the system anyways.


Another remark is that the first call to one of the joystick routines might
return an unaccurate result, i.e. might return no joystick movement even
though the user pushes the stick. All following calls will however work as
expected.



@{B}Functions:@{UB}


@{B}
FUNCTION Stick(n : Short) : Short;
@{UB}


Returns the state of the joystick connected to port "n". The joystick
directions are encoded as follows:

@{CODE}

        10 11 6
         \\ | /
        11-15-7
         / | \\
        9  13 5

@{BODY}


@{B}Note:@{UB}

This is exactly the same function as the "Stick()" function of AtariBasic.



@{B}
FUNCTION Strig(n : Short) : Boolean;
@{UB}


Returns the state of the joystick button in port "n". TRUE for pressed,
FALSE for released.



@{B}
FUNCTION StickUp(n : Short) : Boolean;
@{UB}


Returns TRUE if the joystick is pushed in an upwards direction, straight or
diagonal.



@{B}
FUNCTION StickDown(n : Short) : Boolean;
@{UB}


Returns TRUE for a downwards direction.



@{B}
FUNCTION StickLeft(n : Short) : Boolean;
@{UB}


Returns TRUE for a left push.



@{B}
FUNCTION StickRight(n : Short) : Boolean;
@{UB}


Returns TRUE for a rightwards joystick move.



@{B}
PROCEDURE WaitForStick(unit : Short);
@{UB}


Waits in a multitasking friendly way for any joystick action, i.e. for the
user to push the joystick in any direction or to press the fire button.


@{B}Note:@{UB}

Use this function if your program does nothing with a released joystick, DO
NOT busy wait!



@{B}
PROCEDURE FreeJoystick(unit : Short);
@{UB}


Free the joystick at port "unit", i.e. give the control back to the system.
Makes only sense for port 1 to make the intuition mouse working again.


@ENDNODE
@NODE History "History and Future of the WindowLib"
@{B}History@{UB}

Version 1.xx was only for private use. I made the mistake and uploaded it to
the aminet - it was actually designed for a private patch of the PCQ
compiler and the PCQ link library needed to make PCQ working with an older
release of the PhxAss assembler. It worked never in public, I know.


Version 2.00 is the first really WORKING aminet release. Hope you have fun!



@{B}Future@{UB}


The animation support, in special the collision detection could be better.
This is not my fault, but a serious problem of the OS. It might be worth to
replace the OS animation routines by private routines that work better.


The next version of GFX4PCQ might be designed for a different pascal
compiler, let's see what's available on the aminet - heard some rumors.


A future release might also contain sound support, would be at least handy
for writing games.

@ENDNODE
@NODE Credits "The credits page"

Thanks to Patrick Quaid for his PCQ pascal compiler! The windowlib was
mostly written in pascal and compiled with this compiler.


Thanks to Mike Foreman for converting the PCQ doc files to the AmigaGuide
format. They are really more handy than ASCII files.


Thanks to Nils Sjoholm for supporting the newer releases of PCQ and for the
regular updates I got. Thanks for the support and for a lot of fixed.


Thanks to Ernst Besser for having the nerve and learning pascal with this
library.

@ENDNODE

