@DATABASE "General"
@AUTHOR   "Paul Manias"
@NODE     "Main" "Informations générales"

@{b}@{u}DOCUMENTATION SUR LE SYSTEME@{uu}@{ub}
Nom:        INFORMATIONS GENERALES
Version:    0.9 Beta.
Date:       Octobre 1997
Auteur:     Paul Manias
Traducteur: Julien Boibessot
Copyright:  DreamWorld Productions, 1996-1997. Tous droits réservés.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette documentation couvre la manière dont le Games Master System se
comporte, la façon avec laquelle il a été conçu et les raisons pour
lesquelles ce design a été adopté. Si vous vous posiez des questions
à ces sujets j'espère qu'elles trouveront une réponse ici.

           1. @{"  Vérification des données   " LINK "DataChecking"}
           2. @{"Objets basés sur des Fichiers" LINK "DataObjects"}
           3. @{"      Codes d'erreur         " LINK "ErrorCodes"}
           4. @{"          Listes             " LINK "Lists"}
           5. @{"        Structures           " LINK "Structures"}
           6. @{"          Tags               " LINK "Tags"}

@{b}@{u}CHANGEMENTS DANS LA VERSION 0.9B@{uu}@{ub}
Ajouté:  ERR_MEMORY
         ERR_NOSUPPORT

Edité:  Informations sur les TAGS (code d'exemple)
        Informations sur les listes (LIST2)
        Ce document a été édité dans de nombreuses parties.

@EndNode
---------------------------------------------------------------------------
@NODE "DataObjects" "Objets Basés sur des Fichiers"
@{b}
                             OBJETS BASES SUR DES FICHIERS
@{ub}

Un des problèmes avec la programmation conventionnelle de jeux est que après 
que le jeu ait été compilé, toutes les structures et les données sont souvent 
figées à leur place, impossibles à éditer du point de vue de l'utilisateur, et
n'ont aucunes possibilités d'extensions futures.

En créant un support pour les données-objets externes, on a la possibilité 
d'éditer jusqu'à 100% des données, très facilement. Cela ouvre un grand
nombre de possibilités quant à l'avenir de votre création. Même si vous
arrêtez de le développer, d'autres utilisateurs peuvent faire des 
améliorations. Par exemple:

@{b}Des Graphistes@{ub} peuvent éditer vos graphismes dans tous les domaines,
en leur donnant par exemple la qualité 24 bits, en changeant la résolution 
320x256 en 1280x1024, en modifiant la taille ou le nombre d'images d'une
animation en "clippant" vos BOBs, en ajoutant ou changeant des commandes dans
la Rasterlist et ainsi de suite.

@{b}Des Programmeurs@{ub} peuvent changer des parties existantes du code en
créant de nouveaux effets, en améliorant la compatibilité, en rendant les 
sections critiques plus rapides et plus généralement en changeant tout ce que
vous leur permettez de modifier.

@{b}Des Joueurs@{ub} peuvent créer de nouveaux niveaux, changer la logique
des ennemis, les caractéristiques du jeu, et éditer le jeu pour qu'il leur
convienne mieux.

@{b}
                          LE FORMAT DES FICHIERS-OBJETS
@{ub}

Les données objets sont compilées en fichiers segmentés Amiga standards. Le 
meilleur moyen d'apprendre la manière dont ils fonctionnent est d'en 
étudier un. Voici donc un exemple d'un Screen et d'une Picture qui se 
trouvent dans un fichier objet:


	INCDIR	"GMSDev:Includes/"
	INCLUDE	"games/dpkernel.i"

	SECTION	"Start",DATA

   ;Tous les fichiers objets commencent avec "OBJF" puis viennent immédatement
   ;après les données objets.

Objects:
	dc.l	"OBJF"           ;Identification du fichier.

	;L'objet Screen débute avec l'indispensable "object header", qui
	;contient le nom de l'objet en question. Vous avez besoin de vous 
	;rappeler le nom de tous vos objets car c'est le seul moyen de les
	;identifier correctement.them. Les données de la structure viennent
	;ensuite dans la section de données.

OBJ_Screen:
	dc.l	"TAGS"           ;Type de l'Objet.
	dc.l	OBJ_Picture      ;Pointeur vers l'Objet suivant.
	dc.b	"Screen",0       ;Nom.
	even
.data	dc.l	TAGS_SCREEN,0
	dc.l	GSA_AmtColours,16
	dc.l	GSA_ScrWidth,640
	dc.l	GSA_ScrHeight,256
	dc.l	GSA_Attrib,CENTRE
	dc.l	GSA_ScrMode,HIRES|LACED
	dc.l	TAGEND

	;La disposition de l'Objet Picture est identique à celle du Screen
	;nous avons juste changé le nom et entré la structure correcte de 
	;données.

OBJ_Picture:
	dc.l	"TAGS"           ;Type de l'Object.
	dc.l	End              ;Pointeur vers le prochain Objet.
	dc.b	"Picture",0      ;Nom.
	even
.data	dc.l	TAGS_PICTURE,0
	dc.l	PCA_AmtColours,16
	dc.l	PCA_Width,640
	dc.l	PCA_Height,256
	dc.l	PCA_ScrMode,HIRES|LACED
	dc.l	PCA_Options,IMG_RESIZE
	dc.l	PCA_File,.file
	dc.l	TAGEND

.file	FILENAME "GMS:demos/data/IFF.Pic640x256"

	;Toutes les Listes doivent se terminer avec "OEND".

End:	dc.l	"OEND"

                                 ---FIN---

Il y aura un éditeur pour les fichiers objets, ainsi tout le monde sera capable
de les créer et de les éditer avec une interface GUI plutôt qu'en assembleur. 

@{b}
                      RECUPERER DES DONNEES D'UN FICHIER OBJET
@{ub}

Vous pouvez récupérer un pointeur vers un objet en chargeant d'abord le fichier,
et ensuite en utilisant la fonction GetObject(). Tout ce que vous avez à
faire est de fournir le nom de l'objet que vous voulez récupérer et cette
fonction le fera pour vous. 

Notez que les structures identifiables par Tags (eg TAGS_SCREEN) seront
pré-traitées par GetObject(), donc dans ce cas il vous sera retourné une
structure Screen qui contient déjà les valeurs de la Liste de Tags. Votre
prochaine étape sera d'écrire vos propres champs et ensuite d'appeler Init()
pour terminer votre processus d'initialisation.

Si vous voulez retrouver plus d'un objet vous pouvez utiliser une liste 
d'objet. C'est une liste spécialement créée pour la fonction GetObjectList().
Elle ressemble à peu près à cela:

	dc.l	OBJECTLIST,0
	dc.l	<Nom>,<Objet>
	dc.l	...
	dc.l	LISTEND

<Nom> pointe sur le nom de l'objet que vous voulez retrouver. <Objet> sera
initialisé par la fonction GetObjectList(), ie il pointera vers l'objet si
il le retrouve. Normalement vous devez mettre ce champ à NULL avant d'appeler
la fonction, si vous placez quelque chose dans ce champ, GetObjectList()
l'ignorera. Vous pouvez aussi mélanger différents types d'objets dans la
même liste par exemple des BOBS et des sons peuvent être retrouvés par
un seul appel.


@EndNode
---------------------------------------------------------------------------
@NODE "Structures" "Organisation des Structures"

                             @{b}ORGANISATION DES STRUCTURES@{ub}

Les structures GMS ont un point commun: Elles commencent toutes par
un header système standard, suivi par des paramètres propres à chaque
type de structure.

Le header de la structure ressemble à cela:

    STRUCTURE	Head,0
  WORD	   HEAD_ID
  WORD	   HEAD_Version
  APTR	   HEAD_SysObject
  APTR	   HEAD_Stats
  LABEL   HEAD_SIZEOF

L'ID est contitué d'un identificateur d'objet de la taille d'un mot. Un
example pour les Screens est ID_SCREEN. L'ID est important uniquement pour
identifier la classe à laquelle l'objet appartient. Toutes les fois que
nous voudrons identifier un objet le plus rapidement possible c'est ici
que nous regarderons en premier. Evidemment il est important que l'ID soit
correct à chaque fois, autrement vous pouvez induire en erreur le système 
assez rapidement.

L'ID est aussi utilisé pour d'autres choses que l'examen des structures.
En exemple on peut citer le LIST ID header, qui dit à une fonction qu'elle
a besoin d'accomplir la même action sur deux ou plusieurs structures
(Vous pouvez en apprendre plus sur le sujet dans les @{"Listes" LINK "Lists"}).

Le champ Version peut être utilisé dans des tables de saut pour traiter
les différents types de structures et gérer les expansions futures des
structures. Il commence à 1 et va en augmentant.

Le champ Stats est réservé pour une utilisation bas niveau du système
et ne peut être lu par des programmes normaux.

La champ SysObject pointe vers le détail de la classe de l'objet et ne
doit pas être lu à moins de savoir ce que l'on fait. Il ne servira pas
à 99% des développeurs mais il est très important pour le système, donc
essayer de ne pas le tripatouiller.


                       @{b}AUTO-INITIALISATION DES STRUCTURES@{ub}


Une politique standard dans GMS pour l'initialisation est d'initialiser
tous les paramètres vides soit aux valeurs par défaut de l'utilisateur
soit aux valeurs déterminées par un quelconque paramètre qui leur est lié.
Par exemple, omettre les valeurs Width et Height d'un écran va avoir 
pour conséquence l'ouverture de l'écran avec les paramètres par défaut 
Width et Height de l'utilisateur. D'un autre côté si vous aviez oublié
de spécifier Width et Height du bitmap fils, alors ils auraient hérité des
valeurs présentes dans Width et Height de l'écran père.

Quelques fois si il y a un fichier présent, les valeurs proviendront du 
header de la structure de ce fichier. Par exemple une image IFF remplira
les paramètres vides d'une structure Picture.

Les seuls champs qui ne sont pas automatiquement initialisés sont ceux qui 
contiennent les flags de programmation (Attrib, Option) et les champs de 
données.


                           @{b}COMPATIBILITE FUTURE@{ub}


Il est interdit de définir une structure dans votre code et de la compiler
dans le fichier binaire final. Le seul moyen d'obtenir légalement une 
structure est de faire un appel à Get() ou à Init(). Cette règle permet
de résoudre tous les futurs problèmes de compatibilité liés à la gestion
des structures et à l'augmentation de taille.

@EndNode
---------------------------------------------------------------------------
@Node "Lists" "Listes"
@{b}
                                   LISTES
@{ub}

Les listes sont prévues pour traiter 2 ou plusieurs structures dans la même 
fonction. C'est le moyen le plus rapide d'appliquer une fonction à 2 ou 
plusieurs structures sans avoir à faire tout un tas d'appels à la fonction.
Supposons que vous vouliez charger 10 sons depuis votre disque dur en 
utilisant Init(). Normalement Init() prend en paramètre un objet standard, 
mais elle peut aussi identifier une liste en vérifiant le header 
d'IDentification.

Comme illustration voici une liste typique d'initialisation/chargement
de sons:


SoundList:
	dc.l	LIST1               ;Header d'IDentification de la liste.
	dc.l	SND_Boom            ;Pointeurs vers chaques sons à charger et
	dc.l	SND_Crash           ;à initialiser.
	dc.l	SND_Bang
	dc.l	SND_Ping
	dc.l	SND_Zoom
	dc.l	SND_Zig
	dc.l	SND_Zag
	dc.l	SND_Wang
	dc.l	SND_Whump
	dc.l	SND_Bong
	dc.l	LISTEND             ;Indique la fin de la liste.

Lorsque vous voulez charger tous vos sons utilisez simplement la routine qui
suit:

   move.l  DPKBase(pc),a6
   lea     SoundList(pc),a0    ;a0 = Pointeur vers la liste des sons (Soundlist).
   sub.l   a1,a1
   CALL    Init
   tst.l   d0
   bne.s   .error

Ou:	if (Init(&SoundList,NULL) IS NULL) {
	   return(ERR_FAILED);
        }

Certaines fonctions sont spécialement écrites pour recevoir en paramètre
exclusivement des listes, eg DrawBobList(). C'est exclusivement pour des
raisons de vitesse car on ne veut pas gaspiller du temps à vérifier si
on traite une liste ou une structure dans des situations où le temps
machine est compté.

Il y a un second type de Listes qui s'appelle LIST2. C'est une liste spéciale
prévue pour l'initialisation et la libération de processus et elle ressemble
à cela:

List:	dc.l	LIST2,NULL
	dc.l	<TagList>,<Object>
	dc.l	LISTEND

L'avantage de cette liste est que vous pouvez spécifier des Tags sur la
gauche, ainsi dés que vous appelez Init() elle place les pointeurs vers
les objets alloués à droite. Cela rend les choses un peu plus facile lorsque
vous voulez libérer (Free()) tous vos pointerus vers les objets.

Voilà qui résume à peu près les Listes. Vous pourriez être intéressé de
savoir que l'environement GMS est le seul système qui utilise les structures
de cette façon. Vous en apprendrez plus sur l'aide qu'apportent les listes
et les champs d'ID dans les autres parties de la documentation.

@EndNode
---------------------------------------------------------------------------
@NODE "Tags" "Tags"
@{b}
                             TAGS ET LISTES DE TAGS
@{ub}


Les Tags sont supportés d'une manière qui est proche de celle de l'Amiga
OS. La principale différence est que le nouveau design leur permet d'être
traitée un peu plus vite. 

Les Tags vous permettent de supporter toutes les prochaines versions des
structures, et ils sont pratiques si vous utilisez le C. Du fait que les 
structures pré-compilées sont interdites dans GMS, vous devrez utiliser 
assez souvent les Tags. Regardez bien les sources des démos pour comprendre
leur utilisation. Les fonctions les plus importantes utilisant les Tags sont
Init(), ou pour les programmeurs C InitTags(). Il n'y a pas beaucoup d'autres
fonctions qui ont besoin d'un usage intensifs des listes de Tags.

Vu du plus bas niveau les Tags sont représentés comme suit: 

	dc.l	TAGS_ID,<Structure>
	dc.l	<ti_Tag>,<ti_Data>
	dc.l	TAGEND

Exemple:

	dc.l	TAGS_SCREEN,NULL
	dc.l	GSA_Width,320
	dc.l	GSA_Height,256
	dc.l	TAGEND

Si vous omettez de donner un pointeur de structure (comme dans cet exemple,
la structure sera allouée pour vous, via un appel à Get(). Cette structure
sera placée dans le pointeur de structure dans votre liste de Tag (utile
pour les programmeurs en assembleur), et sera donc retournée par la fonction.
Si l'appel à un Tag retourne NULL alors c'est qu'une erreur s'est produite 
et que l'appel a échoué. Pour trouver la raison de cet échec vous devrez
utiliser un debugger système tel que IceBreaker.

Voici comment utiliser les Tags en C:

      struct Screen *Screen;

      if (Screen = InitTags(NULL,
           TAGS_SCREEN,   NULL,
           GSA_Palette,   Palette,
           GSA_ScrMode,   LORES,
           GSA_ScrWidth,  320,
           GSA_ScrHeight, 256,
           GSA_ScrAttrib, DBLBUFFER,
           TAGEND)) {

         /* Mettre le code ici */

      Free(Screen);
      }

@{b}@{u}SE DEPLACER DANS LES OBJET FILS@{uu}@{ub}
Une caractéristique intéressante et importante des Tags est que vous pouvez
"marcher" dans les objets fils. Par exemple l'objet CardSet a ces propres
champs, mais comme il est basé sur l'objet Bob, il hérite aussi des champs
du Bob et de ses fonctionnalités. Maintenant si vous initialisez votre
objet CardSet, vous pouvez vouloir définir des quelques uns de champs du
Bob tels que les coordonnées X et Y. Mais comment faites vous si ces champs
se trouvent dans une structure sous-jacente? Voici la solution:

      struct CardSet *CardSet;

      if (CardSet = InitTags(NULL,
           TAGS_CARDSET,  NULL,
           CSA_Source,    file_CardSet,
             CSA_BobTags,   NULL,      <- Gagne l'accès à l'objet Bob.
             BBA_XCoord,    100,       <- Définit la coordonnée X du Bob.
             BBA_YCoord,    125,       <- Définit la coordonnée Y du Bob.
             TAGEND,        NULL,      <- Retourne aux Tags du CardSet.
           TAGEND)) {

         /* Code  */

      Free(CardSet);
      }

Notez comment le préfixe pour les Tags change de CSA_ à BBA_ une fois que
nous sommes entrés dans l'objet Bob, et que nous avons terminé la section Bob
avec TAGEND et NULL. Nous avons aussi indenté la liste pour voir clairement
que la liste de Tags se déplaçait dans un objet fils.

@{b}@{u}FLAGS SPECIAUX@{uu}@{ub}
Finalement il y a quelques flags spéciaux que vous pouvez utiliser pour
une gestion avancée des Tags. Il est peu problable que vous ayez à les 
utiliser, mais ils sont disponibles si vous en avez besoin. Ces flags
sont identifiés dans ti_Tag, les voici:

TAG_IGNORE - Saute vers le prochain Tag.

TAG_MORE   - Termine la TagList courante et commence une nouvelle (pointée
             par le champ ti_Data).

TAG_SKIP   - Saute le ti_data courant et le prochain.

C'est tout ce que vous avez besoin de savoir, rappelez vous juste qu'il faut 
terminer tous vos appels à des tags avec TAGEND.

@EndNode
---------------------------------------------------------------------------
@NODE "ErrorCodes" "Codes d'Erreurs"

                                @{b}CODES D'ERREURS@{ub}


Un panel universel de codes d'erreurs est utilisé par les fonctions qui
retournent un @{i}ErrorCode@{ui}. Cela vous permet d'identifier facilement 
les erreurs et de résoudre les problèmes lorqu'ils surviennent. Les codes
d'erreur sont envoyés à IceBreaker avec une description complète, donc
utilisez ce programme si vous voulez identifier facilement les erreurs.
Voici une description des codes d'erreur actuels et ce qu'ils signifient:


@{b}[0] ERR_OK@{ub}
Aucune erreur, la fonction s'est éxécutée correctement.

@{b}[1] ERR_NOMEM@{ub}
Pas assez de mémoire était disponible lorsque la fonction a essayé d'allouer 
un bloc mémoire.

@{b}[2] ERR_NOPTR@{ub}
Un pointeur d'adresse requis n'était pas présent.

@{b}[3] ERR_INUSE@{ub}
La structure a déjà des allocations précédentes qui n'ont pas été libérées.

@{b}[4] ERR_STRUCT@{ub}
Vous avez donné à la fonction une version d'une structure qui n'est pas
supportée, ou vous avez donné une adresse mémoire non-identifiable..

@{b}[5] ERR_FAILED@{ub}
Un problème non spécifié s'est produit.

@{b}[6] ERR_FILE@{ub}
Erreur de fichier non-spécifiée, ex fichier non trouvé, disque plein etc...

@{b}[7] ERR_DATA@{ub}
Cette fonction a rencontré des données qui ont des erreurs irrécupérables.

@{b}[8] ERR_SEARCH@{ub}
Une recherche interne s'est produite et a échouée. C'est une erreur spécifique
qui peut se produire quand la fonction est en train de rechercher quelque chose 
dans des file headers, ex la section BODY d'un fichier IFF.

@{b}[9] ERR_TYPE@{ub}
Type de Bitmap non reconnu ou non supporté, ex à l'heure actuelle les modes True
Colour ne sont pas disponibles.

@{b}[10] ERR_MODULE@{ub}
La fonction a essayé d'initialiser un module et a échouée.

@{b}[11] ERR_RASTCOMMAND@{ub}
Une commande raster invalide a été détectée. Vérifiez votre rasterlist et
regardez si elle se termine bien par RASTEND.

@{b}[12] ERR_RASTERLIST@{ub}
Echec total de la rasterlist. Vous avez essayez de faire quelque chose qui
est impossible dans les conditions actuelles.

@{b}[13] ERR_NORASTER@{ub}
Aucun objet raster n'a été trouvé dans Screen->Raster.

@{b}[14] ERR_DISKFULL@{ub}
Le Disque est plein, il est temps de faire un peu de place.

@{b}[15] ERR_FILEMISSING@{ub}
Fichier non trouvé, cela se produit lorsqu'un FileName référence un
fichier qui n'existe pas.

@{b}[16] ERR_WRONGVER@{ub}
Mauvaise version ou version non supportée.

@{b}[17] ERR_MONITOR@{ub}
Pilote du Moniteur non trouvé ou non supporté.

@{b}[18] ERR_UNPACK@{ub}
Problème avec le décompactage des données.

@{b}[19] ERR_ARGS@{ub}
Vous avez essayé de passer des arguments invalides à cette fonction tels
qu'une valeur NULL là où vous deviez placé un pointeur.

@{b}[20] ERR_NODATA@{ub}
Cette fonction attendait certaines données que vous ne lui avez pas
fournies.

@{b}[21] ERR_READ@{ub}
Se produit si vous essayez de lire un fichier et q'une erreur apparait.
Peut-être n'y a t'il plus rien à lire, ou bien l'objet File a été invalidé,
ou bien il y a des erreurs de surface sur le media en question.

@{b}[22] ERR_WRITE@{ub}
Se produit si vous essayez d'écrire sur un fichier et q'une erreur apparait.
Habituellement cela est du à un problème de hardware tel que un manque
d'espace ou une erreur de surface.

@{b}[23] ERR_LOCK@{ub}
Cette erreur peut se produire si vous essayez de bloquer un objet qui est
déjà bloqué par une autre tâche, ou si vous bloquez un objet qui n'existe
pas.

@{b}[24] ERR_EXAMINE@{ub}
Cette erreur s'applique aux fichiers et aux répertoires. Elle peut se
produire pour toutes sortes de raisons, une cause probable pourrait être
la corruption/invalidité d'une partie de la structure du disque.

@{b}[25] ERR_LOSTCLASS@{ub}
C'est une erreur très sérieuse qui se produit si un objet perd sa référence
envers son SysObject. Cela signifie que l'Object->Head.SysObject a été
effacé ou invalidé.

@{b}[26] ERR_NOACTION@{ub}
Si vous appelez une action sur un objet et si cet objet ne la supporte pas
alors vous recevrez ce message. Un example pourrait être:

  Draw(Segment);

@{b}[27] ERR_NOSUPPORT@{ub}
Peut arriver si un objet n'est pas initialisé avec succès, ce qui est
souvent due à un format de donnée non supporté.

@{b}[28] ERR_MEMORY@{ub}
Erreur générale de mémoire, telle que aucune mémoire disponible ou mémoire
trop fragmentée.

@EndNode
---------------------------------------------------------------------------
@NODE "DataChecking" "Vérification des Données"
@{b}
                          VERIFICATION DES DONNEES

                                    ET

                           VALIDATION DES PROCEDURES
@{ub}

Ce système a été créé pour permettre l'inclusion de mécanismes simples
et efficaces de vérification de données. Toutes les fonctions basées sur
le noyau supportent le null handling, la vérification et la validation
des données. Du fait de la présence de IceBreaker vous pouvez rapidement
trouver l'endroit où votre programme a foiré car les fonctions vous 
reportent directement leurs erreurs en anglais (et non pas des codes d'erreur
ou des numéros de "software failure").

@{b}
                            PROTECTION CONTRE LE PLANTAGE
@{ub}

L'exemple le plus simple de protection contre le plantage qui a déja été
mentionné est celui des fonctions qui vérifient qu'on leur a bien passé
les structures de données correctes avant de faire quoi que se soit d'autre.
Cela offre au programmeur plus de sécurité lors du développement car passer
un mauvais argument à une fonction est fréquent et peut souvent avoir pour
conséquence un désastre. Dans le passé la protection contre de telles actions
a été employée au niveau des langages de compilation, telle que la
vérification de type du C. Cependant un problème évident est que cela
ne fournit aucune assurance sur le fait que vous passiez le bon argument;
il n'y a aucun moyen de savoir si les données ont été traitées, si le
pointeur pointe simplement vers la mauvaise structure ou si il n'a pas
été initialisé correctement au départ.

C'est pourquoi le seul moyen de protéger un système et le programmeur 
contre de tels incidents est au niveau des fonctions, là où la validité
des données est vérifiée et de ne pas continuer tant que celles-ci n'ont
pas passés les différents tests. Cela ne veut pas dire qu'il faut vérifier
chaque champ, un simple test d'ID est suffisant à ce stade. Etonnement
très peu voir même aucun autre système ne propose de telles propriétés.

D'autres protection contre le plantage incluent des protections mémoires
basées sur logiciel. Cela est différent des protections mémoire hardware
qui requiert l'addition d'une MMU. Bien que la protection mémoire logicielle
sera toujours moins rigoureuse que celle hardware, elle a l'avantage d'être
capable de gérer les erreurs d'une manière plus confortable, au lieu de
générer des exceptions qui résultent souvent en une destruction du
programme par l'OS. Un bon exemple de tout cela est la fonction TagInit().

TagInit() prend une structure vide et une liste de tags, traite ceux-ci
et écrit le résultat dans la structure donnée. La procédure utilisée pour
faire cela est directe et demande que peu d'instructions assembleur.
Cependant si la liste de Tags contient des valeurs fausses, rien ne peut
empêcher l'écriture de données au-delà des limites mémoires de la structure.
Pour empêcher cela TagInit() trouve la taille de la structure destination
et la compare à la destination donnée dans chaque Tag. Si un problème survient,
la fonction stoppe les opérations, envoie un message informatif à 
IceBreaker et retourne au programme avec un message d'erreur. Le programmme
peut alors se terminer de lui-même et le programmeur peut trouver
immédiatement ce qui n'allait pas sans avoir de "codes d'exception à
l'adresse $xxx" et une liste incomprehensible de registres assembleurs.

@{b}
                        INTERFERENCE DE DONNEES
@{ub}

Il y a deux types d'interférences de données: une interférence 'accidentelle'
(qui est le résultat d'une erreur de programmation) et l'interférence 
'délibérée' (vous modifiez les données d'un programme volontairement).

Beaucoup d'objets et de fonctions GMS proposent cette dernière caractèristique.
Lorsqu'une routine système trouve une valeur de donnée qui est érronée
ou extrèmement inappropriée, elle sera changée. Ainsi un programme ne se
crache pas ou ne se termine pas brusquement pour de simples erreurs. Par
exemple on peut vouloir ouvrir un écran de 640x1024 alors que le système
de l'utilisateur ne supporte que 640x512. Dans ce cas l'objet Screen verra
sa taille modifiée de manière à être ouvert à la taille correcte. Pour
alerter le programme de l'erreur, un message sera envoyé au debugger système.
Dans l'AmigaOS actuel cette vérification ne se produit jamais, et ce problème
se rencontre avec des fenêtre qui s'ouvrent à des tailles qui ne tiennent
pas dans l'écran.

Voici un second exemple:

Disons qu'un programmeur était en train de charger une image de 4 plans de 
profondeur. Bien que cela soit spécifié dans la structure Picture il oublie
de définir le type d'écran en ILBM. Du fait que cela était précisé dans les
préférences de GMSPrefs tout marche comme si de rien n'était. Plus tard un
utilisateur essaie le programme avec une préférence en CHUNKY8. Normalement
cela devrait crasher le système ou bien faire que la programme ne marche 
jamais car un écran en CHUNKY8 ne peut avoir 4 plans de profondeur. Cependant
Init(Picture) va réagir immédiatement et changer la valeur en 8. Le problème
est résolu et le programme marche très bien.

Ces types de vérifications et de comparaisons sont très souvent utilisées
et permettent d'ajouter plus de profondeur aux fonctionnalités classiques.
Un petit défaut de programmation qui ne pourrait se voir que dans les
versions futures de GMS peut donc être traité et n'occasionne aucun 
incident.


@EndNode
---------------------------------------------------------------------------
