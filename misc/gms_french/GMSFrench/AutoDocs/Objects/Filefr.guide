@DATABASE "File"
@AUTHOR   "Paul Manias"
@NODE     "Main" "Objet: File"

@{b}@{u}DOCUMENTATION SUR L'OBJET@{uu}@{ub}
Nom:        @{"FILE" LINK "Description"}
Version:    0.9
Date:       Decembre 1997
Auteur:     Paul Manias
Traducteur: Julien Boibessot
Copyright:  DreamWorld Productions, 1996-1997. Tous droits réservés.

@{b}@{u}CHANGEMENTS DANS LA VERSION 0.9B@{uu}@{ub}
Ajouté:  Query() supporte les listes.
         File->Permissions

Edité:  File->Comment
        File->Date

@EndNode
---------------------------------------------------------------------
------
@NODE "Description" "Objet: File"

@{b}@{u}OBJET@{uu}@{ub}
Nom:     File
Module:  @{"Files" LINK "GMSDev:AutoDocs/Filesfr.guide/Functions"}
Version: 1
Type:    Simple

@{b}@{u}DESCRIPTION@{uu}@{ub}
L'objet File est utilisé pour la gestion de base des fichiers. Au 
contraire
d'AmigaDOS la gestion fichier de GMS permet de trouver de nombreux
details sur un fichier, sans efforts, grâce à l'utilisation de cette
structure.

Les fichiers supportent le décompactage et la recherche automatiques.
Comme tous les objets sont tracés il n'y a aucune chance que le 
système
oublie de fermer un fichier.

@{b}@{u}ACTIONS@{ub}@{uu}
L'objet File supporte les actions suivantes:

     @{"Free() " LINK "GMSDev:AutoDocs/Kernelfr.guide/Free()"} Libère 
l'objet File.
     @{"Get()  " LINK "GMSDev:AutoDocs/Kernelfr.guide/Get()" } 
Obtient une structure File.
     @{"Init() " LINK "GMSDev:AutoDocs/Kernelfr.guide/Init()"} 
Initialise un File.
     @{"Query()" LINK "GMSDev:AutoDocs/Kernelfr.guide/Query()"} 
Obtient des informations sur un fichier.

@{b}@{u}FONCTIONS@{ub}@{uu}
Quelques unes des fonctions relatives aux fichiers sont:

     @{"OpenFile() " LINK "GMSDev:AutoDocs/Filesfr.guide/OpenFile()" 
} Prepare un fichier pour sa lecture et son 
ecriture.
     @{"ReadFile() " LINK "GMSDev:AutoDocs/Filesfr.guide/ReadFile()" 
} Lit des données dans un fichier.
     @{"WriteFile()" LINK 
"GMSDev:AutoDocs/Filesfr.guide/WriteFile()"} Ecrit des données dans 
un fichier.

@{b}STRUCTURE@{ub}
La structure File (Fichier) est constituée des champs suivant:

     @{"BytePos   " LINK "FILE_BytePos"  } Position courante dans le 
fichier.
     @{"Comment   " LINK "FILE_Comment"  } Commentaires pour le 
fichier, s'ils existent.
     @{"Date      " LINK "FILE_Date     "} Pointeur vers la date de 
la dernière modification.
     @{"Flags     " LINK "FILE_Flags"    } Flags du fichier et 
options.
     @{"Next      " LINK "FILE_Next"     } Prochain fichier dans la 
chaine (répertoire).
     @{"Permissions" LINK "FILE_Permissions"} RWED et autres flags de 
permission.
     @{"Prev      " LINK "FILE_Prev"     } Fichier précédent dans la 
chaine (répertoire).
     @{"Size      " LINK "FILE_Size"     } Taille totale du fichier.
     @{"Source    " LINK "FILE_Source"   } Pointeur vers la source du 
fichier.

@EndNode
---------------------------------------------------------------------
------
@NODE "FILE_BytePos" "Objet: File"

@{b}@{u}CHAMP@{uu}@{ub}
Nom:          BytePos
Type:         LONG
Intervalle:   Entre 0 et File->Size
Modification: Dynamique
Status:       Lecture/Ecriture

@{b}@{u}DESCRIPTION@{uu}@{ub}
Spécifie la position courante en octets dans le fichier ouvert. Vous 
pouvez changer cette valeur pour lire ou écrire en différentes 
positions du fichier. 

@EndNode
---------------------------------------------------------------------
------
@NODE "FILE_Comment" "Objet: File"

@{b}@{u}CHAMP@{uu}@{ub}
Nom:           Comment
Type:          BYTE *
Héritage:      Obtenu du fichier stocké, si possible.
Modification:  SetFileComment()
Status:        Lecture/IEcriture

@{b}@{u}DESCRIPTION@{uu}@{ub}
Ce champ pointe sur une chaine de caractères qui contient un 
commentaire de l'utilisateur pour le fichier. Bien que l'objet File 
supporte des commentaires d'une taille illimitée, le file-system lui-
même coupera le commentaire à partir d'un certain point. Il serait 
peu prudent de penser disposer de plus de 128 octets. Si lors de 
l'écriture d'un nouveau commentaire vous dépassez cette limite, les 
caractères supplémentaires seront ignorés.

@{b}@{u}NOTE@{uu}@{ub}
Si vous initialisez un fichier existant et définissez un commentaire
l'ancien commentaire (du file system) sera écrasé par le nouveau.

@EndNode
---------------------------------------------------------------------
------
@NODE "FILE_Date" "Objet: File"

@{b}@{u}CHAMP@{uu}@{ub}
Nom:              DateStamp
Type:             struct Time *
Héritage:         Obtenu du fichier stocké, si possible.
Pour le modifier: SetFileDate()
Status:           Lecture/IEcriture

@{b}@{u}DESCRIPTION@{uu}@{ub}
Ce champ pointe sur un objet Time qui spécifie la date à laquelle le 
fichier a été modifié pour la dernière fois.

@{b}@{u}NOTE@{uu}@{ub}
Si vous utilisez Init() sur un fichier qui existe déjà sur disk et si
vous spécifiez une Date alors l'ancienne date sera écrasée par la 
nouvelle.

@EndNode
---------------------------------------------------------------------
------
@NODE "FILE_Flags" "Objet: File"

@{b}@{u}CHAMP@{uu}@{ub}
Nom:          Flags
Type:         LONG
Modification: Ne peut être modifié dynamiquement.
Status:       Lecture/IEcriture.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Ce champ spécifie la commande à utiliser lors de l'ouverture du 
fichier. Après l'ouverture de votre fichier vous ne devez vous 
référer à ce champ que dans un but d'historique.

Voici les flags que vous pouvez spécifier - ce sont les mêmes flags 
que vous pouvez utiliser dans OpenFile().

@{u}FL_READ@{uu}
Ce flag est celui par défaut et ouvre le fichier pour y lire des 
données.

@{u}FL_WRITE@{uu}
Prépare le fichier pour y écrire des données en partant de la 
position
0. Si vous voulez commencer à écrire depuis la fin du fichier, copiez 
la
valeur File->Size dans File->BytePos après que OpenFile() est été 
lancée
avec succès.

@{u}FL_LOCK@{uu}
Définir celui-ci va verrouiller le fichier pour permettre un accès 
exclusif
ie aucun autre processus ne sera capable d'ouvrir le fichier pendant 
que
vous l'utilisez. Si ce flag n'est pas défini alors le fichier sera 
ouvert
en accès partagé. Essayer de verrouiller un fichier qui a été ouvert 
en accès
partagé résultera en un échec.

@{u}FL_FIND@{uu}
Ce flag permet à OpenFile d'user de son intelligence et d'essayer de
trouver le fichier si celui-ci n'est pas dans le chemin indiqué. 	Le 
processus comprend une recherche dans l'arboresence, simple mais 	
puissante.

@{u}Exemple@{uu}
Vous essayez de charger le fichier Game:Data/PIC.Crocodile. Cependant
l'assignement Games: n'existe pas. Vous êtes parti du répertoire
HD1:Game/Data/  qui est un répertoire au dessus de l'assignement 	
requis.
OpenFile() va trouver le fichier en éxécutant la procédure suivante:

Open -	Game:Data/PIC.Crocodile (ECHEC)
		Data/PIC.Crocodile      (ECHEC - 
HD1:Game/Data/Data/PIC.Crocodile)
		PIC.Crocodile           (REUSSITE - 
HD1:Game/Data/PIC.Crocodile)

@{u}Note@{uu}
La possibilité de trouver un fichier est limitée à une recherche 
locale,
il n'y aura pas d'essais de recherche dans l'arborescence de tous les 
répertoires d'un assignement (c'est trop long).

@{u}FL_NOUNPACK/FL_NOPACK@{uu}
Si vous ne voulez pas utiliser les modes de compactage/décompactage 
sur
votre fichier vous devez spécifiez ces flags. Dans la plupart des
circonstances vous ne devez jamais définir ces flags car si 
l'utilisateur
veut utiliser ou non la compression il peut le dire dans les 
préférences.

@{u}FL_NOBUFFER@{uu}
Définir ce flag empêche le fichier d'être placé dans le cache. Cela 
est
impératif si vous voulez que le fichier reflètee son contenu à tout
moment.

@EndNode
---------------------------------------------------------------------
------
@NODE "FILE_Next" "OBJET: File"

@{b}@{u}CHAMP@{uu}@{ub}
Nom:          Next
Type:         struct File *
Héritage:     Les liens sont formés automatiquement lors du listing
              des répertoires.
Modification: Dynamique
Status:       Lecture seulement.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Le champ Next est généralement utilisé pour construire des structures 
de
répertoires. Par exemple si vous appliquez Activate() sur un objet
Directory elle va construire une liste de tous les fichiers dans ce
répertoire et pointer vers le premier fichier de la liste. Tous les 
fichiers
suivant seront rejoints grâce au champ Next.

Vous pouvez détacher un fichier de la chaine en utilisant 
@{"Detach()" LINK "GMSDev:AutoDocs/Kernel.guide/Detach()"}.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Champ:  @{"Prev"     LINK "FILE_Prev"}
Kernel: @{"Detach()" LINK "GMSDev:AutoDocs/Kernelfr.guide/Detach()"}

@EndNode
---------------------------------------------------------------------
------
@NODE "FILE_Permissions" "Object: File"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Permissions
Type:        LONG
Inheritance: Init()
Default:     FPF_READ|FPF_WRITE|FPF_DELETE
Status:      Read/IWrite

@{b}@{u}DESCRIPTION@{uu}@{ub}
Ce champ de permission donne des informations sur les droits de 
l'utilisateur vis à vis d'un répertoire ou d'un fichier particulier.
Les Flags actuellement disponibles sont:

@{u}FPF_HIDDEN@{uu}
Si le fichier doit être caché à cet utilisateur.

@{u}FPF_DELETE@{uu}
Si l'utilisateur a le droit d'effacer ce fichier.

@{u}FPF_EXECUTE@{uu}
Les droits d'éxécution ne peuvent être donnés qu'aux fichiers 
éxécutables et aux scripts.

@{u}FPF_PASSWORD@{uu}
C'est un flag spécial qui peut verrouiller un fichier jusqu'à ce que
le mot de passe adequat soit donné. Notez que le support de ce flag 
est toujours en cours et que la plupart des file-systems actuels ne 
peuvent le supporter directement.

@{u}FPF_READ@{uu}
Ce flag  permet à l'utilisateur de lire le fichier afin d'avoir accès 
à son contenu. Notez que l'accès à la lecture ne donne pas accès à 
l'éxécution.

@{u}FPF_SCRIPT@{uu}
Des fichiers texte standards qui sont définis avec ce flag seront 
traités comme des scripts qui sont capables d'éxécuter de multiples 
commandes. Vous aurez besoin de définir ce flag en conjonction avec  
EXECUTE afin d'éxécuter le script.

@{u}FPF_WRITE@{uu}
Ce flag permet à l'utilisateur d'écrire des données dans le fichier. 
Même si cela ne donne pas accès à l'effaçage soyez conscient qu'il 
est possible de ramener la taille d'un fichier à 0 octets.

@EndNode
---------------------------------------------------------------------
------

@NODE "FILE_Prev" "OBJET: File"

@{b}@{u}CHAMP@{uu}@{ub}
Nom:          Prev
Type:         struct File *
Héritage:     Les liens sont formés automatiquement lors du listing
              des répertoires.
Modification: Dynamique.
Status:       Lecture/Ecriture

@{b}@{u}DESCRIPTION@{uu}@{ub}
Le champ Prev est généralement impliqué lors de la construction des 
structures répertoires. Par exemple, si vous appliquez Activate() à 
un objet Directory elle va construire une liste de tous les Fichiers 
dans ce Répertoire et pointer vers le premier Fichier dans la liste. 
Le champ Prev va permettre la remontée dans cette liste chainée.

Vous pouvez détacher un Fichier de la chaine en utilisant l'action 
Detach().

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Champ:  @{"Next"     LINK "FILE_Next"}
Kernel: @{"Detach()" LINK "GMSDev:AutoDocs/Kernelfr.guide/Detach()"}

@EndNode
---------------------------------------------------------------------
------
@NODE "FILE_Size" "OBJET: File"

@{b}@{u}CHAMP@{uu}@{ub}
Nom:          Size
Type:         LONG
Héritage:     Init()
Status:       Lecture seulement.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Spécifie la taille courante en octets du fichier ouvert. Ce champ ne 
peut être changé que si lors d'un appel à WriteFile() la taille du 
fichier requiert une augmentation. Il ne peut être modifié 
dynamiquement et ne peut être diminué.

@EndNode
---------------------------------------------------------------------
------
@NODE "FILE_Source" "OBJET: File"

@{b}@{u}CHAMP@{uu}@{ub}
Nom:          Source
Type:         APTR
Modification: Ne peut être modifié dynamiquement.
Status:       Lecture/IEcriture.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Pointe vers un objet source qui peut être soit un nom de fichier 
(FileName), un pointeur mémoire (MemPtr) ou un objet reconnu par le 
système. La source sera utilisée pour y lire ou y écrire des données. 
Notez que FileName et MemPtr sont pleinement supportés par le 
système, à tout moment, mais tous les objets ne peuvent prétendre 
supporter les actions de Lecture/Ecriture.

@EndNode
