@DATABASE "Directory"
@AUTHOR   "Paul Manias"
@NODE     "Main" "Objet: Directory"

@{b}@{u}OBJECT DOCUMENTATION@{uu}@{ub}
Nom:        @{"DIRECTORY" LINK "Description"}
Version:    0.9 Beta.
Date:       Janvier 1998
Auteur:     Paul Manias
Traducteur: Julien Boibessot
Copyright:  DreamWorld Productions, 1996-1997. Tous Droits Réservés.
Notes:      Ce document est en cours d'écriture.

@{b}@{u}CHANGEMENTS DANS LA VERSION 0.9B@{uu}@{ub}
Ajoutés:  Directory->ChildDir
          Directory->ChildFile
          Directory->Next
          Directory->Prev

Edités:   Directory->Comment
          Directory->Date

Renommé:  Directory->UserFlags devient Directory->Permissions

@EndNode
---------------------------------------------------------------------
------
@NODE "Description" "Objet: Directory"

@{b}@{u}OBJET@{uu}@{ub}
Nom:     Directory
Module:  @{"Files" LINK "GMSDev:AutoDocs/Filesfr.guide/Functions"}
Version: 1
Type:    Complexe

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cet object est utilisé pour la gestion des fichiers et des 
répertoires.

@{b}@{u}FONCTIONS@{ub}@{uu}
Les fonctions supportant l'objet Directory sont:

     @{"WriteComment()" LINK 
"GMSDev:AutoDocs/Filesfr.guide/WriteComment()"}
     @{"WriteDate()   " LINK 
"GMSDev:AutoDocs/Filesfr.guide/WriteDate()"}

@{b}@{u}ACTIONS@{ub}@{uu}
L'objet Directory (Répertoire) supporte les actions suivantes:

     @{"Activate()" LINK "GMSDev:AutoDocs/Kernelfr.guide/Activate()"} 
Créé un listing du répertoire.
     @{"Free()    " LINK "GMSDev:AutoDocs/Kernelfr.guide/Free()"} 
Libère l'objet Directory.
     @{"Get()     " LINK "GMSDev:AutoDocs/Kernelfr.guide/Get()" } 
Créé une nouvelle structure Directory.
     @{"Init()    " LINK "GMSDev:AutoDocs/Kernelfr.guide/Init()"} 
Initialise un Directory.

@{b}STRUCTURE@{ub}
La structure Directory comprend les champs publics suivant:

     @{"ChildDir   " LINK "DIR_ChildDir"   } Pointeur vers le premier 
sous-répertoire dans la liste.
     @{"ChildFile  " LINK "DIR_ChildFile"  } Pointeur vers le premier 
sous-fichier dans la liste.
     @{"Comment   " LINK "DIR_Comment"  } Commentaire pour le 
répertoire, si il existe.
     @{"Date      " LINK "DIR_Date     "} Pointeur vers la date de 
dernière modification.
     @{"DirList   " LINK "DIR_DirList"  } Liste des répertoires sous 
celui-ci.
     @{"FileList  " LINK "DIR_FileList" } Liste des fichiers dans ce 
répertoire.
     @{"Flags     " LINK "DIR_Flags"    } Flags et options de ce 
répertoire.
     @{"Next       " LINK "DIR_Next"       } Prochain répertoire dans 
la liste.
     @{"Prev       " LINK "DIR_Prev"       } Répertoire précédent 
dans la liste.
     @{"Source    " LINK "DIR_Source"   } Pointeur vers la source de 
Directory.
     @{"Permissions " LINK "DIR_Permissions"} Flags de permission, eg 
RWED.

@EndNode
---------------------------------------------------------------------
------
@NODE "DIR_ChildDir" "Object: Directory"

@{b}@{u}CHAMP@{uu}@{ub}
Nom:         ChildDir
Type:        struct Directory *
Héritage:    Activate()
Status:      Lecture seulement.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Ce champ pointe vers la première structure d'une liste chainée de 
sous
répertoires de votre répertoire maître. Cette liste n'est construite 
que si
vous appelez la fonction Activate(). Les structures seront Query()ser 
et
donc elles contiendront la Date, les Commentaires etc.. Vous pouvez 
les
traiter comme des objets normaux et appeler Init() et Activate() sur 
chaque
objet fils pour commencer à construire des structures d'arbre 
complexe.

Notez que quand vous libérez votre objet Directory tous les objets 
fils
de la liste chainée seront libérés. Si vous voulez garder un 
répertoire
fils vous pouvez utiliser l'action Detach(). Après que vous ayez 
extrait
votre objet vous devrez le libérer vous même (avec Free()).

Si il n'y a pas de sous-répertoires alors ce champ sera mis à NULL 
après
un Activate() ou un Query().

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Champs: @{"ChildFile" LINK "DIR_ChildFile"}
        @{"Next"      LINK "DIR_Next"}
        @{"Prev"      LINK "DIR_Prev"}

@EndNode
---------------------------------------------------------------------
------
@NODE "DIR_ChildFile" "Object: Directory"

@{b}@{u}CHAMP@{uu}@{ub}
Nom:         ChildFile
Type:        struct File *
Héritage:    Activate()
Status:      Lecture/Ecriture

@{b}@{u}DESCRIPTION@{uu}@{ub}
Ce champ pointe vers la première structure d'une liste chainée de 
sous
fichiers de votre répertoire maître. Cette liste n'est construite que 
si
vous appelez la fonction Activate(). Les structures seront Query()ser 
et
donc elles contiendront la Date, les Commentaires etc.. Vous pouvez 
les
traiter comme des objets normaux et utiliser dessus les diverses 
fonctions
pour les fichiers.

Notez que quand vous libérez votre objet Directory tous les objets 
fils
de la liste chainée seront libérés. Si vous voulez garder un fichier
fils vous pouvez utiliser l'action Detach(). Après que vous ayez 
extrait
votre objet vous devrez le libérer vous même (avec Free()).

Si il n'y a pas de sous-fichiers alors ce champ sera mis à NULL après
un Activate() ou un Query().

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Champs: @{"ChildDir" LINK "DIR_ChildDir"}
        @{"Next"     LINK "DIR_Next"}
        @{"Prev"     LINK "DIR_Prev"}

@EndNode
---------------------------------------------------------------------
------
@NODE "DIR_Comment" "Object: Directory"

@{b}@{u}CHAMP@{uu}@{ub}
Nom:         Comment
Type:        BYTE *
Héritage:    Obtenu depuis le répertoire existant, si possible.
To Change:   SetFileComment()
Status:      Lecture/IEcriture

@{b}@{u}DESCRIPTION@{uu}@{ub}
Ce champ pointe sur une chaine de caractères qui contient un 
commentaire
de l'utilisateur pour le répertoire. Bien que l'objet Directory 
supporte
des commentaires d'une taille illimitée, le file-system lui-même 
coupera
le commentaire à partir d'un certain point. Il serait peu prudent de 
penser
disposer de plus de 128 octets. Si lors de l'écriture d'un nouveau
commentaire vous dépassez cette limite, les caractères 
supplémentaires
seront ignorés.

@{b}@{u}NOTE@{uu}@{ub}
Si vous initialisez un répertoire existant et définissez un 
commentaire
l'ancien commentaire (du file system) sera écrasé par le nouveau.

@EndNode
---------------------------------------------------------------------
------
@NODE "DIR_Date" "Object: Directory"

@{b}@{u}CHAMP@{uu}@{ub}
Nom:            DateStamp
Type:           struct Time *
Héritage:       Obtenu depuis le répertoire existant, si possible.
Modification:   SetFileDate()
Status:         Lecture/IEcriture

@{b}@{u}DESCRIPTION@{uu}@{ub}
Ce champ pointe vers un objet Time qui spécifie la date à laquelle le
répertoire a été modifié pour la dernière fois.

{u}NOTE@{uu}@{ub}
Si vous initialisez un répertoire existant avec un pointeur Date, 
l'ancienne
Date sera écrasée par la nouvelle.

@EndNode
---------------------------------------------------------------------
------
@NODE "DIR_Flags" "Objet: Directory"

@{b}@{u}CHAMP@{uu}@{ub}
Nom:          Flags
Type:         LONG
Modification: Ne peut être modifié dynamiquement.
Status:       Lecture/IEcriture.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Spécifie les flags utilisés pour ouvrir le répertoire. Voici les 
flags
que vous pouvez spécifier pour OpenFile() et Init():

@{u}FL_LOCK@{uu}
Définir celui-ci bloque le répertoire pour un accès exclusif - aucun
autre processus ne pourra ouvrir le répertoire pendant que vous 
l'utilisez.
Si ce flag n'est pas défini alors le répertoire sera ouvert en accès
partagé. Essayer de bloquer un répertoire qui l'est déjà est voué à
l'échec. Souvenez vous que les du bloquage d'un répertoire ne se 
répercutent
pas sur les répertoires fils.

@{u}FL_FIND@{uu}
Ce flag permet à OpenFile() d'utiliser de son intelligence et de 
trouver
le répertoire même si celui-ci n'est pas exactement à la place 
spécifiée
par FileName. Le processus impliqué est juste une simple recherche 
dans
un arbre. La capacité de recherche d'un répertoire est limitée à une 
recherche
locale, aucune recherche dans toute l'arborescence des répertoires ne
sera entreprise pour un assignement (c'est trop long).

@{u}FL_NOBUFFER@{uu}
Définir ce flag permet au répertoire de ne pas être placé dans un 
cache, ce 
qui est impératif si vous voulez que le répertoire soit le reflet de 
son contenu
à tout moment.

@EndNode
---------------------------------------------------------------------
------
@NODE "DIR_Next" "Object: Directory"

@{b}@{u}CHAMP@{uu}@{ub}
Nom:         Next
Type:        struct Directory *
Héritage:    Activate()
Status:      Lecture seulement.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Ce champ n'est utile que lorsqu'un objet Directory fait partie d'une 
liste
chainée de répertoires. Il pointe directement vers le prochain 
répertoire
dans la chaine. Si sa valeur est NULL alors c'est le dernier de la 
liste.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
CHAMPs: @{"ChildDir" LINK "DIR_ChildDir"}
        @{"Prev"     LINK "DIR_Prev"}

@EndNode
---------------------------------------------------------------------
------
@NODE "DIR_Permissions" "Object: Directory"

@{b}@{u}CHAMP@{uu}@{ub}
Nom:         Permissions
Type:        LONG
Héritage:    Init()
Par défaut:  FPF_READ|FPF_WRITE|FPF_DELETE
Status:      Lecture/IEcriture

@{b}@{u}DESCRIPTION@{uu}@{ub}
Ce champ de permission donne des informations sur les droits de 
l'utilisateur vis à vis d'un répertoire ou d'un fichier particulier. 
Les Flags actuellemnt disponibles sont:

@{u}FPF_HIDDEN@{uu}
Si le répertoire doit être caché à cet utilisateur.

@{u}FPF_DELETE@{uu}
Si l'utilisateur a le droit d'effacer ce répertoire. Notez que si il 
y
a des sous-répertoires/fichiers que l'utilisateur n'a pas le droit 
d'effacer
alors il ne pourra pas effacer le répertoire en entier.

@{u}FPF_PASSWORD@{uu}
C'est un flag spécial qui peut verrouiller un répertoire jusqu'à ce 
que
le mot de passe adequat soit donné. Si un répertoire contient des 
sous
fichiers et des répertoires, l'accès à ceux-ci sera aussi affecté par 
le
mot de passe.
Notez que le support de ce flag est toujours en cours et que la 
plupart
des file-systems actuels ne peuvent le supporter directement.

@{u}FPF_READ@{uu}
Ce flag ne s'applique pas aux répertoires.

@{u}FPF_SCRIPT@{uu}
Ce flag ne s'applique pas aux répertoires.

@{u}FPF_WRITE@{uu}
Ce flag ne s'applique pas aux répertoires.

@EndNode
---------------------------------------------------------------------
------
@NODE "DIR_Prev" "Object: Directory"

@{b}@{u}CHAMP@{uu}@{ub}
Nom:        Prev
Type:       struct Directory *
Héritage:   Activate()
Status:     Lecture/Ecriture

@{b}@{u}DESCRIPTION@{uu}@{ub}
Ce champ n'est utile que lorsqu'un objet Directory fait partie d'une 
liste
chainée de répertoires. Il pointe directement vers le répertoire 
précédent
dans la chaine. Si sa valeur est NULL alors c'est le premier de la 
liste.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
CHAMPs: @{"ChildDir" LINK "DIR_ChildDir"}
        @{"Next"     LINK "DIR_Next"}

@EndNode
---------------------------------------------------------------------
------
@NODE "DIR_Source" "Object: Directory"

@{b}@{u}CHAMP@{uu}@{ub}
Nom:          Source
Type:         APTR
Modification: Ne peut être modifié dynamiquement.
Status:       Lecture/IEcriture.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Pointe vers un objet source, qui peut être soit un FileName soit un 
objet
reconnu par le système. La Source sera utilisée pour y lire et y 
écrire
des données.

Notez que le type source FileName est pleinement supporté à l'heure 
actuelle.

@EndNode
