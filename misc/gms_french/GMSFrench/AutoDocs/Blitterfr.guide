@DATABASE "Blitter"
@AUTHOR   "Paul Manias"
@NODE     "Main" "Blitter Documentation"

@{b}@{u}MODULE DOCUMENTATION@{uu}@{ub}
Nom:        @{"BLITTER" LINK "Functions"}
Version:    0.9 Beta.
Date:       Décembre 1997
Auteur:     Paul Manias
Traducteur: Julien Boibessot
Copyright:  DreamWorld Productions, 1996-1997.  Tous droits réservés.
Notes:      Ce document est perpétuellement en cours d'écriture et contiendra
            sûrement bon nombre d'erreurs. Les informations données ne seront
            officielles que lorsque cette autodoc atteindra la version 1.0.


@{b}@{u}CHANGEMENTS DANS LA VERSION 0.9B@{uu}@{ub}
Retiré:  AllocBlitter()
         FreeBlitter()

Edité:   AllocBlitMem()
         FreeBlitMem()
         DrawBob()
         DrawBobList()
         DrawPixelList()
         CreateMasks()

@EndNode
---------------------------------------------------------------------------
@NODE "Functions" "Blitter Information"

 @{"INTRODUCTION" LINK "Introduction"}
 
 @{b}OBJETS@{ub}
 @{"Bitmap  " LINK "GMSDev:AutoDocs/Objects/Bitmapfr.guide/Description"}
 @{"Bob     " LINK "GMSDev:AutoDocs/Objects/Bob_MBobfr.guide/Description"}
 @{"MBob    " LINK "GMSDev:AutoDocs/Objects/Bob_MBobfr.guide/Description"}
 @{"Restore " LINK "GMSDev:AutoDocs/Objects/Restorefr.guide/Description"}

 @{b}FONCTIONS@{ub}
 @{"AllocBlitMem()    "     LINK "AllocBlitMem()"}
 @{"ClearBob()        "         LINK "ClearBob()"}
 @{"ClearBitmap()     "      LINK "ClearBitmap()"}
 @{"CopyBuffer()      "       LINK "CopyBuffer()"}
 @{"CreateMasks()     "      LINK "CreateMasks()"}
 @{"DrawBob()         "          LINK "DrawBob()"}
 @{"DrawBobList()     "      LINK "DrawBobList()"}
 @{"DrawLine()        "         LINK "DrawLine()"}
 @{"DrawPixel()       "        LINK "DrawPixel()"}
 @{"DrawPixelList()   "    LINK "DrawPixelList()"}
 @{"DrawUCLine()      "       LINK "DrawUCLine()"}
 @{"DrawUCPixel()     "      LINK "DrawUCPixel()"}
 @{"DrawUCPixelList() "  LINK "DrawUCPixelList()"}
 @{"FreeBlitMem()     "      LINK "FreeBlitMem()"}
 @{"ReadPixel()       "        LINK "ReadPixel()"}
 @{"ReadPixelList()   "    LINK "ReadPixelList()"}
 @{"SetBobDimensions()" LINK "SetBobDimensions()"}
 @{"SetBobDrawMode()  "   LINK "SetBobDrawMode()"}
 @{"SetBobFrames()    "     LINK "SetBobFrames()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Introduction" "Blitter Module Overview"

@{b}
                         BLITTER SUPPORT OVERVIEW
@{ub}

Le support du Blitter est étudié pour éxécuter des dessins d'images sur un écran
le plus rapidement possible. Le meilleur moyen de de faire cette opération est 
de vous fournir un large choix de fonctions de dessin, ainsi vous pouvez  
spécifier exactement la manière avec laquelle vous voulez qu'une image soit 
dessinée. Pour les programmeurs expérimentés, ce niveau de fonctionnalité est 
extrêmement utile pour créer des routines de dessin rapides et optimisées. Si 
vous êtes débutant cela pourra prendre un peu de temps avant que vous ne 
sachiez quelle méthode utiliser dans une situation particulière mais avec un 
peu d'entrainement vous saurez comment utiliser les options disponibles à 
votre avantage. Actuellement, les options comprennent le blitting en liste, 
clipping on/off, des modes de restauration et de nettoyage, masquage on/off, 
création de masques pour les BOBs multiples, la définition des zones de 
clipping etc...
Pour rendre le module Blitter aussi efficace que possible, des règles spéciales, 
qui sont spécifiques à la programmation de jeux, ont été adoptées. Si vous
êtes habitués à programmer l'OS alors ces idées pourront vous sembler 
inhabituelles, mais elles prennent tout leur sens lors de la programmation de 
jeux. Par nature aucun jeu n'est fait pour tourner en multi-tâche avec d'autres 
jeux, car il est impossible pour un joueur de jouer à deux jeux en même temps 
sur le même écran. Si deux jeux différents essaient de partager des ressources 
communes le résultat peut être catastrophique. Comme GMS permet à un jeu 
seulement d'utiliser l'affichage à un moment donné (ie pas de fenêtres ou 
d'écrans avec une barre titre scrollables), il est logique que la seule tâche qui 
doive utiliser les fonctions de dessin est celle qui est "en avant". Cela veut dire 
qu'à un instant quelconque quand votre tâche est active, vous savez que vous 
avez 100% du temps blitter disponible. Vos cycles de dessin ne seront pas volés 
par des tâches cachées!
On m'avait suggérer dans le passé d'utiliser QBlit() ou une interruption 
similaire du Blitter. L'avantage de cette méthode est que c'est plus facile 
pour le processeur de faire des choses pendant que le blitter est actif et le 
Blitter n'attend jamais. Cela semblait au départ une bonne idée, mais après 
avoir essayé, les résultats furent décourageant, donc je n'ai pas continuer.
Pourquoi?  Et bien parce que cette méthode ne tient pas compte du fait que
le blitter est si LENT! Essayez simplement d'utiliser le blitter, vous aurez de la 
chance si vous affichez 7 BOBs 32x32x32 sur un écran à 50 images par secondes 
avec les modes de nettoyage actifs. Peu importe la vitesse de vos routines le 
blitter ne déplacera pas les données assez rapidement.
Cela n'est pas acceptable pour les jeux d'arcade.

En remplacement Paul est en train actuellement de développer des routines 
de blittage assistées par le CPU et très rapides. Elles marchent extrêmement
bien dans les opérations de blittage massif avec une amélioration de la vitesse
d'environ 20-30% sur son '020 A1200+Fast par rapport au mode classique 
avec le blitter seul. Sur un 030 on devrait avoir une amélioration de 40% alors 
que sur 040  et 060  nous pourrons tracer 2 bobs avec le CPU pendant que le 
Blitter en trace 1. Je pense que les possesseurs d'Amiga avec des CPU rapides
apprécieront cette fonction, alors que les autres utilisateurs n'en patiront pas
car le Blitter s'occupera de tout sur des machines avec un CPU lent.

Profitez bien du blittage rapide, et si vous avez d'autres bonnes idées envoyez 
les moi.

@EndNode
-----------------------------------------------------------------------------
@NODE "AllocBlitMem()" "Blitter: AllocBlitMem()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        AllocBlitMem()
Résumé:     Alloue un bloc de mémoire pour le Blitter.
Synopsis: APTR AllocBlitMem(LONG Size [d0], LONG Flags [d1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Alloue un bloc de mémoire utilisable par le module Blitter. Sur les Amigas 
actuels elle n'allouera que de la mémoire chip, mais la mémoire Fast
sera gérée dans le futur (pour du Blitting avec le CPU seul).

Vous pouvez libérer la mémoire en appelant FreeBlitMem() ou FreeMemBlock().

@{b}@{u}NOTE@{uu}@{ub}
Il est possible d'utiliser de la mémoire vidéo comme mémoire Blitter.
Cependant le contraire n'est pas faisable car comme mentionné plus haut
la mémoire Blitter peut être de la mémoire FAST, qui n'est pas adequat
à un affichage vidéo.

@{b}@{u}ENTREES@{uu}@{ub}
Size  - La taille de la mémoire à alouer.
Flags - Flags mémoire spéciaux tels que MEM_UNTRACKED.

@{b}@{u}RESULTAT@{uu}@{ub}
Retourne un pointeur vers la mémoire allouée. Toute mémoire allouée 
pour le Blitter est formatée avec des zéros. Si une erreur se produit
un pointeur NULL est retourné.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Blitter: @{"FreeBlitMem()"  LINK "FreeBlitMem()"}
Kernel:  @{"AllocMemBlock()" LINK "GMSDev:AutoDocs/Kernelfr.guide/AllocMemBlock()"}
         @{"FreeMemBlock() " LINK "GMSDev:AutoDocs/Masterfr.guide/FreeMemBlock()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "AllocBlitter()" "Blitter: AllocBlitter()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        AllocBlitter()
Résumé:     Alloue le Blitter afin que l'on puisse l'utiliser.
Assembleur: ErrorCode = AllocBlitter()
C/C++:      LONG AllocBlitter(void);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Alloue le blitter, et si nécessaire l'alloue pour un usage par votre 
programme exclusivement. Cette fonction peut aussi éxécuter d'autres
tâches pour obtenir les meilleures performances possibles du blitter,
elle peut mettre en oeuvre une interruption du blitter.

Vous devez appeler cette fonction avant l'utilisation de tout autre 
fonction liée (de près ou de loin) au blitter, et appeler FreeBlitter()
lorsque vous quittez votre programme.

@{b}@{u}RESULTAT@{uu}@{ub}
ErrorCode - Retourne NULL si l'appel a réussi.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Blitter: @{"FreeBlitter()" LINK "FreeBlitter()"}

@EndNode
---------------------------------------------------------------------------
@NODE "ClearBob()" "Blitter: ClearBob()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:      ClearBob()
Résumé:   Efface l'image d'un BOB d'un Bitmap.
Synopsis: ClearBob(APTR Bob [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Efface l'image d'un BOB d'un Bitmap. C'est une méthode rapide pour effacer
un Bob car elle a été écrite pour utiliser du mieux possible le Blitter.
Elle peut gérer des MBobs, mais pour effacer plusieurs Bobs de l'écran
vous devrez probablement utiliser un objet Restore.

Notez que vous n'avez pas besoin de définir le flag CLEAR pour utiliser
cette fonction. Si vous avez besoin d'effacer avec le masque du Bob,
définissez CLRMASK, sinon définissez CLRNOMASK.

@{b}@{u}ENTREES@{uu}@{ub}
Bob - Pointeur vers une structure Bob/MBob initialisée.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Blitter: @{"DrawBob()" LINK "DrawBob()"}

@EndNode-----------------------------------------------------------------------------
@NODE "ClearBitmap()" "Blitter: ClearBitmap()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        ClearBitmap()
Résumé:     Nettoie un Bitmap.
Synopsis: void ClearBitmap(*Bitmap [a0]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Efface toutes les données contenues dans un Bitmap. La méthode utilisée par cette fonction dépend largement
de la sélection faite dans GMSPrefs, pour le moment il y a trois 
méthodes de nettoyage disponibles:

	     Nettoyage avec le Blitter.
	     Nettoyage avec le CPU.
	     Nettoyage avec le Blitter et le CPU.

La méthode par défaut est celle du Blitter+CPU, qui est la plus
efficace des trois.

@{b}@{u}ENTREES@{uu}@{ub}
Bitmap - Pointeur vers une structure Bitmap initialisée. Le Bitmap doit
         se trouver en mémoire Vidéo.

@EndNode
---------------------------------------------------------------------------
@NODE "CopyBuffer()" "Blitter: CopyBuffer()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        CopyBuffer()
Résumé:     Copie le contenu d'un buffer écran vers un autre.
Synopsis: void CopyBuffer(*Screen [a0], WORD SrcBuffer [d0],
           WORD DestBuffer [d1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Copie le contenu du buffer d'un écran vers un autre. Notez que cette
copie ne peut être effectuée que dans la même structure Screen, donc
vous ne pouvez pas copier un écran vers un autre.
	
Elle utilisera le CPU et le blitter pour éxécuter cette action aussi
rapidement que possible.


@{b}@{u}ENTREES@{uu}@{ub}
Screen     - Pointeur vers une structure Screen initialisée.
SrcBuffer  - L'ID du buffer source, ex BUFFER1.
DestBuffer - L'ID du buffer destination, ex BUFFER2.

@EndNode
-----------------------------------------------------------------------------
@NODE "CreateMasks()" "Blitter: CreateMasks()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        CreateMasks()
Résumé:     Créé ou recréé tous les masques d'un Bob.
Synopsis: LONG CreateMasks(APTR Bob [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction créé tous les masques pour un Bob ou un MBob. Si le
Bob a déjà été initialisé, les anciens masques seront libérés et un
nouveau set sera créé.

Les masques sont créés en regardant les données graphiques du Bob en
question. La couleur 0 est toujours considérée comme étant la couleur
transparente, donc tous les pixels du fond d'écran ne pourront être vus
qu'à travers cette couleur.

Si vous définissez l'option FILLMASK dans Bob->Attrib, des pixels masqués
seront créés là où il y a des trous dans le graphisme.
Par exemple si vous dessinez un personnage avec des yeux Noirs, en temps
normal vous verriez le fond à travers. Avec FILLMASK les yeux seront
remplis. La routine de remplissage est un simple remplisseur linéaire
donc si vous voulez générer des masques plus complexes il vaut mieux
les dessiner vous-même.

@{b}@{u}ENTREE@{uu}@{ub}
Bob - Pointeur vers une structure Bob ou MBob.

@{b}@{u}RESULTAT@{uu}@{ub}
Retourne ERR_OK en cas de succès. L'appel peut échoué pour toutes sortes
de raisons, mais le plus souvent seulement s'il reste trop peu de mémoire
pour l'allocation du masque.

@EndNode
-----------------------------------------------------------------------------
@NODE "DrawBob()" "Blitter: DrawBob()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        DrawBob()
Résumé:     Dessine un "Blitter OBject" directement sur un Bitmap.
Synopsis: void DrawBob(APTR Bob [a1]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Dessine un Bob ou un MBob sur un Bitmap en tenant compte des valeurs dans
la structure Bob/MBob. 

La méthode utilisée pour tracer les Bobs n'est pas censée vous être 
familière: le Blitter, le CPU, ou les 2 en même temps peuvent être 
utilisés pour dessiner un Bob à l'écran. Gardez seulement en mémoire
que l'objectif premier de cette fonction est simplement d'afficher 
l'image à l'écran aussi vite que possible et en utilisant tous les 
moyens disponibles.

@{b}@{u}PROPRIETES@{uu}@{ub}
Les fonctions pour "blitter" ont quelques propriétés dont vous devez 
tenir compte si vous voulez obtenir la vitesse de tracage maximum. 
Dès que possible, le CPU sera utilisé pour dessiner lorsque le Blitter
est occupé. Il assistera aussi le Blitter en dessinant certaines parties
du Bob pendant que le Blitter dessine les autres. Ce traçage en parallèle
permet un gain considérable en vitesse sur des machines à base de 68020
ou supérieur.

Blitter des images à des multiples de 16 pixels sera plus rapide car
aucun "shifting" n'est alors requis. Si vous vous rappeler de ceci 
alors vous pourrez l'utiliser à votre avantage dans certaines situations
Un exemple classique est un shoot'em-up horizontal, dans lequel vous
pouvez aligner les missiles de votre vaisseau sur 16 pixels. Cela permet
d'augmenter la vitesse lorsque vous blittez autant d'objets.

Blitter et nettoyer sans les masques sera aussi naturellement plus rapide.
Vous pouvez utiliser souvent le mode CLEAR si vous savez qu'il n'y a
rien sur le background. Utilisez les MBobs dès que possible, et 
utilisez toujours un objet Restore car c'est le moyen le plus rapide de
nettoyer ou de restaurer votre background.

@{b}@{u}ENTREES@{uu}@{ub}
Bob - Pointeur vers une structure BOB/MBOB initialisée.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Blitter: @{"DrawBobList()" LINK "DrawBobList()"}
Kernel:  @{"Draw()" LINK "GMSDev:AutoDocs/Kernelfr.guide/Draw()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DrawBobList()" "Blitter: DrawBobList()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        DrawBobList()
Résumé:     Dessine une Liste de Bobs sur un Bitmap.
Assembleur: DrawBobList(BobList [a1])
C/C++:      void DrawBobList(LONG *BobList[]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
C'est une fonction de "traçage en masse", qui vous permet de blitter  
plusieurs BOBs qui proviennent d'une liste sur leur Bitmap respectifs.
Elle peut gérer tous les types de structures de Bobs et elle est le moyen
le plus rapide pour gérer le traçage de nombreux Bobs en même temps.

La méthode utilisée pour dessiner les Bobs  n'est pas censé vous être 
familière: le blitter, le CPU, ou les 2 en même temps peuvent être 
utilisés pour dessiner un Bob à l'écran. 
Gardez seulement en mémoire que l'objectif premier de cette fonction est
simplement d'afficher l'image à l'écran aussi vite que possible et en 
utilisant tous les moyens disponibles.

@{b}@{u}ENTREES@{uu}@{ub}
BobList - Pointeur vers une LISTE des structures Bobs à afficher qui
          doit être terminée par LISTEND.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Blitter: @{"DrawBob()" LINK "DrawBob()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DrawLine()" "Blitter: DrawLine()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        DrawLine()
Résumé:     Dessine une ligne entre deux points d'un Bitmap.
Synopsis: void DrawLine(*Bitmap [a0], WORD XStart [d1], WORD YStart [d2],
	   WORD XEnd [d3], WORD YEnd [d4], LONG Colour [d5])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Trace une ligne entre (XStart,YStart) et (XEnd,YEnd). Cette fonction
peut dessiner la ligne soit avec le blitter, soit avec le CPU (ou 
peut-être les deux), cela dépend des choix faits dans GMSPrefs.

Cette fonction supporte le clipping pour des lignes qui sont en dehors 
des limites de l'image. Pour tracer des lignes plus rapidement, utilisez
DrawUCLine si vous êtes sûr que la ligne sera bien dans les limites de 
l'image.

@{b}@{u}ENTREES@{uu}@{ub}
Bitmap  - Pointeur vers une structure Bitmap initialisée.
XStart  - Coordonnée X de départ.
YStart  - Coordonnée Y de départ.
XEnd    - Coordonnée X d'arrivée.
YEnd    - Coordonnée Y d'arrivée.
Colour  - Couleur de la ligne.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Blitter: @{"DrawUCLine()" LINK "DrawUCLine()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DrawPixel()" "Blitter: DrawPixel()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        DrawPixel()
Résumé:     Dessine un pixel sur un Bitmap.
Synopsis: void DrawPixel(*Bitmap [a0], WORD XCoord [d1], WORD YCoord [d2],
	   LONG Colour [d3])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Dessine un pixel aux coordonnées XCoord, YCoord sur un Bitmap. Cette
fonction teste les coordonnées données pour être sûr que le pixel sera
dans les limites du Bitmap, dans le cas contraire le pixel n'est pas dessiné.
Si vous n'avez pas besoin du clipping, utilisez DrawUCPixel().

@{b}@{u}NOTES@{uu}@{ub}
Ne donnez jamais en paramètre une couleur qui ne fait pas partie des
couleurs du Bitmap.
Les pixels Chunky sont dessinés plusieurs fois plus rapidement que les 
pixels interleaved ou planar, du fait des capacités de ce format 
d'affichage.

@{b}@{u}ENTREES@{uu}@{ub}
Bitmap - Pointeur vers une structure Bitmap initialisée.
XCoord - La coordonnée X du pixel.
YCoord - La coordonnée Y du pixel.
Colour - Le numéro de la couleur à utiliser pour le pixel.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Blitter: @{"DrawPixelList()"   LINK "DrawPixelList()"}
         @{"DrawUCPixelList()" LINK "DrawUCPixelList()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DrawUCLine()" "Blitter: DrawUCLine()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        DrawUCLine()
Résumé:     Dessine une ligne entre deux points d'un Bitmap, ceci sans
            clipping.
Synopsis: void DrawLine(*Bitmap [a0], WORD XStart [d1], WORD YStart [d2],
	   WORD XEnd [d3], WORD YEnd [d4], LONG Colour [d5])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Trace une ligne entre (XStart,YStart) et (XEnd,YEnd). Cette fonction
peut dessiner la ligne soit avec le blitter, soit avec le CPU (ou 
peut-être les deux), cela dépend des choix faits dans GMSPrefs.

La fonction ne gère pas le clipping, donc il est impératif de faire 
en sorte que toutes les lignes que vous traciez soit dans les limites
de l'image. Dans le cas contraire utilisez DrawLine().


@{b}@{u}ENTREES@{uu}@{ub}
Bitmap  - Pointeur vers une structure Bitmap initialisée.
XStart  - Coordonnée X de départ.
YStart  - Coordonnée Y de départ.
XEnd    - Coordonnée X d'arrivée.
YEnd    - Coordonnée Y d'arrivée.
Colour  - Couleur de la ligne.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Blitter: @{"DrawLine()" LINK "DrawLine()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DrawUCPixel()" "Blitter/DrawUCPixel"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        DrawUCPixel()
Résumé:     Trace un pixel dans le Bitmap sans clipping.
Synopsis: void DrawUCPixel(*Bitmap [a0], WORD XCoord [d1], WORD YCoord [d2],
	    LONG Colour [d3])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Trace un pixel aux coordonnées XCoord, YCoord sur un Bitmap. Cette
fonction n'utilise pas le clipping, et s'attend à ce que les coordonnées
soient dans les limites du Bitmap. Si vous avez besoin du clipping, 
vous devrez utiliser DrawPixel().

@{b}@{u}ENTREES@{uu}@{ub}
Bitmap - Pointeur vers une structure Bitmap initialisée.
XCoord - La coordonnée X du pixel.
YCoord - La coordonnée Y du pixel.
Colour - Le numéro de la couleur à utiliser pour le pixel.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Blitter: @{"   DrawPixel()   "       LINK "DrawPixel()"}
         @{" DrawPixelList() "   LINK "DrawPixelList()"}
         @{"DrawUCPixelList()" LINK "DrawUCPixelList()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DrawPixelList()" "Blitter: DrawPixelList()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        DrawPixelList()
Résumé:     Trace une liste de pixels dans le buffer d'un Bitmap.
Synopsis: void DrawPixelList(*Bitmap [a0], WORD *PixelList [a1]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Trace une liste entière de pixels à l'écran, le clipping étant activé.
	
C'est la deuxième méthode la plus rapide pour tracer plusieurs pixels 
sans faire des appels à répétition à la librairie. Pour un tracage 
encore plus rapide, vous pouvez utiliser DrawUCPixelList(), mais soyez
conscients du fait que cette fonction ne se sert pas du clipping.

Une Liste de pixel n'est pas une liste GMS standard. Elle ressemble 
plutôt à cela:

	dc.w	<AmtEntries>,<EntrySize>
	dc.l	<*Array>

Array:	dc.w	<XCoord>,<YCoord>
	dc.l	<Colour>
	dc.w	...
	dc.l	...

Par exemple pour tracer 3 pixels sur un écran 4 couleurs de dimensions
320x256. Notez l'utilisation de la macro PIXEL qui vous aide à remplir 
les trois paramètres sur une même ligne:

PixelList:
  dc.w   3,PXL_SIZEOF
  dc.l   .Values

.Values
  PIXEL  140,201,3
  PIXEL  036,165,1
  PIXEL  224,051,2

Voici la version pour le C:


  struct PixelList PixelList = { /* Définition du header de la liste
    3,                                            de pixels */
    sizeof(struct PixelEntry),
    Pixels
  };

  struct PixelEntry Pixels[3] = { /* Valeurs de la liste de pixels */
    140,201,3
    036,165,1
    224,051,2	  
  };

Vous êtes autorisés à transformer chaque PixelEntry ainsi vous pouvez 
stocker des données supplémentaires dans la liste. Par exemple, si vous
écriviez une démo avec des pixels clignotants, alors cela serait plus
pratique si vous pouviez stocker l'état ON/OFF de chaques pixels dans
la même liste.
Pour faire cela vous aurez besoin d'augmenter le paramètre EntrySize 
de telle sorte que DrawPixelList() connaisse la véritable taille de chaque
entrée. Ex:


LightList:
	dc.w	3,PXL_SIZEOF+2
	dc.l	.Values

.Values	PIXEL	140,201,3
	dc.w	0
	PIXEL	036,165,1
	dc.w	1
	PIXEL	224,051,2
	dc.w	0

Vous pouvez aussi reprendre la structure PixelEntry dans les fichiers 
Includes et lui ajouter d'autres paramètres si cela vous semble plus
adapté.

Un flag existe pour "sauter" un pixel. Spécifiez SKIPPIXEL dans la 
coordonnée X si vous ne voulez pas que le pixel soit dessiné.


@{b}@{u}ENTREES@{uu}@{ub}
Bitmap    - Pointeur vers une structure Bitmap initialisée.
PixelList - Pointe vers une liste de pixels, voir plus haut.


@{b}@{u}VOIR AUSSI@{uu}@{ub}
Blitter: @{"DrawPixel()"       LINK "DrawPixel()"}
         @{"DrawUCPixelList()" LINK "DrawUCPixelList()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DrawUCPixelList()" "Blitter: DrawUCPixelList()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:      DrawUCPixelList()
Résumé:      Trace une liste de pixels sur un Bitmap sans clipping.
Synopsis: void DrawUCPixelList(*Bitmap [a0], *PixelList [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Trace une liste de pixels sans clipping sur un écran. C'est une fonction
spéciale qui est prévue pour des situations où vous êtes à 100% sûr
qu'aucun pixel ne sera en dehors de l'image. Vu qu'il n'y a pas de 
vérifications, tout pixel "suspect" peut causer des modifications 
illégales en mémoire, donc faites attention! 
L'avantage de cette fonction est qu'elle est très rapide pour tracer
des pixels en masse.

Regardez  @{"DrawPixelList()" LINK "DrawPixelList()"} pour plus
d'informations sur la création d'une PixelList.

@{b}@{u}ENTREES@{uu}@{ub}
Bitmap    - Pointeur vers une structure Bitmap initialisée.
PixelList - Pointe vers une liste de pixels, voir plus haut.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Blitter: @{"DrawPixel"     LINK "DrawPixel()"}
Blitter: @{"DrawPixelList" LINK "DrawPixelList()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "FreeBlitMem()" "Blitter: FreeBlitMem()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        FreeBlitMem()
Résumé:     Libère la mémoire allouée par AllocBlitMem().
Synopsis: void FreeBlitMem(APTR MemBlock [d0]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Libère un bloc mémoire qui a été alloué par AllocBlitMem(). Si vous
passez à cette fonction un pointeur NULL alors l'appel sera ignoré.

De la mémoire pour le Blitter qui est allouée et n'est pas libérée va
rester dans la liste de ressources du système. Un tel Bug aura pour 
conséquence un message d'erreur du système lorsque vous quitterez votre
programme.

@{b}@{u}ENTREE@{uu}@{ub}
MemBlock - MemBlock alloué par AllocBlitMem().

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Blitter: @{"AllocBlitMem()" LINK "AllocBlitMem()"}
Kernel:  @{"FreeMemBlock()" LINK "GMSDev:AutoDocs/Kernelfr.guide/FreeMemBlock()"}

@EndNode
---------------------------------------------------------------------------
@NODE "ReadPixel()" "Blitter: ReadPixel()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        ReadPixel()
Résumé:     Récupère la couleur d'un pixel à une position X/Y.
Synopsis: LONG ReadPixel(*Bitmap [a0], WORD XCoord [d1], WORD YCoord [d2])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Recherche un certain pixel dans un Bitmap et renvoie son numéro de 
couleur ou sa valeur RGB, tout dépend de Bitmap->Type. Si vous donnez à
cette fonction des coordonnées qui sont en dehors de l'image à l'écran
elle vous retournera la valeur -1 dans Pixel.

@{b}@{u}ENTREES@{uu}@{ub}
Bitmap - Pointeur vers une structure Bitmap initialisée.
XCoord - La coordonnée X du pixel à lire.
YCoord - La coordonnée Y du pixel à lire.

@{b}@{u}RESULTAT@{uu}@{ub}
Pixel - Le numéro de couleur du pixel ou sa valeur RGB ou -1.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Blitter: @{"ReadPixelList()" LINK "ReadPixelList()"}

@EndNode
---------------------------------------------------------------------------
@NODE "ReadPixelList()" "Blitter: ReadPixelList()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        ReadPixelList()
Résumé:     Lit une liste de pixels d'un Bitmap.
Synopsis: void ReadPixelList(*Bitmap [a0], *PixelList [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction prend une liste de pixels donnée, analyse chaque couple
de coordonnées et met la couleur du pixel dans le champ correspondant.
Toute coordonnée qui est en dehors des limites du Bitmap recevra la valeur
-1 comme couleur.

@{b}@{u}NOTE@{uu}@{ub}
Cette fonction n'a pas encore été testée.

@{b}@{u}ENTREES@{uu}@{ub}
Bitmap     - Pointeur vers une structure Bitmap initialisée.
PixelList  - Pointeur vers une liste de pixels.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Blitter: @{"ReadPixel()" LINK "ReadPixel()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "SetBobDimensions()" "Blitter: SetBobDimensions()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        SetBobDimensions()
Résumé:     Recalcule les champs de dimension d'un Bob après que l'un
             ou plusieurs d'entre eux aient changé.
Synopsis: void SetBobDimensions(*Bob [a1]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction va recalculer les champs de dimension d'un Bob après que
l'un ou plusieurs d'entre eux aient changé. Par dimensions, on sous-entend
la Largeur et la Hauteur du Bob.

Si vous changez les champs Hauteur et Largeur du Bob alors vous devez
appeler cette fonction pour préparer le Bob pour le prochain "blit".
Autrement vous n'obtiendrez sûrement pas le traçage voulu.

@{b}@{u}NOTE@{uu}@{ub}
Si vous utilisez des masques générés et que vous changez la taille de
votre Bob, cette fonction appelera CreateMasks() afin de pourvoir à ces
changements. Cela peut ralentir légèrement la fonction.
Si le Bob utilise le mode RESTORE alors la fonction sera ralentie de
manière plus conséquente car tous les buffers de restauration devront
être réalloués.

@{b}@{u}ENTREE@{uu}@{ub}
Bob - Pointeur vers le Bob à mettre à jour.

@EndNode
-----------------------------------------------------------------------------
@NODE "SetBobDrawMode()" "Blitter: SetBobDrawMode()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        SetBobDrawMode()
Résumé:     Définit le mode de traçage d'un Bob.
Synopsis: LONG SetBobDrawMode(*Bob [a1], LONG Flags [d0]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Si vous voulez changer le mode de traçage d'un Bob qui a déjà été
initialisé, vous devez appeler cette fonction.

@{b}@{u}ENTREE@{uu}@{ub}
Bob   - Pointeur vers le Bob qui doit être mis à jour.
Flags - Nouvelles valeurs pour les champs de Bob->Attrib.

@{b}@{u}RESULTAT@{uu}@{ub}
ErrorCode - Retourne ERR_OK si la nouvelle définition a réussi.

@EndNode
-----------------------------------------------------------------------------
@NODE "SetBobFrames()" "Blitter: SetBobFrames()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        SetBobFrames()
Résumé:     Recréé les listes directes d'un Bob après modification de
             ses frames.
Synopsis: LONG SetBobFrames(*Bob [a1]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction créé ou recréé les listes GfxDirect et MaskDirect du Bob
à partir des listes GfxCoords et MaskCoords. Vous avez besoin d'appeler
cette fonction à chaque fois que vous changez les coordonnées de un ou
plusieurs graphiques ou masques de votre Bob.
De plus vous pouvez avoir besojn d'appeler CreateMasks() si les masques
deviennent obsolète du fait du changement de coordonnées.

Si vous n'utilisez pas les paramètres GfxCoords ou MaskCoords et que
vous utilisez à la place seulement les champs Direct*, vous devez
toujours appeler cette fonction si vous changez les listes directes.


@{b}@{u}NOTE@{uu}@{ub}
Vous ne pouvez pas augmenter le nombres de frames dans votre Bob avec
cette fonction.

@{b}@{u}ENTREE@{uu}@{ub}
Bob - Pointeur vers le Bob à mettre à jour.

@{b}@{u}RESULTAT@{uu}@{ub}
ErrorCode - Retourne ERR_OK si l'appel a réussi.

@EndNode
-----------------------------------------------------------------------------
@NODE "()" "Blitter:"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:      
Résumé:     
Assembleur: 
C/C++:     

@{b}@{u}DESCRIPTION@{uu}@{ub}

@{b}@{u}NOTE@{uu}@{ub}

@{b}@{u}ENTREE@{uu}@{ub}

@{b}@{u}RESULTAT@{uu}@{ub}

@{b}@{u}VOIR AUSSI@{uu}@{ub}

@EndNode
