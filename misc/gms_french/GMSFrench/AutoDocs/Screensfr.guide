@DATABASE "Screens"
@AUTHOR   "Paul Manias"
@NODE     "Main" "Documentation sur les Ecrans"

@{b}@{u}MODULE DOCUMENTATION@{uu}@{ub}
Nom :         @{"SCREENS" LINK "Functions"}
Version:      0.9 Beta.
Date:         Décembre 1997
Auteur:       Paul Manias
Traducteur:   Julien Boibessot
Copyright:    DreamWorld Productions, 1996-1997.  Tous droits réservés.
Notes:        Ce document est perpétuellement en cours d'écriture et contiendra
              sûrement bon nombre d'erreurs. Les informations données ne seront
              officielles que lorsque cette autodoc atteindra la version 1.0.

@{b}@{u}CHANGEMENTS DANS LA VERSION 0.9B@{uu}@{ub}
Ajoutés:    WaitSwitch()
            LockVideo()
            UnlockVideo()
            Display Buffering
            Video Locking

Renommés: MovePicture() en MoveBitmap()
          ResetPicture() en ResetBitmap()

Edité:  MoveBitmap()

Effacés: Toutes les fonctions et réferences aux Sprites. Les Sprites ne
         seront pas dans la version V1.0.

         Toutes les fonctions raster ont été effacées, car il y a maintenant
         un objet OO Raster.

@EndNode
---------------------------------------------------------------------------
@NODE "Functions" "Module: Screens"

 @{"INTRODUCTION" LINK "Introduction"}

 @{b}OBJETS@{ub}
 @{"Raster" LINK "GMSDev:AutoDocs/Objects/Rasterfr.guide/Description"}
 @{"Screen" LINK "GMSDev:AutoDocs/Objects/Screenfr.guide/Description"}
 
 @{b}THEORIE@{ub}
 @{"Display Buffering" LINK "DisplayBuffering"}
 @{"Video Locking"     LINK "VideoLocking"}

 @{b}FONCTIONS@{ub}
 @{"AllocVideoMem()" LINK "AllocVideoMem()"}
 @{"BlankOn()      "       LINK "BlankOn()"}
 @{"BlankOff()     "      LINK "BlankOff()"}
 @{"FreeVideoMem() "  LINK "FreeVideoMem()"}
 @{"GetScrType()   " LINK "GetScrType()"}
 @{"HideDisplay()  "   LINK "HideDisplay()"}
 @{"LockVideo()"     LINK "LockVideo()"}
 @{"MoveBitmap()"    LINK "MoveBitmap()"}
 @{"ResetBitmap()"   LINK "ResetBitmap()"}
 @{"ReturnDisplay()" LINK "ReturnDisplay()"}
 @{"SwapBuffers()  "   LINK "SwapBuffers()"}
 @{"TakeDisplay()  "   LINK "TakeDisplay()"}
 @{"UnlockVideo()"   LINK "UnlockVideo()"}
 @{"WaitSwitch()"    LINK "WaitSwitch()"}
 @{"WaitAVBL()"      LINK "WaitAVBL()"}
 @{"WaitVBL()      "       LINK "WaitVBL()"}
 @{"WaitRastLine() "  LINK "WaitRastLine()"}

 @{b}Fonctions liées aux couleurs@{ub}
 @{"BlankColours()   "    LINK "BlankColours()"}
 @{"ChangeColours()  "   LINK "ChangeColours()"}
 @{"ColourMorph()    "     LINK "ColourMorph()"}
 @{"ColourToPalette()" LINK "ColourToPalette()"}
 @{"PaletteToColour()" LINK "PaletteToColour()"}
 @{"PaletteMorph()   "    LINK "PaletteMorph()"}
 @{"UpdatePalette()  "   LINK "UpdatePalette()"}
 @{"UpdateColour()   "    LINK "UpdateColour()"}

@EndNode
---------------------------------------------------------------------------
@NODE "Introduction" "Screens Module Overview"
@{b}
                          GENERALITES SUR LES ECRANS
@{ub}

Le module Screen (Ecran) fut le premier module a être écrit et la vitesse
fut un facteur important lors de son développement. Pour le garder rapide
possible l'objet Screen a été hautement simplifié sans pour autant perdre
ces caractéristiques puissantes. Un exemple de cette puissance est que
vous pouvez déplacer l'écran en changeant ses coordonnées et même modifier
dynamiquement sa hauteur et sa largeur sans aucun effet contraire sur 
l'affichage de l'image (regardez la demo Redimension).

Il existe un grand nombre de fonctions, qui comprennent des effets spéciaux
tels que le fondu proportionnel qui permet d'ajouter une touche de finesse
impressionnante à vos programmes. Le support des 'Raster' fournit une
manière simple d'accéder au Copper. En utilisant le commandes disponibles
vous pouvez arriver à des effets tels que le mirroir ou le dégradé de
couleurs.

Le module Screens est supporté par GMSPrefs, ce qui permet à l'utilisateur
de sélectionner ses modes d'écran préférés. Une caractéristique puissante
est de pouvoir selectionner le type d'écran, ainsi vous pouvez changer
le type d'affichage d'ILBM à Chunky par exemple. Cela augmente la vitesse
d'éxécution si votre hardware vous permet d'utiliser de tels modes et si
le jeu peut en profiter (eg les vecteurs 3D). Il est même possible de 
faire qu'un jeu tourne en hi-res entrelacée ou de le faire tourner dans
différents modes tels que le DBLPAL.

@EndNode
---------------------------------------------------------------------------
@NODE "DisplayBuffering" "Screens: Display Buffering"
@{b}
                             DISPLAY BUFFERING
@{ub}


Le "Display buffering" intervient lorsque vous voulez utiliser le double
buffer ou le triple buffer pour un écran. La technique empêche le scintillement
lorsque l'on dessine sur l'écran et dans le cas du triple buffering elle
augmente la vitesse du programme.

Il y a différentes manières pour mettre en oeuvre un display buffering,
je vais vous en expliquer deux:

@{u}La Méthode d'attente@{uu}
Cette méthode est utilisée pour le double buffering et dans certains cas
pour le triple buffering. Elle implique l'attente du 'vertical blank' après
que vous ayez dessiné vos données et en appelant ensuite SwapBuffers().
Elle ressemble habituellemnt à cela:

  while (loop) {
     Move(Bob);             /* Déplace les objets */
     Draw(Bob);             /* Dessine les objets sur le bitmap */
     WaitVBL();             /* Attend un 'vertical blank' */
     SwapBuffers(Screen);   /* Permutte les buffers d'affichage */
  }

Vous pouvez voir quelques exemples dans les codes source des démos.

@{u}Méthode du Triple Buffering@{uu}
Cette méthode peut aussi être utilisée pour le double buffering, mais
elle est spécifiquement prévue pour le triple buffering. Lorsque le module
Screen est chargé, il installe une interruption spéciale de vertical blank
en tâche de fond. Cette interruption teste l'écran courant et vérifie si
le champ Switch est à TRUE (vrai). Si oui, l'interruption va permutter les
buffers écran pendant que le programme tourne.

A ce stade il est important de savoir ce que le champ MemPtrX fait lors
du triple buffering:

  MemPtr1 - Affiché.
  MemPtr2 - Attend que l'affichage/VBL soit prêt.
  MemPtr3 - En train d'être modifié.

Ce que cela nous permet de faire est de dessinner sur le buffer pointé
par MemPtr3 pendant que l'interruption prend garde à permutter l'affichage
avec le buffer pointé par MemPtr2. Voici un exemple:

  Display(Screen);                      /* Affiche l'écran */

  Screen->Bitmap->Data = Screen->MemPtr2;

  while (loop) {

     /* Cette section va dessiner dans le buffer Bitmap->Data. Du fait
     ** qu'une permutation va probablement se produire dans cette partie
     ** vous comprenez pourquoi vous n'êtes pas autorisés à lire le champ
     ** MemPtrX dans une telle zone "incertaine".
     */

     Move(Bob);
     Draw(Bob);

     /* A cette étape nous avons besoin d'être sûr que que l'affichage
     ** a été permuté. Si tel est le cas alors notre programme va trop
     ** vite et nous devons attendre qu'un buffer soit prêt.
     */

     WaitSwitch(Screen);                     /* Attend que switch soit FALSE */
     Screen->Bitmap->Data = Screen->MemPtr3; /* Mise à jour pour le traçage  */
     Screen->Switch = TRUE;                  /* Prêt à permutter de nouveau  */
  }

@EndNode
---------------------------------------------------------------------------
@NODE "VideoLocking" "Screens: Video Locking"

                               VIDEO LOCKING


@EndNode
---------------------------------------------------------------------------

@NODE "AllocVideoMem()" "Screens: AllocVideoMem()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        AllocVideoMem()
Résumé:     Alloue de la mémoire pour le Blitter.
Synoptique: APTR AllocVideoMem(LONG Size [d0], LONG Flags [d1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Alloue un bloc mémoire servant à l'affichage vidéo. Ce type de mémoire
est compatible avec le module blitter, et doit aussi l'être avec toutes
les configurations matérielles.

La mémoire sera recherchée de la même manière que celle précisée dans
AllocMemBlock() si la recherche de ressources est activée.

@{b}@{u}ENTREES@{uu}@{ub}
Size  - La taille de la mémoire à allouer.
Flags - Flags mémoire comme dans FreeMemBlock().

@{b}@{u}RESULTAT@{uu}@{ub}
Pointeur vers la mémoire allouée. Toute mémoire vidéo est remplie de 0
lorsqu'on l'alloue. Retourne NULL si il y a une erreur.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel:  @{"FreeMemBlock()" LINK "GMSDev:AutoDocs/Kernelfr.guide/FreeMemBlock()"}
Screens: @{"FreeVideoMem()" LINK "FreeVideoMem()"}

@EndNode
---------------------------------------------------------------------------
@NODE "BlankColours()" "Screens: BlankColours()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        BlankColours()
Résumé:     Met toutes les couleurs de l'écran à zéro (noir).
Synoptique: void BlankColours(*Screen [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Met toutes les couleurs d'une palette d'écran à zéro, ce qui devrait donner
un écran noir (seulement si le ScrType utilise le registre de palette).
Vous serez incapable de voir une image après avoir appelé cette routine
avec succès.

@{b}@{u}ENTREES@{uu}@{ub}
Screen - Pointeur vers une structure Screen initialisée.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"BlankOn()" LINK "BlankOn()"}

@EndNode
---------------------------------------------------------------------------
@NODE "BlankOn()" "Screens: BlankOn()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        BlankOn()
Résumé:     Rend invisible l'affichage jusqu'à ce que BlankOff() soit appelée.
Synoptique: void BlankOn(void)

@{b}@{u}DESCRIPTION@{uu}@{ub}
Après avoir appelé cette fonction l'affichage sera complètement invisible
jusqu'à ce BlankOff() soit appelée. Durant cette période aucun effet à
l'écran ne sera visible. Notez que Display(Screen) est incapable d'annuler
cet effet, mais une fois que l'affichage est à nouveau rétabli toutes les
altérations subies par l'écran seront visibles.

Cette fonction a pour but de faire une transition propre entre deux
écrans, ie fermer un écran puis en ouvrir un autre.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"BlankOff()" LINK "BlankOff()"}

@EndNode
---------------------------------------------------------------------------
@NODE "BlankOff()" "Screens: BlankOff()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        BlankOff()
Résumé:     Réactive l'affichage après un appel à BlankOn().
Synoptique: void BlankOff(void)

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction réactive l'affichage après un appel à BlankOn(). Tous les
effets qui étaient invisibles après un appel à BlankOn() deviennent
immédiatement visibles après l'appel à cette fonction.
	
@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"BlankOn()" LINK "BlankOn()"}

@EndNode
----------------------------------------- ----------------------------------
@NODE "ColourMorph()" "Screens: ColourMorph()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        ColourMorph()
Résumé:     Fait le fondu d'un set de couleurs vers une couleur définie.
Synoptique: WORD ColourMorph(*Screen [a0], WORD FadeState [d0],
            WORD Speed [d1], LONG StartColour [d3], LONG AmtColours [d4],
            LONG SrcColour [d2], LONG DestColour [d5])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Fait un fondu de l'écran d'une couleur vers une autre. Une fois que vous
avez appelé cette fonction, vous devez continuer à l'appeler jusqu'à ce
qu'elle vous donne le résultat NULL. Cela vous permet de placer cette
fonction dans une boucle et de faire toutes sortes de choses pendant
que le fondu suit son cours.

Cette fonction utilise le "proportional fading" (fondu proportionnel)
pour créer cet effet.

@{b}@{u}NOTE@{uu}@{ub}
Toutes les fonctions de fondu ignore les valeurs des couleurs qui sont
gardées en interne. Cela vous causera donc des 	problèmes si vous ne 
savez pas à quoi ressemble votre palette courante en utilisant ces 
fonctions.

@{b}@{u}EXEMPLE@{uu}@{ub}

    FadeState = NULL;
    do {
       WaitVBL();
       FadeState = ColourMorph(Screen,FadeState,1,0,32,0xFF00AA,0xA7BC30);
    }
    while (FadeState != NULL)

@{b}@{u}ENTREES@{uu}@{ub}
Screen      - Pointeur vers une structure Screen initialisée.
FadeState   - Initialisez le à 0 et continuer à envoyer la valeur 
              retournée jusqu'à ce que ce paramètre soit NULL.
Speed       - La vitesse requise pour le fondu.
SrcColour   - La couleur source du fondu, au format 0xRRGGBB.
DestColour  - La couleur de destination du fondu, au format 0xRRGGBB.
StartColour - La couleur par laquelle on commence le fondu (0 ....
              AmtColours-1).
AmtColours  - La quantité de couleurs dans le fondu (1 ... Maximum de
              couleurs).
              Vous ne devez jamais utiliser une valeur nulle ici.


@{b}@{u}RESULTAT@{uu}@{ub}
Retourne NULL lorsque le fondu est terminé.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"ColourToPalette()" LINK "ColourToPalette()"}
         @{"PaletteMorph()   "    LINK "PaletteMorph()"}
         @{"PaletteToColour()" LINK "PaletteToColour()"}

@EndNode
---------------------------------------------------------------------------
@NODE "ColourToPalette()" "Screens: ColourToPalette()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        ColourToPalette()
Résumé:     Fait un fondu d'un set de couleurs vers un certain nombre de
            valeurs.
Synoptique:  WORD ColourToPalette(*Screen [a0], WORD FadeState [d0],
	    WORD Speed [d1], WORD StartColour [d3], WORD AmtColours [d4],
            APTR Palette [a1], LONG Colour [d2])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Fait un fondu entre un certain nombre de couleurs de la même valeur et
des couleurs spécifiées de la Palette. Une fois que vous avez appelé
cette fonction, vous devez continuer à l'appeler jusqu'à ce qu'elle 
vous donne le résultat NULL. Cela vous permet de placer cette fonction
dans une boucle et de faire toutes sortes de choses pendant que le 
fondu suit son cours.

Cette fonction utilise le "proportional fading" (fondu proportionnel)
pour créer cet effet.

@{b}@{u}NOTE@{uu}@{ub}
Toutes les fonctions de fondu ignore les valeurs des couleurs qui sont
gardées en interne. Cela vous causera donc des 	problèmes si vous ne savez
pas à quoi ressemble votre palette courante en utilisant ces fonctions.
Gardez une trace de votre palette courante peut être utile avec des 
fonctions comme PaletteMorph().

@{b}@{u}ENTREES@{uu}@{ub}
Screen      - Pointeur vers une structure Screen initialisée.
FadeState   - Initialisez le à zéro et continuer à envoyer la valeur
              retournée jusqu'à ce que ce paramètre soit NULL.
Speed       - La vitesse requise pour le fondu.
SrcColour   - La couleur source du fondu, au format 0xRRGGBB.
DestColour  - La couleur de destination du fondu, au format 0xRRGGBB.
StartColour - La couleur par laquelle on commence le fondu (0 ....
              AmtColours-1).
AmtColours  - La quantité de couleurs dans le fondu (1 ... Maximum 
              de couleurs).
              Vous ne devez jamais utiliser une valeur nulle ici.


@{b}@{u}RESULTAT@{uu}@{ub}
Retourne NULL si le fondu est terminé.


@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"ColourMorph()    "     LINK "ColourMorph()"}
         @{"ColourToPalette()" LINK "ColourToPalette()"}
         @{"PaletteMorph()   "    LINK "PaletteMorph()"}

@EndNode
---------------------------------------------------------------------------
@NODE "ChangeColours()" "Screens/ChangeColours"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        ChangeColours()
Résumé:     Change un set de couleurs de la palette interne d'un Screen.
Synoptique:  void ChangeColours(*Screen [a0], APTR Colours [a1],
            LONG StartColour [d0], LONG AmtColours [d1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Change toutes les couleurs comprises entre un certain rang. Les changements
ne seront appliqués qu'à la palette interne de l'écran.

@{b}@{u}ENTREES@{uu}@{ub}
Screen      - Pointeur vers une structure Screen initialisée.
Colours     - Pointeur vers une liste de couleurs 24 bit.
StartColour - Première couleur devant être affectée par le changement.
              NB: La première couleur commence à 0.
AmtColours  - Nombre de couleurs devant être affectées par le changement,
              doit être au moins de 1.

@EndNode
---------------------------------------------------------------------------
@NODE "FreeVideoMem()" "Screens: FreeVideoMem()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        FreeVideoMem()
Résumé:     Libère un bloc mémoire alloué par AllocVideoMem().
Synoptique: void FreeVideoMem(APTR MemBlock [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Libère un bloc mémoire alloué par AllocVideoMem().


@{b}@{u}ENTREE@{uu}@{ub}
MemBlock - Le bloc mémoire à libérer.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel:  @{"AllocMemBlock()" LINK "GMSDev:AutoDocs/Kernelfr.guide/AllocMemBlock()"}
Screens: @{"AllocVideoMem()" LINK "AllocVideoMem()"}

@EndNode
---------------------------------------------------------------------------
@NODE "GetScrType()" "Screens: GetScrType()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        GetScrType()
Résumé:     Obtient le type d'écran par défaut/de l'utilisateur.
Synoptique: LONG GetScrType(void)

@{b}@{u}DESCRIPTION@{uu}@{ub}
Retourne le type d'écran qui est utilisé par défaut dans le module Screen.
Cette fonction est souvent utilisée par d'autres modules, car ScrType est
un paramètre commun à toutes les structures non initialisées par le 
module Screen.

@{b}@{u}RESULTAT@{uu}@{ub}
Le type d'écran par défaut (eg PLANAR).

@EndNode
---------------------------------------------------------------------------
@NODE "HideDisplay()" "Screens: HideDisplay()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        HideDisplay()
Résumé:     Cache tout l'affichage.
Synoptique: *Screen = HideDisplay(void)

@{b}@{u}DESCRIPTION@{uu}@{ub}

Cette FONCTION est privée et à usage interne seulement.

Cette FONCTION va cacher l'affichage de GMS. Cela aura pour conséquence
de retourner le viewport de l'OS, mais GMS tournera toujours en tâche
de fond. Si GMS ne tourne pas par dessus un autre OS alors l'écran GMS
DeskTop sera affiché et la tâche appelante placée en tâche de fond.

Si aucun écran GMS n'est affiché alors cette FONCTION ne fait rien,
et renvoie la valeur NULL.

@{b}@{u}RESULTAT@{uu}@{ub}
Pointeur vers la structure du Screen qui a été cachée par cette fonction.
Est à NULL si aucun Screen n'était actif.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"Display()" LINK "Display()"}

@EndNode
---------------------------------------------------------------------------
@NODE "LockVideo()" "Screens: LockVideo()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        LockVideo()
Résumé:     Verrouille un écran en premier plan pour des opérations vidéo.
Synoptique: void LockVideo(*Screen [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction est requise toutes les fois que vous avez besoin de
dessiner quelque chose sur votre écran, ou si vous voulez utiliser les
champs MemPtrX. Verrouiller un écran est le seul moyen de garantir que
les champs MemPtrX pointent vers la mémoire vidéo.

Essayer de dessiner vers un écran non verrouillé avec le CPU ou le Blitter
peut avoir des résultats désastreux, donc utiliser cette fonction aussi
souvent que nécessaire.

Certains systèmes vont fournir le verrou immédiatement, eg les ordinateurs
UMA et les Amigas standard. Les autres systèmes utilisant des cartes
graphiques ne le feront pas. Votre tâche devra attendre que suffisament de 
mémoire vidéo soit disponible, ce qui ne peut se produire que lorsqu'une
autre tâche déverrouille un écran ou que l'utilisateur ramène votre
tâche en premier plan.

@{b}@{u}NOTE@{uu}@{ub}
Pour maintenir le système stable, screen locks will nest.

@{b}@{u}ENTREE@{uu}@{ub}
Screen - Pointeur vers une structure Screen initialisée.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"UnlockVideo()" LINK "UnlockVideo()"}
Théorie: @{"Video Locking" LINK "VideoLocking"}

@EndNode
---------------------------------------------------------------------------
@NODE "MoveBitmap()" "Screens: MoveBitmap()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        MoveBitmap()
Résumé:     Déplace le Bitmap de l'écran aux valeurs spécifiées par X/Y.
Synoptique: void MoveBitmap(*Screen [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette routine a deux utilisations: le déplacement d'un Bitmap à n'importe
quelle position de l'affichage et le Scrolling Hardware.

Elle va prendre les valeurs de BmpXOffset et BmpYOffset de la structure
Screen et les utiliser pour trouver la nouvelle position de l'image.
Cette fonction s'éxécute à la même vitesse quelles que soient les 
valeurs des déplacements.

Vous devez avoir mis le bit HSCROLL à un pour un scrolling horizontal
et le bit VSCROLL à un pour un scrolling vertical si vous voulez utiliser
cette fonction. Si vous mettez HBUFFER à un dans ScrAttrib alors vous
pouvez utiliser cette fonction pour créer un scrolling hardware légal
qui peut aller jusqu'à 50 écrans dans les deux directions suivant X. 
Ne dessinez aucun graphisme au-delà de ces limites ou bien vous pourriez
endommager le système.

@{b}NOTES@{ub}
Si le hardware ne supporte pas le scrolling hardware, cette routine
blittera problablement l'image entière à la nouvelle position. C'est
très lent mais c'est la seule option.

Le temps d'éxécution de cette fonction en ECS/AGA est de 2/3 d'une
rasterline sur un A1200+Fast.

@{b}@{u}ENTREES@{uu}@{ub}
Screen - Pointeur vers une structure Screen initialisée. Les valeurs
         BmpXOffset et BmpYOffset seront utilisées pour calculer la
         nouvelle position de l'image sur l'écran.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"ResetBitmap()" LINK "ResetBitmap()"}

@EndNode
---------------------------------------------------------------------------
@NODE "PaletteMorph()" "Screens: PaletteMorph()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        PaletteMorph()
Résumé:     Fait un fondu d'un groupe de couleurs vers un autre groupe
            de couleurs.
Synoptique: WORD PaletteMorph(*Screen [a0], WORD FadeState [d0],
           WORD Speed [d1], WORD StartColour [d3], WORD AmtColours [d4],
           LONG *SrcPalette [a1], APTR DestPalette [a2])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction prend la palette désignée par SrcPalette, et l'utilise
pour faire un fondu de certaines de ses couleurs vers celles de la 
palette désignée par DestPalette. Une fois que vous avez appelé cette 
fonction, vous devez continuer à l'appeler jusqu'à ce qu'elle vous 
donne le résultat NULL. Cela vous permet de placer cette fonction dans
une boucle et de faire toutes sortes de choses pendant que le fondu 
suit son cours.

Cette fonction utilise le "proportional fading" (fondu proportionnel)
pour créer cet effet.

@{b}@{u}NOTE@{uu}@{ub}
Toutes les fonctions de fondu ignore les valeurs des couleurs qui sont
gardées en interne. Cela vous causera donc des problèmes si vous ne
savez pas à quoi ressemble votre palette courante en utilisant ces
fonctions. Gardez une trace des valeurs de votre palette et mettez un
pointeur vers elles dans SrcPalette si le problème vous arrive.

@{b}@{u}ENTREES@{uu}@{ub}
Screen      - Pointeur vers une structure Screen initialisée.
FadeState   - Initialisez le à zéro et continuer à envoyer la valeur
              retournée jusqu'à ce que ce paramètre soit NULL.
Speed       - La vitesse requise pour le fondu.
SrcPalette  - Pointeur vers la palette utilisée comme source.
Destpalette - Pointeur vers la palette vers laquelle vous voulez
              fondre.
StartColour - La couleur par laquelle on commence le fondu (0 ....
              AmtColours-1).
AmtColours  - La quantité de couleurs dans le fondu (1 ... Maximum 
              de couleurs).
              Vous ne devez jamais utiliser une valeur nulle ici.

@{b}@{u}RESULTAT@{uu}@{ub}
Retourne NULL si le fondu est terminé.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"ColourMorph()    "     LINK "ColourMorph()"}
         @{"ColourToPalette()" LINK "ColourToPalette()"}
         @{"PaletteToColour()" LINK "PaletteToColour()"}

@EndNode
---------------------------------------------------------------------------
@NODE "PaletteToColour()" "Screens: PaletteToColour()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        PaletteToColour()
Résumé:     Fait un fondu d'un groupe de couleurs vers une couleur
            spécifique.
Synoptique: WORD PaletteToColour(*Screen [a0], WORD FadeState [d0],
	   WORD Speed [d1], LONG StartColour [d3], LONG AmtColours [d4],
           APTR Palette [a1], LONG Colour [d2])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction va faire un fondu entre un certain nombre de couleurs
et une couleur donnée. C'est très pratique pour faire un fondu noir 
de l'écran par exemple. Une fois que vous avez appelé cette fonction,
vous devez continuer à l'appeler jusqu'à ce qu'elle vous donne le
résultat NULL. Cela vous permet de placer cette fonction dans une
boucle et de faire toutes sortes de choses pendant que le fondu suit
son cours.

Cette fonction utilise le "proportional fading" (fondu proportionnel)
pour créer cet effet.

@{b}@{u}NOTE@{uu}@{ub}
Toutes les FONCTIONS de fondu ignore les valeurs des couleurs qui sont
gardées en interne. Cela vous causera donc des problèmes si vous
ne savez pas à quoi ressemble votre palette courante en utilisant ces
fonctions.

@{b}@{u}ENTREES@{uu}@{ub}
Screen      - Pointeur vers une structure Screen initialisée.
FadeState   - Initialisez le à zéro et continuer à envoyer la valeur
              retournée jusqu'à ce que ce paramètre soit NULL.
Speed       - La vitesse requise pour le fondu.
Palette     - Pointeur vers la palette utilisée comme source.
Colour	     - La couleur vers laquelle vous voulez fondre, dans le
              format 0xRRGGBB.
StartColour - La couleur par laquelle on commence le fondu (0 ....
              AmtColours-1).
AmtColours  - La quantité de couleurs dans le fondu (1 ... Maximum 
              de couleurs).
              Vous ne devez jamais utiliser une valeur nulle ici.


@{b}@{u}RESULTAT@{uu}@{ub}
Retourne NULL si le fondu est terminé.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"ColourMorph()    "     LINK "ColourMorph()"}
         @{"PaletteMorph()   "    LINK "PaletteMorph()"}
         @{"PaletteToColour()" LINK "PaletteToColour()"}

@EndNode
---------------------------------------------------------------------------
@NODE "RefreshScreen()" "Screens: RefreshScreen()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        RefreshScreen()
Résumé:     Met à jour l'affichage de l'écran.
Synoptique: void RefreshScreen(*Screen [a0]);

@{b}@{u}DESCRIPTION@{uu}@{ub}



@{b}@{u}ENTREE@{uu}@{ub}
Screen - Pointeur vers une structure Screen initialisée.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"WaitVBL()" LINK "WaitVBL()"}

@EndNode
---------------------------------------------------------------------------
@NODE "RemakeScreen()" "Screens: RemakeScreen()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        RemakeScreen()
Résumé:     Réorganise l'affichage de l'écran en tenant compte de sa
            taille, sa largeur, et sa position sur le moniteur.
Synoptique:  void RemakeScreen(*Screen [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Recalcul le viewport du Screen aussi vite que possible. Si le Screen
est caché, alors les changements ne se verront que la prochaine fois
où vous appellerez la Display(Screen).

Vous ne pouvez pas changer le mode d'affichage, le type de l'écran ou
le nombre de couleurs avec cette fonction.

@{b}@{u}ENTREES@{uu}@{ub}
Screen - Pointeur vers une structure Screen initialisée.

@EndNode
---------------------------------------------------------------------------
@NODE "ResetPicture()" "Screens: ResetPicture()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        ResetPicture()
Résumé:     Remet la position de l'image à X=0,Y=0.
Synoptique: void ResetBitmap(*Screen [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Remet la position de l'image à 0,0. Cette méthode est plus rapide que
de mettre à zéro les paramètres PicXOffset et PicYOffset et ensuite
appeler MoveBitmap().

@{b}@{u}ENTREES@{uu}@{ub}
Screen - Pointeur vers une structure Screen initialisée.

@{b}@{u}RESULTAT@{uu}@{ub}
PicXOffset et PicYOffset du Screen seront mis à zéro.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"MoveBitmap" LINK "MoveBitmap()"}

@EndNode
---------------------------------------------------------------------------
@NODE "ReturnDisplay()" "Screens: ReturnDisplay()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        ReturnDisplay()
Résumé:     Fonction privée.
Synoptique: Screen = ReturnDisplay(void);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction est privée et à usage interne seulement.

Redonne le contrôle de l'affichage à l'OS depuis lequel GMS a été lancé
C'est une fonction spéciale située dans les drivers de moniteurs, et
elle est réservée à une utilisation par le module Screen.

@{b}@{u}RESULTAT@{uu}@{ub}
Pointeur vers le Screen qui a été supprimé.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"TakeDisplay()" LINK "TakeDisplay()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SwapBuffers()" "Screens: SwapBuffers()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        SwapBuffers
Résumé:     Intervertit les buffers d'affichage de l'écran.
Synoptique: void SwapBuffers(*Screen [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Si l'écran est en double buffer, cette FONCTION échange Screen->MemPtr1 
avec Screen->MemPtr2 et active le nouveau bitmap pour qu'il soit affiché.
Si vous utilisez le triple buffering, alors les 3 MemPtr sont intervertis.
Cela donne:  

	@{b}AVANT          APRES@{ub}
	MemPtr1         MemPtr2
	MemPtr2  ---->  MemPtr3
	MemPtr3         MemPtr1

@{b}@{u}ENTREES@{uu}@{ub}
Screen - Pointeur vers une structure Screen initialisée.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Théorie: @{"Dislay Buffering" LINK "DisplayBuffering"}

@EndNode
---------------------------------------------------------------------------
@NODE "TakeDisplay()" "Screens: TakeDisplay()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        TakeDisplay()
Résumé:     FONCTION privée.
Synoptique: LONG TakeDisplay(*Screen [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Prend le contrôle de l'affichage du système d'exploitation sur lequel
GMS a été lancé. C'est une fonction spéciale située dans les drivers de 
moniteurs et réservée à une utilisation par le module Screen.

@{b}@{u}ENTREE@{uu}@{ub}
Screen - Pointeur vers une structure Screen initialisée.

@{b}@{u}RESULTAT@{uu}@{ub}
Retourne ERR_OK si l'appel a réussi.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"ReturnDisplay()" LINK "ReturnDisplay()"}

@EndNode
---------------------------------------------------------------------------
@NODE "UnlockVideo()" "Screens: UnlockVideo()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        UnlockVideo()
Résumé:     
Synoptique: void UnlockVideo(*Screen [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}






@{b}@{u}ENTREE@{uu}@{ub}
Screen - Pointeur vers un objet Screen initialisé.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"LockVideo()"   LINK "LockVideo()"}
Théorie: @{"Video Locking" LINK "VideoLocking"}

@EndNode
---------------------------------------------------------------------------
@NODE "UpdateColour()" "Screens: UpdateColour()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        UpdateColour()
Résumé:     Met à jour la valeur d'une couleur 24 bit $RRGGBB dans la
            palette d'un écran.
Synoptique: void UpdateRGB(*Screen [a0], LONG Colour [d0], LONG RRGGBB [d1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Met à jour la valeur d'une couleur de la palette de l'écran. Le changement
est immédiatement visible lors de la prochaine "Vertical BLank".

@{b}@{u}ENTREES@{uu}@{ub}
Screen - Pointeur vers une structure Screen initialisée.
Colour - Le numéro de la couleur à mettre à jour, compris entre 0 et
         Screen->AmtColours.
RRGGBB - Valeur de la couleur au format standard RRGGBB.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"UpdatePalette()" LINK "UpdatePalette()"}

@EndNode
---------------------------------------------------------------------------
@NODE "UpdatePalette()" "Screens: UpdatePalette()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        UpdatePalette()
Résumé:     Met à jour la palette entière d'un Screen avec les valeurs
            données.
Synoptique: void UpdatePalette(*Screen [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Met à jour la palette entière d'un Screen avec les nouvelles valeurs 
définies dans le champ GS_Palette. Si GS_Palette est NULL alors toutes
les couleurs de l'écran deviendront noires.

Cette fonction n'aucun effet sur les écrans en true colour.

@{b}@{u}NOTE@{uu}@{ub}
Les changements dans la palette ne seront effectifs que lors de la
prochaine "Vertical BLank".

@{b}@{u}ENTREES@{uu}@{ub}
Screen - Pointeur vers une structure Screen initialisée.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"UpdateColour()" LINK "UpdateColour()"}

@EndNode
---------------------------------------------------------------------------
@NODE "WaitRastLine()" "Screens: WaitRastLine()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        WaitRastLine()
Résumé:     Attend que le spot atteigne une ligne spécifique.
Synoptique: void WaitRastLine(WORD LineNumber [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Attend que le faisceau d'électrons atteigne une ligne de l'écran spécifiée
par LineNumber. Les valeurs possibles pour ce paramètre dépendent de la
résolution en hauteur de votre écran, ex 0-255 pour un écran standard 
de 320x256. Il est possible d'entrer des valeurs négatives ou des valeurs
qui dépassent le nombre de lignes de l'écran, mais faites le seulement
si vous le jugez nécessaire.

Cette FONCTION a été spécialement écrite pour éviter les pertes du spot
engendrées par des interruptions inopportunes.

@{b}@{u}ENTREES@{uu}@{ub}
LineNumber - Position verticale du spot à attendre.

@{b}@{u}BUGS@{uu}@{ub}
Si vous entrez une grande valeur comme #350 par exemple,	alors le spot
n'atteindra jamais cette ligne car elle n'existe pas. Cela aura pour 
conséquence de bloquer votre programme. Veuillez donc SVP prendre des
valeurs inférieures ou égales à la hauteur de votre écran.


@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"WaitVBL()" LINK "WaitVBL()"}

@EndNode
---------------------------------------------------------------------------
@NODE "WaitSwitch()" "Screens: WaitSwitch()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        WaitSwitch()
Résumé:     Wait for the buffers to be switched at the vertical blank.
Synoptique: void WaitSwitch(*Screen [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}



@{b}@{u}ENTREE@{uu}@{ub}
Screen - Pointeur vers un objet Screen initialisé.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Théorie: @{"Display Buffering" LINK "DisplayBuffering"}

@EndNode
---------------------------------------------------------------------------
@NODE "WaitVBL()" "Screens: WaitAVBL()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        WaitAVBL()
Résumé:     Attend un "Vertical BLank".
Synoptique: LONG WaitAVBL(void)

@{b}@{u}DESCRIPTION@{uu}@{ub}
Attend le moment où le spot vidéo atteint le début du VBL (juste après
que toutes les données soient affichées à l'écran). Cette routine essaiera
de vous donner le plus d'espace VBL possible en attendant par exemple le
point exact où l'affichage se termine. Si ce n'est pas possible, alors
elle attendra que le spot atteigne le haut du moniteur.

Cette version de WaitVBL() va automatiquement mettre en pause votre tâche
si l'utilisateur s'intéresse à un autre écran. Cela peut être utile, car
il empêche ainsi votre programme de voler des ressources lorsque l'utilisateur
veut faire quelque chose d'autre. 

@{b}@{u}RESULTAT@{uu}@{ub}
Actuellement retourne NULL.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"WaitRastLine()" LINK "WaitRastLine()"}

@EndNode
---------------------------------------------------------------------------
@NODE "WaitVBL()" "Screens: WaitVBL()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        WaitVBL()
Résumé:     Attend un "Vertical BLank".
Synoptique: LONG WaitVBL(void)

@{b}@{u}DESCRIPTION@{uu}@{ub}
Attend le moment où le spot vidéo atteint le début du VBL (juste après
que toutes les données soient affichées à l'écran). Cette routine essaiera
de vous donner le plus d'espace VBL possible en attendant par exemple le
point exact où l'affichage se termine. Si ce n'est pas possible, alors
elle attendra que le spot atteigne le haut du moniteur.

@{b}@{u}RESULTAT@{uu}@{ub}
Actuellement retourne NULL.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Screens: @{"WaitRastLine()" LINK "WaitRastLine()"}

@EndNode
---------------------------------------------------------------------------
@NODE "()" "Screens:"

@{b}@{u}FONCTION@{uu}@{ub}

@{b}@{u}DESCRIPTION@{uu}@{ub}

@{b}@{u}ENTREES@{uu}@{ub}

@{b}@{u}RESULTAT@{uu}@{ub}

@{b}@{u}VOIR AUSSI@{uu}@{ub}

@EndNode
