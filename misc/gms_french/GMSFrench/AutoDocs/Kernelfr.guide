@DATABASE "DPKernel"
@AUTHOR   "Paul Manias"
@NODE     "Main" "Library: DPKernel"

@{b}@{u}DOCUMENTATION SUR LE SYSTEME@{uu}@{ub}
Nom:         @{"DPKERNEL" LINK "Functions"}
Version:     0.9 Beta.
Date:        Décembre 1997
Auteur:      Paul Manias
Traducteur:  Julien Boibessot
Copyright:   DreamWorld Productions, 1996-1997. Tous droits réservés.
Notes:       Ce document est perpétuellement en cours d'écriture et contiendra 
             sûrement bon nombre d'erreurs. Les informations données ne seront
             officielles que lorsque cette autodoc atteindra la version 1.0.

@{b}@{u}CHANGEMENTS DANS LA VERSION 0.9B@{uu}@{ub}
Ajoutés: Flush()
         Read() (vient de filesfr.guide)
         Reset()
         Write() (vient de filesfr.guide)
         Detach()
         AutoStop()

         @{u}Venant de masterfr.guide@{uu}
         FastRandom()
         ReadKey()
         SlowRandom()
         WaitLMB()
         WaitTime()
         WriteDec()

Effacés: SetUserPrefs()
         WaitLMB()
         WriteDec()
         ReadKey()
         AutoSwitch()

Edités:  WaitTime()
         CloseDPK()
         Activate()
         AddSysObject()
@EndNode
---------------------------------------------------------------------------
@NODE "Functions" "DPKernel"

 @{b}OBJETS@{ub}
 @{"Module"    LINK "GMSDev:AutoDocs/Objects/Modulefr.guide/Description"}
 @{"RawData"   LINK "GMSDev:AutoDocs/Objects/RawDatafr.guide/Description"}
 @{"Reference" LINK "GMSDev:AutoDocs/Objects/Referencefr.guide/Description"}
 @{"Segment"   LINK "GMSDev:AutoDocs/Objects/Segmentfr.guide/Description"}
 @{"SysObject" LINK "GMSDev:AutoDocs/Objects/SysObjectfr.guide/Description" }
 @{"Task"      LINK "GMSDev:AutoDocs/Objects/Taskfr.guide/Description"}
 @{"Time"      LINK "GMSDev:AutoDocs/Objects/Time.guide/Description"}
 
@{b}FONCTIONS@{ub}
 @{"AddSysEvent()  "   LINK "AddSysEvent()"}
 @{"AddSysObject() "  LINK "AddSysObject()"}
 @{"AllocMemBlock()" LINK "AllocMemBlock()"}
 @{"AutoStop()"      LINK "AutoStop()"}
 @{"CloseDPK()     "      LINK "CloseDPK()"}
 @{"DPKForbid()    "     LINK "DPKForbid()"}
 @{"DPKPermit()    "     LINK "DPKPermit()"}
 @{"FastRandom()"    LINK "FastRandom()"}
 @{"FindDPKTask()  "   LINK "FindDPKTask()"}
 @{"FindSysObject()" LINK "FindSysObject()"}
 @{"FreeMemBlock() "  LINK "FreeMemBlock()"}
 @{"GetMemSize()   "    LINK "GetMemSize()"}
 @{"GetMemType()   "    LINK "GetMemType()"}
 @{"OpenModule()   "    LINK "OpenModule()"}
 @{"RemSysEvent()  "   LINK "RemSysEvent()"}
 @{"SlowRandom()"    LINK "SlowRandom()"}
 @{"Switch()       "        LINK "Switch()"}
 @{"TagInit()      "       LINK "TagInit()"}
 @{"TotalMem()     "      LINK "TotalMem()"}
 @{"WaitTime()"      LINK "WaitTime()"}

 @{b}Recherche de Ressources@{ub}
 @{"AddTrack()    "     LINK "AddTrack()"}
 @{"DeleteTrack() "  LINK "DeleteTrack()"}
 @{"InitDestruct()" LINK "InitDestruct()"}
 @{"SelfDestruct()" LINK "SelfDestruct()"}

 @{b}ACTIONS@{ub}
 @{"Activate()     "      LINK "Activate()"}
 @{"Clear()        "         LINK "Clear()"}
 @{"CopyStructure()" LINK "Copystructure()"}
 @{"Deactivate()   "    LINK "Deactivate()"}
 @{"Detach()"        LINK "Detach()"}
 @{"Display()      "       LINK "Display()"}
 @{"Draw()         "          LINK "Draw()"}
 @{"Flush()"         LINK "Flush()"}
 @{"Free()         "          LINK "Free()"}
 @{"Get()          "           LINK "Get()"}
 @{"Hide()         "          LINK "Hide()"}
 @{"Init()         "          LINK "Init()"}
 @{"Load()         "          LINK "Load()"}
 @{"Lock()"          LINK "Lock()"}
 @{"Query()        "         LINK "Query()"}
 @{"Read()"          LINK "Read()"}
 @{"Reset()"         LINK "Reset()"}
 @{"Save()         "          LINK "Save()"}
 @{"Unlock()"        LINK "Unlock()"}
 @{"Write()"         LINK "Write()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Activate()" "Kernel: Activate()"

@{b}@{u}ACTION@{uu}@{ub}
Nom:        Activate()
Résumé:     Exécute l'action originelle de l'objet.
Synoptique: LONG Activate(APTR Object [a0]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Exécute l'action originelle d'un objet donné (mais seulement si celui-ci
supporte Activate()). Les actions des différents objets sont très variées
voici quelques exemples de ce que font certains objets lors de l'appel
à Activate():

  Sound     - Joue le sample.
  Restore   - Restaure les parties du fond d'écran détruites.
  Directory - Récupère la liste du contenu d'un répertoire.

Certains objets continueront d'éxécuter leur action première après vous
avoir été retournés, par exemple un Son sera joué en fond pendant que
vous continuer le programme. Si pour une raison particulière vous voulez 
annuler l'action d'un objet vous pouvez essayez d'appeler Deactivate().

@{b}@{u}ENTREE@{uu}@{ub}
Object - Pointeur vers une structure objet initialisée.

@{b}@{u}RESULTAT@{uu}@{ub}
Retourne ERR_OK en cas de succès.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"Deactivate()" LINK "Deactivate()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "AddSysEvent()" "Kernel: AddSysEvent()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:      AddSysEvent()
Résumé:   Ajoute un nouveau noeud d'événement au système.  
Synoptique: *Event AddSysEvent(LONG *Tags)  

@{b}@{u}DESCRIPTION@{uu}@{ub}
Note: Cette partie de l'OS est actuellement en cours de développement,
donc vous l'utilisez à vos propre risques.

Cette fonction ajoute un nouveau noeud d'événement au système. Un événement
est une représentation d'une occurence particulière dans le système
d'exploitation. Des exemples de cela sont l'apparition d'une nouvelle
tâche, la détection d'une disquette insérée par l'utilisateur, mémoire
vide, un nouvel écran affiché et ainsi de suite.

Chaque événement est généré par une partie particulière du système. L'envoie
des événements disquettes est par exemple géré par les routines d'E/S.
Quand un certain événement est signalé par l'un de ces gestionnaires, le
système appellera tous les noeuds qui sont liés à cet événement. Pour 
qu'une application ou un module ajoute un nouveau noeud à cette chaine
d'événement, elle a besoin d'utiliser AddSysEvent().

Les événements actuellement disponibles sont:

  @{"OnNewTask" LINK "EVT_OnNewTask"}
  @{"OnRemTask" LINK "EVT_OnRemTask"} 

@{b}@{u}EXEMPLE@{uu}@{ub}
Cette section  de code  va créer un noeud qui est lié à l'événement
OnNewTask. Notez que le noeud qui est créé aura besoin d'être effacé avec
RemSysEvent() avant que la tâche ne se termine.

  EVTOnNewTask = AddSysEventTags(TAGS,NULL,
     EVA_Number,   EVT_OnNewTask,        /* Type d'événement */
     EVA_Routine,  &OnNewTask,           /* Pointeur vers la routine de l'evt*/
     EVA_Priority, 3,                    /* Définiton de la priorité */
     TAGEND);

@{b}@{u}INPUT@{uu}@{ub}
Tags - Pointeur vers les tags d'initialisation de l'événement. Regardez
       la documentation sur les objets Event pour plus de détails.

@{b}@{u}RESULT@{uu}@{ub}
Retourne un pointeur vers le nouveau noeud d'événement créé.

@{b}@{u}SEE ALSO@{uu}@{ub}
@{"Kernel: RemSysEvent()" LINK "RemSysEvent()"}.

@EndNode
---------------------------------------------------------------------------
@NODE "AddSysObject()" "Kernel: AddSysObject()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        AddSysObject()
Résumé:     Ajoute un nouvel objet au système.
Synoptique: *SysObject AddSysObject(APTR Tags [a0]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Ajoute un nouvel objet au système. L'objectif de cette fonction est de
permettre à votre objet de supporter les fonctions "Action" variées et de
donner au système les informations nécessaires à propos de votre objet.
Exemple:

  JPEGObject = AddSysObjectTags(TAGS,  NULL,
                 SOA_ObjectID,         ID_HIDDEN,
                 SOA_ClassID,          ID_PICTURE,
                 SOA_Nom,             "Picture~Jpeg",
                 SOA_CopyToUniverse,   &PIC_CopyToUniverse,
                 SOA_CopyFromUniverse, &PIC_CopyFromUniverse,
                 SOA_Load,             &PIC_Load,
                 TAGEND);

Ce que AddSysObject() va faire est de créer un type Fils (Child)(appelé Jpeg)
qui appartient à la classe Picture. Du fait que les types fils héritent
des actions des parents, cet objet Jpeg supportera donc des actions telles
que Query(), Init(), Get() et Free().

@{u}Objets Principaux/maitres (Master Objects)@{uu}
Tout objet qui est initialisé avec un ID spécifique sera traité comme
un objet maitre.
Si vous appelez AddSysObject() lorsque l'ID donné est déja utilisé par
un objet maitre dans le système, AddSysObject() ne crééra pas un nouveau
SysObject. A la place il ajoutera les spécifications de votre objet
au SysObject existant.

Par exemple, si vous essayez d'ajouter un objet Picture avec le tag SOA_Activate 
et que l'objet Picture existant ne supporte pas cette action, votre fonction
de support sera ajoutée à l'objet Picture maitre existant.
Si vous spécifiez SOA_Activate|TREPLACE, alors votre fonction Activate
sera placée dans l'objet Picture même si il supporte déjà Activate().
SVP ne prenez pas le flag TREPLACE à la légère - vous pouvez faire cela
seulement si c'est absolument nécessaire. 

@{u}Objets Cachés @{uu}
Vous pouvez déclarer un objet système "caché" en lui passant ID_HIDDEN.
Cela créé à la base un objet qui n'a aucun caractère d'identification.
Cela signifie qu'aucun programme ne sera capable de chercher avec succès
votre objet dans le système. Par exemple, l'action Get() sera complètement
inutile pour chercher votre objet.Le seul moyen d'obtenir votre objet sera
d'utiliser la fonction FindSysObject().

La raison principale pour créer des objets cachés est pour de simples
types d'objets qui ne seront utilisés qu'en interne (dans le système).
Par exemple, le support d'XPK fut implémenté grâce à un objet caché,
car en temps que programmeur vous ne voudriez pas avoir à faire au 
décompactage lors du chargement de données. A l'inverse la fonction
Load()  détectera de manière invisible les fichiers XPK pour vous et 
appellera l'objet XPK caché correspondant pour traiter les données.

@{u}Objets Enfants@{uu}
Pour déclarer un objet enfant, utilisez ID_HIDDEN dans SOA_ObjectID, puis
ensuite utilisez l'identificateur de classe dans SOA_ClassID  (e.g. ID_PICTURE).
Cela est pratique dans des situations où vous voulez ajouter le support
d'un nouveau format de donnée à un objet. Par exemple, lorsque une image
jpeg est chargée, le maitre ne la reconnaitra pas car il n'utilise que
des fichiers IFF. Cet échec va provoquer l'éxécution de la fonction Load()
qui va regarder les objets Fils appartenant à la classe Picture et les
utiliser en remplacement.

L'autre avantage d'un objet Fils est que vous obtenez l'héritage de
fonction du maitre. Ainsi si une action quelconque n'est pas supportée
par votre objet, vous serez toujours capable d'hériter du support des
fonctions du maitre.

@{b}@{u}ENTREE@{uu}@{ub}
Tags - Pointeur vers une liste de tags standard.

@{b}@{u}RESULTAT@{uu}@{ub}
Retourne un pointeur vers l'objet créé ou NULL si erreur.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"Free()" LINK "Free()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "AddTrack()" "Kernel: AddTrack()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        AddTrack()
Résumé:     Ajoute un noeud de recherche de ressources.
Synoptique: LONG AddTrack(LONG Resource [d0], LONG Data [d3], void *Routine [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction est prévue pour une utilisation par les modules système,
mais vous pouvez aussi l'utiliser dans vos programmes si nécessaire.

@{u}A propos de la recherche de ressources@{uu}
Chaque tâche a une liste spéciale de toutes les ressources systèmes qui
sont en cours d'utilisation. Chaque ressource a sa propre liste de noeuds
qui l'identifiée individuellement (eg chaque allocation mémoire a son 
propre noeud ressource). Quand une ressource particulière a été libérée,
la liste est vérifiée et le noeud qui lui est relié est effacé. 
Quand le programme s'arrête, toutes les ressources qui sont encore dans
la liste peuvent être libérées par le noyau, ainsi elles ne s'accumulent
pas dans le système.

Lorsque vous voulez appeler AddTrack() vous avez besoin de lui donner un
ID de ressource qui est constitué d'un des types de ressources suivant.
C'est important car les ressources sont libérées du système dans un ordre
basé sur ces IDs. L'ordre ressemble à ça:

       1. Libère toutes les ressouces basées sur le hardware (blitter,
		   son, etc).
		2. Libère les ressouces complexes (à la fois hardware et 
		   software).
		3. Libère les ressouces habituelles (types définis par 
		   l'utilisateur etc).
		4. Libère la mémoire (toujours libérée en dernier).

Comme vous pouvez le constater un ordre correct est vital, si la mémoire
est libérée en premier cela aura des effets nocifs lors de la libération
des ressources complexes et aussi les types de l'utilisateur. 
Soyez toujours sûr de donner les IDs corrects lorsque vous décrivez vos
ressources. Les IDs sont RES_MEMORY, RES_HARDWARE, RES_COMPLEX et 
RES_CUSTOM, comme c'est souligné dans le fichier include "system/tasks.i".

Passer en paramètre un pointeur de données est optionnel, mais vous en
aurez besoin pour identifier une ressource bien précise plus tard (eg
AllocMemBlock() l'utilise pour stocker un pointeur vers la mémoire allouée).

La routine pointe vers le code qui va libérer la ressource si elle est
toujours active lorsque l'on quitte le programme. Il lui sera passé le
champ Data du noeud de la ressource dans le registre d0, et le champ Key
dans le registre d1. 
Cette routine doit sauver tous les registres CPU qu'elle utilise et peut
seulement libérer sa ressource - elle ne peut faire aucune nouvelle
allocation. Elle peut envoyer des messages d'erreur et de debuggage, ce
qui aidera beaucoup à trouver le problème si quelque chose ne va pas.

@{b}@{u}ENTREES@{uu}@{ub}
Resource - Identifieur correct de la ressource (cf system/tasks.i).
Data     - Pointeur de données optionel pour stocker le noeud de la
	         ressource.
Routine  - Pointeur vers la routine à appeler lors de la libération 
	         de la ressource.

@{b}@{u}RESULTAT@{uu}@{ub}
Retourne une Clé que AddTrack() a utilisée pour identifier de façon unique
la ressource. Vous aurez besoin de stocker la clé quelque part pour quand
vous appellerez DeleteTrack().

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel:  @{"DeleteTrack()"  LINK "DeleteTrack()"}
Include: @{"system/tasks.i" LINK "GMSDev:Includes/system/tasks.i/Main"}

@EndNode
---------------------------------------------------------------------------
@NODE "AllocMemBlock()" "Kernel: AllocMemBlock()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        AllocMemBlock()
Résumé:     Alloue un nouveau bloc mémoire.
Synoptique: APTR AllocMemBlock(LONG Size [d0], LONG MemType [d1]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction alloue un bloc mémoire de la réserve mémoire du système
et le retourne à votre programme. Par défaut toute mémoire est publique.
Ce modèle d'ouverture de mémoire est utilisé pour améliorer le niveau de
communication entre les tâches et les fonctions. Si vous avez besoin de
mémoire privée, vous devrez la demander vous-même et devrez être sûr d'être
la seule tâche à l'utiliser. Une macro AllocPrivate() a été incluse pour
rendre ce type d'allocation plus facile.

@{u}Protection et recherche de ressources@{uu}
Les ID Header et Tail sont utilisés pour offrir une sécurité système
semblable à MungWall, en agissant comme des cookies à chaque fin d'un
bloc mémoire. Vous serez alerté par FreeMemBlock() si les ID sont 
endommagées. C'est une propriété de debuggage permanent, donc il n'y a
pas beaucoup besoin de lancer MungWall pour debugger vos programmes.

La recherche de ressources est automatique, donc vous serez avertis si
vous allouez de la mémoire et oubliez de la libérez lorsque vous quittez
votre programme (ie lorsque vous fermez tout). Cette mémoire sera libérée
à votre convenence.

Par défaut toute mémoire est nettoyée avant qu'elle vous soit donnée.
Par simplicité il n'y a que peu de types de mémoire:

  @{u}MEM_DATA@{uu}
  Adequat pour stocker les données et les variables. C'est le type par
  défaut. Notez que vous n'avez pas le droit de lancer du code depuis ce
  type de mémoire.

  @{u}MEM_CODE@{uu}
  Peut stocker et éxécuter des instructions CPU. Elle a aussi les caractéristiques
  de MEM_DATA, donc vous pouvez y stocker des variables et des données.

  @{u}MEM_VIDEO@{uu}
  Pour afficher des graphismes, et est auusi compatible avec l'interface
  Blitter.

  @{u}MEM_BLIT@{uu}
  Mémoire compatible avec le module Blitter. Actuellement ce module 
  utilise seulement de la mémoire CHIP, mais les versions futures pourront
  aussi supporter le dessin par CPU depuis la mémoire FAST si le graphisme
  est stocké dans cette partie de la mémoire.

  @{u}MEM_SOUND@{uu}
  Mémoire compatible avec l'interface Sound.

Vous pouvez aussi utiliser les flags suivant lorsque vous faîtes votre
allocation mémoire:

  @{u}MEM_PRIVATE@{uu}
  Si d'autres programmes ne doivent pas avoir accès à votre mémoire.

  @{u}MEM_UNTRACKED@{uu}
  Si vous ne voulez pas de recherche de ressources sur votre allocation.
  Vous devez utiliser ce flag seulement si la mémoire fait partie d'une
  ressource complexe qui a déjà été "trackée".

@{b}@{u}ENTREE@{uu}@{ub}
Size    - Taille du bloc mémoire requis en octets.
MemType - Le type de la mémoire à allouer, eg MEM_VIDEO.

@{b}@{u}RESULTAT@{uu}@{ub}
Pointeur vers le début du bloc mémoire alloué ou NULL si erreur.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"FreeMemBlock()" LINK "FreeMemBlock()"}
        @{"GetMemSize()"   LINK "GetMemSize()"}
        @{"GetMemType()"   LINK "GetMemType()"}

@EndNode
---------------------------------------------------------------------------
@NODE "AutoStop()" "Kernel: AutoStop()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     AutoStop()
Short:    Met en pause votre tâche lorsque l'utilisateur quitte votre
          écran où votre fenêtre.
Synoptique: void AutoStop(void)

@{b}@{u}DESCRIPTION@{uu}@{ub}
Si l'utilisateur quitte votre tâche en passant sur un autre écran ou
fenêtre, vous pouvez vouloir mettre en pause vos actions jusqu'à ce que
l'utilisateur retourne à votre tâche. C'est très pratique dans les jeux
et dans les autres programmes non-stop qui peuvent continuer sans interaction
avec l'utilisateur. De tels programmes non-stop peuvent coûter du temps
machine si l'utilisateur fait autre chose et que le programme continue
en tâche de fond.

Si cette fonction s'apperçoit que l'utilisateur s'est déplacé, elle met
en pause votre tâche immédiatement. Lorsque l'utilisateur retourne à votre
tâche, cette fonction retourne à la prochaine instruction de votre
programme.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Switch()" LINK "Switch()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Clear()" "Kernel: Clear()"

@{b}@{u}ACTION@{uu}@{ub}
Nom:        Clear()
Résumé:     Efface un objet graphique de son contenant.
Synoptique: LONG Clear(APTR Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette action va effacer un objet graphique de son contenant. Par exemple
Clear(Bob) va effacer un Bob du Bitmap auquel il est assigné.
Notez que cette fonction ne restaurera pas ce qui était précédemment sous
le graphique - elle ne fait juste que l'effacer. Cela signifie que vous
allez obtenir un rectangle vide ou un masque de l'objet, le plus souvent
de couleur noire.

@{b}@{u}ENTREE@{uu}@{ub}
Object - Pointeur vers un objet initialisé.

@{b}@{u}RESULTAT@{uu}@{ub}
Retourne ERR_OK si l'appel a réussi.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"Draw()" LINK "Draw()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "CloseDPK()" "Kernel: CloseDPK()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:	     CloseDPK()
Résumé:     Ferme le noyau de la librairie.
Synoptique: void CloseDPK(void)

@{b}@{u}DESCRIPTION@{uu}@{ub}
Avant de quitter votre programme vous devrez appeler cette fonction de
sorte que le système sache que vous fermer tout. Si vous ne fermez pas le
noyau avant de quitter votre programme vous allez laisser certaines
allocations mémoire actives et il se peut que des effets indésirables se
produisent.

Cette fonction vérifie vos ressources, ainsi si vous n'avez pas libéré
une ressource système vous en serez averti (si vous obtenez une boite
jaune d'alerte, vous aurez besoin d'utiliser IceBreaker pour obtenir 
une liste détaillée des erreurs).

CloseDPK() est responsable de la getion de l'événement OnRemTask. Cet
événement sera activé dès que votre tâche aura appelé CloseDPK().

@{b}@{u}NOTE@{uu}@{ub}
Souvenez vous que vous ne pouvez plus appeler aucune fonction après
avoir fait un appel à CloseDPK().

Cette fonction est utilisée dans la macro STARTDPK et le fichier dpk.o
donc les programmeurs C et Asm n'ont pas besoin d'appeler cette fonction
explicitement.
Les programmes qui sont démarrés en natif ou depuis l'éxécutable StartDPK
n'auront pas à appeler CloseDPK(). Cela est du au fait que dans ces cas
l'appel sera géré à l'intérieur du système.

@EndNode
-----------------------------------------------------------------------------
@NODE "CopyStructure()" "Kernel: CopyStructure()"

@{b}@{u}ACTION@{uu}@{ub}
Nom:        CopyStructure()
Résumé:     Copie les détails d'une structure vers une autre.
Synoptique: LONG CopyStructure(APTR Source [a0], APTR Destination [a1]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Copie une structure dans une autre. Les structures peuvent être similaires
ou complètement différentes (même une copie Screen -> Sound est possible,
bien que cela n'ait pas beaucoup de résultat).

Cette action copie seulement les champs qui sont actuellement présents
dans l'objet Universe. Cette action NE copie PAS les champs qui contiennent
les flags d'option, les champs qui contiennent des pointeurs vers la zone
principale de données (eg bitplanes d'un écran), ou les champs qui sont
désignés comme privés.

Seul les champs NULL de la structure destination seront changés. Si la
structure destination a déja été initialisée vous verrez que CopyStructure()
n'aura pas d'effets pour cette raison.

@{b}@{u}ENTREES@{uu}@{ub}
Source      - Pointe vers l'objet source.
Destination - Pointe vers l'objet destination.

@{b}@{u}RESULTAT@{uu}@{ub}
Retourne ERR_OK en cas de succès, autrement il se peut qu'elle échoue
à cause d'objets inconnus ou d'arguments non-valides.

@EndNode
-----------------------------------------------------------------------------
@NODE "Deactivate()" "Kernel: Deactivate()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        Deactivate()
Résumé:     Stoppe l'éxécution de l'action première d'un objet.
Synoptique: void Deactivate(APTR Object [a0]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Empêche l'objet donné de continuer à éxécuter son action première.
Cette fonction marche seulement si l'objet a précédemment été appelé
avec Activate(). Si l'objet n'était pas en train d'éxécuter une action,
alors cette fonction ne ferait absolument rien.

@{b}@{u}ENTREE@{uu}@{ub}
Object - Pointeur vers une structure objet initialisée.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"Activate()" LINK "Activate()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "DeleteTrack()" "Kernel: DeleteTrack()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        DeleteTrack()
Résumé:     Efface un noeud de recherche de ressources.
Assembleur: DeleteTrack(Key [d1])
C/C++:      void DeleteTrack(LONG Key);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Efface un noeud de ressource alloué par AddTrack(). Si les noeuds de
ressources ne sont pas effacés ils resteront liés au programme et le
système cherchera à les effacer lorsque le programme se terminera.

Notez que cette fonction efface seulement les @{b}noeuds de ressource@{ub},
elle n'essayera pas de désallouer la ressource en appelant sa fonction de
désallocation.

@{b}@{u}ENTREE@{uu}@{ub}
Key - Une clé (Key) qui a été obtenue par AddTrack().

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"AddTrack()" LINK "AddTrack()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Detach()" "Kernel: Detach()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Detach()
Short:    Détache un objet de sa structure parent.
Synoptique: LONG Detach(APTR Object [a0], APTR Parent [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette action va séparer un objet d'une structure parent, sans causer
de préjudices à l'un des deux. Si cette opération est réussie, vous
pouvez alors utiliser l'objet détaché indépendement de son parent.

Certains détachements sont impossibles ou trop dangereux pour être
tentés, eg un objet Screen n'est rien sans son Bitmap.

@{b}@{u}INPUTS@{uu}@{ub}
Object - L'objet qui doit être détaché.
Parent - Pointeur vers l'objet parent duquel vous voulez le détaché.


@{b}@{u}RESULT@{uu}@{ub}
Retourne ERR_OK si l'appel a réussi. Cet appel peut échouer si l'objet
ne supporte pas l'action Detach(), ou s'il n'est pas attaché à un objet
parent dans la première place.

@EndNode
-----------------------------------------------------------------------------
@NODE "Display()" "Kernel: Display()"

@{b}@{u}ACTION@{uu}@{ub}
Nom:        Display()
Résumé:     Affiche un objet à l'intérieur de son contenant.
Synoptique: LONG Display(APTR Object [a0]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Par appel de cette fonction l'objet sera affiché dans son contenant
spécifié. Si l'objet ne peut être affiché ou s'il n'a jamais été associé
à un contenant lors de Init(), alors l'appel échouera.

a.b}@{u}ENTREE@{uu}@{ub}
Object - L'objet à afficher.

@{b}@{u}RESULTAT@{uu}@{ub}
Retourne ERR_OK si l'appel a réussi.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"Hide()" LINK "Hide()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DPKForbid()" "Kernel: DPKForbid()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        DPKForbid()
Résumé:     Stoppe l'éxécution d'autres tâches/processus.
Synoptique: void DPKForbid(void)

@{b}@{u}DESCRIPTION@{uu}@{ub}
Stoppe l'éxécution de toute autre tâche ou processus jusqu'à ce que vous
appeliez DPKPermit(). Cet appel n'éteindra pas les interruptions.

@{b}@{u}NOTE@{uu}@{ub}
Cette fonction n'a aucun effet dans les systèmes qui ne tournent pas en
multi-tâches.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"DPKPermit()" LINK "DPKPermit()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "DPKPermit()" "Kernel: DPKPermit()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        DPKPermit()
Résumé:     Permet à d'autres tâches de continuer leur éxécution.
Synoptique:  void DPKPermit(void);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Inverse les effets d'un appel à DPKForbid(), ainsi toutes les tâches
peuvent continuer leur éxécution normalement.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"DPKForbid" LINK "DPKForbid()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Draw()" "Kernel: Draw()"

@{b}@{u}ACTION@{uu}@{ub}
Nom:        Draw()
Résumé:     Dessine un objet graphique dans son contenant.
Synoptique: LONG Draw(APTR Object [a0]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette action dessine un objet graphique dans le contenant auquel il a
été précédemment associé. Si l'objet n'a jamais été associé a un contenat
supportant le dessin, cette action n'aura aucun effet. De plus si l'objet
n'a aucune représentation graqhique alors rien ne pourra être dessiné.

Cette action est le plus souvent utilisée pour dessiner des Bobs et
des MBobs.

@{b}@{u}ENTREE@{uu}@{ub}
Object - Pointe vers un objet initialisé que vous voulez dessiner.

@{b}@{u}RESULTAT@{uu}@{ub}
Retourne ERR_OK si l'appel a réussi.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"Clear()" LINK "Clear()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "FastRandom()" "Kernel: FastRandom()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        FastRandom()
Résumé:     Génère un nombre au hazard compris entre 0 et <Range>.
Synoptique: LONG FastRandom(WORD Range [d1]);


@{b}@{u}DESCRIPTION@{uu}@{ub}
Créé un nombre aléatoire le plus rapidement possible. La routine utilise
une division pour déterminer Range et changera automatiquement la valeur
aléatoire chaque fois que vous l'appelerez. Cette routine a été 
complètement testée et génère des nombres vraiment aléatoires et non
redondants.

Rappelez vous que tous les nombres générés son EN-DESSOUS de Range. 
Ajoutez 1 à Range si vous voulez que celui-ci soit inclu.

@{b}@{u}ENTREES@{uu}@{ub}
Range - Un rang entre 1 et 32767. Un rang invalide de 0 	aura pour 
        conséquence une erreur du type "division par zéro".

@{b}@{u}RESULTAT@{uu}@{ub}
Un nombre plus grand ou égal à 0, et @{i}plus petit@{ui} que Range.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Master: @{"SlowRandom()" LINK "SlowRandom()"}
Demos:  @{"demos/randomplot" SYSTEM "GMS:demos/RandomPlot"}

@EndNode
-----------------------------------------------------------------------------

@NODE "FindDPKTask()" "Kernel: FindDPKTask()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        FindDPKTask()
Résumé:     Trouve la structure DPKTask de la tâche courante.
Synoptique: *DPKTask FindDPKTask(void)

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction va retourner la structure DPKTask de la tâche qui l'a
appelée. La structure DPKTask est utilisée pour stocker des données qui
sont spécifiques à votre tâche - des choses telles que les préférences
par exemple. Presque tous les paramètres d'une DPKTask sont privés et
donc vous ne pouvez écrire dessus que si vous êtes un module système.

Pour les curieux, cela prend 3 instructions en assembleur pour récupérer
les noeuds de la tâche, donc vous ne gaspillez pas de temps en appelant
cette fonction.

@{b}@{u}RESULTAT@{uu}@{ub}
Pointeur vers la structure DPKTask.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Include: @{"system/tasks.i" LINK "GMSDev:Includes/system/tasks.i/Main"}

@EndNode
-----------------------------------------------------------------------------
@NODE "FindSysObject()" "Kernel: FindSysObject()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        FindSysObject()
Résumé:     Trouve un objet système en se basant sur son ID.
Synoptique: *SysObject FindSysObject(LONG ID [d0], *SysObject [a0]); *);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction commence à chercher à une structure SysObject lorsqu'on
lui donne un ID et un SysObject initial NULL. Si un SysObject correspondant
est trouvé dans le système, il est retourné immédiatement. Dans le cas
contraire cette fonction va aller dans la liste de référence de l'objet
pour voir si l'objet est disponible sur disque. Si c'est le cas, alors le
module correspondant sera chargé et le SysObject retourné. Dans le cas
contraire, NULL est retourné pour indiquer l'échec de la recherche.

Le premier SysObject correspondant à être retourné est toujours l'objet
maitre de cette classe particulière. Si vous voulez trouver les objets
fils de la classe, appelez FindSysObject() à nouveau et donnez le SysObject
précédemment trouvé.
Le prochain objet correspondant sera trouvé et retourné, dans le cas 
contraire NULL sera retourné s'il n'y a plus d'objets. Notez que si vous
cherchez un objet fils ou caché spécifique vous aurez besoin de vérifier
la chaine de caractère SysObject->Name.

@{b}@{u}NOTE@{uu}@{ub}
Le seul moyen de trouver des objets cachés est de les chercher sous
ID_HIDDEN.

@{b}@{u}ENTREE@{uu}@{ub}
ID        - Un ID d'objet système comme spécifié dans system/register.i.
SysObject - Le dernier SysObject reçu si vous continuez une recherche, ou
            NULL si vous en démarrez une nouvelle.

@{b}@{u}RESULTAT@{uu}@{ub}
SysObject - Le SysObject qui a été trouvé comme résultat de la recherche
            ou NULL si aucun objet correspondant n'a été trouvé.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Include: @{"system/register.i" LINK "GMSDev:Includes/system/register.i/Main"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Flush()" "Kernel: Flush()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Flush()
Short:    Vide les données bufferisées d'un objet.
Synoptique: LONG Flush(APTR Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette action va vider toutes les données bufferisées d'un objet. Elle est
prévue pour les fichiers objets qui peuvent mémoriser des données pour
accélérer le temps de traitement. En résultat de ce vidage, toute données
non-écrite sera renvoyée dans sa location physique, si cela est pratique
pour l'objet en question (eg les fichiers).

Notez que tous objet utilisant une technique de buffer videra automatiquement
ses données lorsque vous le libérerez (Free()).

@{b}@{u}INPUT@{uu}@{ub}
Object - Pointeur vers un objet initialisé.

@{b}@{u}RESULT@{uu}@{ub}
Retourne ERR_OK en cas de succès. Toutes les erreurs retournées par Flush()
ne sont pas fatales, donc vous pouvez continuer à utiliser l'objet même
après un échec.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Reset()" LINK "Reset()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Free()" "Kernel: Free()"

@{b}@{u}ACTION@{uu}@{ub}
Nom:        Free()
Résumé:     Libère un objet et toutes les parties qui lui sont rattachées.
Synoptique: void Free(APTR [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette action va prendre un objet système quelconque et libérer ses
ressources. Elle accepte les listes pour des désallocations multiples.

Si l'objet ne possède pas la propriété d'être libéré, alors elle supposera
que celui-ci n'en n'a pas besoin. Cependant, ce cas est très rare.

Une fois que l'objet a été libéré, le pointeur que vous avez passé à
Free() devient immédiatement invalide. Pour cette raison, toute référence
à l'objet doit être assignée à NULL pour éviter à des Bugs d'apparaitre
dans le programme.

@{b}@{u}ENTREE@{uu}@{ub}
APTR - Pointeur vers :
          Object, ListV1, ListV2, TagList, ObjectList

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"Get()"  LINK "Get()"}
        @{"Init()" LINK "Init()"}

@EndNode
---------------------------------------------------------------------------
@NODE "FreeMemBlock()" "Kernel: FreeMemBlock()" 

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        FreeMemBlock()
Résumé:     Libère un bloc mémoire alloué précédemment.
Synoptique: void FreeMemBlock(APTR MemBlock [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Libère un espace mémoire alloué par AllocMemBlock(), AllocVideoMem(),
AllocBlitMem(), ou AllocSoundMem(). Si il manque le mem header/tail,
alors il y a fort à parier que quelque chose a écrit sur les limites de
votre bloc mémoire, ou bien alors que vous êtes en train de libérer une
allocation qui n'existe pas. Normalement cela causerait un crash du système,
mais à la place nous envoyons simplement un message à Icebreaker et nous
laissons le bloc mémoire au système.

Gardez à l'esprit qu'il est judicieux de sauvegarder votre travail et de
rebooter votre ordinateur si un tel message apparaît, car il indique que
des données-mémoire importantes peuvent avoir été détruites.

@{b}@{u}NOTE@{uu}@{ub}
N'essayez jamais de libérer le même MemBlock deux fois de suite.

@{b}@{u}ENTREE@{uu}@{ub}
MemBlock - Pointe vers le début du bloc mémoire. Si ce paramètre est 
           NULL, alors rien ne se passera (la fonction existe).

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"AllocMemBlock()" LINK "AllocMemBlock()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Get()" "Kernel: Get()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        Get()
Résumé:     Obtient la dernière version d'un objet spécifié.
Synoptique: APTR Get(LONG ID [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction va récupérer la dernière version de tout objet que vous
spécifié dans l'argument ID. Cela bien sûr n'est possible que si l'objet
a été correctement installé et se trouve actuellement dans le système.

Les écrans, les images, les sons sont permanents et par conséquent 
toujours reconnus tandis que des choses comme un CardSet sont optionnels
et doivent avoir été installés avant tout.[Get() retrouve ces types
d'objets en utilisant les fichiers de référence dans GMS:System/References/].

Tout les objets appelés par Get() sont étiquetés avec une clé de
ressource. Avant la fin de votre programme vous devrez libérer l'objet
avec l'action Free().
Si vous voulez que votre programme se termine en laissant certains
objets dans le système (ie pour que d'autres programmes puissent les
utiliser), alors vous pouvez faire un OU logique entre l'argument
ID et GET_NOTRACK.

La structure sera retournée avec des champs vides, à vous donc de les
remplir suivant vos besoin.

Cette fonction est le seul moyen legal d'obtenir un objet système.
Si vous pensiez pouvoir compiler des objets directement dans votre
programme oubliez cette idée - votre programme se crasherait.

@{b}@{u}ENTREE@{uu}@{ub}
ID - Un des ID spécifiés dans le fichier system/register.i.

@{b}@{u}RESULTAT@{uu}@{ub}
Object - La dernière version de l'objet spécifié ou NULL si erreur.
         (causée par un manque de mémoire ou un ID inconnu).

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel:  @{"Free()" LINK "Free()"}
         @{"Init()" LINK "Init()"}
Include: @{"system/register.i" LINK "GMSDev:Includes/system/register.i/Main"}

@EndNode
-----------------------------------------------------------------------------
@NODE "GetMemSize()" "Kernel: GetMemSize()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        GetMemSize()
Résumé:     Identifie la taille d'un bloc mémoire donné.
Synoptique: LONG GetMemSize(APTR MemBlock [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction va obtenir la taille de n'importe quel bloc mémoire
légalement obtenu par AllocMemBlock(). Des pointeurs illégaux auront pour 
résultat NULL.

@{b}@{u}ENTREE@{uu}@{ub}
MemBlock - Pointeur vers le début du bloc mémoire devant être identifié.

@{b}@{u}RESULTAT@{uu}@{ub}
Size - La taille du bloc mémoire en octets.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"GetMemType()" LINK "GetMemType()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "GetMemType()" "Kernel: GetMemType()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        GetMemType()
Résumé:     Identifie le type de mémoire utilisée par un bloc mémoire
            particulier.
Synoptique: LONG GetMemType(APTR MemBlock [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction va obtenir le type de mémoire de tout bloc mémoire obtenu
légalement par AllocMemBlock().  Des pointeurs illégaux auront pour 
résultat -1.

@{b}@{u}ENTREE@{uu}@{ub}
MemBlock - Pointeur vers le début du bloc mémoire devant être identifié.

@{b}@{u}RESULTAT@{uu}@{ub}
Type - Flag mémoire identifiant le bloc (voir @{"AllocMemBlock()" LINK "AllocMemBlock()"}).

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"GetMemSize()" LINK "GetMemSize()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Hide()" "Kernel: Hide()"

@{b}@{u}ACTION@{uu}@{ub}
Nom:        Hide()
Résumé:     Cache un objet qui est affiché.
Synoptique: void Hide(APTR Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Si vous avez réussi à afficher un objet, alors vous pouvez appeler Hide()
pour retirer celui-ci de l'affichage. Si l'objet n'est pas affiché alors
l'appel sera ignoré.

@{b}@{u}ENTREE@{uu}@{ub}
Object - Pointeur vers un objet initialisé et qui a été affiché.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"Display()" LINK "Display()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Init()" "Kernel: Init()"

@{b}@{u}ACTION@{uu}@{ub}
Nom:        Init(), InitTags()
Résumé:     Initialise un objet de telle sorte qu'il soit utilisable.
Synoptique: APTR Init(APTR Data [a0], APTR Container [a1])
          APTR InitTags(APTR Container, LONG tag1type, ...)

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction initialise tout objet système reconnu. L'argument
"Container" (contenant) dépend du type d'objet que vous initialisez
(eg un Bob a besoin d'un Ecran ou d'un Bitmap) donc il n'est pas 
toujours nécessaire dans fournir un.

Si vous fournissez une Liste ou une Liste d'objets sachez que Init()
prendra le même contenant pour TOUS les objets de la liste. Pour cette
raison les objets doivent partager certaines similitudes au niveau du
contenant (eg n'initialisez pas un son dans une liste de Bobs).

Si l'initialisation échoue, alors Init() va chercher toute classe fille
qui pourrait gérer l'initialisation de l'objet.
Si une classe fille y correspond, l'objet fera ses références futures
à cette classe et non au maitre.

Cette action retournera NULL en cas d'erreur, vous pouvez récupérer
les messages d'erreurs en utilisant IceBreaker.

@{u}Note aux Programmeurs de Modules@{uu}
Si votre module échoue dans l'initialisation de l'objet, Init() libérera
l'objet pour vous - n'essayez pas de libérer l'objet vous-même.

@{b}@{u}ENTREES@{uu}@{ub}
Data      - Pointeur vers: un Objet, une TagList, une ListV1, une ListV2 ou
            une liste d'objets.
Container - Certains objets ont besoin d'être initialisés à un "contenant"
            ou à un objet parent. Dans ce cas spécifiez cet objet ici.

@{b}@{u}RESULTAT@{uu}@{ub}
Pointeur vers l'objet initialisé.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"Free()" LINK "Free()"}
        @{"Get()"  LINK "Get()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "InitDestruct()" "Kernel: InitDestruct()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        InitDestruct()
Résumé:     Initialise la tâche pour une utilisation de Selfdestruct().
Synoptique: void InitDestruct(APTR DestructCode [a0], APTR DestructStack [a1])


@{b}@{u}DESCRIPTION@{uu}@{ub}
C'est une fonction spéciale qui est appelée dans la macro STARTDPK, dans
le fichier startup gms.o et dans le programme StartDPK. Vous ne devez
jamais appeler cette fonction explicitement à moins que vous écriviez
votre propre startup code.

InitDestruct() prépare votre tâche afin qu'elle soit détruite par la
fonction SelfDestruct(). DestructCode doit pointer vers le code de sortie
pour votre tâche. Le code de sortie doit appeler CloseDPK() à un endroit 
si vous voulez libérer les ressources de votre tâche. DestructStack doit
pointer vers la bonne zone de pile pour votre code de sortie sinon votre 
tâche ne pourra redonner la main au système correctement

Pour voir un exemple de son fonctionnement regardez la macro STARTDPK 
dans le fichier "dpkernel.i".

@{b}@{u}ENTREES@{uu}@{ub}
DestructCode  - Pointe vers le code avec lequel votre tâche doit sortir.
DestructStack - Pointe vers la pile qui sera utilisée pour la sortie.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"SelfDestruct()" LINK "SelfDestruct()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Load()" "Kernel: Load()"

@{b}@{u}ACTION@{uu}@{ub}
Nom:        Load()
Résumé:     Charge un fichier et l'initialise comme un objet système.
Synoptique: APTR Load(APTR Source [a0], LONG ID [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Charge un fichier, trouve son objet natif et retourne un objet qui a
été initialisé et prêt à être utilisé.

Si vous fournissez un ID spécial ID_MEMBLOCK, Load() va alouer un bloc
mémoire MEM_DATA, charger tout le contenu du fichier dans celui-ci et
ensuite vous retourner le pointeur vers le bloc mémoire.
Vous aurez besoin de libérer ce pointeur avec FreeMemBlock() quand
vous en aurez fini avec lui.

Le fichier sera chargé en tenant compte du format préféré de l'objet
eg le chargement des données d'une image sera toujours fait en mémoire
vidéo. Si vous avez besoin de plus de puissance pour le chargement d'un
objet particulier, utilisez Init() plutôt que Load().

@{b}@{u}NOTE@{ub}@{uu}
Si cette fonction ne peut trouver immédiatement d'objet qui reconnaisse
la structure, Load() va probablement ouvrir le fichier en utilisant
l'objet RawData.

@{b}@{u}ENTREE@{uu}@{ub}
Source - Nom du fichier ou pointeur vers un espace mémoire.
ID     - Force le type d'objet que vous voulez qu'il vous soit retourné.
         Utilisez NULL si vous voulez que Load() évalue le fichier et
         retourne l'objet approprié.

@{b}@{u}RESULTAT@{uu}@{ub}
Pointeur vers l'objet initialisé ou NULL si erreur. Souvenez vous que
RawData est utilisé si aucun autre objet ne reconnait le fichier source.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"Free()" LINK "Free()"}
        @{"Init()" LINK "Init()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "OpenModule()" "Kernel: OpenModule()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        OpenModule()
Résumé:     Fournit un moyen rapide d'ouvrir un module.
Synoptique: *Module OpenModule(LONG ID [d0], BYTE *Name [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}





@{b}@{u}ENTREE@{uu}@{ub}
ID   - ID du module à ouvrir (peut être NULL si Name est fourni).
Name - Nom du module à ouvrir (non requis si ID est connu).

@{b}@{u}RESULTAT@{uu}@{ub}
Pointeur vers une structure Module initialisée ou NULL si une erreur
s'est produite.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Object: @{"Module" LINK "GMSDev:AutoDocs/Objects/Modulefr.guide/Description"}
Kernel: @{"Init()" LINK "Init()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Query()" "Kernel: Query()"

@{b}@{u}ACTION@{uu}@{ub}
Nom:        Query()
Résumé:     Obtient les dernières informations sur un objet particulier.
Synoptique: LONG Query(APTR Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
En appelant Query() vous allez mettre à jour tous les champs de l'objet
donné par rapport aux changements depuis le dernier Query() ou depuis
l'initialisation.

Des exemples d'utilisation de Query() sont l'obtention d'informations
sur des fichiers images (telles que la hauteur, la largeur, le nombre
de couleurs) et l'obtention des changements dans les données, telles
que les informations données par le joystick.

@{b}@{u}ENTREE@{uu}@{ub}
Object - Pointeur vers un objet alloué par Get().

@{b}@{u}RESULTAT@{uu}@{ub}
ErrorCode - ERR_OK si l'appel est réussi.

@EndNode
-----------------------------------------------------------------------------
@NODE "Read()" "Kernel: Read()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Read()
Short:    Met les données d'un objet dans un buffer.
Synoptique: LONG Read(APTR Object [a0], APTR Buffer [a1], LONG Length [d0]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction va lire un nombre d'octets déterminé par 'Length' depuis
l'objet vers un buffer donné en mémoire. La lecture commencera à la
position déterminée par le champ 'Byte Position' de l'objet. Ce champ sera
incrémenté à BytePos+Length si l'appel à la fonction a réussi.
Des appels futurs à Read() commenceront donc là où vous vous êtes arrêté.

Si la longeur dépasse la taille totale du fichier alors cette fonction
ne lira que les mots restant dans le fichier. Vous pouvez toujours comparer
les champs BytePos et Size pour voir combien d'octets il reste à lire dans
l'objet.

@{b}@{u}INPUT@{uu}@{ub}
Object - Pointeur vers un objet initialisé.
Buffer - Pointeur vers un espace mémoire dans lequel seront écrites 
         les données.
Length - Nombre d'octets à lire dans l'objet.

@{b}@{u}RESULT@{uu}@{ub}
Retourne le nombre total de données placés dans le buffer. NULL peut
indiquer une erreur ou bien le fait qu'il n'y a plus de données à lire.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Write()" LINK "Write()"}

@EndNode
-----------------------------------------------------------------------------

@NODE "RemSysEvent()" "Kernel: RemSysEvent()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        RemSysEvent()
Résumé:     Enlève un tag d'événement du système.
Synoptique: void RemSysEvent(*Event [a0])    

@{b}@{u}DESCRIPTION@{uu}@{ub}
Non documenté.

@{b}@{u}NOTE@{uu}@{ub}

@{b}@{u}ENTREE@{uu}@{ub}

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"AddSysEvent()" LINK "AddSysEvent()"}

@EndNode
---------------------------------------------------------------------------
@NODE "Reset()" "Kernel: Reset()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Reset()
Short:    Repositionne un objet dans un état réceptif.
Synoptique: LONG Reset(APTR Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette action va repositionner un objet dans un état réceptif à de nouveau
processus. Son comportement dépend grandement de l'objet at hand. Des fichers
vont remettre leur 'byte position' à 0 pour toutes les prochaines
opérations d'E/S, alors que les objets Restore vont abandonner tout état
courant de restauration et oublier toutes les données mémorisées.

@{b}@{u}NOTE@{uu}@{ub}
Reset() n'est pas équivalent à Flush(). Certains objets vont se flusher
eux mêmes avant d'éxécuter l'action de reset, d'autres non. Cela dépend
des circonstances, mais si vous voulez flusher les données alors utilisez
l'action Flush().

@{b}@{u}INPUT@{uu}@{ub}
Object - Pointeur vers un objet initialisé.

@{b}@{u}RESULT@{uu}@{ub}
Une erreur sera retournée si l'action ne peut être éxécutée. Cela peut
se produire si l'objet ne supporte pas ou n'a pas besoin de l'action
Reset().

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Flush()" LINK "Flush()"}

@EndNode
---------------------------------------------------------------------------
@NODE "Save()" "Kernel: Save()"

@{b}@{u}ACTION@{uu}@{ub}
Nom:        Save()
Résumé:     Ecrit toutes les informations d'un objet dans le fichier
            destination.
Synoptique: LONG Save(APTR Object [a0], APTR Destination [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette action va sauver toutes les données d'un objet dans un fichier
dans un format de données récupérable par l'action Load(). Par exemple:
par défaut, l'objet Picture sauve toutes les images dans le format IFF,
et elle supporte aussi le chargement d'images dans ce format.

Il sera possible à un objet Fils de sauver un fichier dans son propre
format (ie au lieu du format du maitre). De cette façon l'utilisateur
pourra faire des conversions de fichiers telles que charger une image
en IFF et la sauver en JPEG. La méthode pour arriver à cela est encore
'under-way', mais pour simplifier la travail du programmeur, l'utilisateur
sera probablement capable de choisir ses types préférés de sauvegarde
dans GMSPrefs.

@{b}@{u}ENTREE@{uu}@{ub}
Object      - Pointeur vers un objet initialisé.
Destination - Pointeur vers une structure Source/Destination telle qu'un
              nom de fichier (Filename), un MemPtr ou fichier objet

@{b}@{u}RESULTAT@{uu}@{ub}
Retourne ERR_OK si l'appel a réussi.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"Load()" LINK "Load()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SelfDestruct()" "Kernel: SelfDestruct()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        SelfDestruct()
Résumé:     Détruit la tâche et libère ces ressources.
Assembleur: SelfDestruct()
C/C++:      void SelfDestruct(void);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Détruit la tâche qui a appelé cette fonction et libère toutes les ressources
lui étant associées en se référant aux noeuds de ressources. C'est une
manière entièrement sûr et efficace pour détruire une tâche, et qui peut
être utilisée pour démanteler une tâche lorsque celle-ci se met à planter.

Vous devez appeler InitDestruct() avant d'appeler cette fonction. Si vous
programmez en C ou en assembleur cette initialisation est incluse dans
la macro STARTDPK et dans le fichier startup gms.o, donc vous n'êtes pas
concerné.

@{b}@{u}NOTE@{uu}@{ub} 
Cette fonction ne retournera rien. Cependant si InitDestruct() n'a pas
été appelée alors la fonction sera incapable de faire quoique ce soit et
rendra la main à la tâche.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"InitDestruct()" LINK "InitDestruct()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "SlowRandom()" "Kernel: SlowRandom()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        SlowRandom()
Résumé:     Génère un nombre au hasard entre 0 et <Range>.
Synoptique: LONG SlowRandom(WORD Range [d1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Génère un très bon nombre aléatoire en relativement peu de temps. Cette
routine prend approximativement deux fois plus de temps que FastRandom()
mais il est sûr qu'elle donne d'excellentes séquences de nombres
aléatoires.

Rappelez vous que tous les nombres générés son EN-DESSOUS de Range. 
Ajoutez 1 à Range si vous voulez que celui-ci soit inclu.

@{b}@{u}ENTREES@{uu}@{ub}
Range - Un rang entre 1 et 32767.

@{b}@{u}RESULTAT@{uu}@{ub}
Random - Un nombre plus grand ou égal à 0, et @{i}plus petit@{ui} que Range.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"FastRandom()" LINK "FastRandom()"}
Demos:  @{"demos/randomplot" SYSTEM "GMS:demos/RandomPlot"}

@EndNode
---------------------------------------------------------------------------
@NODE "Switch()" "Kernel: Switch()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        Switch()
Résumé:     Arrête la tâche qui a appelé cette fonction.
Assembleur: Switch()
C/C++:      void Switch(void);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Permutte votre tâche avec la prochaine dans la queue. Cette fonction ne
rendra la main que lorsque l'utilisateur aura réactivé votre tâche, donc
l'éxécution de votre tâche est stoppée. Tous processus secondaire et
interruption que vous avez engendré continuera à s'éxécuter, donc le
multi-tâche est toujours effectifs.

Si la tâche suivante utilise un écran, alors votre écran sera retiré de
l'affichage et le nouvel écran sera affiché. Si vous avez des tâches 
secondaires qui tournent notez cela: vous devez les empêcher d'utiliser
les opérations de dessin et le Blitter car votre mémoire d'affichage peut
être temporairement déplacée pour libérer de la mémoire vidéo. 
"Blitter" sur un affichage invisible est considéré comme une mauvaise 
habitude à ne pas prendre car la plupart des tâches GMS ont besoin de 
tout le temps Blitter disponible.  Nous vous demandons aussi de ne pas
utiliser les fonctions audio car la tâche suivante aura peut-être besoin
de tous les canaux.

Si il n'y plus de tâches dans la queue, alors l'affichage reviendra
à Intuition. GMS supporte deux méthodes pour permutter les écrans avec
Intuition, Switch-To-Window et Switch-To-Screen. La méthode à utiliser
dépend des paramètres dans GMSPrefs.

Switch-To-Window revient au Workbench et place une fenêtre sur l'écran.
Elle attendra que le bouton de fermeture soit pressé, puis votre jeu
reprendra là où vous l'aviez quitté.

Switch-To-Screen ouvre un écran Intuition et attend que cet écran soit
"au devant" de l'affichage. A ce moment l'écran Intuition sera fermé et
votre jeu continuera son éxécution.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"AutoStop" LINK "AutoStop()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "TagInit()" "Kernel: TagInit()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        TagInit()
Résumé:     Initialise une structure d'après une liste de Tags.
Synoptique: LONG TagInit(APTR Structure [a0], APTR TagList [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction est prévue pour les modules systèmes mais peut aussi être
utilisée par les programmes si besoin.

Elle traite une liste de Tags standard et stocke les valeurs spécifiées
dans les structures fournies, qui doivent être vides bien que ce ne soit
pas indispensable. Il est important que les Tags eux-même aient été 
correctement définis en utilisant les flags TBYTE, TWORD et TLONG.
Regardez les includes pour avoir des exemples.

Cette fonction a une protection mémoire logicielle et empêchera que des
valeurs soient écrites en dehors de la zone mémoire d'une structure.
Les erreurs détectées seront envoyées au debugger système.

@{b}@{u}ENTREES@{uu}@{ub}
Structure - Pointeur vers la structure mémoire allouée.
TagList   - Pointeur vers une liste de Tags GMS standard (Voir les Tags).


@{b}@{u}RESULTAT@{uu}@{ub}
Retourne ERR_OK si pas d'erreurs.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"Get()" LINK "Get()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "TotalMem()" "Kernel: TotalMem()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        TotalMem()
Résumé:     Obtient la quantité totale de mémoire utilisée par la tâche.
Synoptique: LONG TotalMem(*DPKTask [a0], LONG Flags [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Obtient la quantité totale de mémoire actuellement utilisée par la tâche.
Ce total peut être calculé pour un type spécifique de mémoire ou pour
un total de toutes les mémoires en cours d'utilisation si -1 est
spécifié. Si pour DPKTask vous mettez NULL alors cette fonction va
additionner les tailles mémoires utilisées par toutes les tâches du
système.

@{b}@{u}ENTREE@{uu}@{ub}
DPKTask - Pointeur vers un objet DPKTask, ou NULL pour calculer la mémoire
          occupée par toutes les tâches.
Flags   - Le type de mémoire que vous voulez qui soit calculée (MEM_VIDEO,
          MEM_SOUND, MEM_DATA ou MEM_BLIT). Si vous voulez le total
          de toutes les mémoires en utilisation, spécifié -1 ici. 

@{b}@{u}RESULTAT@{uu}@{ub}
Total - La quantité totale de mémoire en utilisation.

@EndNode
-----------------------------------------------------------------------------
@NODE "WaitTime()" "Kernel: WaitTime()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        WaitTime()
Résumé:     Attend un certain nombre de micro-secondes.
Synoptique: void WaitTime(LONG MicroSeconds [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Attend pendant un certain nombre de micro-secondes. Pendant ce temps,	la
fonction va réduire la priorité de la tâche et faire des appels réguliers
à AutoStop() pour vous.

@{b}@{u}INPUT@{uu}@{ub}
MicroSeconds - Nombre de micro-secondes à attendre (100 = 1 Seconde).

@EndNode
---------------------------------------------------------------------------
@NODE "Write()" "Kernel: Write()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        WriteFile()
Résumé:     Ecrit un nombre donné d'octets dans l'espace donnée d'un objet.
Synoptique: LONG Write(APTR Object [a0], APTR Buffer [a1], LONG Length [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette action va écrire un nombre de mots déterminé par 'Length', depuis
le buffer en mémoire vers un objet donné. L'écriture commencera à la
position déterminée par le champ de BytePos de l'objet. Ce champ sera 
incrémenté à la valeur BytePos+Length si l'appel de la fonction a réussi.

Si BytePos+LeºÑºÓ dépasse la taille totale du fichier, alors l'objet pourra
augmenter la taille de son espace donnée pour pouvoir écrire tout ce qui
est contenu dans le reste du buffer. Cela se produira à chaque fois avec
les fichiers, mais des objets basés sur la mémoire seront rarement capable
de faire cela.

@{b}@{u}ENTREES@{uu}@{ub}
Object - Pointeur vers un objet initialisé.
Buffer - Pointeur vers les données à écrire dans l'objet.
Length - Nombre d'octets à écrire.

@{b}@{u}RESULTAT@{uu}@{ub}
Retourne le nombre d'octets écrits. NULL indique une erreur.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Kernel: @{"Read()" LINK "Read()"}

@EndNode@NODE "()" "Kernel:"

-----------------------------------------------------------------------------
