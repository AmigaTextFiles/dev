@DATABASE "Debug"
@AUTHOR   "Paul Manias"
@NODE     "Main" "Documentation sur le Debuggage"

@{b}@{u}MODULE DOCUMENTATION@{uu}@{ub}
Nom:        @{"DEBUG" LINK "Functions"}
Version:    0.9 Beta.
Date:       Décembre 1997
Auteur:     Paul Manias
Traducteur: Julien Boibessot
Copyright:  DreamWorld Productions, 1996-1997. Tous droits réservés.
Notes:      Les fonctions Debug sont situées dans DPKernel. Elles ne 
            sont activées que lorsque le debuggeur "IceBreaker" est
            chargé.

@{b}@{u}CHANGEMENTS DANS LA VERSION 0.9B@{uu}@{ub}
Renomé:  ErrorMessage() to ErrCode()

Edité:   ErrCode()
         DebugMessage() "see also"

Ajouté:  DPrintF()

@EndNode
---------------------------------------------------------------------------
@NODE "Functions" "Fonctions de Debuggage"

 @{b}FONCTIONS@{ub}
 Ces fonctions sont répertoriées dans dpkernel.

 @{"DebugMessage()" LINK "DebugMessage()"}
 @{"  DPrintF()   "      LINK "DPrintF()"}
 @{"  ErrCode()   "      LINK "ErrCode()"}
 @{"  StepBack()  "     LINK "StepBack()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "DebugMessage()" "Debug: DebugMessage()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        DebugMessage()
Résumé:     Envoie un message au debugger.
Synoptique: void DebugMessage(LONG Type [d7], char *String [a5]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Envoie un message au debugger de GMS, si celui-ci est actif. Si le
debugger n'est pas actif cette fonction est sans effets.

Cette fonction est prévue pour une utilisation dans les modules système,
mais vous pouvez aussi l'utiliser dans des programmes standards pour
envoyer vos propres messages de debuggage. Si tel est le cas alors vous aurez à
utiliser le type DBG_Message et devrez fournir un pointeur vers un 
String (chaine de caractère). Le message sera affiché en gras, ainsi
vous pouvez facilement l'identifier dans une sortie du debugger.

@{u}PROGRAMMEURS DE MODULES@{uu}
Vouss vous appercevrez qu'il y a un type debug pour toutes les initialisations
de fonctions GMS. Si vous utilisez DebugMessage() à l'intérieur de votre
module, il doit être appelé au début de chaque fonction, au fur et à 
mesure que le debugger aura besoin de connaitre vos paramètres. Vous
pouvez aussi utiliser le flag STEP dans le Type parameter ainsi le 
debugger peut créer des sorties sous forme d'arbres. Si cela est le cas
vous aurez besoin d'appeler StepBack() à la fin de la fonction.


@{b}@{u}ENTREES@{uu}@{ub}
Type   - Un des code de debuggage qui est décrit dans games/debug.i.
String - Chaine de caractère optionnelle utilisée par quelques codes de
         debuggage tels que DBG_Message.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Debug: @{"ErrCode()" LINK "ErrCode()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "DPrintF()" "Debug: DPrintF()"

@{b}@{u}FUNCTION@{uu}@{ub}
Nom:      DPrintF()
Résumé:   Envoie une chaine de caractères formattés au debugger.
Synoptique: void DPrintF(const BYTE *Array [a5], ...);

@{b}@{u}DESCRIPTION@{uu}@{ub}
La fonction DPrintF() a la même fonctionnalité et les mêmes commandes que
la fonction ANSI PrintF(). La seule différence est qu'elle imprime
directement dans la fenêtre de debuggage. A cause d'une limite interne
votre chaine de caractère est limitée à un total de 256 octets, mais vous
ne devez pas dépasser 60 octets si vous ne voulez pas écrire sur une
seconde ligne. Vous ne pouvez fournir à cette fonction qu'un maximum de
5 paramètres "%".

@{b}@{u}EXEMPLE@{uu}@{ub}
L'exemple suivant va imprimer la largeur par défaut d'un objet Screen
dans la fenêtre du debugger.

void main(void)
{
   if (Screen = Get(ID_SCREEN)) {
      if (Init(Screen,NULL)) {
         DPrintF("La largeur de l'écran est: %d", Screen->Width);
      }
      Free(Screen);
   }
}

@{b}@{u}ENTREE@{uu}@{ub}
Array - Le premier membre doit être une chaine de caractères. Tous les
        autres membres doivent être fournis en tenant compte des caractères
        de formattage (1 paramètres pour chaque "%" utilisé).

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Debug: @{"DebugMessage()" LINK "DebugMessage()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "ErrCode()" "Debug: ErrCode()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        ErrorMessage()
Résumé:     Envoie un message d'erreur au debugger.
Synoptique: LONG ErrCode(LONG ErrorCode [d0]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Envoie un d'erreur au debugger GMS si celui-ci est actif. Si le debugger 
n'est pas actif alors cette fonction est sans effets.
	
Cette fonction est prévue pour une utilisation dans les modules système,
mais vous pouvez aussi l'utiliser dans des programmes standards pour 
envoyer vos propres messages d'erreurs. Le message sera affiché en gras,
ainsi vous pouvez facilement l'identifier dans une sortie du debugger.

@{b}@{u}ENTREE@{uu}@{ub}
ErrorCode - Code standard d'erreur GMS décrit dans games/games.i.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Debug: @{"DebugMessage()" LINK "DebugMessage()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "StepBack()" "Debug: StepBack()"

@{b}@{u}FONCTION@{uu}@{ub}
Nom:        StepBack()
Résumé:     Revient en arrière dans l'arbre de debuggage de IceBreaker.
Assembleur: StepBack()
C/C++:      void StepBack(void);

@{b}@{u}DESCRIPTION@{uu}@{ub}
Cette fonction est prévue pour une utilisation par les modules système.
Vous pouvez l'utiliser dans vos propres programmes si vous voulez avoir
les propriétés d'arborescence de IceBreaker pour vous aider dans vos
sorties.

StepBack() s'utilise en parallèle avec le flag STEP dans la fonction
DebugMessage(). Regardez DebugMessage() pour plus d'informations sur le
sujet. A chaque fois que DebugMessage() est appelé avec le flag STEP vous
aurez besoin d'appeler StepBack() car c'est le seul moyen de revenir dans
l'arborescence avant la position que vous avez modifiée. Si vous oubliez
d'appeler StepBack() alors l'arbre du debugger sera en permanence à la
mauvaise positon.

@{b}@{u}VOIR AUSSI@{uu}@{ub}
Debug: @{"DebugMessage()" LINK "DebugMessage()"}

@EndNode
