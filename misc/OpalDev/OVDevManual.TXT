
            OpalVision Programers Technical Reference Manual      




                              Version 1.2




                Copyright Opal Technology, 29th  Sep, 1992



This manual was written by the OpalVision development team :

	- Martin Boyd
	- Prashant Maharaj
	- Gary Rayner	
	- Robert Roy
	
with special thanks to:

	- Centaur Development Inc. 


Copyright © 1992 by Opal Technology Pty Ltd.  All rights reserved.  No part
of  this  publication may be copied, photocopied, reproduced, translated or
distributed  in  any  form  or  by  any  means, or stored in a data base or
retrieval  system,  without the prior written permission of Opal Technology
Pty Ltd.

OpalVision  is a trademark of Opal Technology Pty Ltd.  Amiga and Workbench
are registered trademarks of Commodore-Amiga, Inc.

Opal   Technology   Pty  Ltd,  its  employees  and  distributors,  take  no
responsibility   expressed   or   implied  for  the  quality,  performance,
merchantability  or  fitness  for any particular purpose of the information
presented  herein.   The  information in this manual is presented on an "As
Is"  basis.   The user takes full responsibly for the quality, performance,
correctness  or  any  damage  incurred  by  use  of this information.  Opal
Technology  Pty Ltd reserves the right to change information in this manual
without  notice.   Opal  Technology Pty Ltd, its employees and distributors
will  not  under  any  circumstances  be  liable  for any direct, indirect,
incidental  or  consequential  damages  incurred by use of this information
even if the possibility of such damage is known.  


                             TABLE OF CONTENTS

INTRODUCTION						1.0

FEATURES OF THE OPALVISION MOTHER BOARD			2.0

THE OPALVISION SCAN RATE CONVERTER			3.0

THE OPALVISION VIDEO ROASTER CHIP			4.0

FUNCTIONAL DESCRIPTION OF VIDEO COMMUNICATION		5.0

DIGITIAL COMMUNICATION					6.0

COLOUR MODES						7.0
	24Bit Modes					7.1
	8Bit Modes					7.2
	15Bit Mode					7.3
	Colour Mode Selection				7.4

STENCIL MODES						8.0
	Playfield Stencil				8.1
	Priority Stencil				8.2

MEMORY STRUCTURE					9.0

REGISTERS						10.0
	The Control Line Register			10.1
	The CoPro					10.2
	Palette Registers				10.3
	Pixel Read Mask Register			10.4
	Address Load Register				10.5
	Video Command Register				10.6
	Palette Load Register				10.7
	The Video Roaster Chip				10.8

THE LIBRARY						11.0
	The Opalscreen Structure			11.1
	Types of Opalscreens				11.2
	Drawing Routines				11.3
	Frame Buffer Updating				11.4
	Logical Frames					11.5
	Dual Playfield Mode				11.6
	Maniputlaing the Opalvision Registers		11.7
	Screen Positioning				11.8
	Horizontal Synchronization			11.9
	Ownership					11.10

SUMMARY OF LIBRARY FUNCTIONS				12.0
	Drawing Routines				12.1
	Conversion Routines				12.2
	Coprocessor Routines
	
DEFINITION OF TERMS					13.0

       ============================================================






1.0	INTRODUCTION

OpalVision is modular integrated 24bit graphics and video environment
developed with total integration into the Amiga environment in mind.  To
maintain this philosophy the system has been designed to take advantage of
the many specialized and highly productive hardware features of the Amiga.
The OpalVision system provides the freedom and expandability to fit the
specific needs of the user.

Designed as one modular unit, OpalVision circumvents the usual problems
with incompatibility and loss of signal integrity associated with the many
external components available from separate third parties, and the "Rat's
Nest" usually required to connect them.  With the initial release of this
product three expansion modules are available; The Frame Grabber Frame
Grabber Genlock Module, the Scan Rate Converter Module
and the Video Roaster Chip.  The first two of these modules will be fully
supported in the OpalVision development library.  The modules connect
directly to the OpalVision expansion card without tying up separate slots.

Because of the expandable nature of the system Opal Technology strongly
recommends strict adherence to the OpalVision Development Library.  In the
library we have included a comprehensive range of functions encompassing
all modes and resolutions supported by the hardware.  The library also
includes OpalVision Screen Management , Drawing , IFF,
Coprocessor, Virtual Screen, Display Control, Frame Grabber Control and
Linear Keyer Control routines.  If you find that the library has any
inadequacies in relation to your specific application Opal Technology will
gladly consider updating the library to suit your requirements.

The OpalVision system offers an extremely cost effective entry into the
world of high quality 24bit graphics.  With the addition of
the Frame Grabber + Genlock module and the sophisticated effects of the
Video Roaster Chip, it offers an equally satisfactory solution to the world
of Amiga desktop video.  We at Opal Technology have attempted to provide a
consistent and sustainable platform on which to build.  Any suggestions or
recommendations will be gratefully considered.


2.0	FEATURES THE OPALVISION MOTHER BOARD

The OpalVision Mother Board is the heart of the OpalVision System.  It is
designed to reside in the Amiga 2000 or Amiga 3000 video slot.  The
OpalVision Mother Board is the most basic implementation of the OpalVision
system.  The OpalVision Mother Board incorporates a 24bit, 15bit and 8bit
true colour modes, 24bit and 8bit Palette mapped display modes, Dual
Playfield and Overlay Priority stencil modes and a graphics coprocessor.
This range of modes provides the flexibility to meet the wide range of
graphics requirements from animation to real time video
effects to high resolution true colour graphics manipulation.
  
OpalVision provides three different True Colour modes
all of which are available in all supported resolutions.
24bit True Colour which provides one byte for each of the primary colours.
This provides and effective colour range of 16.8 million colours.  15bit
True Colour provides 5 bits of information for each of the primary colours.
This provides an effective colour range of 32,768 colours.  This mode has
the advantage of higher speed updates due to its lower data requirements.
Finally 8bit True Colour which provides 3bits of red, 3bits of
green and 2bits of blue.  With an effective colour range of 256 colours
this mode provides high speed update at the expense of colour range.

OpalVision also supports two different Palette Mapped colour modes.  24bit
Palette Mapped passes all 24bits of data through three 8bit x 256 lookup
tables immediately prior to display.  Each lookup table corresponds to one
of the primary colours.  This feature is especially useful for contrast and
gamma correction and for smooth fade image transitions.  When coupled with
the Frame Grabber it can also be used for real time effects with live video
such as white balance, contrast and gamma correction, solarization,
negative and colourisation effects.  8bit Palette Mapped is a standard
palette mapped configuration allowing access to 256 colours from palette of
16.8 million (256 x 24bit palette registers).

OpalVision incorporates two stencil modes; Overlay Priority stencil and
Dual Playfield Priority stencil.  Overlay Priority allows the OpalVision or
the Amiga to be given foreground priority on a pixel by pixel basis.  This
is particularly useful for backdrop type applications where the speed and
operating system advantages of Amiga graphics can be freely combined with
the numerous advantages of OpalVision graphics.  The Dual Playfield
Priority provides foreground priority information between two OpalVision
screens.  This feature is especially useful for transitions between
OpalVision images.

The OpalVision graphics coprocessor has the ability to change OpalVision
display modes and start address on a line by line basis.  This provides the
ability to freely change resolution, stencil modes, a host of transition
effects and smooth scrolling between multiple adjacent screens.

Below is a table of the most commonly used display resolutions available
with OpalVision


Low Resolution High Resolution Low Resolution Interlaced* High Resolution
Interlaced*

+--------------+------------+-----------+-----------+-----------+
|PAL           |  320 x 256 | 640 x 256 | 320 x 512 | 640 x 512 |
+--------------+------------+-----------+-----------+-----------+
|PAL Overscan  |  384 x 286 | 768 x 286 | 384 x 576 | 768 x 576 |
+--------------+------------+-----------+-----------+-----------+
|NTSC          |  320 x 200 | 640 x 200 | 320 x 400 | 640 x 400 |
+--------------+------------+-----------+-----------+-----------+
|NTSC Overscan |  384 x 236 | 768 x 236 | 384 x 476 | 768 x 476 |
+--------------+------------+-----------+-----------+-----------+

*De-interlaced when Scan Rate Converter Present The OpalVision Genlock and
Frame Grabber


The OpalVision Genlock and Frame Grabber module is a true 24bit frame
grabber, genlock, composite decoder (colour splitter), composite encoder,
256 level linear keyer with alpha channel output and live video effects
processing system.  It does not require a still frame or any sort of signal
preparation for grabbing of images.  The module is easily installed
directly on to the OpalVision mother board and provides its configuration
information to the library.  The module has direct access to the memory and
control systems of the OpalVision Mother Board and therefore appears as one
seamless unit to the software.  The Genlock and Frame Grabber Module will
be fully supported by the library.

The Genlock synchronizes both the OpalVision and the Amiga to an external
video signal.  This allows OpalVision or Amiga graphics to be overlaid on a
live video signal.  It also provides the timing and synchronization for the
frame grabber and live video effects system.

The Composite Decoder receives the incoming composite video signal and
breaks it down into RGB video.  This is the form required for both the
frame grabber and live effects system.

The Frame Grabber is directly connected to the main OpalVision memory
through a 48 bit data bus.  This enables it to digitize all three primary
colours in parallel and at full frame rate while displaying the digitized
video though all the special effects capabilities on the OpalVision Mother
Board.  e.g.  Displaying live video with white balance correction, gamma
correction, increased contrast and seen through an Overlay Priority Stencil
with warping effects provided by the Coprocessor.  Depending on the
resolution the frame grabber is also capable of grabbing and storing
multiple sequential frames which may easily be downloaded into Amiga memory
for modification.

The Composite Encoder converts the processed RGB.  into composite or SVHS
video for easy export to video equipment.

The linear keyer offers the ability to set variable transparency between
OpalVision graphics and live video on a pixel by pixel basis.  OpalVision
provides 256 levels of transparency which allows the user to implement
complex titling effects and video overlay transitions.  The linear keyer is
capable of running at full frame rate in all resolutions.

The OpalVision Genlock + Frame Grabber module provides a comprehensive
array of features specifically designed for the desktop video industry.

3.0	THE OPALVISION SCAN RATE CONVERTER

The OpalVision Scan Rate Converter is designed de-interlace and double the
effective scan rate of the video signal so as to provide flicker free video
for those users willing to invest in a high scan rate or multi sync
monitor.  The OpalVision Scan Rate Converter also provides flicker free
Amiga and live video and is capable of acting as a fully independent frame
buffer.

4.0	THE OPALVISION VIDEO ROASTER CHIP

The OpalVision Video Roaster Chip is a reconfigurable hardware device
situated between the address generation hardware and the memory address
lines.  This allows picture information to be redirected to different
screen locations dynamically.  This combined with the ability of the frame
grabber and genlock module to continuously update the OpalVision memory
with live video provides for a host of complex and flexible video effects
which can be fully implemented in real time with no more than one field
delay.

The Video Roaster is a reconfigurable hardware device which adds another
dimension to the systems flexibility.  The Roaster is fully on the fly
programmable from the Amiga therefore allowing the "Hardware" configuration
to be changed.  The Video Roaster will incorporate support for dynamically
scaleable Picture in Picture as well as the Redirect Address Design (RAD).
The Video Roaster Chip is a fully intergrated part of the OpalVision system
and is therefore fully compatible with all other modules of the OpalVision
system.  For effective use, the Video Roaster Chip and software requires
the Genlock and Frame Grabber Module.


5.0	FUNCTIONAL DESCRIPTION VIDEO COMMUNICATION

The OpalVision communicates with video at several different levels.  In its
basic implementation the OpalVision is an output device with the ability to
switch between Amiga and OpalVision video on a pixel by pixel basis.  While
inactive, the OpalVision simply passes through all Amiga graphics.  While
active the OpalVision has several modes which control the signal priority
on a pixel by pixel basis and provide palette and lookup table effects on
all output information.

With the addition of the Frame Grabber + Genlock module the OpalVision
becomes an input device with the ability to synchronize to a video signal,
digitize at full frame rate and overlay Amiga and OpalVision graphics from
Composite, RGB and SVHS sources.  This provides several different paths for
video information to follow as illustrated in the OpalVision System Flow
Diagram.

With the aid of the genlock and linear keyer, OpalVision graphics may be
overlaid on live video with either pixel by pixel variable transparency or
mixed Amiga and OpalVision graphics.  Alternatively the live video may be
digitized then displayed through the OpalVision Mother board with stencil
priority and lookup table effects.  With the addition of the OpalVision
Video Roaster Chip much more complex live video effects are possible.  The
OpalVision unit functions in a synchronous manner for all functions except
when using Video Roaster special effects.  The Video Roaster effects induce
a 1 field delay on to the signal this is the time required to implement a
pixel remap.

6.0	DIGITAL COMMUNICATION

The OpalVision receives its instructions and 24 bit data through the
Amiga's 4 bit digital video output port.  The Amiga is capable of outputing
a maximum of 4 bits per Amiga pixel through this port.  8 bits of data is
obtained by pairing up two 4 bit hi-res pixels side by side.  This 8 bit
data is then used by OpalVision as information for the CoPro, palette, or
as an 8 bit per pixel update to the red, green or blue bank of 24 bit
display memory.

An activation control code must be present at the top of the Amiga display
in the invisible overscan region of the screen to activate the OpalVision.
All palette and CoPro updates are performed in the 3 scan lines following
this code.

Screen information is output to the OpalVision by a series of standard
Amiga hi-res 4 bit screens.  8 bits per lo-res pixel is updated to the
OpalVision by each Amiga screen.

The OpalVision was designed to interface as closely as possible into the
Amiga display architecture, philosophy, and environment.  All of the
benefits of the Amiga Intuition, Copper, Blitter and display hardware can
be utilized to provide high speed screen updates, a variety of display
modes, width control and effects to use on the 24 bit OpalVision graphics.

You must have at least 8 bits of a 24 bit image residing in Amiga Chip RAM
at a time to update a full 24 bit image into the OpalVision Memory.

Memory Updates to the OpalVision are a continuous 5.5 megabytes per second.
Using the copper and blitter, certain effects may be performed considerably
faster than using the bus based C.P.U.

The OpalVision memory and frame grabbed data is read back to the Amiga
through the parallel port available on the video slot.


See OpalVision System Flow Diagram OpalVision Programmers Tecnical 
Reference Manual 1.2 Page No. 11 


7.0	COLOUR MODES 

7.1	24Bit Mode

24Bit mode provides 24bits of information per pixel, 8bits of red, green
and blue.  There are two distinct ways in which this information may be
dealt with, palette mapped or non palette mapped.

In palette mapped mode, each 8bit value (for red, green and blue) is used
as an index into a 256 entry 8bit palette.  There are separate palette
tables for each of the primary colours.  The 8bit data is ANDed with the
pixel read mask prior to accessing the palette.

In non palette mapped mode, information is sent from memory directly to the
display hardware by-passing the palette and the pixel read mask.

7.2	8Bit Modes

8Bit mode provides 8bits of data per display pixel.  There are two distinct
ways in which this information may be dealt with, palette mapped or non
palette mapped.

In palette mapped mode, each 8bit is used as an index into a 256 entry
24bit palette.  This allows 256 colours from a palette of 16.8 million.  In
this mode the 8bit information is ANDed with the pixel read mask prior to
entering the palette.

In non palette mapped mode, the 8bit information for each pixel is divided
into 3bits of red, 3bits of green and 2bits of blue.  This produces an
absolute 8bit colour value for each pixel.

7.3	15Bit Mode

Unlike the 24bit and 8bit modes, 15bit mode is only available in non
palette mapped form.  15Bit mode is not subject to the pixel read mask.
15Bit mode uses 5 bits of red, green and blue.


7.4	Colour Mode Selection

The OpalVision colour modes are selected by combinations of the S1, S0 bits
in the CoPro and CR7 and CR6 bits in the Video Command Register.

+----+----+-----+-----+--------------+---------+---------+---------+
| S1 | S0 | CR7 | CR6 |     Mode     |  R7-R0  |  G7-G0  |  B7-B0  |
+----+----+-----+-----+--------------+---------+---------+---------+
| 0  | 0  |  0  |  0  |24Bit PMapped |  R7-R0  |  G7-G0  |  B7-B0  |
| 0  | 0  |  0  |  1  |24Bit PMapped |  R7-R0  |  G7-G0  |  B7-B0  |
| 0  | 0  |  1  |  0  |24Bit PMapped |  R7-R0  |  G7-G0  |  B7-B0  |
| 0  | 0  |  1  |  1  |Reserved      |Reserved |Reserved |Reserved |
+----+----+-----+-----+--------------+---------+---------+---------+
| 0  | 1  |  0  |  0  |24Bit By-Pass |  R7-R0  |  G7-G0  |  B7-B0  |
| 0  | 1  |  0  |  1  |24Bit By-Pass |  R7-R0  |  G7-G0  |  B7-B0  |
| 0  | 1  |  1  |  0  |24Bit By-Pass |  R7-R0  |  G7-G0  |  B7-B0  |
| 0  | 1  |  1  |  1  |Reserved      |Reserved |Reserved |Reserved |
+----+----+-----+-----+--------------+---------+---------+---------+
| 1  | 0  |  0  |  0  |8Bit PM Red   |  P7-P0  |Ignored  |Ignored  |
| 1  | 0  |  0  |  1  |8Bit PM Green |Ignored  |  P7-P0  |Ignored  |
| 1  | 0  |  1  |  0  |8Bit PM Blue  |Ignored  |Ignored  |  P7-P0  |
| 1  | 0  |  1  |  1  |Reserved      |Reserved |Reserved |Reserved |
+----+----+-----+-----+--------------+---------+---------+---------+
| 1  | 1  |  0  |  0  |8Bit RGB Red  |RRRGGGBB |Ignored  |Ignored  |
| 1  | 1  |  0  |  1  |8Bit RGB Green|Ignored  |RRRGGGBB |Ignored  |
| 1  | 1  |  1  |  0  |8Bit RGB Blue |Ignored  |Ignored  |RRRGGGBB |
| 1  | 1  |  1  |  1  |15Bit RGB     |XRRRRRGG |GGGBBBBB |Ignored  |
+----+----+-----+-----+--------------+---------+---------+---------+


8.0	STENCIL MODES

OpalVision supports two different stencils which may function independently
or together.  These stencils are described below.

8.1	Playfield Stencil

The playfield stencil provides pixel by pixel display priority between two
screens currently in the frame buffer.  This is made active by selecting
the Dual Playfield mode.  This mode is especially useful for fast dynamic
transitions between OpalVision screens.  Dual Playfield mode is completely
independent of Priority mode and the two may be freely combined.  This
function is available in low resolution only.  The Dual_Play control line
register bit enables the playfield stencil as shown below.

+-------------------+-----------+------+-----------------------+
| PlayField Stencil | Dual_Play | Bank | Memory Bank Dispalyed |
+-------------------+-----------+------+-----------------------+
|      Ignored      |     0     |   0  |            1          |
|      Ignored      |     0     |   1  |            2          |
|         0         |     1     |   0  |            1          |
|         0         |     1     |   1  |            2          |
|         1         |     1     |   0  |            2          |
|         1         |     1     |   1  |            1          |
+-------------------+-----------+------+-----------------------+


8.2	Priority Stencil

Priority mode controls display priority between OpalVision and Amiga
graphics on a pixel by pixel basis.  There are several forms in which this
mode functions.  These are described below.

+----------+-------+----------+-----------+-------------+--------------+
| Priority | Prior | Priority | Dual_Disp | Transparent | Actual Video |
| Stencil  | Mode  |          |           |    Colour   |   Display    |
+----------+-------+----------+-----------+-------------+--------------+
|  Ignored |   0   |    0     |     0     |   Amiga 0   | Amiga on Opal|
|  Ignored |   0   |    0     |     1     |    None     | Amiga Only   |
|  Ignored |   0   |    1     |     0     | OpalVision 0| Opal on Amiga|
|  Ignored |   0   |    1     |     1     |    None     | Opal Only    |
|     0    |   1   | Ignored  |     0     |   Amiga 0   | Amiga on Opal|
|     0    |   1   | Ignored  |     1     |    None     | Amiga Only   |
|     1    |   1   | Ignored  |     0     | OpalVision 0| Opal on Amiga|
|     1    |   1   | Ignored  |     1     |    None     | Opal Only    |
+----------+-------+----------+-----------+-------------+--------------+

The four control bits described above are situated in the CoPro register
and can be updated on every scan line.  The Priority Stencil is completely
independent to the Playfield stencil and the two may be freely mixed.  This
mode is available in all resolutions.

Resolutions OpalVision resolutions exactly matches Amiga low and high
resolutions in both interlaced and non interlaced displays.  This
simplifies the use of Amiga/OpalVision stencil modes.  All colour modes are
available in all resolutions.

OpalVision automatically configures for either PAL or NTSC.  It is
essential therefore that all software should auto configure for PAL and
NTSC.  And this can be done by opening all windows and screens using the
size specified in GfxBase -> NormalDisplayRows, and when positioning
gadgets at the bottom of the screen, do so by making them relative to the
bottom of the screen by setting the GRELBOTTOM.  Special consideration must
be given to the limited screen resolution available in NTSC.

9.0	MEMORY STRUCTURE

OpalVision memory is divided into two Banks and in turn each bank is
divided into two fields.  Each field is also divided into three regions one
each for Red, Green and Blue.  Interlaced pictures must be stored in
adjacent fields.  In non interlaced modes, these fields may be used to
store separate images.  In low resolution non-interlaced each of the four
fields (Banks 1 and 2) can hold complete images.  In low resolution
interlaced both fields are required for each full picture therefore two
complete images may be stored, one in each bank.  In high resolution non
interlaced, one bank is required for each picture allowing the storage of
two complete pictures.  Finally in high resolution interlaced, only one
picture can reside in the OpalVision memory at a given time.

Writing to the rams is controlled by the FIELD, RWR1, GWR1, BWR1, RWR2,
GWR2 and BWR2 bits situated in the control line register.  These bits are
active high.  Bits in the control line register are not mutually exclusive
and may be used in any combination therefore multiple banks may be written
with the same information simultaneously.  This is most useful for memory
initialization type operations.  By the same token, it is possible to write
to one bank while displaying another.  This feature is especially useful
for double buffered animation.  Note however that it is not possible to
write to one field while displaying the other field.

In total there are 12 regions of memory which may be independently
accessed, these are referred to as segments in this document..

Memory Segment Diagram 


                           RWR1           GWR1           BWR1
                     +--------------+--------------+--------------+
                     |              |              |              |
           Field = 0 |     128K     |     128K     |     128K     |
                     |              |              |              |
BANK = 0             +--------------+--------------+--------------+
                     |              |              |              |
           Field = 1 |     128K     |     128K     |     128K     |
                     |              |              |              |
                     +--------------+--------------+--------------+
                           
                           Red            Green          Blue
   
                     +--------------+--------------+--------------+
                     |              |              |              |
           Field = 0 |     128K     |     128K     |     128K     |
                     |              |              |              |
BANK = 1             +--------------+--------------+--------------+
                     |              |              |              |
           Field = 1 |     128K     |     128K     |     128K     |
                     |              |              |              |
                     +--------------+--------------+--------------+
                           RWR2           GWR2           BWR2



In low resolution non interlaced mode, picture information is stored in
sequential form in one field.

In interlaced modes sequential horizontal lines are stored in alternate
memory fields as explained by the diagram.

Interlaced
		+-------------------------------+
		|OOOOOOOOOOOOOOOOOOOOOOOOO      |
		|XXXXXXXXXXXXXXXXXXXXXXX        |
		|OOOOOOOOOOOOOOOOOOOOO          |
		|XXXXXXXXXXXXXXXXXXX            |
		|                               |
		|                               |
		|                               |
		|                               |
		|                               |
		|                               |
		|                               |
		|                               |
		|                               |
		|                               |
		+-------------------------------+

	OO = Even Field
	XX = Odd Field


In high resolution modes, sequential pixels along each horizontal line are
situated in alternate banks.

High Resolution

		+-------------------------------+
		|XOXOXOXOXOXOXOXOXOXOXOXOXOXO   |
		|XOXOXOXOXOXOXOXOXOXOXOXOXO     |
		|XOXOXOXOXOXOXOXOXOXOXOX        |
		|XOXOXOXOXOXOXOXOXOXOX          |
		|                               |
		|                               |
		|                               |
		|                               |
		|                               |
		|                               |
		|                               |
		|                               |
		|                               |
		|                               |
		+-------------------------------+
	
	X = BANK 0
	O = BANK 1

When high resolution and interlaced modes are selected at the same time,
both these effects must be considered.  Therefore sequential horizontal
pixels are situated in alternating banks and sequential Horizontal lines
are situated in alternating fields.

The library provides a full compliment of memory format conversion routines
to simplify the management of the OpalVision display memory and to convert
between the different graphics memory configurations found on the Amiga.


10.0	REGISTERS

10.1	The Opal Control Line Register

The Opal Control Line Register must be present to activate the OpalVision
display.  The Control Line Register provides control for memory write,
display activation and auto display modes.  It's Consists of 20 bits which
are embedded in the first scan line of every Valid OpalVision frame.

+------+------------+-------------------------------------------+------------+
| Bit# |  Name      |Description                                |Active State|
+------+------------+-------------------------------------------+------------+
|  19  |*Freeze     | Frame Freezes Current frame in SRC        |      1     |
|  18  |**VLSI_PROG | Program the Roaster chip if present.      |      1     |
|  17  |BWR2 Enable | Blue Video RAM write Bank 2               |      1     |
|  16  |BWR1 Enable | Blue Video RAM write Bank 1               |      1     |  
|  15  |GWR2 Enable | Green Video RAM write Bank 2              |      1     |
|  14  |GWR1 Enable | Green Video RAM write Bank 1              |      1     |
|  13  |RWR2 Enable | Red Video RAM write Bank 2                |      1     | 
|  12  |RWR1 Enable | Red Video RAM write Bank 1                |      1     |
|  11  |FGrab Enable| Frame Grabbing to Video RAM               |      1     |
|  10  |Latch       | Latch On OpalVision display               |      1     |
|   9  |Field_Mode  | Enable Auto Field Display Toggle          |      1     |
|   8  |FIELD       | Field Toggle value                        |      X     |
|   7  |Dual_Play   | Dual OpalVision Playfield stencil enable  |      1     |
|   6  |AUTO Enable | Auto Line Start Sync                      |      0     |
|   5  |COL/CoPro   | Selects Palette update or CoPro Update    |      X     |
|   4  |WREN        | Address Select for Register Updates       |      X     |
|   3  |Valid_3     | Valid OpalVision Activation Code          |      0     |
|   2  |Valid_2     | Valid OpalVision Activation Code          |      1     |
|   1  |Valid_1     | Valid OpalVision Activation Code          |      0     |
|   0  |Valid_0     | Valid OpalVision Activation Code          |      1     |
+------+------------+-------------------------------------------+------------+

*Available only when the Scan Rate Converter module is present.  **Function
for Live Video Manipulation Chip.  

**Available only when Roaster Chip is present.


10.2	The CoPro

The OpalVision CoPro is a sequential processor which allows control of
OpalVision display modes on a line by line basis.  This is especially
suited to transition effects like slides and wipes, between live and Amiga
video.  The Coprocessor offers the following control information on every
display line .  There are 290 available instructions in the CoPro list, one
for each line of the display.


+------+------------+-------------------------------------------+------------+
| Bit# |  Name      |Description                                |Active State|
+------+------------+-------------------------------------------+------------+
|  7   | Add_Load   | Re-load the address registers.            |      0     |
|  6   | Prior_Mode | Amiga/OpalVision priority stencil enable. |      1     |
|  5   | Priority   | Amiga/OpalVision priority.                |      X     |
|  4   | Dual_Disp  | Mix Amiga/OpalVision graphics.            |      0     |
|  3   | Lo/Hi      | Hi resolution enable.                     |      1     | 
|  2   | Bank       | Video ram display bank selector           |      X     |
|  1   | S1         | Video display mode bit 1                  |      X     | 
|  0   | S0         | Video display mode bit 0                  |      X     |
+------+------------+-------------------------------------------+------------+


10.3	Palette Registers

The OpalVision unit has a separate 256 entry palette for red, green and
blue.  This palette may be configured in two different ways.

In 8bit palette mapped mode, it is organized as 256 24bit registers.  This
is a standard palette configuration.

In 24bit palette mapped mode, the palette acts as three separate 8bit
remap tables.  These are especially useful for gamma correction, contrast
stretching, negatives and smooth fades.

All palette entries can easily be accessed through the library.

10.4	Pixel Read Mask Register

The Pixel Read Mask Register is situated between video memory and the
palette registers.  The Pixel read mask is 8bits wide and is applied to
red, green, blue or 8bit data prior to its entering the palette.  This
facility is available only in palette mapped modes.  The same mask value is
applied to all data paths.

10.5	Address Load Register

The Address load Register is a 17bit register which can be loaded into the
video address counters.  Each address is equal to a low res pixel size.
and there are 371 address counts per line.  This value is independent of
both the resolution of the Amiga or the OpalVision.  Therefore scrolling
the screen down one line may be achieved by simply adding 371 to the value.
The value in this register is not loaded until a clear Add_Load bit in the
CoPro register is encountered.

10.6	Video Command Register

The Command register contains colour mode control bits.  And output
standard information.

+------+------------+-------------------------------------------+------------+
| Bit# |  Name      |Description                                |Active State|
+------+------------+-------------------------------------------+------------+
|  7   |CR7         | Colour Mode Select.  See Video Mode Table |      X     |
|  6   |CR6         | Colour Mode Select.  See Video Mode Table |      X     |
|  5   |Setup       | Specifies 0 IRE or 7.5 IRE Pedestal use 0 |      0     |
|  4   |8/6         | Selects between 6 (0) and 8 (1) bit mode  |      1     |
|  3   |Reserved    | Keep Low                                  |      1     |
|  2   |Reserved    | Keep Low                                  |      1     |
|  1   |VLSI_AD1    | *Ram Bank 1 address replace.              |      1     |
|  0   |VLSI_AD0    | *Ram Bank 0 address replace.              |      1     |
+------+------------+-------------------------------------------+------------+

	*Functions for the Live Video Manipulation Chip (The Roaser).

10.7	Palette Load Register

The Palette Load register is an 8bit register which is used to offset the
palette updates.  This makes it possible for the palette data to be shifted
by the given amount for simple colour cycling effects.  This register is
normally 0.


10.8	The Video Roaster Chip

The Video Roaster Chip is a reconfigurable hardware device which can be
programmed from the Amiga.  The Roaster is situated between the address
counters and the memory address lines.  This allows the roaster to redirect
pixel information from any part of memory to any screen location.  The
Video Roaster requires the Frame Grabber and Genlock module to function.

There will be atleast two different modules which take advantage of this
capability these are the Picture in Picture module (PIP) and the Redirect
Address Design module (RAD) These modules can only be used one at a time as
they require the dedicated attention of the Roaster Chip.


11.0	THE LIBRARY

11.1	The Opalscreen Structure

The library deals with OpalVision screens.  These screens can contain 8, 15
and 24 bitplanes.  Each screen is described by an OpalScreen structure.
The contents of this structure is shown below.

struct OpalScreen
		{ SHORT Width;
		   SHORT Height;
		   SHORT Depth;
	 	   SHORT ClipX1, ClipY1;
	 	   SHORT ClipX2, ClipY2;
		   SHORT BytesPerLine;
		   UWORD Flags;
		   SHORT RelX;
		   SHORT RelY;
		   struct MsgPort *UserPort;
		   SHORT MaxFrames;
		   SHORT VStart;
		   SHORT CoProOffset;
		   SHORT LastWait;
		   UWORD LastCoProIns;
		   UBYTE *BitPlanes[24];
		   UBYTE *MaskPlane;
		   ULONG AddressReg;
		   UBYTE UpdateDelay;
		   UBYTE PalLoadAddress;
		   UBYTE PixelReadMask;
		   UBYTE CommandReg;
		   UBYTE Palette[3*256];
		   UBYTE Pen_R;
		   UBYTE Pen_G;
		   UBYTE Pen_B;
		   UBYTE Red;
		   UBYTE Green;
		   UBYTE Blue;
		   UBYTE CoProData [MAXCOPROINS];
		   SHORT Modulo;
		   UBYTE Reserved [38];
		};

The fields have the following meanings:

Width

The width of the screen in pixels.  This can be specified if the screen was
created  using  CreateScreen24() or this value will be set automatically if
opened using OpenScreen24().

Height

The height of the screen in lines.  This can be specified if the screen was
created  using  CreateScreen24() or this value will be set automatically if
opened  using  OpenScreen24().   When  OpenScreen24() is used the number of
lines  depends on whether the machine is running in NTSC or PAL and also on
the amount of available chip ram.

Depth

The  number  of bitplanes in the screen.  This value is set when the screen
is opened or created.

ClipX1, ClipY1, ClipX2, ClipY2 

These variables define the clipping region used by the drawing routines.
The actual region is defined as ClipX1 <= x < ClipX2 and ClipY1 <= x <
ClipY2.

BytesPerLine 

This defines the screen width in bytes.  This value is not always width/8
and depends on the resolution of the screen.

Flags

These flags may be specified when the screen is first opened using either
OpenScreen24() or CreateScreen24().

These flags are:

HIRES24 Screen is in high resolution mode (640 pixels across).  The default
is 320 pixels across.

ILACE24 Screen is in interlaced mode.  (512 lines for PAL , 400 lines for
NTSC).  The default is 256 lines for PAL and 200 lines for NTSC.

OVERSCAN24 Screen is in an overscan mode.  This is 368 pixels wide in low
resolution or 736 pixels wide in high resolution.  The number of lines in
PAL is 286 non interlaced or 576 interlaced and in NTSC there are 236 lines
in non interlaced or 476 lines interlaced.

PLANES8 Screen has 8 bitplanes.

PLANES15 Screen has 15 bitplanes.

CLOSEABLE24 The screen can be closed by a higher priority task (display
screen only).

PALMAP24 Screen is in palette mapped mode.

CONTROLONLY24 This flag can be used to activate the OpalVision to allow
updating of the internal registers only.


The following flags are set by the library and are not user definable:

NTSC24 Screen is in NTSC mode.  Default is PAL.

INCHIP24 Screen is a display screen in chip ram.



RelX, RelY 

These variables provide a relative drawing origin which is used
by the drawing routines.  These values are simply added to the input
coordinates of drawing routines.

UserPort 

This is a message port opened specifically for the screen.  In
this version of the library this is only used for close down messages to
tasks which have opened a screen with the CLOSEABLE24 flag set.

MaxFrames 

This field is set when the screen is opened and defines how many
screens of this resolution may be held in frame buffer memory.

VStart 

This field is set when the screen is opened and defines the starting
scan line of the screen.  This is normally defined in preferences or is
given a default value for overscan screens.  This value is useful for
building user copper lists.

CoProOffset 

This field is set when the screen is opened and defines the
CoPro instruction number corresponding to the first scan line in the
display.

LastWait 

This field contains the scan line number of the last vertical
position wait for a display copper list.  Normally this is the top of the
display, but must be updated if copper lists are added to the display lists
using the AppendCopper24() function.

LastCoProIns 

This field defines the last CoPro instruction which can be
modified.  Normally this is MAXCOPROINS, however it will be less than this
if a display bottom has been set.

BitPlanes 

This field is an array of pointers to the bitplanes for the
screen which will contain 4, 8, 12, 16 or 24 entries.

MaskPlane 

This can point to a single bitplane mask plane which is allocated
if LoadIFF24() loads a file which contains a mask plane and the LOADMASK24
flag is set.  Likewise this plane is saved in the file if the SaveIFF24()
function is called with the SAVEMASK24 flag set.

AddressReg 

This field holds a copy of the Address Load Register in the
OpalVision.  Values written to this register are not updated in the
OpalVision until SetLoadAddress24() is called.

UpdateDelay 

This field defines the number of frames to wait between
consecutive frame buffer updates.  This field should not be set directly
but set using a call to UpdateDelay24().

PalLoadAddress 

This field holds a copy of the Palette Load Address Register
in the OpalVision.  Values written to this register are not updated in the
OpalVision until RegUpdate24() is called.

PixelReadMask 

This field holds a copy of the PixelReadMask Register in the
OpalVision.  Values written to this register are not updated in the
OpalVision until RegUpdate24() is called.

CommandReg 

This field holds a copy of the Command Register in the
OpalVision.  Values written to this register are not updated in the
OpalVision until RegUpdate24() is called.

Palette 

This contains a copy of the OpalVision's internal palette.  The
palette consists of 256 entries of Red, Green and Blue triplets.  Values
written into the palette will not be updated in the OpalVision until
UpdatePalette24() is called.

Pen_R, Pen_G, Pen_B 

These three fields hold the current pen value used by
the drawing routines.  For 24bit screens all three are used, while in 15bit
screens only Pen_R and Pen_G are used and in 8bit mode only Pen_R is used.
Macros are defined in Opallib.h to simplify setting pen values.

Red, Green, Blue 

These three fields contain the return values from
ReadPixel24().  For 24bit screens all three are used, while in 15bit
screens Red and Green are used and in 8bit mode only Red is used.  Macros
are defined in Opallib.h to simplify getting these values.

CoProData 

This array holds a copy of the CoPro instructions in the
OpalVision.  Values written into this array are not updated in the
OpalVision until UpdateCoPro24() called.

Modulo 

This field holds the line width in pixels used for the 24 bit
display, this value is a constant independent of display resolution.  This
value is required for calculating addresses to place in the address
register.  This value is different for the ColorBurst and the OpalVision.

Reserved 

Reserved for future expansion.


11.2	Types of Opalscreens

There are two types of OpalScreens.  The display screen is the main screen
which is opened using the OpenScreen24() function.  All library calls are
applicable to the display screen which can be used to update the frame
buffer memory and is hence displayable.  The display screen's bitplanes
must reside in chip ram and its size may therefore be restricted by the
available chip memory.

Virtual OpalScreens can be opened using the CreateScreen24() function.
These screens reside in fast ram and therefore cannot be directly
displayed.  Virtual screens are more flexible than display screens in that
they can be opened in any size (memory permitting).  Virtual screens are
useful for file conversion, image processing or implementing virtual screen
support where a large image is stored in fast ram and a smaller scrollable
display window is held in chip ram.

The fields in the OpalScreen structure pertaining to display attributes,
such as the palette, CoPro instructions and registers are ignored for
virtual screens.  Library functions pertaining to display modes cannot be
used for virtual screens and normally do not take an OpalScreen parameter
implying that they operate on the display screen.

Display screens can also be opened as low priority closeable screens by
setting the CLOSEABLE24 flag when opening a screen.  If another task tries
to open a display screen, a message will be sent to the screens message
port requesting that it be closed to enable the other task to open its
screen.  This is useful for backdrop type programs.  An example of using a
closeable screen is given below, note that the screen MUST be closed before
the message is replied to.

	OScrn = OpenScreen24 (CLOSEABLE24);
	if (OScrn!=NULL)
		{ WaitPort (OScrn->UserPort);
		   CloseScreen24();
		   Mesg = GetMsg (OScrn->UserPort);
		   ReplyMsg (Mesg);
		}

Virtual screens can be displayed indirectly using the LowMemUpdate24()
function, this function updates the buffer one segment at a time and
therefore only requires one segment of data to be in chip memory.  If you
only require one off updates of the buffer, this method is strongly
recommended as it does not suffer from chip ram limitations.

11.3	Drawing Routines

All drawing routines are applicable to both types of OpalScreens and take a
screen pointer to define which OpalScreen is used.  Within the screen
structure there are several fields which apply only to drawing.  The
ClipX1, ClipY1 and the ClipX2, ClipY2 fields define an absolute clipping
rectangle defining the allowable drawing area.  Pixels outside of this
rectangle will be unaffected.  The clipping rectangle is initialized to the
size of the screen when it is created.


The RelX, RelY fields define the origin of the drawing coordinate system.
This is initialized to 0 when the screen is opened.

The drawing routines use the Pen_R, Pen_G and Pen_B fields of the screen
structure to define the colour used for drawing.  In 24bit mode the three
values contain 8bits of red, green and blue.  In 8bit mode, Pen_R contains
the 8bit value to be written.  In 15bit mode the Pen_R and Pen_G contain 5
bits of red, green and blue compressed together as shown below.

        Pen_R Pen_G 15bit Pen value 0RRRRRGG GGGBBBBB
        8bit true colour pen value RRRGGGBB

To simplify writing pen values, the following four macros are defined in
Opallib.h:

        SetPen24 (Screen, R,G,B) - Set 24bit pen
	SetPen15 (Screen, R,G,B) - Set 15bit pen
	SetPen8P (Screen, Pen)   - Set 8bit Palette mapped pen.
	SetPen8  (Screen, R,G,B) - Set 8bit true colour pen.

Similarly the values returned by ReadPixel24() are returned in the Red,
Green, Blue fields of the OpalScreen structure in the same format.  To get
the components of the returned value the following macros can be used.

	GetCol24 (Screen, R,G,B) - Get 24bit colour.
	GetCol15 (Screen, R,G,B) - Get 15bit colour.
	GetCol8P (Screen, Pen)   - Get 8bit Palette mapped pen number.
        GetCol8 (Screen, R,G,B)  - Get 8bit colour. 

11.4	Frame Buffer Updating

When instructed the library updates the frame buffer with the contents of
the current display screen.  Making any changes to the current screen
visible.  The library allows two different methods for updating the frame
buffer.  The first method is to make the changes that you wish to the
display screen in memory and then call Refresh24() which will refresh the
frame buffer in the minimum number of frames required for that resolution,
stops updates and then returns.  This form of updating has the nice side
effect of providing inherent double buffering.

The second method is to allow continuous updating of the frame buffer which
is performed transparently by the library.  This mode is enabled by calling
UpdateDelay24() which also allows for a delay parameter to be specified
which sets a frame delay between consecutive updates.  StopUpdate24() can
be used to cease updating.  Note that while frame buffer updates are
occurring the CPU access to chip ram will be limited, the frame delay
between buffer updates gives the CPU a little breathing room and will
increase CPU throughput .  


11.5	Logical Frames

Frame buffer memory can contain several images depending on the resolution
and display mode.  The library divides the frame buffer memory into a
number of logical frames to ease the task of writing several frames into
the buffer.  The frame to be updated is set by calling WriteFrame24() and
the current display frame is set by calling DisplayFrame24().  The maximum
number of frames possible is given by the MaxFrames field in the OpalScreen
structure.

The following tables show the assignments of logical frames to physical
memory segments.

Table:  Frame Assignments in 15 and 24 Bit Modes

Resolution Frame Number

Table:  Frame Assignments in 8Bit Mode



The following information contains terms which should be understood clearly
for an effective understanding of the OpalVision's operating modes.  It is
worth spending a moment to understand the characteristics and differences
between a Dual Display and Dual Playfield as well as the Priority Stencil
and the Playfield Stencil.  Dual Display Mode The OpalVision can operate in
a dual display mode.  When activated, this enables both Amiga and
OpalVision graphics to be visible on the same screen.  The priority of the
display can also be set to enable either Amiga over OpalVision or
OpalVision over Amiga.  This mode enabled by calling DualDisplay24() and
disabled by calling SingleDisplay24().  The Priority is set using
OVPriority() and AmigaPriority().

A priority stencil can also be used to set the priority between OpalVision
and Amiga graphics on a pixel by pixel basis.  The priority stencil is
enabled by calling EnablePRStencil24() and disabled with
DisablePRStencil24().  The functions SetPRStencil24(), ClearPRStencil24(),
WritePRPixel24() and ReadPRPixel24() are provided to help manage the
priority stencil.

Note that when updating the frame buffer in dual display mode, the
information being sent out to the OpalVision will be visible and cause a
glitchy display.  To avoid this the dual display should be turned off when
updating and OpalVision priority should be set.  The following function is
useful to allow glitch free updates, note that it also blanks the sprite
during updates so that the sprite will not be written into the frame
buffer.


void Refresh_Display (void) 
        {
	OVPriority ();
	SingleDisplay24 ();             /* Set up 24bit only display        */
	SetSprite24 (NullPointer,0L);   /* Turn off sprite                  */
	Refresh24 ();                   /* Update frame buffer              */
	DualDisplay24 ();               /* Enable dual Amiga/24 bit display */
	AmigaPriority ();               /* Amiga over 24bit display         */
	SetSprite24 (Pointer,0L);       /* Reinstall sprite                 */ 
        }



11.6	Dual Playfield Mode

Dual Playfield mode allows two low resolution 24bit OpalVision images to be
overlaid.  This can be achieved by writing two frames into the frame buffer
memory using the WriteFrame24() function and calling DualPlayfield24() to
enable dual playfield mode.  SinglePlayfield24() can be used to revert back
to single playfield mode.

When in dual playfield mode a playfield stencil is used to determine which
frame is displayed on a pixel by pixel basis.  The functions
SetPFStencil24(), ClearPFStencil24(), WritePFPixel24() and ReadPFPixel24()
are provided to help manage the playfield stencil.

The function UpdatePFStencil24() can be used to speed up the updates to the
frame buffer so that all consecutive updates will only update the memory
segments containing the playfield stencil.  Using a combination of this and
the above playfield routines fast wipes, dissolves and other transition
effects can be achieved.  After UpdatePFStencil24() has been called, it
takes only one field to update a non interlaced stencil, and two fields (1
frame) for an interlaced one.  Normal updating can be restored by calling
UpdateAll24()

11.7	Manipulating The Opalvision Registers

The Library allows for direct manipulation of all the OpalVision registers
through library calls.  These all involve modifying a copy of the register
in the screen structure and calling a library function to update the
hardware registers.  Also using this method custom CoPro lists can be built
and updated into the OpalVision.

It is important to be aware that all hardware register updates occur during
the vertical blanking period, and your program must synchronize to this and
wait for the update to complete before attempting to modify the registers
again.  If the program is not synchronized, data may be lost.  The function
RegWait24() is available for this purpose.  RegWait24() should also be
called after calling any another library function which affects internal
registers, the CoPro or the palette.

11.8	Screen Positioning

Version 2.0 and later of the Amiga Operation System supports an overscan
WorkBench screen.  If an overscan display is active, the library will
centre non-overscan OpalVision screens in the overscan region.  If you wish
to open an Amiga Screen as an overlay, it will also need to be centred to
maintain alignment between the Amiga and 24 bit displays.

The following code can be used to centre the Amiga intuition screen:

void Centre_Screen (struct NewScreen *NewScreen)
{
   struct Rectangle Rect;
   int Width;

	if (IntuitionBase->LibNode.lib_Version<36)
		return;
	if (!QueryOverscan (LORES_KEY,&Rect,OSCAN_TEXT))
		return;

	Width = Rect.MaxX - Rect.MinX + 1 /* Calculate overscan screen width */
	if (NewScreen->ViewModes & HIRES)
		Width = ((Width - (NewScreen->Width/2))/2)*2;
	else
		Width = (Width - NewScreen->Width)/2;
	NewScreen->LeftEdge = MAX (Width,0);
}

 Call Centre_Screen (&NewScreen) before opening the intuition screen.

NOTE:  The Centre_Screen() code provided in previous revisions of this
manual was incorrect, if you have used the Centre_Screen() function
previously it should be changed to the above code.

Also note that it is not possible to display OpalVision graphics while the
Amiga display is in a high scan mode as available with the AA chip set.  To
avoid this problem, programs like Show24 should open an intuition screen
over the workbench screen to drop the Amiga display back into a standard
scan rate.

11.9	Horizontal Synchronisation

To maintain the OpalVision's horizontal synchronisation with the Amiga's
video the OpalVision uses the Amiga's output to detect the start of each
scan line.  Some consideration has to be given to this when writing
software for the OpalVision.

There are two horizontal synchronisation methods that can be used.  The
first method is to set the least significant bit of blue for the background
colour.  The OpalVision then uses the low to high transition of the LSB of
blue as the start of line indicator.  This is the preferred method as it
provides exact synchronisation with the Amiga's display.  When writing
programs which use an Amiga overlay to contain gadgets and menus, this is
easily achieved by using the LoadRGB24() graphics library function.  (i.e.
if you are setting colour 0 to black, use 001 rather than 000).

Sometimes it is not possible to ensure that the LSB blue of the background
colour is set, if you are not opening an Amiga screen for example, we
cannot assume that the LSB blue is set on the users WorkBench screen (set
in preferences).  In these situations, the OpalVision can be put into an
auto sync mode, it then uses a constant horizontal blanking period which
can be up to 2 hi-res pixels out of phase with the Amiga's display, this
simply means that the 24bit output can be shifted up to 2 pixels to the
left of the Amiga's graphics.  This mode can be enabled and disabled by
calling AutoSync24().

The autosync mode however cannot be used while updating the frame buffer,
and the library will automatically disable this mode while updating is
occurring, note that the 24 bit display will always be in sync with the
Amiga's graphics while updating the frame buffer.  Using the auto-sync mode
can then have the effect of causing the 24bit display to shift from left to
right when jumping in and out of buffer updating mode.

11.10	Ownership

The OpalVision library is basically a passive entity, it contains a set of
functions to make access to the OpalVision hardware easier.  The only
active part of the library is a vertical blanking interrupt handler which
is always active while a display screen is open.  the interrupt handlers'
only function is to update the copper lists required to display the screen.

Any memory or resources allocated via the library calls are therefore owned
by the calling program, in simple terms, a display screen opened using
OpenScreen24() must be later closed by calling CloseScreen24(), similarly
all virtual screens opened by calling CreateScreen24() must be closed by
calling FreeScreen24().  The Lowmemupdate functions also have the side
effect of opening a display screen, this means that after calling
LowMemUpdate() (or the other versions of this function) you will actually
have 2 screens open, one display and one virtual, the display screen opened
by LowMemUpdate() MUST be closed by calling CloseScreen24().  All screens
opened by calling LoadImage24() must also be closed.

 
12.0	SUMMARY OF LIBRARY FUNCTIONS

12.1	Drawing Routines 

ClearPFStencil24        - Clears the playfield stencil 

ClearPRStencil24        - Clears the priority stencil

ClearScreen24           - Clears all bitplanes in a screen

DrawEllipse24           - Draw an ellipse in the designated screen structure 

DrawLine                - Draw a line in the designated screen structure 

ReadPFPixel24           - Reads the state of the specified playfield pixel 

ReadPixel24             - Returns colour information for a given pixel 

ReadPRPixel24           - Reads the state of the specified priority pixel

RectFill24              - Draws a solid rectangle in a screen

SetPFStencil24          - Sets all bits in the playfield stencil to 1 

SetPRStencil24          - Sets all bits in the priority stencil to 1 

SetScreen24             - Fills screen with a colour 

WritePFPixel24          - Writes Dual Playfield stencil information 

WritePixel24            - Writes a pixel 

WritePRPixel24          - Writes Overlay priority stencil information Memory


12.2	Conversion Routines 

BitPlanetoOV            - Converts a standard bit planes to OpalVision format 

ILBMtoOV                - Converts interleaved bitmap to OpalVision format 

OVtoBitPlane            - Converts OpalVision format to standard bit plane 
				format 

OVtoILBM                - Converts OpalVision format to interleaved bitmap 
				format 

OVtoRGB                 - Converts OpalVision format to red, green and blue 
				byte planes

RGBtoOV                 - Converts red, green and blue byte planes to OpalVision 
				format File I/O Routines

LoadImage24             - Loads JPEG, 24bit IFF, Fast Format 24bit,Palette 
				Mapped (up to 256 colours), Hold and Modify 
				and Extra Half Brite files 

SaveIFF24               - Saves an OpalScreen as an IFF interleaved bitmap 
				file with 24bit Thumbnail 

SaveJPEG24              - Saves an OpalScreen as an JPEG JFIF file with 24bit 
				Thumbnail 

WriteThumbnail24        - Writes a Thumbnail chunk for the specified screen to 
				a specified file 

12.3	Coprocessor Routines

AmigaPriority           - Gives Amiga priority over OpalVision graphics 

DualPlayField24         - Initiates OpalVision 24bit Dual Playfield mode 

OVPriority              - Gives OpalVision priority over Amiga Graphics 

SetCoPro24              - Modifies a single instruction in the CoPro list 

SinglePlayField24       - Sets single playfield Mode 

UpdateCoPro24           - Updates coprocessor instructions to the OpalVision 
				Display Control Routines 

ActiveScreen24          - Returns pointer to currently displayed OpalVision 
				screen 

AppendCopper24          - Append Amiga copper lists to currently displayed 
				copper list 

ClearDisplayBottom24    - Resets the OpalVision Display Bottom 

DisablePRStencil24      - Disables the use of priority stencil in dual display 
				mode 

EnablePRStencil24       - Enables the use of priority stencil in dual display 
				mode 

DualDisplay24           - Sets up an Amiga/OpalVision dual display 

FadeIn24                - Fades any palette mapped display from black in a 
				specified time 

FadeOut24               - Fades any palette mapped display to black in a 
				specified time 

LatchDisplay24          - Latch the OpalVision display.  

LowMemUpdate24          - Low Chip Memory usage frame buffer update.  

LowMem2Update24         - Low Chip Memory usage frame buffer update.

LowMemRGB24             - Low Chip Memory usage frame buffer update from an RGB 
				array.

PaletteMap24            - Enables or disable palette mapping

Scroll24                - Scrolls currently displayed image by a given distance

SetDisplayBottom24      - Sets the OpalVision display bottom

SetRGB24                - Sets a single palette entry 

SingleDisplay24         - Sets up an Amiga or OpalVision single display 

UpdatePalette24         - Updates palette information to the OpalVision Frame 
				Buffer Management 

ClearQuick24            - Clear all OpalVision frame buffer memory 

CloseScreen24           - Closes the currently displayed screen and frees 
				resources 

Config24                - Returns Hardware configuration information 

CreateScreen24          - Creates an arbitrarily sized virtual OpalScreen 

DisplayFrame24          - Sets the currently displayed frame within the frame 
				buffer memory 

FreeScreen24            - Frees a virtual OpalScreen

FreezeFrame24           - Freezes the currently displayed screen.  
				(requires Scan Rate Converter) 

OpenScreen24            - Allocates all resources and displays an OpalVision 
				screen 

Refresh24               - Refreshes information in the frame buffer memory 

RegWait24               - Waits for the completion of register updates 

SetControlBit24         - Modifies a bit in the control line data

SetLoadAddress24        - Updates the OpalVision load address register 

SetSprite24             - Sets Amiga sprites on OpalVision display 

StopUpdate24            - Stops updates to the frame buffer memory 

UpdateAll24             - Resets the internal update structure so all required 
				banks are updated 

UpdateDelay24           - Allows user definable update frequency 

UpdatePFStencil24       - Continuously update Dual Playfield stencil only 

UpdateRegs24            - Updates pixel read mask, palette load address and 
				control register 

WriteFrame24            - Sets the current frame to be written within the frame 
				buffer memory Frame Grabber Control


13.0	DEFINITION OF TERMS 

The following library function description is given in
standard C calling conventions.  The terms used are described here for non
C programers.

void                     -This specifies that there are no return values or 
			  input parameters.

USHORT                   -An unsigned 16bit integer.

UBYTE                    -An unsigned byte.

long                     -A signed 32bit integer.

BOOL    		 -A 32bit boolean value.  FALSE = 0, any non zero value 
			  is TRUE.

struct OpalScreen *OScrn -A pointer to an OpalScreen structure described 
			  previously.

UBYTE **Array[]          -A pointer to an array of pointers to UBYTE sized 
			  memory.

long (*Function)()       -A pointer to a function (routine) which returns a long 
                          result in D0.

NULL                     -A NULL pointer value (0).

BPTR                     -A BCPL pointer returned by a DOS Open() call.




