@database "teklib.doc"
@master "teklib.doc"
@Node Main "teklib.doc"
    @{" TAckMsg " Link "TAckMsg"}
    @{" TAddHead " Link "TAddHead"}
    @{" TAddSockPort " Link "TAddSockPort"}
    @{" TAddTag " Link "TAddTag"}
    @{" TAddTail " Link "TAddTail"}
    @{" TAllocSignal " Link "TAllocSignal"}
    @{" TCreatePool " Link "TCreatePool"}
    @{" TCreatePort " Link "TCreatePort"}
    @{" TCreateTask " Link "TCreateTask"}
    @{" TDestroy " Link "TDestroy"}
    @{" TDropMsg " Link "TDropMsg"}
    @{" TFindSockPort " Link "TFindSockPort"}
    @{" TFirstNode " Link "TFirstNode"}
    @{" TFreeMsg " Link "TFreeMsg"}
    @{" TFreeSignal " Link "TFreeSignal"}
    @{" TGetMsg " Link "TGetMsg"}
    @{" TGetMsgAttrs " Link "TGetMsgAttrs"}
    @{" TGetMsgSize " Link "TGetMsgSize"}
    @{" TGetMsgStatus " Link "TGetMsgStatus"}
    @{" TGetRandom " Link "TGetRandom"}
    @{" TGetRandomSeed " Link "TGetRandomSeed"}
    @{" TGetTagArray " Link "TGetTagArray"}
    @{" TGetTagValue " Link "TGetTagValue"}
    @{" TInitList " Link "TInitList"}
    @{" TInitLock " Link "TInitLock"}
    @{" TInitMMU " Link "TInitMMU"}
    @{" TInitMemHead " Link "TInitMemHead"}
    @{" TInitTags " Link "TInitTags"}
    @{" TInsert " Link "TInsert"}
    @{" TLastNode " Link "TLastNode"}
    @{" TListEmpty " Link "TListEmpty"}
    @{" TLock " Link "TLock"}
    @{" TMMUAlloc " Link "TMMUAlloc"}
    @{" TMMUAlloc0 " Link "TMMUAlloc0"}
    @{" TMMUAllocHandle " Link "TMMUAllocHandle"}
    @{" TMMUAllocHandle0 " Link "TMMUAllocHandle0"}
    @{" TMMUFree " Link "TMMUFree"}
    @{" TMMUFreeHandle " Link "TMMUFreeHandle"}
    @{" TMMUGetSize " Link "TMMUGetSize"}
    @{" TMMURealloc " Link "TMMURealloc"}
    @{" TMemCopy " Link "TMemCopy"}
    @{" TMemCopy32 " Link "TMemCopy32"}
    @{" TMemFill " Link "TMemFill"}
    @{" TMemFill32 " Link "TMemFill32"}
    @{" TPoolAlloc " Link "TPoolAlloc"}
    @{" TPoolFree " Link "TPoolFree"}
    @{" TPoolGetSize " Link "TPoolGetSize"}
    @{" TPoolRealloc " Link "TPoolRealloc"}
    @{" TPutMsg " Link "TPutMsg"}
    @{" TPutReplyMsg " Link "TPutReplyMsg"}
    @{" TRemHead " Link "TRemHead"}
    @{" TRemSockPort " Link "TRemSockPort"}
    @{" TRemTail " Link "TRemTail"}
    @{" TRemove " Link "TRemove"}
    @{" TReplyMsg " Link "TReplyMsg"}
    @{" TSeekNode " Link "TSeekNode"}
    @{" TSendMsg " Link "TSendMsg"}
    @{" TSetSignal " Link "TSetSignal"}
    @{" TSignal " Link "TSignal"}
    @{" TStaticAlloc " Link "TStaticAlloc"}
    @{" TStaticFree " Link "TStaticFree"}
    @{" TStaticGetSize " Link "TStaticGetSize"}
    @{" TStaticRealloc " Link "TStaticRealloc"}
    @{" TTaskAlloc " Link "TTaskAlloc"}
    @{" TTaskAlloc0 " Link "TTaskAlloc0"}
    @{" TTaskAllocMsg " Link "TTaskAllocMsg"}
    @{" TTaskBaseTask " Link "TTaskBaseTask"}
    @{" TTaskFree " Link "TTaskFree"}
    @{" TTaskGetData " Link "TTaskGetData"}
    @{" TTaskGetSize " Link "TTaskGetSize"}
    @{" TTaskHeapMMU " Link "TTaskHeapMMU"}
    @{" TTaskMsgMMU " Link "TTaskMsgMMU"}
    @{" TTaskPort " Link "TTaskPort"}
    @{" TTaskRealloc " Link "TTaskRealloc"}
    @{" TTaskSetData " Link "TTaskSetData"}
    @{" TTimeDelay " Link "TTimeDelay"}
    @{" TTimeQuery " Link "TTimeQuery"}
    @{" TTimeReset " Link "TTimeReset"}
    @{" TTimedWait " Link "TTimedWait"}
    @{" TUnlock " Link "TUnlock"}
    @{" TWait " Link "TWait"}
    @{" TWaitPort " Link "TWaitPort"}

rendered with docco[tm] TEKlib document generator (simple amigaguide)
@EndNode
@Node "TCreateTask" "TCreateTask"

    @{b}NAME@{ub}
        TCreateTask - create task.

    @{b}SYNOPSIS@{ub}
        task = TCreateTask(parenttask, function,  taglist);
        TAPTR              TAPTR       TTASKFUNC* TTAGITEM*

    @{b}FUNCTION@{ub}
        launch a task at the given function, or create an
        application's basetask.

        for creating a basetask, both parenttask and function must
        be TNULL. all further tasks and most TEKlib internal
        structures will be derived from a basetask in the end, so
        it's usually one of the first objects created in a TEKlib
        framework.

        for creating a child task, parenttask must refer to the
        caller's context, and function usually refers to a task
        entry function. sometimes it may be desirable to only call
        an init function in a new context, so function may be TNULL,
        provided that the tag argument TTask_InitFunc is specified.
        if neither a task entry function nor an init function is
        specified, @{"TCreateTask" Link "TCreateTask"} returns TNULL.

    @{b}INPUTS@{ub}
        parenttask - parent task. for creating a child task, this must
                     refer to the current context. TNULL for creating
                     an application's base task.

        function   - function entry. this must refer to a function
                     with the prototype TVOID (*function)(TAPTR task),
                     or may optionally be TNULL when the tag
                     TTask_InitFunc is specified in the taglist
                     arguments. TNULL when a basetask is to be created.

        taglist    - pointer to an array of tag items.

    @{b}TAGS@{ub}
        TTask_UserData, TAPTR
            pointer to arbitrary user data. a task's userdata field
            can be obtained with @{"TTaskGetData" Link "TTaskGetData"}.
            default: TNULL

        TTask_InitFunc, TBOOL (*function)(TAPTR task)
            pointer to a user init function. @{"TCreateTask" Link "TCreateTask"} will initially
            call this function inside a newly created context, and enter
            the task's main function entry only if the init function
            returns TTRUE. otherwise child task creation is entirely
            abandoned, the task entry function is never called, and
            @{"TCreateTask" Link "TCreateTask"} returns TNULL. when this argument is specified,
            the task's function entry argument may be TNULL.
            default: TNULL

        TTask_CreatePort, TBOOL
            create an initial message-port in the child's context.
            @{"TCreateTask" Link "TCreateTask"} will entirely fail and return TNULL when
            a childport was requested and could not be established.
            by default, any newly created task will be supplied with
            a messageport. default: TTRUE

        TTask_MMU, TAPTR
            pointer to a memory management unit for allocating the task's
            structures. default: the heap MMU of an application's
            basetask, or TNULL if this is the basetask to be created.

        TTask_HeapMMU, TAPTR
            pointer to a memory management unit. the new task's heap
            memory manager will be put on top of this MMU.
            default: the argument or default value to TTask_MMU

    @{b}RESULTS@{ub}
        task       - task handle, or TNULL if the task could not be
                     established. a task handle is destroyed with a
                     call to @{"TDestroy" Link "TDestroy"}.

    @{b}SEE ALSO@{ub}
        @{"TDestroy" Link "TDestroy"}, @{"TTaskGetData" Link "TTaskGetData"}, @{"TTaskSetData" Link "TTaskSetData"}, @{"TTaskPort" Link "TTaskPort"},
        @{"TTaskBaseTask" Link "TTaskBaseTask"}, @{"TCreatePort" Link "TCreatePort"}, @{"TTaskHeapMMU" Link "TTaskHeapMMU"}


@EndNode
@Node "TAllocSignal" "TAllocSignal"

    @{b}NAME@{ub}
        TAllocSignal - allocate a single or a set of signals

    @{b}SYNOPSIS@{ub}
        signals = TAllocSignal(task, prefsignals)
        TUINT                  TAPTR TUINT

    @{b}FUNCTION@{ub}
        allocate a signal (or a set of preferred signals) from the
        given task. if prefsignals is 0, then this function will try to
        reserve any single free signal. if prefsignals is not 0, this
        function tries to reserve the exact set specified, and returns
        0 if any of the specified signals are already in use.

    @{b}INPUTS@{ub}
        task        - task to which the signal (or signal set) will belong
        prefsignals - preferred signals to allocate, or zero

    @{b}RESULTS@{ub}
        signals     - allocated signal mask. zero if out of signals, or
                      when any of prefsignals are already in use.

    @{b}NOTES@{ub}
        signals no longer needed should be freed with @{"TFreeSignal" Link "TFreeSignal"}.

    @{b}SEE ALSO@{ub}
        @{"TFreeSignal" Link "TFreeSignal"}, @{"TSignal" Link "TSignal"}, @{"TSetSignal" Link "TSetSignal"}, @{"TWait" Link "TWait"}


@EndNode
@Node "TFreeSignal" "TFreeSignal"

    @{b}NAME@{ub}
        TTaskFreeSignal - free a single or set of task signals

    @{b}SYNOPSIS@{ub}
        TFreeSignal(task, sigmask)
                    TAPTR TUINT

    @{b}FUNCTION@{ub}
        free a single or set of signals and return it to a task's
        pool of allocatable signals.

    @{b}INPUTS@{ub}
        task    - task to which the signal(s) belong.
        sigmask - signal mask to be freed. it is safe to pass
                  0 (no-signal) here.

    @{b}SEE ALSO@{ub}
        @{"TAllocSignal" Link "TAllocSignal"}


@EndNode
@Node "TSignal" "TSignal"

    @{b}NAME@{ub}
        TSignal - submit a set of signals to a task.

    @{b}SYNOPSIS@{ub}
        TSignal(task, signals);
                TAPTR TUINT

    @{b}FUNCTION@{ub}
        submit signals to a task. when the task was waiting
        for the specified signals, it will resume operation.

    @{b}INPUTS@{ub}
        task    - task to be signalled.
        signals - a set of signals to be submitted.

    @{b}RESULTS@{ub}
        the signal will show up in the signalled task's
        context.

    @{b}EXAMPLE@{ub}
        /* submit the (predefined) abortion signal: */
        TSignal(task, TTASK_SIG_ABORT);

    @{b}NOTES@{ub}
        it is valid to apply this function to both the caller's
        own task as well as to foreign tasks.

    @{b}SEE ALSO@{ub}
        @{"TSetSignal" Link "TSetSignal"}, @{"TWait" Link "TWait"}


@EndNode
@Node "TSetSignal" "TSetSignal"

    @{b}NAME@{ub}
        TSetSignal - set and get a task's signals.

    @{b}SYNOPSIS@{ub}
        oldsignals = TSetSignal(task, newsignals, sigmask);
                                TAPTR TUINT       TUINT

    @{b}FUNCTION@{ub}
        set (and get) task's signals state

    @{b}INPUTS@{ub}
        task       - task
        newsignals - new set of signals
        sigmask    - signal bits to be affected

    @{b}EXAMPLES@{ub}
        /* get the current state of all signals, but do not modify them */
        signals = TSetSignal(task, 0, 0);

        /* clear the pre-defined abortion signal */
        TSetSignal(task, 0, TTASK_SIG_ABORT);

    @{b}NOTES@{ub}
        it is valid to apply this function to the caller's own task as
        well as to another task. note, however, that the results may be
        confusing when a foreign context is being addressed: with this
        function it would be possible to wakeup a foreign task with the
        affecting signals being removed from its current signal state.

    @{b}SEE ALSO@{ub}
        @{"TSignal" Link "TSignal"}, @{"TWait" Link "TWait"}


@EndNode
@Node "TWait" "TWait"

    @{b}NAME@{ub}
        TWait - wait for a set of signals.

    @{b}SYNOPSIS@{ub}
        signals = TWait(task, sigmask)
        TUINT           TAPTR TUINT

    @{b}FUNCTION@{ub}
        suspend task until one or more of the specified
        signals arrive. those bits will be cleared from
        the task's context when the function returns.

    @{b}INPUTS@{ub}
        task    - task, this MUST refer to the caller's context
        sigmask - mask of signals to wait for. if sigmask is 0,
                  this function will return immediately.

    @{b}RESULTS@{ub}
        signals - signals that caused returning

    @{b}NOTES@{ub}
        if applied not to the caller's own task, the results are
        entirely undefined, and it will likely break your software.

    @{b}SEE ALSO@{ub}
        @{"TTimedWait" Link "TTimedWait"}, @{"TWaitPort" Link "TWaitPort"}, @{"TSignal" Link "TSignal"}


@EndNode
@Node "TTimedWait" "TTimedWait"

    @{b}NAME@{ub}
        TTimedWait - wait for a set of signals, with timeout

    @{b}SYNOPSIS@{ub}
        signals = TTimedWait(task, sigmask, timeout)
        TUINT                TAPTR TUINT    TTIME*

    @{b}FUNCTION@{ub}
        suspend task to wait for a set of signals, or for a timeout.
        any signals causing this function to return will be returned
        to the caller and cleared from the task's set of signals. if
        a timeout caused the return, the return value will be 0.
        if timeout is TNULL or (timeout->sec and timeout->usec) are
        zero, this function is equivalent to @{"TWait" Link "TWait"}.

    @{b}INPUTS@{ub}
        task    - task, this MUST refer to the caller's context
        sigmask - mask of signals to wait for
        timeout - pointer to a TTIME specifier

    @{b}RESULTS@{ub}
        signals - signals that caused returning, or 0 if timeout

    @{b}NOTES@{ub}
        if applied to not the caller's own task, the results are
        entirely undefined, and it will likely break your software.

    @{b}SEE ALSO@{ub}
        @{"TWait" Link "TWait"}, @{"TWaitPort" Link "TWaitPort"}, @{"TSignal" Link "TSignal"}


@EndNode
@Node "TInitLock" "TInitLock"

    @{b}NAME@{ub}
        TInitLock - initialize a task lock

    @{b}SYNOPSIS@{ub}
        success = TInitLock(task, lock,  tags);
        TBOOL               TAPTR TLOCK* TTAGITEM*

    @{b}FUNCTION@{ub}
        initialize a task lock structure. a task lock is an
        atomic cross-task protection mechanism. after initialization,
        the object has no owner and is in unlocked state.

    @{b}INPUTS@{ub}
        task    - caller's own task.
        lock    - pointer to a TLOCK structure.
        tags    - pointer to an array of tag items.

    @{b}TAGS@{ub}
        none defined yet.

    @{b}RESULTS@{ub}
        success - TTRUE if initialization was successful, else TFALSE

    @{b}NOTES@{ub}
        a lock is destroyed with a call to @{"TDestroy" Link "TDestroy"}. results are
        undefined if a lock is destroyed in locked state. any call to
        @{"TLock" Link "TLock"} per calling context must be empaired with exactly
        one matching call to @{"TUnlock" Link "TUnlock"}.

    @{b}SEE ALSO@{ub}
        @{"TLock" Link "TLock"}, @{"TUnlock" Link "TUnlock"}, @{"TDestroy" Link "TDestroy"}


@EndNode
@Node "TLock" "TLock"

    @{b}NAME@{ub}
        TLock - gain exclusive access to a task lock.

    @{b}SYNOPSIS@{ub}
        TLock(lock);
              TLOCK*

    @{b}FUNCTION@{ub}
        gain exclusive access to a task lock. if another task is
        currenty holding the lock, the caller will block until the
        lock is released. if no other task holds the lock, this function
        will return immediately with exclusive access to the lock.

        this function is recurisve (or 'nesting'), i.e. it may be called
        again in the caller's context when the lock is already held in
        the caller's context. in that case an internal counter is
        increased, and this function will return immediately. each call
        per context must be empaired with exactly one matching call
        to @{"TUnlock" Link "TUnlock"}, which will decrease the counter. finally, when
        the counter reaches zero, the lock is actually released.

    @{b}INPUTS@{ub}
        lock    - pointer to a TLOCK structure, initialized with
                  @{"TInitLock" Link "TInitLock"}

    @{b}RESULTS@{ub}
        none

    @{b}SEE ALSO@{ub}
        @{"TUnlock" Link "TUnlock"}, @{"TInitLock" Link "TInitLock"}


@EndNode
@Node "TUnlock" "TUnlock"

    @{b}NAME@{ub}
        TUnlock - release access to a task lock.

    @{b}SYNOPSIS@{ub}
        TUnlock(lock);
                TLOCK*

    @{b}FUNCTION@{ub}
        release access to a task lock, which was previously obtained with
        a call to @{"TLock" Link "TLock"}. see the function description there.

    @{b}INPUTS@{ub}
        lock    - pointer to a TLOCK structure, initialized with
                  @{"TInitLock" Link "TInitLock"}

    @{b}RESULTS@{ub}
        none

    @{b}SEE ALSO@{ub}
        @{"TLock" Link "TLock"}, @{"TInitLock" Link "TInitLock"}


@EndNode
@Node "TCreatePort" "TCreatePort"

    @{b}NAME@{ub}
        TCreatePort - create a messageport.

    @{b}SYNOPSIS@{ub}
        port = TCreatePort(task, tags)
        TPORT*             TAPTR TTAGITEM*

    @{b}FUNCTION@{ub}
        allocate a signal from the given task, and create and initialize
        a port for message communication, which will belong to the
        task's context.

    @{b}INPUTS@{ub}
        task    - task that will be the owner of the messageport.
                  this should be the caller's own task context.
        taglist - pointer to an array of tag items

    @{b}TAGS@{ub}
        TTask_MMU, TAPTR
            pointer to a memory management unit to allocate the port
            structures from. default: the task's heap memory manager.

    @{b}RESULTS@{ub}
        port    - messageport created, or TNULL on failure.

    @{b}NOTES@{ub}
        - a port is destroyed with a call to @{"TDestroy" Link "TDestroy"}.

        - currently (v0.3) it is valid to create a messageport for a
          foreign task, but this should be rarely ever needed, and
          may result in a confusing application design. do not rely
          on this. future versions might limit this function strictly
          to the caller's own task context.

    @{b}SEE ALSO@{ub}
        @{"TWaitPort" Link "TWaitPort"}, @{"TPutMsg" Link "TPutMsg"}, @{"TPutReplyMsg" Link "TPutReplyMsg"}, @{"TDestroy" Link "TDestroy"}


@EndNode
@Node "TWaitPort" "TWaitPort"

    @{b}NAME@{ub}
        TWaitPort - wait for a port to be non-empty

    @{b}SYNOPSIS@{ub}
        TWaitPort(msgport)
                  TPORT*

    @{b}FUNCTION@{ub}
        suspend a messageport's owner task until a message is
        present at its message queue. when a message is already
        present, return immediately.

    @{b}INPUTS@{ub}
        msgport  - messageport. this port must be owned by the
                   caller's context.

    @{b}RESULTS@{ub}
        none

    @{b}NOTES@{ub}
        if the port does not belong to to the caller's own task context,
        the results are entirely undefined, and it will likely break
        your software.

    @{b}SEE ALSO@{ub}
        @{"TCreatePort" Link "TCreatePort"}, @{"TWait" Link "TWait"}, @{"TGetMsg" Link "TGetMsg"}


@EndNode
@Node "TTimeDelay" "TTimeDelay"

    @{b}NAME@{ub}
        TTimeDelay - sleep

    @{b}SYNOPSIS@{ub}
        TTimeDelay(task, time)
                   TAPTR TTIME*

    @{b}FUNCTION@{ub}
        suspend the caller's task and sleep for the specified time.

    @{b}INPUTS@{ub}
        task    - task handle referring to the caller's context.
        time    - time structure

    @{b}SEE ALSO@{ub}
        @{"TTimeQuery" Link "TTimeQuery"}, @{"TCreateTask" Link "TCreateTask"}


@EndNode
@Node "TTimeQuery" "TTimeQuery"

    @{b}NAME@{ub}
        TTimeQuery - query task timer

    @{b}SYNOPSIS@{ub}
        TTimeQuery(task, time)
                   TAPTR TTIME*

    @{b}FUNCTION@{ub}
        this function queries a task's inbuilt timer and inserts the
        time elapsed since task creation into the specified time
        structure.

    @{b}INPUTS@{ub}
        task    - task handle to query.
        time    - time structure.

    @{b}NOTES@{ub}
        - a task's timer is initialized to zero when its task is created,
          therefore it measures the task's lifetime.

        - it is valid to query a foreign task's timer, i.e. the task
          handle does not need to refer to the caller's context.

    @{b}SEE ALSO@{ub}
        @{"TTimeReset" Link "TTimeReset"}, @{"TTimeDelay" Link "TTimeDelay"}, @{"TCreateTask" Link "TCreateTask"}


@EndNode
@Node "TTimeReset" "TTimeReset"

    @{b}NAME@{ub}
        TTimeReset - reset task timer

    @{b}SYNOPSIS@{ub}
        TTimeReset(task)
                   TAPTR

    @{b}FUNCTION@{ub}
        this function resets the given task's inbuilt timer to zero.

    @{b}INPUTS@{ub}
        task    - task to reset

    @{b}SEE ALSO@{ub}
        @{"TTimeQuery" Link "TTimeQuery"}, @{"TTimeDelay" Link "TTimeDelay"}, @{"TCreateTask" Link "TCreateTask"}


@EndNode
@Node "TGetRandomSeed" "TGetRandomSeed"

    @{b}NAME@{ub}
        TGetRandomSeed - get a seed value

    @{b}SYNOPSIS@{ub}
        seed = TGetRandomSeed(task)
        TUINT                 TAPTR

    @{b}FUNCTION@{ub}
        generate a random seed number.

    @{b}INPUTS@{ub}
        task - task handle to query

    @{b}RESULTS@{ub}
        seed - seed value for random number generation

    @{b}NOTES@{ub}
        currently (v0.3) a seed number is generated from a task's
        individual timer, but the quality of this value may differ
        on different hosting environments, and may not be sufficient
        for advanced purposes, such as crypto key generation.

    @{b}SEE ALSO@{ub}
        @{"TGetRandom" Link "TGetRandom"}, @{"TTimeQuery" Link "TTimeQuery"}, @{"TCreateTask" Link "TCreateTask"}


@EndNode
@Node "TTaskAlloc" "TTaskAlloc"

    @{b}NAME@{ub}
        TTaskAlloc - allocate memory from a task

    @{b}SYNOPSIS@{ub}
        mem = TTaskAlloc(task, size)
        TAPTR            TAPTR TUINT

    @{b}FUNCTION@{ub}
        allocate memory from a task's inbuilt heap memory manager.

    @{b}INPUTS@{ub}
        task - task handle to allocate from
        size - size of the requested block of memory [bytes]

    @{b}RESULTS@{ub}
        mem  - pointer to memory, or TNULL if memory exhausted.

    @{b}NOTES@{ub}
        - a task's heap memory manager implements thread-safety and
          cleanup handling by default. unless you do not specify a
          user MMU upon task creation, you may safely allocate from
          foreign tasks, and allocations will be freed automatically
          when their respective task exits.

        - this function is currently (v0.3) being implemented as
          a macro, redirecting the call to @{"TMMUAlloc" Link "TMMUAlloc"} on a task's
          heap MMU.

    @{b}SEE ALSO@{ub}
        @{"TTaskFree" Link "TTaskFree"}, @{"TTaskAlloc0" Link "TTaskAlloc0"}, @{"TTaskRealloc" Link "TTaskRealloc"}, @{"TTaskGetSize" Link "TTaskGetSize"},
        @{"TCreateTask" Link "TCreateTask"}


@EndNode
@Node "TTaskAlloc0" "TTaskAlloc0"

    @{b}NAME@{ub}
        TTaskAlloc0 - allocate blank memory from a task

    @{b}SYNOPSIS@{ub}
        mem = TTaskAlloc0(task, size)
        TAPTR             TAPTR TUINT

    @{b}FUNCTION@{ub}
        allocate blank memory from a task's inbuilt heap memory manager,
        i.e. the allocated block will be cleared with zero-bytes.

    @{b}INPUTS@{ub}
        task - task handle to allocate from
        size - size of the requested block of memory [bytes]

    @{b}RESULTS@{ub}
        mem  - pointer to memory, or TNULL if memory exhausted.

    @{b}NOTES@{ub}
        - see annotations for @{"TTaskAlloc" Link "TTaskAlloc"}.

        - this function is currently (v0.3) being implemented as
          a macro, redirecting the call to @{"TMMUAlloc0" Link "TMMUAlloc0"} on a task's
          heap MMU.

    @{b}SEE ALSO@{ub}
        @{"TTaskFree" Link "TTaskFree"}, @{"TTaskAlloc" Link "TTaskAlloc"}


@EndNode
@Node "TTaskFree" "TTaskFree"

    @{b}NAME@{ub}
        TTaskFree - return memory to a task.

    @{b}SYNOPSIS@{ub}
        TTaskFree(task, mem)
                  TAPTR TAPTR

    @{b}FUNCTION@{ub}
        return an allocation to a task's heap memory manager.

    @{b}INPUTS@{ub}
        task - task handle to allocate from
        mem  - pointer to an allocation made from a task

    @{b}RESULTS@{ub}
        none

    @{b}NOTES@{ub}
        - see annotations for @{"TTaskAlloc" Link "TTaskAlloc"}.

        - this function is currently (v0.3) being implemented as
          a macro, redirecting the call to @{"TMMUFree" Link "TMMUFree"} on a task's
          heap MMU.

    @{b}SEE ALSO@{ub}
        @{"TTaskAlloc" Link "TTaskAlloc"}


@EndNode
@Node "TTaskRealloc" "TTaskRealloc"

    @{b}NAME@{ub}
        TTaskRealloc - realloc an allocation from a task

    @{b}SYNOPSIS@{ub}
        newmem = TTaskRealloc(task, oldmem, newsize)
        TAPTR                 TAPTR TAPTR   TUINT

    @{b}FUNCTION@{ub}
        reallocate an allocation previously made from
        a task's heap memory manager.

        when the oldmem argument is TNULL, this function tries to
        allocate a new block of the given newsize. when newsize is
        zero and oldmem is given, the block will be freed, and TNULL
        will be returned. when oldmem is TNULL and newsize is zero,
        this function returns TNULL.

    @{b}INPUTS@{ub}
        task    - task handle
        oldmem  - pointer to an allocation from the task
        newsize - new size for the reallocated block of memory

    @{b}RESULTS@{ub}
        newmem  - pointer to memory being reallocated, or TNULL.

    @{b}NOTES@{ub}
        - reallocation may require that the given block of memory
          needs to be moved in memory, i.e. pointers to this area
          may become invalid.

        - see annotations for @{"TTaskAlloc" Link "TTaskAlloc"}.

        - this function is currently (v0.3) being implemented as
          a macro, redirecting the call to @{"TMMURealloc" Link "TMMURealloc"} on a task's
          heap MMU.

    @{b}SEE ALSO@{ub}
        @{"TTaskAlloc" Link "TTaskAlloc"}


@EndNode
@Node "TTaskGetSize" "TTaskGetSize"

    @{b}NAME@{ub}
        TTaskGetSize - get size of an allocation from a task.

    @{b}SYNOPSIS@{ub}
        size = TTaskGetSize(task, mem)
        TUINT               TAPTR TAPTR

    @{b}FUNCTION@{ub}
        return the size of an allocation previously made from
        a task's heap memory manager.

    @{b}INPUTS@{ub}
        task - task handle
        mem  - pointer to an allocation made from the task

    @{b}RESULTS@{ub}
        size - size of the allocation [bytes]

    @{b}NOTES@{ub}
        - see annotations for @{"TTaskAlloc" Link "TTaskAlloc"}.

        - this function is currently (v0.3) being implemented as
          a macro, redirecting the call to @{"TMMUGetSize" Link "TMMUGetSize"} on a task's
          heap MMU.

    @{b}SEE ALSO@{ub}
        @{"TTaskAlloc" Link "TTaskAlloc"}


@EndNode
@Node "TTaskAllocMsg" "TTaskAllocMsg"

    @{b}NAME@{ub}
        TTaskAllocMsg - allocate a message.

    @{b}SYNOPSIS@{ub}
        msg = TTaskAllocMsg(task, size)
        TAPTR               TAPTR TUINT

    @{b}FUNCTION@{ub}
        allocate a message of the given size from a task.

    @{b}INPUTS@{ub}
        task  - task handle
        size  - size of the message [bytes]

    @{b}RESULTS@{ub}
        msg   - pointer to message buffer, or TNULL if out of memory

    @{b}NOTES@{ub}
        - the message size can be queried with @{"TGetMsgAttrs" Link "TGetMsgAttrs"}.

        - this function is currently (v0.3) being implemented as
          a macro, redirecting the call to @{"TMMUAlloc" Link "TMMUAlloc"} on a task's
          message MMU.

    @{b}SEE ALSO@{ub}
        @{"TFreeMsg" Link "TFreeMsg"}, @{"TReplyMsg" Link "TReplyMsg"}, @{"TAckMsg" Link "TAckMsg"}, @{"TDropMsg" Link "TDropMsg"}, @{"TGetMsgAttrs" Link "TGetMsgAttrs"},
        @{"TMMUAlloc" Link "TMMUAlloc"}, @{"TSendMsg" Link "TSendMsg"}


@EndNode
@Node "TTaskBaseTask" "TTaskBaseTask"

    @{b}NAME@{ub}
        TTaskBaseTask - get base task handle.

    @{b}SYNOPSIS@{ub}
        basetask = TTaskBaseTask(task)
        TAPTR                    TAPTR

    @{b}FUNCTION@{ub}
        return a pointer to the root task context of a TEKlib framework.
        the pointer to the base task handle is carried in each of its
        childs. it is also valid to apply this function to the basetask
        itself.

    @{b}INPUTS@{ub}
        task      - a task handle

    @{b}RESULTS@{ub}
        basetask  - pointer to the application framework's base task

    @{b}NOTES@{ub}
        this function is currently (v0.3) being implemented as a macro.

    @{b}SEE ALSO@{ub}
        @{"TCreateTask" Link "TCreateTask"}


@EndNode
@Node "TTaskHeapMMU" "TTaskHeapMMU"

    @{b}NAME@{ub}
        TTaskHeapMMU - get a task's heap memory manager.

    @{b}SYNOPSIS@{ub}
        heapmmu = TTaskHeapMMU(task)
        TAPTR                  TAPTR

    @{b}FUNCTION@{ub}
        return a pointer to a task's heap memory manager.

    @{b}INPUTS@{ub}
        task      - task handle

    @{b}RESULTS@{ub}
        heapmmu   - pointer to the task's heap MMU.

    @{b}NOTES@{ub}
        this function is currently (v0.3) being implemented as a macro.

    @{b}SEE ALSO@{ub}
        @{"TCreateTask" Link "TCreateTask"}, @{"TTaskAlloc" Link "TTaskAlloc"}, @{"TTaskMsgMMU" Link "TTaskMsgMMU"}, @{"TInitMMU" Link "TInitMMU"}


@EndNode
@Node "TTaskMsgMMU" "TTaskMsgMMU"

    @{b}NAME@{ub}
        TTaskMsgMMU - get a task's message memory manager.

    @{b}SYNOPSIS@{ub}
        msgmmu = TTaskMsgMMU(task)
        TAPTR                TAPTR

    @{b}FUNCTION@{ub}
        return a pointer to a task's message memory manager.

    @{b}INPUTS@{ub}
        task    - task handle

    @{b}RESULTS@{ub}
        msgmmu  - pointer to the task's message MMU.

    @{b}NOTES@{ub}
        this function is currently (v0.3) being implemented as a macro.

    @{b}SEE ALSO@{ub}
        @{"TCreateTask" Link "TCreateTask"}, @{"TTaskAllocMsg" Link "TTaskAllocMsg"}, @{"TTaskHeapMMU" Link "TTaskHeapMMU"}, @{"TInitMMU" Link "TInitMMU"}


@EndNode
@Node "TTaskGetData" "TTaskGetData"

    @{b}NAME@{ub}
        TTaskGetData - get a task's userdata pointer.

    @{b}SYNOPSIS@{ub}
        userdata = TTaskGetData(task)
        TAPTR                   TAPTR

    @{b}FUNCTION@{ub}
        return a pointer to a task's userdata.

    @{b}INPUTS@{ub}
        task     - task handle

    @{b}RESULTS@{ub}
        userdata - pointer to the task's userdata.

    @{b}NOTES@{ub}
        this function is currently (v0.3) being implemented as a macro.

    @{b}SEE ALSO@{ub}
        @{"TTaskSetData" Link "TTaskSetData"}, @{"TCreateTask" Link "TCreateTask"}


@EndNode
@Node "TTaskSetData" "TTaskSetData"

    @{b}NAME@{ub}
        TTaskSetData - change a task's userdata pointer.

    @{b}SYNOPSIS@{ub}
        TTaskSetData(task, userdata)
                     TAPTR TAPTR

    @{b}FUNCTION@{ub}
        change a task's userdata pointer.

    @{b}INPUTS@{ub}
        task     - task handle
        userdata - arbitrary pointer to user data.

    @{b}NOTES@{ub}
        - if you want to modify and query a task's userdata pointer from
          different task contexts during a task's lifetime, you will
          probably need to implement a locking mechanism to ensure data
          integrity. you might find it more reliable to leave the primary
          userdata pointer unmodified, and reference userdata indirectly:

          struct taskuserdata
          {
              TLOCK lock;
              TAPTR userdata;
          };

          TVOID taskfunc(TAPTR task)
          {
              struct taskuserdata *d = TTaskGetData(task);
              TLock(&d->lock);
              /* set and get and operate on d->userdata pointer safely */
              TUnlock(&d->lock);
          }

          you can, however, safely set and get a task's userdata pointer
          inside a task's init function, because the newly created context
          is unknown to other task contexts at this time. there is no
          locking required in a task's init function.

        - this function is currently (v0.3) being implemented as a macro.

    @{b}SEE ALSO@{ub}
        @{"TTaskGetData" Link "TTaskGetData"}, @{"TCreateTask" Link "TCreateTask"}, @{"TInitLock" Link "TInitLock"}


@EndNode
@Node "TTaskPort" "TTaskPort"

    @{b}NAME@{ub}
        TTaskPort - get a task's messageport.

    @{b}SYNOPSIS@{ub}
        port = TTaskPort(task)
        TPORT*           TAPTR

    @{b}FUNCTION@{ub}
        return a pointer to a task's messageport.

    @{b}INPUTS@{ub}
        task     - task handle

    @{b}RESULTS@{ub}
        port     - pointer to task's messageport

    @{b}NOTES@{ub}
        this function is currently (v0.3) being implemented as a macro.

    @{b}SEE ALSO@{ub}
        @{"TCreateTask" Link "TCreateTask"}, @{"TCreatePort" Link "TCreatePort"}


@EndNode
@Node "TFreeMsg" "TFreeMsg"

    @{b}NAME@{ub}
        TFreeMsg - free a message.

    @{b}SYNOPSIS@{ub}
        TFreeMsg(msg)
                 TAPTR

    @{b}FUNCTION@{ub}
        free a message and return its memory to the message memory
        manager it has been allocated from.

        this function may be applied only when a message was allocated
        but never sent, or when it has been sent as a two-way message
        with @{"TPutReplyMsg" Link "TPutReplyMsg"}, and returned to a replyport.

        one-way messages sent with @{"TPutMsg" Link "TPutMsg"} are freed transparently
        with either @{"TAckMsg" Link "TAckMsg"} or @{"TReplyMsg" Link "TReplyMsg"} at the destination
        endpoint.

    @{b}INPUTS@{ub}
        msg      - message to be freed.

    @{b}NOTES@{ub}
        this function is currently (v0.3) being implemented as a macro.

    @{b}SEE ALSO@{ub}
        @{"TTaskAllocMsg" Link "TTaskAllocMsg"}, @{"TDropMsg" Link "TDropMsg"}, @{"TReplyMsg" Link "TReplyMsg"}, @{"TAckMsg" Link "TAckMsg"}, @{"TPutMsg" Link "TPutMsg"},
        @{"TPutReplyMsg" Link "TPutReplyMsg"}, @{"TSendMsg" Link "TSendMsg"}


@EndNode
@Node "TPutMsg" "TPutMsg"

    @{b}NAME@{ub}
        TPutMsg - send a one-way message.

    @{b}SYNOPSIS@{ub}
        TPutMsg(msgport, msg)
                TPORT*   TAPTR

    @{b}FUNCTION@{ub}
        put a one-way message to a messageport. one-way messages
        do not return to the sender. this function never blocks.

        messages sent to messageports in the caller's local address
        space are reliable, whereas messages put to remote ports are
        not. you may only assume that a one-way message has been
        successfully delivered to a remote port when you receive a
        corresponding reply, which in some way needs to be defined
        elsewhere in your individual protocols.

        when you don't know whether the addressed messageport
        is in your local address space or not, you must consider
        message delivery with this function to be unreliable.

    @{b}INPUTS@{ub}
        msgport    - messageport to be addressed.
        msg        - message to be sent.

    @{b}NOTES@{ub}
        messages can be sent reliably with @{"TPutReplyMsg" Link "TPutReplyMsg"}.

    @{b}SEE ALSO@{ub}
        @{"TPutReplyMsg" Link "TPutReplyMsg"}, @{"TGetMsg" Link "TGetMsg"}, @{"TAckMsg" Link "TAckMsg"}, @{"TReplyMsg" Link "TReplyMsg"}, @{"TDropMsg" Link "TDropMsg"},
        @{"TTaskAllocMsg" Link "TTaskAllocMsg"}, @{"TFreeMsg" Link "TFreeMsg"}, @{"TSendMsg" Link "TSendMsg"}, @{"TCreatePort" Link "TCreatePort"}


@EndNode
@Node "TPutReplyMsg" "TPutReplyMsg"

    @{b}NAME@{ub}
        TPutReplyMsg - send a two-way message.

    @{b}SYNOPSIS@{ub}
        TPutReplyMsg(msgport, replyport, msg)
                     TPORT*   TPORT*     TAPTR

    @{b}FUNCTION@{ub}
        put a two-way message to a messageport, with a reply
        or acknowledgement being delivered to the given replyport.
        two-way messages always return to the sender. this function
        never blocks.

        message delivery to a messageport in local address space
        is defined to be reliable, and will always succeed. message
        delivery over unreliable transmission paths (such as TCP/IP
        network connections), on the other hand, may always fail.

        this function ensures that the sender will be informed about
        a message's fate, regardless whether the addressed port is
        in local address space or not.

        messages that could not be delivered (or failed to return)
        over an unreliable connection will appear on the given
        replyport with their status set to TMSG_STATUS_FAILED.
        successful delivery will be indicated with a status set to
        TMSG_STATUS_REPLIED or TMSG_STATUS_ACKD (depending on the
        reply method). the message status can be queried with
        @{"TGetMsgAttrs" Link "TGetMsgAttrs"}.

        after the message arrived at its replyport, it usually needs
        be freed with @{"TFreeMsg" Link "TFreeMsg"}. it is possible, however, to reuse
        a message.

    @{b}INPUTS@{ub}
        msgport    - messageport to be addressed.
        replyport  - replyport to which the message will be returned.
        msg        - message to be sent.

    @{b}SEE ALSO@{ub}
        @{"TPutMsg" Link "TPutMsg"}, @{"TGetMsg" Link "TGetMsg"}, @{"TAckMsg" Link "TAckMsg"}, @{"TReplyMsg" Link "TReplyMsg"}, @{"TDropMsg" Link "TDropMsg"},
        @{"TTaskAllocMsg" Link "TTaskAllocMsg"}, @{"TFreeMsg" Link "TFreeMsg"}, @{"TSendMsg" Link "TSendMsg"}, @{"TCreatePort" Link "TCreatePort"}


@EndNode
@Node "TGetMsg" "TGetMsg"

    @{b}NAME@{ub}
        TGetMsg - get message.

    @{b}SYNOPSIS@{ub}
        msg = TGetMsg(msgport)
        TAPTR         TPORT*

    @{b}FUNCTION@{ub}
        unlink the next pending message from a messageport's queue
        and return it to the caller. this function does not block.

        a message's status and other attributes can be queried with
        @{"TGetMsgAttrs" Link "TGetMsgAttrs"}.

    @{b}INPUTS@{ub}
        msgport    - messageport to get next message from.

    @{b}RESULTS@{ub}
        msg        - next pending message, or TNULL if the
                     messageport queue was empty.

    @{b}SEE ALSO@{ub}
        @{"TPutMsg" Link "TPutMsg"}, @{"TPutReplyMsg" Link "TPutReplyMsg"}, @{"TAckMsg" Link "TAckMsg"}, @{"TReplyMsg" Link "TReplyMsg"},
        @{"TTaskAllocMsg" Link "TTaskAllocMsg"}, @{"TFreeMsg" Link "TFreeMsg"}, @{"TCreatePort" Link "TCreatePort"}


@EndNode
@Node "TAckMsg" "TAckMsg"

    @{b}NAME@{ub}
        TAckMsg - acknowledge message.

    @{b}SYNOPSIS@{ub}
        TAckMsg(msg)
                TAPTR

    @{b}FUNCTION@{ub}
        acknowledge a two-way message to its sender, i.e. return
        it to its sender's replyport.

        it is safe, however, to apply this function to one-way
        messages as well; if the message was sent without a reply
        or acknowledgement expected, it will be silently freed by
        this function.

        when a message is returned with this function, the sender
        must not rely on any modifications made inside the message body.
        if you want to modify data inside the message and send its
        modified contents back to the sender, you should use @{"TReplyMsg" Link "TReplyMsg"}
        instead.

    @{b}INPUTS@{ub}
        msg     - message to be acknowledged to its sender
                  (or to be freed, transparently)

    @{b}SEE ALSO@{ub}
        @{"TReplyMsg" Link "TReplyMsg"}, @{"TFreeMsg" Link "TFreeMsg"}, @{"TDropMsg" Link "TDropMsg"}, @{"TPutMsg" Link "TPutMsg"}, @{"TPutReplyMsg" Link "TPutReplyMsg"},
        @{"TFreeMsg" Link "TFreeMsg"}, @{"TTaskAllocMsg" Link "TTaskAllocMsg"}, @{"TSendMsg" Link "TSendMsg"}, @{"TCreatePort" Link "TCreatePort"}


@EndNode
@Node "TReplyMsg" "TReplyMsg"

    @{b}NAME@{ub}
        TReplyMsg - reply message.

    @{b}SYNOPSIS@{ub}
        TReplyMsg(msg)
                  TAPTR

    @{b}FUNCTION@{ub}
        reply a two-way message to its sender, i.e. return its entire
        contents back to its sender's replyport.

        it is safe, however, to apply this function to one-way
        messages as well; if the message was sent without a reply
        or acknowledgement expected, it will be silently freed by
        this function.

        use this function for transferring a modified message body
        back to its sender. if the message was not modified and it is
        only required to inform the sender that it has been delivered,
        then you should prefer @{"TAckMsg" Link "TAckMsg"}.

    @{b}INPUTS@{ub}
        msg     - message to be replied to its sender.
                  (or to be freed, transparently)

    @{b}SEE ALSO@{ub}
        @{"TAckMsg" Link "TAckMsg"}, @{"TFreeMsg" Link "TFreeMsg"}, @{"TDropMsg" Link "TDropMsg"}, @{"TPutMsg" Link "TPutMsg"}, @{"TPutReplyMsg" Link "TPutReplyMsg"},
        @{"TFreeMsg" Link "TFreeMsg"}, @{"TTaskAllocMsg" Link "TTaskAllocMsg"}, @{"TSendMsg" Link "TSendMsg"}, @{"TCreatePort" Link "TCreatePort"}


@EndNode
@Node "TDropMsg" "TDropMsg"

    @{b}NAME@{ub}
        TDropMsg - abandon a message.

    @{b}SYNOPSIS@{ub}
        TDropMsg(msg)
                 TAPTR

    @{b}FUNCTION@{ub}
        abandon a two-way message, i.e. return it to its replyport with
        the message status set to TMSG_STATUS_FAILED. this function is
        not guaranteed to return any modifications made inside the
        message body, it will only indicate failure.

        it is safe to apply this function to one-way messages as well;
        if the message was sent without a reply or acknowledgement
        expected, it will be silently freed by this function.

    @{b}INPUTS@{ub}
        msg     - message to be abandoned.

    @{b}NOTES@{ub}
        currently (v0.3), if applied to a remote messageport, this
        function will not only abandon a single message, but the entire
        underlying socket proxy. all messages sent after the one being
        dropped will fail on this network connection, and pending replies
        will fail after their respective timeout.

    @{b}SEE ALSO@{ub}
        @{"TAckMsg" Link "TAckMsg"}, @{"TReplyMsg" Link "TReplyMsg"}, @{"TFreeMsg" Link "TFreeMsg"}, @{"TPutMsg" Link "TPutMsg"}, @{"TPutReplyMsg" Link "TPutReplyMsg"},
        @{"TTaskAllocMsg" Link "TTaskAllocMsg"}, @{"TSendMsg" Link "TSendMsg"}, @{"TCreatePort" Link "TCreatePort"}


@EndNode
@Node "TSendMsg" "TSendMsg"

    @{b}NAME@{ub}
        TSendMsg - send a message, synchronized

    @{b}SYNOPSIS@{ub}
        replymsg = TSendMsg(task, msgport, msg)
        TAPTR               TAPTR TPORT*   TAPTR

    @{b}FUNCTION@{ub}
        this function sends a message two-way, synchronized, and waits
        for either a reply to return, or for the messageport's timeout.
        this is currently the only messaging function that may block.

        the return value will be either set to msg, indicating that the
        message has been sent and acknowledged/replied successfully,
        or TNULL, when the message could not be sent or did not return
        within a remote msgport's timeout.

    @{b}INPUTS@{ub}
        task     - task, must refer to the caller's context.
        msgport  - msgport to address.
        msg      - message to be sent.

    @{b}RETURNS@{ub}
        replymsg - will be set to msg when the message was sent and
                   returned successfully, otherwise TNULL.

    @{b}SEE ALSO@{ub}
        @{"TAckMsg" Link "TAckMsg"}, @{"TReplyMsg" Link "TReplyMsg"}, @{"TDropMsg" Link "TDropMsg"}, @{"TFreeMsg" Link "TFreeMsg"}, @{"TPutMsg" Link "TPutMsg"},
        @{"TPutReplyMsg" Link "TPutReplyMsg"}, @{"TTaskAllocMsg" Link "TTaskAllocMsg"}, @{"TCreatePort" Link "TCreatePort"}, @{"TFindSockPort" Link "TFindSockPort"}


@EndNode
@Node "TGetMsgAttrs" "TGetMsgAttrs"

    @{b}NAME@{ub}
        TGetMsgAttrs - query message attributes.

    @{b}SYNOPSIS@{ub}
        numattr = TGetMsgAttrs(msg,  tags)
        TUINT                  TAPTR TTAGITEM*

    @{b}FUNCTION@{ub}
        this function queries a given set of attributes from a message.
        the attributes will be filled into the taglist's respective
        variable pointers, and the number of attributes successfully
        retrieved will be returned to the caller.

    @{b}INPUTS@{ub}
        msg     - message to be queried.
        tags    - pointer to an array of tagitems.

    @{b}RESULTS@{ub}
        numattr - number of attributes filled into their respective
                  variable pointers.

    @{b}TAGS@{ub}
        TMsg_Size, TUINT *
            the variable being pointed to by the tag value will be filled
            with the size of the message in bytes.

        TMsg_Status, TUINT *
            the variable being pointed to by the tag value will be filled
            with the message status, which can be

                TMSG_STATUS_UNDEFINED - message was never sent.

                TMSG_STATUS_SENT      - the message has been sent
                                        successfully.

                TMSG_STATUS_FAILED    - the message could not be sent or
                                        failed to return within a given
                                        timeout period.

                TMSG_STATUS_REPLIED   - the message has been replied
                                        successfully, and returned to the
                                        sender.

                TMSG_STATUS_ACKD      - the message has been acknowledged
                                        successfully, and returned to the
                                        sender.

        TMsg_Sender, TSTRPTR *
            the variable being pointed to by the tag value will be set to
            a pointer to a string, which will contain a sender
            messageport's unique name. this name is currently (v0.3) being
            composed from the sender's host and port number, such as
            "192.168.0.77:32452". for messages originating from local
            address space, this pointer will be set to TNULL.

            warning: this string pointer is no longer valid after the
            message has been handed over to @{"TReplyMsg" Link "TReplyMsg"}, @{"TAckMsg" Link "TAckMsg"},
            @{"TFreeMsg" Link "TFreeMsg"}, or @{"TDropMsg" Link "TDropMsg"}.

        TMsg_SenderHost, TSTRPTR *
            the variable being pointed to by the tag value will be set to
            a pointer to a string containing the sender's host, e.g.
            "192.168.0.77". for messages originating from local address
            space, this pointer will be set to TNULL.

            warning: this string pointer is no longer valid after the
            message has been handed over to @{"TReplyMsg" Link "TReplyMsg"}, @{"TAckMsg" Link "TAckMsg"},
            @{"TFreeMsg" Link "TFreeMsg"}, or @{"TDropMsg" Link "TDropMsg"}.

        TMsg_SenderPort, TUINT *
            the variable being pointed to by the tag value will be set to
            the sender messageport's internet port number, which may range
            from 0 to 65535. for messages originating from local address
            space, the portnumber will be set to 0xffffffff.

    @{b}NOTES@{ub}
        it would be unwise to assume a specific format for the strings
        returned by TMsg_Sender or TMsg_SenderHost. currently (v0.3), the
        string format returned will reflect the ipv4 addressing scheme.

    @{b}SEE ALSO@{ub}
        @{"TGetMsg" Link "TGetMsg"}, @{"TPutMsg" Link "TPutMsg"}, @{"TPutReplyMsg" Link "TPutReplyMsg"}, @{"TAckMsg" Link "TAckMsg"}, @{"TReplyMsg" Link "TReplyMsg"},
        @{"TDropMsg" Link "TDropMsg"}, @{"TFreeMsg" Link "TFreeMsg"}, @{"TTaskAllocMsg" Link "TTaskAllocMsg"}, @{"TSendMsg" Link "TSendMsg"}, @{"TCreatePort" Link "TCreatePort"}


@EndNode
@Node "TGetMsgStatus" "TGetMsgStatus"

    @{b}NAME@{ub}
        TGetMsgStatus - get message status.

    @{b}SYNOPSIS@{ub}
        status = TGetMsgStatus(msg)
        TUINT                  TAPTR

    @{b}FUNCTION@{ub}
        get a message's delivery status.

    @{b}INPUTS@{ub}
        msg     - message to be queried.

    @{b}RESULTS@{ub}
        status  - message's delivery status, which can be

                  TMSG_STATUS_UNDEFINED - message was never sent.

                  TMSG_STATUS_SENT      - the message has been sent
                                          successfully.

                  TMSG_STATUS_FAILED    - the message could not be sent or
                                          failed to return within a given
                                          timeout period.

                  TMSG_STATUS_REPLIED   - the message has been replied
                                          successfully, and returned to the
                                          sender.

                  TMSG_STATUS_ACKD      - the message has been acknowledged
                                          successfully, and returned to the
                                          sender.

    @{b}NOTES@{ub}
        this function is currently being (v0.3) implemented as a macro.

    @{b}SEE ALSO@{ub}
        @{"TGetMsgAttrs" Link "TGetMsgAttrs"}, @{"TGetMsgSize" Link "TGetMsgSize"}


@EndNode
@Node "TGetMsgSize" "TGetMsgSize"

    @{b}NAME@{ub}
        TGetMsgSize - get message size.

    @{b}SYNOPSIS@{ub}
        size = TGetMsgSize(msg)
        TUINT              TAPTR

    @{b}FUNCTION@{ub}
        get message size.

    @{b}INPUTS@{ub}
        msg     - message to be queried.

    @{b}RESULTS@{ub}
        size    - size of the message in bytes.

    @{b}NOTES@{ub}
        this function is currently being (v0.3) implemented as a macro.

    @{b}SEE ALSO@{ub}
        @{"TGetMsgAttrs" Link "TGetMsgAttrs"}, @{"TGetMsgStatus" Link "TGetMsgStatus"}


@EndNode
@Node "TAddHead" "TAddHead"

    @{b}NAME@{ub}
        TAddHead - add a node at the head of a list.

    @{b}SYNOPSIS@{ub}
        TAddHead(list,  node)
                 TLIST* TNODE*

    @{b}FUNCTION@{ub}
        add a node at the head of a doubly linked list.

    @{b}INPUTS@{ub}
        list - pointer to a list header.
        node - pointer to a node to be inserted.

    @{b}SEE ALSO@{ub}
        @{"TAddTail" Link "TAddTail"}, @{"TInitList" Link "TInitList"}


@EndNode
@Node "TAddTail" "TAddTail"

    @{b}NAME@{ub}
        TAddTail - add a node at the tail of a list.

    @{b}SYNOPSIS@{ub}
        TAddTail(list,  node)
                 TLIST* TNODE*

    @{b}FUNCTION@{ub}
        add a node at the tail of a doubly linked list.

    @{b}INPUTS@{ub}
        list - pointer to a list header.
        node - pointer to a node to be inserted.

    @{b}SEE ALSO@{ub}
        @{"TAddHead" Link "TAddHead"}, @{"TInitList" Link "TInitList"}


@EndNode
@Node "TInsert" "TInsert"

    @{b}NAME@{ub}
        TInsert - insert a node into a list.

    @{b}SYNOPSIS@{ub}
        TInsert(list,  node,  listnode)
                TLIST* TNODE* TNODE *

    @{b}FUNCTION@{ub}
        insert a node into a doubly linked list after the given
        listnode. if listnode == TNULL, this function is equivalent
        to TAddFirst().

    @{b}INPUTS@{ub}
        list - pointer to a list header.
        node - pointer to a node to be inserted.
        listnode - pointer to a node after which to insert.

    @{b}SEE ALSO@{ub}
        @{"TInitList" Link "TInitList"}, @{"TRemove" Link "TRemove"}, @{"TAddHead" Link "TAddHead"}


@EndNode
@Node "TRemove" "TRemove"

    @{b}NAME@{ub}
        TRemove - unlink a node from a list.

    @{b}SYNOPSIS@{ub}
        TRemove(node)
                TNODE*

    @{b}FUNCTION@{ub}
        remove, i.e. unlink a node from whatever list it might
        be linked into.

    @{b}INPUTS@{ub}
        list - pointer to a list header.
        node - pointer to a node to be removed.

    @{b}NOTES@{ub}
        calling this function with a node not being part of a list
        may be fatal.

    @{b}SEE ALSO@{ub}
        @{"TRemHead" Link "TRemHead"}, @{"TRemTail" Link "TRemTail"}, @{"TInitList" Link "TInitList"}


@EndNode
@Node "TRemHead" "TRemHead"

    @{b}NAME@{ub}
        TRemHead - unlink the first node of a list.

    @{b}SYNOPSIS@{ub}
        node = TRemHead(list)
        TNODE*          TLIST*

    @{b}FUNCTION@{ub}
        remove, i.e. unlink and return the first node from
        a doubly linked list.

    @{b}INPUTS@{ub}
        list - pointer to a list header.

    @{b}RESULTS@{ub}
        node - pointer to the node that has been removed, or
               TNULL when the list was empty.

    @{b}SEE ALSO@{ub}
        @{"TRemTail" Link "TRemTail"}, @{"TRemove" Link "TRemove"}, @{"TInitList" Link "TInitList"}


@EndNode
@Node "TRemTail" "TRemTail"

    @{b}NAME@{ub}
        TRemTail - unlink the last node of a list.

    @{b}SYNOPSIS@{ub}
        node = TRemTail(list)
        TNODE*          TLIST*

    @{b}FUNCTION@{ub}
        remove, i.e. unlink and return the last node from
        a doubly linked list.

    @{b}INPUTS@{ub}
        list - pointer to a list header.

    @{b}RESULTS@{ub}
        node - pointer to the node that has been removed, or
               TNULL when the list was empty.

    @{b}SEE ALSO@{ub}
        @{"TRemHead" Link "TRemHead"}, @{"TRemove" Link "TRemove"}, @{"TInitList" Link "TInitList"}


@EndNode
@Node "TSeekNode" "TSeekNode"

    @{b}NAME@{ub}
        TSeekNode - seek node.

    @{b}SYNOPSIS@{ub}
        node = TSeekNode(node,  numsteps)
        TNODE*           TNODE* TINT

    @{b}FUNCTION@{ub}
        starting from node, seek by the given number of steps
        either forwards (steps > 0) or backwards (steps < 0).
        when steps == 0, the current node is returned. when the
        list is seeked past end or before start, TNULL will be
        returned.

    @{b}INPUTS@{ub}
        node  - pointer to a node inside a list.
        steps - number of steps to be seeked.

    @{b}RESULTS@{ub}
        node - pointer to the node reached, or TNULL.

    @{b}SEE ALSO@{ub}
        @{"TInitList" Link "TInitList"}


@EndNode
@Node "TInitList" "TInitList"

    @{b}NAME@{ub}
        TInitList - prepare a list header structure.

    @{b}SYNOPSIS@{ub}
        TInitList(list)
                  TLIST*

    @{b}FUNCTION@{ub}
        prepare a list header structure. the list
        will be empty and ready for usage.

    @{b}INPUTS@{ub}
        list - pointer to an uninitialized list structure.

    @{b}NOTE@{ub}
        this function is currently (v0.3) being implemented as
        a macro.

    @{b}SEE ALSO@{ub}
        @{"TAddHead" Link "TAddHead"}, @{"TAddTail" Link "TAddTail"}, @{"TInsert" Link "TInsert"}, @{"TRemove" Link "TRemove"}, @{"TRemHead" Link "TRemHead"},
        @{"TRemTail" Link "TRemTail"}, @{"TSeekNode" Link "TSeekNode"}, @{"TFirstNode" Link "TFirstNode"}, @{"TLastNode" Link "TLastNode"},
        @{"TListEmpty" Link "TListEmpty"}


@EndNode
@Node "TFirstNode" "TFirstNode"

    @{b}NAME@{ub}
        TFirstNode - get first node of a list.

    @{b}SYNOPSIS@{ub}
        node = TFirstNode(list)
        TNODE*            TLIST*

    @{b}FUNCTION@{ub}
        return the first node in a list, or TNULL when the list
        is empty.

    @{b}INPUTS@{ub}
        list - pointer to a list header.

    @{b}RESULTS@{ub}
        node - pointer to the first node in a list, or TNULL.

    @{b}NOTE@{ub}
        this function is currently (v0.3) being implemented as
        a macro.

    @{b}SEE ALSO@{ub}
        @{"TLastNode" Link "TLastNode"}, @{"TListEmpty" Link "TListEmpty"}, @{"TInitList" Link "TInitList"}


@EndNode
@Node "TLastNode" "TLastNode"

    @{b}NAME@{ub}
        TLastNode - get last node of a list.

    @{b}SYNOPSIS@{ub}
        node = TLastNode(list)
        TNODE*           TLIST*

    @{b}FUNCTION@{ub}
        return the last node in a list, or TNULL when the list
        is empty.

    @{b}INPUTS@{ub}
        list - pointer to a list header.

    @{b}RESULTS@{ub}
        node - pointer to the last node in a list, or TNULL.

    @{b}NOTE@{ub}
        this function is currently (v0.3) being implemented as
        a macro.

    @{b}SEE ALSO@{ub}
        @{"TFirstNode" Link "TFirstNode"}, @{"TListEmpty" Link "TListEmpty"}, @{"TInitList" Link "TInitList"}


@EndNode
@Node "TListEmpty" "TListEmpty"

    @{b}NAME@{ub}
        TListEmpty - test if a list is empty.

    @{b}SYNOPSIS@{ub}
        isempty = TListEmpty(list)
        TBOOL                TLIST*

    @{b}FUNCTION@{ub}
        test if a list is empty.

    @{b}INPUTS@{ub}
        list    - pointer to a list header.

    @{b}RESULTS@{ub}
        isempty - boolean, TTRUE when there are no nodes linked to
                  the list.

    @{b}NOTE@{ub}
        this function is currently (v0.3) being implemented as
        a macro.

    @{b}SEE ALSO@{ub}
        @{"TFirstNode" Link "TFirstNode"}, @{"TInitList" Link "TInitList"}


@EndNode
@Node "TGetTagValue" "TGetTagValue"

    @{b}NAME@{ub}
        TGetTagValue - get tag value from a tag list

    @{b}SYNOPSIS@{ub}
        value = TGetTagValue(tag, defaultvalue, taglist)
        TTAG                 TTAG TTAG          TTAGITEM*

    @{b}FUNCTION@{ub}
        parse a list of tag items and return the matching
        tag value. if the specified tag is not contained in
        the list, return the default value.

    @{b}INPUTS@{ub}
        tag          - tag to be queried.
        defaultvalue - default tag value.
        taglist      - pointer to a list of tag items.

    @{b}RESULTS@{ub}
        value - the value associated with the queried tag, if found
                in the taglist, otherwise the default value.

    @{b}SEE ALSO@{ub}
        @{"TGetTagArray" Link "TGetTagArray"}, @{"TInitTags" Link "TInitTags"}, @{"TAddTag" Link "TAddTag"}


@EndNode
@Node "TGetTagArray" "TGetTagArray"

    @{b}NAME@{ub}
        TGetTagArray - get an array of tag values from a tag list

    @{b}SYNOPSIS@{ub}
        numtags = TGetTagArray(taglist,  tagarray)
        TUINT                  TTAGITEM* TTAG*

    @{b}FUNCTION@{ub}
        this function parses an array of tag items and a taglist, and
        transfers the values of all matching tags from the taglist into
        the variables referenced by pointers in the tag array. both
        the tag array and the taglist must be concluded with TTAG_DONE.
        the number of tags that have been retrieved will be returned to
        the caller.

    @{b}EXAMPLE@{ub}
        TTAG one = 1; two = 2; three = 3;  /* default values */

        num = TGetTagArray(taglist,
                MYTAG_One, (TTAG) &one,
                MYTAG_Two, (TTAG) &two,
                MYTAG_Three, (TTAG) &three,
                TTAG_DONE);

    @{b}INPUTS@{ub}
        taglist  - pointer to a list of tag items.
        tagarray - pointer to an array of pairs of
                   tag and variable pointer each.

    @{b}RESULTS@{ub}
        numtags - number of tags that have been retrieved
                  from the taglist, and inserted to their
                  respective variables.

    @{b}SEE ALSO@{ub}
        @{"TGetTagValue" Link "TGetTagValue"}, @{"TInitTags" Link "TInitTags"}, @{"TAddTag" Link "TAddTag"}


@EndNode
@Node "TInitTags" "TInitTags"

    @{b}NAME@{ub}
        TInitTags - init an array of tagitems.

    @{b}SYNOPSIS@{ub}
        TInitTags(taglist)
                  TTAGITEM*

    @{b}FUNCTION@{ub}
        prepare an array of tagitems to be filled with tag
        attributes, using @{"TAddTag" Link "TAddTag"}.

    @{b}INPUTS@{ub}
        taglist  - pointer to an array of tag items

    @{b}NOTE@{ub}
        this function is currently (v0.3) being implemented as
        a macro.

    @{b}SEE ALSO@{ub}
        @{"TAddTag" Link "TAddTag"}, TGetTagValue, @{"TGetTagArray" Link "TGetTagArray"}


@EndNode
@Node "TAddTag" "TAddTag"

    @{b}NAME@{ub}
        TAddTag - add a tag/value pair to a taglist.

    @{b}SYNOPSIS@{ub}
        TAddTag(taglist,  tag, value)
                TTAGITEM* TTAG TTAG

    @{b}FUNCTION@{ub}
        add a single tag/value pair to a list of tag items.

        your taglist must be dimensioned to contain at least
        one more item than the number of items being added
        with this function.

    @{b}INPUTS@{ub}
        taglist  - pointer to an array of tag items
        tag      - tag identifier
        value    - tag value

    @{b}NOTE@{ub}
        - this function is currently (v0.3) being implemented as
          a macro.

        - this is a convenience macro. it may save a few keystrokes,
          but it is suboptimal. it is quicker to fill a tag list
          manually.

    @{b}SEE ALSO@{ub}
        @{"TInitTags" Link "TInitTags"}, @{"TGetTagValue" Link "TGetTagValue"}, @{"TGetTagArray" Link "TGetTagArray"}


@EndNode
@Node "TGetRandom" "TGetRandom"

    @{b}NAME@{ub}
        TGetRandom - generate signed random number

    @{b}SYNOPSIS@{ub}
        random = TGetRandom(seed)
        TINT                TINT

    @{b}FUNCTION@{ub}
        generate a 32 bit pseudo random number, which will be
        computed from the seed value. the number returned will
        be in the range from -2147483648 to 2147483647.

        typically the returned number will be fed back to
        @{"TGetRandom" Link "TGetRandom"} as the new seed value for the next number
        generation cycle.

    @{b}EXAMPLE@{ub}
        /* generate a random number from 0 to 343 */

        TINT seed, rand_value;
        rand_value = (seed = TGetRandom(seed)) % 344;

    @{b}INPUTS@{ub}
        seed   - a seed value for the number generator.

    @{b}RESULTS@{ub}
        random - a pseudo random number.

    @{b}NOTES@{ub}
        - the numbers generated by this function are not random.
          a number series is always fully determined by its initial
          seed value. the series only appears to be random in an
          arbitrary short range.

        - for useful random numbers the seed variable should be
          initialized with a hardly deterministic number.

    @{b}SEE ALSO@{ub}
        @{"TGetRandomSeed" Link "TGetRandomSeed"}


@EndNode
@Node "TMemCopy" "TMemCopy"

    @{b}NAME@{ub}
        TMemCopy - copy a block of memory.

    @{b}SYNOPSIS@{ub}
        TMemCopy(source, dest, numbytes)
                 TAPTR   TAPTR TUINT

    @{b}FUNCTION@{ub}
        copy a block of memory, i.e. the given number of bytes
        from source to dest.

    @{b}INPUTS@{ub}
        source   - source address
        dest     - destination address
        numbytes - number of bytes to copy

    @{b}NOTES@{ub}
        you may not rely on overlapping copies to work with
        this function.

    @{b}SEE ALSO@{ub}
        @{"TMemCopy32" Link "TMemCopy32"}, @{"TMemFill" Link "TMemFill"}


@EndNode
@Node "TMemFill" "TMemFill"

    @{b}NAME@{ub}
        TMemFill - fill a block of memory.

    @{b}SYNOPSIS@{ub}
        TMemFill(start, numbytes, fillval)
                 TAPTR  TUINT     TUINT

    @{b}FUNCTION@{ub}
        fill a range of memory with a character fill value.

    @{b}INPUTS@{ub}
        start    - start address
        numbytes - number of bytes to fill
        fillval  - character to fill in

    @{b}SEE ALSO@{ub}
        @{"TMemFill32" Link "TMemFill32"}, @{"TMemCopy" Link "TMemCopy"}


@EndNode
@Node "TMemCopy32" "TMemCopy32"

    @{b}NAME@{ub}
        TMemCopy32 - copy a block of memory, aligned

    @{b}SYNOPSIS@{ub}
        TMemCopy32(source, dest, numbytes)
                   TAPTR   TAPTR TUINT

    @{b}FUNCTION@{ub}
        copy a block of memory, i.e. the given number of bytes
        from source to dest. the source and destination address
        must be aligned to 32 bit boundaries in memory, and the
        number of bytes must be 32 bit aligned as well.

    @{b}INPUTS@{ub}
        source   - source address, 32bit aligned
        dest     - destination address, 32bit aligned
        numbytes - number of bytes to copy, 32bit aligned

    @{b}NOTES@{ub}
        you may not rely on overlapping copies to work with
        this function.

    @{b}SEE ALSO@{ub}
        @{"TMemCopy" Link "TMemCopy"}, @{"TMemFill32" Link "TMemFill32"}


@EndNode
@Node "TMemFill32" "TMemFill32"

    @{b}NAME@{ub}
        TMemFill - fill a block of memory, aligned

    @{b}SYNOPSIS@{ub}
        TMemFill32(start, numbytes, fillval)
                   TAPTR  TUINT     TUINT

    @{b}FUNCTION@{ub}
        fill a range of memory with a 32bit fill value. the
        start address and the number of bytes must be aligned
        to 32 bit.

    @{b}INPUTS@{ub}
        start    - start address, 32bit aligned
        numbytes - number of bytes to fill, 32bit aligned
        fillval  - 32bit value to fill in

    @{b}SEE ALSO@{ub}
        @{"TMemFill" Link "TMemFill"}, @{"TMemCopy32" Link "TMemCopy32"}


@EndNode
@Node "TInitMemHead" "TInitMemHead"

    @{b}NAME@{ub}
        TInitMemHead - initialize a memheader.

    @{b}SYNOPSIS@{ub}
        success = TInitMemHead(memhead,  mem,  size, tags)
        TBOOL                  TMEMHEAD* TAPTR TUINT TTAGITEM*

    @{b}FUNCTION@{ub}
        initialize a memheader. a memheader is a memory range
        descriptor that can be used for lowlevel allocation
        from a static block of memory.

    @{b}INPUTS@{ub}
        memhead - pointer to an uninitialized memheader structure
        mem     - pointer to a block of memory to be used as a
                  static memory allocation pool
        size    - size of the memory block [bytes]
        tags    - pointer to an array of tag items

    @{b}TAGS@{ub}
        none defined yet

    @{b}RESULTS@{ub}
        success  - boolean indicating whether initialization
                   was successful. TTRUE if the header is ready.

    @{b}EXAMPLE@{ub}
        /* setup a memheader at the beginning of a memory block */

        TUINT8 memory[100000];

        TInitMemHead((TMEMHEAD *) memory, memory + sizeof(TMEMHEAD),
            sizeof(memory) - sizeof(TMEMHEAD), TNULL);

        /* now ((TMEMHEAD *) memory) may be passed to functions like
           @{"TStaticAlloc" Link "TStaticAlloc"} and @{"TStaticRealloc" Link "TStaticRealloc"}. */

    @{b}SEE ALSO@{ub}
        @{"TStaticAlloc" Link "TStaticAlloc"}, @{"TStaticFree" Link "TStaticFree"}, @{"TStaticRealloc" Link "TStaticRealloc"},
        @{"TStaticGetSize" Link "TStaticGetSize"}


@EndNode
@Node "TStaticAlloc" "TStaticAlloc"

    @{b}NAME@{ub}
        TStaticAlloc - allocate memory from a static block of memory.

    @{b}SYNOPSIS@{ub}
        mem = TStaticAlloc(memhead,  size)
        TAPTR              TMEMHEAD* TUINT

    @{b}FUNCTION@{ub}
        allocate from a block of static memory, which is described by
        a memhead structure. returns a block of memory of the given size,
        or TNULL when the request could not be satisfied.

    @{b}INPUTS@{ub}
        memhead - pointer to an initialized memheader structure
        size    - size of the request [bytes]

    @{b}RESULTS@{ub}
        mem     - memory allocated, or TNULL, when there was no
                  block of memory of the requested size available.

    @{b}NOTES@{ub}
        it is not allowed to pass TNULL or zero for either memhead
        or size. this function is designed for low overhead.

    @{b}SEE ALSO@{ub}
        TInitMemHeadA(), @{"TStaticFree" Link "TStaticFree"}, @{"TStaticRealloc" Link "TStaticRealloc"},
        @{"TStaticGetSize" Link "TStaticGetSize"}


@EndNode
@Node "TStaticRealloc" "TStaticRealloc"

    @{b}NAME@{ub}
        TStaticRealloc - reallocate an allocation from static memory.

    @{b}SYNOPSIS@{ub}
        newmem = TStaticRealloc(memhead,  oldmem, newsize)
        TAPTR                   TMEMHEAD* TAPTR   TUINT

    @{b}FUNCTION@{ub}
        resize a block of memory from a static memory allocation to the
        specified size, and return a pointer to the resized block of
        memory, or TNULL when the memory block could not be resized.

        when a memory block is supplied, and newsize is zero, then
        the memory block will be returned to the static block of
        memory, and the result of this function is TNULL.

        when newsize is nonzero, and the memory block is TNULL, this
        function will try to allocate a new block of the given size.

        if mem is TNULL and size is zero, this function will return
        TNULL.

    @{b}INPUTS@{ub}
        memhead - pointer to an initialized memheader structure
        oldmem  - pointer to a block of memory to be resized
        newsize - new size of the block [bytes]

    @{b}RESULTS@{ub}
        mem     - resized (or freshly allocated) block of memory,
                  or TNULL.

    @{b}NOTES@{ub}
        - it is not allowed to pass TNULL for the memhead argument.

        - reallocation may require that the given block of memory
          needs to be moved in memory, i.e. pointers to this area
          may become invalid.

    @{b}SEE ALSO@{ub}
        TInitMemHeadA(), @{"TStaticAlloc" Link "TStaticAlloc"}, @{"TStaticFree" Link "TStaticFree"},
        @{"TStaticGetSize" Link "TStaticGetSize"}


@EndNode
@Node "TStaticFree" "TStaticFree"

    @{b}NAME@{ub}
        TStaticFree - return memory to a static block of memory.

    @{b}SYNOPSIS@{ub}
        TStaticFree(memhead,  mem)
                    TMEMHEAD* TAPTR

    @{b}FUNCTION@{ub}
        free a block of memory and return it to the static block
        of memory it was allocated from.

    @{b}INPUTS@{ub}
        memhead - pointer to an initialized memheader structure
        mem     - pointer to a block of memory to be freed

    @{b}NOTES@{ub}
        it is not allowed to pass TNULL or zero for either memhead
        or mem. this function is designed for low overhead.

    @{b}SEE ALSO@{ub}
        TInitMemHeadA(), @{"TStaticAlloc" Link "TStaticAlloc"}, @{"TStaticRealloc" Link "TStaticRealloc"},
        @{"TStaticGetSize" Link "TStaticGetSize"}


@EndNode
@Node "TStaticGetSize" "TStaticGetSize"

    @{b}NAME@{ub}
        TStaticGetSize - get size of an allocation from static memory.

    @{b}SYNOPSIS@{ub}
        size = TStaticGetSize(memhead,  mem)
        TUINT                 TMEMHEAD* TAPTR

    @{b}FUNCTION@{ub}
        this function returns the size of an allocation made
        with @{"TStaticAlloc" Link "TStaticAlloc"} or @{"TStaticRealloc" Link "TStaticRealloc"}.

    @{b}INPUTS@{ub}
        memhead - pointer to an initialized memheader structure
        mem     - previously allocated block of memory, or TNULL

    @{b}RESULTS@{ub}
        size    - size of the allocation [bytes].

    @{b}NOTE@{ub}
        it is not allowed to pass TNULL or zero for either memhead
        or mem. this function is designed for low overhead.

    @{b}SEE ALSO@{ub}
        TInitMemHeadA(), @{"TStaticAlloc" Link "TStaticAlloc"}, @{"TStaticRealloc" Link "TStaticRealloc"}


@EndNode
@Node "TCreatePool" "TCreatePool"

    @{b}NAME@{ub}
        TCreatePool - create pooled allocator.

    @{b}SYNOPSIS@{ub}
        pool = TCreatePool(mmu,  chunksize, thressize, tags)
        TAPTR              TAPTR TUINT      TUINT      TTAGITEM*

    @{b}FUNCTION@{ub}
        create and initialize a pooled memory allocator.

        pools can automatically expand and shrink on demand. many
        individual allocations may fit into chunks which are being
        maintained internally by the pooled allocator.

        there is no need to free individual allocations requested
        from a pooled allocator; they will be freed automatically
        when the pool is destroyed with @{"TDestroy" Link "TDestroy"}.

        chunksize is the size of new chunks to be allocated from
        a parent memory manager, when a new allocation cannot be
        satisfied from the current set of chunks.

        thressize is the maximum size of allocations that will be
        allocated from regular chunks. allocations larger than
        thressize will request new chunks of their own.

        pools created with 'dynamic growth' will automatically adapt
        their chunksize, and always allocate new chunks larger than
        required by a single allocation. @{"TPoolRealloc" Link "TPoolRealloc"} will utilize
        this prefetch memory to allow rapidly growing reallocations
        with very few overhead. with dynamic growth enabled, chunksize
        divided by thressize will be used as the pool's prefetch ratio.

    @{b}INPUTS@{ub}
        mmu       - parent memory manager
        chunksize - size of chunks to be allocated from parent
                    memory manager
        thressize - maximum size of allocations that will be
                    requested from chunks of their own
        taglist   - pointer to an array of tag items

    @{b}TAGS@{ub}
        TMem_DynGrow, TBOOL
            when this argument is set to TTRUE, chunksize/threshold
            are interpreted as an initial ratio for dynamic pool
            growth. default: TTRUE

    @{b}RESULTS@{ub}
        pool - an initialized memory pool, or TNULL if something
               went wrong.

    @{b}SEE ALSO@{ub}
        @{"TPoolAlloc" Link "TPoolAlloc"}, @{"TPoolRealloc" Link "TPoolRealloc"}, @{"TPoolFree" Link "TPoolFree"}, @{"TPoolGetSize" Link "TPoolGetSize"},
        @{"TDestroy" Link "TDestroy"}


@EndNode
@Node "TPoolAlloc" "TPoolAlloc"

    @{b}NAME@{ub}
        TPoolAlloc - allocate memory from a pool.

    @{b}SYNOPSIS@{ub}
        mem = TPoolAlloc(pool, size)
        TAPTR            TAPTR TUINT

    @{b}FUNCTION@{ub}
        allocate a block of memory of the given size from a pool.

   @{b}INPUTS@{ub}
        pool - an object created with @{"TCreatePool" Link "TCreatePool"}
        size - size of the allocation [bytes]

    @{b}RESULTS@{ub}
        mem - pointer to a block of memory, or TNULL when the request
              could not be satisfied.

    @{b}SEE ALSO@{ub}
        @{"TCreatePool" Link "TCreatePool"}, @{"TPoolFree" Link "TPoolFree"}, @{"TPoolRealloc" Link "TPoolRealloc"}, @{"TPoolGetSize" Link "TPoolGetSize"}


@EndNode
@Node "TPoolFree" "TPoolFree"

    @{b}NAME@{ub}
        TPoolFree - return memory to a pool.

    @{b}SYNOPSIS@{ub}
        TPoolFree(pool, mem)
        void      TAPTR TAPTR

    @{b}FUNCTION@{ub}
        return a block of memory to a pool.

    @{b}INPUTS@{ub}
        pool - a pooled allocator created with @{"TCreatePool" Link "TCreatePool"}.
        mem  - pointer to a block of memory allocated with
               TPoolAllloc().

    @{b}SEE ALSO@{ub}
        @{"TCreatePool" Link "TCreatePool"}, @{"TPoolAlloc" Link "TPoolAlloc"}, @{"TPoolRealloc" Link "TPoolRealloc"}, @{"TPoolGetSize" Link "TPoolGetSize"}


@EndNode
@Node "TPoolRealloc" "TPoolRealloc"

    @{b}NAME@{ub}
        TPoolRealloc - resize a block of memory in a pool.

    @{b}SYNOPSIS@{ub}
        mem = TPoolRealloc(pool, oldmem, size)
        TAPTR              TAPTR TAPTR   TUINT

    @{b}FUNCTION@{ub}
        resizes a memory block that was allocated from a pool to the
        specified size, and returns a valid pointer to the resized block
        of memory, or TNULL when the memory block could not be resized.

        when a memory block is passed, but the specified size is zero,
        the memory block will be returned to the pool, and the result of
        this function is TNULL.

        when a size is specified, and the memory block is TNULL, this
        function will try to allocate a new block of the given size.

        if mem is TNULL and size is zero, this function will return
        TNULL.

    @{b}INPUTS@{ub}
        pool    - an object created with @{"TCreatePool" Link "TCreatePool"}.
        oldmem  - pointer to a block of memory to be resized.
        size    - new size of the memory block.

    @{b}RESULTS@{ub}
        mem     - resized (or freshly allocated) block of memory,
                  or TNULL.

    @{b}NOTES@{ub}
        reallocation may require that the given block of memory
        needs to be moved in memory, i.e. pointers to this area
        may become invalid.

    @{b}SEE ALSO@{ub}
        @{"TPoolAlloc" Link "TPoolAlloc"}, @{"TPoolFree" Link "TPoolFree"}, @{"TCreatePool" Link "TCreatePool"}, @{"TPoolGetSize" Link "TPoolGetSize"}


@EndNode
@Node "TPoolGetSize" "TPoolGetSize"

    @{b}NAME@{ub}
        TPoolGetSize - get size of an allocation from a pool.

    @{b}SYNOPSIS@{ub}
        size = TPoolGetSize(TAPTR pool, mem)
        TUINT               TAPTR       TAPTR

    @{b}FUNCTION@{ub}
        this function returns the size of an allocation made
        with @{"TPoolAlloc" Link "TPoolAlloc"} or @{"TPoolRealloc" Link "TPoolRealloc"}. if mem is TNULL,
        this function returns 0.

    @{b}INPUTS@{ub}
        mem  - previously allocated block of memory, or TNULL.

    @{b}RESULTS@{ub}
        size - size of the allocation [bytes].

    @{b}SEE ALSO@{ub}
        @{"TPoolAlloc" Link "TPoolAlloc"}, @{"TPoolRealloc" Link "TPoolRealloc"}


@EndNode
@Node "TInitMMU" "TInitMMU"

    @{b}NAME@{ub}
        TInitMMU - initialize a memory management unit.

    @{b}SYNOPSIS@{ub}
        success = TInitMMU(mmu,  allocator, mmutype, tags)
        TBOOL              TMMU* TAPTR      TUINT    TTAGITEM*

    @{b}FUNCTION@{ub}
        initialize a TMMU structure and prepare it for being
        used as a memory management unit.

    @{b}INPUTS@{ub}
        mmu       - pointer to a TMMU structure
        allocator - allocator underlying the MMU to be created
        mmutype   - type of MMU to be created.
            TMMUT_Kernel
                setup a kernel MMU. allocator must be TNULL. the
                newly created MMU will allocate from the kernel.

            TMMUT_Static
                setup a static memory MMU. allocator must point
                to a memheader initialized with @{"TInitMemHead" Link "TInitMemHead"}.

            TMMUT_Pooled
                setup a pooled MMU. allocator must point to a
                pooled allocator created with @{"TCreatePool" Link "TCreatePool"}.

            TMMUT_MMU
                setup a MMU on top of another MMU, implementing
                no additional functionality. allocator must point
                to another MMU.

            TMMUT_Tracking
                setup a tracking MMU on top of another MMU. allocator
                must point to another MMU, or TNULL (which is equivalent
                to a kernel allocator). the resulting MMU will return all
                pending allocations to its parent MMU when it is
                destroyed.

            TMMUT_TaskSafe
                setup a MMU on top of another MMU, implementing safe
                multitasking accesses across tasks, i.e. multiple tasks
                are allowed to operate on the resulting MMU in parallel.
                allocator must point to another MMU, or TNULL (which is
                equivalent to a kernel MMU).

            TMMUT_Message
                setup a special MMU for being used as a message
                allocator. allocator must point to another message MMU,
                or TNULL. aside from special precautions for allocating
                messages, message MMUs also implement multitasking
                safety and tracking capabilities.

            some MMU types may be combined, currently it is possible to
            initialize a MMU implementing TMMUT_TaskSafe|TMMUT_Tracking
            and TMMUT_TaskSafe|TMMUT_Pooled.

        tags      - pointer to an array of tag items

    @{b}TAGS@{ub}
        none defined yet

    @{b}RESULTS@{ub}
        success  - boolean. TFALSE if an invalid combination of a MMU's
                   capabilities was specified.

    @{b}NOTES@{ub}
        a MMU is destroyed with a call to @{"TDestroy" Link "TDestroy"}.

    @{b}SEE ALSO@{ub}
        @{"TDestroy" Link "TDestroy"}, @{"TMMUAlloc" Link "TMMUAlloc"}, @{"TMMUAlloc0" Link "TMMUAlloc0"}, @{"TMMURealloc" Link "TMMURealloc"}, @{"TMMUFree" Link "TMMUFree"},
        @{"TMMUGetSize" Link "TMMUGetSize"}


@EndNode
@Node "TMMUAlloc" "TMMUAlloc"

    @{b}NAME@{ub}
        TMMUAlloc - allocate memory via MMU.

    @{b}SYNOPSIS@{ub}
        mem = TMMUAlloc(mmu,  size)
        TAPtR           TAPTR TUINT

    @{b}FUNCTION@{ub}
        allocate a block of memory via a MMU. returns TNULL when
        the request could not be satisfied.

    @{b}INPUTS@{ub}
        mmu  - pointer to a memory management unit.
        size - size of the allocation [bytes].

    @{b}RESULTS@{ub}
        mem  - pointer to a block of memory, or TNULL.

    @{b}SEE ALSO@{ub}
        @{"TMMUFree" Link "TMMUFree"}, @{"TMMUAlloc0" Link "TMMUAlloc0"}, @{"TMMURealloc" Link "TMMURealloc"}, @{"TMMUGetSize" Link "TMMUGetSize"},
        @{"TInitMMU" Link "TInitMMU"}


@EndNode
@Node "TMMUAlloc0" "TMMUAlloc0"

    @{b}NAME@{ub}
        TMMUAlloc0 - allocate blank memory via MMU.

    @{b}SYNOPSIS@{ub}
        mem = TMMUAlloc0(mmu,  size)
        TAPTR            TAPTR TUINT

    @{b}FUNCTION@{ub}
        allocate a blank block of memory via a MMU, i.e. a block
        of memory that is filled with zero-bytes. returns TNULL
        when the request could not be satisfied.

    @{b}INPUTS@{ub}
        mmu  - pointer to a memory management unit.
        size - size of the allocation [bytes].

    @{b}RESULTS@{ub}
        mem  - pointer to a block of memory, or TNULL.

    @{b}SEE ALSO@{ub}
        @{"TMMUAlloc0" Link "TMMUAlloc0"}, @{"TMMUFree" Link "TMMUFree"}, @{"TMMURealloc" Link "TMMURealloc"}, @{"TMMUGetSize" Link "TMMUGetSize"},
        @{"TInitMMU" Link "TInitMMU"}


@EndNode
@Node "TMMUFree" "TMMUFree"

    @{b}NAME@{ub}
        TMMUFree - free memory via MMU.

    @{b}SYNOPSIS@{ub}
        TMMUFree(mmu,  mem)
                 TAPTR TAPTR

    @{b}FUNCTION@{ub}
        free a block of memory via MMU.

    @{b}INPUTS@{ub}
        mmu  - pointer to a memory management unit.
        mem  - block of memory to be freed.

    @{b}SEE ALSO@{ub}
        @{"TMMUAlloc" Link "TMMUAlloc"}, @{"TMMUAlloc0" Link "TMMUAlloc0"}, @{"TMMURealloc" Link "TMMURealloc"}, @{"TMMUGetSize" Link "TMMUGetSize"},
        @{"TInitMMU" Link "TInitMMU"}


@EndNode
@Node "TMMURealloc" "TMMURealloc"

    @{b}NAME@{ub}
        TMMURealloc - resize a block of memory via MMU.

    @{b}SYNOPSIS@{ub}
        newmem = TMMURealloc(mmu,  oldmem, size)
        TAPTR                TAPTR TAPTR   TUINT32

    @{b}FUNCTION@{ub}
        resizes a memory block that was previously allocated from a MMU
        to the specified size, and returns a valid pointer to the resized
        block of memory, or TNULL when the memory block could not be
        resized.

        when a memory block is passed, and the specified size is zero,
        the memory block will be returned to the pool, and the result of
        this function is TNULL.

        when a size is specified, and the memory block is TNULL, this
        function will try to allocate a new block of the given size.

        if mem is TNULL and size is zero, this function will return
        TNULL.

    @{b}INPUTS@{ub}
        mmu     - pointer to a memory management unit.
        oldmem  - block of memory to be resized.
        size    - new size of the memory block.

    @{b}NOTES@{ub}
        reallocation may require that the given block of memory
        needs to be moved in memory, i.e. pointers to this area
        may become invalid.

    @{b}RESULTS@{ub}
        mem  - pointer to a resized (or freshly allocated) block of
               memory, or TNULL.

    @{b}SEE ALSO@{ub}
        @{"TMMUAlloc" Link "TMMUAlloc"}, @{"TMMUAlloc0" Link "TMMUAlloc0"}, @{"TMMUFree" Link "TMMUFree"}, @{"TMMUGetSize" Link "TMMUGetSize"},
        @{"TInitMMU" Link "TInitMMU"}


@EndNode
@Node "TMMUGetSize" "TMMUGetSize"

    @{b}NAME@{ub}
        TMMUGetSize - get size of an allocation from a MMU.

    @{b}SYNOPSIS@{ub}
        size = TMMUGetSize(mmu,  mem)
        TUINT              TAPTR TAPTR

    @{b}FUNCTION@{ub}
        this function returns the size of an allocation made
        with @{"TMMUAlloc" Link "TMMUAlloc"}, @{"TMMUAlloc0" Link "TMMUAlloc0"}, or @{"TMMURealloc" Link "TMMURealloc"}.

    @{b}INPUTS@{ub}
        mem  - previously allocated block of memory, or TNULL.

    @{b}RESULTS@{ub}
        size - size of the allocation [bytes].

    @{b}SEE ALSO@{ub}
        @{"TMMUAlloc" Link "TMMUAlloc"}, @{"TMMUAlloc0" Link "TMMUAlloc0"}, @{"TMMURealloc" Link "TMMURealloc"}, @{"TMMUFree" Link "TMMUFree"},
        @{"TInitMMU" Link "TInitMMU"}


@EndNode
@Node "TMMUAllocHandle" "TMMUAllocHandle"

    @{b}NAME@{ub}
        TMMUAllocHandle - allocate a handle.

    @{b}SYNOPSIS@{ub}
        mem = TMMUAllocHandle(mmu,  destructor,  size)
        TUINT                 TAPTR TDESTROYFUNC TUINT

    @{b}FUNCTION@{ub}
        allocate a generic handle with destructor. this function
        expects and initializes a heading THNDL structure in the
        allocated block of memory.

        a handle allocated with this function can be destroyed
        with @{"TDestroy" Link "TDestroy"}, which will call the supplied destructor
        before the allocated memory is returned to its MMU.

    @{b}INPUTS@{ub}
        mmu        - memory manager
        destructor - destructor function being invoked with
                     @{"TDestroy" Link "TDestroy"}, or TNULL
        size       - total size of the allocation, including
                     the heading THNDL structure

    @{b}RESULTS@{ub}
        mem        - handle, or TNULL

    @{b}SEE ALSO@{ub}
        @{"TDestroy" Link "TDestroy"}, @{"TMMUAllocHandle0" Link "TMMUAllocHandle0"}, @{"TMMUFreeHandle" Link "TMMUFreeHandle"}, @{"TInitMMU" Link "TInitMMU"}


@EndNode
@Node "TMMUAllocHandle0" "TMMUAllocHandle0"

    @{b}NAME@{ub}
        TMMUAllocHandle0 - allocate a handle with blank memory.

    @{b}SYNOPSIS@{ub}
        mem = TMMUAllocHandle0(mmu,  destructor,  size)
        TUINT                  TAPTR TDESTROYFUNC TUINT

    @{b}FUNCTION@{ub}
        allocate a generic handle with destructor. this function
        expects and initializes a heading THNDL structure in the
        allocated block of memory.

        a handle allocated with this function can be destroyed
        with @{"TDestroy" Link "TDestroy"}, which will call the supplied destructor
        before the allocated memory is returned to its MMU.

        unlike @{"TMMUAllocHandle" Link "TMMUAllocHandle"}, this function will zero out
        the memory followed by the heading THNDL structure.

    @{b}INPUTS@{ub}
        mmu        - memory manager
        destructor - destructor function being invoked with
                     @{"TDestroy" Link "TDestroy"}, or TNULL
        size       - total size of the allocation, including
                     the heading THNDL structure

    @{b}RESULTS@{ub}
        mem        - handle, or TNULL

    @{b}SEE ALSO@{ub}
        @{"TDestroy" Link "TDestroy"}, @{"TMMUAllocHandle" Link "TMMUAllocHandle"}, @{"TMMUFreeHandle" Link "TMMUFreeHandle"}, @{"TInitMMU" Link "TInitMMU"}


@EndNode
@Node "TMMUFreeHandle" "TMMUFreeHandle"

    @{b}NAME@{ub}
        TMMUFreeHandle - free a handle

    @{b}SYNOPSIS@{ub}
        TMMUFreeHandle(handle)
                       TAPTR

    @{b}FUNCTION@{ub}
        free a handle and return its memory to the MMU it was
        allocated from. unlike @{"TDestroy" Link "TDestroy"}, this function will not
        call a handle's destructor.

    @{b}INPUTS@{ub}
        handle     - handle allocated with @{"TMMUAllocHandle" Link "TMMUAllocHandle"} or
                     @{"TMMUAllocHandle0" Link "TMMUAllocHandle0"}

    @{b}SEE ALSO@{ub}
        @{"TMMUAllocHandle" Link "TMMUAllocHandle"}, @{"TDestroy" Link "TDestroy"}, @{"TInitMMU" Link "TInitMMU"}


@EndNode
@Node "TDestroy" "TDestroy"

    @{b}NAME@{ub}
        TDestroy - destroy a generic handle

    @{b}SYNOPSIS@{ub}
        result = TDestroy(handle)
        TINT              TAPTR

    @{b}FUNCTION@{ub}
        call a handle's destroy function.

        the destroy function's object-specific return value will
        be returned to the caller.

        if handle is TNULL, this function returns 0.

    @{b}INPUTS@{ub}
        handle   - generic handle such as allocated with
                   @{"TMMUAllocHandle" Link "TMMUAllocHandle"} or @{"TMMUAllocHandle0" Link "TMMUAllocHandle0"}.
                   it is safe to pass TNULL here.

    @{b}RESULTS@{ub}
        result   - return value, as returned by the handle's
                   destroy function. 0 if handle is TNULL or
                   when a handle's destroy function is TNULL.

    @{b}SEE ALSO@{ub}
        @{"TMMUAllocHandle" Link "TMMUAllocHandle"}, @{"TMMUFreeHandle" Link "TMMUFreeHandle"}, @{"TInitMMU" Link "TInitMMU"}


@EndNode
@Node "TAddSockPort" "TAddSockPort"

    @{b}NAME@{ub}
        TAddSockPort - make msgport available in internet namespace

    @{b}SYNOPSIS@{ub}
        portnr = TAddSockPort(msgport, portnr, tags)
        TUINT                 TPORT*   TUINT   TTAGITEM*

    @{b}FUNCTION@{ub}
        add a messageport to the internet namespace and make it
        available on the given internet port number. if portnr is
        zero, this function will try to allocate a new port number
        and bind the messageport to it. in either case, the internet
        port number will be returned to the caller. a return value
        of zero indicates failure.

    @{b}INPUTS@{ub}
        msgport - messageport to be added to the internet namespace
        portnr  - dedicated internet port number to add the messageport
                  to, or zero for no preference
        tags    - pointer to a list of tag items

    @{b}TAGS@{ub}
        TSock_IdleTimeout, TTIME *
            pointer to a time structure holding a timeout for idle
            internet connections to this messageport. when this timeout
            expires, the respective connection will be dropped without
            further notice, and further communication with that peer
            will be rejected unless the peer reconnects to this
            messageport.
            default: 128 seconds

        TSock_MaxMsgSize, TUINT
            maximum size allowed for a single message incoming via
            network, in bytes. a peer sending larger messages will be
            silently dropped without further notice, and further
            communication with that peer will be rejected unless it
            reconnects to this messageport.
            default: -1 (no limit)

    @{b}RESULTS@{ub}
        portnr  - actual internet port number to which the messageport
                  was added, or zero for failure.

    @{b}SEE ALSO@{ub}
        @{"TFindSockPort" Link "TFindSockPort"}, @{"TRemSockPort" Link "TRemSockPort"}, @{"TCreatePort" Link "TCreatePort"}


@EndNode
@Node "TFindSockPort" "TFindSockPort"

    @{b}NAME@{ub}
        TFindockPort - find a remote message port.

    @{b}SYNOPSIS@{ub}
        msgport = TFindSockPort(task, ipname, portnr, tags)
        TPORT*                  TAPTR TSTRPTR TUINT16 TTAGITEM*

    @{b}FUNCTION@{ub}
        find a remote messageport that has been announced to
        the internet namespace with @{"TAddSockPort" Link "TAddSockPort"}. a proxy
        to the remote messageport will be returned.

    @{b}INPUTS@{ub}
        task    - task, referring to the caller's current context
        ipname  - ip name string
        portnr  - internet port number
        tags    - pointer to a list of tag items

    @{b}TAGS@{ub}
        TSock_ReplyTimeout, TTIME *
            pointer to a time structure holding a timeout for
            replies pending over remote connections. when the
            timeout expires, the message port will fall into a
            'broken' state, and reject further communication with
            the remote peer.
            default: 32 seconds

    @{b}RESULTS@{ub}
        msgport - proxy to the remote msgport, or TNULL on failure.

    @{b}SEE ALSO@{ub}
        @{"TFindSockPort" Link "TFindSockPort"}, @{"TRemSockPort" Link "TRemSockPort"}, @{"TCreatePort" Link "TCreatePort"}


@EndNode
@Node "TRemSockPort" "TRemSockPort"

    @{b}NAME@{ub}
        TRemSockPort - remove a message port from publicity.

    @{b}SYNOPSIS@{ub}
        TRemSockPort(msgport)
                     TPORT*

    @{b}FUNCTION@{ub}
        remove a messageport from the internet namespace.

    @{b}INPUTS@{ub}
        msgport - msgport that has previously been added to the
                  internet namespace with @{"TAddSockPort" Link "TAddSockPort"}.

    @{b}SEE ALSO@{ub}
        @{"TFindSockPort" Link "TFindSockPort"}, @{"TAddSockPort" Link "TAddSockPort"}, @{"TCreatePort" Link "TCreatePort"}


@EndNode
