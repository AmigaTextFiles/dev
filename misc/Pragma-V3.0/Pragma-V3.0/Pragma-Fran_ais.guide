@DATABASE pragma.guide
@AUTHOR CASSE Hugues
@$VER: pragma.guide 3.0 (13.08.96)
@font Courier.font 13
@wordwrap

@NODE main "Sommaire de Pragma V3.0"
@JCENTER
@{u}@{b}Pragma V3.0@{uu}@{ub}
Par Hugues CASSE
@JLEFT

	@{" Présentation " LINK presentation}

	@{" Installation " LINK installation}

	@{" Usage " LINK usage}

	@{" Garantie " LINK garantie}

	@{" Distribution " LINK distribution}

	@{" Historique " LINK historique}

	@{" A faire ... " LINK afaire}

	@{" Documentation " LINK docs}

	@{" Pour me contacter " link contact}

@ENDNODE

@NODE presentation "Présentation ..."

  Ne vous-êtes vous jamais retrouvé dans le cas où vous vouliez utiliser une superbe bibliothèque qui fait exactement ce que vous voulez et dont les auteurs, par malchance, n'ont pas cru utile de fournir des @{"pragmas" link pragma} pour votre compilateur préféré.

  Ou bien, vous possédez effectivement les @{"pragmas" link pragma} pour une bibliothèque donnée mais d'une version trop récente pour contenir la fonction qui vous intéresse. Et bien, @{u}@{b}Pragma@{uu}@{ub} est fait pour tous ceux-là qui désespèrent d'utiliser l'@{FG highlight}Amiga %@{FG text} à @{u}100%@{uu} de ses capacités par l'intermédiaire des fichiers @{"pragma" link pragma}.

  @{u}@{b}Pragma@{uu}@{ub} est une simple @{"commande Shell" link usage} qui va vous permettre de traduire les fichier @{".fd" link fd} en toutes sortes de fichiers utilisables par les compilateurs et les assembleurs.

  Les compilateurs suivants sont actuellement admis:
	- @{"SAS C" link sasc} (et autres vieux Lattice C),
	- @{"Aztec C" link aztecc} (le bon vieux et excellent compilateur),
	- @{"Assembleur" link assembleur}.

  A cela, s'ajoute la possibilité de produire automatiquement des fonctions @{"glues" link glue} pour les bibliothèques pour lesquelles vous possédez uniquement les fichiers @{".fd" link fd} et un support complet pour la gestion des méthodes @{"GLOOPS" link gloops}.
@ENDNODE

@NODE installation "Installation ..."

 - @{u}@{"A partir du Workbench" SYSTEM "Installer Install-Français"}@{uu}:

	Rien de plus simple, double-cliquer sur l'icône @{"Install-Français" SYSTEM "Installer Install-Français"}
	et suivre les indications de l'installeur.


 - @{u}@{"A partir du Shell" SYSTEM newshell}@{uu}:

	@{B}@{FG fill}(1)@{UB}@{FG text} Copier le fichier "pragma" dans C: ou toute autre répertoire faisant
	   partie de votre chemin courant,
			copy pragma C:
		ou
			copy pragma <@{i}votre répertoire@{ui}>

	@{B}@{FG fill}(2)@{UB}@{FG text} Copier le fichier "pragma.guide" dans le répertoire où sont stockées
	    les aides de vos utilitaires.
			copy pragma.guide HELP:
		ou
			copy pragma.guide <@{i}votre répertoire@{ui}>
@ENDNODE

@NODE usage "Usage"

  @{B}@{U}Pragma@{UB}@{UU} est utilisé à partir d'une fenêtre @{"Shell" SYSTEM "NewShell"} en tapant simplement @{B}pragma@{UB} avec les paramètres nécessaires."@{i}pragma ?@{ui}" produit les options suivantes:

      @{B}ASSEMBLER=-A/S, AZTECC=-Z/S, SASC=-C/S, FDFILE=-F, PRAGMA=-P, VERBOSE=-V/S@{UB}
      @{B}STUB=-S/S, MINSTUB=-M/S, SECTION=-X/S, FORMAT=-O/K, GLOOPS=-G/S@{UB}

  Les paramètres sont tous soit sous un style @{FG highlight}Amiga@{FG text}, soit sous un style @{FG highlight}Unix@{FG text} avec un "-" en tête. Ils ont la signification suivante:

	@{B}ASSEMBLER=-A/S@{UB}:
		production de constantes de fonctions de bibliothèques  pour
		@{"assembleur" LINK assembleur},

	@{B}AZTECC=-Z/S@{UB}:
		production de fichier pragma pour le compilateur @{"Aztec C" LINK aztecc},

	@{B}SASC=-C/S@{UB}:
		production de fichier @{"pragma" link pragma} pour les compilateurs @{"SASC" LINK sasc} et @{"Lattice C" link sasC}
		(option par défaut),

	@{B}FDFILE=-F@{UB}:
		fichier @{".fd" LINK fd} à utiliser (option obligatoire),

	@{B}PRAGMA=-P@{UB}: fichier contenant le résultat de la commande (non obligatoire),

	@{B}VERBOSE=-V/S@{UB}:
		passage en mode bavard pour obtenir le détail des opérations.

	@{B}STUB=-S/S@{UB}
		production de fonctions @{"glues" link glue} avec passage des paramètres par la pile.

	@{b}MINSTUB=-M/S@{ub}
		production de fonctions @{"glues" link glue} avec passage des paramètres dans
		les registres.

	@{b}SECTION=-X/S@{ub}
		pour les options @{b}STUB@{ub} et @{b}MINSTUB@{ub}, indique que le code doit être découpé
		en sections.

	@{b}FORMAT=-O/K@{ub}
		pour les options @{b}STUB@{ub} et @{b}MINSTUB@{ub}, provoque le découpage en section dont le
		nom suivra le modèle donné en paramètre. Ce modèle peut contenir tout
		caractère alphanumérique ainsi que des commandes @{i}%<taille><commande>@{ui}:
			@{i}b@{ui}: nom de la base de la bibliothèque,
			@{i}c@{ui}: compteur unique géré par le programme,
			@{i}f@{ui}: nom de la fonction,
			@{i}l@{ui}: valeur positive du @{"LVO" link appels}.

	@{b}GLOOPS=-G/S@{ub}
		commutation en production de code pour les classes @{"GLOOPS" link gloops}, les commandes
		@{"##name" link fd}, @{"##level" link fd}, @{"##get" link fd}, @{"##set" link fd} deviennent disponibles alors que @{"##base" link fd}
		est inutilisable.

  Si le fichier de sortie n'est pas spécifié (option @{B}PRAGMA=-P@{UB}), le nom de ce dernier est construit à partir du nom du fichier d'entrée, de la manière suivante:

	- si la production est destinée à un assembleur (option @{B}ASSEMBLEUR=-A@{UB}),
	  le suffixe "@{i}.fd@{ui}" est remplacé par "@{i}.i@{ui}",

	- si la production doit être des fonctions glues (option @{B}STUB=-S@{UB} ou @{B}MINSTUB=-M@{UB}),
	  le suffixe "@{i}.fd@{ui}" est remplacé par "@{i}.s@{ui}",

	- si la production est destinée à un compilateur C et que le suffixe du fichier est
	  "@{i}_lib.fd@{ui}", ce dernier est alors remplacé par "@{i}_pragmas.h@{ui}",

	- sinon, le suffixe "@{i}.fd@{ui}" est remplacé simplement par "@{i}.h@{ui}".

@ENDNODE

@NODE garantie "Garanties"

  Ce programme a été conçu, programmé et testé avec toutes les marques d'attention dont je suis capable. Toutefois, @{i}errare humanum est@{ui}, il est possible qu'il reste caché si et là des coléoptères désagréables pouvant entrainer des conséquences imprévisibles.

		@{FG fill}@{B}@{U}Donc, l'utilisation de ce programme est laissé
			à votre propre responsabilité.@{FG text}@{UB}@{UU}

  Vous utilisez ce programme à vos risques et périls et, par de-là, je ne puis être tenu responsables des dégradations directes ou indirectes, logicielles ou matérielles, induites par le fonctionnement de ce programme.

@ENDNODE

@NODE distribution "Distribution"

  Ce programme est librement distribuable tant qu'aucune modification n'est apportée au programme ou au paquetage. Il doit @{b}TOUJOURS@{ub} être distribué avec son paquetage, c'est à dire:

	- le programme exécutable,

	- la documentation.

  Si la condition précédente est remplie, il est peut être déposé dans n'importe quelle collection de programmes du @{u}domaine public@{uu} (serveurs, CD-ROM, ...).

  De fait, il peut être inclue dans n'importe quel programme @{i}freeware.@{ui} Son utilisation dans un paquetage @{u}commercial@{uu} ou dans un programme @{u}@{i}shareware@{uu}@{ui} doit d'abord recevoir l'assentiment de son auteur.

  Toutefois, @{b}Pragma@{ub} est un programme @{u}@{i}giftware@{uu}@{ui}. S'il vous paraît intéressant, si vous l'utilisez ou si vous appréciez le travail qui a été fait, vous pouvez me le faire savoir ou me faire un cadeau quelconque:

	- un message @{i}email@{ui},

	- une aide financière,

	- carte postale,

	- cacahuètes (grillés),

	- infos sur @{fg fill}@{b}X-files@{fg text}@{ub}, etc.

  Et n'hésitez à me faire parvenir vos critiques, vos idées d'améliorations, vos questions.

@ENDNODE

@NODE historique "Historique"

  Ce programme est en fait beaucoup plus vieux que son numéro de version le laisse supposer.

  @{b}Pragma V1.0@{ub} est en fait une version personnelle, elle date de 1991. Mon problème était alors d'obtenir les fichiers pragmas pour mon assembleur et mon compilateur C pour le @{b}KickStart 3.0@{ub}. En effet, je ne possédait ceux du vieux système 2.0. J'avais toutefois aux fichiers @{".fd" link fd} du nouveau système, il ne restait plus qu'à les transformer suivant mes besoins: le résultat remplit son objectif mais fut loin d'être ergonomique.

  Aôut 1992, après de nombreux déboires d'utilisation, il me paraît nécessaire d'améliorer l'interface pour éviter des massacres inutiles de fichiers et corriger un énorme bug. Ce sera la version @{b}1.1@{ub}. La version @{b}Pragma V2.0@{ub} sera une refonte de la version 1.1 avec une interface repensée et plus intuitive et beaucoup plus de types de fichiers générés. Elle date d'octobre 1994 mais ne sera publié que pendant l'été 1996 sous une version @{b}2.1@{ub} avec l'option @{u}VERBOSE@{uu} ajoutée.

  Août 1996, votre serviteur travaille sur un projet d'objets dynamiques optimisés, @{b}GLOOPS@{ub}. Pour simplifier l'utilisation de la bibliothèque obtenue, il est fait grand cas de fonctions glues, et pour les bibliothèques standards, et pour les classes @{b}GLOOPS@{ub}. La prise en compte de ces deux éléments donne enfin @{b}Pragma V3.0@{ub} .

@ENDNODE

@NODE afaire "A Faire ..."

  @{b}Pragma@{ub} peut encore être grandement amélioré et son champs d'investigation peut être encore élargi:

	- permettre la traduction simultané de plusieurs fichiers en une seule
	  commande.

	- étendre les fichiers produits à d'autres compilateurs
	  (HighSpeedPascal, E, Obéron, ...). Je ne maîtrise pas tous
	  ces langages mais je suis preneur de toute information à leur sujet.


  Mes projets de programmation actuels tournent autour d'une bibliothèque d'implémentation et de gestion d'objets dynamiques. Un peu dans le style des classes @{b}BOOPSI@{ub}, mes objets devraient éviter la lourdeur d'appel de méthode et d'accès aux attributs à travers un système inspiré des tables de vecteur des bibliothèques @{fg highlight}Amiga@{fg text}.

  La première version devrait sortir en octobre avec, pour exemple, un économiseur d'écran modulaire compatible avec ceux existants. Cette bibliothèque pourra même fonctionner sur le vieux @{i}KickStart@{ui} 1.3 .

@ENDNODE

@NODE docs "Documentation"

  @{b}Pragma V3.0@{ub} trouve son uniquement son intérêt dans le cadre du système @{fg highlight}Amiga@{fg text} et des techniques mises en oeuvre pour gérer les @{u}bibliothèques@{uu}. Pour mieux comprendre l'utilité de ce programme, les trois points suivants sont à explorer:

	- les @{"appels aux bibliothèques" link appels},

	- les @{"fichiers .fd" link fd},

	- les @{"pragmas" link pragma},

	- les fonctions @{"glues" link glue}.

  Ces trois éléments, plus ou moins directement, vont permettre à une application d'exploiter toute la puissance des bibliothèques @{fg highlight}Amiga@{fg text}.

@ENDNODE

@NODE appels "Les appels de bibliothèques"

  Les @{u}bibliothèques@{uu} sont des collections de fonctions groupées autour d'un thème commun. Par exemple, @{b}Exec@{ub}, @{b}Graphics@{ub}, @{b}Intuition@{ub} font partie des @{u}bibliothèques@{uu} les plus connues de l'@{fg highlight}Amiga@{fg text}.
  Toutefois, il n'est pas question de les appeler directement à une adresse fixe dans la @{i}ROM@{ui}. Pour assurer la comptabilité et l'évolutivité, le @{i}KickStart@{ui} utilise la structure décrite ci-dessous:

		+-------------+
		|  Structure  |
		|   Library   |
	base--> +-------------+_
	     -6 | Open        | \
		+-------------+ |
	    -12 | Close       | |
		+-------------+ | LVO f
		     ...
		+-------------+ |
	   -n*6 | <fonction f>| |
		+-------------+_/
		     ...

  L'ouverture d'une bibliothèque renvoit sa @{u}base@{uu}. Dans les adresses supérieures de la @{u}base@{uu} se trouve la structure @{i}Library@{ui} et des données internes à la bibliothèque.
  Dans les adresses inférieures se trouvent les @{u}vecteurs d'appels des fonctions@{uu}. Ces vecteurs, d'une taille de 6 octets, sont des instructions @{fg fill}MC68000@{fg text} de la forme:

		@{b}JMP@{ub} <adresse_fonction>

  Pour appeler une fonction du système, il suffit d'obtenir la base de la bibliothèque et de connaître la position de la fonction dans la @{u}table des vecteurs@{uu}: ce déplacement négatif est appelé @{i}Library Vector Offset@{ui} (@{b}LVO@{ub}).
  L'appel de la fonction f prend alors la forme suivante:

		@{b}move.l@{ub}  base_bibliotheque,@{b}a6@{ub}
		@{b}jsr@{ub}     LVOf(@{b}a6@{ub})


  Il se pose alors rapidement un problème: comment déterminer simplement la valeur des @{b}LVOs@{ub} dans des bibliothèques pouvant compter plus d'une centaine de fonctions.
  La réponse se trouve dans les fichiers @{".fd" link fd} qui permettent de décrire simplement les fonctions constituant une bibliothèque et qui peuvent être traités d'une manière @{u}automatique@{uu} pour permettre à tout compilateur d'accéder aux fonctions du système.

@ENDNODE

@NODE fd "Fichiers .fd"

  Les fichiers @{b}.fd@{ub} contiennent la liste et l'organisation des fonctions d'une bibliothèque. @{b}fd@{ub} est l'acronyme de @{i}File Description@{ui}.
  Ainsi, chaque @{u}bibliothèque@{uu} a un fichier @{b}.fd@{ub} associé dont le nom a la forme suivante:

		<@{i}nom_de_la_bibliothèque@{ui}>_lib.fd

@{fg fill}(1)@{fg text} @{b}La déclaration des fonctions@{ub}

  Ces fichiers possèdent une syntaxe particulière permettant de décrire le @{"LVO" link appels} et les paramètres qui doivent être fournis à la fonction.
  Chaque ligne, décrivant une fonction, a la forme suivante:

	<@{i}nom_fonction@{ui}>@{u}(@{uu}<@{i}paramètres_explicites@{ui}>@{u})(@{uu}<@{i}paramètres_registres@{ui}>@{u})@{uu}

  Le @{"LVO" link appels} est calculé pour chaque fonction en ajoutant 6 (taille du vecteur dans la table de la @{u}bibliothèque@{uu}) à celui de la fonction précédente. Ainsi, dans la définition suivante, si le @{"LVO" link appels} de @{b}Allocate@{ub} est 186, celui de @{b}AllocMem@{ub} est 198. Les @{"LVO" link appels} sont toujours calculés positivement mais sont soustraits au moment de leur utilisation (ce sont des déplacements négatifs).

	@{fg fill}@{u}Exemple@{uu}@{fg text}:
		@{b}Allocate@{ub}(freeList,byteSize)(a0,d0)
		@{b}Deallocate@{ub}(freeList,memoryBlock,byteSize)(a0/a1,d0)
		@{b}AllocMem@{ub}(byteSize,requirements)(d0/d1)

  Les @{u}paramètres explicites@{uu} sont une liste d'identificateurs séparés par des "@{u},@{uu}". Ils ont plus un rôle informatif qu'une véritable utilité fonctionelle.

  Les @{u}paramètres registres@{uu} sont une liste de registre @{fg highlight}MC68000@{fg text} séparés par des "@{u},@{uu}" ou des "@{u}/@{uu}". Cette liste est parallèle à celle des @{u}paramètres explicites@{uu} et indique quel registre est associé à chaque paramètre de la fonction.
  Les @{u}paramètres registres@{uu} permettent d'extraire de la pile d'appels la valeur à stocker dans les registres pour un appeler la fonction. Les petits bouts de programme qui font cela sont appelés des fonctions @{u}glue@{uu}. Ainsi, les "@{u}/@{uu}" sont placés pour séparer des suites de registres chargeables avec une seule instruction @{b}MOVEM@{ub} du @{fg highlight}MC68000@{fg text}. Les "@{u},@{uu}" ont seulement pour but de séparer ces suites.

	@{fg fill}@{u}Exemple@{fg text}@{uu}:
		@{b}Deallocate@{ub}(freeList,memoryBlock,byteSize)(a0/a1,d0)
		génèrera
			@{b}MOVEM.L@{ub} 4(SP),A0/A1
			@{b}MOVE.L@{ub}  12(SP),D0

		@{b}Deallocate@{ub}(freeList,memoryBlock,byteSize)(a0,a1,d0)
		génèrera
			@{b}MOVE.L@{ub}  4(SP),A0
			@{b}MOVE.L@{ub}  8(SP),A1
			@{b}MOVE.L@{ub}  12(SP),D0


@{fg fill}(2)@{fg text} @{b}Autres commandes@{ub}

  D'autres commandes peuvent être utilisées pour conrôler l'interprétation des lignes de déclaration des fonctions d'une @{u}bibliothèque@{uu}. Elles doivent commencer en @{u}début en ligne@{uu} et @{u}une seule@{uu} est autorisée par ligne.

  Voici la liste des ces commandes:

@{b}*@{ub} <@{i}commentaire@{ui}>
	Les commentaires sont introduits par une "@{u}*@{uu}" en début de ligne. Ils se
	terminent en fin de ligne.

@{b}##base@{ub} <@{i}nom_base@{ui}>
	Permet de spécifier le nom standard de la base de la bibliothèque à utiliser pour
	appeler les fonctions décrites dans le fichier. Le nom de la base est sous sa forme
	brute, c'est à dire avec un "_" en début. Par exemple, @{b}_IntuitionBase@{ub} est le
	nom de la base de la bibliothèque @{fg highlight}Intuition@{fg text}.

@{b}##bias@{ub} <@{i}valeur@{ui}>
	Permet de fixer à la valeur (décimale) donnée en paramètre les @{"LVOs" link appels} des
	fonctions suivantes. Cette commande se trouve le plus souvent en début de fichier
	avec une valeur 30 pour éviter de prendre en compte les quatre fonctions de base
	d'une bibliothèque (@{b}Open@{ub}, @{b}Close@{ub}, @{b}Expunge@{ub} et @{b}Null@{ub}).

@{b}##private@{ub}
	Les fonctions suivantes seront prise en compte pour le calcul du @{"LVO" link appels}
	mais ne produiront rien lorsqu'elles seront traitées. Cette commande permet
	d'ignorer un certain nombre de fonctions privées.

@{b}##public@{ub}
	Commande inverse de @{b}##private@{ub}, c'est le mode par défaut.

@{b}##end@{ub}
	Indique la fin du fichier @{".fd" link appels}.

@{b}##same@{ub}
	Cette commande a été ajouté par @{b}Pragma V2.1@{ub} et n'est donc pas standard. La fonction
	qui suit aura le même @{"LVO" link appels} que la fonction précédente. Il est ainsi possible
	d'affecter des déclarations différentes à une même fonction de la bibliothèque.

@{fg fill}(3)@{fg text} @{b}Commandes mode GLOOPS@{ub}

  Ces commandes ne sont pas standards. Elles sont été ajoutées pour permettre le traitement des fichiers de déclaration de méthodes @{"GLOOPS" link gloops} qui utilisent une syntaxe très proche de celle des fichiers @{".FD" link fd} de l'Amiga.
  Ces commandes sont uniquement valides lorsque l'option @{b}GLOOPS=-G@{ub} est sélectionnée.

@{b}##name@{ub} <@{i}nom_class@{ui}>
	Définit le nom de la classe (remplace le nom de la base dans la génération
	automatique de nom de section, %b).

@{b}##level@{ub} <@{i}niveau@{ui}>
	Définit la valeur du niveau de la classe. Cette valeur doit être positive et paire.
	La classe racine a pour niveau 2.

@{b}##set@{ub} <@{i}nom_méthode@{ui}>
	Définit une méthode qui renvoie la valeur d'un attribut.

@{b}##get@{ub} <@{i}nom_méthode@{ui}>
	Définit une méthode qui modifie la valeur d'un attribut.

@ENDNODE

@NODE pragma "Les fichiers pragma"

  @{b}Pragma@{ub} est une instruction du @{u}préprocesseur C@{uu} qui permet de prendre en compte
des caractéristiques liés au matériel utilisé. Dans le monde @{fg highlight}Amiga@{fg text},
l'instruction @{b}pragma@{ub} permet de définir avec précision le protocole d'appel
d'une fonction de bibliothèque de manière à ce que le compilateur puisse
produire le code correspondant à l'appel de la fonction (chargement des
registres, appel de routine calculée grâce à la base et au @{"LVO" link appels}).

  D'où l'extension directe vers les fichiers de déclaration dédiés à la
définition des fonctions d'une bibliothèque.
  Ces fichiers sont contenus dans le répertoire @{u}pragmas@{uu} et leur nom est
construit de la manière suivante:

	<@{i}nom_de_la_bibliothèque@{ui}>@{u}_pragmas.h@{uu}


  Toutefois, la syntaxe de l'instruction @{b}pragma@{ub}, change d'un compilateur à
l'autre d'où l'intérêt de créer des fichiers @{".fd" link fd} qui donnent, avec une @{"syntaxe" link fd}
normalisée, une description des fonctions de la bibliothèque indépendantes de
tout compilateur et autre assembleur.

  @{b}Pragma V2.1@{ub} couvre actuellement trois familles de traducteurs:

	- les @{"assembleurs MC680x0" link assembleur},

	- les compileurs @{"SASC" link sasc} et @{"Lattice C" link sasc},

	- le compilateur @{"Aztec C" link aztecc}.


@ENDNODE

@NODE assembleur "Production pour assembleur MC680x0"

  Le nom des fichiers produits pour @{u}assembleur@{uu} @{fg highlight}MC680x0@{fg text} est construit sur le modèle suivant:

			<@{i}nom_bibliothèque@{ui}>_lib.i

  Les lignes de fonctions sont traduites en affectations d'identificateurs de @{"LVOs" link appels} de la forme suivante:

			_LVO<@{i}nom_fonction@{ui}>      @{b}equ@{ub}     <@{i}valeur@{ui}>

	@{fg fill}@{u}Exemple@{fg text}@{uu}:
		@{b}Allocate@{ub}(freeList,byteSize)(a0,d0)
		@{b}Deallocate@{ub}(freeList,memoryBlock,byteSize)(a0/a1,d0)
		@{b}AllocMem@{ub}(byteSize,requirements)(d0/d1)

	donnera

		_LVOAllocate    @{b}equ@{ub}     186
		_LVODeallocate  @{b}equ@{ub}     192
		_LVOAllocMem    @{b}equ@{ub}     198

@ENDNODE

@NODE sasc "Production pour compilateur SASC"

  La déclaration des fonctions de bibliothèque des fichiers @{"pragma" link pragma} dans le cas du compilateur @{b}SASC@{ub} ou @{b}Lattice C@{ub} a la forme suivante:

	@{b}#pragma libcall@{ub} <@{i}nom_base@{ui}> <@{i}nom_fonction@{ui}> <@{"LVO" link appels}> <@{i}liste_paramètres@{ui}>

  L'identificateur du nom de la base est sous la forme normale en C, c'est à dire sans "_".

  Le @{"LVO" link appels} est exprimé en hexadécimal.

  La liste des paramètres est la concaténation de l'expression hexadécimale du numéro des registres dans l'ordre inverse. Cette liste est terminée par l'expression hexadécimale du nombre de paramètres sur deux digits. Dans le cas où il n'y aucun paramètre, un "0" unique suffit.
  Les registres sont codés de 0 à 07 pour @{b}d0@{ub} à @{b}d7@{ub} et 08 à 0f pour @{b}a0@{ub} à @{b}a7@{ub}.

	@{fg fill}@{u}Exemple:@{uu}@{fg text}

		@{b}Deallocate@{ub}(freeList,memoryBlock,byteSize)(a0/a1,d0)
	devient
		@{b}#pragma libcall@{ub} ExecBase @{b}Deallocate@{ub} C0 09803

@ENDNODE

@NODE aztecc "Production pour compilateur Aztec C"

  La déclaration d'une fonction de bibliothèque dans un fichier @{"pragma" link pragma} pour un compilateur @{b}Aztec C@{ub} a la forme suivante:

	@{b}#pragma amicall@{ub}(<@{i}nom_base@{ui}>,<@{i}LVO@{ui}>,<@{i}nom_fonction@{ui}>(<@{i}liste_paramètres@{ui}>))

  Le nom de la base est exprimée sous forme brute, c'est à dire avec "_" en début.

  Le @{"LVO" link appels} est exprimé sous une expression hexadécimale C, c'est à dire avec un "0x" en tête.

  La paramètres sont une liste de registres séparés par des ",". Les registres sont exprimés sous leur forme littérale, c'est à dire @{b}d0@{ub} à @{b}d7@{ub} et @{b}a0@{ub} à @{b}a7@{ub}.

@ENDNODE

@NODE glue "Les fonctions glues"
  A l'origine, il n'était pas possible à un compilateur de passer directement les paramètres dans des registres et d'appeler une fonction d'une bibliothèque. Cette tâche était effectuée par un morceau de code écrit en @{u}assembleur@{uu} qui allait chercher les paramètres dans la pile et procédait à l'appel de la fonction de la bibliothèque.
  Ces morceaux de code sont appelés @{b}fonction glue@{ub}. A chaque fonction de bibliothèque correspond une @{b}fonction glue@{ub}. Les @{b}fonctions glues@{ub} des bibliothèques du système sont contenues dans la bibliothèque @{u}liable@{uu} @{b}amiga.lib@{ub} .

  @{b}Pragma V3.0@{ub} permet de générer automatiquement les @{b}fonctions glues@{ub} à partir d'un fichier @{".FD" link fd}. Ces fonctions suivent le schéma suivant:

	@{fg fill}(1)@{fg text} Sauvegarde des registres utilisés
	@{fg fill}(2)@{fg text} Chargement des paramètres de la pile
	@{fg fill}(3)@{fg text} Appel de la fonction de la bibliothèque
	@{fg fill}(4)@{fg text} Restauration des registres sauvegardés

  Le fichier produit est un programme en assembleur @{fg highlight}MC68x00@{fg text} qui peut être compilé par tout type d'assembleur avant d'être utilisé.

  Par exemple,
	@{b}DrawEllipse@{ub}(rp,xCenter,yCenter,a,b)(a1,d0/d1/d2/d3)
  donne la fonction glue suivante:
	@{b}_DrawEllipse@{ub}:
		movem.l d2/d3,-(sp)     ; sauvegarde d2 / d3
		move.l  $C(sp),a1       ; chargement rp
		movem.l $10(sp),d0-d3   ; chargement xCenter, yCenter, a, b
		move.l  _GfxBase,a6     ; chargement de la base de la bibliothèque
		jsr     -$b4(a6)        ; appel de la fontion
		movem.l (sp)+,d2/d3     ; restauration d2/d3
		rts                     ; retour de la fonction glue

  @{b}Pragma V3.0@{ub} propose deux types de fonctions glues:
	- option @{b}STUB=-S@{ub}: les paramètres sont transférés de la pile dans les registres,
	- option @{b}MINSTUB=-M@{ub}: les paramètres doivent être déjâ présents dans les registres
	  (cette option n'est réellement intéressante qu'en conjonction avec l'option
	  @{b}GLOOPS=-G@{ub} pour les classes @{"GLOOPS" link gloops}).

@ENDNODE

@NODE gloops "Le mode GLOOPS"

  @{b}GLOOPS@{ub} est une bibliothèque, développée par votre serviteur, qui permet de gérer les objets dynamiques très proche des objets @{b}BOOPSI@{ub} d'@{fg highlight}Intuition@{fg text} mais avec des mécanismes d'appel de @{u}méthode@{uu} et d'accès aux @{u}attributs@{uu} beaucoup plus rapides.

  L'organisation d'une classe @{b}GLOOPS@{ub} a pris pour modèle celle des bibliothèques de l'@{fg highlight}Amiga@{fg text}. L'utilisation de fichier au format @{".FD" link fd}, avec quelques modifications, devient alors toute indiquée. @{b}Pragma V3.0@{ub} propose donc tous les outils nécessaires pour manipuler de tels fichiers grâce à l'option @{b}GLOOPS=-G@{ub}.

  La production pour l'assembleur (option @{b}ASSEMBLER=-A@{ub}), pour les compilateurs SASC et Lattice C (option @{b}SASC=-C@{ub}) et le compilateur Aztec C (option @{b}AZTECC=-Z@{ub}) sont alors une suite de constantes associées à chacune des méthodes du fichier @{".FD" link fd}.
  Ces constantes ont la forme suivante:
		@{b}METHOD_@{ub}<@{i}nom_de_la_méthode@{ui}>
  La valeur associée peut être passée en paramètres aux primitives d'appels de méthode de la bibliothèque @{b}GLOOPS@{ub}.

  Les options @{b}STUB=-S@{ub} et @{b}MINSTUB=-M@{ub} fournissent les fonctions @{"glues" link glue} nécessaires à l'appel direct des méthodes et à l'appel contraint associé.

@ENDNODE

@NODE contact "Pour me contacter ..."

  Il est possible de me contecter ...

	- soit par e-mail
				@{fg fill}@{u}@{b}casse@irit.fr@{fg text}@{uu}@{ub}

	- soit par adresse postale

				@{b}CASSE Hugues@{ub}
				Arignac
				09400 Tarascon FRANCE

  Je suis actuellement étudiant en Doctorat d'Informatique Fondamentale à l'Université de Toulouse Rangueil FRANCE. Pour toute question, tout conseil ou toute collaboration, n'hésitez pas à me contacter.

@ENDNODE
