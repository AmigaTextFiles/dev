@DATABASE pragma.guide
@AUTHOR CASSE Hugues
@$VER: pragma.guide 3.0 (13.08.96)
@font Courier.font 13
@wordwrap

@NODE main "Pragma V3.0 Summary"
@JCENTER
@{u}@{b}Pragma V3.0@{uu}@{ub}
By Hugues CASSE
@JLEFT

	@{" Presentation " LINK presentation}

	@{" Installation " LINK installation}

	@{" Usage " LINK usage}

	@{" Warranty " LINK garantie}

	@{" Distribution " LINK distribution}

	@{" History " LINK historique}

	@{" To do ... " LINK afaire}

	@{" Documentation " LINK docs}

	@{" To get in touch with me " link contact}

@ENDNODE

@NODE presentation "Presentation ..."

  Have you never had the case where you want to use a fine library which match exactly what you like and whose writers, unluckily, didn't think usable to provide @{"pragmas" link pragma} files for your favourite compiler.

  Either, you own actually @{"pragmas" link pragma} files for some library but from a version too late for containing function of insterest. So, @{u}@{b}Pragma@{uu}@{ub} is made for all which despair to use @{FG highlight}Amiga@{FG text} at @{u}100%@{uu} of its capacity by way of @{"pragma" link pragma} files.

  @{u}@{b}Pragma@{uu}@{ub} is simple @{"Shell command" link usage} which allows translation of @{".fd" link fd} files in several files usable by compilers and assemblers.

  Pragma admits following compilers:
	- @{"SAS C" link sasc} (and old Lattice C),
	- @{"Aztec C" link aztecc} (this excellent and old compiler),
	- @{"Assembler" link assembleur}.

  Now, @{b}Pragma V3.0@{ub} can automatically produce @{"stub" link glue} produce for libraries for which you owns only @{".fd" link fd} files and  provide complete management for @{"GLOOPS" link gloops} methods definition files.
@ENDNODE

@NODE installation "Installation ..."

 - @{u}@{"From Workbench" SYSTEM "Installer Install-English"}@{uu}:

	Nothing is more simple, double-click on icon @{"Install-English" SYSTEM "Installer Install-Français"} and follow indications
	from installer.


 - @{u}@{"From Shell" SYSTEM newshell}@{uu}:

	@{B}@{FG fill}(1)@{UB}@{FG text} Copy file "pragma" to C: or any directory contained in your current path,
			copy pragma C:
		or
			copy pragma <@{i}your directory@{ui}>

	@{B}@{FG fill}(2)@{UB}@{FG text} Copy file "pragma.guide" in your directory where are stored help for yours
	    utilities.
			copy pragma.guide HELP:
		or
			copy pragma.guide <@{i}your directory@{ui}>
@ENDNODE

@NODE usage "Usage"

  @{B}@{U}Pragma@{UB}@{UU} is used from @{"Shell" SYSTEM "NewShell"} window: type simply @{B}pragma@{UB} with needed parameters."@{i}pragma ?@{ui}" displays following options:

      @{B}ASSEMBLER=-A/S, AZTECC=-Z/S, SASC=-C, FDFILE=-F, PRAGMA=-P/K, VERBOSE=-V/S@{UB}
      @{B}STUB=-S/S, MINSTUB=-M/S, SECTION=-X/S, FORMAT=-O/K, GLOOPS=-G/S@{UB}

  Parameters are available either with an @{FG highlight}Amiga@{FG text} style, or with a @{FG highlight}Unix@{FG text}-like style, with a leading "-". Their meaning is listed below:

	@{B}ASSEMBLER=-A/S@{UB}:
		production of library functions constants @{"assembleur" LINK assembler},

	@{B}AZTECC=-Z/S@{UB}:
		production of pragma file for @{"Aztec C" LINK aztecc} compiler,

	@{B}SASC=-C/S@{UB}:
		production of @{"pragma" link pragma} file for @{"SASC" LINK sasc} and @{"Lattice C" link sasC} compilers
		(default option),

	@{B}FDFILE/A@{UB}:
		@{".fd" LINK fd} file to use (requisite option),

	@{B}PRAGMA=-P/K@{UB}:
		file containing result of command (not requisite),

	@{B}VERBOSE=-V/S@{UB}:
		chatty mode activated for more details on operations.

	@{B}STUB=-S/S@{UB}
		production of @{"stub" link glue} function by passing parameters in stack.

	@{b}MINSTUB=-M/S@{ub}
		production of @{"stub" link glue} function by passing parameters in registers.

	@{b}SECTION=-X/S@{ub}
		for @{b}STUB@{ub} and @{b}MINSTUB@{ub} options, produced code must be cut
		in sections.

	@{b}FORMAT=-O/K@{ub}
		for @{b}STUB@{ub} and @{b}MINSTUB@{ub} sections, cause cuttinhg in section
		whose name matches given pattern. This pattern may contain any alphanumeric
		character and following commands @{i}%<size><command>@{ui}:
			@{i}b@{ui}: library base name,
			@{i}c@{ui}: single counter managed by program,
			@{i}f@{ui}: function name,
			@{i}l@{ui}: positive value of @{"LVO" link appels}.

	@{b}GLOOPS=-G/S@{ub}
		select pcode production for @{"GLOOPS" link gloops} classes, commands
		@{"##name" link fd}, @{"##level" link fd}, @{"##get" link fd}, @{"##set" link fd} becomes available whereas @{"##base" link fd}
		is unusable.
  
  If no output file is specified (@{B}PRAGMA=-P@{UB} option), its name is constructed from input file name, in such way:

	- if production is intended to assembler (@{B}ASSEMBLEUR=-A@{UB} option),
	  "@{i}.fd@{ui}" suffix is replaced by "@{i}.i@{ui}",

	- if result is stub functions (either @{B}STUB=-S@{UB} or @{B}MINSTUB=-M@{UB} options),
	  "@{i}.fd@{ui}" suffix is replaced by "@{i}.s@{ui}",

	- if production is intended to C compiler and if suffix of file is
	  "@{i}_lib.fd@{ui}", the latter is replaced by "@{i}_pragmas.h@{ui}",

	- else, "@{i}.fd@{ui}" suffix is merely replaced by "@{i}.h@{ui}".

@ENDNODE

@NODE garantie "Warranty"

  This program has been designed, developped  and tested with all attention notices I'm capable. Yet, @{i}errare humanum est@{ui}, some unpleasant coleopter may still stay hidden somewhere and they could cause some impredictable outcomes.

			@{FG fill}@{B}@{U}So, use of this program is let
			to your own responsability.@{FG text}@{UB}@{UU}

  You use this program at your own risks and, thus, I don't have any responsability about direct or indirect, software or hardware, damages caused by work of this program.

@ENDNODE

@NODE distribution "Distribution"

  This program may be freely distributed while no modification is done on it or on its package. It must @{b}EVER@{ub} be dsitributed inside its package which contains:

	- executable program,

	- documentation.

  If previous condition is filled, it may be added to any program collection of @{u}public domain@{uu} (servers, CD-ROM, ...).

  So, it may be embodyed in any @{i}freeware.@{ui} program. Its use in a @{u}commercial@{uu} package or in a @{u}@{i}shareware@{uu}@{ui} program must be first submitted to its author.

  Yet, @{b}Pragma@{ub} is a @{u}@{i}giftware@{uu}@{ui} program. If you find it interesting, if you use it or if you like work which has been done, you could send me a message or offer any gift you want:

	- @{i}email@{ui},

	- financial help,

	- postcard,

	- peanut,

	- infos on @{fg fill}@{b}X-files@{fg text}@{ub}, etc.

  Feel you free to send me your reviews, your improvement ideas or your questions.

@ENDNODE

@NODE historique "History"

  In fact, this program is much older than it seems through its version number.

  @{b}Pragma V1.0@{ub} is a personnal version, it was created in august, 1991. The matter was to obtain pragma files for my assembler and my C compiler for @{b}KickStart 3.0@{ub}. Indeed, I was owning those of old 2.0 system. Yet, @{".fd" link fd} files of new system was available, I had to translate them according my needs: result reached its goal but wasn't practical at all.

  August 1992, after a lot of disappointement during use, it seems to me necessary to improve interface to avoid useless file murders and to correct a big bug. It will be @{b}1.1@{ub} version. @{b}Pragma V2.0@{ub} version will come from previous version but with a rethinked interface, more intuitive and a lot of file types produced. It's dating from octobre 1994 but will only published during summer 1996 as @{b}2.1@{ub} version with @{u}VERBOSE@{uu} option added.

  August 1996, your servant works optimized dynamic object library, @{b}GLOOPS@{ub}. To make more easier use of the library, stub functions seems to be very interesring, either for standard libraries, or for @{b}GLOOPS@{ub} classes. Taking in account if theses two items will give, at end, @{b}Pragma V3.0@{ub} .

@ENDNODE

@NODE afaire "To do ..."

  @{b}Pragma@{ub} may have lots of improvements and its investigation area may be extended:

	- allowing simultaneous translation of several files with a single command.

	- extending produced files to other compilers (HighSpeedPascal, E, Obéron, ...).
	  I'm not skilled in all this languages but I'm looking documentation about them.

  Actually, my developement projects are about a library for implementing and managing dynamic objects. Somewhat like @{b}BOOPSI@{ub} classes, this objects might avoid method call and attribute access weight using a @{fg highlight}Amiga@{fg text} library vector table-like system.

  First version will be published in octobre with, as sample, a modular screen blanker consistent with existing ones. This library could work too with old @{i}KickStart@{ui} 1.3 .

@ENDNODE

@NODE docs "Documentation"

  @{b}Pragma V2.1@{ub} is only interesting in @{fg highlight}Amiga@{fg text} system environment and skills implemented for managing @{u}libraries@{uu}. To understand use of this program, three following items must be studied:

	- @{"libraries calls" link appels},

	- @{".fd files" link fd},

	- @{"pragma files" link pragma},

	- @{"stub functions" link glue}.

  Those items, more or less directly, allow an application to benefit of the entire power of @{fg highlight}Amiga@{fg text} libraries.

@ENDNODE

@NODE appels "Libraries calls"

  @{u}Libraries@{uu} are collections of functions gathered around a common theme. For instance, @{b}Exec@{ub}, @{b}Graphics@{ub}, @{b}Intuition@{ub} are part of more known @{u}libraries@{uu} in @{fg highlight}Amiga@{fg text} system.
  Yet, it's out of mind to call them straight forward to a fixed address in @{i}ROM@{ui}. To ensure comptability and extensibility, @{i}KickStart@{ui} use below structure:

		+-------------+
		|  Structure  |
		|   Library   |
	base--> +-------------+_
	     -6 | Open        | \
		+-------------+ |
	    -12 | Close       | |
		+-------------+ | LVO f
		     ...
		+-------------+ |
	   -n*6 | <function f>| |
		+-------------+_/
		     ...

  Library opening return its @{u}base@{uu}. In upper adresses relative to @{u}base@{uu}, is found @{i}Library@{ui} structure et and library internal data.
  In lower adresses, stand @{u}function call vectors@{uu}. These vectors, six byte long, are @{fg fill}MC68000@{fg text} statements like:

		@{b}JMP@{ub} <@{i}function_address@{ui}>

  To call a system function, application must obtain library base and must know function place in @{u}vector table@{uu}: this negative offset is called @{i}Library Vector Offset@{ui} (@{b}LVO@{ub}).
  Call of function f seems like:

		@{b}move.l@{ub}  library_base,@{b}a6@{ub}
		@{b}jsr@{ub}     LVOf(@{b}a6@{ub})


  There's an immediate matter: how to merely compute @{b}LVOs@{ub} value in libraries able to count more than about hundred of functions.
  Answer is @{".fd" link fd} files which give a simple description of functions owned by a library and which could be handled in an @{u}automatic@{uu} way. They allow any compiler to access system functions.

@ENDNODE

@NODE fd "fd files"

  @{b}.fd@{ub} files hold the list and the map of library functions. @{b}fd@{ub} stand for @{i}File Description@{ui}.
  So, every @{u}library@{uu} has an associated @{b}.fd@{ub} file whose name looks like:

				<@{i}library_name@{ui}>_lib.fd

@{fg fill}(1)@{fg text} @{b}Function declaration@{ub}

  Syntax of these files allows to describe @{"LVO" link appels} and arguments which must be supplied to functions.
  Each line depicts a function like:

	<@{i}function_name@{ui}>@{u}(@{uu}<@{i}explicit_arguments@{ui}>@{u})(@{uu}<@{i}register_arguments@{ui}>@{u})@{uu}

  @{"LVO" link appels} is computed for each function by adding 6 (size of vector in @{u}library@{uu} table) to previous function one. So, in following definition, if @{b}Allocate@{ub} @{"LVO" link appels} is 186, @{b}AllocMem@{ub} one becomes 198. @{"LVOs" link appels} are ever computed with positive numbers but are subtracted  at using time (they are negative offsets).

	@{fg fill}@{u}Sample@{uu}@{fg text}:
		@{b}Allocate@{ub}(freeList,byteSize)(a0,d0)
		@{b}Deallocate@{ub}(freeList,memoryBlock,byteSize)(a0/a1,d0)
		@{b}AllocMem@{ub}(byteSize,requirements)(d0/d1)

  @{u}Explicit arguments@{uu} are an identifier list separated by "@{u},@{uu}". Their aim is more for information than for a TRUE functional use.

  @{u}Register arguments@{uu} are a @{fg highlight}MC68000@{fg text} register list separated either by "@{u},@{uu}" or "@{u}/@{uu}". This list is parallel to @{u}explicit arguments@{uu} one and show which register is associated to which function argument.
  @{u}Register arguments@{uu} allow to extract from procedure call stack values to store in registers to call a function. Little bytes of program which are doing this work are called @{u}glue@{uu} functions. So, "@{u}/@{uu}" are set to divide register sequence which can be loaded with a single @{b}MOVEM@{ub} statement from @{fg highlight}MC68000@{fg text}. "@{u},@{uu}" aim only to separate this sequences.

	@{fg fill}@{u}Sample@{fg text}@{uu}:
		@{b}Deallocate@{ub}(freeList,memoryBlock,byteSize)(a0/a1,d0)
		will give
			@{b}MOVEM.L@{ub} 4(SP),A0/A1
			@{b}MOVE.L@{ub}  12(SP),D0

		@{b}Deallocate@{ub}(freeList,memoryBlock,byteSize)(a0,a1,d0)
		will give
			@{b}MOVE.L@{ub}  4(SP),A0
			@{b}MOVE.L@{ub}  8(SP),A1
			@{b}MOVE.L@{ub}  12(SP),D0


@{fg fill}(2)@{fg text} @{b}Miscalleneous statements@{ub}

  Some other statements may be used to control interpretation of @{u}library@{uu} function declaration lines. They must begin at @{u}line start@{uu} and hold a @{u}single line@{uu}.

  Here is statement list:

@{b}*@{ub} <@{i}commentary@{ui}>
	Commentaries begin with a "@{u}*@{uu}" at start of the line. They finish at the end
	of the line.

@{b}##base@{ub} <@{i}base_name@{ui}>
	Allows to specify library base standard name to use for calling functions listed
	in file. Base name is provided in a raw form, that is without leading "_". For
	instance,@{b}_IntuitionBase@{ub} is base name of @{fg highlight}Intuition@{fg text} library.

@{b}##bias@{ub} <@{i}value@{ui}>
	Given (decimal) value fix following functions @{"LVOs" link appels}. This statement
	is often found at the begin of the file with a value equal to 30 to avoid to take
	in account the four basic functions of libraries (@{b}Open@{ub}, @{b}Close@{ub}, @{b}Expunge@{ub} and @{b}Null@{ub}).

@{b}##private@{ub}
	Following functions will be used for computing @{"LVOs" link appels} but won't produce anything
	when they are translated. This statement allows to ignore some private functions.

@{b}##public@{ub}
	Opposite statement to @{b}##private@{ub}, this is the default mode.

@{b}##end@{ub}
	Show end of @{".fd" link appels} file.

@{b}##same@{ub}
	This command is added by @{b}Pragma V2.1@{ub} then it isn't standard. Follogin function
	will have same @{"LVO" link appels} as previous function. So, different declarations
	may be assigned at a single library function.

@{fg fill}(3)@{fg text} @{b}Commands of mode GLOOPS@{ub}

  These commands aren't standard. They have been added for managing @{"GLOOPS" link gloops} method declaration files which use a syntax very close to one of Amiga @{".FD" link fd} files.
  These command are only available when @{b}GLOOPS=-G@{ub} option is selected.

@{b}##name@{ub} <@{i}class_level@{ui}>
	Set class name (replace library base name in automatic generation of section
	name, %b).

@{b}##level@{ub} <@{i}level@{ui}>
	Set value of class level. This value must be positive and even. Root class got
	2 as level.

@{b}##set@{ub} <@{i}method_name@{ui}>
	 Define a method which returns value of an attribute.

@{b}##get@{ub} <@{i}nom_méthode@{ui}>
	Define a method which modifies value of an attribute.


@ENDNODE

@NODE pragma "Les fichiers pragma"

  @{b}Pragma@{ub} is a @{u}preprocessor C@{uu} statement which allow to use processor dependant features. In @{fg highlight}Amiga@{fg text} system, @{b}pragma@{ub} statement provide a way for defining  exactly call protocol of a library function so that compiler could generate code for calling this function (register loading, routine call address computed from library base and from @{"LVO" link appels}).

  From it comes the straight forward name extension for declaration files dedicated to library function definition.
  These file are contained in @{u}pragmas@{uu} directory and their name is built like below:

			<@{i}library name@{ui}>@{u}_pragmas.h@{uu}


  Yet, @{b}pragma@{ub} statement syntax, change from a compiler to another. Consequently, @{".fd" link fd} files are very interesting because they give in normalized single @{"syntax" link fd} a description of library functions free of any compiler and any assembler.

  Actually, @{b}Pragma V2.1@{ub} provides translation for three family of compilers:

	- @{"assemblers MC680x0" link assembleur},

	- @{"SASC" link sasc} and @{"Lattice C" link sasc} compilers,

	- @{"Aztec C" link aztecc} compiler.


@ENDNODE

@NODE assembleur "Output for MC680x0 assembler"

  Output file names for @{u}assembler@{uu} @{fg highlight}MC680x0@{fg text} is built on following pattern:

			<@{i}library name@{ui}>_lib.i

  Function name are translated in identifier affectations of functions @{"LVOs" link appels} in following way:

			_LVO<@{i}function_name@{ui}>      @{b}equ@{ub}     <@{i}value@{ui}>

	@{fg fill}@{u}Sample@{fg text}@{uu}:
		@{b}Allocate@{ub}(freeList,byteSize)(a0,d0)
		@{b}Deallocate@{ub}(freeList,memoryBlock,byteSize)(a0/a1,d0)
		@{b}AllocMem@{ub}(byteSize,requirements)(d0/d1)

	will give

		_LVOAllocate    @{b}equ@{ub}     186
		_LVODeallocate  @{b}equ@{ub}     192
		_LVOAllocMem    @{b}equ@{ub}     198

@ENDNODE

@NODE sasc "Output for SASC compiler"

   Library functions declaration in @{"pragma" link pragma} file for case of @{b}SASC@{ub} and @{b}Lattice C@{ub} compilers follows this pattern:

	@{b}#pragma libcall@{ub} <@{i}base_name@{ui}> <@{i}function_name@{ui}> <@{"LVO" link appels}> <@{i}argument_list@{ui}>

  Base name identifier is given in C normal form, that is without leading "_".

  @{"LVO" link appels} is expressed in hexadecimal.

  Argument list is concaténation of hexadecimal expressions of register number in backward order. This list is ended by hexadecimal value of register count on two digits. If there's none argument, a single "0" is needed.
  Registers are coded from 0 to 07 as @{b}d0@{ub} to @{b}d7@{ub} and from 08 to 0f as @{b}a0@{ub} to @{b}a7@{ub}.

	@{fg fill}@{u}Sample:@{uu}@{fg text}

		@{b}Deallocate@{ub}(freeList,memoryBlock,byteSize)(a0/a1,d0)
	becomes
		@{b}#pragma libcall@{ub} ExecBase @{b}Deallocate@{ub} C0 09803

@ENDNODE

@NODE aztecc "Output for Aztec C compiler"

  Library function declaration in @{"pragma" link pragma} file for @{b}Aztec C@{ub} compiler is presented below:

	@{b}#pragma amicall@{ub}(<@{i}base_name@{ui}>,<@{i}LVO@{ui}>,<@{i}function_name@{ui}>(<@{i}argument_list@{ui}>))

  Base name is expressed in raw form, that is with leading "_".

  @{"LVO" link appels} is expressed in hexadecimal C form, that is with leading "0x".

  Arguments are a register list separated with ",". Register are expressed with litteral register identifiers, that is @{b}d0@{ub} to @{b}d7@{ub} and @{b}a0@{ub} to @{b}a7@{ub}.

@ENDNODE

@NODE glue "Stub Functions"
  In the beginning, compilers couldn't pass straight forward parameters into registers and call a library function. This task was performed by a little piece of code written in @{b}assembly@{ub} which took parameters from stack and did library function call.
  These little pieces of code are called @{b}Stub Functions@{ub}. At each library function is matched by a @{b}stub function@{ub}. @{b}Stub function@{ub} for system libraries are stored in a @{u}linkable@{uu} library, @{b}amiga.lib@{ub}.

  @{b}Pragma V3.0@{ub} allows to produce automatically @{b}stubs functions@{ub} from a @{".FD" link fd} file. These functions go by this pattern:

	@{fg fill}(1)@{fg text} Saving used registers
	@{fg fill}(2)@{fg text} Loading parameters from stack
	@{fg fill}(3)@{fg text} Calling library function
	@{fg fill}(4)@{fg text} Restoring saved registers

  Result file is a @{fg highlight}MC68x00@{fg text} assembly program which may be compiled by any assembler before being used.

  For sample,
	@{b}DrawEllipse@{ub}(rp,xCenter,yCenter,a,b)(a1,d0/d1/d2/d3)
  gives following stub function:
	@{b}_DrawEllipse@{ub}:
		movem.l d2/d3,-(sp)     ; saving d2/d3
		move.l  $C(sp),a1       ; loading rp
		movem.l $10(sp),d0-d3   ; loading xCenter, yCenter, a, b
		move.l  _GfxBase,a6     ; loading library base
		jsr     -$b4(a6)        ; calling function
		movem.l (sp)+,d2/d3     ; restoring d2/d3
		rts                     ; returning from stub function

  @{b}Pragma V3.0@{ub} provides two kinds of stub function:
	- @{b}STUB=-S@{ub} option: parameters are retrieved from stack into registers,
	- @{b}MINSTUB=-M@{ub} option: parameters must be already set in registers (this option
	  is only interesting with @{b}GLOOPS=-G@{ub} options for @{"GLOOPS" link gloops}
	  classes).

@ENDNODE

@NODE gloops "GLOOPS Mode"

  @{b}GLOOPS@{ub} is a library, developed by your servant,, which allows management of dynamic objects very close to @{b}BOOPSI@{ub} objects of @{fg highlight}Intuition@{fg text} but with faster @{u}method@{uu} call and @{u}attribute@{uu} access device.

  @{b}GLOOPS@{ub} class structure looks like @{fg highlight}Amiga@{fg text} libraries. Use of @{".FD" link fd} file, with some modifications, seems to be a very good idea. So, @{b}Pragma V3.0@{ub} provides all needed tools to handle such files thanks to @{b}GLOOPS=-G@{ub} option.

  Output for assembler (@{b}ASSEMBLER=-A@{ub} option), for SASC and Lattice C compilers(@{b}SASC=-C@{ub} option) and Aztec C compiler (@{b}AZTECC=-Z@{ub} option) is a sequence of constants associated with each @{".FD" link fd} file method.
  This contants match pattern below:
		@{b}METHOD_@{ub}<@{i}method_name@{ui}>
  Constant value may be passed as parameters for method call functions of @{b}GLOOPS@{ub} library.

  @{b}STUB=-S@{ub} and @{b}MINSTUB=-M@{ub} options supply @{"stub" link glue} functions needed for method straight forward call and associated coerced call.

@ENDNODE

@NODE contact "To get in touch with me ..."

  You can get in touche with me ...

	- either by e-mail
				@{fg fill}@{u}@{b}casse@irit.fr@{fg text}@{uu}@{ub}

	- or by postcard address

				@{b}CASSE Hugues@{ub}
				Arignac
				09400 Tarascon FRANCE

  Actually, I'm a doctor's degree student in Fundamental Computer Science at Toulouse Rangueil University, FRANCE. For any question, any advice or collaboration, feel you free to get in touch with me.

@ENDNODE
