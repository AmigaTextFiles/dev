@database       CTIMER
@$VER:          1.0
@author:        "Hans Bühler"
@(c)            "Hans Bühler"
@INDEX          Main
@remark         cTimer.o V1 (c)1996 by Hans Bühler,
@remark                        codex@studi.mathematik.hu-berlin.de

@remark -----------------------------------------------------------

@NODE Main "ctimer.o V1.00 ©1996 Hans Bühler, Codex Design Software
@NEXT Duty

                @{b}·C·O·D·E·X· ·D·E·S·I·G·N· ·S·O·F·T·W·A·R·E·@{ub}
                                 presents:

                              @{fg shine}ctimer.o V1.00@{fg text}
                   @{i}timed exec functions for all purposes@{ui}

                               @{u}Information:@{uu}

                          @{" Introduction          " LINK Intro}
                          @{" Installation          " LINK Install}
                          @{" Using ctimer.o        " LINK Background}

                   @{u}Initialization/Termination functions:@{uu}

                          @{" ctimerInit()         " LINK ctimerInit}
                          @{" ctimerRem()          " LINK ctimerRem}
                          @{" ctimerCancelAll()    " LINK ctimerCancelAll}

                           @{u}Timed exec functions:@{uu}

               @{" ctimerPutMsg()       " LINK ctimerPutMsg} @{" ctimerCancelPutMsg() " LINK ctimerCancelPutMsg}
               @{" ctimerSignal()       " LINK ctimerSignal} @{" ctimerCancelSignal() " LINK ctimerCancelSignal}
               @{" ctimerWait()         " LINK ctimerWait}

                                 @{u}Appendix:@{uu}

                          @{" Disclaimer and ©stuff " LINK Duty}
                          @{" Author                " LINK TalkLine}

          ctimer.o V1.00 object and include ©1996 by Hans Bühler,
                           Codex Design Software
@ENDNODE

@remark -----------------------------------------------------------
@remark -----------------------------------------------------------

@NODE Intro "How to make use of ctimer.o"
@PREV Main
@NEXT Install

                               @{b}@{u}INTRODUCTION:@{ub}@{uu}

 This  object  offers  several  functions  that  extend the hopefully known
@{"exec/Signal()"  LINK exec/Signal} or @{"exec/PutMsg()" LINK exec/PutMsg}  functions by allowing to pass a 'time' to
them  indicating  how  long  you  want to wait until one of these functions
should be executed.
 A timeoutable @{"exec/Wait()" LINK exec/Wait} replacement is also available !
 Every function you have declared to be delayed (e.g.  a ctimer.o function)
can be canceled before it takes part, if neccessary.
 The  main  aim  of  these  functions is to allow you to accept a (possibly
user-definable) delay time before an action takes place.

 Note:   This  object  doesn't  make  sense if you either want _exact_ time
calculations or if you already make use of the timer.device.

 Using this archive you can simply implement stuff like
 - Confirm requester within @{i}y@{ui} seconds.
 - Execute an action after @{i}y@{ui} seconds
   (e.g. stop a child process).
 - "Timeout" a @{"Wait()" LINK exec/Wait}/@{"WaitPort()" LINK exec/WaitPort} after some time
   (e.g. if an AmiTCP connection doesn't work).

 Additionally, there aren't any restrictions made to the use of ctimer.o in
your own productions.  The only thing I await from you is to note that your
program makes use of ctimer.o in your documentation.
 @{"See copyright notes" LINK duty}.

 ctimer.o doesn't need any additional software/ressources to run.

 If you need such things, @{"read on" LINK Background} !
@ENDNODE

@remark -----------------------------------------------------------

@NODE Install "How to make install ctimer.o"
@PREV Intro
@NEXT Background

                            @{b}@{u}INSTALLING ctimer.o@{ub}@{uu}

 You need to copy ctimer.o to @{b}LIB:ctimer.o@{ub}
                  ctimer.h to @{b}INCLUDE:ctimer.h@{ub}

                  ctimer.guide where you have your other library function
                  guides saved to (otherwise links to exec or dos functions
                  don't work).

                 @{b}@{u}MAKING ctimer.o AVAILABLE TO YOUR PROGRAM@{ub}@{uu}

 Into the source that needs ctimer.o objects, you have to
   @{b}#include <ctimer.h>@{ub}
 to make your program knowing about ctimer's functions and defines.

 If  you  compiled  your  program,  you  have  to  link @{b}LIB:ctimer.o@{ub} to the
executable.
@ENDNODE

@remark -----------------------------------------------------------

@NODE Background "How to use ctimer.o in your own program"
@PREV Install
@NEXT ctimerInit

                    @{b}@{u}HOW TO USE ctimer.o IN YOUR PROGRAM@{ub}@{uu}

Please note the @{"making ctimer.o available to your program" LINK Install} paragraph on the
Installation page !

                          @{u}Initialize a new timer@{uu}

 If you want to make use of any of the functions of ctimer.o you first have
to create a new timer for your process(es).
 Note  that  although creating and removing the timer must be done from the
same  process/task  all  other  routines  will  also  cooperate  from other
processes/tasks even if they are not sharing the same data array (of course
they  need the routines they're calling available to do so ;-).  That means
that you can even use another program's timer if you want to do so.

 @{fg shine}You create a new timer using @{fg text}@{"ctimerInit()" LINK ctimerInit}@{fg shine}.@{fg text}

 ctimer.o  identifies a timer by its name.  Therefore it is not possible to
create another timer with the same name.

                             @{u}Calling functions@{uu}

 Having initialized your timer you can now play around with the functions
offered to you by ctimer.o.

                            @{u}Removing the timer@{uu}

 @{fg shine}If you are done using the timer you have to remove it using@{fg text} @{"ctimerRem()" LINK ctimerRem}@{fg shine}.@{fg text}

 Again note that ctimerRem() must be called from the same task/process that
initialized the timer using ctimerInit() !

 If  you are removing the timer, all jobs which aren't done will be removed
from  the  timer  @{u}and executed@{uu}.   That  means that you have to check up any
msgport  you  decided  to  send messages to if you are not sure whether you
already got these messages !
 Additionally,  if  you have timed signalled any tasks, note that that will
happen now (if not already done, of course).

 You  can  remove  all  jobs  from  the  timer without executing them using
ctimerCancelAll()  but  please  note that having executed ctimerCancelAll()
does  @{u}not@{uu}  gurantee  that the timer isn't been commanded to execute further
jobs when you're using the timer from several processes/tasks again.
 The  only  way to be safe that your timer is empty after ctimerCancelAll()
is  either  to  use  it  by one process/task only or to forbid all ctimer.o
functions by hand (via a global flag or stuff).
 For more information, check the description of @{"ctimerCancelAll()" LINK ctimerCancelAll}.
@ENDNODE

@remark -----------------------------------------------------------
@remark -----------------------------------------------------------

@NODE ctimerInit "ctimer/ctimerInit()"
@NEXT ctimerRem
@PREV Background

 @{b}NAME@{ub}

   ctimerInit() - initialize new timer process

 @{b}SYNOPSIS@{ub}

   error = ctimerInit(timername, pri, delaySteps)
   UBYTE              char *     BYTE UBYTE
   d0                 a0         d0   d1


 @{b}FUNCTION@{ub}

 This  function  has to be called before you can use any of the other timer
functions.
 It  sets  up  a  new  timer  with  the  given  name  in  your system.  The
'timername'  parameter  is used to identify the timer, later. Thus you have
to keep track of the string you're passing to ctimerInit().
 Use @{"ctimerRem()" LINK ctimerRem} to remove a timer if you aren't using it any longer !

 @{b}NOTES@{ub}

 ctimerRem()   must  be  called  from  the  same  task/process  from  which
ctimerInit()  is  been  called.  This  is because ctimerInit() @{"allocates" LINK "exec/AllocSignal"} a
signal  to  communicate  with  the  timer  process.   If  ctimerRem() would
re-allocate  one,  it  would be possible that it fails what would lead into
additional error checks when quitting your program.
 To  avoid  this,  ctimerRem()  and ctimerInit() must be used from the same
task !

 This function is save to be called from a task.

 @{b}IMPLEMENTATION@{ub}

 ctimerInit() runs a new process called 'timername' with the priority 'pri'
and  a  stack size of ~800 Bytes. Additionally, it adds a @{"signal semaphore"  LINK "INCLUDE:exec/semaphores.h/Main"}
to  the  system's  semaphore list.  This semaphore has the same name as the
process.  All  functions concerning a timer will then @{"exec/FindSemaphore()" LINK "exec/FindSemaphore"}
to  get  the timer's database.  Therefore you can't run two timers with the
same name !

 @{b}INPUTS@{ub}

   timername    - A @{u}unique@{uu} name for the timer.
                  Since this string will be used as a reference,
                  you @{u}must not@{uu} free it before you are done
                  with the timer.
                  @{i}A zero value here leads into an error.@{ui}
   pri          - Priority of the timer's process.
                  It is wise to use a priority higher than the
                  priority of the father process.
   delaySteps   - All 'times' of ctimer's functions are measured
                  in (50/delaySteps) seconds.
                  I recommend to read some @{"further information" LINK DelaySteps} before
                  you're going to choose any value here !
                  However, a value of CTIM_DEFDELAY will suit most
                  demands (1/5s per unit), I think.
                  @{i}A zero value here leads into an error.@{ui}

 @{b}RESULTS@{ub}

   ET_OKAY == 0 for success o@{uu@{uu@{uu}

   TRET_BADINPUT        timername == 0 or delaySteps == 0
   TRET_BADNAME         there's already a timer called 'timername'
   TRET_OUTOFMEMORY     ... just guess
   TRET_NOSIGNAL        can't @{"exec/AllocSignal()" LINK "exec/AllocSignal"} for your proces
   TRET_NOPROCESS       can't create new process using
                        @{"dos/CreateNewProc()" LINK "dos/CreateNewProc"}
   TRET_NOCHILDCONFIG   the timer process can't configurate itself.
                        Since it only calls exec/AllocSignal()
                        twice, I don't expect you'll get this event.

 @{b}EXAMPLE@{ub}

 Little routine to install a timer called 'my_timer' (returns BOOL) :

   char    *tname = "my_timer";

   BOOL SetUpTimer(void);
   {
      return ( ctimerInit(tname,1,5) == TRET_OKAY );
   }

 @{b}SEE ALSO@{ub}

   @{"Background" LINK Background} @{"Defining 'delaySteps'" LINK delaySteps}

   @{"ctimer/ctimerRem()" LINK ctimerRem}

   @{"exec/AllocSignal()" LINK "exec/AllocSignal"}
   @{"exec/AddSemaphore()" LINK "exec/AddSemaphore"}
   @{"dos/CreateNewProc()" LINK "dos/CreateNewProc"}
@ENDNODE

@remark -----------------------------------------------------------

@NODE ctimerRem "ctimer/ctimerRem()"
@PREV ctimerInit
@NEXT ctimerCancelAll

 @{b}NAME@{ub}

   ctimerRem() - remove a timer from the system

 @{b}SYNOPSIS@{ub}

   error = ctimerRem(timername)
   UBYTE             char *
   d0                a0

 @{b}FUNCTION@{ub}

 This  function removes  a timer you installed using @{"ctimerInit()" LINK ctimerInit} from the
system.
 All  outstanding  "delayed"  jobs  will  be  cancelled  @{u}and executed@{uu} - see
ctimerCancel@{i}xxx@{ui}() functions !) and all ressources will be freed.

 If this function succeeds all further calls relating the timer 'timername'
will fail by returning TRET_BADTIMER.

 @{b}NOTES@{ub}

 You  MUST  call  this  function  from  the  same task/process which called
ctimerInit() for this timer !
 You can savely call this function if ctimerInit() failed.

 This function is save to be called from a task.

 @{b}INPUTS@{ub}

   timername    - Name of the timer you passed to ctimerInit().
                  @{i}A zero value here leads into an error.@{ui}

 @{b}RESULTS@{ub}

   TRET_OKAY == 0 for success

   TRET_BADTIMER   can't find timer "timername"
                   Note that this means that there ISN'T a timer
                   with that name (e.g. because ctimerInit()
                   failed).
   TRET_BADTASK    The task which calls ctimerRem() doesn't
                   match the task which called ctimerInit() !!!
                   They must be the same !!!!

 @{b}SEE ALSO@{ub}

   @{"Background" LINK Background}

   @{"ctimer/ctimerInit()" LINK ctimerInit}
   @{"ctimer/ctimerCancelPutMsg()" LINK ctimerCancelPutMsg}
   @{"ctimer/ctimerCancelSignal()" LINK ctimerCancelSignal}
   @{"ctimer/ctimerCancelAll()" LINK ctimerCancelAll}

   @{"exec/FreeSignal()" LINK "exec/FreeSignal"}
   @{"exec/RemSemaphore()" LINK "exec/RemSemaphore"}
@ENDNODE

@remark -----------------------------------------------------------

@NODE ctimerCancelAll "ctimer/ctimerRem()"
@PREV ctimerRem
@NEXT ctimerPutMsg

 @{b}NAME@{ub}

   ctimerCancelAll() - cancel all delayed jobs commanded to a timer.

 @{b}SYNOPSIS@{ub}

   error = ctimerCancelAll(timername, execute)
   UBYTE                   char *     BOOL
   d0                      a2         d2

 @{b}FUNCTION@{ub}

 This  function cancels all jobs available on the timer by executing either
@{"ctimerCancelPutMsg()" LINK ctimerCancelPutMsg} or @{"ctimerCancelSignal()" LINK ctimerCancelSignal}.

 @{b}NOTES@{ub}

 Please  note  that  -  if  more than one process is using your timer - you
can't  be  sure  that there aren't any jobs on the timer if you didn't took
appropiate  steps  by yourself (say your other processes that they can't do
any timer jobs _before_ you call this function).
 BTW:  Even  a   @{"Forbid()" LINK exec/Forbid}/@{"Permit()" LINK exec/Permit}  call  around  ctimerCancelAll()  and
@{"ctimerRem()" LINK ctimerRem}  won't  operate  since  ctimerCancelAll() and ctimerRem() might
@{"Wait()" LINK exec/Wait} until the timer is accessible (therefore other processes could send
their jobs to it while your program Waits()).

 This function is save to be called from a task.

 @{b}INPUTS@{ub}

   timername    - Name of the timer you passed to ctimerInit().
                  @{i}A zero value here leads into an error.@{ui}
   execute      - Whether you want to execute the function associated with
                  each job or not.
                  See @{"ctimerCancelPutMsg()" LINK ctimerCancelPutMsg} and @{"ctimerCancelSignal()" LINK ctimerCancelSignal} for
                  further information.

 @{b}RESULTS@{ub}

   TRET_OKAY == 0 for success

   TRET_BADTIMER   can't find timer "timername"
                   Note that this means that there ISN'T a timer
                   with that name (e.g. because ctimerInit()
                   failed).

 @{b}SEE ALSO@{ub}

   @{"Background" LINK Background}

   @{"ctimer/ctimerInit()" LINK ctimerInit}
   @{"ctimer/ctimerRem()" LINK ctimerInit}
   @{"ctimer/ctimerCancelPutMsg()" LINK ctimerCancelPutMsg}
   @{"ctimer/ctimerCancelSignal()" LINK ctimerCancelSignal}
@ENDNODE

@remark -----------------------------------------------------------
@remark -----------------------------------------------------------

@NODE ctimerPutMsg "ctimer/ctimerPutMsg()"
@PREV ctimerRem
@NEXT ctimerCancelPutMsg

 @{b}NAME@{ub}

   ctimerPutMsg() - delayed @{"exec/PutMsg()" LINK "exec/PutMsg"} function

 @{b}SYNOPSIS@{ub}

   error = ctimerPutMsg(port, msg, timername, time)
   UBYTE                struct MsgPort*, struct Message *, char *, ULONG
   d0                   a0    a1   a2         d2

 @{b}FUNCTION@{ub}

 This  function  might  be  used to send a 'msg' to a 'port'  after  'time'
passed by. The 'time' parameter is meassured by @{"(delaySteps/50)s" LINK DelaySteps} !
 You can abort this operation using @{"ctimerCancelPutMsg()" LINK ctimerCancelPutMsg} !

 @{b}NOTES@{ub}

 This  function  will  simply  call exec/PutMsg(port,msg) if the 'time' you
specified  passed  by.
 Do @{u}not@{uu} expect this function to do anything else !

 This function is save to be called from a task.

 @{b}INPUTS@{ub}

   port         - Port to put msg to.
                  @{i}A zero value here leads into an error.@{ui}
   msg          - Msg to put to port.
                  @{i}A zero value here leads into an error.@{ui}
   timername    - Name of timer to be used.
                  @{i}A zero value here leads into an error.@{ui}
   time         - Time meassured in @{"(delaySteps/50)" LINK DelaySteps} secs to wait before
                  msg will be sent.
                  @{i}A zero value here leads into an error.@{ui}

 @{b}RESULTS@{ub}

   TRET_OKAY == 0 for success

   TRET_BADINPUT    - port, msg or time == 0
   TRET_BADTIMER    - timer 'timername' doesn't exist !
   TRET_OUTOFMEMORY - ... hm. what could that mean ;-?

 @{b}EXAMPLE@{ub}

 Send  a message 'msg' to a port 'port' in 'time' * (delaySteps/50) seconds
or abort if CTRL-C is been pressed (assuming timer is called 'my_timer'):
 See @{"ctimerPutMsg()" LINK ctimerPutMsg}, too !

   struct Message *SendMsg(struct MsgPort *port,
                           struct Message *msg,
                           ULONG time)
   {
      ctimerPutMsg(port,msg,"my_timer",time);

      Wait((1 << port->mp_SigBut) | SIGBREAKF_CTRL_C) &   // see dos/dos.h
         (1 << port->mp_SigBit);

      @{"ctimerCancelPutMsg" LINK ctimerCancelPutMsg}(port,msg,"my_timer",FALSE);   // execute cancel

      return GetMsg(port);
   }


 another  solution  of  the  same problem (easily extentable for more break
bits):

   struct Message *SendMsg(struct MsgPort *port,
                           struct Message *msg,
                           ULONG time)
   {
      ctimerPutMsg(port,msg,"my_timer",time);

      if(Wait((1 << port->mp_SigBut) | SIGBREAKF_CTRL_C) &   // see dos/dos.h
         (1 << port->mp_SigBit))
      {
         return GetMsg(port);         // 'msg' received !
      }

      // -- CTRL-C received ! --

      if(@{"ctimerCancelPutMsg" LINK ctimerCancelPutMsg}(port,msg,"my_timer",FALSE) == -1)
      {
         WaitPort(port);
         return GetMsg(port);         // 'msg' had arrived while we were
      }                               //   doing the upper stuff

      return 0;                       // message canceled !
   }

 @{b}SEE ALSO@{ub}

   @{"Background" LINK Background}

   @{"ctimer/ctimerInit()" LINK ctimerInit}
   @{"ctimer/ctimerCancelPutMsg()" LINK ctimerCancelPutMsg}

   @{"exec/PutMsg()" LINK "exec/PutMsg"}
@ENDNODE

@remark -----------------------------------------------------------

@NODE ctimerCancelPutMsg "ctimer/ctimerCancelPutMsg()"
@PREV ctimerPutMsg
@NEXT ctimerSignal

 @{b}NAME@{ub}

   ctimerCancelPutMsg() - cancel an outstanding delayed
                          ctimerPutMsg() operation

 @{b}SYNOPSIS@{ub}

   timeLeft = ctimerCancelPutMsg(port, msg, timername, send)
   LONG                          struct MsgPort*, struct Message *, char *, BOOL
   d0                            a0    a1   a2         d2

 @{b}FUNCTION@{ub}

  This function might be used to cancel a previously invoked @{"ctimerPutMsg()" LINK ctimerPutMsg}
operation.
 It  will  either  simply  remove  the  job from the timer or remove it and
exeucte @{"exec/PutMsg()" LINK exec/PutMsg}.

 @{b}NOTES@{ub}

 You  may  ignore  the  return  code  -1  because it says that your msg has
already  been  sent  (in  the  case  you  are  sure that you did called the
appropiate ctimerPutMsg() function).

 This function is save to be called from a task.

 @{b}INPUTS@{ub}

   port, msg, timername - same as passed to @{"ctimerPutMsg()" LINK ctimerPutMsg}.
   send                 - If TRUE, @{"exec/PutMsg" LINK "exec/PutMsg"}(port,msg) will be executed,
                          otherwise not.

 @{b}RESULTS@{ub}

   >=0   job removed; return value is time (in @{"(delaySteps/50)" LINK DelaySteps} secs) that
         had already passed by.
   -1    job not found (e.g. because it has already been executed).
   -2    'timername' timer not found / invalid.

 @{b}SEE ALSO@{ub}

   @{"Background" LINK Background}

   @{"ctimer/ctimerPutMsg()" LINK ctimerPutMsg}
   @{"ctimer/ctimerRem()" LINK ctimerRem}

   @{"exec/PutMsg()" LINK "exec/PutMsg"}
   @{"exec/GetMsg()" LINK "exec/GetMsg"}
   @{"exec/WaitPort()" LINK "exec/WaitPort"}
   @{"exec/Wait()" LINK "exec/Wait"}
@ENDNODE

@remark -----------------------------------------------------------
@remark -----------------------------------------------------------

@NODE ctimerSignal "ctimer/ctimerSignal()"
@PREV ctimerPutMsg
@NEXT ctimerCancelSignal

 @{b}NAME@{ub}

   ctimerSignal() - delayed @{"exec/Signal()" LINK "exec/Signal"} function

 @{b}SYNOPSIS@{ub}

   error = ctimerSignal(task, signals, timername, timer)
   UBYTE                struct Task *, ULONG, char *, ULONG
   d0                   a0    d0       a2         d2

 @{b}FUNCTION@{ub}

 This  function  executes  exec/@{"Signal" LINK HLEPDIR:exec.guide/Signal} (task,signals)  after  the  'time'  -
meassured in (delaySteps/50) secs has passed by.
 You can abort this operation using @{"ctimerCancelSignal()" LINK ctimerCancelSignal} !

 @{b}NOTES@{ub}

 This function is save to be called from a task.

 @{b}INPUTS@{ub}

   task         - Task that should be signalled. If you leave that zero,
                  the caller task will be used (@{"FindTask(0)" LINK exec/FindTask}).
   signals      - Signals to set.
                  @{i}A zero value here leads into an error.@{ui}
   timername    - Name of timer to be used.
                  @{i}A zero value here leads into an error.@{ui}
   time         - Time meassured in @{"(delaySteps/50)" LINK DelaySteps} secs to wait before
                  the signals will be set for the 'task'.
                  @{i}A zero value here leads into an error.@{ui}

 @{b}RESULTS@{ub}

   TRET_OKAY == 0 for success

   TRET_BADINPUT    - task, signals or time == 0
   TRET_BADTIMER    - timer 'timername' doesn't exist !
   TRET_OUTOFMEMORY - ... hm. what could that mean ;-?

 @{b}EXAMPLE@{ub}

   See @{"ctimerWait()" LINK ctimerWait}

 @{b}SEE ALSO@{ub}

   @{"Background" LINK Background}

   @{"ctimer/ctimerInit()" LINK ctimerInit}
   @{"ctimer/ctimerCancelSignal()" LINK ctimerCancelSignal}

   @{"exec/Signal()" LINK "exec/Signal"}
   @{"exec/FindTask(0)" LINK "exec/FindTask"}
@ENDNODE

@remark -----------------------------------------------------------

@NODE ctimerCancelSignal "ctimer/ctimerCancelSignal()"
@PREV ctimerSignal
@NEXT ctimerWait

 @{b}NAME@{ub}

   ctimerCancelSignal() - cancel and outstanding delayed
                          ctimerSignal() operation

 @{b}SYNOPSIS@{ub}

   timeLeft = ctimerCancelSignal(task,signals,timername,set)
   LONG                          struct Task *, ULONG, char *, BOOL
   d0                            a0    d0       a2         d2

 @{b}FUNCTION@{ub}

 Using  this function you can cancel a previously commanded @{"ctimerSignal()" LINK ctimerSignal}
call and optionally execute its exec/@{"Signal()" LINK exec/Signal} call immediately.

 @{b}NOTES@{ub}

 You  may  ignore  the  return  code  -1  because it says that your msg has
already  been  sent  (in  the  case  you  are  sure that you did called the
appropiate ctimerSignal() function).

 This function is save to be called from a task.

 @{b}INPUTS@{ub}

   task,signals,timername - same as passed to @{"ctimerSignal()" LINK ctimerSignal}
                            if you leave task zero, it must be the same
                            from which you called ctimerSignal().
   set                    - if TRUE, exec/@{"Signal" LINK exec/Signal}(task,signals) will be
                            called immediately, otherwise not.

 @{b}RESULTS@{ub}

   >=0   job removed; return value is time (in @{"(delaySteps/50)" LINK DelaySteps} secs) that
         had already passed by.
   -1    job not found (e.g. because it has already been executed).
   -2    'timername' timer not found / invalid.

 @{b}EXAMPLE@{ub}

   See @{"ctimerWait()" LINK ctimerWait}

 @{b}SEE ALSO@{ub}

   @{"Background" LINK Background}

   @{"ctimer/ctimerCancelSignal()" LINK ctimerCancelSignal}
   @{"ctimer/ctimerRem()" LINK ctimerRem}

   @{"exec/Signal()" LINK "exec/Signal"}
   @{"exec/FindTask(0)" LINK "exec/FindTask"}
   @{"exec/Wait()" LINK "exec/Wait"}
@ENDNODE

@remark -----------------------------------------------------------
@remark -----------------------------------------------------------

@NODE ctimerWait "ctimer/ctimerWait()"
@PREV ctimerSignal
@NEXT Main

 @{b}NAME@{ub}

   ctimerWait() - @{"exec/Wait()" LINK exec/Wait"} for signals a given time

 @{b}SYNOPSIS@{ub}

   timeLeft = ctimerWait(signalPtr, timername, time)
   LONG                  ULONG *,   char *,    ULONG
   d0                    d0         a2         d2

 @{b}FUNCTION@{ub}

 This  function  allows  you  to  wait  for some signals until one of these
signals is set or 'time' passed by.
 The  'signalPtr' pointer  has  two  different  meanings:  When calling the
function  ctimerWait()  will  read  from  it the signals to wait for.  When
ctimerWait()  returns  a  return  code  greater than NULL, you can find the
signals  received  in  here.   If  it  contains  NULL,  no signals had been
received but 'time' passed by.

 @{b}NOTES@{ub}

 If   some  signals  had  been  received  (and  therefore  the  long  where
'signalPtr'  points to is not NULL), these signals aren't set in the task's
received signals buffer !
 If  you  want  to  have  the signals received set there, use the following
short cut:

   LONG new_ctimerWait(ULONG *sigPtr, char *timername, ULONG time)
   {
      LONG time;

      if( ((time = ctimerWait(sigPtr,timername,time)) > 0) &&
          *sigPtr)
      {
         Signal(FindTask(0),*sigPtr);
      }
      return time;
   }

 Additionally,  note  that ctimerWait() needs to allocate a @{"new signal" LINK exec/AllocSignal}. If
this isn't possible it will fail !

 This function is save to be called from a task.

 @{b}INPUTS@{ub}

   signalPtr    - POINTER to an ULONG containing the signals to Wait for
                  in the beginning and containing the received signals
                  at the end (if no failure occured).
                  @{i}A zero value here leads into an error.@{ui}
   timername    - Name of timer to be used.
                  @{i}A zero value here leads into an error.@{ui}
   time         - Time of meassured in @{"(delaySteps/50)" LINK DelaySteps} secs to wait
                  until the routine returns legally.
                  @{i}A zero value here leads into an error.@{ui}

 @{b}RESULTS@{ub}

   >0  - One of the signals received. Which can be found out by checking
         *signalPtr.
         Value means the time meassured in @{"(delaySteps/50)" LINK delaySteps} secs that had
         already passed by.
   0   - Time completely passed by.
   -1  - Any error occured (bad timer, bad time (=0), no free signal, out
         of memory etc.)

 @{b}IMPLEMENTATION@{ub}

 ctimerWait()  makes use of  a  @{"ctimerSignal()" LINK ctimerSignal}/@{"ctimerCancelSignal()"  LINK ctimerCancelSignal} pair.
Here is the complete (simplified) source for ctimerWait():

__asm LONG ctimerWait(  register __d0 ULONG *breakMask,
                        register __a2 char *timername,
                        register __d2 ULONG time)
{
   register BYTE  mySignal;
   register LONG  rec,mask;

   if(!time || !breakMask || ((mySignal = AllocSignal(-1)) == -1))
      return -1;

   if(ctimerSignal(0,mySignal,timername,time) == TRET_OKAY)
   {
      mask        =  *breakMask;
      *breakMask  =  0;

      rec = Wait((1 << mySignal) | mask);

      if(rec & mask)
      {
         time  =  ctimerCancelSignal(0,mySignal,timername,FALSE);

         if(time == 0)              // user should know that it was a break
            time = 1;

         *breakMask  =  rec & mask;
      }
      else
         if(rec & (1 << mySignal))
         {
            time  =  0;
         }
   }
   else
      time  =  -1;

   FreeSignal(mySignal);

   return time;
}

 @{b}SEE ALSO@{ub}

   @{"Background" LINK Background}

   @{"ctimerSignal()" LINK ctimerSignal}
   @{"ctimerCancelSignal()" LINK ctimerCancelSignal}

   @{"exec/AllocSignal()" LINK exec/AllocSignal}
   @{"exec/Wait()" LINK exec/Wait}
   @{"exec/FreeSignal()" LINK exec/FreeSignal}
@ENDNODE

@remark -----------------------------------------------------------
@remark -----------------------------------------------------------

@NODE DelaySteps "Using time parameters"
@PREV ctimerInit

                        @{b}@{u}THE 'delaySteps' PARAMETER@{ub}@{uu}

 All  'time'  values  your  can  use  with any function of this archive are
calculated by the following formula:

   @{fg shine}realtime = time * ( delaySteps / 50 ) seconds@{fg text}

 You  have  to  define  the  'delaySteps'  parameter  when  you  are  using
@{"ctimerInit()" LINK ctimerInit} to set up a new timer for your purposes.  This value can't be
changed while the timer is running.

 Before  you  decide  to  choose  a value of your like please note that two
points _should_ influence your decission:

 a) ctimerRem()   can  -  in  the  worst  case  -  be  delayed  by  exactly
(delaySteps/50) seconds.  That means that if you e.g.  choose delaysteps=50
(and  therefore  all  'time' values  will match 'time' seconds) ctimerRem()
_could_ need @{b}one@{ub} second until it returns.

 b) On the other hand, ctimer.o of course needs to check its list each time
(delaySteps/50)  seconds  passed by.  Although a very quick routine is used
to  perform  this, that - if you're massively using ctimer.o timed routines
(that means very much jobs are to be done) - could waste CPU time !

 In order to help you evaluating the situation here's the semi-code of a
timer's mainloop:

   do
   {
      if(jobs_to_do)
      {
         @{"Delay" LINK dos/Delay}(delaySteps);    // doesn't block multi-tasing !

         for(job = firstjob; job; job = job->Next)
         {
            if(time_of_job_passed_by)
               execute_job();
         }
      }
      else
      {
         Wait(until_there_is_something_to_do);
      }
   }
   while(timer_is_left_alive);

 You'll  note that the disadvantage of choosing a low 'delaySteps' value is
obsolete as long as you are not awaiting any job to be done by the timer.
 @{fg shine}
 I recommend to use delaySteps = @{"CTIM_DEFDELAY" LINK INCLUDE:ctimer.h/Main} (=10) or anything else that
will feed the most needs.
 @{fg text}
                            @{b}@{u}A 'time' PARAMETER@{ub}@{uu}

 Having   read   the   former   paragraphs,   you   can   now  calculate  a
'time' parameter  (as  requested  by  all ctimer@{i}xxx@{ui}() functions) using this
formula ("real_secs" given in seconds):

   @{fg shine}time = real_secs * (50/delaySteps).@{fg text}

 @{u}An example:@{uu}

 You want  to  execute  exec/@{"Signal" LINK exec/Signal}(t,s) using a timer 'my_timer' after @{b}12@{ub}
seconds.  You had choosed delaySteps = 10 (CTIM_DEFDELAY):

   'time' value = @{b}12@{ub} * (50/CTIM_DEFDELAY) = @{b}60@{ub}

   void DelayedSignal(t,s)
   {
      @{"ctimerSignal" LINK ctimerSignal}(t,s,"my_timer",@{b}60@{ub});
   }
@ENDNODE

@remark -----------------------------------------------------------
@remark -----------------------------------------------------------

@NODE Duty "©-stuff & disclaimer"
@NEXT TalkLine

                                @{u}Disclaimer:@{uu}

 The  author  cannot be held liable for the suitability or accuracy of this
manual  and/or  the  program(s)  it  describes.   Any  damage  directly  or
indirectly caused by the use or misuse of this manual and/or the program it
describes is the sole responsibility of the user her/him self.

                                @{u}Copyrights:@{uu}

 ctimer.o, ctimer.h and this guide
   are copyrighted ©1996 by @{"Hans Bühler" LINK TalkLine},
                            Codex Design Technologies [software].

                   @{u}Using ctimer.o in an own production:@{uu}

 You  can freely use the object ctimer.o (and use the include file ctimer.h
to  compile  your  program)  as  long as you find a place in your program's
documentation where you note that you
   (a) made use of ctimer.o
   (b) this object had been programmed by Hans Bühler and
   (c) where others may find this object if it isn't part of your programs
       distribution (ftp aminet:dev/misc/ctimer.lha or from the author).

The best is, you snap this passage and include it into your documentation:

<SNIP>

 This  program makes use of the ctimer.o object ©Hans Bühler available from
the aminet (dev/misc/ctimer.lha) or from
  Hans Bühler: codex@studi.mathematik.hu-berlin.de

<SNIP>

 Additionally,  if you copy/distribute ctimer.o you are not allowed to make
any  changes  to the archive ctimer.lha or to this guide (except correcting
my English ;^).
@ENDNODE

@remark -----------------------------------------------------------
@remark -----------------------------------------------------------

@NODE TalkLine " Have a chat with me. "
@PREV Duty
                                     .
                                     .
                                     .
                                     .
                                     :
                                     :
                                     :
                                     :
                                     :
                                     :
                             ........:
                             :
       h a n s b u e h l e r : c o d e x d e s i g n s o f t w a r e
                             :
                             :.....................
                                                  :
                                  @{b}[email]@{ub}         :
             codex@studi.mathematik.hu-berlin.de (Hans Bühler)
                  buehlhan@kadewe.artcom.de (Hans Bühler)
                                   @{b}[www]@{ub}          :
        http://kadewe.artcom.de/~codex/rawtext.html (AMosaic etc.)
               http://kadewe.artcom.de/~codex (NetScape 2+)
                                                  :
                                  @{b}[smail]@{ub}         :
                                Hans Bühler       :
                     Stromstraße 48 - 10551 Berlin 21
                                  Germany         :
                                                  :
                                     .............:
                                     :
                                     :
                                     :
                                     :
                                     :
                                     .
                                     .
                                     .
@ENDNODE


