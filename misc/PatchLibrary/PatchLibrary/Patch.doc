TABLE OF CONTENTS

patch.library/FindPatch
patch.library/InstallPatch
patch.library/RemovePatch
patch.library/WaitRemovePatch


 patch.library/InstallPatch

    NAME
	InstallPatch -- Installs a patchroutine for libraryfunctions.

    SYNOPSIS
	Patch = InstallPatch( NewPatch )
	D0 		      A0

	struct Patch *InstallPatch( struct NewPatch * );

    FUNCTION
	Opens a library and installs a user provided routine to a library
	function.

	Before you call InstallPatch(), you must initialize an instance of
	a NewPatch structure.  NewPatch is a structure that contains
	all of the arguments needed to install a patch.  The NewPatch
	structure may be discarded immediately after it is used to install
	the patch.

    INPUTS
	NewPatch = pointer to an instance of a NewPatch structure
		       containing the following fields

		NPAT_NewCode:
			Pointer to the patch code to be installed.
			If NPAT_PRI is >= 0 then your patch code gets all
			registers set to the same values as the program
			that called the function.
			If NPAT_PRI is < 0 then your patch code gets all
			registers set to the same values as the library
			function returned them.
			It is up to the patch code to keep the registers
			intact, when it returns with 'rts'.
			Due to the internal implementation of the patches,
			library functions patched with patch.library
			require four bytes more stack.  This might cause in
			very rare cases crashes due to stack overflow.
		NPAT_NewCodeSize:
			Optional length of the patch code to be installed.
			If this field is set to the correct value
			the PC-RELATIVE patch code starting at NPAT_NewCode
			will be copied to an internal Buffer.
			So it is possible to deallocate the patch code
			after InstallPatch returns.
		NPAT_LibraryName:
			Pointer to the name of the library, which contains
			the function to patch.
			( as in exec.library/OpenLibrary() )
		NPAT_LibVersion:
			version of the Library to open should be specified,
			if a function is available only from a certain
			library version on.
			( as in exec.library/OpenLibrary() )
		NPAT_LVO:
			Library Offset Vector (LVO) of the function to patch
		NPAT_Priority:
			Priority of the patch
			valid range: -127...+126
			It indicates the sequence of patches, if
			more than one patch for a function is installed.
			The original code has a priority of 0.
			Priority:    Meaning:
			>0: patch will be executed before the original
			<0: patch will be executed after the original
			=0: patch will be executed instead of the original
		NPAT_Flags:
			No flags are used and this field will be ignored
			( keep zero )
		NPAT_PatchName:
			An optional pointer to a string, which can be used
			to search for a patch with FindPatch().
			The null-terminated string will be copied, so you
			may free its memory when InstallPatch() returns.
			The string should contain the name of your program
			to identify the program that installed the task.
		NPAT_Result2:
			An optional pointer to a longword, which will contain
			an errorcode as defined later. Assembler programmers
			can always find this in d1, too.

    RESULT
        Patch = pointer to a patch structure or NULL on failure
 		    This structure is totally PRIVATE, so hands off.

    NOTES

    BUGS

    SEE ALSO
	WaitRemovePatch(), RemovePatch(), Patch.h,
	exec.library/OpenLibrary()


 patch.library/WaitRemovePatch

    NAME
	WaitRemovePatch -- Waits until it is possible to remove a patch.

    SYNOPSIS
	Error = WaitRemovePatch( Patch )
	D0		         A0

	ULONG Error WaitRemovePatch( struct Patch * );

    FUNCTION
	Waits until no task is using the library function.
	Then RemovePatch() will be called to remove the patch.

	All allocated resources for that specific patch will
	be deallocated.

    INPUTS
	Patch = pointer to the PRIVATE patch structure or NULL for no action

    RESULT
        Error = Errorcodes as defined in Patch.h.
		    All errorcodes as from RemovePatch() except
		    PATERR_PatchInUse are possible.

    NOTES
	Removing a patch routine can never be made absolutely save.
	Although patch.library does anything possible to provide methods
	to minimize the chance of a crash, there will always be a
	slight chance.
	So minimize the number of install and remove operations.

    BUGS

    SEE ALSO
	RemovePatch(), Patch.h


 patch.library/RemovePatch

    NAME
	RemovePatch -- Removes a patch installed by InstallPatch().

    SYNOPSIS
	Error = RemovePatch( Patch )
	D0	             A0

	ULONG Error RemovePatch( struct Patch * );

    FUNCTION
	Removes a patch from a library function.

	All allocated resources for that specific patch will
	be deallocated.

    INPUTS
	Patch = pointer to the PRIVATE patch structure or NULL for no action

    RESULT
        Error = Errorcodes as defined in Patch.h.
		PATERR_Ok
			Indicates success of the operation.
		PATERR_PatchInUse
			Indicates that some other task is using the
			installed function and can't be removed now.
			Your task may wait and try again later.
		PATERR_PatchInstalled
			Indicates that a patchcode has been installed for
			that function after your patch.library patch has
			been installed and your patch is the only
			patch.library patch for that function.
			If patch.library would remove your patch
			tasks would jump into deallocated memory
			Result:  blinking borders.
		PATERR_InvalidHandle
			Indicates that the pointer you passed to
			RemovePatch() was not or no longer valid.
			This might happen, if you pass a wrong pointer or
			you got the pointer via FindPatch() and another
			task has removed the patch before this task called
			RemovePatch().

    NOTES
	Removing a patch routine can never be made absolutely save.
	Although patch.library does anything possible to provide methods
	to minimize the chance of a crash, there will always be a
	slight chance.
	So minimize the number of install and remove operations.

    BUGS

    SEE ALSO
	WaitRemovePatch(), Patch.h


 patch.library/FindPatch

    NAME
	FindPatch -- find a patch structure with a given name.

    SYNOPSIS
	Patch = FindPatch( Name )
	D0		   A0

	struct Patch *FindPatch( STRPTR );

    FUNCTION
	This function will search the patch.library private lists for a
	patch structure with the given name. The first patch matching
	this name will be returned.

    INPUTS
	Name = Name of the patch structure to find

    RESULT
	Patch = a pointer to the patch structure with the same name else
	    zero to indicate that the string was not found.

    NOTES
	If your task is not the owner of the patch, the
	pointer is only valid as long as the system is in forbid.

    BUGS

    SEE ALSO
	WaitRemovePatch(), RemovePatch(), Patch.h

