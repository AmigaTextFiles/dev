
\magnification = \magstep2

\font\titlefont=cmbx10 scaled \magstep3 
\font\sectionfont=cmr10 scaled \magstep2
\font\magone=cmr10 scaled \magstep1
\font\magonebf=cmbx10 scaled \magstep1 
\font\magtwo=cmr10 scaled \magstep2
\font\magtwobf=cmbx10 scaled \magstep2 
\font\magthree=cmr10 scaled \magstep3
\font\magthreebf=cmbx10 scaled \magstep3 
\font\magfour=cmr10 scaled \magstep4
\font\magfourbf=cmbx10 scaled \magstep4 
 
\font\bigone=cmr10 scaled \magstep1
\font\bigtwo=cmr10 scaled \magstep2
\font\bigthree=cmr10 scaled \magstep3
\font\bigfour=cmr10 scaled \magstep4

\hsize=16truecm
\hoffset=1.9truecm    % +0.5 cm 
\vsize=24.5truecm
\voffset=1.7truecm    % +1 cm

\baselineskip 14pt
\spaceskip  .4em plus .25em minus .25em
\xspaceskip .65em

\parindent 0pt
\parskip 11pt plus 1pt minus 1pt 

\def\CC{C\raise.08ex\hbox{\tt ++\ }}
\def\nat{\hbox{\rm\vrule\kern-0.045em N}}
\def\real{\hbox{\rm\vrule\kern-0.035em R}}
\def\nl{\hfill\break}
\def\'{^\prime}
\def\beginitem   {\parindent 20pt }
\def\enditem     {\parindent 0pt }
\def\refstart #1 {\parindent #1 }
\def\refend      {\parindent 0pt }
\def\ref #1 #2   {\item {\hbox to \parindent {\bf \ [#1] \hfill}} #2}

%

\def\op #1 #2 #3 #4 {& $#1$ & \var.#2($#3$) & #4\cr}

\def\friend #1 #2 #3 #4 {& $#1$ & #2($#3$) & #4\cr}

\def\opr #1 #2 #3 {& $#1$ & \var$#2$ & #3\cr}

\def\nop #1       {&&& #1\cr}

\def\decl #1 #2 
{{\bf declare}($#1, #2$) \def\type {#1} \def\name {$#1(#2)$} }

\def\decltwo #1 #2 #3 
{{\bf declare2}($#1, #2, #3$) \def\type {#1} \def\name {$#1(#2,#3)$} }

\def\declthree #1 #2 #3 #4
{{\bf declare2}($#1, #2, #3, #4$) \def\type {#1} \def\name {$#1(#2,#3,#4)$} }

\def\create #1 #2 { \name\ \ $#1 #2$; \def\var {$#1$} }


\def\operations  {Operations on a \type\ \var}

\def\precond {{\it Precondition}: }


% C++ reserved words:

\def\If       {{\bf if} }
\def\Else     {{\bf else} }
\def\Do       {{\bf do} }
\def\For      {{\bf for} }
\def\While    {{\bf while} }
\def\Return   {{\bf return} }
\def\Break    {{\bf return} }
\def\Continue {{\bf continue} }
\def\Case     {{\bf case} }
\def\Switch   {{\bf switch} }
\def\Class    {{\bf class} }
\def\Struct   {{\bf struct} }
\def\Public   {{\bf public} }
\def\Friend   {{\bf friend} }
\def\Typedef  {{\bf typedef} }

\def\n {$\backslash$n}


% LEDA macros:

\def\Forall         {{\bf forall} }
\def\Forallnodes    {{\bf forall\_nodes} }
\def\Foralledges    {{\bf forall\_edges} }
\def\Foralladjnodes {{\bf forall\_adj\_nodes} }
\def\Foralladjedges {{\bf forall\_adj\_edges} }



\nopagenumbers


\#include $<$LEDA/graph.h$>$\nl 
\medskip
\cleartabs
\+void DIJKSTRA(& graph $G$, node $s$, edge\_array(int) $cost$, node\_array(int) $dist$)\cr
\smallskip
\+\cleartabs 
  $\{$ &\cr
\+     & node\_pq(int) $PQ(G)$;\cr
\smallskip
\+     &node $u,v$;\cr
\+     &edge $e$;\cr
\+     &int $c$;\cr
\medskip
\+     &{\bf forall\_nodes}($v,G$)\cr
\+     &\ \ \ &$\{$ & $dist[v] = infinity$;\cr
\+     &      &     & $PQ$.insert($v,dist[v])$;\cr
\+     &      &\ $\}$\cr
\medskip
\+     &$dist[s] = 0$;\cr
\+     &$PQ$.decrease\_inf($s,0)$;\cr
\medskip
\+     &{\bf while} ( ! $PQ$.empty())\cr
\+     &\ \ \ &$\{$ &$u = PQ$.delete\_min()\cr
\medskip
\+     &      &     &{\bf forall\_adj\_edges}($e,u$)\cr
\+     &      &     &\ \ \ &$\{$ &$v = G.target(e) $;       \cr
\+     &      &     &      &     &$c = dist[u] + cost[e] $;\cr
\+     &      &     &      &     &{\bf if} ( $c < dist[v] $)\cr
\+     &      &     &      &     &\ \ &$\{$ &$dist[v] = c$;\cr
\+     &      &     &      &     &    &     &$PQ$.decrease\_inf($v,c$);\cr
\+     &      &     &      &     &    &\ $\}$\cr
\+     &      &     &      &\ $\}$ \cr
\medskip
\+     &      &\ $\}$ \cr
\medskip
\+\ $\}$\cr

\vfill\eject


\vglue 15truecm

\#include $<$LEDA/d\_array.h$>$
\medskip
\cleartabs
\+main()\cr
\+$\{$\ \ &\cr
\+  &d\_array(string,int) $Anzahl(0)$;\cr
\medskip
\+  &string $w$;\cr
\medskip
\+  &{\bf while} &(cin $>>$ $w$) $Anzahl[w]++$;\cr
\medskip
\+  &{\bf forall\_defined}($w,Anzahl$) 
            printf("\%s\ \ \%d$\backslash$n", $w$, $Anzahl[w]$);\cr
\smallskip
\+\ $\}$\cr


\bye
