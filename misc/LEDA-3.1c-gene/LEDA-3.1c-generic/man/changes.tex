\input hp.mac

\input LEDA.mac

\baselineskip 14pt
\spaceskip  .4em plus .25em minus .25em
\xspaceskip .65em

\parskip 11pt plus 1pt minus 1pt

\pageno=121

{\magtwobf Changes  with respect to version 2.0}
\bigskip

{\magonebf 1.6 Input and output}
\bigskip

The overloaded $Read$ and $Write$ functions for defining input and output 
functions for user defined pointer types now have an additional stream argument.

$void$\ \  $Read(T\&,\ istream\&)$  $\{$ \dots $\}$\nl
defines an input function for reading objects of type $T$ from an input stream.

$void$\ \  $Print(T\&,\ ostream\&)$  $\{$ \dots $\}$ \nl
defines an output function for printing objects of type $T$ to an output stream.


\+\cleartabs & \hskip 2truecm & \hskip 5.5truecm &\cr

\bigskip
{\magonebf 3.1 One Dimensional Arrays (array)}
\bigskip
\def\var  {$A$}
\+\op  void      sort {int\ (*cmp)(E\&, E\&),\ int\ l,\ int\ h}  {}
\+\nop                      {applies the sorting operation to the sub-array}
\+\nop                      {\var$[l..h]$.}
\medskip
\+\op void       read {istream\ I}
                            {reads $b-a+1$ objects of type $E$ from the input}
\+\nop                      {stream $I$ into the array $A$ using the overloaded}
\+\nop                      {$Read$ function (section 1.6)}
\smallskip
\+\op void       read {}
                            {Calls $A$.read($cin$) to read $A$ from}
\+\nop                      {the standard input stream $cin$.}
\smallskip
\+\op void       read {string\ s}
                            {As above, but uses string $s$ as a prompt.}
\smallskip
\+\op void       print {ostream\ O,\ char\ space = '\ '}    {} 
\+\nop                      {Prints the contents of array $A$ to the output}
\+\nop                      {stream $O$ using the overload $Print$ function}
\+\nop                      {(section 1.5) to print each element. The elements}
\+\nop                      {are separated by the space character $space$.}
\smallskip
\+\op void       print {char\ space = '\ '}
                            {Calls $A$.print($cout$, $space$) to print $A$ on}
\+\nop                      {the standard output stream $cout$.}
\smallskip
\+\op void       print {string\ s,\ char\ space = '\ '}    {} 
\+\nop                      {As above, but uses string $s$ as a header.}


\vfill\eject

\bigskip
{\magonebf 3.7 Linear Lists (list)}
\bigskip
\def\var {$L$}
\+\op void       read {istream\ I,\ char\ delim = '\backslash n'}     {}
\+\nop                      {reads a sequence of objects of type $E$ terminated}
\+\nop                      {by the delimiter $delim$ from the input stream $I$}
\+\nop                      {using the overloaded $Read$ function (section 1.5)}
\+\nop                      {$L$ is made a list of appropriate length and the}
\+\nop                      {sequence is stored in $L$.}
\smallskip
\+\op void       read {char\ delim = '\backslash n'}
                            {Calls $L$.read($cin$, $delim$) to read $L$ from}
\+\nop                      {the standard input stream $cin$.}
\smallskip
\+\op void       read {string\ s,\ char\ delim = '\backslash n'}     {}
\+\nop                      {As above, but uses string $s$ as a prompt.}
\smallskip
\+\op void       print {ostream\ O,\ char\ space = '\ '}    {} 
\+\nop                      {Prints the contents of list $L$ to the output}
\+\nop                      {stream $O$ using the overload $Print$ function}
\+\nop                      {(section 1.5) to print each element. The elements}
\+\nop                      {are separated by the space character $space$.}
\smallskip
\+\op void       print {char\ space = '\ '}
                            {Calls $L$.print($cout$, $space$) to print $L$ on}
\+\nop                      {the standard output stream $cout$.}
\smallskip
\+\op void       print {string\ s,\ char\ space = '\ '}    {} 
\+\nop                      {As above, but uses string $s$ as a header.}


\bigskip
{\magonebf 5.4  Parameterized Graphs (GRAPH)}
\bigskip
\def\var {$G$}
\+\op void   write {string\ fname}        
                          {writes $G$ to the file with name $fname$. The}
\+\nop                    {overloaded functions $Print(vtype,ostream)$}
\+\nop                    {and $Print(etype,ostream)$ (cf.~section 1.6)}
\+\nop                    {are used to write the node and edge entries}
\+\nop                    {of $G$ respectively.}
\smallskip
\+\op int    read {string\ fname}         
                          {reads $G$ from the file with name $fname$. The}
\+\nop                    {overloaded functions $Read(vtype,istream)$}
\+\nop                    {and $Read(etype,istream)$ (cf.~section 1.6)}
\+\nop                    {are used to read the node and edge entries}
\+\nop                    {of $G$ respectively. Returns error code}
\+\nop                    {1 \quad if file $fname$ does not exist}
\+\nop                    {2 \quad if graph is not of type $GRAPH(vtype,etype)$}
\+\nop                    {3 \quad if file $fname$ does not contain a graph}
\+\nop                    {0 \quad otherwise.}

\vfill\eject

\bigskip
{\magonebf 6.3 Sets of two-dimensional points (point\_set)}
\bigskip
\def\var  {$S$}
\+\cleartabs & \hskip 3truecm & \hskip 4.5truecm &\cr
\+\op list(ps\_item) convex\_hull {} {}
\+\nop                {returns the list of items containing}
\+\nop                {all points of the convex hull of \var}
\+\nop                {in clockwise order.}


\bigskip
{\magonebf 6.1.6 Plane Algorithms}
\bigskip

$\bullet$ {\bf Voronoi Diagrams}

$void$\quad VORONOI$(list(point)\& \ sites,\ real\ R,\ GRAPH(point,point)\&\ G)$

VORONOI takes as input a list of points  $sites$ and a real number 
$R$. It computes a directed graph $G$ representing the planar subdivision
defined by the Voronoi-diagram of $sites$ where all ``infinite" edges have
length $R$. For each node $v$ $G$.inf($v$) is the corresponding Voronoi 
vertex ($point$) and for each edge $e$  $G$.inf($e$) is the site ($point$) 
whose Voronoi region is bounded by $e$. 

\bigskip
{\magonebf 6.7  Graphic Windows (window)}

Data type $gwindow$ no longer exists, it is replaced by data type $window$

The data type $window$ provides an interface for the input and 
output of basic two-dimensinal geometric objects (cf.~section 5.1) 
using the X11 (xview) or SunView window system.
There are two object code libraries (libWs.a, libWx.a) containing 
implementations for different environments. Application programs using data type
$window$ have to be linked with one of these libraries (cf.~section~1.6):

\beginitem
\item{ a)} 
For the SunView window system:\nl
CC $prog.c$ -lWs -lP -lG -lL -lm  -lsuntool -lsunwindow -lpixrect

\item{ b)} 
For the X11 (open windows) window system:\nl
CC $prog.c$ -lWx -lP -lG -lL -lm  -lxview -lolgx -lX11 

\enditem

\vfill\eject

{\bf Creation of a graphic window }
\bigskip
\cleartabs
\bigskip
\+a) &$window$ $W(int\ xpix,\ int\ ypix,\ int\ xpos,\ int\ ypos)$;\cr
\bigskip
\+b) &$window$ $W(int\ xpix,\ int\ ypix)$;\cr
\bigskip
\+c) &$window$ $W()$;\cr
\bigskip

Variant a) creates a window $W$ of physical size $xpix \times ypix$ pixels 
with its upper left corner at position ($xpos,ypos$) on the screen,
variant b) places $W$ into the upper right corner of the screen, and
variant c) creates a $850 \times 850$ pixel window positioned into the
upper right corner.

All three variants initialize the coordinates of $W$ to $x0 = 0$,
$x1 = 100$ and $y0 = 0$. The $init$ operation (see  below) can later 
be used to change the window coordinates and scaling.


{\bf Additional operations:}

\bigskip
\bigskip
\def\var {$W$}
\+\op int  read\_panel {string\ h,\ int\ n,\ string*\ S} {}
\+\nop           {displays a panel with header $h$ and an array $S[1..n]$ }
\+\nop           {of $n$ string items, returns the index of the selected}
\+\nop           {item.}
\medskip
\+\op int  read\_vpanel {string\ h,\ int\ n,\ string*\ S} {}
\+\nop           {like read\_panel with vertical button layout}
\medskip
\+\op int  read\_int {string\ p} {}
\+\nop           {displays a panel with prompt $p$ for integer input,}
\+\nop           {returns the input}
\medskip
\+\op real  read\_real {string\ p} {}
\+\nop           {displays a panel with prompt $p$ for real input}
\+\nop           {returns the input}
\medskip
\+\op string  read\_string {string\ p} {}
\+\nop           {displays a panel with prompt $p$ for string input,}
\+\nop           {returns the input}
\medskip
\+\op string  read\_string {string\ p,\ list(string)\ menu} {}
\+\nop           {as above, adds an additional menu button which}
\+\nop           {can be used to select a string from $menu$.}
\medskip
\+\op string  read\_string {string\ p,\ string\ label,\ list(string)\ menu} {}
\+\nop           {as above, the menu button is labelled with $label$.}
\medskip


\vfill\eject



{\magonebf 7.1 Streams}

The stream data types described in this section are all derived from
the \CC stream types $istream$ and $ostream$. Some of these types 
may be obsolete in combination with some of the latest versions of the 
standard \CC I/O library.


\bigskip
{\magonebf 7.1.3 String input streams (string\_istream)}

An instance $I$ of the data type $string\_istream$ is an \CC istream
connected to a string $s$, i.e., all input operations or operators
applied to $I$ read from $s$. 

{\bf 1. Creation of a string input stream} 

$string\_istream\ \ \ I(string\ s)$;

creates an instance $I$ of type string\_istream connected to the string $s$.

{\bf 2. Operations} 

All operations and operators ($>>$) defined for \CC istreams can
be applied to string input streams as well.

\bigskip
{\magonebf 7.1.4 String output streams (string\_ostream)}

An instance $O$ of the data type $string\_ostream$ is an \CC ostream
connected to an internal string buffer, i.e., all output operations 
or operators applied to $O$ write into this internal buffer.  The current
value of the buffer is called the contents of $O$.

{\bf 1. Creation of a string output stream} 

$string\_ostream\ \ \ O$;

creates an instance $O$ of type string\_ostream.

{\bf 2. Operations} 
\medskip
\cleartabs
\+\hskip 1.8truecm &\hskip 5truecm &\cr
\medskip
\+string      &O.clear()  &clears the contents of $O$\cr
\medskip
\+string      &O.str()    &returns the current contents of $O$\cr
\smallskip

All operations and operators ($<<$) defined for \CC ostreams can
be applied to string output streams as well.

\bigskip
{\magonebf 7.1.5 Command input streams (cmd\_istream)}

An instance $I$ of the data type $cmd\_istream$ is an \CC istream
connected to the output of a shell command $cmd$, i.e., all input operations 
or operators applied to $I$ read from the standard output of command $cmd$. 

{\bf 1. Creation of a command input stream} 

$cmd\_istream\ \ \ in(string\ cmd)$;

creates an instance $in$ of type cmd\_istream connected to the output of command $cmd$.

{\bf 2. Operations} 

All operations and operators ($>>$) defined for \CC istreams can
be applied to command input streams as well.


\bigskip
{\magonebf 7.1.6 Command output streams (cmd\_ostream)}

An instance $O$ of the data type $cmd\_ostream$ is an \CC ostream
connected to the input of a shell command $cmd$, i.e., all output operations 
or operators applied to $O$ write into the standard input of command $cmd$. 

{\bf 1. Creation of a command output stream} 

$cmd\_ostream\ \ \ out(string\ cmd)$;

creates an instance $out$ of type cmd\_ostream connected to the input of 
command $cmd$. 

{\bf 2. Operations} 

All operations and operators ($<<$) defined for \CC ostreams can
be applied to command output streams as well.

\vfill\eject
\bye
