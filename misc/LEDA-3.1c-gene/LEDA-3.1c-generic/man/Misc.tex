{\magtwo 7. Miscellaneous}
\bigskip
\bigskip

This section describes some additional useful data types, functions and
macros of LEDA. They can be used in any program that includes the
$<$LEDA/basic.h$>$ header file.

\bigskip
\bigskip
{\magonebf 7.1 Streams}

The stream data types described in this section are all derived from
the \CC stream types $istream$ and $ostream$. Some of these types 
may be obsolete in combination with the latest versions of the 
standard \CC I/O library.

\bigskip
\bigskip
{\magonebf 7.1.1 File input streams (file\_istream)}

{\bf 1. Definition}

An instance $I$ of the data type $file\_istream$ is an \CC istream
connected to a file $F$, i.e., all input operations or operators
applied to $I$ read from $F$. 

{\bf 2. Creation}

$file\_istream\ \ \ I(string\ s)$;

creates an instance $I$ of type file\_istream connected to the file with
name $s$.

{\bf 3. Operations} 

All operations and operators ($>>$) defined for \CC istreams can
be applied to file input streams as well.

\bigskip
\bigskip
{\magonebf 7.1.2 File output streams (file\_ostream)}

{\bf 1. Definition}

An instance $O$ of the data type $file\_ostream$ is an \CC ostream
connected to a file $F$, i.e., all output operations or operators
applied to $O$ write to $F$. 

{\bf 2. Creation}

$file\_ostream\ \ \ O(string\ s)$;

creates an instance $O$ of type file\_ostream connected to the file with
name $s$.

{\bf 3. Operations} 

All operations and operators ($<<$) defined for \CC ostreams can
be applied to file output streams as well.

\bigskip
{\magonebf 7.1.3 String input streams (string\_istream)}

{\bf 1. Definition}

An instance $I$ of the data type $string\_istream$ is an \CC istream
connected to a string $s$, i.e., all input operations or operators
applied to $I$ read from $s$. 

{\bf 2. Creation}

$string\_istream\ \ \ I(string\ s)$;

creates an instance $I$ of type string\_istream connected to the string $s$.

{\bf 3. Operations} 

All operations and operators ($>>$) defined for \CC istreams can
be applied to string input streams as well.

\bigskip
{\magonebf 7.1.4 String output streams (string\_ostream)}

{\bf 1. Definition}

An instance $O$ of the data type $string\_ostream$ is an \CC ostream
connected to an internal string buffer, i.e., all output operations 
or operators applied to $O$ write into this internal buffer.  The current
value of the buffer is called the contents of $O$.

{\bf 2. Creation}

$string\_ostream\ \ \ O$;

creates an instance $O$ of type string\_ostream.

{\bf 3. Operations} 
\medskip
\cleartabs
\+\hskip 1.8truecm &\hskip 5truecm &\cr
\medskip
\+string      &O.clear()  &clears the contents of $O$\cr
\medskip
\+string      &O.str()    &returns the current contents of $O$\cr
\smallskip

All operations and operators ($<<$) defined for \CC ostreams can
be applied to string output streams as well.


\bigskip
{\magonebf 7.1.5 Command input streams (cmd\_istream)}

{\bf 1. Definition}

An instance $I$ of the data type $cmd\_istream$ is an \CC istream
connected to the output of a shell command $cmd$, i.e., all input operations 
or operators applied to $I$ read from the standard output of command $cmd$. 

{\bf 2. Creation}

$cmd\_istream\ \ \ I(string\ cmd)$;

creates an instance $I$ of type cmd\_istream connected to the output of command $cmd$.

{\bf 3. Operations} 

All operations and operators ($>>$) defined for \CC istreams can
be applied to command input streams as well.

\bigskip
{\magonebf 7.1.6 Command output streams (cmd\_ostream)}

{\bf 1. Definition}

An instance $O$ of the data type $cmd\_ostream$ is an \CC ostream
connected to the input of a shell command $cmd$, i.e., all output operations 
or operators applied to $O$ write into the standard input of command $cmd$. 

{\bf 2. Creation}

$cmd\_ostream\ \ \ O(string\ cmd)$;

creates an instance $O$ of type cmd\_ostream connected to the input of 
command $cmd$. 

{\bf 3. Operations} 

All operations and operators ($<<$) defined for \CC ostreams can
be applied to command output streams as well.


\bigskip
\bigskip
{\magonebf 7.2 Some useful functions and macros}
\smallskip
\cleartabs
\+\hskip 1.8truecm &\hskip 5truecm &\cr
\medskip
\+int      &read\_int(string $s$ = ``'')    
                             &prints $s$ and reads an integer\cr
\smallskip
\+char     &read\_char(string $s$ = ``'')   
                             &prints $s$ and reads a character\cr
\smallskip
\+double   &read\_real(string $s$ = ``'')   
                             &prints $s$ and reads a real number\cr
\smallskip
\+string   &read\_string(string $s$ = ``'') 
                             &prints $s$ and reads a line of input\cr
\smallskip
\+bool     &Yes(string $s$ = ``'')          
                             &returns (read\_char($s$) == `y')\cr
\bigskip
\+void   &init\_random()     &initializes the random number generator.\cr
\smallskip
\+double &random()           &returns a real valued random number in $[0,1]$\cr
\smallskip
\+int    &random(int a, int b) &returns a random integer in $[a..b]$\cr
\bigskip
\+float &used\_time()       &returns the currently used cpu time in seconds.\cr
\smallskip
\+float &used\_time(float\& $T$)  
                             &returns the cpu time used by the program from\cr
\+      &                    &$T$ up to this moment and assings the current\cr
\+      &                    &time to $T$.\cr
\smallskip
\+void  &print\_statistics() &prints a summary of the currently used memory\cr

\bigskip
\cleartabs
\+{\bf newline} \hskip 2truecm   &cout $<<$ ``\n"\cr
\+\cr
\+{\bf forever}                  &for(;;)\cr
\+\cr
\+{\bf loop(a,b,c)}              &for ($a=b;a<=c;a++$)\cr
\+\cr
\+{\bf Max(a,b)}                 &($(a>b)\ ?\ a\ :\ b$)\cr
\+\cr
\+{\bf Min(a,b)}                 &($(a>b)\ ?\ b\ :\ a$)\cr


\vfill\eject

\bigskip
\bigskip
{\magonebf 7.3 Memory Management}

LEDA offers an efficient memory management system that is used internally 
for all node, edge and item types. This system can easily be customized for 
user defined classes by the ``LEDA\_MEMORY" macro. You simply have
to add the macro call ``LEDA\_MEMORY($T$)" to the declaration of a class
$T$. This creates new and delete operators for type $T$ allocating and
deallocating memory using LEDA's internal memory manager. We continue
the example from section 1.5:
\medskip
\cleartabs
\+{\bf struct} $pair$ $\{$\cr
\+\quad &$double\ \ x$;\cr
\+      &$double\ \ y$;\cr
\+\cr
\+&$pair()\ \{\ x = y = 0;\ \}$\cr
\+&$pair($const $pair\&\ p)\ \{\ x = p.x;\ y = p.y;\ \}$\cr
\+\cr
\+&friend $ostream$\& \ &operator\<\<($ostream$\&,const $pair$\&) $\{$ \dots $\}$\cr
\+&friend $istream$\& \ &operator\>\>($istream$\&,$pair$\&) $\{$ \dots $\}$\cr
\+&friend $int$         &compare(const $pair\&\ p$, const $pair\&\ q$) $\{$ \dots $\}$\cr
\+\cr
\+&LEDA\_MEMORY($pair$)\cr
\+$\}$;\cr
\smallskip
dictionary\<$pair$,$int$\> D;


\bigskip
\bigskip
{\magonebf 7.4 Error Handling}

LEDA tests the preconditions of many (not all!) operations. Preconditions
are never tested, if the test takes more than constant time. If the test
of a precondition fails an error handling routine is called. It takes 
an integer error number $i$ and a $char*$ error message string $s$ as 
arguments. It writes $s$ to the diagnostic output (cerr) and terminates 
the program abnormally if $i \ne 0$.
Users can provide their own error handling function $handler$ by calling 
\smallskip
set\_error\_handler($handler$).
\smallskip 
After this function call $handler$ is used instead of the default error 
handler. $handler$ must be a function of type  $void\ \ handler(int,char*)$. 
The parameters are replaced by the error number and the error message
respectively.

\vfill\eject

\vglue 10cm
\vfill\eject

