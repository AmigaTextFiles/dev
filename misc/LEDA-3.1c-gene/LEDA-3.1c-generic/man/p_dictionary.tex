
{\magonebf 4.7 Persistent Dictionaries (p\_dictionary)}

\decltwo p\_dictionary K I

{\bf 1. Definition}

The difference between dictionaries (cf.~section~4.3) and persistent 
dictionaries lies in the fact that update operations performed 
on a persistent dictionary $D$ do not change $D$ but create and return a 
new dictionary $D\'$. For example, $D$.del($k$) returns the dictionary $D\'$ 
containing all items $it$ of $D$ with key($it$) $\ne$ $k$. 

An instance $D$ of the parameterized data type \name\ is a set 
of items (type $p\_dic\_item$). Every item in $D$ contains a key from the 
linearly ordered data type $K$, called the key type of $D$, and an information 
from data type $I$, called the information type  of $D$. The number of items in 
$D$ is called the size of $D$. A dictionary of size zero is called empty. 
We use $<k,i>$ to denote an item with key $k$ and information 
$i$ ($i$ is said to be the information associated with key $k$).  For each 
$k \in K$ there is at most one item $<k,i> \in D$.


\bigskip
{\bf 2. Creation}

\create D {}

creates an instance \var\ of type \name\ and initializes \var\ to an 
empty persistent dictionary. 



\bigskip
{\bf 3. Operations}

\+\cleartabs & \hskip 3.8truecm & \hskip 4truecm &\cr
\+\op K         key {p\_dic\_item\ it}  
                              {returns the key of item $it$.}
\+\nop                        {\precond $it$ $\in$ \var.}
\smallskip
\+\op I         inf {p\_dic\_item\ it}  
                              {returns the information of item $it$.}
\+\nop                        {\precond $it$ $\in$ \var.}
\smallskip
\+\op p\_dic\_item lookup {K\ k} 
                              {returns the item with key $k$ (nil if no such}
\+\nop                        {item exists in \var).}
\smallskip
\+\op I         access {K\ k} 
                              {returns the information associated with $k$}
\+\nop                        {\precond there is an item with key $k$}
\+\nop                        {in \var.}
\smallskip
\+\op p\_dictionary(K,I) del {K\ k}         
                              {returns $\{\ x \in \var\ |\ key(x) \ne k\ \}$.}
\smallskip
\+\op p\_dictionary(K,I) del\_item {p\_dic\_item\ it}    {}
\+\nop                        {returns $\{\ x \in \var\ |\ x \ne it\ \}$.}
\smallskip
\+\op p\_dictionary(K,I) insert {K\ k,\ I\ i} 
                              {returns \var.del($k$) $\cup$ $\{<k,i>\}$.}
\smallskip
\+\op p\_dictionary(K,I) change\_inf {p\_dic\_item\ it,\ I\ i}  {}
\+\nop                        {Let $k = key(it)$, returns \var.del\_item($it$) $\cup$} 
\+\nop                        {$\{<k,i>\}$. \precond $it$ $\in$ \var.}
\smallskip 
\+\op p\_dictionary(K,I) clear {}      
                              {returns an empty persistent dictionary.}
\smallskip
\+\op bool      empty {}      
                              {returns true if \var\ is empty, false otherwise.}
\smallskip 
\+\op int       size {}       
                              {returns the size of \var.}

\bigskip
{\bf 4. Implementation}

Persistent Dictionaries are implemented by leaf oriented 
persistent red black trees (cf.~[DSST89]).
Operations insert, lookup, del\_item, del take time $O(\log n)$, key, inf, 
empty, size, change\_inf and clear take time $O(1)$. The space requirement is
$O(1)$ for each update operation.
 
%\bigskip
%{\bf 5. Example}
%\medskip
%\input prog/p_dic.prog

