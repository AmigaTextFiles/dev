{\magonebf  6.7 Graphic Windows (window)}

{\bf 1. Definition}

The data type $window$ provides an interface for the input and 
output of basic two-dimensional geometric objects (cf.~section 5.1) using the 
X11 or SunView window system. There are two object code libraries libWx11.a, 
and libWxview.a containing implementations for both the basic X11 and the xview 
environments. Application programs using data type $window$ have to 
be linked with one of these libraries (cf.~section~1.6):

\beginitem
\item{ a)} 
For the X11 window system:\nl
CC $prog.c$ -lP -lG -lL -lWx11 -lX11 -lm

\item{ b)} 
For the xview environment:\nl
CC $prog.c$ -lP -lG -lL -lWx11 -lxview -lolgx -lX11 -lm
\enditem


An instance $W$ of the data type $window$ is an iso-oriented 
rectangular window in the two-dimensional plane. 
The default representation of $W$ on the screen is a 850 $\times$ 850 pixel
square positioned in the upper right corner (cf.~creation, variant c)).
The coordinates and scaling of $W$ used for drawing operations are defined 
by three double parameters: 
$x_0$, the x-coordinate of the left side, $x_1$, the x-coordinate of the right 
side, and $y_0$, the y-coordinate of the bottom side. 
The y-coordinate of the top side of $W$ is determined by the current size and 
shape of the window on the screen, which can be changed interactively. 
A graphic window supports operations for drawing points, lines, segments, 
arrows, circles, polygons, graphs, \dots and for graphical input of all these 
objects using the mouse input device. Most of the drawing operations have an 
optional color argument. Possible colors are $black$ (default), $white$,
$blue$, $green$, $red$, $violet$, and $orange$. On monochrome displays all 
colors different from $white$ are turned to $black$. There are 6 parameters 
used by the drawing operations:
\beginitem
\item {1. } 
The {\sl line width} parameter (default value 1 pixel) defines the width of all 
kinds of lines (segments, arrows, edges, circles, polygons). 

\item {2. }
The {\sl line style} parameter defines the style of lines. Possible line 
styles are $solid$ (default), $dashed$, and $dotted$. 

\item {3. }
The {\sl node width} parameter (default value 10 pixels) defines the diameter 
of nodes created by the draw\_node and draw\_filled\_node operations.

\item {4. }
The {\sl text mode} parameter defines how text is inserted into the window.
Possible values are $transparent$ (default)  and $opaque$.

\item {5. }
The {\sl drawing mode} parameter defines the logical operation that is used
for setting pixels in all drawing operations. Possible values are
$src\_mode$ (default) and $xor\_mode$. In $src\_mode$ pixels are set to 
the respective color value, in $xor\_mode$ the value is bitwise added to the 
current pixel value.

\item {6. }
The {\sl redraw function} parameter is used to redraw the entire window, 
whenever a redrawing is necessary, e.g., if the window shape on the screen 
has  been changed. Its type is pointer to a void-function taking no arguments,
i.e., void (*F)();
\enditem

\def\var {$W$}
\def\name {$window$}
\def\type {$window$}

\bigskip
{\bf 2. Creation}

a) \create W (int\ xpix,\ int\ ypix,\ int\ xpos,\ int\ ypos)

b) \create W (int\ xpix,\ int\ ypix)

c) \create W {}

Variant a) creates a window $W$ of physical size $xpix \times ypix$ pixels 
with its upper left corner at position ($xpos,ypos$) on the screen,
variant b) places $W$ into the upper right corner of the screen, and
variant c) creates a $850 \times 850$ pixel window positioned into the
upper right corner.

All three variants initialize the coordinates of $W$ to $x0 = 0$,
$x1 = 100$ and $y0 = 0$. The $init$ operation (see  below) can later 
be used to change the window coordinates and scaling.

\cleartabs
\+&\hskip 2.2truecm &\hskip 4truecm &\cr
{\bf 3. Operations}

\bigskip
{\bf 3.1 Initialization}
\medskip
\+\op void init {double\ x_0,\ double\ x_1,\ double\ y_0} {}
\+\nop          {sets the coordinates of $W$ to $x_0$,$x_1$, and $y_0$}
\medskip
\+\op void set\_grid\_mode {int\ d}  {}
\+\nop          {Adds a rectangular grid with integer coordinates and }
\+\nop          {grid distance $d$ to $W$, if $d > 0$. Removes grid from} 
\+\nop          {$W$, if $d\le 0$.}
\medskip
\+\op void init {double\ x_0,\ double\ x_1,\ double\ y_0,\ int\ d} {}
\+\nop          {like init($x_0,x_1,y_0$) followed by set\_grid($d$)}
\medskip
\+\op void clear {}   {$W$ is erased.}
\medskip

\vfill\eject

\bigskip
{\bf 3.2 Setting parameters}
\medskip
\+\op int set\_line\_width {int\ pix}  {}
\+\nop         {Sets the line width parameter to $pix$ pixels and }
\+\nop         {returns its previous value.}
\medskip
\+\op line\_style set\_line\_style {linestyle\ s}  {}
\+\nop         {Sets the line style parameter to $s$ and returns its }
\+\nop         {previous value.}
\medskip
\+\op int set\_node\_width {int\ pix}   {}
\+\nop         {Sets the node width parameter to $pix$ pixels and }
\+\nop         {returns its previous value.}
\medskip
\+\op text\_mode set\_text\_mode {text\_mode\ m}   {}
\+\nop         {Sets the text mode parameter to $m$ and returns}
\+\nop         {its previous value.}
\medskip
\+\op drawing\_mode set\_mode {drawing\_mode\ m}   {}
\+\nop         {Sets the drawing mode parameter to $m$ and returns}
\+\nop         {its previous value.}
\medskip
\+\op void set\_redraw {void\ (*F)()} {} 
\+\nop          {Sets the redraw function parameter to $F$.} 

\bigskip
{\bf 3.3 Reading parameters and window coordinates}
\bigskip
\+\op int         get\_line\_width {}      
                                           {returns the current line width.} 
\medskip
\+\op line\_style get\_line\_style {}      
                                           {returns the current line style.} 
\medskip
\+\op int         get\_node\_width {}      
                                           {returns the current node width.} 
\medskip
\+\op text\_mode  get\_text\_mode {}       
                                           {returns the current text mode.} 
\medskip
\+\op drawing\_mode  get\_mode {} {}
\+\nop                                     {returns the current drawing mode.} 
\medskip
\+\op double        xmin {}  
                           {returns $x_0$, the minimal x-coordinate of $W$.} 
\medskip
\+\op double        ymin {}  
                           {returns $y_0$, the minimal y-coordinate of $W$.} 
\medskip
\+\op double        xmax {}  
                           {returns $x_1$, the maximal x-coordinate of $W$.} 
\medskip
\+\op double        ymax {}  
                           {returns $y_1$, the maximal y-coordinate of $W$.} 
\medskip
\+\op double        scale {} 
                           {returns the number of pixels of a unit length}
\+\nop                     {line segment.}
\medskip

\vfill\eject

\bigskip
{\bf 3.4 Drawing points}
\bigskip
\+\op void draw\_point {double\ x,\ double\ y,\ color\ c=black} {}
\+\nop    {draws the point $(x,y)$ as a cross of a vertical}
\+\nop    {and a horizontal segment intersecting at $(x,y)$.}
\medskip
\+\op void draw\_point {point\ p,\ c=black}  {}
\+\nop    {draws point ($p$.xcoord(),$p$.ycoord()).}

\bigskip
{\bf 3.5 Drawing line segments}
\bigskip
\+\op void draw\_segment {double\ x_1,\ double\ y_1,\ double\ x_2,\ double\ y_2,\ color\ c=black} {}
\+\nop    {draws a line segment from $(x_1,y_1)$ to $(x_2,y_2)$.}
\medskip
\+\op void draw\_segment {point\ p,\ point\ q,\ color\ c=black} {}
\+\nop    {draws a line segment from point $p$ to point $q$.}
\medskip
\+\op void draw\_segment {segment\ s,\ color\ c=black} {}
\+\nop    {draws line segment $s$.}

\bigskip
{\bf 3.6 Drawing lines}
\bigskip
\+\op void draw\_line {double\ x_1,\ double\ y_1,\ double\ x_2,\ double\ y_2,\ color\ c=black} {}
\+\nop    {draws a straight line passing through points}
\+\nop    {$(x_1,y_1)$ and $(x_2,y_2)$.}
\medskip
\+\op void draw\_line {point\ p,\ point\ q,\ color\ c=black} {}
\+\nop    {draws a straight line passing through points}
\+\nop    {$p$ and $q$.}
\medskip
\+\op void draw\_line {line\ l,\ color\ c=black} {}
\+\nop    {draws line $l$.}
\medskip
\+\op void draw\_hline {double\ y,\ color\ c=black} {}
\+\nop    {draws a horizontal line with y-coordinate $y$. }
\medskip
\+\op void draw\_vline {double\ x,\ color\ c=black} {}
\+\nop    {draws a vertical line with x-coordinate $x$. }


\bigskip
{\bf 3.7 Drawing arrows}
\bigskip
\+\op void draw\_arrow {double\ x_1,\ double\ y_1,\ double\ x_2,\ double\ y_2,\ color\ c=black} {}
\+\nop    {draws an arrow pointing from $(x_1,y_1)$ to $(x_2,y_2)$.}
\vfill\eject

\+\op void draw\_arrow {point\ p,\ point\ q,\ color\ c=black} {}
\+\nop    {draws an arrow pointing from point $p$ to point $q$.}
\medskip
\+\op void draw\_arrow {segment\ s,\ color\ c=black} {}
\+\nop    {draws an arrow pointing from $s$.start() to $s$.end().}

\bigskip
{\bf 3.8 Drawing circles}
\bigskip
\+\op void draw\_circle {double\ x,\ double\ y,\ double\ r,\ color\ c = black} {}
\+\nop           {draws the circle with center $(x,y)$ and radius $r$.}
\medskip
\+\op void draw\_circle {point\ p,\ double\ r,\ color\ c = black} {}
\+\nop           {draws the circle with center $p$ and radius $r$.}
\medskip
\+\op void draw\_circle {circle\ C,\ color\ c = black} {}
\+\nop           {draws circle $C$.}

\bigskip
{\bf 3.9 Drawing discs}
\bigskip
\+\op void draw\_disc {double\ x,\ double\ y,\ double\ r,\ color\ c = black} {}
\+\nop           {draws a filled circle with center $(x,y)$ and radius $r$.}
\medskip
\+\op void draw\_disc {point\ p,\ double\ r,\ color\ c = black} {}
\+\nop           {draws a filled circle with center $p$ and radius $r$.}
\medskip
\+\op void draw\_disc {circle\ C,\ color\ c = black} {}
\+\nop           {draws filled circle $C$.}
\medskip

\bigskip
{\bf 3.10 Drawing polygons }
\bigskip
\+\op void draw\_polygon {list\<point\>\ lp,\ color\ c=black} {}
\+\nop {draws the polygon with vertex sequence $lp$.}
\medskip
\+\op void draw\_polygon {polygon\ P,\ color\ c=black} {}
\+\nop {draws polygon $P$.}
\medskip
\+\op void draw\_filled\_polygon {list\<point\>\ lp,\ color\ c=black} {}
\+\nop {draws the filled polygon with vertex sequence $lp$.}
\medskip
\+\op void draw\_filled\_polygon {polygon\ P,\ color\ c=black} {}
\+\nop {draws filled polygon $P$.}
\medskip

\vfill\eject

\bigskip
{\bf 3.11 Drawing functions}
\bigskip
\+\op void plot\_xy {double\ x_0,\ double\ x_1,\ (double)(*F)(double),\ color\ c = black} {}
\+\nop               {draws function $F$ in range $[x_0,x_1]$, i.e., all points}
\+\nop               {$(x,y)$ with $y = F(x)$ and $x_0\le x\le x_1$}
\medskip
\+\op void plot\_yx {double\ y_0,\ double\ y_1,\ (double)(*F)(double),\ color\ c = black} {}
\+\nop               {draws function $F$ in range $[y_0,y_1]$, i.e., all points}
\+\nop               {$(x,y)$ with $x = F(y)$ and $y_0\le y\le y_1$}


\bigskip
{\bf 3.12 Drawing text}
\bigskip
\+\op void draw\_text {double\ x,\ double\ y,\ string\ s,\ color\ c = black} {}
\+\nop               {writes string $s$ starting at position $(x,y)$.}
\medskip
\+\op void draw\_text {point\ p,\ string\ s,\ color\ c = black} {}
\+\nop               {writes string $s$ starting at position $p$.}
\medskip
\+\op void draw\_ctext {double\ x,\ double\ y,\ string\ s,\ color\ c = black} {}
\+\nop               {writes string $s$ centered at position $(x,y)$.}
\medskip
\+\op void draw\_ctext {point\ p,\ string\ s,\ color\ c = black} {}
\+\nop               {writes string $s$ centered at position $p$.}




\bigskip
{\bf 3.13 Drawing nodes}
%Nodes are circles of diameter $node\_width$.
\bigskip
\+\op void draw\_node {double\  x_0,\ double\ y_0,\ color\ c = black} {}
\+\nop               {draws a node at position $(x_0,y_0)$.}
\medskip
\+\op void draw\_node {point\ p,\ color\ c = black} {}
\+\nop               {draws a node at position $p$.}
\medskip
\+\op void draw\_filled\_node {double\  x_0,\ double\  y_0,\ color\ c = black} {}
\+\nop               {draws a filled node at position $(x_0,y_0)$.}
\medskip
\+\op void draw\_filled\_node {point\ p,\ color\ c = black} {}
\+\nop               {draws a filled node at position $p$.}
\medskip
\+\op void draw\_text\_node {double\  x,\ double\  y,\ string\ s,\ color\ c = black} {}
\+\nop               {draws a node with label $s$ at position $(x_0,y_0)$. }
\medskip
\+\op void draw\_text\_node {point\ p,\ string\ s,\ color\ c = black} {}
\+\nop               {draws a node with label $s$ at position $p$. }
\medskip
\+\op void draw\_int\_node {double\  x,\ double\  y,\ int\ i,\ color\ c = black} {}
\+\nop               {draws a node with integer label $i$ at position }
\+\nop               {$(x_0,y_0)$. }
\medskip
\+\op void draw\_int\_node {point\ p,\ int\ i,\ color\ c = black} {}
\+\nop               {draws a node with integer label $i$ at position  $p$. }

\bigskip
{\bf 3.14 Drawing edges}
%Edges are straigth line segments or arrows with a clearance of 
%$node\_width/2$ at each end.
\bigskip
\+\op void draw\_edge {double\  x_1, \ double\ y_1, \ double\ x_2, \ double\ y_2,\ color\ c = black} {}
\+\nop               {draws an edge from $(x_1,y_1)$ to $(x_2,y_2)$.}
\medskip
\+\op void draw\_edge {point\ p,\ point\ q,\ color\ c = black} {}
\+\nop               {draws an edge from $p$ to $q$.}
\medskip
\+\op void draw\_edge {segment\ s,\ color\ c = black} {}
\+\nop               {draws an edge from $s$.start() to $s$.end().}
\medskip
\+\op void draw\_edge\_arrow {double\  x_1, \ double\ y_1, \ double\ x_2, \ double\ y_2,\ color\ c = black} {}
\+\nop               {draws a directed edge from $(x_1,y_1)$ to $(x_2,y_2)$.}
\medskip
\+\op void draw\_edge\_arrow {point\ p,\ point\ q,\ color\ c = black} {}
\+\nop               {draws a directed edge from $p$ to $q$.}
\medskip
\+\op void draw\_edge\_arrow {segment\ s,\ color\ c = black} {}
\+\nop               {draws a directed edge from $s$.start() to $s$.end().} 



\bigskip
{\bf 3.15 Mouse Input}
\bigskip
\+\op int   read\_mouse {}
                 {displays the mouse cursor until a button is pressed.}
\+\nop           {Returns integer 1 for the left, 2 for the middle, and}
\+\nop           {3 for the right button (-1,-2,-3, if the shift key is}
\+\nop           {pressed simultaneously).}
\medskip
\+\op int   read\_mouse {double\&\ x,\ double\&\ y}  {}
\+\nop           {displays the mouse cursor on the screen until a}
\+\nop           {button is pressed. When a button is pressed the }
\+\nop           {current position of the cursor is assigned to }
\+\nop           {to $(x,y)$ and the pressed button is returned.}
\medskip
\+\op int   read\_mouse\_seg {double\ x_0,\ double\ y_0,\ double\&\ x,\ double\&\ y}  {}
\+\nop           {displays a line segment from $(x_0,y_0)$ to the }
\+\nop           {current cursor position until a mouse button is}
\+\nop           {pressed. When a button is pressed the current}
\+\nop           {position is assigned to $(x,y)$ and the pressed}
\+\nop           {button is returned.}
\medskip
\+\op int   read\_mouse\_rect {double\ x_0,\ double\ y_0,\ double\&\ x,\ double\&\ y}  {}
\+\nop           {displays a rectangle with diagonal from $(x_0,y_0)$}
\+\nop           {to the current cursor position until a mouse button}
\+\nop           {is pressed. When a button is pressed the current}
\+\nop           {position is assigned to $(x,y)$ and the pressed}
\+\nop           { button is returned.}
\medskip
\+\op int   read\_mouse\_circle {double\ x_0,\ double\ y_0,\ double\&\ x,\ double\&\ y}  {}
\+\nop           {displays a circle with center $(x_0,y_0)$ passing}
\+\nop           {through the current cursor position until a mouse}
\+\nop           {button is pressed. When a button is pressed the}
\+\nop           {current position is assigned to $(x,y)$ and the}
\+\nop           {pressed button is returned.}
\medskip
\+\op bool  confirm {string\ s} 
                 {displays string $s$ and asks for confirmation.}
\+\nop           {Returns true iff the answer was ``yes''.}
\medskip
\+\op void acknowledge {string\ s} {}
\+\nop           {displays string $s$ and asks for acknowledgement.}
\medskip
\+\op int  read\_panel {string\ h,\ int\ n,\ string*\ S} {}
\+\nop           {displays a panel with header $h$ and an array $S[1..n]$ }
\+\nop           {of $n$ string buttons, returns the index of the selected}
\+\nop           {button.}
\medskip
\+\op int  read\_vpanel {string\ h,\ int\ n,\ string*\ S} {}
\+\nop           {like read\_panel with vertical button layout}
\medskip
\+\op int  read\_int {string\ p} {}
\+\nop           {displays a panel with prompt $p$ for integer input,}
\+\nop           {returns the input}
\medskip
\+\op double  read\_real {string\ p} {}
\+\nop           {displays a panel with prompt $p$ for real input}
\+\nop           {returns the input}
\medskip
\+\op string  read\_string {string\ p} {}
\+\nop           {displays a panel with prompt $p$ for string input,}
\+\nop           {returns the input}
\medskip
\+\op void  message {string\ s} 
                 {displays message $s$ (each call adds a new line).}
\medskip
\+\op void  del\_message {} 
                 {deletes the text written by all previous message}
\+\nop           {operations.}
\medskip

\vfill\eject

\bigskip
{\bf 3.16 Input and output operators}

For input and output of basic geometric objects in the plane such as points, 
lines, line segments, circles, and polygons the $<<$ and $>>$ operators can 
be used. Similar to \CC input streams windows have an internal state indicating
whether there is more input to read or not. Its initial value is true and it 
is turned to false if an input sequence is terminated  by clicking the right 
mouse button (similar to ending stream input by the eof character). In 
conditional statements objects of type $window$ are automatically converted 
to boolean by returning this internal state. Thus, they can be used in 
conditional statements in the same way as \CC input streams. For example,
to read a sequence of points terminated by a right button click,  use 
`` {\bf while} ($W\ >>\ p$) $\{\  \dots\ \}$ ''. 


{\bf 3.16.1 Output}
\smallskip
\cleartabs
\+&\hskip 3truecm      &\hskip 4truecm &\cr
\+\opb window\& << {point\ p}     
                                   {like $W$.draw\_point($p$)}
\medskip
\+\opb window\& << {segment\ s}   
                                   {like $W$.draw\_segment($s$)}
\medskip
\+\opb window\& << {line\ l}      
                                   {like $W$.draw\_line($l$)}
\medskip
\+\opb window\& << {circle\ C}    
                                   {like $W$.draw\_circle($C$)}
\medskip
\+\opb window\& << {polygon\ P}   
                                   {like $W$.draw\_polygon($P$)}
\medskip


\bigskip
{\bf 3.16.2 Input}
\medskip
\+\opb window\& >> p   
                           {reads a point $p$: clicking the left button}
\+\nop                     {assigns the current cursor position to $p$.}
\medskip
\+\opb window\& >> s   
                           {reads a segment $s$: use the left button to input}
\+\nop                     {the start and end point of $s$.}
\medskip
\+\opb window\& >> l   
                           {reads a line $l$: use the left button to input}
\+\nop                     {two different points on $l$}
\medskip
\+\opb window\& >> C   
                           {reads a circle $C$: use the left button to input}
\+\nop                     {the center of $C$ and a point on $C$}
\medskip
\+\opb window\& >> P   
                           {reads a polygon $P$: use the left button to input}
\+\nop                     {the sequence of vertices of $P$, end the sequence}
\+\nop                     {by clicking the middle button.}
\medskip

As long as an input operation has not been completed the last read point can 
be erased by simultaneously pressing the shift key and the left mouse button.

