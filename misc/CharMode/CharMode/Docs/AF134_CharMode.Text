Banging the 
Metal



CUSTOM MODES - We combine techniques uncovered in our custom chip 
exploration 



Chapter 9	Many applications for the Amiga Blitter	

Chapter 10	Sprites in OCS, ECS and AGA modes

Chapter 11	Programming Amiga MMUs directly

Chapter 12	Hardware extras in each Amiga version

Chapter 13	Revealing a new set of graphics modes

Chapter 14	Copper and Blitter in perfect harmony



(( Highlight on Chapter 13 ))



Chapter 13 - CUSTOM MODES



Our tour of the custom chips is complete, and it's time to show how they fit 
together. The last two parts of this series demonstrate useful routines that use 
the Copper to program the Blitter to program the Copper to program the Blitter! 
The result is a neat demonstration of the potential of metal-bashing. You get a 
host of new Amiga video modes, on classic lines, guaranteed flicker-free with 
zero CPU overhead.



The demonstration routines show how the Amiga custom chips can perfectly 
simulate hardware that was built into old computers, including arcade 
machines, terminals and home micros. A custom copper list triggers 100,000 
or more graphic operations every second. You can animate the whole screen 
at 50 or 60 Hertz with hardly any effort from the main processor.



The techniques are at least as useful as the result. Rather than write out a 
Copper list, potentially 40K or more in length, for each new video mode, the 
program builds a custom mode to suit your requirement.



Character maps



In the days before bit-mapped graphics, when processor time was scarce, 
displays were built up from a grid of characters. A byte in memory determined 
the character displayed is a particular location. Most terminals, including 
Viewdata travel systems, still work that way. The codes are normally ASCII 
(except on Pet, TRS-80, and the first ZX systems) so programs can copy text 
directly to display memory, and the characters appear at once. There's no 
need to plot them one dot at a time which would have been painfully slow on 
early micros, or when emulating alien code now.



There's nothing to stop the 'characters' being graphical symbols - indeed that's 
the key to the animation in early arcade games like Space Invaders or Lunar 
Rescue. You can even simulate the striped colour overlay in those games with 
palette-tweaking Copper instructions. Again, Amiga software perfectly 
emulates custom hardware!



Later eight-bit systems like the C64, Atari, MSX, Einstein and Memotech 
extended this idea by moving the character patterns from ROM to RAM that 
the processor could access. A change in those patterns 'instantly' updates all 
corresponding characters on the screen. This is great for background patterns 
and effects like waves in the sea, where a few pokes can animate the entire 
background. It's hard work to emulate this entirely in software, but trivial in our 
custom modes, as their fonts work exactly the same way.



The Amiga and Mac were among the first computers to switch to purely 
bit-mapped displays. PCs still have character-mapped modes, which explains 
the blurringly-fast scrolling in MSDOS and Linux shell windows on 
IBM-compatibles. This hack shows that the Amiga hardware is so flexible that 
it can pull off the same tricks, with nothing but a BASIC program to set it going.



Copper Compiler



Rather than simulate a single layout - say, 24 lines of 40 characters for Apple 
2 or MSX text, 80 by 24 for CP/M, or 64 by 16 for TRS-80 displays - I've 
written a Copper List Compiler. This generates a centred display in LowRes or 
HiRes, depending on the required layout, and supports characters from 8 to 16 
pixels high.



The listing shows how the mode is set up. Next month I'll explain the compiler 
and the code it generates.  There's a complete example Copper List for a 32 
by 24 character mode on AFCD50. This is annotated output from the Copper 
List disassembler introduced in part 5.



The SuperBASIC procedures MOVE, WAIT and SKIP generate corresponding 
Copper instructions, so the Copper List can be read directly from the BASIC 
program. Symbolic variable names make the code easier to read and allow 
conditional code generation.



Each MOVE updates 16 bits, so it's convenient that the font, characters and 
copper list all start in the same 64K 'segment' of chip memory. The most 
significant bits of the custom chip registers all point to this segment, and we 
only need to change the low 16 bits to specify any address therein.



The first 8K is allocated to the character patterns, or 'fount' in Qdos parlance. 
After this, space is allocated for the screen bit-plane - the place where the 
Blitter puts the character patterns, and from whence Amiga DMA reads the 
bit-mapped display. The Character Map follows, with one byte per character 
code, then the custom Copper List.



The Copper list does four things. It sets up a custom bit plane display 
centred on the PAL screen. This is in LowRes or HiRes mode depending 
on the number of character columns. Next it can expand an 8 bit wide 
character font into 16 bit format for blitting.



After converting a table of eight bit character codes into pattern blit 
instructions, it generates the new display by blitting one pattern for each 
character code into the display. 



Each blitter transfer merges two lines of eight bits into a 16 bit word from 
the font locations corresponding to odd and even character codes. Each 
complete blit copies all the horizontal lines that make up two characters. 
All this happens 50 times per second, just ahead of the display's 
scanning beam, so updates appear instantaneous and flicker-free.



The diagram shows how a table of character codes, on the left, is 
indexed into the font, giving patterns for the display. As soon as you 
change the codes or the font patterns, the display changes to match.



Next month



Next month I'll explain the Copper Compiler, MAKE_COPPER_BLITS, and 
how to customise the new modes. There are copious further notes and 
programs on our CD.



Simon Goodwin



(( BOX - Running the demo ))



The Copper List compiler is written in SuperBASIC, to run under Amiga Qdos; 
this makes it easy to take over the entire system, and provides plenty of free 
programming tools. Everything you need to test and tweak the new modes is 
on AFCD50, including program notes, sample fonts and copper disassemblies, 
tested on everything from an old A500 to a 75 MHz 68060 with AGA.



Before running the compiler you need to make a Qdos boot disk, with the 
program, data and PD extensions on it. Mount the QL file system (QL0:, or 
FD0: if you prefer the multi-format XFS), put an empty DD disk in DF0:, then 
click on the 'MakeDemo' icon.



This formats the 720K Qdos disk and copies the required files there. Leave the 
disk in the drive, and start the emulator by clicking on MakeAssigns in the 
Amiga Qdos drawer, then Qdos_UK. The emulator displaces AmigaOS and 
links its own system 'ROMs', as shown, then waits for you to press F1 or F2. 
Press F1, leaving the Qdos floppy in drive 0. The BOOT file runs 
automatically. If you forget the disk and end up in the command line, with a 
flashing cursor, the command LRUN FLP1_BOOT will start things manually.



The toolkits sign on, followed by a short delay while the compiler is loaded and 
tokenised. Once it starts, messages will appear at the bottom of the screen as 
the copper list is assembled in Chip RAM. Use the Chip ONLY startup icon in 
the Custom_UK drawer if Qdos is relocated entirely to fast RAM on your 
system - this averts any 'Chip RAM not found' messages.



Press any key to return to SuperBASIC while the custom mode is displayed. 
Type SEE to momentarily switch back to the custom screen. QL_ON and 
CUSTOM_ON switch the Copper and Blitter between the Qdos system and 
character-mapped displays. Fast machines use the CPU for Qdos screen 
updates unless you type ACE_OFF: BLIT_ON.



Go-faster stripes



Amiga Qdos comes with SuperBASIC documentation, but all you need to 
know to make your own custom mode is how to edit the relevant lines. Line 
230 sets the number of lines and columns of characters. To change this, enter 
EDIT 230 and move the cursor with the horizontal arrows, then DEL and insert 
digits to change the values. Line 220 sets the pixel height of characters - stick 
with eight if you want automatic font unpacking - and line 260 controls 
ShowTime, which puts up optional copper stripes to show what the blitter is 
doing as the display is generated.



Green and Blue stripes indicate when the characters are being extracted from 
the Character Map and packed into the Copper List. This is done in two 
passes, in ascending and descending mode, for odd and even characters 
respectively. Red and purple stripes show the two passes when the blitter is 
unpacking the font from eight bit bytes to 16 bit words.



These stages are optional, and delay the start of the custom mode display. A 
standard Amiga bitmap slice is displayed above the custom mode. You could 
display titles, buttons or emulator status in this area. If the BlitFount or 
BlitChars flags are clear, character blitting starts higher up, but the font and 
character map are not automatically unpacked. The demo clears these flags if 
you've requested a lot of characters, to leave more time to blit them.



You can still update the font on the fly by writing whole words, with the pattern 
in the first byte and the second byte zero. To change the character at a given 
location you write its font offset into the Copper list. Each sequence of MOVEs 
and WAIT blits two characters from the font into adjacent columns, reading 
from Blitter channels A and B and writing to channel D.



ShowTime paints the background dark blue while the character patterns are 
blitted, and black for the remainder of the field. If the black starts before the 
last line you can be sure that the update will be flicker-free, as the blitter is 
always ahead of the beam.



(( Example Listing 1 - Copper Codegen procedures ))



DEFine PROCedure MOVE(value%,reg%)

POKE_W copper,reg%

POKE_W copper+2,value%

copper=copper+4

END DEFine MOVE



DEFine PROCedure WAIT(x%,y%)

POKE_W copper,(y% && 255)*256+(x% && 254)+1

POKE_W copper+2,32766 :REMark Blitter wait

copper=copper+4

END DEFine WAIT



DEFine PROCedure SKIP(x%,y%)

POKE_W copper,(y% && 255)*256+(x% && 254)+1

POKE_W copper+2,32767 :REMark Blitter skip

copper=copper+4

END DEFine SKIP



"These procedures let you write a Copper List directly into a SuperBASIC 
program"



(( Example Listing 2 -  Custom Screen setup ))



MOVE #page TO BLTAPTH :REMark All blitter data starts in this page

MOVE #page TO BLTBPTH : MOVE #page TO BLTDPT

MOVE #page TO BPL1PTH :REM Base page address of bitplane

MOVE #8192 TO BPL1PTL :REMark offset of bitplane in page

MOVE #0 TO BPLCON3 :REMark No special AGA tricks needed

MOVE #0 TO COLOUR0 :REMark Black background

MOVE #HEX("0CC5") TO COLOUR1 : REMark Bright yellow foreground

MOVE #top_line%*256+left_edge% TO DIWSTART :REMark True left limit

MOVE #left_edge% DIV 2 TO DDFSTART :REMark Hardware stop is at 18

IF CharColumns%>40

  MOVE #HEX("9200") TO BPLCON0 :REMark Hires Colour, 1 bitplane

  MOVE #(top_line%+lines%)*256+left_edge%+width%*4+8 TO DIWSTOP

  MOVE #(left_edge% DIV 2)+4*(width% DIV 2)-8 TO DDFSTOP

ELSE 

  MOVE #HEX("1200") TO BPLCON0 :REMark LowRes Colour, one plane

  MOVE #(top_line%+lines%)*256+left_edge%+width%*8+16 TO DIWSTOP

  MOVE #(left_edge% DIV 2)+4*width%-8 TO DDFSTOP :REMark Limit 204

END IF 

MOVE #HEX("2100") TO DIWHIGH  :REMark Set H8 and V8 (ECS extras)

MOVE #0 TO BPL1MOD : MAKE_COPPER_BLITS : WAIT 255,255



"BASIC to set up custom video modes, extracted from CharMode_BAS on AFCD50"



(( Captions - the first image is by far the most important; the last two can be 
small ))



CustomMode3 "Character codes select font patterns for corresponding display 
positions"



Qdos324 :"Press F1 with the floppy in drive 0 to start Amiga Qdos and the 
CharMode demo"



Invaders1 "Space Invaders made pioneering use of character-mapped graphics"



LunarRescue "Lunar Rescue combined adjacent characters for bigger graphics"



