{\rtf1\ansi\deff0
{\fonttbl
{\f1\fnil Tahoma;}
{\f2\fnil Arial;}
}
{\stylesheet
{\s1\li0\ri0\fi0\ql\sl240\slmult1\hyphpar\b\i\f0\fs72\strike0\ulnone
\caps0\nosupersub\snext2 Document Title;}
{\s2\b\i0\f0\fs40\sbasedon1\snext6 Section Name;}
{\s3\b\i0\f0\fs30\sbasedon1\snext6 Topic Name;}
{\s4\b\i0\f0\fs26\sbasedon1\snext6 Sub Topic 1;}
{\s5\b\i0\f0\fs24\sbasedon1\snext6 Sub Topic 2;}
{\s6\hyphpar0\b\i\f0\fs22\sbasedon1 Body;}
{\s7\fi480\b\i\f0\fs20\sbasedon6 Indented Body;}
}
{\info
{\comment
This document was exported from FinalWriter 5 word processor for the Am
iga computers, Copyright (c) Softwood, Inc. 1995, 1996. RTF document ex
port driver V1.0.
}
{\revtim\yr2001\mo10\dy25\hr11\min11\sec11}
}
\paperw11908\paperh16834\margl720\margt360\margr0\margb360\deftab720
\sectd\pard\plain\colsx708\marglsxn1440\margtsxn1080\margrsxn1440
\pgnstarts1\pgndec
\sl240\slmult1\hyphpar0
\f0\fs128\strike0\ulnone\nosupersub
Banging the Metal\par
\i\fs26
\par
CUSTOM MODES - We combine techniques uncovered in our custom chip explo
ration \par
\par
\i0\f1
Chapter 9\tab Many applications for the Amiga Blitter\tab\par
Chapter 10\tab Sprites in OCS, ECS and AGA modes\par
Chapter 11\tab Programming Amiga MMUs directly\par
Chapter 12\tab Hardware extras in each Amiga version\par
\b\f2
Chapter 13\tab Revealing a new set of graphics modes\par
\b0\f1
Chapter 14\tab Copper and Blitter in perfect harmony\par
\par
\i\f0
(( Highlight on Chapter 13 ))\par
\b\i0\f2
\par
Chapter 13 - CUSTOM MODES\par
\b0\f1
\par
Our tour of the custom chips is complete, and it's time to show how the
y fit together. The last two parts of this series demonstrate useful ro
utines that use the Copper to program the Blitter to program the Copper
 to program the Blitter! The result is a neat demonstration of the pote
ntial of metal-bashing. You get a host of new Amiga video modes, on cla
ssic lines, guaranteed flicker-free with zero CPU overhead.\par
\par
The demonstration routines show how the Amiga custom chips can perfectl
y simulate hardware that was built into old computers, including arcade
 machines, terminals and home micros. A custom copper list triggers 100
,000 or more graphic operations every second. You can animate the whole
 screen at 50 or 60 Hertz with hardly any effort from the main processo
r.\par
\par
The techniques are at least as useful as the result. Rather than write 
out a Copper list, potentially 40K or more in length, for each new vide
o mode, the program builds a custom mode to suit your requirement.\par
\par
\b\f2
Character maps\par
\b0\f1
\par
In the days before bit-mapped graphics, when processor time was scarce,
 displays were built up from a grid of characters. A byte in memory det
ermined the character displayed is a particular location. Most terminal
s, including Viewdata travel systems, still work that way. The codes ar
e normally ASCII (except on Pet, TRS-80, and the first ZX systems) so p
rograms can copy text directly to display memory, and the characters ap
pear at once. There's no need to plot them one dot at a time which woul
d have been painfully slow on early micros, or when emulating alien cod
e now.\par
\par
There's nothing to stop the 'characters' being graphical symbols - inde
ed that's the key to the animation in early arcade games like Space Inv
aders or Lunar Rescue. You can even simulate the striped colour overlay
 in those games with palette-tweaking Copper instructions. Again, Amiga
 software perfectly emulates custom hardware!\par
\par
Later eight-bit systems like the C64, Atari, MSX, Einstein and Memotech
 extended this idea by moving the character patterns from ROM to RAM th
at the processor could access. A change in those patterns 'instantly' u
pdates all corresponding characters on the screen. This is great for ba
ckground patterns and effects like waves in the sea, where a few pokes 
can animate the entire background. It's hard work to emulate this entir
ely in software, but trivial in our custom modes, as their fonts work e
xactly the same way.\par
\par
The Amiga and Mac were among the first computers to switch to purely bi
t-mapped displays. PCs still have character-mapped modes, which explain
s the blurringly-fast scrolling in MSDOS and Linux shell windows on IBM
-compatibles. This hack shows that the Amiga hardware is so flexible th
at it can pull off the same tricks, with nothing but a BASIC program to
 set it going.\par
\par
\b\f2
Copper Compiler\par
\par
\b0\f1
Rather than simulate a single layout - say, 24 lines of 40 characters f
or Apple 2 or MSX text, 80 by 24 for CP/M, or 64 by 16 for TRS-80 displ
ays - I've written a Copper List Compiler. This generates a centred dis
play in LowRes or HiRes, depending on the required layout, and supports
 characters from 8 to 16 pixels high.\par
\par
The listing shows how the mode is set up. Next month I'll explain the c
ompiler and the code it generates.  There's a complete example Copper L
ist for a 32 by 24 character mode on AFCD50. This is annotated output f
rom the Copper List disassembler introduced in part 5.\par
\par
The SuperBASIC procedures MOVE, WAIT and SKIP generate corresponding Co
pper instructions, so the Copper List can be read directly from the BAS
IC program. Symbolic variable names make the code easier to read and al
low conditional code generation.\par
\par
Each MOVE updates 16 bits, so it's convenient that the font, characters
 and copper list all start in the same 64K 'segment' of chip memory. Th
e most significant bits of the custom chip registers all point to this 
segment, and we only need to change the low 16 bits to specify any addr
ess therein.\par
\par
The first 8K is allocated to the character patterns, or 'fount' in Qdos
 parlance. After this, space is allocated for the screen bit-plane - th
e place where the Blitter puts the character patterns, and from whence 
Amiga DMA reads the bit-mapped display. The Character Map follows, with
 one byte per character code, then the custom Copper List.\par
\par
\fs28
The Copper list does four things. It sets up a custom bit plane display
 centred on the PAL screen. This is in LowRes or HiRes mode depending o
n the number of character columns. Next it can expand an 8 bit wide cha
racter font into 16 bit format for blitting.\par
\par
After converting a table of eight bit character codes into pattern blit
 instructions, it generates the new display by blitting one pattern for
 each character code into the display. \par
\par
Each blitter transfer merges two lines of eight bits into a 16 bit word
 from the font locations corresponding to odd and even character codes.
 Each complete blit copies all the horizontal lines that make up two ch
aracters. All this happens 50 times per second, just ahead of the displ
ay's scanning beam, so updates appear instantaneous and flicker-free.
\par
\par
The diagram shows how a table of character codes, on the left, is index
ed into the font, giving patterns for the display. As soon as you chang
e the codes or the font patterns, the display changes to match.\par
\par
\b\f2\fs26
Next month\par
\par
\b0\f1
Next month I'll explain the Copper Compiler, MAKE_COPPER_BLITS, and how
 to customise the new modes. There are copious further notes and progra
ms on our CD.\par
\par
\b\f2\fs24
Simon Goodwin\par
\par
(( BOX - Running the demo ))\par
\par
\b0\f1\fs26
The Copper List compiler is written in SuperBASIC, to run under Amiga Q
dos; this makes it easy to take over the entire system, and provides pl
enty of free programming tools. Everything you need to test and tweak t
he new modes is on AFCD50, including program notes, sample fonts and co
pper disassemblies, tested on everything from an old A500 to a 75 MHz 6
8060 with AGA.\par
\par
Before running the compiler you need to make a Qdos boot disk, with the
 program, data and PD extensions on it. Mount the QL file system (QL0:,
 or FD0: if you prefer the multi-format XFS), put an empty DD disk in D
F0:, then click on the 'MakeDemo' icon.\par
\par
This formats the 720K Qdos disk and copies the required files there. Le
ave the disk in the drive, and start the emulator by clicking on MakeAs
signs in the Amiga Qdos drawer, then Qdos_UK. The emulator displaces Am
igaOS and links its own system 'ROMs', as shown, then waits for you to 
press F1 or F2. Press F1, leaving the Qdos floppy in drive 0. The BOOT 
file runs automatically. If you forget the disk and end up in the comma
nd line, with a flashing cursor, the command LRUN FLP1_BOOT will start 
things manually.\par
\par
The toolkits sign on, followed by a short delay while the compiler is l
oaded and tokenised. Once it starts, messages will appear at the bottom
 of the screen as the copper list is assembled in Chip RAM. Use the Chi
p ONLY startup icon in the Custom_UK drawer if Qdos is relocated entire
ly to fast RAM on your system - this averts any 'Chip RAM not found' me
ssages.\par
\par
Press any key to return to SuperBASIC while the custom mode is displaye
d. Type SEE to momentarily switch back to the custom screen. QL_ON and 
CUSTOM_ON switch the Copper and Blitter between the Qdos system and cha
racter-mapped displays. Fast machines use the CPU for Qdos screen updat
es unless you type ACE_OFF: BLIT_ON.\par
\par
\b\f2
Go-faster stripes\par
\par
\b0\f1
Amiga Qdos comes with SuperBASIC documentation, but all you need to kno
w to make your own custom mode is how to edit the relevant lines. Line 
230 sets the number of lines and columns of characters. To change this,
 enter EDIT 230 and move the cursor with the horizontal arrows, then DE
L and insert digits to change the values. Line 220 sets the pixel heigh
t of characters - stick with eight if you want automatic font unpacking
 - and line 260 controls ShowTime, which puts up optional copper stripe
s to show what the blitter is doing as the display is generated.\par
\b\f2
\par
\b0\f1
Green and Blue stripes indicate when the characters are being extracted
 from the Character Map and packed into the Copper List. This is done i
n two passes, in ascending and descending mode, for odd and even charac
ters respectively. Red and purple stripes show the two passes when the 
blitter is unpacking the font from eight bit bytes to 16 bit words.\par
\par
These stages are optional, and delay the start of the custom mode displ
ay. A standard Amiga bitmap slice is displayed above the custom mode. Y
ou could display titles, buttons or emulator status in this area. If th
e BlitFount or BlitChars flags are clear, character blitting starts hig
her up, but the font and character map are not automatically unpacked. 
The demo clears these flags if you've requested a lot of characters, to
 leave more time to blit them.\par
\par
You can still update the font on the fly by writing whole words, with t
he pattern in the first byte and the second byte zero. To change the ch
aracter at a given location you write its font offset into the Copper l
ist. Each sequence of MOVEs and WAIT blits two characters from the font
 into adjacent columns, reading from Blitter channels A and B and writi
ng to channel D.\par
\par
ShowTime paints the background dark blue while the character patterns a
re blitted, and black for the remainder of the field. If the black star
ts before the last line you can be sure that the update will be flicker
-free, as the blitter is always ahead of the beam.\par
\par
\b\f2
(( Example Listing 1 - Copper Codegen procedures ))\par
\par
\b0\f0
DEFine PROCedure MOVE(value%,reg%)\par
POKE_W copper,reg%\par
POKE_W copper+2,value%\par
copper=copper+4\par
END DEFine MOVE\par
\par
DEFine PROCedure WAIT(x%,y%)\par
POKE_W copper,(y% && 255)*256+(x% && 254)+1\par
POKE_W copper+2,32766 :REMark Blitter wait\par
copper=copper+4\par
END DEFine WAIT\par
\par
DEFine PROCedure SKIP(x%,y%)\par
POKE_W copper,(y% && 255)*256+(x% && 254)+1\par
POKE_W copper+2,32767 :REMark Blitter skip\par
copper=copper+4\par
END DEFine SKIP\par
\par
\i
"These procedures let you write a Copper List directly into a SuperBASI
C program"\par
\par
\b\i0\f2\fs24
(( Example Listing 2 -  Custom Screen setup ))\par
\b0\i\f0
\par
\i0
MOVE #page TO BLTAPTH :REMark All blitter data starts in this page\par
MOVE #page TO BLTBPTH : MOVE #page TO BLTDPT\par
MOVE #page TO BPL1PTH :REM Base page address of bitplane\par
MOVE #8192 TO BPL1PTL :REMark offset of bitplane in page\par
MOVE #0 TO BPLCON3 :REMark No special AGA tricks needed\par
MOVE #0 TO COLOUR0 :REMark Black background\par
MOVE #HEX("0CC5") TO COLOUR1 : REMark Bright yellow foreground\par
MOVE #top_line%*256+left_edge% TO DIWSTART :REMark True left limit\par
MOVE #left_edge% DIV 2 TO DDFSTART :REMark Hardware stop is at 18\par
IF CharColumns%>40\par
  MOVE #HEX("9200") TO BPLCON0 :REMark Hires Colour, 1 bitplane\par
  MOVE #(top_line%+lines%)*256+left_edge%+width%*4+8 TO DIWSTOP\par
  MOVE #(left_edge% DIV 2)+4*(width% DIV 2)-8 TO DDFSTOP\par
ELSE \par
  MOVE #HEX("1200") TO BPLCON0 :REMark LowRes Colour, one plane\par
  MOVE #(top_line%+lines%)*256+left_edge%+width%*8+16 TO DIWSTOP\par
  MOVE #(left_edge% DIV 2)+4*width%-8 TO DDFSTOP :REMark Limit 204\par
END IF \par
MOVE #HEX("2100") TO DIWHIGH  :REMark Set H8 and V8 (ECS extras)\par
MOVE #0 TO BPL1MOD : MAKE_COPPER_BLITS : WAIT 255,255\par
\par
\i
"BASIC to set up custom video modes, extracted from CharMode_BAS on AFC
D50"\par
\par
\b\i0\f2
(( Captions - the first image is by far the most important; the last tw
o can be small ))\par
\par
\b0\i\f0
CustomMode3 "Character codes select font patterns for corresponding dis
play positions"\par
\par
Qdos324 :"Press F1 with the floppy in drive 0 to start Amiga Qdos and t
he CharMode demo"\par
\par
Invaders1 "Space Invaders made pioneering use of character-mapped graph
ics"\par
\par
LunarRescue "Lunar Rescue combined adjacent characters for bigger graph
ics"\par
\par
}