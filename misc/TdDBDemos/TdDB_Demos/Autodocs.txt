TABLE OF CONTENTS

tddbase.library/TDDB_AbortMsg
tddbase.library/TDDB_CloseBase
tddbase.library/TDDB_CopyBase
tddbase.library/TDDB_CopyNode
tddbase.library/TDDB_CreateBase
tddbase.library/TDDB_DeleteNode
tddbase.library/TDDB_FindIntA
tddbase.library/TDDB_FindStringA
tddbase.library/TDDB_FlushNodes
tddbase.library/TDDB_ForceUpdate
tddbase.library/TDDB_FreeList
tddbase.library/TDDB_FreeNode
tddbase.library/TDDB_GetDataItem
tddbase.library/TDDB_GetDataListA
tddbase.library/TDDB_GetDataValue
tddbase.library/TDDB_GetDBFromNode
tddbase.library/TDDB_GetHandle
tddbase.library/TDDB_GetNode
tddbase.library/TDDB_InstallMsg
tddbase.library/TDDB_LockNode
tddbase.library/TDDB_MakeList
tddbase.library/TDDB_NewNode
tddbase.library/TDDB_OpenBase
tddbase.library/TDDB_SeekBaseA
tddbase.library/TDDB_SetData
tddbase.library/TDDB_SetDataListA
tddbase.library/TDDB_SwapNodes
tddbase.library/TDDB_UnLockNode
tddbase.library/TDDB_UpdateList
tddbase.library/TDDB_AbortMsg                   tddbase.library/TDDB_AbortMsg

   NAME
        TDDB_AbortMsg -- Aborts a UpdateMsg.

   SYNOPSIS
        TDDB_AbortMsg(DBase,Msg)
                       A0    A1

        void TDDB_AbortMsg(struct DBHandle *,struct UpdateMsg *);

   FUNCTION
        This function is used when you want to remove an installed UpdateMsg.
        If the message is in the queue it will be replayed with a Type of
        MSG_ABORTED. 

   INPUTS
        DBase - A Handle on the database this message is conected to.
        Msg   - Pointer to the message you want to abort.

   NOTES
        Only messages that is in the waiting queue will have type
        MSG_ABORTED, if the message is already waiting in your ReplyPort it
        will not be changed.
        You must GetMsg() it from your reply port before it can safly be
        deallokated.

   SEE ALSO
        TDDB_InstallMsg()

tddbase.library/TDDB_CloseBase                 tddbase.library/TDDB_CloseBase

   NAME
        TDDB_CloseBase -- Closes a database.

   SYNOPSIS
        TDDB_CloseBase(DBase)
                          A0

        void TDDB_CloseBase(struct DBHandle *);

   FUNCTION
        Closes the database, and if the number of handles on this database is
       0 it will also free all other resources in form of caches and locked
       nodes. 

   INPUTS
        DBase - A handle returned by TDDB_OpenBase() or TDDB_CreateBase().

   SEE ALSO
        TDDB_OpenBase(), TDDB_CeateBase()

tddbase.library/TDDB_CopyBase                   tddbase.library/TDDB_CopyBase

   NAME
        TDDB_CopyBase -- Copies a whole database to a new place/name.

   SYNOPSIS
        DBase=TDDB_CopyBase(FromBase, Name)
        D0                       A0          A1

        struct DBHandle *TDDB_CopyBase(struct DBHandle *,STRPTR);

   FUNCTION
        This function copies the given database to a new name and also makes
        shure that the index file folows.

        If the copy succeded it will return a handle to the destination
        database wich must be closed if it is not to be used.

   INPUTS
        FromBase - A DBHandle on the base you want to copy.
        Name     - The name for the new database.

   RESULT
        DBase - The result of a TDDB_OpenBase on the destination database.

    SEE ALSO
        TDDB_CopyNode(), TDDB_OpenBase()

tddbase.library/TDDB_CopyNode                   tddbase.library/TDDB_CopyNode

   NAME
        TDDB_CopyNode -- Copies a node to a new place and/or database.

   SYNOPSIS
        Err=TDDB_CopyNode(FromBase,FromNr,ToBase,ToNr)
        D0                    A0       D0      A1     D1

        int TDDB_CopyNode(struct DBHandle *,ULONG,struct DBHandle *,ULONG)

   FUNCTION
        Copies the given node to another node that can reside in the same
        database or another database. Note that the destination node must
        already exist.

   INPUTS
        FromBase - DBHandle on the database to copy from.
        FromNr   - Number for the node to be copied.
        ToBase     - DBHandle on the destination database or NULL meaning the
                   same as FromBase.
        ToNr     - Number for destination node.

   RESULT
        Err - non-NULL for error or NULL for success.

   NOTES
        Both nodes must NOT be locked in any way by this task or any other
        task that is dependent on this copy.

   SEE ALSO
        TDDB_LockNode(),TDDB_GetNode()

tddbase.library/TDDB_CreateBase               tddbase.library/TDDB_CreateBase

   NAME
        TDDB_CreateBase -- Create a new database.

   SYNOPSIS
        DBase=TDDB_CreateBaseA(Name,Format,ID,Tags)
        D0                       A0   D0       D1 A1

        struct DBHandle *TDDB_CreateBaseA(STRPTR, ULONG, ULONG,struct TagItem
 *);

        DBase=TDDB_CreateBase(Name,Format, ID, tag1, data, tag2,...)
        
        struct DBHandle *TDDB_CreateBase(STRPTR, ULONG, ULONG, tag, ...);

   FUNCTION
        This function creates and opens a completly new database ready to
        accept new data.

        Name is the name of the databasefile to create and its recomended
        that the file has the prefix .DBS even if it is not necesary. There
        will actualy be 2 files created, one with this name and one who
        has changed prefix to IDX, ie with a name of Example.DBS you will
        get 2 files, one called Example.DBS and one called Example.IDX.

        Format descibes what kind of format you want the file and database
        to have. This field is currently ignored but you should always set
        it to FILID_STATIC to keep forward compability.

        ID is an unique identifyer over the database. This is nothing this
        library will use and its main purpose is to identify the database to
        the user programm. If you dont want to use this feature you should
        set it to DBID_NOID.

        Currently there is no tags defined you better set that field to
        NULL.

    INPUTS
        Namn   - Name on the new database. 
        Format - Type of database to create, currently ignored.
        ID     - An id value for that database or DBID_NOID.
        Tags   - None defined... 

    RESULTS
        DBase - The results of a TDDB_OpenBase on the created file or NULL
                if the creation failed.

    NOTES
        Read the TDDB_OpenBase() autodoc for a important note about the
        returned handle.

   BUGS
        Doesnt check if there already exits an open database with that name
        before it initlize file.

   SEE ALSO
        TDDB_OpenBase()

tddbase.library/TDDB_DeleteNode               tddbase.library/TDDB_DeleteNode

   NAME
        TDDB_DeleteNode -- Deletes a node from database.

   SYNOPSIS
        TDDB_DeleteNode(DBase,Nummer)
                           A0     D0

        void TDDB_DeleteNode(struct DBHandle *,ULONG);

   FUNCTION
       This function deletes a node that is no longer needed.

   INPUTS
        DBase  - The database to delete a node from.
        Nummer - Number of the node to delete.

    SEE ALSO
        TDDB_NewNode()

tddbase.library/TDDB_FindIntA                   tddbase.library/TDDB_FindIntA

   NAME
        TDDB_FindIntA -- Search for a number in database.

   SYNOPSIS
        Node=TDDB_FindIntA(DBase,ID, Nummer,Tags)
        D0                   A0    D0  D1     A1

        struct DBNode *TDDB_FindIntA(struct DBHandle *,ULONG,ULONG,
                                       struct TagItem *);

   FUNCTION
       This is a simple shell for SeekBase that lets you search after a
       specific number.

   INPUTS
        DBase  - Handle on database to search in.
        ID     - The field to search in.
        Nummer - Number to search for.
        Tags   - Tags that is passed to SeekBase.

   RESULT
        Node - The first found match.

   BUGS
        Empty fields are considered the same as field with a 0 storaged in
       them.

   SEE ALSO
        TDDB_SeekBaseA()

tddbase.library/TDDB_FindStringA             tddbase.library/TDDB_FindStringA

   NAME
        TDDB_FindStringA -- Searches database for a string.

   SYNOPSIS
        Node=TDDB_FindStringA(DBase,ID,Str,Tags)
        D0                      A0    D0 A1  A2

        struct DBNode *TDDB_FindStringA(struct DBHandle *,ULONG,STRPTR,
                                                   struct TagItem *);

   FUNCTION
       Same as TDDB_FindInt() but searches for a string instead.

   INPUTS
        DBase - Handle on database to search in.
        ID    - Field to search in.
        Str      - String to search for.
        Tags  - Tags given to TDDB_SeekBase()

   RESULT
        Node - The node that has a matching string.

   SEE ALSO
        TDDB_FindIndA(),TDDB_SeekBaseA()

tddbase.library/TDDB_FlushNodes               tddbase.library/TDDB_FlushNodes

   NAME
        TDDB_FlushNodes -- Flushes cache on one database.

   SYNOPSIS
        TDDB_FlushNodes(DBase)
                           A0

        void TDDB_FlushNodes(struct DBHandle *);

   FUNCTION
        This routine flushes (deallocates) the ram cache for the given
        database.

   INPUTS
        DBase - Handle on the database you want to flush cache in.

    NOTES
        This is automaticly done when a memory flush occurs.

tddbase.library/TDDB_ForceUpdate             tddbase.library/TDDB_ForceUpdate

   NAME
        TDDB_ForceUpdate -- Broadcast a user event.

   SYNOPSIS
        TDDB_ForceUpdate(DBase,NodeNr,More)
                         A0       D0     D1

        void TDDB_ForceUpdate(struct DBHandle *,ULONG,ULONG);

   FUNCTION
        This function is used when you want to send a message to all other
        users of this database that does not fall under any of the other
        categories.

        The special message will have a type of MSG_USER wich NodeNr and
        MoreData field coresponding to the given arguments.

   INPUTS
        DBase  - A handle on the database to send a message from/about.
        NodeNr - A value to be placed in the NodeNr field of message.
        More   - Same as above but this is placed in ModeData.

   SEE ALSO
        TDDB_InstallMsg(),TDDB_AbortMsg()

tddbase.library/TDDB_FreeList                   tddbase.library/TDDB_FreeList

   NAME
        TDDB_FreeList -- Deallocates a list.

    SYNOPSIS
        TDDB_FreeList(Handle,List)
                       A0     A1

        void TDDB_FreeList(struct DBHandle *,struct List *);

   FUNCTION
        This function deallocates the list that was allocated by
        TDDB_MakeList()

   INPUTS
        Handle - The same handle that was given to TDDB_MakeList()
        List   - A header wich to be deallocated.

   SEE ALSO
        TDDB_MakeList()

tddbase.library/TDDB_FreeNode                   tddbase.library/TDDB_FreeNode

   NAME
        TDDB_FreeNode -- Declears that you are finished with a node.

   SYNOPSIS
        TDDB_FreeNode(DBase,Node)
                       A0    A1

        void TDDB_FreeNode(struct DBHandle *, struct DBNode *);

   FUNCTION
        This routine releases the node so that other programms can use them
        and in case there are a (partial) new contents, it will be writen
        down to disk.

   INPUTS
        DBase - A handle on the database this node belongs to.
        Node  - A nodestructure returned by TDDB_GetNode(),TDDB_NewNode().

   SEE ALSO
        TDDB_GetNode()

tddbase.library/TDDB_GetDataItem             tddbase.library/TDDB_GetDataItem

   NAME
        TDDB_GetDataItem -- Gets a DataStorage elemement from 

   SYNOPSIS
        Data=TDDB_GetDataItem(Node,ID)
        D0                       A0   D0

        struct DataStorage *TDDB_GetDataItem(struct DBNode *,ULONG);

   FUNCTION
        This function returns a DataStorage elemt from the given node.

   INPUTS
        Node - The node to search in.
        ID   - Field to get.

   RESULT
        Data - The DataStorage structure that belongs to the field.

   SEE ALSO
        TDDB_GetDataValue()

tddbase.library/TDDB_GetDataListA           tddbase.library/TDDB_GetDataListA

   NAME
        TDDB_GetDataListA -- Collect a list of data from database.

   SYNOPSIS
        TDDB_GetDataListA(Node,CmdArray)
                           A0    A1

        void TDDB_GetDataListA(struct DBNode *,ULONG *);

        TDDB_GetDataList(Node,Cmd,DataPtr,...)

        void TDDB_GetDataList(struct DBNode *,ULONG, ...);

   FUNCTION
        This funcion collects a lot of data from a datanode and write
        their value to a lot of variables.

        CmdArray is a list of ID,Datapointer pares, where ID is the field
        you want to collect data from and Datapointer is a pointer to a
        place where to store data. If there arent any data stored in the
        given field the place pointed to by datapointer is left alone and
        you can therefore place default data there before this call.

        The array is termenated by a NULL ID field.

   INPUTS
        Node     - The node you want to collect data from.
        CmdArray - A array with information about what you want to collect.

   SEE ALSO
        TDDB_SetDataListA(),TDDB_GetDataValue(), TDDB_GetDataItem()

tddbase.library/TDDB_GetDataValue           tddbase.library/TDDB_GetDataValue

   NAME
        TDDB_GetDataValue -- Gets the value stored in node.

   SYNOPSIS
        Data=TDDB_GetDataValue(Node,ID)
        D0                         A0   D0

        ULONG TDDB_GetDataValue(struct DBNode *,ULONG);

   FUNCTION
        This function gets the value of the given field, and if it doesnt
        exists such a field, it will return NULL.

   INPUTS
        Node - The node you want to get data from.
        ID   - The field to get data from.

   RESULT
        Data - The data that is stored in database.

   SEE ALSO
        TDDB_GetDataList(), TDDB_GetDataItem(), TDDB_GetNode()

tddbase.library/TDDB_GetDBFromNode         tddbase.library/TDDB_GetDBFromNode

   NAME
        TDDB_GetDBFromNode -- Finds database that node belongs to.

   SYNOPSIS
        DBase=TDDB_GetDBFromNode(Node);
        D0                         A0

        struct DataBase *TDDB_GetDBFromNode(struct DBNode *);

   FUNCTION
        This function is used when you got a nodepointer and you want to
        know which database it belongs to. Note that it returns a pointer
        to the database and not to a handler on that database, if you
        want to get a handle you should use TDDB_GetHandle.

        If order for this routine to work it must be a valid node and it
        must be placed in the cache, ie nodes got with MODEF_NOCACHE flag
        will not work.

   INPUTS
        Node - The node you are intrested in.

   RESULT
        DBase - Database it belongs to

    BUGS
        Doesnt check if it is a valid node. Doesnt check if list linkage is
        broken.

    NOTES
        This function internaly calls Forbid()/Permit()

   SEE ALSO
        TDDB_GetHandle()

tddbase.library/TDDB_GetHandle                 tddbase.library/TDDB_GetHandle

   NAME
        TDDB_GetHandle -- Tries to find a handle on a database.

   SYNOPSIS
        Handle=TDDB_GetHandle(DBase)
        D0                      A0

        struct DBHandle *TDDB_GetHandle(struct DataBase *);

   FUNCTION
        This function goes truogh the list of Handles on this database in
        search for a handle that belongs to this task, and if it is found
        it will be returned.

   INPUTS
        DBase - A struct DataBase you want to find a handle on.

   RESULT
        Handle - A databasehandle on that database or NULL if noone could be
                 found.

tddbase.library/TDDB_GetNode                     tddbase.library/TDDB_GetNode

   NAME
        TDDB_GetNode -- Get access to a node in database.

   SYNOPSIS
        Node=TDDB_GetNode(DBase,NodeNr,Flags)
        D0                   A0    D0       D1

        struct DBNode *TDDB_GetNode(struct DBHandle *, ULONG, ULONG);

   FUNCTION
        This is a very important one since it grant's you access to a node
        so you can store or read data from it.

        DBase is a handle on the database as returned by TDDB_OpenBase() and
        NodeNr states wich node you want to get.

        Flags state what type of action you want to take.

        MODEF_READ - States that you want read-only access to the node.
        MODEF_WRITE - States that you want read/write access to the node.
            You must ALWAYS declare one of these.

        MODEF_NOWAIT - If a node is not available, the calling process will
            be put to sleap until it becomes so. If you do not want this
            to happen you set this flag and you will get an ERR_NodeBusy 
            instead.

    INPUTS
        DBase  - Handle on database to get node from.
        NodeNr - Number of the node you want.
        Flags  - In wich way do you want it.

   RESULT
        Node - A node ready for use or NULL in case of an error. 

   SEE ALSO
        TDDB_FreeNode(), TDDB_LockNode(), exec.library/ObtainSemaphore()

tddbase.library/TDDB_InstallMsg               tddbase.library/TDDB_InstallMsg

   NAME
        TDDB_InstallMsg -- Installs a update message in a database

   SYNOPSIS
        TDDB_InstallMsg(Handle,Msg)
                           A0       A1

        void TDDB_InstallMsg(struct DBHandle *,struct UpdateMsg *);

   FUNCTION
        This function installs a UpdateMsg that will be ReplyMsg()'ed back
        when something interesting happens.

        struct UpdateMsg
        {
            struct Message    Msg;
            struct DataBase *DBase;
            struct Task     *Task;
            ULONG            Type;
            ULONG             NodeNr;
            ULONG            MoreData;
        };

        DBase points to the database this message comes from. Note that it
        is a pointer to a database and not to a DBHandle, to get a pointer
        to your handle on this database you can call TDDB_GetHandle().

        Task points to the task that caused this message to be sent. Usefull
        if you for example want to check if you have caused this message or
        not.

        The last 3 fields tells what type of message it is and the node that
        is involved.

        MSG_NEWNODE tells that a new node has been created, where NodeNr is
            the number for it. Note that this is caused by a call to
            TDDB_NewNode() and therefore the node is probobly still locked
            by the task that created it, to see when it is unlocked you have
            to check for a MSG_CHANGED with its NodeNr.

        MSG_DELNODE gets sent when a node has been deleted and therefore all
            nodes after this now has a new number wich is one less than their
            old one.

        MSG_NODELOCK informs you that another programm has laid an informal
            lock on that node.

        MSG_NODEUNLOCK informs you that a node is no longer locked.

        MSG_CHANGED tells that a program has changed some of the data that
            is stored in this node.

        MSG_SWAP has basicly the same meaning as MSG_CHANGED but is produced
            by a call to SwapNodes() and states that the nodes with number
            NodeNr and MoreData has changed place with eachother.

        MSG_USER is sent by a call to TDDB_ForceUpdate(). This is in case
            you come up with some strange sitation wich does not fall under
            some of the other categories, and when you recive such a message
            it can be a good chance to take a closer look at the node
            that Msg->NodeNr states.

        MSG_ABORTED states that this message has been removed by a call to
            TDDB_AbortMessage().

   INPUTS
        DBase - A DBHandle on the databas you wich to be informed about.
        Msg   - A message that is to be ReplyMsg()'ed back with some
                important data.

   NOTES
        Only one (1) message is replayed to each port even if there is
        several messages that has the same replyport.
        You will always get a message even if you are the one causing it,
        check if Task pointes to your task or not.

   SEE ALSO
        TDDB_AbortMsg(), TDDB_ForceUpdate()

tddbase.library/TDDB_LockNode                   tddbase.library/TDDB_LockNode

   NAME
        TDDB_LockNode -- Make a soft lock on node.

   SYNOPSIS
        TDDB_LockNode(DBase, NodeNr)
                       A0     D0

        void TDDB_LockNode(struct DBHandle *,ULONG);

   FUNCTION
        This function places a "soft" lock on the given node. Soft locks are
        primary used to inform other programms that this specific node will
        be changed by the user.

   INPUTS
        DBase  - A handle on the database to edit.
        NodeNr - Number of the node to lock.

   NOTES
        This function does not stop other (faulty!) programs to change data
        in this node.

   SEE ALSO
        TDDB_UnLockNode()

tddbase.library/TDDB_MakeList                   tddbase.library/TDDB_MakeList

   NAME
        TDDB_MakeList -- Creates an execlist from database.

   SYNOPSIS
        Error=TDDB_MakeList(Handle,List,ID)
        D0                    A0       A1    D0

        LONG TDDB_MakeList(struct DBHandle *,struct List *,ULONG);

   FUNCTION
        This function creates a standard exec list (for use in ListViews for
        exanple). Each node will have its ln_Name attribute pointed at a
        buffer that contained the same string as the coresponding database
        node.

   INPUTS
        Handle - A handle on a database.
        List   - A initlized listheader to append nodes to.
        ID     - The field to collect strings from.

   RESULT
        Error - An errorcode or Err_NoErr (0) to signal succuess.

   NOTES
        TDDB_FreeList should ALWAYS be called, even if this function returns
        an errorcode.

   SEE ALSO
        TDDB_UpdateList(), TDDB_FreeList()

tddbase.library/TDDB_NewNode                     tddbase.library/TDDB_NewNode

   NAME
        TDDB_NewNode -- Creates a new node to store data in.

   SYNOPSIS
        Node=TDDB_NewNode(DBase)
        D0                   A0

        struct DBNode *TDDB_NewNode(struct DBHandle *);

   FUNCTION
       Creates a new, empty, node in the given database, set it to 
       write-mode and return it. 

       This also involves sending MSG_NEWNODE messages to everybody.

   INPUTS
        DBase - A handle on the database to create node in.

   RESULT
        Node - The newly created node.

   BUGS
       Created nodes MUST be unlocked in the same order they were created!

   SEE ALSO
        TDDB_FreeNode(), TDDB_DeleteNode()

tddbase.library/TDDB_OpenBase                   tddbase.library/TDDB_OpenBase

   NAME
        TDDB_OpenBase -- Open a database.

   SYNOPSIS
        DBase=TDDB_OpenBase( Name )
        D0                   A0

        struct DBHandle *TDDB_OpenBase(STRPTR)

   FUNCTION
       Tries to open a previosly created database so you can access all
       data stored in it.

       Note that this function almost always return a Handle even if the
        main databasefile failed to open, so remember to check that Error
        field.

   INPUTS
        Name - Name of main database file to open.

   RESULT
        DBase - a DBHandle that is aplied on your database if it sucsesfully
               opened.

   NOTES
       Returns a Handle even if the database failed to open, remember to
       check its Error field before usage. A handle must ALWAYS be closed
       even if the open failed.

   SEE ALSO
        TDDB_CreateBase(), TDDB_CloseBase()

tddbase.library/TDDB_SeekBaseA                 tddbase.library/TDDB_SeekBaseA

   NAME
        TDDB_SeekBaseA -- Search in database.

   SYNOPSIS
        Node=TDDB_SeekBaseA(Handle,CmpHook,SeekData, Tags);
        D0                      A0      A1        A2        A3

        struct DBNode *TDDB_SeekBaseA(struct DBHandle *,struct Hook *,APTR,
                                                        struct TagItem *);

   FUNCTION
       This function lets you search a database precisly as you wish since
       you have to do both comparison and give an offset to the next node
       to check.

       The function will then be called with "Object" pointed to a node
       that is to be compared and "Message" is the same as SeekData and
       return either the offset to next node or 0 if this is the node you
       are looking for.

       The search will end when CmpFunc returns 0 or it tries to access
       nodes with negative numbers or higher then the total number of
       nodes in database.

       Tags can be used to modify certain things about this search.
       Currenlty there is only one tag defined, SBT_StartNode wich indicates
       what number to start from instead of 0.

   INPUTS
       Handle   - Handle on database to search in.
       CmpHook  - Hook to make comparison.
       SeekData - Data sent to CmpHook.
       Tags     - Give more details about search.

   RESULT
        Node - The node that matches your criteria or NULL if none was
               found.

   NOTES
       Nodes given to CmpHook is locked in ReadOnly mode and can therefor
       not be written to. After all, writing during searches is considered
       to be a BadThing (tm).

   SEE ALSO
        TDDB_FindIntA(), TDDB_FindStringA()

tddbase.library/TDDB_SetData                     tddbase.library/TDDB_SetData

   NAME
        TDDB_SetData -- Stores one data item in database.

   SYNOPSIS
        TDDB_SetData(Handle,Node,ID,Data);

        void TDDB_SetData(struct DBHandle *,struct DBNode *,ULONG,ULONG);

   FUNCTION
        This function stores one dataitem in the given database & node. If
        the given field already exists, its data will be overwritten with
        a new value. 

   INPUTS
        Handle - A handle on the databasen that this node belongs to.
        Node   - The node that you want to store data in.
        ID       - The field you want to store data as.
        Data   - The data to be placed in database.

   SEE ALSO
        TDDB_GetNode(),TDDB_SetDataListA()

tddbase.library/TDDB_SetDataListA           tddbase.library/TDDB_SetDataListA

   NAME
        TDDB_SetDataListA -- Stores a datalist in node.

   SYNOPSIS
        TDDB_SetDataListA(DBase, Node, CmdArray)
                           A0     A1       A2

        void TDDB_SetDataListA(struct DBHandle *,struct DBNode *,
                                                    struct DataStorage *);

        TDDB_SetDataList(DBase, Node, Fält1, Data1,...)

        void TDDB_SetDataList(struct DBHandle *,struct DBNode *,ULONG, ...);

   FUNCTION
        Stores one or more datastorage elements in database.

        If there already exists a entry with the same ID it will be replaced
        and if there doesnt exist an entry, a new one will be created.

   INPUTS
        DBase    - A Handle on the database this node belongs to.
        Node     - The node you want to store data in.
        CmdArray - Data to be stored.

   BUGS
        All pointers that are located in CmdArray WILL be changed to point
        to the new buffer that can become obsolete at any time.

   SEE ALSO
        TDDB_GetNode(), TDDB_GetDataListA(), TDDB_SetData()

tddbase.library/TDDB_SwapNodes                 tddbase.library/TDDB_SwapNodes

   NAME
        TDDB_SwapNodes -- Swaps places of 2 nodes.

   SYNOPSIS
        TDDB_SwapNodes(DBase, Node1,Node2)
                        A0      D0    D1

        void TDDB_SwapNodes(struct DBHandle *, ULONG, ULONG);

   FUNCTION
       This function swaps the contents of 2 nodes wich can be used in for
       example sorting routines.

       This routine also involves sending out MSG_SWAP UpdateMsg.

   INPUTS
        DBase - Handle on database they are in.
        Node1 - Number of the first node.
        Node2 - Number of the second node.

   NOTES
       This routine does a GetNode(MODEF_WRITE) on both nodes.

   SEE ALSO
        TDDB_GetNode(),TDDB_CopyNode()

tddbase.library/TDDB_UnLockNode               tddbase.library/TDDB_UnLockNode

   NAME
        TDDB_UnLockNode -- Removes a soft lock from node.

   SYNOPSIS
        TDDB_UnLockNode(DBase, NodeNr)
                           A0       D0

        void TDDB_UnLockNode(struct DBHandle *,ULONG);

   FUNCTION
        Unlocks the given node. This will also send out MSG_NODEUNLOCK.

   INPUTS
        DBase - A database handle
        Node  - Number of the node to unlock.

    BUGS
        Currently TDDB_LockNode()&TDDB_UnLockNode does not nest so a node
        will be unlocked by the FIRST call to TDDB_UnlockNode().

   SEE ALSO
        TDDB_LockNode()

tddbase.library/TDDB_UpdateList               tddbase.library/TDDB_UpdateList

   NAME
        TDDB_UpdateList -- Update a list created by TDDB_MakeList()

   SYNOPSIS
        Err=TDDB_UpdateList(Handle,List,ID)
        D0                       A0       A1   D0

        LONG TDDB_UpdateList(struct DBHandle *,struct List *,ULONG);

   FUNCTION
        Updates a previosly created list so it matches the present contents
        of the database.

   INPUTS
        Handle - The same handle that was given to TDDB_MakeList()
        List   - The listheader given to TDDB_MakeList()
        ID     - And the field to use.

   RESULT
        Err - returns an error or Err_NoErr (0) if everything worked.

   SEE ALSO
        TDDB_MakeList(), TDDB_FreeList()

