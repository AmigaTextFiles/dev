/*
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : Mattias Karlsson
 */

#include <exec/types.h>
#include <intuition/intuition.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>
#include <proto/exec.h>
#include <proto/intuition.h>
#include <proto/gadtools.h>
#include <proto/graphics.h>
#include <proto/utility.h>
#include <proto/diskfont.h>
#include <string.h>

#include "Control.h"

struct Screen         *Scr = NULL;
UBYTE                 *PubScreenName = NULL;
APTR                   VisualInfo = NULL;
struct Window         *MainWindowWnd = NULL;
struct Gadget         *MainWindowGList = NULL;
struct Menu           *MainWindowMenus = NULL;
struct IntuiMessage    MainWindowMsg;
struct Gadget         *MainWindowGadgets[4];
UWORD                  MainWindowLeft = 128;
UWORD                  MainWindowTop = 73;
UWORD                  MainWindowWidth = 387;
UWORD                  MainWindowHeight = 59;
UBYTE                 *MainWindowWdt = (UBYTE *)"MMBase";
struct TextAttr       *Font, Attr;
UWORD                  FontX, FontY;
UWORD                  OffX, OffY;
struct TextFont       *MainWindowFont = NULL;

struct NewMenu MainWindowNewMenu[] = {
	NM_TITLE, (STRPTR)"Project", NULL, 0, NULL, NULL,
	NM_ITEM, (STRPTR)"New Node...", (STRPTR)"N", 0, 0L, (APTR)MainWindowMenu_NewNode,
	NM_ITEM, (STRPTR)NM_BARLABEL, NULL, 0, 0L, NULL,
	NM_ITEM, (STRPTR)"About...", NULL, 0, 0L, (APTR)MainWindowItem0,
	NM_ITEM, (STRPTR)"Quit", (STRPTR)"Q", 0, 0L, (APTR)MainWindowItem1,
	NM_END, NULL, NULL, 0, 0L, NULL };

UWORD MainWindowGTypes[] = {
	SCROLLER_KIND,
	TEXT_KIND,
	STRING_KIND,
	BUTTON_KIND
};

struct NewGadget MainWindowNGad[] = {
	368, 1, 14, 54, NULL, NULL, GD_Scroller, 0, NULL, (APTR)ScrollerClicked,
	80, 3, 285, 13, (UBYTE *)"Name", NULL, GD_Name, PLACETEXT_LEFT, NULL, NULL,
	80, 18, 285, 14, (UBYTE *)"Comments", NULL, GD_Comments, PLACETEXT_LEFT, NULL, (APTR)CommentsClicked,
	80, 34, 285, 20, (UBYTE *)"Show", NULL, GD_Show, PLACETEXT_IN, NULL, (APTR)ShowClicked
};

ULONG MainWindowGTags[] = {
	(GTSC_Total), 1, (GTSC_Arrows), 8, (PGA_Freedom), LORIENT_VERT, (GA_RelVerify), TRUE, (TAG_DONE),
	(GTTX_Border), TRUE, (TAG_DONE),
	(GTST_MaxChars), 256, (TAG_DONE),
	(TAG_DONE)
};

static UWORD ComputeX( UWORD value )
{
	return(( UWORD )((( FontX * value ) + 4 ) / 8 ));
}

static UWORD ComputeY( UWORD value )
{
	return(( UWORD )((( FontY * value ) + 4 ) / 8 ));
}

static void ComputeFont( UWORD width, UWORD height )
{
	Forbid();
	Font = &Attr;
	Font->ta_Name = (STRPTR)GfxBase->DefaultFont->tf_Message.mn_Node.ln_Name;
	Font->ta_YSize = FontY = GfxBase->DefaultFont->tf_YSize;
	FontX = GfxBase->DefaultFont->tf_XSize;
	Permit();

	OffX = Scr->WBorLeft;
	OffY = Scr->RastPort.TxHeight + Scr->WBorTop + 1;

	if ( width && height ) {
		if (( ComputeX( width ) + OffX + Scr->WBorRight ) > Scr->Width )
			goto UseTopaz;
		if (( ComputeY( height ) + OffY + Scr->WBorBottom ) > Scr->Height )
			goto UseTopaz;
	}
	return;

UseTopaz:
	Font->ta_Name = (STRPTR)"topaz.font";
	FontX = FontY = Font->ta_YSize = 8;
}

int SetupScreen( void )
{
	if ( ! ( Scr = LockPubScreen( PubScreenName )))
		return( 1L );

	ComputeFont( 0, 0 );

	if ( ! ( VisualInfo = GetVisualInfo( Scr, TAG_DONE )))
		return( 2L );

	return( 0L );
}

void CloseDownScreen( void )
{
	if ( VisualInfo ) {
		FreeVisualInfo( VisualInfo );
		VisualInfo = NULL;
	}

	if ( Scr        ) {
		UnlockPubScreen( NULL, Scr );
		Scr = NULL;
	}
}

int HandleMainWindowIDCMP( void )
{
	struct IntuiMessage	*m;
	struct MenuItem		*n;
	int			(*func)();
	BOOL			running = TRUE;

	while( m = GT_GetIMsg( MainWindowWnd->UserPort )) {

		CopyMem(( char * )m, ( char * )&MainWindowMsg, (long)sizeof( struct IntuiMessage ));

		GT_ReplyIMsg( m );

		switch ( MainWindowMsg.Class ) {

			case	IDCMP_REFRESHWINDOW:
				GT_BeginRefresh( MainWindowWnd );
				GT_EndRefresh( MainWindowWnd, TRUE );
				break;

			case	IDCMP_CLOSEWINDOW:
				running = MainWindowCloseWindow();
				break;

			case	IDCMP_GADGETUP:
			case	IDCMP_GADGETDOWN:
				func = ( void * )(( struct Gadget * )MainWindowMsg.IAddress )->UserData;
				running = func();
				break;

			case	IDCMP_MENUPICK:
				while( MainWindowMsg.Code != MENUNULL ) {
					n = ItemAddress( MainWindowMenus, MainWindowMsg.Code );
					func = (void *)(GTMENUITEM_USERDATA( n ));
					running = func();
					MainWindowMsg.Code = n->NextSelect;
				}
				break;
		}
	}
	return( running );
}

int OpenMainWindowWindow( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		wleft = MainWindowLeft, wtop = MainWindowTop, ww, wh;

	ComputeFont( MainWindowWidth, MainWindowHeight );

	ww = ComputeX( MainWindowWidth );
	wh = ComputeY( MainWindowHeight );

	if (( wleft + ww + OffX + Scr->WBorRight ) > Scr->Width ) wleft = Scr->Width - ww;
	if (( wtop + wh + OffY + Scr->WBorBottom ) > Scr->Height ) wtop = Scr->Height - wh;

	if ( ! ( MainWindowFont = OpenDiskFont( Font )))
		return( 5L );

	if ( ! ( g = CreateContext( &MainWindowGList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < MainWindow_CNT; lc++ ) {

		CopyMem((char * )&MainWindowNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr   = Font;
		ng.ng_LeftEdge   = OffX + ComputeX( ng.ng_LeftEdge );
		ng.ng_TopEdge    = OffY + ComputeY( ng.ng_TopEdge );
		ng.ng_Width      = ComputeX( ng.ng_Width );
		ng.ng_Height     = ComputeY( ng.ng_Height);

		MainWindowGadgets[ lc ] = g = CreateGadgetA((ULONG)MainWindowGTypes[ lc ], g, &ng, ( struct TagItem * )&MainWindowGTags[ tc ] );

		while( MainWindowGTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	if ( ! ( MainWindowMenus = CreateMenus( MainWindowNewMenu, GTMN_FrontPen, 0L, TAG_DONE )))
		return( 3L );

	LayoutMenus( MainWindowMenus, VisualInfo, TAG_DONE );

	if ( ! ( MainWindowWnd = OpenWindowTags( NULL,
				WA_Left,	wleft,
				WA_Top,		wtop,
				WA_Width,	ww + OffX + Scr->WBorRight,
				WA_Height,	wh + OffY + Scr->WBorBottom,
				WA_IDCMP,	SCROLLERIDCMP|ARROWIDCMP|TEXTIDCMP|STRINGIDCMP|BUTTONIDCMP|IDCMP_MENUPICK|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW,
				WA_Flags,	WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH,
				WA_Gadgets,	MainWindowGList,
				WA_Title,	MainWindowWdt,
				WA_ScreenTitle,	"MultiMediaBase 1.0  © 1996 BetaSoft",
				WA_PubScreen,	Scr,
				TAG_DONE )))
	return( 4L );

	SetMenuStrip( MainWindowWnd, MainWindowMenus );
	GT_RefreshWindow( MainWindowWnd, NULL );

	return( 0L );
}

void CloseMainWindowWindow( void )
{
	if ( MainWindowMenus      ) {
		ClearMenuStrip( MainWindowWnd );
		FreeMenus( MainWindowMenus );
		MainWindowMenus = NULL;	}

	if ( MainWindowWnd        ) {
		CloseWindow( MainWindowWnd );
		MainWindowWnd = NULL;
	}

	if ( MainWindowGList      ) {
		FreeGadgets( MainWindowGList );
		MainWindowGList = NULL;
	}

	if ( MainWindowFont ) {
		CloseFont( MainWindowFont );
		MainWindowFont = NULL;
	}
}

