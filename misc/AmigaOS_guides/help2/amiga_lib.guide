@database "amiga_lib.guide"
@master "Work:Programing/sc/OS3.1_Docs/doc/amiga_lib.doc"

@Node Main "amiga_lib.guide"
@{b}@{u}tasks:@{uu}@{ub}          @{b}@{u}ports:@{uu}@{ub}            @{b}@{u}tooltypes:@{uu}@{ub}      @{b}@{u}memory pools:@{uu}@{ub}     @{b}@{u}encrypting:@{uu}@{ub}
@{"CreateTask()" Link "CreateTask()"}   @{"CreatePort()" Link "CreatePort()"}     @{"ArgArrayInit()" Link "ArgArrayInit()"} @{"LibAllocPooled()" Link "LibAllocPooled()"} @{"ACrypt()" Link "ACrypt()"}
@{"AddTOF()" Link "AddTOF()"}       @{"DeletePort()" Link "DeletePort()"}     @{"ArgInt()" Link "ArgInt()"}       @{"LibCreatePool()" Link "LibCreatePool()"}  @{b}@{u}ffp math:@{uu}@{ub}
@{"RemTOF()" Link "RemTOF()"}       @{b}@{u}classes&messages:@{uu}@{ub} @{"ArgString()" Link "ArgString()"}    @{"LibDeletePool()" Link "LibDeletePool()"}  @{"arnd()" Link "arnd()"}
@{"DeleteTask()" Link "DeleteTask()"}   @{"SetSuperAttrs()" Link "SetSuperAttrs()"}  @{"ArgArrayDone()" Link "ArgArrayDone()"} @{"LibFreePooled()" Link "LibFreePooled()"}  @{"afp()" Link "afp()"}
@{b}@{u}commodities:@{uu}@{ub}    @{"DoSuperMethodA()" Link "DoSuperMethodA()"} @{b}@{u}input events:@{uu}@{ub}   @{b}@{u}lists:@{uu}@{ub}            @{"dbf()" Link "dbf()"}
@{"CxCustom()" Link "CxCustom()"}     @{"DoSuperMethod()" Link "DoSuperMethod()"}  @{"InvertString()" Link "InvertString()"} @{"NewList()" Link "NewList()"}        @{"fpa()" Link "fpa()"}
@{"CxSignal()" Link "CxSignal()"}     @{"CoerceMethodA()" Link "CoerceMethodA()"}  @{"FreeIEvents()" Link "FreeIEvents()"}  @{b}@{u}hooks:@{uu}@{ub}            @{"FastRand()" Link "FastRand()"}
@{"CxFilter()" Link "CxFilter()"}     @{"CoerceMethod()" Link "CoerceMethod()"}   @{b}@{u}stdin/out:@{uu}@{ub}      @{"CallHookA()" Link "CallHookA()"}      @{"RangeRand()" Link "RangeRand()"}
@{"CxTranslate()" Link "CxTranslate()"}  @{"DoMethodA()" Link "DoMethodA()"}      @{"stdio()" Link "stdio()"}        @{"CallHook()" Link "CallHook()"}       @{b}@{u}delay:@{uu}@{ub}
@{"CxSender()" Link "CxSender()"}     @{"DoMethod()" Link "DoMethod()"}       @{"printf()" Link "printf()"}       @{"HookEntry()" Link "HookEntry()"}      @{"TimeDelay()" Link "TimeDelay()"}
@{"HotKey()" Link "HotKey()"}       @{b}@{u}device I/O:@{uu}@{ub}       @{"sprintf()" Link "sprintf()"}
@{"CxDebug()" Link "CxDebug()"}      @{"CreateExtIO()" Link "CreateExtIO()"}
@{b}@{u}arexx:@{uu}@{ub}          @{"BeginIO()" Link "BeginIO()"}
@{"CheckRexxMsg()" Link "CheckRexxMsg()"} @{"DeleteExtIO()" Link "DeleteExtIO()"}                 @{"same, but sorted" link SORTED}
@{"SetRexxVar()" Link "SetRexxVar()"}   @{"CreateStdIO()" Link "CreateStdIO()"}
@{"GetRexxVar()" Link "GetRexxVar()"}   @{"DeleteStdIO()" Link "DeleteStdIO()"}
@EndNode
@node SORTED "sorted"
@{"ACrypt()" Link "ACrypt()"}        @{"CxCustom()" Link "CxCustom()"}       @{"GetRexxVar()" Link "GetRexxVar()"}
@{"AddTOF()" Link "AddTOF()"}        @{"CxDebug()" Link "CxDebug()"}        @{"HookEntry()" Link "HookEntry()"}
@{"afp()" Link "afp()"}           @{"CxFilter()" Link "CxFilter()"}       @{"HotKey()" Link "HotKey()"}
@{"ArgArrayDone()" Link "ArgArrayDone()"}  @{"CxSender()" Link "CxSender()"}       @{"InvertString()" Link "InvertString()"}
@{"ArgArrayInit()" Link "ArgArrayInit()"}  @{"CxSignal()" Link "CxSignal()"}       @{"NewList()" Link "NewList()"}
@{"ArgInt()" Link "ArgInt()"}        @{"CxTranslate()" Link "CxTranslate()"}    @{"printf()" Link "printf()"}
@{"ArgString()" Link "ArgString()"}     @{"dbf()" Link "dbf()"}            @{"RangeRand()" Link "RangeRand()"}
@{"arnd()" Link "arnd()"}          @{"DeleteExtIO()" Link "DeleteExtIO()"}    @{"RemTOF()" Link "RemTOF()"}
@{"BeginIO()" Link "BeginIO()"}       @{"DeletePort()" Link "DeletePort()"}     @{"SetRexxVar()" Link "SetRexxVar()"}
@{"CallHook()" Link "CallHook()"}      @{"DeleteStdIO()" Link "DeleteStdIO()"}    @{"SetSuperAttrs()" Link "SetSuperAttrs()"}
@{"CallHookA()" Link "CallHookA()"}     @{"DeleteTask()" Link "DeleteTask()"}     @{"sprintf()" Link "sprintf()"}
@{"CheckRexxMsg()" Link "CheckRexxMsg()"}  @{"DoMethod()" Link "DoMethod()"}       @{"stdio()" Link "stdio()"}
@{"CoerceMethod()" Link "CoerceMethod()"}  @{"DoMethodA()" Link "DoMethodA()"}      @{"TimeDelay()" Link "TimeDelay()"}
@{"CoerceMethodA()" Link "CoerceMethodA()"} @{"DoSuperMethod()" Link "DoSuperMethod()"}  @{"LibAllocPooled()" Link "LibAllocPooled()"}
@{"CreateExtIO()" Link "CreateExtIO()"}   @{"DoSuperMethodA()" Link "DoSuperMethodA()"} @{"LibCreatePool()" Link "LibCreatePool()"}
@{"CreatePort()" Link "CreatePort()"}    @{"FastRand()" Link "FastRand()"}       @{"LibDeletePool()" Link "LibDeletePool()"}
@{"CreateStdIO()" Link "CreateStdIO()"}   @{"fpa()" Link "fpa()"}            @{"LibFreePooled()" Link "LibFreePooled()"}
@{"CreateTask()" Link "CreateTask()"}    @{"FreeIEvents()" Link "FreeIEvents()"}














@endnode
@Node "ACrypt()" "amiga.lib/ACrypt"
@{b}@{u}ACrypt@{uu}@{ub} -- Encrypt a password.@{FG fill}(V37)@{FG text}
  This function takes a buffer of at least 12 characters in length,
  an unencrypted password and the user's name (as known to the host
  system) and returns an encrypted password in the passed buffer.
  This is a one-way encryption.Normally, the user's encrypted
  password is stored in a file for future password comparison.
SYNOPSIS  STRPTR ACrypt( STRPTR, STRPTR, STRPTR);
  @{i}@{b}newpass@{ub}@{ui} = ACcrypt( @{i}buffer@{ui}, @{i}password@{ui}, @{i}username@{ui} )
  @{i}buffer@{ui}    - a pointer to a buffer at least 12 bytes in length.
  @{i}password@{ui}  - a pointer to an unencrypted password string.
  @{i}username@{ui}  - a pointer to the user's name.
  @{i}@{b}newpass@{ub}@{ui}   - a pointer to the passed buffer if successful, NULL upon failure.
    The encrypted password placed in the buffer will be be eleven (11)
    characters in length and will be NULL-terminated.
EXAMPLE
  UBYTE *@{i}pw@{ui}, *getpassword() ;
  UBYTE *@{i}user@{ui} = "alf"
  UBYTE *@{i}newpass@{ui} ;
  UBYTE @{i}buffer@{ui}[16] ;         /* size >= 12 */
  @{i}pw@{ui} = getpassword() ;   /* your own function */
  @{FG shine}if@{FG text}((@{i}newpass@{ui} = ACrypt(@{i}buffer@{ui}, @{i}pw@{ui}, @{i}user@{ui})) != NULL)
  {
    printf("pw = %s\n", newpass) ; /* newpass = &buffer[0] */
  } @{FG shine}else@{FG text} {
    printf("ACrypt failed\n") ;
  }
NOTES
  This function first appeared in later V39 versions of amiga.lib,
  but works under V37 and up.
@EndNode
@Node "AddTOF()" "amiga.lib/AddTOF"
@{u}@{b}AddTOF@{ub}@{uu} -- add a task to the VBlank interrupt server chain.
  Adds a task to the vertical-blanking interval interrupt server
  chain.This prevents C programmers from needing to write an
  assembly language stub to do this function.
SYNOPSIS  @{FG shine}void@{FG text} AddTOF(@{FG shine}struct@{FG text} @{"Isrvstr" Link "include:graphics/graphint.h/Main" 19} *, APTR, APTR);
  AddTOF(@{i}i@{ui},@{i}p@{ui},@{i}a@{ui});
  @{i}i@{ui} - pointer to an initialized Isrvstr structure
  @{i}p@{ui} - pointer to the C-code routine that this server is to call each time
    TOF happens
  @{i}a@{ui} - pointer to the first longword in an array of longwords that is to be used
    as the arguments passed to your routine pointed to by p.
SEE ALSO
  @{"RemTOF()" Link "RemTOF()"}, @{"<graphics/graphint.h>" Link "include:graphics/graphint.h/Main" 0}
@EndNode
@Node "afp()" "amiga.lib/afp"
@{b}@{u}afp@{uu}@{ub} -- Convert ASCII string variable into fast floating point.
  Accepts the address of the ASCII string in C format that is converted into an
  FFP floating point number.
  The string is expected in this Format:
  {S}{digits}{'.'}{digits}{'E'}{S}{digits}
  <*******MANTISSA*******><***EXPONENT***>
  @{b}Syntax rules@{ub}:
  Both signs are optional and are '+' or '-'.The mantissa must be
  present.The exponent need not be present.The mantissa may lead
  with a decimal point.The mantissa need not have a decimal point.
  @{b}Examples@{ub}: All of these values represent the number fourty-two.
         42      .042e3
         42.+.042e+03
        +42.0.000042e6
    0000042.00   420000e-4
           420000.00e-0004
  @{b}Floating point range@{ub}:
  Fast floating point supports the value zero and non-zero values
  within the following bounds:
      18             20
   9.22337177 x 10   > +number >  5.42101070 x 10
      18             -20
  -9.22337177 x 10   > -number > -2.71050535 x 10
  @{b}Precision@{ub}:
  This conversion results in a 24 bit precision with guaranteed
  error less than or equal to one-half least significant bit.
SYNOPSIS
  @{i}@{b}ffp_value@{ub}@{ui} = afp(@{i}string@{ui});
  @{i}string@{ui} - Pointer to the ASCII string to be converted.
  @{i}@{b}string@{ub}@{ui} - points to the character which terminated the scan
  @{i}@{b}equ@{ub}@{ui} - fast floating point equivalent
@EndNode
@Node "ArgArrayDone()" "amiga.lib/ArgArrayDone"
@{b}@{u}ArgArrayDone@{uu}@{ub} -- release the memory allocated by a previous call to
  @{"ArgArrayInit()" Link "ArgArrayInit()"}.@{FG fill}(V36)@{FG text}
  This function frees memory and does cleanup required after a
  call to @{"ArgArrayInit()" Link "ArgArrayInit()"}.Don't call this until you are done using
  the ToolTypes argument strings.
SYNOPSIS  @{FG shine}void@{FG text} ArgArrayDone(@{FG shine}void@{FG text});
  ArgArrayDone();
SEE ALSO
  @{"ArgArrayInit()" Link "ArgArrayInit()"}
@EndNode
@Node "ArgArrayInit()" "amiga.lib/ArgArrayInit"
@{b}@{u}ArgArrayInit@{uu}@{ub} -- allocate and initialize a tooltype array.@{FG fill}(V36)@{FG text}
  This function returns a null-terminated array of strings
  suitable for sending to @{"icon.library/FindToolType()" Link "libs.guide/FindToolType()"}.This array will
  be the ToolTypes array of the program's icon, if it was started from
  Workbench.It will just be 'argv' if the program was started from a shell.
  Pass ArgArrayInit() your startup arguments received by main().
  ArgArrayInit() requires that icon.library be open (even if the caller
  was started from a shell, so that the function @{"FindToolType()" Link "libs.guide/FindToolType()"} can be
  used) and may call @{"GetDiskObject()" Link "libs.guide/GetDiskObject()"}, so clean up is necessary when
  the strings are no longer needed.The function @{"ArgArrayDone()" Link "ArgArrayDone()"} does just that.
SYNOPSIS  UBYTE **ArgArrayInit(@{FG shine}long@{FG text},UBYTE **);
  @{i}@{b}ttypes@{ub}@{ui} = ArgArrayInit(@{i}argc@{ui},@{i}argv@{ui});
  @{i}argc@{ui} - the number of arguments in argv, 0 when started from Workbench
  @{i}argv@{ui} - an array of pointers to the program's arguments, or the
    Workbench startup message when started from WB.
  @{i}@{b}ttypes@{ub}@{ui} - the initialized argument array or NULL if it could not be allocated
EXAMPLE
  Use of these routines facilitates the use of ToolTypes or command-
  line arguments to control end-user parameters in Commodities
  applications.For example, a filter used to trap a keystroke for
  popping up a window might be created by something like this:
    @{FG shine}char@{FG text} *@{i}ttypes@{ui} = ArgArrayInit(@{i}argc@{ui}, @{i}argv@{ui});
    CxObj *@{i}filter@{ui} = UserFilter(@{i}ttypes@{ui}, "POPWINDOW", "alt f1");
           ...with ...
    CxObj *UserFilter(@{FG shine}char@{FG text} **@{i}tt@{ui}, @{FG shine}char@{FG text} *@{i}action_name@{ui}, @{FG shine}char@{FG text} *@{i}default_descr@{ui})
    {
    @{FG shine}char@{FG text} *@{i}desc@{ui};
      @{i}desc@{ui} = FindToolType(@{i}tt@{ui},@{i}action_name@{ui});
      @{FG shine}return@{FG text}(CxFilter((ULONG)(@{i}desc@{ui}? @{i}desc@{ui}: @{i}default_descr@{ui})));
    }
  In this way the user can assign "alt f2" to the action by
  entering a tooltype in the program's icon of the form:
    POPWINDOW=alt f2
  or by starting the program from the CLI like so:
    myprogram "POPWINDOW=alt f2"
NOTE
  Your program must open icon.library and set up IconBase before calling
  this routine.In addition IconBase must remain valid until after
  @{"ArgArrayDone()" Link "ArgArrayDone()"} has been called!
SEE ALSO
  @{"ArgArrayDone()" Link "ArgArrayDone()"}, @{"ArgString()" Link "ArgString()"}, @{"ArgInt()" Link "ArgInt()"}, @{"icon.library/FindToolType()" Link "libs.guide/FindToolType()"}
@EndNode
@Node "ArgInt()" "amiga.lib/ArgInt"
@{b}@{u}ArgInt@{uu}@{ub} -- return an integer value from a ToolTypes array.@{FG fill}(V36)@{FG text}
  This function looks in the ToolTypes array 'tt' returned
  by @{"ArgArrayInit()" Link "ArgArrayInit()"} for 'entry' and returns the value associated
  with it.'tt' is in standard ToolTypes format such as:
    ENTRY=Value
  The Value string is passed to atoi() and the result is returned by
  this function.
  If 'entry' is not found, the integer 'defaultval' is returned.
SYNOPSIS  @{FG shine}long@{FG text} ArgInt(UBYTE **,STRPTR,@{FG shine}long@{FG text});
  @{i}@{b}value@{ub}@{ui} = ArgInt(@{i}tt@{ui},@{i}entry@{ui},@{i}defaultval@{ui})
  @{i}tt@{ui} - a ToolTypes array as returned by @{"ArgArrayInit()" Link "ArgArrayInit()"}
  @{i}entry@{ui} - the entry in the ToolTypes array to search for
  @{i}defaultval@{ui} - the value to return in case 'entry' is not found within
    the ToolTypes array
  @{i}@{b}value@{ub}@{ui} - the value associated with 'entry', or defaultval if 'entry'
    is not in the ToolTypes array
NOTES
  This function requires that dos.library V36 or higher be opened.
SEE ALSO
  @{"ArgArrayInit()" Link "ArgArrayInit()"}
@EndNode
@Node "ArgString()" "amiga.lib/ArgString"
@{b}@{u}ArgString@{uu}@{ub} -- return a string pointer from a ToolTypes array.@{FG fill}(V36)@{FG text}
  This function looks in the ToolTypes array 'tt' returned
  by @{"ArgArrayInit()" Link "ArgArrayInit()"} for 'entry' and returns the value associated
  with it.'tt' is in standard ToolTypes format such as:
    ENTRY=Value
  This function returns a pointer to the Value string.
  If 'entry' is not found, 'defaultstring' is returned.
SYNOPSIS  STRPTR ArgString(UBYTE **,STRPTR,STRPTR);
  @{i}@{b}string@{ub}@{ui} = ArgString(@{i}tt@{ui},@{i}entry@{ui},@{i}defaultstring@{ui})
  @{i}tt@{ui} - a ToolTypes array as returned by @{"ArgArrayInit()" Link "ArgArrayInit()"}
  @{i}entry@{ui} - the entry in the ToolTypes array to search for
  @{i}defaultstring@{ui} - the value to return in case 'entry' is not found within
    the ToolTypes array
  @{i}@{b}value@{ub}@{ui} - the value associated with 'entry', or defaultstring if 'entry'
    is not in the ToolTypes array
SEE ALSO
  @{"ArgArrayInit()" Link "ArgArrayInit()"}
@EndNode
@Node "arnd()" "amiga.lib/arnd"
@{b}@{u}arnd@{uu}@{ub} - ASCII round of the provided floating point string.
  Accepts an ASCII string representing an FFP floating point
  number, the binary representation of the exponent of said
  floating point number and the number of places to round to.
  A rounding process is initiated, either to the left or right
  of the decimal place and the result placed back at the
  input address defined by &string[0].
SYNOPSIS
  arnd(@{i}place@{ui}, @{i}exp@{ui}, @{i}&string@{ui}[0]);
  @{i}place@{ui} - integer representing number of decimal places to round to
  @{i}exp@{ui} - integer representing exponent value of the ASCII string
  @{i}&string@{ui}[0] - address where rounded ASCII string is to be placed (16 bytes)
  @{i}@{b}&string@{ub}@{ui}[0] - rounded ASCII string
@EndNode
@Node "BeginIO()" "amiga.lib/BeginIO"
@{b}@{u}BeginIO@{uu}@{ub} -- initiate asynchronous device I/O.
  This function takes an IORequest, and passes it directly to the
  "BeginIO" vector of the proper device.This is equivalent to
  @{"SendIO()" Link "exec.guide/SendIO()"}, except that io_Flags is not cleared.A good understanding
  of Exec device I/O is required to properly use this function.
  This function does not wait for the I/O to complete.
SYNOPSIS  @{FG shine}void@{FG text} BeginIO(@{FG shine}struct@{FG text} @{"IORequest" Link "include:exec/io.h/Main" 18} *);
  BeginIO(@{i}ioReq@{ui})
  @{i}ioReq@{ui} - an initialized and opened IORequest structure with the io_Flags
    field set to a reasonable value (set to 0 if you do not require io_Flags).
SEE ALSO
  @{"exec.library/DoIO()" Link "exec.guide/DoIO()"}, @{"exec.library/SendIO()" Link "exec.guide/SendIO()"}, @{"exec.library/WaitIO()" Link "exec.guide/WaitIO()"}
@EndNode
@Node "CallHook()" "amiga.lib/CallHook"
@{b}@{u}CallHook@{uu}@{ub} -- Invoke a hook given a message on the stack.
  Like @{"CallHookA()" Link "CallHookA()"}, CallHook() invoke a hook on the supplied
  hook-specific data (an "object") and a parameter packet ("message").
  However, CallHook() allows you to build the message on your stack.
  hookPtr - A system-standard hook
SYNOPSIS  ULONG CallHook( @{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *, Object *, ...);
  @{i}@{b}result@{ub}@{ui} = CallHook( @{i}hookPtr@{ui}, @{i}obj@{ui}, ...)
  @{i}obj@{ui} - hook-specific data object
  ...- The hook-specific message you wish to send.The hook is expecting
    a pointer to the message, so a pointer into your stack will be sent.
  @{i}@{b}result@{ub}@{ui} - a hook-specific result.
NOTES
  This function first appeared in the V37 release of amiga.lib.
  However, it does not depend on any particular version of the OS,
  and works fine even in V34.
EXAMPLE
  If your hook's message was
    @{FG shine}struct@{FG text} myMessage
    {
      ULONG @{i}mm_FirstGuy@{ui};
      ULONG @{i}mm_SecondGuy@{ui};
      ULONG @{i}mm_ThirdGuy@{ui};
    };
  You could write:
    @{i}@{b}result@{ub}@{ui} = CallHook( @{i}hook@{ui}, @{i}obj@{ui}, @{i}firstguy@{ui}, @{i}secondguy@{ui}, @{i}thirdguy@{ui} );
  as a shorthand for:
    @{FG shine}struct@{FG text} @{i}myMessage@{ui} @{i}msg@{ui};
    msg.@{i}mm_FirstGuy@{ui} = @{i}firstguy@{ui};
    msg.@{i}mm_SecondGuy@{ui} = @{i}secondguy@{ui};
    msg.@{i}mm_ThirdGuy@{ui} = @{i}thirdguy@{ui};
    @{i}@{b}result@{ub}@{ui} = CallHookA( @{i}hook@{ui}, @{i}obj@{ui}, @{i}&msg@{ui} );
SEE ALSO
  @{"CallHookA()" Link "CallHookA()"}, @{"utility.library/CallHookPkt()" Link "ROMlibs.guide/CallHookPkt()"}, @{"<utility/hooks.h>" Link "include:utility/hooks.h/Main" 0}
@EndNode
@Node "CallHookA()" "amiga.lib/CallHookA"
@{b}@{u}CallHookA@{uu}@{ub} -- Invoke a hook given a pointer to a message.
  Invoke a hook on the supplied hook-specific data (an "object")
  and a parameter packet ("message").This function is equivalent
  to @{"utility.library/CallHookPkt()" Link "ROMlibs.guide/CallHookPkt()"}.
SYNOPSIS  ULONG CallHook( @{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *, Object *, APTR );
  @{i}@{b}result@{ub}@{ui} = CallHookA( @{i}hookPtr@{ui}, @{i}obj@{ui}, @{i}message@{ui} )
  @{i}hookPtr@{ui} - A system-standard hook
  @{i}obj@{ui} - hook-specific data object
  @{i}message@{ui} - The hook-specific message you wish to send
  @{i}@{b}result@{ub}@{ui} - a hook-specific result.
NOTES
  This function first appeared in the V37 release of amiga.lib.
  However, it does not depend on any particular version of the OS,
  and works fine even in V34.
SEE ALSO
  @{"CallHook()" Link "CallHook()"}, @{"utility.library/CallHookPkt()" Link "ROMlibs.guide/CallHookPkt()"}, @{"<utility/hooks.h>" Link "include:utility/hooks.h/Main" 0}
@EndNode
@Node "CheckRexxMsg()" "amiga.lib/CheckRexxMsg"
@{b}@{u}CheckRexxMsg@{uu}@{ub} - Check if a RexxMsg is from ARexx.
  This function checks to make sure that the message is from ARexx
  directly.It is required when using the Rexx Variable Interface
  routines (RVI) that the message be from ARexx.
  While this function is new in the V37 amiga.lib, it is safe to
  call it in all versions of the operating system.It is also
  PURE code, thus usable in resident/pure executables.
SYNOPSIS  BOOL CheckRexxMsg(@{FG shine}struct@{FG text} @{"RexxMsg" Link "include:rexx/storage.h/Main" 98} *);
  @{i}@{b}result@{ub}@{ui} = CheckRexxMsg(@{i}message@{ui})
   D0                    A0
  @{i}message@{ui} - pointer to the RexxMsg in question
  @{i}@{b}result@{ub}@{ui} - boolean - TRUE if message is from ARexx.
NOTE
  This is a stub in amiga.lib.It is only available via amiga.lib.
  The stub has two labels.One, _CheckRexxMsg, takes the arguments from
  the stack.The other, CheckRexxMsg, takes the arguments in registers.
EXAMPLE
  @{FG shine}if@{FG text} (CheckRexxMsg(@{i}rxmsg@{ui}))
  {
    /* @{"Message" Link "include:exec/ports.h/Main" 48} is one from ARexx */
  }
SEE ALSO
  @{"GetRexxVar()" Link "GetRexxVar()"}, @{"SetRexxVar()" Link "SetRexxVar()"}
@EndNode
@Node "CoerceMethod()" "amiga.lib/CoerceMethod"
@{b}@{u}CoerceMethod@{uu}@{ub} -- Perform method on coerced object.
  Boopsi support function that invokes the supplied message
  on the specified object, as though it were the specified
  class.Equivalent to @{"CoerceMethodA()" Link "CoerceMethodA()"}, but allows you to
  build the message on the stack.
SYNOPSIS  ULONG CoerceMethod( @{FG shine}struct@{FG text} IClass *, Object *, ULONG, ...);
  @{i}@{b}result@{ub}@{ui} = CoerceMethod( @{i}cl@{ui}, @{i}obj@{ui}, @{i}MethodID@{ui}, ...)
  @{i}cl@{ui} - pointer to boopsi class to receive the message
  @{i}obj@{ui} - pointer to boopsi object
  ...- method-specific message built on the stack
  @{i}@{b}result@{ub}@{ui} - class and message-specific result.
NOTES
  This function first appears in the V37 release of amiga.lib.
  While it intrinsically does not require any particular release
  of the system software to operate, it is designed to work with
  the boopsi subsystem of Intuition, which was only introduced in V36.
SEE ALSO
  @{"CoerceMethodA()" Link "CoerceMethodA()"}, @{"DoMethodA()" Link "DoMethodA()"}, @{"DoSuperMethodA()" Link "DoSuperMethodA()"}, @{"<intuition/classusr.h>" Link "include:intuition/classusr.h/Main" 0}
  ROM Kernel Manual boopsi section
@EndNode
@Node "CoerceMethodA()" "amiga.lib/CoerceMethodA"
@{b}@{u}CoerceMethodA@{uu}@{ub} -- Perform method on coerced object.
  Boopsi support function that invokes the supplied message
  on the specified object, as though it were the specified class.
SYNOPSIS  ULONG CoerceMethodA( @{FG shine}struct@{FG text} IClass *, Object *, Msg );
  @{i}@{b}result@{ub}@{ui} = CoerceMethodA( @{i}cl@{ui}, @{i}obj@{ui}, @{i}msg@{ui} )
  @{i}cl@{ui} - pointer to boopsi class to receive the message
  @{i}obj@{ui} - pointer to boopsi object
  @{i}msg@{ui} - pointer to method-specific message to send
  @{i}@{b}result@{ub}@{ui} - class and message-specific result.
NOTES
  This function first appears in the V37 release of amiga.lib.
  While it intrinsically does not require any particular release
  of the system software to operate, it is designed to work with
  the boopsi subsystem of Intuition, which was only introduced in V36.
  Some early example code may refer to this function as CM().
SEE ALSO
  @{"CoerceMethod()" Link "CoerceMethod()"}, @{"DoMethodA()" Link "DoMethodA()"}, @{"DoSuperMethodA()" Link "DoSuperMethodA()"}, @{"<intuition/classusr.h>" Link "include:intuition/classusr.h/Main" 0}
  ROM Kernel Manual boopsi section
@EndNode
@Node "CreateExtIO()" "amiga.lib/CreateExtIO"
@{b}@{u}CreateExtIO@{uu}@{ub} -- create an IORequest structure.
  Allocates memory for and initializes a new IO request block
  of a user-specified number of bytes.The number of bytes
  MUST be the size of a legal IORequest (or extended IORequest)
  or very nasty things will happen.
SYNOPSIS  @{FG shine}struct@{FG text} @{"IORequest" Link "include:exec/io.h/Main" 18} *CreateExtIO(@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *, ULONG);
  @{i}@{b}ioReq@{ub}@{ui} = CreateExtIO(@{i}port@{ui},@{i}ioSize@{ui});
  @{i}port@{ui} - an already initialized message port to be used for this IO
    request's reply port.If this is NULL this function fails.
  @{i}ioSize@{ui} - the size of the IO request to be created.
  @{i}@{b}ioReq@{ub}@{ui} - a new IO Request block, or NULL if there was not enough memory
EXAMPLE
  @{FG shine}if@{FG text} (@{i}ioReq@{ui} = CreateExtIO(CreatePort(NULL,0),@{FG shine}sizeof@{FG text}(@{FG shine}struct@{FG text} IOExtTD)))
SEE ALSO
  @{"DeleteExtIO()" Link "DeleteExtIO()"}, @{"CreatePort()" Link "CreatePort()"}, @{"exec.library/CreateMsgPort()" Link "exec.guide/CreateMsgPort()"}
@EndNode
@Node "CreatePort()" "amiga.lib/CreatePort"
@{b}@{u}CreatePort@{uu}@{ub}@{b}@{u}@{uu}@{ub} - Allocate and initialize a new message port.
  Allocates and initializes a new message port.The message list
  of the new port will be prepared for use (via NewList).A signal
  bit will be allocated, and the port will be set to signal your
  task when a message arrives (PA_SIGNAL).
  You *must* use @{"DeletePort()" Link "DeletePort()"} to delete ports created with CreatePort()!
SYNOPSIS  @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *CreatePort(STRPTR,@{FG shine}long@{FG text});
  @{i}@{b}port@{ub}@{ui} = CreatePort(@{i}name@{ui},@{i}pri@{ui})
  @{i}name@{ui} - public name of the port, or NULL if the port is not named.
    The name string is not copied.Most ports do not need names,
    see notes below on this.
  @{i}pri@{ui}  - Priority used for insertion into the public port list, normally 0.
  @{i}@{b}port@{ub}@{ui} - a new MsgPort structure ready for use, or NULL if the port
    could not be created due to not enough memory or no available signal bit.
NOTE
  In most cases, ports should not be named.Named ports are used for
  rendez-vous between tasks.Everytime a named port needs to be located,
  the list of all named ports must be traversed.The more named
  ports there are, the longer this list traversal takes.Thus, unless
  you really need to, do not name your ports, which will keep them off
  of the named port list and improve system performance.
BUGS
  With versions of amiga.lib prior to V37.14, this function would
  not fail even though it couldn't allocate a signal bit.The port
  would be returned with no signal allocated.
SEE ALSO
  @{"DeletePort()" Link "DeletePort()"}, @{"exec.library/FindPort()" Link "exec.guide/FindPort()"}, @{"<exec/ports.h>" Link "include:exec/ports.h/Main" 0},
  @{"exec.library/CreateMsgPort()" Link "exec.guide/CreateMsgPort()"}
@EndNode
@Node "CreateStdIO()" "amiga.lib/CreateStdIO"
@{b}@{u}CreateStdIO@{uu}@{ub} -- create an IOStdReq structure.
  Allocates memory for and initializes a new IOStdReq structure.
SYNOPSIS  @{FG shine}struct@{FG text} @{"IOStdReq" Link "include:exec/io.h/Main" 27} *CreateStdIO(@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *)
  @{i}@{b}ioReq@{ub}@{ui} = CreateStdIO(@{i}port@{ui});
  @{i}port@{ui} - an already initialized message port to be used for this IO
    request's reply port.If this is NULL this function fails.
  @{i}@{b}ioReq@{ub}@{ui} - a new IOStdReq structure, or NULL if there was not enough memory
SEE ALSO
  @{"DeleteStdIO()" Link "DeleteStdIO()"}, @{"CreateExtIO()" Link "CreateExtIO()"}, @{"exec.library/CreateIORequest()" Link "exec.guide/CreateIORequest()"}
@EndNode
@Node "CreateTask()" "amiga.lib/CreateTask"
@{b}@{u}CreateTask@{uu}@{ub} -- Create task with given name, priority, stacksize.
  This function simplifies program creation of sub-tasks by
  dynamically allocating and initializing required structures
  and stack space, and adding the task to Exec's task list
  with the given name and priority.A tc_MemEntry list is provided
  so that all stack and structure memory allocated by CreateTask()
  is automatically deallocated when the task is removed.
  An Exec task may not call dos.library functions or any function
  which might cause the loading of a disk-resident library, device,
  or file (since such functions are indirectly calls to dos.library).
  Only AmigaDOS Processes may call AmigaDOS; see the
  @{"dos.library/CreateProc()" Link "dos.guide/CreateProc()"} or the @{"dos.library/CreateNewProc()" Link "dos.guide/CreateNewProc()"}
  functions for more information.
  If other tasks or processes will need to find this task by name,
  provide a complex and unique name to avoid conflicts.
  If your compiler provides automatic insertion of stack-checking
  code, you may need to disable this feature when compiling sub-task
  code since the stack for the subtask is at a dynamically allocated
  location.If your compiler requires 68000 registers to contain
  particular values for base relative addressing, you may need to
  save these registers from your main process, and restore them
  in your initial subtask code.
  The function entry initPC is generally provided as follows:
  In C:
  @{FG shine}extern@{FG text} @{FG shine}void@{FG text} functionName();
  @{FG shine}char@{FG text} *@{i}tname@{ui} = "unique name";
  @{i}task@{ui} = CreateTask(@{i}tname@{ui}, 0L, functionName, 4000L);
  In assembler:
    PEA startLabel
SYNOPSIS  @{FG shine}struct@{FG text} @{"Task" Link "include:exec/tasks.h/Main" 24} *CreateTask(STRPTR,@{FG shine}long@{FG text},funcEntry,ULONG);
  @{i}@{b}task@{ub}@{ui} = CreateTask(@{i}name@{ui},@{i}pri@{ui},@{i}initPC@{ui},@{i}stackSize@{ui})
  @{i}name@{ui} - a null-terminated name string
  @{i}pri@{ui} - an Exec task priority between -128 and 127, normally 0
  @{i}funcEntry@{ui} - the address of the first executable instruction of the
    subtask code
  @{i}stackSize@{ui} - size in bytes of stack for the subtask.
    Don't cut it too close - system function stack usage may change.
  @{i}@{b}task@{ub}@{ui} - a pointer to the newly created task,
    or NULL if there was not enough memory.
BUGS
  Under exec.library V37 or beyond, the @{"AddTask()" Link "exec.guide/AddTask()"} function used
  internally by CreateTask() can fail whereas it couldn't fail in
  previous versions of Exec.Prior to amiga.lib V37.14, this function
  did not check for failure of @{"AddTask()" Link "exec.guide/AddTask()"} and thus might return a
  pointer to a task structure even though the task was not actually
  added to the system.
SEE ALSO
  @{"DeleteTask()" Link "DeleteTask()"}, @{"exec/FindTask()" Link "exec.guide/FindTask()"}
@EndNode
@Node "CxCustom()" "amiga.lib/CxCustom"
@{b}@{u}CxCustom@{uu}@{ub} -- create a custom commodity object.@{FG fill}(V36)@{FG text}
  This function creates a custom commodity object.The action
  of this object on receiving a commodity message is to call a
  function of the application programmer's choice.
  The function provided ('action') will be passed a pointer to
  the actual commodities message (in commodities private data
  space), and will actually execute as part of the input handler
  system task.Among other things, the value of 'id' can be
  recovered from the message by using the function @{"CxMsgID()" Link "libs.guide/CxMsgID()"}.
  The purpose of this function is two-fold.First, it allows
  programmers to create Commodities Exchange objects with
  functionality that was not imagined or chosen for inclusion
  by the designers.Secondly, this is the only way to act
  synchronously with Commodities.
  This function is a C-language macro for @{"CreateCxObj()" Link "libs.guide/CreateCxObj()"}, defined
  in @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}.
SYNOPSIS  CxObj *CxCustom(@{FG shine}long@{FG text}(*)(),@{FG shine}long@{FG text});
  @{i}@{b}customObj@{ub}@{ui} = CxCustom(@{i}action@{ui},@{i}id@{ui});
  @{i}action@{ui} - a function to call whenever a message reaches the object
  @{i}id@{ui} - a message id to assign to the object
  @{i}@{b}customObj@{ub}@{ui} - a pointer to the new custom object,
    or NULL if it could not be created.
  SEE ALSO
  @{"commodities.library/CreateCxObj()" Link "libs.guide/CreateCxObj()"}, @{"commodities.library/CxMsgID()" Link "libs.guide/CxMsgID()"}
@EndNode
@Node "CxDebug()" "amiga.lib/CxDebug"
@{b}@{u}CxDebug@{uu}@{ub} -- create a commodity debug object.@{FG fill}(V36)@{FG text}
  This function creates a Commodities debug object.The action of this
  object on receiving a Commodities message is to print out information
  about the Commodities message through the serial port (using the
  kprintf() routine).The value of 'id' will also be displayed.
  Note that this is a synchronous occurrence (the printing is done by
  the input device task).If screen or file output is desired, using a
  sender object instead of a debug object is necessary, since such
  output is best done by your application process.
  This function is a C-language macro for @{"CreateCxObj()" Link "libs.guide/CreateCxObj()"}, defined
  in @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}.
SYNOPSIS  CxObj *CxDebug(@{FG shine}long@{FG text});
  @{i}@{b}debugObj@{ub}@{ui} = CxDebug(@{i}id@{ui});
  @{i}id@{ui} - the id to assign to the debug object, this value is output
    whenever the debug object sends data to the serial port.
  @{i}@{b}debugObj@{ub}@{ui} - a pointer to the debug object, or NULL if it could not be created.
SEE ALSO
  @{"commodities.library/CreateCxObj()" Link "libs.guide/CreateCxObj()"}, @{"CxSender()" Link "CxSender()"}, debug.lib/kprintf()
@EndNode
@Node "CxFilter()" "amiga.lib/CxFilter"
@{b}@{u}CxFilter@{uu}@{ub} -- create a commodity filter object.@{FG fill}(V36)@{FG text}
  Creates an input event filter object that matches the
  'description' string.If 'description' is NULL, the filter will not
  match any messages.
  A filter may be modified by the functions @{"SetFilter()" Link "libs.guide/SetFilter()"}, using
  a description string, and @{"SetFilterIX()" Link "libs.guide/SetFilterIX()"}, which takes a
  binary Input Expression as a parameter.
  This function is a C-language macro for @{"CreateCxObj()" Link "libs.guide/CreateCxObj()"}, defined
  in @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}.
SYNOPSIS  CxObj *CxFilter(STRPTR)
  @{i}@{b}filterObj@{ub}@{ui} = CxFilter(@{i}description@{ui});
  description - the description string in the same format as strings
    expected by @{"commodities.library/SetFilter()" Link "libs.guide/SetFilter()"}
  filterObj - a pointer to the filter object, or NULL if there was not
    enough memory.If there is a problem in the description string,
    the internal error code of the filter object will be set to so indicate.
    This error code may be interrogated using the function @{"CxObjError()" Link "libs.guide/CxObjError()"}.
SEE ALSO
  @{"commodities.library/CreateCxObj()" Link "libs.guide/CreateCxObj()"}, @{"commodities.library/SetFilter()" Link "libs.guide/SetFilter()"},
  @{"commodities.library/SetFilterIX()" Link "libs.guide/SetFilterIX()"}, @{"commodities.library/CxObjError()" Link "libs.guide/CxObjError()"}
@EndNode
@Node "CxSender()" "amiga.lib/CxSender"
@{b}@{u}CxSender@{uu}@{ub} -- create a commodity sender object.@{FG fill}(V36)@{FG text}
  This function creates a Commodities sender object.The action
  of this object on receiving a Commodities message is to copy the
  Commodities message into a standard Exec @{"Message" Link "include:exec/ports.h/Main" 48}, to put the value
  'id' in the message as well, and to send the message off to the
  message port 'port'.
  The value 'id' is used so that an application can monitor
  messages from several senders at a single port.It can be retrieved
  from the Exec message by using the function @{"CxMsgID()" Link "libs.guide/CxMsgID()"}.The value can
  be a simple integer ID, or a pointer to some application data structure.
  Note that Exec messages sent by sender objects arrive
  asynchronously at the destination port.Do not assume anything about
  the status of the Commodities message which was copied into the Exec
  message you received.
  All Exec messages sent to your ports must be replied.Messages may be
  replied after the sender object has been deleted.
  This function is a C-language macro for @{"CreateCxObj()" Link "libs.guide/CreateCxObj()"}, defined
  in @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}.
SYNOPSIS  CxObj *CxSender(@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *,@{FG shine}long@{FG text});
  @{i}@{b}senderObj@{ub}@{ui} = CxSender(@{i}port@{ui},@{i}id@{ui})
  @{i}port@{ui} - the port for the sender to send messages to
  @{i}id@{ui} - the id of the messages sent by the sender
  @{i}@{b}senderObj@{ub}@{ui} - a pointer to the sender object, or NULL if it could not be created.
SEE ALSO
  @{"commodities.library/CreateCxObj()" Link "libs.guide/CreateCxObj()"}, @{"commodities.library/CxMsgID()" Link "libs.guide/CxMsgID()"},
  @{"exec.library/PutMsg()" Link "exec.guide/PutMsg()"}, @{"exec.library/ReplyMsg()" Link "exec.guide/ReplyMsg()"}
@EndNode
@Node "CxSignal()" "amiga.lib/CxSignal"
@{b}@{u}CxSignal@{uu}@{ub} -- create a commodity signaller object.@{FG fill}(V36)@{FG text}
  This function creates a Commodities signal object.The action
  of this object on receiving a Commodities message is to
  send the 'signal' to the 'task'.The caller is responsible
  for allocating the signal and determining the proper task ID.
  Note that 'signal' is the signal value as returned by @{"AllocSignal()" Link "exec.guide/AllocSignal()"},
  not the mask made from that value.
  This function is a C-language macro for @{"CreateCxObj()" Link "libs.guide/CreateCxObj()"}, defined
  in @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}.
SYNOPSIS  CxObj *CxSignal(@{FG shine}struct@{FG text} @{"Task" Link "include:exec/tasks.h/Main" 24} *,@{FG shine}long@{FG text});
  @{i}@{b}signalerObj@{ub}@{ui} = CxSignal(@{i}task@{ui},@{i}signal@{ui});
  @{i}task@{ui} - the task for the signaller to signal
  @{i}signal@{ui} - the signal bit number for the signaller to send
  @{i}@{b}signallerObj@{ub}@{ui} - a pointer to the signaller object,
    or NULL if it could not be created.
SEE ALSO
  @{"commodities.library/CreateCxObj()" Link "libs.guide/CreateCxObj()"}, @{"exec.library/FindTask()" Link "exec.guide/FindTask()"}
  @{"exec.library/Signal()" Link "exec.guide/Signal()"}, @{"exec.library/AllocSignal()" Link "exec.guide/AllocSignal()"},
@EndNode
@Node "CxTranslate()" "amiga.lib/CxTranslate"
@{b}@{u}CxTranslate@{uu}@{ub} -- create a commodity translator object.@{FG fill}(V36)@{FG text}
  This function creates a Commodities 'translator' object.
  The action of this object on receiving a Commodities message is to
  replace that message in the commodities network with a chain of
  Commodities input messages.
  There is one new Commodities input message generated for each input
  event in the linked list starting at 'ie' (and NULL terminated).The
  routing information of the new input messages is copied from the input
  message they replace.
  The linked list of input events associated with a translator object
  can be changed using the @{"SetTranslate()" Link "libs.guide/SetTranslate()"} function.
  If 'ie' is NULL, the null translation occurs: that is, the original
  commodities input message is disposed, and no others are created to
  take its place.
  This function is a C-language macro for @{"CreateCxObj()" Link "libs.guide/CreateCxObj()"}, defined
  in @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}.
SYNOPSIS  CxObj *CxTranslate(@{FG shine}struct@{FG text} @{"InputEvent" Link "include:devices/inputevent.h/Main" 198} *);
  @{i}@{b}translatorObj@{ub}@{ui} = CxTranslate(@{i}ie@{ui});
  @{i}ie@{ui} - the input event list used as replacement by the translator
  @{i}@{b}translatorObj@{ub}@{ui} - a pointer to the translator object,
    or NULL if it could not be created.
SEE ALSO
  @{"commodities.library/CreateCxObj()" Link "libs.guide/CreateCxObj()"}, @{"commodities.library/SetTranslate()" Link "libs.guide/SetTranslate()"}
@EndNode
@Node "dbf()" "amiga.lib/dbf"
@{b}@{u}dbf@{uu}@{ub} - convert FFP dual-binary number to FFP format.
  Accepts a dual-binary format (described below) floating point
  number and converts it to an FFP format floating point number.
  The dual-binary format is defined as:
    exp bit 16 = sign (0=>positive, 1=>negative)
    exp bits 15-0 = binary integer representing the base ten (10) exponent
    man = binary integer mantissa
SYNOPSIS
  @{i}@{b}fnum@{ub}@{ui} = dbf(@{i}exp@{ui}, @{i}mant@{ui});
  @{i}exp@{ui} - binary integer representing sign and exponent
  @{i}mant@{ui} - binary integer representing the mantissa
  @{i}@{b}fnum@{ub}@{ui} - converted FFP floating point format number
@EndNode
@Node "DeleteExtIO()" "amiga.lib/DeleteExtIO"
@{b}@{u}DeleteExtIO@{uu}@{ub} - return memory allocated for extended IO request.
  Frees up an IO request as allocated by @{"CreateExtIO()" Link "CreateExtIO()"}.
SYNOPSIS  @{FG shine}void@{FG text} DeleteExtIO(@{FG shine}struct@{FG text} @{"IORequest" Link "include:exec/io.h/Main" 18} *);
  DeleteExtIO(@{i}ioReq@{ui});
  @{i}ioReq@{ui} - the IORequest block to be freed, or NULL.
SEE ALSO
  @{"CreateExtIO()" Link "CreateExtIO()"}
@EndNode
@Node "DeletePort()" "amiga.lib/DeletePort"
@{b}@{u}DeletePort@{uu}@{ub} - free a message port created by @{"CreatePort()" Link "CreatePort()"}.
  Frees a message port created by @{"CreatePort" Link "amiga_lib/CreatePort()"}.All messages that
  may have been attached to this port must have already been
  replied before this function is called.
SYNOPSIS  @{FG shine}void@{FG text} DeletePort(@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *);
  DeletePort(@{i}port@{ui})
  @{i}port@{ui} - message port to delete
SEE ALSO
  @{"CreatePort()" Link "CreatePort()"}
@EndNode
@Node "DeleteStdIO()" "amiga.lib/DeleteStdIO"
@{b}@{u}DeleteStdIO@{uu}@{ub} - return memory allocated for IOStdReq.
  Frees up an IOStdReq as allocated by @{"CreateStdIO()" Link "CreateStdIO()"}.
SYNOPSIS  @{FG shine}void@{FG text} DeleteStdIO(@{FG shine}struct@{FG text} @{"IOStdReq" Link "include:exec/io.h/Main" 27} *);
  DeleteStdIO(@{i}ioReq@{ui});
  @{i}ioReq@{ui} - the @{"IORequest" Link "include:exec/io.h/Main" 18} block to be freed, or NULL.
SEE ALSO
  @{"CreateStdIO()" Link "CreateStdIO()"}, @{"DeleteExtIO()" Link "DeleteExtIO()"}, @{"exec.library/CreateIORequest()" Link "exec.guide/CreateIORequest()"}
@EndNode
@Node "DeleteTask()" "amiga.lib/DeleteTask"
@{b}@{u}DeleteTask@{uu}@{ub} -- delete a task created with @{"CreateTask()" Link "CreateTask()"}.
  This function simply calls @{"exec.library/RemTask()" Link "exec.guide/RemTask()"}, deleting a task
  from the Exec task lists and automatically freeing any stack and
  structure memory allocated for it by @{"CreateTask()" Link "CreateTask()"}.
  Before deleting a task, you must first make sure that the task is
  not currently executing any system code which might try to signal
  the task after it is gone.
  This can be accomplished by stopping all sources that might reference
  the doomed task, then causing the subtask to execute a Wait(0L).
  Another option is to have the task call @{"DeleteTask()/RemTask()" Link "exec.guide/RemTask()"} on itself.
SYNOPSIS  @{FG shine}void@{FG text} DeleteTask(@{FG shine}struct@{FG text} @{"Task" Link "include:exec/tasks.h/Main" 24} *);
  DeleteTask(@{i}task@{ui})
  @{i}task@{ui} - task to remove from the system
NOTE
  This function simply calls @{"exec.library/RemTask()" Link "exec.guide/RemTask()"}, so you can call
  @{"RemTask()" Link "exec.guide/RemTask()"} directly instead of calling this function.
SEE ALSO
  @{"CreateTask()" Link "CreateTask()"}, @{"exec.library/RemTask()" Link "exec.guide/RemTask()"}
@EndNode
@Node "DoMethod()" "amiga.lib/DoMethod"
@{b}@{u}DoMethod@{uu}@{ub} -- Perform method on object.
  Boopsi support function that invokes the supplied message
  on the specified object.The message is invoked on the
  object's true class.Equivalent to @{"DoMethodA()" Link "DoMethodA()"}, but allows
  you to build the message on the stack.
SYNOPSIS  ULONG DoMethod( Object *, ULONG, ...);
  @{i}@{b}result@{ub}@{ui} = DoMethod( @{i}obj@{ui}, @{i}MethodID@{ui}, ...)
  @{i}obj@{ui} - pointer to boopsi object
  @{i}MethodID@{ui} - which method to send (see @{"<intuition/classusr.h>" Link "include:intuition/classusr.h/Main" 0})
  ...- method-specific message built on the stack
  @{i}@{b}result@{ub}@{ui} - specific to the message and the object's class.
NOTES
  This function first appears in the V37 release of amiga.lib.
  While it intrinsically does not require any particular release
  of the system software to operate, it is designed to work with
  the boopsi subsystem of Intuition, which was only introduced
  in V36.
SEE ALSO
  @{"DoMethodA()" Link "DoMethodA()"}, @{"CoerceMethodA()" Link "CoerceMethodA()"}, @{"DoSuperMethodA()" Link "DoSuperMethodA()"}, @{"<intuition/classusr.h>" Link "include:intuition/classusr.h/Main" 0}
  ROM Kernel Manual boopsi section
@EndNode
@Node "DoMethodA()" "amiga.lib/DoMethodA"
@{b}@{u}DoMethodA@{uu}@{ub} -- Perform method on object.
  Boopsi support function that invokes the supplied message
  on the specified object.The message is invoked on the
  object's true class.
SYNOPSIS  ULONG DoMethodA( Object *, Msg );
  @{i}@{b}result@{ub}@{ui} = DoMethodA( @{i}obj@{ui}, @{i}msg@{ui} )
  @{i}obj@{ui} - pointer to boopsi object
  @{i}msg@{ui} - pointer to method-specific message to send
  @{i}@{b}result@{ub}@{ui} - specific to the message and the object's class.
NOTES
  This function first appears in the V37 release of amiga.lib.
  While it intrinsically does not require any particular release
  of the system software to operate, it is designed to work with
  the boopsi subsystem of Intuition, which was only introduced
  in V36.
  Some early example code may refer to this function as DM().
SEE ALSO
  @{"DoMethod()" Link "DoMethod()"}, @{"CoerceMethodA()" Link "CoerceMethodA()"}, @{"DoSuperMethodA()" Link "DoSuperMethodA()"}, @{"<intuition/classusr.h>" Link "include:intuition/classusr.h/Main" 0}
  ROM Kernel Manual boopsi section
@EndNode
@Node "DoSuperMethod()" "amiga.lib/DoSuperMethod"
@{b}@{u}DoSuperMethod@{uu}@{ub} -- Perform method on object coerced to superclass.
  Boopsi support function that invokes the supplied message
  on the specified object, as though it were the superclass
  of the specified class.Equivalent to @{"DoSuperMethodA()" Link "DoSuperMethodA()"},
  but allows you to build the message on the stack.
SYNOPSIS  ULONG DoSuperMethod( @{FG shine}struct@{FG text} IClass *, Object *, ULONG, ...);
  @{i}@{b}result@{ub}@{ui} = DoSuperMethod( @{i}cl@{ui}, @{i}obj@{ui}, @{i}MethodID@{ui}, ...)
  @{i}cl@{ui} - pointer to boopsi class whose superclass is to receive the message
  @{i}obj@{ui} - pointer to boopsi object
  ...- method-specific message built on the stack
  @{i}@{b}result@{ub}@{ui} - class and message-specific result.
NOTES
  This function first appears in the V37 release of amiga.lib.
  While it intrinsically does not require any particular release
  of the system software to operate, it is designed to work with
  the boopsi subsystem of Intuition, which was only introduced
  in V36.
SEE ALSO
  @{"CoerceMethodA()" Link "CoerceMethodA()"}, @{"DoMethodA()" Link "DoMethodA()"}, @{"DoSuperMethodA()" Link "DoSuperMethodA()"}, @{"<intuition/classusr.h>" Link "include:intuition/classusr.h/Main" 0}
  ROM Kernel Manual boopsi section
@EndNode
@Node "DoSuperMethodA()" "amiga.lib/DoSuperMethodA"
@{b}@{u}DoSuperMethodA@{uu}@{ub} -- Perform method on object coerced to superclass.
  Boopsi support function that invokes the supplied message
  on the specified object, as though it were the superclass
  of the specified class.
SYNOPSIS  ULONG DoSuperMethodA( @{FG shine}struct@{FG text} IClass *, Object *, Msg );
  @{i}@{b}result@{ub}@{ui} = DoSuperMethodA( @{i}cl@{ui}, @{i}obj@{ui}, @{i}msg@{ui} )
  @{i}cl@{ui} - pointer to boopsi class whose superclass is to receive the message
  @{i}obj@{ui} - pointer to boopsi object
  @{i}msg@{ui} - pointer to method-specific message to send
  @{i}@{b}result@{ub}@{ui} - class and message-specific result.
NOTES
  This function first appears in the V37 release of amiga.lib.
  While it intrinsically does not require any particular release
  of the system software to operate, it is designed to work with
  the boopsi subsystem of Intuition, which was only introduced
  in V36.
  Some early example code may refer to this function as DSM().
SEE ALSO
  @{"CoerceMethodA()" Link "CoerceMethodA()"}, @{"DoMethodA()" Link "DoMethodA()"}, @{"DoSuperMethod()" Link "DoSuperMethod()"}, @{"<intuition/classusr.h>" Link "include:intuition/classusr.h/Main" 0}
  ROM Kernel Manual boopsi section
@EndNode
@Node "FastRand()" "amiga.lib/FastRand"
@{b}@{u}FastRand@{uu}@{ub} - quickly generate a somewhat random integer.
  Seed value is taken from stack, shifted left one position,
  exclusive-or'ed with hex value $1D872B41 and returned.
SYNOPSIS  ULONG FastRand(ULONG);
  @{i}@{b}number@{ub}@{ui} = FastRand(@{i}seed@{ui});
  @{i}seed@{ui} - a 32-bit integer
  @{i}@{b}number@{ub}@{ui} - new random seed, a 32-bit value
SEE ALSO
  @{"RangeRand()" Link "RangeRand()"}
@EndNode
@Node "fpa()" "amiga.lib/fpa"
@{b}@{u}fpa@{uu}@{ub} - convert fast floating point into ASCII string equivalent.
  Accepts an FFP number and the address of the ASCII string where it's
  converted output is to be stored.The number is converted to a NULL
  terminated ASCII string in and stored at the address provided.
  Additionally, the base ten (10) exponent in binary form is returned.
SYNOPSIS
  @{i}@{b}exp@{ub}@{ui} = fpa(@{i}fnum@{ui}, @{i}&string@{ui}[0]);
  @{i}fnum@{ui} - Motorola Fast Floating Point number
  @{i}&string@{ui}[0] - address for output of converted ASCII character string (16 bytes)
  @{i}@{b}&string@{ub}@{ui}[0] - converted ASCII character string
  @{i}@{b}exp@{ub}@{ui} - integer exponent value in binary form
@EndNode
@Node "FreeIEvents()" "amiga.lib/FreeIEvents"
@{b}@{u}FreeIEvents@{uu}@{ub} -- free a chain of input events allocated by @{"InvertString()" Link "InvertString()"}.@{FG fill}(V36)@{FG text}
  This function frees a linked list of input events as obtained from
  @{"InvertString()" Link "InvertString()"}.
SYNOPSIS  @{FG shine}void@{FG text} FreeIEvents(@{FG shine}struct@{FG text} @{"InputEvent" Link "include:devices/inputevent.h/Main" 198} *);
  FreeIEvents(@{i}events@{ui})
  @{i}events@{ui} - the list of input events to free, may be NULL.
SEE ALSO
  @{"InvertString()" Link "InvertString()"}
@EndNode
@Node "GetRexxVar()" "amiga.lib/GetRexxVar"
@{b}@{u}GetRexxVar@{uu}@{ub} - Gets the value of a variable from a running ARexx program.
  This function will attempt to extract the value of the symbol
  varname from the ARexx script that sent the message.When called
  from C, a pointer to the extracted value will be placed in the
  pointer pointed to by bufpointer.(*bufpointer will be the pointer
  to the value)
  When called from assembly, the pointer will be returned in A1.
  The value string returned *MUST* *NOT* be modified.
  While this function is new in the V37 amiga.lib, it is safe to
  call it in all versions of the operating system.It is also
  PURE code, thus usable in resident/pure executables.
SYNOPSIS  @{FG shine}long@{FG text} GetRexxVar(@{FG shine}struct@{FG text} @{"RexxMsg" Link "include:rexx/storage.h/Main" 98} *,char *,char **);
  @{i}@{b}error@{ub}@{ui} = GetRexxVar(@{i}message@{ui},@{i}varname@{ui},@{i}bufpointer@{ui})
   D0,A1              A0      A1      (C-only)
  @{i}message@{ui} - A message gotten from an ARexx script
  @{i}varname@{ui} - The name of the variable to extract
  @{i}bufpointer@{ui} - (For C only) A pointer to a string pointer.
  @{i}@{b}error@{ub}@{ui} -  0 for success, otherwise an error code.
    (Other codes may exists, these are documented)
    3  == Insufficient Storage
    9  == String too long
    10 == invalid message
  @{i}@{b}A1@{ub}@{ui} - (Assembly only)  Pointer to the string.
NOTE
  This is a stub in amiga.lib.It is only available via amiga.lib.
  The stub has two labels.One, _GetRexxVar, takes the arguments from
  the stack.The other, GetRexxVar, takes the arguments in registers.
  This routine does a @{"CheckRexxMsg()" Link "CheckRexxMsg()"} on the message.
EXAMPLE
  @{FG shine}char@{FG text}  *@{i}value@{ui};
  /* @{"Message" Link "include:exec/ports.h/Main" 48} is one from ARexx */
  @{FG shine}if@{FG text} (!GetRexxVar(@{i}rxmsg@{ui},"TheVar",@{i}&value@{ui}))
  {
    /* The value was gotten and now is pointed to by value */
    printf("Value of TheVar is %s\n",@{i}value@{ui});
  }
SEE ALSO
  @{"SetRexxVar()" Link "SetRexxVar()"}, @{"CheckRexxMsg()" Link "CheckRexxMsg()"}
@EndNode
@Node "HookEntry()" "amiga.lib/HookEntry"
@{b}@{u}HookEntry@{uu}@{ub} -- Assembler to HLL conversion stub for hook entry.
  By definition, a standard hook entry-point must receive the
  hook in A0, the object in A2, and the message in A1.If your
  hook entry-point is written in a high-level language and is
  expecting its parameters on the stack, then HookEntry() will
  put the three parameters on the stack and invoke the function
  stored in the hook h_SubEntry field.
  This function is only useful to hook implementers, and is
  never called from C.
SYNOPSIS
  @{i}@{b}result@{ub}@{ui} = HookEntry( @{FG shine}struct@{FG text} @{i}Hook@{ui} *, @{i}Object@{ui} *, APTR )
   D0                  A0             A2        A1
  @{i}hook@{ui} - pointer to hook being invoked
  @{i}object@{ui} - pointer to hook-specific data
  @{i}msg@{ui} - pointer to hook-specific message
  @{i}@{b}result@{ub}@{ui} - a hook-specific result.
NOTES
  This function first appeared in the V37 release of amiga.lib.
  However, it does not depend on any particular version of the OS,
  and works fine even in V34.
EXAMPLE
  If your hook dispatcher is this:
  dispatch( @{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *@{i}hookPtr@{ui}, Object *@{i}obj@{ui}, APTR @{i}msg@{ui} )
  {
    ...
  }
  Then when you initialize your hook, you would say:
  myhook.h_Entry = HookEntry; /* amiga.lib stub */
  myhook.h_SubEntry = dispatch; /* HLL entry */
SEE ALSO
  @{"CallHook()" Link "CallHook()"}, @{"CallHookA()" Link "CallHookA()"}, @{"<utility/hooks.h>" Link "include:utility/hooks.h/Main" 0}
@EndNode
@Node "HotKey()" "amiga.lib/HotKey"
@{b}@{u}HotKey@{uu}@{ub} -- create a commodity triad.@{FG fill}(V36)@{FG text}
  This function creates a triad of commodity objects to accomplish a
  high-level function.
  The three objects are a filter, which is created to match by the call
  CxFilter(description), a sender created by the call CxSender(port,id),
  and a translator which is created by CxTranslate(NULL), so that it
  swallows any commodity input event messages that are passed down by
  the filter.
  This is the simple way to get a message sent to your program when the
  user performs a particular input action.
  It is strongly recommended that the ToolTypes environment be used to
  allow the user to specify the input descriptions for your application's
  hotkeys.
SYNOPSIS  CxObj *HotKey(STRPTR,@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *,@{FG shine}long@{FG text});
  @{i}@{b}filterObj@{ub}@{ui} = Hotkey(@{i}description@{ui},@{i}port@{ui},@{i}id@{ui});
  @{i}description@{ui} - the description string to use for the filter in the same
    format as accepted by @{"commodities.library/SetFilter()" Link "libs.guide/SetFilter()"}
  @{i}port@{ui} - port for the sender to send messages to.
  @{i}id@{ui} - id of the messages sent by the sender
  @{i}@{b}filterObj@{ub}@{ui} - a pointer to a filter object, or NULL if it could not be created.
SEE ALSO
  @{"CxFilter()" Link "CxFilter()"}, @{"CxSender()" Link "CxSender()"}, @{"CxTranslate()" Link "CxTranslate()"},
  @{"commodities.library/CxObjError()" Link "libs.guide/CxObjError()"}, @{"commodities.library/SetFilter()" Link "libs.guide/SetFilter()"}
@EndNode
@Node "InvertString()" "amiga.lib/InvertString"
@{b}@{u}InvertString@{uu}@{ub} -- produce input events that would generate the given string.@{FG fill}(V36)@{FG text}
  This function returns a linked list of input events which would
  translate into the string using the supplied keymap (or the system
  default keymap if 'km' is NULL).
  'str' is null-terminated and may contain:
     - ANSI character codes
     - backslash escaped characters:
    \n   -   CR
    \r   -   CR
    \t   -   TAB
    \0   -   illegal, do not use!
    \\   -   backslash
     - a text description of an input event as used by @{"ParseIX()" Link "libs.guide/ParseIX()"},
       enclosed in angle brackets.
  An example is:
    abc<alt f1>\nhi there.
SYNOPSIS  @{FG shine}struct@{FG text} @{"InputEvent" Link "include:devices/inputevent.h/Main" 198} *InvertString(STRPTR,@{FG shine}struct@{FG text} @{"KeyMap" Link "include:devices/keymap.h/Main" 21} *);
  @{i}@{b}events@{ub}@{ui} = InvertString(@{i}str@{ui},@{i}km@{ui})
  @{i}str@{ui} - null-terminated string to convert to input events
  @{i}km@{ui} - keymap to use for the conversion, or NULL to use the default keymap.
  @{i}@{b}events@{ub}@{ui} - a chain of input events, or NULL if there was a problem.
    The most likely cause of failure is an illegal description enclosed in
    angled brackets.This chain should eventually be freed using @{"FreeIEvents()" Link "FreeIEvents()"}.
SEE ALSO
  @{"commodities.library/ParseIX()" Link "libs.guide/ParseIX()"}, @{"FreeIEvents()" Link "FreeIEvents()"}
@EndNode
@Node "NewList()" "amiga.lib/NewList"
@{b}@{u}NewList@{uu}@{ub} -- prepare a list structure for use.
  Perform the magic needed to prepare a List header structure for
  use; the list will be empty and ready to use.(If the list is the
  full featured type, you may need to initialize lh_Type afterwards)
  Assembly programmers may want to use the NEWLIST macro instead.
SYNOPSIS
  @{FG shine}void@{FG text} NewList(@{FG shine}struct@{FG text} @{"List" Link "include:exec/lists.h/Main" 20} *);
  @{FG shine}void@{FG text} NewList(@{FG shine}struct@{FG text} @{"MinList" Link "include:exec/lists.h/Main" 32} *);
  NewList(@{i}list@{ui})
  @{i}list@{ui} - pointer to a List or MinList.
SEE ALSO
  @{"<exec/lists.h>" Link "include:exec/lists.h/Main" 0}
@EndNode
@Node "printf()" "amiga.lib/printf"
@{b}@{u}printf@{uu}@{ub} - print a formatted output line to the standard output.
  Format the output in accordance with specifications in the format string.
SYNOPSIS
  printf(@{i}formatstring@{ui} [,@{i}value@{ui} [,@{i}values@{ui}] ] );
  @{i}formatString@{ui} - a C-language-like NULL-terminated format string,
    with the following supported % options:
    %[@{i}flags@{ui}][@{i}width@{ui}][.@{i}limit@{ui}][@{i}length@{ui}]@{i}type@{ui}
      $     - must follow the arg_pos value, if specified
    @{i}flags@{ui}   - only one allowed.'-' specifies left justification.
    @{i}width@{ui}   - field width.
      If the first character is a '0', the field is padded with leading 0s.
      .     - must precede the field width value, if specified
    @{i}limit@{ui}   - maximum number of characters to output from a string.
      (only valid for %s or %b).
    @{i}length@{ui}  - size of input data defaults to word (16-bit) for types c,
      d, u and x, 'l' changes this to @{FG shine}long@{FG text} (32-bit).
    @{i}type@{ui}    - supported types are:
      b - BSTR, data is 32-bit BPTR to byte count followed
        by a byte string.A NULL BPTR is treated as an empty string.@{FG fill}(V36)@{FG text}
      d - signed decimal
      u - unsigned decimal
      x - hexadecimal with hex digits in uppercase
      X - hexadecimal with hex digits in lowercase
      s - string, a 32-bit pointer to a NULL-terminated byte string.
        A NULL pointer is treated as an empty string.
      c - character
  @{i}value@{ui}(s) - numeric variables or addresses of null-terminated strings
    to be added to the format information.
NOTE
  The global "_stdout" must be defined, and contain a pointer to
  a legal AmigaDOS file handle.Using the standard Amiga startup
  module sets this up.In other cases you will need to define
  stdout, and assign it to some reasonable value (like what the
  @{"dos.library/Output()" Link "dos.guide/Output()"} call returns).This code would set it up:
    ULONG stdout;
    stdout=Output();
BUGS
  This function will crash if the resulting stream after
  parameter substitution is longer than 140 bytes.
@EndNode
@Node "RangeRand()" "amiga.lib/RangeRand"
@{b}@{u}RangeRand@{uu}@{ub} - generate a random number within a specific integer range.
  RangeRand() accepts a value from 0 to 65535, and returns a value
  within that range.
  maxValue is passed on stack as a 32-bit integer but used as though
  it is only a 16-bit integer.Variable named RangeSeed is available
  beginning with V33 that contains the global seed value passed from
  call to call and thus can be changed in a program by declaring:
    @{FG shine}extern@{FG text} ULONG @{i}RangeSeed@{ui};
SYNOPSIS  UWORD RangeRand(UWORD);
  @{i}@{b}number@{ub}@{ui} = RangeRand(@{i}maxValue@{ui});
  @{i}maxValue@{ui} - the returned random number will be in the range [0..maxValue-1]
  @{i}@{b}number@{ub}@{ui} - pseudo random number in the range of [0..maxValue-1].
SEE ALSO
  @{"FastRand()" Link "FastRand()"}
@EndNode
@Node "RemTOF()" "amiga.lib/RemTOF"
@{b}@{u}RemTOF@{uu}@{ub} - remove a task from the VBlank interrupt server chain.
  Removes a task from the vertical-blanking interval interrupt server chain.
SYNOPSIS  @{FG shine}void@{FG text} RemTOF(@{FG shine}struct@{FG text} @{"Isrvstr" Link "include:graphics/graphint.h/Main" 19} *);
  RemTOF(@{i}i@{ui});
  @{i}i@{ui} - pointer to an Isrvstr structure
SEE ALSO
  @{"AddTOF()" Link "AddTOF()"}, @{"<graphics/graphint.h>" Link "include:graphics/graphint.h/Main" 0}
@EndNode
@Node "SetRexxVar()" "amiga.lib/SetRexxVar"
@{b}@{u}SetRexxVar@{uu}@{ub} - Sets the value of a variable of a running ARexx program.
  This function will attempt to the the value of the symbol
  varname in the ARexx script that sent the message.
  While this function is new in the V37 amiga.lib, it is safe to
  call it in all versions of the operating system.It is also
  PURE code, thus usable in resident/pure executables.
SYNOPSIS  @{FG shine}long@{FG text} SetRexxVar(@{FG shine}struct@{FG text} @{"RexxMsg" Link "include:rexx/storage.h/Main" 98} *,@{FG shine}char@{FG text} *,@{FG shine}char@{FG text} *,ULONG);
  @{i}@{b}error@{ub}@{ui} = SetRexxVar(@{i}message@{ui},@{i}varname@{ui},@{i}value@{ui},@{i}length@{ui})
   D0                 A0      A1      D0    D1
  @{i}message@{ui} - A message gotten from an ARexx script
  @{i}varname@{ui} - The name of the variable to set
  @{i}value@{ui} - A string that will be the new value of the variable
  @{i}length@{ui} - The length of the value string
  @{i}@{b}error@{ub}@{ui} - 0 for success, otherwise an error code.
    (Other codes may exists, these are documented)
    3  == Insufficient Storage
    9  == String too long
    10 == invalid message
NOTE
  This is a stub in amiga.lib.It is only available via amiga.lib.
  The stub has two labels.One, _SetRexxVar, takes the arguments
  from the stack.The other, SetRexxVar, takes the arguments in
  registers.
  This routine does a @{"CheckRexxMsg()" Link "CheckRexxMsg()"} on the message.
EXAMPLE
  @{FG shine}char@{FG text}  *@{i}value@{ui};
  /* @{"Message" Link "include:exec/ports.h/Main" 48} is one from ARexx */
  @{FG shine}if@{FG text} (!SetRexxVar(@{i}rxmsg@{ui},"TheVar","25 Dollars",10))
  {
    /* The value of TheVar will now be "25 Dollars" */
  }
SEE ALSO
  SetRexxVar(), @{"CheckRexxMsg()" Link "CheckRexxMsg()"}
@EndNode
@Node "SetSuperAttrs()" "amiga.lib/SetSuperAttrs"
@{b}@{u}SetSuperAttrs@{uu}@{ub} -- Invoke OM_SET method on superclass with varargs.
  Boopsi support function which invokes the OM_SET method on the
  superclass of the supplied class for the supplied object.Allows
  the ops_AttrList to be supplied on the stack (i.e.in a varargs
  way).The equivalent non-varargs function would simply be
    DoSuperMethod( @{i}cl@{ui}, @{i}obj@{ui}, OM_SET, @{i}taglist@{ui}, NULL );
SYNOPSIS  ULONG SetSuperAttrs( @{FG shine}struct@{FG text} IClass *, Object *, ULONG, ...);
  @{i}@{b}result@{ub}@{ui} = SetSuperAttrs( @{i}cl@{ui}, @{i}obj@{ui}, @{i}tag@{ui}, ...)
  @{i}cl@{ui} - pointer to boopsi class whose superclass is to receive the OM_SET message
  @{i}obj@{ui} - pointer to boopsi object
  @{i}tag@{ui} - list of tag-attribute pairs, ending in TAG_DONE
  @{i}@{b}result@{ub}@{ui} - class and message-specific result.
NOTES
  This function first appears in the V37 release of amiga.lib.
  While it intrinsically does not require any particular release
  of the system software to operate, it is designed to work with
  the boopsi subsystem of Intuition, which was only introduced
  in V36.
SEE ALSO
  @{"CoerceMethodA()" Link "CoerceMethodA()"}, @{"DoMethodA()" Link "DoMethodA()"}, @{"DoSuperMethodA()" Link "DoSuperMethodA()"}, @{"<intuition/classusr.h>" Link "include:intuition/classusr.h/Main" 0}
  ROM Kernel Manual boopsi section
@EndNode
@Node "sprintf()" "amiga.lib/sprintf"
@{b}@{u}sprintf@{uu}@{ub} - format a C-like string into a string buffer.
  Performs string formatting identical to @{"printf" Link "amiga_lib/printf()"}, but directs the output
  into a specific destination in memory.This uses the ROM version
  of @{"printf" Link "amiga_lib/printf()"} @{"(exec.library/RawDoFmt()" Link "exec.guide/RawDoFmt()"}), so it is very small.
  Assembly programmers can call this by placing values on the
  stack, followed by a pointer to the formatstring, followed
  by a pointer to the destination string.
SYNOPSIS
  sprintf(@{i}destination@{ui}, @{i}formatstring@{ui} [,@{i}value@{ui} [, @{i}values@{ui}] ] );
  @{i}destination@{ui} - the address of an area in memory into which the
    formatted output is to be placed.
  @{i}formatstring@{ui} - pointer to a null terminated string describing the
    desired output formatting (see @{"printf()" Link "printf()"} for a description of this string).
  @{i}value@{ui}(s) - numeric information to be formatted into the output stream.
SEE ALSO
   @{"printf()" Link "printf()"}, @{"exec.library/RawDoFmt()" Link "exec.guide/RawDoFmt()"}
@EndNode
@Node "stdio()" "amiga.lib/stdio"
@{b}@{u}NAMES@{uu}@{ub}
  @{b}fclose@{ub}  - close a file
  @{b}fgetc@{ub} - get a character from a file
  @{b}fprintf@{ub} - format data to file (see @{"printf()" Link "printf()"})
  @{b}fputc@{ub} - put character to file
  @{b}fputs@{ub} - write string to file
  @{b}getchar@{ub} - get a character from stdin
  @{"printf" Link "amiga_lib/printf()"} - put format data to stdout (see exec.library/RawDoFmt)
  @{b}putchar@{ub} - put character to stdout
  @{b}puts@{ub}  - put string to stdout, followed by newline
  These functions work much like the standard C functions of the same
  names.The file I/O functions all use non-buffered AmigaDOS
  files, and must not be mixed with the file I/O of any C
  compiler.The names of these functions match those found in many
  standard C libraries, when a name conflict occurs, the function is
  generally taken from the FIRST library that was specified on the
  linker's command line.Thus to use these functions, specify
  the amiga.lib library first.
  To get a suitable AmigaDOS @{"FileHandle" Link "include:dos/dosextens.h/Main" 89}, the @{"dos.library/Open()" Link "dos.guide/Open()"} or
  @{"dos.library/Output()" Link "dos.guide/Output()"} functions must be used.
  All of the functions that write to stdout expect an appropriate
  @{"FileHandle" Link "include:dos/dosextens.h/Main" 89} to have been set up ahead of time.Depending on
  your C compiler and options, this may have been done by the
  startup code.Or it can be done manually
  From C:
    @{FG shine}extern@{FG text} ULONG stdout;
    /* Remove the extern if startup code did not define stdout */
    stdout=Output();
  From assembly:
    XDEF  _stdout
    DC.L  _stdout ;<- Place result of @{"dos.library/Output()" Link "dos.guide/Output()"} here.
@EndNode
@Node "TimeDelay()" "amiga.lib/TimeDelay"
@{b}@{u}TimeDelay@{uu}@{ub} -- Return after a period of time has elapsed.
  Waits for the period of time specified before returning to the the caller.
SYNOPSIS  @{FG shine}long@{FG text} TimeDelay( @{FG shine}long@{FG text}, ULONG, ULONG );
  @{i}@{b}Error@{ub}@{ui} = TimeDelay( @{i}Unit@{ui}, @{i}Seconds@{ui}, @{i}MicroSeconds@{ui} )
   D0                 D0    D1       D2
  @{i}Unit@{ui} -- timer.device @{"Unit" Link "include:exec/devices.h/Main" 32} to open for this command.
  @{i}Seconds@{ui} -- The seconds field of a @{"timerequest" Link "include:devices/timer.h/Main" 36} is filled with this value.
    Check the documentation for what a particular timer.device unit
    expects there.
  @{i}MicroSeconds@{ui} -- The microseconds field of a @{"timerequest" Link "include:devices/timer.h/Main" 36} is
    filled with this value.Check the documentation for what
    a particular timer.device units expects there.
  @{i}@{b}Error@{ub}@{ui} -- will be zero if all went well; otherwise, non-zero.
NOTES
  Two likely reasons for failures are invalid unit numbers or
  no more free signal bits for this task.
  While this function first appears in V37 amiga.lib, it works
  on Kickstart V33 and higher.
SEE ALSO
  @{"timer.device/TR_ADDREQUEST" Link "devices.guide/TR_ADDREQUEST"},
  timer.device/TR_WAITUNTIL,
  timer.device/WaitUnitl()
@EndNode
@Node "LibAllocPooled()" "pools.lib/LibAllocPooled"
@{b}@{u}LibAllocPooled@{uu}@{ub} -- Allocate memory with the pool manager.@{FG fill}(V33)@{FG text}
  This function is a copy of the pool functions in V39 and up of EXEC.
  In fact, if you are running in V39, this function will notice and call the
  EXEC function.This function works in V33 and up (1.2) Amiga system.
  The C code interface is _LibAllocPooled() and takes its arguments
  from the stack just like the C code interface for AllocPooled()
  in amiga.lib.The assembly code interface is with the symbol
  _AsmAllocPooled: and takes the parameters in registers with the
  additional parameter of ExecBase being in a6 which can be used
  from SAS/C 6 by a prototype of:
  @{FG shine}void@{FG text} * __asm AsmAllocPooled(@{FG shine}register@{FG text} __a0 @{FG shine}void@{FG text} *, @{FG shine}register@{FG text} __d0 ULONG,
    @{FG shine}register@{FG text} __a6 @{FG shine}struct@{FG text} @{"ExecBase" Link "include:exec/execbase.h/Main" 34} *);
  Allocate memSize bytes of memory, and return a pointer.NULL is
  returned if the allocation fails.
  Doing a @{"LibDeletePool()" Link "LibDeletePool()"} on the pool will free all of the puddles
  and thus all of the allocations done with LibAllocPooled() in that
  pool.(No need to @{"LibFreePooled()" Link "LibFreePooled()"} each allocation)
SYNOPSIS  @{FG shine}void@{FG text} *LibAllocPooled(@{FG shine}void@{FG text} *,ULONG);
  @{i}@{b}memory@{ub}@{ui}=LibAllocPooled(@{i}poolHeader@{ui},@{i}memSize@{ui})
   d0                    a0         d0
  @{i}memSize@{ui} - the number of bytes to allocate
  @{i}poolHeader@{ui} - a specific private pool header.
  Returns a pointer to the memory, or NULL.
  The memory block returned is long word aligned.
NOTES
  The pool function do not protect an individual pool from
  multiple accesses.The reason is that in most cases the pools
  will be used by a single task.If your pool is going to
  be used by more than one task you must @{"Semaphore" Link "include:exec/semaphores.h/Main" 53} protect
  the pool from having more than one task trying to allocate
  within the same pool at the same time.Warning:  @{"Forbid()" Link "exec.guide/Forbid()"}
  protection *will not work* in the future.*Do NOT* assume
  that we will be able to make it work in the future.LibAllocPooled() may well
  break a @{"Forbid()" Link "exec.guide/Forbid()"} and as such can only be protected by a semaphore.
  To track sizes yourself, the following code can be used:
  *Assumes a6=ExecBase*
  ; Function to do AllocVecPooled(Pool,memSize)
  AllocVecPooled: addq.l  #4,d0   ; Get space for tracking
    move.l  d0,-(sp)  ; Save the size
    jsr LibAllocPooled  ; Call pool...
    move.l  (sp)+,d1  ; Get size back...
    tst.l d0    ; Check for error
    beq.s avp_fail  ; If NULL, failed!
    move.l  d0,a0   ; Get pointer...
    move.l  d1,(a0)+  ; Store size
    move.l  a0,d0   ; Get result
  avp_fail: rts     ; return
  ; Function to do LibFreeVecPooled(pool,memory)
  FreeVecPooled:  move.l  -(a1),d0  ; Get size / ajust pointer
    jmp LibFreePooled
SEE ALSO
  FreePooled(), CreatePool(), DeletePool(),
  @{"LibFreePooled()" Link "LibFreePooled()"}, @{"LibCreatePool()" Link "LibCreatePool()"}, @{"LibDeletePool()" Link "LibDeletePool()"}
@EndNode
@Node "LibCreatePool()" "pools.lib/LibCreatePool"
@{b}@{u}LibCreatePool@{uu}@{ub} -- Generate a private memory pool header.@{FG fill}(V33)@{FG text}
  This function is a copy of the pool functions in V39 and up of
  EXEC.In fact, if you are running in V39, this function will
  notice and call the EXEC function.This function works in
  V33 and up (1.2) Amiga system.
  The C code interface is _LibCreatePool() and takes its arguments
  from the stack just like the C code interface for CreatePool()
  in amiga.lib.The assembly code interface is with the symbol
  _AsmCreatePool: and takes the parameters in registers with the
  additional parameter of ExecBase being in a6 which can be used
  from SAS/C 6 by a prototype of:
  @{FG shine}void@{FG text} * __asm AsmCreatePool(@{FG shine}register@{FG text} __d0 ULONG, @{FG shine}register@{FG text} __d1 ULONG,
    @{FG shine}register@{FG text} __d2 ULONG, @{FG shine}register@{FG text} __a6 @{FG shine}struct@{FG text} @{"ExecBase" Link "include:exec/execbase.h/Main" 34} *);
  Allocate and prepare a new memory pool header.Each pool is a
  separate tracking system for memory of a specific type.Any number
  of pools may exist in the system.
  Pools automatically expand and shrink based on demand.Fixed sized
  "puddles" are allocated by the pool manager when more total memory
  is needed.Many small allocations can fit in a single puddle.
  Allocations larger than the threshSize are allocation in their own puddles.
  At any time individual allocations may be freed.Or, the entire
  pool may be removed in a single step.
SYNOPSIS  @{FG shine}void@{FG text} *LibCreatePool(ULONG,ULONG,ULONG);
  @{i}@{b}newPool@{ub}@{ui}=LibCreatePool(@{i}memFlags@{ui},@{i}puddleSize@{ui},@{i}threshSize@{ui})
   a0                    d0       d1         d2
  @{i}memFlags@{ui} - a memory flags specifier, as taken by @{"AllocMem" Link "exec.guide/AllocMem()"}.
  @{i}puddleSize@{ui} - the size of Puddles...
  @{i}threshSize@{ui} - the largest allocation that goes into normal puddles.
    This *MUST* be less than or equal to puddleSize.
    (LibCreatePool() will fail if it is not)
  Returns the address of a new pool header, or NULL for error.
SEE ALSO
  DeletePool(), AllocPooled(), FreePooled(), exec/memory.i,
  @{"LibDeletePool()" Link "LibDeletePool()"}, @{"LibAllocPooled()" Link "LibAllocPooled()"}, @{"LibFreePooled()" Link "LibFreePooled()"}
@EndNode
@Node "LibDeletePool()" "pools.lib/LibDeletePool"
@{b}@{u}LibDeletePool@{uu}@{ub} --  Drain an entire memory pool.@{FG fill}(V33)@{FG text}
  This function is a copy of the pool functions in V39 and up of
  EXEC.In fact, if you are running in V39, this function will
  notice and call the EXEC function.This function works in
  V33 and up (1.2) Amiga system.
  The C code interface is _LibDeletePool() and takes its arguments
  from the stack just like the C code interface for DeletePool()
  in amiga.lib.The assembly code interface is with the symbol
  _AsmDeletePool: and takes the parameters in registers with the
  additional parameter of ExecBase being in a6 which can be used
  from SAS/C 6 by a prototype of:
  @{FG shine}void@{FG text} __asm AsmDeletePool(@{FG shine}register@{FG text} __a0 @{FG shine}void@{FG text} *,@{FG shine}register@{FG text} __a6 @{FG shine}struct@{FG text} @{"ExecBase" Link "include:exec/execbase.h/Main" 34} *);
  Frees all memory in all puddles of the specified pool header, then
  deletes the pool header.Individual free calls are not needed.
SYNOPSIS  @{FG shine}void@{FG text} LibDeletePool(@{FG shine}void@{FG text} *);
  LibDeletePool(@{i}poolHeader@{ui})
                 a0
  @{i}poolHeader@{ui} - as returned by @{"LibCreatePool()" Link "LibCreatePool()"}.
SEE ALSO
  CreatePool(), AllocPooled(), FreePooled(),
  @{"LibCreatePool()" Link "LibCreatePool()"}, @{"LibAllocPooled()" Link "LibAllocPooled()"}, @{"LibFreePooled()" Link "LibFreePooled()"}
@EndNode
@Node "LibFreePooled()" "pools.lib/LibFreePooled"
@{b}@{u}LibFreePooled@{uu}@{ub} -- Free pooled memory.@{FG fill}(V33)@{FG text}
  This function is a copy of the pool functions in V39 and up of
  EXEC.In fact, if you are running in V39, this function will
  notice and call the EXEC function.This function works in
  V33 and up (1.2) Amiga system.
  The C code interface is _LibFreePooled() and takes its arguments
  from the stack just like the C code interface for FreePooled()
  in amiga.lib.The assembly code interface is with the symbol
  _AsmFreePooled: and takes the parameters in registers with the
  additional parameter of ExecBase being in a6 which can be used
  from SAS/C 6 by a prototype of:
  @{FG shine}void@{FG text} __asm AsmFreePooled(@{FG shine}register@{FG text} __a0 @{FG shine}void@{FG text} *, @{FG shine}register@{FG text} __a1 @{FG shine}void@{FG text} *,
    @{FG shine}register@{FG text} __d0 ULONG, @{FG shine}register@{FG text} __a6 @{FG shine}struct@{FG text} @{"ExecBase" Link "include:exec/execbase.h/Main" 34} *);
  Deallocates memory allocated by @{"LibAllocPooled()" Link "LibAllocPooled()"}.The size of the
  allocation *MUST* match the size given to @{"LibAllocPooled()" Link "LibAllocPooled()"}.
  The reason the pool functions do not track individual allocation
  sizes is because many of the uses of pools have small allocation
  sizes and the tracking of the size would be a large overhead.
  Only memory allocated by @{"LibAllocPooled()" Link "LibAllocPooled()"} may be freed with this function!
  Doing a @{"LibDeletePool()" Link "LibDeletePool()"} on the pool will free all of the puddles
  and thus all of the allocations done with @{"LibAllocPooled()" Link "LibAllocPooled()"} in that
  pool.(No need to LibFreePooled() each allocation)
SYNOPSIS  @{FG shine}void@{FG text} LibFreePooled(@{FG shine}void@{FG text} *,@{FG shine}void@{FG text} *,ULONG);
  LibFreePooled(@{i}poolHeader@{ui},@{i}memory@{ui},@{i}memSize@{ui})
                 a0         a1     d0
  @{i}memory@{ui} - pointer to memory allocated by AllocPooled.
  @{i}poolHeader@{ui} - a specific private pool header.
NOTES
  The pool function do not protect an individual pool from
  multiple accesses.The reason is that in most cases the pools
  will be used by a single task.If your pool is going to
  be used by more than one task you must @{"Semaphore" Link "include:exec/semaphores.h/Main" 53} protect
  the pool from having more than one task trying to allocate
  within the same pool at the same time.Warning:  @{"Forbid()" Link "exec.guide/Forbid()"}
  protection *will not work* in the future.*Do NOT* assume
  that we will be able to make it work in the future.LibFreePooled()
  may well break a @{"Forbid()" Link "exec.guide/Forbid()"} and as such can only be protected
  by a semaphore.
  To track sizes yourself, the following code can be used:
  *Assumes a6=ExecBase*
  ; Function to do AllocVecPooled(Pool,memSize)
  AllocVecPooled: addq.l  #4,d0   ; Get space for tracking
    move.l  d0,-(sp)  ; Save the size
    jsr LibAllocPooled  ; Call pool...
    move.l  (sp)+,d1  ; Get size back...
    tst.l d0    ; Check for error
    beq.s avp_fail  ; If NULL, failed!
    move.l  d0,a0   ; Get pointer...
    move.l  d1,(a0)+  ; Store size
    move.l  a0,d0   ; Get result
  avp_fail: rts     ; return
  ; Function to do LibFreeVecPooled(pool,memory)
  FreeVecPooled:  move.l  -(a1),d0  ; Get size / ajust pointer
    jmp LibFreePooled
SEE ALSO
  AllocPooled(), CreatePool(), DeletePool(),
  @{"LibAllocPooled()" Link "LibAllocPooled()"}, @{"LibCreatePool()" Link "LibCreatePool()"}, @{"LibDeletePool()" Link "LibDeletePool()"}
@EndNode

