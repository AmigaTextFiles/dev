@database "graphics"
@master "Work:Programing/sc/OS3.1_Docs/doc/graphics.doc"

@Node Main "graphics.doc"
@{b}@{u}Gels@{uu}@{ub}:          @{b}@{u}Rastport@{uu}@{ub}:       @{b}@{u}Fonts@{uu}@{ub}:         @{b}@{u}Viewport@{uu}@{ub}:          @{b}@{u}Colors@{uu}@{ub}:
@{"InitGels()" Link "InitGels()"}    @{"AllocRaster()" Link "AllocRaster()"}  @{"AddFont()" Link "AddFont()"}     @{"InitVPort()" Link "InitVPort()"}       @{"AttachPalExtra()" Link "AttachPalExtra()"}
@{"InitMasks()" Link "InitMasks()"}   @{"InitRastPort()" Link "InitRastPort()"} @{"OpenFont()" Link "OpenFont()"}    @{"GetVPModeID()" Link "GetVPModeID()"}     @{"GetColorMap()" Link "GetColorMap()"}
@{"InitGMasks()" Link "InitGMasks()"}  @{"SetWriteMask()" Link "SetWriteMask()"} @{"ExtendFont()" Link "ExtendFont()"}  @{"ModeNotAvailable()" Link "ModeNotAvailable()"}@{"LoadRGB32()" Link "LoadRGB32()"}
@{"GetGBuffers()" Link "GetGBuffers()"} @{"SetRPAttrA()" Link "SetRPAttrA()"}   @{"FontExtent()" Link "FontExtent()"}  @{"ScrollVPort()" Link "ScrollVPort()"}     @{"SetRGB32()" Link "SetRGB32()"}
@{"AddBob()" Link "AddBob()"}      @{"GetRPAttrA()" Link "GetRPAttrA()"}   @{"SetFont()" Link "SetFont()"}     @{"WaitBOVP()" Link "WaitBOVP()"}        @{"SetRGB32CM()" Link "SetRGB32CM()"}
@{"AddVSprite()" Link "AddVSprite()"}  @{"InitTmpRas()" Link "InitTmpRas()"}   @{"AskFont()" Link "AskFont()"}     @{"CalcIVG()" Link "CalcIVG()"}         @{"GetRGB32()" Link "GetRGB32()"}
@{"AddAnimOb()" Link "AddAnimOb()"}   @{"SetRast()" Link "SetRast()"}      @{"SetSoftStyle()" Link "SetSoftStyle()"}@{"CoerceMode()" Link "CoerceMode()"}      @{"LoadRGB4()" Link "LoadRGB4()"}
@{"SortGList()" Link "SortGList()"}   @{"ClearScreen()" Link "ClearScreen()"}  @{"AskSoftStyle()" Link "AskSoftStyle()"}@{"AllocDBufInfo()" Link "AllocDBufInfo()"}   @{"SetRGB4()" Link "SetRGB4()"}
@{"SetCollision()" Link "SetCollision()"}@{"Flood()" Link "Flood()"}        @{"StripFont()" Link "StripFont()"}   @{"ChangeVPBitMap()" Link "ChangeVPBitMap()"}  @{"SetRGB4CM()" Link "SetRGB4CM()"}
@{"DoCollision()" Link "DoCollision()"} @{"ScrollRaster()" Link "ScrollRaster()"} @{"CloseFont()" Link "CloseFont()"}   @{"FreeDBufInfo()" Link "FreeDBufInfo()"}    @{"GetRGB4()" Link "GetRGB4()"}
@{"DrawGList()" Link "DrawGList()"}   @{"RectFill()" Link "RectFill()"}     @{"RemFont()" Link "RemFont()"}     @{b}@{u}Regions@{uu}@{ub}:           @{"ObtainPen()" Link "ObtainPen()"}
@{"Animate()" Link "Animate()"}     @{"ScrollRasterBF()" Link "ScrollRasterBF()"}@{b}@{u}Drawing@{uu}@{ub}:      @{"NewRegion()" Link "NewRegion()"}       @{"ObtainBestPenA()" Link "ObtainBestPenA()"}
@{"RemBob()" Link "RemBob()"}      @{"EraseRect()" Link "EraseRect()"}    @{"Move()" Link "Move()"}        @{"ClearRegion()" Link "ClearRegion()"}     @{"FindColor()" Link "FindColor()"}
@{"RemIBob()" Link "RemIBob()"}     @{"FreeRaster()" Link "FreeRaster()"}   @{"Draw()" Link "Draw()"}        @{"ClearRectRegion()" Link "ClearRectRegion()"} @{"ReleasePen()" Link "ReleasePen()"}
@{"RemVSprite()" Link "RemVSprite()"}  @{b}@{u}Area drawing@{uu}@{ub}:   @{"PolyDraw()" Link "PolyDraw()"}    @{"AndRectRegion()" Link "AndRectRegion()"}   @{"VideoControl()" Link "VideoControl()"}
@{"FreeGBuffers()" Link "FreeGBuffers()"}@{"InitArea()" Link "InitArea()"}     @{"DrawEllipse()" Link "DrawEllipse()"} @{"AndRegionRegion()" Link "AndRegionRegion()"} @{"FreeColorMap()" Link "FreeColorMap()"}
@{b}@{u}Extended nodes@{uu}@{ub}:@{"AreaMove()" Link "AreaMove()"}     @{"TextLength()" Link "TextLength()"}  @{"OrRectRegion()" Link "OrRectRegion()"}
@{"GfxNew()" Link "GfxNew()"}      @{"AreaDraw()" Link "AreaDraw()"}     @{"TextExtent()" Link "TextExtent()"}  @{"OrRegionRegion()" Link "OrRegionRegion()"}
@{"GfxAssociate()" Link "GfxAssociate()"}@{"AreaCircle()" Link "AreaCircle()"}   @{"TextFit()" Link "TextFit()"}     @{"XorRectRegion()" Link "XorRectRegion()"}  @{"Same, but sorted" Link "SORTED"}
@{"GfxLookUP()" Link "GfxLookUP()"}   @{"AreaEllipse()" Link "AreaEllipse()"}  @{"Text()" Link "Text()"}        @{"XorRegionRegion()" Link "XorRegionRegion()"}
@{"GfxFree()" Link "GfxFree()"}     @{"AreaEnd()" Link "AreaEnd()"}      @{"ClearEOL()" Link "ClearEOL()"}    @{"DisposeRegion()" Link "DisposeRegion()"}
@{b}@{u}Pens@{uu}@{ub}:               @{b}@{u}Sprites@{uu}@{ub}:                @{b}@{u}Copper@{uu}@{ub}:       @{b}@{u}Layers@{uu}@{ub}:
@{"SetMaxPen()" Link "SetMaxPen()"}        @{"AllocSpriteDataA()" Link "AllocSpriteDataA()"}     @{"MakeVPort()" Link "MakeVPort()"}  @{"AttemptLockLayerRom()" Link "AttemptLockLayerRom()"}
@{"SetAPen()" Link "SetAPen()"}          @{"GetSprite()" Link "GetSprite()"}            @{"InitView()" Link "InitView()"}   @{"LockLayerRom()" Link "LockLayerRom()"}
@{"GetAPen()" Link "GetAPen()"}          @{"ChangeSprite()" Link "ChangeSprite()"}         @{"LoadView()" Link "LoadView()"}   @{"UnlockLayerRom()" Link "UnlockLayerRom()"}
@{"SetBPen()" Link "SetBPen()"}          @{"GetExtSpriteA()" Link "GetExtSpriteA()"}        @{"MrgCop()" Link "MrgCop()"}     @{b}@{u}DisplayInfo@{uu}@{ub}@{b}@{u}@{uu}@{ub}:
@{"GetBPen()" Link "GetBPen()"}          @{"ChangeExtSpriteA()" Link "ChangeExtSpriteA()"}     @{"CINIT " Link "CINIT"}       @{"FindDisplayInfo()" Link "FindDisplayInfo()"}
@{"SetDrMd()" Link "SetDrMd()"}          @{"MoveSprite()" Link "MoveSprite()"}           @{"CMOVE " Link "CMOVE"}       @{"GetDisplayInfoData()" Link "GetDisplayInfoData()"}
@{"GetDrMd()" Link "GetDrMd()"}          @{"FreeSprite()" Link "FreeSprite()"}           @{"CWAIT " Link "CWAIT"}       @{"NextDisplayInfo()" Link "NextDisplayInfo()"}
@{"SetABPenDrMd()" Link "SetABPenDrMd()"}     @{"FreeSpriteData()" Link "FreeSpriteData()"}       @{"CBump()" Link "CBump()"}      @{"BestModeIDA()" Link "BestModeIDA()"}
@{"SetOPen()" Link "SetOPen()"}          @{b}@{u}Blitter@{uu}@{ub}:                @{"CEND " Link "CEND"}        @{"SetChipRev()" Link "SetChipRev()"}
@{"SetOutlinePen()" Link "SetOutlinePen()"}    @{"OwnBlitter()" Link "OwnBlitter()"}           @{"FreeCopList()" Link "FreeCopList()"}@{"VBeamPos()" Link "VBeamPos()"}
@{"GetOPen()" Link "GetOPen()"}          @{"WaitBlit()" Link "WaitBlit()"}             @{"FreeCprList()" Link "FreeCprList()"}@{"WaitTOF()" Link "WaitTOF()"}
@{"ReadPixel()" Link "ReadPixel()"}        @{"ClipBlit()" Link "ClipBlit()"}             @{"FreeVPortCopLists()" Link "FreeVPortCopLists()"}
@{"WritePixel()" Link "WritePixel()"}       @{"BltTemplate()" Link "BltTemplate()"}          @{b}@{u}Bitmaps@{uu}@{ub}:
@{"ReadPixelArray8()" Link "ReadPixelArray8()"}  @{"BltBitMap()" Link "BltBitMap()"}            @{"AllocBitMap()" Link "AllocBitMap()"}
@{"WritePixelArray8()" Link "WritePixelArray8()"} @{"BltBitMapRastPort()" Link "BltBitMapRastPort()"}    @{"InitBitMap()" Link "InitBitMap()"}
@{"ReadPixelLine8()" Link "ReadPixelLine8()"}   @{"BltMaskBitMapRastPort()" Link "BltMaskBitMapRastPort()"}@{"GetBitMapAttr()" Link "GetBitMapAttr()"}
@{"WritePixelLine8()" Link "WritePixelLine8()"}  @{"BltClear()" Link "BltClear()"}             @{"ScalerDiv()" Link "ScalerDiv()"}
@{"WriteChunkyPixels()" Link "WriteChunkyPixels()"}@{"BltPattern()" Link "BltPattern()"}           @{"BitMapScale()" Link "BitMapScale()"}
@{b}@{u}Monitors@{uu}@{ub}:           @{"QBlit()" Link "QBlit()"}                @{"SyncSBitMap()" Link "SyncSBitMap()"}
@{"OpenMonitor()" Link "OpenMonitor()"}      @{"QBSBlit()" Link "QBSBlit()"}              @{"CopySBitMap()" Link "CopySBitMap()"}
@{"CloseMonitor()" Link "CloseMonitor()"}     @{"DisownBlitter()" Link "DisownBlitter()"}        @{"FreeBitMap()" Link "FreeBitMap()"}
@endnode
@Node SORTED "graphics.doc"
@{"AddAnimOb()" Link "AddAnimOb()"}
@{"AddBob()" Link "AddBob()"}
@{"AddFont()" Link "AddFont()"}
@{"AddVSprite()" Link "AddVSprite()"}
@{"AllocBitMap()" Link "AllocBitMap()"}
@{"AllocDBufInfo()" Link "AllocDBufInfo()"}
@{"AllocRaster()" Link "AllocRaster()"}
@{"AllocSpriteDataA()" Link "AllocSpriteDataA()"}
@{"AndRectRegion()" Link "AndRectRegion()"}
@{"AndRegionRegion()" Link "AndRegionRegion()"}
@{"Animate()" Link "Animate()"}
@{"AreaCircle()" Link "AreaCircle()"}
@{"AreaDraw()" Link "AreaDraw()"}
@{"AreaEllipse()" Link "AreaEllipse()"}
@{"AreaEnd()" Link "AreaEnd()"}
@{"AreaMove()" Link "AreaMove()"}
@{"AskFont()" Link "AskFont()"}
@{"AskSoftStyle()" Link "AskSoftStyle()"}
@{"AttachPalExtra()" Link "AttachPalExtra()"}
@{"AttemptLockLayerRom()" Link "AttemptLockLayerRom()"}
@{"BestModeIDA()" Link "BestModeIDA()"}
@{"BitMapScale()" Link "BitMapScale()"}
@{"BltBitMap()" Link "BltBitMap()"}
@{"BltBitMapRastPort()" Link "BltBitMapRastPort()"}
@{"BltClear()" Link "BltClear()"}
@{"BltMaskBitMapRastPort()" Link "BltMaskBitMapRastPort()"}
@{"BltPattern()" Link "BltPattern()"}
@{"BltTemplate()" Link "BltTemplate()"}
@{"CalcIVG()" Link "CalcIVG()"}
@{"CBump()" Link "CBump()"}
@{"CEND " Link "CEND"}
@{"ChangeExtSpriteA()" Link "ChangeExtSpriteA()"}
@{"ChangeSprite()" Link "ChangeSprite()"}
@{"ChangeVPBitMap()" Link "ChangeVPBitMap()"}
@{"CINIT " Link "CINIT"}
@{"ClearEOL()" Link "ClearEOL()"}
@{"ClearRectRegion()" Link "ClearRectRegion()"}
@{"ClearRegion()" Link "ClearRegion()"}
@{"ClearScreen()" Link "ClearScreen()"}
@{"ClipBlit()" Link "ClipBlit()"}
@{"CloseFont()" Link "CloseFont()"}
@{"CloseMonitor()" Link "CloseMonitor()"}
@{"CMOVE " Link "CMOVE"}
@{"CoerceMode()" Link "CoerceMode()"}
@{"CopySBitMap()" Link "CopySBitMap()"}
@{"CWAIT " Link "CWAIT"}
@{"DisownBlitter()" Link "DisownBlitter()"}
@{"DisposeRegion()" Link "DisposeRegion()"}
@{"DoCollision()" Link "DoCollision()"}
@{"Draw()" Link "Draw()"}
@{"DrawEllipse()" Link "DrawEllipse()"}
@{"DrawGList()" Link "DrawGList()"}
@{"EraseRect()" Link "EraseRect()"}
@{"ExtendFont()" Link "ExtendFont()"}
@{"FindColor()" Link "FindColor()"}
@{"FindDisplayInfo()" Link "FindDisplayInfo()"}
@{"Flood()" Link "Flood()"}
@{"FontExtent()" Link "FontExtent()"}
@{"FreeBitMap()" Link "FreeBitMap()"}
@{"FreeColorMap()" Link "FreeColorMap()"}
@{"FreeCopList()" Link "FreeCopList()"}
@{"FreeCprList()" Link "FreeCprList()"}
@{"FreeDBufInfo()" Link "FreeDBufInfo()"}
@{"FreeGBuffers()" Link "FreeGBuffers()"}
@{"FreeRaster()" Link "FreeRaster()"}
@{"FreeSprite()" Link "FreeSprite()"}
@{"FreeSpriteData()" Link "FreeSpriteData()"}
@{"FreeVPortCopLists()" Link "FreeVPortCopLists()"}
@{"GetAPen()" Link "GetAPen()"}
@{"GetBitMapAttr()" Link "GetBitMapAttr()"}
@{"GetBPen()" Link "GetBPen()"}
@{"GetColorMap()" Link "GetColorMap()"}
@{"GetDisplayInfoData()" Link "GetDisplayInfoData()"}
@{"GetDrMd()" Link "GetDrMd()"}
@{"GetExtSpriteA()" Link "GetExtSpriteA()"}
@{"GetGBuffers()" Link "GetGBuffers()"}
@{"GetOPen()" Link "GetOPen()"}
@{"GetRGB32()" Link "GetRGB32()"}
@{"GetRGB4()" Link "GetRGB4()"}
@{"GetRPAttrA()" Link "GetRPAttrA()"}
@{"GetSprite()" Link "GetSprite()"}
@{"GetVPModeID()" Link "GetVPModeID()"}
@{"GfxAssociate()" Link "GfxAssociate()"}
@{"GfxFree()" Link "GfxFree()"}
@{"GfxLookUP()" Link "GfxLookUP()"}
@{"GfxNew()" Link "GfxNew()"}
@{"InitArea()" Link "InitArea()"}
@{"InitBitMap()" Link "InitBitMap()"}
@{"InitGels()" Link "InitGels()"}
@{"InitGMasks()" Link "InitGMasks()"}
@{"InitMasks()" Link "InitMasks()"}
@{"InitRastPort()" Link "InitRastPort()"}
@{"InitTmpRas()" Link "InitTmpRas()"}
@{"InitView()" Link "InitView()"}
@{"InitVPort()" Link "InitVPort()"}
@{"LoadRGB32()" Link "LoadRGB32()"}
@{"LoadRGB4()" Link "LoadRGB4()"}
@{"LoadView()" Link "LoadView()"}
@{"LockLayerRom()" Link "LockLayerRom()"}
@{"MakeVPort()" Link "MakeVPort()"}
@{"ModeNotAvailable()" Link "ModeNotAvailable()"}
@{"Move()" Link "Move()"}
@{"MoveSprite()" Link "MoveSprite()"}
@{"MrgCop()" Link "MrgCop()"}
@{"NewRegion()" Link "NewRegion()"}
@{"NextDisplayInfo()" Link "NextDisplayInfo()"}
@{"ObtainBestPenA()" Link "ObtainBestPenA()"}
@{"ObtainPen()" Link "ObtainPen()"}
@{"OpenFont()" Link "OpenFont()"}
@{"OpenMonitor()" Link "OpenMonitor()"}
@{"OrRectRegion()" Link "OrRectRegion()"}
@{"OrRegionRegion()" Link "OrRegionRegion()"}
@{"OwnBlitter()" Link "OwnBlitter()"}
@{"PolyDraw()" Link "PolyDraw()"}
@{"QBlit()" Link "QBlit()"}
@{"QBSBlit()" Link "QBSBlit()"}
@{"ReadPixel()" Link "ReadPixel()"}
@{"ReadPixelArray8()" Link "ReadPixelArray8()"}
@{"ReadPixelLine8()" Link "ReadPixelLine8()"}
@{"RectFill()" Link "RectFill()"}
@{"ReleasePen()" Link "ReleasePen()"}
@{"RemBob()" Link "RemBob()"}
@{"RemFont()" Link "RemFont()"}
@{"RemIBob()" Link "RemIBob()"}
@{"RemVSprite()" Link "RemVSprite()"}
@{"ScalerDiv()" Link "ScalerDiv()"}
@{"ScrollRaster()" Link "ScrollRaster()"}
@{"ScrollRasterBF()" Link "ScrollRasterBF()"}
@{"ScrollVPort()" Link "ScrollVPort()"}
@{"SetABPenDrMd()" Link "SetABPenDrMd()"}
@{"SetAPen()" Link "SetAPen()"}
@{"SetBPen()" Link "SetBPen()"}
@{"SetChipRev()" Link "SetChipRev()"}
@{"SetCollision()" Link "SetCollision()"}
@{"SetDrMd()" Link "SetDrMd()"}
@{"SetFont()" Link "SetFont()"}
@{"SetMaxPen()" Link "SetMaxPen()"}
@{"SetOPen()" Link "SetOPen()"}
@{"SetOutlinePen()" Link "SetOutlinePen()"}
@{"SetRast()" Link "SetRast()"}
@{"SetRGB32()" Link "SetRGB32()"}
@{"SetRGB32CM()" Link "SetRGB32CM()"}
@{"SetRGB4()" Link "SetRGB4()"}
@{"SetRGB4CM()" Link "SetRGB4CM()"}
@{"SetRPAttrA()" Link "SetRPAttrA()"}
@{"SetSoftStyle()" Link "SetSoftStyle()"}
@{"SetWriteMask()" Link "SetWriteMask()"}
@{"SortGList()" Link "SortGList()"}
@{"StripFont()" Link "StripFont()"}
@{"SyncSBitMap()" Link "SyncSBitMap()"}
@{"Text()" Link "Text()"}
@{"TextExtent()" Link "TextExtent()"}
@{"TextFit()" Link "TextFit()"}
@{"TextLength()" Link "TextLength()"}
@{"UnlockLayerRom()" Link "UnlockLayerRom()"}
@{"VBeamPos()" Link "VBeamPos()"}
@{"VideoControl()" Link "VideoControl()"}
@{"WaitBlit()" Link "WaitBlit()"}
@{"WaitBOVP()" Link "WaitBOVP()"}
@{"WaitTOF()" Link "WaitTOF()"}
@{"WriteChunkyPixels()" Link "WriteChunkyPixels()"}
@{"WritePixel()" Link "WritePixel()"}
@{"WritePixelArray8()" Link "WritePixelArray8()"}
@{"WritePixelLine8()" Link "WritePixelLine8()"}
@{"XorRectRegion()" Link "XorRectRegion()"}
@{"XorRegionRegion()" Link "XorRegionRegion()"}
@EndNode
@Node "AddAnimOb()" "graphics.library/AddAnimOb"
@{b}@{u}AddAnimOb@{uu}@{ub}  --  Add an AnimOb to the linked list of AnimObs.
  Links this AnimOb into the current list pointed to by animKey.
  Initializes all the Timers of the AnimOb's components.
  Calls @{"AddBob" Link "AddBob()"} with each component's @{"Bob" Link "include:graphics/gels.h/Main" 139}.
  rp->GelsInfo must point to an initialized @{"GelsInfo" Link "include:graphics/rastport.h/Main" 39} structure.
SYNOPSIS  @{FG shine}void@{FG text} AddAnimOb(@{FG shine}struct@{FG text} @{"AnimOb" Link "include:graphics/gels.h/Main" 203} *,@{FG shine}struct@{FG text} AnimOb **, @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *);
  AddAnimOb(@{i}anOb@{ui}, @{i}anKey@{ui}, @{i}rp@{ui})
             A0    A1     A2
  @{i}anOb@{ui}  = pointer to the AnimOb structure to be added to the list
  @{i}anKey@{ui} = address of a pointer to the first AnimOb in the list
    (anKey = NULL if there are no AnimObs in the list so far)
  @{i}rp@{ui}    = pointer to a valid RastPort
SEE ALSO
  @{"Animate()" Link "Animate()"} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0} @{"graphics/gels.h" Link "include:graphics/gels.h/Main" 0}
@EndNode
@Node "AddBob()" "graphics.library/AddBob"
@{b}@{u}AddBob@{uu}@{ub} -- Adds a Bob to current gel list.
  Sets up the system Bob flags, then links this gel into the list
  via @{"AddVSprite" Link "AddVSprite()"}.
SYNOPSIS  @{FG shine}void@{FG text} AddBob(@{FG shine}struct@{FG text} @{"Bob" Link "include:graphics/gels.h/Main" 139} *, @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *);
  AddBob(@{i}Bob@{ui}, @{i}rp@{ui})
          A0   A1
  @{i}Bob@{ui} = pointer to the Bob structure to be added to the gel list
  @{i}rp@{ui}  = pointer to a RastPort structure
SEE ALSO
  @{"InitGels()" Link "InitGels()"}  @{"AddVSprite()" Link "AddVSprite()"}  @{"graphics/gels.h" Link "include:graphics/gels.h/Main" 0}  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "AddFont()" "graphics.library/AddFont"
@{b}@{u}AddFont@{uu}@{ub} -- add a font to the system list.
  This function adds the text font to the system, making it
  available for use by any application.The font added must be
  in public memory, and remain until successfully removed.
SYNOPSIS  @{FG shine}void@{FG text} AddFont(@{FG shine}struct@{FG text} @{"TextFont" Link "include:graphics/text.h/Main" 89} *);
  AddFont(@{i}textFont@{ui})
           A1
  @{i}textFont@{ui} - a TextFont structure in public ram.
NOTES
  This function will set the tf_Accessors to 0.
SEE ALSO
  @{"SetFont()" Link "SetFont()"}  @{"RemFont()" Link "RemFont()"}  @{"graphics/text.h" Link "include:graphics/text.h/Main" 0}
@EndNode
@Node "AddVSprite()" "graphics.library/AddVSprite"
@{b}@{u}AddVSprite@{uu}@{ub} -- Add a VSprite to the current gel list.
  Sets up the system VSprite flags
  Links this VSprite into the current gel list using its Y,X
SYNOPSIS  @{FG shine}void@{FG text} AddVSprite(@{FG shine}struct@{FG text} @{"VSprite" Link "include:graphics/gels.h/Main" 72} *, @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *);
  AddVSprite(@{i}vs@{ui}, @{i}rp@{ui})
              A0  A1
  @{i}vs@{ui} = pointer to the VSprite structure to be added to the gel list
  @{i}rp@{ui} = pointer to a RastPort structure
SEE ALSO
  @{"InitGels()" Link "InitGels()"}  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}  @{"graphics/gels.h" Link "include:graphics/gels.h/Main" 0}
@EndNode
@Node "AllocBitMap()" "graphics.library/AllocBitMap"
@{b}@{u}AllocBitMap@{uu}@{ub} -- Allocate a bitmap and attach bitplanes to it.@{FG fill}(V39)@{FG text}
  Allocates and initializes a bitmap structure.Allocates and initializes
  bitplane data, and sets the bitmap's planes to point to it.
SYNOPSIS  @{FG shine}struct@{FG text} @{"BitMap" Link "include:graphics/gfx.h/Main" 46} *AllocBitMap(ULONG,ULONG,ULONG,ULONG, @{FG shine}struct@{FG text} BitMap *);
  @{i}@{b}bitmap@{ub}@{ui}=AllocBitMap(@{i}sizex@{ui},@{i}sizey@{ui},@{i}depth@{ui}, @{i}flags@{ui}, @{i}friend_bitmap@{ui})
                      d0    d1    d2      d3     a0
  @{i}sizex@{ui} = the width (in pixels) desired for the bitmap data.
  @{i}sizey@{ui} = the height (in pixels) desired.
  @{i}depth@{ui} = the number of bitplanes deep for the allocation.
    Pixels with AT LEAST this many bits will be allocated.
  @{"flags" link ALLOCBITMAP_FLAGS}
  @{i}friend_bitmap@{ui} = pointer to another bitmap, or NULL.
    If this pointer is passed, then the bitmap data will be allocated in
    the most efficient form for blitting to friend_bitmap.
NOTES
  When allocating using a friend bitmap, it is not safe to assume anything about
  the structure of the bitmap data if that friend BitMap might not be a standard
  amiga bitmap (for instance, if the workbench is running on a non-amiga display
  device, its Screen->RastPort->BitMap won't be in standard amiga format.
  The only safe operations to perform on a non-standard BitMap are:
  - blitting it to another bitmap, which must be either a standard Amiga bitmap,
    or a friend of this bitmap.
  - blitting from this bitmap to a friend bitmap or to a standard Amiga bitmap.
  - attaching it to a rastport and making rendering calls.
  Good arguments to pass for the friend_bitmap are your window's
  RPort->BitMap, and your screen's RastPort->BitMap.
  Do NOT pass &(screenptr->BitMap)!
  BitMaps not allocated with BMF_DISPLAYABLE may not be used as Intuition
  Custom BitMaps or as RasInfo->BitMaps.They may be blitted to a BMF_DISPLAYABLE
  BitMap, using one of the @{"BltBitMap()" Link "BltBitMap()"} family of functions.
SEE ALSO
  @{"FreeBitMap()" Link "FreeBitMap()"}
@EndNode
@node ALLOCBITMAP_FLAGS "AllocBitMap_flags"
@{i}BMF_CLEAR@{ui} to specify that the allocated raster should be filled with color 0.
@{i}BMF_DISPLAYABLE@{ui} to specify that this bitmap data should
  be allocated in such a manner that it can be displayed.
  Displayable data has more severe alignment restrictions
  than non-displayable data in some systems.
@{i}BMF_INTERLEAVED@{ui} tells graphics that you would like your
  bitmap to be allocated with one large chunk of display
  memory for all bitplanes.This minimizes color flashing
  on deep displays.If there is not enough contiguous RAM
  for an interleaved bitmap, graphics.library will fall
  back to a non-interleaved one.
@{i}BMF_MINPLANES@{ui} causes graphics to only allocate enough space
  in the bitmap structure for "depth" plane pointers.This
  is for system use and should not be used by applications use
  as it is inefficient, and may waste memory.
@endnode
@Node "AllocDBufInfo()" "graphics.library/AllocDBufInfo"
@{b}@{u}AllocDBufInfo@{uu}@{ub} -- Allocate structure for multi-buffered animation.@{FG fill}(V39)@{FG text}
  Allocates a structure which is used by the @{"ChangeVPBitMap()" Link "ChangeVPBitMap()"} routine.
SYNOPSIS  @{FG shine}struct@{FG text} DBufInfo * AllocDBufInfo(@{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *)
  AllocDBufInfo(@{i}vp@{ui})
                 a0
  @{i}vp@{ui}  =  A pointer to a ViewPort structure.
NOTES
  Returns 0 if there is no memory available or if the display mode
  of the viewport does not support double-buffering.
  The only fields of the DBufInfo structure which can be used by application
  programs are the @{i}dbi_SafeMessage@{ui}, @{i}dbi_DispMessage@{ui}, @{i}dbi_UserData1@{ui} and
  @{i}dbi_UserData2@{ui} fields.
  @{i}dbi_SafeMessage@{ui} and @{i}dbi_DispMessage@{ui} are standard exec message structures
  which may be used for synchronizing your animation with the screen update.
  @{i}dbi_SafeMessage@{ui} is a message which is replied to when it is safe to write to
  the old @{"BitMap" Link "include:graphics/gfx.h/Main" 46} (the one which was installed when you called ChangeVPBitMap).
  @{i}dbi_DispMessage@{ui} is replied to when it is safe to call ChangeVPBitMap again
  and be certain that the new frame has been seen at least once.
  The @{i}dbi_UserData1@{ui} and @{i}dbi_UserData2@{ui} fields, which are stored after each
  message, are for your application to stuff any data into that it may need
  to examine when looking at the reply coming into the ReplyPort for either
  of the embedded @{"Message" Link "include:exec/ports.h/Main" 48} structures.
  DBufInfo structures MUST be allocated with this function.The size of
  the structure will grow in future releases.
  The following fragment shows proper double buffering synchronization:
    @{FG shine}int@{FG text} @{i}SafeToChange@{ui}=TRUE, @{i}SafeToWrite@{ui}=TRUE, @{i}CurBuffer@{ui}=1;
    @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *@{i}ports@{ui}[2];    /* reply ports for DispMessage and SafeMessage */
    @{FG shine}struct@{FG text} BitMap *@{i}BmPtrs@{ui}[2];
    @{FG shine}struct@{FG text} DBufInfo *@{i}myDBI@{ui};
    ...allocate bitmap pointers, DBufInfo, set up viewports, etc.
    @{i}myDBI@{ui}->dbi_SafeMessage.@{i}mn_ReplyPort@{ui}=@{i}ports@{ui}[0];
    @{i}myDBI@{ui}->dbi_DispMessage.@{i}mn_ReplyPort@{ui}=@{i}ports@{ui}[1];
    @{FG shine}while@{FG text} (! @{i}done@{ui}) {
      @{FG shine}if@{FG text} (! @{i}SafeToWrite@{ui})
        @{FG shine}while@{FG text}(! GetMsg(@{i}ports@{ui}[0])) Wait(1l<<(@{i}ports@{ui}[0]->@{i}mp_SigBit@{ui}));
      @{i}SafeToWrite@{ui}=TRUE;
      ...render to bitmap # CurBuffer.
      @{FG shine}if@{FG text} (! @{i}SafeToChange@{ui})
        @{FG shine}while@{FG text}(! GetMsg(@{i}ports@{ui}[1])) Wait(1l<<(@{i}ports@{ui}[1]->@{i}mp_SigBit@{ui}));
      @{i}SafeToChange@{ui}=TRUE;
      WaitBlit();         /* be sure rendering has finished */
      ChangeVPBitMap(@{i}vp@{ui},BmPtrs[@{i}CurBuffer@{ui}],@{i}myDBI@{ui});
      @{i}SafeToChange@{ui}=FALSE;
      @{i}SafeToWrite@{ui}=FALSE;
      @{i}CurBuffer@{ui} ^=1;  /* toggle current buffer */
    }
    @{FG shine}if@{FG text} (! @{i}SafeToChange@{ui})  /* cleanup pending messages */
      @{FG shine}while@{FG text}(! GetMsg(@{i}ports@{ui}[1])) Wait(1l<<(@{i}ports@{ui}[1]->@{i}mp_SigBit@{ui}));
    @{FG shine}if@{FG text} (! @{i}SafeToWrite@{ui}) /* cleanup */
      @{FG shine}while@{FG text}(! GetMsg(@{i}ports@{ui}[0])) Wait(1l<<(@{i}ports@{ui}[0]->@{i}mp_SigBit@{ui}));
SEE ALSO
  @{"FreeDBufInfo()" Link "FreeDBufInfo()"} @{"ChangeVPBitMap()" Link "ChangeVPBitMap()"}
@EndNode
@Node "AllocRaster()" "graphics.library/AllocRaster"
@{b}@{u}AllocRaster@{uu}@{ub} -- Allocate space for a bitplane.
  This function calls the memory allocation routines
  to allocate memory space for a bitplane "width" bits
  wide and "height" bits high.
SYNOPSIS  PLANEPTR AllocRaster(ULONG,ULONG);
  @{i}@{b}planeptr@{ub}@{ui} = AllocRaster( @{i}width@{ui}, @{i}height@{ui} )
   d0                      d0     d1
  @{i}width@{ui} - number of columns in bitplane
  @{i}height@{ui}  - number of rows in bitplane
  @{i}@{b}planeptr@{ub}@{ui} - pointer to first word in bitplane,
    or NULL if it was not possible to allocate the desired amount of memory.
NOTES
  In order to assure proper alignment of display memory, the
  @{"AllocBitMap()" Link "AllocBitMap()"} function should be used instead of AllocRaster
  when you wish to allocate display memory (rasters which are
  attached to a ViewPort or Screen).
SEE ALSO
  @{"FreeRaster()" Link "FreeRaster()"} @{"graphics/gfx.h" Link "include:graphics/gfx.h/Main" 0}
@EndNode
@Node "AllocSpriteDataA()" "graphics.library/AllocSpriteDataA"
@{b}@{u}AllocSpriteDataA@{uu}@{ub} -- allocate sprite data and convert from a bitmap.@{FG fill}(V39)@{FG text}
@{b}@{u}AllocSpriteData@{uu}@{ub}  -- varargs stub for AllocSpriteData().@{FG fill}(V39)@{FG text}
  Allocate memory to hold a sprite image, and convert the passed-in
  bitmap data to the appropriate format.The tags allow specification
  of width, scaling, and other options.
SYNOPSIS
  @{FG shine}struct@{FG text} ExtSprite *AllocSpriteDataA( @{FG shine}struct@{FG text} @{"BitMap" Link "include:graphics/gfx.h/Main" 46} *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} * );
  extsprite=AllocSpriteData(bitmap,tags,...TAG_END)
  @{i}@{b}SpritePtr@{ub}@{ui} | 0 = AllocSpriteDataA(@{i}bitmap@{ui},@{i}taglist@{ui})
   d0                               a2      a1
  @{i}bitmap@{ui} - ptr to a bitmap.
    This bitmap provides the source data for the sprite image.
  @{"tags" link ALLOCSPRITEDATAA_TAGS}
  Bitplane data is not required to be in chip ram for this function.
  @{i}@{b}SpritePtr@{ub}@{ui} = a pointer to a ExtSprite structure, or 0 if there is a failure.
    You should pass this pointer to @{"FreeSpriteData()" Link "FreeSpriteData()"} when finished with the
    sprite.
BUGS
  Under V39, the appropriate attach bits would not be set in the sprite data.
  The work-around is to set the bits manually.Bit 7 of the second
  word should be set.On a 32 bit sprite, bit 7 of the 3rd word should
  also be set.For a 64 bit sprite, bit 7 of the 5th word should also be
  set.This should NOT be done under @{b}V40@{ub}, as the bug is fixed.
SEE ALSO
  @{"FreeSpriteData()" Link "FreeSpriteData()"} @{"FreeSprite()" Link "FreeSprite()"} @{"ChangeSprite()" Link "ChangeSprite()"} @{"MoveSprite()" Link "MoveSprite()"} @{"GetExtSpriteA()" Link "GetExtSpriteA()"}
  @{"AllocBitMap()" Link "AllocBitMap()"} @{"graphics/sprite.h" Link "include:graphics/sprite.h/Main" 0}
@EndNode
@node ALLOCSPRITEDATAA_TAGS "AllocSpriteDataA_tags"
@{i}SPRITEA_Width@{ui} - specifies how many pixels wide you desire the sprite to be.
  Specifying a width wider than the hardware can handle will cause the function
  to return failure.If the bitmap passed in is narrower than the width asked for,
  then it will be padded on the right with transparent pixels.
  Defaults to 16.
@{i}SPRITEA_XReplication@{ui} - controls the horizontal pixel replication factor used
  when converting the bitmap data.
  Valid values are:
    0 - perform a 1 to 1 conversion
    1 - each pixel from the source is replicated twice in the output.
    2 - each pixel is replicated 4 times.
   -1 - skip every other pixel in the source bitmap
   -2 - only include every fourth pixel from the source.
  This tag is useful for converting data from one resolution to another.
  For instance, hi-res bitmap data can be correctly converted for a lo-res
  sprite by using an x replication factor of -1.Defaults to 0.
@{i}SPRITEA_YReplication@{ui} - controls the vertical pixel replication factor
  in the same manner as @{i}SPRITEA_XReplication@{ui}@{i}@{ui} controls the horizontal.
@{i}SPRITEA_OutputHeight@{ui} - specifies how tall the resulting sprite should be.
  Defaults to the bitmap height.
  The bitmap MUST be at least as tall as the output height.
@{i}SPRITEA_Attached@{ui} - tells the function that you wish to convert the data for the
  second sprite in an attached sprite pair.This will cause AllocSpriteData() to
  take its data from the 3rd and 4th bitplanes of the passed in bitmap.
@endnode
@Node "AndRectRegion()" "graphics.library/AndRectRegion"
@{b}@{u}AndRectRegion@{uu}@{ub} -- Perform 2d AND operation of rectangle with region,
  leaving result in region.
  Clip away any portion of the region that exists outside
  of the rectangle.Leave the result in region.
SYNOPSIS  @{FG shine}void@{FG text} AndRectRegion( @{FG shine}struct@{FG text} @{"Region" Link "include:graphics/regions.h/Main" 28} *, @{FG shine}struct@{FG text} @{"Rectangle" Link "include:graphics/gfx.h/Main" 27} * );
  AndRectRegion(@{i}region@{ui},@{i}rectangle@{ui})
                 a0     a1
  @{i}region@{ui} - pointer to Region structure
  @{i}rectangle@{ui} - pointer to Rectangle structure
NOTES
  Unlike the other rect-region primitives, AndRectRegion() cannot fail.
SEE ALSO
  @{"AndRegionRegion()" Link "AndRegionRegion()"} @{"OrRectRegion()" Link "OrRectRegion()"} @{"graphics/regions.h" Link "include:graphics/regions.h/Main" 0}
@EndNode
@Node "AndRegionRegion()" "graphics.library/AndRegionRegion"
@{b}@{u}AndRegionRegion@{uu}@{ub} -- Perform 2d AND operation of one region with second region,
  leaving result in second region.
  Remove any portion of region2 that is not in region1.
SYNOPSIS  BOOL AndregionRegion(@{FG shine}struct@{FG text} @{"Region" Link "include:graphics/regions.h/Main" 28} *, @{FG shine}struct@{FG text} Region * );
  @{i}@{b}status@{ub}@{ui} = AndRegionRegion(@{i}region1@{ui},@{i}region2@{ui})
   d0                       a0      a1
  @{i}region1@{ui} - pointer to Region structure
  @{i}region2@{ui} - pointer to Region structure to use and for result
  @{i}@{b}status@{ub}@{ui} - return TRUE if successful operation,
    return FALSE if ran out of memory
SEE ALSO
  @{"OrRegionRegion()" Link "OrRegionRegion()"} @{"AndRectRegion()" Link "AndRectRegion()"} @{"graphics/regions.h" Link "include:graphics/regions.h/Main" 0}
@EndNode
@Node "Animate()" "graphics.library/Animate"
@{b}@{u}Animate@{uu}@{ub}  --  Processes every AnimOb in the current animation list.
  For every AnimOb in the list:
  - update its location and velocities
  - call the AnimOb's special routine if one is supplied
  - for each component of the AnimOb
  - if this sequence times out, switch to the new one
  - call this component's special routine if one is supplied
  - set the sequence's VSprite's y,x coordinates based on whatever
    these routines cause
SYNOPSIS  @{FG shine}void@{FG text} Animate(@{FG shine}struct@{FG text} @{"AnimOb" Link "include:graphics/gels.h/Main" 203} **, @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *);
  Animate(@{i}anKey@{ui}, @{i}rp@{ui})
           A0     A1
  @{i}ankey@{ui} = address of the variable that points to the head AnimOb
  @{i}rp@{ui}    = pointer to the RastPort structure
SEE ALSO
  @{"AddAnimOb()" Link "AddAnimOb()"} @{"graphics/gels.h" Link "include:graphics/gels.h/Main" 0} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "AreaCircle()" "graphics.library/AreaCircle"
@{b}@{u}AreaCircle@{uu}@{ub} -- add a circle to areainfo list for areafill.
  Add circle to the vector buffer.It will be drawn to the rastport when
  @{"AreaEnd" Link "AreaEnd()"} is executed.
SYNOPSIS  ULONG AreaCircle(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, WORD, WORD, UWORD);
  @{i}@{b}error@{ub}@{ui} = (@{FG shine}int@{FG text}) AreaCircle( @{i}rp@{ui},  @{i}cx@{ui},  @{i}cy@{ui}, @{i}radius@{ui})
   D0                        A1   D0    D1  D2
  @{i}rp@{ui}   - pointer to a RastPort structure
  @{i}cx@{ui}, @{i}cy@{ui}   - the coordinates of the center of the desired circle.
  @{i}radius@{ui}   - is the radius of the circle to draw around the centerpoint.
  @{i}@{b}error@{ub}@{ui} - 0 if no error, -1 if no space left in vector list
NOTES
  This function is actually a macro which calls
  AreaEllipse(rp,cx,cy,radius,radius).
SEE ALSO
  @{"AreaMove()" Link "AreaMove()"} @{"AreaDraw()" Link "AreaDraw()"} AreaCircle() @{"InitArea()" Link "InitArea()"} @{"AreaEnd()" Link "AreaEnd()"}
  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0} @{"graphics/gfxmacros.h" Link "include:graphics/gfxmacros.h/Main" 0}
@EndNode
@Node "AreaDraw()" "graphics.library/AreaDraw"
@{b}@{u}AreaDraw@{uu}@{ub} -- Add a point to a list of end points for areafill.
  Add point to the vector buffer.
SYNOPSIS  ULONG AreaDraw( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, SHORT, SHORT);
  @{i}@{b}error@{ub}@{ui} = AreaDraw( @{i}rp@{ui},  @{i}x@{ui},     @{i}y@{ui})
   d0                A1   D0:16  D1:16
  @{i}rp@{ui}  - points to a RastPort structure.
  @{i}x@{ui},@{i}y@{ui} - are coordinates of a point in the raster.
  @{i}@{b}error@{ub}@{ui} - zero for success, else
    -1 if no there was no space left in the vector list.
SEE ALSO
  @{"AreaMove()" Link "AreaMove()"} @{"InitArea()" Link "InitArea()"} @{"AreaEnd()" Link "AreaEnd()"} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "AreaEllipse()" "graphics.library/AreaEllipse"
@{b}@{u}AreaEllipse@{uu}@{ub} -- add a ellipse to areainfo list for areafill.
  Add an ellipse to the vector buffer.It will be draw when @{"AreaEnd()" Link "AreaEnd()"} is called.
SYNOPSIS  @{FG shine}long@{FG text} AreaEllipse( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, SHORT, SHORT, SHORT, SHORT)
  @{i}@{b}error@{ub}@{ui} = AreaEllipse( @{i}rp@{ui}, @{i}cx@{ui},   @{i}cy@{ui},   @{i}a@{ui},    @{i}b@{ui}    )
   d0                   a1  d0:16 d1:16 d2:16 d3:16
  @{i}rp@{ui} - pointer to a RastPort structure
  @{i}cx@{ui} - x coordinate of the centerpoint relative to the rastport.
  @{i}cy@{ui} - y coordinate of the centerpoint relative to the rastport.
  @{i}a@{ui}  - the horizontal radius of the ellipse (note: a must be > 0)
  @{i}b@{ui}  - the vertical radius of the ellipse (note: b must be > 0)
  @{i}@{b}error@{ub}@{ui} - zero for success, or -1 if there is no space left in the vector list
SEE ALSO
  @{"AreaMove()" Link "AreaMove()"} @{"AreaDraw()" Link "AreaDraw()"} @{"AreaCircle()" Link "AreaCircle()"} @{"InitArea()" Link "InitArea()"} @{"AreaEnd()" Link "AreaEnd()"}
  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "AreaEnd()" "graphics.library/AreaEnd"
@{b}@{u}AreaEnd@{uu}@{ub} -- @{"Process" Link "include:dos/dosextens.h/Main" 37} table of vectors and ellipses and produce areafill.
  Trigger the filling operation.
  Process the vector buffer and generate required fill into the raster planes.
  After the fill is complete, reinitialize for the next @{"AreaMove" Link "AreaMove()"} or
  @{"AreaEllipse" Link "AreaEllipse()"}.Use the raster set up by @{"InitTmpRas" Link "InitTmpRas()"}
  when generating an areafill mask.
SYNOPSIS  @{FG shine}long@{FG text} AreaEnd( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} * );
  @{i}@{b}error@{ub}@{ui} = AreaEnd(@{i}rp@{ui})
   d0              A1
  @{i}rp@{ui} - pointer to a RastPort structure which specifies where the filled
    regions will be rendered to.
  @{i}@{b}error@{ub}@{ui} - zero for success, or -1 if an error occurred anywhere.
SEE ALSO
  @{"InitArea()" Link "InitArea()"} @{"AreaMove()" Link "AreaMove()"} @{"AreaDraw()" Link "AreaDraw()"} @{"AreaEllipse()" Link "AreaEllipse()"}  @{"InitTmpRas()" Link "InitTmpRas()"}
  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "AreaMove()" "graphics.library/AreaMove"
@{b}@{u}AreaMove@{uu}@{ub} -- Define a new starting point for a new shape in the vector list.
  Close  the last polygon and start another polygon
  at  (x,y).Add the necessary  points  to  vector
  buffer.Closing a polygon may result in the generation
  of another @{"AreaDraw()" Link "AreaDraw()"} to close previous polygon.
  Remember to have an initialized @{"AreaInfo" Link "include:graphics/rastport.h/Main" 21} structure attached to the RastPort.
SYNOPSIS  @{FG shine}long@{FG text} AreaMove( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, SHORT, SHORT );
  @{i}@{b}error@{ub}@{ui} =  AreaMove( @{i}rp@{ui},   @{i}x@{ui},     @{i}y@{ui})
   d0                 a1    d0:16  d1:16
  @{i}rp@{ui}  - points to a RastPort structure
  @{i}x@{ui},@{i}y@{ui} - positions in the raster
  @{i}@{b}error@{ub}@{ui} - zero for success, or -1 if there is no space left in the vector list
SEE ALSO
  @{"InitArea()" Link "InitArea()"} @{"AreaDraw()" Link "AreaDraw()"} @{"AreaEllipse()" Link "AreaEllipse()"} @{"AreaEnd()" Link "AreaEnd()"} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "AskFont()" "graphics.library/AskFont"
@{b}@{u}AskFont@{uu}@{ub} -- get the text attributes of the current font.
  This function fills the text attributes structure with the
  attributes of the current font in the RastPort.
SYNOPSIS  @{FG shine}void@{FG text} AskFont(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, @{FG shine}struct@{FG text} @{"TextAttr" Link "include:graphics/text.h/Main" 65} *);
  AskFont(@{i}rp@{ui}, @{i}textAttr@{ui})
           A1  A0
  @{i}rp@{ui}       - the RastPort from which the text attributes are extracted
  @{i}textAttr@{ui} - the @{"TextAttr" Link "include:graphics/text.h/Main" 65} structure to be filled.
    Note that there is no support for a @{"TTextAttr" Link "include:graphics/text.h/Main" 72}.
    The textAttr structure is filled with the RastPort's text attributes.
SEE ALSO
  @{"graphics/text.h" Link "include:graphics/text.h/Main" 0}
@EndNode
@Node "AskSoftStyle()" "graphics.library/AskSoftStyle"
@{b}@{u}AskSoftStyle@{uu}@{ub} -- Get the soft style bits of the current font.
  This function returns those style bits of the current font
  that are not intrinsic in the font itself, but
  algorithmically generated.These are the bits that are
  valid to set in the enable mask for @{"SetSoftStyle()" Link "SetSoftStyle()"}.
SYNOPSIS  ULONG AskSoftStyle(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *);
  @{i}@{b}enable@{ub}@{ui} = AskSoftStyle(@{i}rp@{ui})
   D0                    A1
  @{i}rp@{ui} - the RastPort from which the font and style  are extracted.
  @{i}@{b}enable@{ub}@{ui} - those bits in the style algorithmically generated.
    Style bits that are not defined are also set.
SEE ALSO
  @{"SetSoftStyle()" Link "SetSoftStyle()"}  @{"graphics/text.h" Link "include:graphics/text.h/Main" 0}
@EndNode
@Node "AttachPalExtra()" "graphics.library/AttachPalExtra"
@{b}@{u}AttachPalExtra@{uu}@{ub} -- Allocate and attach a palette sharing structure to a
  colormap.@{FG fill}(V39)@{FG text}
  Allocates and attaches a PalExtra structure to a ColorMap.
  This is necessary for color palette sharing to work.The
  PalExtra structure will be freed by @{"FreeColorMap()" Link "FreeColorMap()"}.
  The set of available colors will be determined by the mode
  and depth of the viewport.
SYNOPSIS  @{FG shine}long@{FG text} AttachPalExtra( @{FG shine}struct@{FG text} @{"ColorMap" Link "include:graphics/view.h/Main" 143} *, @{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *);
  @{i}@{b}status@{ub}@{ui}=AttachPalExtra( @{i}cm@{ui}, @{i}vp@{ui})
                          a0  a1
  @{i}cm@{ui}  =  A pointer to a color map created by @{"GetColorMap()" Link "GetColorMap()"}.
  @{i}vp@{ui}   = A pointer to the viewport structure associated with the ColorMap.
  @{i}@{b}status@{ub}@{ui} - 0 if sucessful, else an error number.
    The only currently defined error number is out of memory (1).
NOTES
  This function is for use with custom ViewPorts and custom ColorMaps,
  as Intuition attaches a PalExtra to all of its Screens.
  If there is already a PalExtra associated with the ColorMap, then
  this function will do nothing.
SEE ALSO
  @{"GetColorMap()" Link "GetColorMap()"} @{"FreeColorMap()" Link "FreeColorMap()"} @{"ObtainPen()" Link "ObtainPen()"} @{"ObtainBestPenA()" Link "ObtainBestPenA()"}
@EndNode
@Node "AttemptLockLayerRom()" "graphics.library/AttemptLockLayerRom"
@{b}@{u}AttemptLockLayerRom@{uu}@{ub} -- Attempt to Lock Layer structure by ROM(gfx lib) code.
  Query the current state of the lock on this Layer.If it is
  already locked then return FALSE, could not lock.If the
  Layer was not locked then lock it and return TRUE.
  This call does not destroy any registers.
  This call nests so that callers in this chain will not lock themselves out.
SYNOPSIS  BOOL AttempLockLayerRom( @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} * );
  @{i}@{b}gotit@{ub}@{ui} = AttemptLockLayerRom( @{i}layer@{ui} )
   d0                           a5
  @{i}layer@{ui} - pointer to Layer structure
  @{i}@{b}gotit@{ub}@{ui} - TRUE or FALSE depending on whether the Layer was
    successfully locked by the caller.
SEE ALSO
  @{"LockLayerRom()" Link "LockLayerRom()"} @{"UnlockLayerRom()" Link "UnlockLayerRom()"}
@EndNode
@Node "BestModeIDA()" "graphics.library/BestModeIDA"
@{b}@{u}BestModeIDA@{uu}@{ub} -- calculate the best ModeID with given parameters.@{FG fill}(V39)@{FG text}
@{b}@{u}BestModeID@{uu}@{ub}  -- varargs stub for BestModeIDA().
  To determine the best ModeID to fit the parameters set in the TagList.
SYNOPSIS
  ULONG BestModeIDA(@{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  ULONG BestModeID (ULONG, ...);
  @{i}@{b}ID@{ub}@{ui} = BestModeIDA(@{i}TagItems@{ui})
   d0               a0
  @{i}@{b}ID@{ub}@{ui} = BestModeID (@{i}Tag1@{ui}, ...)
  @{i}TagItems@{ui} - A pointer to an array of TagItems.
@{"TAGS" link BESTMODEIDA_TAGS}
  @{i}@{b}ID@{ub}@{ui} - ID of the best mode to use, or INVALID_ID if a match could not be found.
NOTES
  This function takes into account the Compatability of the Monitor
  being matched to, and the source ViewPort or ModeID.
  Incompatibilitys will cause a result of INVALID_ID.
  @{i}BIDTAG_NominalWidth@{ui}, @{i}BIDTAG_NominalHeight@{ui},
  @{i}BIDTAG_DesiredWidth@{ui}, @{i}BIDTAG_DesiredHeight@{ui}, must all be non-0.
  The comparisons are made against the DimensionInfo->Nominal values.
  ie, this will not return a best fit against overscan dimensions.
EXAMPLE
  IFF Display Program with a HAM image, to be displayed in the same
  monitor type as the Workbench ViewPort.
    @{i}ID@{ui} = BestModeID(BIDTAG_NominalWidth, IFFImage->@{i}Width@{ui},
      BIDTAG_NominalHeight, IFFImage->@{i}Height@{ui},
      BIDTAG_Depth, IFFImage->@{i}Depth@{ui},
      BIDTAG_DIPFMustHave, DIPF_IS_HAM,
      BIDTAG_MonitorID, (GetVPModeID(WbVP) & MONITOR_ID_MASK), TAG_END);
  To make an interlace version of a ViewPort:
    @{i}ID@{ui} = BestModeID(BIDTAG_ViewPort, @{i}ThisViewPort@{ui},
      BIDTAG_MustHave, DIFP_IS_LACE, TAG_END);
SEE ALSO
  <graphics/modeid.h> @{"<graphics/displayinfo.h>" Link "include:graphics/displayinfo.h/Main" 0}
@EndNode
@node BESTMODEIDA_TAGS "BestModeIDA_tags"
@{i}BIDTAG_DIPFMustHave@{ui} (ULONG) - Mask of DIPF_ flags
  (from DisplayInfo->PropertyFlags) that the returned ModeID must have.
  Default - NULL.
@{i}BIDTAG_DIPFMustNotHave@{ui} (ULONG) - Mask of DIPF_ flags that the returned ModeID
  must not have.
  Default - SPECIAL_FLAGS.
@{i}BIDTAG_ViewPort@{ui} (@{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *) - ViewPort for which a best-fit ModeID is
  sought.Default - NULL.
@{i}BIDTAG_NominalWidth@{ui} (UWORD), @{i}BIDTAG_NominalHeight@{ui} (UWORD) - together make the
  aspect ratio.These values override the vp->DWidth and vp->DHeight values in
  the given ViewPort.
  Default - SourceID NominalDimensionInfo if @{i}BIDTAG_SourceID@{ui} is passed,
  or vp->DWidth and vp->DHeight if @{i}BIDTAG_ViewPort@{ui} is passed, or 640 x 200.
@{i}BIDTAG_DesiredWidth@{ui} (UWORD),@{i}BIDTAG_DesiredHeight@{ui} (UWORD) - Used to distinguish
  between two mode IDs with identical aspect ratios.
  Default - same values as NominalWidth and NominalHeight.
@{i}BIDTAG_Depth@{ui} (UBYTE) - minimum the returned ModeID must support.
  Default - vp->RasInfo->BitMap->Depth if @{i}BIDTAG_ViewPort@{ui} is passed, else 1.
@{i}BIDTAG_MonitorID@{ui} (ULONG) - returned ModeID must use this monitor.
  Default - will not restrict the search to any particular monitor.
@{i}BIDTAG_SourceID@{ui} (ULONG) - Use this ModeID instead of a ViewPort.
  If specified, the DIPFMustHave mask is made up of the
  ((DisplayInfo->PropertyFlags of this ID & SPECIAL_FLAGS) | DIPFMustHave flags).
  Default - VPModeID(vp) if @{i}BIDTAG_ViewPort@{ui} was passed, else the
  DIPFMustHave and DIPFMustNotHave masks are left unchanged.
@{i}BIDTAG_RedBits@{ui} (UBYTE), @{i}BIDTAG_BlueBits@{ui} (UBYTE),
@{i}BIDTAG_Greenits@{ui} (UBYTE) - Minimum bits per gun the resultant ModeID must support.
  Default - 4 bits per gun.
@endnode
@Node "BitMapScale()" "graphics.library/BitMapScale"
@{b}@{u}BitMapScale@{uu}@{ub} -- Perform raster scaling on a bit map.@{FG fill}(V36)@{FG text}
  Scale a source bit map to a non-overlapping destination bit map.
SYNOPSIS  @{FG shine}void@{FG text} BitMapScale(@{FG shine}struct@{FG text} @{"BitScaleArgs" Link "include:graphics/scale.h/Main" 18} *);
  BitMapScale(@{i}bitScaleArgs@{ui})
               A0
  @{"bitScaleArgs" link BITMAPSCALE_ARGS} - structure of parameters describing scale:
NOTES
  o This function may use the blitter.
  o Overlapping source and destination bit maps are not supported.
  o No check is made to ensure destBitMap is big enough: use
    @{"ScalerDiv" Link "ScalerDiv()"} to calculate a destination dimension.
BUGS
  o This function does not use the HighRes Agnus 'Big Blit'
    facility.You should not use XSrcFactor == XDestFactor,
    where SrcWidth or DestWidth > 1024.
  o Also, the blitter is used when expanding in the Y direction.
    You should not expand in the Y direction if
    ((DestX & 0xf) + DestWidth) >= 1024 pixels.(Up to 1008 pixels
    is always safe).
SEE ALSO
  @{"ScalerDiv()" Link "ScalerDiv()"}  @{"graphics/scale.h" Link "include:graphics/scale.h/Main" 0}
@EndNode
@node BITMAPSCALE_ARGS "BitMapScale_args"
@{i}bsa_SrcX@{ui}, @{i}bsa_SrcY@{ui} - origin of the source bits.
@{i}bsa_SrcWidth@{ui}, @{i}bsa_SrcHeight@{ui} - number of bits to scale from in x and y.
@{i}bsa_DestX@{ui}, @{i}bsa_DestY@{ui} - origin of the destination.
@{i}bsa_DestWidth@{ui}, @{i}bsa_DestHeight@{ui} - resulting number of bits in x and y.
  @{b}NOTE@{ub}: these values are set by this function.
@{i}bsa_XSrcFactor@{ui}:@{i}bsa_XDestFactor@{ui} - equivalent to the ratio
  @{i}srcWidth@{ui}:@{i}destWidth@{ui}, but not necessarily the same numbers.
  Each must be in the range 1..16383.
@{i}bsa_YSrcFactor@{ui}:@{i}bsa_YDestFactor@{ui} - equivalent to the ratio
  @{i}srcHeight@{ui}:@{i}destHeight@{ui}, but not necessarily the same numbers.
  Each must be in the range 1..16383.
@{i}bsa_SrcBitMap@{ui} - source of the bits to scale.
@{i}bsa_DestBitMap@{ui} - destination for the bits to scale.
  This had better be big enough!
@{i}bsa_Flags@{ui} - future scaling options.Set it to zero!
@{i}bsa_XDDA@{ui}, @{i}bsa_YDDA@{ui} - for future use.Need not be set by user.
@{i}bsa_Reserved1@{ui}, @{i}bsa_Reserved2@{ui} - for future use.Need not be set.
@endnode
@Node "BltBitMap()" "graphics.library/BltBitMap"
@{b}@{u}BltBitMap@{uu}@{ub} -- Move a rectangular region of bits in a BitMap.
  Perform non-destructive blits to move a rectangle from one
  area in a BitMap to another area, which can be on a different BitMap.
  This blit is assumed to be friendly: no error conditions (e.g.
  a rectangle outside the BitMap bounds) are tested or reported.
SYNOPSIS
  ULONG BltBitMap(@{FG shine}struct@{FG text} @{"BitMap" Link "include:graphics/gfx.h/Main" 46} *, WORD, WORD, @{FG shine}struct@{FG text} BitMap *, WORD, WORD,
    WORD, WORD, UBYTE, UBYTE, UWORD *);
  @{i}@{b}planecnt@{ub}@{ui} = BltBitMap(@{i}SrcBitMap@{ui}, @{i}SrcX@{ui}, @{i}SrcY@{ui}, @{i}DstBitMap@{ui}, @{i}DstX@{ui}, @{i}DstY@{ui},
   D0                   A0         D0:16  D1:16 A1         D2:16 D3:16
    @{i}SizeX@{ui}, @{i}SizeY@{ui}, @{i}Minterm@{ui}, @{i}Mask@{ui} [, @{i}TempA@{ui}])
     D4:16   D5:16  D6:8     D7:8   [A2]
  @{i}SrcBitMap@{ui}, @{i}DstBitMap@{ui} - the BitMap(s) containing the rectangles
  - the planes copied from the source to the destination are only those whose
    plane numbers are identical and less than the minimum Depth of either BitMap
    and whose Mask bit for that plane is non-zero.
  - as a special case, if a plane pointer in the SrcBitMap is zero, it acts as a
    pointer to a plane of all zeros, and if the plane pointer is 0xffffffff, it
    acts as a pointer to a plane of all ones.(Note: new for V36)
  - SrcBitMap and DstBitMap can be identical if they point to actual planes.
  @{i}SrcX@{ui}, @{i}SrcY@{ui} - the x and y coordinates of the upper left corner of the source
    rectangle.Valid range is positive signed integer such that the raster word's
    offset 0..(32767-Size)
  @{i}DstX@{ui}, @{i}DstY@{ui} - the x and y coordinates of the upper left corner of the
    destination for the rectangle.Valid range is as for Src.
  @{i}SizeX@{ui}, @{i}SizeY@{ui} - the size of the rectangle to be moved.Valid range is
    (X: 1..976; Y: 1..1023 such that final raster word's offset is 0..32767)
  @{i}Minterm@{ui} - the logic function to apply to the rectangle when A is non-zero
    (i.e. within the rectangle).B is the source rectangle and C, D is the
    destination for the rectangle.
    - $0C0 is a vanilla copy
    - $030 inverts the source before the copy
    - $050 ignores the source and inverts the destination
    - see the hardware reference manual for other combinations
  @{i}Mask@{ui} - the write mask to apply to this operation.Bits set indicate the
    corresponding planes (if not greater than the minimum plane count)
    are to participate in the operation.Typically this is set to 0xff.
  @{i}TempA@{ui} - If the copy overlaps exactly to the left or right (i.e. the scan
    line addresses overlap), and TempA is non-zero,it points to enough chip
    accessible memory to hold a line of A source for the blit (ie CHIP RAM).
    BltBitMap will allocate (and free) the needed TempA if none is provided
    and one is needed.Blit overlap is determined from the relation of the
    first non-masked planes in the source and destination bit maps.
  @{i}planecnt@{ui} - the number of planes actually involved in the blit.
NOTES
  o This function may use the blitter.
SEE ALSO
  @{"ClipBlit()" Link "ClipBlit()"}  @{"graphics/gfx.h" Link "include:graphics/gfx.h/Main" 0}  @{"hardware/blit.h" Link "include:hardware/blit.h/Main" 0}
@EndNode
@Node "BltBitMapRastPort()" "graphics.library/BltBitMapRastPort"
@{b}@{u}BltBitMapRastPort@{uu}@{ub} -- Blit from source bitmap to destination rastport.
  Blits from source bitmap to position specified in destination rastport
  using minterm.
SYNOPSIS
  BOOL BltBitMapRastPort(@{FG shine}struct@{FG text} @{"BitMap" Link "include:graphics/gfx.h/Main" 46} *, WORD, WORD, @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, WORD,
    WORD, WORD, WORD, UBYTE);
  @{i}@{b}error@{ub}@{ui} = BltBitMapRastPort
          (@{i}srcbm@{ui}, @{i}srcx@{ui}, @{i}srcy@{ui}, @{i}destrp@{ui}, @{i}destX@{ui}, @{i}destY@{ui}, @{i}sizeX@{ui}, @{i}sizeY@{ui}, @{i}minterm@{ui})
   D0       A0     D0    D1     A1      D2     D3     D4      D5     D6
  @{i}srcbm@{ui}   - a pointer to the source bitmap
  @{i}srcx@{ui}    - x offset into source bitmap
  @{i}srcy@{ui}    - y offset into source bitmap
  @{i}destrp@{ui}  - a pointer to the destination rastport
  @{i}destX@{ui}   - x offset into dest rastport
  @{i}destY@{ui}   - y offset into dest rastport
  @{i}sizeX@{ui}   - width of blit in pixels
  @{i}sizeY@{ui}   - height of blit in rows
  @{i}minterm@{ui} - minterm to use for this blit
  @{i}@{b}error@{ub}@{ui} - TRUE
SEE ALSO
  @{"BltMaskBitMapRastPort()" Link "BltMaskBitMapRastPort()"} @{"graphics/gfx.h" Link "include:graphics/gfx.h/Main" 0} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "BltClear()" "graphics.library/BltClear"
@{b}@{u}BltClear@{uu}@{ub} - Clear a block of memory words to zero.
  For memory that is local and blitter accessible, the most efficient way to
  clear a range of memory locations is to use the system's most efficient data
  mover, the blitter.This command accepts the starting location and count and
  clears that block to zeros.
SYNOPSIS  @{FG shine}void@{FG text} BltClear( @{FG shine}void@{FG text} *, ULONG, ULONG );
  BltClear( @{i}memBlock@{ui}, @{i}bytecount@{ui}, @{i}flags@{ui} )
             a1        d0         d1
  @{i}memBloc@{ui} - pointer to local memory to be cleared
    memBlock is assumed to be even.
  @{i}flags@{ui} - set bit 0 to force function to wait until the blit is done.
    set bit 1 to use row/bytesperrow.
  @{i}bytecount@{ui} - @{FG shine}if@{FG text} (@{i}flags@{ui} & 2) == 0 @{FG shine}then@{FG text} {even number of bytes to clear}
    @{FG shine}else@{FG text} {
      low 16 bits is taken as number of bytes per row and
      upper 16 bits taken as number of rows}.
NOTES
  This function is somewhat hardware dependent.In the rows/bytesperrow
  mode (with the pre-ECS blitter) rows must be <- 1024.In bytecount mode
  multiple runs of the blitter may be used to clear all the memory.
  Set bit 2 to use the upper 16 bits of the Flags as the data to fill 
  memory with instead of 0 @{FG fill}(V36)@{FG text}.The block of memory is initialized.
@EndNode
@Node "BltMaskBitMapRastPort()" "graphics.library/BltMaskBitMapRastPort"
@{b}@{u}BltMaskBitMapRastPort@{uu}@{ub} -- blit from source bitmap to destination rastport
  with masking of source image.
  Blits from source bitmap to position specified in destination rastport
  using bltmask to determine where source overlays destination, and
  minterm to determine whether to copy the source image "as is" or
  to "invert" the sense of the source image when copying.In either
  case, blit only occurs where the mask is non-zero.
SYNOPSIS
  @{FG shine}void@{FG text} BltMaskBitMapRastPort(@{FG shine}struct@{FG text} @{"BitMap" Link "include:graphics/gfx.h/Main" 46} *, WORD, WORD, @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *,
    WORD, WORD, WORD, WORD, UBYTE, APTR);
  BltMaskBitMapRastPort
      (@{i}srcbm@{ui}, @{i}srcx@{ui}, @{i}srcy@{ui}, @{i}destrp@{ui}, @{i}destX@{ui}, @{i}destY@{ui}, @{i}sizeX@{ui}, @{i}sizeY@{ui}, @{i}minterm@{ui}, @{i}bltmask@{ui})
        A0     D0    D1     A1      D2     D3      D4     D5     D6       A2
  @{i}srcbm@{ui}   - a pointer to the source bitmap
  @{i}srcx@{ui}    - x offset into source bitmap
  @{i}srcy@{ui}    - y offset into source bitmap
  @{i}destrp@{ui}  - a pointer to the destination rastport
  @{i}destX@{ui}   - x offset into dest rastport
  @{i}destY@{ui}   - y offset into dest rastport
  @{i}sizeX@{ui}   - width of blit in pixels
  @{i}sizeY@{ui}@{i}@{ui}   - height of blit in rows
  @{i}minterm@{ui} - either (ABC|ABNC|ANBC) if copy source and blit thru mask
   or (ANBC) if invert source and blit thru mask
  @{i}bltmask@{ui} - pointer to the single bit-plane mask, which must be the
    same size and dimensions as the planes of the source bitmap.
SEE ALSO
  @{"BltBitMapRastPort()" Link "BltBitMapRastPort()"} @{"graphics/gfx.h" Link "include:graphics/gfx.h/Main" 0} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "BltPattern()" "graphics.library/BltPattern"
@{b}@{u}BltPattern@{uu}@{ub} --  Using standard drawing rules for areafill, blit through a mask.
  Blit using drawmode,areafill pattern, and mask
  at position rectangle (xl,yl) (maxx,maxy).
SYNOPSIS
  @{FG shine}void@{FG text} BltPattern(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, @{FG shine}void@{FG text} *, SHORT, SHORT, SHORT, SHORT, SHORT);
  BltPattern(@{i}rp@{ui}, @{i}mask@{ui}, @{i}xl@{ui}, @{i}yl@{ui}, @{i}maxx@{ui}, @{i}maxy@{ui}, @{i}bytecnt@{ui})
              a1  a0    d0   d1  d2    d3    d4
  @{i}rp@{ui}    -  points to the destination RastPort for the blit.
  @{i}mask@{ui}  -  points to 2 dimensional mask if needed
    if mask == NULL then use a rectangle.
  @{i}xl@{ui},@{i}yl@{ui} -  coordinates of upper left of rectangular region in RastPort
  @{i}maxx@{ui},@{i}maxy@{ui} - points to lower right of rectangular region in RastPort
  @{i}bytecnt@{ui} - BytesPerRow for mask
SEE ALSO
  @{"AreaEnd" Link "AreaEnd()"}
@EndNode
@Node "BltTemplate()" "graphics.library/BltTemplate"
@{b}@{u}BltTemplate@{uu}@{ub} - Cookie cut a shape in a rectangle to the RastPort.
  This function draws the image in the template into the RastPort
  in the current color and drawing mode at the specified position.
  The template is assumed not to overlap  the destination.If the template
  falls outside the RastPort boundary, it is truncated to that boundary.
SYNOPSIS
  @{FG shine}void@{FG text} BltTemplate(UWORD *,WORD,WORD,@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *,WORD,WORD,WORD,WORD);
  BltTemplate(@{i}SrcTemplate@{ui}, @{i}SrcX@{ui}, @{i}SrcMod@{ui}, @{i}rp@{ui}, @{i}DstX@{ui},  @{i}DstY@{ui}, @{i}SizeX@{ui}, @{i}SizeY@{ui})
               A0           D0:16  D1:16   A1  D2:16  D3:16  D4:16  D5:16
  @{i}SrcTemplate@{ui}  - pointer to the first (nearest) word of the template mask.
  @{i}SrcX@{ui}         - x bit offset into the template mask (range 0..15).
  @{i}SrcMod@{ui}       - number of bytes per row in template mask.
  @{i}rp@{ui}           - pointer to destination RastPort.
  @{i}DstX@{ui}, @{i}DstY@{ui}   - x and y coordinates of the upper left corner of the
    destination for the blit.
  @{i}SizeX@{ui}, @{i}SizeY@{ui} - size of the rectangle to be used as the template.
NOTES
  o The SrcTemplate pointer should point to the "nearest" word (rounded down)
    of the template mask.Fine alignment of the mask is achieved by setting the
    SrcX bit offset within the range of 0 to 15 decimal.
  o This function may use the blitter.
SEE ALSO
  @{"BltBitMap()" Link "BltBitMap()"}  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "CalcIVG()" "graphics.library/CalcIVG"
@{b}@{u}CalcIVG@{uu}@{ub} -- Calculate the number of blank lines above a ViewPort.@{FG fill}(V39)@{FG text}
  To calculate the maximum number of blank lines above a viewport needed to
  load all the copper instructions, after accounting for the viewport
  bandwidth and size.
SYNOPSIS  UWORD CalcIVG(@{FG shine}struct@{FG text} @{"View" Link "include:graphics/view.h/Main" 57} *, @{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *);
  @{i}@{b}count@{ub}@{ui} = CalcIVG(@{i}View@{ui}, @{i}ViewPort@{ui})
   d0.w            a0     a1
  @{i}View@{ui}       - pointer to the View
  @{i}ViewPort@{ui}   - pointer to the ViewPort you are interested in.
  @{i}@{b}count@{ub}@{ui}      - the number of ViewPort resolution scan lines needed to
    execute all the copper instructions for ViewPort, or 0 if any error.
NOTES
  The number of copper instructions comes from the vp->vp_DspIns list.
  Although there may be other copper instructions in the final list (from
  UCopIns, SprIns and ClrIns) they are currently ignored for this function.
  This also means that if the ViewPort has never been made (for example, the
  ViewPort of an intuition screen was opened behind) then vp->vp_DspIns is NULL.
  Although CalcIVG() returns the true number of lines needed by the copper,intu-
  ition still maintains an inter-screen gap of 3 non-laced lines (6 interlaced).
  Therefore, for intuition screens use: MAX(CalcIVG(v, vp), (islaced ? 6 : 3))
SEE ALSO
  @{"GfxNew()" Link "GfxNew()"}  @{"VideoControl()" Link "VideoControl()"}  @{"graphics/view.h" Link "include:graphics/view.h/Main" 0}
@EndNode
@Node "CBump()" "graphics.library/CBump"
@{b}@{u}CBump@{uu}@{ub} -  increment user copper list pointer (bump to next position in list).
  Increment pointer to space for next instruction in user copper list.
SYNOPSIS  @{FG shine}void@{FG text} CBump( @{FG shine}struct@{FG text} @{"UCopList" Link "include:graphics/copper.h/Main" 82} * );
  CBump( @{i}c@{ui} )
         a1
  @{i}c@{ui} - pointer to UCopList structure
    User copper list pointer is incremented to next position.
    Pointer is repositioned to next user copperlist instruction block
    if the current block is full.
NOTE
  CBump is usually invoked for the programmer as part of the
  macro definitions @{"CWAIT" Link "CWAIT"} or @{"CMOVE" Link "CMOVE"}.
SEE ALSO
  @{"CINIT" Link "CINIT"} @{"CWAIT" Link "CWAIT"} @{"CMOVE" Link "CMOVE"} @{"CEND" Link "CEND"} @{"graphics/copper.h" Link "include:graphics/copper.h/Main" 0}
@EndNode
@Node "CEND" "graphics.library/CEND"
@{b}@{u}CEND@{uu}@{ub} -- Terminate user copper list.
  Add instruction to terminate user copper list.
SYNOPSIS  @{FG shine}struct@{FG text} @{"UCopList" Link "include:graphics/copper.h/Main" 82} *c;
  CEND( @{i}c@{ui} )
  @{i}c@{ui} - pointer to UCopList structure
NOTE
  This is actually a macro that calls the macro CWAIT(c,10000,255)
  10000 is a magical number that the graphics.library uses.
  I hope display technology doesn't catch up too fast!
SEE ALSO
  @{"CINIT" Link "CINIT"} @{"CWAIT" Link "CWAIT"} @{"CMOVE" Link "CMOVE"} @{"graphics/copper.h" Link "include:graphics/copper.h/Main" 0}
@EndNode
@Node "ChangeExtSpriteA()" "graphics.library/ChangeExtSpriteA"
@{b}@{u}ChangeExtSpriteA@{uu}@{ub} -- Change the sprite image pointer.@{FG fill}(V39)@{FG text}
  Attempt to change which sprite is displayed for a given sprite engine.
SYNOPSIS
  success=ChangeExtSpriteA(@{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *, @{FG shine}struct@{FG text} ExtSprite *,
    @{FG shine}struct@{FG text} ExtSprite *, @{FG shine}struct@{FG text} TagList *);
  @{i}@{b}success@{ub}@{ui}=ChangeExtSpriteA( @{i}vp@{ui}, @{i}oldsprite@{ui}, @{i}newsprite@{ui}, @{i}tags@{ui})
                             a0  a1          a2         a3
  @{i}@{b}success@{ub}@{ui}=ChangeExtSprite (@{i}vp@{ui},@{i}old_sp@{ui},@{i}new_sp@{ui},@{i}tag@{ui},....);
  @{i}vp@{ui} - pointer to ViewPort structure that this sprite is relative to,
    or 0 if relative only top of View
  @{i}oldsprite@{ui} - pointer the old ExtSprite structure
  @{i}newsprite@{ui} - pointer to the new ExtSprite structure.
  @{i}@{b}success@{ub}@{ui} - 0 if there was an error.
SEE ALSO
  @{"FreeSprite()" Link "FreeSprite()"} @{"ChangeSprite()" Link "ChangeSprite()"} @{"MoveSprite()" Link "MoveSprite()"} @{"AllocSpriteDataA()" Link "AllocSpriteDataA()"}
  @{"graphics/sprite.h" Link "include:graphics/sprite.h/Main" 0}
@EndNode
@Node "ChangeSprite()" "graphics.library/ChangeSprite"
@{b}@{u}ChangeSprite@{uu}@{ub} -- Change the sprite image pointer.
  The sprite image is changed to use the data starting at newdata.
SYNOPSIS  @{FG shine}void@{FG text} ChangeSprite(@{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *, @{FG shine}struct@{FG text} @{"SimpleSprite" Link "include:graphics/sprite.h/Main" 19} *, @{FG shine}void@{FG text} * )
  ChangeSprite( @{i}vp@{ui}, @{i}s@{ui}, @{i}newdata@{ui})
                 a0  a1 a2
  @{i}vp@{ui} - pointer to ViewPort structure that this sprite is relative to,
    or 0 if relative only top of View
  @{i}s@{ui} - pointer to SimpleWrite structure
  @{i}newdata@{ui} - pointer to data structure of the following form.
    @{FG shine}struct@{FG text} @{i}spriteimage@{ui}
      {
          UWORD  posctl[2]; /* used by simple sprite machine*/
          UWORD  data[height][2];   /* actual sprite image */
          UWORD  reserved[2]; /* initialized to 0x0,0x0 */
      };
    The programmer must initialize reserved[2].Spriteimage must be in CHIP
    memory.The height subfield of the SimpleWrite structure must be set to
    reflect the height of the new spriteimage BEFORE calling ChangeSprite().
    The programmer may allocate two sprites to handle a single attached sprite.
    After @{"GetSprite()" Link "GetSprite()"}, ChangeSprite(), the programmer can set the SPRITE_ATTACHED
    bit in posctl[1] of the odd numbered sprite.
NOTE
  If you need more than 8 sprites,look up VSprites in the graphics documentation.
SEE ALSO
  @{"FreeSprite()" Link "FreeSprite()"} ChangeSprite() @{"MoveSprite()" Link "MoveSprite()"} @{"AddVSprite()" Link "AddVSprite()"} @{"graphics/sprite.h" Link "include:graphics/sprite.h/Main" 0}
@EndNode
@Node "ChangeVPBitMap()" "graphics.library/ChangeVPBitMap"
@{b}@{u}ChangeVPBitMap@{uu}@{ub} -- change display memory address for multi-buffered
  animation.@{FG fill}(V39)@{FG text}
  Changes the area of display memory which will be displayed in a
  viewport.This can be used to implement double (or triple)
  buffering, a method of achieving smooth animation.
SYNOPSIS
  @{FG shine}void@{FG text} ChangeVPBitMap(@{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *, @{FG shine}struct@{FG text} @{"BitMap" Link "include:graphics/gfx.h/Main" 46} *, @{FG shine}struct@{FG text} DBufInfo *);
  ChangeVPBitMap(@{i}vp@{ui},@{i}bm@{ui},@{i}db@{ui})
                  a0 a1 a2
  @{i}vp@{ui}  =  a pointer to a viewport
  @{i}bm@{ui}  = a pointer to a BitMap structure.
    This BitMap structure must be of the same layout as the one attached
    to the viewport (same depth, alignment, and BytesPerRow).
  @{i}db@{ui}  =  A pointer to a DBufInfo.
NOTES
  This will set the vp->RasInfo->BitMap field to the bm pointer which is passed.
  When using the synchronization features, you MUST carefully insure that
  all messages have been replied to before calling FreeDBufInfo or
  calling ChangeVPBitMap with the same DBufInfo.
SEE ALSO
  @{"AllocDBufInfo()" Link "AllocDBufInfo()"} @{"AllocBitMap()" Link "AllocBitMap()"}
@EndNode
@Node "CINIT" "graphics.library/CINIT"
@{b}@{u}CINIT@{uu}@{ub} -- Initialize user copperlist to accept intermediate user copper
  instructions.
  Allocates and/or initialize copperlist structures/buffers
  internal to a UCopList structure.
  This is a macro that calls UCopListInit.You must pass a
  (non-initialized) UCopList to CINIT (CINIT will NOT allocate
  a new UCopList if ucl==0 ).If (ucl != 0) it will initialize the
  intermediate data buffers internal to a UCopList.
  The maximum number of intermediate copper list instructions that these
  internal CopList data buffers contain is specified as the parameter n.
SYNOPSIS  @{FG shine}struct@{FG text} @{"CopList" Link "include:graphics/copper.h/Main" 62} *UCopperListInit( @{FG shine}struct@{FG text} @{"UCopList" Link "include:graphics/copper.h/Main" 82} *, UWORD );
  @{i}@{b}cl@{ub}@{ui} = CINIT( @{i}ucl@{ui} , @{i}n@{ui} )
  @{i}@{b}cl@{ub}@{ui} = UCopperListInit( @{i}ucl@{ui} , @{i}n@{ui} )
                         a0    d0
  @{i}ucl@{ui} - pointer to UCopList structure
  @{i}n@{ui} - number of instructions buffer must be able to hold
  @{i}@{b}cl@{ub}@{ui}- a pointer to a buffer which will accept n intermediate copper instructions.
  @{b}NOTE@{ub}: this is NOT a UCopList pointer, rather a pointer to the
    UCopList's->FirstCopList sub-structure.
BUGS
  CINIT will not actually allocate a new UCopList if ucl==0.
  Instead you must allocate a block MEMF_PUBLIC|MEMF_CLEAR, the 
  @{FG shine}sizeof@{FG text}(@{FG shine}struct@{FG text} UCopList) and pass it to this function.
  The system's @{"FreeVPortCopLists" Link "FreeVPortCopLists()"} function will take care of
  deallocating it if they are called.
  Prior to release V36 the  CINIT macro had { } braces surrounding
  the definition, preventing the proper return of the result value.
  These braces have been removed for the V36 include definitions.
SEE ALSO
  CINIT @{"CMOVE" Link "CMOVE"} @{"CEND" Link "CEND"} @{"graphics/copper.h" Link "include:graphics/copper.h/Main" 0}
@EndNode
@Node "ClearEOL()" "graphics.library/ClearEOL"
@{b}@{u}ClearEOL@{uu}@{ub} -- Clear from current position to end of line.
  Clear a rectangular swath from the current position to the
  right edge of the rastPort.The height of the swath is taken
  from that of the current text font, and the vertical
  positioning of the swath is adjusted by the text baseline,
  such that text output at this position would lie wholly on
  this newly cleared area.
  Clearing consists of setting the color of the swath to zero,
  or, if the DrawMode is 2, to the BgPen.
SYNOPSIS  @{FG shine}void@{FG text} ClearEOL(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *);
  ClearEOL(@{i}rp@{ui})
            A1
  @{i}rp@{ui} - pointer to RastPort structure
NOTES
  o This function may use the blitter.
SEE ALSO
  @{"Text()" Link "Text()"}  @{"ClearScreen()" Link "ClearScreen()"}  @{"SetRast()" Link "SetRast()"}
  @{"graphics/text.h" Link "include:graphics/text.h/Main" 0}  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "ClearRectRegion()" "graphics.library/ClearRectRegion"
@{b}@{u}ClearRectRegion@{uu}@{ub} -- Perform 2d CLEAR operation of rectangle with region,
  leaving result in region.
  Clip away any portion of the region that exists inside
  of the rectangle.Leave the result in region.
SYNOPSIS  BOOL ClearRectRegion(@{FG shine}struct@{FG text} @{"Region" Link "include:graphics/regions.h/Main" 28} *, @{FG shine}struct@{FG text} @{"Rectangle" Link "include:graphics/gfx.h/Main" 27} * );
  @{i}@{b}status@{ub}@{ui} = ClearRectRegion(@{i}region@{ui},@{i}rectangle@{ui})
   d0                       a0     a1
  @{i}region@{ui} - pointer to Region structure
  @{i}rectangle@{ui} - pointer to Rectangle structure
  @{i}@{b}status@{ub}@{ui} - return TRUE if successful operation,
    return FALSE if ran out of memory
SEE ALSO
  @{"AndRectRegion()" Link "AndRectRegion()"} @{"graphics/regions.h" Link "include:graphics/regions.h/Main" 0}
@EndNode
@Node "ClearRegion()" "graphics.library/ClearRegion"
@{b}@{u}ClearRegion@{uu}@{ub} -- Remove all rectangles from region.
  Clip away all rectangles in the region leaving nothing.
SYNOPSIS  viod ClearRegion( @{FG shine}struct@{FG text} @{"Region" Link "include:graphics/regions.h/Main" 28} * );
  ClearRegion(@{i}region@{ui})
               a0
  @{i}region@{ui} - pointer to Region structure
SEE ALSO
  @{"NewRegion()" Link "NewRegion()"} @{"graphics/regions.h" Link "include:graphics/regions.h/Main" 0}
@EndNode
@Node "ClearScreen()" "graphics.library/ClearScreen"
@{b}@{u}ClearScreen@{uu}@{ub} -- Clear from current position to end of RastPort.
  Clear a rectangular swath from the current position to the
  right edge of the rastPort with @{"ClearEOL" Link "ClearEOL()"}, then clear the rest
  of the screen from just beneath the swath to the bottom of the rastPort.
  Clearing consists of setting the color of the swath to zero,
  or, if the DrawMode is 2, to the BgPen.
SYNOPSIS  @{FG shine}void@{FG text} ClearScreen(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *);
  ClearScreen(@{i}rp@{ui})
               A1
  @{i}rp@{ui} - pointer to RastPort structure
NOTES
  o This function may use the blitter.
SEE ALSO
  @{"ClearEOL()" Link "ClearEOL()"}  @{"Text()" Link "Text()"}  @{"SetRast()" Link "SetRast()"}
  @{"graphics/text.h" Link "include:graphics/text.h/Main" 0}  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "ClipBlit()" "graphics.library/ClipBlit"
@{b}@{u}ClipBlit@{uu}@{ub}  --  Calls @{"BltBitMap()" Link "BltBitMap()"} after accounting for windows.
  Performs the same function as @{"BltBitMap()" Link "BltBitMap()"}, except that it
  takes into account the Layers and ClipRects of the layer library,
  all of which are (and should be) transparent to you.So, whereas
  @{"BltBitMap()" Link "BltBitMap()"} requires pointers to BitMaps, ClipBlit requires pointers to
  the RastPorts that contain the Bitmaps, Layers, etcetera.
  If you are going to blit blocks of data around via the RastPort of your
  Intuition @{"Window" Link "include:intuition/intuition.h/Main" 910}, you must call this routine (rather than @{"BltBitMap()" Link "BltBitMap()"}).
  Either the Src RastPort, the Dest RastPort, both, or neither, can have
  Layers.This routine takes care of all cases.
  See @{"BltBitMap()" Link "BltBitMap()"} for a thorough explanation.
SYNOPSIS
  @{FG shine}void@{FG text} ClipBlit(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, WORD, WORD, @{FG shine}struct@{FG text} RastPort *, WORD, WORD,
    WORD, WORD, UBYTE);
  ClipBlit(@{i}Src@{ui}, @{i}SrcX@{ui}, @{i}SrcY@{ui}, @{i}Dest@{ui}, @{i}DestX@{ui}, @{i}DestY@{ui}, @{i}XSize@{ui}, @{i}YSize@{ui}, @{i}Minterm@{ui})
            A0   D0    D1     A1    D2     D3     D4      D5     D6
  @{i}Src@{ui}          = pointer to the RastPort of the source for your blit
  @{i}SrcX@{ui}, @{i}SrcY@{ui}   = the topleft offset into Src for your data
  @{i}Dest@{ui}         = pointer to the RastPort to receive the blitted data
  @{i}DestX@{ui}, @{i}DestY@{ui} = the topleft offset into the destination RastPort
  @{i}XSize@{ui}        = the width of the blit (must be ta least 1)
  @{i}YSize@{ui}        = the height of the blit (must be at least 1)
  @{i}Minterm@{ui}      = the boolean blitter function, where SRCB is associated
    with the Src RastPort and SRCC goes to the Dest RastPort
SEE ALSO
  BltBitMap();
@EndNode
@Node "CloseFont()" "graphics.library/CloseFont"
@{b}@{u}CloseFont@{uu}@{ub} -- Release a pointer to a system font.
  This function indicates that the font specified is no longer
  in use.It is used to close a font opened by @{"OpenFont" Link "OpenFont()"}, so
  that fonts that are no longer in use do not consume system resources.
SYNOPSIS  @{FG shine}void@{FG text} CloseFont(@{FG shine}struct@{FG text} @{"TextFont" Link "include:graphics/text.h/Main" 89} *);
  CloseFont(@{i}font@{ui})
             A1
  @{i}font@{ui} -  a font pointer as returned by @{"OpenFont()" Link "OpenFont()"} or @{"OpenDiskFont()" Link "libs.guide/OpenDiskFont()"}
SEE ALSO
  @{"OpenFont()" Link "OpenFont()"}  @{"diskfont.library/OpenDiskFont" Link "libs.guide/OpenDiskFont()"}  @{"graphics/text.h" Link "include:graphics/text.h/Main" 0}
@EndNode
@Node "CloseMonitor()" "graphics.library/CloseMonitor"
@{b}@{u}CloseMonitor@{uu}@{ub} -- close a MonitorSpec.@{FG fill}(V36)@{FG text}
  Relinquish access to a MonitorSpec.
SYNOPSIS  @{FG shine}long@{FG text} CloseMonitor( @{FG shine}struct@{FG text} @{"MonitorSpec" Link "include:graphics/monitor.h/Main" 25} * );
  @{i}@{b}error@{ub}@{ui} = CloseMonitor( @{i}monitor_spec@{ui} )
   d0                    a0
  @{i}monitor_spec@{ui} - a pointer to a MonitorSpec opened via @{"OpenMonitor()" Link "OpenMonitor()"}, or NULL.
  @{i}@{b}error@{ub}@{ui} - FALSE if MonitorSpec closed uneventfully.
    TRUE if MonitorSpec could not be closed.
SEE ALSO
  @{"OpenMonitor()" Link "OpenMonitor()"}
@EndNode
@Node "CMOVE" "graphics.library/CMOVE"
@{b}@{u}CMOVE@{uu}@{ub} -- append copper move instruction to user copper list.
  Add instruction to move value v to hardware register a.
  This is actually a macro that calls CMove(c,&a,v) and then calls CBump(c)
  to bump the local pointer to the next instruction.
  Watch out for macro side affects.
SYNOPSIS  @{FG shine}void@{FG text} CMove( @{FG shine}struct@{FG text} @{"UCopList" Link "include:graphics/copper.h/Main" 82} *, @{FG shine}void@{FG text} *, WORD );
  CMOVE( @{i}c@{ui} , @{i}a@{ui} , @{i}v@{ui} )
  CMove( @{i}c@{ui} , @{i}a@{ui} , @{i}v@{ui} )
          a1  d0  d1
  CBump( @{i}c@{ui} )
          a1
  @{i}c@{ui} - pointer to UCopList structure
  @{i}a@{ui} - hardware register
  @{i}v@{ui} - 16 bit value to be written
SEE ALSO
  @{"CINIT" Link "CINIT"} @{"CWAIT" Link "CWAIT"} @{"CEND" Link "CEND"} @{"graphics/copper.h" Link "include:graphics/copper.h/Main" 0}
@EndNode
@Node "CoerceMode()" "graphics.library/CoerceMode"
@{b}@{u}CoerceMode@{uu}@{ub} -- calculate ViewPort mode coercion.@{FG fill}(V39)@{FG text}
  To determine the best mode in the MonitorID to coerce RealViewPort to,
  given the restrictions set in Flags.
SYNOPSIS  ULONG CoerceMode(@{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *, ULONG, ULONG);
  @{i}@{b}ID@{ub}@{ui} = CoerceMode(@{i}RealViewPort@{ui}, @{i}MonitorID@{ui}, @{i}Flags@{ui});
   d0              a0            d0          d1
  @{i}RealViewPort@{ui} - ViewPort to coerce
  @{i}MonitorID@{ui} - Montor number to coerce to (ie a mode masked with MONITOR_ID_MASK).
  @{i}Flags@{ui} - PRESERVE_COLORS - keep the number of bitplanes in the ViewPort.
    AVOID_FLICKER - do not coerce to an interlace mode
  @{i}@{b}ID@{ub}@{ui} - ID of the best mode to coerce to, or INVALID_ID if could not coerce
    (see NOTES).
NOTES
  This function takes into account the compatibility of the Monitor
  being coerced to, and the ViewPort that is being coerced.
  Incompatibilities will cause a result of INVALID_ID.
EXAMPLE
  @{i}newmode@{ui} = CoerceMode(@{i}vp@{ui}, VGA_MONITOR_ID, PRESERVE_COLORS);
SEE ALSO
  <graphics/coerce.h> @{"<graphics/displayinfo.h>" Link "include:graphics/displayinfo.h/Main" 0}
@EndNode
@Node "CopySBitMap()" "graphics.library/CopySBitMap"
@{b}@{u}CopySBitMap@{uu}@{ub} -- Syncronize Layer window with contents of Super @{"BitMap" Link "include:graphics/gfx.h/Main" 46}.
  This is the inverse of @{"SyncSBitMap" Link "SyncSBitMap()"}.
  Copy all bits from SuperBitMap to Layer bounds.
  This is used for those functions that do not
  want to deal with the @{"ClipRect" Link "include:graphics/clip.h/Main" 63} structures but do want
  to be able to work with a SuperBitMap Layer.
SYNOPSIS  @{FG shine}void@{FG text} CopySBitMap(@{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *);
  CopySBitMap( @{i}layer@{ui} )
                a0
  @{i}layer@{ui} - pointer to a SuperBitMap Layer.
    The Layer must already be locked by the caller.
SEE ALSO
  @{"LockLayerRom()" Link "LockLayerRom()"} @{"SyncSBitMap()" Link "SyncSBitMap()"}
@EndNode
@Node "CWAIT" "graphics.library/CWAIT"
@{b}@{u}CWAIT@{uu}@{ub} -- Append copper wait instruction to user copper list.
  Add instruction to wait for vertical beam position v and
  horizontal position h to this intermediate copper list.
  This is actually a macro that calls CWait(c,v,h) and then calls CBump(c)
  to bump the local pointer to the next instruction.
SYNOPSIS  @{FG shine}void@{FG text} CWait( @{FG shine}struct@{FG text} @{"UCopList" Link "include:graphics/copper.h/Main" 82} *, WORD, WORD)
  CWAIT( @{i}c@{ui} , @{i}v@{ui} , @{i}h@{ui} )
  CWait( @{i}c@{ui} , @{i}v@{ui} , @{i}h@{ui} )
          a1  d0  d1
  CBump( @{i}c@{ui} )
          a1
  @{i}c@{ui} - pointer to UCopList structure
  @{i}v@{ui} - vertical beam position (relative to top of viewport)
  @{i}h@{ui} - horizontal beam position
BUGS
  User waiting for horizontal values of greater than 222 decimal is illegal.
SEE ALSO
  @{"CINIT" Link "CINIT"} @{"CMOVE" Link "CMOVE"} @{"CEND" Link "CEND"} @{"graphics/copper.h" Link "include:graphics/copper.h/Main" 0}
@EndNode
@Node "DisownBlitter()" "graphics.library/DisownBlitter"
@{b}@{u}DisownBlitter@{uu}@{ub} -- return blitter to free state.
  Free blitter up for use by other blitter users.
SYNOPSIS  @{FG shine}void@{FG text} DisownBlitter( @{FG shine}void@{FG text} );
  DisownBlitter()
SEE ALSO
  @{"OwnBlitter()" Link "OwnBlitter()"}
@EndNode
@Node "DisposeRegion()" "graphics.library/DisposeRegion"
@{b}@{u}DisposeRegion@{uu}@{ub} -- Return all space for this region to free memory pool.
  Free all RegionRectangles for this Region then free the Region itself.
SYNOPSIS  @{FG shine}void@{FG text} DisposeRegion( @{FG shine}struct@{FG text} @{"Region" Link "include:graphics/regions.h/Main" 28} * );
  DisposeRegion(@{i}region@{ui})
                 a0
  @{i}region@{ui} - pointer to Region structure
SEE ALSO
  @{"NewRegion()" Link "NewRegion()"} @{"graphics/regions.h" Link "include:graphics/regions.h/Main" 0}
@EndNode
@Node "DoCollision()" "graphics.library/DoCollision"
@{b}@{u}DoCollision@{uu}@{ub} -- Test every gel in gel list for collisions.
  Tests each gel in gel list for boundary and gel-to-gel collisions.
  On detecting one of these collisions, the appropriate collision-
  handling routine is called.See the documentation for a thorough
  description of which collision routine is called.This routine
  expects to find the gel list correctly sorted in Y,X order.
  The system routine @{"SortGList" Link "SortGList()"} performs this function for the user.
SYNOPSIS  @{FG shine}void@{FG text} DoCollision(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *);
  DoCollision(@{i}rp@{ui})
               A1
  @{i}rp@{ui} = pointer to a RastPort
SEE ALSO
  @{"InitGels()" Link "InitGels()"}  @{"SortGList()" Link "SortGList()"}  @{"graphics/gels.h" Link "include:graphics/gels.h/Main" 0}  @{"graphics/gels.h" Link "include:graphics/gels.h/Main" 0}
@EndNode
@Node "Draw()" "graphics.library/Draw"
@{b}@{u}Draw@{uu}@{ub} -- Draw a line between the current pen position and the new x,y position.
  Draw a line from the current pen position to (x,y).
SYNOPSIS  @{FG shine}void@{FG text} Draw( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, SHORT, SHORT);
  Draw( @{i}rp@{ui},   @{i}x@{ui},     @{i}y@{ui})
         a1    d0:16  d1:16
  @{i}rp@{ui} - pointer to the destination RastPort
  @{i}x@{ui},@{i}y@{ui} - coordinates of where in the RastPort to end the line.
SEE ALSO
  @{"Move()" Link "Move()"} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "DrawEllipse()" "graphics.library/DrawEllipse"
@{b}@{u}DrawEllipse@{uu}@{ub} -- Draw an ellipse centered at cx,cy with vertical and horizontal
  radii of a,b respectively.
  Creates an elliptical outline within the rectangular region
  specified by the parameters, using the current foreground pen color.
SYNOPSIS  @{FG shine}void@{FG text} DrawEllipse( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, SHORT, SHORT, SHORT, SHORT);
  DrawEllipse( @{i}rp@{ui}, @{i}cx@{ui}, @{i}cy@{ui}, @{i}a@{ui}, @{i}b@{ui} )
                a1  d0  d1   d2 d3
  @{i}rp@{ui} - pointer to the RastPort into which the ellipse will be drawn.
  @{i}cx@{ui} - x coordinate of the centerpoint relative to the rastport.
  @{i}cy@{ui} - y coordinate of the centerpoint relative to the rastport.
  @{i}a@{ui} - the horizontal radius of the ellipse (note: a must be > 0)
  @{i}b@{ui} - the vertical radius of the ellipse (note: b must be > 0)
NOTES
  this routine does not clip the ellipse to a non-layered rastport.
SEE ALSO
  DrawCircle(), @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "DrawGList()" "graphics.library/DrawGList"
@{b}@{u}DrawGList@{uu}@{ub} -- @{"Process" Link "include:dos/dosextens.h/Main" 37} the gel list, queueing VSprites, drawing Bobs.
  Performs one pass of the current gel list.
  - If nextLine and lastColor are defined, these are initialized for each gel.
  - If it's a @{"VSprite" Link "include:graphics/gels.h/Main" 72}, build it into the copper list.
  - If it's a @{"Bob" Link "include:graphics/gels.h/Main" 139}, draw it into the current raster.
  - Copy the save values into the "old" variables, double-buffering if required.
SYNOPSIS  @{FG shine}void@{FG text} DrawGList(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, @{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *);
  DrawGList(@{i}rp@{ui}, @{i}vp@{ui})
             A1  A0
  @{i}rp@{ui} = pointer to the RastPort where Bobs will be drawn
  @{i}vp@{ui} = pointer to the ViewPort for which VSprites will be created
BUGS
  MUSTDRAW isn't implemented yet.
SEE ALSO
  @{"InitGels()" Link "InitGels()"}  @{"graphics/gels.h" Link "include:graphics/gels.h/Main" 0} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}  @{"graphics/view.h" Link "include:graphics/view.h/Main" 0}
@EndNode
@Node "EraseRect()" "graphics.library/EraseRect"
@{b}@{u}EraseRect@{uu}@{ub} - Fill a defined rectangular area using the current BackFill hook.@{FG fill}(V36)@{FG text}
  Fill the rectangular region specified by the parameters with the
  BackFill hook.If non-layered, the rectangular region specified by
  the parameters is cleared.If layered the Layer->BackFill @{"Hook" Link "include:utility/hooks.h/Main" 23} is used.
SYNOPSIS  @{FG shine}void@{FG text} EraseRect(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, SHORT, SHORT, SHORT, SHORT);
  EraseRect( @{i}rp@{ui}, @{i}xmin@{ui}, @{i}ymin@{ui}, @{i}xmax@{ui}, @{i}ymax@{ui})
              a1  d0:16 d1:16  d2:16 d3:16
  @{i}rp@{ui}  - pointer to a RastPort structure
  @{i}xmin@{ui}  - x coordinate of the upper left corner of the region to fill.
  @{i}ymin@{ui}  - y coordinate of the upper left corner of the region to fill.
  @{i}xmax@{ui}  - x coordinate of the lower right corner of the region to fill.
  @{i}ymax@{ui}  - y coordinate of the lower right corner of the region to fill.
NOTES
  The following relation MUST be true:
  (xmax >= xmin) and (ymax >= ymin)
SEE ALSO
  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0} @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0}
@EndNode
@Node "ExtendFont()" "graphics.library/ExtendFont"
@{b}@{u}ExtendFont@{uu}@{ub} -- ensure tf_Extension has been built for a font.@{FG fill}(V36)@{FG text}
  To extend a TextFont structure.
SYNOPSIS
  ULONG ExtendFont(@{FG shine}struct@{FG text} @{"TextFont" Link "include:graphics/text.h/Main" 89} *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  ULONG ExtendFontTags(@{FG shine}struct@{FG text} @{"TextFont" Link "include:graphics/text.h/Main" 89} *, ULONG, ...);
  @{i}@{b}success@{ub}@{ui} = ExtendFont(@{i}font@{ui}, @{i}fontTags@{ui})
   D0                   A0     A1
  @{i}@{b}success@{ub}@{ui} = ExtendFontTags(@{i}font@{ui}, @{i}Tag1@{ui}, ...) @{FG fill}(V39)@{FG text}
  @{i}font@{ui} - The font to extend.
  @{i}fontTags@{ui} - An optional taglist.If NULL, then a default is used.
    Currently, the only tag defined is TA_DeviceDPI.
  @{i}@{b}success@{ub}@{ui} - 1 if the TextFont was properly extended, else 0.
NOTES
  The varargs stub was missing from amiga.lib until V39.
SEE ALSO
  @{"graphics/text.h" Link "include:graphics/text.h/Main" 0}
@EndNode
@Node "FindColor()" "graphics.library/FindColor"
@{b}@{u}FindColor@{uu}@{ub} -- Find the closest matching color in a colormap.@{FG fill}(V39)@{FG text}
  The system will attempt to find the color in the passed colormap which most
  closely matches the RGB values passed.No new pens will be allocated, and you
  should not @{"ReleasePen()" Link "ReleasePen()"} the returned pen.This function is not sensitive to
  palette sharing issues.Its intended use is for:
  (a) programs which pop up on public screens when those screens are not using
    palette sharing.You might use this function as a fallback when
    @{"ObtainBestPenA()" Link "ObtainBestPenA()"} says that there are no sharable pens.
  (b) Internal color matching by an application which is either running on a
    non-public screen, or which wants to match colors to an internal color table
    which may not be associated with any displayed screen.
SYNOPSIS  ULONG FindColor( @{FG shine}struct@{FG text} @{"ColorMap" Link "include:graphics/view.h/Main" 143} *, ULONG, ULONG, ULONG,@{FG shine}long@{FG text});
  @{i}@{b}color@{ub}@{ui} = FindColor( @{i}cm@{ui},  @{i}R@{ui},   @{i}G@{ui},    @{i}B@{ui} , @{i}maxpen@{ui})
                      a3   d1    d2    d3  d4
  @{i}cm@{ui} = colormap
  @{i}R@{ui} = red level   (32 bit left justified fraction)
  @{i}G@{ui} = green level (32 bit left justified fraction)
  @{i}B@{ui} = blue level  (32 bit left justified fraction)
  @{i}@{b}MaxPen@{ub}@{ui} = the maximum entry in the color table to search.A value of -1
    will limit the search to only those pens which could be rendered in
    (for instance, it will not examine the sprite colors on a 4 color screen).
NOTES
  In order to use the MaxPen=-1 feature, you must have initialized
  palette sharing via @{"AttachPalExtra()" Link "AttachPalExtra()"} (all intuition screens do this).
  Otherwise, MaxPen=-1 will search all colors in the colormap.
SEE ALSO
  @{"ObtainBestPenA()" Link "ObtainBestPenA()"} @{"GetColorMap()" Link "GetColorMap()"} @{"ObtainPen()" Link "ObtainPen()"} @{"ReleasePen()" Link "ReleasePen()"}
@EndNode
@Node "FindDisplayInfo()" "graphics.library/FindDisplayInfo"
@{b}@{u}FindDisplayInfo@{uu}@{ub} -- search for a record identified by a specific key.@{FG fill}(V36)@{FG text}
  Given a 32-bit Mode Key, return a handle to a valid DisplayInfoRecord
  found in the graphics database.Using this handle, you can obtain
  information about this Mode, including its default dimensions,
  properties, and whether it is currently available for use.
SYNOPSIS  DisplayInfoHandle FindDisplayInfo(ULONG);
  @{i}@{b}handle@{ub}@{ui} = FindDisplayInfo(@{i}ID@{ui})
   D0                       D0
  @{i}ID@{ui} - unsigned @{FG shine}long@{FG text} identifier
  @{i}@{b}handle@{ub}@{ui} - handle to a displayinfo Record with that key or NULL if no match.
SEE ALSO
  @{"graphics/displayinfo.h" Link "include:graphics/displayinfo.h/Main" 0}
@EndNode
@Node "Flood()" "graphics.library/Flood"
@{b}@{u}Flood@{uu}@{ub} -- Flood rastport like areafill.
  Search the @{"BitMap" Link "include:graphics/gfx.h/Main" 46} starting at (x,y).Fill all adjacent pixels if they are:
    Mode 0: not the same color as AOLPen
    Mode 1: the same color as the pixel at (x,y)
  When actually doing the fill use the modes that apply to standard areafill
  routine such as drawmodes and patterns.
SYNOPSIS  BOOL Flood(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, ULONG, SHORT, SHORT);
  @{i}@{b}error@{ub}@{ui} = Flood( @{i}rp@{ui}, @{i}mode@{ui}, @{i}x@{ui}, @{i}y@{ui})
   d0             a1  d2    d0  d1
  @{i}rp@{ui} - pointer to RastPort
  (@{i}x@{ui},@{i}y@{ui}) - coordinate in BitMap to start the flood fill at.
  @{i}mode@{ui} - 0 fill all adjacent pixels searching for border.
    1 fill all adjacent pixels that have same pen number as the one at (x,y).
NOTES
  In order to use Flood, the destination RastPort must have a valid
  @{"TmpRas" Link "include:graphics/rastport.h/Main" 32} raster whose size is as large as that of the RastPort.
SEE ALSO
  @{"AreaEnd()" Link "AreaEnd()"} @{"InitTmpRas()" Link "InitTmpRas()"} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "FontExtent()" "graphics.library/FontExtent"
@{b}@{u}FontExtent@{uu}@{ub} -- get the font attributes of the current font.@{FG fill}(V36)@{FG text}
  This function fills the text extent structure with a bounding
  (i.e. maximum) extent for the characters in the specified font.
SYNOPSIS  @{FG shine}void@{FG text} FontExtent(@{FG shine}struct@{FG text} @{"TextFont" Link "include:graphics/text.h/Main" 89} *, @{FG shine}struct@{FG text} @{"TextExtent" Link "include:graphics/text.h/Main" 165} *);
  FontExtent(@{i}font@{ui}, @{i}fontExtent@{ui})
              A0    A1
  @{i}font@{ui}       - the TextFont from which the font metrics are extracted.
  @{i}fontExtent@{ui} - the @{"TextExtent" Link "include:graphics/text.h/Main" 165} structure to be filled.
  fontExtent is filled.
NOTES
  The TextFont, not the RastPort, is specified -- unlike
  @{"TextExtent()" Link "TextExtent()"}, effect of algorithmic enhancements is not
  included, nor does te_Width include any effect of
  rp_TxSpacing.The returned te_Width will be negative only
  when FPF_REVPATH is set in the tf_Flags of the font -- the
  effect of left-moving characters is ignored for the width of
  a normal font, and the effect of right-moving characters is
  ignored if a REVPATH font.These characters will, however,
  be reflected in the bounding extent.
SEE ALSO
  @{"TextExtent()" Link "TextExtent()"}  @{"graphics/text.h" Link "include:graphics/text.h/Main" 0}
@EndNode
@Node "FreeBitMap()" "graphics.library/FreeBitMap"
@{b}@{u}FreeBitMap@{uu}@{ub} -- free a bitmap created by AllocBitMap.@{FG fill}(V39)@{FG text}
  Frees bitmap and all associated bitplanes
SYNOPSIS  @{FG shine}void@{FG text} FreeBitMap(@{FG shine}struct@{FG text} @{"BitMap" Link "include:graphics/gfx.h/Main" 46} *)
  FreeBitMap(@{i}bm@{ui})
              a0
  @{i}bm@{ui}  =  A pointer to a BitMap structure.
    Passing a NULL-pointer (meaning "do nothing") is OK.
NOTES
  Be careful to insure that any rendering done to the bitmap has
  completed (by calling @{"WaitBlit()" Link "WaitBlit()"}) before you call this function.
SEE ALSO
  @{"AllocBitMap()" Link "AllocBitMap()"}
@EndNode
@Node "FreeColorMap()" "graphics.library/FreeColorMap"
@{b}@{u}FreeColorMap@{uu}@{ub} - Free the ColorMap structure and return memory to free memory pool.
  Return the memory to the free memory pool that was allocated
  with @{"GetColorMap" Link "GetColorMap()"}.
SYNOPSIS  @{FG shine}void@{FG text} FreeColorMap(@{FG shine}struct@{FG text} @{"ColorMap" Link "include:graphics/view.h/Main" 143} *);
  FreeColorMap( @{i}colormap@{ui} )
                 a0
  @{i}colormap@{ui} - pointer to ColorMap allocated with @{"GetColorMap" Link "GetColorMap()"}.
    Passing a NULL pointer (meaning "do nothing") is acceptable @{FG fill}(V39)@{FG text}.
  The space is made available for others to use.
SEE ALSO
  @{"SetRGB4()" Link "SetRGB4()"} @{"GetColorMap()" Link "GetColorMap()"} @{"graphics/view.h" Link "include:graphics/view.h/Main" 0}
@EndNode
@Node "FreeCopList()" "graphics.library/FreeCopList"
@{b}@{u}FreeCopList@{uu}@{ub} -- deallocate intermediate copper list.
  Deallocate all memory associated with this copper list.
SYNOPSIS  @{FG shine}void@{FG text} FreeCopList( @{FG shine}struct@{FG text} @{"CopList" Link "include:graphics/copper.h/Main" 62} *);
  FreeCopList(@{i}coplist@{ui})
               a0
  @{i}coplist@{ui}  - pointer to structure CopList
  memory returned to memory manager
SEE ALSO
  @{"graphics/copper.h" Link "include:graphics/copper.h/Main" 0}
@EndNode
@Node "FreeCprList()" "graphics.library/FreeCprList"
@{b}@{u}FreeCprList@{uu}@{ub} -- deallocate hardware copper list.
  Return cprlist to free memory pool.
SYNOPSIS  @{FG shine}void@{FG text} FreeCprList(@{FG shine}struct@{FG text} @{"cprlist" Link "include:graphics/copper.h/Main" 55} *);
  FreeCprList(@{i}cprlist@{ui})
               a0
  @{i}cprlist@{ui} - pointer to cprlist structure
  memory returned and made available to other tasks
SEE ALSO
  @{"graphics/copper.h" Link "include:graphics/copper.h/Main" 0}
@EndNode
@Node "FreeDBufInfo()" "graphics.library/FreeDBufInfo"
@{b}@{u}FreeDBufInfo@{uu}@{ub} -- free information for multi-buffered animation.@{FG fill}(V39)@{FG text}
  Frees a structure obtained from AllocDBufInfo.
SYNOPSIS  @{FG shine}void@{FG text} FreeDBufInfo(@{FG shine}struct@{FG text} DBufInfo *)
  FreeDBufInfo(@{i}db@{ui})
                a1
  @{i}db@{ui}  =  A pointer to a DBufInfo.
NOTES
  FreeDBufInfo(NULL) is a no-op.
SEE ALSO
  @{"AllocDBufInfo()" Link "AllocDBufInfo()"} @{"ChangeVPBitMap()" Link "ChangeVPBitMap()"}
@EndNode
@Node "FreeGBuffers()" "graphics.library/FreeGBuffers"
@{b}@{u}FreeGBuffers@{uu}@{ub} -- Deallocate memory obtained by GetGBufers.
  For each sequence of each component of the AnimOb, deallocate memory for:
    SaveBuffer
    BorderLine
    CollMask and ImageShadow (point to same buffer)
    if db is set (user had used double-buffering) deallocate:
      @{"DBufPacket" Link "include:graphics/gels.h/Main" 233}
      BufBuffer
SYNOPSIS  @{FG shine}void@{FG text} FreeGBuffers(@{FG shine}struct@{FG text} @{"AnimOb" Link "include:graphics/gels.h/Main" 203} *, @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, BOOL);
  FreeGBuffers(@{i}anOb@{ui}, @{i}rp@{ui}, @{i}db@{ui})
                A0    A1  D0
  @{i}anOb@{ui} = pointer to the AnimOb structure
  @{i}rp@{ui}   = pointer to the current RastPort
  @{i}db@{ui}   = double-buffer indicator (set TRUE for double-buffering)
SEE ALSO
  @{"GetGBuffers()" Link "GetGBuffers()"}  @{"graphics/gels.h" Link "include:graphics/gels.h/Main" 0}  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "FreeRaster()" "graphics.library/FreeRaster"
@{b}@{u}FreeRaster@{uu}@{ub} -- Release an allocated area to the system free memory pool.
  Return the memory associated with this PLANEPTR of size width and height
  to the MEMF_CHIP memory pool.
SYNOPSIS  @{FG shine}void@{FG text} FreeRaster( PLANEPTR, USHORT, USHORT);
  FreeRaster( @{i}p@{ui}, @{i}width@{ui}, @{i}height@{ui})
               a0 d0:16  d1:16
  @{i}p@{ui}  =  a pointer to a memory space returned as a result of a call to
    @{"AllocRaster" Link "AllocRaster()"}.
  @{i}width@{ui} - the width in bits of the bitplane.
  @{i}height@{ui} - number of rows in bitplane.
NOTES
  Width and height should be the same values with which youcalled @{"AllocRaster" Link "AllocRaster()"}
  in the first place.
SEE ALSO
  @{"AllocRaster()" Link "AllocRaster()"} @{"graphics/gfx.h" Link "include:graphics/gfx.h/Main" 0}
@EndNode
@Node "FreeSprite()" "graphics.library/FreeSprite"
@{b}@{u}FreeSprite@{uu}@{ub} -- Return sprite for use by others and virtual sprite machine.
  Mark sprite as available for others to use.
  These sprite routines are provided to ease sharing of sprite hardware and to
  handle simple cases of sprite usage and movement.It is assumed the programs
  that use these routines do want to be good citizens in their hearts.ie: they
  will not FreeSprite unless they actually own the sprite.
  The Virtual Sprite machine may ignore the simple sprite machine.
SYNOPSIS  @{FG shine}void@{FG text} FreeSprite( WORD );
  FreeSprite( @{i}pick@{ui} )
               d0
  @{i}pick@{ui} - number in range of 0-7
  Sprite made available for subsequent callers of @{"GetSprite" Link "GetSprite()"} as well as use by
  Virtual Sprite Machine.
SEE ALSO
  @{"GetSprite()" Link "GetSprite()"} @{"ChangeSprite()" Link "ChangeSprite()"} @{"MoveSprite()" Link "MoveSprite()"} @{"graphics/sprite.h" Link "include:graphics/sprite.h/Main" 0}
@EndNode
@Node "FreeSpriteData()" "graphics.library/FreeSpriteData"
@{b}@{u}FreeSpriteData@{uu}@{ub} -- free sprite data allocated by AllocSpriteData().@{FG fill}(V39)@{FG text}
SYNOPSIS  @{FG shine}void@{FG text} FreeSpriteData(@{FG shine}struct@{FG text} ExtSprite *);
  FreeSpriteData(@{i}extsp@{ui})
                  a2
  @{i}extsp@{ui} - The extended sprite structure to be freed.Passing NULL is a NO-OP.
SEE ALSO
  FreeSpriteData() @{"FreeSprite()" Link "FreeSprite()"} @{"ChangeSprite()" Link "ChangeSprite()"} @{"MoveSprite()" Link "MoveSprite()"} GetExtSprite()
  @{"AllocBitMap()" Link "AllocBitMap()"} @{"graphics/sprite.h" Link "include:graphics/sprite.h/Main" 0}
@EndNode
@Node "FreeVPortCopLists()" "graphics.library/FreeVPortCopLists"
@{b}@{u}FreeVPortCopLists@{uu}@{ub} -- deallocate all intermediate copper lists and their headers
  from a viewport.
  Search display, color, sprite, and user copper lists and call @{"FreeMem()" Link "exec.guide/FreeMem()"}
  to deallocate them from memory.
SYNOPSIS  @{FG shine}void@{FG text} FreeVPortCopLists(@{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *);
  FreeVPortCopLists(@{i}vp@{ui})
                     a0
  @{i}vp@{ui} - pointer to ViewPort structure
  The memory allocated to the various copper lists will be returned
  to the system's free memory pool, and the following fields in
  the viewport structure will be set to NULL:
    @{i}DspIns@{ui}, @{i}Sprins@{ui}, @{i}ClrIns@{ui}, @{i}UCopIns@{ui}
SEE ALSO
  @{"graphics/view.h" Link "include:graphics/view.h/Main" 0}
@EndNode
@Node "GetAPen()" "graphics.library/GetAPen"
@{b}@{u}GetAPen@{uu}@{ub} -- Get the A Pen value for a RastPort.@{FG fill}(V39)@{FG text}
  Return the current value of the A pen for the rastport.This function
  should be used instead of peeking the structure directly, because future
  graphics devices may store it differently, for instance, using more bits.
SYNOPSIS  ULONG GetAPen(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *)
  @{i}@{b}pen@{ub}@{ui} = GetAPen( @{i}rp@{ui} )
   d0             a0
  @{i}rp@{ui} = a pointer to a valid RastPort structure.
SEE ALSO
  @{"SetAPen()" Link "SetAPen()"} @{"graphics/gfx.h" Link "include:graphics/gfx.h/Main" 0}
@EndNode
@Node "GetBitMapAttr()" "graphics.library/GetBitMapAttr"
@{b}@{u}GetBitMapAttr@{uu}@{ub} -- Returns information about a bitmap.@{FG fill}(V39)@{FG text}
  Determines information about a bitmap.This function should be used
  instead of reading the bitmap structure fields directly.This will
  provide future compatibility.
SYNOPSIS  ULONG GetBitMapAttr(@{FG shine}struct@{FG text} @{"BitMap" Link "include:graphics/gfx.h/Main" 46} *,ULONG);
  @{i}@{b}value@{ub}@{ui}=GetBitMapAttr(@{i}bitmap@{ui},@{i}attribute_number@{ui});
   d0                  a0      d1
  @{i}bm@{ui}  =  A pointer to a BitMap structure.
  @{i}attribute_number@{ui} = A number telling graphics which attribute
    of the bitmap should be returned:
    @{i}BMA_HEIGHT@{ui} - returns the height in pixels
    @{i}BMA_WIDTH@{ui} - returns the width in pixels.
    @{i}BMA_DEPTH@{ui} - returns the depth.
      This is the number of bits which are required to store the information for
      one pixel in the bitmap.
    @{i}BMA_FLAGS@{ui} - returns a longword bitfield describing various attributes which
      the bitmap may have.Currently defined flags are BMF_DISPLAYABLE,
      BMF_INTERLEAVED (see AllocBitMap()).The flag BMF_STANDARD returns will be
      set if the bitmap is represented as planar data in Amiga Chip RAM.
NOTES
  Unknown attributes are reserved for future use, and return zero.
  BMF_DISPLAYABLE will only be set if the source bitmap meets all of the
  required alignment restrictions.A bitmap which does not meet these
  restrictions may still be displayable at some loss of efficiency.
  Size values returned by this function may not exactly match the values
  which were passed to @{"AllocBitMap()" Link "AllocBitMap()"}, due to alignment restrictions.
SEE ALSO
  @{"AllocBitMap()" Link "AllocBitMap()"}
@EndNode
@Node "GetBPen()" "graphics.library/GetBPen"
@{b}@{u}GetBPen@{uu}@{ub} - Get the B Pen value for a RastPort.@{FG fill}(V39)@{FG text}
  Return the current value of the B pen for the rastport.This function
  should be used instead of peeking the structure directly, because future
  graphics devices may store it differently, using more bits.
SYNOPSIS  ULONG GetBPen(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *)
  @{i}@{b}pen@{ub}@{ui} = GetBPen( @{i}rp@{ui} )
   d0             a0
  @{i}rp@{ui}  =  a pointer to a valid RastPort structure.
SEE ALSO
  @{"SetBPen()" Link "SetBPen()"} @{"graphics/gfx.h" Link "include:graphics/gfx.h/Main" 0}
@EndNode
@Node "GetColorMap()" "graphics.library/GetColorMap"
@{b}@{u}GetColorMap@{uu}@{ub} -- allocate and initialize Colormap.
  Allocates, initializes and returns a pointer to a ColorMap data structure,
  later enabling calls to @{"SetRGB4" Link "SetRGB4()"}  and @{"LoadRGB4" Link "LoadRGB4()"} to load colors for a view port.
  The ColorTable pointer in the ColorMap structure points to a hardware specific
  colormap data structure.You should not count on it being anything you can
  understand.Use @{"GetRGB4()" Link "GetRGB4()"} to query it or @{"SetRGB4CM" Link "SetRGB4CM()"} to set it directly.
SYNOPSIS  @{FG shine}struct@{FG text} @{"ColorMap" Link "include:graphics/view.h/Main" 143} *GetColorMap( ULONG);
  @{i}@{b}cm@{ub}@{ui} = GetColorMap( @{i}entries@{ui} )
   d0                d0
  @{i}entries@{ui} - number of entries for this colormap
  @{i}@{b}cm@{ub}@{ui} - the pointer value returned by this routine, if nonzero,
    may be stored into the ViewPort.ColorMap pointer.
    If a value of 0 is returned, the system was unable to allocate
    enough memory space for the required data structures.
SEE ALSO
  @{"SetRGB4()" Link "SetRGB4()"} @{"FreeColorMap()" Link "FreeColorMap()"}
@EndNode                      
@Node "GetDisplayInfoData()" "graphics.library/GetDisplayInfoData"
@{b}@{u}GetDisplayInfoData@{uu}@{ub} -- query @{"DisplayInfo" Link "include:graphics/displayinfo.h/Main" 49} Record parameters.@{FG fill}(V36)@{FG text}
  GetDisplayInfoData() fills a buffer with data meaningful to the
  DisplayInfoRecord pointed at by your valid handle.The data type
  that you are interested in is indicated by a tagID for that chunk.
SYNOPSIS
  ULONG GetDisplayInfoData(DisplayInfoHandle, UBYTE *, ULONG, ULONG, ULONG);
  @{i}@{b}result@{ub}@{ui} = GetDisplayInfoData(@{i}handle@{ui}, @{i}buf@{ui}, @{i}size@{ui}, @{i}tagID@{ui}, [@{i}ID@{ui}])
   D0                          A0      A1    D0    D1     [D2]
  @{i}handle@{ui} - displayinfo handle
  @{i}buf@{ui}    - pointer to destination buffer
  @{i}size@{ui}   - buffer size in bytes
  @{i}tagID@{ui}  - data chunk type
    DTAG_DISP: (DisplayInfo) - properties and availability information
    DTAG_DIMS: (DimensionInfo) - default dimensions and overscan info
    DTAG_MNTR: (MonitorInfo) - type, position, scanrate, and compatibility
    DTAG_NAME: (NameInfo) - a user friendly way to refer to this mode
  @{i}ID@{ui}     - displayinfo identifier, optionally used if handle is NULL
  @{i}@{b}result@{ub}@{ui} - if positive, number of bytes actually transferred,
    if zero, no information for ID was available
SEE ALSO
  @{"FindDisplayInfo()" Link "FindDisplayInfo()"}, @{"NextDisplayInfo()" Link "NextDisplayInfo()"}
  @{"graphics/displayinfo.h" Link "include:graphics/displayinfo.h/Main" 0}
@EndNode
@Node "GetDrMd()" "graphics.library/GetDrMd"
@{b}@{u}GetDrMd@{uu}@{ub} -- Get the draw mode value for a RastPort.@{FG fill}(V39)@{FG text}
  Return the current value of the draw mode for the rastport.This function
  should be used instead of peeking the structure directly, because future
  graphics devices may store it differently.
SYNOPSIS  ULONG GetDrMd(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *)
  @{i}@{b}mode@{ub}@{ui} = GetDrMd( @{i}rp@{ui} )
   d0              a0
  @{i}rp@{ui} = a pointer to a valid RastPort structure.
SEE ALSO
  @{"SetDrMd()" Link "SetDrMd()"} @{"graphics/gfx.h" Link "include:graphics/gfx.h/Main" 0}
@EndNode
@Node "GetExtSpriteA()" "graphics.library/GetExtSpriteA"
@{b}@{u}GetExtSpriteA@{uu}@{ub} -- Attempt to get a sprite for the extended sprite manager.@{FG fill}(V39)@{FG text}
@{b}@{u}GetExtSprite@{uu}@{ub}  -- varargs stub for GetExtSpriteA.@{FG fill}(V39)@{FG text}
  Attempt to allocate one of the eight sprites for private use
  with the extended sprite manager.
SYNOPSIS  @{FG shine}long@{FG text} GetExtSpriteA( @{FG shine}struct@{FG text} ExtSprite *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} * );
  @{i}@{b}Sprite_Number@{ub}@{ui} = GetExtSpriteA( @{i}sprite@{ui}, @{i}tags@{ui} )  @{FG fill}(V39)@{FG text}
   d0                             a2       a1
  @{i}@{b}spritenum@{ub}@{ui} = GetExtSprite (@{i}sprite@{ui},@{i}tags@{ui},...);
  @{i}sprite@{ui} - ptr to programmer's ExtSprite (from AllocSpriteData()).
  @{i}tags@{ui} - a standard tag list:
    GSTAG_SPRITE_NUM - specifies a specific sprite to get by number.
    GSTAG_ATTACHED - specifies that you wish to get a sprite pair.
      The tag data field points to a ExtSprite structure for the second sprite.
      You must free both sprites.
  @{i}@{b}Sprite_number@{ub}@{ui} = a sprite number or -1 for an error.
    This call will fail if no sprites could be allocated, or if you try to
    allocate a sprite which would require a mode change when there are other
    sprites of incompatible modes in use.
NOTE
  GSTAG_ATTACHED does not work in version 39.When running under V39,
  you should attach the second sprite with a separate GetExtSprite call.
SEE ALSO
  @{"FreeSprite()" Link "FreeSprite()"} @{"ChangeSprite()" Link "ChangeSprite()"} @{"MoveSprite()" Link "MoveSprite()"} @{"GetSprite()" Link "GetSprite()"} @{"graphics/sprite.h" Link "include:graphics/sprite.h/Main" 0}
@EndNode
@Node "GetGBuffers()" "graphics.library/GetGBuffers"
@{b}@{u}GetGBuffers@{uu}@{ub} -- Attempt to allocate ALL buffers of an entire AnimOb.
  For each sequence of each component of the AnimOb, allocate memory for:
    SaveBuffer
    BorderLine
    CollMask and ImageShadow (point to same buffer)
    if db is set TRUE (user wants double-buffering) allocate:
      @{"DBufPacket" Link "include:graphics/gels.h/Main" 233}
      BufBuffer
SYNOPSIS  BOOL GetGBuffers(@{FG shine}struct@{FG text} @{"AnimOb" Link "include:graphics/gels.h/Main" 203} *, @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, BOOL);
  @{i}@{b}status@{ub}@{ui} = GetGBuffers(@{i}anOb@{ui}, @{i}rp@{ui}, @{i}db@{ui})
   D0                   A0    A1   D0
  @{i}anOb@{ui} = pointer to the AnimOb structure
  @{i}rp@{ui} = pointer to the current RastPort
  @{i}db@{ui} = double-buffer indicator (set TRUE for double-buffering)
  @{i}@{b}status@{ub}@{ui} = TRUE if the memory allocations were all successful, else FALSE
BUGS
  If any of the memory allocations fail it does not free the partial
  allocations that did succeed.
SEE ALSO
  @{"FreeGBuffers()" Link "FreeGBuffers()"} @{"graphics/gels.h" Link "include:graphics/gels.h/Main" 0}
@EndNode
@Node "GetOPen()" "graphics.library/GetOPen"
@{b}@{u}GetOPen@{uu}@{ub} -- Get the O Pen value for a RastPort.@{FG fill}(V39)@{FG text}
  Return the current value of the O pen for the rastport.This function
  should be used instead of peeking the structure directly, because future
  graphics devices may store it differently, for instance, using more bits.
SYNOPSIS  ULONG GetOPen(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *)
  @{i}@{b}pen@{ub}@{ui} = GetOPen( @{i}rp@{ui} )
   d0             a0
  @{i}rp@{ui}  =  a pointer to a valid RastPort structure.
SEE ALSO
  @{"SetOutlinePen()" Link "SetOutlinePen()"} @{"graphics/gfx.h" Link "include:graphics/gfx.h/Main" 0}
@EndNode
@Node "GetRGB32()" "graphics.library/GetRGB32"
@{b}@{u}GetRGB32@{uu}@{ub} -- Set a series of color registers for this Viewport.@{FG fill}(V39)@{FG text}
SYNOPSIS  @{FG shine}void@{FG text} GetRGB32( @{FG shine}struct@{FG text} @{"ColorMap" Link "include:graphics/view.h/Main" 143} *, ULONG, ULONG, ULONG *);
  GetRGB32( @{i}cm@{ui},  @{i}firstcolor@{ui}, @{i}ncolors@{ui}, @{i}table@{ui} )
             a0   d0          d1        a1
  @{i}cm@{ui} = colormap
  @{i}firstcolor@{ui} = the first color register to get
  @{i}ncolors@{ui} = the number of color registers to set.
  @{i}table@{ui}=a pointer to a series of 32-bit RGB triplets.
  The ULONG data pointed to by 'table' will be filled with the 32 bit fractional
    RGB values from the colormap.
NOTES
  'Table' should point to at least ncolors*3 longwords.
SEE ALSO
  @{"LoadRGB4()" Link "LoadRGB4()"} @{"GetColorMap()" Link "GetColorMap()"} @{"LoadRGB32()" Link "LoadRGB32()"} @{"SetRGB32CM()" Link "SetRGB32CM()"} @{"graphics/view.h" Link "include:graphics/view.h/Main" 0}
@EndNode
@Node "GetRGB4()" "graphics.library/GetRGB4"
@{b}@{u}GetRGB4@{uu}@{ub} -- Inquire value of entry in ColorMap.
  Read and format a value from the ColorMap.
SYNOPSIS  ULONG GetRGB4(@{FG shine}struct@{FG text} @{"ColorMap" Link "include:graphics/view.h/Main" 143} *, @{FG shine}long@{FG text});
  @{i}@{b}value@{ub}@{ui} = GetRGB4( @{i}colormap@{ui}, @{i}entry@{ui} )
   d0               a0         d0
  @{i}colormap@{ui} - pointer to ColorMap structure
  @{i}entry@{ui} - index into colormap
  returns -1 if no valid entry,
    return UWORD RGB value 4 bits per gun right justified
NOTE
  Intuition's @{"DisplayBeep()" Link "intuition.guide/DisplayBeep()"} changes color 0.Reading Color 0 during a
  @{"DisplayBeep()" Link "intuition.guide/DisplayBeep()"} will lead to incorrect results.
SEE ALSO
  @{"SetRGB4()" Link "SetRGB4()"} @{"LoadRGB4()" Link "LoadRGB4()"} @{"GetColorMap()" Link "GetColorMap()"} @{"FreeColorMap()" Link "FreeColorMap()"} @{"graphics/view.h" Link "include:graphics/view.h/Main" 0}
@EndNode
@Node "GetRPAttrA()" "graphics.library/GetRPAttrA"
@{b}@{u}GetRPAttrA@{uu}@{ub} -- examine rastport settings via a tag list.
@{b}@{u}GetRPAttrs@{uu}@{ub} -- varargs stub for GetRPAttrA.
  Read the settings of a rastport into variables.The ti_Tag field of the
  TagItem specifies which attribute should be read, and the ti_Data field
  points at the location where the result hsould be stored.
  All current tags store the return data as LONGs (32 bits).
SYNOPSIS  @{FG shine}void@{FG text} GetRPAttrA(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  GetRPAttrA(@{i}rp@{ui},@{i}tags@{ui})
              a0 a1
  GetRPAttrs(@{i}rp@{ui},@{i}attr1@{ui},@{i}&result1@{ui},...);
  @{i}rp@{ui} - pointer to the RastPort to examine.
  @{"tags" link GETRPATTRA_TAGS} - a standard tag list specifying the attributes to be read,
    and where to store their values.
SEE ALSO
  @{"GetAPen()" Link "GetAPen()"} @{"GetBPen()" Link "GetBPen()"} @{"GetDrMd()" Link "GetDrMd()"} GetOutLinePen()
  GetWriteMask() @{"SetRPAttrA()" Link "SetRPAttrA()"} graphics/rpattr.h
@EndNode
@node GETRPATTRA_TAGS "GetRPAttrA_tags"
@{i}RPTAG_DrawBounds@{ui} - Determine the area that will be rendered into by rendering
  commands.Can be used to optimize window refresh.
  Pass a pointer to a rectangle in the tag data.On return, the rectangle's
  MinX will be greater than its MaxX if there are no active cliprects.
@{i}RPTAG_WriteMask@{ui} - Bit Mask for writing.
@{i}RPTAG_Font@{ui} - Font for @{"Text()" Link "Text()"}
@{i}RPTAG_SoftStyle@{ui} - style for text (see @{"graphics/text.h)" Link "include:graphics/text.h/Main" 0}
@{i}RPTAG_DrMd@{ui} - Drawing mode (see @{"graphics/rastport.h)" Link "include:graphics/rastport.h/Main" 0}
@{i}RPTAG_APen@{ui} - Primary rendering pen
@{i}RPTAG_BPen@{ui} - Secondary rendering pen
@{i}RPTAG_OutLinePen@{ui} - Area Outline pen
@{i}RPTAG_MaxPen@{ui} - Maximum pen to render (see @{"SetMaxPen()" Link "SetMaxPen()"})
@endnode
@Node "GetSprite()" "graphics.library/GetSprite"
@{b}@{u}GetSprite@{uu}@{ub} -- Attempt to get a sprite for the simple sprite manager.
  Attempt to allocate one of the eight sprites for private use
  with the simple sprite manager.This must be done before using
  further calls to the simple sprite machine.If the programmer
  wants to use 15 color sprites, they must allocate both sprites
  and set the 'SPRITE_ATTACHED' bit in the odd sprite's posctldata array.
SYNOPSIS  WORD GetSprite( @{FG shine}struct@{FG text} @{"SimpleSprite" Link "include:graphics/sprite.h/Main" 19} *, WORD );
  @{i}@{b}Sprite_Number@{ub}@{ui} = GetSprite( @{i}sprite@{ui}, @{i}pick@{ui} )
   d0                         a0      d0
  @{i}sprite@{ui} - ptr to programmers SimpleWrite structure.
  @{i}pick@{ui} - number in the range of 0-7 or
    -1 if programmer just wants the next one.
    If pick is 0-7 attempt to allocate the sprite.
      If the sprite is already allocated then return -1.
    If pick is -1 allocate the next sprite starting the search at 0.
      If no sprites are available return -1 and fill -1 in num entry
        of SimpleWrite structure.
      If the sprite is available for allocation, mark it allocated
      and fill in the 'num' entry of the SimpleWrite structure.
  If successful return the sprite number.
SEE ALSO
  @{"FreeSprite()" Link "FreeSprite()"} @{"ChangeSprite()" Link "ChangeSprite()"} @{"MoveSprite()" Link "MoveSprite()"} GetSprite() @{"graphics/sprite.h" Link "include:graphics/sprite.h/Main" 0}
@EndNode
@Node "GetVPModeID()" "graphics.library/GetVPModeID"
@{b}@{u}GetVPModeID@{uu}@{ub} - get the 32 bit DisplayID from a ViewPort.@{FG fill}(V36)@{FG text}
  Returns the normal display modeID, if one is currently  associated
  with this ViewPort.
SYNOPSIS  ULONG GetVPModeID( @{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *);
  @{i}@{b}modeID@{ub}@{ui} =  GetVPModeID( @{i}vp@{ui} )
   d0                     a0
  @{i}vp@{ui} - pointer to a ViewPort structure.
  @{i}@{b}modeID@{ub}@{ui} - a 32 bit DisplayInfoRecord identifier associated with this ViewPort,
    or INVALID_ID.
NOTES
  Test the return value of this function against INVALID_ID, not NULL.
  (INVALID_ID is defined in @{"graphics/displayinfo.h)" Link "include:graphics/displayinfo.h/Main" 0}.
SEE ALSO
  @{"graphics/displayinfo.h" Link "include:graphics/displayinfo.h/Main" 0}, @{"ModeNotAvailable()" Link "ModeNotAvailable()"}
@EndNode
@Node "GfxAssociate()" "graphics.library/GfxAssociate"
@{b}@{u}GfxAssociate@{uu}@{ub} -- associate a graphics extended node with a given pointer.@{FG fill}(V36)@{FG text}
  Associate a special graphics extended data structure (each of which
  begins with an ExtendedNode structure)  with another structure via
  the other structure's pointer.Later, when you call GfxLookUp()
  with the other structure's pointer you may retrieve a pointer
  to this special graphics extended data structure, if it is available.
SYNOPSIS  @{FG shine}void@{FG text} GfxAssociate(@{FG shine}void@{FG text} *, @{FG shine}struct@{FG text} @{"ExtendedNode" Link "include:graphics/gfxnodes.h/Main" 18} *);
  GfxAssociate(@{i}pointer@{ui}, @{i}node@{ui});
                A0       A1
  @{i}pointer@{ui} = a pointer to a data structure.
  @{i}node@{ui} = an ExtendedNode structure to associate with the pointer
  An association is created between the pointer and the node such
  that given the pointer the node can be retrieved via GfxLookUp().
SEE ALSO
  @{"graphics/gfxnodes.h" Link "include:graphics/gfxnodes.h/Main" 0} @{"GfxNew()" Link "GfxNew()"} @{"GfxFree()" Link "GfxFree()"} GfxLookUp()
@EndNode
@Node "GfxFree()" "graphics.library/GfxFree"
@{b}@{u}GfxFree@{uu}@{ub} -- free a graphics extended data structure.@{FG fill}(V36)@{FG text}
  Free a special graphics extended data structure
  (each of which begins with an ExtendedNode structure).
SYNOPSIS  @{FG shine}void@{FG text} GfxFree(@{FG shine}struct@{FG text} @{"ExtendedNode" Link "include:graphics/gfxnodes.h/Main" 18} *);
  GfxFree( @{i}node@{ui} );
            a0
  @{i}node@{ui} = pointer to a graphics extended data structure obtained via @{"GfxNew()" Link "GfxNew()"}.
  The node is deallocated from memory.Graphics will disassociate
  this special graphics extended node from any associated data
  structures, if necessary, before freeing it (see @{"GfxAssociate()" Link "GfxAssociate()"}).
BUGS
  An @{"Alert()" Link "exec.guide/Alert()"} will be called if you attempt to free any structure
  other than a graphics extended data structure obtained via GfxFree().
SEE ALSO
  @{"graphics/gfxnodes.h" Link "include:graphics/gfxnodes.h/Main" 0} @{"GfxNew()" Link "GfxNew()"} @{"GfxAssociate()" Link "GfxAssociate()"} GfxLookUp()
@EndNode
@Node "GfxLookUP()" "graphics.library/GfxLookUP"
@{b}@{u}GfxLookUp@{uu}@{ub} -- find a graphics extended node associated with a given pointer.@{FG fill}(V36)@{FG text}
  Finds a special graphics extended data structure (if any) associated
  with the pointer to a data structure (eg: @{"ViewExtra" Link "include:graphics/view.h/Main" 69} associated with
  a @{"View" Link "include:graphics/view.h/Main" 57} structure).
SYNOPSIS  @{FG shine}struct@{FG text} @{"ExtendedNode" Link "include:graphics/gfxnodes.h/Main" 18} *GfxLookUp( @{FG shine}void@{FG text} *);
  @{i}@{b}result@{ub}@{ui} = GfxLookUp( @{i}pointer@{ui} );
   d0                  a0
  @{i}pointer@{ui} = a pointer to a data structure which may have an
    ExtendedNode associated with it (typically a View ).
  @{i}@{b}result@{ub}@{ui} = a pointer to the ExtendedNode that has previously been
    associated with the pointer.
SEE ALSO
  @{"graphics/gfxnodes.h" Link "include:graphics/gfxnodes.h/Main" 0} @{"GfxNew()" Link "GfxNew()"} @{"GfxFree()" Link "GfxFree()"} @{"GfxAssociate()" Link "GfxAssociate()"}
@EndNode
@Node "GfxNew()" "graphics.library/GfxNew"
@{b}@{u}GfxNew@{uu}@{ub} -- allocate a graphics extended data structure.@{FG fill}(V36)@{FG text}
  Allocate a special graphics extended data structure (each of which
  begins with an ExtendedNode structure).The type of structure to
  be allocated is specified by the node_type identifier.
SYNOPSIS  @{FG shine}struct@{FG text} @{"ExtendedNode" Link "include:graphics/gfxnodes.h/Main" 18} *GfxNew( ULONG);
  @{i}@{b}result@{ub}@{ui} = GfxNew( @{i}node_type@{ui} );
   d0               d0
  @{i}node_type@{ui} = which type of graphics extended data structure to allocate.
    (see gfxnodes.h for identifier definitions.)
  @{i}@{b}result@{ub}@{ui} = a pointer to the allocated graphics node
    or NULL if the allocation failed.
SEE ALSO
  @{"graphics/gfxnodes.h" Link "include:graphics/gfxnodes.h/Main" 0} @{"GfxFree()" Link "GfxFree()"} @{"GfxAssociate()" Link "GfxAssociate()"} GfxLookUp()
@EndNode
@Node "InitArea()" "graphics.library/InitArea"
@{b}@{u}InitArea@{uu}@{ub} -- Initialize vector collection matrix.
  This function provides initialization for the vector collection matrix
  such that it has a size of (max vectors ).The size of the region
  pointed to by buffer (short pointer) should be five (5) times as large
  as maxvectors.This size is in bytes.Areafills done by using @{"AreaMove" Link "AreaMove()"},
  @{"AreaDraw" Link "AreaDraw()"}, and @{"AreaEnd" Link "AreaEnd()"} must have enough space allocated in this table to
  store all the points of the largest fill.@{"AreaEllipse" Link "AreaEllipse()"} takes up two
  vectors for every call.If AreaMove/Draw/Ellipse detect too many
  vectors going into the buffer they will return -1.
SYNOPSIS  @{FG shine}void@{FG text} InitArea(@{FG shine}struct@{FG text} @{"AreaInfo" Link "include:graphics/rastport.h/Main" 21} *, @{FG shine}void@{FG text} *, SHORT);
  InitArea( @{i}areainfo@{ui}, @{i}buffer@{ui}, @{i}maxvectors@{ui} )
             a0        a1      d0
  @{i}areainfo@{ui} - pointer to AreaInfo structure
  @{i}buffer@{ui} - pointer to chunk of memory to collect vertices
  @{i}maxvectors@{ui} - max number of vectors this buffer can hold
  Pointers are set up to begin storage of vectors done by
  @{"AreaMove" Link "AreaMove()"}, @{"AreaDraw" Link "AreaDraw()"}, and @{"AreaEllipse" Link "AreaEllipse()"}.
SEE ALSO
  @{"AreaEnd()" Link "AreaEnd()"} @{"AreaMove()" Link "AreaMove()"} @{"AreaDraw()" Link "AreaDraw()"} @{"AreaEllipse()" Link "AreaEllipse()"} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "InitBitMap()" "graphics.library/InitBitMap"
@{b}@{u}InitBitMap@{uu}@{ub} -- Initialize bit map structure with input values.
  Initialize various elements in the BitMap structure to
  correctly reflect depth, width, and height.
  Must be used before use of BitMap in other graphics calls.
  The Planes[8] are not initialized and need to be set up
  by the caller.The Planes table was put at the end of the
  structure so that it may be truncated to conserve space,
  as well as extended.All routines that use BitMap should
  only depend on existence of depth number of bitplanes.
  The Flagsh and pad fields are reserved for future use and
  should not be used by application programs.
SYNOPSIS  @{FG shine}void@{FG text} InitBitMap( @{FG shine}struct@{FG text} @{"BitMap" Link "include:graphics/gfx.h/Main" 46} *, BYTE, UWORD, UWORD );
  InitBitMap( @{i}bm@{ui}, @{i}depth@{ui}, @{i}width@{ui}, @{i}height@{ui} )
               a0  d0     d1      d2
  @{i}bm@{ui} - pointer to a BitMap structure (gfx.h)
  @{i}depth@{ui} - number of bitplanes that this bitmap will have
  @{i}width@{ui} - number of bits (columns) wide for this BitMap
  @{i}height@{ui}- number of bits (rows) tall for this BitMap
SEE ALSO
  @{"graphics/gfx.h" Link "include:graphics/gfx.h/Main" 0}
@EndNode
@Node "InitGels()" "graphics.library/InitGels"
@{b}@{u}InitGels@{uu}@{ub} -- initialize a gel list; must be called before using gels.
  Assigns the VSprites as the head and tail of the gel list in @{"GfxBase" Link "include:graphics/gfxbase.h/Main" 24}.
  Links these two gels together as the keystones of the list.
  If the collHandler vector points to some memory array, sets
  the BORDERHIT vector to NULL.
SYNOPSIS  @{FG shine}void@{FG text} InitGels(@{FG shine}struct@{FG text} @{"VSprite" Link "include:graphics/gels.h/Main" 72} *, @{FG shine}struct@{FG text} VSprite *, @{FG shine}struct@{FG text} @{"GelsInfo" Link "include:graphics/rastport.h/Main" 39} *);
  InitGels(@{i}head@{ui}, @{i}tail@{ui}, @{i}GInfo@{ui})
            A0    A1     A2
  @{i}head@{ui}  = pointer to the VSprite structure to be used as the gel list head
  @{i}tail@{ui}  = pointer to the VSprite structure to be used as the gel list tail
  @{i}GInfo@{ui} = pointer to the GelsInfo structure to be initialized
SEE ALSO
  @{"graphics/gels.h" Link "include:graphics/gels.h/Main" 0}  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "InitGMasks()" "graphics.library/InitGMasks"
@{b}@{u}InitGMasks@{uu}@{ub} -- Initialize all of the masks of an AnimOb.
  For every sequence of every component call @{"InitMasks" Link "InitMasks()"}.
SYNOPSIS  @{FG shine}void@{FG text} InitGMasks(@{FG shine}struct@{FG text} @{"AnimOb" Link "include:graphics/gels.h/Main" 203} *);
  InitGMasks(@{i}anOb@{ui})
              A0
  @{i}anOb@{ui} = pointer to the AnimOb
SEE ALSO
  @{"InitMasks()" Link "InitMasks()"} @{"graphics/gels.h" Link "include:graphics/gels.h/Main" 0}
@EndNode
@Node "InitMasks()" "graphics.library/InitMasks"
@{b}@{u}InitMasks@{uu}@{ub} -- Initialize the BorderLine and CollMask masks of a VSprite.
  Creates the appropriate BorderLine and CollMask masks of the VSprite.
  Correctly detects if the VSprite is actually a @{"Bob" Link "include:graphics/gels.h/Main" 139} definition, handles
  the image data accordingly.
SYNOPSIS  @{FG shine}void@{FG text} InitMasks(@{FG shine}struct@{FG text} @{"VSprite" Link "include:graphics/gels.h/Main" 72} *);
  InitMasks(@{i}vs@{ui})
             A0
  @{i}vs@{ui} = pointer to the VSprite structure
SEE ALSO
  @{"InitGels()" Link "InitGels()"}  @{"graphics/gels.h" Link "include:graphics/gels.h/Main" 0}
@EndNode
@Node "InitRastPort()" "graphics.library/InitRastPort"
@{b}@{u}InitRastPort@{uu}@{ub} -- Initialize raster port structure.
  Initialize a RastPort structure to standard values.
SYNOPSIS  @{FG shine}void@{FG text} InitRastPort(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *rp);
  InitRastPort( @{i}rp@{ui} )
                 a1
  @{i}rp@{ui}  = pointer to a RastPort structure.
  All entries in RastPort get zeroed out, with the following exceptions:
  - Mask, FgPen, AOLPen, and LinePtrn are set to -1.
  - The DrawMode is set to JAM2.
  - The font is set to the standard system font.
NOTES
  The @{FG shine}struct@{FG text} Rastport describes a control structure for a write-able raster.
  The RastPort structure describes how a complete single playfield display
  will be written into.A RastPort structure is referenced whenever any drawing
  or filling operations are to be performed on a section of memory.
  The section of memory which is being used in this way may or may not be
  presently a part of the current actual onscreen display memory.The name
  of the actual memory section which is linked to the RastPort is referred
  to here as a "raster" or as a bitmap.
  Calling the routine InitRastPort only establishes various defaults.It does NOT
  establish where, in memory, the rasters are located.To do graphics with this
  RastPort the user must set up the BitMap pointer in the RastPort.
SEE ALSO
graphics/rastport.h
@EndNode
@Node "InitTmpRas()" "graphics.library/InitTmpRas"
@{b}@{u}InitTmpRas@{uu}@{ub} -- Initialize area of local memory for usage by areafill, floodfill,
  text.
  The area of memory pointed to by buffer is set up to be used
  by @{"RastPort" Link "include:graphics/rastport.h/Main" 54} routines that may need to get some memory for
  intermediate operations in preparation to putting the graphics
  into the final @{"BitMap" Link "include:graphics/gfx.h/Main" 46}.
  Tmpras is used to control the usage of buffer.
SYNOPSIS  @{FG shine}void@{FG text} InitTmpRas( @{FG shine}struct@{FG text} @{"TmpRas" Link "include:graphics/rastport.h/Main" 32} *, @{FG shine}void@{FG text} *, ULONG );
  InitTmpRas(@{i}tmpras@{ui}, @{i}buffer@{ui}, @{i}size@{ui})
              a0      a1      d0
  @{i}tmpras@{ui} - pointer to a TmpRas structure to be linked into a RastPort
  @{i}buffer@{ui} - pointer to a contiguous piece of chip memory.
  @{i}size@{ui} - size in bytes of buffer
  Makes buffer available for users of RastPort
BUGS
  Would be nice if RastPorts could share one TmpRas.
SEE ALSO
  @{"AreaEnd()" Link "AreaEnd()"} @{"Flood()" Link "Flood()"} @{"Text()" Link "Text()"} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "InitView()" "graphics.library/InitView"
@{b}@{u}InitView@{uu}@{ub}@{b}@{u}@{uu}@{ub} - Initialize View structure.
  Initialize View structure to default values.
SYNOPSIS  @{FG shine}void@{FG text} InitView( @{FG shine}struct@{FG text} @{"View" Link "include:graphics/view.h/Main" 57} * );
  InitView( @{i}view@{ui} )
             a1
  @{i}view@{ui} - pointer to a View structure
  View structure set to all 0's.(1.0,1.1.1.2)
    Then values are put in DxOffset,DyOffset to properly position
    default display about .5 inches from top and left on monitor.
    InitView pays no attention to previous contents of view.
SEE ALSO
  @{"MakeVPort" Link "MakeVPort()"} @{"graphics/view.h" Link "include:graphics/view.h/Main" 0}
@EndNode
@Node "InitVPort()" "graphics.library/InitVPort"
@{b}@{u}InitVPort@{uu}@{ub} - Initialize ViewPort structure.
  Initialize ViewPort structure to default values.
SYNOPSIS  @{FG shine}void@{FG text} InitViewPort( @{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} * );
  InitVPort( @{i}vp@{ui} )
              a0
  @{i}vp@{ui} - pointer to a ViewPort structure
  ViewPort structure set to all 0's.(1.0,1.1)
    New field added SpritePriorities, initialized to 0x24 (1.2)
SEE ALSO
  @{"MakeVPort()" Link "MakeVPort()"} @{"graphics/view.h" Link "include:graphics/view.h/Main" 0}
@EndNode
@Node "LoadRGB32()" "graphics.library/LoadRGB32"
@{b}@{u}LoadRGB32@{uu}@{ub} -- Set a series of color registers for this Viewport.@{FG fill}(V39)@{FG text}
  LoadRGB32 is faster than SetRGB32, even for one color.
SYNOPSIS  @{FG shine}void@{FG text} LoadRGB32( @{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *, ULONG *);
  LoadRGB32( v@{i}@{ui}p,  @{i}table@{ui} )
              a0   a1
  @{i}vp@{ui} = viewport
  @{i}table@{ui} = a pointer to a series of records which describe which colors to modify.
    Passing a NULL "table" is ignored.The format of the table passed to
    this function is a series of records, each with the following format:
    - 1 Word with the number of colors to load
    - 1 Word with the first color to be loaded.
    - 3 longwords representing a left justified 32 bit rgb triplet.
    - The list is terminated by a count value of 0.
  The selected color registers are changed to match your specs.
EXAMPLES
  ULONG table[]={1l<<16+0,0xffffffff,0,0,0} loads color register 0 with 100% red.
  ULONG table[]={256l<<16+0,r1,g1,b1,r2,g2,b2,.....0} can be used to load an
  entire 256 color palette.
  Lower order bits of the palette specification will be discarded, depending on
  the color palette resolution of the target graphics device.Use 0xffffffff for
  the full value, 0x7fffffff for 50%, etc.You can find out the palette range for
  your screen by querying the graphics data base.
SEE ALSO
  @{"LoadRGB4()" Link "LoadRGB4()"} @{"GetColorMap()" Link "GetColorMap()"} @{"GetRGB32()" Link "GetRGB32()"} @{"SetRGB32CM()" Link "SetRGB32CM()"} @{"graphics/view.h" Link "include:graphics/view.h/Main" 0}
@EndNode
@Node "LoadRGB4()" "graphics.library/LoadRGB4"
@{b}@{u}LoadRGB4@{uu}@{ub} -- Load RGB color values from table.
  Load the count words of the colormap from table starting at entry 0.
SYNOPSIS  @{FG shine}void@{FG text} LoadRGB4( @{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *, UWORD *, WORD);
  LoadRGB4( @{i}vp@{ui}, @{i}colors@{ui} , @{i}count@{ui} )
             a0  a1        d0:16
  @{i}vp@{ui} - pointer to ViewPort, whose colors you wish to change
  @{i}colors@{ui} - pointer to table of RGB values set up as an array of USHORTS
    background--  0x0RGB
    color1    --  0x0RGB
    color2    --  0x0RGB
    etc.UWORD per value.
    The colors are interpreted as 15 = maximum intensity, 0 = minimum intensity.
  @{i}count@{ui} = number of UWORDs in the table to load into the colormap starting at
    color 0(background) and proceeding to the next higher color number.
  The ViewPort should have a pointer to a valid ColorMap to store the colors in.
  Updates the hardware copperlist to reflect the new colors.
  Updates the intermediate copperlist with the new colors.
NOTE
  Under V36 and up, it is not safe to call this function from an interrupt,
  due to semaphore protection of graphics copper lists.
SEE ALSO
  @{"SetRGB4()" Link "SetRGB4()"} @{"GetRGB4()" Link "GetRGB4()"} @{"GetColorMap()" Link "GetColorMap()"} @{"graphics/view.h" Link "include:graphics/view.h/Main" 0}
@EndNode
@Node "LoadView()" "graphics.library/LoadView"
@{b}@{u}LoadView@{uu}@{ub} -- Use a (possibly freshly created) coprocessor instruction list to
  create the current display.
  Install a new view to be displayed during the next display refresh pass.
  Coprocessor instruction list has been created by @{"InitVPort()" Link "InitVPort()"}, @{"MakeVPort()" Link "MakeVPort()"},
  and @{"MrgCop()" Link "MrgCop()"}.
SYNOPSIS  @{FG shine}void@{FG text} LoadView( @{FG shine}struct@{FG text} @{"View" Link "include:graphics/view.h/Main" 57} * );
  LoadView( @{i}View@{ui} )
             A1
  @{i}View@{ui} - a pointer to the View structure which contains the
    pointer to the constructed coprocessor instructions list, or NULL.
  If the View pointer is non-NULL, the new View is displayed, according to your
  instructions.The vertical blank routine will pick this pointer up and direct
  the copper to start displaying this View.
  If the View pointer is NULL, no View is displayed.
NOTE
  Even though a LoadView(NULL) is performed, display DMA will still be 
  active.Sprites will continue to be displayed after a LoadView(NULL)
  unless an OFF_SPRITE is subsequently performed.
SEE ALSO
  @{"InitVPort()" Link "InitVPort()"} @{"MakeVPort()" Link "MakeVPort()"} @{"MrgCop()" Link "MrgCop()"} @{"intuition/RethinkDisplay()" Link "intuition.guide/RethinkDisplay()"}
  @{"graphics/view.h" Link "include:graphics/view.h/Main" 0}
@EndNode
@Node "LockLayerRom()" "graphics.library/LockLayerRom"
@{b}@{u}LockLayerRom@{uu}@{ub} -- Lock Layer structure by ROM(gfx lib) code.
  Return when the layer is locked and no other task may
  alter the @{"ClipRect" Link "include:graphics/clip.h/Main" 63} structure in the Layer structure.
  This call does not destroy any registers.
  This call nests so that callers in this chain will not lock themselves out.
  Do not have the Layer locked during a call to intuition.
  There is a potential deadlock problem here, if intuition
  needs to get other locks as well.
  Having the layer locked prevents other tasks from using the
  layer library functions, most notably intuition itself.So be brief.
  layers.library's @{"LockLayer" Link "ROMlibs.guide/LockLayer()"} is identical to LockLayerRom.
SYNOPSIS  @{FG shine}void@{FG text} LockLayerRom( @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} * );
  LockLayerRom( @{i}layer@{ui} )
                 a5
  @{i}layer@{ui} - pointer to Layer structure
  The layer is locked and the task can render assuming the ClipRects will
  not change out from underneath it until an @{"UnlockLayerRom" Link "UnlockLayerRom()"} is called.
SEE ALSO
  @{"UnlockLayerRom()" Link "UnlockLayerRom()"} @{"layers.library/LockLayer()" Link "ROMlibs.guide/LockLayer()"} @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0}
@EndNode
@Node "MakeVPort()" "graphics.library/MakeVPort"
@{b}@{u}MakeVPort@{uu}@{ub} -- generate display copper list for a viewport.
  Uses information in the View, ViewPort, ViewPort->RasInfo to
  construct and intermediate copper list for this ViewPort.
SYNOPSIS  ULONG MakeVPort( @{FG shine}struct@{FG text} @{"View" Link "include:graphics/view.h/Main" 57} *, @{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} * );
  @{i}@{b}error@{ub}@{ui} = MakeVPort( @{i}view@{ui}, @{i}viewport@{ui} )
   d0                 a0     a1
  @{i}view@{ui} - pointer to a View structure
  @{i}viewport@{ui} - pointer to a ViewPort structure
    The viewport must have valid pointer to a RasInfo.
  Constructs intermediate copper list and puts pointers in viewport.DspIns.
    If the @{"ColorMap" Link "include:graphics/view.h/Main" 143} ptr in ViewPort is NULL then it uses colors from the
    default color table.If DUALPF in Modes then there must be a second RasInfo
    pointed to by the first RasInfo.
    From V39, MakeVPort can return a ULONG error value (previous versions
    returned @{FG shine}void@{FG text}), to indicate that either not enough memory could be allocated
    for MakeVPort's use, or that the ViewPort mode and bitplane alignments are
    incorrect for the bitplane's depth.
    You should check for these error values - they are defined in
    @{"<graphics/view.h>" Link "include:graphics/view.h/Main" 0}.
BUGS
  In V37 and earlier, narrow Viewports (whose righthand edge is 
  less than 3/4 of the way across the display) do not work properly.
SEE ALSO
  @{"InitVPort()" Link "InitVPort()"} @{"MrgCop()" Link "MrgCop()"} @{"graphics/view.h" Link "include:graphics/view.h/Main" 0} @{"intuition.library/MakeScreen()" Link "intuition.guide/MakeScreen()"}
  @{"intuition.library/RemakeDisplay()" Link "intuition.guide/RemakeDisplay()"} @{"intuition.library/RethinkDisplay()" Link "intuition.guide/RethinkDisplay()"}
@EndNode
@Node "ModeNotAvailable()" "graphics.library/ModeNotAvailable"
@{b}@{u}ModeNotAvailable@{uu}@{ub} -- check to see if a DisplayID isn't available.@{FG fill}(V36)@{FG text}
  Returns an error code, indicating why this modeID is not available,
  or NULL if there is no reason known why this mode should not be there.
SYNOPSIS  ULONG ModeNotAvailable( ULONG);
  @{i}@{b}error@{ub}@{ui} =  ModeNotAvailable( @{i}modeID@{ui} )
   d0                         d0
  @{i}modeID@{ui} -- a 32 bit DisplayInfoRecord identifier.
  @{i}@{b}error@{ub}@{ui} -- a general indication of why this modeID is not available,
     or NULL if there is no reason why it shouldn't be available.
NOTE
  ULONG return values from this function are a proper superset of the
  DisplayInfo.NotAvailable field (defined in @{"graphics/displayinfo.h)" Link "include:graphics/displayinfo.h/Main" 0}.
SEE ALSO
  @{"graphics/displayinfo.h" Link "include:graphics/displayinfo.h/Main" 0}, @{"GetVPModeID()" Link "GetVPModeID()"}
@EndNode
@Node "Move()" "graphics.library/Move"
@{b}@{u}Move@{uu}@{ub} -- Move graphics pen position.
  Move graphics pen position to (x,y) relative to upper left (0,0)
  of RastPort.This sets the starting point for subsequent @{"Draw()" Link "Draw()"}
  and @{"Text()" Link "Text()"} calls.
SYNOPSIS  @{FG shine}void@{FG text} Move( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, SHORT, SHORT );
  Move( @{i}rp@{ui},   @{i}x@{ui},    @{i}y@{ui})
         a1    d0:16 d1:16
  @{i}rp@{ui} - pointer to a RastPort structure
  @{i}x@{ui},@{i}y@{ui} - point in the RastPort
SEE ALSO
  Draw @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "MoveSprite()" "graphics.library/MoveSprite"
@{b}@{u}MoveSprite@{uu}@{ub} -- Move sprite to a point relative to top of viewport.
  Move sprite image to new place on display.
SYNOPSIS  @{FG shine}void@{FG text} MoveSprite(@{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *,@{FG shine}struct@{FG text} @{"SimpleSprite" Link "include:graphics/sprite.h/Main" 19} *, WORD, WORD);
  MoveSprite(@{i}vp@{ui}, @{i}sprite@{ui}, @{i}x@{ui}, @{i}y@{ui})
              A0  A1      D0  D1
  @{i}vp@{ui} - pointer to ViewPort structure
    if vp = 0, sprite is positioned relative to @{"View" Link "include:graphics/view.h/Main" 57}.
  @{i}sprite@{ui} - pointer to SimpleWrite structure
  (@{i}x@{ui},@{i}y@{ui})  - new position relative to top of viewport or view.
  Calculate the hardware information for the sprite and place it in the
    posctldata array.During next video display
    the sprite will appear in new position.
BUGS
  Sprites really appear one pixel to the left of the position you specify.
  This bug affects the apparent display position of the sprite on the screen,
  but does not affect the numeric position relative to the viewport or view.
  This behaviour only applies to SimpleSprites, not to ExtSprites.
SEE ALSO
  @{"FreeSprite()" Link "FreeSprite()"}  @{"ChangeSprite()" Link "ChangeSprite()"}  @{"GetSprite()" Link "GetSprite()"}  @{"graphics/sprite.h" Link "include:graphics/sprite.h/Main" 0}
@EndNode
@Node "MrgCop()" "graphics.library/MrgCop"
@{b}@{u}MrgCop@{uu}@{ub} -- Merge together coprocessor instructions.
  Merge together the display, color, sprite and user coprocessor instructions
  into a single coprocessor instruction stream.This essentially creates a
  per-display-frame program for the coprocessor.
  This function MrgCop is used, for example, by the graphics animation routines
  which effectively add information into an essentially static background
  display.This changes some of the user or sprite instructions, but not those
  which have formed the basic display in the first place.When all forms of
  coprocessor instructions are merged together, you will have a complete
  per-frame instruction list for the coprocessor.
  @{b}Restrictions@{ub}: Each of the coprocessor instruction lists MUST be
  internally sorted in min to max Y-X order.The merge routines depend on this!
  Each list must be terminated using CEND(copperlist).
SYNOPSIS  ULONG MrgCop( @{FG shine}struct@{FG text} @{"View" Link "include:graphics/view.h/Main" 57} * );
  @{i}@{b}error@{ub}@{ui} = MrgCop( @{i}View@{ui} )
   d0              A1
  @{i}View@{ui} - a pointer to the view structure whose coprocessor instructions are to
    be merged.
  From V39, MrgCop() can return a ULONG error value (previous versions returned
    @{FG shine}void@{FG text}), to indicate that either there was insufficient memory to build the
    system copper lists, or that MrgCop() had no work to do if, for example,
    there were no ViewPorts in the list.
    You should check for these error values - they are defined in
    @{"<graphics/view.h>" Link "include:graphics/view.h/Main" 0}.
NOTES
  The view structure will now contain a complete, sorted/merged list of
  instructions for the coprocessor, ready to be used by the display processor.
  The display processor is told to use this new instruction stream through the
  instruction @{"LoadView()" Link "LoadView()"}.
SEE ALSO
  @{"InitVPort()" Link "InitVPort()"} @{"MakeVPort()" Link "MakeVPort()"} @{"LoadView()" Link "LoadView()"} @{"graphics/view.h" Link "include:graphics/view.h/Main" 0}
  @{"intuition.library/RethinkDisplay()" Link "intuition.guide/RethinkDisplay()"}
@EndNode
@Node "NewRegion()" "graphics.library/NewRegion"
@{b}@{u}NewRegion@{uu}@{ub} -- Get an empty region.
  Create a Region structure, initialize it to empty, and return a pointer to it.
SYNOPSIS  @{FG shine}struct@{FG text} @{"Region" Link "include:graphics/regions.h/Main" 28} *NewRegion();
  @{i}@{b}region@{ub}@{ui} = NewRegion()
   d0
  @{i}@{b}region@{ub}@{ui} - pointer to initialized region.
    If it could not allocate required memory region = NULL.
SEE ALSO
  @{"graphics/regions.h" Link "include:graphics/regions.h/Main" 0}
@EndNode
@Node "NextDisplayInfo()" "graphics.library/NextDisplayInfo"
@{b}@{u}NextDisplayInfo@{uu}@{ub} -- iterate current displayinfo identifiers.@{FG fill}(V36)@{FG text}
  The basic iteration function with which to find all records in the
  graphics database.Using each ID in succession, you can then call
  @{"FindDisplayInfo()" Link "FindDisplayInfo()"} to obtain the handle associated with each ID.
  Each ID is a 32-bit Key which uniquely identifies one record.
  The INVALID_ID is special, and indicates the end-of-list.
SYNOPSIS  ULONG NextDisplayInfo(ULONG);
  @{i}@{b}next_ID@{ub}@{ui} = NextDisplayInfo(@{i}last_ID@{ui})
   D0                        D0
  @{i}last_ID@{ui} - previous displayinfo identifier or INVALID_ID if beginning iteration
  @{i}@{b}next_ID@{ub}@{ui} - subsequent displayinfo identifier or INVALID_ID if no more records
SEE ALSO
  @{"FindDisplayInfo()" Link "FindDisplayInfo()"}, @{"GetDisplayInfoData()" Link "GetDisplayInfoData()"}
  @{"graphics/displayinfo.h" Link "include:graphics/displayinfo.h/Main" 0}
@EndNode
@Node "ObtainBestPenA()" "graphics.library/ObtainBestPenA"
@{b}@{u}ObtainBestPenA@{uu}@{ub} - Search for the closest color match,or allocate a new one.@{FG fill}(V39)@{FG text}
@{b}@{u}ObtainBestPen@{uu}@{ub}  - varargs stub for ObtainBestPenA.
  This function can be used by applications to figure out what pen to use to
  represent a given color.
  The system will attempt to find the color in your viewport closest to the
  specified color.If there is no color within your tolerance, then a new one
  will be allocated, if available.
  If none is available, then the closest one found will be returned.
SYNOPSIS
  @{FG shine}long@{FG text} ObtainBestPenA(@{FG shine}struct@{FG text} @{"ColorMap" Link "include:graphics/view.h/Main" 143} *,ULONG,ULONG,ULONG,@{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  @{i}@{b}color@{ub}@{ui} | @{i}@{b}-1@{ub}@{ui} =ObtainBestPenA( @{i}cm@{ui}, @{i}R@{ui}, @{i}G@{ui}, @{i}B@{ui}, @{i}taglist@{ui} )
                               a0   d1 d2 d3 a1
  @{i}@{b}color@{ub}@{ui} = ObtainBestPen(@{i}cm@{ui},@{i}r@{ui},@{i}g@{ui},@{i}b@{ui},@{i}tags@{ui}....);
  @{i}cm@{ui} = colormap
  @{i}R@{ui} = red level   (32 bit left justified fraction)
  @{i}G@{ui} = green level (32 bit left justified fraction)
  @{i}B@{ui} = blue level  (32 bit left justified fraction)
  @{i}taglist@{ui} = a pointer to a standard tag list specifying the color
    matching settings desired:
  @{i}OBP_Precision@{ui} - specifies the desired precision for the match.
    Should be PRECISION_GUI,PRECISION_ICON,PRECISION_IMAGE or PRECISION_EXACT.
    Defaults to PRECISION_IMAGE.
  @{i}OBP_FailIfBad@{ui} - specifies that you want ObtainBestPen to return a failure
    value if there is not a color within the given tolerance, instead of
    returning the closest color.
    With @{i}OBP_FailIfBad@{ui}==FALSE, ObtainBestPen will only fail if the @{"ViewPort" Link "include:graphics/view.h/Main" 40}
    contains no sharable colors.Defaults to FALSE.
  @{i}@{b}color@{ub}@{ui} - The correct pen value, or -1 if no sharable palette entries are
    available.
NOTES
  If this call succceeds, then you must call @{"ReleasePen()" Link "ReleasePen()"} when you are
  done with the color.
  The error metric used for ObtainBestPen() is based on the magnitude squared
  between the two RGB values, scaled by the percentage of free entries.
SEE ALSO
  @{"GetColorMap()" Link "GetColorMap()"} @{"ObtainPen()" Link "ObtainPen()"} @{"ReleasePen()" Link "ReleasePen()"} 
@EndNode
@Node "ObtainPen()" "graphics.library/ObtainPen"
@{b}@{u}ObtainPen@{uu}@{ub} -- Obtain a free palette entry for use by your program.@{FG fill}(V39)@{FG text}
  Attempt to allocate an entry in the colormap for use by the application.
  If successful, you should @{"ReleasePen()" Link "ReleasePen()"} this entry after you have finished with it.
  Applications needing exclusive use of a color register (say for color cycling)
  will typically call this function with n=-1.Applications needing only the
  shared use of a color will typically use @{"ObtainBestPenA()" Link "ObtainBestPenA()"} instead.
  Other uses of this function are rare.
SYNOPSIS  @{FG shine}long@{FG text} ObtainPen(@{FG shine}struct@{FG text} @{"ColorMap" Link "include:graphics/view.h/Main" 143} *,ULONG,ULONG,ULONG,ULONG,ULONG);
  @{i}@{b}n@{ub}@{ui} = ObtainPen( @{i}cm@{ui}, @{i}n@{ui}, @{i}r@{ui}, @{i}g@{ui}, @{i}b@{ui}, @{i}flags@{ui})
   d0             a0  d0 d1  d2 d3 d4
  @{i}cm@{ui} =  A pointer to a color map created by @{"GetColorMap()" Link "GetColorMap()"}.
  @{i}n@{ui} = The index of the desired entry, or -1 if any one is acceptable
  @{i}rgb@{ui} = The RGB values (32 bit left justified fractions) to set the new
    palette entry to.
  @{i}flags@{ui}:
    @{i}PEN_EXCLUSIVE@{ui} - tells the system that you want exclusive (non-shared)
      use of this pen value.Default is shared access.
    @{i}PEN_NO_SETCOLOR@{ui} - tells the system to not change the rgb values for the
      selected pen.Really only makes sense for exclusive pens.
  @{i}@{b}n@{ub}@{ui} = The allocated pen.-1 will be returned if there is no pen available for you.
NOTES
  When you allocate a palette entry in non-exclusive mode, you should not change
  it (via SetRGB32), because other programs on the same screen may be using it.
  With @{i}PEN_EXCLUSIVE@{ui} mode, you can change the returned entry at will.
  To avoid visual artifacts, you should not free up a palette entry until you
  are sure that your application is not displaying any pixels in that color at
  the time you free it.Otherwise, another task could allocate and set that color
  index, thus changing the colors of your pixels.
  Generally, for shared access, you should use @{"ObtainBestPenA()" Link "ObtainBestPenA()"} instead,
  since it will not allocate a new color if there is one "close enough"
  to the one you want already.
  If there is no Palextra attached to the colormap,
  then this routine will always fail.
SEE ALSO
  @{"GetColorMap()" Link "GetColorMap()"} @{"ReleasePen()" Link "ReleasePen()"} @{"AttachPalExtra()" Link "AttachPalExtra()"} @{"ObtainBestPenA()" Link "ObtainBestPenA()"}
@EndNode
@Node "OpenFont()" "graphics.library/OpenFont"
@{b}@{u}OpenFont@{uu}@{ub} -- Get a pointer to a system font.
  This function searches the system font space for the graphics text font that
  best matches the attributes specified.The pointer to the font returned can be
  used in subsequent @{"SetFont" Link "SetFont()"} and @{"CloseFont" Link "CloseFont()"} calls.It is important to match this
  call with a corresponding CloseFont call for effective management of ram fonts.
SYNOPSIS  @{FG shine}struct@{FG text} @{"TextFont" Link "include:graphics/text.h/Main" 89} *OpenFont(@{FG shine}struct@{FG text} @{"TextAttr" Link "include:graphics/text.h/Main" 65} *);
  @{i}@{b}font@{ub}@{ui} = OpenFont(@{i}textAttr@{ui})
   D0              A0
  @{i}textAttr@{ui} - a TextAttr or @{"TTextAttr" Link "include:graphics/text.h/Main" 72} structure that describes the
    text font attributes desired.
  @{i}@{b}font@{ub}@{ui} - 0 if the desired font cannot be found.
    If the named font is found, but the size and style specified are not
    available, a font with the nearest attributes is returned.
BUGS
  Prior to V39 this function would return a TextFont pointer for any font which
  matched exactly in Y size, regardless of differences in DPI, or DotSize.
  As part of fixing this bug it is REQUIRED that you use pass the same TextAttr
  (or TTextAttr) to this function that was used when @{"OpenDiskFont()" Link "libs.guide/OpenDiskFont()"} was called.
  OpenFont(), and @{"OpenDiskFont()" Link "libs.guide/OpenDiskFont()"} use @{"WeighTAMatch()" Link "WeighTAMatch()"} to measure how well two
  fonts match.WeightTAMatch() was a public function in graphics.library V36-V37;
  it is now a system PRIVATE function as of V39.
SEE ALSO
  @{"CloseFont()" Link "CloseFont()"} @{"SetFont()" Link "SetFont()"} @{"diskfont.library/OpenDiskFont" Link "libs.guide/OpenDiskFont()"}
  @{"graphics/text.h" Link "include:graphics/text.h/Main" 0} @{"intuition/intuition.h" Link "include:intuition/intuition.h/Main" 0}
@EndNode
@Node "OpenMonitor()" "graphics.library/OpenMonitor"
@{b}@{u}OpenMonitor@{uu}@{ub} -- open a named MonitorSpec.@{FG fill}(V36)@{FG text}
  Locate and open a named MonitorSpec.
SYNOPSIS  @{FG shine}struct@{FG text} @{"MonitorSpec" Link "include:graphics/monitor.h/Main" 25} *OpenMonitor( @{FG shine}char@{FG text} *, ULONG );
  @{i}@{b}mspc@{ub}@{ui} = OpenMonitor( @{i}monitor_name@{ui} , @{i}display_id@{ui})
   d0                  a1             d0
  @{i}monitor_name@{ui} - a pointer to a null terminated string.
  @{i}display_id@{ui} - an optional 32 bit monitor/mode identifier
  @{i}@{b}mspc@{ub}@{ui} - a pointer to an open MonitorSpec structure.
    NULL if MonitorSpec could not be opened.
NOTE
  if monitor_name is non-NULL, the monitor will be opened by name.
  if monitor_name is NULL the monitor will be opened by optional ID.
  if both monitor_name and display_id are NULL returns default monitor.
SEE ALSO
  @{"CloseMonitor()" Link "CloseMonitor()"} @{"graphics/monitor.h" Link "include:graphics/monitor.h/Main" 0}
@EndNode
@Node "OrRectRegion()" "graphics.library/OrRectRegion"
@{b}@{u}OrRectRegion@{uu}@{ub} -- Perform 2d OR operation of rectangle with region,
  leaving result in region.
  If any portion of rectangle is not in the region then add
  that portion to the region.
SYNOPSIS  BOOL OrRectRegion( @{FG shine}struct@{FG text} @{"Region" Link "include:graphics/regions.h/Main" 28} *, @{FG shine}struct@{FG text} @{"Rectangle" Link "include:graphics/gfx.h/Main" 27} * );
  @{i}@{b}status@{ub}@{ui} = OrRectRegion(@{i}region@{ui},@{i}rectangle@{ui})
   d0                    a0     a1
  @{i}region@{ui} - pointer to Region structure
  @{i}rectangle@{ui} - pointer to Rectangle structure
  @{i}@{b}status@{ub}@{ui} - return TRUE if successful operation,
    return FALSE if ran out of memory
SEE ALSO
  @{"AndRectRegion()" Link "AndRectRegion()"} @{"OrRegionRegion()" Link "OrRegionRegion()"} @{"graphics/regions.h" Link "include:graphics/regions.h/Main" 0}
@EndNode
@Node "OrRegionRegion()" "graphics.library/OrRegionRegion"
@{b}@{u}OrRegionRegion@{uu}@{ub} -- Perform 2d OR operation of one region with second region,
  leaving result in second region.
  If any portion of region1 is not in the region,
  then add that portion to the region2.
SYNOPSIS  BOOL OrRegionRegion( @{FG shine}struct@{FG text} @{"Region" Link "include:graphics/regions.h/Main" 28} *, @{FG shine}struct@{FG text} Region * );
  @{i}@{b}status@{ub}@{ui} = OrRegionRegion(@{i}region1@{ui},@{i}region2@{ui})
   d0                      a0      a1
  @{i}region1@{ui} - pointer to Region structure
  @{i}region2@{ui} - pointer to Region structure
  @{i}@{b}status@{ub}@{ui} - return TRUE if successful operation,
    return FALSE if ran out of memory
SEE ALSO
  @{"OrRectRegion()" Link "OrRectRegion()"} @{"graphics/regions.h" Link "include:graphics/regions.h/Main" 0}
@EndNode
@Node "OwnBlitter()" "graphics.library/OwnBlitter"
@{b}@{u}OwnBlitter@{uu}@{ub} - get the blitter for private usage.
  If blitter is available return immediately with the blitter locked for your
  exclusive use.If the blitter is not available put task to sleep.It will be
  awakened as soon as the blitter is available.When the task first owns the
  blitter the blitter may still be finishing up a blit for the previous owner.
  You must do a @{"WaitBlit" Link "WaitBlit()"} before actually using the blitter registers.
  Calls to OwnBlitter() do not nest.If a task that owns the blitter calls
  OwnBlitter() again, a lockup will result.(Same situation if the task calls a
  system function that tries to own the blitter).
SYNOPSIS  @{FG shine}void@{FG text} OwnBlitter( @{FG shine}void@{FG text} );
  OwnBlitter()
SEE ALSO
  @{"DisownBlitter()" Link "DisownBlitter()"} @{"WaitBlit()" Link "WaitBlit()"}
@EndNode
@Node "PolyDraw()" "graphics.library/PolyDraw"
@{b}@{u}PolyDraw@{uu}@{ub} -- Draw lines from table of (x,y) values.
  Starting with the first pair in the array, draw connected lines to
  it and every successive pair.
SYNOPSIS  @{FG shine}void@{FG text} PolyDraw( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, WORD, WORD * );
  PolyDraw( @{i}rp@{ui}, @{i}count@{ui} , @{i}array@{ui} )
             a1  d0      a0
  @{i}rp@{ui} - pointer to RastPort structure
  @{i}count@{ui} -  number of (x,y) pairs in the array
  @{i}array@{ui} - pointer to first (x,y) pair
SEE ALSO
  @{"Draw()" Link "Draw()"} @{"Move()" Link "Move()"} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "QBlit()" "graphics.library/QBlit"
@{b}@{u}QBlit@{uu}@{ub} -- Queue up a request for blitter usage.
  Link a request for the use of the blitter to the end of the current blitter
  queue.The pointer bp points to a blit structure containing, among other things,
  the link information, and the address of your routine which is to be called
  when the blitter queue finally gets around to this specific request.When your
  routine is called, you are in control of the blitter ...it is not busy with
  anyone else's requests.This means that you can directly specify the register
  contents and start the blitter.
  See the description of the blit structure and the uses of QBlit in the section
  titled Graphics Support in the OS Kernel Manual.
  Your code must be written to run either in supervisor or user mode
  on the 68000.
SYNOPSIS  @{FG shine}void@{FG text} QBlit( @{FG shine}struct@{FG text} @{"bltnode" Link "include:hardware/blit.h/Main" 89} * );
  QBlit( @{i}bp@{ui} )
          a1
  @{i}bp@{ui} - pointer to a blit structure
  Your routine is called when the blitter is ready for you.
    In general requests for blitter usage through this channel are put in front
    of those who use the blitter via @{"OwnBlitter" Link "OwnBlitter()"} and @{"DisownBlitter" Link "DisownBlitter()"}.However,for
    small blits there is more overhead using the queuer than Own/Disown Blitter.
NOTES
  Code which uses QBlit(), or @{"QBSBlit()" Link "QBSBlit()"} should make use of the pointer to a
  cleanup routine in the bltnode structure.The cleanup routine may be called on
  the context of an interrupt, therefore the routine may set a flag, and signal
  a task, but it may not call @{"FreeMem()" Link "exec.guide/FreeMem()"} directly.Use of the cleanup routine is
  the only safe way to signal that your bltnode has completed.
BUGS
  QBlit(), and @{"QBSBlit()" Link "QBSBlit()"} have been rewritten for V39 due to
  various long standing bugs in earlier versions of this code.
SEE ALSO
  @{"QBSBlit()" Link "QBSBlit()"} @{"hardware/blit.h" Link "include:hardware/blit.h/Main" 0}
@EndNode
@Node "QBSBlit()" "graphics.library/QBSBlit"
@{b}@{u}QBSBlit@{uu}@{ub} -- Synchronize the blitter request with the video beam.
  Call a user routine for use of the blitter, enqueued separately from the
  @{"QBlit" Link "QBlit()"} queue.Calls the user routine contained in the blit structure when the
  video beam is located at a specified position onscreen.Useful when you are
  trying to blit into a visible part of the screen and wish to perform the data
  move while the beam is not trying to display that same area.(prevents showing
  part of an old display and part of a new display simultaneously).
  Blitter requests on the QBSBlit queue take precedence over those on the regular
  blitter queue.The beam position is specified in the bltnode.
SYNOPSIS  @{FG shine}void@{FG text} QBSBlit( @{FG shine}struct@{FG text} @{"bltnode" Link "include:hardware/blit.h/Main" 89} * );
  QBSBlit( @{i}bsp@{ui} )
            a1
  @{i}bsp@{ui} - pointer to a blit structure.
    See description in the Graphics Support section of the manual for more info.
  User routine is called when the QBSBlit queue reaches this request
    AND the video beam is in the specified position.
    If there are lots of blits going on and the video beam has wrapped around
    back to the top it will call all the remaining bltnodes as fast as it can
    to try and catch up.
NOTES
  @{"QBlit()" Link "QBlit()"}, and QBSBlit() have been rewritten for V39.
  Queued blits are now handled in FIFO order.Tasks trying to @{"OwnBlitter()" Link "OwnBlitter()"} are
  now given a fair share of the total blitter time available.QBSBlit() are
  no longer queued separately from nodes added by @{"QBlit()" Link "QBlit()"}.This fixes the ordering
  dependencies listed under BUGS in prior autodoc notes.
SEE ALSO
  @{"QBlit()" Link "QBlit()"} @{"hardware/blit.h" Link "include:hardware/blit.h/Main" 0}
@EndNode
@Node "ReadPixel()" "graphics.library/ReadPixel"
@{b}@{u}ReadPixel@{uu}@{ub} -- read the pen number value of the pixel at a specified x,y location
  within a certain RastPort.
  Combine the bits from each of the bit-planes used to describe a particular
  RastPort into the pen number selector which that bit combination normally
  forms for the system hardware selection of pixel color.
SYNOPSIS  @{FG shine}long@{FG text} ReadPixel( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, SHORT, SHORT );
  @{i}@{b}penno@{ub}@{ui} = ReadPixel( @{i}rp@{ui},    @{i}x@{ui},    @{i}y@{ui} )
   d0                 a1     d0:16 d1:16
  @{i}rp@{ui} -  pointer to a RastPort structure
  (@{i}x@{ui},@{i}y@{ui}) a point in the RastPort
  @{i}@{b}penno@{ub}@{ui} - the pen number of the pixel at (x,y) is returned.
    -1 is returned if the pixel cannot be read for some reason.
SEE ALSO
  @{"WritePixel()" Link "WritePixel()"}  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "ReadPixelArray8()" "graphics.library/ReadPixelArray8"
@{b}@{u}ReadPixelArray8@{uu}@{ub} -- read the pen number value of a rectangular array
  of pixels starting at a specified x,y location and continuing 
  through to another x,y location within a certain RastPort.@{FG fill}(V36)@{FG text}
  For each pixel in a rectangular region, combine the bits from each
  of the bit-planes used to describe a particular RastPort into the pen
  number selector which that bit combination normally forms for the
  system hardware selection of pixel color.
SYNOPSIS
  @{FG shine}long@{FG text} ReadPixelArray8(@{FG shine}struct@{FG text}  @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, UWORD, UWORD, UWORD, UWORD, UBYTE *,
    @{FG shine}struct@{FG text} RastPort *);
  @{i}@{b}count@{ub}@{ui} = ReadPixelArray8(@{i}rp@{ui},@{i}xstart@{ui},@{i}ystart@{ui},@{i}xstop@{ui}@{i}@{ui},@{i}ystop@{ui},@{i}array@{ui},@{i}temprp@{ui})
   D0                      A0 D0:16   D1:16  D2:16 D3:16 A2     A1
  @{i}rp@{ui} -  pointer to a RastPort structure
  (@{i}xstart@{ui},@{i}ystart@{ui}) - starting point in the RastPort
  (@{i}xstop@{ui},@{i}ystop@{ui}) - stopping point in the RastPort
  @{i}array@{ui} - pointer to an array of UBYTEs from which to fetch the pixel data.
    Allocate at least ((((width+15)>>4)<<4)*(ystop-ystart+1)) bytes.
  @{i}temprp@{ui} - temporary rastport (copy of rp with Layer set == NULL,
    temporary memory allocated for temprp->BitMap with Rows set == 1,
    temprp->BytesPerRow == (((width+15)>>4)<<1),
    and temporary memory allocated for temprp->BitMap->Planes[])
  @{b}For each pixel in the array@{ub}:
    @{i}@{b}Pen@{ub}@{ui} - (0..255) number at that position is returned
  @{i}@{b}count@{ub}@{ui} - the number of pixels read.
NOTE
  xstop must be >= xstart, ystop must be >= ystart
SEE ALSO
  @{"ReadPixel()" Link "ReadPixel()"}  @{"ReadPixelLine8()" Link "ReadPixelLine8()"}  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "ReadPixelLine8()" "graphics.library/ReadPixelLine8"
@{b}@{u}ReadPixelLine8@{uu}@{ub} -- read the pen number value of a horizontal line of pixels
  starting at a specified x,y location and continuing right for count pixels.@{FG fill}(V36)@{FG text}
  For each pixel in a rectangular region, combine the bits from each
  of the bit-planes used to describe a particular RastPort into the pen
  number selector which that bit combination normally forms for the
  system hardware selection of pixel color.
SYNOPSIS
  @{FG shine}long@{FG text} ReadPixelLine8(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, UWORD, UWORD, UWORD, UBYTE *,
    @{FG shine}struct@{FG text} RastPort * );
  @{i}@{b}count@{ub}@{ui} = ReadPixelLine8(@{i}rp@{ui},@{i}xstart@{ui},@{i}ystart@{ui},@{i}width@{ui},@{i}array@{ui},@{i}temprp@{ui})
   D0                     A0 D0:16   D1:16  D2    A2     A1
  @{i}rp@{ui} - pointer to a RastPort structure
  (@{i}xstart@{ui},@{i}ystart@{ui}) - a point in the RastPort
  @{i}width@{ui} - count of horizontal pixels to read
  @{i}array@{ui} - pointer to an array of UBYTEs from which to fetch the pixel data.
    Allocate at least (((width+15)>>4)<<4) bytes.
  @{i}temprp@{ui} - temporary rastport (copy of rp with Layer set == NULL,
    temporary memory allocated for temprp->BitMap with Rows set == 1,
    temprp->BytesPerRow == (((width+15)>>4)<<1),
    and temporary memory allocated for temprp->BitMap->Planes[])
  @{b}For each pixel in the array@{ub}:
    @{i}@{b}Pen@{ub}@{ui} - (0..255) number at that position is returned
  @{i}@{b}count@{ub}@{ui} - the number of pixels read.
NOTE
  width must be non negative.
SEE ALSO
  @{"ReadPixel()" Link "ReadPixel()"}  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "RectFill()" "graphics.library/RectFill"
@{b}@{u}RectFill@{uu}@{ub} -- Fill a rectangular region in a RastPort.
  Fills the rectangular region specified by the parameters with the
  chosen pen colors, areafill pattern, and drawing mode.
  If no areafill pattern is specified, fill the rectangular region with the
  FgPen color, taking into account the drawing mode.
SYNOPSIS  @{FG shine}void@{FG text} RectFill( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, SHORT, SHORT, SHORT, SHORT );
  RectFill( @{i}rp@{ui}, @{i}xmin@{ui}, @{i}ymin@{ui}, @{i}xmax@{ui}, @{i}ymax@{ui})
             a1  d0:16 d1:16  d2:16 d3:16
  @{i}rp@{ui} - pointer to a RastPort structure
  (@{i}xmin@{ui},@{i}ymin@{ui}) (@{i}xmax@{ui},@{i}ymax@{ui}) are the coordinates of the upper left corner and
    the lower right corner, respectively, of the rectangle.
NOTE
  The following relation MUST be true:
    (xmax >= xmin) and (ymax >= ymin)  
BUGS
  Complement mode with FgPen complements all bitplanes.
SEE ALSO
  @{"AreaEnd()" Link "AreaEnd()"} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "ReleasePen()" "graphics.library/ReleasePen"
@{b}@{u}ReleasePen@{uu}@{ub} -- Release an allocated palette entry to the free pool.@{FG fill}(V39)@{FG text}
  Return the palette entry for use by other applications.
  If the reference count for this palette entry goes to zero,
  then it may be reset to another RGB value.
SYNOPSIS  @{FG shine}void@{FG text} ReleasePen( @{FG shine}struct@{FG text} @{"ColorMap" Link "include:graphics/view.h/Main" 143} *, ULONG);
  ReleasePen( @{i}cm@{ui}, @{i}n@{ui})
               a0  d0
  @{i}cm@{ui} = A pointer to a color map created by @{"GetColorMap()" Link "GetColorMap()"}.
  @{i}n@{ui} = A palette index obtained via any of the palette allocation functions.
    Passing a -1 will result in this call doing nothing.
NOTES
  This function works for both shared and exclusive palette entries.
SEE ALSO
  @{"GetColorMap()" Link "GetColorMap()"} @{"ObtainPen()" Link "ObtainPen()"} @{"ObtainBestPenA()" Link "ObtainBestPenA()"}
@EndNode
@Node "RemBob()" "graphics.library/RemBob"
@{b}@{u}RemBob@{uu}@{ub} -- Macro to remove a Bob from the gel list.
  Marks a Bob as no-longer-required.The gels internal code then
  removes the Bob from the list of active gels the next time
  @{"DrawGList" Link "DrawGList()"} is executed.This is implemented as a macro.
  If the user is double-buffering the Bob, it could take two calls to
  @{"DrawGList" Link "DrawGList()"} before the Bob actually disappears from the RastPort.
SYNOPSIS  RemBob(@{FG shine}struct@{FG text} @{"Bob" Link "include:graphics/gels.h/Main" 139} *);
  RemBob(@{i}bob@{ui})
  @{i}Bob@{ui} = pointer to the Bob to be removed
SEE ALSO
  @{"RemIBob()" Link "RemIBob()"}  @{"DrawGList()" Link "DrawGList()"}  @{"graphics/gels.h" Link "include:graphics/gels.h/Main" 0}  @{"graphics/gfxmacros.h" Link "include:graphics/gfxmacros.h/Main" 0}
@EndNode
@Node "RemFont()" "graphics.library/RemFont"
@{b}@{u}RemFont@{uu}@{ub} -- Remove a font from the system list.
  This function removes a font from the system, ensuring that access to it is
  restricted to those applications that currently have an active pointer to it.
  i.e. no new @{"SetFont" Link "SetFont()"} requests to this font are satisfied.
SYNOPSIS  @{FG shine}void@{FG text} RemFont(@{FG shine}struct@{FG text} @{"TextFont" Link "include:graphics/text.h/Main" 89} *);
  RemFont(@{i}textFont@{ui})
           A1
  @{i}textFont@{ui} - the TextFont structure to remove.
SEE ALSO
  @{"SetFont()" Link "SetFont()"}  @{"AddFont()" Link "AddFont()"}  @{"graphics/text.h" Link "include:graphics/text.h/Main" 0}
@EndNode
@Node "RemIBob()" "graphics.library/RemIBob"
@{b}@{u}RemIBob@{uu}@{ub} -- Immediately remove a Bob from the gel list and the RastPort.
  Removes a Bob immediately by uncoupling it from the gel list and
  erases it from the RastPort.
SYNOPSIS  @{FG shine}void@{FG text} RemIBob(@{FG shine}struct@{FG text} @{"Bob" Link "include:graphics/gels.h/Main" 139} *, @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, @{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *);
  RemIBob(@{i}bob@{ui}, @{i}rp@{ui}, @{i}vp@{ui})
           A0   A1  A2
  @{i}bob@{ui} = pointer to the Bob to be removed
  @{i}rp@{ui}  = pointer to the RastPort if the Bob is to be erased
  @{i}vp@{ui}  = pointer to the ViewPort for beam-synchronizing
SEE ALSO
  @{"InitGels()" Link "InitGels()"}  @{"RemVSprite()" Link "RemVSprite()"}  @{"graphics/gels.h" Link "include:graphics/gels.h/Main" 0}
@EndNode
@Node "RemVSprite()" "graphics.library/RemVSprite"
@{b}@{u}RemVSprite@{uu}@{ub} -- Remove a VSprite from the current gel list.
  Unlinks the VSprite from the current gel list.
SYNOPSIS  @{FG shine}void@{FG text} RemVSprite(@{FG shine}struct@{FG text} @{"VSprite" Link "include:graphics/gels.h/Main" 72} *);
  RemVSprite(@{i}vs@{ui})
              A0
  @{i}vs@{ui} = pointer to the VSprite structure to be removed from the gel list
SEE ALSO
  @{"InitGels()" Link "InitGels()"}  @{"RemIBob()" Link "RemIBob()"}  @{"graphics/gels.h" Link "include:graphics/gels.h/Main" 0}
@EndNode
@Node "ScalerDiv()" "graphics.library/ScalerDiv"
@{b}@{u}ScalerDiv@{uu}@{ub} -- Get the scaling result that @{"BitMapScale" Link "BitMapScale()"} would.@{FG fill}(V36)@{FG text}
  Calculate the expression (factor*numerator/denominator) such
  that the result is the same as the width of the destination
  result of @{"BitMapScale" Link "BitMapScale()"} when the factor here is the width of
  the source, and the numerator and denominator are the
  XDestFactor and XSrcFactor for @{"BitMapScale" Link "BitMapScale()"}.
SYNOPSIS  UWORD ScalerDiv(UWORD, UWORD, UWORD);
  @{i}@{b}result@{ub}@{ui} = ScalerDiv(@{i}factor@{ui}, @{i}numerator@{ui}, @{i}denominator@{ui})
   D0                 D0       D1         D2
  @{i}factor@{ui} - a number in the range 0..16383
  @{i}numerator@{ui}, @{i}denominator@{ui} - numbers in the range 1..16383
  @{i}@{b}result@{ub}@{ui} - this returns @{i}factor@{ui}*@{i}numerator@{ui}/@{i}denominator@{ui}
@EndNode
@Node "ScrollRaster()" "graphics.library/ScrollRaster"
@{b}@{u}ScrollRaster@{uu}@{ub} -- Push bits in rectangle in raster around by dx,dy towards 0,0
  inside rectangle.
  Move the bits in the raster by (dx,dy) towards (0,0).The space vacated is
  RectFilled with BGPen.
  Limit the scroll operation to the rectangle defined by (xmin,ymin)(xmax,ymax).
  Bits outside will not be affected.If xmax,ymax is outside the rastport then
  use the lower right corner of the rastport.
  If you are dealing with a SimpleRefresh layered RastPort you should check
  rp->Layer->Flags & LAYERREFRESH to see if there is any damage in the damage
  list.If there is you should call the appropriate BeginRefresh(Intuition) or
  BeginUpdate(graphics) routine sequence.
SYNOPSIS
  @{FG shine}void@{FG text} ScrollRaster(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, WORD, WORD, WORD, WORD, WORD, WORD);
  ScrollRaster(@{i}rp@{ui}, @{i}dx@{ui}, @{i}dy@{ui}, @{i}xmin@{ui}, @{i}ymin@{ui}, @{i}xmax@{ui}, @{i}ymax@{ui})
                A1  D0  D1   D2    D3    D4    D5
  @{i}rp@{ui} - pointer to a RastPort structure
  @{i}dx@{ui},@{i}dy@{ui} are integers that may be positive, zero, or negative
  @{i}xmin@{ui},@{i}ymin@{ui} - upper left of bounding rectangle
  @{i}xmax@{ui},@{i}ymax@{ui} - lower right of bounding rectangle
EXAMPLE
  ScrollRaster(@{i}rp@{ui},0,1,@{i}minx@{ui},@{i}miny@{ui},@{i}maxx@{ui},@{i}maxy@{ui}) /* shift raster up by one row */
  ScrollRaster(@{i}rp@{ui},-1,-1,@{i}minx@{ui},@{i}miny@{ui},@{i}maxx@{ui},@{i}maxy@{ui})
    /* shift raster down and to the right by 1 pixel
BUGS
  In 1.2/V1.3 if you ScrollRaster a SUPERBITMAP exactly left or right, and there
  is no @{"TmpRas" Link "include:graphics/rastport.h/Main" 32} attached to the RastPort, the system will allocate one for you,
  but will never free it or record its location.This bug has been fixed for V36.
  The workaround for 1.2/1.3 is to attach a valid TmpRas of size at least
  MAXBYTESPERROW to the RastPort before the call.
  Beginning with V36 ScrollRaster adds the shifted areas into the damage list
  for SIMPLE_REFRESH windows.Due to unacceptable system overhead, the decision
  was made NOT to propagate this shifted area damage for SMART_REFRESH windows.
SEE ALSO
  @{"ScrollRasterBF()" Link "ScrollRasterBF()"} graphics/rastport.h
@EndNode
@Node "ScrollRasterBF()" "graphics.library/ScrollRasterBF"
@{b}@{u}ScrollRasterBF@{uu}@{ub} -- Push bits in rectangle in raster around by dx,dy towards 0,0
  inside rectangle.Newly empty areas will be filled via @{"EraseRect()" Link "EraseRect()"}.@{FG fill}(V39)@{FG text}
  Move the bits in the raster by (dx,dy) towards (0,0).The space vacated is
  filled by calling EraseRect().
  Limit the scroll operation to the rectangle defined by (xmin,ymin)(xmax,ymax).
  Bits outside will not be affected.If xmax,ymax is outside the rastport then
  use the lower right corner of the rastport.
  If you are dealing with a SimpleRefresh layered RastPort you should check
  rp->Layer->Flags & LAYERREFRESH to see if there is any damage in the damage
  list.If there is you should call the appropriate BeginRefresh(Intuition) or
  BeginUpdate(graphics) routine sequence.
SYNOPSIS
  @{FG shine}void@{FG text} ScrollRasterBF(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, WORD, WORD, WORD, WORD, WORD, WORD);
  ScrollRasterBF(@{i}rp@{ui}, @{i}dx@{ui}, @{i}dy@{ui}, @{i}xmin@{ui}, @{i}ymin@{ui}, @{i}xmax@{ui}, @{i}ymax@{ui})
                  A1  D0  D1   D2    D3    D4    D5
  @{i}rp@{ui} - pointer to a RastPort structure
  @{i}dx@{ui},@{i}dy@{ui} are integers that may be positive, zero, or negative
  @{i}xmin@{ui},@{i}ymin@{ui} - upper left of bounding rectangle
  @{i}xmax@{ui},@{i}ymax@{ui} - lower right of bounding rectangle
NOTES
  This call is exactly the same as @{"ScrollRaster" Link "ScrollRaster()"}, except that it calls
  @{"EraseRect()" Link "EraseRect()"} instead of @{"RectFill()" Link "RectFill()"} when clearing the newly exposed
  area.This allows use of a custom layer backfill hook.
SEE ALSO
  @{"ScrollRaster()" Link "ScrollRaster()"} @{"EraseRect()" Link "EraseRect()"} intuition.library/ScrollWindowRaster()
  graphics/rastport.h
@EndNode
@Node "ScrollVPort()" "graphics.library/ScrollVPort"
@{b}@{u}ScrollVPort@{uu}@{ub} - Reinterpret RasInfo information in ViewPort to reflect the
  current Offset values.
  After the programmer has adjusted the Offset values in the RasInfo structures
  of ViewPort, change the the copper lists to reflect the the Scroll positions.
  Changing the @{"BitMap" Link "include:graphics/gfx.h/Main" 46} ptr in RasInfo and not changing the Offsets will cause a
  double buffering affect.
SYNOPSIS  @{FG shine}void@{FG text} ScrollVPort(@{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *vp);
  ScrollVPort( @{i}vp@{ui} )
                a0
  @{i}vp@{ui} - pointer to a ViewPort structure that is currently be displayed.
NOTES
  Modifies hardware and intermediate copperlists to reflect new RasInfo.
BUGS
  pokes not fast enough to avoid some visible hashing of display.@{FG fill}(V37)@{FG text}
  This function was re-written in V39 and is ~10 times faster than before.
SEE ALSO
  @{"MakeVPort()" Link "MakeVPort()"} @{"MrgCop()" Link "MrgCop()"} @{"LoadView()" Link "LoadView()"}  @{"graphics/view.h" Link "include:graphics/view.h/Main" 0}
@EndNode
@Node "SetABPenDrMd()" "graphics.library/SetABPenDrMd"
@{b}@{u}SetABPenDrMd@{uu}@{ub} -- Set pen colors and draw mode for a RastPort.
  Set the pen values and drawing mode for lines, fills and text.
  Get the bit definitions from rastport.h
SYNOPSIS  @{FG shine}void@{FG text} SetABPenDrMd( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, ULONG, ULONG, ULONG );
  SetABPenDrMd( @{i}rp@{ui}, @{i}apen@{ui}, @{i}bpen@{ui}, @{i}mode@{ui} )
                 a1  d0    d1     d2
  @{i}rp@{ui} - pointer to RastPort structure.
  @{i}apen@{ui} - primary pen value
  @{i}bpen@{ui} - secondary pen value
  @{i}mode@{ui} - 0-255, some combinations may not make much sense.
NOTES
  The mode set is dependent on the bits selected.
  Changes minterms to reflect new drawing mode and colors.
  Sets line drawer to restart pattern.
  This call is essentially the same as a sequence of
  SetAPen()/SetBPen()/SetDrMD() calls, except that it is significantly faster.
  The minterms will only be generated once, or not at all if nothing changed
  (warning to illegal RastPort pokers!).
SEE ALSO
  @{"SetAPen()" Link "SetAPen()"} @{"SetBPen()" Link "SetBPen()"} @{"SetDrMd()" Link "SetDrMd()"} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "SetAPen()" "graphics.library/SetAPen"
@{b}@{u}SetAPen@{uu}@{ub} -- Set the primary pen for a RastPort.
  Set the primary drawing pen for lines, fills, and text.
SYNOPSIS  @{FG shine}void@{FG text} SetAPen( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, UBYTE );
  SetAPen( @{i}rp@{ui}, @{i}pen@{ui} )
            a1  d0
  @{i}rp@{ui} - pointer to RastPort structure.
  @{i}pen@{ui} - (0-255)
NOTES
  Changes the minterms in the RastPort to reflect new primary pen.
  Sets line drawer to restart pattern.
SEE ALSO
  @{"SetBPen()" Link "SetBPen()"} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "SetBPen()" "graphics.library/SetBPen"
@{b}@{u}SetBPen@{uu}@{ub} -- Set secondary pen for a RastPort.
  Set the secondary drawing pen for lines, fills, and text.
SYNOPSIS  @{FG shine}void@{FG text} SetBPen( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, UBYTE );
  SetBPen( @{i}rp@{ui}, @{i}pen@{ui} )
            a1  d0
  @{i}rp@{ui} - pointer to RastPort structure.
  @{i}pen@{ui} - (0-255)
NOTES
  Changes the minterms in the RastPort to reflect new secondary pen.
  Sets line drawer to restart pattern.
SEE ALSO
  @{"SetAPen()" Link "SetAPen()"} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "SetChipRev()" "graphics.library/SetChipRev"
@{b}@{u}SetChipRev@{uu}@{ub} -- turns on the features of a Chip Set.@{FG fill}(V39)@{FG text}
  Enables the features of the requested Chip Set if available,
  and updates the graphics database accordingly.
SYNOPSIS  ULONG SetChipRev(ULONG);
  @{i}@{b}chiprevbits@{ub}@{ui} = SetChipRev(@{i}ChipRev@{ui})
                            d0
  @{i}ChipRev@{ui} - Chip Rev that you would like to be enabled.
  @{i}@{b}chiprevbits@{ub}@{ui} - Actual bits set in GfxBase->ChipRevBits0.
NOTES
  This routine should only be called once.It will be called by the system
  in the startup-sequence, but is included in the autodocs for authors
  of bootblock-games that wish to take advantage of post-ECS features.
SEE ALSO
  @{"<graphics/gfxbase.h>" Link "include:graphics/gfxbase.h/Main" 0}
@EndNode
@Node "SetCollision()" "graphics.library/SetCollision"
@{b}@{u}SetCollision@{uu}@{ub} -- Set a pointer to a user collision routine.
  Sets a specified entry (num) in the user's collision vectors table
  equal to the address of the specified collision routine.
SYNOPSIS  @{FG shine}void@{FG text} SetCollision(ULONG, @{FG shine}void@{FG text} (*)(), @{FG shine}struct@{FG text} @{"GelsInfo" Link "include:graphics/rastport.h/Main" 39} *);
  SetCollision(@{i}num@{ui}, @{i}routine@{ui}, @{i}GInfo@{ui})
                D0   A0        A1
  @{i}num@{ui}     = collision vector number
  @{i}routine@{ui} = pointer to the user's collision routine
  @{i}GInfo@{ui}   = pointer to a @{"GelsInfo" Link "include:graphics/rastport.h/Main" 39} structure
SEE ALSO
  @{"InitGels()" Link "InitGels()"}  @{"graphics/gels.h" Link "include:graphics/gels.h/Main" 0}  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "SetDrMd()" "graphics.library/SetDrMd"
@{b}@{u}SetDrMd@{uu}@{ub} -- Set drawing mode for a RastPort.
  Set the drawing mode for lines, fills and text.
  Get the bit definitions from rastport.h.
SYNOPSIS  @{FG shine}void@{FG text} SetDrMd( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, UBYTE );
  SetDrMd( @{i}rp@{ui}, @{i}mode@{ui} )
            a1  d0:8
  @{i}rp@{ui} - pointer to RastPort structure.
  @{i}mode@{ui} - 0-255, some combinations may not make much sense.
NOTES
  The mode set is dependent on the bits selected.
  Changes minterms to reflect new drawing mode.
  Sets line drawer to restart pattern.
SEE ALSO
  @{"SetAPen()" Link "SetAPen()"} @{"SetBPen()" Link "SetBPen()"} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "SetFont()" "graphics.library/SetFont"
@{b}@{u}SetFont@{uu}@{ub} -- Set the text font and attributes in a RastPort.
  This function sets the font in the RastPort to that described
  by font, and updates the text attributes to reflect that
  change.This function clears the effect of any previous soft styles.
SYNOPSIS  @{FG shine}void@{FG text} SetFont(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, @{FG shine}struct@{FG text} @{"TextFont" Link "include:graphics/text.h/Main" 89} *);
  SetFont(@{i}rp@{ui}, @{i}font@{ui})
           A1  A0
  @{i}rp@{ui}   - the RastPort in which the text attributes are to be changed
  @{i}font@{ui} - pointer to a TextFont structure returned from @{"OpenFont()" Link "OpenFont()"}
    or @{"OpenDiskFont()" Link "libs.guide/OpenDiskFont()"}
NOTES
  This function had previously been documented that it would
  accept a null font.This practice is discouraged.
  o Use of a RastPort with a null font with text routines has
    always been incorrect and risked the guru.
  o Keeping an obsolete font pointer in the RastPort is no more
    dangerous than keeping a zero one there.
  o SetFont(rp, 0) causes spurious low memory accesses under
    some system software releases.
  As of V36, the following Amiga font variants are no longer directly supported:
    fonts with NULL tf_CharSpace and non-NULL tf_CharKern.
    fonts with non-NULL tf_CharSpace and NULL tf_CharKern.
    fonts with NULL tf_CharSpace and NULL tf_CharKern with
      a tf_CharLoc size component greater than tf_XSize.
  Attempts to SetFont these one of these font variants will
  cause the system to modify your font to make it acceptable.
BUGS
  Calling SetFont() on in-code TextFonts (ie fonts not OpenFont()ed)
  will result in a loss of 24 bytes from the system as of V36.
  This can be resolved by calling @{"StripFont()" Link "StripFont()"}.
SEE ALSO
  @{"OpenFont()" Link "OpenFont()"} @{"StripFont()" Link "StripFont()"} @{"diskfont.library/OpenDiskFont()" Link "libs.guide/OpenDiskFont()"} @{"graphics/text.h" Link "include:graphics/text.h/Main" 0}
@EndNode
@Node "SetMaxPen()" "graphics.library/SetMaxPen"
@{b}@{u}SetMaxPen@{uu}@{ub} -- set maximum pen value for a rastport.@{FG fill}(V39)@{FG text}
  This will instruct the graphics library that the owner of the rastport
  will not be rendering in any colors whose index is >maxpen.If there
  are any speed optimizations which the graphics device can make based
  on this fact (for instance, setting the pixel write mask), they will be done.
  Basically this call sets the rastport mask, if this would improve
  speed.On devices where masking would slow things down (like with
  chunky pixels), it will be a no-op.
SYNOPSIS  @{FG shine}void@{FG text} SetMaxPen(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *,ULONG)
  SetMaxPen( @{i}rp@{ui}, @{i}maxpen@{ui})
              a0  d0
  @{i}rp@{ui}  =  a pointer to a valid RastPort structure.
  @{i}maxpen@{ui} =  a longword pen value.
NOTES
  The maximum pen value passed must take into account not only which
  colors you intend to render in the future, but what colors you will
  be rendering on top of.
  SetMaxPen(rp,0) doesn't make much sense.
SEE ALSO
  @{"SetWriteMask()" Link "SetWriteMask()"}
@EndNode
@Node "SetOPen()" "graphics.library/SetOPen"
@{b}@{u}SetOPen@{uu}@{ub} -- Change the Area OutLine pen and turn on Outline mode for areafills.
  This is implemented as a c-macro.
  Pen is the pen number that will be used to draw a border
  around an areafill during @{"AreaEnd()" Link "AreaEnd()"}.
SYNOPSIS  @{FG shine}void@{FG text} SetOPen( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, UBYTE );
  SetOPen(@{i}rp@{ui}, @{i}pen@{ui})
  @{i}rp@{ui} = pointer to RastPort structure
  @{i}pen@{ui} = number  between 0-255
SEE ALSO
  @{"AreaEnd()" Link "AreaEnd()"} @{"graphics/gfxmacros.h" Link "include:graphics/gfxmacros.h/Main" 0} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "SetOutlinePen()" "graphics.library/SetOutlinePen"
@{b}@{u}SetOutlinePen@{uu}@{ub} -- Set the Outline Pen value for a RastPort.@{FG fill}(V39)@{FG text}
  Set the current value of the O pen for the rastport and turn on area outline
  mode.This function should be used instead of poking the structure directly,
  because future graphics devices may store it differently, for instance,
  using more bits.
SYNOPSIS  ULONG SetOutlinePen(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *,ULONG)
  @{i}@{b}old_pen@{ub}@{ui}=SetOutlinePen( @{i}rp@{ui}, @{i}pen@{ui} )
   d0                     a0  d0
  @{i}rp@{ui} = a pointer to a valid RastPort structure.
  @{i}pen@{ui} = a longword pen number
  @{i}@{b}old_pen@{ub}@{ui} = previous outline pen
SEE ALSO
  @{"GetOPen()" Link "GetOPen()"} @{"graphics/gfxmacros.h" Link "include:graphics/gfxmacros.h/Main" 0}
@EndNode
@Node "SetRast()" "graphics.library/SetRast"
@{b}@{u}SetRast@{uu}@{ub} - Set an entire drawing area to a specified color.
  Set the entire contents of the specified RastPort to the specified pen.
  All pixels within the drawing area are set to the selected pen number.
SYNOPSIS  @{FG shine}void@{FG text} SetRast( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, UBYTE );
  SetRast( @{i}rp@{ui}, @{i}pen@{ui} )
            a1  d0
  @{i}rp@{ui} - pointer to RastPort structure
  @{i}pen@{ui} - the pen number (0-255) to jam into bitmap
SEE ALSO
  @{"RectFill()" Link "RectFill()"} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "SetRGB32()" "graphics.library/SetRGB32"
@{b}@{u}SetRGB32@{uu}@{ub} -- Set one color register for this Viewport.@{FG fill}(V39)@{FG text}
  If there is a @{"ColorMap" Link "include:graphics/view.h/Main" 143} for this viewport, then the value will
  be stored in the ColorMap.
  The selected color register is changed to match your specs.
  If the color value is unused then nothing will happen.
SYNOPSIS  @{FG shine}void@{FG text} SetRGB32( @{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *, ULONG, ULONG, ULONG, ULONG );
  SetRGB32(  @{i}vp@{ui},  @{i}n@{ui},   @{i}r@{ui},    @{i}g@{ui},    @{i}b@{ui})
              a0   d0   d1     d2    d3
  @{i}vp@{ui} = viewport
  @{i}n@{ui} = the number of the color register to set.
  @{i}r@{ui} = red level   (32 bit left justified fraction)
  @{i}g@{ui} = green level (32 bit left justified fraction)
  @{i}b@{ui} = blue level  (32 bit left justified fraction)
NOTES
  Lower order bits of the palette specification will be discarded,
  depending on the color palette resolution of the target graphics
  device.Use 0xffffffff for the full value, 0x7fffffff for 50%,
  etc.You can find out the palette range for your screen by
  querying the graphics data base.
SEE ALSO
  @{"GetColorMap()" Link "GetColorMap()"} @{"GetRGB32()" Link "GetRGB32()"} @{"SetRGB32CM()" Link "SetRGB32CM()"} @{"LoadRGB32()" Link "LoadRGB32()"} @{"graphics/view.h" Link "include:graphics/view.h/Main" 0}
@EndNode
@Node "SetRGB32CM()" "graphics.library/SetRGB32CM"
@{b}@{u}SetRGB32CM@{uu}@{ub} -- Set one color register for this ColorMap.@{FG fill}(V39)@{FG text}
  Store the (r,g,b) triplet at index n of the ColorMap structure.
  This function can be used to set up a ColorMap before linking it
  into a viewport.
SYNOPSIS  @{FG shine}void@{FG text} SetRGB4CM( @{FG shine}struct@{FG text} @{"ColorMap" Link "include:graphics/view.h/Main" 143} *, ULONG, ULONG, ULONG , ULONG);
  SetRGB32CM(  @{i}cm@{ui},  @{i}n@{ui},   @{i}r@{ui}@{i}@{ui},    @{i}g@{ui},    @{i}b@{ui})
                a0   d0   d1     d2    d3
  @{i}cm@{ui} = colormap
  @{i}n@{ui} = the number of the color register to set.
    Must not exceed the number of colors allocated for the colormap.
  @{i}r@{ui} = red level (32 bit unsigned left justified fraction)
  @{i}g@{ui} = green level
  @{i}b@{ui} = blue level
SEE ALSO
  @{"GetColorMap()" Link "GetColorMap()"} @{"GetRGB32()" Link "GetRGB32()"} @{"SetRGB32()" Link "SetRGB32()"} @{"SetRGB4CM()" Link "SetRGB4CM()"} @{"graphics/view.h" Link "include:graphics/view.h/Main" 0}
@EndNode
@Node "SetRGB4()" "graphics.library/SetRGB4"
@{b}@{u}SetRGB4@{uu}@{ub} -- Set one color register for this viewport.
  Change the color look up table so that this viewport displays
  the color (r,g,b) for pen number n.
SYNOPSIS  @{FG shine}void@{FG text} SetRGB4( @{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *, SHORT, UBYTE, UBYTE, UBYTE );
  SetRGB4(  @{i}vp@{ui}, @{i}n@{ui},   @{i}r@{ui},    @{i}g@{ui},    @{i}b@{ui})
             a0  d0   d1:4  d2:4   d3:4
  @{i}vp@{ui} - pointer to  viewport structure
  @{i}n@{ui} - the color number (range from 0 to 31)
  @{i}r@{ui} - red level (0-15)
  @{i}g@{ui} - green level (0-15)
  @{i}b@{ui} - blue level (0-15)
NOTES
  If there is a ColorMap for this viewport, then the value will
  be stored in the ColorMap.
  The selected color register is changed to match your specs.
  If the color value is unused then nothing will happen.
BUGS
  Under V36 and up, it is not safe to call this function from an interrupt,
  due to semaphore protection of graphics copper lists.
SEE ALSO
  @{"LoadRGB4()" Link "LoadRGB4()"} @{"GetRGB4()" Link "GetRGB4()"} @{"graphics/view.h" Link "include:graphics/view.h/Main" 0}
@EndNode
@Node "SetRGB4CM()" "graphics.library/SetRGB4CM"
@{b}@{u}SetRGB4CM@{uu}@{ub} -- Set one color register for this ColorMap.
  Store the (r,g,b) triplet at index n of the ColorMap structure.
  This function can be used to set up a ColorMap before linking it
  into a viewport.
SYNOPSIS  @{FG shine}void@{FG text} SetRGB4CM( @{FG shine}struct@{FG text} @{"ColorMap" Link "include:graphics/view.h/Main" 143} *, SHORT, UBYTE, UBYTE, UBYTE );
  SetRGB4CM(  @{i}cm@{ui},  @{i}n@{ui},   @{i}r@{ui},    @{i}g@{ui},    @{i}b@{ui})
               a0   d0   d1:4   d2:4  d3:4
  @{i}cm@{ui} = colormap
  @{i}n@{ui} = the number of the color register to set.
    Ranges from 0 to 31on current Amiga displays.
  @{i}r@{ui} = red level (0-15)
  @{i}g@{ui} = green level (0-15)
  @{i}b@{ui} = blue level (0-15)
SEE ALSO
  @{"GetColorMap()" Link "GetColorMap()"} @{"GetRGB4()" Link "GetRGB4()"} @{"SetRGB4()" Link "SetRGB4()"} @{"graphics/view.h" Link "include:graphics/view.h/Main" 0}
@EndNode
@Node "SetRPAttrA()" "graphics.library/SetRPAttrA"
@{b}@{u}SetRPAttrA@{uu}@{ub} -- modify rastport settings via a tag list.
@{b}@{u}SetRPAttrs@{uu}@{ub} -- varargs stub for SetRPAttrA.
  Modify settings of a rastport, based on the taglist passed.
SYNOPSIS  @{FG shine}void@{FG text} SetRPAttrA(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  SetRPAttrA(@{i}rp@{ui}, @{i}tags@{ui})
              a0  a1
  SetRPAttrs(@{i}rp@{ui}, @{i}tag@{ui},...);
  @{i}rp@{ui} - pointer to the RastPort to modify.
  @{i}tags@{ui} - a standard tag list (currently available are):
    @{i}RPTAG_Font@{ui} - Font for @{"Text()" Link "Text()"}
    @{i}RPTAG_SoftStyle@{ui} - style for text (see @{"graphics/text.h)" Link "include:graphics/text.h/Main" 0}
    @{i}RPTAG_APen@{ui} - Primary rendering pen
    @{i}RPTAG_BPen@{ui} - Secondary rendering pen
    @{i}RPTAG_DrMd@{ui} - Drawing mode (see @{"graphics/rastport.h)" Link "include:graphics/rastport.h/Main" 0}
    @{i}RPTAG_OutLinePen@{ui} - Area Outline pen
    @{i}RPTAG_WriteMask@{ui} - Bit Mask for writing.
    @{i}RPTAG_MaxPen@{ui} - Maximum pen to render (see @{"SetMaxPen()" Link "SetMaxPen()"})
SEE ALSO
  @{"SetFont()" Link "SetFont()"} @{"SetSoftStyle()" Link "SetSoftStyle()"} @{"SetAPen()" Link "SetAPen()"} @{"SetBPen()" Link "SetBPen()"} @{"SetDrMd()" Link "SetDrMd()"} SetOutLinePen()
  @{"SetWriteMask()" Link "SetWriteMask()"} @{"SetMaxPen()" Link "SetMaxPen()"} @{"GetRPAttrA()" Link "GetRPAttrA()"} graphics/rpattr.h
@EndNode
@Node "SetSoftStyle()" "graphics.library/SetSoftStyle"
@{b}@{u}SetSoftStyle@{uu}@{ub} -- Set the soft style of the current font.
  This function alters the soft style of the current font.Only
  those bits that are also set in enable are affected.The
  resulting style is returned, since some style request changes
  will not be honored when the implicit style of the font
  precludes changing them.
SYNOPSIS  ULONG SetSoftStyle(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, ULONG, ULONG);
  @{i}@{b}newStyle@{ub}@{ui} = SetSoftStyle(@{i}rp@{ui}, @{i}style@{ui}, @{i}enable@{ui})
   D0                      A1  D0      D1
  @{i}rp@{ui}     - the RastPort from which the font and style are extracted.
  @{i}style@{ui}  - the new font style to set, subject to enable.
  @{i}enable@{ui} - those bits in style to be changed.
    Any set bits here that would not be set as a result of @{"AskSoftStyle" Link "AskSoftStyle()"} will
    be ignored, and the newStyle result will not be as expected.
  @{i}@{b}newStyle@{ub}@{ui} - the resulting style, both as a result of previous
    soft style selection, the effect of this function,
    and the style inherent in the set font.
SEE ALSO
  @{"AskSoftStyle()" Link "AskSoftStyle()"}  @{"graphics/text.h" Link "include:graphics/text.h/Main" 0}
@EndNode
@Node "SetWriteMask()" "graphics.library/SetWriteMask"
@{b}@{u}SetWriteMask@{uu}@{ub} -- Set the pixel write mask value for a RastPort.@{FG fill}(V39)@{FG text}
  Set the current value of the bit write mask for the rastport.
  bits of the pixel with zeros in their mask will not be modified by
  subsequent drawing operations.
SYNOPSIS  ULONG SetWriteMask(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *,ULONG)
  @{i}@{b}success@{ub}@{ui}=SetWriteMask ( @{i}rp@{ui}, @{i}msk@{ui} )
   d0                     a0  d0
  @{i}rp@{ui} = a pointer to a valid RastPort structure.
  @{i}msk@{ui} = a longword mask value.
  @{i}@{b}success@{ub}@{ui} = Graphics devices which do not support per-bit masking
    will return 0 (failure).
SEE ALSO
  @{"graphics/gfxmacros.h" Link "include:graphics/gfxmacros.h/Main" 0}
@EndNode
@Node "SortGList()" "graphics.library/SortGList"
@{b}@{u}SortGList@{uu}@{ub} -- Sort the current gel list, ordering its y,x coordinates.
  Sorts the current gel list according to the gels' y,x coordinates.
  This sorting is essential before calls to @{"DrawGList" Link "DrawGList()"} or @{"DoCollision" Link "DoCollision()"}.
SYNOPSIS  @{FG shine}void@{FG text} SortGList(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *);
  SortGList(@{i}rp@{ui})
             A1
  @{i}rp@{ui} = pointer to the RastPort structure containing the @{"GelsInfo" Link "include:graphics/rastport.h/Main" 39}
SEE ALSO
  @{"InitGels()" Link "InitGels()"}  @{"DoCollision()" Link "DoCollision()"}  @{"DrawGList()" Link "DrawGList()"}  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "StripFont()" "graphics.library/StripFont"
@{b}@{u}StripFont@{uu}@{ub} -- remove the tf_Extension from a font.@{FG fill}(V36)@{FG text}
SYNOPSIS  @{FG shine}void@{FG text} StripFont(@{FG shine}struct@{FG text} @{"TextFont" Link "include:graphics/text.h/Main" 89} *);
  StripFont(@{i}font@{ui})
             A0
@EndNode
@Node "SyncSBitMap()" "graphics.library/SyncSBitMap"
@{b}@{u}SyncSBitMap@{uu}@{ub} -- Syncronize Super @{"BitMap" Link "include:graphics/gfx.h/Main" 46} with whatever is in the standard
  Layer bounds.
  Copy all bits from ClipRects in Layer into Super BitMap
  BitMap.This is used for those functions that do not
  want to deal with the @{"ClipRect" Link "include:graphics/clip.h/Main" 63} structures but do want
  to be able to work with a SuperBitMap Layer.
SYNOPSIS  @{FG shine}void@{FG text} SyncSBitMap( @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} * );
  SyncSBitMap( @{i}layer@{ui} )
                a0
  @{i}layer@{ui} - pointer to a Layer that has a SuperBitMap
    The Layer should already be locked by the caller.
NOTE
  After calling this function, the programmer can manipulate
  the bits in the superbitmap associated with the layer.
  Afterwards, the programmer should call @{"CopySBitMap" Link "CopySBitMap()"} to
  copy the bits back into the onscreen layer.
SEE ALSO
  @{"CopySBitMap()" Link "CopySBitMap()"} @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0}
@EndNode
@Node "Text()" "graphics.library/Text"
@{b}@{u}Text@{uu}@{ub} -- Write text characters (no formatting).
  This graphics function writes printable text characters to the specified
  RastPort at the current position.No control meaning is applied to any of
  the characters, thus only text on the current line is output.
  The current position in the RastPort is updated to the next character position.
  If the characters displayed run past the RastPort boundary, the current
  position is truncated to the boundary, and thus does not equal the old
  position plus the text length.
SYNOPSIS  @{FG shine}void@{FG text} Text(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, STRPTR, WORD);
  Text(@{i}rp@{ui}, @{i}string@{ui}, @{i}length@{ui})
        A1  A0       D0-0:16
  @{i}rp@{ui} - a pointer to the RastPort which describes where the text is to be output
  @{i}string@{ui} - the address of string to output
  @{i}length@{ui} - the number of characters in the string.
    If zero, there are no characters to be output.
NOTES
  o This function may use the blitter.
  o Changing the text direction with RastPort->TxSpacing is not supported.
BUGS
  For V34 and earlier:
  o The maximum string length (in pixels) is limited to
    (1024 - 16 = 1008) pixels wide.
  o A text string whose last character(s) have a tf_CharLoc size component
    that extends to the right of the rightmost of the initial and final
    CP positions will be (inappropriately) clipped.
SEE ALSO
  @{"Move()" Link "Move()"}  @{"TextLength()" Link "TextLength()"}  @{"graphics/text.h" Link "include:graphics/text.h/Main" 0}  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "TextExtent()" "graphics.library/TextExtent"
@{b}@{u}TextExtent@{uu}@{ub} -- Determine raster extent of text data.@{FG fill}(V36)@{FG text}
  This function determines a more complete metric of the space
  that a text string would render into than the @{"TextLength()" Link "TextLength()"} function.
SYNOPSIS  @{FG shine}void@{FG text} textExtent(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *,STRPTR,WORD,@{FG shine}struct@{FG text} @{"TextExtent" Link "include:graphics/text.h/Main" 165} *);
  TextExtent(@{i}rp@{ui}, @{i}string@{ui}, @{i}count@{ui}, @{i}textExtent@{ui})
              A1  A0      D0:16   A2
  @{i}rp@{ui} - a pointer to the RastPort which describes where the text attributes reside
  @{i}string@{ui} - the address of the string to determine the length of
  @{i}count@{ui}  - the number of characters in the string.
    If zero, there are no characters in the string.
  @{"textExtent" link TEXTEXTENT_TEXTEXTENT} - a structure to hold the result.
SEE ALSO
  @{"TextLength()" Link "TextLength()"}  @{"Text()" Link "Text()"}  @{"TextFit()" Link "TextFit()"}
  @{"graphics/text.h" Link "include:graphics/text.h/Main" 0}  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@node TEXTEXTENT_TEXTEXTENT "TextExtent_TextExtent"
@{i}@{b}te_Width@{ub}@{ui}  - same as @{"TextLength()" Link "TextLength()"}
  result: the rp_cp_x advance that rendering this text would cause.
@{i}@{b}te_Height@{ub}@{ui} - same as tf_YSize.The height of the font.
te_Extent.@{i}@{b}MinX@{ub}@{ui} - the offset to the left side of the rectangle
  this would render into.Often zero.
te_Extent.@{i}@{b}MinY@{ub}@{ui} - same as -tf_Baseline.
  The offset from the baseline to the top of the rectangle
  this would render into.
te_Extent.@{i}@{b}MaxX@{ub}@{ui} - the offset of the left side of the
  rectangle this would render into.Often the same as te_Width-1.
te_Extent.@{i}@{b}MaxY@{ub}@{ui} - same as tf_YSize-tf_Baseline-1.
  The offset from the baseline to the bottom of
  the rectangle this would render into.
@endnode
@Node "TextFit()" "graphics.library/TextFit"
@{b}@{u}TextFit@{uu}@{ub} - count characters that will fit in a given extent.@{FG fill}(V36)@{FG text}
  This function determines how many of the characters of the provided string
  will fit into the space described by the constraining parameters.
  It also returns the extent of that number of characters.
SYNOPSIS
  ULONG TextFit(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, STRPTR, UWORD, @{FG shine}struct@{FG text} @{"TextExtent" Link "include:graphics/text.h/Main" 165} *,
    @{FG shine}struct@{FG text} TextExtent *, WORD, UWORD, UWORD);
  @{i}@{b}chars@{ub}@{ui} = TextFit(@{i}rastport@{ui}, @{i}string@{ui}, @{i}strLen@{ui}, @{i}textExtent@{ui}, @{i}constrainingExtent@{ui},
   D0              A1        A0       D0      A2          A3
  @{i}strDirection@{ui}, @{i}constrainingBitWidth@{ui}, @{i}constrainingBitHeight@{ui})
   D1            D2                     D3
  @{i}rp@{ui} - a pointer to the RastPort which describes where the
    text attributes reside.
  @{i}string@{ui} - the address of string to determine the constraint of
  @{i}strLen@{ui} - The number of characters in the string.
    If zero, there are no characters in the string.
  @{i}textExtent@{ui} - a structure to hold the extent result.
  @{i}constrainingExtent@{ui} - the extent that the text must fit in.This can be NULL, #
    indicating only the constrainingBit dimensions will describe the constraint.
  @{i}strDirection@{ui} - the offset to add to the string pointer to get to the next
    character in the string.Usually 1.
    Set to -1 and the string to the end of the string to perform a
    TextFit() anchored at the end.No other value is valid.
  @{i}constrainingBitWidth@{ui} - an alternative way to specify the rendering box
    constraint width that is independent of the rendering origin.Range 0..32767.
  @{i}constrainingBitHeight@{ui} - an alternative way to specify the rendering box
    constraint height that is independent of the rendering origin.Range 0..32767.
  @{i}@{b}chars@{ub}@{ui} - the number of characters from the origin of the given string
    that will fit in both the constraining extent
    (which specifies a CP bound and a rendering box relative to the origin)
    and in the rendering width and height specified.
NOTES
  The result is zero chars and an empty textExtent when the fit
  cannot be performed.This occurs not only when no text will
  fit in the provided constraints, but also when:
  - the RastPort rp's rp_TxSpacing sign and magnitude is so
    great it reverses the path of the text.
  - the constrainingExtent does not include x = 0.
BUGS
  Under V37, TextFit() would return one too few characters if the
  font was proportional.This can be worked around by passing
  (constrainingBitWidth + 1) for proportional fonts.This is fixed for V39.
SEE ALSO
  @{"TextExtent()" Link "TextExtent()"}  @{"TextLength()" Link "TextLength()"}  @{"Text()" Link "Text()"}
  @{"graphics/text.h" Link "include:graphics/text.h/Main" 0}  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "TextLength()" "graphics.library/TextLength"
@{b}@{u}TextLength@{uu}@{ub} -- Determine raster length of text data.
  This graphics function determines the length that text data would occupy if
  output to the specified RastPort with the current attributes.The length is
  specified as the number of raster dots: to determine what the current position
  would be after a @{"Text()" Link "Text()"} using this string, add the length to cp_x (cp_y is
  unchanged by @{"Text()" Link "Text()"}).Use the newer @{"TextExtent()" Link "TextExtent()"} to get more information.
SYNOPSIS  WORD TextLength(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, STRPTR, WORD);
  @{i}@{b}length@{ub}@{ui} = TextLength(@{i}rp@{ui}, @{i}string@{ui}, @{i}count@{ui})
   D0                  A1   A0      D0:16
  @{i}rp@{ui} - a pointer to the RastPort which describes where the text attributes reside
  @{i}string@{ui} - the address of string to determine the length of
  @{i}count@{ui} - the string length.If zero, there are no characters in the string.
  @{i}length@{ui} - the number of pixels in x this text would occupy, not including any
    negative kerning that may take place at the beginning of the text string,
    nor taking into account the effects of any clipping that may take place.
NOTES
  Prior to V36, the result length occupied only the low word of d0 and
  was not sign extended into the high word.
BUGS
  A length that would overflow single word arithmetic isn't calculated correctly.
SEE ALSO
  @{"TextExtent()" Link "TextExtent()"} @{"Text()" Link "Text()"} @{"TextFit()" Link "TextFit()"} @{"graphics/text.h" Link "include:graphics/text.h/Main" 0} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "UnlockLayerRom()" "graphics.library/UnlockLayerRom"
@{b}@{u}UnlockLayerRom@{uu}@{ub} -- Unlock Layer structure by ROM(gfx lib) code.
  Release the lock on this layer.If the same task has called
  @{"LockLayerRom" Link "LockLayerRom()"} more than once than the same number of calls to
  UnlockLayerRom must happen before the layer is actually freed
  so that other tasks may use it.
  This call does destroy scratch registers.
  This call is identical to @{"UnlockLayer" Link "ROMlibs.guide/UnlockLayer()"} (layers.library).
SYNOPSIS  @{FG shine}void@{FG text} UnlockLayerRom( @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} * );
  UnlockLayerRom( @{i}layer@{ui} )
                   a5
  @{i}layer@{ui} - pointer to Layer structure
SEE ALSO
  @{"LockLayerRom()" Link "LockLayerRom()"} @{"layers.library/UnlockLayer()" Link "ROMlibs.guide/UnlockLayer()"} @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0}
@EndNode
@Node "VBeamPos()" "graphics.library/VBeamPos"
@{b}@{u}VBeamPos@{uu}@{ub} -- Get vertical beam position at this instant.
  Get the vertical beam position from the hardware.
SYNOPSIS  @{FG shine}long@{FG text} VBeamPos( @{FG shine}void@{FG text} );
  @{i}@{b}pos@{ub}@{ui} = VBeamPos()
   d0
  @{i}@{b}pos@{ub}@{ui} - interrogates hardware for beam position and returns value.
    Valid results are in the range of 0-511.Because of multitasking, the actual
    value returned may have no use.If you are the highest priority task then the
    value returned should be close, within 1 line.
@EndNode
@Node "VideoControl()" "graphics.library/VideoControl"
@{b}@{u}VideoControl@{uu}@{ub} -- Modify the operation of a ViewPort's ColorMap.@{FG fill}(V36)@{FG text}
@{b}@{u}VideoControlTags@{uu}@{ub} -- varargs stub for VideoControl.@{FG fill}(V36)@{FG text}
  Process the commands in the VideoControl command TagItem buffer
  using cm as the target, with respect to its "attached" @{"ViewPort" Link "include:graphics/view.h/Main" 40}.
  The operating characteristics of the ColorMap and its attached
  ViewPort are modified.The result will be incorporated into the
  ViewPort when its copper lists are reassembled via @{"MakeVPort()" Link "MakeVPort()"}.
  Note that you must NOT change colors in the viewport (via @{"SetRGB4()" Link "SetRGB4()"},
  @{"LoadRGB4()" Link "LoadRGB4()"}, @{"SetRGB4()" Link "SetRGB4()"}, etc.) after changing any of the color palette
  offsets (VTAG_PF1_BASE, etc), without first remaking the ViewPort.
SYNOPSIS  ULONG VideoControl( @{FG shine}struct@{FG text} @{"ColorMap" Link "include:graphics/view.h/Main" 143} *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} * );
  @{i}@{b}error@{ub}@{ui} = VideoControl( @{i}cm@{ui} , @{i}tags@{ui} )
   d0                    a0   a1
  @{i}@{b}error@{ub}@{ui}= VideoControlTags(@{i}cm@{ui}, @{i}tags@{ui},...);
  @{i}cm@{ui}   = pointer to @{FG shine}struct@{FG text} ColorMap obtained via @{"GetColorMap()" Link "GetColorMap()"}.
  @{i}tags@{ui} = pointer to a table of videocontrol tagitems.
@{"viewport commands" link VIDEOCONTROL_VIEWPORTCOMMANDS} @{"genlock commands" link VIDEOCONTROL_GENLOCKCOMMANDS} @{"other commands" link VIDEOCONTROL_OTHERCOMMANDS}
  @{i}@{b}error@{ub}@{ui} = NULL if no error occurred in the control operation.
    (non-NULL if bad colormap pointer, no tagitems or bad tag)
NOTES
  Sprite resolutions is controlled by two sets of tags, SPRITERESN
  and DEFSPRITERESN.If you don't set the sprite resolution, it will
  follow the intuition-controlled "default" sprite resolution.Setting
  the sprite resolution to one of the SPRITERESN_ values will allow the
  application to override intuition's control of it.
  This function will modify the contents of the TagList you pass to it by
  changing _GET tags to the corresponding _SET or _CLR tag.The exceptions
  to this rule are documented as such above (such as VTAG_IMMEDIATE).
  The new tags added for @{b}(V40)@{ub} have the prefix VC_ instead of VTAG_.These
  tags work in the same manner as all other tags in the system, and will
  not be modified by VideoControl().
EXAMPLE
  @{i}must_remake@{ui}=-1;
  @{i}error@{ui}=VideoControl(myvp->@{i}ColorMap@{ui},VTAG_BORDERBLANK_SET,-1,
    (GFXBase->@{i}lib_Version@{ui}>=39)?VTAG_IMMEDIATE:TAG_IGNORE, @{i}&must_remake@{ui});
  @{FG shine}if@{FG text} (@{i}must_remake@{ui}) { MakeVPort(@{i}myview@{ui},@{i}myvp@{ui}); MrgCop(@{i}myview@{ui}); }
EXAMPLE
  @{FG shine}struct@{FG text} TagItem @{i}VCTags@{ui}[] = {
    {VTAG_BORDERBLANK_GET, NULL}, {VTAG_SPRITERESN_SET, SPRITERESN_35NS},
    {TAG_DONE, NULL}
  };
  BOOL @{i}bblank@{ui} = FALSE;
  @{FG shine}if@{FG text} (VideoControl(@{i}cm@{ui}, @{i}VCTags@{ui}) == NULL)
    @{i}bblank@{ui} = (VCTags[0].@{i}ti_Tag@{ui} == VTAG_BORDERBLANK_SET);
EXAMPLE
  @{FG shine}struct@{FG text} TagItem @{i}VCTags@{ui}[] = {
    {@{i}VC_NoColorPaletteLoad_Query@{ui}, NULL},{TAG_DONE}
  };
  ULONG @{i}query@{ui};
  VCTags[0].@{i}ti_Data@{ui} = (ULONG)@{i}&query@{ui};
  @{FG shine}if@{FG text} (VideoControl(@{i}cm@{ui}, @{i}VCTags@{ui}) == NULL)
    printf("Palette loading is %s\n", (query ? "off" : "on"));
SEE ALSO
  @{"graphics/videocontrol.h" Link "include:graphics/videocontrol.h/Main" 0}, @{"GetColorMap()" Link "GetColorMap()"}, @{"FreeColorMap()" Link "FreeColorMap()"}
@EndNode
@node VIDEOCONTROL_VIEWPORTCOMMANDS "VideoControl_viewportcommands"
@{i}VTAG_ATTACH_CM@{ui}     [_SET | _GET] - set/get attached viewport
@{i}VTAG_VIEWPORTEXTRA@{ui} [_SET | _GET] - set/get attached vp_extra
@{i}VTAG_NORMAL_DISP@{ui}   [_SET | _GET] - set/get DisplayInfoHandle (natural mode)
@{i}VTAG_COERCE_DISP@{ui}   [_SET | _GET] - set/get DisplayInfoHandle (coerced mode)
@{i}VTAG_PF1_BASE@{ui}      [_SET | _GET] - set/get color base for first playfield @{FG fill}(V39)@{FG text}
@{i}VTAG_PF2_BASE@{ui}      [_SET | _GET] - set/get color base for second playfield @{FG fill}(V39)@{FG text}
@{i}VTAG_SPODD_BASE@{ui}    [_SET | _GET] - set/get color base for odd sprites @{FG fill}(V39)@{FG text}
@{i}VTAG_SPEVEN_BASE@{ui}   [_SET | _GET] - set/get color base for even sprites @{FG fill}(V39)@{FG text}
@{i}VTAG_BORDERSPRITE@{ui}  [_SET | _CLR | _GET] - on/off/inquire sprites in borders @{FG fill}(V39)@{FG text}
@{i}VTAG_DEFSPRITERESN@{ui} [_SET | _GET] - set/get default sprite resolution
@{i}VTAG_SPRITERESN@{ui}    [_SET | _GET] - set/get sprite resolution
  Legal values are SPRITERESN_ECS/_140NS/_70NS/_35NS,see  @{"graphics/view.h)" Link "include:graphics/view.h/Main" 0} @{FG fill}(V39)@{FG text}
@{i}VTAG_PF1_TO_SPRITEPRI@{ui} [_SET | _GET] - set/get playfield1 priority with respect
  to sprites @{FG fill}(V39)@{FG text}
@{i}VTAG_PF2_TO_SPRITEPRI@{ui} [_SET | _GET] - set/get playfield2 priority with respect
  to sprites @{FG fill}(V39)@{FG text}
(These two require that the ColorMap is attached to a ViewPort to be effective).
@endnode
@node VIDEOCONTROL_GENLOCKCOMMANDS "VideoControl_genlockcommands"
@{i}VTAG_BORDERBLANK@{ui}   [_SET | _CLR | _GET] - on/off/inquire blanking
@{i}VTAG_BORDERNOTRANS@{ui} [_SET | _CLR | _GET] - on/off/inquire notransparency
@{i}VTAG_CHROMAKEY@{ui}     [_SET | _CLR | _GET] - on/off/inquire chroma mode
@{i}VTAG_BITPLANEKEY@{ui}   [_SET | _CLR | _GET] - on/off/inquire bitplane mode
@{i}VTAG_CHROMA_PEN@{ui}    [_SET | _CLR | _GET] - set/clr/get chromakey pen #
@{i}VTAG_CHROMA_PLANE@{ui}  [_SET |      | _GET] - set/get bitplanekey plane #
@{i}VTAG_IMMEDIATE@{ui} - normally, VideoControl changes do not occur until the next
  @{"MakeVPort" Link "MakeVPort()"}.Using this tag, some changes can be made to happen immediately.
  The tag data is a pointer to a longword flag variable which will be cleared if
  all changes happened immediately.See the example.@{FG fill}(V39)@{FG text}
@{i}VTAG_FULLPALETTE@{ui} [_SET | _CLR | _GET] - enable/disable loading of all colors
  in the copper list.Normally, graphics will only load the colors which are
  necessary for the viewport, based upon the screen depth and mode.In order
  to use the color palette banking features, you may need to use this tag to
  tell graphics to load ALL colors, regardless of screen depth.@{FG fill}(V39)@{FG text}
@{i}VC_IntermediateCLUpdate@{ui}, @{i}VC_IntermediateCLUpdate_Query@{ui} - When set, graphics will
  update the intermediate copper lists on colour changes.
  When FALSE, graphics won't update the intermediate copperlists, so
  @{"ScrollVPort()" Link "ScrollVPort()"}, @{"ChangeVPBitMap()" Link "ChangeVPBitMap()"} and colour loading functions will be faster.
  This value is TRUE by default.@{b}(V40)@{ub}
@{i}VC_NoColorPaletteLoad@{ui}, @{i}VC_NoColorPaletteLoad_Query@{ui} - When set, only colour 0
  will be loaded for this @{"ViewPort" Link "include:graphics/view.h/Main" 40}, hence the inter-ViewPort gap will be smaller.
  The colours for this ViewPort are inherited from the next higher ViewPort.
  The results are undefined if this is the first or only ViewPort in the display,
  and undefined when used in conjunction with @{i}VTAG_FULLPALETTE@{ui} (!?!).
  This value is FALSE by default.@{b}(V40)@{ub}
@{i}VC_DUALPF_Disable@{ui}, @{i}VC_DUALPF_Disable_Query@{ui} - When set, disables the setting of
  the dual-playfield bit in bplcon0.When used with a dual-playfield mode screen,
  this allows using separate scroll and bitmaps for the odd and even bitplanes,
  without going through the normal dual-playfield priority and palette selection.
  With appropriate palette setup, this can be used for transparency effects, etc.
  @{b}(V40)@{ub}
@endnode
@node VIDEOCONTROL_OTHERCOMMANDS "VideoControl_othercommands"
@{b}@{u}copper commands:@{uu}@{ub}
  @{i}VTAG_USERCLIP@{ui} [_SET | _CLR | _GET] -- on/off/inquire clipping of
    UserCopperList at bottom edge of ColorMap->cm_vp (defaults to off)
@{b}@{u}buffer commands:@{uu}@{ub}
  @{i}VTAG_NEXTBUF_CM@{ui} - link to more VTAG commands
  @{i}VTAG_END_CM@{ui} - terminate command buffer
@{b}@{u}batch mode commands:@{uu}@{ub}
  (if you want your videocontrol taglist to be processed in "batch" mode,
  that is, at the next @{"MakeVPort()" Link "MakeVPort()"} for the ColorMap->cm_vp;
  you may install a static list of videocontrol TagItems into the 
  ColorMap with the BATCH_ITEMS_SET command; and then enable/disable
  batch mode processing of those items via the BATCH_CM control command)
  @{i}VTAG_BATCH_CM@{ui}    [_SET | _CLR | _GET] - on/off/inquire batch mode
  @{i}VTAG_BATCH_ITEMS@{ui} [_SET | _ADD | _GET] - set/add/get batched TagLists
@{b}@{u}private commands@{uu}@{ub} (used internally by intuition - do not call):
  @{i}VTAG_VPMODEID@{ui}    [_SET | _CLR | _GET] - force @{"GetVPModeID()" Link "GetVPModeID()"} return
@endnode
@Node "WaitBlit()" "graphics.library/WaitBlit"
@{b}@{u}WaitBlit@{uu}@{ub} -- Wait for the blitter to be finished before proceeding with
  anything else.
  WaitBlit returns when the blitter is idle.This function should normally only
  be used when dealing with the blitter in a synchronous manner, such as when
  using @{"OwnBlitter" Link "OwnBlitter()"} and @{"DisownBlitter" Link "DisownBlitter()"}.WaitBlit does not wait for all blits
  queued up using @{"QBlit" Link "QBlit()"} or @{"QBSBlit" Link "QBSBlit()"}.You should call WaitBlit if you are just
  about to modify or free some memory that the blitter may be using.
SYNOPSIS  @{FG shine}void@{FG text} WaitBlit( @{FG shine}void@{FG text} );
  WaitBlit()
  Your program waits until the blitter is finished.
NOTES
  This routine does not use any the CPU registers. do/d1/a0/a1 are preserved by
  this routine.It may change the condition codes though.
BUGS
  When examining bits with the CPU right after a blit, or when freeing
  temporary memory used by the blitter, a WaitBlit() may be required.
  Note that many graphics calls fire up the blitter, and let it run.
  The CPU does not need to wait for the blitter to finish before returning.
  Because of a bug in Agnus (prior to all revisions of fat Agnus)
  this code may return too soon when the blitter has, in fact, not started
  the blit yet, even though BltSize has been written.This most often occurs
  in a heavily loaded system with extended memory, HIRES, and 4 bitplanes.
  WaitBlit currently tries to avoid this Agnus problem by testing
  the BUSY bit multiple times to make sure the blitter has started.
  If the blitter is BUSY at first check, this function busy waits.
  This initial hardware bug was fixed as of the first "Fat Agnus" chip, 
  as used in all A500 and A2000 computers.
  Because of a different bug in Agnus (currently all revisions thru ECS)
  this code may return too soon when the blitter has, in fact, not 
  stopped the blit yet, even though blitter busy has been cleared.
  This most often occurs in a heavily loaded system with extended memory,
  in PRODUCTIVITY mode, and 2 bitplanes.
  WaitBlit currently tries to avoid this Agnus problem by testing
  the BUSY bit multiple times to make sure the blitter has really
  written its final word of destination data.
SEE ALSO
  @{"OwnBlitter()" Link "OwnBlitter()"} @{"DisownBlitter()" Link "DisownBlitter()"} @{"hardware/blit.h" Link "include:hardware/blit.h/Main" 0}
@EndNode
@Node "WaitBOVP()" "graphics.library/WaitBOVP"
@{b}@{u}WaitBOVP@{uu}@{ub} -- Wait till vertical beam reached bottom of this viewport.
  Returns when the vertical beam has reached the bottom of this viewport
SYNOPSIS  @{FG shine}void@{FG text} WaitBOVP( @{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} * );
  WaitBOVP( @{i}vp@{ui} )
             a0
  @{i}vp@{ui} - pointer to ViewPort structure
  This function will return sometime after the beam gets beyond
  the bottom of the viewport.Depending on the multitasking load
  of the system, the actual beam position may be different than
  what would be expected in a lightly loaded system.
BUGS
  Horrors! This function currently busy waits waiting for the
  beam to get to the right place.It should use the copper
  interrupt to trigger and send signals like @{"WaitTOF" Link "WaitTOF()"} does.
SEE ALSO
  @{"WaitTOF()" Link "WaitTOF()"} @{"VBeamPos()" Link "VBeamPos()"}
@EndNode
@Node "WaitTOF()" "graphics.library/WaitTOF"
@{b}@{u}WaitTOF@{uu}@{ub} -- Wait for the top of the next video frame.
  Wait  for vertical blank to occur and all vertical blank
  interrupt routines to complete before returning to caller.
SYNOPSIS  @{FG shine}void@{FG text} WaitTOF( @{FG shine}void@{FG text} );
  WaitTOF()
  Places this task on the TOF wait queue.When the vertical blank
  interrupt comes around, the interrupt service routine will fire off
  signals to all the tasks doing WaitTOF.The highest priority task
  ready will get to run then.
SEE ALSO
  @{"exec.library/Wait()" Link "exec.guide/Wait()"} @{"exec.library/Signal()" Link "exec.guide/Signal()"}
@EndNode
@Node "WriteChunkyPixels()" "graphics.library/WriteChunkyPixels"
@{b}@{u}WriteChunkyPixels@{uu}@{ub} -- write the pen number value of a rectangular array
  of pixels starting at a specified x,y location and continuing
  through to another x,y location within a certain RastPort.@{b}(V40)@{ub}
  For each pixel in a rectangular region, decode the pen number selector
  from a linear array of pen numbers into the bit-planes used to describe
  a particular rastport.
SYNOPSIS
  @{FG shine}void@{FG text} WriteChunkyPixels(@{FG shine}struct@{FG text}  @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *,@{FG shine}long@{FG text},@{FG shine}long@{FG text},@{FG shine}long@{FG text},@{FG shine}long@{FG text},UBYTE *,@{FG shine}long@{FG text});
  WriteChunkyPixels(@{i}rp@{ui},@{i}xstart@{ui},@{i}ystart@{ui},@{i}xstop@{ui},@{i}ystop@{ui},@{i}array@{ui},@{i}bytesperrow@{ui})
                     A0 D0      D1     D2    D3    A2     D4
  @{i}rp@{ui} -  pointer to a RastPort structure
  (@{i}xstart@{ui},@{i}ystart@{ui}) -  starting point in the RastPort
  (@{i}xstop@{ui},@{i}ystop@{ui}) -  stopping point in the RastPort
  @{i}array@{ui} - pointer to an array of UBYTEs from which to fetch the pixel data.
  @{i}bytesperrow@{ui} - The number of bytes per row in the source array.
    This should be at least as large as the number of pixels
    being written per line.
NOTES
  xstop must be >= xstart, ystop must be >= ystart
  The source array can be in fast RAM.
@{"chunky-to-planar conversion HW" link CHUNKY-TO-PLANAR_CONVERSION_HW}
BUGS
  Not very fast on systems without chunky-to-planar conversion hardware.
SEE ALSO
  @{"WritePixel()" Link "WritePixel()"}  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@node CHUNKY-TO-PLANAR_CONVERSION_HW "chunky-to-planar_conversion_HW"
GfxBase->@{i}@{b}ChunkyToPlanarPtr@{ub}@{ui} is either NULL, or a pointer to a HW register used
to aid in the process of converting 8-bit chunky pixel data into the bit-plane
format used by the Amiga custom display chips.
If NULL, then such hardware is not present.
If an expansion device provides hardware which operates compatibly, than it can
install the HW address into this pointer at boot time,and the system will use it.
This pointer may be used for direct access to the chunky-to-planar conversion HW,
if more is desired than the straight chunky-pixel copy that is performed by
WriteChunkyPixels().If using the hardware directly, it should only be accessed
when the task using it has control of the blitter (via @{"OwnBlitter()" Link "OwnBlitter()"}), since
this is the locking used to arbitrate usage of this device.
The hardware may be viewed as a device which accepts 32 8-bit chunky pixels and
outputs 8 longwords of bitplane data.
For proper operation, exactly 8 longwords (containing 32 pixels) of chunky data
should be written to *(GfxBase->@{i}@{b}ChunkyToPlanarPtr@{ub}@{ui}).After the data is written,
bitplane data (starting with plane 0) can be read back a longword at a time.
There is no need to read back all 8 longwords if the high-order bitplanes are
not needed.
Since WriteChunkyPixels is not (currently) particularly fast on systems without
the chunky-to-planar hardware, time critical applications (games, etc) may want
to use their own custom conversion routine if GfxBase->@{i}@{b}ChunkyToPlanarPtr@{ub}@{ui} is NULL,
and call WriteChunkyPixels() otherwise.
This pointer is only present in @{"GfxBase" Link "include:graphics/gfxbase.h/Main" 24} in versions of graphics.library >= @{b}40@{ub},
so this should be checked before the pointer is read.
@endnode
@Node "WritePixel()" "graphics.library/WritePixel"
@{b}@{u}WritePixel@{uu}@{ub} -- Change the pen num of one specific pixel in a specified RastPort.
  Changes the pen number of the selected pixel in the specified
  RastPort to that currently specified by PenA, the primary
  drawing pen.Obeys minterms in RastPort.
SYNOPSIS  @{FG shine}long@{FG text} WritePixel( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, SHORT, SHORT );
   @{i}@{b}error@{ub}@{ui} = WritePixel( @{i}rp@{ui}, @{i}x@{ui},  @{i}y@{ui})
    d0                  a1  D0   D1
  @{i}rp@{ui} - a pointer to the RastPort structure
  (@{i}x@{ui},@{i}y@{ui}) - point within the RastPort at which the selected pixel is located.
  @{i}@{b}error@{ub}@{ui} = 0 if pixel succesfully changed, -1 if (x,y) is outside the RastPort
SEE ALSO
  @{"ReadPixel()" Link "ReadPixel()"} @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "WritePixelArray8()" "graphics.library/WritePixelArray8"
@{b}@{u}WritePixelArray8@{uu}@{ub} -- write the pen number value of a rectangular array
  of pixels starting at a specified x,y location and continuing
  through to another x,y location within a certain RastPort.@{FG fill}(V36)@{FG text}
  For each pixel in a rectangular region, decode the pen number selector
  from a linear array of pen numbers into the bit-planes used to describe
  a particular rastport.
SYNOPSIS
  @{FG shine}long@{FG text} WritePixelArray8(@{FG shine}struct@{FG text}  @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, UWORD, UWORD, UWORD, UWORD, UBYTE *,
    @{FG shine}struct@{FG text}  RastPort *);
  @{i}@{b}count@{ub}@{ui} = WritePixelArray8(@{i}rp@{ui},@{i}xstart@{ui},@{i}ystart@{ui},@{i}xstop@{ui},@{i}ystop@{ui},@{i}array@{ui},@{i}temprp@{ui})
   D0                       A0 D0:16   D1:16  D2:16 D3:16  A2    A1
  @{i}rp@{ui} -  pointer to a RastPort structure
  (@{i}xstart@{ui},@{i}ystart@{ui}) -  starting point in the RastPort
  (@{i}xstop@{ui},@{i}ystop@{ui}) -  stopping point in the RastPort
  @{i}array@{ui} - pointer to an array of UBYTEs from which to fetch the pixel data.
    Allocate at least ((((width+15)>>4)<<4)*(ystop-ystart+1)) bytes.
  @{i}temprp@{ui} - temporary rastport (copy of rp with Layer set == NULL,
    temporary memory allocated for temprp->BitMap with Rows set == 1,
    temprp->BytesPerRow == (((width+15)>>4)<<1),
    and temporary memory allocated for temprp->BitMap->Planes[])
  @{i}@{b}count@{ub}@{ui} - will be set to the number of pixels plotted.
NOTE
  xstop must be >= xstart, ystop must be >= ystart
SEE ALSO
  @{"WritePixel()" Link "WritePixel()"}  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "WritePixelLine8()" "graphics.library/WritePixelLine8"
@{b}@{u}WritePixelLine8@{uu}@{ub} - write the pen number value of a horizontal line of pixels,star-
  ting at a specified x,y location and continuing right for count pixels.@{FG fill}(V36)@{FG text}
  For each pixel in a horizontal region, decode the pen number selector
  from a linear array of pen numbers into the bit-planes used to describe
  a particular rastport.
SYNOPSIS
  @{FG shine}long@{FG text} WritePixelLine8(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, UWORD, UWORD, UWORD, UBYTE *,
    @{FG shine}struct@{FG text} RastPort *);
  @{i}@{b}count@{ub}@{ui} = WritePixelLine8(@{i}rp@{ui},@{i}xstart@{ui},@{i}ystart@{ui},@{i}width@{ui},@{i}array@{ui},@{i}temprp@{ui})
   D0                      A0 D0:16   D1:16  D2     A2    A1
  @{i}rp@{ui}    -  pointer to a RastPort structure
  (@{i}xstart@{ui},@{i}ystart@{ui}) - a point in the RastPort
  @{i}width@{ui} - count of horizontal pixels to write
  @{i}array@{ui} - pointer to an array of UBYTEs from which to fetch the pixel data.
    Allocate at least (((width+15)>>4)<<4) bytes.
  @{i}temprp@{ui} - temporary rastport (copy of rp with Layer set == NULL,
    temporary memory allocated for temprp->BitMap with Rows set == 1,
    temprp->BytesPerRow == (((width+15)>>4)<<1),
    and temporary memory allocated for temprp->BitMap->Planes[])
  @{i}@{b}Count@{ub}@{ui} - will be set to the number of pixels plotted
NOTE
  width must be non negative.
SEE ALSO
  @{"WritePixel()" Link "WritePixel()"}  @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}
@EndNode
@Node "XorRectRegion()" "graphics.library/XorRectRegion"
@{b}@{u}XorRectRegion@{uu}@{ub} -- Perform 2d XOR operation of rectangle with region, leaving
  result in region.
  Add portions of rectangle to region if they are not in the region.
  Remove portions of rectangle from region if they are in the region.
SYNOPSIS  BOOL XorRectRegion( @{FG shine}struct@{FG text} @{"Region" Link "include:graphics/regions.h/Main" 28} *, @{FG shine}struct@{FG text} @{"Rectangle" Link "include:graphics/gfx.h/Main" 27} * );
  @{i}@{b}status@{ub}@{ui} = XorRectRegion(@{i}region@{ui},@{i}rectangle@{ui})
   d0                     a0     a1
  @{i}region@{ui} - pointer to Region structure
  @{i}rectangle@{ui} - pointer to Rectangle structure
  @{i}@{b}status@{ub}@{ui} - return TRUE if successful operation,
    return FALSE if ran out of memory
SEE ALSO
  @{"OrRegionRegion()" Link "OrRegionRegion()"} @{"AndRegionRegion()" Link "AndRegionRegion()"} @{"graphics/regions.h" Link "include:graphics/regions.h/Main" 0}
@EndNode
@Node "XorRegionRegion()" "graphics.library/XorRegionRegion"
@{b}@{u}XorRegionRegion@{uu}@{ub} -- Perform 2d XOR operation of one region with second region,
  leaving result in second region.
  Join the regions together.If any part of region1 overlaps region2 then
  remove that from the new region.
SYNOPSIS  BOOL XorRegionRegion( @{FG shine}struct@{FG text} @{"Region" Link "include:graphics/regions.h/Main" 28} *, @{FG shine}struct@{FG text} Region * );
  @{i}@{b}status@{ub}@{ui} = XorRegionRegion(@{i}region1@{ui},@{i}region2@{ui})
   d0                       a0      a1
  @{i}region1@{ui} = pointer to Region structure
  @{i}region2@{ui} = pointer to Region structure
  @{i}@{b}status@{ub}@{ui} - return TRUE if successful operation,
    return FALSE if ran out of memory
@EndNode

