@database "intuition"
@master "Work:Programing/sc/OS3.1_Docs/doc/intuition.doc"

@Node Main "intuition.doc"
@{b}@{u}Windows@{uu}@{ub}:                                  @{b}@{u}Gadgets@{uu}@{ub}:          @{b}@{u}Requesters@{uu}@{ub}:
@{"OpenWindow()" Link "OpenWindow()"}       @{"WindowToFront()" Link "WindowToFront()"}      @{"AddGList()" Link "AddGList()"}       @{"InitRequester()" Link "InitRequester()"}
@{"OpenWindowTagList()" Link "OpenWindowTagList()"}@{"MoveWindowInFrontOf()" Link "MoveWindowInFrontOf()"}@{"SetGadgetAttrsA()" Link "SetGadgetAttrsA()"}@{"SetDMRequest()" Link "SetDMRequest()"}
@{"SetWindowTitles()" Link "SetWindowTitles()"}  @{"WindowToBack()" Link "WindowToBack()"}       @{"AddGadget()" Link "AddGadget()"}      @{"BuildSysRequest()" Link "BuildSysRequest()"}
@{"WindowLimits()" Link "WindowLimits()"}     @{"ScrollWindowRaster()" Link "ScrollWindowRaster()"} @{"ObtainGIRPort()" Link "ObtainGIRPort()"}  @{"AutoRequest()" Link "AutoRequest()"}
@{"ModifyIDCMP()" Link "ModifyIDCMP()"}      @{"MoveWindow()" Link "MoveWindow()"}         @{"OnGadget()" Link "OnGadget()"}       @{"BuildEasyRequestArgs()" Link "BuildEasyRequestArgs()"}
@{"ViewAddress()" Link "ViewAddress()"}      @{"SizeWindow()" Link "SizeWindow()"}         @{"ActivateGadget()" Link "ActivateGadget()"} @{"EasyRequestArgs()" Link "EasyRequestArgs()"}
@{"ViewPortAddress()" Link "ViewPortAddress()"}  @{"ChangeWindowBox()" Link "ChangeWindowBox()"}    @{"HelpControl()" Link "HelpControl()"}    @{"Request()" Link "Request()"}
@{"SetWindowPointerA()" Link "SetWindowPointerA()"}@{"ZipWindow()" Link "ZipWindow()"}          @{"GadgetMouse()" Link "GadgetMouse()"}    @{"SysReqHandler()" Link "SysReqHandler()"}
@{"SetPointer()" Link "SetPointer()"}       @{"RefreshWindowFrame()" Link "RefreshWindowFrame()"} @{"ModifyProp()" Link "ModifyProp()"}     @{"EndRequest()" Link "EndRequest()"}
@{"ClearPointer()" Link "ClearPointer()"}     @{"EndRefresh()" Link "EndRefresh()"}         @{"NewModifyProp()" Link "NewModifyProp()"}  @{"FreeSysRequest()" Link "FreeSysRequest()"}
@{"ActivateWindow()" Link "ActivateWindow()"}   @{"CloseWindow()" Link "CloseWindow()"}        @{"SetEditHook()" Link "SetEditHook()"}    @{"ClearDMRequest()" Link "ClearDMRequest()"}
@{"BeginRefresh()" Link "BeginRefresh()"}     @{b}@{u}Classes@{uu}@{ub}:              @{"DoGadgetMethodA()" Link "DoGadgetMethodA()"}@{b}@{u}Border@{uu}@{ub}:
@{b}@{u}Menus@{uu}@{ub}:              @{"MakeClass()" Link "MakeClass()"}          @{"RefreshGadgets()" Link "RefreshGadgets()"} @{"DrawBorder()" Link "DrawBorder()"}
@{"SetMenuStrip()" Link "SetMenuStrip()"}     @{"AddClass()" Link "AddClass()"}           @{"RefreshGList()" Link "RefreshGList()"}
@{"OnMenu()" Link "OnMenu()"}           @{"NewObject()" Link "NewObject()"}          @{"OffGadget()" Link "OffGadget()"}
@{"ResetMenuStrip()" Link "ResetMenuStrip()"}   @{"SetAttrsA()" Link "SetAttrsA()"}          @{"ReleaseGIRPort()" Link "ReleaseGIRPort()"}
@{"ItemAddress()" Link "ItemAddress()"}      @{"GetAttr()" Link "GetAttr()"}            @{"RemoveGadget()" Link "RemoveGadget()"}
@{"LendMenus()" Link "LendMenus()"}        @{"NextObject()" Link "NextObject()"}         @{"RemoveGList()" Link "RemoveGList()"}
@{"OffMenu()" Link "OffMenu()"}          @{"DisposeObject()" Link "DisposeObject()"}      @{b}@{u}Remember@{uu}@{ub}:
@{"ClearMenuStrip()" Link "ClearMenuStrip()"}   @{"FreeClass()" Link "FreeClass()"}          @{"AllocRemember()" Link "AllocRemember()"}
                    @{"RemoveClass()" Link "RemoveClass()"}        @{"FreeRemember()" Link "FreeRemember()"}
@{b}@{u}Screens@{uu}@{ub}:                                     @{b}@{u}Workbench@{uu}@{ub}:
@{"AllocScreenBuffer()" Link "AllocScreenBuffer()"}  @{"NextPubScreen()" Link "NextPubScreen()"}      @{"OpenWorkBench()" Link "OpenWorkBench()"}
@{"ChangeScreenBuffer()" Link "ChangeScreenBuffer()"} @{"GetScreenData()" Link "GetScreenData()"}      @{"WBenchToFront()" Link "WBenchToFront()"}
@{"MakeScreen()" Link "MakeScreen()"}         @{"GetScreenDrawInfo()" Link "GetScreenDrawInfo()"}  @{"WBenchToBack()" Link "WBenchToBack()"}
@{"RethinkDisplay()" Link "RethinkDisplay()"}     @{"FreeScreenDrawInfo()" Link "FreeScreenDrawInfo()"} @{"CloseWorkBench()" Link "CloseWorkBench()"}
@{"RemakeDisplay()" Link "RemakeDisplay()"}      @{"ShowTitle()" Link "ShowTitle()"}          @{b}@{u}Images@{uu}@{ub}:
@{"QueryOverscan()" Link "QueryOverscan()"}      @{"MoveScreen()" Link "MoveScreen()"}         @{"DrawImage()" Link "DrawImage()"}
@{"OpenScreen()" Link "OpenScreen()"}         @{"ScreenPosition()" Link "ScreenPosition()"}     @{"DrawImageState()" Link "DrawImageState()"}
@{"OpenScreenTagList()" Link "OpenScreenTagList()"}  @{"ScreenToFront()" Link "ScreenToFront()"}      @{"PointInImage()" Link "PointInImage()"}
@{"LockPubScreen()" Link "LockPubScreen()"}      @{"ScreenDepth()" Link "ScreenDepth()"}        @{"EraseImage()" Link "EraseImage()"}
@{"LockPubScreenList()" Link "LockPubScreenList()"}  @{"ScreenToBack()" Link "ScreenToBack()"}       @{b}@{u}Mouse@{uu}@{ub}:
@{"SetPubScreenModes()" Link "SetPubScreenModes()"}  @{"UnlockPubScreenList()" Link "UnlockPubScreenList()"}@{"CurrentTime()" Link "CurrentTime()"}
@{"SetDefaultPubScreen()" Link "SetDefaultPubScreen()"}@{"UnlockPubScreen()" Link "UnlockPubScreen()"}    @{"DoubleClick()" Link "DoubleClick()"}
@{"GetDefaultPubScreen()" Link "GetDefaultPubScreen()"}@{"CloseScreen()" Link "CloseScreen()"}        @{"SetMouseQueue()" Link "SetMouseQueue()"}
@{"PubScreenStatus()" Link "PubScreenStatus()"}    @{"FreeScreenBuffer()" Link "FreeScreenBuffer()"}   @{"ReportMouse()" Link "ReportMouse()"}
@{b}@{u}Display alerts@{uu}@{ub}:       @{b}@{u}Prefs@{uu}@{ub}:
@{"DisplayBeep()" Link "DisplayBeep()"}        @{"GetDefPrefs()" Link "GetDefPrefs()"}
@{"DisplayAlert()" Link "DisplayAlert()"}       @{"SetPrefs()" Link "SetPrefs()"}
@{"TimedDisplayAlert()" Link "TimedDisplayAlert()"}  @{"GetPrefs()" Link "GetPrefs()"}           @{"Same, but sorted" link SORTED}
@{b}@{u}IntuiBase@{uu}@{ub}:            @{b}@{u}IntuiText@{uu}@{ub}:
@{"LockIBase()" Link "LockIBase()"}          @{"IntuiTextLength()" Link "IntuiTextLength()"}
@{"UnlockIBase()" Link "UnlockIBase()"}        @{"PrintIText()" Link "PrintIText()"}
@EndNode
@Node SORTED "intuition.doc"
@{"ActivateGadget()" Link "ActivateGadget()"}
@{"ActivateWindow()" Link "ActivateWindow()"}
@{"AddClass()" Link "AddClass()"}
@{"AddGadget()" Link "AddGadget()"}
@{"AddGList()" Link "AddGList()"}
@{"AllocRemember()" Link "AllocRemember()"}
@{"AllocScreenBuffer()" Link "AllocScreenBuffer()"}
@{"AutoRequest()" Link "AutoRequest()"}
@{"BeginRefresh()" Link "BeginRefresh()"}
@{"BuildEasyRequestArgs()" Link "BuildEasyRequestArgs()"}
@{"BuildSysRequest()" Link "BuildSysRequest()"}
@{"ChangeScreenBuffer()" Link "ChangeScreenBuffer()"}
@{"ChangeWindowBox()" Link "ChangeWindowBox()"}
@{"ClearDMRequest()" Link "ClearDMRequest()"}
@{"ClearMenuStrip()" Link "ClearMenuStrip()"}
@{"ClearPointer()" Link "ClearPointer()"}
@{"CloseScreen()" Link "CloseScreen()"}
@{"CloseWindow()" Link "CloseWindow()"}
@{"CloseWorkBench()" Link "CloseWorkBench()"}
@{"CurrentTime()" Link "CurrentTime()"}
@{"DisplayAlert()" Link "DisplayAlert()"}
@{"DisplayBeep()" Link "DisplayBeep()"}
@{"DisposeObject()" Link "DisposeObject()"}
@{"DoGadgetMethodA()" Link "DoGadgetMethodA()"}
@{"DoubleClick()" Link "DoubleClick()"}
@{"DrawBorder()" Link "DrawBorder()"}
@{"DrawImage()" Link "DrawImage()"}
@{"DrawImageState()" Link "DrawImageState()"}
@{"EasyRequestArgs()" Link "EasyRequestArgs()"}
@{"EndRefresh()" Link "EndRefresh()"}
@{"EndRequest()" Link "EndRequest()"}
@{"EraseImage()" Link "EraseImage()"}
@{"FreeClass()" Link "FreeClass()"}
@{"FreeRemember()" Link "FreeRemember()"}
@{"FreeScreenBuffer()" Link "FreeScreenBuffer()"}
@{"FreeScreenDrawInfo()" Link "FreeScreenDrawInfo()"}
@{"FreeSysRequest()" Link "FreeSysRequest()"}
@{"GadgetMouse()" Link "GadgetMouse()"}
@{"GetAttr()" Link "GetAttr()"}
@{"GetDefaultPubScreen()" Link "GetDefaultPubScreen()"}
@{"GetDefPrefs()" Link "GetDefPrefs()"}
@{"GetPrefs()" Link "GetPrefs()"}
@{"GetScreenData()" Link "GetScreenData()"}
@{"GetScreenDrawInfo()" Link "GetScreenDrawInfo()"}
@{"HelpControl()" Link "HelpControl()"}
@{"InitRequester()" Link "InitRequester()"}
@{"IntuiTextLength()" Link "IntuiTextLength()"}
@{"ItemAddress()" Link "ItemAddress()"}
@{"LendMenus()" Link "LendMenus()"}
@{"LockIBase()" Link "LockIBase()"}
@{"LockPubScreen()" Link "LockPubScreen()"}
@{"LockPubScreenList()" Link "LockPubScreenList()"}
@{"MakeClass()" Link "MakeClass()"}
@{"MakeScreen()" Link "MakeScreen()"}
@{"ModifyIDCMP()" Link "ModifyIDCMP()"}
@{"ModifyProp()" Link "ModifyProp()"}
@{"MoveScreen()" Link "MoveScreen()"}
@{"MoveWindow()" Link "MoveWindow()"}
@{"MoveWindowInFrontOf()" Link "MoveWindowInFrontOf()"}
@{"NewModifyProp()" Link "NewModifyProp()"}
@{"NewObject()" Link "NewObject()"}
@{"NextObject()" Link "NextObject()"}
@{"NextPubScreen()" Link "NextPubScreen()"}
@{"ObtainGIRPort()" Link "ObtainGIRPort()"}
@{"OffGadget()" Link "OffGadget()"}
@{"OffMenu()" Link "OffMenu()"}
@{"OnGadget()" Link "OnGadget()"}
@{"OnMenu()" Link "OnMenu()"}
@{"OpenScreen()" Link "OpenScreen()"}
@{"OpenScreenTagList()" Link "OpenScreenTagList()"}
@{"OpenWindow()" Link "OpenWindow()"}
@{"OpenWindowTagList()" Link "OpenWindowTagList()"}
@{"OpenWorkBench()" Link "OpenWorkBench()"}
@{"PointInImage()" Link "PointInImage()"}
@{"PrintIText()" Link "PrintIText()"}
@{"PubScreenStatus()" Link "PubScreenStatus()"}
@{"QueryOverscan()" Link "QueryOverscan()"}
@{"RefreshGadgets()" Link "RefreshGadgets()"}
@{"RefreshGList()" Link "RefreshGList()"}
@{"RefreshWindowFrame()" Link "RefreshWindowFrame()"}
@{"ReleaseGIRPort()" Link "ReleaseGIRPort()"}
@{"RemakeDisplay()" Link "RemakeDisplay()"}
@{"RemoveClass()" Link "RemoveClass()"}
@{"RemoveGadget()" Link "RemoveGadget()"}
@{"RemoveGList()" Link "RemoveGList()"}
@{"ReportMouse()" Link "ReportMouse()"}
@{"Request()" Link "Request()"}
@{"ResetMenuStrip()" Link "ResetMenuStrip()"}
@{"RethinkDisplay()" Link "RethinkDisplay()"}
@{"ScreenDepth()" Link "ScreenDepth()"}
@{"ScreenPosition()" Link "ScreenPosition()"}
@{"ScreenToBack()" Link "ScreenToBack()"}
@{"ScreenToFront()" Link "ScreenToFront()"}
@{"ScrollWindowRaster()" Link "ScrollWindowRaster()"}
@{"SetAttrsA()" Link "SetAttrsA()"}
@{"SetDefaultPubScreen()" Link "SetDefaultPubScreen()"}
@{"SetDMRequest()" Link "SetDMRequest()"}
@{"SetEditHook()" Link "SetEditHook()"}
@{"SetGadgetAttrsA()" Link "SetGadgetAttrsA()"}
@{"SetMenuStrip()" Link "SetMenuStrip()"}
@{"SetMouseQueue()" Link "SetMouseQueue()"}
@{"SetPointer()" Link "SetPointer()"}
@{"SetPrefs()" Link "SetPrefs()"}
@{"SetPubScreenModes()" Link "SetPubScreenModes()"}
@{"SetWindowPointerA()" Link "SetWindowPointerA()"}
@{"SetWindowTitles()" Link "SetWindowTitles()"}
@{"ShowTitle()" Link "ShowTitle()"}
@{"SizeWindow()" Link "SizeWindow()"}
@{"SysReqHandler()" Link "SysReqHandler()"}
@{"TimedDisplayAlert()" Link "TimedDisplayAlert()"}
@{"UnlockIBase()" Link "UnlockIBase()"}
@{"UnlockPubScreen()" Link "UnlockPubScreen()"}
@{"UnlockPubScreenList()" Link "UnlockPubScreenList()"}
@{"ViewAddress()" Link "ViewAddress()"}
@{"ViewPortAddress()" Link "ViewPortAddress()"}
@{"WBenchToBack()" Link "WBenchToBack()"}
@{"WBenchToFront()" Link "WBenchToFront()"}
@{"WindowLimits()" Link "WindowLimits()"}
@{"WindowToBack()" Link "WindowToBack()"}
@{"WindowToFront()" Link "WindowToFront()"}
@{"ZipWindow()" Link "ZipWindow()"}
@EndNode
@Node "ActivateGadget()" "intuition.library/ActivateGadget"
@{b}@{u}ActivateGadget@{uu}@{ub} -- Activate a (string or custom) gadget.
  Activates a string or custom gadget.If successful, this means that
  the user does not need to click in the gadget before typing.
  The window parameter must point to the window which contains the gadget.
  If the gadget is actually in a requester, the window must contain
  the requester, and a pointer to the requester must also be passed.
  The requester parameter must only be valid if the gadget has the
  @{i}GTYP_REQGADGET@{ui} flag set, a requirement for all requester gadgets.The success of
  this function depends on a rather complex set of conditions.The intent is that
  the user is never interrupted from what interactions he may have underway.
  @{i}The current set of conditions includes@{ui}:
  - The window must be active.If you are opening a new window and want an
    active gadget in it, it is not sufficient to assume that the @{i}WFLG_ACTIVATE@{ui}
    flag has taken effect by the time @{"OpenWindow()" Link "OpenWindow()"} returns, even if you insert
    a delay of some finite amount of time.Use the @{i}IDCMP_ACTIVEWINDOW@{ui}
    @{"IntuiMessage" Link "include:intuition/intuition.h/Main" 761} to tell when your window really becomes active.
    Many programs use an event loop that calls ActivateGadget() whenever they
    receive the @{i}IDCMP_ACTIVEWINDOW@{ui} message, and also the @{i}IDCMP_MOUSEBUTTONS@{ui}
    messages, and so on, to keep the gadget active until it is used
    (or the user selects some other "Cancel" gadget).
  - No other gadgets may be in use.This includes system gadgets,
    such as those for window sizing, dragging, etc.
  - If the gadget is in a requester, that requester must be active.
    (Use @{i}IDCMP_REQSET@{ui} and @{i}IDCMP_REQCLEAR@{ui}).
  - The right mouse button cannot be held down (e.g.menus)
SYNOPSIS
  BOOL ActivateGadget( @{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} * );
  @{i}@{b}Success@{ub}@{ui} = ActivateGadget( @{i}Gadget@{ui}, @{i}Window@{ui}, @{i}Requester@{ui} )
   D0                        A0      A1       A2
  @{i}Gadget@{ui} = pointer to the gadget that you want activated.
  @{i}Window@{ui} = pointer to a window structure containing the gadget.
  @{i}Requester@{ui} = pointer to a requester (may by NULL if this isn't
    a requester gadget (i.e.@{i}GTYP_REQGADGET@{ui} is not set)).
  If the conditions above are met, and the gadget is in fact a string
  gadget, then this function will return TRUE, else FALSE.
NOTE
  Don't try to activate a gadget which is disabled or
  not attached to a window or requester.
BUGS
  At present, this function will not return FALSE if a custom
  gadget declines to be activated.
@EndNode
@Node "ActivateWindow()" "intuition.library/ActivateWindow"
@{b}@{u}ActivateWindow@{uu}@{ub} -- Activate an Intuition window.
  Note that this call may have its action deferred: you cannot assume
  that when this call is made the selected window has become active.
  This action will be postponed while the user plays with gadgets and
  menus, or sizes and drags windows.You may detect when the window
  actually has become active by the @{i}IDCMP_ACTIVEWINDOW@{ui} IDCMP message.
  This call is intended to provide flexibility but not to confuse the user.
  Please call this function synchronously with some action by the user.
SYNOPSIS  @{FG shine}void@{FG text} ActivateWindow( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} * );
  ActivateWindow( @{i}Window@{ui} )
                   A0
  @{i}Window@{ui} = a pointer to a Window structure
BUGS
  Some versions of the documentation claimed that this function
  had a meaningful return value under V36 and higher.That is not true.
  Calling this function in a tight loop can blow out Intuition's
  deferred action queue.
SEE ALSO
  @{"OpenWindow()" Link "OpenWindow()"}, and the WFLG_ACTIVATE window flag
@EndNode
@Node "AddClass()" "intuition.library/AddClass"
@{b}@{u}AddClass@{uu}@{ub} -- Make a public class available.(V36)
  Adds a public boopsi class to the internal list of classes available
  for public consumption.
  You must call this function after you call @{"MakeClass()" Link "MakeClass()"}.
SYNOPSIS  @{FG shine}void@{FG text} AddClass( @{FG shine}struct@{FG text} IClass * );
  AddClass( @{i}Class@{ui} )
             A0
  @{i}Class@{ui} = pointer returned by @{"MakeClass()" Link "MakeClass()"}
BUGS
  Although there is some protection against creating classes with the
  same name as an existing class, this function does not do any checking
  or other dealings with like-named classes.Until this is rectified,
  only officially registered names can be used for public classes,
  and there is no "class replacement" policy in effect.
SEE ALSO
  @{"MakeClass()" Link "MakeClass()"}, @{"FreeClass()" Link "FreeClass()"}, @{"RemoveClass()" Link "RemoveClass()"}
  Document "Basic Object-Oriented Programming System for Intuition"
  and the "boopsi Class Reference" document.
@EndNode
@Node "AddGadget()" "intuition.library/AddGadget"
@{b}@{u}AddGadget@{uu}@{ub} -- Add a gadget to the gadget list of a window.
  Adds the specified gadget to the gadget list of the given window,
  linked in at the position in the list specified by the position 
  argument (that is, if Position == 0, the gadget will be inserted
  at the head of the list, and if Position == 1 then the gadget will
  be inserted after the first gadget and before the second).If the
  position you specify is greater than the number of gadgets in the
  list, your gadget will be added to the end of the list.
  Calling AddGadget() does not cause your gadget to be redisplayed.
  The benefit of this is that you may add several gadgets without
  having the gadget list redrawn every time.
  This procedure returns the position at which your gadget was added.
SYNOPSIS  UWORD  AddGadget( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, UWORD );
  @{i}@{b}RealPosition@{ub}@{ui} = AddGadget( @{i}Window@{ui}, @{i}Gadget@{ui}, @{i}Position@{ui} )
   D0                        A0       A1      D0
  @{i}Window@{ui} = pointer to the window to get your gadget
  @{i}Gadget@{ui} = pointer to the new gadget
  @{i}Position@{ui} = integer position in the list for the new gadget (starting
    from zero as the first position in the list)
  Returns the position of where the gadget was actually added.
NOTES
  A relatively safe way to add the gadget to the end of the list is to
  specify a position of -1 (i.e., (UWORD) ~0).That way, only the 65536th
  (and multiples of it) will be inserted at the wrong position.The return
  value of the procedure will tell you where it was actually inserted.
  The system window gadgets are initially added to the front of the gadget
  list.The reason for this is: If you position your own gadgets in some way
  that interferes with the graphical representation of the system gadgets,
  the system's ones will be "hit" first by user.If you then start adding
  gadgets to the front of the list, you will disturb this plan, so beware.
  On the other hand, if you don't violate the design rule of never overlapping
  your gadgets, there's no problem.
  You may not add your own gadgets to a screen.Gadgets may be added to backdrop
  windows, however, which can be visually similar, but also provide an IDCMP
  channel for gadget input messages.
SEE ALSO
  @{"AddGList()" Link "AddGList()"}, @{"RemoveGadget()" Link "RemoveGadget()"}, @{"RemoveGList()" Link "RemoveGList()"}
@EndNode
@Node "AddGList()" "intuition.library/AddGList"
@{b}@{u}AddGList@{uu}@{ub} -- Add a linked list of gadgets to a window or requester.
  Adds the list of gadgets to the gadget list of the given window or requester
  linked in at the position in the list specified by the position argument.
  See @{"AddGadget()" Link "AddGadget()"} for more information about gadget list position,
  and more information about gadgets in general.
  The requester parameter will be ignored unless the GTYP_REQGADGET
  bit is set in the GadgetType field of the first gadget in the list.
  In that case, the gadget list is added to the requester gadgets.
SYNOPSIS
  UWORD AddGList( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, UWORD, WORD,
    @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} * );
  @{i}@{b}RealPosition@{ub}@{ui} = AddGList( @{i}Window@{ui}, @{i}Gadget@{ui}, @{i}Position@{ui}, @{i}Numgad@{ui}, @{i}Requester@{ui} )
   D0                       A0       A1      D0        D1      A2
  @{i}Window@{ui} = pointer to the window to get your gadget
  @{i}Gadget@{ui} = pointer to the first gadget to be added
  @{i}Position@{ui} = integer position in the list for the new gadget
    (starting from zero as the first position in the list)
  @{i}Numgad@{ui} = the number of gadgets from the linked list to be added if Numgad
    equals -1, the entire null-terminated list of gadgets will be added.
  @{i}Requester@{ui} = the requester the gadgets will be added to if the GTYP_REQGADGET
    GadgetType flag is set for the first gadget in the list
  Returns the position of where the first gadget in the list was actually added.
NOTES
  Be sure that GTYP_REQGADGET is either set or cleared consistently for all
  gadgets in the list.@{i}NOTE ALSO@{ui}: The window parameter should point to the window
  that the requester (will) appear in.Will add 'Numgad' gadgets from gadget list
  linked by the field NextGadget, or until some NextGadget field is found to be
  NULL.Does not assume that the Numgad'th gadget has NextGadget equal to NULL.
  @{b}NOTE WELL:@{ub} In order to link your gadget list in, the NextGadget
  field of the Numgad'th (or last) gadget will be modified.Thus, if
  you are adding the first 3 gadgets from a linked list of five gadgets,
  this call will sever the connection between your third and fourth gadgets.
SEE ALSO
  @{"AddGadget()" Link "AddGadget()"}, @{"RemoveGadget()" Link "RemoveGadget()"}, @{"RemoveGList()" Link "RemoveGList()"}
@EndNode
@Node "AllocRemember()" "intuition.library/AllocRemember"
@{b}@{u}AllocRemember@{uu}@{ub} -- @{"AllocMem()" Link "exec.guide/AllocMem()"} with tracking to make freeing easy.
  This routine calls the Exec @{"AllocMem()" Link "exec.guide/AllocMem()"} function for you, but also links
  the parameters of the allocation into a master list, so that
  you can simply call the Intuition routine @{"FreeRemember()" Link "FreeRemember()"} at a later 
  time to deallocate all allocated memory without being required to
  remember the details of the memory you've allocated.
  @{i}This routine will have two primary uses:@{ui}
  - Let's say that you're doing a long series of allocations in a procedure.
    If any one of the allocations fails, your program may need to abort the
    procedure.Abandoning ship correctly involves freeing up what memory you've
    already allocated.This procedure allows you to free up that memory easily,
    without being required to keep track of how many allocations you've already
    done, what the sizes of the allocations were, or where the memory was
    allocated.
  - Also, in the more general case, you may do all of the allocations in your
    entire program using this routine.Then, when your program is exiting,
    you can free it all up at once with a simple call to @{"FreeRemember()" Link "FreeRemember()"}.
  You create the "anchor" for the allocation master list by creating a variable
  that's a pointer to structure Remember, and initializing that pointer to NULL.
  This is called the RememberKey.Whenever you call AllocRemember(), the routine
  actually does two memory allocations, one for the memory you want and the other
  for a copy of a Remember structure.The Remember structure is filled in with
  data describing your memory allocation, and it's linked into the master list
  pointed to by your RememberKey.Then,to free up any memory that's been allocated,
  all you have to do is call @{"FreeRemember()" Link "FreeRemember()"} with your RememberKey.
  Please read the @{"FreeRemember()" Link "FreeRemember()"} function description, too.As you will see,
  you can select either to free just the link nodes and keep all the allocated
  memory for yourself, or to free both the nodes and your memory buffers.
SYNOPSIS  APTR AllocRemember( @{FG shine}struct@{FG text} @{"Remember" Link "include:intuition/intuition.h/Main" 1424} **, ULONG, ULONG );
  @{i}@{b}MemBlock@{ub}@{ui} = AllocRemember( @{i}RememberKey@{ui}, @{i}Size@{ui}, @{i}Flags@{ui} )
   D0                        A0            D0    D1
  @{i}RememberKey@{ui} = the address of a pointer to structure Remember.
    Before the very first call to AllocRemember, initialize this pointer to NULL.
  @{i}Size@{ui} = the size in bytes of the memory allocation.Please refer to the
    @{"exec.library/AllocMem()" Link "exec.guide/AllocMem()"} function for details.
  @{i}Flags@{ui} = the specifications for the memory allocation.Please refer to the
    @{"exec.library/AllocMem()" Link "exec.guide/AllocMem()"} function for details.
EXAMPLE
  @{FG shine}struct@{FG text} Remember *@{i}RememberKey@{ui};
  @{i}RememberKey@{ui} = NULL;
  @{i}buffer@{ui} = AllocRemember(@{i}&RememberKey@{ui}, BUFSIZE, MEMF_CHIP);
  @{FG shine}if@{FG text} (@{i}buffer@{ui})
  {
      /* Use the buffer */
      ...
  }
  FreeRemember(@{i}&RememberKey@{ui}, TRUE);
  If the memory allocation is successful, this routine returns the byte 
  address of your requested memory block.Also, the node to your block
  will be linked into the list pointed to by your RememberKey variable.
  If the allocation fails, this routine returns NULL and the list pointed
  to by RememberKey, if any, will be unchanged.
BUGS
  This function makes two allocations for each memory buffer you request.This is
  neither fast nor good for memory fragmentation.This function should use the
  exec AllocPool() function internally, at least for the Remember headers.
SEE ALSO
  @{"FreeRemember()" Link "FreeRemember()"}, @{"exec.library/AllocMem()" Link "exec.guide/AllocMem()"}
@EndNode
@Node "AllocScreenBuffer()" "intuition.library/AllocScreenBuffer"
@{b}@{u}AllocScreenBuffer@{uu}@{ub} -- Get a ScreenBuffer for double-buffering.(V39)
  Allocates a ScreenBuffer structure and usually a BitMap.
  This structure can be used for double (or multiple) buffering in Intuition
  screens.You may use this call to obtain a ScreenBuffer structure for the
  screen's initial BitMap, or for other BitMaps you intend to swap in.
  AllocScreenBuffer() also allocates a graphics.library DBufInfo
  structure.The ScreenBuffer structure this call returns contains
  a pointer to that DBufInfo structure, which is free for your use.
  See graphics.library/AllocDBufInfo() for full details on using
  this structure to achieve notification of when it is safe to
  render into an old buffer and when it is right to switch again.
SYNOPSIS
  @{FG shine}struct@{FG text} ScreenBuffer *AllocScreenBuffer(@{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} *,@{FG shine}struct@{FG text} @{"BitMap" Link "include:graphics/gfx.h/Main" 46} *,ULONG);
  @{i}@{b}sbuffer@{ub}@{ui} = AllocScreenBuffer( @{i}Screen@{ui}, @{i}BitMap@{ui}, @{i}flags@{ui} )
   D0                           A0       A1      D0
  @{i}Screen@{ui} = pointer to the screen to double-buffer
  @{i}BitMap@{ui} = For CUSTOMBITMAP screens, you may pre-allocate a BitMap
    matching the screen's BitMap's properties, and pass that in, to get a
    ScreenBuffer referring to that BitMap.Set this parameter to NULL if you'd
    prefer that Intuition allocate the alternate buffer.
    This parameter must be NULL for non-CUSTOMBITMAP screens.
  @{i}Flags@{ui} = Set a combination of these flags:
    For non-CUSTOMBITMAP screens, set @{i}SB_SCREEN_BITMAP@{ui} in order to
    get a ScreenBuffer referring to the screen's actual BitMap.
    (For CUSTOMBITMAP screens, just set the BitMap parameter
    to the BitMap you passed to @{"OpenScreen()" Link "OpenScreen()"}).
    Set @{i}SB_COPY_BITMAP@{ui} if you would like the screen's BitMap copied into
    this ScreenBuffer's BitMap.This is required to get any menu-bar or
    gadget imagery into each ScreenBuffer's BitMap.If the screen has no
    Intuition rendering, you may omit this flag.Also, when allocating a
    ScreenBuffer for the screen's initial BitMap, this flag should not be set.
  Pointer to a valid ScreenBuffer structure, or NULL if failure.
  You may render into the resulting BitMap as appropriate.
  You may use the sb_DBufInfo field to access graphics.library
  ViewPort-buffering features such as learning when it is safe
  to reuse the previous BitMap.If not, you risk writing into
  the on-screen BitMap, which can damage menu or gadget rendering!
NOTES
  The role of @{i}SB_SCREEN_BITMAP@{ui} is to wrap a ScreenBuffer around the actual
  current BitMap used by the non-CUSTOMBITMAP screen.
  The words actual or current are used instead of initial, since an application
  could do some double-buffering, leave the non-initial buffer installed into
  the screen, free up the others, then re-allocate ScreenBuffer structures to do
  more double-buffering.In that case, the actual screen BitMap is not necessarily
  the initial one.The role of @{i}SB_COPY_BITMAP@{ui} is to say "please put whatever
  imagery is currently on-screen into this new BitMap too".That's how the screen
  titlebar and other imagery get copied over into each buffer.
SEE ALSO
  @{"FreeScreenBuffer()" Link "FreeScreenBuffer()"}, @{"ChangeScreenBuffer()" Link "ChangeScreenBuffer()"},
  graphics.library/AllocDBufInfo(), graphics.library/ChangeVPBitMap()
@EndNode
@Node "AutoRequest()" "intuition.library/AutoRequest"
@{b}@{u}AutoRequest@{uu}@{ub} -- Automatically build and get response from a requester.
  This procedure automatically builds a requester for you and then waits for a
  response from the user, or for the system to satisfy your request.
  If the response is positive, this procedure returns TRUE.
  If the response is negative, this procedure returns FALSE.
  An IDCMPFlag specification is created by bitwise "or'ing" your PosFlags,
  NegFlags, and the IDCMP classes IDCMP_GADGETUP and IDCMP_RAWKEY.
  You may specify zero flags for either the PosFlags or NegFlags arguments.
  The IntuiText arguments, and the width and height values, are
  passed directly to the @{"BuildSysRequest()" Link "BuildSysRequest()"} procedure along with 
  your window pointer and the IDCMP flags.Please refer to
  @{"BuildSysRequest()" Link "BuildSysRequest()"} for a description of the IntuiText that you are
  expected to supply when calling this routine.It's an important
  but long-winded description that need not be duplicated here.
  If the @{"BuildSysRequest()" Link "BuildSysRequest()"} procedure does not return a pointer 
  to a window, it will return TRUE or FALSE (not valid structure pointers)
  instead, and these BOOL values will be returned to you immediately.
  On the other hand, if a valid window pointer is returned, that 
  window will have had its IDCMP ports and flags initialized according 
  to your specifications.AutoRequest() then waits for IDCMP messages
  on the UserPort, which satisfies one of four requirements:
  -either the message is of a class that matches one of your PosFlags arguments
   (if you've supplied any), in which case this routine returns TRUE.Or
  -the message class matches one of your NegFlags arguments
   (if you've supplied any), in which case this routine returns FALSE.Or
  -the IDCMP message is of class IDCMP_GADGETUP, which means that one of the two
   gadgets, as provided with the PosText and NegText arguments, was selected
   by the user.
   If the TRUE gadget was selected, TRUE is returned.
   If the FALSE gadget was selected, FALSE is returned.
  -Lastly, two IDCMP_RAWKEY messages may satisfy the request:
   those for the V and B keys with the left Amiga key depressed.
   These keys, satisfy the gadgets on the left or right side of
   the requester--TRUE or FALSE--, respectively.
  @{i}NOTE@{ui}: @{i}For V36@{ui}, these two keys left-Amiga-B and V are processed through the
  default keymap.
  When the dust has settled, this routine calls @{"FreeSysRequest()" Link "FreeSysRequest()"} if
  necessary to clean up the requester and any other allocated memory.
  @{i}NOTE@{ui}: @{i}For V36@{ui}, this function now switches the processor stack
  to ensure sufficient stack space for the function to succeed.
SYNOPSIS
  BOOL AutoRequest( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"IntuiText" Link "include:intuition/intuition.h/Main" 650} *, @{FG shine}struct@{FG text} IntuiText *,
    @{FG shine}struct@{FG text} IntuiText *, ULONG, ULONG, WORD, WORD );
  @{i}@{b}Response@{ub}@{ui} = AutoRequest(@{i}Window@{ui},@{i}BodyText@{ui},@{i}PosText@{ui},@{i}NegText@{ui},@{i}PosFlags@{ui},@{i}NegFlags@{ui},@{i}Width@{ui},@{i}Height@{ui})
   D0                     A0      A1       A2      A3      D0       D1        D2    D3
  @{i}Window@{ui} = pointer to a Window structure.
    See @{"BuildSysRequest()" Link "BuildSysRequest()"} for a full discussion.
  @{i}BodyText@{ui} = pointer to an IntuiText structure
  @{i}PosText@{ui} = pointer to an IntuiText structure, may by NULL.
  @{i}NegText@{ui} = pointer to an IntuiText structure, @{b}MUST@{ub} be valid!
  @{i}PosFlags@{ui} = flags for the IDCMP
  @{i}NegFlags@{ui} = flags for the IDCMP
  @{i}Width@{ui}, @{i}Height@{ui} = the sizes to be used for the rendering of the requester
    @{i}NOTE for V36:@{ui} The width and height parameters are ignored, as are several
    other specifications in the IntuiText, to make AutoRequest() requesters
    retroactively conform to the new look designed for EasyRequest().
  The return value is either TRUE or FALSE.See the text above for a
  complete description of the chain of events that might lead to either
  of these values being returned.
NOTES
  When DOS brings up AutoRequests() on your process (eg.
  "Please insert volume XXX in any drive", they normally come
  up on the Workbench screen.If you set your @{"Process" Link "include:dos/dosextens.h/Main" 37} pr_WindowPtr
  field to point to one of your windows, then DOS will bring its
  requesters up on the same screen as that window.A pr_WindowPtr
  of -1 prevents requesters from coming up at all.
  (Some FileSystem requesters cannot be redirected or supressed).
BUGS
  The requester no longer devolves into a call to @{"DisplayAlert()" Link "DisplayAlert()"}
  if there is not enough memory for the requester.
SEE ALSO
  @{"EasyRequestArgs()" Link "EasyRequestArgs()"}, @{"BuildSysRequest()" Link "BuildSysRequest()"}, @{"SysReqHandler()" Link "SysReqHandler()"}
@EndNode
@Node "BeginRefresh()" "intuition.library/BeginRefresh"
@{b}@{u}BeginRefresh@{uu}@{ub} -- Sets up a window for optimized refreshing.
  This routine sets up your window for optimized refreshing.
  Its role is to provide Intuition integrated access to the Layers
  library function @{"BeginUpdate()" Link "ROMlibs.guide/BeginUpdate()"}.Its additional contribution is
  to be sure that locking protocols for layers are followed, by
  locking both layers of a @{i}WFLG_GIMMEZEROZERO@{ui} window only after the
  parent @{"Layer_Info" Link "include:graphics/layers.h/Main" 29} has been locked.Also, the @{i}WFLG_WINDOWREFRESH@{ui}
  flag is set in your window, for your information.
  The purpose of @{"BeginUpdate()" Link "ROMlibs.guide/BeginUpdate()"}, and hence BeginRefresh(), is to
  restrict rendering in a window (layer) to the region that needs
  refreshing after an operation such as window sizing or uncovering.
  This restriction to the "damage region" persists until you call
  @{"EndRefresh()" Link "EndRefresh()"}.
  For instance, if you have a @{i}WFLG_SIMPLE_REFRESH@{ui} window which is partially
  concealed and the user brings it to the front, you can receive an
  @{i}IDCMP_REFRESHWINDOW@{ui} message asking you to refresh your display.If you call
  BeginRefresh() before doing any of the rendering, then the layer that
  underlies your window will be arranged so that the only rendering that
  will actually take place will be that which goes to the newly-revealed
  areas.This is very performance-efficient, and visually attractive.
  After you have performed your refresh of the display, you should call
  @{"EndRefresh()" Link "EndRefresh()"} to reset the state of the layer and the window.Then you
  may proceed with rendering to the entire window as usual.
  You learn that your window needs refreshing by receiving either a message
  of class @{i}IDCMP_REFRESHWINDOW@{ui} through the IDCMP, or an input event of
  class @{i}IECLASS_REFRESHWINDOW@{ui} through the Console device.
  Whenever you are told that your window needs refreshing, you should call
  BeginRefresh() and @{"EndRefresh()" Link "EndRefresh()"} to clear the refresh-needed state, even
  if you don't plan on doing any rendering.You may relieve yourself of even
  this burden by setting the @{i}WFLG_NOCAREREFRESH@{ui} flag when opening your window.
SYNOPSIS  @{FG shine}void@{FG text} BeginRefresh( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} * );
  BeginRefresh( @{i}Window@{ui} )
                 A0
  @{i}Window@{ui} = pointer to the window structure which needs refreshing
NOTES
@{b}WARNING:@{ub} You should only perform simple graphics refreshing
  operations between BeginRefresh() and @{"EndRefresh()" Link "EndRefresh()"}.These include
  any graphics.library drawing functions or the simple Intuition
  rendering functions (DrawImage(), @{"PrintIText()" Link "PrintIText()"}, @{"DrawBorder()" Link "DrawBorder()"}, and
  so on).In particular, do not call @{"RefreshGadgets()" Link "RefreshGadgets()"}, @{"RefreshGList()" Link "RefreshGList()"},
  @{"RefreshWindowFrame()" Link "RefreshWindowFrame()"}, etc., since any of the complex Intuition
  functions run the risk of creating a deadlock.Also avoid any
  other high-level calls in Intuition or ones that might invoke
  Intuition.This means no calling @{"SetPointer()" Link "SetPointer()"}, no calling
  @{"LockIBase()" Link "LockIBase()"}, no dos.library functions (since an EasyRequest()
  might result), etc.Keep it simple.
  By the time the application receives its @{i}IDCMP_REFRESHWINDWOW@{ui}
  message, Intuition has already repaired any damaged regions
  of the window border or the gadgets in the window, so attempts
  to redraw gadgets or borders are as unnecessary as they are dangerous.
@{b}ANOTHER WARNING:@{ub} The concept of multiple refresh passes using
  EndRefresh( @{i}w@{ui}, FALSE ) is not completely sound without furtherprotection.
  The reason is that between two sessions, more damage can occur to your window.
  Your final EndRefresh( @{i}w@{ui}, TRUE ) will dispose of all damage, including the new,
  and your initial refreshing pass will never get the chance to refresh the new
  damage.To avoid this, you must protect your session using @{"LockLayerInfo()" Link "ROMlibs.guide/LockLayerInfo()"}
  which will prevent Intuition from performing window operations or anything
  else which might cause further damage from occurring.Again, while holding the
  LayerInfo lock make no Intuition function calls dealing with gadgets; just
  render.You can, however, call @{"InstallClipRegion()" Link "ROMlibs.guide/InstallClipRegion()"} for the different refresh
  passes, if you have two clip regions.
@{b}SIMILAR WARNING:@{ub} Your program and Intuition "share" your window
  layer's DamageList.BeginRefresh() helps arbitrate this sharing, but the
  lower-level function @{"layers.library/BeginUpdate()" Link "ROMlibs.guide/BeginUpdate()"} does not.It isn't really
  supported to use @{"BeginUpdate()" Link "ROMlibs.guide/BeginUpdate()"} on a window's layer, but if you
  do--for whatever reason--it is critical that you first acquire the LayerInfo
  lock as in the above example: even if you only have one pass of refresh
  rendering to do.Otherwise, the refreshing of your window's borders and gadgets
  can be incomplete, and the problem might occur only under certain conditions
  of task priority and system load.
EXAMPLE
  Code fragment for "two pass" window refreshing, in response
  to an @{i}IDCMP_REFRESHWINDOW@{ui} message:
  @{FG shine}switch@{FG text} ( imsg->@{i}Class@{ui} )
  {
  ...
  @{FG shine}case@{FG text} @{b}IDCMP_REFRESHWINDOW@{ub}:
    @{i}window@{ui} = imsg->@{i}IDCMPWindow@{ui};
    /* this lock only needed for "two-pass" refreshing */
    LockLayerInfo( @{i}&window@{ui}->WScreen->@{i}LayerInfo@{ui} );
    /* refresh pass for region 1 */
    @{i}origclip@{ui} = InstallClipRegion( window->@{i}WLayer@{ui}, @{i}region1@{ui} );
    BeginRefresh( @{i}window@{ui} );
    myRefreshRegion1( @{i}window@{ui} );
    EndRefresh( @{i}window@{ui}, FALSE );
    /* refresh pass for region 2 */
    InstallClipRegion( window->@{i}WLayer@{ui}, @{i}region2@{ui} );
    BeginRefresh( @{i}window@{ui} );
    myRefreshRegion2( @{i}window@{ui} );
    EndRefresh( @{i}window@{ui}, TRUE );   /* and dispose damage list */
    /* restore and unlock */
    InstallClipRegion( window->@{i}WLayer@{ui}, @{i}origclip@{ui} );
    UnlockLayerInfo( @{i}&window@{ui}->WScreen->@{i}LayerInfo@{ui} );
    @{FG shine}break@{FG text};
  ...
  }
BUGS
  This function should check the return code of
  @{"layers.library/BeginUpdate()" Link "ROMlibs.guide/BeginUpdate()"}, and abort if that function fails.
SEE ALSO
  @{"EndRefresh()" Link "EndRefresh()"}, @{"layers.library/BeginUpdate()" Link "ROMlibs.guide/BeginUpdate()"}, @{"OpenWindow()" Link "OpenWindow()"}
  @{"layer.library/InstallClipRegion()" Link "ROMlibs.guide/InstallClipRegion()"}, @{"layers.library/LockLayerInfo()" Link "ROMlibs.guide/LockLayerInfo()"}
  The "Windows" chapter of the Intuition Reference Manual
@EndNode
@Node "BuildEasyRequestArgs()" "intuition.library/BuildEasyRequestArgs"
@{b}@{u}BuildEasyRequestArgs@{uu}@{ub} -- Simple creation of system request.(V36)
@{b}@{u}BuildEasyRequest@{uu}@{ub}     -- Varargs stub for BuildEasyRequestArgs().(V36)
  This function is to EasyRequest() as @{"BuildSysRequest()" Link "BuildSysRequest()"} is to
  AutoRequest(): it returns a pointer to the system requester window.
  The input from that window can then be processed under application control.
  It is recommended that this processing be done with @{"SysReqHandler()" Link "SysReqHandler()"},
  so that future enhancement to the processing will be enjoyed.
  After you have determined that the requester is satisfied or
  cancelled, you must free this requester using @{"FreeSysRequest()" Link "FreeSysRequest()"}.
  Please see the autodoc for EasyRequest().
SYNOPSIS
  @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *BuildEasyRequestArgs( @{FG shine}struct@{FG text} Window *, @{FG shine}struct@{FG text} @{"EasyStruct" Link "include:intuition/intuition.h/Main" 1455} *,
    ULONG, APTR );
  @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *BuildEasyRequest    ( @{FG shine}struct@{FG text} Window *, @{FG shine}struct@{FG text} @{"EasyStruct" Link "include:intuition/intuition.h/Main" 1455} *,
    ULONG, APTR, ...);
  @{i}@{b}ReqWindow@{ub}@{ui} = BuildEasyRequestArgs( @{i}RefWindow@{ui}, @{i}easyStruct@{ui}, @{i}IDCMP@{ui}, @{i}Args@{ui} )
   D0                                A0          A1          D0     A3
  @{i}@{b}ReqWindow@{ub}@{ui} = BuildEasyRequest    ( @{i}RefWindow@{ui}, @{i}easyStruct@{ui}, @{i}IDCMP@{ui}, @{i}Arg1@{ui}, ...)
  @{i}Window@{ui} = reference window for requester: determines the
    requester window title and screen.
  @{i}easyStruct@{ui} = pointer to EasyStruct structure, as described
    in the EasyRequest() autodocs.
  @{i}IDCMP@{ui} = (@{b}NOT A POINTER@{ub}) provided application specific IDCMP
    flags for the system requester window.
  @{i}Args@{ui} = see @{"EasyRequestArgs()" Link "EasyRequestArgs()"}
  Returns a pointer to the system request window opened.In the event of problems,
  you may also be returned the value '0' which is to be interpreted as the
  "FALSE, Cancel" choice, or (if you have a second gadget defined) the value '1',
  which is to be taken to mean the equivalent of your corresponding left-most
  gadget.If there is a problem creating the window, a recoverable alert may be
  substituted for the requester, and the result, either 0 or 1, returned.
NOTE
  This function switches the processor stack to ensure
  sufficient stack space for the function to complete.
BUGS
  Does not put up alternative alert.
  See also BUGS listed for @{"EasyRequestArgs()" Link "EasyRequestArgs()"}.
SEE ALSO
  @{"EasyRequestArgs()" Link "EasyRequestArgs()"}, @{"FreeSysRequest()" Link "FreeSysRequest()"}, @{"SysReqHandler()" Link "SysReqHandler()"}, 
  @{"BuildSysRequest()" Link "BuildSysRequest()"}, @{"AutoRequest()" Link "AutoRequest()"}
@EndNode
@Node "BuildSysRequest()" "intuition.library/BuildSysRequest"
@{b}@{u}BuildSysRequest@{uu}@{ub} -- Build and display a system requester.
  This procedure builds a system requester based on the supplied
  information.If all goes well and the requester is constructed,
  this procedure returns a pointer to the window in which the requester
  appears.That window will have its IDCMP initialized to reflect the
  flags found in the IDCMPFlags argument.You may then wait on those
  ports to detect the user's response to your requester, which response
  may include either selecting one of the gadgets or causing some other
  event to be noticed by Intuition (like @{i}IDCMP_DISKINSERTED@{ui}, for instance).
  After the requester is satisfied, you should call the @{"FreeSysRequest()" Link "FreeSysRequest()"}
  procedure to remove the requester and free up any allocated memory.
  See the autodoc for @{"SysReqHandler()" Link "SysReqHandler()"} for more information on the
  how to handle the IntuiMessages this window will receive.
  The requester used by this function has the @{i}NOISYREQ@{ui} flag bit set,
  which means that the set of IDCMPFlags that may be used here
  include @{i}IDCMP_RAWKEY@{ui}, @{i}IDCMP_MOUSEBUTTONS@{ui}, and others.
  In release previous to V36, if the requester could not be built,this function
  would try to call @{"DisplayAlert()" Link "DisplayAlert()"} with the same information,
  with more or less favorable results.In V36, the requesters themselves
  require less memory (@{i}SIMPLEREQ@{ui}), but there is no alert attempt.
  The function may return TRUE (1) or FALSE if it cannot post the requester.
  (V36 will always return FALSE, but be sure to test for TRUE in case somebody
  reinstates the fallback alert.) If the window argument you supply is equal to
  NULL, a new window will be created for you in the Workbench screen, or the
  default public screen, for V36.If you want the requester created by this
  routine to be bound to a particular window (i.e., to appear in the same screen
  as the window), you should not supply a window argument of NULL.
  @{i}New for V36@{ui}: if you pass a NULL window pointer, the system requester
  will appear on the default public screen, which is not always the Workbench.
  The text arguments are used to construct the display.Each is a
  pointer to an instance of the structure IntuiText.
  The BodyText argument should be used to describe the nature of the requester.
  As usual with IntuiText data, you may link several lines of text together,
  and the text may be placed in various locations in the requester.This
  IntuiText pointer will be stored in the ReqText variable of the new requester.
  The PosText argument describes the text that you want associated with the
  user choice of "Yes,  TRUE,  Retry,  Good."  If the requester is successfully
  opened, this text will be rendered in a gadget in the lower-left of the
  requester, which gadget will have the GadgetID field set to TRUE.
  If the requester cannot be opened and the @{"DisplayAlert()" Link "DisplayAlert()"} mechanism is used,
  this text will be rendered in the lower-left corner of the alert display with
  additional text specifying that the left mouse button will select this choice.
  This pointer can be set to NULL, which specifies that there is no TRUE choice
  that can be made.
  The NegText argument describes the text that you want associated with the
  user choice of "No,  FALSE,  Cancel,  Bad."  If the requester is successfully
  opened, this text will be rendered in a gadget in the lower-right of the
  requester, which gadget will have the GadgetID field set to FALSE.
  If the requester cannot be opened and the @{"DisplayAlert()" Link "DisplayAlert()"} mechanism is used,
  this text will be rendered in the lower-right corner of the alert display with
  additional text specifying that the right mouse button will select this choice.
  This pointer cannot be set to NULL.There must always be a way for the user to
  cancel this requester.
  @{i}The Positive and Negative Gadgets created by this routine have
  the following features@{ui}:
  - @{b}GTYP_BOOLGADGET@{ub}
  - @{b}GACT_RELVERIFY@{ub}
  - @{b}GTYP_REQGADGET@{ub}
  - @{b}GACT_TOGGLESELECT@{ub}
  When defining the text for your gadgets, you may find it convenient to use the
  special constants used by Intuition for the construction of the gadgets.These
  include defines like @{i}AUTODRAWMODE@{ui}, @{i}AUTOLEFTEDGE@{ui}, @{i}AUTOTOPEDGE@{ui} and @{i}AUTOFRONTPEN@{ui}.
  You can find these in your local intuition.h (or intuition.i) file.
  These hard-coded constants are not very resolution or font sensitive,
  but V36 will override them to provide more modern layout.
  @{i}New for V36@{ui}, linked lists of IntuiText are not correctly supported
  for gadget labels.
  The width and height values describe the size of the requester.All
  of your BodyText must fit within the width and height of your
  requester.The gadgets will be created to conform to your sizes.
  @{b}@{u}VERY IMPORTANT NOTE@{uu}@{ub}: for this release of this procedure, a new window
  is opened in the same screen as the one containing your window.
  Future alternatives may be provided as a function distinct from this one.
  @{i}NOTE@{ui}: This function will pop the screen the requester and its window
  appears in to the front of all screens.New for V36,if the user
  doesn't perform any other screen arrangement before finishing
  with the requester, a popped screen will be pushed back behind.
SYNOPSIS
  @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *BuildSysRequest( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"IntuiText" Link "include:intuition/intuition.h/Main" 650} *,
    @{FG shine}struct@{FG text} IntuiText *, @{FG shine}struct@{FG text} IntuiText *, ULONG, WORD, WORD );
  @{i}@{b}ReqWindow@{ub}@{ui} = BuildSysRequest(@{i}Window@{ui},@{i}BodyText@{ui},@{i}PosText@{ui},@{i}NegText@{ui},@{i}IDCMPFlags@{ui},@{i}Width@{ui},@{i}Height@{ui})
   D0                          A0      A1       A2      A3      D0          D1    D2
  @{i}Window@{ui} = pointer to a Window structure
  @{i}BodyText@{ui} = pointer to an IntuiText structure
  @{i}PosText@{ui} = pointer to an IntuiText structure
  @{i}NegText@{ui} = pointer to an IntuiText structure
  @{i}IDCMPFlags@{ui} = the IDCMP flags you want used for the initialization of the
    IDCMP of the window containing this requester
  @{i}Width@{ui}, @{i}Height@{ui} = the size required to render your requester
    @{i}NOTE for V36:@{ui} the width and height you pass are ignored, as
    are some of the parameters of your IntuiText, so that Intuition
    can make the Requesters real nice for the new look.
  If the requester was successfully created, the value returned by this procedure
  is a pointer to the window in which the requester is rendered.If the requester
  could not be created, this routine might have called @{"DisplayAlert()" Link "DisplayAlert()"} before
  returning (it depends on the version) and will pass back TRUE if the user
  pressed the left mouse button and FALSE if the user pressed the right mouse
  button.If the version of Intuition doesn't call @{"DisplayAlert()" Link "DisplayAlert()"}, or if it does,
  and there's not enough memory for the alert, the value of FALSE is returned.
BUGS
  This procedure currently opens a window in the Screen which contains the
  window which is passed as a parameter, or the default public screen,
  if that parameter is NULL.Although not as originally envisioned,
  this will probably always be the behavior of this function.
  @{"DisplayAlert()" Link "DisplayAlert()"} is not called in version V36.
  It's almost impossible to make complete, correct account of different
  system fonts, window border dimensions, and screen resolution to get
  the layout of a System Requester just right using this routine.
  For V36, we recommend the automatic layout implemented in
  @{"BuildEasyRequestArgs()" Link "BuildEasyRequestArgs()"} and @{"EasyRequestArgs()" Link "EasyRequestArgs()"}.
SEE ALSO
  @{"FreeSysRequest()" Link "FreeSysRequest()"}, @{"DisplayAlert()" Link "DisplayAlert()"}, @{"ModifyIDCMP()" Link "ModifyIDCMP()"}, @{"exec.library/Wait()" Link "exec.guide/Wait()"},
  @{"Request()" Link "Request()"}, @{"AutoRequest()" Link "AutoRequest()"}, @{"EasyRequestArgs()" Link "EasyRequestArgs()"}, @{"BuildEasyRequestArgs()" Link "BuildEasyRequestArgs()"}
@EndNode
@Node "ChangeScreenBuffer()" "intuition.library/ChangeScreenBuffer"
@{b}@{u}ChangeScreenBuffer@{uu}@{ub} -- Swap the screen's BitMap.(V39)
  Performs double (or multiple) buffering on an Intuition screen in an
  Intuition-cooperative manner.The BitMap associated with the supplied
  ScreenBuffer will be installed in the specified screen, if possible.
  The previously-installed BitMap is available for re-use upon receiving
  a signal from graphics.library.See the graphics.library autodocs for
  graphics.library/AllocDBufInfo() and graphics.library/ChangeVPBitMap()
  for details.
SYNOPSIS  ULONG ChangeScreenBuffer( @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} *, @{FG shine}struct@{FG text} ScreenBuffer * );
  @{i}@{b}success@{ub}@{ui} = ChangeScreenBuffer( @{i}Screen@{ui}, @{i}ScreenBuffer@{ui} )
   D0                            A0       A1
  @{i}Screen@{ui}: pointer to the screen whose bitmap is to be swapped.
  @{i}ScreenBuffer@{ui}: pointer to a ScreenBuffer structure obtained from
    @{"AllocScreenBuffer()" Link "AllocScreenBuffer()"}.
  Returns non-zero if the operation succeeded.Returns zero
  if the operation cannot be performed.This function will
  fail if Intuition's state cannot permit it, for example the
  user is playing with menus or gadgets.
NOTES
  It is not required to restore the original ScreenBuffer
  before closing the screen.Simply @{"FreeScreenBuffer()" Link "FreeScreenBuffer()"} each
  buffer (including the original and the currently-installed one)
  then close the screen.Of course, you cannot call
  ChangeScreenBuffer() after freeing the currently-installed one.
SEE ALSO
  @{"AllocScreenBuffer()" Link "AllocScreenBuffer()"}, @{"FreeScreenBuffer()" Link "FreeScreenBuffer()"},
  graphics.library/ChangeVPBitMap()
@EndNode
@Node "ChangeWindowBox()" "intuition.library/ChangeWindowBox"
@{b}@{u}ChangeWindowBox@{uu}@{ub} -- Change window position and dimensions.(V36)
  Makes simultaneous changes in window position and dimensions,
  in absolute (not relative) coordinates.
  Like @{"MoveWindow()" Link "MoveWindow()"} and @{"SizeWindow()" Link "SizeWindow()"}, the effect of this function
  is deferred until the next input comes along.Unlike these
  functions, ChangeWindowBox() specifies absolute window position
  and dimensions, not relative.This makes for more reliable
  results considering that the action is deferred, so this
  function is typically preferable to @{"MoveWindow()" Link "MoveWindow()"} and @{"SizeWindow()" Link "SizeWindow()"} paired.
  You can detect that this operation has completed by receiving
  the @{i}IDCMP_CHANGEWINDOW@{ui} IDCMP message.
  The dimensions are limited to legal range, but you should still
  take care to specify sensible inputs based on the window's dimension
  limits and the size of its screen.
  This function limits the position and dimensions to legal values.
SYNOPSIS  @{FG shine}void@{FG text} ChangeWindowBox( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, WORD, WORD, WORD, WORD );
  ChangeWindowBox( @{i}Window@{ui}, @{i}Left@{ui}, @{i}Top@{ui}, @{i}Width@{ui}, @{i}Height@{ui} )
                    A0      D0     D1   D2     D3
  @{i}Window@{ui} = the window to change position/dimension
  @{i}Left@{ui}, @{i}Top@{ui}, @{i}Width@{ui}, @{i}Height@{ui} = new position and dimensions
  Position and dimension are changed to your specification, or as close as
  possible.Returns nothing.
SEE ALSO
  @{"MoveWindow()" Link "MoveWindow()"}, @{"SizeWindow()" Link "SizeWindow()"}, @{"ZipWindow()" Link "ZipWindow()"},
  @{"layers.library/MoveSizeLayer()" Link "ROMlibs.guide/MoveSizeLayer()"}
@EndNode
@Node "ClearDMRequest()" "intuition.library/ClearDMRequest"
@{b}@{u}ClearDMRequest@{uu}@{ub} -- Clear (detaches) the DMRequest of the window.
  Attempts to clear the DMRequest from the specified window,
  that is detaches the special requester that you attach to 
  the double-click of the menu button which the user can then 
  bring up on demand.This routine @{b}WILL NOT@{ub} clear the DMRequest
  if it's active (in use by the user).The IDCMP message class
  @{i}IDCMP_REQCLEAR@{ui} can be used to detect that the requester is not in use,
  but that message is sent only when the last of perhaps several
  requesters in use in a window is terminated.
SYNOPSIS  BOOL ClearDMRequest( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} * );
  @{i}@{b}Response@{ub}@{ui} = ClearDMRequest( @{i}Window@{ui} )
   D0                         A0
  @{i}Window@{ui} = pointer to the window from which the DMRequest is to be cleared.
  If the DMRequest was not currently in use, detaches the DMRequest
  from the window and returns TRUE.
  If the DMRequest was currently in use, doesn't change anything
  and returns FALSE.
SEE ALSO
  @{"SetDMRequest()" Link "SetDMRequest()"}, @{"Request()" Link "Request()"}
@EndNode
@Node "ClearMenuStrip()" "intuition.library/ClearMenuStrip"
@{b}@{u}ClearMenuStrip@{uu}@{ub} -- Clear (detach) the menu strip from the window.
  Detaches the current menu strip from the window; menu strips
  are attached to windows using the @{"SetMenuStrip()" Link "SetMenuStrip()"} function
  (or, for V36, @{"ResetMenuStrip()" Link "ResetMenuStrip()"} ).
  If the menu is in use (for that matter if any menu is in use)
  this function will block (Wait()) until the user has finished.
  Call this function before you make any changes to the data
  in a Menu or @{"MenuItem" Link "include:intuition/intuition.h/Main" 89} structure which is part of a menu
  strip linked into a window.
SYNOPSIS  @{FG shine}void@{FG text} ClearMenuStrip( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} * );
  ClearMenuStrip( @{i}Window@{ui} )
                   A0
  @{i}Window@{ui} = pointer to a window structure
SEE ALSO
  @{"SetMenuStrip()" Link "SetMenuStrip()"}, @{"ResetMenuStrip()" Link "ResetMenuStrip()"}
@EndNode
@Node "ClearPointer()" "intuition.library/ClearPointer"
@{b}@{u}ClearPointer@{uu}@{ub} -- Clear the mouse pointer definition from a window.
  Clears the window of its own definition of the Intuition mouse pointer.
  After calling ClearPointer(), every time this window is the active 
  one the default Intuition pointer will be the pointer displayed 
  to the user.If your window is the active one when this routine
  is called, the change will take place immediately.
  @{"Custom" Link "include:hardware/custom.h/Main" 25} definitions of the mouse pointer which this function clears
  are installed by a call to @{"SetPointer()" Link "SetPointer()"}.
SYNOPSIS  @{FG shine}void@{FG text} ClearPointer( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} * );
  ClearPointer( @{i}Window@{ui} )
                 A0
  @{i}Window@{ui} = pointer to the window to be cleared of its pointer definition
SEE ALSO
  @{"SetWindowPointerA()" Link "SetWindowPointerA()"}, @{"SetPointer()" Link "SetPointer()"}
@EndNode
@Node "CloseScreen()" "intuition.library/CloseScreen"
@{b}@{u}CloseScreen@{uu}@{ub} -- Close an Intuition screen.
  Unlinks the screen, unlinks the viewport, deallocates everything that
  Intuition allocated when the screen was opened (using @{"OpenScreen()" Link "OpenScreen()"}).
  Doesn't care whether or not there are still any windows attached to the
  screen.Doesn't try to close any attached windows; in fact, ignores
  them altogether (but see below for changes in V36).
  If this is the last screen to go, attempts to reopen Workbench.
  @{i}New for V36@{ui}: this function will refuse to close the screen
  if there are windows open on the screen or if there are any
  outstanding screen locks (see @{"LockPubScreen()" Link "LockPubScreen()"}) when
  CloseScreen() is called.This avoids the almost certain crash
  when a screen is closed out from under a window.
SYNOPSIS  BOOL CloseScreen( @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} * );
          /* returns BOOL in V36 and greater */
  @{i}@{b}Success@{ub}@{ui} = CloseScreen( @{i}Screen@{ui} )
   D0 (V36)               A0
  @{i}Screen@{ui} = pointer to the screen to be closed.
  @{i}New for V36@{ui}: returns TRUE (1) if screen is closed,
  returns FALSE (0) if screen had open windows when called.
SEE ALSO
  @{"OpenScreen()" Link "OpenScreen()"}
@EndNode
@Node "CloseWindow()" "intuition.library/CloseWindow"
@{b}@{u}CloseWindow@{uu}@{ub} -- Close an Intuition window.
  Closes an Intuition window.Unlinks it from the system, deallocates
  its memory, and makes it disappear.
  When this function is called, all IDCMP messages which have been sent
  to your window are deallocated.If the window had shared a message
  Port with other windows, you must be sure that there are no unreplied
  messages for this window in the message queue.Otherwise, your program
  will try to make use of a linked list (the queue) which contains free
  memory (the old messages).This will give you big problems.
  See the code fragment CloseWindowSafely(), below.
SYNOPSIS  @{FG shine}void@{FG text} CloseWindow( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} * );
  CloseWindow( @{i}Window@{ui} )
                A0
  @{i}Window@{ui} = a pointer to a Window structure
NOTES
  If you have added a Menu strip to this Window (via a call to
  @{"SetMenuStrip()" Link "SetMenuStrip()"}) you must be sure to remove that Menu strip
  (via a call to @{"ClearMenuStrip()" Link "ClearMenuStrip()"}) before closing your Window.
  This function may block until it is safe to de-link and free your window.
  Your program may thus be suspended while the user plays with gadgets,
  menus, or window sizes and position.
  @{i}New for V36@{ui}: If your window is a "Visitor Window" (see OpenWindow)
  CloseWindow will decrement the "visitor count" in the public screen on which
  the window was open.When the last visitor window is closed, a signal will be
  sent to the public screen task, if this was pre-arranged (see OpenScreen).
EXAMPLE
  /*  CloseWindowSafely */
  /* these functions close an Intuition window that shares a port with other
   * Intuition windows or IPC customers.
   * We are careful to set the UserPort to null before closing, and to free
   * any messages that it might have been sent.*/
  @{b}#include@{ub} "exec/types.h"
  @{b}#include@{ub} "exec/nodes.h"
  @{b}#include@{ub} "exec/lists.h"
  @{b}#include@{ub} "exec/ports.h"
  @{b}#include@{ub} "intuition/intuition.h"
  CloseWindowSafely( @{i}win@{ui} )
  @{FG shine}struct@{FG text} Window *@{i}win@{ui};
  {
    /* we forbid here to keep out of race conditions with Intuition */
    Forbid();
    /* send back any messages for this window that have not yet been processed */
    StripIntuiMessages( win->@{i}UserPort@{ui}, @{i}win@{ui} );
    /* clear UserPort so Intuition will not free it */
    win->@{i}UserPort@{ui} = NULL;
    /* tell Intuition to stop sending more messages */
    ModifyIDCMP( @{i}win@{ui}, 0L );
    /* turn multitasking back on */
    Permit();
    /* and really close the window */
    CloseWindow( @{i}win@{ui} );
  }
  /* remove and reply all IntuiMessages on a port that have been sent to a
   * particular window (note that we don't rely on the ln_Succ pointer
   * of a message after we have replied it) */
  StripIntuiMessages( @{i}mp@{ui}, @{i}win@{ui} )
  @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *@{i}mp@{ui};
  @{FG shine}struct@{FG text} Window *@{i}win@{ui};
  {
    @{FG shine}struct@{FG text} @{"IntuiMessage" Link "include:intuition/intuition.h/Main" 761} *@{i}msg@{ui};
    @{FG shine}struct@{FG text} @{"Node" Link "include:exec/nodes.h/Main" 22} *@{i}succ@{ui};
    @{i}msg@{ui} = (@{FG shine}struct@{FG text} IntuiMessage *) mp->mp_MsgList.@{i}lh_Head@{ui};
    @{FG shine}while@{FG text}( @{i}succ@{ui} =  msg->ExecMessage.mn_Node.@{i}ln_Succ@{ui} ) {
      @{FG shine}if@{FG text}( msg->@{i}IDCMPWindow@{ui} ==  @{i}win@{ui} ) {
        /* Intuition is about to free this message.
         * Make sure that we have politely sent it back.*/
        Remove( @{i}msg@{ui} );
        ReplyMsg( @{i}msg@{ui} );
      }
      @{i}msg@{ui} = (@{FG shine}struct@{FG text} IntuiMessage *) @{i}succ@{ui};
    }
  }
SEE ALSO
  @{"OpenWindow()" Link "OpenWindow()"}, @{"OpenScreen()" Link "OpenScreen()"}, @{"CloseScreen()" Link "CloseScreen()"}
@EndNode
@Node "CloseWorkBench()" "intuition.library/CloseWorkBench"
@{b}@{u}CloseWorkBench@{uu}@{ub} -- Closes the Workbench screen.
  This routine attempts to close the Workbench screen:
  - Test whether or not any applications have opened windows on the Workbench,
    and return FALSE if so.Otherwise ...
  - Clean up all special buffers 
  - Close the Workbench screen 
  - Make the Workbench program mostly inactive
    (it will still monitor disk activity)
  - Return TRUE 
SYNOPSIS  @{FG shine}long@{FG text} CloseWorkBench( @{FG shine}void@{FG text} );
  @{i}@{b}Success@{ub}@{ui} = CloseWorkBench()
   D0
  TRUE if the Workbench screen closed successfully 
  FALSE if the Workbench was not open, or if it has windows open which are not
    Workbench drawers.
NOTES
  This routine has been drastically rewritten for V36.It is much more solid,
  although we haven't eliminated all the problem cases yet.
BUGS
  The name of this function is improperly spelled.It ought to have been
  CloseWorkbench().
  It might be more convenient to have it return TRUE if the Workbench wasn't
  opened when called.The idea as it is now is probably this: if you want to
  free up the memory of the Workbench screen when your program begins, you can
  call CloseWorkBench().The return value of that call indicates whether you
  should call @{"OpenWorkBench()" Link "OpenWorkBench()"} when your program exits: if FALSE, that means
  either the the Workbench existed but you could not close it, or that it
  wasn't around to begin with, and you should not try to re-open it.
  We would prefer that you provide a user selection to attempt
  to open or close the Workbench screen from within your application,
  rather than your making assumptions like these.
SEE ALSO
  @{"OpenWorkBench()" Link "OpenWorkBench()"}
@EndNode
@Node "CurrentTime()" "intuition.library/CurrentTime"
@{b}@{u}CurrentTime@{uu}@{ub} -- Get the current time values.
  Puts copies of the current time into the supplied argument pointers.
  This time value is not extremely accurate, nor is it of a very fine 
  resolution.This time will be updated no more than sixty times a
  a second, and will typically be updated far fewer times a second.
SYNOPSIS  @{FG shine}void@{FG text} CurrentTime( ULONG *, ULONG * );
  CurrentTime( @{i}Seconds@{ui}, @{i}Micros@{ui} )
                A0       A1
  @{i}Seconds@{ui} = pointer to a long variable to receive the current seconds value
  @{i}Micros@{ui} = pointer to a long variable for the current microseconds value
  Puts the time values into the memory locations specified by the arguments
  Return value is not defined.
SEE ALSO
  @{"timer.device/TR_GETSYSTIME" Link "devices.guide/TR_GETSYSTIME"}
@EndNode
@Node "DisplayAlert()" "intuition.library/DisplayAlert"
@{b}@{u}DisplayAlert@{uu}@{ub} -- Create the display of an alert message.
  Creates an alert display with the specified message.
  If the system can recover from this alert, it's a @{i}RECOVERY_ALERT@{ui} and
  this routine waits until the user presses one of the mouse buttons, 
  after which the display is restored to its original state and a 
  BOOL value is returned by this routine to specify whether or not 
  the user pressed the LEFT mouse button.
  If the system cannot recover from this alert, it's a @{i}DEADEND_ALERT@{ui}
  and this routine returns immediately upon creating the alert display.
  The return value is FALSE.
  @{b}NOTE:@{ub} Starting with V33, if Intuition can't get enough
  memory for a @{i}RECOVERY_ALERT@{ui}, the value FALSE will be returned.
  AlertNumber is a @{FG shine}long@{FG text} value, historically related to the value
  sent to the @{"Alert()" Link "exec.guide/Alert()"} routine.But the only bits that are pertinent to
  this routine are the @{i}ALERT_TYPE@{ui} bit(s).These bits must be set to
  either @{i}RECOVERY_ALERT@{ui} for alerts from which the system may safely
  recover, or @{i}DEADEND_ALERT@{ui} for those fatal alerts.These states are
  described in the paragraph above.There is a third type of
  alert, the @{i}DAISY_ALERT@{ui}, which is used only by the Exec.
  The string argument points to an AlertMessage string.The AlertMessage
  string is comprised of one or more substrings, each of which is 
  composed of the following components:
  - first, a 16-bit x-coordinate and an 8-bit y-coordinate, describing where
    on the alert display you want this string to appear.
    The y-coordinate describes the offset to the baseline of the text.
  - then, the bytes of the string itself, which must be null-terminated
    (end with a byte of zero)
  - lastly, the continuation byte, which specifies whether or not there's another
    substring following this one.If the continuation byte is non-zero,there @{b}IS@{ub}
    another substring to be processed in this alert message.If the continuation
    byte is zero, this is the last substring in the message.
  The last argument, Height, describes how many video lines tall you want the
  alert display to be.
  @{i}New for V36@{ui}: Alerts are always rendered in Topaz 8 (80 column font),regardless
  of the system default font.Also, @{i}RECOVERY_ALERTs@{ui} are displayed in amber,
  while @{i}DEADEND_ALERTs@{ui} are still red.Alerts no longer push down the application
  screens to be displayed.Rather, they appear alone in a black display.
  @{i}Also new for V36:@{ui} Alerts block each other out, and input during an alert
  is deprived of the rest of the system.Internal input buffers still cause
  alert clicks to be processed by applications sometimes.
SYNOPSIS  BOOL DisplayAlert( ULONG, UBYTE *, UWORD );
  @{i}@{b}Response@{ub}@{ui} = DisplayAlert( @{i}AlertNumber@{ui}, @{i}String@{ui}, @{i}Height@{ui} )
   D0                       D0            A0      D1
  @{i}AlertNumber@{ui} = the number of this alert message.
    The only pertinent bits of this number are the @{i}ALERT_TYPE@{ui} bit(s).
    The rest of the number is ignored by this routine.
  @{i}String@{ui} = pointer to the alert message string, as described above
  @{i}Height@{ui} = minimum display lines required for your message
  Returns a BOOL value of TRUE or FALSE.
  If this is a @{i}DEADEND_ALERT@{ui}, FALSE is always the return value.
  If this is a @{i}RECOVERY_ALERT@{ui}, the return value will be TRUE if the user presses
  the left mouse button in response to your message, and FALSE if the user
  presses the right mouse button in response to your text,
  or if the alert could not be posted.
BUGS
  If the system is worse off than you think, the level of your alert
  may become @{i}DEADEND_ALERT@{ui} without you ever knowing about it.
  This will @{b}NOT@{ub} happen due simply to low memory.Rather, the alert
  display will be skipped, and FALSE will be returned.
  The left and right button clicks satisfying the alerts are
  unfortunately passed to the normal applications, because of
  some internal system input buffering.
SEE ALSO
  @{"TimedDisplayAlert()" Link "TimedDisplayAlert()"}
@EndNode
@Node "DisplayBeep()" "intuition.library/DisplayBeep"
@{b}@{u}DisplayBeep@{uu}@{ub} -- Flash the video display.
  "Beeps" the video display by flashing the background color of the specified
  screen.If the screen argument is NULL, every screen in the display will be
  beeped.Flashing everyone's screen is not a polite thing to do, so this should
  be reserved for dire circumstances.The reason such a routine is supported is
  because the Amiga has no internal bell or speaker.When the user needs to know
  of an event that is not serious enough to require the use of a requester,
  the DisplayBeep() function may be called.
  @{i}New for V36@{ui}: Intuition now calls DisplayBeep through the external library
  vector.This means that if you call @{"SetFunction()" Link "exec.guide/SetFunction()"} to replace DisplayBeep
  with an audible beep, for example, then your change will affect even
  Intuition's calls to DisplayBeep.
SYNOPSIS  @{FG shine}void@{FG text} DisplayBeep( @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} * );
  DisplayBeep( @{i}Screen@{ui} )
                A0
  @{i}Screen@{ui} = pointer to a screen.
    If NULL, every screen in the display will be flashed
NOTES
  Since this function changes color zero of the affected screen(s),
  surprising results could occur if the screen's owner reading
  colors or perhaps cycling them.
@EndNode
@Node "DisposeObject()" "intuition.library/DisposeObject"
@{b}@{u}DisposeObject@{uu}@{ub} -- Deletes a 'boopsi' object.(V36)
  Deletes a boopsi object and all of it auxiliary data.
  These objects are all created by @{"NewObject()" Link "NewObject()"}.Objects
  of certain classes "own" other objects, which will also
  be deleted when the object is passed to DisposeObject().
  Read the per-class documentation carefully to be aware
  of these instances.
SYNOPSIS  @{FG shine}void@{FG text} DisposeObject( APTR );
  DisposeObject( @{i}Object@{ui} )
                  A0
  @{i}Object@{ui} = abstract pointer to a boopsi object returned by @{"NewObject()" Link "NewObject()"}.
    The pointer may be NULL, in which case this function has no effect.
NOTES
  This function invokes the @{i}OM_DISPOSE@{ui} method.
SEE ALSO
  @{"NewObject()" Link "NewObject()"}, SetAttrs(), @{"GetAttr()" Link "GetAttr()"}, @{"MakeClass()" Link "MakeClass()"},
  Document "Basic Object-Oriented Programming System for Intuition"
  and the "boopsi Class Reference" document.
@EndNode
@Node "DoGadgetMethodA()" "intuition.library/DoGadgetMethodA"
@{b}@{u}DoGadgetMethodA@{uu}@{ub} -- Invoke method on a boopsi gadget.(V39)
@{b}@{u}DoGadgetMethod@{uu}@{ub}  -- Varargs stub for DoGadgetMethodA().(V39)
  Same as the @{"DoMethod()" Link "amiga_lib.guide/DoMethod()"} function of amiga.lib, but provides context information
  and arbitration for classes which implement custom Intuition gadgets.
  You should use this function for boopsi gadget objects, or for "models"
  which propagate information to gadgets.
  Unlike @{"DoMethod()" Link "amiga_lib.guide/DoMethod()"}, this function provides a @{"GadgetInfo" Link "include:intuition/cghooks.h/Main" 25} pointer
  (if possible) when invoking the method.Some classes may require
  or benefit from this.
SYNOPSIS
  ULONG DoGadgetMethodA( @{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *,
    Msg );
  ULONG DoGadgetMethod ( @{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *,
    ULONG, ...);
  @{i}@{b}result@{ub}@{ui} = DoGadgetMethodA( @{i}Gadget@{ui}, @{i}Window@{ui}, @{i}Requester@{ui}, @{i}Message@{ui} )
   D0                        A0      A1       A2         A3
  @{i}@{b}result@{ub}@{ui} = DoGadgetMethod ( @{i}Gadget@{ui}, @{i}Window@{ui}, @{i}Requester@{ui}, @{i}MethodID@{ui}, ...)
  @{i}Gadget@{ui} = abstract pointer to a boopsi gadget
  @{i}Window@{ui} = window gadget has been added to using @{"AddGList()" Link "AddGList()"} or @{"AddGadget()" Link "AddGadget()"}
  @{i}Requester@{ui} = for @{i}REQGADGETs@{ui}, requester containing the gadget
  @{i}Msg@{ui} = the boopsi message to send
  The object does whatever it wants with the message you sent, which might
  include updating its gadget visuals.The return value is defined per-method.
NOTES
  This function invokes the specified method with a @{"GadgetInfo" Link "include:intuition/cghooks.h/Main" 25}
  derived from the 'Window' and 'Requester' pointers.The GadgetInfo
  is passed as the second parameter of the message, except for
  @{i}OM_NEW@{ui}, @{i}OM_SET@{ui}, @{i}OM_NOTIFY@{ui}, and @{i}OM_UPDATE@{ui}, where the GadgetInfo
  is passed as the third parameter.
  Implementers of new gadget methods should ensure that the
  GadgetInfo is the second long-word of their message!
SEE ALSO
  @{"NewObject()" Link "NewObject()"}, @{"DisposeObject()" Link "DisposeObject()"}, @{"GetAttr()" Link "GetAttr()"}, @{"MakeClass()" Link "MakeClass()"},
  Document "Basic Object-Oriented Programming System for Intuition"
  and the "boopsi Class Reference" document.
@EndNode
@Node "DoubleClick()" "intuition.library/DoubleClick"
@{b}@{u}DoubleClick@{uu}@{ub} -- Test two time values for double-click timing.
  Compares the difference in the time values with the double-click 
  timeout range that the user has set (using the "Preferences" tool) or 
  some other program has configured into the system.If the
  difference between the specified time values is within the current 
  double-click time range, this function returns TRUE, else it returns FALSE.
  These time values can be found in input events and IDCMP messages.
  The time values are not perfect; however, they are precise enough for 
  nearly all applications.
SYNOPSIS  BOOL DoubleClick( ULONG, ULONG, ULONG, ULONG );
  @{i}@{b}IsDouble@{ub}@{ui} = DoubleClick( @{i}StartSecs@{ui}, @{i}StartMicros@{ui}, @{i}CurrentSecs@{ui}, @{i}CurrentMicros@{ui} )
   D0                      D0          D1           D2           D3
  @{i}StartSeconds@{ui}, @{i}StartMicros@{ui} = the timestamp value describing the start of
    the double-click time period you are considering
  @{i}CurrentSeconds@{ui}, @{i}CurrentMicros@{ui} = the timestamp value describing
    the end of the double-click time period you are considering
  If the difference between the supplied timestamp values is within the
  double-click time range in the current set of Preferences, this
  function returns TRUE, else it returns FALSE.
SEE ALSO
  @{"CurrentTime()" Link "CurrentTime()"}
@EndNode
@Node "DrawBorder()" "intuition.library/DrawBorder"
@{b}@{u}DrawBorder@{uu}@{ub} -- Draw the specified Border structure into a RastPort.
  First, sets up the draw mode and pens in the RastPort according to the
  arguments of the Border structure.Then, draws the vectors of the
  border argument into the RastPort, offset by the left and top offsets.
  As with all graphics rendering routines, the border will be clipped to
  to the boundaries of the RastPort's layer, if it exists.This is
  the case with window RastPorts.
  This routine will draw all borders in the NULL-terminated list linked
  by the NextBorder field of the border argument.
SYNOPSIS  @{FG shine}void@{FG text} DrawBorder( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, @{FG shine}struct@{FG text} @{"Border" Link "include:intuition/intuition.h/Main" 673} *, WORD, WORD );
  DrawBorder( @{i}RastPort@{ui}, @{i}Border@{ui}, @{i}LeftOffset@{ui}, @{i}TopOffset@{ui} )
               A0        A1      D0           D1
  @{i}RastPort@{ui} = pointer to the RastPort to receive the border rendering
  @{i}Border@{ui} = pointer to a Border structure
  @{i}LeftOffset@{ui} = the offset to be added to each vector's x coordinate
  @{i}TopOffset@{ui} = the offset to be added to each vector's y coordinate
@EndNode
@Node "DrawImage()" "intuition.library/DrawImage"
@{b}@{u}DrawImage@{uu}@{ub} -- Draw the specified Image structure into a RastPort.
  First, sets up the draw mode and pens in the RastPort according to the
  arguments of the Image structure.Then, moves the image data of
  the image argument into the RastPort, offset by the left and top offsets.
  This routine does window layer clipping if you pass your window's (layered)
  RastPort -- if you draw an image outside of your window, your imagery will be
  clipped at the window's edge.If you pass a (non-layered) screen RastPort,
  you @{b}MUST@{ub} be sure your image is wholly contained within the rastport bounds.
  If the NextImage field of the image argument is non-NULL, the next image is
  rendered as well, and so on until some NextImage field is found to be NULL.
SYNOPSIS  @{FG shine}void@{FG text} DrawImage( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, @{FG shine}struct@{FG text} @{"Image" Link "include:intuition/intuition.h/Main" 700}  *, WORD, WORD );
  DrawImage( @{i}RastPort@{ui}, @{i}Image@{ui}, @{i}LeftOffset@{ui}, @{i}TopOffset@{ui} )
              A0        A1     D0           D1
  @{i}RastPort@{ui} = pointer to the RastPort to receive image rendering
  @{i}Image@{ui} = pointer to an image structure
  @{i}LeftOffset@{ui} = the offset which will be added to the image's x coordinate
  @{i}TopOffset@{ui} = the offset which will be added to the image's y coordinate
NOTES
  Intuition always has and will continue to assume there are at least as many
  planes of data pointed to by ImageData as there are '1' bits in the PlanePick
  field.Please ensure that this is so.(See the intuition.h include file for
  full details on using PlanePick).
SEE ALSO
  @{"DrawImageState()" Link "DrawImageState()"}, @{"EraseImage()" Link "EraseImage()"}
@EndNode
@Node "DrawImageState()" "intuition.library/DrawImageState"
@{b}@{u}DrawImageState@{uu}@{ub} -- Draw an (extended) Intuition Image with special visual state.(V36)
  This function draws an Intuition Image structure in a variety of
  "visual states," which are defined by constants in
  @{"intuition/imageclass.h" Link "include:intuition/imageclass.h/Main" 0}.These include:
    @{b}IDS_NORMAL@{ub} - like @{"DrawImage()" Link "DrawImage()"}
    @{b}IDS_SELECTED@{ub} - represents the "selected state" of a @{"Gadget" Link "include:intuition/intuition.h/Main" 215}
    @{b}IDS_DISABLED@{ub} - the "ghosted state" of a gadget
    @{b}IDS_BUSY@{ub} - for future functionality
    @{b}IDS_INDETERMINATE@{ub} - for future functionality
    @{b}IDS_INACTIVENORMAL@{ub} - for gadgets in window border
    @{b}IDS_INACTIVESELECTED@{ub} - for gadgets in window border
    @{b}IDS_INACTIVEDISABLED@{ub} - for gadgets in window border
  Only IDS_NORMAL will make sense for traditional Image structures,
  this function is more useful when applied to new custom images
  or "object-oriented image classes."
  Each class of custom images is responsible for documenting which
  visual states it supports, and you typically want to use images
  which support the appropriate states with your custom gadgets.
  The DrawInfo parameter provides information invaluable to
  "rendered" images, such as pen color and resolution.Each
  image class must document whether this parameter is required.
SYNOPSIS
  @{FG shine}void@{FG text} DrawImageState( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, @{FG shine}struct@{FG text} @{"Image" Link "include:intuition/intuition.h/Main" 700} *, WORD, WORD, ULONG,
    @{FG shine}struct@{FG text} @{"DrawInfo" Link "include:intuition/screens.h/Main" 60} * );
  DrawImageState( @{i}RPort@{ui}, @{i}Image@{ui}, @{i}LeftOffset@{ui}, @{i}TopOffset@{ui}, @{i}State@{ui}, @{i}DrawInfo@{ui} )
                   A0     A1     D0           D1         D2     A2
  @{i}RPort@{ui} - RastPort for rendering
  @{i}Image@{ui} - pointer to a (preferably custom) image
  @{i}LeftOffset@{ui},@{i}RightOffset@{ui} - positional offsets in pixels
  @{i}State@{ui} - visual state selected from above
  @{i}DrawInfo@{ui} - pointer to packed of pen selections and resolution.
EXAMPLE
  Provided separately in the DevCon '90 disk set.
SEE ALSO
  @{"DrawImage()" Link "DrawImage()"}, @{"GetScreenDrawInfo()" Link "GetScreenDrawInfo()"}, @{"intuition/imageclass.h" Link "include:intuition/imageclass.h/Main" 0}
@EndNode
@Node "EasyRequestArgs()" "intuition.library/EasyRequestArgs"
@{b}@{u}EasyRequestArgs@{uu}@{ub} -- Easy alternative to @{"AutoRequest()" Link "AutoRequest()"}.(V36)
@{b}@{u}EasyRequest@{uu}@{ub}     -- Varargs stub for EasyRequestArgs().(V36)
  This function provides a simpler method of using a 'System Requester' than
  provided by @{"AutoRequest()" Link "AutoRequest()"}.It performs layout and size calculations
  sensitive to the current font and screen resolution.
  It provides for the descriptive 'body' text and the gadget text to be
  constructed from 'printf' style format strings.It also provides a general
  way for the requester to be sensitive to particular IDCMP messages.
  The first function listed is the actual Intuition library function.It is passed
  the arguments for the formatting operations as a pointer to the first argument.
  The second function uses a C-style variable number of argument (varargs)
  calling convention.It should be implemented as a call to the first function,
  and might be supplied by your compiler vendor, in amiga.lib, or using the
  first  example below, for most C compilers.
  @{i}NOTE@{ui}: The formatting is done by @{"exec.library/RawDoFmt()" Link "exec.guide/RawDoFmt()"}, so be aware that to
  display a 32-bit integer argument, for example, you must say "%ld", not "%d",
  since @{"RawDoFmt()" Link "exec.guide/RawDoFmt()"} is "word-oriented."
  @{i}NOTE@{ui}: This function switches the processor stack to ensure sufficient stack
  space for the function to complete.
SYNOPSIS
  @{FG shine}long@{FG text} EasyRequestArgs(@{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *,@{FG shine}struct@{FG text} @{"EasyStruct" Link "include:intuition/intuition.h/Main" 1455} *, ULONG *, APTR );
  @{FG shine}long@{FG text} EasyRequest    (@{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *,@{FG shine}struct@{FG text} @{"EasyStruct" Link "include:intuition/intuition.h/Main" 1455} *, ULONG *, APTR, ...);
  @{i}@{b}num@{ub}@{ui} = EasyRequestArgs( @{i}Window@{ui}, @{i}easyStruct@{ui}, @{i}IDCMP_ptr@{ui}, @{i}ArgList@{ui} )
   D0                     A0      A1           A2         A3
  @{i}@{b}num@{ub}@{ui} = EasyRequest    ( @{i}Window@{ui}, @{i}easyStruct@{ui}, @{i}IDCMP_ptr@{ui}, @{i}Arg1@{ui}, @{i}Arg2@{ui}, ...)
  @{i}Window@{ui} = Reference window pointer, determines the screen and title of the
    requester window.This can be NULL, which means the requester is to
    appear on the Workbench screen, or default public screen, if defined.
  @{i}IDCMP_ptr@{ui} = Pointer to IDCMP flags that you want to terminate the requester.
    This pointer may be NULL.
  @{i}easyStruct@{ui} = Pointer to EasyStruct structure with fields interpreted as follows:
    @{i}es_StructSize@{ui} = @{FG shine}sizeof@{FG text} (@{FG shine}struct@{FG text} EasyStruct), for future extension.
    @{i}es_Flags@{ui} = 0 for now, in the future may specify other options.
    @{i}es_Title@{ui} = Title of system requester window.If this is NULL,
      the title will be taken to be the same as the title of 'Window',
      if provided, or else "System Request."
    @{i}es_TextFormat@{ui} = Format string, a la @{"RawDoFmt()" Link "exec.guide/RawDoFmt()"}, for message in
      requester body.Lines are separated by the newline character.
      This character is represented in C by '\n', in the Amiga Shell
      by "*N", etc.Formatting '%' functions are supported exactly
      as in @{"RawDoFmt()" Link "exec.guide/RawDoFmt()"}.
    @{i}es_GadgetFormat@{ui} = Format string for gadgets.Text for separate
      gadgets is separated by '|'.Format functions are supported.
      You @{b}MUST@{ub} specify at least one gadget.
    @{i}ArgList@{ui} = Arguments for format commands.
      Arguments for GadFmt follow arguments for TextFmt.
    @{i}0, 1, ..., N@{ui} = Successive GadgetID values, for the gadgets you specify
      for the requester.
      @{b}NOTE:@{ub} The numbering from left to right is actually: 1, 2, ..., N, 0.
      This is for compatibility with @{"AutoRequest()" Link "AutoRequest()"}, which has FALSE
      for the rightmost gadget.
   @{i}-1@{ui} = Means that one of the caller-supplied IDCMPFlags occurred.
      The IDCMPFlag value is in the longword pointed to by IDCMP_ptr.
EXAMPLES
  /* varargs interface works for most C compilers */
  EasyRequest( @{i}w@{ui}, @{i}es@{ui}, @{i}ip@{ui}, @{i}arg1@{ui} )
  @{FG shine}struct@{FG text} Window *@{i}w@{ui};
  @{FG shine}struct@{FG text} EasyStruct *@{i}es@{ui};
  ULONG *@{i}ip@{ui};
  @{FG shine}int@{FG text}   @{i}arg1@{ui};
  {
    @{FG shine}return@{FG text} ( EasyRequestArgs( @{i}w@{ui}, @{i}es@{ui}, @{i}ip@{ui}, @{i}&arg1@{ui} ) );
  }
  /* typical use */
  @{FG shine}struct@{FG text} EasyStruct @{i}volumeES@{ui} = {
    @{FG shine}sizeof@{FG text} (@{FG shine}struct@{FG text} EasyStruct),
    0,
    "Volume Request",
    "Please insert volume %s in any drive.",
    "Retry|Cancel",
  };
  @{b}#define@{ub} CANCEL  (0)
  Volume * getVolume( @{i}volname@{ui} )
  UBYTE *@{i}volname@{ui};
  {
    Volume *@{i}vptr@{ui};
    Volume *@{i}findVolume@{ui}();
    UWORD @{i}reply@{ui};
    ULONG @{i}iflags@{ui};
    @{i}iflags@{ui} = IDCMP_DISKINSERTED;
    @{FG shine}while@{FG text} ( ((@{i}vptr@{ui} = findVolume( @{i}volname@{ui} )) == NULL) &&
     (EasyRequest( @{i}w@{ui}, @{i}&volumeES@{ui}, @{i}&iflags@{ui}, @{i}volname@{ui} ) != CANCEL) )
     /* loop */ ;
     /* note that in some circumstances, you will have to re-initialize the
     value of 'iflags'.Here, it is either unchanged, or returned as the single
     IDCMPFlag value @{i}IDCMP_DISKINSERTED@{ui}.If you combine multiple IDCMPFlag
     values in 'iflags,' only one will be returned, so you must reinitialize
     'iflags' to be the combination. */
     @{FG shine}return@{FG text} ( @{i}vptr@{ui} );
  }
NOTES
  When DOS brings up EasyRequests() on your process (eg. "Please insert volume
  XXX in any drive", they normally come up on the default public screen, which
  is usually the Workbench screen.
  If you set your @{"Process" Link "include:dos/dosextens.h/Main" 37} @{i}pr_WindowPtr@{ui} field to point to one of your windows,
  then DOS will bring its requesters up on the same screen as that window.
  A @{i}pr_WindowPtr@{ui} of -1 prevents requesters from coming up at all.
  (Some FileSystem requesters cannot be redirected or supressed).
BUGS
  Does not fall back to a recoverable alert if the requester cannot be created.
  Does not handle case when gadgets don't fit or window title is too long,
  although it does trim trailing spaces from thetitle for calculating dimensions.
PLANS
  Possible enhancements include: centering of text, size-sensitive layout,
  window-relative requester, vertical gadget layout, window placement,
  more keyboard shortcuts.We also reserve the use of the newline character
  ('\n') in gadget format strings for future use as a line separator.
SEE ALSO
  @{"exec.library/RawDoFmt()" Link "exec.guide/RawDoFmt()"}, @{"BuildEasyRequestArgs()" Link "BuildEasyRequestArgs()"}, @{"SysReqHandler()" Link "SysReqHandler()"},
  @{"AutoRequest()" Link "AutoRequest()"}, @{"BuildSysRequest()" Link "BuildSysRequest()"}
@EndNode
@Node "EndRefresh()" "intuition.library/EndRefresh"
@{b}@{u}EndRefresh@{uu}@{ub} -- End the optimized refresh state of the window.
  This function gets you out of the special refresh state of your window.
  It is called following a call to @{"BeginRefresh()" Link "BeginRefresh()"} routine, which puts you
  into the special refresh state.While your window is in the refresh state,
  the only rendering that will be wrought in your window will be to those areas
  which were recently revealed and need to be refreshed.
  After you've done all the refreshing you want to do for this window, 
  you should call this routine to restore the window to its non-refreshing
  state.Then all rendering will go to the entire window, as usual.
  The 'Complete' argument is a boolean TRUE or FALSE value used to describe
  whether or not the refreshing you've done was all the refreshing that needs
  to be done at this time.Most often, this argument will be TRUE.But if,
  for instance, you have multiple tasks or multiple procedure calls which
  must run to completely refresh the window, then each can call its own
  Begin/EndRefresh() pair with a Complete argument of FALSE, and only the
  last calls with a Complete argument of TRUE.
@{b}WARNING:@{ub}Passing this function the value of FALSE has its pitfalls.
  Please see the several caveats in the autodoc for @{"BeginRefresh()" Link "BeginRefresh()"}.
  For your information, this routine calls the Layers library function
  @{"EndUpdate()" Link "ROMlibs.guide/EndUpdate()"}, unlocks your layers (calls @{"UnlockLayerRom()" Link "graphics.guide/UnlockLayerRom()"}), clears
  the @{i}LAYERREFRESH@{ui} bit in your @{"Layer" Link "include:graphics/clip.h/Main" 27} Flags, and clears the
  @{i}WFLG_WINDOWREFRESH@{ui} bit in your window Flags.
SYNOPSIS  @{FG shine}void@{FG text} EndRefresh( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, BOOL );
  EndRefresh( Window, Complete )
               A0      D0
  @{i}Window@{ui} = pointer to the window currently in optimized-refresh mode
  @{i}Complete@{ui} = Boolean TRUE or FALSE describing whether or not this window
    is completely refreshed
SEE ALSO
  @{"BeginRefresh()" Link "BeginRefresh()"}, @{"layers.library/EndUpdate()" Link "ROMlibs.guide/EndUpdate()"},
  @{"graphics.library/UnlockLayerRom()" Link "graphics.guide/UnlockLayerRom()"}
@EndNode
@Node "EndRequest()" "intuition.library/EndRequest"
@{b}@{u}EndRequest@{uu}@{ub} -- Remove a currently active requester.
  Ends the request by erasing the requester and decoupling it from the window.
  Note that this doesn't necessarily clear all requesters from the window,
  only the specified one.If the window labors under other requesters,
  they will remain in the window.
SYNOPSIS  @{FG shine}void@{FG text} EndRequest( @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} * );
  EndRequest( @{i}Requester@{ui}, @{i}Window@{ui} )
               A0         A1
  @{i}Requester@{ui} = pointer to the requester to be removed
  @{i}Window@{ui} = pointer to the Window structure with which this requester
    is associated
SEE ALSO
  @{"Request()" Link "Request()"}
@EndNode
@Node "EraseImage()" "intuition.library/EraseImage"
@{b}@{u}EraseImage@{uu}@{ub} -- Erases an Image.(V36)
  Erases an Image.For a normal Image structure, this will call
  the graphics function @{"EraseRect()" Link "graphics.guide/EraseRect()"} (clear using layer backfill,
  if any) for the Image box (LeftEdge/TopEdge/Width/Height).
  For custom image, the exact behavior is determined by the custom image class.
SYNOPSIS  @{FG shine}void@{FG text} EraseImage( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, @{FG shine}struct@{FG text} @{"Image" Link "include:intuition/intuition.h/Main" 700} *, WORD, WORD );
  EraseImage( @{i}RPort@{ui}, @{i}Image@{ui}, @{i}LeftOffset@{ui}, @{i}TopOffset@{ui} )
               A0     A1      D0          D1
  @{i}RPort@{ui} - RastPort to erase a part of
  @{i}Image@{ui} - custom or standard image
  @{i}LeftOffset@{ui},@{i}RightOffset@{ui} - pixel offsets of Image position
SEE ALSO
  @{"graphics.library/EraseRect()" Link "graphics.guide/EraseRect()"}.
@EndNode
@Node "FreeClass()" "intuition.library/FreeClass"
@{b}@{u}FreeClass@{uu}@{ub} -- Frees a boopsi class created by @{"MakeClass()" Link "MakeClass()"}.For class implementors
  only. (V36)
  Tries to free a boopsi class created by MakeClass().This won't always succeed:
  classes with outstanding objects or with subclasses cannot be freed.You cannot
  allow the code which implements the class to be unloaded in this case.
  For public classes, this function will *always* remove the class (see
  @{"RemoveClass()" Link "RemoveClass()"} ) making it unavailable, whether it succeeds or not.
  If you have a dynamically allocated data for your class (hanging off of
  @{i}cl_UserData@{ui}), try to free the class before you free the user data, so you
  don't get stuck with a half-freed class.
SYNOPSIS  BOOL FreeClass( @{FG shine}struct@{FG text} IClass * );
  @{i}@{b}success@{ub}@{ui} = FreeClass( @{i}ClassPtr@{ui} )
   D0                   A0
  @{i}ClassPtr@{ui} - pointer to a class created by @{"MakeClass()" Link "MakeClass()"}.
  Returns FALSE if the class could not be freed.Reasons include, but will not
  be limited to, having non-zero @{i}cl_ObjectCount@{ui} or @{i}cl_SubclassCount@{ui}.
  Returns TRUE if the class could be freed.
  Calls @{"RemoveClass()" Link "RemoveClass()"} for the class in either case.
EXAMPLE
  Freeing a private class with dynamically allocated user data:
  freeMyClass( @{i}cl@{ui} )
  @{FG shine}struct@{FG text} IClass *@{i}cl@{ui};
  {
    @{FG shine}struct@{FG text} MyPerClassData *@{i}mpcd@{ui};
    @{i}mpcd@{ui} = (@{FG shine}struct@{FG text} MyPerClassData *) cl->@{i}cl_UserData@{ui};
    @{FG shine}if@{FG text} ( FreeClass( @{i}cl@{ui} ) ){
      FreeMem( @{i}mpcd@{ui}, @{FG shine}sizeof@{FG text} @{i}mpcd@{ui} );
      @{FG shine}return@{FG text} ( TRUE );
    } @{FG shine}else@{FG text} {
      @{FG shine}return@{FG text} ( FALSE );
    }
  }
SEE ALSO
  @{"MakeClass()" Link "MakeClass()"},
  Document "Basic Object-Oriented Programming System for Intuition"
  and the "boopsi Class Reference" document.
@EndNode
@Node "FreeRemember()" "intuition.library/FreeRemember"
@{b}@{u}FreeRemember@{uu}@{ub} -- Free memory allocated by calls to @{"AllocRemember()" Link "AllocRemember()"}.
  This function frees up memory allocated by the @{"AllocRemember()" Link "AllocRemember()"} function.
  It will either free up just the Remember structures, which supply the
  link nodes that tie your allocations together, or it will deallocate
  both the link nodes @{b}AND@{ub} your memory buffers too.
  If you want to deallocate just the Remember structure link nodes, you should
  set the ReallyForget argument to FALSE.However, if you want FreeRemember to
  really deallocate all the memory, including both the Remember structure link
  nodes and the buffers you requested via earlier calls to @{"AllocRemember()" Link "AllocRemember()"},
  then you should set the ReallyForget argument to TRUE.
  @{b}NOTE WELL:@{ub} Once you call this function passing it FALSE, the linkages
  between all the memory chunks are lost, and you cannot subsequently use
  FreeRemember() to free them.
SYNOPSIS  @{FG shine}void@{FG text} FreeRemember( @{FG shine}struct@{FG text} @{"Remember" Link "include:intuition/intuition.h/Main" 1424} **, BOOL );
  FreeRemember( @{i}RememberKey@{ui}, @{i}ReallyForget@{ui} )
                 A0           D0
  @{i}RememberKey@{ui} = the address of a pointer to structure Remember.
    This pointer should either be NULL or set to some value (possibly NULL)
    by a call to @{"AllocRemember()" Link "AllocRemember()"}.
  @{i}ReallyForget@{ui} = a BOOL FALSE or TRUE describing, respectively,
    whether you want to free up only the Remember nodes or if you want
    this procedure to really forget about all of the memory, including
    both the nodes and the memory buffers referenced by the nodes.
EXAMPLE
  @{FG shine}struct@{FG text} Remember *@{i}RememberKey@{ui};
  @{i}RememberKey@{ui} = NULL;
  AllocRemember(@{i}&RememberKey@{ui}, BUFSIZE, MEMF_CHIP);
  FreeRemember(@{i}&RememberKey@{ui}, TRUE);
SEE ALSO
  @{"AllocRemember()" Link "AllocRemember()"}, @{"exec.library/FreeMem()" Link "exec.guide/FreeMem()"}
@EndNode
@Node "FreeScreenBuffer()" "intuition.library/FreeScreenBuffer"
@{b}@{u}FreeScreenBuffer@{uu}@{ub} -- Free a ScreenBuffer structure.(V39)
  Frees a ScreenBuffer structure you got from @{"AllocScreenBuffer()" Link "AllocScreenBuffer()"},
  and releases associated resources.You must call FreeScreenBuffer()
  before you close your screen.
SYNOPSIS  @{FG shine}void@{FG text} FreeScreenBuffer( @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} *, @{FG shine}struct@{FG text} ScreenBuffer * );
  FreeScreenBuffer( @{i}Screen@{ui}, @{i}ScreenBuffer@{ui} )
                     A0      A1
  @{i}Screen@{ui}: pointer to the screen this ScreenBuffer is associated with.
  @{i}ScreenBuffer@{ui}: pointer to a ScreenBuffer structure obtained from
    @{"AllocScreenBuffer()" Link "AllocScreenBuffer()"}.It is safe to call this function with a NULL argument.
    It will have no effect.
NOTES
  Originally, FreeScreenBuffer() did not @{"WaitBlit()" Link "graphics.guide/WaitBlit()"} before freeing
  a BitMap.The intent was that the application should do this.
  However, as this sort of thing is easily forgotten, @{"WaitBlit()" Link "graphics.guide/WaitBlit()"}
  was added in @{b}V40@{ub}.Application writers should ensure that freeing
  the buffer is safe by calling @{"WaitBlit()" Link "graphics.guide/WaitBlit()"} themselves.
  The @{i}SB_SCREEN_BITMAP@{ui} flag instructs @{"AllocScreenBuffer()" Link "AllocScreenBuffer()"} to provide
  a ScreenBuffer referring to the screen's actual bitmap.When you
  are done changing screen buffers, you must FreeScreenBuffer()
  the currently-installed ScreenBuffer before you close the screen.
  Intuition will recognize when FreeScreenBuffer() is called for
  the currently-installed ScreenBuffer, and will know to free the
  supporting structures but not the BitMap.@{"CloseScreen()" Link "CloseScreen()"} will
  take care of that.
SEE ALSO
  @{"AllocScreenBuffer()" Link "AllocScreenBuffer()"}, @{"ChangeScreenBuffer()" Link "ChangeScreenBuffer()"},
  graphics.library/ChangeVPBitMap()
@EndNode
@Node "FreeScreenDrawInfo()" "intuition.library/FreeScreenDrawInfo"
@{b}@{u}FreeScreenDrawInfo@{uu}@{ub} -- Finish using a DrawInfo structure.(V36)
  Declares that you are finished with the DrawInfo structure
  returned by @{"GetScreenDrawInfo()" Link "GetScreenDrawInfo()"}.
SYNOPSIS  @{FG shine}void@{FG text} FreeScreenDrawInfo( @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} *, @{FG shine}struct@{FG text} @{"DrawInfo" Link "include:intuition/screens.h/Main" 60} * );
  FreeScreenDrawInfo( @{i}Screen@{ui}, @{i}DrInfo@{ui} )
                       A0      A1
  @{i}Screen@{ui} - pointer to screen passed to @{"GetScreenDrawInfo()" Link "GetScreenDrawInfo()"}.
  @{i}DrInfo@{ui} - pointer to DrawInfo returned by @{"GetScreenDrawInfo()" Link "GetScreenDrawInfo()"}.
    A NULL DrawInfo pointer is a valid parameter, signifying "do nothing".
NOTES
  This function, and @{"GetScreenDrawInfo()" Link "GetScreenDrawInfo()"}, don't really do much, but
  they provide an upward compatibility path.That means that
  if you misuse them today, they probably won't cause a problem,
  although they may someday later.So, please be very careful
  only to use the DrawInfo structure between calls to
  @{"GetScreenDrawInfo()" Link "GetScreenDrawInfo()"} and FreeScreenDrawInfo(), and be sure
  that you don't forget FreeScreenDrawInfo().
SEE ALSO
  @{"GetScreenDrawInfo()" Link "GetScreenDrawInfo()"}
@EndNode
@Node "FreeSysRequest()" "intuition.library/FreeSysRequest"
@{b}@{u}FreeSysRequest@{uu}@{ub} -- Free resources gotten by a call to @{"BuildSysRequest()" Link "BuildSysRequest()"}.
  This routine frees up all memory allocated by a successful call to
  the @{"BuildSysRequest()" Link "BuildSysRequest()"} procedure.If @{"BuildSysRequest()" Link "BuildSysRequest()"} returned a
  pointer to a window, then you are able to wait on the message port
  of that window to detect an event which satisfies the requester.When you want
  to remove the requester, you call this procedure.It ends the requester and
  deallocates any memory used in the creation of the requester.It also closes
  the special window that was opened for your system requester.
  @{i}For V36@{ui}:  It's OK if you pass a NULL or a TRUE (1) value to this function.
  Also, this function properly disposes of requesters gotten using
  @{"BuildEasyRequestArgs()" Link "BuildEasyRequestArgs()"}.
SYNOPSIS  @{FG shine}void@{FG text} FreeSysRequest( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} * );
  FreeSysRequest( @{i}Window@{ui} )
                   A0
  @{i}Window@{ui} = value of the window pointer returned by a successful call to
    the @{"BuildSysRequest()" Link "BuildSysRequest()"} procedure
SEE ALSO
  @{"BuildSysRequest()" Link "BuildSysRequest()"}, @{"AutoRequest()" Link "AutoRequest()"}, @{"CloseWindow()" Link "CloseWindow()"}
@EndNode
@Node "GadgetMouse()" "intuition.library/GadgetMouse"
@{b}@{u}GadgetMouse@{uu}@{ub} -- Calculate gadget-relative mouse position.(V36)
  Determines the current location of the mouse pointer relative to the
  upper-left corner of a custom gadget.Typically used only in the
  @{i}GM_HANDLEINPUT@{ui} and @{i}GM_GOACTIVE@{ui} custom gadget hook routines.
  @{b}NEWS FLASH@{ub}!!: These two hook routines are now passed the mouse coordinates,
  so this function has no known usefulness.We recommend that you don't call it.
  Note that this function calculates the mouse position taking
  "gadget relativity" (@{i}GFLG_RELRIGHT@{ui}, @{i}GFLG_RELBOTTOM@{ui}) into consideration.
  If your custom gadget intends to ignore these properties, then you should
  either enjoin or inhibit your users from setting those bits, since Intuition
  won't ask if you respect them.
SYNOPSIS  @{FG shine}void@{FG text} GadgetMouse( @{FG shine}struct@{FG text} @{"GadgetInfo" Link "include:intuition/cghooks.h/Main" 25} *, WORD * );
  GadgetMouse( @{i}Gadget@{ui}, @{i}GInfo@{ui}, @{i}MousePoint@{ui} )
                A0      A1     A2
  @{i}GInfo@{ui} = A pointer to a @{"GadgetInfo" Link "include:intuition/cghooks.h/Main" 25} structure as passed to the custom
    gadget hook routine.
  @{i}MousePoint@{ui} = address of two WORDS, or a pointer to a structure of type Point.
  Returns nothing.Fills in the two words pointed to by
  MousePoint with the gadget-relative mouse position.
BUGS
  Useless, since equivalent information is now passed to every
  function that might have a use for this.
@EndNode
@Node "GetAttr()" "intuition.library/GetAttr"
@{b}@{u}GetAttr@{uu}@{ub} -- Inquire the value of some attribute of an object.(V36)
  Inquires from the specified object the value of the specified attribute.
  You always pass the address of a long variable, which will
  receive the same value that would be passed to SetAttrs() in
  the ti_Data portion of a @{"TagItem" Link "include:utility/tagitem.h/Main" 31} element.
  See the documentation for the class for exceptions to this general rule.
  Not all attributes will respond to this function.Those that
  will are documented on a class-by-class basis.
SYNOPSIS  ULONG GetAttr( ULONG, APTR, ULONG * );
  @{i}@{b}attr@{ub}@{ui} = GetAttr( @{i}AttrID@{ui}, @{i}Object@{ui}, @{i}StoragePtr@{ui} )
   D0              D0      A0       A1
  @{i}AttrID@{ui} = the attribute tag ID understood by the object's class
  @{i}Object@{ui} = abstract pointer to the boopsi object you are interested in
  @{i}StoragePtr@{ui} = pointer to appropriate storage for the answer
  Returns FALSE (0) if the inquiries of attribute are not provided
  by the object's class.
NOTES
  This function invokes the @{i}OM_GET@{ui} method of the object.
SEE ALSO
  @{"NewObject()" Link "NewObject()"}, @{"DisposeObject()" Link "DisposeObject()"}, SetAttrs(), @{"MakeClass()" Link "MakeClass()"},
  Document "Basic Object-Oriented Programming System for Intuition"
  and the "boopsi Class Reference" document.
@EndNode
@Node "GetDefaultPubScreen()" "intuition.library/GetDefaultPubScreen"
@{b}@{u}GetDefaultPubScreen@{uu}@{ub} -- Get name of default public screen.(V36)
  Provides the name of the current default public screen.
  Only anticipated use is for Public Screen Manager utilities,
  since it is easy to open a visitor window on the default
  public screen without specifying the name.
SYNOPSIS  @{FG shine}void@{FG text} GetDefaultPubScreen( UBYTE * );
  GetDefaultPubScreen( @{i}Namebuff@{ui} )
                        A0
  @{i}Namebuff@{ui} = a buffer of MAXPUBSCREENNAME.This can be NULL.
  Will provide the string "Workbench" in Namebuff if there is no current
  default public screen.
NOTES
  This function actually "returns" in register D0 a pointer to the public screen.
  Unfortunately, the lifespan of this pointer is not ensured; the screen
  could be closed at any time.The *@{b}ONLY@{ub}* legitimate use we can see for
  this return value is to compare for identity with the pointer to a
  public screen you either have a window open in, or a lock on using
  @{"LockPubScreen()" Link "LockPubScreen()"}, to determine if that screen is in fact the default screen.
  Also note that if there no default public screen has been set, the return value
  of this function will be zero, and not a pointer to the Workbench screen.
BUGS
  The function prototype does not reflect the return value.
SEE ALSO
  @{"SetDefaultPubScreen()" Link "SetDefaultPubScreen()"}, @{"OpenWindow()" Link "OpenWindow()"}
@EndNode
@Node "GetDefPrefs()" "intuition.library/GetDefPrefs"
@{b}@{u}GetDefPrefs@{uu}@{ub} -- Get a copy of the the Intuition default Preferences.
  Gets a copy of the Intuition default preferences data.Writes the
  data into the buffer you specify.The number of bytes you want
  copied is specified by the size argument.
  The default preferences are those that Intuition uses when it
  is first opened.If no preferences file is found, these are
  the preferences that are used.These would also be the startup
  preferences in an AmigaDOS-less environment.
  It is legal to take a partial copy of the Preferences structure.
  The more pertinent preferences variables have been grouped near
  the top of the structure to facilitate the memory conservation
  that can be had by taking a copy of only some of the Preferences structure.
SYNOPSIS  @{FG shine}struct@{FG text} @{"Preferences" Link "include:intuition/preferences.h/Main" 43} *GetDefPrefs( @{FG shine}struct@{FG text} Preferences *, WORD );
  @{i}@{b}Prefs@{ub}@{ui} = GetDefPrefs( @{i}PrefBuffer@{ui}, @{i}Size@{ui} )
   D0                   A0           D0
  @{i}PrefBuffer@{ui} = pointer to the memory buffer to receive your copy of the
    Intuition Preferences structure
  @{i}Size@{ui} = the number of bytes in your PrefBuffer, the number of bytes
    you want copied from the system's internal Preference settings
  Returns your parameter PrefBuffer.
SEE ALSO
  @{"GetPrefs()" Link "GetPrefs()"}
@EndNode
@Node "GetPrefs()" "intuition.library/GetPrefs"
@{b}@{u}GetPrefs@{uu}@{ub} -- Get the current Intuition Preferences structure.
  Gets a copy of the current Intuition Preferences structure.
  Writes the data into the buffer you specify.The number of bytes you
  want copied is specified by the size argument.
  It is legal to take a partial copy of the Preferences structure.
  The more pertinent preferences variables have been grouped near the
  top of the structure to facilitate the memory conservation that can
  be had by taking a copy of only some of the Preferences structure.
  @{i}New for V36@{ui}: A new and more extensible method for supplying Preferences has
  been introduced in V36, and relies on file system notification.The Intuition
  preferences items rely also on the IPrefs program.Certain elements of the
  Preferences structure have been superseded by this new method.
  As much as possible, the Preferences structure returned by GetPrefs() reflect
  the current state of Preferences.However, it is impossible to represent some
  of the V36-style preferences items using the existing Preferences structure.
SYNOPSIS  @{FG shine}struct@{FG text} @{"Preferences" Link "include:intuition/preferences.h/Main" 43} *GetPrefs( @{FG shine}struct@{FG text} Preferences *, WORD );
  @{i}@{b}Prefs@{ub}@{ui} = GetPrefs( @{i}PrefBuffer@{ui}, @{i}Size@{ui} )
   D0                A0           D0
  @{i}PrefBuffer@{ui} = pointer to the memory buffer to receive your copy of the
    Intuition Preferences
  @{i}Size@{ui} = the number of bytes in your PrefBuffer, the number of bytes
    you want copied from the system's internal Preference settings
  Returns your parameter PrefBuffer.
SEE ALSO
  @{"GetDefPrefs()" Link "GetDefPrefs()"}, @{"SetPrefs()" Link "SetPrefs()"}
@EndNode
@Node "GetScreenData()" "intuition.library/GetScreenData"
@{b}@{u}GetScreenData@{uu}@{ub} -- Get copy of a screen data structure.
  This function copies into the caller's buffer data from a Screen structure.
  Typically, this call will be used to find the size, title bar height,
  and other values for a standard screen, such as the Workbench screen.
  @{i}To get the data for the Workbench screen, one would call@{ui}:
    GetScreenData(@{i}buff@{ui}, @{FG shine}sizeof@{FG text}(@{FG shine}struct@{FG text} @{i}Screen@{ui}), WBENCHSCREEN, NULL)
SYNOPSIS  BOOL GetScreenData( APTR, UWORD, UWORD, @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} * );
  @{i}@{b}Success@{ub}@{ui} = GetScreenData( @{i}Buffer@{ui}, @{i}Size@{ui}, @{i}Type@{ui}, @{i}Screen@{ui} )
   D0                       A0       D0    D1    A1
  @{i}Buffer@{ui} = pointer to a buffer into which data can be copied
  @{i}Size@{ui}   = the size of the buffer provided, in bytes
  @{i}Type@{ui}   = the screen type, as specified in @{"OpenWindow()" Link "OpenWindow()"}
    (WBENCHSCREEN, CUSTOMSCREEN, ...)
  @{i}Screen@{ui} = ignored, unless type is CUSTOMSCREEN, which results only in copying
    'size' bytes from 'screen' to 'buffer'
  TRUE if successful,FALSE if standard screen of Type 'type' could not be opened.
NOTE
  If the requested standard screen is not open, this function will have
  the effect of opening it.
  This function has been useful for two basic types of things:
  1) Determining information about the Workbench screen, in preparation
     for opening a window on it.
  2) Attempts at discerning the user's preferences in a working screen, for
     "cloning" the Workbench modes and dimensions when opening a similar
     custom screen.
  Providing compatibility with both of these goals has proven
  difficult, as we introduce new display modes and screen scrolling in V36.
  Read carefully the somewhat involved exceptions we elected to implement ...
  @{i}Changes as of V36:@{ui} For V36 and later, the function @{"LockPubScreen()" Link "LockPubScreen()"} is an
  improvement over this function, in that it doesn't copy the screen data
  but returns a pointer and a guarantee that the screen will not be closed.
  If the global public screen @{b}SHANGHAI@{ub} mode is in effect (see
  @{"SetPubScreenModes()" Link "SetPubScreenModes()"} ), this function will actually report on the default
  public screen, where "Workbench" windows will actually open.
  For V36 and later, this function does some "compatibility tricks" when you
  inquire about the WBENCHSCREEN.To keep programs from "stumbling" into modes
  they don't understand, and because an NTSC machine may be running a PAL
  Workbench or PRODUCTIVITY, for example,the following "false" information
  is returned.The Screen.ViewPort.Modes field will either be HIRES or HIRES+LACE
  (with the SPRITES flag also set, as usual).HIRES+LACE is used if the display
  mode selected for the Workbench screen is an interlaced screen of any type.
  The dimensions returned will be the *smaller* of the @{i}OSCAN_TEXT@{ui} dimensions
  for the returned mode, and the actual dimensions of the Workbench screen.
EXCEPTION
  For specific compatibility considerations, if the Workbench is in one of the
  A2024 modes, the mode returned in Screen.ViewPort.Modes will be HIRES+LACE
  (with perhaps  some "special" bits also set for future improvement), but with
  dimensions equal to the actual A2024-mode Workbench screen.This will favor
  programs which open windows on the A2024 Workbench,but will cause some problems
  for programs which try to "clone" the Workbench screen using this function.
  If you want the real information about the modern Workbench screen, call
  LockPubScreen( "Workbench" ) and acquire its display mode ID by inquiring of
  the actual @{"ViewPort" Link "include:graphics/view.h/Main" 40} (using @{"graphics.library/GetVPModeID()" Link "graphics.guide/GetVPModeID()"} ).
  You may then use the information you get to clone as many of the properties of
  the Workbench screen that you wish.In the long run, it's probably better
  to provide your user with a screen mode selection option, and skip all this.
BUGS
  You cannot support the new V36 display modes using this function.
SEE ALSO
  @{"OpenWindow()" Link "OpenWindow()"}, @{"LockPubScreen()" Link "LockPubScreen()"}, @{"graphics.library/GetVPModeID()" Link "graphics.guide/GetVPModeID()"},
  @{"SetPubScreenModes()" Link "SetPubScreenModes()"}, @{"OpenScreen()" Link "OpenScreen()"}
@EndNode
@Node "GetScreenDrawInfo()" "intuition.library/GetScreenDrawInfo"
@{b}@{u}GetScreenDrawInfo@{uu}@{ub} -- Get pointer to rendering information.(V36)
  Returns a pointer to a DrawInfo structure derived from the screen passed.
  This data structure is @{b}READ ONLY@{ub}.The field dri_Version identifies which
  version of @{FG shine}struct@{FG text} DrawInfo you are given a pointer to.
SYNOPSIS  @{FG shine}struct@{FG text} @{"DrawInfo" Link "include:intuition/screens.h/Main" 60} *GetScreenDrawInfo( @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} * );
  @{i}@{b}DrInfo@{ub}@{ui} = GetScreenDrawInfo( @{i}Screen@{ui} )
   D0                          A0
  @{i}Screen@{ui} - pointer to a valid, open screen.
  @{i}@{b}DrInfo@{ub}@{ui} - pointer to a system-allocated DrawInfo structure,
  as defined in @{"intuition/screens.h" Link "include:intuition/screens.h/Main" 0}.
NOTES
  Some information in the DrawInfo structure may in the future be calculated
  the first time this function is called for a particular screen.
  You must call @{"FreeScreenDrawInfo()" Link "FreeScreenDrawInfo()"} when you are done using the
  returned pointer.
  This function does not prevent a screen from closing.Apply it
  only to the screens you opened yourself, or apply a protocol
  such as @{"LockPubScreen()" Link "LockPubScreen()"}.
@{b}WARNING:@{ub} Until further notice, the pointer returned does not
  remain valid after the screen is closed.
  This function and @{"FreeScreenDrawInfo()" Link "FreeScreenDrawInfo()"} don't really do much now,
  but they provide an upward compatibility path.That means that
  if you misuse them today, they probably won't cause a problem,
  although they may someday later.So, please be very careful
  only to use the DrawInfo structure between calls to
  GetScreenDrawInfo() and @{"FreeScreenDrawInfo()" Link "FreeScreenDrawInfo()"}, and be sure
  that you don't forget @{"FreeScreenDrawInfo()" Link "FreeScreenDrawInfo()"}.
BUGS
  Does not reflect to changes in screen modes, depth, or pens.
SEE ALSO
  @{"FreeScreenDrawInfo()" Link "FreeScreenDrawInfo()"}, @{"LockPubScreen()" Link "LockPubScreen()"}, @{"intuition/screens.h" Link "include:intuition/screens.h/Main" 0}
@EndNode
@Node "HelpControl()" "intuition.library/HelpControl"
@{b}@{u}HelpControl@{uu}@{ub} -- Enable/disable Gadget-Help feature.(V39)
  This function can be used to turn Gadget-Help on or off for
  your window.Gadget-Help will also be enabled/disabled
  accordingly for all other windows which share the same
  help-group.This allows Gadget-Help to be well-behaved
  for multiple-window applications.
SYNOPSIS  @{FG shine}void@{FG text} HelpControl( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, ULONG );
  HelpControl( @{i}window@{ui}, @{i}flags@{ui} )
                A0      D0
  @{i}window@{ui} - Pointer to the window you wish to affect.(Other windows
    will also be affected, as explained above.
  @{i}flags@{ui} - Currently, @{i}HC_GADGETHELP@{ui} or zero are the allowed values.
  One or more windows will have Gadget-Help turned on or off.
NOTES
  You must use utility.library/GetUniqueID() to get a help-group identifier.
  Never ever supply your own!
SEE ALSO
  WA_HelpGroup
@EndNode
@Node "InitRequester()" "intuition.library/InitRequester"
@{b}@{u}InitRequester@{uu}@{ub} -- Initialize a Requester structure.
  Initializes a requester for general use.After calling InitRequester,
  you need fill in only those Requester values that fit your needs.
  The other values are set to NULL--or zero--states.
  Note that the example in the early versions of the Intuition
  Reference Manual is flawed because the Requester structure is
  initialized @{b}BEFORE@{ub} InitRequester is called.Be sure to
  perform your initialization @{b}AFTER@{ub} calling InitRequester.
SYNOPSIS  @{FG shine}void@{FG text} InitRequester( @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} * );
  InitRequester( @{i}Requester@{ui} )
                  A0
  @{i}Requester@{ui} = a pointer to a Requester structure
BUGS
  Since the publication of the first Intuition Manual to this
  day, most people haven't used this function, and for
  compatibility reasons, we'll never be able to assume that
  they do.Thus, this function is useless.
@EndNode
@Node "IntuiTextLength()" "intuition.library/IntuiTextLength"
@{b}@{u}IntuiTextLength@{uu}@{ub} -- Return the length (pixel-width) of an IntuiText.
  This routine accepts a pointer to an instance of an IntuiText structure,
  and returns the length (the pixel-width) of the string which that
  instance of the structure represents.
SYNOPSIS  @{FG shine}long@{FG text} IntuiTextLength( @{FG shine}struct@{FG text} @{"IntuiText" Link "include:intuition/intuition.h/Main" 650} * );
  @{i}@{b}Length@{ub}@{ui} = IntuiTextLength( @{i}IText@{ui} )
   D0                        A0
  @{i}IText@{ui} = pointer to an instance of an IntuiText structure
  Returns the pixel-width of the text specified by the IntuiText data
NOTE
  If the Font pointer of your IntuiText structure is set to NULL,
  you'll get the pixel-width of your text in terms of the current system
  default font.You may wish to be sure that the field IText->@{i}ITextFont@{ui}
  for 'default font' text is equal to the Font field of the screen it is
  being measured for.
BUGS
  Would do better to take a RastPort as argument, so that a NULL in
  the Font pointer would lead automatically to the font for the
  intended target RastPort, rather than the system default font.
SEE ALSO
  @{"OpenScreen()" Link "OpenScreen()"}
@EndNode
@Node "ItemAddress()" "intuition.library/ItemAddress"
@{b}@{u}ItemAddress@{uu}@{ub} -- Returns the address of the specified MenuItem.
  This routine feels through the specified menu strip and returns the address
  of the item specified by the menu number.Typically,you will use this routine
  to get the address of a menu item from a menu number sent to you by Intuition
  after user has chosen from a window's menus.
  This routine requires that the arguments are well-defined.
  MenuNumber may be equal to MENUNULL, in which case this routine returns NULL.
  If MenuNumber doesn't equal MENUNULL, it's presumed to be a valid item number
  selector for your menu strip, which includes:
  - a valid menu number
  - a valid item number
  - if the item specified by the above two components has a sub-item,
    the menu number may have a sub-item component, too.
  Note that there must be @{b}BOTH@{ub} a menu number and an item number.
  Because a sub-item specifier is optional, the address returned by
  this routine may point to either an item or a sub-item.
SYNOPSIS  @{FG shine}struct@{FG text} @{"MenuItem" Link "include:intuition/intuition.h/Main" 89} *ItemAddress( @{FG shine}struct@{FG text} @{"Menu" Link "include:intuition/intuition.h/Main" 61} *, UWORD );
  @{i}@{b}Item@{ub}@{ui} = ItemAddress( @{i}MenuStrip@{ui}, @{i}MenuNumber@{ui} )
   D0                  A0         D0
  @{i}MenuStrip@{ui} = a pointer to the first menu in your menu strip
  @{i}MenuNumber@{ui} = the value which contains the packed data that selects the menu
    and item (and sub-item).See the Intuition Reference Manual for information
    on menu numbers.
  If MenuNumber == MENUNULL, this routine returns NULL,else this routine
  returns the address of the menu item specified by MenuNumber.
SEE ALSO
  The "Menus" chapter of the Intuition Reference Manual,
  or the Amiga ROM Kernel Manual
@EndNode
@Node "LendMenus()" "intuition.library/LendMenus"
@{b}@{u}LendMenus@{uu}@{ub} -- Lend window's menu action to another window.(V39)
  This function is used to "lend" the menus of one window to another.
  This means that menu events (for example, the user presses the mouse menu
  button) will take place in another window's menu (using that other window's
  menu strip and screen).The sole intended use of this function is to unify two
  windows on different screens that are attached.(See @{i}SA_Parent@{ui}, @{i}SA_FrontChild@{ui},
  @{i}SA_BackChild@{ui}).An example would be a program with a full-sized parent screen
  which has a short control panel screen attached in the front.Pressing the
  menu button even when the control panel window of the canvas screen
  is active can now cause the menus of the parent screen to appear.
SYNOPSIS  @{FG shine}void@{FG text} LendMenus( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} * );
  LendMenus( @{i}fromWindow@{ui}, @{i}toWindow@{ui} )
              A0          A1
  @{i}fromWindow@{ui} = pointer to the Window structure whose menu actions
    are to go to another window.
  @{i}toWindow@{ui} = pointer to the Window structure whose menus are to
    be displayed in place of the fromWindow's.If NULL, turns
    off menu-lending from the fromWindow.
BUGS
  The current behavior is such that the toWindow is temporarily activated.
  This may not continue to be the case.Be prepared to handle this!
SEE ALSO
  @{"SetMenuStrip()" Link "SetMenuStrip()"}, @{"ClearMenuStrip()" Link "ClearMenuStrip()"}
@EndNode
@Node "LockIBase()" "intuition.library/LockIBase"
@{b}@{u}LockIBase@{uu}@{ub} -- Invoke semaphore arbitration of @{"IntuitionBase" Link "include:intuition/intuitionbase.h/Main" 66}.
  Grabs Intuition internal semaphore so that caller may examine
  IntuitionBase safely.This function is not a magic "fix all my
  race conditions" panacea.
  The idea here is that you can get the locks Intuition needs before
  such IntuitionBase fields as ActiveWindow and FirstScreen are
  changed, or linked lists of windows and screens are changed.
  @{b}Do Not Get Tricky@{ub} with this entry point, and do not hold these locks
  for long, as all Intuition input processing will wait for you to
  surrender the lock by a call to @{"UnlockIBase()" Link "UnlockIBase()"}.
SYNOPSIS  ULONG LockIBase( ULONG );
  @{i}@{b}Lock@{ub}@{ui} = LockIBase( @{i}LockNumber@{ui} )
   D0                D0
  A long unsigned integer, @{i}LockNumber@{ui}, specifies which of Intuition's
  internal locks you want to get.This parameter should be zero for all
  forseeable uses of this function, which will let you examine active
  fields and linked lists of screens and windows with safety.
  Returns another ULONG which should be passed to @{"UnlockIBase()" Link "UnlockIBase()"} to
  surrender the @{i}@{b}lock@{ub}@{ui} gotten by this call.
  @{b}NOTE WELL:@{ub} A call to this function @{b}MUST@{ub} be paired with a subsequent
  call to @{"UnlockIBase()" Link "UnlockIBase()"}, and soon, please.
  Do not call any Intuition functions (nor any graphics, layers, dos,
  or other high-level system function) while holding this lock.
BUGS
  This function must not be called while holding any other system locks
  such as layer or LayerInfo locks.
SEE ALSO
  @{"UnlockIBase()" Link "UnlockIBase()"}, @{"layers.library/LockLayerInfo()" Link "ROMlibs.guide/LockLayerInfo()"},
  @{"exec.library/ObtainSemaphore()" Link "exec.guide/ObtainSemaphore()"}
@EndNode
@Node "LockPubScreen()" "intuition.library/LockPubScreen"
@{b}@{u}LockPubScreen@{uu}@{ub} -- Prevent a public screen from closing.(V36)
  Prevents a public screen (or the Workbench) from closing while you examine it
  in preparation of opening a visitor window.
  @{i}The sequence you use to open a visitor window that needs to examine fields
  in the screen it is about to open on is@{ui}:
  - LockPubScreen()
    ...examine fields ...
  - @{"OpenWindow()" Link "OpenWindow()"} on public screen
  - @{"UnlockPubScreen()" Link "UnlockPubScreen()"}
    ...use your window ...
  - @{"CloseWindow()" Link "CloseWindow()"}
SYNOPSIS  @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} *LockPubScreen( UBYTE * );
  @{i}@{b}screen@{ub}@{ui} = LockPubScreen( @{i}Name@{ui} )
   D0                      A0
  @{i}Name@{ui} = name string for public screen or NULL for default public  screen.
    The string "Workbench" indicates the Workbench screen.
  Returns pointer to a screen, if successful, else NULL.
  The call can fail for reasons including that the named
  public screen doesn't exist or is in private state.
NOTE
  You needn't hold the "pubscreen lock" for the duration that your
  window is opened.LockPubScreen() basically has the same effect as
  an open visitor window: it prevents the screen from being closed.
  If you pass the string "Workbench" or you pass NULL and there
  is no default public screen, the Workbench screen will
  be automatically opened if it is not already present.
SEE ALSO
  @{"OpenWindow()" Link "OpenWindow()"}, @{"UnlockPubScreen()" Link "UnlockPubScreen()"}, @{"GetScreenData()" Link "GetScreenData()"}
@EndNode
@Node "LockPubScreenList()" "intuition.library/LockPubScreenList"
@{b}@{u}LockPubScreenList@{uu}@{ub} -- Prevent changes to the system list.(V36)
  Arbitrates access to public screen list while you quickly make a copy of it
  for display to the user.
  Note that this is intended only for the Public Screen Manager program.
SYNOPSIS  @{FG shine}struct@{FG text} @{"List" Link "include:exec/lists.h/Main" 20} *LockPubScreenList( @{FG shine}void@{FG text} );
  @{i}@{b}List@{ub}@{ui} = LockPubScreenList()
   D0                                                       
  Returns a pointer to the public screen list.
NOTES
  The nodes on the list are @{"PubScreenNode" Link "include:intuition/screens.h/Main" 537} structures.
  Act quickly while holding this lock.The restrictions
  on @{"LockIBase()" Link "LockIBase()"} apply here as well.
SEE ALSO
  @{"UnlockPubScreenList()" Link "UnlockPubScreenList()"}, @{"OpenScreen()" Link "OpenScreen()"}, Intuition V36 update documentation  
@EndNode
@Node "MakeClass()" "intuition.library/MakeClass"
@{b}@{u}MakeClass@{uu}@{ub} -- Create and initialize a boopsi class.For class implementors
  only.(V36)
  This function creates a new public or private boopsi class.
  The superclass should be defined to be another boopsi class:
  all classes are descendants of the class "rootclass".
  Superclasses can be public or private.You provide a name/ID for your class
  if it is to be a public class (but you must have registered your class name
  and your attribute ID's with Commodore before you do this!).
  For a public class,you would also call @{"AddClass()" Link "AddClass()"} to make it available after
  you have finished your initialization.
  Returns pointer to an IClass data structure for your class.You then initialize
  the Hook cl_Dispatcher for your class methods code.You can also set up special
  data shared by all objects in your class, and point cl_UserData at it.
  The last step for public classes is to call @{"AddClass()" Link "AddClass()"}.
  You dispose of a class created by this function by calling @{"FreeClass()" Link "FreeClass()"}.
SYNOPSIS
  @{FG shine}struct@{FG text} IClass *MakeClass( UBYTE *, UBYTE *, @{FG shine}struct@{FG text} IClass *, UWORD, ULONG );
  @{i}@{b}iclass@{ub}@{ui} = MakeClass( @{i}ClassID@{ui}, @{i}SuperClassID@{ui}, @{i}SuperClassPtr@{ui},@{i}InstanceSize@{ui}, @{i}Flags@{ui} )
   D0                  A0        A1            A2            D0            D1
  @{i}ClassID@{ui} = NULL for private classes, the name/ID string for public classes
  @{i}SuperClassID@{ui} = name/ID of your new class's superclass.
    NULL if superclass is a private class
  @{i}SuperClassPtr@{ui} = pointer to private superclass.Only used if SuperClassID is NULL.
    You are required never to provide a NULL superclass.
  @{i}InstanceSize@{ui} = the size of the instance data that your class's objects will
    require, beyond that data defined for your superclass's objects.
  @{i}Flags@{ui} = for future enhancement, including possible additional parameters.
    Provide zero for now.
  Returns pointer to the resulting class, or NULL if not possible:
  - no memory for class data structure
  - public superclass not found
  - public class of same name/ID as this one already exists
EXAMPLE
  Creating a private subclass of a public class:
    /* per-object instance data defined by my class */
    @{FG shine}struct@{FG text} MyInstanceData { ULONG @{i}mid_SomeData@{ui}; };
    /* some useful table I'll share use for all objects */
    UWORD @{i}myTable@{ui}[] = { 5, 4, 3, 2, 1, 0 };
    @{FG shine}struct@{FG text} IClass *@{i}initMyClass@{ui}()
    {
      ULONG @{FG shine}__saveds@{FG text}  myDispatcher();
      ULONG hookEntry();  /* asm-to-C interface glue  */
      @{FG shine}struct@{FG text} IClass *@{i}cl@{ui};
      @{FG shine}struct@{FG text} IClass *@{i}MakeClass@{ui}();
      @{FG shine}if@{FG text} ( @{i}cl@{ui} =  MakeClass( NULL,
        SUPERCLASSID, NULL,   /* superclass is public      */
        @{FG shine}sizeof@{FG text} (@{FG shine}struct@{FG text} MyInstanceData),
        0 )) {
        /* initialize the cl_Dispatcher Hook */
        cl->cl_Dispatcher.@{i}h_Entry@{ui} = @{i}hookEntry@{ui};
        cl->cl_Dispatcher.@{i}h_SubEntry@{ui} = @{i}myDispatcher@{ui};
        cl->cl_Dispatcher.@{i}h_Data@{ui} = (@{FG shine}void@{FG text} *) 0xFACE; /* unused */
        cl-@{i}cl_UserData@{ui} = (ULONG) @{i}myTable@{ui};
      }
      @{FG shine}return@{FG text} ( @{i}cl@{ui} );
    }
BUGS
  The typedef 'Class' isn't consistently used.Class pointers
  used blindly should be APTR, or @{FG shine}struct@{FG text} IClass for class implementors.
SEE ALSO
  @{"FreeClass()" Link "FreeClass()"}, @{"AddClass()" Link "AddClass()"}, @{"RemoveClass()" Link "RemoveClass()"}, @{"NewObject()" Link "NewObject()"},
  Document "Basic Object-Oriented Programming System for Intuition"
  and the "boopsi Class Reference" document.
@EndNode
@Node "MakeScreen()" "intuition.library/MakeScreen"
@{b}@{u}MakeScreen@{uu}@{ub} -- Do an Intuition-integrated @{"MakeVPort()" Link "graphics.guide/MakeVPort()"} of a screen.
  This procedure allows you to do a @{"MakeVPort()" Link "graphics.guide/MakeVPort()"} for the viewport of your
  custom screen in an Intuition-integrated way.This way you can
  do your own screen manipulations without worrying about interference
  with Intuition's usage of the same viewport.
  @{i}The operation of this function is as follows@{ui}:
  - Block until the Intuition @{"View" Link "include:graphics/view.h/Main" 57} structure is not in being changed.
  - Set the view modes correctly to reflect if there is a (visible)
    interlaced screen.
  - call @{"MakeVPort()" Link "graphics.guide/MakeVPort()"}, passing the Intuition @{"View" Link "include:graphics/view.h/Main" 57} and your screen's @{"ViewPort" Link "include:graphics/view.h/Main" 40}.
  - Unlocks the Intuition View.
  After calling this routine, you should call @{"RethinkDisplay()" Link "RethinkDisplay()"} to 
  incorporate the new viewport of your custom screen into the Intuition display.
SYNOPSIS
  @{FG shine}long@{FG text} MakeScreen( @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} * );
  /* Returns @{FG shine}long@{FG text} in V39 and greater */
  @{i}@{b}failure@{ub}@{ui} = MakeScreen( @{i}Screen@{ui} )
   D0 (V39)               A0
  @{i}Screen@{ui} = address of the custom screen structure
  Starting with V39, returns zero for success, non-zero for failure.
  Probable cause of failure is failure of @{"graphics.library/MakeVPort()" Link "graphics.guide/MakeVPort()"}.
  Prior to V39, the return code is invalid.Do not interpret it when
  running on pre-V39 systems!
NOTE
  Intuition may determine that because of a change in global
  interlace needs that all viewports need to be remade, so
  it may effectively call @{"RemakeDisplay()" Link "RemakeDisplay()"}.
SEE ALSO
  @{"RethinkDisplay()" Link "RethinkDisplay()"}, @{"RemakeDisplay()" Link "RemakeDisplay()"}, @{"graphics.library/MakeVPort()" Link "graphics.guide/MakeVPort()"}
@EndNode
@Node "ModifyIDCMP()" "intuition.library/ModifyIDCMP"
@{b}@{u}ModifyIDCMP@{uu}@{ub} -- Modify the state of a window's IDCMPFlags.
  This routine modifies the state of your window's IDCMP (Intuition
  Direct Communication @{"Message" Link "include:exec/ports.h/Main" 48} Port).The state is modified to reflect
  your desires as described by the flag bits in the value IDCMPFlags.
  @{i}The four actions that might be taken are@{ui}:
  - if there is currently no IDCMP in the given window, and IDCMPFlags
    is zero, nothing happens.
  - if there is currently no IDCMP in the given window, and any of the
    IDCMPFlags is selected (set), then the IDCMP of the window is
    created, including allocating and initializing the message ports
    and allocating a signal bit for your port.See the "Input and Output
    Methods" chapter of the Intuition Reference Manual for full details.
  - if the IDCMP for the given window exists, and the IDCMPFlags argument is
    zero, this says that you want Intuition to close the ports, free the buffers
    and free your signal bit.You @{b}MUST@{ub} be the same task that was active when this
    signal bit was allocated (either by ModifyIDCMP() or @{"OpenWindow()" Link "OpenWindow()"} ).
  - if the IDCMP for the given window is opened, and the IDCMPFlags argument
    is not zero, this means that you want to change the state of which events
    will be broadcast to you through the IDCMP.
SYNOPSIS
  BOOL ModifyIDCMP( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, ULONG );
  /* returns BOOL in V37 and greater */
  @{i}@{b}Success@{ub}@{ui} = ModifyIDCMP( @{i}Window@{ui}, @{i}IDCMPFlags@{ui} )
   D0 (V37)               A0       D0
  @{i}Window@{ui} = pointer to the Window structure containing the IDCMP ports
  @{"IDCMPFlags" link IDCMP_FLAGS} = the flag bits describing the new desired state of the IDCMP.
  Starting in V37, this function returns NULL if it was unable to create the
  necessary message ports.(The possibility of failure exists in earlier releases,
  but no return code was offered).Do not check the return code under V36 or
  earlier.
NOTE
  You can set up the Window->@{i}UserPort@{ui} to any port of your own before you call
  ModifyIDCMP().If IDCMPFlags is non-null but your UserPort is already
  initialized, Intuition will assume that it's a valid port with task and signal
  data preset and Intuition won't disturb your set-up at all,Intuition will just
  allocate the Intuition message port half of it.The converse is true as well:
  if UserPort is NULL when you call here with IDCMPFlags == NULL,Intuition will
  deallocate only the Intuition side of the port.
  @{i}This allows you to use a port that you already have allocated@{ui}:
  - @{"OpenWindow()" Link "OpenWindow()"} with IDCMPFlags equal to NULL (open no ports)
  - set the UserPort variable of your window to any valid port of your
    own choosing
  - call ModifyIDCMP with IDCMPFlags set to what you want
  - then, to clean up later, set UserPort equal to NULL before calling
    @{"CloseWindow()" Link "CloseWindow()"} (leave IDCMPFlags alone).
    @{b}BUT FIRST@{ub}: you must make sure that no messages sent to your window are
    queued at the port,since they will be returned to the memory free pool.
  For an example of how to close a window with a shared IDCMP,
  see the description for @{"CloseWindow()" Link "CloseWindow()"}.
SEE ALSO
  @{"OpenWindowTagList()" Link "OpenWindowTagList()"}, @{"OpenWindow()" Link "OpenWindow()"}, @{"CloseWindow()" Link "CloseWindow()"}
@EndNode
@node IDCMP_FLAGS "IDCMP_flags"
@{b}IDCMP_REQVERIFY@{ub} is the flag which, like @{i}IDCMP_SIZEVERIFY@{ui} and ...
  @{i}IDCMP_MENUVERIFY@{ui} (see immediately below), specifies that you want to make
  sure that your graphical state is quiescent before something extraordinary
  happens.In this case, the extraordinary event is that a rectangle of
  graphical data is about to be blasted into your Window.If you're drawing
  directly into its screen, you probably will wish to make sure that you've
  ceased drawing before the user is allowed to bring up the DMRequest you've
  set up, and the same for when system has a request for the user.
  Set this flag to ask for that verification step.
@{b}IDCMP_REQCLEAR@{ub} is the flag you set to hear a message whenever a requester
  is cleared from your window.If you are using @{i}IDCMP_REQVERIFY@{ui} to arbitrate
  access to your screen's bitmap, it is safe to start your output once you
  have heard an @{i}IDCMP_REQCLEAR@{ui} for each @{i}IDCMP_REQSET@{ui}.
@{b}IDCMP_REQSET@{ub} is a flag that you set to receive a broadcast for each
  requester that is opened in your window.Compare this with @{i}IDCMP_REQCLEAR@{ui}
  above.This function is distinct from @{i}IDCMP_REQVERIFY@{ui}.
  This functions merely tells you that a requester has opened, whereas
  @{i}IDCMP_REQVERIFY@{ui} requires you to respond before the requester is opened.
@{b}IDCMP_MENUVERIFY@{ub} is the flag you set to have Intuition stop and wait for
  you to finish all graphical output to your window before rendering the
  menus.Menus are currently rendered in the most memory-efficient way, which
  involves interrupting output to all windows in the screen before the menus
  are drawn.If you need to finish your graphical output before this happens,
  you can set this flag to make sure that you do.
@{b}IDCMP_SIZEVERIFY@{ub} means that you will be doing output to your window which
  depends on a knowledge of the current size of the window.If the user wants
  to resize the window, you may want to make sure that any queued output
  completes before the sizing takes place (critical text, for instance).
  If this is the case, set this flag.Then, when the user wants to size,
  Intuition will send you the @{i}IDCMP_SIZEVERIFY@{ui} message and @{"Wait()" Link "exec.guide/Wait()"} until you
  reply that it's OK to proceed with the sizing.
  @{i}NOTE:@{ui} when we say that Intuition will @{"Wait()" Link "exec.guide/Wait()"} until you reply, what we're
  really saying is that user will @{b}WAIT@{ub} until you reply, which suffers the
  great negative potential of User-Unfriendliness.
  @{i}So remember:@{ui} use this flag sparingly, and, as always with any IDCMP Message
  you receive, reply to it promptly! Then, after user has sized the window,
  you can find out about it using @{i}IDCMP_NEWSIZE@{ui}.
  With all the "VERIFY" functions, it is not save to leave them enabled at any
  time when your task may not be able to respond for a long period.
  It is @{b}NEVER@{ub} safe to call AmigaDOS, directly or indirectly, when a "VERIFY"
  function is active.If AmigaDOS needs to put up a disk requester for you,
  your task might end up waiting for the requester to be satisfied, at the
  same time as Intuition is waiting for your response.The result is a complete
  machine lockup.@{b}USE ModifyIDCMP() TO TURN OFF ANY VERIFY MESSAGES BEFORE
  CALLING dos.library!!@{ub}
  @{i}For V36:@{ui} If you do not respond to the verification IntuiMessages within the
  user specified timeout duration, Intuition will abort the operation.
  This eliminates the threat of these easy deadlocks, but can result in a
  confused user.Please try hard to continue to avoid "logical deadlocks".
@{b}IDCMP_NEWSIZE@{ub} is the flag that tells Intuition to send an IDCMP message to
  you after the user has resized your window.At this point, you could examine
  the size variables in your window structure to discover the new size of the
  window.See also the @{i}IDCMP_CHANGEWINDOW@{ui} IDCMP flag.
@{b}IDCMP_REFRESHWINDOW@{ub} when set will cause a message to be sent whenever
  your window needs refreshing.This flag makes sense only with
  @{i}WFLG_SIMPLE_REFRESH@{ui} and @{i}WFLG_SMART_REFRESH@{ui} windows.
@{b}IDCMP_MOUSEBUTTONS@{ub} will get reports about mouse-button up/down events
  broadcast to you.(@{i}Note:@{ui}only the ones that don't mean something to
  Intuition.If the user clicks the select button over a gadget, Intuition
  deals with it and you don't find out about it through here).
@{b}IDCMP_MOUSEMOVE@{ub} will work only if you've set the @{i}WFLG_REPORTMOUSE@{ui} flag
  above, or if one of your gadgets has the @{i}GACT_FOLLOWMOUSE@{ui} flag set.Then
  all mouse movements will be reported here, providing your window is active.
@{b}IDCMP_GADGETDOWN@{ub} means that when the User "selects" a gadget you've
  created with the @{i}GACT_IMMEDIATE@{ui} flag set, the fact will be broadcast
  through the IDCMP.
@{b}IDCMP_GADGETUP@{ub} means that when the user "releases" a gadget that you've
  created with the @{i}GACT_RELVERIFY@{ui} flag set, the fact will be broadcast
  through the IDCMP.This message is only generated if the release is "good",
  such as releasing the select button over a Boolean gadget, or typing ENTER
  in a string gadget.
@{b}IDCMP_MENUPICK@{ub} selects that menu number data will be sent via the IDCMP.
@{b}IDCMP_CLOSEWINDOW@{ub} means broadcast the @{i}IDCMP_CLOSEWINDOW@{ui} event through the
  IDCMP rather than the console.
@{b}IDCMP_RAWKEY@{ub} selects that all @{i}IDCMP_RAWKEY@{ui} events are transmitted via the
  IDCMP.Note that these are absolutely RAW keycodes, which you will have
  to translate before using.Setting this and the MOUSE flags effectively
  eliminates the need to open a Console device to get input from the
  keyboard and mouse.Of course, in exchange you lose all of the console
  features, most notably the "cooking" of input data and the systematic
  output of text to your window.
@{b}IDCMP_VANILLAKEY@{ub} is for developers who don't want the hassle of
  @{i}IDCMP_RAWKEYS@{ui}.This flag will return all the keycodes after translation via
  the current country-dependent keymap.When you set this flag, you will get
  IntuiMessages where the Code field has a decoded ANSI character code
  representing the key struck on the keyboard.Only codes that map to a
  single character are returned: you can't read such keys as HELP or the
  function keys with @{i}IDCMP_VANILLAKEY@{ui}.
  @{i}NEW FOR V36:@{ui} If you have both @{i}IDCMP_RAWKEY@{ui} and @{i}IDCMP_VANILLAKEY@{ui} set,
  Intuition will send an @{i}IDCMP_RAWKEY@{ui} event for those *downstrokes* which
  do not map to single-byte characters ("non-vanilla" keys).In this way
  you can easily detect cursor keys, function keys, and the Help key without
  sacrificing the convenience of @{i}IDCMP_VANILLAKEY@{ui}.@{b}NB@{ub}: A side-effect of
  having both @{i}IDCMP_RAWKEY@{ui} and @{i}IDCMP_VANILLAKEY@{ui} set is that you never hear
  @{i}IDCMP_RAWKEY@{ui} upstrokes, even for keys that caused @{i}IDCMP_RAWKEY@{ui} downstrokes.
@{b}IDCMP_INTUITICKS@{ub} gives you simple timer events from Intuition when your
  window is the active one; it may help you avoid opening and managing
  the timer device.With this flag set, you will get only one queued-up
  INTUITICKS message at a time.If Intuition notices that you've been sent an
  @{i}IDCMP_INTUITICKS@{ui} message and haven't replied to it, another message will
  not be sent.Intuition receives timer events and considers sending you an
  @{i}IDCMP_INTUITICKS@{ui} message approximately ten times a second.
@{b}IDCMP_DELTAMOVE@{ub} gives raw (unscaled) input event delta X/Y values.
  This is so you can detect mouse motion regardless of screen/window/display
  boundaries.This works a little strangely: if you set both @{i}IDCMP_MOUSEMOVE@{ui}
  and @{i}IDCMP_DELTAMOVE@{ui} IDCMPFlags, you will get @{i}IDCMP_MOUSEMOVE@{ui} messages with
  delta x/y values in the MouseX and MouseY fields of the IDCMPMessage.
@{b}IDCMP_NEWPREFS@{ub} indicates you wish to be notified when the system-wide
  Preferences changes.For V36, there is a new environment mechanism to
  replace @{"Preferences" Link "include:intuition/preferences.h/Main" 43}, which we recommend you consider using instead.
  - Set @{i}IDCMP_ACTIVEWINDOW@{ui} and @{i}IDCMP_INACTIVEWINDOW@{ui} to get messages when those
    events happen to your window.Take care not to confuse this "ACTIVEWINDOW"
    with the familiar sounding, but totally different "WINDOWACTIVE" flag.
    These two flags have been supplanted by "IDCMP_ACTIVEWINDOW" and
    "WFLG_WINDOWACTIVE".Use the new equivalent terms to avoid confusion.
  - Set @{i}IDCMP_DISKINSERTED@{ui} or @{i}IDCMP_DISKREMOVED@{ui} to learn when
    removable disks are inserted or removed, respectively.
@{b}IDCMP_IDCMPUPDATE@{ub} is a new class for V36 which is used as a channel of
  communication from custom and boopsi gadgets to your application.
@{b}IDCMP_CHANGEWINDOW@{ub} is a new class for V36 that will be sent to your window
  whenever its dimensions or position are changed by the user or the
  functions @{"SizeWindow()" Link "SizeWindow()"}, @{"MoveWindow()" Link "MoveWindow()"}, @{"ChangeWindowBox()" Link "ChangeWindowBox()"}, or @{"ZipWindow()" Link "ZipWindow()"}.
@{b}IDCMP_MENUHELP@{ub} is new for V37.If you specify the WA_MenuHelp tag when you
  open your window, then when the user presses the HELP key on the keyboard
  during a menu session, Intuition will terminate the menu session and
  issue this event in place of an @{i}IDCMP_MENUPICK@{ui} message.
  - @{b}NEVER@{ub} follow the NextSelect link for MENUHELP messages.
  - You will be able to hear MENUHELP for ghosted menus.
    (This lets you tell the user why the option is ghosted.)
  - Be aware that you can receive a MENUHELP message whose code corresponds
    to a menu header or an item that has sub-items (which does not happen
    for MENUPICK).The code may also be MENUNULL.
  - @{b}LIMITATION@{ub}:if the user extend-selects some checkmarked items with the
    mouse, then presses MENUHELP, your application will only hear the
    MENUHELP report.You must re-examine the state of your checkmarks when
    you get a MENUHELP.
  - Availability of MENUHELP in V36 is not directly controllable.
    We apologize...
@{b}IDCMP_GADGETHELP@{ub} is new for V39.If you turn on gadget help for your window
  (using the @{"HelpControl()" Link "HelpControl()"}) function, then Intuition will send
  @{i}IDCMP_GADGETHELP@{ui} messages when the mouse passes over certain gadgets or
  your window.The IntuiMessage->@{i}Code@{ui} field is normally ~0, but a boopsi
  gadget can return any word value it wishes.
  Ordinarily, gadget help is only processed for the active window.When
  Intuition has determined that the mouse is pointing at a gadget which has
  the @{i}GMORE_GADGETHELP@{ui} property, you will be sent an @{i}IDCMP_GADGETHELP@{ui} message
  whose IAddress points to the gadget.When the mouse is over your window but
  not over any help-aware gadget, you will be sent a message whose IAddress
  is the window itself.When the mouse is not over your window, Intuition
  sends a message whose IAddress is zero.
  A multi-window application can use the WA_HelpGroup or WA_HelpGroupWindow
  tags to indicate that all its windows belong in a group.(The help group
  identifier should be obtained with utility.library/GetUniqueID().)
  This makes Intuition test gadget help in all windows of the group when
  any one of them is the active one.Inactive windows whose WA_HelpGroup
  matches the active window's receive @{i}IDCMP_GADGETHELP@{ui} messages when the
  mouse is over that window or any of its help-aware gadgets.The @{i}GADGETHELP@{ui}
  message with an IAddress of zero means the mouse is not over the active
  window or any other window of the same group.It is always sent to the
  active window (which is not necessarily the window in your group that
  last got a message).
  To maximize performance, gadget help is not checked while the mouse is
  travelling quickly, or if it has not moved at all since the last test.
  As well, if Intuition discovers that the mouse is still over same gadget
  and that gadget does not wish to send a different IntuiMessage->@{i}Code@{ui}
  from the last message, no new @{"IntuiMessage" Link "include:intuition/intuition.h/Main" 761} is sent.
@endnode
@Node "ModifyProp()" "intuition.library/ModifyProp"
@{b}@{u}ModifyProp@{uu}@{ub} -- Modify the current parameters of a proportional gadget.
  Modifies the parameters of the specified proportional gadget.The
  gadget's internal state is then recalculated and the imagery 
  is redisplayed in the window or requester that contains the gadget.
  The requester variable can point to a requester structure.If the
  gadget has the @{i}GTYP_REQGADGET@{ui} flag set, the gadget is in a requester
  and the window pointer must point to the window of the requester.
  If this is not the gadget of a requester, the requester argument may be NULL.
SYNOPSIS
  @{FG shine}void@{FG text} ModifyProp( @{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *,
    UWORD, UWORD, UWORD, UWORD, UWORD );
  ModifyProp(@{i}Gadget@{ui},@{i}Window@{ui},@{i}Requester@{ui},@{i}Flags@{ui},@{i}HorizPot@{ui},@{i}VertPot@{ui},@{i}HorizBody@{ui},@{i}VertBody@{ui})
              A0     A1      A2        D0    D1       D2       D3        D4
  @{i}PropGadget@{ui} = pointer to a proportional gadget
  @{i}Window@{ui} = pointer to the window containing the gadget or the window
    containing the requester containing the gadget.
  @{i}Requester@{ui} = pointer to a requester (may be NULL if this isn't a requester
    gadget)
  @{i}Flags@{ui} = value to be stored in the Flags field of the @{"PropInfo" Link "include:intuition/intuition.h/Main" 536}
  @{i}HorizPot@{ui} = value to be stored in the HorizPot field of the PropInfo
  @{i}VertPot@{ui} = value to be stored in the VertPot field of the PropInfo
  @{i}HorizBody@{ui} = value to be stored in the HorizBody field of the PropInfo
  @{i}VertBody@{ui} = value to be stored in the VertBody field of the PropInfo
NOTE
  This function causes all gadgets from the proportional gadget to the end
  of the gadget list to be refreshed, for reasons of compatibility.
  For more refined display updating, use @{"NewModifyProp()" Link "NewModifyProp()"}.
  @{i}New for V36@{ui}: ModifyProp() refreshing consists of redrawing gadgets
  completely.@{"NewModifyProp()" Link "NewModifyProp()"} has changed this behavior (see
  @{"NewModifyProp()" Link "NewModifyProp()"}).
SEE ALSO
  @{"NewModifyProp()" Link "NewModifyProp()"}
  The Intuition Reference Manual and Amiga ROM Kernel Manual contain
  more information on Proportional Gadgets.
@EndNode
@Node "MoveScreen()" "intuition.library/MoveScreen"
@{b}@{u}MoveScreen@{uu}@{ub} -- Attempt to move the screen by the increments provided.
  Moves the screen the specified increment, specified in screen
  pixel resolution coordinates.
  @{i}New for V36@{ui}: Screen movement limits have been greatly relaxed, to support
  screen scrolling.In particular, negative values for screen @{i}LeftEdge@{ui} and
  @{i}TopEdge@{ui} may now be valid.
  If the @{i}DeltaX@{ui} and @{i}DeltaY@{ui} variables you specify would move the screen
  in a way that violates any restrictions, the screen will be moved as far
  as possible.You may examine the @{i}LeftEdge@{ui} and @{i}TopEdge@{ui} fields of the Screen
  structure after this function returns to see where the screen really ended up.
SYNOPSIS  @{FG shine}void@{FG text} MoveScreen( @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} *, WORD, WORD );
  MoveScreen( @{i}Screen@{ui}, @{i}DeltaX@{ui}, @{i}DeltaY@{ui} )
               A0      D0       D1
  @{i}Screen@{ui} = pointer to a Screen structure
  @{i}DeltaX@{ui} = amount to move the screen on the x-axis
    Note that DeltaX no longer (V36) need be set to zero
  @{i}DeltaY@{ui} = amount to move the screen on the y-axis
    Note that these coordinates are in the same resolution as the screen
    (such as HIRES or INTERLACE)
SEE ALSO
  @{"ScreenPosition()" Link "ScreenPosition()"}, @{"RethinkDisplay()" Link "RethinkDisplay()"}
@EndNode
@Node "MoveWindow()" "intuition.library/MoveWindow"
@{b}@{u}MoveWindow@{uu}@{ub} -- Ask Intuition to move a window.
  This routine sends a request to Intuition asking to move the window the
  specified distance.The delta arguments describe how far to move the window
  along the respective axes.
  Note that the window will not be moved immediately, but rather will be moved
  the next time Intuition receives an input event, which happens currently at a
  minimum rate of ten times per second, and a maximum of sixty times a second.
  Interactions with other arbitration of Intuition data structures may defer
  this operation longer.For V36, you can use the new IDCMP class
  @{i}IDCMP_CHANGEWINDOW@{ui} to detect when this operation has completed.
  @{i}New for V36@{ui}: Intuition now will do validity checking on the final
  position.To send absolute movements, or to move and size a window
  in one step, use @{"ChangeWindowBox()" Link "ChangeWindowBox()"}.
SYNOPSIS  @{FG shine}void@{FG text} MoveWindow( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, WORD, WORD );
  MoveWindow( @{i}Window@{ui}, @{i}DeltaX@{ui}, @{i}DeltaY@{ui} )
               A0      D0       D1
  @{i}Window@{ui} = pointer to the structure of the Window to be moved
  @{i}DeltaX@{ui} = how far to move the Window on the x-axis
  @{i}DeltaY@{ui} = how far to move the Window on the y-axis
SEE ALSO
  @{"ChangeWindowBox()" Link "ChangeWindowBox()"}, @{"SizeWindow()" Link "SizeWindow()"}, @{"WindowToFront()" Link "WindowToFront()"}, @{"WindowToBack()" Link "WindowToBack()"}
@EndNode
@Node "MoveWindowInFrontOf()" "intuition.library/MoveWindowInFrontOf"
@{b}@{u}MoveWindowInFrontOf@{uu}@{ub} -- Arrange the relative depth of a window.(V36)
  Depth-arranges a window in front of an another window.
  Brings out the layers.library @{"MoveLayerInFrontOf()" Link "ROMlibs.guide/MoveLayerInFrontOf()"} to the Intuition user.
SYNOPSIS  @{FG shine}void@{FG text} MoveWindowInFrontOf( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} * );
  MoveWindowInFrontOf( @{i}Window@{ui}, @{i}BehindWindow@{ui} )
                        A0       A1
  @{i}Window@{ui} =  window to re-position in front of another window
  @{i}BehindWindow@{ui} =  window to re-position in front of
  Repositions window.
BUGS
  Doesn't respect backdrop windows.
SEE ALSO
  @{"WindowToFront()" Link "WindowToFront()"}, @{"WindowToBack()" Link "WindowToBack()"}, @{"layers.library/MoveLayerInFrontOf()" Link "ROMlibs.guide/MoveLayerInFrontOf()"}
@EndNode
@Node "NewModifyProp()" "intuition.library/NewModifyProp"
@{b}@{u}NewModifyProp@{uu}@{ub} -- @{"ModifyProp()" Link "ModifyProp()"}, but with selective refresh.
  Performs the function of @{"ModifyProp()" Link "ModifyProp()"}, but refreshes
  gadgets in the list as specified by the NumGad parameter.
  With @{i}NumGad@{ui} = -1, this function is identical to @{"ModifyProp()" Link "ModifyProp()"}.
  @{i}New for V36@{ui}: When @{i}NumGad@{ui} = 1, this function will now perform
  an incremental update of the proportional gadget knob image,
  rather than refreshing the entire gadget.This means much less
  flashing when programmatically scrolling a proportional gadget.
SYNOPSIS
  @{FG shine}void@{FG text} NewModifyProp( @{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *,
    UWORD, UWORD, UWORD, UWORD, UWORD, WORD );
  NewModifyProp(Gadget,Window,Requester,Flags,HorizPot,VertPot,HorizBody,VertBody,NumGad)
                 A0     A1     A2        D0    D1       D2      D3        D4       D5
  @{i}PropGadget@{ui} = pointer to a proportional gadget
  @{i}Window@{ui} = pointer to the window containing the gadget or the window
    containing the requester containing the gadget.
  @{i}Requester@{ui} = pointer to a requester (may be NULL if this isn't
   a requester gadget)
  @{i}Flags@{ui} = value to be stored in the Flags field of the @{"PropInfo" Link "include:intuition/intuition.h/Main" 536}
  @{i}HorizPot@{ui} = value to be stored in the HorizPot field of the PropInfo
  @{i}VertPot@{ui} = value to be stored in the VertPot field of the PropInfo
  @{i}HorizBody@{ui} = value to be stored in the HorizBody field of the PropInfo
  @{i}VertBody@{ui} = value to be stored in the VertBody field of the PropInfo
  @{i}NumGad@{ui} = number of gadgets to be refreshed after propgadget internals
    have been adjusted.-1 means "to end of list."
SEE ALSO
  @{"ModifyProp()" Link "ModifyProp()"}
  The Intuition Reference Manual contains more information on
  Proportional Gadgets.
@EndNode
@Node "NewObject()" "intuition.library/NewObject"
@{b}@{u}NewObjectA@{uu}@{ub} -- Create an object from a class.(V36)
@{b}@{u}NewObject@{uu}@{ub}  -- Varargs stub for NewObjectA().(V36)
  This is the general method of creating objects from 'boopsi' classes.
  ('@{b}Boopsi@{ub}' stands for "@{b}basic object-oriented programming system for Intuition@{ub}".)
  You specify a class either as a pointer (for a private class) or
  by its ID string (for public classes).If the class pointeris NULL,
  then the classID is used.
  You further specify initial "create-time" attributes for the
  object via a TagItem list, and they are applied to the resulting
  generic data object that is returned.The attributes, their meanings,
  attributes applied only at create-time, and required attributes
  are all defined and documented on a class-by-class basis.
SYNOPSIS
  APTR NewObjectA( @{FG shine}struct@{FG text} IClass *, UBYTE *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} * );
  APTR NewObject ( @{FG shine}struct@{FG text} IClass *, UBYTE *, ULONG, ...);
  @{i}@{b}object@{ub}@{ui} = NewObjectA( @{i}class@{ui}, @{i}classID@{ui}, @{i}tagList@{ui} )
   D0                   A0     A1        A2
  @{i}@{b}object@{ub}@{ui} = NewObject ( @{i}class@{ui}, @{i}classID@{ui}, @{i}Tag1@{ui}, ...)
  @{i}class@{ui} = abstract pointer to a boopsi class gotten via @{"MakeClass()" Link "MakeClass()"}.
  @{i}classID@{ui} = the name/ID string of a public class.This parameter is
    only used if 'class' is NULL.
  @{i}tagList@{ui} = pointer to array of TagItems containing attribute/value
    pairs to be applied to the object being created
  A boopsi object, which may be used in different contexts such
  as a gadget or image, and may be manipulated by generic functions.
  You eventually free the object using @{"DisposeObject()" Link "DisposeObject()"}.
NOTES
  This function invokes the @{i}OM_NEW@{ui} "method" for the class specified.
BUGS
  Typedef's for 'Object' and 'Class' are defined in the include files but not
  used consistently.The generic type APTR is probably best used for object and
  class "handles", with the type (UBYTE *) used for classID strings.
SEE ALSO
  @{"DisposeObject()" Link "DisposeObject()"}, SetAttrs(), @{"GetAttr()" Link "GetAttr()"}, @{"MakeClass()" Link "MakeClass()"},
  Document "Basic Object-Oriented Programming System for Intuition"
  and the "boopsi Class Reference" document.
@EndNode
@Node "NextObject()" "intuition.library/NextObject"
@{b}@{u}NextObject@{uu}@{ub} -- iterate through the object on an Exec list.(V36)
  This function is for boopsi class implementors only.
  When you collect a set of boopsi objects on an Exec List structure
  by invoking their @{i}OM_ADDMEMBER@{ui} method, you can (only) retrieve them
  by iterations of this function.
  Works even if you remove and dispose the returned list members in turn.
SYNOPSIS  APTR NextObject( APTR );
  @{i}@{b}object@{ub}@{ui} = NextObject( @{i}objectPtrPtr@{ui} )
   D0                   A0
  Initially, you set a pointer variable to equal the lh_Head field of the
  list (or @{i}mlh_Head@{ui} field of a MinList).You pass the *address* of
  that pointer repeatedly to NextObject() until it returns NULL.
  Returns pointers to each object in the list in turn, and NULL
  when there are no more.
EXAMPLE
  /* here is the @{i}OM_DISPOSE@{ui} case of some class's dispatcher */
  @{FG shine}case@{FG text} @{b}OM_DISPOSE@{ub}:
    /* dispose members  */
    @{i}object_state@{ui} = mydata->md_CollectionList.@{i}lh_Head@{ui};
    @{FG shine}while@{FG text} ( @{i}member_object@{ui} = NextObject( @{i}&object_state@{ui} ) )
    {
      DoMethod( @{i}member_object@{ui}, OM_REMOVE ); /* remove from list */
      DoMethodA( @{i}member@{ui}, @{i}msg@{ui} ); /* and pass along dispose */
    }
SEE ALSO
  @{"DisposeObject()" Link "DisposeObject()"}, SetAttrs(), @{"GetAttr()" Link "GetAttr()"}, @{"MakeClass()" Link "MakeClass()"},
  Document "Basic Object-Oriented Programming System for Intuition"
  and the "boopsi Class Reference" document.
@EndNode
@Node "NextPubScreen()" "intuition.library/NextPubScreen"
@{b}@{u}NextPubScreen@{uu}@{ub} -- Identify next public screen in the cycle.(V36)
  Returns name of next public screen in system rotation, to allow visitor windows
  to provide function to "jump" among public-screens in a cycle.
SYNOPSIS  UBYTE *NextPubScreen( @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} *, UBYTE * );
  @{i}@{b}Buff@{ub}@{ui} = NextPubScreen( @{i}Screen@{ui}, @{i}NameBuff@{ui} )
   D0                    A0      A1
  @{i}Screen@{ui} = pointer to the screen your window is currently open in,
    or NULL, if you don't have a pointer to a public screen.
  @{i}NameBuff@{ui} = pointer to a buffer of MAXPUBSCREENNAME+1 characters, for Intuition
    to fill in with the name of the next public screen in rotation.
  Returns NULL if there are no public screens, otherwise a
  pointer to your @{i}NameBuff@{ui}.
NOTES
  There is no guarantee that the public screen whose name
  was returned by this function will exist or be in "public" state
  by the time you call @{"LockPubScreen()" Link "LockPubScreen()"}, etc.You must handle
  cases where @{"LockPubScreen()" Link "LockPubScreen()"}, etc.will fail.
  Note that this function may return the name of a public screen
  which is open but in "private mode" (see @{"PubScreenStatus()" Link "PubScreenStatus()"} and @{i}PSNF_PRIVATE@{ui}).
BUGS
  Due to a bug, your buffer needs to be (MAXPUBSCREENNAME + 1)
  characters big, which is one more than originally documented.
  The starting screen and cycle order of the public screens isn't defined,
  so do not draw conclusions about the order you see in the current version of
  Intuition.We reserve the right to add meaning to the ordering at a future time.
SEE ALSO
  @{"OpenScreen()" Link "OpenScreen()"}, Intuition V36 update documentation 
@EndNode
@Node "ObtainGIRPort()" "intuition.library/ObtainGIRPort"
@{b}@{u}ObtainGIRPort@{uu}@{ub} -- Set up a RastPort for a custom gadget.(V36)
  Sets up a RastPort for use (only) by custom gadget hook routines.
  This function must be called @{b}EACH@{ub} time a hook routine needing
  to perform gadget rendering is called, and must be accompanied
  by a corresponding call to @{"ReleaseGIRPort()" Link "ReleaseGIRPort()"}.
  Note that if a hook function passes you a RastPort pointer,
  e.g., @{i}GM_RENDER@{ui}, you needn't call ObtainGIRPort() in that case.
SYNOPSIS  @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *ObtainGIRPort( @{FG shine}struct@{FG text} @{"GadgetInfo" Link "include:intuition/cghooks.h/Main" 25} * );
  @{i}@{b}RPort@{ub}@{ui} = ObtainGIRPort( @{i}GInfo@{ui} )
   D0                     A0
  @{i}GInfo@{ui} =  pointer to a GadgetInfo structure, as passed to each custom
    gadget hook function.
  @{i}@{b}RPort@{ub}@{ui} =  pointer to a RastPort that may be used for gadget rendering.
    This pointer may be NULL, in which case you should do no rendering.
    You may (optionally) pass a null return value to ReleaseGIRPort().
SEE ALSO
  @{"ReleaseGIRPort()" Link "ReleaseGIRPort()"}, @{"Custom" Link "include:hardware/custom.h/Main" 25} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} documentation
@EndNode
@Node "OffGadget()" "intuition.library/OffGadget"
@{b}@{u}OffGadget@{uu}@{ub} -- Disable the specified gadget.
  This command disables the specified gadget.When a gadget is disabled,
  these things happen:
  - its imagery is displayed ghosted
  - the @{i}GFLG_DISABLED@{ui} flag is set
  - the gadget cannot be selected by User
  The window parameter must point to the window which contains the
  gadget, or which contains the requester that contains the gadget.
  The requester parameter must only be valid if the gadget has the
  @{i}GTYP_REQGADGET@{ui} flag set, a requirement for all requester gadgets.
SYNOPSIS
  @{FG shine}void@{FG text} OffGadget( @{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} * );
  OffGadget( @{i}Gadget@{ui}, @{i}Window@{ui}, @{i}Requester@{ui} )
              A0      A1       A2
  @{i}Gadget@{ui} = pointer to the gadget that you want disabled
  @{i}Window@{ui} = pointer to a window structure containing the gadget or
    containing the requester which contains the gadget
  @{i}Requester@{ui} = pointer to a requester (may by NULL if this isn't
    a requester gadget (i.e.@{i}GTYP_REQGADGET@{ui} is not set)).
NOTES
  It's never safe to tinker with the gadget list yourself.Don't supply
  some gadget that Intuition hasn't already processed in the usual way.
  For compatibility reasons, this function will refresh all
  gadgets in a requester, and all gadgets from gadget to the 
  end of the gadget list if gadget is in a window.
  If you want to improve on this behavior, you may perform the
  equivalent operation yourself: remove a gadget or gadgets,
  change the state of their @{i}GFLG_DISABLED@{ui} flag, replace the
  gadgets using @{"AddGList()" Link "AddGList()"}, and selectively call @{"RefreshGList()" Link "RefreshGList()"}.
SEE ALSO
  @{"OnGadget()" Link "OnGadget()"}, @{"AddGadget()" Link "AddGadget()"}, @{"RefreshGadgets()" Link "RefreshGadgets()"}
@EndNode
@Node "OffMenu()" "intuition.library/OffMenu"
@{b}@{u}OffMenu@{uu}@{ub} -- Disable the given menu or menu item.
  This command disables a sub-item, an item, or a whole menu.
  This depends on the contents of the data packed into MenuNumber,
  which is described in the Intuition Reference Manual.
SYNOPSIS  @{FG shine}void@{FG text} OffMenu( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, UWORD );
  OffMenu( @{i}Window@{ui}, @{i}MenuNumber@{ui} )
            A0      D0
  @{i}Window@{ui} = pointer to the window
  @{i}MenuNumber@{ui} = the menu piece to be disabled
SEE ALSO
  @{"OnMenu()" Link "OnMenu()"}, @{"ResetMenuStrip()" Link "ResetMenuStrip()"}
@EndNode
@Node "OnGadget()" "intuition.library/OnGadget"
@{b}@{u}OnGadget@{uu}@{ub} -- Enable the specified gadget.
  This command enables the specified gadget.When a gadget is
  enabled, these things happen:
  - its imagery is displayed normally (not ghosted)
  - the @{i}GFLG_DISABLED@{ui} flag is cleared
  - the gadget can thereafter be selected by the user
  The window parameter must point to the window which contains the
  gadget, or which contains the requester that contains the gadget
  The requester parameter must only be valid if the gadget has the
  @{i}GTYP_REQGADGET@{ui} flag set, a requirement for all requester gadgets.
SYNOPSIS
  @{FG shine}void@{FG text} OnGadget( @{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} * );
  OnGadget( @{i}Gadget@{ui}, @{i}Window@{ui}, @{i}Requester@{ui} )
             A0      A1       A2
  @{i}Gadget@{ui} = pointer to the gadget that you want disabled
  @{i}Window@{ui} = pointer to a window structure containing the gadget or
    containing the requester which contains the gadget
  @{i}Requester@{ui} = pointer to a requester (may by NULL if this isn't
    a requester gadget (i.e.@{i}GTYP_REQGADGET@{ui} is not set)).
NOTES
  It's never safe to tinker with the gadget list yourself.Don't supply
  some gadget that Intuition hasn't already processed in the usual way.
  For compatibility reasons, this function will refresh all
  gadgets in a requester, and all gadgets from gadget to the 
  end of the gadget list if gadget is in a window.
  If you want to improve on this behavior, you may perform the
  equivalent operation yourself: remove a gadget or gadgets,
  change the state of their @{i}GFLG_DISABLED@{ui} flag, replace the
  gadgets using @{"AddGList()" Link "AddGList()"}, and selectively call @{"RefreshGList()" Link "RefreshGList()"}.
BUGS
  Traditional gadgets are rendered very simply.This can result in incomplete
  clearing away of the ghosting pattern when OnGadget() is used.
  For example, a button whose imagery consists of an IntuiText inside a
  rectangular Border doesn't have the button interior cleared by OnGadget().
  This is because OnGadget() clears the @{i}GFLG_DISABLED@{ui} flag then redraws
  the gadget.Redrawing this gadget consists of redrawing the border and text.
  Nothing redraws the field.
  The solution to this type of problem is to either use a gadget
  whose imagery is a @{FG shine}struct@{FG text} Image that covers the whole select area,
  or to manually remove the gadget, erase the gadget's select area
  (say using @{"EraseRect()" Link "graphics.guide/EraseRect()"}), then clear the @{i}GFLG_DISABLED@{ui} flag,
  add the gadget back to the window, and refresh it.
SEE ALSO
  @{"OffGadget()" Link "OffGadget()"}
@EndNode
@Node "OnMenu()" "intuition.library/OnMenu"
@{b}@{u}OnMenu@{uu}@{ub} -- Enable the given menu or menu item.
  This command enables a sub-item, an item, or a whole menu.
  This depends on the contents of the data packed into MenuNumber,
  which is described in the Intuition Reference Manual.
SYNOPSIS  @{FG shine}void@{FG text} OnMenu( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, UWORD );
  OnMenu( @{i}Window@{ui}, @{i}MenuNumber@{ui} )
           A0       D0
  @{i}Window@{ui} = pointer to the window
  @{i}MenuNumber@{ui} = the menu piece to be enabled
SEE ALSO
  @{"OffMenu()" Link "OffMenu()"}, @{"ResetMenuStrip()" Link "ResetMenuStrip()"}
@EndNode
@node NEWSCREEN_INIT_DATA "NewScreen_init_data"
@{b}@{u}NewScreen is initialized with the following information@{uu}@{ub}:
  @{i}Left@{ui} = initial x-position of your screen (should be zero for
    releases prior to V36)
  @{i}Top@{ui} = initial y-position of the opening screen
    (@{i}Note@{ui}: Left and Top are specified relative to the Intuition's view,
    in same resolution as the screen pixels.)
  @{i}Width@{ui} = the width for this screen's RastPort
  @{i}Height@{ui} = the height for this screen's RastPort, or the constant
    @{i}STDSCREENHEIGHT@{ui} to get the current default height (at this time guaranteed
    to be at least 200 rows).The normal width and height for a particular system
    is stored by the graphics.library in GfxBase->@{i}NormalDisplayRows@{ui} and
    GfxBase->@{i}NormalDisplayColumns@{ui}.These values will be different depending on
    factors such as PAL video and overscan.
    @{i}For V36@{ui}, a new constant @{i}STDSCREENWIDTH@{ui} is introduced.It serves the similar
    function for screen width.Both @{i}STDSCREENWIDTH@{ui} and @{i}STDSCREENHEIGHT@{ui} indicate
    that your screen RastPort is to be the same dimensions as your DisplayClip
    rectangle.If you do not specify either a standard or custom DisplayClip,
    the @{i}OSCAN_TEXT@{ui} region will be used, which corresponds to the standard
    dimensions of V35 and earlier.
    Furthermore, if you are using @{"OpenScreenTagList()" Link "OpenScreenTagList()"}, and you specify
    @{i}STDSCREENWIDTH@{ui}, and you @{b}DO NOT@{ub} provide a @{"NewScreen" Link "include:intuition/screens.h/Main" 477} pointer, and you
    @{b}DO NOT@{ub} provide @{i}sA_Left@{ui}, then Intuition will automatically set the @{i}LeftEdge@{ui}
    of the screen to be the left edge of the screen's DisplayClip region.
    Likewise for @{i}STDSCREENHEIGHT@{ui} and the screen's TopEdge.
  @{i}Depth@{ui} = number of bitplanes
  @{i}DetailPen@{ui} = pen number for details (like gadgets or text in title bar)
    The common value for this pen is 0.
  @{i}BlockPen@{ui} = pen number for block fills (like title bar)
    The common value for this pen is 1.
  @{i}Type@{ui} = screen type values
  @{i}ViewModes@{ui} = the appropriate argument for the data type ViewPort.Modes.
    @{i}These include@{ui}:
      @{b}HIRES@{ub} for this screen to be HIRES width.
      @{b}LACE@{ub} for the display to switch to interlace.
      @{b}SPRITES@{ub} for this screen to use sprites
        (the pointer sprite is always displayed)
      @{b}DUALPF@{ub} for dual-playfield mode (not supported yet)
    @{i}For V36:@{ui} The ViewModes field is superseded by a TagItem with tag value
      @{i}SA_DisplayID@{ui}.
  @{i}Font@{ui} = pointer to the default @{"TextAttr" Link "include:graphics/text.h/Main" 65} structure for text in this screen
    and all windows that open in this screen.Text that uses this TextAttr
    includes title bars of both screen and windows, string gadgets, and menu
    titles.Of course, IntuiText that specifies a NULL TextAttr field will use
    the screen/window default fonts.
    @{i}NOTE:@{ui} Intuition will *@{b}NOT@{ub}* call @{"OpenDiskFont()" Link "libs.guide/OpenDiskFont()"}, so the TextAttr you supply
    must be in memory.The ways to ensure that are to either use a ROM font
    (Topaz 8 or 9) or first call @{"OpenDiskFont()" Link "libs.guide/OpenDiskFont()"} to load the font, and don't
    close it until after your screen is successfully opened.
    @{i}For V36:@{ui} this is superseded by @{i}SA_Font@{ui} and @{i}SA_SysFont@{ui}.
  @{i}DefaultTitle@{ui} = pointer to a line of text that will be displayed along the
    screen's title bar.Null terminated, or just a NULL pointer to get no text.
    @{i}For V36:@{ui} superseded by @{i}SA_Title@{ui}.
  @{i}Gadgets@{ui} = This field should be set to NULL, since no user gadgets may be
    attached to a screen with the current versions of Intuition.
  @{i}CustomBitMap@{ui} = if you're not supplying a custom bitmap, this value is ignored.
    However,if you have your own display memory that you want used for this
    screen, the CustomBitMap field should point to the BitMap structure that
    describes your display memory.See the "Screens" chapter and the "Amiga
    ROM Kernel Manual" for more information about bitmaps.
    @{i}For V36:@{ui} this is superseded by @{i}SA_BitMap@{ui}.
    @{i}Set these flags as desired from the set@{ui}:
      @{b}CUSTOMSCREEN@{ub} -- this is your own screen, not a system screen.
      @{b}CUSTOMBITMAP@{ub} -- this custom screen has bit maps supplied in the
        bitmap field of the @{"NewScreen" Link "include:intuition/screens.h/Main" 477} structure.Intuition is not going
        to allocate any raster bitmaps.
      @{b}SCREENBEHIND@{ub} -- your screen will be created behind all other open screens.
        This allows a program to prepare imagery in the screen, change its
        colors, and so on, bringing it to the front when it is presentable.
      @{b}SCREENQUIET@{ub} -- Intuition will not render system screen gadgets or
        screen title.In concert with the @{i}WFLG_RMBTRAP@{ui} flag on all your
        screen's windows, this flag will prevent Intuition from rendering
        into your screen's bitplanes.
        Without @{i}WFLG_RMBTRAP@{ui} (or using the @{i}IDCMP_MENUVERIFY@{ui} facility to cancel
        menu operations), this flag will prevent Intuition from clearing your
        menu bar, which is probably unacceptable.The menu bar layer may still
        overwrite a portion of your screen bitmap when the screen is opened.
        (V36: it won't clobber your bits any more.)
      @{b}NS_EXTENDED@{ub} for this screen to use extended attributes pointed to by the
       'Extended' field, below.All @{"TagItem" Link "include:utility/tagitem.h/Main" 31} extensions below are new for V36.
  @{i}Extension@{ui} = if @{i}NS_EXTENDED@{ui} is set in NewScreen.@{i}Type@{ui}.
    This pointer should point to an array (or chain of arrays) of TagItems,
    as defined in the include file @{"<utility/tagitem.h>" Link "include:utility/tagitem.h/Main" 0}.This field is only
    defined in the structure ExtNewScreen.
    The values to use for TagItem.@{i}ti_Tag@{ui} are defined below.We recommend that
    V36-specific applications use the new Intuition entry point
    @{"OpenScreenTagList()" Link "OpenScreenTagList()"}, rather than using this field.
    The @{"ExtNewScreen" Link "include:intuition/screens.h/Main" 502} structure is a convenient way to give V36 Intuition
    some information that V34 and earlier Intuition will ignore.
    Each TagItem is an optional tagged data structure which identifies
    an additional parameter to OpenScreen().@{b}@{u}The applicable tag ID@{uu}@{ub}
    @{b}@{u}values for TagItem.ti_Tag and their corresponding data follow@{uu}@{ub}:
      @{"NewScreen tags" link NEWSCREEN_INIT_DATA_NEWSCREEN_TAGS}
      @{"ExtNewScreen tags" link NEWSCREEN_INIT_DATA_EXTNEWSCREEN_TAGS}
      @{"Attached screen tags" link NEWSCREEN_INIT_DATA_ATTACHEDSCREEN_TAGS}
@endnode
@node NEWSCREEN_INIT_DATA_NEWSCREEN_TAGS "NewScreen_init_data_NewScreen_tags"
@{b}@{u}Several of the tag items are alternative (and overriding) versions to familiar
fields in NewScreen.(Defaults only apply if NewScreen == NULL).They are@{uu}@{ub}:
  @{b}SA_Left@{ub}
  @{b}SA_Top@{ub}
  @{b}SA_Width@{ub}
  @{b}SA_Height@{ub}
    The defaults for the @{i}SA_Left@{ui}, @{i}SA_Top@{ui}, @{i}SA_Width@{ui}, and @{i}SA_Height@{ui} tags end up
    being a bit complex.If none of these tags are specified, and no NewScreen
    structure is used, then the left/top/width/height correctly match the
    display clip of your screen (see @{i}SA_DClip@{ui} and @{i}SA_Overscan@{ui}).
    The difficulty comes with overscanned screens, because the normal value of
    @{i}SA_Left@{ui} or @{i}SA_Top@{ui} for such a screen may be non-zero.If a NewScreen structure
    is supplied, then the left/top/width/height come originally from there.If no
    NewScreen structure is supplied, but a non-default @{i}SA_Width@{ui} (@{i}SA_Height@{ui}) is
    specified, then @{i}SA_Left@{ui} (@{i}SA_Top@{ui}) defaults to zero instead.In these cases,
    the left and top edge may not be what you want.
    If you need to specify explicit width or height, or supply a NewScreen,
    you must supply correct values for @{i}SA_Left@{ui} and @{i}SA_Top@{ui}.The correct normal
    values are the display clip rectangle's @{i}MinX@{ui} and @{i}MinY@{ui} values respectively.
    If you are using the @{i}SA_DClip@{ui} tag, then you already have a rectangle to
    consult for these values.If you are using @{i}SA_Overscan@{ui} to get one of the
    standard overscan types, you may use @{"QueryOverscan()" Link "QueryOverscan()"} to get a rectangle
    for that overscan type.
  @{b}SA_Depth@{ub} (defaults to 1)
  @{b}SA_DetailPen@{ub} (defaults to 0)
  @{b}SA_BlockPen@{ub} (defaults to 1)
  @{b}SA_Title@{ub} (defaults to NULL)
  @{b}SA_Font@{ub} (defaults to NULL, meaning user's preferred monospace font)
  @{b}SA_BitMap@{ub} (whose existence also implies @{i}CUSTOMBITMAP@{ui}).
@{i}Several tags are Booleans, which means that depending on whether their
corresponding ti_Data field is zero (FALSE) or non-zero (TRUE), they
specify Boolean attributes@{ui}.@{b}@{u}The ones corresponding to Boolean flags
in the NewScreen.@{i}Type@{ui} field are@{uu}@{ub}:
  @{b}SA_ShowTitle@{ub} (defaults to TRUE)
  @{b}SA_Behind@{ub} (equiv.to @{i}SCREENBEHIND@{ui}) (defaults to FALSE)
  @{b}SA_Quiet@{ub} (equiv.to @{i}SCREENQUIET@{ui}) (defaults to FALSE)
@endnode
@node NEWSCREEN_INIT_DATA_EXTNEWSCREEN_TAGS "NewScreen_init_data_ExtNewScreen_tags"
@{b}@{u}The following tags provide extended information to Intuition
when creating a screen@{uu}@{ub}:
  @{b}SA_Type@{ub}: ti_Data corresponds to the @{i}SCREENTYPE@{ui} bits of the
    NewScreen.Type field.This should be one of PUBLICSCREEN or
    CUSTOMSCREEN.The other bits of the NewScreen.Type field
    must be set with the appropriate tags (@{i}SA_Behind@{ui}, @{i}SA_Quiet@{ui}, etc.)
  @{b}SA_DisplayID@{ub}: ti_Data is a 32-bit extended display mode ID, as
    defined in the <graphics/modeid.h> include file (V39 and up)
    or in @{"<graphics/displayinfo.h>" Link "include:graphics/displayinfo.h/Main" 0} (V37 and V38).
  @{b}SA_Overscan@{ub}: ti_Data contains a defined constant specifying
    one of the system standard overscan dimensions appropriate for
    the display mode of the screen.Used with the Width and
    Height dimensions @{i}STDSCREENWIDTH@{ui} and @{i}STDSCREEN@{ui}, this makes
    it trivial to open an overscanned or standard dimension
    screen.You may also hand-pick your various dimensions
    for overscanned or other screens, by specifying screen position
    and dimensions explicitly, and by using @{i}SA_DClip@{ui} to explicitly
    specify an overscanned DisplayClip region.
    @{i}The values for ti_Data of this tag are as follows@{ui}:
      @{b}OSCAN_TEXT@{ub} - Text Overscan region.A region which is completely
        on screen and readable ("text safe").A preferences data
        setting, this is backward equivalent with the old MoreRows,
        and specifies the DisplayClip and default dimensions of the
        Workbench screen.This is the default.
      @{b}OSCAN_STANDARD@{ub} - Also a preferences setting, this specifies
        a rectangle whose edges are "just out of view." This yields
        the most efficient position and dimensions of on-monitor
        presentations, such as games and artwork.
      @{b}OSCAN_MAX@{ub} - This is the largest rectangular region that the
        graphics library can handle "comfortably" for a given mode.
        Screens can smoothly scroll (hardware pan) within this region,
        and any DisplayClip or Screen region within this rectangle
        is also legal.It is not a preferences item, but reflects
        the limits of the graphics hardware and software.
      @{b}OSCAN_VIDEO@{ub} - This is the largest region that the graphics
        library can display, comfortable or not.There is no guarantee
        that all smaller rectangles are valid.This region is
        typically out of sight on any monitor or TV, but provides our
        best shot at "edge-to-edge" video generation.
    Remember, using overscan drastically effects memory use and
    chip memory bandwidth.Always use the smallest (standard)
    overscan region that works for your application.
  @{b}SA_DClip@{ub}: ti_Data is a pointer to a rectangle which explicitly
    defines a DisplayClip region for this screen.See @{"QueryOverscan()" Link "QueryOverscan()"}
    for the role of the DisplayClip region.
    Except for overscan display screens, this parameter is
    unnecessary, and specifying a standard value using @{i}SA_Overscan@{ui}
    is normally an easier way to get overscan.
  @{b}SA_AutoScroll@{ub}: this is a Boolean tag item, which specifies that
    this screens is to scroll automatically when the mouse pointer
    reaches the edge of the screen.The operation of this requires
    that the screen dimensions be larger than its DisplayClip region.
  @{b}SA_PubName@{ub}:If this field is present (and ti_Data is non-NULL),
    it means that the screen is a public screen, and that
    the public screen name string is pointed to by ti_Data.
    Public screens are opened in "PRIVATE" mode and must
    be made public using PubScreenStatus( screen, 0 ).
  @{b}SA_Pens@{ub}:The ti_Data field (if non-NULL) points to a UWORD
    array of pen specification, as defined for @{FG shine}struct@{FG text} @{"DrawInfo" Link "include:intuition/screens.h/Main" 60}.
    This array will be used to initialize the screen's DrawInfo.@{i}dri_Pens@{ui} array.
    @{i}SA_Pens@{ui} is also used to decide that a screen is ready to support the
    full-blown "new look" graphics.If you want the 3D embossed look, you
    must provide this tag, and the ti_Data value cannot be NULL.If it points
    to a "minimal" array, containing just the terminator ~0, you can specify
    "new look" without providing any values for the pen array.
    The way the @{"DrawInfo" Link "include:intuition/screens.h/Main" 60} pens are determined is Intuition
    picks a default pen-array.Then, any pens you supply with
    @{i}SA_Pens@{ui} override the defaults, up until the ~0 in your array.
    - If the screen is monochrome or old-look, the default will be the
    standard two-color pens.
    - If the screen is two or more planes deep, the default will be the
    standard four-color pens, which now include the new-look menu colors.
    - If the screen has the @{i}SA_LikeWorkbench@{ui} property, the default will be the
    user's preferred pen-array, changeable through preferences.
  The following @{i}two@{ui} tag items specify the task and signal to be issued
  to notify when the last "visitor" window closes on a public screen.
  This support is to assist envisioned public screen manager programs.
  @{b}SA_PubTask@{ub}: @{"Task" Link "include:exec/tasks.h/Main" 24} to be signalled.If absent (and SA_PubSig is
    valid), use the task which called OpenScreen() or
    @{"OpenScreenTagList()" Link "OpenScreenTagList()"}).
  @{b}SA_PubSig@{ub}: Data is a UBYTE signal number (not flag) used to notify
    a task when the last visitor window closes on a public screen.
  @{b}SA_Colors@{ub}: ti_Data points to an array of @{"ColorSpec" Link "include:intuition/intuition.h/Main" 1439} structures
    (terminated with ColorIndex = -1) which specify initial
    values of the screen's color palette.
  @{b}SA_FullPalette@{ub}: this is a Boolean attribute.Prior to V36, there
    were just 7 RGB color values that Intuition maintained
    in its user preferences (playfield colors 0-3, and colors
    17-19 for the sprite).When opening a screen, the color
    map for the screens viewport is first initialized by
    graphics @{"(graphics.library/GetColorMap()" Link "graphics.guide/GetColorMap()"}) then these
    seven values are overridden to take the preferences values.
    In V36, Intuition maintains a full set of 32 preferences colors.
    If you specify TRUE for @{i}SA_FullPalette@{ui}, Intuition will
    override @{b}ALL@{ub} color map entries with its full suite of
    preferred colors.(Defaults to FALSE).
  @{b}SA_ErrorCode@{ub}: ti_Data points to a ULONG in which Intuition will
    stick an extended error code if OpenScreen[TagList]() fails.
    @{i}Values of this tag's ti_data include 0, for success, and@{ui}:
      OSERR_NOMONITOR - monitor for display mode not available.
      OSERR_NOCHIPS - you need newer custom chips for display mode.
      OSERR_NOMEM - couldn't get normal memory
      OSERR_NOCHIPMEM - couldn't get chip memory
      OSERR_PUBNOTUNIQUE - public screen name already used
      OSERR_UNKNOWNMODE - don't recognize display mode requested
      OSERR_TOODEEP - screen too deep to be displayed on this hardware (V39)
      OSERR_ATTACHFAIL - An illegal attachment of screens was requested (V39)
    @{b}NOTE:@{ub} These values are not the same as some similar return values defined in
    @{"graphics.library/ModeNotAvailable()" Link "graphics.guide/ModeNotAvailable()"}.
  @{b}SA_SysFont@{ub}: ti_Data selects one of the system standard fonts specified in
    preferences.This tag item overrides the NewScreen.Font field and the
    @{i}SA_Font@{ui} tag item.Values recognized in ti_Data at present are:
    @{i}0@{ui} - old DefaultFont, fixed-width, the default.
    @{i}1@{ui} - Workbench screen preferred font.
      You have to be very font sensitive to handle a proportional or larger than
      traditional screen font.
    @{b}NOTE WELL:@{ub} if you select sysfont 1, windows opened on your screen will not
    inherit the screen font, but rather the window RastPort will be initialized
    to the old-style DefaultFont (sysfont 0).
@endnode
@node NEWSCREEN_INIT_DATA_ATTACHEDSCREEN_TAGS "NewScreen_init_data_AttachedScreen_tags"
@{b}@{u}Attached screen tags@{uu}@{ub}: V39 supports attached screens, where one or more child
  screens can be associated with a parent screen.Attached screens depth-arrange
  as a group, and always remain adjacent depth-wise.Independent depth-arrangement
  of child screens is possible through the V39 @{"ScreenDepth()" Link "ScreenDepth()"} call.If a child
  screen is made non-draggable through {@{i}SA_Draggable@{ui}, FALSE}, then it will drag
  exclusively with the parent.Normal child screens drag independently of the
  parent, but are pulled down when the parent is.
  Use the @{i}SA_Parent@{ui}, @{i}SA_FrontChild@{ui}, and @{i}SA_BackChild@{ui} tags to attach screens.
  @{b}SA_Parent@{ub}: If you wish to attach this screen to an already-open parent screen,
    use this tag and set ti_Data to point to the parent screen.
    See also @{i}SA_FrontChild@{ui} and @{i}SA_BackChild@{ui}.(V39).
  @{b}SA_FrontChild@{ub}: If you wish to attach an already-open child screen to this
    screen, set ti_Data to point to the child screen.The child screen will come
    to the front of the family defined by the parent screen you are opening.
    See also @{i}SA_Parent@{ui} and @{i}SA_BackChild@{ui}.(V39)
  @{b}SA_BackChild@{ub}: If you wish to attach an already-open child screen to this
    screen, set ti_Data to point to the child screen.The child screen will go
    to the back of the family defined by the parent screen you are opening.
    See also @{i}SA_Parent@{ui} and @{i}SA_FrontChild@{ui}.(V39)
  @{b}SA_BackFill@{ub}: ti_Data is a pointer to a backfill hook for the screen's
    @{"Layer_Info" Link "include:graphics/layers.h/Main" 29}.(see layers.library/InstallLayerInfoHook()).(V39).
  @{b}SA_Draggable@{ub}: ti_Data is a boolean.Set to FALSE if you wish your screen to be
    non-draggable.@{b}This tag should be used very sparingly!@{ub}.Defaults to TRUE.
    For child screens (see @{i}SA_Parent@{ui}, @{i}SA_FrontChild@{ui}, and @{i}SA_BackChild@{ui}) this
    tag has a slightly different meaning: non-draggable child screens are
    non-draggable with respect to their parent, meaning they always drag exactly
    with the parent, as opposed to having relative freedom.
    Also see @{"ScreenPosition()" Link "ScreenPosition()"}.(V39)
  @{b}SA_Exclusive@{ub}: ti_Data is a boolean.Defaults to FALSE.
    Set to TRUE if you never want your screen to share the display with another
    screen.This means that your screen can't be pulled down,and will not appear
    behind other screens that are pulled down.Your screen may still be depth
    arranged, though.@{b}Use this tag sparingly!@{ub}
    @{b}Starting with V40@{ub}, attached screens may be @{i}SA_Exclusive@{ui}.
    Setting @{i}SA_Exclusive@{ui} for each screen will produce an exclusive family.(V39).
  @{b}SA_SharePens@{ub}: For those pens in the screen's DrawInfo->@{i}dri_Pens@{ui}, Intuition
    obtains them in shared mode (see graphics.library/ObtainPen()).
    For compatibility, Intuition obtains the other pens of a public screen as
    @{i}PENF_EXCLUSIVE@{ui}.Screens that wish to manage the pens themselves should
    generally set this tag to TRUE.This instructs Intuition to leave the
    other pens unallocated.Defaults to FALSE.(V39).
  @{b}SA_Colors32@{ub}: Tag to set the screen's initial palette colors
    at 32 bits-per-gun.ti_Data is a pointer to a table to be passed
    to the graphics.library/LoadRGB32() function.This format supports
    both runs of color registers and sparse registers.
    See the autodoc for that function for full details.Any color set here
    has precedence over the same register set by @{i}SA_Colors@{ui}.(V39).
  @{b}SA_Interleaved@{ub}: ti_Data is a boolean.Defaults to FALSE.
    Set to TRUE to request an interleaved bitmap for your screen.
    If the system cannot allocate an interleaved bitmap for you,
    it will attempt to allocate a non-interleaved one (V39).
  @{b}SA_VideoControl@{ub}: ti_Data points to a taglist that will be passed to
    @{"VideoControl()" Link "graphics.guide/VideoControl()"} after your screen is open.
    You might use this to turn on border-sprites, for example.(V39).
  @{b}SA_ColorMapEntries@{ub}: ti_Data is the number of entries that you wish Intuition
    to allocate for this screen's @{"ColorMap" Link "include:graphics/view.h/Main" 113}.
    While Intuition allocates a suitable number for ordinary use, certain
    graphics.library features require a ColorMap which is larger than default.
    (The default value is 1<<depth, but not less than 32).(V39)
  @{b}SA_LikeWorkbench@{ub}: ti_Data is boolean.
    Set to TRUE to get a screen just like the Workbench screen.This is the best
    way to inherit all the characteristics of the Workbench, including depth,
    colors, pen-array, screen mode,etc.Individual attributes can be overridden
    through the use of tags.(@{i}SA_LikeWorkbench@{ui} itself overrides things specified
    in the NewScreen structure).Attention should be paid to hidden assumptions
    when doing this.For example, setting the depth to two makes assumptions
    about the pen values in the @{"DrawInfo" Link "include:intuition/screens.h/Main" 60} pens.Note that this tag requests that
    Intuition @{b}ATTEMPT@{ub} to open the screen to match the Workbench.There are fall-
    backs in case that fails, so it is not correct to make enquiries about the
    Workbench screen then make strong assumptions about what you're going to get.
    (Defaults to FALSE).(V39)
  @{b}SA_MinimizeISG@{ub}: ti_Data is boolean.
    For compatibility, Intuition always ensures that the inter-screen gap is at
    least three non-interlaced lines.If your application would look best with
    the smallest possible inter-screen gap, set ti_Data to TRUE.
    If you use the new graphics @{"VideoControl()" Link "graphics.guide/VideoControl()"} @{i}VC_NoColorPaletteLoad@{ui} tag
    for your screen's @{"ViewPort" Link "include:graphics/view.h/Main" 40}, you should also set this tag.@{b}(V40)@{ub}
@endnode
@Node "OpenScreen()" "intuition.library/OpenScreen"
@{b}@{u}OpenScreen@{uu}@{ub} -- Open an Intuition screen.
  Opens an Intuition screen according to the specified parametersfound in the
  NewScreen structure.
  Does all the allocations, sets up the screen structure and all
  substructures completely, and links this screen's viewport into
  Intuition's @{"View" Link "include:graphics/view.h/Main" 57} structure.
  Before you call OpenScreen(), you must initialize an instance of a NewScreen
  structure.NewScreen is a structure that contains all of the arguments needed
  to open a screen.The NewScreen structure may be discarded immediately after
  OpenScreen() returns.
  The @{i}SHOWTITLE@{ui} flag is set to TRUE by default when a screen is opened.
  To change this, you must call the routine @{"ShowTitle()" Link "ShowTitle()"}.
  @{i}New for V36@{ui}: In addition to the information contained in the NewScreen
  structure, Intuition now recognizes extended data passed in the form
  of an array of TagItem structures (from @{"<utility/tagitem.h>" Link "include:utility/tagitem.h/Main" 0}),
  commonly called a "tag list."There are two ways to provide this array.
  The first is to use the new Intuition entry point @{"OpenScreenTagList()" Link "OpenScreenTagList()"} and
  pass the tag list as a parameter.This is the recommended method,and has a con-
  venient format variation for C programs using a variable number of arguments.
  An older way used for some V36 development uses the OpenScreen() entry point,
  and an extension of the NewScreen structure named @{"ExtNewScreen" Link "include:intuition/screens.h/Main" 502}.
  See the documentation of the flag @{i}NS_EXTENDED@{ui}, below.
  While we recommend that you use @{"OpenScreenTagList()" Link "OpenScreenTagList()"} rather than OpenScreen()
  when using the extension tag list, we document the tag ID values here,
  so that all parameters for opening a screen can be found in one place.
SYNOPSIS
  @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} *OpenScreen( @{FG shine}struct@{FG text} @{"NewScreen" Link "include:intuition/screens.h/Main" 477} * ); or
  @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} *OpenScreen( @{FG shine}struct@{FG text} @{"ExtNewScreen" Link "include:intuition/screens.h/Main" 502} * );
  @{i}@{b}Screen@{ub}@{ui} = OpenScreen( @{i}NewScreen@{ui} )
   D0                   A0
  @{i}NewScreen@{ui} = pointer to an instance of a NewScreen structure.
  If all is well, returns the pointer to your new screen.
  If anything goes wrong, returns NULL, with further error specification in
  the variable pointed to by the @{i}SA_ErrorCode@{ui} data field (V36 and later).
  @{"NewScreen is initialized with the following information" link NEWSCREEN_INIT_DATA}
EXAMPLE
  @{b}#include@{ub} "libraries/dosextens.h"
    ...
  @{FG shine}struct@{FG text} @{"Process" Link "include:dos/dosextens.h/Main" 37} *@{i}process@{ui};
  @{FG shine}struct@{FG text} Window *@{i}window@{ui};
  APTR    @{i}temp@{ui};
    ...
    @{i}process@{ui} = (@{FG shine}struct@{FG text} Process *) FindTask(NULL);
    @{i}temp@{ui} = process->@{i}pr_WindowPtr@{ui}; (save old value)
    process->@{i}pr_WindowPtr@{ui} = (APTR) @{i}window@{ui};
    ( use a pointer to any open window on your screen )
      ...
    your code goes here
      ...
    process->@{i}pr_WindowPtr@{ui} = @{i}temp@{ui};
    ( restore value BEFORE @{"CloseWindow()" Link "CloseWindow()"} )
    CloseWindow(@{i}window@{ui});
NOTES
  By default, AmigaDOS requesters related to your process are put on the
  Workbench screen (these are messages like "Disk Full").If you wish them to
  show up on custom screens, DOS must be told.This fragment shows the procedure.
  More information is available in the AmigaDOS manuals.
  @{b}A VERY IMPORTANT NOTE@{ub} about the Screen->@{i}BitMap@{ui}:In the future, bitmaps will
  need to grow.The embedded instance of a bitmap in the screen will no longer
  be large enough to hold the whole description of the bitmap.
  @{b}YOU ARE STRONGLY URGED@{ub} to use Screen->RastPort.@{i}BitMap@{ui} in place of
  &Screen->@{i}BitMap@{ui} whenever and whereever possible.
SEE ALSO
  @{"OpenScreenTagList()" Link "OpenScreenTagList()"}, @{"OpenWindow()" Link "OpenWindow()"}, @{"PrintIText()" Link "PrintIText()"}, @{"CloseScreen()" Link "CloseScreen()"},
  @{"QueryOverscan()" Link "QueryOverscan()"} @{"PubScreenStatus()" Link "PubScreenStatus()"}, The Intuition Reference Manual,
  @{"utility/tagitem.h" Link "include:utility/tagitem.h/Main" 0}, @{"graphics.library/ModeNotAvailable()" Link "graphics.guide/ModeNotAvailable()"},
  @{"diskfont.library/OpenDiskFont()" Link "libs.guide/OpenDiskFont()"}, @{"graphics.library/GetColorMap()" Link "graphics.guide/GetColorMap()"}
@EndNode
@Node "OpenScreenTagList()" "intuition.library/OpenScreenTagList"
@{b}@{u}OpenScreenTagList@{uu}@{ub} -- @{"OpenScreen()" Link "OpenScreen()"} with TagItem extension array.(V36)
@{b}@{u}OpenScreenTags@{uu}@{ub}    -- Varargs stub for OpenScreenTagList.(V36)
  Provides an extension to the parameters passed to @{"OpenScreen()" Link "OpenScreen()"}.
  This extensions is in the form of (a pointer to) an array of
  TagItem structures, which have to fields:ti_Tag, an ID identifying
  the meaning of the other field, ti_Data.See @{"<utility/tagitem.h>" Link "include:utility/tagitem.h/Main" 0}.
  The tag items can supplement or override the values in NewScreen.
  In fact, you can pass a NULL value of the NewScreen pointer.
  For that matter, if you pass NULL in both arguments, you'll get
  a screen with defaults in all fields, including display mode,
  depth, colors, dimension, title, and so on.We ask that
  you at least supply a title when you open a screen.
  See @{"OpenScreen()" Link "OpenScreen()"} documentation for parameter specifications.
SYNOPSIS
  @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} *OpenScreenTagList( @{FG shine}struct@{FG text} @{"NewScreen" Link "include:intuition/screens.h/Main" 477} *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} * );
  @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} *OpenScreenTags   ( @{FG shine}struct@{FG text} @{"NewScreen" Link "include:intuition/screens.h/Main" 477} *, ULONG, ...);
  @{i}@{b}Screen@{ub}@{ui} = OpenScreenTagList( @{i}NewScreen@{ui}, @{i}TagItems@{ui} )
   D0                          A0          A1
  @{i}@{b}Screen@{ub}@{ui} = OpenScreenTags   ( @{i}NewScreen@{ui}, @{i}Tag1@{ui}, ...)
  @{i}NewScreen@{ui} - (optional) pointer to a NewScreen structure.
  @{i}TagItems@{ui}  - (optional) pointer to (an array of) TagItem
    structures, terminated by the value TAG_END.
  @{i}@{b}Screen@{ub}@{ui} - an open Intuition screen.See @{"OpenScreen()" Link "OpenScreen()"} for
    extended error codes when Screen is returned NULL.
EXAMPLE
  The version using a variable number of arguments must be created for each
  particular compiler, and may not have an analogue in all versions.
  For vanilla, 32-bit C parameter passing conventions, this works
  (and will appear in amiga.lib):
  @{FG shine}struct@{FG text} Screen *OpenScreenTags( @{i}ns@{ui}, @{i}tag1@{ui} )
  @{FG shine}struct@{FG text} NewScreen *@{i}ns@{ui};
  ULONG @{i}tag1@{ui};
  {
      @{FG shine}struct@{FG text} Screen *OpenScreenTagList();
      @{FG shine}return@{FG text} ( OpenScreenTagList( @{i}ns@{ui}, (@{FG shine}struct@{FG text} TagItem *) @{i}&tag1@{ui} ) );
  }
NOTES
  We recommend this extension to @{"OpenScreen()" Link "OpenScreen()"} over using the field ExtNewScreen.
  Extension.However, the ExtNewScreen.Extension is a convenient way to supply a
  few tags to V36 Intuition which will be ignored by V34 Intuition.
  See @{"OpenScreen()" Link "OpenScreen()"} documentation for lots of details.
  @{b}A VERY IMPORTANT NOTE@{ub} about the Screen->@{i}BitMap@{ui}:In the future,
  bitmaps will need to grow.The embedded instance of a bitmap
  in the screen will no longer be large enough to hold the whole
  description of the bitmap.
  @{b}YOU ARE STRONGLY URGED@{ub} to use Screen->RastPort.@{i}BitMap@{ui} in place of
  &Screen->@{i}BitMap@{ui} whenever and whereever possible.
SEE ALSO
  @{"OpenScreen()" Link "OpenScreen()"}
@EndNode
@node NEWWINDOW_INIT_DATA "NewWindow_init_data"
@{b}@{u}NewWindow structure is initialized with the following data@{uu}@{ub}:
  @{i}Left@{ui} = the initial x-position for your window
  @{i}Top@{ui} = the initial y-position for your window
  @{i}Width@{ui} = the initial width of this window
  @{i}Height@{ui} = the initial height of this window
  @{i}DetailPen@{ui} = pen number (or -1) for the rendering of window details
    (like gadgets or text in title bar)
  @{i}BlockPen@{ui} = pen number (or -1) for window block fills (like title bar)
  [@{i}For V36:@{ui} Title bar colors are determined otherwise.]
  @{i}Gadgets@{ui} = the pointer to the first of a linked list of the your own
    Gadgets which you want attached to this Window.
    Can be NULL if you have no Gadgets of your own.
  @{i}CheckMark@{ui} = a pointer to an instance of the @{FG shine}struct@{FG text} Image where can be found
    the imagery you want used when any of your menu items is to be checkmarked.
    If you don't want to supply your own imagery and you want to just use
    Intuition's own checkmark, set this argument to NULL.
  @{i}Text@{ui} = a null-terminated line of text to appear on the title bar of
    your window (may be null if you want no text).
  @{i}Type@{ui} = the screen type for this window.If this equal CUSTOMSCREEN,
    you must have already opened a CUSTOMSCREEN (see text above).
    @{i}Types available include@{ui}:
      - @{b}WBENCHSCREEN@{ub}
      - @{b}CUSTOMSCREEN@{ub}
      - @{b}PUBLICSCREEN@{ub} (@{i}new for V36@{ui}, see text below)
  @{i}Screen@{ui} = if your type is one of Intuition's standard screens, then
   this argument is ignored.However, if Type == CUSTOMSCREEN,
   this must point to the structure of your own screen.
  @{i}BitMap@{ui} = if you have specified @{i}WFLG_SUPER_BITMAP@{ui} as the type of
    refreshing you want for this window, then this value points to a
    instance of the @{FG shine}struct@{FG text} bitmap.However, if the refresh type
    is @{b}NOT@{ub} @{i}WFLG_SUPER_BITMAP@{ui}, this pointer is ignored.
  @{i}MinWidth@{ui}, @{i}MinHeight@{ui}, @{i}MaxWidth@{ui}, @{i}MaxHeight@{ui} = the size limits for this
    window.These must be reasonable values, which is to say that
    the minimums cannot be greater than the current size, nor can
    the maximums be smaller than the current size.If they are,
    they're ignored.Any one of these can be initialized to zero,
    which means that that limit will be set to the current
    dimension of that axis.The limits can be changed after the
    Window is opened by calling the @{"WindowLimits()" Link "WindowLimits()"} routine.
    @{i}NOTE@{ui}:@{b}ORIGINALLY@{ub}, we stated that:
    "@{i}If you haven't requested the WFLG_SIZEGADGET option, these
    variables are ignored so you don't have to initialize them.@{ui}"
  @{"Flags" link NEWWINDOW_INIT_DATA_FLAGS}
  @{"IDCMPFlags" link NEWWINDOW_INIT_DATA_IDCMPFLAGS}
  @{i}Extension@{ui} (@{i}New for V36@{ui}) = a pointer to an array (or chain of arrays)
    of TagItems to specify additional parameters to OpenWindow().
    TagItems in general are described in @{"utility/tagitem.h" Link "include:utility/tagitem.h/Main" 0},
    and the OpenWindow tags are defined in @{"intuition/intuition.h" Link "include:intuition/intuition.h/Main" 0}
    and described here.@{b}@{u}For items pertaining to Public Screens@{uu}@{ub}
    @{b}@{u}and visitor windows, please see below@{uu}@{ub}:
      @{"NewWindow tags" link NEWWINDOW_INIT_DATA_NEWWINDOW_TAGS}
      @{"ExtNewWindow tags" link NEWWINDOW_INIT_DATA_EXTNEWWINDOW_TAGS}
@endnode
@node NEWWINDOW_INIT_DATA_FLAGS "NewWindow_init_data_flags"
@{b}@{u}Flags = specifiers for your requirements of this window, including@{uu}@{ub}:
  @{i}which system gadgets you want attached to your window@{ui}:
    @{b}WFLG_DRAGBAR@{ub} allows this window to be dragged
    @{b}WFLG_DEPTHGADGET@{ub} lets the user depth-arrange this window
    @{b}WFLG_CLOSEGADGET@{ub} attaches the standard close gadget
    @{b}WFLG_SIZEGADGET@{ub} allows this window to be sized.
      If you ask for the @{i}WFLG_SIZEGADGET@{ui} gadget, you must specify one or
      both of the flags @{i}WFLG_SIZEBRIGHT@{ui} and @{i}WFLG_SIZEBBOTTOM@{ui} below; if
      you don't, the default is @{i}WFLG_SIZEBRIGHT@{ui}.See the following items
      @{i}WFLG_SIZEBRIGHT@{ui} and @{i}WFLG_SIZEBBOTTOM@{ui} for more details.
    @{b}WFLG_SIZEBRIGHT@{ub} is a special system gadget flag that
      you set to specify whether or not you want the
      @{b}RIGHT@{ub} border adjusted to account for the physical size
      of the sizing gadget.The sizing gadget must, after
      all, take up room in either the right or bottom border
      (or both, if you like) of the window.Setting either
      this or the @{i}WFLG_SIZEBBOTTOM@{ui} flag selects which edge
      will take up the slack.This will be particularly
      useful to applications that want to use the extra space
      for other gadgets (like a proportional gadget and two
      Booleans done up to look like scroll bars) or, for
      for instance, applications that want every possible
      horizontal bit and are willing to lose lines vertically.
      @{i}NOTE@{ui}:if you select @{i}WFLG_SIZEGADGET@{ui}, you must select
      either @{i}WFLG_SIZEBRIGHT@{ui} or @{i}WFLG_SIZEBBOTTOM@{ui} or both.If
      you select neither, the default is @{i}WFLG_SIZEBRIGHT@{ui}.
    @{b}WFLG_SIZEBBOTTOM@{ub} is a special system gadget flag that
      you set to specify whether or not you want the
      @{b}BOTTOM@{ub} border adjusted to account for the physical size
      of the sizing gadget.For details, refer to
      @{i}WFLG_SIZEBRIGHT@{ui} above.
    @{b}WFLG_GIMMEZEROZERO@{ub} for easy but expensive output
  @{i}what type of window layer you want, either@{ui}:
    @{b}WFLG_SIMPLE_REFRESH@{ub}
    @{b}WFLG_SMART_REFRESH@{ub}
    @{b}WFLG_SUPER_BITMAP@{ub}
    @{b}WFLG_BACKDROP@{ub} for whether or not you want this window to be one
      of Intuition's special backdrop windows.See @{i}WFLG_BORDERLESS@{ui} as well.
    @{b}WFLG_REPORTMOUSE@{ub} for whether or not you want to "listen" to
      mouse movement events whenever your window is the active
      one.After you've opened your window, if you want to change
      you can later change the status of this via a call to
      @{"ReportMouse()" Link "ReportMouse()"}.Whether or not your window is listening to
      mouse is affected by gadgets too, since they can cause you
      to start getting reports too if you like.The mouse move
      reports (either InputEvents or messages on the IDCMP) that
      you get will have the x/y coordinates of the current mouse
      position, relative to the upper-left corner of your window
      (@{i}WFLG_GIMMEZEROZERO@{ui} notwithstanding).This flag can work in
      conjunction with the IDCMP Flag called @{i}IDCMP_MOUSEMOVE@{ui}, which
      allows you to listen via the IDCMP.
    @{b}WFLG_BORDERLESS@{ub} should be set if you want a window with no
      border padding.Your window may have the border variables
      set anyway, depending on what gadgetry you've requested for
      the window, but you won't get the standard border lines and
      spacing that comes with typical windows.
      This is a good way to take over the entire screen, since you
      can have a window cover the entire width of the screen using
      this flag.This will work particularly well in conjunction
      with the @{i}WFLG_BACKDROP@{ui} flag (see above), since it allows you
      to open a window that fills the @{b}ENTIRE@{ub} screen.
      @{i}NOTE@{ui}:this is not a flag that you want to set casually, since it
      may cause visual confusion on the screen.The window borders are
      the only dependable visual division between various windows and
      the background screen.Taking away that border takes away
      that visual cue, so make sure that your design doesn't need
      it at all before you proceed.
    @{b}WFLG_ACTIVATE@{ub} is the flag you set if you want this window to
      automatically become the active window.The active
      window is the one that receives input from the keyboard and
      mouse.It's usually a good idea to to have the window you
      open when your application first starts up be an @{b}ACTIVATED@{ub}
      one, but all others opened later not be @{b}ACTIVATED@{ub} (if the
      user is off doing something with another screen, for instance,
      your new window will change where the input is going, which
      would have the effect of yanking the input rug from under
      the user).Please use this flag thoughtfully and carefully.
      @{i}Some notes:@{ui}First, your window may or may not be active
      by the time this function returns.Use the @{i}IDCMP_ACTIVEWINDOW@{ui}
      IDCMP message to know when your window has become active.
      Also, be very careful not to mistakenly specify the obsolete flag
      names @{i}WINDOWACTIVE@{ui} or @{i}ACTIVEWINDOW@{ui}.These are used in other contexts,
      and their values unintentionally added to your flags can cause
      most unfortunate results.To avoid confusion, they are now
      know as @{i}WFLG_WINDOWACTIVE@{ui} and @{i}IDCMP_ACTIVEWINDOW@{ui}.
    @{b}WFLG_RMBTRAP@{ub}, when set, causes the right mouse button events
      to be trapped and broadcast as events.You can receive
      these events through either the IDCMP or the console.
    @{b}WFLG_NOCAREREFRESH@{ub} indicates that you do not wish to
      be responsible for calling @{"BeginRefresh()" Link "BeginRefresh()"} and @{"EndRefresh()" Link "EndRefresh()"}
      when your window has exposed regions (i.e., when the
      @{i}IDCMP_REFRESHWINDOW@{ui} message would be generated).See also
      the descriptions of these two functions.
    @{b}WFLG_NW_EXTENDED@{ub} (V36) indicates that NewWindow in fact points to an
      @{"ExtNewWindow" Link "include:intuition/intuition.h/Main" 1151} structure, and that the 'Extension' field points to an
      array of TagItem structures, with meaning described below.
    @{b}WFLG_NEWLOOKMENUS@{ub} (V39) Requests new-look menu treatment.
      @{"Menu" Link "include:intuition/intuition.h/Main" 61} colors are derived from the screen @{"DrawInfo" Link "include:intuition/screens.h/Main" 60} @{i}BARDETAILPEN@{ui},
      @{i}BARBLOCKPEN@{ui}, and @{i}BARTRIMPEN@{ui}, instead of window detail and
      block pens.Also requests that a suitably scaled and colored
      Amiga-key symbol and checkmark symbol be used in the menus.
      Applications using @{i}WFLG_NEWLOOKMENUS@{ui} need to use the new screen
      @{"DrawInfo" Link "include:intuition/screens.h/Main" 60} pens to color their @{"MenuItem" Link "include:intuition/intuition.h/Main" 89} and SubItem imagery.
      If your application uses GadTools, the {@{i}GTMN_NewLookMenus@{ui},TRUE}
      tag-item should be passed to the menu layout calls.
      (@{b}NB@{ub}: For the menus to actually appear with improved colors,
      the screen's opener must supply suitable values for the
      new menu pens in the DrawInfo.If this is not the case, then an
      application requesting NewLookMenus will get the scaled Amiga-key
      and checkmark but in V37-compatible colors.Note that the screen's
      DrawInfo will always contain valid values for the new pens;
      they just may correspond to the "old look").
  It is now clear that a variety of programs take it upon
  themselves to call @{"SizeWindow()" Link "SizeWindow()"} (or @{"ChangeWindowBox()" Link "ChangeWindowBox()"}) without
  your program's consent or consulting your @{i}WFLG_SIZEGADGET@{ui}
  option.To protect yourself against the results, we strongly
  urge that you supply suitable values for these fields even
  if you do not specify @{i}WFLG_SIZEGADGET@{ui}.
  The maximums may be @{b}LARGER@{ub} than the current size, or even
  larger than the current screen.The maximums should be set to
  the highest value your application can handle.This allows
  users with larger display devices to take full advantage of
  your software.If there is no good reason to limit the size,
  then don't.-1 or ~0 indicates that the maximum size is only
  limited by the size of the window's screen.
  See also the docs on the function @{"WindowLimits()" Link "WindowLimits()"} for more information.
@endnode
@node NEWWINDOW_INIT_DATA_IDCMPFLAGS "NewWindow_init_data_IDCMPflags"
@{b}@{u}IDCMPFlags@{uu}@{ub} = IDCMP is the acronym for Intuition Direct Communications
  @{"Message" Link "include:exec/ports.h/Main" 48} Port.(It's Intuition's sole acronym.) If any of the IDCMP Flags is
  selected, Intuition will create a pair of message ports and use them for
  direct communications with the task opening this window (as compared with
  broadcasting information via the Console device).See the "Input and Output
  Methods" chapter of the Intuition Reference Manual for complete details.
  You request an IDCMP by setting any of these flags.Except for the special
  @{i}VERIFY@{ui} flags, every other flag you set tells Intuition that if a given
  event occurs which your program wants to know about, it is to broadcast the
  details of that event through the IDCMP rather than via the Console device.
  This allows a program to interface with Intuition directly, rather than
  going through the Console device.
  Many programs have elected to use IDCMP communication exclusively, and not
  to associate a console with their windows at all.Some operations, such as
  @{i}IDCMP_MENUVERIFY@{ui}, can @{b}ONLY@{ub} be achieved using IDCMP.The IDCMP flags you can
  set are described in the @{"ModifyIDCMP()" Link "ModifyIDCMP()"} autodoc.
@endnode
@node NEWWINDOW_INIT_DATA_NEWWINDOW_TAGS "NewWindow_init_data_NewWindow_tags"
Here are the TagItem.ti_Tag values that are defined for OpenWindow
(and @{"OpenWindowTagList()" Link "OpenWindowTagList()"}).
Certain tags simply override equivalent values in NewWindow, and allow you to
open a window using @{"OpenWindowTagList()" Link "OpenWindowTagList()"} without having a NewWindow structure at
all.In each case, cast the corresponding data to ULONG and put it in ti_Data.
@{b}@{u}The compatible tag items include@{uu}@{ub}:
  @{b}WA_Left@{ub}
  @{b}WA_Top@{ub}
  @{b}WA_Width@{ub}
  @{b}WA_Height@{ub}
  @{b}WA_DetailPen@{ub}  - @{i}NOTE@{ui}: only overrides NewWindow.DetailPen of -1!
  @{b}WA_BlockPen@{ub} - @{i}NOTE@{ui}: only overrides NewWindow.BlockPen of -1!
  @{b}WA_IDCMP@{ub}
  @{b}WA_Flags@{ub}  - initial values for Flags before looking at other
    Boolean component Tag values
  @{b}WA_Gadgets@{ub}
  @{b}WA_Title@{ub}
  @{b}WA_CustomScreen@{ub} - also implies @{i}CUSTOMSCREEN@{ui} property
  @{b}WA_SuperBitMap@{ub}  - also implies @{i}WFLG_SUPER_BITMAP@{ui} refresh mode.
  @{b}WA_MinWidth@{ub}
  @{b}WA_MinHeight@{ub}
  @{b}WA_MaxWidth@{ub}
  @{b}WA_MaxHeight@{ub}
@{b}@{u}These Boolean tag items are alternatives to the NewWindow.@{i}Flags@{ui}
Boolean attributes with similar names@{uu}@{ub}:
  @{b}WA_SizeGadget@{ub}   - equivalent to @{i}WFLG_SIZEGADGET@{ui}
  @{b}WA_DragBar@{ub}    - equivalent to @{i}WFLG_DRAGBAR@{ui}
  @{b}WA_DepthGadget@{ub}    - equivalent to @{i}WFLG_DEPTHGADGET@{ui}
  @{b}WA_CloseGadget@{ub}    - equivalent to @{i}WFLG_CLOSEGADGET@{ui}
  @{b}WA_Backdrop@{ub}   - equivalent to @{i}WFLG_BACKDROP@{ui}
  @{b}WA_ReportMouse@{ub}    - equivalent to @{i}WFLG_REPORTMOUSE@{ui}
  @{b}WA_NoCareRefresh@{ub}  - equivalent to @{i}WFLG_NOCAREREFRESH@{ui}
  @{b}WA_Borderless@{ub}   - equivalent to @{i}WFLG_BORDERLESS@{ui}
  @{b}WA_Activate@{ub}   - equivalent to @{i}WFLG_ACTIVATE@{ui}
  @{b}WA_RMBTrap@{ub}    - equivalent to @{i}WFLG_RMBTRAP@{ui}
  @{b}WA_WBenchWindow@{ub}   - equivalent to @{i}WFLG_WBENCHWINDOW@{ui} (system PRIVATE)
  @{b}WA_SimpleRefresh@{ub}  - only specify if TRUE
  @{b}WA_SmartRefresh@{ub}   - only specify if TRUE
  @{b}WA_SizeBRight@{ub}   - equivalent to @{i}WFLG_SIZEBRIGHT@{ui}
  @{b}WA_SizeBBottom@{ub}    - equivalent to @{i}WFLG_SIZEBBOTTOM@{ui}
  @{b}WA_GimmeZeroZero@{ub}  - equivalent to @{i}WFLG_GIMMEZEROZERO@{ui}
  @{b}WA_NewLookMenus@{ub}   - equivalent to @{i}WFLG_NEWLOOKMENUS@{ui}
@endnode
@node NEWWINDOW_INIT_DATA_EXTNEWWINDOW_TAGS "NewWindow_init_data_ExtNewWindow_tags"
@{b}@{u}The following tag items specify new attributes of a window@{uu}@{ub}:
  @{b}WA_ScreenTitle@{ub} - You can specify the screen title associated
    with your window this way, and avoid a call to @{"SetWindowTitles()" Link "SetWindowTitles()"}
    when your window opens.
  @{b}WA_AutoAdjust@{ub} - a Boolean attribute which says that it's OK to move or
    even shrink the dimensions of this window to fit it on the screen,
    within the dimension limits specified by @{i}MinWidth@{ui} and @{i}MinHeight@{ui}.
    Someday, this processing might be sensitive to the currently visible
    portion of the screen the window will be opening on, so don't draw
    too many conclusions about the auto-adjust algorithms.
    (Normally, this attribute defaults to FALSE.However, if you call
    OpenWindowTags() or @{"OpenWindowTagList()" Link "OpenWindowTagList()"} with a NULL @{"NewWindow" Link "include:intuition/intuition.h/Main" 1081} pointer,
    this attribute defaults to TRUE).
  @{b}WA_InnerWidth@{ub}
  @{b}WA_InnerHeight@{ub} - You can specify the dimensions of the interior
    region of your window, independent of what the border thicknesses will be.
    You probably want to specify @{i}WA_AutoAdjust@{ui} to allow Intuition to move your
    window or even shrink it so that it is completely on screen.
    @{i}Note@{ui}: using these tags puts some reasonable restrictions on the
    gadgets you can specify as "border" gadgets when you open your window.
    Since border gadgets determine the border dimensions and hence the overall
    dimensions of your window, those dimensions cannot be used calculating
    the position or dimensions of border gadgets.
    @{i}Here's the complete list of restrictions@{ui}:
    - @{i}GACT_LEFTBORDER@{ui} gadgets cannot be @{i}GFLG_RELWIDTH@{ui} if @{i}WA_InnerWidth@{ui} is used.
    - @{i}GACT_RIGHTBORDER@{ui} gadgets @{b}MUST@{ub} be @{i}GFLG_RELRIGHT@{ui} if @{i}WA_InnerWidth@{ui} is used.
    - @{i}GACT_TOPBORDER@{ui} gadgets cannot be @{i}GFLG_RELHEIGHT@{ui} if @{i}WA_InnerHeight@{ui} is used.
    - @{i}GACT_BOTTOMBORDER@{ui} gadgets @{b}MUST@{ub} be @{i}GFLG_RELBOTTOM@{ui} if @{i}WA_InnerHeight@{ui} is used.
  @{b}WA_PubScreenName@{ub} - This tag item declares that you want your window
    to open as a visitor window on the public screen whose name
    is pointed to by (UBYTE *) ti_Data.
  @{b}WA_PubScreen@{ub} - Open as a visitor window on the public screen
    whose address if provided as (@{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} *) ti_Data.
    @{i}To ensure that this screen remains open long enough, you  must either@{ui}:
    1) Be the screen's owner
    2) have another window already open on the screen
    3) use @{"LockPubScreen()" Link "LockPubScreen()"}
      Using @{"exec.library/Forbid()" Link "exec.guide/Forbid()"} is not sufficient.
    You can provide ti_Data to be NULL (zero), without any
    of the above precautions, to specify the default public screen.
  @{b}WA_PubScreenFallBack@{ub} - This Boolean attribute specifies that a
    visitor window should "fall back" to opening on the default
    public screen if the explicitly specify public screen is not available.
  @{b}WA_WindowName@{ub} - this visionary specification of a window
    rendezvous name string is not yet implemented.
  @{b}WA_Colors@{ub} - this equally great idea about associating a palette
    specification with the active window may not ever be implemented.
  @{b}WA_Zoom@{ub} - ti_Data points to an array of four WORD's to be used as the
    initial Left/Top/Width/Height of the "alternate Zoom position and
    dimensions." The presence of this tag item implies that you want
    a Zoom gadget, even though you  might not have a sizing gadget.
    @{i}New for V39@{ui}: if the initial zoom-box left and top are both set to ~0,
    then Intuition will give your window "size-only" zooming, meaning that
    zooming the window will not affect the left/top unless the window needs
    to be moved on-screen.
  @{b}WA_MouseQueue@{ub} - This tag specifies a limit for the number
    of outstanding @{i}IDCMP_MOUSEMOVE@{ui} IntuiMessages that Intuition
    will send to your window.You can change the value of this
    limit after the window is open using @{"SetMouseQueue()" Link "SetMouseQueue()"}.
  @{b}WA_RptQueue@{ub} - This tag specifies a limit for the number of
    outstanding repeated-@{i}IDCMP_RAWKEY@{ui}, repeated-@{i}IDCMP_VANILLAKEY@{ui},
    and repeated-@{i}IDCMP_IDCMPUPDATE@{ui} IntuiMessages that Intuition will send to
    your window.Currently, there is no function to adjust the repeat-key queue.
  @{b}WA_BackFill@{ub} - ti_Data is a pointer to a @{"Hook" Link "include:utility/hooks.h/Main" 23} structure that
    the Layers library will call when your window needs "backfilling."
    See @{"layers.library/InstallLayerHook()" Link "ROMlibs.guide/InstallLayerHook()"}.
  @{b}WA_MenuHelp@{ub} - ti_Data is a boolean.If true, enables the MenuHelp
    feature for this window.See @{i}IDCMP_MENUHELP@{ui} above.(V37)
  @{b}WA_NotifyDepth@{ub} - ti_Data is a boolean.
    Set to true if you would also like @{i}IDCMP_CHANGEWINDOW@{ui} events sent to
    your window when it is depth-arranged.Normally, such events are only
    sent for movement or resizing of the window.
    @{i}IDCMP_CHANGEWINDOW@{ui} events originating from depth-arrangement have a Code
    equal to @{i}CWCODE_DEPTH@{ui}, as opposed to @{i}CWCODE_MOVESIZE@{ui}.(V39)
  @{b}WA_Checkmark@{ub} - (ti_Data is @{FG shine}struct@{FG text} @{"Image" Link "include:intuition/intuition.h/Main" 700} *) Image to use as a
    checkmark in menus.Prior to V39, or if @{i}WA_NewLookMenus@{ui} is not specified,
    the default will be the traditional checkmark in the original colors.
    Under V39 and higher, if you have requested @{i}WA_NewLookMenus@{ui} then the default
    will be an appropriately colored checkmark scaled to the screen's font.
    Alternately, you can provide a custom one, which you can
    design yourself or get from sysiclass (use this if your
    menu-font is different from the screen's font).
  @{b}WA_AmigaKey@{ub} - (ti_Data is @{FG shine}struct@{FG text} Image *) Image to use as
    the Amiga-key symbol in menus.If @{i}WA_NewLookMenus@{ui} is not specified, the
    default will be the traditional Amiga-key symbol in the original colors.
    If you've requested @{i}WA_NewLookMenus@{ui}, then the default will be an
    appropriately colored Amiga-key scaled to the screen's font.
    Alternately, you can provide a custom one, which you can
    design yourself or get from sysiclass (use this if your
    menu-font is different from the screen's font).(V39)
  @{b}WA_Pointer@{ub} - (APTR) The pointer you wish to associate with
    your window.If NULL, you are requesting the Preferences
    default pointer.@{"Custom" Link "include:hardware/custom.h/Main" 25} pointers should be allocated by
    performing a @{"NewObject()" Link "NewObject()"} on "pointerclass".(See
    <intuition/pointerclass.h>).Defaults to NULL.This tag is
    also recognized by @{"SetWindowPointerA()" Link "SetWindowPointerA()"}.(V39)
  @{b}WA_BusyPointer@{ub} (BOOL) - Set to TRUE to request the Preferences
    busy-pointer.If FALSE, your pointer will be as requested
    by @{i}WA_Pointer@{ui}.Defaults to FALSE.This tag is also
    recognized by @{"SetWindowPointerA()" Link "SetWindowPointerA()"}.(V39)
  @{b}WA_PointerDelay@{ub} - (BOOL) Set to TRUE to defer changing your
    pointer for a brief instant.This is typically used along
    with setting the busy pointer, especially when the
    application knows it may be busy for a very short while.If
    the application clears the pointer or sets another pointer
    before the delay expires, the pending pointer change is
    cancelled.This reduces short flashes of the busy pointer.
    This tag is also recognized by @{"SetWindowPointerA()" Link "SetWindowPointerA()"}.(V39)
  @{b}WA_HelpGroup@{ub} - (ULONG) Normally, only the active window can
    receive @{i}IDCMP_GADGETHELP@{ui} messages.However, an application
    with multiple windows will want all its windows to be able
    to receive help when any of them are active.First obtain a
    unique help ID with utility.library/GetUniqueID(), then
    pass it as ti_Data of this tag to all your windows.
    See @{"HelpControl()" Link "HelpControl()"}.(V39)
  @{b}WA_HelpGroupWindow@{ub} - (@{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *) Instead of using
    WA_HelpGroup, you can pass a pointer to another window
    whose HelpGroup you wish this window to belong to.(V39)
  @{b}WA_TabletMessages@{ub} - (BOOL) Set to TRUE to request extended IntuiMessages
    for your window.If a tablet driver is generating @{i}IESUBCLASS_NEWTABLET@{ui}
    input events, you will be able to receive extended tablet information
    with most IntuiMessages.See the @{i}eim_TabletData@{ui} field of the
    ExtIntuiMessage structure.Defaults to FALSE.(V39)
@endnode
@Node "OpenWindow()" "intuition.library/OpenWindow"
@{b}@{u}OpenWindow@{uu}@{ub} -- Open an Intuition window.
  Opens an Intuition window of the given dimensions and position,
  with the properties specified in the NewWindow structure.
  Allocates everything you need to get going.
  @{i}New for V36@{ui}: there is an extensive discussion of public Screens and visitor
  windows at the end of this section.Also, you can provide extensions to the
  NewWindow parameters using and array of TagItem structures.See the discussion
  below, and the documentation for the function @{"OpenScreenTagList()" Link "OpenScreenTagList()"}.
  Before you call OpenWindow(), you must initialize an instance of a NewWindow
  structure.@{i}NewWindow@{ui} is a structure that contains all of the arguments needed
  to open a window.The NewWindow structure may be discarded immediately after it
  is used to open the window.
  If @{i}Type@{ui} == CUSTOMSCREEN, you must have opened your own screen already via
  a call to @{"OpenScreen()" Link "OpenScreen()"}.Then Intuition uses your screen argument for the
  pertinent information needed to get your window going.On the other hand,
  if @{i}type@{ui} == one of the Intuition's standard screens, your screen argument is
  ignored.Instead, Intuition will check to see whether or not that screen
  already exists: if it doesn't, it will be opened first before Intuition
  opens your window in the standard screen.
  @{i}New for V36:@{ui} If you specify @{i}Type@{ui} == WBENCHSCREEN, then your window
  will appear on the Workbench screen, unless the global public screen mode
  SHANGHAI is set, in which case your window will be "hijacked" to the default
  public screen.See also @{"SetPubScreenModes()" Link "SetPubScreenModes()"}.
  @{i}New for V36@{ui}: If the @{i}WFLG_NW_EXTENDED@{ui} flag is set, it means that the field
  'ExtNewWindow->@{i}Extension@{ui}' points to an array of TagItems, as defined in
  intuition/tagitem.h.This provides an extensible means of providing extra
  parameters to OpenWindow.For compatibility reasons, we could not add the
  'Extension' field to the NewWindow structure, so we have define a new structure
  @{"ExtNewWindow" Link "include:intuition/intuition.h/Main" 1151}, which is identical to NewWindow with the addition of the
  Extension field.
  We recommend that rather than using ExtNewWindow.@{i}Extension@{ui}, you use the
  new Intuition function @{"OpenWindowTagList()" Link "OpenWindowTagList()"} and its varargs equivalent
  OpenWindowTags().We document the window attribute tag ID's (ti_Tag values)
  here, rather than in @{"OpenWindowTagList()" Link "OpenWindowTagList()"}, so that you can find all the
  parameters for a new window defined in one place.
  If the @{i}WFLG_SUPER_BITMAP@{ui} flag is set, the bitmap variable must point
  to your own bitmap.
  The @{i}DetailPen@{ui} and the @{i}BlockPen@{ui} are used for system rendering; for
  instance, the title bar is first filled using the @{i}BlockPen@{ui}, and then
  the gadgets and text are rendered using @{i}DetailPen@{ui}.You can either
  choose to supply special pens for your window, or, by setting either
  of these arguments to -1, the screen's pens will be used instead.
  @{i}Note for V36:@{ui} The @{i}DetailPen@{ui} and @{i}BlockPen@{ui} no longer determine
  what colors will be used for window borders, if your window
  opens on a "full-blown new look screen."
SYNOPSIS  @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *OpenWindow( @{FG shine}struct@{FG text} @{"NewWindow" Link "include:intuition/intuition.h/Main" 1081} * );
  @{i}@{b}Window@{ub}@{ui} = OpenWindow( @{i}NewWindow@{ui} )
   D0                   A0
  @{i}NewWindow@{ui} = pointer to an instance of a NewWindow structure.
  If all is well, returns the pointer to your new Window
  If anything goes wrong, returns NULL
  @{"NewWindow structure is initialized with the following data" link NEWWINDOW_INIT_DATA}
NOTES
  Regarding Public Screens, you can specify a window to be a 
  "visitor window" on a public screen in one of several ways.
  In each case, you must be sure not to specify a NewWindow
  type of CUSTOMSCREEN.You should use the value PUBLICSCREEN.
  @{b}@{u}There are actually several ways you can specify which screen@{uu}@{ub}
  @{b}@{u}you want a visitor window to be opened on@{uu}@{ub}:
  1) Specify the name of the public screen @{i}WA_PubScreenName@{ui}, or a NULL pointer,
    in ti_Data.The name might have been provided by the user.
    A NULL pointer means to use the default public screen.
    If the named screen cannot be found, the default public screen
    will be used if the Boolean attribute @{i}WA_PubScreenFallBack@{ui} is TRUE.
  2) Specify a pointer to a public screen using the @{i}WA_PubScreen@{ui} tag item.
    The @{i}WA_PubScreenFallBack@{ui} attribute has no effect.You can specify the
    default public screen by providing a NULL pointer.You can also specify
    the pointer by setting NewWindow.@{i}Type@{ui} to PUBLICSCREEN, and specifying
    the public screen pointer in NewWindow.@{i}Screen@{ui}. The @{i}WA_PubScreen@{ui} tag item
    has precedent over this technique.
    Unless NULL, the screen pointer provided @{b}MUST@{ub} be a valid
    public screen.You may ensure this several ways:
    - Be the owner of the screen.
    - Have a window already open on the screen.
    - Use @{"LockPubScreen()" Link "LockPubScreen()"} to prevent the screen from closing.
    - specifying the @{i}WFLG_VISITOR@{ui} bit in NewWindow.@{i}Flags@{ui} is not supported.
    It is anticipated that the last will be the most common method
    of opening public screens because you often want to examine
    properties of the screen your window will be using in order
    to compensate for differences in dimension, depth, and font.
    @{i}The standard sequence for this method is as follows@{ui}:
    - @{"LockPubScreen()" Link "LockPubScreen()"} - obtain a pointer and a promise
    - layout window - adapt your window to the screen you will use
    - OpenWindow() - using the pointer you specify
    - @{"UnlockPubScreen()" Link "UnlockPubScreen()"} - once your window is open, you can let go
      of the lock on the public screen
      ...normal window events processing ...
    - @{"CloseWindow()" Link "CloseWindow()"}.
  Regarding "service" windows, such as those opened for a system
  requester or file requester associated with a given "client"window.
  These windows should @{b}NOT@{ub} be "visitor" windows.Open them
  using NewWindow.@{i}Type@{ui} = CUSTOMSCREEN and NewWindow.@{i}Screen@{ui}
  equal to the screen of the client window (window->@{i}WScreen@{ui}).
  You can also use @{i}WA_CustomScreen@{ui}, which has precedence.
  This ensures that the requester service window will be allowed to
  open on the same screen as the client window, even if that
  screen is not a public screen, or has private status.
  This has an implication for service/client protocol: when you
  pass a window pointer to any system requester routine or
  to a routine which creates some other other service window,
  you @{b}MUST@{ub} keep your window open until the client window is closed.
  If a requester service will allow a NULL client window, this
  should indicate to open the service window on the default public
  screen (probably Workbench).The correct way to get a pointer
  to this screen is to call LockPubScreen( NULL ).In this
  case, you want to open as a visitor window, which means you
  should use either PUBLICSCREEN or @{i}WA_PubScreen@{ui}, described above.
  You should call @{"UnlockPubScreen()" Link "UnlockPubScreen()"} after your visitor window is open.
  @{i}As of V36@{ui}, gadgets in the right and bottom border
  (specified with @{i}GACT_RIGHTBORDER@{ui} and @{i}GACT_BOTTOMBORDER@{ui}) only
  contribute to the dimensions of the borders if they are also
  @{i}GFLG_RELRIGHT@{ui} and @{i}GFLG_RELBOTTOM@{ui}, respectively.
BUGS
  When you open a window, Intuition will set the font of
  the window's RastPort to the font of the window's screen.
  This does not work right for GimmeZeroZero windows: the
  BorderRPort RastPort has the font set correctly, but
  Window.@{i}RPort@{ui} is set up with the system default font.
  For compatibility reasons, we won't be fixing this problem.
  Also, there is a compatibility trick going on with the
  default font of your window's RastPort if the screen's
  font is "fancy." See the @{i}SA_SysFont@{ui} attribute described
  under @{"OpenScreen()" Link "OpenScreen()"}.
  Unless you arrange otherwise, each window you open will allocate
  a signal for your task from the 16 "user signals."
  If no signal is available, your window will not be able
  to be opened.In early V36 versions and before, Intuition didn't
  check this condition, but just left you with an unusable port.
SEE ALSO
  @{"OpenWindowTagList()" Link "OpenWindowTagList()"}, @{"OpenScreen()" Link "OpenScreen()"}, @{"ModifyIDCMP()" Link "ModifyIDCMP()"}, @{"SetWindowTitles()" Link "SetWindowTitles()"},
  @{"LockPubScreen()" Link "LockPubScreen()"}, @{"SetDefaultPubScreen()" Link "SetDefaultPubScreen()"}, @{"ZipWindow()" Link "ZipWindow()"},
  @{"layers.library/InstallLayerHook()" Link "ROMlibs.guide/InstallLayerHook()"}, @{"SetPubScreenModes()" Link "SetPubScreenModes()"}
@EndNode
@Node "OpenWindowTagList()" "intuition.library/OpenWindowTagList"
@{b}@{u}OpenWindowTagList@{uu}@{ub} -- @{"OpenWindow()" Link "OpenWindow()"} with TagItem extension.(V36)
@{b}@{u}OpenWindowTags@{uu}@{ub}    -- Varargs stub for OpenWindowTagList.(V36)
  A variation of @{"OpenWindow()" Link "OpenWindow()"} that allow direct specification of
  a TagItem array of extension data.Recommended over using the
  ExtNewWindow.@{i}Extension@{ui} field.
  If you omit the NewWindow (pass NULL), a set of defaults are used,
  and overridden by the tag items.Even without any tag items at all,
  a reasonable window opens on the Workbench or default public screen.
  See @{"OpenWindow()" Link "OpenWindow()"} for all the details.
SYNOPSIS
  @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *OpenWindowTagList( @{FG shine}struct@{FG text} @{"NewWindow" Link "include:intuition/intuition.h/Main" 1081} *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} * );
  @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *OpenWindowTags   ( @{FG shine}struct@{FG text} @{"NewWindow" Link "include:intuition/intuition.h/Main" 1081} *, ULONG, ...);
  @{i}@{b}Window@{ub}@{ui} = OpenWindowTagList( @{i}NewWindow@{ui}, @{i}TagItems@{ui} )
   D0                          A0          A1
  @{i}@{b}Window@{ub}@{ui} = OpenWindowTags   ( @{i}NewWindow@{ui}, @{i}Tag1@{ui}, ...)
  @{i}NewWindow@{ui} - (optional) pointer to a NewWindow structure.
  @{i}TagItems@{ui} - (optional) pointer to TagItem array, with tag
    values as described under the description for @{"OpenWindow()" Link "OpenWindow()"}.
  @{i}@{b}Window@{ub}@{ui} - newly created window, per your specifications.
EXAMPLE
  See @{"OpenScreenTagList()" Link "OpenScreenTagList()"} for an example of how to create
  a "varargs" version of this function for convenient C language programming.
SEE ALSO
  @{"OpenWindow()" Link "OpenWindow()"}
@EndNode
@Node "OpenWorkBench()" "intuition.library/OpenWorkBench"
@{b}@{u}OpenWorkBench@{uu}@{ub} -- Open the Workbench screen.
  This routine attempts to reopen the Workbench.The actions taken are:
  - general good stuff and nice things, and then return a non-null
    pointer to the Workbench screen.
  - find that something has gone wrong, and return NULL
  The return value, if not NULL, is indeed the address of the Workbench
  screen, although you should not use it as such.This is because the
  Workbench may be closed by other programs, which can invalidate
  the address at any time.We suggest that you regard the return
  value as a ULONG indication that the routine has succeeded, if
  you pay any attention to it at all.
@{b}    SYNOPSIS @{ub}  ULONG OpenWorkBench( @{FG shine}void@{FG text} );
  @{i}@{b}WBScreen@{ub}@{ui} = OpenWorkBench()
   D0
  non-zero if Workbench screen opened successfully, or was already opened
  zero if anything went wrong and the Workbench screen isn't out there 
BUGS
  The name of this routine is spelled wrong: it ought to have been
  OpenWorkbench().
@EndNode
@Node "PointInImage()" "intuition.library/PointInImage"
@{b}@{u}PointInImage@{uu}@{ub} -- Tests whether an image "contains" a point.(V36)
  Tests whether a point is properly contained in an image.
  The intention of this is to provide custom gadgets a means
  to delegate "image mask" processing to the Image, where
  it belongs (superseding things like BOOLMASK).After all,
  a rounded rect image with a drop shadow knows more about
  what points are inside it than anybody else should.
  For traditional Intuition Images, this routine checks if
  the point is in the Image box (LeftEdge/RightEdge/Width/Height).
SYNOPSIS  BOOL PointInImage( @{FG shine}struct@{FG text} Point, @{FG shine}struct@{FG text} @{"Image" Link "include:intuition/intuition.h/Main" 700} * );
  @{i}@{b}DoesContain@{ub}@{ui} = PointInImage( @{i}Point@{ui}, @{i}Image@{ui} )
   D0                          D0      A0
  @{i}Point@{ui} - Two words, X/Y packed into a @{FG shine}long@{FG text}, with high word
    containing 'X'.This is what you get if you pass a Point structure
    (not a pointer!) using common C language parameter conventions.
  @{i}Image@{ui} - a pointer to a standard or custom Image data object.
    @{i}NOTE:@{ui} If 'Image' is NULL, this function returns TRUE.
  @{i}@{b}DoesContain@{ub}@{ui} - Boolean result of the test.
BUGS
  Only applies to the first image, does not follow NextImage
  linked list.This might be preferred.
@EndNode
@Node "PrintIText()" "intuition.library/PrintIText"
@{b}@{u}PrintIText@{uu}@{ub} -- Print text described by the IntuiText argument.
  Prints the IntuiText into the specified RastPort.Sets up the RastPort
  as specified by the IntuiText values, then prints the text into the
  RastPort at the IntuiText x/y coordinates offset by the left/top arguments.
  Note, though, that the IntuiText structure itself may contain further
  text position coordinates: those coordinates and the Left/TopOffsets are
  added to obtain the true position of the text to be rendered.
  This routine does window layer clipping as appropriate -- if you 
  print text outside of your window, your characters will be clipped
  at the window's edge, providing you pass your window's (layered) RastPort.
  If the NextText field of the IntuiText argument is non-NULL, the next
  IntuiText is rendered as well, and so on until some NextText field is NULL.
  IntuiText with the ITextFont field NULL are displayed in the
  font of the RastPort.If the RastPort font is also NULL, the
  system default font, as set via the Preferences tool, will be used.
SYNOPSIS  @{FG shine}void@{FG text} PrintIText( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, @{FG shine}struct@{FG text} @{"IntuiText" Link "include:intuition/intuition.h/Main" 650} *, WORD, WORD );
  PrintIText( @{i}RastPort@{ui}, @{i}IText@{ui}, @{i}LeftOffset@{ui}, @{i}TopOffset@{ui} )
               A0        A1     D0           D1
  @{i}RastPort@{ui} = the RastPort destination of the text
  @{i}IText@{ui} = pointer to an instance of the structure IntuiText
  @{i}LeftOffset@{ui} = left offset of the IntuiText into the RastPort
  @{i}TopOffset@{ui} = top offset of the IntuiText into the RastPort
@EndNode
@Node "PubScreenStatus()" "intuition.library/PubScreenStatus"
@{b}@{u}PubScreenStatus@{uu}@{ub} -- Change status flags for a public screen.(V36)
  Changes status flags for a given public screen.The only flag bit currently
  defined is @{i}PSNF_PRIVATE@{ui}.Thus, PubScreenStatus( screen, @{i}PSNF_PRIVATE@{ui} )
  makes a screen private, while PubScreenStatus( screen, 0 ) makes it public.
  Do not apply this function to a screen if your program isn't the screen's
  "owner", in particular, don't call this function for the Workbench screen.
SYNOPSIS  UWORD PubScreenStatus( @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} *, UWORD );
  @{i}@{b}ResultFlags@{ub}@{ui} = PubScreenStatus( @{i}Screen@{ui}, @{i}StatusFlags@{ui} )
   D0                             A0       D0
  @{i}Screen@{ui} = pointer to public screen
  @{i}StatusFlags@{ui} = Any of the @{i}PSNF_@{ui} flags (only @{b}PSNF_PRIVATE@{ub} is currently defined).
  Returns 0 in the lowest order bit of the return value if the screen wasn't
  public, or because it can not be taken private because visitors are open in it.
  All other bits in the return code are reserved for future enhancement.
SEE ALSO
  @{"OpenScreen()" Link "OpenScreen()"}, Intuition V36 update documentation 
@EndNode
@Node "QueryOverscan()" "intuition.library/QueryOverscan"
@{b}@{u}QueryOverscan@{uu}@{ub} -- Inquire about a standard overscan region.(V36)
  This function fills in a rectangle with one of the system overscan dimensions,
  scaled appropriately for the mode of the DisplayID it is passed.
  @{i}There are three types of system overscan values@{ui}:
  @{b}OSCAN_TEXT@{ub}:completely visible, by user preference.Used for Workbench screen
    and screen dimensions @{i}STDSCREENWIDTH@{ui} and @{i}STDSCREENHEIGHT@{ui}.
    Left/Top is always 0,0.
  @{b}OSCAN_STANDARD@{ub}:just beyond visible bounds of monitor, by user preference.
    Left/Top may be negative.
  @{b}OSCAN_MAX@{ub}:The largest region we can display, @{b}AND@{ub} display any smaller region
    (see note below).
  @{b}OSCAN_VIDEO@{ub}:The absolute largest region that the graphics.library can display.
    This region must be used as-is.
SYNOPSIS  @{FG shine}long@{FG text} QueryOverscan( ULONG, @{FG shine}struct@{FG text} @{"Rectangle" Link "include:graphics/gfx.h/Main" 27} *, WORD );
  @{i}@{b}success@{ub}@{ui} = QueryOverscan( @{i}DisplayID@{ui}, @{i}Rect@{ui}, @{i}OScanType@{ui} )
   D0                       A0         A1     D0
  @{i}DisplayID@{ui} -- A 32-bit identifier for a display mode, as defined
    in the <graphics/modeid.h> include file (V39 and up) or in
    @{"<graphics/displayinfo.h>" Link "include:graphics/displayinfo.h/Main" 0} (V37/V38).
    @{i}NOTE@{ui}: If you only intend to use one of the four standard overscan dimensions
    as is, and open your screen to exactly the DisplayClip dimensions, you can
    specify one of the OSCAN_ values using the SA_Overscan tag to the
    @{"OpenScreenTagList()" Link "OpenScreenTagList()"} function and omit all of @{i}SA_Left@{ui}, @{i}SA_Top@{ui}, @{i}SA_Width@{ui},
    and @{i}SA_Height@{ui}.This also requires that you do not supply a @{"NewScreen" Link "include:intuition/screens.h/Main" 477}
    structure, since it always contains left/top/width/height information.
    If you wish to supply a NewScreen structure, then you are supplying
    left/top/width/height information.This information can be taken from the
    rectangle resulting from this function:
    NewScreen.@{i}LeftEdge@{ui} = Rect.@{i}MinX@{ui};
    NewScreen.@{i}TopEdge@{ui} = Rect.@{i}MinY@{ui};
    NewScreen.@{i}Width@{ui} = @{b}STDSCREENWIDTH@{ub};
      /* or ( Rect.@{i}MaxX@{ui} - Rect.@{i}MinX@{ui} + 1 ) */
    NewScreen.@{i}Height@{ui} = @{b}STDSCREENHEIGHT@{ub};
      /* or ( Rect.@{i}MaxY@{ui} - Rect.@{i}Miny@{ui} + 1 ) */
  @{i}Rect@{ui} -- pointer to a Rectangle structure which this function will fill out
    with its return values.Note that to convert a rectangle to a screen "Height"
    you do (@{i}MaxY@{ui} - @{i}MinY@{ui} + 1), and similarly for "Width."  The rectangle may be
    passed directly to @{"OpenScreen()" Link "OpenScreen()"} as a DisplayClip region (@{i}SA_DClip@{ui}).
  0 (FALSE) if the @{"MonitorSpec" Link "include:graphics/monitor.h/Main" 25} your NewScreen requests does not exist.
  Non-zero (TRUE) if it does.
BUGS
  Change in parameter V36.A17 might cause problems for some.
SEE ALSO
  @{"OpenScreen()" Link "OpenScreen()"}, Intuition V36 update documentation
@EndNode
@Node "RefreshGadgets()" "intuition.library/RefreshGadgets"
@{b}@{u}RefreshGadgets@{uu}@{ub} -- Refresh (redraw) the gadget display.
  Refreshes (redraws) all of the gadgets in the gadget list starting
  from the specified gadget.
  The window parameter must point to the window which contains the
  gadget, or which contains the requester that contains the gadget
  The requester parameter must only be valid if the gadget has the
  @{i}GTYP_REQGADGET@{ui} flag set, a requirement for all requester gadgets.
  The Pointer argument points to a Window structure.
  @{i}The two main reasons why you might want to use this routine are@{ui}:
  - first, that you've modified the imagery of the gadgets in your
    display and you want the new imagery to be displayed;
  - secondly, if you think that some graphic operation you just performed
  trashed the gadgetry of your display, this routine will refresh
  the imagery for you.
  Note that to modify the imagery of a gadget, you must first remove
  that gadget from the window's gadget list, using @{"RemoveGadget()" Link "RemoveGadget()"} (or
  RemoveGList()).After changing the image, border, text (including
  text for a string gadget), the gadget is replaced in the gadget list
  (using @{"AddGadget()" Link "AddGadget()"} or @{"AddGList()" Link "AddGList()"}).Adding gadgets does not cause
  them to be displayed (refreshed), so this function, or @{"RefreshGList()" Link "RefreshGList()"}
  is typically called.
  A common technique is to set or reset the @{i}GFLG_SELECTED@{ui} flag of a
  Boolean gadget and then call RefreshGadgets() to see it displayed
  highlighted if and only if @{i}GFLG_SELECTED@{ui} is set.If you wish to do
  this and be completely proper, you must @{"RemoveGadget()" Link "RemoveGadget()"}, change the
  @{i}GFLG_SELECTED@{ui} flag, @{"AddGadget()" Link "AddGadget()"}, and RefreshGadgets(), or the equivalent.
  The gadgets argument can be a copy of the FirstGadget variable in 
  the Window structure that you want refreshed:
  the effect of this will be that all gadgets will be redrawn.
  However, you can selectively refresh just some of the gadgets 
  by starting the refresh part-way into the list: for instance,
  redrawing your window non-@{i}GTYP_GZZGADGET@{ui} gadgets only, which you've
  conveniently grouped at the end of your gadget list.
  Even more control is available using the @{"RefreshGList()" Link "RefreshGList()"} routine which
  enables you to refresh a single gadget, or number of your choice.
SYNOPSIS
  @{FG shine}void@{FG text} RefreshGadgets( @{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} * );
  RefreshGadgets( @{i}Gadgets@{ui}, @{i}Window@{ui}, @{i}Requester@{ui} )
                   A0       A1       A2
  @{i}Gadgets@{ui} = pointer to the first in the list of gadgets wanting refreshment
  @{i}Window@{ui} = pointer to the window containing the gadget or its requester
  @{i}Requester@{ui} = pointer to a requester
    (ignored if gadget is not attached to a requester).
NOTE
  It's never safe to tinker with the gadget list yourself.Don't supply
  some gadget list that Intuition hasn't already processed in the usual way.
SEE ALSO
  @{"RefreshGList()" Link "RefreshGList()"}, @{"RemoveGadget()" Link "RemoveGadget()"}, @{"RemoveGList()" Link "RemoveGList()"}, @{"AddGadget()" Link "AddGadget()"}, @{"AddGList()" Link "AddGList()"}
@EndNode
@Node "RefreshGList()" "intuition.library/RefreshGList"
@{b}@{u}RefreshGList@{uu}@{ub} -- Refresh (redraw) a chosen number of gadgets.
  Refreshes (redraws) gadgets in the gadget list starting
  from the specified gadget.At most NumGad gadgets are redrawn.
  If NumGad is -1, all gadgets until a terminating NULL value
  in the NextGadget field is found will be refreshed, making this
  routine a superset of @{"RefreshGadgets()" Link "RefreshGadgets()"}.
  The Requester parameter can point to a Requester structure.If
  the first gadget in the list has the @{i}GTYP_REQGADGET@{ui} flag set, the
  gadget list refers to gadgets in a requester and the pointer 
  must necessarily point to a window.If these are not the gadgets
  of a requester, the requester argument may be NULL.
  Be sure to see the @{"RefreshGadgets()" Link "RefreshGadgets()"} function description, as this
  function is simply an extension of that.
SYNOPSIS
  @{FG shine}void@{FG text} RefreshGList( @{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *,
    WORD );
  RefreshGList( @{i}Gadgets@{ui}, @{i}Window@{ui}, @{i}Requester@{ui}, @{i}NumGad@{ui} )
                 A0       A1      A2          D0
  @{i}Gadgets@{ui} = pointer to the first in the list of gadgets wanting refreshment
  @{i}Window@{ui} = pointer to the window containing the gadget or its requester
  @{i}Requester@{ui} = pointer to a requester
    (ignored if Gadget is not attached to a Requester).
  @{i}NumGad@{ui}  = maximum number of gadgets to be refreshed.A value of -1 will
    cause all gadgets to be refreshed from gadget to the end of the list.
    A value of -2 will also do this, but if 'Gadgets' points to a Requester
    Gadget (@{i}GTYP_REQGADGET@{ui}) @{b}ALL@{ub} gadgets in the requester will be refreshed
    (this is a mode compatible with v1.1 RefreshGadgets().)
SEE ALSO
  @{"RefreshGadgets()" Link "RefreshGadgets()"}
@EndNode
@Node "RefreshWindowFrame()" "intuition.library/RefreshWindowFrame"
@{b}@{u}RefreshWindowFrame@{uu}@{ub} -- Ask Intuition to redraw your window border.
  Refreshes the border of a window, including title region and all
  of the window's gadgets.
  You may use this call if you wish to update the display of your borders.
  The expected use of this is to correct unavoidable corruption.
SYNOPSIS  @{FG shine}void@{FG text} RefreshWindowFrame( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} * );
  RefreshWindowFrame( @{i}Window@{ui} )
                       A0
  @{i}Window@{ui} = a pointer to a Window structure
@EndNode
@Node "ReleaseGIRPort()" "intuition.library/ReleaseGIRPort"
@{b}@{u}ReleaseGIRPort@{uu}@{ub} -- Release a custom gadget RastPort.(V36)
  The corresponding function to @{"ObtainGIRPort()" Link "ObtainGIRPort()"}, it releases
  arbitration used by Intuition for gadget RastPorts.
  Pointer to the RastPort returned by @{"ObtainGIRPort()" Link "ObtainGIRPort()"}.
  This pointer can be NULL, in which case nothing happens.
SYNOPSIS  @{FG shine}void@{FG text} ReleaseGIRPort( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} * );
  ReleaseGIRPort( @{i}RPort@{ui} )
                   A0
SEE ALSO
  @{"ObtainGIRPort()" Link "ObtainGIRPort()"}, @{"Custom" Link "include:hardware/custom.h/Main" 25} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} documentation
@EndNode
@Node "RemakeDisplay()" "intuition.library/RemakeDisplay"
@{b}@{u}RemakeDisplay@{uu}@{ub} -- Remake the entire Intuition display.
  This is the big one.
  This procedure remakes the entire @{"View" Link "include:graphics/view.h/Main" 57} structure for the
  Intuition display.It does the equivalent of @{"MakeScreen()" Link "MakeScreen()"} for
  every screen in the system, and then it calls the internal
  equivalent of @{"RethinkDisplay()" Link "RethinkDisplay()"}.
SYNOPSIS  @{FG shine}long@{FG text} RemakeDisplay( @{FG shine}void@{FG text} );
  /* Returns @{FG shine}long@{FG text} in V39 and greater */
  @{i}@{b}failure@{ub}@{ui} = RemakeDisplay()
   D0 (V39)
  Starting with V39, returns zero for success, non-zero for failure.
  Probable cause of failure is failure of @{"graphics.library/MakeVPort()" Link "graphics.guide/MakeVPort()"}
  or of @{"graphics.library/MrgCop()" Link "graphics.guide/MrgCop()"}.
  Prior to V39, the return code is invalid.Do not interpret it when
  running on pre-V39 systems!
  @{b}WARNING:@{ub}This routine can take many milliseconds to run,
  so do not use it lightly.
  Calling @{"MakeScreen()" Link "MakeScreen()"} followed by @{"RethinkDisplay()" Link "RethinkDisplay()"} is typically
  a more efficient method for affecting changes to a single
  screen's @{"ViewPort" Link "include:graphics/view.h/Main" 40}.
SEE ALSO
  @{"MakeScreen()" Link "MakeScreen()"}, @{"RethinkDisplay()" Link "RethinkDisplay()"}, @{"graphics.library/MakeVPort()" Link "graphics.guide/MakeVPort()"}
  @{"graphics.library/MrgCop()" Link "graphics.guide/MrgCop()"}, @{"graphics.library/LoadView()" Link "graphics.guide/LoadView()"}
@EndNode
@Node "RemoveClass()" "intuition.library/RemoveClass"
@{b}@{u}RemoveClass@{uu}@{ub} -- Make a public boopsi class unavailable.(V36)
  Makes a public class unavailable for public consumption.
  It's OK to call this function for a class which is not
  yet in the internal public class list, or has been already removed.
SYNOPSIS  @{FG shine}void@{FG text} RemoveClass( @{FG shine}struct@{FG text} IClass * );
  RemoveClass( @{i}classPtr@{ui} )
                A0
  @{i}ClassPtr@{ui} = pointer to *public* class created by @{"MakeClass()" Link "MakeClass()"}, may be NULL.
SEE ALSO
  @{"MakeClass()" Link "MakeClass()"}, @{"FreeClass()" Link "FreeClass()"}, @{"AddClass()" Link "AddClass()"}
  Document "Basic Object-Oriented Programming System for Intuition"
  and the "boopsi Class Reference" document.
@EndNode
@Node "RemoveGadget()" "intuition.library/RemoveGadget"
@{b}@{u}RemoveGadget@{uu}@{ub} -- Remove a gadget from a window.
  Removes the given gadget from the gadget list of the specified 
  window.Returns the ordinal position of the removed gadget.
  If the gadget is in a requester attached the the window, this
  routine will look for it and remove it if it is found.
  If the gadget pointer points to a gadget that isn't in the appropriate list,
  -1 is returned.If there aren't any gadgets in the list, -1 is returned.
  If you remove the 65535th gadget from the list -1 is returned.
SYNOPSIS  UWORD RemoveGadget( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} * );
  @{i}@{b}Position@{ub}@{ui} = RemoveGadget( @{i}Window@{ui}, @{i}Gadget@{ui} )
   D0                       A0       A1
  @{i}Window@{ui} = pointer to the window containing the gadget or the requester
    containing the gadget to be removed.
  @{i}Gadget@{ui} = pointer to the gadget to be removed.The gadget itself describes
    whether this is a gadget that should be removed from the window or
    some requester.
  Returns the ordinal position of the removed gadget.If the gadget wasn't found
  in the appropriate list, or if there are no gadgets in the list, returns -1.
NOTES
  @{i}New with V37@{ui}: If one of the gadgets you wish to remove is the active gadget,
  this routine will wait for the user to release the mouse button before
  deactivating and removing the gadget.
SEE ALSO
  @{"AddGadget()" Link "AddGadget()"}, @{"AddGList()" Link "AddGList()"}, @{"RemoveGList()" Link "RemoveGList()"}
@EndNode
@Node "RemoveGList()" "intuition.library/RemoveGList"
@{b}@{u}RemoveGList@{uu}@{ub} -- Remove a sublist of gadgets from a window.
  Removes 'Numgad' gadgets from the gadget list of the specified 
  window.Will remove gadgets from a requester if the first
  gadget's GadgetType flag @{i}GTYP_REQGADGET@{ui} is set.
  Otherwise identical to @{"RemoveGadget()" Link "RemoveGadget()"}.
SYNOPSIS  UWORD RemoveGList( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, WORD );
  @{i}@{b}Position@{ub}@{ui} = RemoveGList( @{i}Window@{ui}, @{i}Gadget@{ui}, @{i}Numgad@{ui} )
   D0                      A0       A1      D0
  @{i}Window@{ui} = pointer to the window containing the gadget or the requester
      containing the gadget to be removed.
  @{i}Gadget@{ui} = pointer to the gadget to be removed.The gadget itself describes
    whether this is a gadget that should be removed from the window or
    some requester.
  @{i}Numgad@{ui} = number of gadgets to be removed.If -1, remove all gadgets
    to end of window gadget list
  Returns the ordinal position of the removed gadget.If the gadget wasn't found
  in the appropriate list, or if there are no gadgets in the list, returns -1.
NOTE
  The last gadget in the list does @{b}NOT@{ub} have its link zeroed.
  @{i}New with V36@{ui}: OK, last gadget's NextGadget field is set to NULL.
  @{i}New with V37@{ui}: If one of the gadgets you wish to remove is the active gadget,
  this routine will wait for the user to release the mouse button before
  deactivating and removing the gadget.
SEE ALSO
  @{"RemoveGadget()" Link "RemoveGadget()"}, @{"AddGadget()" Link "AddGadget()"}, @{"AddGList()" Link "AddGList()"}
@EndNode
@Node "ReportMouse()" "intuition.library/ReportMouse"
@{b}@{u}ReportMouse@{uu}@{ub} -- Tell Intuition whether to report mouse movement.
  Tells Intuition whether or not to broadcast mouse-movement events to
  your window when it's the active one.The Boolean value specifies
  whether to start or stop broadcasting position information of mouse-movement.
  If the window is the active one, mouse-movement reports start coming
  immediately afterwards.This same routine will change the current state
  of the @{i}GACT_FOLLOWMOUSE@{ui} function of a currently-selected gadget too.
  Note that calling ReportMouse() when a gadget is selected will only
  temporarily change whether or not mouse movements are reported while
  that gadget remains selected; the next time the gadget is selected, its
  @{i}GACT_FOLLOWMOUSE@{ui} flag is examined anew.
  Note also that calling ReportMouse() when no gadget is currently
  selected will change the state of the window's @{i}WFLG_REPORTMOUSE@{ui} flag,
  but will have no effect on any gadget that may be subsequently
  selected.(This is all fixed in V36.)
  The ReportMouse() function is first performed when @{"OpenWindow()" Link "OpenWindow()"} 
  is first called; if the flag @{i}WFLG_REPORTMOUSE@{ui} is included among
  the options, then all mouse-movement events are reported 
  to the opening task and will continue to be reported
  until ReportMouse() is called with a Boolean value of FALSE.
  If @{i}WFLG_REPORTMOUSE@{ui} is not set, then no mouse-movement reports will
  be broadcast until ReportMouse() is called with a Boolean of TRUE.
  Note that the @{i}WFLG_REPORTMOUSE@{ui} flag, as managed by this routine,
  determines IF mouse messages are to be broadcast.Determining @{b}HOW@{ub}
  they are to be broadcast is determined by the @{i}IDCMP_MOUSEMOVE@{ui} IDCMPFlag.
SYNOPSIS  @{FG shine}void@{FG text} ReportMouse( BOOL, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} * );
  ReportMouse( @{i}Boolean@{ui}, @{i}Window@{ui} )
                D0       A0  <-note
  @{i}Window@{ui} = pointer to a Window structure associated with this request
  @{i}Boolean@{ui} = TRUE or FALSE value specifying whether to turn this function
    on or off
SPECIAL NOTE
  Some compilers and link files switch the arguments to this function
  about in unpredictable ways.We apologize for this confusion
  wrapped around an error enclosing a mistake.
  @{i}The call will take one of two forms@{ui}:
    ReportMouse(@{i}Boolean@{ui}, @{i}Window@{ui});
      -or-
    ReportMouse(@{i}Window@{ui}, (ULONG)@{i}Boolean@{ui});
  The first form is the one that corresponds to the amiga.lib supplied
  by Commodore.The linker libraries and "pragmas" of some compilers
  supply the alternate form.
  A key point to remember is that the form of the function in ROM
  has always been the same, so there has always been object code
  compatibility.However some care should be taken when switching
  compilers or switching between stubs and pragmas.
  From assembler the interface has always been:
    Boolean in D0, Window in A0
  Also, it is still endorsed to simply set the @{i}WFLG_REPORTMOUSE@{ui} flag bit
  in Window->@{i}Flags@{ui}, or reset it, on your own.Make the operation
  an atomic assembly instruction (OR.W #WFLG_REPORTMOUSE,wd_Flags+2(A0)
  where A0 contains your window pointer).Most compilers will produce
  an atomic operation when faced with:
    Window->@{i}Flags@{ui} |= WFLG_REPORTMOUSE;
    Window->@{i}Flags@{ui} &=~WFLG_REPORTMOUSE;
  or else bracket the operation between @{"Forbid()/Permit()" Link "exec.guide/Permit()"}.
BUGS
  See above
SEE ALSO
  The Input and Output section of the Intuition Reference Manual
@EndNode
@Node "Request()" "intuition.library/Request"
@{b}@{u}Request@{uu}@{ub} -- Activate a requester.
  Links in and displays a requester into the specified window.
  This routine ignores the window's @{i}IDCMP_REQVERIFY@{ui} flag.
SYNOPSIS  BOOL Request( @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} * );
  @{i}@{b}Success@{ub}@{ui} = Request( @{i}Requester@{ui}, @{i}Window@{ui} )
   D0                 A0         A1
  @{i}Requester@{ui} = pointer to the requester to be displayed
  @{i}Window@{ui} = pointer to the window into which this requester goes
  @{i}New for V36@{ui}: the @{i}POINTREL@{ui} flag now has meaning if the requester
    is not a DMR (Double-Menu Requester):
    If @{i}POINTREL@{ui} is set this requester should be placed in the center
    of the window, offset by Requester.@{i}RelLeft@{ui} and Requester.@{i}RelTop@{ui}.
    If the requester doesn't fit in the window, its position will be
    adjusted to show the upper-left corner.
  If the requester is successfully opened, TRUE is returned.
  Otherwise,if the requester could not be opened, FALSE is returned.
BUGS
  It turns out that the return code of this function is not
  always correct under V34 and prior.If your requester does not
  have an ENDGADGET, then you can examine window->@{i}FirstRequest@{ui} to see
  if your requester successfully opened.(A requester with an ENDGADGET
  can go away all by itself before you get the chance to look).
  Under V36 and higher, the return code from this routine is fine.
  There is a maximum of 8 requesters that are supported in
  a window that can be changed in size, position, or depth.
SEE ALSO
  The Requesters section of the Intuition Reference Manual
@EndNode
@Node "ResetMenuStrip()" "intuition.library/ResetMenuStrip"
@{b}@{u}ResetMenuStrip@{uu}@{ub} -- Re-attach a menu strip to a window.(V36)
  This function is simply a "fast" version of @{"SetMenuStrip()" Link "SetMenuStrip()"} that
  doesn't perform the precalculations of menu page sizes that
  @{"SetMenuStrip()" Link "SetMenuStrip()"} does.
  You may call this function @{b}ONLY IF@{ub} the menu strip and all items
  and sub-items have not changed since the menu strip was passed to
  @{"SetMenuStrip()" Link "SetMenuStrip()"}, with the following exceptions:
  - You may change the @{i}CHECKED@{ui} flag to turn a checkmark on or off.
  - You may change the @{i}ITEMENABLED@{ui} flag to enable/disable some
    @{"MenuItem" Link "include:intuition/intuition.h/Main" 89} or Menu structures.
  In all other ways, this function performs like @{"SetMenuStrip()" Link "SetMenuStrip()"}.
  @{i}The new sequence of events you can use is@{ui}:
  - @{"OpenWindow()" Link "OpenWindow()"}
  - @{"SetMenuStrip()" Link "SetMenuStrip()"}
  - zero or more iterations of:
    - @{"ClearMenuStrip()" Link "ClearMenuStrip()"}
    - change @{i}CHECKED@{ui} or @{i}ITEMENABLED@{ui} flags
    - ResetMenuStrip()
  - @{"ClearMenuStrip()" Link "ClearMenuStrip()"}
  - @{"CloseWindow()" Link "CloseWindow()"}
SYNOPSIS  BOOL ResetMenuStrip( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Menu" Link "include:intuition/intuition.h/Main" 61} * );
  @{i}@{b}Success@{ub}@{ui} = ResetMenuStrip( @{i}Window@{ui}, @{i}Menu@{ui} )
   D0                        A0      A1
  @{i}Window@{ui} = pointer to a Window structure
  @{i}Menu@{ui} = pointer to the first menu in the menu strip
  TRUE always.
SEE ALSO
  @{"SetMenuStrip()" Link "SetMenuStrip()"}, @{"ClearMenuStrip()" Link "ClearMenuStrip()"}
@EndNode
@Node "RethinkDisplay()" "intuition.library/RethinkDisplay"
@{b}@{u}RethinkDisplay@{uu}@{ub} -- Grand manipulation of the entire Intuition display.
  This function performs the Intuition global display reconstruction.
  This includes rethinking about all of the  ViewPorts and their
  relationship to one another and reconstructing the entire display
  based on the results of this rethinking.
  @{i}Specifically, and omitting many internal details, the operation
  consists of this@{ui}:
    Determine which ViewPorts are invisible and set their @{i}VP_HIDE@{ui}
    @{"ViewPort" Link "include:graphics/view.h/Main" 40} Mode flag.@{i}VP_HIDE@{ui} flags are also set for screens that
    may not be simultaneously displayed with the frontmost.(V36)
    If a change to a viewport height, or changing interlace or
    monitor scan rates require, @{"MakeVPort()" Link "graphics.guide/MakeVPort()"} is called for specific
    screen viewports.After this phase, the intermediate Copper lists
    for each screen's viewport are correctly set up.
    @{"MrgCop()" Link "graphics.guide/MrgCop()"} and @{"LoadView()" Link "graphics.guide/LoadView()"} are then called to get these Copper lists
    in action, thus establishing the new state of the Intuition display.
  You may perform a @{"MakeScreen()" Link "MakeScreen()"} on your @{"Custom" Link "include:hardware/custom.h/Main" 25} @{"Screen" Link "include:intuition/screens.h/Main" 120} before calling
  this routine.The results will be incorporated in the new display, but
  changing the INTERLACE @{"ViewPort" Link "include:graphics/view.h/Main" 40} mode for one screens must be reflected
  in the Intuition @{"View" Link "include:graphics/view.h/Main" 57}, which is left to Intuition.
@{b}WARNING:@{ub}This routine can take several milliseconds to run, so
  do not use it lightly.
  @{i}New for V36@{ui}: This routine is substantially changed to support
  new screen modes.In particular, if screen rearrangement has
  caused a change in interlace mode or scan rate, this routine
  will remake the copper lists for each screen's viewport.
SYNOPSIS  @{FG shine}long@{FG text} RethinkDisplay( @{FG shine}void@{FG text} );
  /* Returns @{FG shine}long@{FG text} in V39 and greater */
  @{i}@{b}failure@{ub}@{ui} = RethinkDisplay()
   D0 (V39)
  Starting with V39, returns zero for success, non-zero for failure.
  Probable cause of failure is failure of @{"graphics.library/MakeVPort()" Link "graphics.guide/MakeVPort()"}
  or of @{"graphics.library/MrgCop()" Link "graphics.guide/MrgCop()"}.
  Prior to V39, the return code is invalid.Do not interpret it when
  running on pre-V39 systems!
BUGS
  In V35 and earlier, an interlaced screen coming to the front
  may not trigger a complete remake as required when the global
  interlace state is changed.In some cases, this can be compensated
  for by setting the viewport DHeight field to 0 for hidden screens.
SEE ALSO
  @{"RemakeDisplay()" Link "RemakeDisplay()"}, @{"graphics.library/MakeVPort()" Link "graphics.guide/MakeVPort()"}, @{"graphics.library/MrgCop()" Link "graphics.guide/MrgCop()"},
  @{"graphics.library/LoadView()" Link "graphics.guide/LoadView()"}, @{"MakeScreen()" Link "MakeScreen()"}
@EndNode
@Node "ScreenDepth()" "intuition.library/ScreenDepth"
@{b}@{u}ScreenDepth@{uu}@{ub} -- Depth arrange a screen with extra control.(V39)
  Brings the specified screen to the front or back, based on
  the supplied flags.Also allows control of screen
  depth-arranging within screen families.
SYNOPSIS  @{FG shine}void@{FG text} ScreenDepth( @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} *, ULONG, APTR );
  ScreenDepth( @{i}screen@{ui}, @{i}flags@{ui}, @{i}reserved@{ui} )
                A0      D0     A1
  @{i}screen@{ui} = a pointer to the screen to move
  @{i}flags@{ui} = one of @{i}SDEPTH_TOFRONT@{ui} or @{i}SDEPTH_TOBACK@{ui} (bringing the
    screen to front or back respectively).If the screen is an attached screen,
    then you may also specify @{i}SDEPTH_INFAMILY@{ui} to move the screen within the
    screen family.If the screen is an attached screen and @{i}SDEPTH_INFAMILY@{ui} is not
    specified, then the whole family will move, which is also the behavior of the
    @{"ScreenToFront()" Link "ScreenToFront()"} and @{"ScreenToBack()" Link "ScreenToBack()"} functions, as well as the user-interface
    controls.
  @{i}reserved@{ui} = must be NULL for now.
NOTES
  @{b}ONLY@{ub} the application which owns the screen should use @{i}SDEPTH_INFAMILY@{ui}.
  It is incorrect style (and against the intentions of the screen opener) for
  programs such as commodities or mouse-helpers to move child screens around
  in their family.(Note that this is a style-behavior requirement; there is no
  technical requirement that the task calling this function need to be the task
  which opened the screen).
SEE ALSO
  @{"ScreenToFront()" Link "ScreenToFront()"}, @{"ScreenToBack()" Link "ScreenToBack()"},
  SA_Parent, SA_FrontChild, SA_BackChild
@EndNode
@Node "ScreenPosition()" "intuition.library/ScreenPosition"
@{b}@{u}ScreenPosition@{uu}@{ub} -- Move screens with greater control.(V39)
  Moves the screen to the specified position or by the specified
  increment, in screen pixel resolution coordinates.
  If the @{i}x1@{ui} and @{i}y1@{ui} variables you specify would move the screen in
  a way that violates any restrictions, the screen will be moved
  as far as possible.You may examine the @{i}LeftEdge@{ui} and @{i}TopEdge@{ui}
  fields of the Screen structure after this function returns to
  see where the screen really ended up.
  Note that negative values for screen @{i}LeftEdge@{ui} and @{i}TopEdge@{ui} are
  valid for screens bigger than their display clip.
SYNOPSIS  @{FG shine}void@{FG text} ScreenPosition( @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} *, ULONG, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text} );
  ScreenPosition( @{i}Screen@{ui}, @{i}flags@{ui}, @{i}x1@{ui}, @{i}y1@{ui}, @{i}x2@{ui}, @{i}y2@{ui} )
                   A0      D0     D1   D2  D3  D4
  @{i}Screen@{ui} = pointer to a Screen structure
  @{i}flags@{ui} = Set to one of @{i}SPOS_RELATIVE@{ui}, @{i}SPOS_ABSOLUTE@{ui}, or @{i}SPOS_MAKEVISIBLE@{ui}.
    You may additionally set @{i}SPOS_FORCEDRAG@{ui} if you need.
  - Use @{i}SPOS_RELATIVE@{ui} (zero) for normal use (move screen a relative
    amount expressed by @{i}x1@{ui},@{i}y1@{ui}).
  - Set the @{i}SPOS_ABSOLUTE@{ui} flag if you wish @{i}x1@{ui} and @{i}y1@{ui} to be absolute
    coordinates to move the screen to.
  - Set @{i}SPOS_MAKEVISIBLE@{ui} to position an oversized scrolling screen so that the
    rectangle described by (@{i}x1@{ui},@{i}y1@{ui})-(@{i}x2@{ui},@{i}y2@{ui}) is on the visible part of the display.
    (A word-processor may wish to support autoscrolling as the user types.
    In that case, it could call ScreenPosition() with the @{i}SPOS_MAKEVISIBLE@{ui} flag
    and a rectangle that encompasses the cursor with some space around it.
  - In addition to any one of the above choices, you can additionally set
    @{i}SPOS_FORCEDRAG@{ui} if you wish to reposition a screen that was opened with
    the {@{i}SA_Draggable@{ui},FALSE} attribute.
  @{i}x1@{ui},@{i}y1@{ui} = Absolute position or change in position you wish to apply
    to the screen, when using @{i}SPOS_ABSOLUTE@{ui} or @{i}SPOS_RELATIVE@{ui}.
    When using @{i}SPOS_MAKEVISIBLE@{ui}, these variables describe the upper-left corner
    of the rectangle you would like to ensure is on the visible part of a
    scrolling screen.
  @{i}x2@{ui},@{i}y2@{ui} = Ignored when using @{i}SPOS_ABSOLUTE@{ui} or @{i}SPOS_RELATIVE@{ui}.
    When using @{i}SPOS_MAKEVISIBLE@{ui}, these variables describe the lower-right corner
    of the rectangle you would like to ensure is on the visible part of a
    scrolling screen.
    Note that these coordinates are in the same resolution as the screen
    (such as HIRES or INTERLACE)
NOTES
  @{b}ONLY@{ub} the owner of the screen should use @{i}SPOS_FORCEDRAG@{ui}.
  It is incorrect style (and against the intentions of the screen opener) for
  programs such as commodities or mouse-helpers to move non-draggable screens.
SEE ALSO
  @{"MoveScreen()" Link "MoveScreen()"}, @{"RethinkDisplay()" Link "RethinkDisplay()"}
@EndNode
@Node "ScreenToBack()" "intuition.library/ScreenToBack"
@{b}@{u}ScreenToBack@{uu}@{ub} -- Send the specified screen to the back of the display.
  Sends the specified screen to the back of the display.
SYNOPSIS  @{FG shine}void@{FG text} ScreenToBack( @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} * );
  ScreenToBack( @{i}Screen@{ui} )
                 A0
  @{i}Screen@{ui} = pointer to a Screen structure
SEE ALSO
  @{"ScreenDepth()" Link "ScreenDepth()"}, @{"ScreenToFront()" Link "ScreenToFront()"}
@EndNode
@Node "ScreenToFront()" "intuition.library/ScreenToFront"
@{b}@{u}ScreenToFront@{uu}@{ub} -- Make the specified screen the frontmost.
  Brings the specified Screen to the front of the display.
SYNOPSIS  @{FG shine}void@{FG text} ScreenToFront( @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} * );
  ScreenToFront( @{i}Screen@{ui} )
                  A0
  @{i}Screen@{ui} = a pointer to a Screen structure
SEE ALSO
  @{"ScreenDepth()" Link "ScreenDepth()"}, @{"ScreenToBack()" Link "ScreenToBack()"}
@EndNode
@Node "ScrollWindowRaster()" "intuition.library/ScrollWindowRaster"
@{b}@{u}ScrollWindowRaster@{uu}@{ub} -- Intuition-friendly ScrollRasterBF().(V39)
  Calls graphics.library/ScrollRasterBF(), which moves
  the bits in the raster by (dx,dy) towards (0,0)
  The space vacated is filled by calling @{"EraseRect()" Link "graphics.guide/EraseRect()"}.
  @{i}NOTE@{ui}: that vacated space is _not_ considered damage! The scroll operation is
  limited to the rectangle defined by (@{i}xmin@{ui},@{i}ymin@{ui})-(@{i}xmax@{ui},@{i}ymax@{ui}).Bits outside
  will not be affected.If (xmax,ymax) is outside the rastport then use the
  lower right corner of the rastport.If a window is partly obscured, then it is
  possible for ScrollWindowRaster() to scroll some of the obscured area into view.
  If the window is simple-refresh, then the formerly obscured area is damage, and
  the application needs to repair it.If Intuition detects damage as a result of
  ScrollWindowRaster(),it will send an @{i}IDCMP_REFRESHWINDOW@{ui} event to the
  application's window.This handling of damage is the principal reason
  ScrollWindowRaster() is preferred to @{"ScrollRaster()" Link "graphics.guide/ScrollRaster()"} and ScrollRasterBF().
SYNOPSIS
  @{FG shine}void@{FG text} ScrollWindowRaster(@{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, WORD, WORD, WORD, WORD, WORD, WORD);
  ScrollWindowRaster(@{i}win@{ui}, @{i}dx@{ui}, @{i}dy@{ui}, @{i}xmin@{ui}, @{i}ymin@{ui}, @{i}xmax@{ui}, @{i}ymax@{ui})
                      A1   D0  D1   D2    D3    D4    D5
  @{i}win@{ui} - pointer to a Window structure
  @{i}dx@{ui},@{i}dy@{ui} are integers that may be postive, zero, or negative
  @{i}xmin@{ui},@{i}ymin@{ui} - upper left of bounding rectangle
  @{i}xmax@{ui},@{i}ymax@{ui} - lower right of bounding rectangle
NOTES
  This call uses ScrollRasterBF(), which calls @{"EraseRect()" Link "graphics.guide/EraseRect()"}
  when clearing the newly exposed area.This allows use of
  a custom layer backfill hook.
@{b}IMPORTANT:@{ub} boopsi gadgets should use @{"ScrollRaster()" Link "graphics.guide/ScrollRaster()"} or
  ScrollRasterBF() directly!  Never call ScrollWindowRaster()
  from inside a boopsi gadget's method handler.Note that
  Intuition will detect and handle damage caused by such use
  of @{"ScrollRaster()" Link "graphics.guide/ScrollRaster()"} or ScrollRasterBF(), for gadgets with
  the @{i}GMORE_SCROLLRASTER@{ui} property.
@{b}VERY IMPORTANT:@{ub} if you have any gadgets in your simple-refresh
  window with the @{i}GMORE_SCROLLRASTER@{ui} property, you must use
  ScrollWindowRaster() instead of @{"ScrollRaster()" Link "graphics.guide/ScrollRaster()"} or ScrollRasterBF().
  Handling of gadget scroll damage is incompatible with continued
  use of these graphics functions in an Intuition window.
@{b}NB@{ub}: If you're using a gadget class whose source code you do
  not control, that class might be using @{i}GMORE_SCROLLRASTER@{ui} or
  might start to in a future version.For that reason, you
  should use ScrollWindowRaster() if you are using any such gadgets.
SEE ALSO
  @{"graphics.library/ScrollRaster()" Link "graphics.guide/ScrollRaster()"}, graphics.library/ScrollRasterBF()
  @{"graphics.library/EraseRect()" Link "graphics.guide/EraseRect()"}, WA_BackFill
@EndNode
@Node "SetAttrsA()" "intuition.library/SetAttrsA"
@{b}@{u}SetAttrsA@{uu}@{ub} -- Specify attribute values for an object.(V36)
@{b}@{u}SetAttrs@{uu}@{ub}  -- Varargs stub for SetAttrsA().(V36)
  Specifies a set of attribute/value pairs with meaning as
  defined by a 'boopsi' object's class.
  This function does not provide enough context information or
  arbitration for boopsi gadgets which are attached to windows
  or requesters.For those objects, use SetGadgetAttrs().
SYNOPSIS
  ULONG SetAttrsA( APTR, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} * );
  ULONG SetAttrs( APTR, ULONG, ...);
  @{i}@{b}result@{ub}@{ui} = SetAttrsA( @{i}Object@{ui}, @{i}TagList@{ui} )
   D0                  A0       A1
  @{i}@{b}result@{ub}@{ui} = SetAttrs ( @{i}Object@{ui}, @{i}Tag1@{ui}, ...)
  @{i}Object@{ui} = abstract pointer to a boopsi object.
  @{i}TagList@{ui} = array of TagItem structures with attribute/value pairs.
  The object does whatever it wants with the attributes you provide.
  The return value tends to be non-zero if the changes would require
  refreshing gadget imagery, if the object is a gadget.
NOTES
  This function invokes the @{i}OM_SET@{ui} method with a NULL @{"GadgetInfo" Link "include:intuition/cghooks.h/Main" 25} parameter.
SEE ALSO
  @{"NewObject()" Link "NewObject()"}, @{"DisposeObject()" Link "DisposeObject()"}, @{"GetAttr()" Link "GetAttr()"}, @{"MakeClass()" Link "MakeClass()"},
  Document "Basic Object-Oriented Programming System for Intuition"
  and the "boopsi Class Reference" document.
@EndNode
@Node "SetDefaultPubScreen()" "intuition.library/SetDefaultPubScreen"
@{b}@{u}SetDefaultPubScreen@{uu}@{ub} -- Choose a new default public screen.(V36)
  Establishes a new default public screen for visitor windows.
  This screen is used by windows asking for a named public screen
  that doesn't exist and the @{i}FALLBACK@{ui} option is selected, and for
  windows asking for the default public screen directly.
SYNOPSIS  @{FG shine}void@{FG text} SetDefaultPubScreen( UBYTE * );
  SetDefaultPubScreen( @{i}Name@{ui} )
                        A0
  @{i}Name@{ui} = name of chosen public screen to be the new default.
  A value of NULL means that the Workbench screen is to
  be the default public screen.
SEE ALSO
  @{"OpenWindow()" Link "OpenWindow()"}, @{"OpenScreen()" Link "OpenScreen()"}, Intuition V36 update documentation  
@EndNode
@Node "SetDMRequest()" "intuition.library/SetDMRequest"
@{b}@{u}SetDMRequest@{uu}@{ub} -- Set the DMRequest of a window.
  Attempts to set the DMRequest into the specified window.
  The DMRequest is the special requester that you attach to 
  the double-click of the menu button which the user can then 
  bring up on demand.This routine @{b}WILL NOT@{ub} change the DMRequest
  if it's already set and is currently active (in use by the user).
  After having called SetDMRequest(), if you want to change the 
  DMRequest, the correct way to start is by calling @{"ClearDMRequest()" Link "ClearDMRequest()"} 
  until it returns a value of TRUE; then you can call SetDMRequest() 
  with the new DMRequest.
  If the @{i}POINTREL@{ui} flag is set in the DMRequest, the DMR will open as
  close to the pointer as possible.The RelLeft/Top fields are
  for fine-tuning the position.
SYNOPSIS  BOOL SetDMRequest( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} * );
  @{i}@{b}success@{ub}@{ui} = SetDMRequest( @{i}Window@{ui}, @{i}DMRequest@{ui} )
   D0                      A0      A1
  @{i}Window@{ui} = pointer to the window from which the DMRequest is to be set
  @{i}DMRequest@{ui} = a pointer to a requester
  If the current DMRequest was not in use, sets the DMRequest
    pointer into the window and returns TRUE.
  If the DMRequest was currently in use, doesn't change the pointer
    and returns FALSE.
SEE ALSO
  @{"ClearDMRequest()" Link "ClearDMRequest()"}, @{"Request()" Link "Request()"}
@EndNode
@Node "SetEditHook()" "intuition.library/SetEditHook"
@{b}@{u}SetEditHook@{uu}@{ub} -- Set global processing for string gadgets.(V36)
  Sets new global editing hook for string gadgets.
@{b}WARNING:@{ub}The use and integration of this function has not
  been explored, and thus should be considered a risky function.
  Do *@{b}NOT@{ub}* use this in a commercial product until further notice.
SYNOPSIS  @{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *SetEditHook( @{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} * );
  @{i}@{b}OldHook@{ub}@{ui} = SetEditHook( @{i}Hook@{ui} )
   D0                     A0
  @{i}Hook@{ui} -- A pointer to a @{FG shine}struct@{FG text} Hook which determines a function
    in your code to be called every time the user types a key.
    This is done before control is passed to the gadget custom
    editing hook, so affects @{b}ALL@{ub} string gadgets.
  Returns previous global edit hook structure.You may need this hook if you
  wish to invoke the previous edit hook's behavior in addition to your own.
NOTES
  There are a few key differences between a global edit hook and the
  more famililar per-gadget StringExtend->@{i}EditHook@{ui} field.In the
  case of the latter, the hook's creator supplies a WorkBuffer.
  Intuition's idea of the result of a keystroke is stored in
  the @{"SGWork" Link "include:intuition/sghooks.h/Main" 31} structure (which references the WorkBuffer).The
  state of the gadget before Intuition's hook acted is available in
  the StringInfo->@{i}Buffer@{ui}, ->@{i}BufferPos@{ui}, and ->@{i}NumChars@{ui} fields.
  In the case of a global editing hook, your hook _becomes_
  Intuition's hook, which affects all gadgets, most of which
  do not have a WorkBuffer.This means that if you invoke
  Intuition's original hook (which you got as the result of this
  function), there isn't any easy way for you to "undo" that after
  the fact.This means that if Intuition's behavior for certain
  keystrokes is incompatible with your hook's objectives, then
  you must avoid calling Intuition's hook for those keys.One
  approach is to run through your hook's code first, acting on
  those keys you wish to recognize.Then, call Intuition's
  hook for those keys you do not recognize, or for those keys
  whose default actions you wish to add to.
  Do not forget to set @{i}SGA_REDISPLAY@{ui} when needed (see sghooks.h),
  and please be sure to give the SGWork->@{i}EditOp@{ui} field a value
  which is as meaningful as possible.
  Currently, only @{i}SGH_KEY@{ui} messages are sent to the global edit hook,
  though custom edit hooks do receive @{i}SGH_CLICK@{ui} messages in addition.
  Finally, there is currently no arbitration between a global edit hook and a
  custom edit hook as to ownership of keystrokes.It would be fair to expect that
  a custom edit hook would be written to match the current Intuition edit hook.
  If your global edit hook acts on (say) up and down arrow keystrokes, an
  undesirable result may occur if some string gadget's custom hook also acts on
  these keystrokes.There is currently no easy way to resolve this issue.
@EndNode                                                                    
@Node "SetGadgetAttrsA()" "intuition.library/SetGadgetAttrsA"
@{b}@{u}SetGadgetAttrsA@{uu}@{ub} -- Specify attribute values for a boopsi gadget.(V36)
@{b}@{u}SetGadgetAttrs@{uu}@{ub}  -- Varargs stub for SetGadgetAttrsA().(V36)
  Same as SetAttrs(), but provides context information and arbitration for
  classes which implement custom Intuition gadgets.You should use this function
  for boopsi gadget objects which have already been added to a requester or a
  window, or for "models" which propagate information to gadget already added.
  Typically, the gadgets will refresh their visuals to reflect changes to visible
  attributes, such as the value of a slider, the text in a string-type gadget,
  the selected state of a button.You can use this as a replacement for SetAttrs()
  too, if you specify NULL for the 'Window' and 'Requester' parameters.
SYNOPSIS
  ULONG SetGadgetAttrsA( @{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *,
    @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} * );
  ULONG SetGadgetAttrs ( @{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *,
    @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *, ULONG, ...);
  @{i}@{b}result@{ub}@{ui} = SetGadgetAttrsA( @{i}Gadget@{ui}, @{i}Window@{ui}, @{i}Requester@{ui}, @{i}TagList@{ui} )
   D0                        A0      A1       A2         A3
  @{i}@{b}result@{ub}@{ui} = SetGadgetAttrs( @{i}Gadget@{ui}, @{i}Window@{ui}, @{i}Requester@{ui}, @{i}Tag1@{ui}, ...)
  @{i}Gadget@{ui} = abstract pointer to a boopsi gadget
  @{i}Window@{ui} = window gadget has been added to using @{"AddGList()" Link "AddGList()"} or @{"AddGadget()" Link "AddGadget()"}
  @{i}Requester@{ui} = for @{i}REQGADGET@{ui}s, requester containing the gadget
  @{i}TagList@{ui} = array of TagItem structures with attribute/value pairs.
  The object does whatever it wants with the attributes you provide,
  which might include updating its gadget visuals.
  The return value tends to be non-zero if the changes would require
  refreshing gadget imagery, if the object is a gadget.
NOTES
  This function invokes the @{i}OM_SET@{ui} method with a @{"GadgetInfo" Link "include:intuition/cghooks.h/Main" 25}
  derived from the 'Window' and 'Requester' pointers.
BUGS
  Prior to V39, this function ran with inadequate locking against
  the calls that Intuition's input task makes to the gadgets.
  To run properly prior to V39, this function, input processing,
  and and the gadget's dispatcher must be mutually re-entrant.
SEE ALSO
  @{"NewObject()" Link "NewObject()"}, @{"DisposeObject()" Link "DisposeObject()"}, @{"GetAttr()" Link "GetAttr()"}, @{"MakeClass()" Link "MakeClass()"},
  Document "Basic Object-Oriented Programming System for Intuition"
  and the "boopsi Class Reference" document.
@EndNode
@Node "SetMenuStrip()" "intuition.library/SetMenuStrip"
@{b}@{u}SetMenuStrip@{uu}@{ub} -- Attach a menu strip to a window.
  Attaches the menu strip to the window.After calling this routine, if the user
  presses the menu button, this specified menu strip will be displayed and
  accessible by the user.Menus with zero menu items are not allowed.
SYNOPSIS  BOOL SetMenuStrip( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Menu" Link "include:intuition/intuition.h/Main" 61} * );
  @{i}@{b}Success@{ub}@{ui} = SetMenuStrip( @{i}Window@{ui}, @{i}Menu@{ui} )
   D0                      A0      A1
  @{i}Window@{ui} = pointer to a Window structure
  @{i}Menu@{ui} = pointer to the first menu in the menu strip
  TRUE if there were no problems.TRUE always, since this routine
  will wait until it is OK to proceed.
NOTES
  You should always design your menu strip changes to be a
  two-way operation, where for every menu strip you add to your 
  window you should always plan to clear that strip sometime.Even
  in the simplest case, where you will have just one menu strip for 
  the lifetime of your window, you should always clear the menu strip 
  before closing the window.If you already have a menu strip attached
  to this window, the correct procedure for changing to a new menu 
  strip involves calling @{"ClearMenuStrip()" Link "ClearMenuStrip()"} to clear the old first.
  The sequence of events should be:
  - @{"OpenWindow()" Link "OpenWindow()"}
  - zero or more iterations of:
    - SetMenuStrip()
    - @{"ClearMenuStrip()" Link "ClearMenuStrip()"}
  - @{"CloseWindow()" Link "CloseWindow()"}
SEE ALSO
  @{"ClearMenuStrip()" Link "ClearMenuStrip()"}, @{"ResetMenuStrip()" Link "ResetMenuStrip()"}
@EndNode
@Node "SetMouseQueue()" "intuition.library/SetMouseQueue"
@{b}@{u}SetMouseQueue@{uu}@{ub} -- Change limit on pending mouse messages.(V36)
  Changes the number of mouse messages that Intuition will allow
  to be outstanding for your window.
SYNOPSIS  @{FG shine}long@{FG text} SetMouseQueue( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, UWORD );
  @{i}@{b}oldQueueLength@{ub}@{ui} = SetMouseQueue( @{i}Window@{ui}, @{i}QueueLength@{ui} )
   D0                              A0      D0
  @{i}Window@{ui} = your window
  @{i}QueueLength@{ui} = the new value of outstanding mouse movement messages you wish
    to allow.
  -1 if 'Window' is not known.Otherwise the previous value of the queue limit.
  The corresponding function for changing the repeat key
  queue limit is not yet implemented.
SEE ALSO
  @{"OpenWindow()" Link "OpenWindow()"}
@EndNode
@Node "SetPointer()" "intuition.library/SetPointer"
@{b}@{u}SetPointer@{uu}@{ub} -- Specify a pointer sprite image for a window.
  Sets up the window with the sprite definition for the pointer.
  Then, whenever the window is the active one, the pointer image will change
  to the window's version.If the window is the active one when this routine
  is called, the change takes place immediately.
  The XOffset and YOffset parameters are used to offset the
  upper-left corner of the hardware sprite image from what Intuition
  regards as the current position of the pointer.Another way of
  describing it is as the offset from the "hot spot" of the pointer
  to the top-left corner of the sprite.For instance, if you specify
  offsets of zero, zero, then the top-left corner of your sprite 
  image will be placed at the mouse position.On the other hand,
  if you specify an XOffset of -7 (remember, sprites are 16 pixels 
  wide) then your sprite will be centered over the mouse position.
  If you specify an XOffset of -15, the right-edge of the sprite 
  will be over the mouse position.
SYNOPSIS  @{FG shine}void@{FG text} SetPointer( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, UWORD *, WORD, WORD, WORD, WORD );
  SetPointer( @{i}Window@{ui}, @{i}Pointer@{ui}, @{i}Height@{ui}, @{i}Width@{ui}, @{i}XOffset@{ui}, @{i}YOffset@{ui} )
               A0      A1       D0       D1     D2       D3
  @{i}Window@{ui} = pointer to the window to receive this pointer definition
  @{i}Pointer@{ui} = pointer to the data definition of a sprite
  @{i}Height@{ui} = the height of the pointer
  @{i}Width@{ui} = the width of the sprite (must be less than or equal to sixteen)
  @{i}XOffset@{ui} = the offset for your sprite from the mouse position
  @{i}YOffset@{ui} = the offset for your sprite from the mouse position
SEE ALSO
  @{"SetWindowPointerA()" Link "SetWindowPointerA()"}, @{"ClearPointer()" Link "ClearPointer()"}, ROM Kernel Manual: Libraries
@EndNode
@Node "SetPrefs()" "intuition.library/SetPrefs"
@{b}@{u}SetPrefs@{uu}@{ub} -- Set Intuition preferences data.
  Sets new preferences values.Copies the first 'Size' bytes
  from your preferences buffer to the system preferences table,
  and puts them into effect.
  The 'Inform' parameter, if TRUE, indicates that an @{i}IDCMP_NEWPREFS@{ui}
  message is to be sent to all windows that have the @{i}IDCMP_NEWPREFS@{ui}
  IDCMPFlag set.
  It is legal to set a partial copy of the Preferences structure.
  The most frequently changed values are grouped at the beginning
  of the Preferences structure.
  @{i}New for V36@{ui}: A new and more extensible method for supplying
  Preferences has been introduced in V36, and relies on file
  system notification.The Intuition preferences items rely
  also on the IPrefs program.Certain elements of the
  Preferences structure have been superseded by this new method.
  (Elements are generally superseded as new hardware or software
  features demand more information than fits in @{FG shine}struct@{FG text} Preferences.
  Parts of @{FG shine}struct@{FG text} Preferences must be ignored so that applications
  calling @{"GetPrefs()" Link "GetPrefs()"}, modifying some other part of @{FG shine}struct@{FG text} @{"Preferences" Link "include:intuition/preferences.h/Main" 43},
  then calling SetPrefs(), don't end up truncating the extended data).
  @{b}Pointer Preferences@{ub}: Starting with V36, pointer changes
  submitted through SetPrefs() are only heeded until the first
  time IPrefs informs Intuition of a V36-style pointer preferences
  file.In V39 and higher, only the pointer from the initial
  SetPrefs() (i.e.devs:system-configuration) is heeded.
  @{b}Palette Preferences@{ub}: Starting with V39, color changes submitted
  through SetPrefs() are ignored after the first time IPrefs sends
  Intuition new style palette preferences.
  @{b}FontHeight and LaceWB@{ub}: These are only respected from devs:system-configuration.
  @{b}View centering and size@{ub}: Changes to ViewX/YOffset and Row/ColumnSizeChange
  only apply to the default monitor (NTSC or PAL), and not to other monitors
  such as Productivity.
  Other fields may be superseded in the future.
SYNOPSIS  @{FG shine}struct@{FG text} @{"Preferences" Link "include:intuition/preferences.h/Main" 43} *SetPrefs( @{FG shine}struct@{FG text} Preferences *, @{FG shine}long@{FG text}, BOOL );
  @{i}@{b}Prefs@{ub}@{ui} = SetPrefs( @{i}PrefBuffer@{ui}, @{i}Size@{ui}, @{i}Inform@{ui} )
   D0                A0           D0    D1
  @{i}PrefBuffer@{ui} = pointer to the memory buffer which contains your
    desired settings for Intuition preferences
  @{i}Size@{ui} = the number of bytes in your PrefBuffer, the number of bytes
    you want copied to the system's internal preference settings
  @{i}Inform@{ui} = whether you want the information of a new preferences
      setting propagated to all windows.
  Returns your parameter PrefBuffer.
NOTES
  Unless you are responding to a user's explicit request to
  change Preferences (for example, you are writing a Preferences
  editor), you should probably avoid using this function.
  The user's Preferences should be respected, not overridden.
SEE ALSO
  @{"GetDefPrefs()" Link "GetDefPrefs()"}, @{"GetPrefs()" Link "GetPrefs()"}
@EndNode
@Node "SetPubScreenModes()" "intuition.library/SetPubScreenModes"
@{b}@{u}SetPubScreenModes@{uu}@{ub} -- Establish global public screen behavior.(V36)
Sets GLOBAL Intuition public screen modes.
SYNOPSIS  UWORD SetPubScreenModes( UWORD );
  @{i}@{b}OldModes@{ub}@{ui} = SetPubScreenModes( @{i}Modes@{ui} )
   D0                            D0
  @{i}Modes@{ui} = new global modes flags.Values for flag bits are:
    @{b}SHANGHAI@{ub}: workbench windows are to be opened on the default public screen
    @{b}POPPUBSCREEN@{ub}: when a visitor window is opened, the public screen it opens on
    is to be brought to the front.
  @{i}@{b}OldModes@{ub}@{ui} = previous global mode settings
SEE ALSO
  @{"OpenScreen()" Link "OpenScreen()"}, Intuition V36 update documentation 
@EndNode
@Node "SetWindowPointerA()" "intuition.library/SetWindowPointerA"
@{b}@{u}SetWindowPointerA@{uu}@{ub} -- Select a pointer for your window.(V39)
@{b}@{u}SetWindowPointer@{uu}@{ub}  -- Varargs stub for SetWindowPointerA().(V39)
  Allows you to set the pointer image associated with the
  specified window.Whenever the window is the active one,
  the pointer image will change to the window's version.
  If the window is the active one when this routine is
  called, the change takes place immediately.
SYNOPSIS
  @{FG shine}void@{FG text} SetWindowPointerA( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} * );
  @{FG shine}void@{FG text} SetWindowPointer( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, ULONG tag1, ...);
  SetWindowPointerA( @{i}window@{ui}, @{i}taglist@{ui} )
                      A0      A1
  SetWindowPointer ( @{i}window@{ui}, @{i}tag1@{ui}, ...)
  @{i}window@{ui} = pointer to the window to receive this pointer definition
  @{i}taglist@{ui} = pointer to a taglist describing your pointer
@{"TAGS" link SETWINDOWPOINTERA_TAGS}
EXAMPLE
  This example sets the standard busy pointer with pointer-delay,
  does a bit of work, then clears the pointer:
    /* Put up the busy pointer, with pointer-delay */
    SetWindowPointer(@{i}win@{ui},WA_BusyPointer,TRUE,WA_PointerDelay,TRUE,TAG_DONE);
    /* Do busy stuff here */
    /* No tags means "clear the pointer" */
    SetWindowPointer(@{i}win@{ui},TAG_DONE);
SEE ALSO
  @{"SetPointer()" Link "SetPointer()"}, @{"ClearPointer()" Link "ClearPointer()"}, ROM Kernel Manual: Libraries
@EndNode
@node SETWINDOWPOINTERA_TAGS "SetWindowPointerA_tags"
The same three tags are also accepted by @{"OpenWindowTagList()" Link "OpenWindowTagList()"}, which allows
you to establish the initial pointer at the time you open your window.
@{i}@{b}WA_Pointer@{ub}@{ui} (APTR) - The pointer you wish to associate with your window.
  If NULL, you are requesting the Preferences default pointer.Custom pointers
  should be allocated by performing a @{"NewObject()" Link "NewObject()"} on "pointerclass".
  (See <intuition/pointerclass.h>).Defaults to NULL.
@{i}@{b}WA_BusyPointer@{ub}@{ui} (BOOL) - Set to TRUE to request the Preferences busy-pointer.
  If FALSE, your pointer will be as requested by WA_Pointer.Defaults to FALSE.
@{i}@{b}WA_PointerDelay@{ub}@{ui} (BOOL) - Set to TRUE to defer changing your pointer for a
  brief instant.This is typically used along with setting the busy pointer,
  especially when the application knows it may be busy for a very short while.
  If the application clears the pointer or sets another pointer before
  the delay expires, the pending pointer change is cancelled.
  This reduces short flashes of the busy pointer.
@endnode
@Node "SetWindowTitles()" "intuition.library/SetWindowTitles"
@{b}@{u}SetWindowTitles@{uu}@{ub} -- Set the window's titles for both window and screen.
  Allows you to set the text which appears in the Window and/or Screen
  title bars.The window title appears at all times along the window title bar.
  The window's screen title appears at the screen title bar whenever
  this window is the active one.
  When this routine is called, your window title will be changed 
  immediately.If your window is the active one when this routine is
  called, the screen title will be changed immediately.
  You can specify a value of -1 (i.e.(UBYTE *) ~0) for either of
  the title pointers.This designates that you want Intuition to leave
  the current setting of that particular title alone, and modify
  only the other one.Of course, you could set both to -1.
  Furthermore, you can set a value of 0 (zero) for either of the
  title pointers.Doing so specifies that you want no title to
  appear (the title bar will be blank).
  Both of the titles are rendered in the default font of the window's
  screen, as set using @{"OpenScreen()" Link "OpenScreen()"}.
  In setting the window's title, Intuition may do some other rendering
  in the top border of your window.If your own rendering sometimes
  appears in your window border areas, you may want to restore the entire
  window border frame.The function SetWindowTitles() does not do this
  in the newer versions.The function @{"RefreshWindowFrame()" Link "RefreshWindowFrame()"} is provided
  to do this kind of thing for you.
SYNOPSIS  @{FG shine}void@{FG text} SetWindowTitles( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, UBYTE *, UBYTE * );
  SetWindowTitles( @{i}Window@{ui}, @{i}WindowTitle@{ui}, @{i}ScreenTitle@{ui} )
                    A0      A1            A2
  @{i}Window@{ui} = pointer to your window structure
  @{i}WindowTitle@{ui} = pointer to a null-terminated text string, or set to
    either the value of -1 (negative one) or 0 (zero)
  @{i}ScreenTitle@{ui} = pointer to a null-terminated text string, or set to
    either the value of -1 (negative one) or 0 (zero)
SEE ALSO
  @{"OpenWindow()" Link "OpenWindow()"}, @{"RefreshWindowFrame()" Link "RefreshWindowFrame()"}, @{"OpenScreen()" Link "OpenScreen()"}
@EndNode
@Node "ShowTitle()" "intuition.library/ShowTitle"
@{b}@{u}ShowTitle@{uu}@{ub} -- Set the screen title bar display mode.
  This routine sets the @{i}SHOWTITLE@{ui} flag of the specified screen, and
  then coordinates the redisplay of the screen and its windows.
  The screen title bar can appear either in front of or behind
  @{i}WFLG_BACKDROP@{ui} windows.This is contrasted with the fact that
  non-@{i}WFLG_BACKDROP@{ui} windows always appear in front of the screen title
  bar.You specify whether you want the screen title bar to be in front
  of or behind the screen's @{i}WFLG_BACKDROP@{ui} windows by calling this routine.
  The ShowIt argument should be set to either TRUE or FALSE.If TRUE,
  the screen's title bar will be shown in front of @{i}WFLG_BACKDROP@{ui} windows.
  If FALSE, the title bar will be rendered behind all windows. When a screen
  is first opened, the default setting of the @{i}SHOWTITLE@{ui} flag is TRUE.
SYNOPSIS  @{FG shine}void@{FG text} ShowTitle( @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} *, BOOL );
  ShowTitle( @{i}Screen@{ui}, @{i}ShowIt@{ui} )
              A0      D0
  @{i}Screen@{ui} = pointer to a Screen structure
  @{i}ShowIt@{ui} = Boolean TRUE or FALSE describing whether to show or hide the
   screen title bar
@EndNode
@Node "SizeWindow()" "intuition.library/SizeWindow"
@{b}@{u}SizeWindow@{uu}@{ub} -- Ask Intuition to size a window.
  This routine sends a request to Intuition asking to size the window 
  the specified amounts.The delta arguments describe how much to
  size the window along the respective axes.
  Note that the window will not be sized immediately, but rather 
  will be sized the next time Intuition receives an input event, 
  which happens currently at a minimum rate of ten times per second,
  and a maximum of sixty times a second.You can discover when
  you window has finally been sized by setting the @{i}IDCMP_NEWSIZE@{ui} flag
  of the IDCMP of your window.See the "Input and Output Methods"
  chapter of The Intuition Reference Manual for description of the IDCMP.
  @{i}New for V36@{ui}: Intuition now will do validity checking on the final
  dimensions.To change to new absolute dimensions, or to move and
  size a window in one step, use @{"ChangeWindowBox()" Link "ChangeWindowBox()"}.
  However, limit checking against window MinWidth, MinHeight, MaxWidth, and
  MaxHeight was not done prior to V36, and these fields are still ignored
  (as documented) if you have no sizing gadget (@{i}WFLG_SIZEGADGET@{ui} is not set).
  They *are* respected now (V36) if @{i}WFLG_SIZEGADGET@{ui} is set.
  @{i}New for V36@{ui}: you can determine when the change in size has
  taken effect by receiving the @{i}IDCMP_CHANGEWINDOW@{ui} IDCMP message.
SYNOPSIS  @{FG shine}void@{FG text} SizeWindow( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, WORD, WORD );
  SizeWindow( @{i}Window@{ui}, @{i}DeltaX@{ui}, @{i}DeltaY@{ui} )
               A0      D0      D1
  @{i}Window@{ui} = pointer to the structure of the window to be sized
  @{i}DeltaX@{ui} = signed value describing how much to size the window on the x-axis
  @{i}DeltaY@{ui} = signed value describing how much to size the window on the y-axis
SEE ALSO
  @{"ChangeWindowBox()" Link "ChangeWindowBox()"}, @{"MoveWindow()" Link "MoveWindow()"}, @{"WindowToFront()" Link "WindowToFront()"}, @{"WindowToBack()" Link "WindowToBack()"}
@EndNode
@Node "SysReqHandler()" "intuition.library/SysReqHandler"
@{b}@{u}SysReqHandler@{uu}@{ub} -- Handle system requester input.(V36)
  Handles input for a window returned by either @{"BuildSysRequest()" Link "BuildSysRequest()"} or
  BuildEasyRequest().These functions with SysReqHandler() you can perform an
  "asynchronous" EasyRequest() or @{"AutoRequest()" Link "AutoRequest()"}.That is to say, you can perform
  other processing while you wait for the requester to be satisfied.Each time
  this function is called, it will process all IDCMPMessages that the window
  has received.If the parameter 'WaitInput' is non-zero, SysReqHandler() will
  wait for input (by calling @{"WaitPort()" Link "exec.guide/WaitPort()"}) if there are no IDCMP messages.
  SysReqHandler() returns the same values as EasyRequest(): A gadget ID greater
  than equal to 0, and  -1 if one of the other IDCMP events were received.
  An additional value of -2 is returned if the input processed does not satisfy
  the requester.In this case, you might perform some processing and call
  SysReqHandler() again.
SYNOPSIS  @{FG shine}long@{FG text} SysReqHandler( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, ULONG *, BOOL );
  @{i}@{b}num@{ub}@{ui} = SysReqHandler( @{i}Window@{ui}, @{i}IDCMPFlagsPtr@{ui}, @{i}WaitInput@{ui} )
   D0                   A0       A1             D0
  @{i}Window@{ui} = Window pointer returned from @{"BuildSysRequest()" Link "BuildSysRequest()"} or BuildEasyRequest().
    Those functions can also return values '0' or '1', and these values may also
    be passed to SysReqHandler(), which will immediately return the same value.
  @{i}IDCMPFlagsPtr@{ui} = If you passed application specific IDCMP flags to
    @{"BuildSysRequest()" Link "BuildSysRequest()"} or BuildEasyRequest(),
    SysReqHandler() will return -1 if that IDCMP message is received.
    If IDCMPFlagsPtr is non-null, it points to a ULONG where the IDCMP class
    received will be copied for your examination.This pointer can be NULL if
    you have provided no application specific IDCMP flags or if you do not need
    to know which application specific IDCMP  event occurred.If you provide more
    than on flag in the flags variable this pointer points to, you will have to
    refresh the variable whenever -1 is returned, since the variable will have
    been changed to show just the single IDCMP Class bit that caused the return.
  @{i}WaitInput@{ui} = Specifies that you want SysReqHandler() to wait for IDCMP input
    if there is none pending.
  @{i}0, 1, ..., N@{ui} = Successive GadgetID values, for the gadgets you specify
    for the requester.
    @{i}NOTE@{ui}: The numbering from left to right is actually: 1, 2, ..., N, 0.
    This is for compatibility with AutoRequests which has FALSE for the
    rightmost gadget.
  @{i}-1@{ui} = Means that one of the caller-supplied IDCMPFlags occurred.
    The IDCMPFlag value is in the longword pointed to by UDCMP_ptr.
  @{i}-2@{ui} = input processed did not satisfy the requester.
    One example is a keystroke that does not satisfy the requester.
    Another example is if there is no input pending and you specified FALSE
    for WaitInput.
NOTE
  This function does @{b}NOT@{ub} terminate the system request.
  Not only must you call @{"FreeSysRequest()" Link "FreeSysRequest()"} to eliminate the request,
  but you may also continue processing after an event which would
  normally terminate a normal call to EasyRequest().
EXAMPLE
  Implementation of EasyRequest() input loop:
  @{i}window@{ui} = BuildEasyRequest( ...)
  @{FG shine}while@{FG text} ( (retval = SysReqHandler( @{i}window@{ui}, @{i}idcmp_ptr@{ui}, TRUE )) == -2 )
  {
      /* loop */;
  }
  FreeSysRequest( @{i}window@{ui} );
EXAMPLE
  Request a volume, but don't remove the requester when the user inserts
  the wrong disk:
  @{FG shine}struct@{FG text} @{"EasyStruct" Link "include:intuition/intuition.h/Main" 1455} @{i}volumeES@{ui} = {
    @{FG shine}sizeof@{FG text} (@{FG shine}struct@{FG text} EasyStruct),
    0,
    "Volume Request",
    "Please insert volume %s in any drive.",
    "Cancel"
  };
  Volume *
  getVolume( @{i}volname@{ui} )
  UBYTE *@{i}volname@{ui};
  {
    @{FG shine}struct@{FG text} Window *@{i}window@{ui};
    Volume *@{i}volume@{ui} = NULL;
    Volume *findVolume();
    @{FG shine}int@{FG text}    @{i}retval@{ui};
    @{i}window@{ui} = BuildEasyRequest( NULL, @{i}&volumeES@{ui}, IDCMP_DISKINSERTED, @{i}volname@{ui} );
    @{FG shine}while@{FG text} ( (@{i}retval@{ui} = SysReqHandler( @{i}window@{ui}, NULL, TRUE )) != 0 )
    {
      /* not cancelled yet  */
      /* when IDCMP_DISKINSERTED, check for volume */
      @{FG shine}if@{FG text} (( @{i}retval@{ui} == -1 ) && (@{i}volume@{ui} = findVolume( @{i}volname@{ui} )))
      @{FG shine}break@{FG text};
    }
    FreeSysRequest( @{i}window@{ui} );
    @{FG shine}return@{FG text} ( @{i}volume@{ui} );
  }
SEE ALSO
  @{"exec.library/WaitPort()" Link "exec.guide/WaitPort()"}
@EndNode
@Node "TimedDisplayAlert()" "intuition.library/TimedDisplayAlert"
@{b}@{u}TimedDisplayAlert@{uu}@{ub} -- Display an alert with automatic time-out.(V39)
  This function is equivalent to @{"DisplayAlert()" Link "DisplayAlert()"}, except that if
  the user fails to respond in a given time, the alert comes down automatically.
  See the autodoc for @{"DisplayAlert()" Link "DisplayAlert()"} for full details.
SYNOPSIS  BOOL TimedDisplayAlert( ULONG, UBYTE *, UWORD, ULONG );
  @{i}@{b}Response@{ub}@{ui} = TimedDisplayAlert( @{i}AlertNumber@{ui}, @{i}String@{ui}, @{i}Height@{ui}, @{i}Time@{ui} )
   D0                            D0           A0       D1      A1
  @{i}AlertNumber@{ui} = the number of this alert message.The only pertinent
    bits of this number are the @{i}ALERT_TYPE@{ui} bit(s).The rest of the
    number is ignored by this routine.
  @{i}String@{ui} = pointer to the alert message string, as described above
  @{i}Height@{ui} = minimum display lines required for your message
  @{i}Time@{ui} = length of time the alert should wait for the user to respond.
    This time is the number of video frames the alert should remain up for.
  A BOOL value of TRUE or FALSE.If this is a @{i}DEADEND_ALERT@{ui}, FALSE
  is always the return value.If this is a @{i}RECOVERY_ALERT@{ui}.The return
  value will be TRUE if the user presses the left mouse button in 
  response to your message, and FALSE if the user presses the right hand 
  button is response to your text, or if the alert could not
  be posted.If the alert times out, the return value will be FALSE.
SEE ALSO
  @{"DisplayAlert()" Link "DisplayAlert()"} 
@EndNode
@Node "UnlockIBase()" "intuition.library/UnlockIBase"
@{b}@{u}UnlockIBase@{uu}@{ub} -- Surrender an Intuition lock gotten by @{"LockIBase()" Link "LockIBase()"}.
  Surrenders lock gotten by @{"LockIBase()" Link "LockIBase()"}.
  Calling this function when you do not own the specified lock will
  immediately crash the system.
  The value returned by @{"LockIBase()" Link "LockIBase()"} should be passed to this function,
  to specify which internal lock is to be freed.
  Note that the parameter is passed in A0, not D0, for historical reasons.
SYNOPSIS  @{FG shine}void@{FG text} UnlockIBase( ULONG );
  UnlockIBase( @{i}Lock@{ui} )
                A0
SEE ALSO
  @{"LockIBase()" Link "LockIBase()"}
@EndNode
@Node "UnlockPubScreen()" "intuition.library/UnlockPubScreen"
@{b}@{u}UnlockPubScreen@{uu}@{ub} -- Release lock on a public screen.(V36)
  Releases lock gotten by @{"LockPubScreen()" Link "LockPubScreen()"}.
  It is best to identify the locked public screen by
  the pointer returned from @{"LockPubScreen()" Link "LockPubScreen()"}.To do this,
  supply a NULL 'Name' pointer and the screen pointer.
  In rare circumstances where it would be more convenient to pass a non-NULL
  pointer to the public screen name string, the 'Screen' parameter is ignored.
SYNOPSIS  @{FG shine}void@{FG text} UnlockPubScreen( UBYTE *, @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} * );
  UnlockPubScreen( @{i}Name@{ui}, [@{i}Screen@{ui}] )
                    A0     A1
  @{i}Name@{ui} = pointer to name of public screen.If Name is NULL,
    then argument 'Screen' is used as a direct pointer to a public screen.
  @{i}Screen@{ui} = pointer to a public screen.Used only if Name is NULL.
    This pointer @{b}MUST@{ub} have been returned by @{"LockPubScreen()" Link "LockPubScreen()"}.It is safe
    to call UnlockPubScreen() with NULL Name and Screen
    (the function will have no effect).
SEE ALSO
  @{"LockPubScreen()" Link "LockPubScreen()"}
@EndNode
@Node "UnlockPubScreenList()" "intuition.library/UnlockPubScreenList"
@{b}@{u}UnlockPubScreenList@{uu}@{ub} -- Release public screen list semaphore.(V36)
  Releases lock gotten by @{"LockPubScreenList()" Link "LockPubScreenList()"}.
SYNOPSIS  @{FG shine}void@{FG text} UnlockPubScreenList( @{FG shine}void@{FG text} );
  UnlockPubScreenList()
SEE ALSO
  @{"LockPubScreenList()" Link "LockPubScreenList()"}
@EndNode
@Node "ViewAddress()" "intuition.library/ViewAddress"
@{b}@{u}ViewAddress@{uu}@{ub} -- Return the address of the Intuition View structure.
  If you want to use any of the graphics, text, or animation primitives
  in your window and that primitive requires a pointer to a view,
  this routine will return the address of the view for you.
SYNOPSIS  @{FG shine}struct@{FG text} @{"View" Link "include:graphics/view.h/Main" 57} *ViewAddress( @{FG shine}void@{FG text} );
  @{i}@{b}view@{ub}@{ui} = ViewAddress()
   D0
  Returns the address of the Intuition View structure
SEE ALSO
  graphics.library
@EndNode
@Node "ViewPortAddress()" "intuition.library/ViewPortAddress"
@{b}@{u}ViewPortAddress@{uu}@{ub} -- Return the address of a window's viewport.
  Returns the address of the viewport associated with the specified
  window.The viewport is actually the viewport of the screen within
  which the window is displayed.If you want to use any of the graphics,
  text, or animation primitives in your window and that primitive
  requires a pointer to a viewport, you can use this call.
  This pointer is only valid as long as your window's screen remains
  open, which is ensured by keeping your window open.
SYNOPSIS  @{FG shine}struct@{FG text} @{"ViewPort" Link "include:graphics/view.h/Main" 40} *ViewPortAddress( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} * );
  @{i}@{b}ViewPort@{ub}@{ui} = ViewPortAddress( @{i}Window@{ui} )
   D0                          A0
  @{i}Window@{ui} = pointer to the window for which you want the viewport address
  Returns the address of the Intuition ViewPort structure for
  your window's screen .
BUGS
  This routine is unnecessary: you can just use the expression
  &Window->WScreen->@{i}ViewPort@{ui}.
SEE ALSO
  graphics.library
@EndNode
@Node "WBenchToBack()" "intuition.library/WBenchToBack"
@{b}@{u}WBenchToBack@{uu}@{ub} -- Send the Workbench screen in back of all screens.
  Causes the Workbench screen, if it's currently opened, to go behind
  all other screens.This does not 'move' the screen up or down,
  instead only affects the depth-arrangement of the screens.
SYNOPSIS  BOOL WBenchToBack( @{FG shine}void@{FG text} );
  @{i}@{b}Success@{ub}@{ui} = WBenchToBack()
   D0
  If the Workbench screen was opened, this function returns TRUE,
  otherwise it returns FALSE.
SEE ALSO
  @{"WBenchToFront()" Link "WBenchToFront()"}, @{"ScreenToFront()" Link "ScreenToFront()"}
@EndNode
@Node "WBenchToFront()" "intuition.library/WBenchToFront"
@{b}@{u}WBenchToFront@{uu}@{ub} -- Bring the Workbench screen in front of all screens.
  Causes the Workbench Screen, if it's currently opened, to come to
  the foreground.This does not 'move' the screen up or down, instead
  only affects the depth-arrangement of the screen.
SYNOPSIS  BOOL WBenchToFront( @{FG shine}void@{FG text} );
  @{i}@{b}Success@{ub}@{ui} = WBenchToFront()
   D0
  If the Workbench screen was opened, this function returns TRUE,otherwise FALSE.
SEE ALSO
  @{"WBenchToBack()" Link "WBenchToBack()"}, @{"ScreenToBack()" Link "ScreenToBack()"}
@EndNode
@Node "WindowLimits()" "intuition.library/WindowLimits"
@{b}@{u}WindowLimits@{uu}@{ub} -- Set the minimum and maximum limits of a window.
  Sets the minimum and maximum limits of the window's size.Until this
  routine is called, the window's size limits are equal to the initial
  values established in the @{"OpenWindow()" Link "OpenWindow()"} function.
  After a call to this routine, the Window will be able to be sized
  to any dimensions within the specified limits.
  If you don't want to change any one of the dimensions, set the limit
  argument for that dimension to zero.If any of the limit arguments
  is equal to zero, that argument is ignored and the initial setting
  of that parameter remains undisturbed.
  If any of the arguments is out of range (minimums greater than the
  current size, maximums less than the current size), that limit
  will be ignored, though the others will still take effect if they
  are in range.If any are out of range, the return value from this procedure
  will be FALSE.If all arguments are valid, the return value will be TRUE.
  If you want your window to be able to become "as large as possible"
  you may put -1 (i.e.~0) in either or both Max arguments.But
  please note: screen sizes may vary for several reasons, and you
  must be able to handle any possible size of window you might end
  up with if you use this method.Note that you can use the function
  @{"LockPubScreen()" Link "LockPubScreen()"} to find out how big the screen your window will
  appear in is.You may also refer to the WScreen field in your window
  structure, providing that your window remains open, which will ensure
  that the screen remains open, and thus the pointer remains valid.
  If the user is currently sizing this window, the new limits will
  not take effect until after the sizing is completed.
SYNOPSIS
  BOOL WindowLimits( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, WORD, WORD, UWORD, UWORD );
  @{i}@{b}Success@{ub}@{ui} = WindowLimits( @{i}Window@{ui}, @{i}MinWidth@{ui}, @{i}MinHeight@{ui}, @{i}MaxWidth@{ui},@{i}MaxHeight@{ui} )
   D0                      A0      D0        D1          D2       D3
  @{i}Window@{ui} = pointer to a Window structure
  @{i}MinWidth@{ui}, @{i}MinHeight@{ui}, @{i}MaxWidth@{ui}, @{i}MaxHeight@{ui} = the new limits for the size
    of this window.If any of these is set to zero, it will be ignored and that
    setting will be unchanged.
  Returns TRUE if everything was in order.If any of the parameters was
  out of range (minimums greater than current size, maximums less than
  current size), FALSE is returned and the errant limit request is
  not fulfilled (though the valid ones will be).
SEE ALSO
  @{"LockPubScreen()" Link "LockPubScreen()"}
@EndNode
@Node "WindowToBack()" "intuition.library/WindowToBack"
@{b}@{u}WindowToBack@{uu}@{ub} -- Ask Intuition to send a window behind others.
  This routine sends a request to Intuition asking to send the window 
  in back of all other windows in the screen.
  Note that the window will not be depth-arranged immediately, but rather 
  will be arranged the next time Intuition receives an input event, 
  which happens currently at a minimum rate of ten times per second,
  and a maximum of sixty times a second.
  Remember that @{i}WFLG_BACKDROP@{ui} windows cannot be depth-arranged.
SYNOPSIS  @{FG shine}void@{FG text} WindowToBack( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} * );
  WindowToBack( @{i}Window@{ui} )
                 A0
  @{i}Window@{ui} = pointer to the structure of the window to be sent to the back
SEE ALSO
  @{"MoveWindow()" Link "MoveWindow()"}, @{"SizeWindow()" Link "SizeWindow()"}, @{"WindowToFront()" Link "WindowToFront()"}, @{"MoveWindowInFrontOf()" Link "MoveWindowInFrontOf()"}
@EndNode
@Node "WindowToFront()" "intuition.library/WindowToFront"
@{b}@{u}WindowToFront@{uu}@{ub} -- Ask Intuition to bring a window to the front.
  This routine sends a request to Intuition asking to bring the window 
  in front of all other windows in the screen.
  Note that the window will not be depth-arranged immediately, but rather 
  will be arranged the next time Intuition receives an input event, 
  which happens currently at a minimum rate of ten times per second,
  and a maximum of sixty times a second.
  Remember that @{i}WFLG_BACKDROP@{ui} windows cannot be depth-arranged.
SYNOPSIS  @{FG shine}void@{FG text} WindowToFront( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} * );
  WindowToFront( @{i}Window@{ui} )
                  A0
  @{i}Window@{ui} = pointer to the structure of the window to be brought to front
SEE ALSO
  @{"MoveWindow()" Link "MoveWindow()"}, @{"SizeWindow()" Link "SizeWindow()"}, @{"WindowToBack()" Link "WindowToBack()"}, @{"MoveWindowInFrontOf()" Link "MoveWindowInFrontOf()"}
@EndNode
@Node "ZipWindow()" "intuition.library/ZipWindow"
@{b}@{u}ZipWindow@{uu}@{ub} -- Change window to "alternate" position and dimensions.(V36)
  Changes the position and dimension of a window to the values at the last
  occasion of ZipWindow being called (or invoked via the "@{i}zoom@{ui}" gadget).
  Typically this is used to snap between a normal, large, working dimension
  of the window to a smaller, more innocuous position and dimension.
  Like @{"MoveWindow()" Link "MoveWindow()"}, @{"SizeWindow()" Link "SizeWindow()"}, and @{"ChangeWindowBox()" Link "ChangeWindowBox()"}, the action of
  this function is deferred to the Intuition input handler.
  More tuning needs to be done to establish initial values for
  the first invocation of this function for a window.You can
  provide initial values using the @{"OpenWindow()" Link "OpenWindow()"} tag item @{i}WA_Zoom@{ui}.
  It could also use a new name, but "ZoomWindow" is misleading,
  since "@{i}Zoom@{ui}" normally implies "@{i}scale@{ui}."
  The zoom gadget will appear (in the place of the old "@{i}toback@{ui}" gadget) when
  you open your window if you either specify a sizing gadget or use @{i}WA_Zoom@{ui}.
  You can detect that this function has taken effect by receiving
  an @{i}IDCMP_CHANGEWINDOW@{ui} IDCMP message.
SYNOPSIS  @{FG shine}void@{FG text} ZipWindow( @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} * );
  ZipWindow( @{i}Window@{ui} )
              A0
  @{i}Window@{ui} -- window to be changed.
BUGS
  @{"OpenWindow()" Link "OpenWindow()"} assumes that the proper default "other" dimensions are
  "full size."
SEE ALSO
  @{"ChangeWindowBox()" Link "ChangeWindowBox()"}, @{"MoveWindow()" Link "MoveWindow()"}, @{"SizeWindow()" Link "SizeWindow()"}
@EndNode

