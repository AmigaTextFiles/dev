@database "exec"
@master "Work:Programing/sc/OS3.1_Docs/doc/exec.doc"
@Node Main "exec.guide"
@{b}@{u}Libraries@{uu}@{ub}:          @{b}@{u}Devices@{uu}@{ub}:          @{b}@{u}Module creation@{uu}@{ub}:  @{b}@{u}Tasks@{uu}@{ub}:        @{b}@{u}Lists@{uu}@{ub}:
@{"AddLibrary()" Link "AddLibrary()"}       @{"AddDevice()" Link "AddDevice()"}      @{"InitCode()" Link "InitCode()"}       @{"AddTask()" Link "AddTask()"}    @{"AddHead()" Link "AddHead()"}
@{"OldOpenLibrary()" Link "OldOpenLibrary()"}   @{"OpenDevice()" Link "OpenDevice()"}     @{"InitStruct()" Link "InitStruct()"}     @{"RemTask()" Link "RemTask()"}    @{"RemHead()" Link "RemHead()"}
@{"OpenLibrary()" Link "OpenLibrary()"}      @{"CreateIORequest()" Link "CreateIORequest()"}@{"InitResident()" Link "InitResident()"}   @{"StackSwap()" Link "StackSwap()"}  @{"Insert()" Link "Insert()"}
@{"CloseLibrary()" Link "CloseLibrary()"}     @{"DoIO()" Link "DoIO()"}           @{"FindResident()" Link "FindResident()"}   @{"FindTask()" Link "FindTask()"}   @{"Enqueue()" Link "Enqueue()"}
@{"RemLibrary()" Link "RemLibrary()"}       @{"SendIO()" Link "SendIO()"}         @{"MakeLibrary()" Link "MakeLibrary()"}    @{"SetTaskPri()" Link "SetTaskPri()"} @{"Remove()" Link "Remove()"}
@{"SetFunction()" Link "SetFunction()"}      @{"CheckIO()" Link "CheckIO()"}        @{"MakeFunctions()" Link "MakeFunctions()"}  @{"SetSignal()" Link "SetSignal()"}  @{"AddTail()" Link "AddTail()"}
@{"SumLibrary()" Link "SumLibrary()"}       @{"WaitIO()" Link "WaitIO()"}         @{b}@{u}Memory allocation@{uu}@{ub}:@{"SetExcept()" Link "SetExcept()"}  @{"RemTail()" Link "RemTail()"}
@{b}@{u}Interrupts@{uu}@{ub}:         @{"AbortIO()" Link "AbortIO()"}        @{"Allocate()" Link "Allocate()"}       @{"Wait()" Link "Wait()"}       @{"FindName()" Link "FindName()"}
@{"Disable()" Link "Disable()"}          @{"DeleteIORequest()" Link "DeleteIORequest()"}@{"Deallocate()" Link "Deallocate()"}     @{"Signal()" Link "Signal()"}     @{b}@{u}Task trees@{uu}@{ub}:
@{"Enable()" Link "Enable()"}           @{"CloseDevice()" Link "CloseDevice()"}    @{"AllocMem()" Link "AllocMem()"}       @{"AllocSignal()" Link "AllocSignal()"}ChildFree
@{"Forbid()" Link "Forbid()"}           @{"RemDevice()" Link "RemDevice()"}      @{"TypeOfMem()" Link "TypeOfMem()"}      @{"FreeSignal()" Link "FreeSignal()"} ChildOrphan
@{"Permit()" Link "Permit()"}           @{b}@{u}Messages@{uu}@{ub}:         @{"AllocAbs()" Link "AllocAbs()"}       @{"AllocTrap()" Link "AllocTrap()"}  ChildStatus
@{"SetSR()" Link "SetSR()"}            @{"CreateMsgPort()" Link "CreateMsgPort()"}  @{"FreeMem()" Link "FreeMem()"}        @{"FreeTrap()" Link "FreeTrap()"}   ChildWait
@{"Supervisor()" Link "Supervisor()"}       @{"AddPort()" Link "AddPort()"}        @{"AvailMem()" Link "AvailMem()"}
@{"SuperState()" Link "SuperState()"}       @{"PutMsg()" Link "PutMsg()"}         @{"AllocEntry()" Link "AllocEntry()"}
@{"UserState()" Link "UserState()"}        @{"GetMsg()" Link "GetMsg()"}         @{"FreeEntry()" Link "FreeEntry()"}
@{"AddIntServer()" Link "AddIntServer()"}     @{"ReplyMsg()" Link "ReplyMsg()"}       @{b}@{u}Pool LVOs@{uu}@{ub}:            @{"same, but sorted" link SORTED}
@{"SetIntVector()" Link "SetIntVector()"}     @{"WaitPort()" Link "WaitPort()"}       @{"CreatePool()" Link "CreatePool()"}
@{"ObtainQuickVector()" Link "ObtainQuickVector()"}@{"FindPort()" Link "FindPort()"}       @{"AllocPooled()" Link "AllocPooled()"}
@{"RemIntServer()" Link "RemIntServer()"}     @{"RemPort()" Link "RemPort()"}        @{"FreePooled()" Link "FreePooled()"}
@{"Cause()" Link "Cause()"}            @{"DeleteMsgPort()" Link "DeleteMsgPort()"}  @{"DeletePool()" Link "DeletePool()"}
@{b}@{u}Semaphores@{uu}@{ub}:               @{b}@{u}Memory support@{uu}@{ub}:      @{"--Overview--" Link "--Overview--"}
@{"AddSemaphore()" Link "AddSemaphore()"}           @{"AddMemList()" Link "AddMemList()"}        @{"ALLOCATE_MEMORY" Link "ALLOCATE_MEMORY"}
@{"InitSemaphore()" Link "InitSemaphore()"}          @{"CopyMem()" Link "CopyMem()"}           @{"CALL_ADDRESS" Link "CALL_ADDRESS"}
@{"FindSemaphore()" Link "FindSemaphore()"}          @{"CopyMemQuick()" Link "CopyMemQuick()"}      @{"FREE_MEMORY" Link "FREE_MEMORY"}
@{"ObtainSemaphore()" Link "ObtainSemaphore()"}        @{"AllocVec()" Link "AllocVec()"}          @{"GET_CONTEXT_FRAME" Link "GET_CONTEXT_FRAME"}
@{"ObtainSemaphoreList()" Link "ObtainSemaphoreList()"}    @{"FreeVec()" Link "FreeVec()"}           @{"NOP" Link "NOP"}
@{"ObtainSemaphoreShared()" Link "ObtainSemaphoreShared()"}  @{b}@{u}Low memory handlers@{uu}@{ub}: @{"READ_ARRAY" Link "READ_ARRAY"}
@{"Procure()" Link "Procure()"}                @{"AddMemHandler()" Link "AddMemHandler()"}     @{"READ_BYTE" Link "READ_BYTE"}
@{"Vacate()" Link "Vacate()"}                 @{"RemMemHandler()" Link "RemMemHandler()"}     @{"READ_LONG" Link "READ_LONG"}
@{"AttemptSemaphore()" Link "AttemptSemaphore()"}       @{b}@{u}Kickmem support@{uu}@{ub}:     @{"READ_WORD" Link "READ_WORD"}
@{"AttemptSemaphoreShared()" Link "AttemptSemaphoreShared()"} @{"SumKickData()" Link "SumKickData()"}       @{"RESET" Link "RESET"}
@{"ReleaseSemaphore()" Link "ReleaseSemaphore()"}       @{b}@{u}Cache@{uu}@{ub}:               @{"RETURN_TO_SYSTEM" Link "RETURN_TO_SYSTEM"}
@{"ReleaseSemaphoreList()" Link "ReleaseSemaphoreList()"}   @{"CacheClearU()" Link "CacheClearU()"}       @{"TURN_OFF_SINGLE" Link "TURN_OFF_SINGLE"}
@{"RemSemaphore()" Link "RemSemaphore()"}           @{"CacheClearE()" Link "CacheClearE()"}       @{"TURN_ON_SINGLE" Link "TURN_ON_SINGLE"}
@{b}@{u}Resources@{uu}@{ub}:                @{"CacheControl()" Link "CacheControl()"}      @{"WRITE_ARRAY" Link "WRITE_ARRAY"}
@{"AddResource()" Link "AddResource()"}            @{"CachePreDMA()" Link "CachePreDMA()"}       @{"WRITE_BYTE" Link "WRITE_BYTE"}
@{"OpenResource()" Link "OpenResource()"}           @{"CachePostDMA()" Link "CachePostDMA()"}      @{"WRITE_LONG" Link "WRITE_LONG"}
@{"RemResource()" Link "RemResource()"}            @{b}@{u}Misc@{uu}@{ub}:                @{"WRITE_WORD" Link "WRITE_WORD"}
@{b}@{u}Diagnostics@{uu}@{ub}:              @{"RawDoFmt()" Link "RawDoFmt()"}
@{"Alert()" Link "Alert()"}                  @{"GetCC()" Link "GetCC()"}
@{"Debug()" Link "Debug()"}                  @{"ColdReboot()" Link "ColdReboot()"}
@EndNode
@node SORTED "sorted"
@{"AbortIO()" Link "AbortIO()"}
@{"AddDevice()" Link "AddDevice()"}
@{"AddHead()" Link "AddHead()"}
@{"AddIntServer()" Link "AddIntServer()"}
@{"AddLibrary()" Link "AddLibrary()"}
@{"AddMemHandler()" Link "AddMemHandler()"}
@{"AddMemList()" Link "AddMemList()"}
@{"AddPort()" Link "AddPort()"}
@{"AddResource()" Link "AddResource()"}
@{"AddSemaphore()" Link "AddSemaphore()"}
@{"AddTail()" Link "AddTail()"}
@{"AddTask()" Link "AddTask()"}
@{"Alert()" Link "Alert()"}
@{"AllocAbs()" Link "AllocAbs()"}
@{"Allocate()" Link "Allocate()"}
@{"AllocEntry()" Link "AllocEntry()"}
@{"AllocMem()" Link "AllocMem()"}
@{"AllocPooled()" Link "AllocPooled()"}
@{"AllocSignal()" Link "AllocSignal()"}
@{"AllocTrap()" Link "AllocTrap()"}
@{"AllocVec()" Link "AllocVec()"}
@{"AttemptSemaphore()" Link "AttemptSemaphore()"}
@{"AttemptSemaphoreShared()" Link "AttemptSemaphoreShared()"}
@{"AvailMem()" Link "AvailMem()"}
@{"CacheClearE()" Link "CacheClearE()"}
@{"CacheClearU()" Link "CacheClearU()"}
@{"CacheControl()" Link "CacheControl()"}
@{"CachePreDMA()" Link "CachePreDMA()"}
@{"CachePostDMA()" Link "CachePostDMA()"}
ChildFree
ChildOrphan
ChildStatus
ChildWait
@{"ColdReboot()" Link "ColdReboot()"}
@{"Cause()" Link "Cause()"}
@{"CheckIO()" Link "CheckIO()"}
@{"CloseDevice()" Link "CloseDevice()"}
@{"CloseLibrary()" Link "CloseLibrary()"}
@{"CopyMem()" Link "CopyMem()"}
@{"CopyMemQuick()" Link "CopyMemQuick()"}
@{"CreateIORequest()" Link "CreateIORequest()"}
@{"CreateMsgPort()" Link "CreateMsgPort()"}
@{"CreatePool()" Link "CreatePool()"}
@{"Deallocate()" Link "Deallocate()"}
@{"Debug()" Link "Debug()"}
@{"DeleteIORequest()" Link "DeleteIORequest()"}
@{"DeleteMsgPort()" Link "DeleteMsgPort()"}
@{"DeletePool()" Link "DeletePool()"}
@{"Disable()" Link "Disable()"}
@{"DoIO()" Link "DoIO()"}
@{"Enable()" Link "Enable()"}
@{"Enqueue()" Link "Enqueue()"}
@{"FindName()" Link "FindName()"}
@{"FindResident()" Link "FindResident()"}
@{"FindPort()" Link "FindPort()"}
@{"FindSemaphore()" Link "FindSemaphore()"}
@{"FindTask()" Link "FindTask()"}
@{"Forbid()" Link "Forbid()"}
@{"FreeEntry()" Link "FreeEntry()"}
@{"FreeMem()" Link "FreeMem()"}
@{"FreePooled()" Link "FreePooled()"}
@{"FreeSignal()" Link "FreeSignal()"}
@{"FreeTrap()" Link "FreeTrap()"}
@{"FreeVec()" Link "FreeVec()"}
@{"GetCC()" Link "GetCC()"}
@{"GetMsg()" Link "GetMsg()"}
@{"InitCode()" Link "InitCode()"}
@{"InitResident()" Link "InitResident()"}
@{"InitSemaphore()" Link "InitSemaphore()"}
@{"InitStruct()" Link "InitStruct()"}
@{"Insert()" Link "Insert()"}
@{"MakeFunctions()" Link "MakeFunctions()"}
@{"MakeLibrary()" Link "MakeLibrary()"}
@{"ObtainQuickVector()" Link "ObtainQuickVector()"}
@{"ObtainSemaphore()" Link "ObtainSemaphore()"}
@{"ObtainSemaphoreList()" Link "ObtainSemaphoreList()"}
@{"ObtainSemaphoreShared()" Link "ObtainSemaphoreShared()"}
@{"OldOpenLibrary()" Link "OldOpenLibrary()"}
@{"OpenDevice()" Link "OpenDevice()"}
@{"OpenLibrary()" Link "OpenLibrary()"}
@{"OpenResource()" Link "OpenResource()"}
@{"Permit()" Link "Permit()"}
@{"Procure()" Link "Procure()"}
@{"PutMsg()" Link "PutMsg()"}
@{"ReleaseSemaphore()" Link "ReleaseSemaphore()"}
@{"ReleaseSemaphoreList()" Link "ReleaseSemaphoreList()"}
@{"RawDoFmt()" Link "RawDoFmt()"}
@{"RemHead()" Link "RemHead()"}
@{"RemDevice()" Link "RemDevice()"}
@{"RemIntServer()" Link "RemIntServer()"}
@{"RemLibrary()" Link "RemLibrary()"}
@{"RemMemHandler()" Link "RemMemHandler()"}
@{"Remove()" Link "Remove()"}
@{"RemPort()" Link "RemPort()"}
@{"RemResource()" Link "RemResource()"}
@{"RemSemaphore()" Link "RemSemaphore()"}
@{"RemTail()" Link "RemTail()"}
@{"RemTask()" Link "RemTask()"}
@{"ReplyMsg()" Link "ReplyMsg()"}      
@{"SendIO()" Link "SendIO()"}
@{"SetExcept()" Link "SetExcept()"}
@{"SetFunction()" Link "SetFunction()"}
@{"SetIntVector()" Link "SetIntVector()"}
@{"SetSignal()" Link "SetSignal()"}
@{"SetSR()" Link "SetSR()"}
@{"SetTaskPri()" Link "SetTaskPri()"}
@{"Signal()" Link "Signal()"}
@{"StackSwap()" Link "StackSwap()"}
@{"SumKickData()" Link "SumKickData()"}
@{"SumLibrary()" Link "SumLibrary()"}
@{"SuperState()" Link "SuperState()"}
@{"Supervisor()" Link "Supervisor()"}
@{"TypeOfMem()" Link "TypeOfMem()"}
@{"UserState()" Link "UserState()"}
@{"Vacate()" Link "Vacate()"}
@{"Wait()" Link "Wait()"}
@{"WaitIO()" Link "WaitIO()"}
@{"WaitPort()" Link "WaitPort()"}

@{"--Overview--" Link "--Overview--"}
@{"ALLOCATE_MEMORY" Link "ALLOCATE_MEMORY"}
@{"CALL_ADDRESS" Link "CALL_ADDRESS"}
@{"FREE_MEMORY" Link "FREE_MEMORY"}
@{"GET_CONTEXT_FRAME" Link "GET_CONTEXT_FRAME"}
@{"NOP" Link "NOP"}
@{"READ_ARRAY" Link "READ_ARRAY"}
@{"READ_BYTE" Link "READ_BYTE"}
@{"READ_LONG" Link "READ_LONG"}
@{"READ_WORD" Link "READ_WORD"}
@{"RESET" Link "RESET"}
@{"RETURN_TO_SYSTEM" Link "RETURN_TO_SYSTEM"}
@{"TURN_ON_SINGLE" Link "TURN_ON_SINGLE"}
@{"TURN_OFF_SINGLE" Link "TURN_OFF_SINGLE"}
@{"WRITE_ARRAY" Link "WRITE_ARRAY"}
@{"WRITE_BYTE" Link "WRITE_BYTE"}
@{"WRITE_LONG" Link "WRITE_LONG"}
@{"WRITE_WORD" Link "WRITE_WORD"}
@endnode
@Node "AbortIO()" "exec.library/AbortIO"
@{b}@{u}AbortIO@{uu}@{ub} - attempt to abort an in-progress I/O request.
  Ask a device to abort a previously started IORequest.This is done
  by calling the device's ABORTIO vector, with your given IORequest.
  AbortIO is a command the device that may or may not grant.If
  successful, the device will stop processing the IORequest, and
  reply to it earlier than it would otherwise have done.
SYNOPSIS  @{FG shine}void@{FG text} AbortIO(@{FG shine}struct@{FG text} @{"IORequest" Link "include:exec/io.h/Main" 18} *);
  AbortIO(@{i}iORequest@{ui})
           A1
  @{i}iORequest@{ui} - pointer to an I/O request block (must have been used at least once.
    May be active or finished).
NOTE
  AbortIO() does NOT @{"Remove()" Link "Remove()"} the IORequest from your ReplyPort, OR wait for it
  to complete.After an AbortIO() you must wait normally for the reply message
  before actually reusing the request.
  If a request has already completed when AbortIO() is called, no action is taken.
EXAMPLE
  AbortIO(timer_request);
  WaitIO(timer_request);
  /* @{"Message" Link "include:exec/ports.h/Main" 48} is free to be reused */
SEE ALSO
  @{"WaitIO" Link "WaitIO()"}, @{"DoIO" Link "DoIO()"}, @{"SendIO" Link "SendIO()"}, @{"CheckIO" Link "CheckIO()"}
@EndNode
@Node "AddDevice()" "exec.library/AddDevice"
@{b}@{u}AddDevice@{uu}@{ub} -- add a device to the system.
  This function adds a new device to the system device list, making it available
  to other programs.The device must be ready to be opened at this time.
SYNOPSIS  @{FG shine}void@{FG text} AddDevice(@{FG shine}struct@{FG text} @{"Device" Link "include:exec/devices.h/Main" 25} *);
  AddDevice(@{i}device@{ui})
             A1
  @{i}device@{ui} - pointer to a properly initialized device node
SEE ALSO
  @{"RemDevice" Link "RemDevice()"}, @{"OpenDevice" Link "OpenDevice()"}, @{"CloseDevice" Link "CloseDevice()"}, @{"MakeLibrary" Link "MakeLibrary()"}
@EndNode
@Node "AddHead()" "exec.library/AddHead"
@{b}@{u}AddHead@{uu}@{ub} -- insert node at the head of a list.
  Add a node to the head of a doubly linked list.Assembly
  programmers may prefer to use the ADDHEAD macro from "exec/lists.i".
SYNOPSIS  @{FG shine}void@{FG text} AddHead(@{FG shine}struct@{FG text} @{"List" Link "include:exec/lists.h/Main" 20} *, @{FG shine}struct@{FG text} @{"Node" Link "include:exec/nodes.h/Main" 22} *)
  AddHead(@{i}list@{ui}, @{i}node@{ui})
           A0    A1
  @{i}list@{ui} - a pointer to the target list header
  @{i}node@{ui} - the node to insert at head
@{b}WARNING@{ub}
  This function does not arbitrate for access to the list.
  The calling task must be the owner of the involved list.
SEE ALSO
  @{"AddTail" Link "AddTail()"}, @{"Enqueue" Link "Enqueue()"}, Insert, Remove, @{"RemHead" Link "RemHead()"}, @{"RemTail" Link "RemTail()"}
@EndNode
@Node "AddIntServer()" "exec.library/AddIntServer"
@{b}@{u}AddIntServer@{uu}@{ub} -- add an interrupt server to a system server chain.
  This function adds a new interrupt server to a given server chain.
  The node is located on the chain in a priority dependent position.
  If this is the first server on a particular chain, interrupts will
  be enabled for that chain.
  Each link in the chain will be called in priority order until the
  chain ends or one of the servers returns with the 68000's Z condition
  code clear (indicating non-zero).Servers on the chain should return
  with the Z flag clear if the interrupt was specifically for that
  server, and no one else.VERTB servers should always return Z set.
  (Take care with High Level Language servers, the language may not
  have a mechanism for reliably setting the Z flag on exit).
  Servers are called with the following register conventions:
    D0 - scratch
    D1 - scratch
    A0 - scratch
    A1 - server is_Data pointer (scratch)
    A5 - jump vector register (scratch)
    A6 - scratch
    all other registers must be preserved
SYNOPSIS  @{FG shine}void@{FG text} AddIntServer(ULONG, @{FG shine}struct@{FG text} @{"Interrupt" Link "include:exec/interrupts.h/Main" 23} *);
  AddIntServer(@{i}intNum@{ui}, @{i}interrupt@{ui})
                D0-0:4  A1
  @{i}intNum@{ui} - the Paula interrupt bit number (0 through 14).
    Processor level seven interrupts (NMI) are encoded as intNum 15.
    The PORTS,COPER,VERTB,EXTER and NMI interrupts are set up as server chains.
  @{i}interrupt@{ui} - pointer to an Interrupt structure.
    By convention,the LN_NAME of the interrupt structure must point a
    descriptive string so that other users may identify who currently
    has control of the interrupt.
@{b}WARNING@{ub}
  Some compilers or assemblers may optimize code in unexpected ways,
  affecting the conditions codes returned from the function.Watch
  out for a "MOVEM" instruction (which does not affect the condition
  codes) turning into "MOVE" (which does).
BUGS
  The graphics library's VBLANK server, and some user code, currently
  assume that address register A0 will contain a pointer to the custom
  chips.If you add a server at a priority of 10 or greater, you must
  compensate for this by providing the expected value ($DFF000).
SEE ALSO
  @{"RemIntServer" Link "RemIntServer()"}, @{"SetIntVector" Link "SetIntVector()"}, hardware/intbits.i,exec/interrupts.i
@EndNode
@Node "AddLibrary()" "exec.library/AddLibrary"
@{b}@{u}AddLibrary@{uu}@{ub} -- add a library to the system.
  This function adds a new library to the system, making it available
  to other programs.The library should be ready to be opened at
  this time.It will be added to the system library name list, and
  the checksum on the library entries will be calculated.
SYNOPSIS  @{FG shine}void@{FG text} AddLibrary(@{FG shine}struct@{FG text} @{"Library" Link "include:exec/libraries.h/Main" 34} *);
  AddLibrary(@{i}library@{ui})
              A1
  @{i}library@{ui} - pointer to a properly initialized library structure
SEE ALSO
  @{"RemLibrary" Link "RemLibrary()"}, @{"CloseLibrary" Link "CloseLibrary()"}, @{"OpenLibrary" Link "OpenLibrary()"}, @{"MakeLibrary" Link "MakeLibrary()"}
@EndNode
@Node "AddMemHandler()" "exec.library/AddMemHandler"
@{b}@{u}AddMemHandler@{uu}@{ub} - Add a low memory handler to exec.@{FG fill}(V39)@{FG text}
  This function adds a low memory handler to the system.The handler
  is described in the Interrupt structure.Due to multitasking
  issues, the handler must be ready to run the moment this function
  call is made.(The handler may be called before the call returns)
SYNOPSIS  @{FG shine}void@{FG text} AddMemHandler(@{FG shine}struct@{FG text} @{"Interrupt" Link "include:exec/interrupts.h/Main" 23} *);
  AddMemHandler(@{i}memHandler@{ui})
                 A1
  @{i}memHandler@{ui} - A pointer to a completely filled in Interrupt structure
    The priority field determine the position of the handler with respect
    to other handlers in the system.The higher the priority, the earlier the
    handler is called.Positive priorities will have the handler called before
    any of the library expunge vectors are called.Negative priority handlers
    will be called after the library  expunge routines are called.
    @{b}Note:@{ub} RAMLIB is a handler at priority 0
NOTE
  Adding a handler from within a handler will cause undefined actions.It is safe
  to add a handler to the list while within a handler but the newly added
  handler may or may not be called for the specific failure currently running.
EXAMPLE
  @{FG shine}struct@{FG text} Interrupt *@{i}myInt@{ui};  /* Assume it is allocated */
  @{i}myInt@{ui}->is_Node.@{i}ln_Pri@{ui}=50;  /* Relatively early; before RAMLIB */
  /* Please fill in the name field! */
  @{i}myInt@{ui}->is_Node.@{i}ln_Name@{ui}="Example Handler";
  @{i}myInt@{ui}->is_Data=(APTR)@{i}mydata_pointer@{ui};
  @{i}myInt@{ui}->is_Code=@{i}myhandler_code@{ui};
  AddMemHandler(@{i}myInt@{ui});
  .../* and so on */
  _myhandler_code:
    ; This is the handler code
    ; We are passed a pointer to @{FG shine}struct@{FG text} MemHandlerData
    ; in a0, the value of is_Data in a1 and
    ; @{"ExecBase" Link "include:exec/execbase.h/Main" 34} in a6.
    ; We must not break forbid!!!
  ; Start off assuming we did nothing
    moveq.l #MEM_DID_NOTHING,d0
    move.l  memh_RequestFlags(a0),d1
    btst.l  #MEMB_CHIP,d1 ; Did the failure happen in CHIP
    beq.s handler_nop ; If not, we have nothing to do
    bsr DoMyMagic ; Do the magic...
    ; DoMyMagic frees whatever we can and returns d0 set...
  handler_nop:
    rts     ; Return with d0 set...
SEE ALSO
  RemMemHandler, exec/interrupts.i
@EndNode
@Node "AddMemList()" "exec.library/AddMemList"
@{b}@{u}AddMemList@{uu}@{ub} - add memory to the system free pool.
  Add a new region of memory to the system free pool.The first few
  bytes will be used to hold the @{"MemHeader" Link "include:exec/memory.h/Main" 28} structure.The remainder
  will be made available to the rest of the world.
SYNOPSIS  @{FG shine}void@{FG text} AddMemList(ULONG, ULONG, @{FG shine}long@{FG text}, APTR, STRPTR);
  AddMemList( @{i}size@{ui}, @{i}attributes@{ui}, @{i}pri@{ui}, @{i}base@{ui}, @{i}name@{ui} )
               D0    D1          D2    A0    A1
  @{i}size@{ui} - the size (in bytes) of the memory area
  @{i}attributes@{ui} - the attributes word that the memory pool will have
  @{i}pri@{ui}  - the priority for this memory.CHIP memory has a pri of -10,
    16 bit expansion memory has a priority of 0.The higher the priority,
    the closer to the head of the memory list it will be placed.
  @{i}base@{ui} - the base of the new memory area
  @{i}name@{ui} - the name that will be used in the memory header, or NULL if no name
    is to be provided.This name is not copied, so it must remain valid for as
    long as the memory header is in the system.
NOTES
  *DO NOT* add memory to the system with the attribute of MEMF_KICK.
  EXEC will mark your memory as such if it is of the right type.
SEE ALSO
  @{"AllocMem" Link "AllocMem()"}, @{"exec/memory.h" Link "include:exec/memory.h/Main" 0}
@EndNode
@Node "AddPort()" "exec.library/AddPort"
@{b}@{u}AddPort@{uu}@{ub} -- add a public message port to the system.
  This function attaches a message port structure to the system's public message
  port list, where it can be found by the @{"FindPort()" Link "FindPort()"} function.The name and
  priority fields of the port structure must be initialized prior to calling
  this function.If the user does not require the priority field, it should be
  initialized to zero.Only ports that will be searched for with @{"FindPort()" Link "FindPort()"}
  need to be added to the system list.In addition,adding ports is often useful
  during debugging.If the port will be searched for, the priority field should
  be at least 1 (to avoid the large number of inactive ports at priority zero).
  If the port will be searched for often, set the priority in the 50-100 range
  (so it will be before other less used ports).
  Once a port has been added to the naming list, you must be careful to remove
  the port from the list (via RemPort) before deallocating its memory.
SYNOPSIS  @{FG shine}void@{FG text} AddPort(@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *);
  AddPort(@{i}port@{ui})
           A1
  @{i}port@{ui} - pointer to a message port
NOTE
  A point of confusion is that clearing a MsgPort structure to all zeros is
  not enough to prepare it for use.As mentioned in the Exec chapter of the
  ROM Kernel Manual, the @{"List" Link "include:exec/lists.h/Main" 20} for the MsgPort must be initialized.This is
  automatically handled by AddPort(), and @{"amiga.lib/CreatePort" Link "amiga_lib.guide/CreatePort()"}.
  This initialization can be done manually with @{"amiga.lib/NewList" Link "amiga_lib.guide/NewList()"} or the
  assembly NEWLIST macro.Do not AddPort an active port.
SEE ALSO
  @{"RemPort" Link "RemPort()"}, @{"FindPort" Link "FindPort()"}, @{"amiga.lib/CreatePort" Link "amiga_lib.guide/CreatePort()"}, @{"amiga.lib/NewList" Link "amiga_lib.guide/NewList()"}
@EndNode
@Node "AddResource()" "exec.library/AddResource"
@{b}@{u}AddResource@{uu}@{ub} -- add a resource to the system.
  This function adds a new resource to the system and makes it available to
  other users.The resource must be ready to be called at this time.
  Resources currently have no system-imposed structure, however they
  must start with a standard named node (LN_SIZE), and should with
  a standard @{"Library" Link "include:exec/libraries.h/Main" 34} node (LIB_SIZE).
SYNOPSIS  @{FG shine}void@{FG text} AddResource(APTR);
  AddResource(@{i}resource@{ui})
               A1
  @{i}resource@{ui} - pointer an initialized resource node
SEE ALSO
  @{"RemResource" Link "RemResource()"}, @{"OpenResource" Link "OpenResource()"}, @{"MakeLibrary" Link "MakeLibrary()"}
@EndNode
@Node "AddSemaphore()" "exec.library/AddSemaphore"
@{b}@{u}AddSemaphore@{uu}@{ub} -- initialize then add a signal semaphore to the system.
  This function attaches a signal semaphore structure to the system's public
  signal semaphore list.The name and priority fields of the semaphore structure
  must be initialized prior to calling this function.If you do not want to let
  others rendezvous with this semaphore, use @{"InitSemaphore()" Link "InitSemaphore()"} instead.
  If a semaphore has been added to the naming list, you must be careful to remove
  the semaphore from the list (via RemSemaphore) before deallocating its memory.
  Semaphores that are linked together in an allocation list (which
  @{"ObtainSemaphoreList()" Link "ObtainSemaphoreList()"} would use) may not be added to the system naming list,
  because the facilities use the link field of the signal semaphore
  in incompatible ways.
SYNOPSIS  @{FG shine}void@{FG text} AddSemaphore(@{FG shine}struct@{FG text} @{"SignalSemaphore" Link "include:exec/semaphores.h/Main" 40} *);
  AddSemaphore(@{i}signalSemaphore@{ui})
                A1
  @{i}signalSemaphore@{ui} -- an signal semaphore structure
BUGS
  Does not work in Exec <V36.Instead use this code:
  @{b}#include@{ub} @{"<exec/execbase.h>" Link "include:exec/execbase.h/Main" 0}
  @{b}#include@{ub} @{"<exec/nodes.h>" Link "include:exec/nodes.h/Main" 0}
  extern @{FG shine}struct@{FG text} @{"ExecBase" Link "include:exec/execbase.h/Main" 34} *SysBase;
    ...
  @{FG shine}void@{FG text} LocalAddSemaphore(@{i}s@{ui})
  @{FG shine}struct@{FG text} SignalSemaphore *@{i}s@{ui};
  {
    @{i}s@{ui}->ss_Link.@{i}ln_Type@{ui}=NT_SIGNALSEM;
    InitSemaphore(@{i}s@{ui});
    Forbid();
    Enqueue(&SysBase->@{i}SemaphoreList@{ui},@{i}s@{ui});
    Permit();
  }
SEE ALSO
  @{"RemSemaphore" Link "RemSemaphore()"}, @{"FindSemaphore" Link "FindSemaphore()"}, @{"InitSemaphore" Link "InitSemaphore()"}
@EndNode
@Node "AddTail()" "exec.library/AddTail"
@{b}@{u}AddTail@{uu}@{ub} -- append node to tail of a list.
  Add a node to the tail of a doubly linked list.Assembly
  programmers may prefer to use the ADDTAIL macro from "exec/lists.i".
SYNOPSIS  @{FG shine}void@{FG text} AddTail(@{FG shine}struct@{FG text} @{"List" Link "include:exec/lists.h/Main" 20} *, @{FG shine}struct@{FG text} @{"Node" Link "include:exec/nodes.h/Main" 22} *);
  AddTail(@{i}list@{ui}, @{i}node@{ui})
           A0    A1
  @{i}list@{ui} - a pointer to the target list header
  @{i}node@{ui} - a pointer to the node to insert at tail of the list
@{b}WARNING@{ub}
  This function does not arbitrate for access to the list.The
  calling task must be the owner of the involved list.
SEE ALSO
  @{"AddHead" Link "AddHead()"}, @{"Enqueue" Link "Enqueue()"}, Insert, Remove, @{"RemHead" Link "RemHead()"}, @{"RemTail" Link "RemTail()"}
@EndNode
@Node "AddTask()" "exec.library/AddTask"
@{b}@{u}AddTask@{uu}@{ub} -- add a task to the system.
  Add a task to the system.A reschedule will be run; the task with
  the highest priority in the system will start to execute (this may
  or may not be the new task).

  Certain fields of the task control block must be initialized and a
  stack allocated prior to calling this function.The absolute
  smallest stack that is allowable is something in the range of 100
  bytes, but in general the stack size is dependent on what
  subsystems are called.In general 256 bytes is sufficient if only
  Exec is called, and 4K will do if anything in the system is called.
  DO NOT UNDERESTIMATE.If you use a stack sniffing utility,
  leave a healthy pad above the minimum value.The system guarantees
  that its stack operations will leave the stack longword aligned.

  This function will temporarily use space from the new task's stack
  for the task's initial set of registers.This space is allocated
  starting at the SPREG location specified in the task control block
  (not from SPUPPER).This means that a task's stack may contain
  static data put there prior to its execution.This is useful for
  providing initialized global variables or some tasks may want to
  use this space for passing the task its initial arguments.

  A task's initial registers are set to zero (except the PC).

  The TC_MEMENTRY field of the task structure may be extended by
  the user to hold additional MemLists (as returned by @{"AllocEntry()" Link "AllocEntry()"}).
  These will be automatically be deallocated at @{"RemTask()" Link "RemTask()"} time.
  If the code you have used to start the task has already added something
  to the MEMENTRY list, simply use @{"AddHead" Link "AddHead()"} to add your new MemLists in.
  If no initialization has been done, a @{"NewList" Link "amiga_lib.guide/NewList()"} will need to be performed.
SYNOPSIS  APTR AddTask(@{FG shine}struct@{FG text} @{"Task" Link "include:exec/tasks.h/Main" 24} *, APTR, APTR);
  AddTask(@{i}task@{ui}, @{i}initialPC@{ui}, @{i}finalPC@{ui})
           A1     A2         A3
  @{i}task@{ui}  - pointer to the task control block (TCB).All unset fields
    must be zero.
  @{i}initialPC@{ui} - the initial entry point's address
  @{i}finalPC@{ui} - the finalization code entry point's address.
    If zero,the system will use a general finalizer.This pointer is
    placed on the stack as if it were the outermost return address.
  For V36, AddTask returns either a NULL or the address of the new
  task.Old code need not check this.
@{b}WARNING@{ub}
  Tasks are a low-level building block, and are unable to call
  dos.library, or any system function that might call dos.library.
  See the AmigaDOS @{"CreateProc()" Link "dos.guide/CreateProc()"} for information on Processes.
SEE ALSO
  @{"RemTask" Link "RemTask()"}, @{"FindTask" Link "FindTask()"}, @{"amiga.lib/CreateTask" Link "amiga_lib.guide/CreateTask()"}, @{"dos/CreateProc" Link "dos.guide/CreateProc()"},
  @{"amiga.lib/NewList" Link "amiga_lib.guide/NewList()"}
@EndNode
@Node "Alert()" "exec.library/Alert"
@{b}@{u}Alert@{uu}@{ub} -- alert the user of an error.
  Alerts the user of a serious system problem.This function will
  bring the system to a grinding halt, and do whatever is necessary
  to present the user with a message stating what happened.
  Interrupts are disabled, and an attempt to post the alert is made.
  If that fails, the system is reset.When the system comes up again,
  Exec notices the cause of the failure and tries again to post the alert.
  If the Alert is a recoverable type, @{i}this call MAY return@{ui}.
  This call may be made at any time, including interrupts.
  (Well, only in interrupts if it is non-recoverable)
  @{i}New, for V39:@{ui} The alert now times out based on the value in LastAlert[3].
  This value is transfered accross warm-reboots and thus will let you set it
  once.The value is the number of frames that need to be displayed before the
  alert is auto-answered.A value of 0 will thus make the alert never be displayed.
  Note that it is recommended that applications *NOT* change the value in
  LastAlert[] since the main reason for this is to make unattended
  operation of the Amiga (in production enviroments) possible.
SYNOPSIS  @{FG shine}void@{FG text} Alert(ULONG);
  Alert(@{i}alertNum@{ui})
         D7
  @{i}alertNum@{ui}   - a number indicating the particular alert.-1 is not a valid input.
@{b}POST-MORTEM DIAGNOSIS@{ub}
  There are several options for determining the cause of a crash.Descriptions of
  each alert number can be found in the "alerts.h" include file.
  A remote terminal can be attached to the Amiga's first built-in serial port.
  Set the communication parameters to 9600 baud, 8 bits, no parity.
  Before resetting the machine, the Alert function will blink the
  power LED 10 times.While the power indicator is flashing, pressing
  DELETE on the remote terminal will invoke the ROM debugger.
NOTE
  Much more needs to be said about this function and its implications.
SEE ALSO
  @{"exec/alerts.h" Link "include:exec/alerts.h/Main" 0}
@EndNode
@Node "AllocAbs()" "exec.library/AllocAbs"
@{b}@{u}AllocAbs@{uu}@{ub} -- allocate at a given location.
  This function attempts to allocate memory at a given absolute memory location.
  Often this is used by boot-surviving entities such as recoverable ram-disks.
  If the memory is already being used, or if there is not enough memory to
  satisfy the request, AllocAbs will return NULL.
  This block may not be exactly the same as the requested block because of
  rounding, but if the return value is non-zero, the block is guaranteed to
  contain the requested range.
SYNOPSIS  @{FG shine}void@{FG text} *AllocAbs(ULONG, APTR);
  @{i}@{b}memoryBlock@{ub}@{ui} = AllocAbs(@{i}byteSize@{ui}, @{i}location@{ui})
   D0                     D0         A1
  @{i}byteSize@{ui} - the size of the desired block in bytes
    This number is rounded up to the next larger block size
    for the actual allocation.
  @{i}location@{ui} - the address where the memory MUST be.
  @{i}@{b}memoryBlock@{ub}@{ui} - a pointer to the newly allocated memory block, or NULL if failed.
NOTE
  If the free list is corrupt, the system will panic with alert
  AN_MemCorrupt, $01000005.
  The 8 bytes past the end of an AllocAbs will be changed by Exec
  relinking the next block of memory.Generally you can't trust
  the first 8 bytes of anything you AllocAbs.
SEE ALSO
  @{"AllocMem" Link "AllocMem()"}, @{"FreeMem" Link "FreeMem()"}
@EndNode
@Node "Allocate()" "exec.library/Allocate"
@{b}@{u}Allocate@{uu}@{ub} - allocate a block of memory.
  This function is used to allocate blocks of memory from a given
  private free memory pool (as specified by a MemHeader and its
  memory chunk list).Allocate will return the first free block that
  is greater than or equal to the requested size.

  All blocks, whether free or allocated, will be block aligned;
  hence, all allocation sizes are rounded up to the next block even
  value (e.g.the minimum allocation resolution is currently 8
  bytes.A request for 8 bytes will use up exactly 8 bytes.A
  request for 7 bytes will also use up exactly 8 bytes.).

  This function can be used to manage an application's internal data
  memory.Note that no arbitration of the MemHeader and associated
  free chunk list is done.You must be the owner before calling Allocate.
SYNOPSIS  @{FG shine}void@{FG text} *Allocate(@{FG shine}struct@{FG text} @{"MemHeader" Link "include:exec/memory.h/Main" 28} *, ULONG);
  @{i}@{b}memoryBlock@{ub}@{ui}=Allocate(@{i}memHeader@{ui}, @{i}byteSize@{ui})
   D0                   A0         D0
  @{i}memHeader@{ui} - points to the local memory list header.
  @{i}byteSize@{ui} - the size of the desired block in bytes.
  @{i}@{b}memoryBlock@{ub}@{ui} - a pointer to the just allocated free block.
    If there are no free regions large enough to satisfy the request,return zero.
EXAMPLE
  @{b}#include@{ub} @{"<exec/types.h>" Link "include:exec/types.h/Main" 0}
  @{b}#include@{ub} @{"<exec/memory.h>" Link "include:exec/memory.h/Main" 0}
  @{FG shine}void@{FG text} *AllocMem();
  @{b}#define@{ub} BLOCKSIZE 4096L /* Or whatever you want */
  @{FG shine}void@{FG text} main()
  {
    @{FG shine}struct@{FG text} MemHeader *@{i}mh@{ui};
    @{FG shine}struct@{FG text} @{"MemChunk" Link "include:exec/memory.h/Main" 20}  *@{i}mc@{ui};
    APTR @{i}block1@{ui};
    APTR @{i}block2@{ui};
    /* Get the MemHeader needed to keep track of our new block */
    @{i}mh@{ui} = (@{FG shine}struct@{FG text} MemHeader *)
    AllocMem((@{FG shine}long@{FG text})@{FG shine}sizeof@{FG text}(@{FG shine}struct@{FG text} MemHeader), MEMF_CLEAR );
    @{FG shine}if@{FG text}( !@{i}mh@{ui} )
      @{FG shine}exit@{FG text}(10);
    /* Get the actual block the above MemHeader will manage */
    mc = (@{FG shine}struct@{FG text} MemChunk *)AllocMem( BLOCKSIZE, 0L );
    @{FG shine}if@{FG text}( !@{i}mc@{ui} ) {
      FreeMem( @{i}mh@{ui}, (@{FG shine}long@{FG text})@{FG shine}sizeof@{FG text}(@{FG shine}struct@{FG text} MemHeader) ); @{FG shine}exit@{FG text}(10);
    }
    mh->mh_Node.@{i}ln_Type@{ui} = NT_MEMORY;
    mh->mh_Node.@{i}ln_Name@{ui} = "myname";
    mh->@{i}mh_First@{ui} = @{i}mc@{ui};
    mh->@{i}mh_Lower@{ui} = (APTR) @{i}mc@{ui};
    mh->@{i}mh_Upper@{ui} = (APTR) ( BLOCKSIZE + (ULONG) @{i}mc@{ui} );
    mh->@{i}mh_Free@{ui}  = BLOCKSIZE;
    /* Set up first chunk in the freelist */
    mc->@{i}mc_Next@{ui}  = NULL;
    mc->@{i}mc_Bytes@{ui} = BLOCKSIZE;
    @{i}block1@{ui} = (APTR) Allocate( @{i}mh@{ui}, 20L );
    @{i}block2@{ui} = (APTR) Allocate( @{i}mh@{ui}, 314L );
    printf("mh=$%lx mc=$%lx\n",mh,mc);
    printf("Block1=$%lx, Block2=$%lx\n",block1,block2);
    FreeMem( @{i}mh@{ui}, (@{FG shine}long@{FG text})@{FG shine}sizeof@{FG text}(@{FG shine}struct@{FG text} MemHeader) );
    FreeMem( @{i}mc@{ui}, BLOCKSIZE );
  }
NOTE
  If the free list is corrupt, the system will panic with alert
  AN_MemCorrupt, $01000005.
SEE ALSO
  Deallocate, @{"exec/memory.h" Link "include:exec/memory.h/Main" 0}
@EndNode
@Node "AllocEntry()" "exec.library/AllocEntry"
@{b}@{u}AllocEntry@{uu}@{ub} -- allocate many regions of memory.
  This function takes a memList structure and allocates enough memory to hold the
  required memory as well as a MemList structure to keep track of it.
  These MemList structures may be linked together in a task control
  block to keep track of the total memory usage of this task.(See
  the description of TC_MEMENTRY under RemTask).
SYNOPSIS  @{FG shine}struct@{FG text} @{"MemList" Link "include:exec/memory.h/Main" 56} *AllocEntry(@{FG shine}struct@{FG text} MemList *);
  @{i}@{b}memList@{ub}@{ui} = AllocEntry(@{i}memList@{ui})
   D0                   A0
  @{i}memList@{ui} -- A MemList structure filled in with @{"MemEntry" Link "include:exec/memory.h/Main" 40} structures.
  @{i}@{b}memList@{ub}@{ui} -- A different MemList filled in with the actual memory
    allocated in the me_Addr field, and their sizes in me_Length.
    If enough memory cannot be obtained, then the requirements of
    the allocation that failed is returned and bit 31 is set.
    @{b}WARNING@{ub}: The result is unusual!  Bit 31 indicates failure.
EXAMPLES
  The user wants five regions of 2, 4, 8, 16, and 32 bytes in size
  with requirements of MEMF_CLEAR, MEMF_PUBLIC, MEMF_CHIP!MEMF_CLEAR,
  MEMF_CLEAR, and MEMF_PUBLIC!MEMF_CLEAR respectively.The
  following code fragment would do that:
  MemListDecl:
    DS.B  LN_SIZE       * reserve space for list node
    DC.W  5       * number of entries
    DC.L  MEMF_CLEAR        * entry #0
    DC.L  2
    DC.L  MEMF_PUBLIC       * entry #1
    DC.L  4
    DC.L  MEMF_CHIP!MEMF_CLEAR      * entry #2
    DC.L  8
    DC.L  MEMF_CLEAR          * entry #3
    DC.L  16
    DC.L  MEMF_PUBLIC!MEMF_CLEAR      * entry #4
    DC.L  32
  start:
    LEA.L MemListDecl(PC),A0
    JSR _LVOAllocEntry(a6)
    BCLR.L  #31,D0
    BEQ.S success
  ------- Type of memory that we failed on is in D0
BUGS
  If any one of the allocations fails, this function fails to back out fully.
  This is fixed by the "SetPatch" program on V1.3 Workbench disks.
SEE ALSO
  @{"exec/memory.h" Link "include:exec/memory.h/Main" 0}
@EndNode
@Node "AllocMem()" "exec.library/AllocMem"
@{b}@{u}AllocMem@{uu}@{ub} -- allocate memory given certain requirements.
  This is the memory allocator to be used by system code and applications.
  It provides a means of specifying that the allocation should be made in a
  memory area accessible to the chips, or accessible to shared system code.
  Memory is allocated based on requirements and options.Any "requirement"
  must be met by a memory allocation, any "option" will be applied to the
  block regardless.AllocMem will try all memory spaces until one is found
  with the proper requirements and room for the memory request.
SYNOPSIS  @{FG shine}void@{FG text} *AllocMem(ULONG, ULONG);
  @{i}@{b}memoryBlock@{ub}@{ui} = AllocMem(@{i}byteSize@{ui}, @{i}attributes@{ui})
   D0                     D0         D1
  @{i}byteSize@{ui} - the size of the desired block in bytes.
    The operating system will automatically round this number to a
    multiple of the system memory chunk size
  @{"attributes" link ALLOCMEM_ATTRIBUTES}
  @{i}@{b}memoryBlock@{ub}@{ui} - a pointer to the newly allocated memory block.
    If there are no free memory regions large enough to satisfy the request,
    zero will be returned.The pointer must be checked for zero before the
    memory block may be used! The memory block returned is long word aligned.
@{b}WARNING@{ub}
  The result of any memory allocation MUST be checked, and a viable error
  handling path taken.ANY allocation may fail if memory has been filled.
EXAMPLES
  AllocMem(64,0L)   - Allocate the best available memory
  AllocMem(25,MEMF_CLEAR) - Allocate the best available memory, and
    clear it before returning.
  AllocMem(128,MEMF_CHIP) - Allocate chip memory
  AllocMem(128,MEMF_CHIP|MEMF_CLEAR) - Allocate cleared chip memory
  AllocMem(821,MEMF_CHIP|MEMF_PUBLIC|MEMF_CLEAR) - Allocate cleared,
    public, chip memory.
NOTE
  If the free list is corrupt, the system will panic with alert
  AN_MemCorrupt, $01000005.
  This function may not be called from interrupts.
  A DOS process will have its pr_Result2 field set to ERROR_NO_FREE_STORE if the
  memory allocation fails.
SEE ALSO
  @{"FreeMem" Link "FreeMem()"}
@EndNode
@node ALLOCMEM_ATTRIBUTES "AllocMem_attributes"
@{b}@{u}Required@{uu}@{ub}:
If no flags are set, the system will return the best available memory block.
For expanded systems, the fast memory pool is searched first.
@{i}MEMF_CHIP@{ui}: If the requested memory will be used by the Amiga custom chips,
  this flag *must* be set.Only certain parts of memory are reachable by the
  special chip sets' DMA circuitry.Chip DMA includes screen memory, images that
  are blitted, audio data, copper lists, sprites and Pre-V36 trackdisk.device
  buffers.
@{i}MEMF_FAST@{ui}: This is non-chip memory.
  If no flag is set MEMF_FAST is taken as the default.DO NOT SPECIFY MEMF_FAST
  unless you know exactly what you are doing! If MEMF_FAST is set, AllocMem()
  will fail on machines that only have chip memory! This flag may not be set
  when MEMF_CHIP is set.
@{i}MEMF_PUBLIC@{ui}: Memory that must not be mapped, swapped, or otherwise made
  non-addressable.ALL MEMORY THAT IS REFERENCED VIA INTERRUPTS AND/OR BY
  OTHER TASKS MUST BE EITHER PUBLIC OR LOCKED INTO MEMORY! This includes both
  code and data.
@{i}MEMF_LOCAL@{ui}: This is memory that will not go away after the CPU @{"RESET" Link "RESET"}
  instruction.Normally, autoconfig memory boards become unavailable after @{"RESET" Link "RESET"}
  while motherboard memory may still be available.This memory type is now
  automatically set in V36.Pre-V36 systems may not have this memory type
  and AllocMem() will then fail.
@{i}MEMF_24BITDMA@{ui}: This is memory that is within the address range of 24-bit DMA
  devices.(Zorro-II) This is required if you run a Zorro-II DMA device on a
  machine that has memory beyond the 24-bit addressing limit of Zorro-II.
  This memory type is now automatically set in V36.Pre-V36 systems may not
  have this memory type and AllocMem() will then fail.
@{i}MEMF_KICK@{ui}: This memory is memory that EXEC was able to access during/before the
  KickMem and KickTags are processed.This means that if you wish to use these,
  you should allocate memory with this flag.This flag is automaticly set by
  EXEC in V39.Pre-V39 systems may not have this memory type and AllocMem() will
  then fail.Also, *DO NOT* ever add memory the system with this flag set.
  EXEC will set the flag as needed if the memory matches the needs of EXEC.
@{b}@{u}Optional@{uu}@{ub}:
@{i}MEMF_CLEAR@{ui}: The memory will be initialized to all zeros.
@{i}MEMF_REVERSE@{ui}: This allocates memory from the top of the memory pool.
  It searches the pools in the same order, such that FAST memory will be found
  first.However, the memory will be allocated from the highest address available
  in the pool.This option is new as of V36.Note that this option has a bug in
  pre-V39 systems.
@{i}MEMF_NO_EXPUNGE@{ui} This will prevent an expunge to happen on a failed memory
  allocation.This option is new to V39 and will be ignored in V37.
  If a memory allocation with this flag set fails, the allocator will not cause
  any expunge operations.(See @{"AddMemHandler()" Link "AddMemHandler()"})
@endnode
@Node "AllocPooled()" "exec.library/AllocPooled"
@{b}@{u}AllocPooled@{uu}@{ub} -- Allocate memory with the pool manager.@{FG fill}(V39)@{FG text}
  Allocate memSize bytes of memory, and return a pointer.NULL is returned if the
  allocation fails.
  Doing a @{"DeletePool()" Link "DeletePool()"} on the pool will free all of the puddles
  and thus all of the allocations done with AllocPooled() in that pool.
  (No need to @{"FreePooled()" Link "FreePooled()"} each allocation)
SYNOPSIS  @{FG shine}void@{FG text} *AllocPooled(@{FG shine}void@{FG text} *,ULONG);
  @{i}@{b}memory@{ub}@{ui}=AllocPooled(@{i}poolHeader@{ui},@{i}memSize@{ui})
   d0                 a0          d0
  @{i}memSize@{ui} - the number of bytes to allocate
  @{i}poolHeader@{ui} - a specific private pool header.
  Returns a pointer to the memory, or NULL.
  The memory block returned is long word aligned.
NOTES
  The pool function do not protect an individual pool from multiple accesses.
  The reason is that in most cases the pools will be used by a single task.
  If your pool is going to be used by more than one task you must @{"Semaphore" Link "include:exec/semaphores.h/Main" 53}
  protect the pool from having more than one task trying to allocate within the
  same pool at the same time.
  @{b}WARNING@{ub}: @{"Forbid()" Link "Forbid()"} protection *will not work* in the future.*Do NOT* assume
  that we will be able to make it work in the future.AllocPooled() may well break
  a @{"Forbid()" Link "Forbid()"} and as such can only be protected by a semaphore.
  To track sizes yourself, the following code can be used:
  Assumes a6=ExecBase
  ; Function to do AllocVecPooled(Pool,memSize)
  AllocVecPooled: addq.l  #4,d0   ; Get space for tracking
    move.l  d0,-(sp)  ; Save the size
    jsr _LVOAllocPooled(a6) ; Call pool...
    move.l  (sp)+,d1  ; Get size back...
    tst.l d0    ; Check for error
    beq.s avp_fail  ; If NULL, failed!
    move.l  d0,a0   ; Get pointer...
    move.l  d1,(a0)+  ; Store size
    move.l  a0,d0   ; Get result
  avp_fail: rts     ; return
  ; Function to do FreeVecPooled(pool,memory)
  FreeVecPooled:  move.l  -(a1),d0  ; Get size / ajust pointer
    jmp _LVOFreePooled(a6)
SEE ALSO
  @{"FreePooled()" Link "FreePooled()"}, @{"CreatePool()" Link "CreatePool()"}, @{"DeletePool()" Link "DeletePool()"}
@EndNode
@Node "AllocSignal()" "exec.library/AllocSignal"
@{b}@{u}AllocSignal@{uu}@{ub} -- allocate a signal bit.
  Allocate a signal bit from the current tasks' pool.Either a particular bit,
  or the next free bit may be allocated.The signal associated with the bit
  will be properly initialized (cleared).At least 16 user signals are available
  per task.Signals should be deallocated before the task exits.If the signal
  is already in use (or no free signals are available) a -1 is returned.
  Allocated signals are only valid for use with the task that allocated them.
SYNOPSIS  BYTE AllocSignal(BYTE);
  @{i}@{b}signalNum@{ub}@{ui} = AllocSignal(@{i}signalNum@{ui})
   D0                      D0
  @{i}signalNum@{ui} - the desired signal number {of 0..31} or -1 for no preference.
  @{i}@{b}signalNum@{ub}@{ui} - the signal bit number allocated {0..31}.
    If no signals are available, this function returns -1.
@{b}WARNING@{ub}
  Signals may not be allocated or freed from exception handling code.
SEE ALSO
  @{"FreeSignal" Link "FreeSignal()"}
@EndNode
@Node "AllocTrap()" "exec.library/AllocTrap"
@{b}@{u}AllocTrap@{uu}@{ub} -- allocate a processor trap vector.
  Allocate a trap number from the current task's pool.These trap numbers are
  those associated with the 68000 TRAP type instructions.Either a particular
  number, or the next free number may be allocated.If the trap is already
  in use (or no free traps are available) a -1 is returned.
  This function only affects the currently running task.
  Traps are sent to the trap handler pointed at by tc_TrapCode.
  Unless changed by user code, this points to a standard trap
  handler.The stack frame of the exception handler will be:
    0(SP) = Exception vector number.This will be in the
      range of 32 to 47 (corresponding to the
      Trap #1...Trap #15 instructions).
    4(SP) = 68000/68010/68020/68030, etc.exception frame
  tc_TrapData is not used.
SYNOPSIS  @{FG shine}long@{FG text} AllocTrap(@{FG shine}long@{FG text});
  @{i}@{b}trapNum@{ub}@{ui} = AllocTrap(@{i}trapNum@{ui})
   D0                   D0
  @{i}trapNum@{ui} - the desired trap number {of 0..15} or -1 for no preference.
  @{i}@{b}trapNum@{ub}@{ui} - the trap number allocated {of 0..15}.
    If no traps are available, this function returns -1.Instructions of the
    form "Trap #trapNum" will be sent to the task's trap handler.
@{b}WARNING@{ub}
  Traps may not be allocated or freed from exception handling code.
  You are not allowed to write to the exception table yourself.In
  fact, on some machines you will have trouble finding it - the VBR
  register may be used to remap its location.
SEE ALSO
  @{"FreeTrap" Link "FreeTrap()"}
@EndNode
@Node "AllocVec()" "exec.library/AllocVec"
@{b}@{u}AllocVec@{uu}@{ub} -- allocate memory and keep track of the size.@{FG fill}(V36)@{FG text}
  This function works identically to @{"AllocMem()" Link "AllocMem()"}, but tracks the size of the
  allocation.See the @{"AllocMem()" Link "AllocMem()"} documentation for details.
SYNOPSIS  @{FG shine}void@{FG text} *AllocVec(ULONG, ULONG);
  @{i}@{b}memoryBlock@{ub}@{ui} = AllocVec(@{i}byteSize@{ui}, @{i}attributes@{ui})
   D0                     D0         D1
@{b}WARNING@{ub}
  The result of any memory allocation MUST be checked, and a viable error
  handling path taken.ANY allocation may fail if memory has been filled.
SEE ALSO
  @{"FreeVec" Link "FreeVec()"}, @{"AllocMem" Link "AllocMem()"}
@EndNode
@Node "AttemptSemaphore()" "exec.library/AttemptSemaphore"
@{b}@{u}AttemptSemaphore@{uu}@{ub} -- try to obtain without blocking.
  This call is similar to @{"ObtainSemaphore()" Link "ObtainSemaphore()"}, except that it will not
  block if the semaphore could not be locked.
SYNOPSIS  @{FG shine}long@{FG text} AttemptSemaphore(@{FG shine}struct@{FG text} @{"SignalSemaphore" Link "include:exec/semaphores.h/Main" 40} *);
  @{i}@{b}success@{ub}@{ui} = AttemptSemaphore(@{i}signalSemaphore@{ui})
   D0                         A0
  @{i}signalSemaphore@{ui} -- an initialized signal semaphore structure
  @{i}@{b}success@{ub}@{ui} -- TRUE if the semaphore was locked, false if some other task
    already possessed the semaphore.
NOTE
  This call does NOT preserve registers.
SEE ALSO
  @{"ObtainSemaphore()" Link "ObtainSemaphore()"} @{"ObtainSemaphoreShared()" Link "ObtainSemaphoreShared()"}, @{"ReleaseSemaphore()" Link "ReleaseSemaphore()"},
  @{"exec/semaphores.h" Link "include:exec/semaphores.h/Main" 0}
@EndNode
@Node "AttemptSemaphoreShared()" "exec.library/AttemptSemaphoreShared"
@{b}@{u}AttemptSemaphoreShared@{uu}@{ub} -- try to obtain without blocking.@{FG fill}(V37)@{FG text}
  This call is similar to @{"ObtainSemaphoreShared()" Link "ObtainSemaphoreShared()"}, except that it
  will not block if the semaphore could not be locked.
SYNOPSIS  @{FG shine}long@{FG text} AttemptSemaphoreShared(@{FG shine}struct@{FG text} @{"SignalSemaphore" Link "include:exec/semaphores.h/Main" 40} *);
  @{i}@{b}success@{ub}@{ui} = AttemptSemaphoreShared(@{i}signalSemaphore@{ui})
   D0                               A0
  @{i}signalSemaphore@{ui} -- an initialized signal semaphore structure
  @{i}@{b}success@{ub}@{ui} -- TRUE if the semaphore was granted, false if some other task
    already possessed the semaphore in exclusive mode.
NOTE
  This call does NOT preserve registers.
  Starting in V39 this call will grant the semaphore if the caller is already
  the owner of an exclusive lock on the semaphore.In pre-V39 systems this would
  not be the case.If you need this feature you can do the following workaround:
  @{FG shine}long@{FG text} myAttemptSempahoreShared(@{FG shine}struct@{FG text} SignalSemaphore *@{i}ss@{ui})
  {
    @{FG shine}long@{FG text} @{i}result@{ui};
    /* Try for a shared semaphore */
    @{FG shine}if@{FG text} (!(@{i}result@{ui}=AttemptSemaphoreShared(@{i}ss@{ui}))) {
      /* Now try for the exclusive one...*/
      @{i}result@{ui}=AttempSemaphore(@{i}ss@{ui});
    }
      @{FG shine}return@{FG text}(@{i}result@{ui});
  }
SEE ALSO
  @{"ObtainSemaphore()" Link "ObtainSemaphore()"} @{"ObtainSemaphoreShared()" Link "ObtainSemaphoreShared()"}, @{"ReleaseSemaphore()" Link "ReleaseSemaphore()"},
  @{"exec/semaphores.h" Link "include:exec/semaphores.h/Main" 0}
@EndNode
@Node "AvailMem()" "exec.library/AvailMem"
@{b}@{u}AvailMem@{uu}@{ub} -- memory available given certain requirements.
  This function returns the amount of free memory given certain attributes.
  To find out what the largest block of a particular type is, add MEMF_LARGEST
  into the requirements argument.Returning the largest block is a slow operation.
SYNOPSIS  ULONG AvailMem(ULONG);
  @{i}@{b}size@{ub}@{ui} = AvailMem(@{i}attributes@{ui})
   D0              D1
  @{i}required@{ui} - a required mask as specified in @{"AllocMem" Link "AllocMem()"}.
    Any of the @{"AllocMem" Link "AllocMem()"} bits are valid, as is MEMF_LARGEST which returns the
    size of the largest block matching the requirements.
  @{i}@{b}size@{ub}@{ui} - total free space remaining (or the largest free block).
@{b}WARNING@{ub}
  Due to the effect of multitasking, the value returned may not
  actually be the amount of free memory available at that instant.
NOTE
  For V36 Exec, AvailMem(MEMF_LARGEST) does a consistency check on the
  memory list.Alert AN_MemoryInsane will be pulled if any mismatch is noted.
EXAMPLE
  AvailMem(MEMF_CHIP|MEMF_LARGEST);
  /* return size of largest available chip memory chunk */
SEE ALSO
  @{"exec/memory.h" Link "include:exec/memory.h/Main" 0}
@EndNode
@Node "CacheClearE()" "exec.library/CacheClearE"
@{b}@{u}CacheClearE@{uu}@{ub} - Cache clearing with extended control.@{FG fill}(V37)@{FG text}
  Flush out the contents of the CPU instruction and/or data caches.
  If dirty data cache lines are present, push them to memory first.
  Motorola CPUs have separate instruction and data caches.A data write does
  not update the instruction cache.If an instruction is written to memory or
  modified, the old instruction may still exist in the cache.Before attempting
  to execute the code, a flush of the instruction cache is required.
  For most systems, the data cache is not updated by Direct Memory
  Access (DMA), or if some external factor changes shared memory.
  Caches must be cleared after *any* operation that could cause
  invalid or stale data.The most common cases are DMA and modifying
  instructions using the processor.
  Some examples:
    Self modifying code
    Building Jump tables
    Run-time code patches
    Relocating code for use at different addresses.
    Loading code from disk
SYNOPSIS  @{FG shine}void@{FG text} CacheClearE(APTR,ULONG,ULONG);
  CacheClearE(@{i}address@{ui},@{i}length@{ui},@{i}caches@{ui})
               a0       d0     d1
  @{i}address@{ui} - Address to start the operation.
    This may be rounded due to hardware granularity.
  @{i}length@{ui}  - Length of area to be cleared, or $FFFFFFFF to indicate all addresses
    should be cleared.
  @{i}caches@{ui}  - Bit flags to indicate what caches to affect.
    The current supported flags are:
      CACRF_ClearI  ;Clear instruction cache
      CACRF_ClearD  ;Clear data cache
      All other bits are reserved for future definition.
NOTES
  On systems with a copyback mode cache, any dirty data is pushed to memory as a
  part of this operation.
  Regardless of the length given, the function will determine the most
  efficient way to implement the operation.For some cache systems,
  including the 68030, the overhead partially clearing a cache is often
  too great.The entire cache may be cleared.
  For all current Amiga models, Chip memory is set with Instruction
  caching enabled, data caching disabled.This prevents coherency
  conflicts with the blitter or other custom chip DMA.@{"Custom" Link "include:hardware/custom.h/Main" 26} chip
  registers are marked as non-cacheable by the hardware.
  The system takes care of appropriately flushing the caches for normal
  operations.The instruction cache is cleared by all calls that
  modify instructions, including @{"LoadSeg()" Link "dos.guide/LoadSeg()"}, @{"MakeLibrary()" Link "MakeLibrary()"} and
  @{"SetFunction()" Link "SetFunction()"}.
SEE ALSO
  exec/execbase.i, @{"CacheControl" Link "CacheControl()"}, @{"CacheClearU" Link "CacheClearU()"}
@EndNode
@Node "CacheClearU()" "exec.library/CacheClearU"
@{b}@{u}CacheClearU@{uu}@{ub} - User callable simple cache clearing.@{FG fill}(V37)@{FG text}
  Flush out the contents of any CPU instruction and data caches.
  If dirty data cache lines are present, push them to memory first.
  Caches must be cleared after *any* operation that could cause
  invalid or stale data.The most common cases are DMA and modifying
  instructions using the processor.See the @{"CacheClearE()" Link "CacheClearE()"} autodoc
  for a more complete description.
  Some examples of when the cache needs clearing:
    Self modifying code
    Building Jump tables
    Run-time code patches
    Relocating code for use at different addresses.
    Loading code from disk
SYNOPSIS  @{FG shine}void@{FG text} CacheClearU(@{FG shine}void@{FG text});
  CacheClearU()
SEE ALSO
  exec/execbase.i, @{"CacheControl" Link "CacheControl()"}, @{"CacheClearE" Link "CacheClearE()"}
@EndNode
@Node "CacheControl()" "exec.library/CacheControl"
@{b}@{u}CacheControl@{uu}@{ub} - Instruction & data cache control.
  This function provides global control of any instruction or data caches that
  may be connected to the system.All settings are global -- per task control is
  not provided.
  The action taken by this function will depend on the type of
  CPU installed.This function may be patched to support external
  caches, or different cache architectures.In all cases the function
  will attempt to best emulate the provided settings.Use of this
  function may save state specific to the caches involved.
  The list of supported settings is provided in the exec/execbase.i
  include file.The bits currently defined map directly to the Motorola
  68030 CPU CACR register.Alternate cache solutions may patch into
  the Exec cache functions.Where possible, bits will be interpreted to
  have the same meaning on the installed cache.
SYNOPSIS  ULONG CacheControl(ULONG,ULONG);
  @{i}@{b}oldBits@{ub}@{ui} = CacheControl(@{i}cacheBits@{ui},@{i}cacheMask@{ui})
   D0                      D0        D1
  @{i}cacheBits@{ui} - new values for the bits specified in cacheMask.
  @{i}cacheMask@{ui} - a mask with ones for all bits to be changed.
  @{i}@{b}oldBits@{ub}@{ui}   - the complete prior values for all settings.
NOTE
  As a side effect, this function clears all caches.
SEE ALSO
  exec/execbase.i, @{"CacheClearU" Link "CacheClearU()"}, @{"CacheClearE" Link "CacheClearE()"}
@EndNode
@Node "CachePostDMA()" "exec.library/CachePostDMA"
@{b}@{u}CachePostDMA@{uu}@{ub} - Take actions after to hardware DMA.@{FG fill}(V37)@{FG text}
  Take all appropriate steps after Direct Memory Access (DMA).This
  function is primarily intended for writers of DMA device drivers.The
  action will depend on the CPU type installed, caching modes, and the
  state of any Memory Management @{"Unit" Link "include:exec/devices.h/Main" 32} (MMU) activity.
  As implemented
    68000 - Do nothing
    68010 - Do nothing
    68020 - Do nothing
    68030 - Flush the data cache
    68040 - Flush matching areas of the data cache
    ????? - External cache boards, Virtual Memory Systems, or future hardware
      may patch this vector to best emulate the intended behavior.
      With a Bus-Snooping CPU, this function my end up doing nothing.
SYNOPSIS  CachePostDMA(APTR,@{FG shine}long@{FG text} *,ULONG);
  CachePostDMA(@{i}vaddress@{ui},@{i}@{b}&length@{ub}@{ui},@{i}flags@{ui})
                a0       a1       d0
  @{i}vaddress@{ui} - Same as initially passed to @{"CachePreDMA" Link "CachePreDMA()"}
  @{i}@{b}&length@{ub}@{ui}  - Same as initially passed to @{"CachePreDMA" Link "CachePreDMA()"}
  @{"flags" link CACHEPOSTDMA_FLAGS}
SEE ALSO
  exec/execbase.i, @{"CachePreDMA" Link "CachePreDMA()"}, @{"CacheClearU" Link "CacheClearU()"}, @{"CacheClearE" Link "CacheClearE()"}
@EndNode
@node CACHEPOSTDMA_FLAGS "CachePostDMA_flags"
@{i}DMA_NoModify@{ui} - If the area was not modified (and thus there is no reason to
  flush the cache) set this bit.
@{i}DMA_ReadFromRAM@{ui} - Indicates that this DMA is a read from RAM to the DMA device
  (ie - a write to the hard drive)
  This flag is not required but if used must match in both the PreDMA and
  PostDMA calls.This flag *should* be used to help the system provide the
  best performance.This flag is safe in all versions of CachePostDMA()
@endnode
@Node "CachePreDMA()" "exec.library/CachePreDMA"
@{b}@{u}CachePreDMA@{uu}@{ub} - Take actions prior to hardware DMA.@{FG fill}(V37)@{FG text}
  Take all appropriate steps before Direct Memory Access (DMA).This
  function is primarily intended for writers of DMA device drivers.The
  action will depend on the CPU type installed, caching modes, and the
  state of any Memory Management @{"Unit" Link "include:exec/devices.h/Main" 32} (MMU) activity.
  This function supports advanced cache architectures that have "copyback" modes.
  With copyback, write data may be cached, but not actually flushed out to
  memory.If the CPU has unflushed data at the time of DMA, data may be lost.
  As implemented
    68000 - Do nothing
    68010 - Do nothing
    68020 - Do nothing
    68030 - Do nothing
    68040 - Write any matching dirty cache lines back to memory.
      As a side effect of the 68040's design, matching data cache lines are
      also invalidated -- future CPUs may be different.
    ????? - External cache boards, Virtual Memory Systems, or future hardware
      may patch this vector to best emulate the intended behavior.
      With a Bus-Snooping CPU, this function my end up doing nothing.
SYNOPSIS  APTR CachePreDMA(APTR,@{FG shine}long@{FG text} *,ULONG);
  @{i}@{b}paddress@{ub}@{ui} = CachePreDMA(@{i}vaddress@{ui},@{i}@{b}&length@{ub}@{ui},@{i}flags@{ui})
   d0                     a0       a1       d0
  @{i}vaddress@{ui} - Base address to start the action.
  @{i}length@{ui}  - Pointer to a longword with a length.
  @{"flags" link CACHEPREDMA_FLAGS}
  @{i}@{b}paddress@{ub}@{ui}- Physical address that corresponds to the input virtual address.
  @{i}@{b}&length@{ub}@{ui} - This length value will be updated to reflect the contiguous
    length of physical memory present at paddress.This may be smaller than the
    requested length.To get the mapping for the next chunk of memory, call the
    function again with a new address, length, and the DMA_Continue flag.
NOTE
  Due to processor granularity, areas outside of the address range may be
  affected by the cache flushing actions.Care has been taken to ensure that
  no harm is done outside the range, and that activities on overlapping
  cache lines won't harm data.
SEE ALSO
  exec/execbase.i, @{"CachePostDMA" Link "CachePostDMA()"}, @{"CacheClearU" Link "CacheClearU()"}, @{"CacheClearE" Link "CacheClearE()"}
@EndNode
@node CACHEPREDMA_FLAGS "CachePreDMA_flags"
@{i}DMA_Continue@{ui} - Indicates this call is to complete a prior request that was
  broken up.
@{i}DMA_ReadFromRAM@{ui} - Indicates that this DMA is a read from RAM to the DMA device
  (ie - a write to the hard drive)
  This flag is not required but if used must match in both the PreDMA and
  PostDMA calls.This flag *should* be used to help the system provide the
  best performance.This flag is safe in all versions of CachePreDMA()
@endnode
@Node "Cause()" "exec.library/Cause"
@{b}@{u}Cause@{uu}@{ub} -- cause a software interrupt.
  This function causes a software interrupt to occur.If it is called from
  user mode (and processor level 0), the software interrupt will preempt the
  current task.This call is often used by high-level hardware interrupts to
  defer medium-length processing down to a lower interrupt level.
  Note that a software interrupt is still a real interrupt, and must obey the
  same restrictions on what system function it may call.
  Currently only 5 software interrupt priorities are implemented:
  -32, -16, 0, +16, and +32.Priorities in between are truncated,
  values outside the -32/+32 range are not allowed.
SYNOPSIS  @{FG shine}void@{FG text} Cause(@{FG shine}struct@{FG text} @{"Interrupt" Link "include:exec/interrupts.h/Main" 23} *);
  Cause(@{i}interrupt@{ui})
         A1
  @{i}interrupt@{ui} - pointer to a properly initialized interrupt node
NOTE
  When setting up the Interrupt structure, set the node type to
  NT_INTERRUPT, or NT_UNKNOWN.
IMPLEMENTATION
  1> Checks if the node type is NT_SOFTINT.If so does nothing since the
     softint is already pending.No nest count is maintained.
  2> Sets the node type to NT_SOFTINT.
  3> Links into one of the 5 priority queues.
  4> Pokes the hardware interrupt bit used for softints.
  The node type returns to NT_INTERRUPT after removal from the list.
BUGS
  Unlike other Interrupts, SoftInts must preserve the value of A6.
@EndNode
@Node "CheckIO()" "exec.library/CheckIO"
@{b}@{u}CheckIO@{uu}@{ub} -- get the status of an IORequest.
  This function determines the current state of an I/O request and
  returns FALSE if the I/O has not yet completed.This function
  effectively hides the internals of the I/O completion mechanism.
  CheckIO() will NOT remove the returned IORequest from the reply port.
  This is best performed with @{"WaitIO()" Link "WaitIO()"}.If the request has already
  completed, @{"WaitIO()" Link "WaitIO()"} will return quickly.Use of the @{"Remove()" Link "Remove()"}
  function is dangerous, since other tasks may still be adding things
  to your message port; a @{"Disable()" Link "Disable()"} would be required.
  This function should NOT be used to busy loop (looping until IO is
  complete).@{"WaitIO()" Link "WaitIO()"} is provided for that purpose.
SYNOPSIS  @{FG shine}struct@{FG text} @{"IORequest" Link "include:exec/io.h/Main" 18} *CheckIO(@{FG shine}struct@{FG text} IORequest *);
  @{i}@{b}result@{ub}@{ui} = CheckIO(@{i}iORequest@{ui})
   D0               A1
  @{i}iORequest@{ui} - pointer to an I/O request block
  @{i}@{b}result@{ub}@{ui} - NULL if I/O is still in progress.
    Otherwise D0 points to the IORequest block.
NOTE
  CheckIO can hang if called on an IORequest that has never been used.
  This occurs if LN_TYPE of the IORequest is set to "NT_MESSAGE".
  Instead simply set LN_TYPE to 0.
SEE ALSO
  @{"DoIO" Link "DoIO()"}, @{"SendIO" Link "SendIO()"}, @{"WaitIO" Link "WaitIO()"}, @{"AbortIO" Link "AbortIO()"}
@EndNode
@Node "CloseDevice()" "exec.library/CloseDevice"
@{b}@{u}CloseDevice@{uu}@{ub} - conclude access to a device.
  This function informs the device that access to a device/unit previously
  opened has been concluded.The device may perform certain house-cleaning
  operations.
  The user must ensure that all outstanding IORequests have been returned before
  closing the device.The @{"AbortIO" Link "AbortIO()"} function can kill any stragglers.

  After a close, the I/O request structure is free to be reused.
  Starting with V36 exec it is safe to CloseDevice() with an
  IORequest that is either cleared to zeros, or failed to open.
SYNOPSIS  @{FG shine}void@{FG text} CloseDevice(@{FG shine}struct@{FG text} @{"IORequest" Link "include:exec/io.h/Main" 18} *);
  CloseDevice(@{i}iORequest@{ui})
               A1
  @{i}iORequest@{ui} - pointer to an I/O request structure
SEE ALSO
  @{"OpenDevice" Link "OpenDevice()"}
@EndNode
@Node "CloseLibrary()" "exec.library/CloseLibrary"
@{b}@{u}CloseLibrary@{uu}@{ub} -- conclude access to a library.
  This function informs the system that access to the given library
  has been concluded.The user must not reference the library or any
  function in the library after this close.
  Starting with V36, it is safe to pass a NULL instead of a library pointer.
SYNOPSIS  @{FG shine}void@{FG text} CloseLibrary(@{FG shine}struct@{FG text} @{"Library" Link "include:exec/libraries.h/Main" 34} *);
  CloseLibrary(@{i}library@{ui})
                A1
  @{i}library@{ui} - pointer to a library node
NOTE
  Library writers must pass a SegList pointer or NULL back from their open point.
  This value is used by the system, and not visible as a return code from
  CloseLibrary.
SEE ALSO
  @{"OpenLibrary" Link "OpenLibrary()"}
@EndNode
@Node "ColdReboot()" "exec.library/ColdReboot"
@{b}@{u}ColdReboot@{uu}@{ub} - reboot the Amiga.@{FG fill}(V36)@{FG text}
  Reboot the machine.All external memory and periperals will be
  @{"RESET" Link "RESET"}, and the machine will start its power up diagnostics.
  This function never returns.
SYNOPSIS  @{FG shine}void@{FG text} ColdReboot(@{FG shine}void@{FG text});
  ColdReboot()
  Inputs a chaotic pile of disoriented bits.
  Returns an altogether totally integrated living system.
@EndNode
@Node "CopyMem()" "exec.library/CopyMem"
@{b}@{u}CopyMem@{uu}@{ub} - general purpose memory copy function.
  CopyMem is a general purpose, fast memory copy function.It can
  deal with arbitrary lengths, with its pointers on arbitrary
  alignments.It attempts to optimize larger copies with more
  efficient copies, it uses byte copies for small moves, parts of
  larger copies, or the entire copy if the source and destination are
  misaligned with respect to each other.
  Arbitrary overlapping copies are not supported.
  The internal implementation of this function will change from
  system to system, and may be implemented via hardware DMA.
SYNOPSIS  @{FG shine}void@{FG text} CopyMem(APTR,APTR,ULONG);
  CopyMem( @{i}source@{ui}, @{i}dest@{ui}, @{i}size@{ui} )
            A0      A1    D0
  @{i}source@{ui} - a pointer to the source data region
  @{i}dest@{ui}  - a pointer to the destination data region
  @{i}size@{ui}  - the size (in bytes) of the memory area.Zero copies zero bytes
SEE ALSO
  @{"CopyMemQuick" Link "CopyMemQuick()"}
@EndNode
@Node "CopyMemQuick()" "exec.library/CopyMemQuick"
@{b}@{u}CopyMemQuick@{uu}@{ub} - optimized memory copy function.
  CopyMemQuick is a highly optimized memory copy function, with
  restrictions on the size and alignment of its arguments.Both the
  source and destination pointers must be longword aligned.In
  addition, the size must be an integral number of longwords (e.g.
  the size must be evenly divisible by four).
  Arbitrary overlapping copies are not supported.
  The internal implementation of this function will change from system
  to system, and may be implemented via hardware DMA.
SYNOPSIS  @{FG shine}void@{FG text} CopyMemQuick(ULONG *,ULONG *,ULONG);
  CopyMemQuick( @{i}source@{ui}, @{i}dest@{ui}, @{i}size@{ui} )
                 A0      A1    D0
  @{i}source@{ui} - a pointer to the source data region, long aligned
  @{i}dest@{ui} -  a pointer to the destination data region, long aligned
  @{i}size@{ui} -  the size (in bytes) of the memory area.Zero copies zero bytes.
SEE ALSO
  @{"CopyMem" Link "CopyMem()"}
@EndNode
@Node "CreateIORequest()" "exec.library/CreateIORequest"
@{b}@{u}CreateIORequest@{uu}@{ub}() -- create an IORequest structure.@{FG fill}(V36)@{FG text}
  Allocates memory for and initializes a new IO request block
  of a user-specified number of bytes.The number of bytes
  must be at least as large as a "@{FG shine}struct@{FG text} Message".
SYNOPSIS  @{FG shine}struct@{FG text} @{"IORequest" Link "include:exec/io.h/Main" 18} *CreateIORequest(@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *, ULONG);
  @{i}@{b}ioReq@{ub}@{ui} = CreateIORequest( @{i}ioReplyPort@{ui}, @{i}size@{ui} );
                            A0           D0
  @{i}ioReplyPort@{ui} - Pointer to a port for replies (an initialized message port,
    as created by @{"CreateMsgPort()" Link "CreateMsgPort()"} ).If NULL, this function fails.
  @{i}size@{ui} - the size of the IO request to be created.
  @{i}@{b}ioReq@{ub}@{ui} - A pointer to the new IORequest block, or NULL.
SEE ALSO
  @{"DeleteIORequest" Link "DeleteIORequest()"}, @{"CreateMsgPort()" Link "CreateMsgPort()"}, @{"amiga.lib/CreateExtIO()" Link "amiga_lib.guide/CreateExtIO()"}
@EndNode
@Node "CreateMsgPort()" "exec.library/CreateMsgPort"
@{b}@{u}CreateMsgPort@{uu}@{ub} - Allocate and initialize a new message port.@{FG fill}(V36)@{FG text}
  Allocates and initializes a new message port.The message list of the new port
  will be prepared for use (via NewList).A signal bit will be allocated, and the
  port will be set to signal your task when a message arrives (PA_SIGNAL).
  You *must* use @{"DeleteMsgPort()" Link "DeleteMsgPort()"} to delete ports created with CreateMsgPort()!
SYNOPSIS  @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} * CreateMsgPort(@{FG shine}void@{FG text});
  CreateMsgPort()
  @{i}@{b}MsgPort@{ub}@{ui} - A new MsgPort structure ready for use, or NULL if out of memory or
    signals.If you wish to add this port to the public port list, fill in the
    ln_Name and ln_Pri fields, then call @{"AddPort()" Link "AddPort()"}.Don't forget RemPort()!
SEE ALSO
  @{"DeleteMsgPort()" Link "DeleteMsgPort()"}, @{"AddPort()" Link "AddPort()"}, @{"exec/ports.h" Link "include:exec/ports.h/Main" 0}, @{"amiga.lib/CreatePort()" Link "amiga_lib.guide/CreatePort()"}
@EndNode
@Node "CreatePool()" "exec.library/CreatePool"
@{b}@{u}CreatePool@{uu}@{ub} -- Generate a private memory pool header.@{FG fill}(V39)@{FG text}
  Allocate and prepare a new memory pool header.Each pool is a separate
  tracking system for memory of a specific type.Any number of pools may
  exist in the system.
  Pools automatically expand and shrink based on demand.Fixed sized "puddles"
  are allocated by the pool manager when more total memory is needed.Many small
  allocations can fit in a single puddle.
  Allocations larger than the threshSize are allocation in their own puddles.
  At any time individual allocations may be freed.Or, the entire pool may be
  removed in a single step.
SYNOPSIS  @{FG shine}void@{FG text} *CreatePool(ULONG,ULONG,ULONG);
  @{i}@{b}newPool@{ub}@{ui}=CreatePool(@{i}memFlags@{ui},@{i}puddleSize@{ui},@{i}threshSize@{ui})
   a0                 d0       d1          d2
  @{i}memFlags@{ui} - a memory flags specifier, as taken by @{"AllocMem" Link "AllocMem()"}.
  @{i}puddleSize@{ui} - the size of Puddles...
  @{i}threshSize@{ui} - the largest allocation that goes into normal puddles
    This *MUST* be less than or equal to puddleSize
    (CreatePool() will fail if it is not)
  Returns the address of a new pool header, or NULL for error.
SEE ALSO
  @{"DeletePool()" Link "DeletePool()"}, @{"AllocPooled()" Link "AllocPooled()"}, @{"FreePooled()" Link "FreePooled()"}, exec/memory.i
@EndNode
@Node "Deallocate()" "exec.library/Deallocate"
@{b}@{u}Deallocate@{uu}@{ub} -- deallocate a block of memory.
  This function deallocates memory by returning it to the appropriate private
  free memory pool.This function can be used to free an entire block allocated
  with the above function, or it can be used to free a sub-block of a previously
  allocated block.Sub-blocks must be an even multiple of the memory chunk size
  (currently 8 bytes).This function can even be used to add a new free region
  to an existing MemHeader,however the extent pointers in the MemHeader will no
  longer be valid.
  If memoryBlock is not on a block boundary (MEM_BLOCKSIZE) then it will be
  rounded down in a manner compatible with @{"Allocate()" Link "Allocate()"}.
  Note that this will work correctly with all the memory allocation functions,
  but may cause surprises if one is freeing only part of a region.The size of the
  block will be rounded up, so the freed block will fill to an even memory block
  boundary.
SYNOPSIS  @{FG shine}void@{FG text} Deallocate(@{FG shine}struct@{FG text} @{"MemHeader" Link "include:exec/memory.h/Main" 28} *,APTR,ULONG);
  Deallocate(@{i}memHeader@{ui}, @{i}memoryBlock@{ui}, @{i}byteSize@{ui})
              A0         A1           D0
  @{i}memHeader@{ui} - points to the memory header this block is part of.
  @{i}memoryBlock@{ui} - address of memory block to free.
  @{i}byteSize@{ui} - the size of the block in bytes.If NULL, nothing happens.
SEE ALSO
  Allocate, @{"exec/memory.h" Link "include:exec/memory.h/Main" 0}
@EndNode
@Node "Debug()" "exec.library/Debug"
@{b}@{u}Debug@{uu}@{ub} -- run the system debugger.
  This function calls the system debugger.By default this debugger is
  "SAD" in >= V39 and "ROM-WACK" in < V39.Other debuggers are encouraged to
  take over this entry point (via @{"SetFunction()" Link "SetFunction()"}) so that when an
  application calls Debug(), the alternative debugger will get control.
  Currently a zero is passed to allow future expansion.
SYNOPSIS  @{FG shine}void@{FG text} Debug(ULONG);
  Debug(@{i}flags@{ui})
         D0
NOTE
  The Debug() call may be made when the system is in a questionable state;
  if you have a @{"SetFunction()" Link "SetFunction()"} patch, make few assumptions, be
  prepared for @{"Supervisor" Link "Supervisor()"} mode, and be aware of differences in the
  Motorola stack frames on the 68000,'10,'20,'30,'40 (etc.)
BUGS
  In ROMWack, calling this function in SUPERVISOR state would have caused the a5
  register to be trashed and the user stack pointer to be trashed.As of V39
  (and the instroduction of SAD) this is no longer the case.However, calling
  this function in @{"Supervisor" Link "Supervisor()"} state is a bit "tricky" at best...
  Note that due to a bug, pre-@{b}V40@{ub} SAD had the command codes wrong.
  See the SAD autodoc for more details.
SEE ALSO
  @{"SetFunction()" Link "SetFunction()"}
  your favorite debugger's manual...
  the SAD autodocs...
  the ROM-WACK chapter of the ROM Kernel Manual...(pre-V39)
@EndNode
@Node "DeleteIORequest()" "exec.library/DeleteIORequest"
@{b}@{u}DeleteIORequest@{uu}@{ub}() - Free a request made by @{"CreateIORequest()" Link "CreateIORequest()"}.@{FG fill}(V36)@{FG text}
  Frees up an IO request as allocated by @{"CreateIORequest()" Link "CreateIORequest()"}.
SYNOPSIS  @{FG shine}void@{FG text} DeleteIORequest(@{FG shine}struct@{FG text} @{"IORequest" Link "include:exec/io.h/Main" 18} *);
  DeleteIORequest( @{i}ioReq@{ui} );
                    a0
  @{i}ioReq@{ui} - A pointer to the IORequest block to be freed, or NULL.
    This function uses the mn_Length field to determine how much memory to free.
SEE ALSO
  @{"CreateIORequest()" Link "CreateIORequest()"}, @{"amiga.lib/DeleteExtIO()" Link "amiga_lib.guide/DeleteExtIO()"}
@EndNode
@Node "DeleteMsgPort()" "exec.library/DeleteMsgPort"
@{b}@{u}DeleteMsgPort@{uu}@{ub} - Free a message port created by @{"CreateMsgPort" Link "CreateMsgPort()"}.@{FG fill}(V36)@{FG text}
  Frees a message port created by @{"CreateMsgPort()" Link "CreateMsgPort()"}.All messages that
  may have been attached to this port must have already been replied to.
SYNOPSIS  @{FG shine}void@{FG text} DeleteMsgPort(@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *);
  DeleteMsgPort(m@{i}msgPort@{ui})
                 a0
  @{i}msgPort@{ui} - A message port.NULL for no action.
SEE ALSO
  @{"CreateMsgPort()" Link "CreateMsgPort()"}, @{"amiga.lib/DeletePort()" Link "amiga_lib.guide/DeletePort()"}
@EndNode
@Node "DeletePool()" "exec.library/DeletePool"
@{b}@{u}DeletePool@{uu}@{ub} --  Drain an entire memory pool.@{FG fill}(V39)@{FG text}
  Frees all memory in all pudles of the specified pool header, then
  deletes the pool header.Individual free calls are not needed.
SYNOPSIS  @{FG shine}void@{FG text} DeletePool(@{FG shine}void@{FG text} *);
  DeletePool(@{i}poolHeader@{ui})
              a0
  @{i}poolHeader@{ui} - as returned by @{"CreatePool()" Link "CreatePool()"}.
SEE ALSO
  @{"CreatePool()" Link "CreatePool()"}, @{"AllocPooled()" Link "AllocPooled()"}, @{"FreePooled()" Link "FreePooled()"}
@EndNode
@Node "Disable()" "exec.library/Disable"
@{b}@{u}Disable@{uu}@{ub} -- disable interrupt processing.
  Prevents interrupts from being handled by the system, until a matching
  @{"Enable()" Link "Enable()"} is executed.Disable() implies @{"Forbid()" Link "Forbid()"}.
  DO NOT USE THIS CALL WITHOUT GOOD JUSTIFICATION.THIS CALL IS VERY DANGEROUS!
  All interrupt processing is deferred until the task executing makes a call to
  @{"Enable()" Link "Enable()"} or is placed in a wait state.Normal task rescheduling does not
  occur while interrupts are disabled.In order to restore normal interrupt
  processing, the programmer must execute exactly one call to @{"Enable()" Link "Enable()"}
  for every call to Disable().
  @{b}IMPORTANT REMINDER:@{ub} It is important to remember that there is a danger in
  using disabled sections.Disabling interrupts for more than ~250 microseconds
  will prevent vital system functions (especially serial I/0) from operating in a
  normal fashion.Think twice before using Disable(), then think once more.
  After all that, think again.With enough thought, the need for a Disable() can
  often be eliminated.For the user of many device drivers, a write to disable
  *only* the particular interrupt of interest can replace a Disable().
  For example:
    MOVE.W  #INTF_PORTS,_intena
  Do not use a macro for Disable(), insist on the real thing.
  This call may be made from interrupts, it will have the effect of locking out
  all higher-level interrupts (lower-level interrupts are automatically disabled
  by the CPU).
  @{b}NOTE:@{ub} In the event of a task entering a @{"Wait()" Link "Wait()"} after disabling interrupts,
  the system "breaks" the disabled state and runs normally until the task which
  called Disable() is rescheduled.
SYNOPSIS  @{FG shine}void@{FG text} Disable(@{FG shine}void@{FG text});
  Disable(@{i}m@{ui});
NOTE
  This call is guaranteed to preserve all registers.
SEE ALSO
  Forbid, Permit, Enable
@EndNode
@Node "DoIO()" "exec.library/DoIO"
@{b}@{u}DoIO@{uu}@{ub} -- perform an I/O command and wait for completion.
  This function requests a device driver to perform the I/O command
  specified in the I/O request.This function will always wait until
  the I/O request is fully complete.
  DoIO() handles all the details, including Quick I/O, waiting for
  the request, and removing the reply message, etc..
SYNOPSIS  BYTE DoIO(@{FG shine}struct@{FG text} @{"IORequest" Link "include:exec/io.h/Main" 18} *);
  @{i}@{b}error@{ub}@{ui} = DoIO(@{i}iORequest@{ui})
   D0           A1
  @{i}iORequest@{ui} - pointer to an IORequest initialized by @{"OpenDevice()" Link "OpenDevice()"}
  @{i}@{b}error@{ub}@{ui} - a sign-extended copy of the io_Error field of the IORequest.
    Most device commands require that the error return be checked.
IMPLEMENTATION
  This function first tries to complete the IO via the "Quick I/O"
  mechanism.The io_Flags field is always set to IOF_QUICK (0x01)
  before the internal device call.
  The LN_TYPE field is used internally to flag completion.Active
  requests have type NT_MESSAGE.Requests that have been replied
  have type NT_REPLYMSG.It is illegal to start IO using a
  still active IORequest, or a request with type NT_REPLYMSG.
SEE ALSO
  @{"SendIO" Link "SendIO()"}, @{"CheckIO" Link "CheckIO()"}, @{"WaitIO" Link "WaitIO()"}, @{"AbortIO" Link "AbortIO()"}, @{"amiga.lib/BeginIO" Link "amiga_lib.guide/BeginIO()"}
@EndNode
@Node "Enable()" "exec.library/Enable"
@{b}@{u}Enable@{uu}@{ub} -- permit system interrupts to resume.
  Allow system interrupts to again occur normally, after a matching
  @{"Disable()" Link "Disable()"} has been executed.
  Interrupt processing is restored to normal operation.The
  programmer must execute exactly one call to Enable() for every call
  to @{"Disable()" Link "Disable()"}.
SYNOPSIS  @{FG shine}void@{FG text} Enable(@{FG shine}void@{FG text});
  Enable();
NOTE
  This call is guaranteed to preserve all registers.
SEE ALSO
  Forbid, Permit, Disable
@EndNode
@Node "Enqueue()" "exec.library/Enqueue"
@{b}@{u}Enqueue@{uu}@{ub} -- insert or append node to a system queue.
  Insert or append a node into a system queue.The insert is
  performed based on the node priority -- it will keep the list
  properly sorted.New nodes will be inserted in front of the first
  node with a lower priority.Hence a FIFO queue for nodes of equal priority
SYNOPSIS  @{FG shine}void@{FG text} Enqueue(@{FG shine}struct@{FG text} @{"List" Link "include:exec/lists.h/Main" 20} *, @{FG shine}struct@{FG text} @{"Node" Link "include:exec/nodes.h/Main" 22} *);
  Enqueue(@{i}list@{ui}, @{i}node@{ui})
           A0    A1
  @{i}list@{ui} - a pointer to the system queue header
  @{i}node@{ui} - the node to enqueue.
    This must be a full featured node with type, priority and name fields.
@{b}WARNING@{ub}
  This function does not arbitrate for access to the list.The
  calling task must be the owner of the involved list.
SEE ALSO
  @{"AddHead" Link "AddHead()"}, @{"AddTail" Link "AddTail()"}, Insert, Remove, @{"RemHead" Link "RemHead()"}, @{"RemTail" Link "RemTail()"}
@EndNode
@Node "FindName()" "exec.library/FindName"
@{b}@{u}FindName@{uu}@{ub} -- find a system list node with a given name.
  Traverse a system list until a node with the given name is found.
  To find multiple occurrences of a string, this function may be
  called with a node starting point.
  No arbitration is done for access to the list!  If multiple tasks access the
  same list, an arbitration mechanism such as SignalSemaphores must be used.
SYNOPSIS  @{FG shine}struct@{FG text} @{"Node" Link "include:exec/nodes.h/Main" 22} *FindName(@{FG shine}struct@{FG text} @{"List" Link "include:exec/lists.h/Main" 20} *, STRPTR);
  @{i}@{b}node@{ub}@{ui} = FindName(@{i}start@{ui}, @{i}name@{ui})
   D0,Z            A0     A1
  @{i}start@{ui} - a list header or a list node to start the search
    (if node, this one is skipped)
  @{i}name@{ui} - a pointer to a name string terminated with NULL
  @{i}@{b}node@{ub}@{ui} - a pointer to the node with the same name else zero to indicate that the
    string was not found.
@EndNode
@Node "FindPort()" "exec.library/FindPort"
@{b}@{u}FindPort@{uu}@{ub} -- find a given system message port.
  This function will search the system message port list for a port
  with the given name.The first port matching this name will be
  returned.No arbitration of the port list is done.This function
  MUST be protected with A @{"Forbid()/Permit()" Link "Permit()"} pair!
SYNOPSIS  @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *FindPort(STRPTR);
  @{i}@{b}port@{ub}@{ui} = FindPort(@{i}name@{ui})
   D0              A1
  @{i}name@{ui} - name of the port to find
  @{i}@{b}port@{ub}@{ui} - a pointer to the message port, or zero if not found.
EXAMPLE
  @{b}#include@{ub} @{"<exec/types.h>" Link "include:exec/types.h/Main" 0}
  @{FG shine}struct@{FG text} MsgPort *FindPort();
  ULONG SafePutToPort(@{i}message@{ui}, @{i}portname@{ui})
  @{FG shine}struct@{FG text} @{"Message" Link "include:exec/ports.h/Main" 48} *@{i}message@{ui};
  STRPTR  @{i}portname@{ui};
  {
    @{FG shine}struct@{FG text} MsgPort *@{i}port@{ui};
    Forbid();
    @{i}port@{ui} = FindPort(@{i}portname@{ui});
    @{FG shine}if@{FG text} (@{i}port@{ui})
      PutMsg(@{i}port@{ui},@{i}message@{ui});
    Permit();
    @{FG shine}return@{FG text}((ULONG)@{i}port@{ui}); /* If zero, the port has gone away */
  }
@EndNode
@Node "FindResident()" "exec.library/FindResident"
@{b}@{u}FindResident@{uu}@{ub} - find a resident module by name.
  Search the system resident tag list for a resident tag ("ROMTag") with the
  given name.If found return a pointer to the resident tag structure, else
  return zero.
  Resident modules are used by the system to pull all its parts together at
  startup.Resident tags are also found in disk based devices and libraries.
SYNOPSIS  @{FG shine}struct@{FG text} @{"Resident" Link "include:exec/resident.h/Main" 19} *FindResident(STRPTR);
  @{i}@{b}resident@{ub}@{ui} = FindResident(@{i}name@{ui})
   D0                      A1
  @{i}name@{ui} - pointer to name string
  @{i}@{b}resident@{ub}@{ui} - pointer to the resident tag structure or zero if none found.
SEE ALSO
  @{"exec/resident.h" Link "include:exec/resident.h/Main" 0}, @{"InitResident" Link "InitResident()"}
@EndNode
@Node "FindSemaphore()" "exec.library/FindSemaphore"
@{b}@{u}FindSemaphore@{uu}@{ub} -- find a given system signal semaphore.
  This function will search the system signal semaphore list for a semaphore
  with the given name.The first semaphore matching this name will be returned.
  This function does not arbitrate for access to the semaphore list,
  surround the call with a @{"Forbid()/Permit()" Link "Permit()"} pair.
SYNOPSIS  @{FG shine}struct@{FG text} @{"SignalSemaphore" Link "include:exec/semaphores.h/Main" 40} *FindSemaphore(STRPTR);
  @{i}@{b}signalSemaphore@{ub}@{ui} = FindSemaphore(@{i}name@{ui})
   D0                              A1
  @{i}name@{ui} - name of the semaphore to find
  @{i}@{b}semaphore@{ub}@{ui} - a pointer to the signal semaphore, or zero if not found.
@EndNode
@Node "FindTask()" "exec.library/FindTask"
@{b}@{u}FindTask@{uu}@{ub} -- find a task with the given name or find oneself.
  This function will check all task queues for a task with the given name,
  and return a pointer to its task control block.If a NULL name pointer is
  given a pointer to the current task will be returned.
  Finding oneself with a NULL for the name is very quick.Finding a task by
  name is very system expensive, and will disable interrupts for a long time.
  Since a task may remove itself at any time,a @{"Forbid()/Permit()" Link "Permit()"} pair may be
  needed to ensure the pointer returned by FindTask() is still valid when used.
SYNOPSIS  @{FG shine}struct@{FG text} @{"Task" Link "include:exec/tasks.h/Main" 24} *FindTask(STRPTR);
  @{i}@{b}task@{ub}@{ui} = FindTask(@{i}name@{ui})
   D0              A1
  @{i}name@{ui} - pointer to a name string
  @{i}@{b}task@{ub}@{ui} - pointer to the task (or Process)
@EndNode
@Node "Forbid()" "exec.library/Forbid"
@{b}@{u}Forbid@{uu}@{ub} -- forbid task rescheduling.
  Prevents other tasks from being scheduled to run by the dispatcher, until a
  matching @{"Permit()" Link "Permit()"} is executed, or this task is scheduled to @{"Wait()" Link "Wait()"}.
  Interrupts are NOT disabled.
  DO NOT USE THIS CALL WITHOUT GOOD JUSTIFICATION.THIS CALL IS DANGEROUS!
  The current task will not be rescheduled as long as it is ready to
  run.In the event that the current task enters a wait state, other
  tasks may be scheduled.Upon return from the wait state, the original
  task will continue to run without disturbing the Forbid().
  Calls to Forbid() nest.In order to restore normal task rescheduling,
  the programmer must execute exactly one call to @{"Permit()" Link "Permit()"} for every call to Forbid().
SYNOPSIS  @{FG shine}void@{FG text} Forbid(@{FG shine}void@{FG text});
  Forbid()
@{b}WARNING@{ub}
  In the event of a task entering a @{"Wait()" Link "Wait()"} after a Forbid(), the system
  "breaks" the forbidden state and runs normally until the task which called
  Forbid() is rescheduled.If caution is not taken, this can cause subtle bugs,
  since any device or DOS call will (in effect) cause your task to wait.
  Forbid() is not useful or safe from within interrupt code
  (All interrupts are always higher priority than tasks, and interrupts are
  allowed to break a Forbid()).
NOTE
  This call is guaranteed to preserve all registers.
SEE ALSO
  Permit, Disable, @{"ObtainSemaphore" Link "ObtainSemaphore()"}, @{"ObtainSemaphoreShared" Link "ObtainSemaphoreShared()"}
@EndNode
@Node "FreeEntry()" "exec.library/FreeEntry"
@{b}@{u}FreeEntry@{uu}@{ub} -- free many regions of memory.
  This function takes a memList structure (as returned by AllocEntry)
  and frees all the entries.
SYNOPSIS  @{FG shine}void@{FG text} FreeEntry(@{FG shine}struct@{FG text} @{"MemList" Link "include:exec/memory.h/Main" 56} *);
  FreeEntry(@{i}memList@{ui})
             A0
  @{i}memList@{ui} -- pointer to structure filled in with @{"MemEntry" Link "include:exec/memory.h/Main" 40} structures
SEE ALSO
  @{"AllocEntry" Link "AllocEntry()"}
@EndNode
@Node "FreeMem()" "exec.library/FreeMem"
@{b}@{u}FreeMem@{uu}@{ub} -- deallocate with knowledge.
  Free a region of memory, returning it to the system pool from which
  it came.Freeing partial blocks back into the system pool is unwise.
SYNOPSIS  @{FG shine}void@{FG text} FreeMem(@{FG shine}void@{FG text} *,ULONG);
  FreeMem(@{i}memoryBlock@{ui}, @{i}byteSize@{ui})
           A1            D0
  @{i}memoryBlock@{ui} - pointer to the memory block to free
  @{i}byteSize@{ui} - the size of the desired block in bytes.
    (The operating system will automatically round this number to a multiple of
    the system memory chunk size)
NOTE
  If a block of memory is freed twice, the system will Guru.The
  Alert is AN_FreeTwice ($01000009).If you pass the wrong pointer,
  you will probably see AN_MemCorrupt $01000005.Future versions may
  add more sanity checks to the memory lists.
SEE ALSO
  @{"AllocMem" Link "AllocMem()"}
@EndNode
@Node "FreePooled()" "exec.library/FreePooled"
@{b}@{u}FreePooled@{uu}@{ub} -- Free pooled memory.@{FG fill}(V39)@{FG text}
  Deallocates memory allocated by @{"AllocPooled()" Link "AllocPooled()"}.The size of the
  allocation *MUST* match the size given to @{"AllocPooled()" Link "AllocPooled()"}.
  The reason the pool functions do not track individual allocation
  sizes is because many of the uses of pools have small allocation
  sizes and the tracking of the size would be a large overhead.
  Only memory allocated by @{"AllocPooled()" Link "AllocPooled()"} may be freed with this function!
  Doing a @{"DeletePool()" Link "DeletePool()"} on the pool will free all of the puddles
  and thus all of the allocations done with @{"AllocPooled()" Link "AllocPooled()"} in that pool.
  (No need to FreePooled() each allocation)
SYNOPSIS  @{FG shine}void@{FG text} FreePooled(@{FG shine}void@{FG text} *,@{FG shine}void@{FG text} *,ULONG);
  FreePooled(@{i}poolHeader@{ui},@{i}memory@{ui},@{i}memSize@{ui})
              a0         a1      d0
  @{i}memory@{ui} - pointer to memory allocated by AllocPooled.
  @{i}poolHeader@{ui} - a specific private pool header.
NOTES
  The pool function do not protect an individual pool from multiple accesses.
  The reason is that in most cases the pools will be used by a single task.
  If your pool is going to be used by more than one task you must @{"Semaphore" Link "include:exec/semaphores.h/Main" 53}
  protect the pool from having more than one task trying to allocate within the
  same pool at the same time.
  @{b}WARNING:@{ub} @{"Forbid()" Link "Forbid()"} protection *will not work* in the future.*Do NOT* assume
  that we will be able to make it work in the future.FreePooled() may well break
  a @{"Forbid()" Link "Forbid()"} and as such can only be protected by a semaphore.
  To track sizes yourself, the following code can be used:
  Assumes a6=ExecBase
  ; Function to do AllocVecPooled(Pool,memSize)
  AllocVecPooled: addq.l  #4,d0   ; Get space for tracking
    move.l  d0,-(sp)  ; Save the size
    jsr _LVOAllocPooled(a6) ; Call pool...
    move.l  (sp)+,d1  ; Get size back...
    tst.l d0    ; Check for error
    beq.s avp_fail  ; If NULL, failed!
    move.l  d0,a0   ; Get pointer...
    move.l  d1,(a0)+  ; Store size
    move.l  a0,d0   ; Get result
  avp_fail: rts     ; return
  ; Function to do FreeVecPooled(pool,memory)
  FreeVecPooled:  move.l  -(a1),d0  ; Get size / ajust pointer
   jmp _LVOFreePooled(a6)
SEE ALSO
  @{"AllocPooled()" Link "AllocPooled()"}, @{"CreatePool()" Link "CreatePool()"}, @{"DeletePool()" Link "DeletePool()"}
@EndNode
@Node "FreeSignal()" "exec.library/FreeSignal"
@{b}@{u}FreeSignal@{uu}@{ub} -- free a signal bit.
  This function frees a previously allocated signal bit for reuse.This call must
  be performed while running in the same task in which the signal was allocated.
SYNOPSIS  @{FG shine}void@{FG text} FreeSignal(BYTE);
  FreeSignal(@{i}signalNum@{ui})
              D0
  @{i}signalNum@{ui} - the signal number to free {0..31}.
@{b}WARNING@{ub}
  Signals may not be allocated or freed from exception handling code.
NOTE
  Starting with V37, an attempt to free signal -1 is harmless.
@EndNode
@Node "FreeTrap()" "exec.library/FreeTrap"
@{b}@{u}FreeTrap@{uu}@{ub} -- free a processor trap.
  This function frees a previously allocated trap number for reuse.This call must
  be performed while running in the same task in which the trap was allocated.
SYNOPSIS  @{FG shine}void@{FG text} FreeTrap(ULONG);
  FreeTrap(@{i}trapNum@{ui})
            D0
  @{i}trapNum@{ui} - the trap number to free {of 0..15}
@{b}WARNING@{ub}
  Traps may not be allocated or freed from exception handling code.
@EndNode
@Node "FreeVec()" "exec.library/FreeVec"
@{b}@{u}FreeVec@{uu}@{ub} -- return @{"AllocVec()" Link "AllocVec()"} memory to the system.@{FG fill}(V36)@{FG text}
  Free an allocation made by the @{"AllocVec()" Link "AllocVec()"} call.The memory will
  be returned to the system pool from which it came.
SYNOPSIS  @{FG shine}void@{FG text} FreeVec(@{FG shine}void@{FG text} *);
  FreeVec(@{i}memoryBlock@{ui})
           A1
  @{i}memoryBlock@{ui} - pointer to the memory block to free, or NULL.
NOTE
  If a block of memory is freed twice, the system will Guru.The
  Alert is AN_FreeTwice ($01000009).If you pass the wrong pointer,
  you will probably see AN_MemCorrupt $01000005.Future versions may
  add more sanity checks to the memory lists.
SEE ALSO
  @{"AllocVec" Link "AllocVec()"}
@EndNode
@Node "GetCC()" "exec.library/GetCC"
@{b}@{u}GetCC@{uu}@{ub} -- get condition codes in a 68010 compatible way.
  The 68000 processor has a "MOVE SR,<ea>" instruction which gets a copy of the
  processor condition codes.
  On the 68010,20 and 30 CPUs, "MOVE SR,<ea>" is privileged.User code will
  trap if it is attempted.These processors need to use the "MOVE CCR,<ea>"
  instruction instead.
  This function provides a means of obtaining the CPU condition codes in a
  manner that will make upgrades transparent.
  This function is VERY short and quick.
SYNOPSIS  UWORD GetCC(@{FG shine}void@{FG text});
  @{i}@{b}conditions@{ub}@{ui} = GetCC()
   D0
  @{i}@{b}conditions@{ub}@{ui} - the 680XX condition codes
NOTE
  This call is guaranteed to preserve all registers.This function
  may be implemented as code right in the jump table.
@EndNode
@Node "GetMsg()" "exec.library/GetMsg"
@{b}@{u}GetMsg@{uu}@{ub} -- get next message from a message port.
  This function receives a message from a given message port.It provides a fast,
  non-copying message receiving mechanism.The received message is removed from
  the message port.This function will not wait.If a message is not present
  this function will return zero.If a program must wait for a message, it can
  @{"Wait()" Link "Wait()"} on the signal specified for the port or use the
  @{"WaitPort()" Link "WaitPort()"} function.There can only be one task waiting for any given port.
  Getting a message does not imply to the sender that the message is free to be
  reused by the sender.When the receiver is finished with the message, it may
  @{"ReplyMsg()" Link "ReplyMsg()"} it back to the sender.
  Getting a signal does NOT always imply a message is ready.More than one message
  may arrive per signal, and signals may show up without messages.Typically you
  must loop to GetMsg() until it returns zero, then @{"Wait()" Link "Wait()"} or @{"WaitPort()" Link "WaitPort()"}.
SYNOPSIS  @{FG shine}struct@{FG text} @{"Message" Link "include:exec/ports.h/Main" 48} *GetMsg(@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *);
  @{i}@{b}message@{ub}@{ui} = GetMsg(@{i}port@{ui})
   D0               A0
  @{i}port@{ui} - a pointer to the receiver message port
  @{i}@{b}message@{ub}@{ui} - a pointer to the first message available.
    If there are no messages, return zero.
    Callers must be prepared for zero at any time.
SEE ALSO
  @{"PutMsg" Link "PutMsg()"}, @{"ReplyMsg" Link "ReplyMsg()"}, @{"WaitPort" Link "WaitPort()"}, Wait, @{"exec/ports.h" Link "include:exec/ports.h/Main" 0}
@EndNode
@Node "InitCode()" "exec.library/InitCode"
@{b}@{u}InitCode@{uu}@{ub} - initialize resident code modules (internal function).
  (This function may be ignored by application programmers)
  Call @{"InitResident()" Link "InitResident()"} for all resident modules in the ResModules array
  with the given startClass and with versions equal or greater than
  that specified.The segList parameter is passed as zero.
  @{"Resident" Link "include:exec/resident.h/Main" 19} modules are used by the system to pull all its parts
  together at startup.Modules are initialized in a prioritized order.
  Modules that do not have a startclass should be of priority -120.
  RTF_AFTERDOS modules should start at -100 (working down).
SYNOPSIS  @{FG shine}void@{FG text} InitCode(ULONG,ULONG);
  InitCode(@{i}startClass@{ui}, @{i}version@{ui})
            D0          D1
  @{i}startClass@{ui} - the class of code to be initialized:
    BITDEF RT,COLDSTART,0
    BITDEF RT,SINGLETASK,1  ;ExecBase->ThisTask==0 (V36 only)
    BITDEF RT,AFTERDOS,2  ;(V36 only)
  @{i}version@{ui} - a major version number
SEE ALSO
  ResidentTag (RT) structure definition (resident.h)
@EndNode
@Node "InitResident()" "exec.library/InitResident"
@{b}@{u}InitResident@{uu}@{ub} - initialize resident module.
  Initialize a ROMTag.ROMTags are used to link system modules together.
  Each disk based device or library must contain a ROMTag structure in the
  first code hunk. Once the validity of the ROMTag is verified, the RT_INIT
  pointer is jumped to  with the following registers:
    D0 = 0
    A0 = segList
    A6 = @{"ExecBase" Link "include:exec/execbase.h/Main" 34}
SYNOPSIS  APTR InitResident(@{FG shine}struct@{FG text} @{"Resident" Link "include:exec/resident.h/Main" 19} *,ULONG);
  @{i}@{b}object@{ub}@{ui} = InitResident(@{i}resident@{ui}, @{i}segList@{ui})
   D0                    A1         D1
  @{i}resident@{ui} - Pointer to a ROMTag
  @{i}segList@{ui}  - SegList of the loaded object, if loaded from disk.
    Libraries & Devices will cache this value for later return at
    close or expunge time.Pass NULL for ROM modules.
  @{i}@{b}object@{ub}@{ui}  - Return value from the init code, usually the library
    or device base.NULL for failure.
AUTOINIT FEATURE
  An automatic method of library/device base and vector table initialization is
  also provided by InitResident().The initial code hunk of the library or device
  should contain "MOVEQ #-1,d0; RTS;".Following that must be an initialized
  Resident structure with RTF_AUTOINIT set in rt_Flags, and an rt_Init pointer
  which points to four longwords.These four longwords will be used in a call to
  MakeLibrary();
  - The size of your library/device base structure including initial
    Library or @{"Device" Link "include:exec/devices.h/Main" 25} structure.
  - A pointer to a longword table of standard, then library specific
    function offsets, terminated with -1L.
    (short format offsets are also acceptable)
  - Pointer to data table in @{"InitStruct" Link "InitStruct()"} format for initialization of
    @{"Library" Link "include:exec/libraries.h/Main" 34} or Device structure.
  - Pointer to library initialization function, or NULL.
    Calling sequence:
      D0 = library base
      A0 = segList
      A6 = ExecBase
        This function must return in D0 the library/device base to be linked into
        the library/device list.If the initialization function fails, the device
        memory must be manually deallocated, then NULL returned in D0.
SEE ALSO
  exec/resident.i, @{"FindResident" Link "FindResident()"}
@EndNode
@Node "InitSemaphore()" "exec.library/InitSemaphore"
@{b}@{u}InitSemaphore@{uu}@{ub} -- initialize a signal semaphore.
  This function initializes a signal semaphore and prepares it for use.
  It does not allocate anything, but does initialize list pointers and the
  semaphore counters.
  Semaphores are often used to protect critical data structures or hardware that
  can only be accessed by one task at a time.After initialization, the address
  of the SignalSemaphore may be made available to any number of tasks.Typically a
  task will try to @{"ObtainSemaphore()" Link "ObtainSemaphore()"}, passing this address in.If no other task
  owns the semaphore, then the call will lock and return quickly.If more tasks
  try to @{"ObtainSemaphore()" Link "ObtainSemaphore()"}, they will be put to sleep.When the owner of the
  semaphore releases it, the next waiter in turn will be woken up.
  Semaphores are often preferable to the old-style @{"Forbid()/Permit()" Link "Permit()"} type
  arbitration.With @{"Forbid()/Permit()" Link "Permit()"} *all* other tasks are prevented from
  running.With semaphores, only those tasks that need access to whatever the
  semaphore protects are subject to waiting.
SYNOPSIS  @{FG shine}void@{FG text} InitSemaphore(@{FG shine}struct@{FG text} @{"SignalSemaphore" Link "include:exec/semaphores.h/Main" 40} *);
  InitSemaphore(@{i}signalSemaphore@{ui})
                 A0
  @{i}signalSemaphore@{ui} -- a signal semaphore structure
    (with all fields set to zero before the call)
SEE ALSO
  @{"ObtainSemaphore" Link "ObtainSemaphore()"}, @{"ObtainSemaphoreShared" Link "ObtainSemaphoreShared()"}, @{"AttemptSemaphore" Link "AttemptSemaphore()"},
  @{"ReleaseSemaphore" Link "ReleaseSemaphore()"}, @{"Procure" Link "Procure()"}, @{"Vacate" Link "Vacate()"}, @{"exec/semaphores.h" Link "include:exec/semaphores.h/Main" 0}
@EndNode
@Node "InitStruct()" "exec.library/InitStruct"
@{b}@{u}InitStruct@{uu}@{ub} - initialize memory from a table.
  Clear a memory area, then set up default values according to the data and
  offset values in the initTable.Typically only assembly programs take advantage
  of this function, and only with the macros defined in "exec/initializers.i".
  The initialization table has byte commands to
       |a    ||byte|  |given||byte|       |once     |
  load |count||word| into |next ||rptr| offset, |repetitively |
        |long|
  Not all combinations are supported.The offset, when specified, is
  relative to the memory pointer provided (Memory), and is initially
  zero.The initialization data (InitTable) contains byte commands
  whose 8 bits are interpreted as follows:
  ddssnnnn
    dd  the destination type (and size):
      00  no offset, use next destination, nnnn is count
      01  no offset, use next destination, nnnn is repeat
      10  destination offset is in the next byte, nnnn is count
      11  destination offset is in the next 24-bits, nnnn is count
    ss  the size and location of the source:
      00  @{FG shine}long@{FG text}, from the next two aligned words
      01  word, from the next aligned word
      10  byte, from the next byte
      11  ERROR - will cause an ALERT (see below)
    nnnn  the count or repeat:
      count  the (number+1) of source items to copy
      repeat  the source is copied (number+1) times.
  initTable commands are always read from the next even byte.Given
  destination offsets are always relative to the memory pointer (A2).
  The command %00000000 ends the InitTable stream: use %00010001 if you
  really want to copy one longword without a new offset.
  24 bit APTR not supported for 68020 compatibility -- use @{FG shine}long@{FG text}.
SYNOPSIS  @{FG shine}void@{FG text} InitStruct(@{FG shine}struct@{FG text} InitStruct *, APTR, ULONG);
  InitStruct(@{i}initTable@{ui}, @{i}memory@{ui}, @{i}size@{ui});
              A1         A2       D0
  @{i}initTable@{ui} - the beginning of the commands and data to init Memory with.
    Must be on an even boundary unless only byte initialization is done.
    End table with "dc.b 0" or "dc.w 0".
  @{i}memory@{ui} - the beginning of the memory to initialize.
    Must be on an even boundary if size is specified.
  @{i}size@{ui} - the size of memory, which is used to clear it before initializing it
    via the initTable.If Size is zero, memory is not cleared before initializing.
    size must be an even number.
SEE ALSO
  exec/initializers.i
@EndNode
@Node "Insert()" "exec.library/Insert"
@{b}@{u}Insert@{uu}@{ub} -- insert a node into a list.
  Insert a node into a doubly linked list AFTER a given node position.Insertion
  at the head of a list is possible by passing a zero value for listNode,though
  the @{"AddHead" Link "AddHead()"} function is slightly faster for that special case.
SYNOPSIS  @{FG shine}void@{FG text} Insert(@{FG shine}struct@{FG text} @{"List" Link "include:exec/lists.h/Main" 20} *, @{FG shine}struct@{FG text} @{"Node" Link "include:exec/nodes.h/Main" 22} *, @{FG shine}struct@{FG text} Node *);
  Insert(@{i}list@{ui}, @{i}node@{ui}, @{i}listNode@{ui})
          A0    A1     A2
  @{i}list@{ui} - a pointer to the target list header
  @{i}node@{ui} - the node to insert
  @{i}listNode@{ui} - the node after which to insert
@{b}WARNING@{ub}
  This function does not arbitrate for access to the list.The
  calling task must be the owner of the involved list.
SEE ALSO
  @{"AddHead" Link "AddHead()"}, @{"AddTail" Link "AddTail()"}, @{"Enqueue" Link "Enqueue()"}, @{"RemHead" Link "RemHead()"}, Remove, @{"RemTail" Link "RemTail()"}
@EndNode
@Node "MakeFunctions()" "exec.library/MakeFunctions"
@{b}@{u}MakeFunctions@{uu}@{ub} -- construct a function jump table.
  A low level function used by @{"MakeLibrary" Link "MakeLibrary()"} to build jump tables of
  the type used by libraries, devices and resources.It allows the
  table to be built anywhere in memory, and can be used both for
  initialization and replacement.This function also supports function
  pointer compression by expanding relative displacements into absolute pointers.
  The processor instruction cache is cleared after the table building.
SYNOPSIS  ULONG MakeFunctions(APTR,APTR,APTR);
  @{i}@{b}tableSize@{ub}@{ui} = MakeFunctions(@{i}target@{ui}, @{i}functionArray@{ui}, @{i}funcDispBase@{ui})
   D0                        A0       A1             A2
  @{i}destination@{ui} - the target address for the high memory end of the
    function jump table.Typically this will be the library base pointer.
  @{i}functionArray@{ui} - pointer to an array of function pointers or function
    displacements.If funcDispBase is zero, the arrayis assumed to contain
    absolute pointers to functions.If funcDispBase is not zero, then the
    array is assumed to contain word displacements to functions.In both cases,
    the array is terminated by a -1 (of the same size as the actual entry.
  @{i}funcDispBase@{ui} - pointer to the base about which all function displacements are
    relative.If zero, then the function array contains absolute pointers.
  @{i}@{b}tableSize@{ub}@{ui} - size of the new table in bytes (for LIB_NEGSIZE).
SEE ALSO
  @{"MakeLibrary" Link "MakeLibrary()"}
@EndNode
@Node "MakeLibrary()" "exec.library/MakeLibrary"
@{b}@{u}MakeLibrary@{uu}@{ub} -- construct a library.
  This function is used for constructing a library vector and data area.
  The same call is used to make devices.Space for the library is allocated
  from the system's free memory pool.The data portion of the library is
  initialized.init may point to a library specific entry point.
SYNOPSIS
  @{FG shine}struct@{FG text} @{"Library" Link "include:exec/libraries.h/Main" 34} *MakeLibrary (APTR,@{FG shine}struct@{FG text} @{"InitStruct" Link "InitStruct()"} *,APTR,ULONG,BPTR);
  @{i}@{b}library@{ub}@{ui} = MakeLibrary(@{i}vectors@{ui}, @{i}structure@{ui}, @{i}init@{ui}, @{i}dSize@{ui}, @{i}segList@{ui})
   D0                    A0        A1         A2    D0     D1
  @{i}vectors@{ui} - pointer to an array of function pointers or function displacements.
    If the first word of the array is -1, then the array contains relative word
    displacements (based off of vectors); otherwise, the array contains absolute
    function pointers.The vector list is terminated by a -1
    (of the same size as the pointers).
  @{i}structure@{ui} - points to an "InitStruct" data region.
    If NULL, then it will not be used.
  @{i}init@{ui} - If non-NULL, an entry point that will be called before adding the
    library to the system.Registers are as follows:
      d0 = libAddr  ;Your Library Address
      a0 = segList  ;Your AmigaDOS segment list
      a6 = @{"ExecBase" Link "include:exec/execbase.h/Main" 34}  ;Address of exec.library
    The result of the init function must be the library address, or NULL for
    failure.If NULL, the init point must manually deallocate the library base
    memory (based on the sizes stored in lib_PosSize and lib_NegSize).
  @{i}dSize@{ui} - the size of the library data area, including the standard library
    node data.This must be at leas @{FG shine}sizeof@{FG text}(@{FG shine}struct@{FG text} Library).
  @{i}segList@{ui} - pointer to an AmigaDOS SegList (segment list).
    This is passed to a library's init code, and is used later for removing the
    library from memory.
  @{i}@{b}library@{ub}@{ui} - the reference address of the library.
    This is the address used in references to the library, not the beginning
    of the memory area allocated.If the library vector table require more
    system memory than is available, this function will return NULL.
NOTE
  Starting with V36, the library base is longword adjusted.The lib_PosSize and
  lib_NegSize fields of the library structure are adjusted to match.
SEE ALSO
  @{"InitStruct" Link "InitStruct()"}, @{"InitResident" Link "InitResident()"}, exec/initializers.i
@EndNode
@Node "ObtainQuickVector()" "exec.library/ObtainQuickVector"
@{b}@{u}ObtainQuickVector@{uu}@{ub} -- obtain and install a Quick @{"Interrupt" Link "include:exec/interrupts.h/Main" 23} vector.@{FG fill}(V39)@{FG text}
  This function will install the code pointer into the quick interrupt
  vector it allocates and returns to you the interrupt vector that
  your Quick Interrupt system needs to use.
  This function may also return 0 if no vectors are available.Your
  hardware should be able to then fall back to using the shared
  interrupt server chain should this happen.
  The interrupt code is a direct connect to the physical interrupt.
  This means that it is the responsibility of your code to do all
  of the context saving/restoring required by interrupt code.
  Also, due to the performance of the interrupt controller, you may
  need to also watch for "false" interrupts.These are interrupts
  that come in just after a DISABLE.The reason this happens is
  because the interrupt may have been posted before the DISABLE
  hardware access is completed.For example:
  myInt:    move.l  d0,-(sp)  ; Save d0...
    move.w  _intenar,d0 ; Get interrupt enable state
    btst.l  #INTB_INTEN,d0  ; Check if pending disable
    bne.s realInt   ; If not, do real one...
  exitInt:  move.l  (sp)+,d0  ; Restore d0
    rte     ; Return from int...
  realInt:  ; Now do your int code...d0 is already saved
    ; ALL other registers need to be saved if needed
    ; This includes a0/a1/d0/d1 as this is an interrupt
    ; and not a function call...
    bra.s exitInt   ; Exit interrupt...
  If your interrupt will not play with system (OS) structures and your
  own structures are safe to play with you do not need to check for
  the disable.It is only needed for when the system is in disable but
  that "one last interrupt" still got through.
SYNOPSIS  ULONG ObtainQuickVector(APTR);
  @{i}@{b}vector@{ub}@{ui}=ObtainQuickVector(@{i}interruptCode@{ui})
   d0                        a0
  Returns a pointer to your interrupt code.This code is not an EXEC interrupt
  but is dirrectly connected to the hardware interrupt.Thus, the interrupt code
  must not modify any registers and must return via an RTE.
  The 8-bit vector number is used for Zorro-III Quick Interrupts.
  If it returns 0, no quick interrupt was allocatable.The device should at this
  point switch to using the shared interrupt server method.
NOTE
  This function was not implemented fully until V39.Due to a mis-cue
  it is not safe to call in V37 EXEC.(Sorry)
@EndNode
@Node "ObtainSemaphore()" "exec.library/ObtainSemaphore"
@{b}@{u}ObtainSemaphore@{uu}@{ub} -- gain exclusive access to a semaphore.
  @{"Signal" Link "Signal()"} semaphores are used to gain exclusive access to an object.
  ObtainSemaphore is the call used to gain this access.If another user currently
  has the semaphore locked the call will block until the object is available.
  If the current task already has locked the semaphore and attempts to lock it
  again the call will still succeed.A "nesting count" is incremented each time
  the current owning task of the semaphore calls ObtainSemaphore().This counter
  is decremented each time @{"ReleaseSemaphore()" Link "ReleaseSemaphore()"} is called.When the counter returns
  to zero the semaphore is actually released,and the next waiting task is called.
  A queue of waiting tasks is maintained on the stacks of the waiting tasks.Each
  will be called in turn as soon as the current task releases the semaphore.
  @{"Signal" Link "Signal()"} Semaphores are different than @{"Procure()/Vacate()" Link "Vacate()"} semaphores.
  The former requires less CPU time, especially if the semaphore is not currently
  locked.They require very little set up and user thought.The latter flavor of
  semaphore make no assumptions about how they are used -- they are completely
  general.Unfortunately they are not as efficient as signal semaphores, and
  require the locker to have done some setup before doing the call.
SYNOPSIS  @{FG shine}void@{FG text} ObtainSemaphore(@{FG shine}struct@{FG text} @{"SignalSemaphore" Link "include:exec/semaphores.h/Main" 40} *);
  ObtainSemaphore(@{i}signalSemaphore@{ui})
                   A0
  @{i}signalSemaphore@{ui} -- an initialized signal semaphore structure
NOTE
  This function preserves all registers (see BUGS).
BUGS
  Until V37, this function could destroy A0.
SEE ALSO
  @{"ObtainSemaphoreShared()" Link "ObtainSemaphoreShared()"}, @{"InitSemaphore()" Link "InitSemaphore()"}, @{"ReleaseSemaphore()" Link "ReleaseSemaphore()"},
  @{"AttemptSemaphore()" Link "AttemptSemaphore()"}, @{"ObtainSemaphoreList()" Link "ObtainSemaphoreList()"}, @{"Procure()" Link "Procure()"}, @{"Vacate()" Link "Vacate()"}
@EndNode
@Node "ObtainSemaphoreList()" "exec.library/ObtainSemaphoreList"
@{b}@{u}ObtainSemaphoreList@{uu}@{ub} -- get a list of semaphores.
  @{"Signal" Link "Signal()"} semaphores may be linked together into a list.This function takes a
  list of these semaphores and attempts to lock all of them at once.This call is
  preferable to applying @{"ObtainSemaphore()" Link "ObtainSemaphore()"} to each element in the list because
  it attempts to lock all the elements simultaneously, and won't deadlock if
  someone is attempting to lock in some other order.
  This function assumes that only one task at a time will attempt to lock the
  entire list of semaphores.In other words,there needs to be a higher level lock
  (perhaps another signal semaphore...) that is used before someone attempts to
  lock the semaphore list via ObtainSemaphoreList().
  Note that deadlocks may result if this call is used AND someone attempts to
  use @{"ObtainSemaphore()" Link "ObtainSemaphore()"} to lock more than one semaphore on the list.If you
  wish to lock more than semaphore (but not all of them) then you should obtain
  the higher level lock (see above).
SYNOPSIS  @{FG shine}void@{FG text} ObtainSemaphoreList(@{FG shine}struct@{FG text} @{"List" Link "include:exec/lists.h/Main" 20} *);
  ObtainSemaphoreList(@{i}list@{ui})
                       A0
  @{i}list@{ui} -- a list of signal semaphores
SEE ALSO
  @{"ObtainSemaphoreShared()" Link "ObtainSemaphoreShared()"}, @{"InitSemaphore()" Link "InitSemaphore()"}, @{"ReleaseSemaphore()" Link "ReleaseSemaphore()"},
  @{"AttemptSemaphore()" Link "AttemptSemaphore()"}, @{"ObtainSemaphoreShared()" Link "ObtainSemaphoreShared()"}, @{"Procure()" Link "Procure()"}, @{"Vacate()" Link "Vacate()"}
@EndNode
@Node "ObtainSemaphoreShared()" "exec.library/ObtainSemaphoreShared"
@{b}@{u}ObtainSemaphoreShared@{uu}@{ub} -- gain shared access to a semaphore.@{FG fill}(V36)@{FG text}
  A lock on a signal semaphore may either be exclusive, or shared.
  Exclusive locks are granted by the @{"ObtainSemaphore()" Link "ObtainSemaphore()"} and
  @{"AttemptSemaphore()" Link "AttemptSemaphore()"} functions.Shared locks are granted by
  ObtainSemaphoreShared().Calls may be nested.
  Any number of tasks may simultaneously hold a shared lock on a semaphore.
  Only one task may hold an exclusive lock.A typical application is a list
  that is often read, but only occasionally written to.
  Any exlusive locker will be held off until all shared lockers release the
  semaphore.Likewise, if an exlusive lock is held, all potential shared lockers
  will block until the exclusive lock is released.All shared lockers are
  restarted at the same time.
SYNOPSIS  @{FG shine}void@{FG text} ObtainSemaphoreShared(@{FG shine}struct@{FG text} @{"SignalSemaphore" Link "include:exec/semaphores.h/Main" 40} *);
  ObtainSemaphoreShared(@{i}signalSemaphore@{ui})
                         a0
  @{i}signalSemaphore@{ui} -- an initialized signal semaphore structure
EXAMPLE
    ObtainSemaphoreShared(@{i}ss@{ui});
    /* read data */
    ReleaseSemaohore(@{i}ss@{ui});
    ObtainSemaphore(@{i}ss@{ui});
    /* modify data */
    ReleaseSemaohore(@{i}ss@{ui});
NOTES
  While this function was added for V36, the feature magically works with all
  older semaphore structures.
  A task owning a shared lock must not attempt to get an exclusive lock on the
  same semaphore.
  Starting in V39, if the caller already has an exclusive lock on the semaphore
  it will return with another nesting of the lock.Pre-V39 this would cause a
  deadlock.For pre-V39 use, you can use the following workaround:
    /* Try to get the shared semaphore */
    @{FG shine}if@{FG text} (!AttemptSemaphoreShared(@{i}ss@{ui})) {
      /* Check if we can get the exclusive version */
      @{FG shine}if@{FG text} (!AttemptSemaphore(@{i}ss@{ui})) {
        /* Oh well, wait for the shared lock */
        ObtainSemaphoreShared(@{i}ss@{ui}));
      }
    }
    :
    :
    ReleaseSemaphore(@{i}ss@{ui});
NOTE
  This call is guaranteed to preserve all registers, starting with V37 exec.
SEE ALSO
  @{"ObtainSemaphore()" Link "ObtainSemaphore()"}, @{"InitSemaphore()" Link "InitSemaphore()"}, @{"ReleaseSemaphore()" Link "ReleaseSemaphore()"},
  @{"AttemptSemaphore()" Link "AttemptSemaphore()"}, @{"ObtainSemaphoreList()" Link "ObtainSemaphoreList()"}, @{"Procure()" Link "Procure()"}, @{"Vacate()" Link "Vacate()"}
@EndNode
@Node "OldOpenLibrary()" "exec.library/OldOpenLibrary"
@{b}@{u}OldOpenLibrary@{uu}@{ub} -- obsolete @{"OpenLibrary" Link "OpenLibrary()"}.
  The 1.0 release of the Amiga system had an incorrect version of
  OpenLibrary that did not check the version number during the
  library open.This obsolete function is provided so that object
  code compiled using a 1.0 system will still run.
  This is exactly the same as "OpenLibrary(libName,0L);"
SYNOPSIS  @{FG shine}struct@{FG text} @{"Library" Link "include:exec/libraries.h/Main" 34} *OldOpenLibrary(APTR);
  @{i}@{b}library@{ub}@{ui} = OldOpenLibrary(@{i}libName@{ui})
   D0                       A1
  libName - the name of the library to open
  library - a library pointer for a successful open, else zero
SEE ALSO
  @{"CloseLibrary" Link "CloseLibrary()"}
@EndNode
@Node "OpenDevice()" "exec.library/OpenDevice"
@{b}@{u}OpenDevice@{uu}@{ub} -- gain access to a device.
  This function opens the named device/unit and initializes the given
  I/O request block.Specific documentation on opening procedures may
  come with certain devices.The device may exist in memory, or on disk;
  this is transparent to the OpenDevice caller.
  A full path name for the device name is legitimate.For example
  "test:devs/fred.device".This allows the use of custom devices without
  requiring the user to copy the device into the system's DEVS: directory.
SYNOPSIS
  BYTE OpenDevice(STRPTR,ULONG,@{FG shine}struct@{FG text} @{"IORequest" Link "include:exec/io.h/Main" 18} *,ULONG);
  @{i}@{b}error@{ub}@{ui} = OpenDevice(@{i}devName@{ui}, @{i}unitNumber@{ui}, @{i}iORequest@{ui}, @{i}flags@{ui})
   D0                 A0        D0          A1         D1
  @{i}devName@{ui} - requested device name
  @{i}unitNumber@{ui} - the unit number to open on that device.
    The format of the unit number is device specific.
    If the device does not have separate units, send a zero.
  iORequest - the I/O request block to be returned with appropriate fields
    initialized.
  @{i}flags@{ui} - additional driver specific information.
    This is sometimes used to request opening a device with exclusive access.
  @{i}@{b}error@{ub}@{ui} - Returns a sign-extended copy of the io_Error field of the IORequest.
    Zero if successful, else an error code is returned.
NOTES
  All calls to OpenDevice should have matching calls to CloseDevice!
  Devices on disk cannot be opened until after DOS has been started.
  As of V36 tasks can safely call OpenDevice, though DOS may open
  system requesters (e.g., asking the user to insert the Workbench
  disk if DEVS: is not online).You must call this function from a
  DOS @{"Process" Link "include:dos/dosextens.h/Main" 37} if you want to turn off DOS requesters.
BUGS
  AmigaDOS file names are not case sensitive, but Exec lists are.If the
  library name is specified in a different case than it exists on disk,
  unexpected results may occur.
  Prior to V36, tasks could not make OpenDevice calls requiring disk access
  (since tasks are not allowed to make dos.library calls).
  Now OpenDevice is protected from tasks.
SEE ALSO
  @{"CloseDevice" Link "CloseDevice()"}, @{"DoIO" Link "DoIO()"}, @{"SendIO" Link "SendIO()"}, @{"CheckIO" Link "CheckIO()"}, @{"AbortIO" Link "AbortIO()"}, @{"WaitIO" Link "WaitIO()"}
@EndNode
@Node "OpenLibrary()" "exec.library/OpenLibrary"
@{b}@{u}OpenLibrary@{uu}@{ub} -- gain access to a library.
  This function returns a pointer to a library that was previously
  installed into the system.If the requested library is exists, and
  if the library version is greater than or equal to the requested
  version, then the open will succeed.
  The library may exist in memory, or on disk; this is transparent to
  the OpenLibrary caller.Only Processes are allowed to call
  OpenLibrary (since OpenLibrary may in turn call dos.library).
  A full path name for the library name is legitimate.For example
  "wp:libs/wp.library".This allows the use of custom libraries
  without requiring the user to copy the library into the system's LIBS: directory.
SYNOPSIS  @{FG shine}struct@{FG text} @{"Library" Link "include:exec/libraries.h/Main" 34} *OpenLibrary(STRPTR, ULONG);
  @{i}@{b}library@{ub}@{ui} = OpenLibrary(@{i}libName@{ui}, @{i}version@{ui})
   D0                     A1       D0
  @{i}libName@{ui} - the name of the library to open
  @{i}version@{ui} - the version of the library required.
  @{i}@{b}library@{ub}@{ui} - a library pointer for a successful open, else zero
NOTES
  All calls to OpenLibrary should have matching calls to CloseLibrary!
  Libraries on disk cannot be opened until after DOS has been started.
  As of V36 tasks can safely call OpenLibrary, though DOS may open
  system requesters (e.g., asking the user to insert the Workbench
  disk if LIBS: is not online).You must call this function from a
  DOS @{"Process" Link "include:dos/dosextens.h/Main" 37} if you want to turn off DOS requesters.
BUGS
  AmigaDOS file names are not case sensitive, but Exec lists are.If the
  library name is specified in a different case than it exists on disk,
  unexpected results may occur.
  Prior to V36, tasks could not make OpenLibrary calls requiring disk access
  (since tasks are not allowed to make dos.library calls).
  Now OpenLibrary is protected from tasks.
  The version number of the resident tag in disk based library must match the
  version number of the library, or V36 may fail to load it.
SEE ALSO
  @{"CloseLibrary" Link "CloseLibrary()"}
@EndNode
@Node "OpenResource()" "exec.library/OpenResource"
@{b}@{u}OpenResource@{uu}@{ub} -- gain access to a resource.
  This function returns a pointer to a resource that was previously installed
  into the system.There is no CloseResource() function.
SYNOPSIS  APTR OpenResource(STRPTR);
  @{i}@{b}resource@{ub}@{ui} = OpenResource(@{i}resName@{ui})
   D0                      A1
  @{i}resName@{ui} - the name of the resource requested.
  @{i}@{b}resource@{ub}@{ui} - if successful, a resource pointer, else NULL
@EndNode
@Node "Permit()" "exec.library/Permit"
@{b}@{u}Permit@{uu}@{ub} -- permit task rescheduling.
  Allow other tasks to be scheduled to run by the dispatcher, after a
  matching @{"Forbid()" Link "Forbid()"} has been executed.
  Other tasks will be rescheduled as they are ready to run.In order
  to restore normal task rescheduling, the programmer must execute
  exactly one call to Permit() for every call to @{"Forbid()" Link "Forbid()"}.
SYNOPSIS  @{FG shine}void@{FG text} Permit(@{FG shine}void@{FG text});
  Permit()
NOTE
  This call is guaranteed to preserve all registers.
SEE ALSO
  Forbid, Disable, Enable
@EndNode
@Node "Procure()" "exec.library/Procure"
@{b}@{u}Procure@{uu}@{ub} -- bid for a semaphore.@{FG fill}(V39)@{FG text}
  This function is used to obtain a semaphore in an async manner.
  Like @{"ObtainSemaphore()" Link "ObtainSemaphore()"}, it will obtain a SignalSemaphore for you
  but unlike @{"ObtainSemaphore()" Link "ObtainSemaphore()"}, you will not block until you get
  the semaphore.Procure() will just post a request for the semaphore
  and will return.When the semaphore is available (which could
  be at any time) the bidMessage will @{"ReplyMsg()" Link "ReplyMsg()"} and you will own
  the semaphore.This lets you wait on multiple semaphores at once
  and to continue processing while waiting for the semaphore.
SYNOPSIS  @{FG shine}void@{FG text} Procure(@{FG shine}struct@{FG text} @{"SignalSemaphore" Link "include:exec/semaphores.h/Main" 40} *, @{FG shine}struct@{FG text} SemaphoreMessage *);
  Procure(@{i}semaphore@{ui}, @{i}bidMessage@{ui})
           A0          A1
  @{i}semaphore@{ui} - The SignalSemaphore that you wish to Procure()
  @{i}bidMessage@{ui} - The SemaphoreMessage that you wish replied when you obtain access
    to the semaphore.The message's ssm_Semaphore field will point at the
    semaphore that was obtained.If the ssm_Semaphore field is NULL, the
    Procure() was aborted via @{"Vacate()" Link "Vacate()"}.
    The mn_ReplyPort field of the message must point to a valid message port.
    To obtain a shared semaphore, the ln_Name field must be set to 1.For an
    exclusive lock, the ln_Name field must be 0.No other values are valid.
NOTES
  Pre-V39, Procure() and @{"Vacate()" Link "Vacate()"} did not work correctly.
  They also did not operate on SignalSemaphore semaphores.
  Old (and broken) MessageSemaphore use as of V39 will no longer work.
BUGS
  Before V39, Procure() and @{"Vacate()" Link "Vacate()"} used a different semaphore
  system that was very broken.This new system is only available
  as of V39 even though the LVOs are the same.
SEE ALSO
  @{"ObtainSemaphoreShared()" Link "ObtainSemaphoreShared()"}, @{"InitSemaphore()" Link "InitSemaphore()"}, @{"ReleaseSemaphore()" Link "ReleaseSemaphore()"},
  @{"AttemptSemaphore()" Link "AttemptSemaphore()"}, @{"ObtainSemaphoreList()" Link "ObtainSemaphoreList()"}, @{"Vacate()" Link "Vacate()"}, @{"ObtainSemaphore()" Link "ObtainSemaphore()"}
@EndNode
@Node "PutMsg()" "exec.library/PutMsg"
@{b}@{u}PutMsg@{uu}@{ub} -- put a message to a message port.
  This function attaches a message to the end of a given message port.
  It provides a fast, non-copying message sending mechanism.
  Messages can be attached to only one port at a time.The message body can be of
  any size or form.Because messages are not copied, cooperating tasks share the
  same message memory.The sender task must not recycle the message until it has
  been replied by the receiver.Of course this depends on the message handling
  conventions setup by the involved tasks.If the ReplyPort field is non-zero,
  when the message is replied by the receiver, it will be sent back to that port.
  Any one of the following actions can be set to occur when a message is put:
    1.no special action
    2.signal a given task (specified by MP_SIGTASK)
    3.cause a software interrupt (specified by MP_SIGTASK)
  The action is selected depending on the value found in the MP_FLAGS of the
  destination port.
SYNOPSIS  @{FG shine}void@{FG text} PutMsg(@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *, @{FG shine}struct@{FG text} @{"Message" Link "include:exec/ports.h/Main" 48} *);
  PutMsg(@{i}port@{ui}, @{i}message@{ui})
          A0    A1
  @{i}port@{ui} - pointer to a message port
  @{i}message@{ui} - pointer to a message
IMPLEMENTATION
  1.Sets the LN_TYPE field to "NT_MESSAGE".
  2.Attaches the message to the destination port.
  3.Performs the specified arrival action at the destination.
SEE ALSO
  @{"GetMsg" Link "GetMsg()"}, @{"ReplyMsg" Link "ReplyMsg()"}, @{"exec/ports.h" Link "include:exec/ports.h/Main" 0}
@EndNode
@Node "RawDoFmt()" "exec.library/RawDoFmt"
@{b}@{u}RawDoFmt@{uu}@{ub} -- format data into a character stream.
  perform "C"-language-like formatting of a data stream, outputting the result a
  character at a time.Where % formatting commands are found in the FormatString,
  they will be replaced with the corresponding element in the DataStream.
  %% must be used in the string if a % is desired in the output.
  Under V36, RawDoFmt() returns a pointer to the end of the DataStream
  (The next argument that would have been processed).This allows
  multiple formatting passes to be made using the same data.
SYNOPSIS  APTR RawDoFmt(STRPTR,APTR,@{FG shine}void@{FG text} (*)(),APTR);
  @{i}@{b}NextData@{ub}@{ui} = RawDoFmt(@{i}FormatString@{ui}, @{i}DataStream@{ui}, @{i}PutChProc@{ui}, @{i}PutChData@{ui});
   d0                  a0             a1          a2         a3
  @{"FormatString" link RAWDOFMT_FORMATSTRING} - a "C"-language-like NULL terminated format string
  @{i}DataStream@{ui} - a stream of data that is interpreted according to the format
    string.Often this is a pointer into the task's stack.
  @{i}PutChProc@{ui}  - the procedure to call with each character to be output,called as:
    PutChProc(@{i}Char@{ui},  @{i}PutChData@{ui});
               D0-0:8 A3
    the procedure is called with a NULL Char at the end of the format string.
  @{i}PutChData@{ui} - a value that is passed through to the PutChProc procedure.
    This is untouched by RawDoFmt, and may be modified by the PutChProc.
EXAMPLE
  ; Simple version of the C "sprintf" function.Assumes C-style
  ; stack-based function conventions.
  ;   @{FG shine}long@{FG text} eyecount;
  ;   eyecount=2;
  ;   sprintf(string,"%s have %ld eyes.","Fish",eyecount);
  ; would produce "Fish have 2 eyes." in the string buffer.
    XDEF _sprintf
    XREF _AbsExecBase
    XREF _LVORawDoFmt
  _sprintf: ; ( ostring, format, {values} )
    movem.l a2/a3/a6,-(sp)
    move.l  4*4(sp),a3       ;Get the output string pointer
    move.l  5*4(sp),a0       ;Get the FormatString pointer
    lea.l 6*4(sp),a1       ;Get the pointer to the DataStream
    lea.l stuffChar(pc),a2
    move.l  _AbsExecBase,a6
    jsr _LVORawDoFmt(a6)
    movem.l (sp)+,a2/a3/a6
    rts
  ;------ PutChProc function used by RawDoFmt -----------
  stuffChar:
    move.b  d0,(a3)+        ;Put data to output string
    rts
@{b}WARNING@{ub}
  This Amiga ROM function formats word values in the data stream.If your
  compiler defaults to longs, you must add an "l" to your % specifications.
  This can get strange for characters, which might look like "%lc".
  The result of RawDoFmt() is *ONLY* valid in V36 and later releases
  of EXEC.Pre-V36 versions of EXEC have "random" return values.
SEE ALSO
  Documentation on the C language "printf" call in any C language reference book.
@EndNode
@node RAWDOFMT_FORMATSTRING "RawDoFmt_formatstring"
@{b}@{u}Supported % options@{uu}@{ub}: %[@{i}flags@{ui}][@{i}width@{ui}.@{i}limit@{ui}][@{i}length@{ui}]@{i}type@{ui}
  @{i}flags@{ui} - only one allowed.'-' specifies left justification.
  @{i}width@{ui} - field width.
    If the first character is a '0', the field will be padded with leading 0's.
  .- must follow the field width, if specified
  @{i}limit@{ui} - maximum number of characters to output from a string.
    (only valid for %s).
  @{i}length@{ui} - size of input data defaults to WORD for types d, x, and c,
    'l' changes this to @{FG shine}long@{FG text} (32-bit).
  @{i}type@{ui}  - supported types are:
    b - BSTR, data is 32-bit BPTR to byte count followed by a byte string, or
        NULL terminated byte string.A NULL BPTR is treated as an empty string.
        (Added in V36 exec)
    d - decimal
    u - unsigned decimal (Added in V37 exec)
    x - hexadecimal
    s - string, a 32-bit pointer to a NULL terminated byte string.
        In V36, a NULL pointer is treated as an empty string
    c - character
@endnode
@Node "ReleaseSemaphore()" "exec.library/ReleaseSemaphore"
@{b}@{u}ReleaseSemaphore@{uu}@{ub} -- make signal semaphore available to others.
  ReleaseSemaphore() is the inverse of @{"ObtainSemaphore()" Link "ObtainSemaphore()"}.It makes the semaphore
  lockable to other users.If tasks are waiting for the semaphore and this task
  is done with the semaphore then the next waiting task is signalled.
  Each @{"ObtainSemaphore()" Link "ObtainSemaphore()"} call must be balanced by exactly one
  ReleaseSemaphore() call.This is because there is a nesting count maintained in
  the semaphore of the number of times that the current task has locked the
  semaphore.The semaphore is not released to other tasks until the number of
  releases matches the number of obtains.
  Needless to say, havoc breaks out if the task releases more times than
  it has obtained.
SYNOPSIS  @{FG shine}void@{FG text} ReleaseSemaphore(@{FG shine}struct@{FG text} @{"SignalSemaphore" Link "include:exec/semaphores.h/Main" 40} *);
  ReleaseSemaphore(@{i}signalSemaphore@{ui})
                    A0
  @{i}signalSemaphore@{ui} -- an initialized signal semaphore structure
NOTE
  This call is guaranteed to preserve all registers.
SEE ALSO
  @{"InitSemaphore()" Link "InitSemaphore()"}, @{"ObtainSemaphore()" Link "ObtainSemaphore()"}, @{"ObtainSemaphoreShared()" Link "ObtainSemaphoreShared()"}
@EndNode
@Node "ReleaseSemaphoreList()" "exec.library/ReleaseSemaphoreList"
@{b}@{u}ReleaseSemaphoreList@{uu}@{ub} -- make a list of semaphores available.
  ReleaseSemaphoreList() is the inverse of @{"ObtainSemaphoreList()" Link "ObtainSemaphoreList()"}.It releases
  each element in the semaphore list.
  Needless to say, havoc breaks out if the task releases more times than
  it has obtained.
SYNOPSIS  @{FG shine}void@{FG text} ReleaseSemaphoreList(@{FG shine}struct@{FG text} @{"List" Link "include:exec/lists.h/Main" 20} *);
  ReleaseSemaphoreList(@{i}list@{ui})
                        A0
  @{i}list@{ui} -- a list of signal semaphores
SEE ALSO
  @{"ObtainSemaphoreList()" Link "ObtainSemaphoreList()"}
@EndNode
@Node "RemDevice()" "exec.library/RemDevice"
@{b}@{u}RemDevice@{uu}@{ub} -- remove a device from the system.
  This function calls the device's EXPUNGE vector, which requests that a
  device delete itself.The device may refuse to do this if it is busy or
  currently open.This is not typically called by user code.
  There are certain, limited circumstances where it may be appropriate to
  attempt to specifically flush a certain device.
  Example:
   /* Attempts to flush the named device out of memory.*/
   @{b}#include@{ub} @{"<exec/types.h>" Link "include:exec/types.h/Main" 0}
   @{b}#include@{ub} @{"<exec/execbase.h>" Link "include:exec/execbase.h/Main" 0}
   @{FG shine}void@{FG text} FlushDevice(@{i}name@{ui})
   STRPTR @{i}name@{ui};
   {
     @{FG shine}struct@{FG text} Device *@{i}result@{ui};
     Forbid();
     @{FG shine}if@{FG text}(@{i}result@{ui}=(@{FG shine}struct@{FG text} Device *)FindName(&SysBase->@{i}DeviceList@{ui},@{i}name@{ui}))
       RemDevice(@{i}result@{ui});
     Permit();
   }
SYNOPSIS  @{FG shine}void@{FG text} RemDevice(@{FG shine}struct@{FG text} @{"Device" Link "include:exec/devices.h/Main" 25} *);
  RemDevice(@{i}device@{ui})
             A1
  @{i}device@{ui} - pointer to a device node
SEE ALSO
  @{"AddLibrary" Link "AddLibrary()"}
@EndNode
@Node "RemHead()" "exec.library/RemHead"
@{b}@{u}RemHead@{uu}@{ub} -- remove the head node from a list.
  Get a pointer to the head node and remove it from the list.
  Assembly programmers may prefer to use the REMHEAD macro from "exec/lists.i".
SYNOPSIS  @{FG shine}struct@{FG text} @{"Node" Link "include:exec/nodes.h/Main" 22} *RemHead(@{FG shine}struct@{FG text} @{"List" Link "include:exec/lists.h/Main" 20} *);
  @{i}@{b}node@{ub}@{ui} = RemHead(@{i}list@{ui})
   D0              A0
  @{i}list@{ui} - a pointer to the target list header
  @{i}@{b}node@{ub}@{ui} - the node removed or zero when empty list
@{b}WARNING@{ub}
  This function does not arbitrate for access to the list.The
  calling task must be the owner of the involved list.
SEE ALSO
  @{"AddHead" Link "AddHead()"}, @{"AddTail" Link "AddTail()"}, @{"Enqueue" Link "Enqueue()"}, Insert, Remove, @{"RemTail" Link "RemTail()"}
@EndNode
@Node "RemIntServer()" "exec.library/RemIntServer"
@{b}@{u}RemIntServer@{uu}@{ub} -- remove an interrupt server from a server chain.
  This function removes an interrupt server node from the given server chain.
  If this server was the last one on this chain, interrupts for this chain are
  disabled.
SYNOPSIS  @{FG shine}void@{FG text} RemIntServer(ULONG,@{FG shine}struct@{FG text} @{"Interrupt" Link "include:exec/interrupts.h/Main" 23} *);
  RemIntServer(@{i}intNum@{ui}, @{i}interrupt@{ui})
                D0       A1
  @{i}intNum@{ui} - the Paula interrupt bit (0..14)
  @{i}interrupt@{ui} - pointer to an interrupt server node
BUGS
  Before V36 Kickstart, the feature that disables the interrupt
  would not function.For most server chains this does not cause a problem.
SEE ALSO
  @{"AddIntServer" Link "AddIntServer()"}, @{"hardware/intbits.h" Link "include:hardware/intbits.h/Main" 0}
@EndNode
@Node "RemLibrary()" "exec.library/RemLibrary"
@{b}@{u}RemLibrary@{uu}@{ub} -- remove a library from the system.
  This function calls the library's EXPUNGE vector, which requests that a
  library delete itself.The library may refuse to do this if it is busy or
  currently open.This is not typically called by user code.
  There are certain, limited circumstances where it may be appropriate to
  attempt to specifically flush a certain Library.
  Example:
   /* Attempts to flush the named library out of memory.*/
   @{b}#include@{ub} @{"<exec/types.h>" Link "include:exec/types.h/Main" 0}
   @{b}#include@{ub} @{"<exec/execbase.h>" Link "include:exec/execbase.h/Main" 0}
   @{FG shine}void@{FG text} FlushLibrary(@{i}name@{ui})
   STRPTR @{i}name@{ui};
   {
     @{FG shine}struct@{FG text} Library *@{i}result@{ui};
     Forbid();
     @{FG shine}if@{FG text}(@{i}result@{ui}=(@{FG shine}struct@{FG text} Library *)FindName(&SysBase->@{i}LibList@{ui},@{i}name@{ui}))
       RemLibrary(@{i}result@{ui});
     Permit();
   }
SYNOPSIS  @{FG shine}void@{FG text} RemLibrary(@{FG shine}struct@{FG text} @{"Library" Link "include:exec/libraries.h/Main" 34} *);
  RemLibrary(@{i}library@{ui})
              A1
  @{i}library@{ui} - pointer to a library node structure
@EndNode
@Node "RemMemHandler()" "exec.library/RemMemHandler"
@{b}@{u}RemMemHandler@{uu}@{ub} - Remove low memory handler from exec.@{FG fill}(V39)@{FG text}
  This function removes the low memory handler from the system.
  This function can be called from within a handler.If removing
  oneself, it is important that the handler returns MEM_ALL_DONE.
SYNOPSIS  @{FG shine}void@{FG text} RemMemHandler(@{FG shine}struct@{FG text} @{"Interrupt" Link "include:exec/interrupts.h/Main" 23} *);
  RemMemHandler(@{i}memHandler@{ui})
                 A1
  @{i}memHandler@{ui} - Pointer to a handler added with @{"AddMemHandler()" Link "AddMemHandler()"}
NOTE
  When removing a handler, the handler may be called until this
  function returns.Thus, the handler must still be valid until then.
SEE ALSO
  AddMemHandler, exec/interrupts.i
@EndNode
@Node "Remove()" "exec.library/Remove"
@{b}@{u}Remove@{uu}@{ub} -- remove a node from a list.
  Unlink a node from whatever list it is in.Nodes that are not part
  of a list must not be passed to this function!  Assembly programmers
  may prefer to use the REMOVE macro from "exec/lists.i".
SYNOPSIS  @{FG shine}void@{FG text} Remove(@{FG shine}struct@{FG text} @{"Node" Link "include:exec/nodes.h/Main" 22} *);
  Remove(@{i}node@{ui})
          A1
  @{i}node@{ui} - the node to remove
@{b}WARNING@{ub}
  This function does not arbitrate for access to the list.The
  calling task must be the owner of the involved list.
SEE ALSO
  @{"AddHead" Link "AddHead()"}, @{"AddTail" Link "AddTail()"}, @{"Enqueue" Link "Enqueue()"}, Insert, @{"RemHead" Link "RemHead()"}, @{"RemTail" Link "RemTail()"}
@EndNode
@Node "RemPort()" "exec.library/RemPort"
@{b}@{u}RemPort@{uu}@{ub} -- remove a message port from the system.
  This function removes a message port structure from the system's
  message port list.Subsequent attempts to rendezvous by name with
  this port will fail.
SYNOPSIS  @{FG shine}void@{FG text} RemPort(@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *);
  RemPort(@{i}port@{ui})
           A1
  @{i}port@{ui} - pointer to a message port
SEE ALSO
  @{"AddPort" Link "AddPort()"}, @{"FindPort" Link "FindPort()"}
@EndNode
@Node "RemResource()" "exec.library/RemResource"
@{b}@{u}RemResource@{uu}@{ub} -- remove a resource from the system.
  This function removes an existing resource from the system resource
  list.There must be no outstanding users of the resource.
SYNOPSIS  @{FG shine}void@{FG text} RemResource(APTR);
  RemResource(@{i}resource@{ui})
               A1
  @{i}resource@{ui} - pointer to a resource node
SEE ALSO
  @{"AddResource" Link "AddResource()"}
@EndNode
@Node "RemSemaphore()" "exec.library/RemSemaphore"
@{b}@{u}RemSemaphore@{uu}@{ub} -- remove a signal semaphore from the system.
  This function removes a signal semaphore structure from the
  system's signal semaphore list.Subsequent attempts to
  rendezvous by name with this semaphore will fail.
SYNOPSIS  @{FG shine}void@{FG text} RemSemaphore(@{FG shine}struct@{FG text} @{"SignalSemaphore" Link "include:exec/semaphores.h/Main" 40} *);
  RemSemaphore(@{i}signalSemaphore@{ui})
                A1
  @{i}signalSemaphore@{ui} -- an initialized signal semaphore structure
SEE ALSO
  @{"AddSemaphore" Link "AddSemaphore()"}, @{"FindSemaphore" Link "FindSemaphore()"}
@EndNode
@Node "RemTail()" "exec.library/RemTail"
@{b}@{u}RemTail@{uu}@{ub} -- remove the tail node from a list.
  Remove the last node from a list, and return a pointer to it.If
  the list is empty, return zero.Assembly programmers may prefer to
  use the REMTAIL macro from "exec/lists.i".
SYNOPSIS  @{FG shine}struct@{FG text} @{"Node" Link "include:exec/nodes.h/Main" 22} *RemTail(@{FG shine}struct@{FG text} @{"List" Link "include:exec/lists.h/Main" 20} *);
  @{i}@{b}node@{ub}@{ui} = RemTail(@{i}list@{ui})
   D0             A0
  @{i}list@{ui} - a pointer to the target list header
  @{i}@{b}node@{ub}@{ui} - the node removed or zero when empty list
@{b}WARNING@{ub}
  This function does not arbitrate for access to the list.The
  calling task must be the owner of the involved list.
SEE ALSO
  @{"AddHead" Link "AddHead()"}, @{"AddTail" Link "AddTail()"}, @{"Enqueue" Link "Enqueue()"}, Insert, Remove, @{"RemHead" Link "RemHead()"}, RemTail
@EndNode
@Node "RemTask()" "exec.library/RemTask"
@{b}@{u}RemTask@{uu}@{ub} -- remove a task from the system.
  This function removes a task from the system.Deallocation of resources should
  have been performed prior to calling this function.Removing some other task is
  very dangerous.Generally is is best to arrange for tasks to call RemTask(0L)
  on themselves.RemTask will automagically free any memory lists attached to the
  task's TC_MEMENTRY list.
SYNOPSIS  @{FG shine}void@{FG text} RemTask(@{FG shine}struct@{FG text} @{"Task" Link "include:exec/tasks.h/Main" 24} *);
  RemTask(@{i}task@{ui})
           A1
  @{i}task@{ui} - pointer to the task node representing the task to be removed.
    A zero value indicates self removal, and will cause the next ready task to
    begin execution.
BUGS
  Before V36 if RemTask() was called on a task other than the current task,
  and that task was created with @{"amiga.lib/CreateTask" Link "amiga_lib.guide/CreateTask()"}, there was a slight
  chance of a crash.The problem can be hidden by bracketing RemTask() with
  @{"Forbid()/Permit()" Link "Permit()"}.
SEE ALSO
  @{"AddTask" Link "AddTask()"}, @{"exec/AllocEntry" Link "AllocEntry()"}, @{"amiga.lib/DeleteTask" Link "amiga_lib.guide/DeleteTask()"}
@EndNode
@Node "ReplyMsg()" "exec.library/ReplyMsg"
@{b}@{u}ReplyMsg@{uu}@{ub} -- put a message to its reply port.
  This function sends a message to its reply port.This is usually done when the
  receiver of a message has finished and wants to return it to the sender
  (so that it can be re-used or deallocated, whatever).
  This call may be made from interrupts.
SYNOPSIS  @{FG shine}void@{FG text} ReplyMsg(@{FG shine}struct@{FG text} @{"Message" Link "include:exec/ports.h/Main" 48} *);
  ReplyMsg(@{i}message@{ui})
            A1
  @{i}message@{ui} - a pointer to the message
IMPLEMENTATION
  1> Places "NT_REPLYMSG" into LN_TYPE.
  2> Puts the message to the port specified by MN_REPLYPORT
     If there is no replyport, sets LN_TYPE to "NT_FREEMSG"
     (use this feature only with extreme care).
SEE ALSO
  @{"GetMsg" Link "GetMsg()"}, @{"PutMsg" Link "PutMsg()"}, @{"exec/ports.h" Link "include:exec/ports.h/Main" 0}
@EndNode
@Node "SendIO()" "exec.library/SendIO"
@{b}@{u}SendIO@{uu}@{ub} -- initiate an I/O command.
  This function requests the device driver start processing the given
  I/O request.The device will return control without waiting for
  the I/O to complete.
  The io_Flags field of the IORequest will be set to zero before the
  request is sent.See @{"BeginIO()" Link "amiga_lib.guide/BeginIO()"} for more details.
SYNOPSIS  @{FG shine}void@{FG text} SendIO(@{FG shine}struct@{FG text} @{"IORequest" Link "include:exec/io.h/Main" 18} *);
  SendIO(@{i}iORequest@{ui})
          A1
  @{i}iORequest@{ui} - pointer to an I/O request, or a device specific extended IORequest.
SEE ALSO
  @{"DoIO" Link "DoIO()"}, @{"CheckIO" Link "CheckIO()"}, @{"WaitIO" Link "WaitIO()"}, @{"AbortIO" Link "AbortIO()"}
@EndNode
@Node "SetExcept()" "exec.library/SetExcept"
@{b}@{u}SetExcept@{uu}@{ub} -- define certain signals to cause exceptions.
  This function defines which of the task's signals will cause a
  private task exception.When any of the signals occurs the task's
  exception handler will be dispatched.If the signal occurred prior
  to calling SetExcept, the exception will happen immediately.
  The user function pointed to by the task's tc_ExceptCode gets called as:
  @{i}@{b}newExcptSet@{ub}@{ui} = <exceptCode>(@{i}signals@{ui}, @{i}exceptData@{ui}),@{i}SysBase@{ui}
   D0                         D0       A1           A6
  @{i}signals@{ui} - The set of signals that caused this exception.
    These Signals have been disabled from the current set of signals
    that can cause an exception.
  @{i}exceptData@{ui} - A copy of the task structure tc_ExceptData field.
  @{i}@{b}newExcptSet@{ub}@{ui} - The set of signals in NewExceptSet will be re-enabled for
    exception generation.Usually this will be the same as the Signals
    that caused the exception.
SYNOPSIS  ULONG SetExcept(ULONG,ULONG);
  @{i}@{b}oldSignals@{ub}@{ui} = SetExcept(@{i}newSignals@{ui}, @{i}signalMask@{ui})
   D0                     D0           D1
  @{i}newSignals@{ui} - the new values for the signals specified in signalMask.
  @{i}signalMask@{ui} - the set of signals to be effected
  @{i}@{b}oldSignals@{ub}@{ui} - the prior exception signals
EXAMPLE
  Get the current state of all exception signals:
    SetExcept(0,0)
  Change a few exception signals:
    SetExcept($1374,$1074)
SEE ALSO
  @{"Signal" Link "Signal()"}, @{"SetSignal" Link "SetSignal()"}
@EndNode
@Node "SetFunction()" "exec.library/SetFunction"
@{b}@{u}SetFunction@{uu}@{ub} -- change a function vector in a library.
  SetFunction is a functional way of changing where vectors in a
  library point.They are changed in such a way that the checksumming
  process will never falsely declare a library to be invalid.
SYNOPSIS  APTR SetFunction(@{FG shine}struct@{FG text} @{"Library" Link "include:exec/libraries.h/Main" 34} *,@{FG shine}long@{FG text},APTR);
  @{i}@{b}oldFunc@{ub}@{ui} = SetFunction(@{i}library@{ui}, @{i}funcOffset@{ui}, @{i}funcEntry@{ui})
   D0                    A1       A0.W         D0
  @{i}library@{ui}    - a pointer to the library to be changed
  @{i}funcOffset@{ui} - the offset of the function to be replaced
  @{i}funcEntry@{ui}  - pointer to new function
  @{i}@{b}oldFunc@{ub}@{ui}    - pointer to the old function that was just replaced
@{b}WARNING@{ub}
  If you use SetFunction on a function that can be called from
  interrupts, you are obligated to provide your own arbitration.
NOTE
  SetFunction cannot be used on non-standard libraries like pre-V36
  dos.library.Here you must manually @{"Forbid()" Link "Forbid()"}, preserve all 6
  original bytes, set the new vector, @{"SumLibrary()" Link "SumLibrary()"}, then @{"Permit()" Link "Permit()"}.
@EndNode
@Node "SetIntVector()" "exec.library/SetIntVector"
@{b}@{u}SetIntVector@{uu}@{ub} -- set a new handler for a system interrupt vector.
  This function provides a mechanism for setting the system interrupt vectors.
  These are non-sharable;setting a new interrupt handler disconnects the
  old one.Installed handlers are responsible for processing, enabling and
  clearing the interrupt.Note that interrupts may have been left in any
  state by the previous code.
  The IS_CODE and IS_DATA pointers of the Interrupt structure will be copied
  into a private place by Exec.A pointer to the previously installed Interrupt
  structure is returned.
  When the system calls the specified interrupt code, the registers are setup
  as follows:
    D0 - scratch
    D1 - scratch (on entry: active interrupts -> equals INTENA & INTREQ)
    A0 - scratch (on entry: pointer to base of custom chips for fast indexing)
    A1 - scratch (on entry: Interrupt's IS_DATA pointer)
    A5 - jump vector register (scratch on call)
    A6 - Exec library base pointer (scratch on call)
    all other registers must be preserved
SYNOPSIS  @{FG shine}struct@{FG text} @{"Interrupt" Link "include:exec/interrupts.h/Main" 23} *SetIntVector(ULONG, @{FG shine}struct@{FG text} Interrupt *);
  @{i}@{b}oldInterrupt@{ub}@{ui} = SetIntVector(@{i}intNumber@{ui}, @{i}interrupt@{ui})
   D0                          D0         A1
  @{i}intNum@{ui} - the Paula interrupt bit number (0..14).
    Only non-chained interrupts should be set.
    Use @{"AddIntServer()" Link "AddIntServer()"} for server chains.
  @{i}interrupt@{ui} - a pointer to an Interrupt structure containing the handler's entry
    point and data segment pointer.A NULL interrupt pointer will remove the
    current interrupt and set illegal values for IS_CODE and IS_DATA.
    By convention, the LN_NAME of the interrupt structure must point a
    descriptive string so that other users may identify who currently has
    control of the interrupt.
  Returns a pointer to the prior interrupt structure which had control of
  this interrupt.
SEE ALSO
  @{"AddIntServer()" Link "AddIntServer()"},exec/interrupts.i,hardware/intbits.i
@EndNode
@Node "SetSignal()" "exec.library/SetSignal"
@{b}@{u}SetSignal@{uu}@{ub} -- define the state of this task's signals.
  This function can query or modify the state of the current task's
  received signal mask.Setting the state of signals is considered
  dangerous.Reading the state of signals is safe.
SYNOPSIS  ULONG SetSignal(ULONG,ULONG);
  @{i}@{b}oldSignals@{ub}@{ui} = SetSignal(@{i}newSignals@{ui}, @{i}signalMask@{ui})
   D0                     D0          D1
  @{i}newSignals@{ui} - the new values for the signals specified in signalSet.
  @{i}signalMask@{ui} - the set of signals to be affected.
  @{i}@{b}oldSignals@{ub}@{ui} - the prior values for all signals
EXAMPLES
  Get the current state of all signals:
    SetSignal(0L,0L);
  Clear the CTRL-C signal:
    SetSignal(0L,SIGBREAKF_CTRL_C);
  Check if the CTRL-C signal was pressed:
    @{b}#include@{ub} @{"<libraries/dos.h>" Link "include:libraries/dos.h/Main" 0}
    /* Check & clear CTRL_C signal */
    @{FG shine}if@{FG text}(SetSignal(0L,SIGBREAKF_CTRL_C) & SIGBREAKF_CTRL_C) {
      printf("CTRL-C pressed!\n");
    }
SEE ALSO
  @{"Signal" Link "Signal()"}, Wait
@EndNode
@Node "SetSR()" "exec.library/SetSR"
@{b}@{u}SetSR@{uu}@{ub} -- get and/or set processor status register.
  This function provides a means of modifying the CPU status register in a
  "safe" way (well, how safe can a function like this be anyway?).This
  function will only affect the status register bits specified in the mask
  parameter.The prior content of the entire status register is returned.
SYNOPSIS
  @{i}@{b}oldSR@{ub}@{ui} = SetSR(@{i}newSR@{ui}, @{i}mask@{ui})
   D0            D0     D1
  ULONG SetSR(ULONG, ULONG);
  @{i}newSR@{ui} - new values for bits specified in the mask.
    All other bits are not effected.
  @{i}mask@{ui} - bits to be changed
  @{i}@{b}oldSR@{ub}@{ui} - the entire status register before new bits
EXAMPLES
  To get the current SR:
    currentSR = SetSR(0,0);
  To change the processor interrupt level to 3:
    oldSR = SetSR($0300,$0700);
  Set processor interrupts back to prior level:
    SetSR(oldSR,$0700);
@EndNode
@Node "SetTaskPri()" "exec.library/SetTaskPri"
@{b}@{u}SetTaskPri@{uu}@{ub} -- get and set the priority of a task.
  This function changes the priority of a task regardless of its state.
  The old priority of the task is returned.A reschedule is performed,
  and a context switch may result.
  To change the priority of the currently running task, pass the
  result of FindTask(0); as the task pointer.
SYNOPSIS  BYTE SetTaskPri(@{FG shine}struct@{FG text} @{"Task" Link "include:exec/tasks.h/Main" 24} *,@{FG shine}long@{FG text});
  @{i}@{b}oldPriority@{ub}@{ui} = SetTaskPri(@{i}task@{ui}, @{i}priority@{ui})
   D0-0:8                   A1    D0-0:8
  @{i}task@{ui} - task to be affected
  @{i}priority@{ui} - the new priority for the task
  @{i}@{b}oldPriority@{ub}@{ui} - the tasks previous priority
@EndNode
@Node "Signal()" "exec.library/Signal"
@{b}@{u}Signal@{uu}@{ub} -- signal a task.
  This function signals a task with the given signals.If the task
  is currently waiting for one or more of these signals, it will be
  made ready and a reschedule will occur.If the task is not waiting
  for any of these signals, the signals will be posted to the task
  for possible later use.A signal may be sent to a task regardless
  of whether it is running, ready, or waiting.
  This function is considered "low level".Its main purpose is to
  support multiple higher level functions like @{"PutMsg" Link "PutMsg()"}.
  This function is safe to call from interrupts.
SYNOPSIS  @{FG shine}void@{FG text} Signal(@{FG shine}struct@{FG text} @{"Task" Link "include:exec/tasks.h/Main" 24} *,ULONG);
  Signal(@{i}task@{ui}, @{i}signals@{ui})
          A1    D0
  @{i}task@{ui} - the task to be signalled
  @{i}signals@{ui} - the signals to be sent
SEE ALSO
  Wait, @{"SetSignal" Link "SetSignal()"}
@EndNode
@Node "StackSwap()" "exec.library/StackSwap"
@{b}@{u}StackSwap@{uu}@{ub} - EXEC supported method of replacing task's stack.@{FG fill}(V37)@{FG text}
  This function will, in an EXEC supported manner, swap the stack of your task
  with the given values in StackSwap.The StackSwapStruct structure will then
  contain the values of the old stack such that the old stack can be restored.
  This function is new in V37.
SYNOPSIS  @{FG shine}void@{FG text} StackSwap(@{FG shine}struct@{FG text} @{"StackSwapStruct" Link "include:exec/tasks.h/Main" 52} *);
  StackSwap(@{i}newStack@{ui})
             A0
  @{i}newStack@{ui} - A structure that contains the values for the new upper and lower
    stack bounds and the new stack pointer.This structure will have its values
    replaced by those in you task such that you can restore the stack later.
  @{i}newStack@{ui} - The structure will now contain the old stack.
    This means that StackSwap(foo); StackSwap(foo); will effectively do nothing.
NOTE
  If you do a stack swap, only the new stack is set up.This function does not
  copy the stack or do anything else other than set up the new stack for the
  task.It is generally required that you restore your stack before exiting.
SEE ALSO
  @{"AddTask" Link "AddTask()"}, @{"RemTask" Link "RemTask()"}, @{"exec/tasks.h" Link "include:exec/tasks.h/Main" 0}
@EndNode
@Node "SumKickData()" "exec.library/SumKickData"
@{b}@{u}SumKickData@{uu}@{ub} -- compute the checksum for the Kickstart delta list.
  The Amiga system has some ROM (or Kickstart) resident code that provides the
  basic functions for the machine.This code is unchangeable by the system soft-
  ware.This function is part of a support system to modify parts of the ROM.

  The ROM code is linked together at run time via ROMTags (also known as
  @{"Resident" Link "include:exec/resident.h/Main" 19} structures, defined in @{"exec/resident.h)" Link "include:exec/resident.h/Main" 0}.These tags tell Exec's
  low level boot code what subsystems exist in which regions of memory.The
  current list of ROMTags is contained in the ResModules field of @{"ExecBase" Link "include:exec/execbase.h/Main" 34}.
  By default this list contains any ROMTags found in the address ranges
  $F80000-$FFFFFF and $F00000-$F7FFFF.

  There is also a facility to selectively add or replace modules to the
  ROMTag list.These modules can exist in RAM, and the memory they occupy will be
  deleted from the memory free list during the boot process.SumKickData() plays
  an important role in this run-time modification of the ROMTag array.

  Three variables in ExecBase are used in changing the ROMTag array:
  KickMemPtr, KickTagPtr, and KickCheckSum.KickMemPtr points to a linked list
  of MemEntry structures.The memory that these MemEntry structures reference
  will be allocated (via AllocAbs) at boot time.The @{"MemEntry" Link "include:exec/memory.h/Main" 40} structure itself
  must also be in the list.

  KickTagPtr points to a long-word array of the same format as the ResModules
  array.The array has a series of pointers to ROMTag structures.The array is
  either NULL terminated, or will have an entry with the most significant bit
  (bit 31) set.The most significant bit being set says that this is a link to
  another long-word array of ROMTag entries.This new array's address can be
  found by clearing bit 31.

  KickCheckSum has the result of SumKickData().It is the checksum of both the
  KickMemPtr structure and the KickTagPtr arrays.If the checksum does not compute
  correctly then both KickMemPtr and KickTagPtr will be ignored.If all the memory
  referenced by KickMemPtr can't be allocated then KickTagPtr will be ignored.

  There is one more important caveat about adding ROMTags.All this ROMTag magic
  is run very early on in the system -- before expansion memory is added to the
  system.Therefore any memory in this additional ROMTag area must be addressable
  at this time.This means that your ROMTag code, MemEntry structures, and resi-
  dent arrays cannot be in expansion memory.There are two regions of memory that
  are acceptable: one is chip memory, and the other is "Ranger" memory
  (memory in the range between $C00000-$D80000).

  Remember that changing an existing ROMTag entry falls into the "heavy magic"
  category -- be very careful when doing it.The odd are that you will blow
  yourself out of the water.
SYNOPSIS  ULONG SumKickData(@{FG shine}void@{FG text});
  @{i}@{b}checksum@{ub}@{ui} = SumKickData()
   D0
  Returns value to be stuffed into ExecBase->KickCheckSum.
NOTE
  SumKickData was introduced in the 1.2 release
@{b}WARNING@{ub}
  After writing to KickCheckSum, you should push the data cache.
  This prevents potential problems with large copyback style caches.
  A call to @{"CacheClearU" Link "CacheClearU()"} will do fine.
SEE ALSO
  @{"InitResident" Link "InitResident()"}, @{"FindResident" Link "FindResident()"}
@EndNode
@Node "SumLibrary()" "exec.library/SumLibrary"
@{b}@{u}SumLibrary@{uu}@{ub} -- compute and check the checksum on a library.
  SumLibrary computes a new checksum on a library.It can also be used to check
  an old checksum.If an old checksum does not match, and the library has not
  been marked as changed, then the system will call @{"Alert()" Link "Alert()"}.
  This call could also be periodically made by some future system-checking task.
SYNOPSIS  @{FG shine}void@{FG text} SumLibrary(@{FG shine}struct@{FG text} @{"Library" Link "include:exec/libraries.h/Main" 34} *);
  SumLibrary(@{i}library@{ui})
              A1
  @{i}library@{ui} - a pointer to the library to be changed
NOTE
  An alert will occur if the checksum fails.
SEE ALSO
  @{"SetFunction" Link "SetFunction()"}
@EndNode
@Node "SuperState()" "exec.library/SuperState"
@{b}@{u}SuperState@{uu}@{ub} -- enter supervisor state with user stack.
  Enter supervisor mode while running on the user's stack.The user
  still has access to user stack variables.Be careful though, the
  user stack must be large enough to accommodate space for all
  interrupt data -- this includes all possible nesting of interrupts.
  This function does nothing when called from supervisor state.
SYNOPSIS  APTR SuperState(@{FG shine}void@{FG text});
  @{i}@{b}oldSysStack@{ub}@{ui} = SuperState()
   D0
  @{i}@{b}oldSysStack@{ub}@{ui} - system stack pointer; save this.
    It will come in handy when you return to user state.
    If the system is already in supervisor mode, oldSysStack is zero.
SEE ALSO
  @{"UserState/Supervisor" Link "Supervisor()"}
@EndNode
@Node "Supervisor()" "exec.library/Supervisor"
@{b}@{u}Supervisor@{uu}@{ub} -- trap to a short supervisor mode function.
  Allow a normal user-mode program to execute a short assembly language function
  in the supervisor mode of the processor.Supervisor() does not modify or save
  registers; the user function has full access to the  register set.All rules
  that apply to interrupt code must be followed.In addition, no system calls
  are permitted.The function must end with an RTE instruction.
SYNOPSIS  ULONG Supervisor(@{FG shine}void@{FG text} *);
  @{i}@{b}result@{ub}@{ui} = Supervisor(@{i}userFunc@{ui})
   Rx                  A5
  @{i}userFunc@{ui} - A pointer to a short assembly language function ending in RTE.
    The function has full access to the register set.
  @{i}@{b}result@{ub}@{ui}   - Whatever values the userFunc left in the registers.
EXAMPLE
  ;Obtain the Exception Vector base.68010 or greater only!
    MOVECtrap:  movec.l VBR,d0  ;$4e7a,$0801
    rte
SEE ALSO
  @{"SuperState" Link "SuperState()"},@{"UserState" Link "UserState()"}
@EndNode
@Node "TypeOfMem()" "exec.library/TypeOfMem"
@{b}@{u}TypeOfMem@{uu}@{ub} -- determine attributes of a given memory address.
  Given a RAM memory address, search the system memory lists and return its
  memory attributes.The memory attributes are similar to those specified when
  the memory was first allocated: (eg.MEMF_CHIP and MEMF_FAST).
  This function is usually used to determine if a particular block of memory is
  within CHIP space.
  If the address is not in known-space, a zero will be returned.
  (Anything that is not RAM, like the ROM or expansion area, will return zero.
  Also the first few bytes of a memory area are used up by the MemHeader.)
SYNOPSIS  ULONG TypeOfMem(@{FG shine}void@{FG text} *);
  @{i}@{b}attributes@{ub}@{ui} = TypeOfMem(@{i}address@{ui})
   D0                     A1
  @{i}address@{ui} - a memory address
  @{i}@{b}attributes@{ub}@{ui} - a long word of memory attribute flags.
    If the address is not in known RAM, zero is returned.
SEE ALSO
  @{"AllocMem()" Link "AllocMem()"}
@EndNode
@Node "UserState()" "exec.library/UserState"
@{b}@{u}UserState@{uu}@{ub} -- return to user state with user stack.
  Return to user state with user stack, from supervisor state with
  user stack.This function is normally used in conjunction with the
  @{"SuperState" Link "SuperState()"} function above.
  This function must not be called from the user state.
SYNOPSIS  @{FG shine}void@{FG text} UserState(APTR);
  UserState(@{i}sysStack@{ui})
             D0
  @{i}sysStack@{ui} - supervisor stack pointer
BUGS
  This function is broken in V33/34 Kickstart.Fixed in V1.31 setpatch.
SEE ALSO
  @{"SuperState/Supervisor" Link "Supervisor()"}
@EndNode
@Node "Vacate()" "exec.library/Vacate"
@{b}@{u}Vacate@{uu}@{ub} -- release a bitMessage from @{"Procure()" Link "Procure()"}.@{FG fill}(V39)@{FG text}
  This function can be used to release a semaphore obtained via @{"Procure()" Link "Procure()"}.
  However, the main purpose for this call is to be able to remove a bid for a
  semaphore that has not yet responded.This is required when a @{"Procure()" Link "Procure()"} was
  issued and the program no longer needs to get the semaphore and wishes to
  cancel the @{"Procure()" Link "Procure()"} request.The canceled request will be replied with the
  ssm_Semaphore field set to NULL.If you own the semaphore, the message was
  already replied and only the ssm_Semaphore field will be cleared.
SYNOPSIS  @{FG shine}void@{FG text} Vacate(@{FG shine}struct@{FG text} @{"SignalSemaphore" Link "include:exec/semaphores.h/Main" 40} *,@{FG shine}struct@{FG text} SemaphoreMessage *);
  Vacate(@{i}semaphore@{ui}, @{i}bidMessage@{ui})
          A0         A1
  @{i}semaphore@{ui} - The SignalSemaphore that you wish to Vacate()
  @{i}bidMessage@{ui} - The SemaphoreMessage that you wish to abort.
    The message's ssm_Semaphore field will be cleared.
    The message will be replied if it is still on the waiting list.
    If it is not on the waiting list, it is assumed that the semaphore is owned
    and it will be released.
NOTE
  Pre-V39, @{"Procure()" Link "Procure()"} and Vacate() did not work correctly.
  They also did not operate on SignalSemaphore semaphores.
  Old (and broken) MessageSemaphore use as of V39 will no longer work.
BUGS
  Before V39, @{"Procure()" Link "Procure()"} and Vacate() used a different semaphore
  system that was very broken.This new system is only available
  as of V39 even though the LVOs are the same.
SEE ALSO
  @{"ObtainSemaphoreShared()" Link "ObtainSemaphoreShared()"}, @{"InitSemaphore()" Link "InitSemaphore()"}, @{"ReleaseSemaphore()" Link "ReleaseSemaphore()"},
  @{"AttemptSemaphore()" Link "AttemptSemaphore()"}, @{"ObtainSemaphoreList()" Link "ObtainSemaphoreList()"}, @{"Procure()" Link "Procure()"}, @{"ObtainSemaphore()" Link "ObtainSemaphore()"}
@EndNode
@Node "Wait()" "exec.library/Wait"
@{b}@{u}Wait@{uu}@{ub} -- wait for one or more signals.
  This function will cause the current task to suspend waiting for one or more
  signals.When one or more of the specified signals occurs, the task will return
  to the ready state, and those signals will be cleared.
  If a signal occurred prior to calling Wait(), the wait condition will be
  immediately satisfied, and the task will continue to run without delay.
SYNOPSIS  ULONG Wait(ULONG);
  @{i}@{b}signals@{ub}@{ui} = Wait(@{i}signalSet@{ui})
   D0             D0
  @{i}signalSet@{ui} - The set of signals for which to wait.
    Each bit represents a particular signal.
  @{i}@{b}signals@{ub}@{ui} - the set of signals that were active
@{b}CAUTION@{ub}
  This function cannot be called while in supervisor mode or interrupts!
  This function will break the action of a @{"Forbid()" Link "Forbid()"} or @{"Disable()" Link "Disable()"} call.
@EndNode
@Node "WaitIO()" "exec.library/WaitIO"
@{b}@{u}WaitIO@{uu}@{ub} -- wait for completion of an I/O request.
  This function waits for the specified I/O request to complete, then removes it
  from the replyport.If the I/O has already completed, this function will return
  immediately.
  This function should be used with care, as it does not return until the I/O
  request completes; if the I/O never completes, this function will never return,
  and your task will hang.If this situation is a possibility, it is safer to use
  the @{"Wait()" Link "Wait()"} function.@{"Wait()" Link "Wait()"} will return return when any of a specified set of
  signal is received.This is how I/O timeouts can be properly handled.
SYNOPSIS  BYTE WaitIO(@{FG shine}struct@{FG text} @{"IORequest" Link "include:exec/io.h/Main" 18} *);
  @{i}@{b}error@{ub}@{ui} = WaitIO(@{i}iORequest@{ui})
   D0             A1
  @{i}iORequest@{ui} - pointer to an I/O request block
  @{i}@{b}error@{ub}@{ui} - zero if successful, else an error is returned
    (a sign extended copy of io_Error).
@{b}WARNING@{ub}
  If this IORequest was "Quick" or otherwise finished BEFORE this call, this
  function drops though immediately, with no call to@{"Wait()" Link "Wait()"}.A side effect is
  that the signal bit related the port may remain set.Expect this.
  When removing a known complete IORequest from a port, WaitIO() is the
  preferred method.A simple @{"Remove()" Link "Remove()"} would require a Disable/Enable pair!
SEE ALSO
  @{"DoIO" Link "DoIO()"}, @{"SendIO" Link "SendIO()"}, @{"CheckIO" Link "CheckIO()"}, @{"AbortIO" Link "AbortIO()"}
@EndNode
@Node "WaitPort()" "exec.library/WaitPort"
@{b}@{u}WaitPort@{uu}@{ub} -- wait for a given port to be non-empty.
  This function waits for the given port to become non-empty.If necessary, the
  @{"Wait()" Link "Wait()"} function will be called to wait for the port signal.If a message is
  already present at the port, this function will return immediately.
  The return value is always a pointer to the first message queued
  (but it is not removed from the queue).
SYNOPSIS  @{FG shine}struct@{FG text} @{"Message" Link "include:exec/ports.h/Main" 48} *WaitPort(@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *);
  @{i}@{b}message@{ub}@{ui} = WaitPort(@{i}port@{ui})
   D0                 A0
  @{i}port@{ui} - a pointer to the message port
  @{i}@{b}message@{ub}@{ui} - a pointer to the first available message
@{b}CAUTION@{ub}
  More than one message may be at the port when this returns.It is proper to
  call the @{"GetMsg()" Link "GetMsg()"} function in a loop until all messages have been handled,
  then wait for more to arrive.
  To wait for more than one port, combine the signal bits from each port into
  one call to the @{"Wait()" Link "Wait()"} function, then use a @{"GetMsg()" Link "GetMsg()"} loop to collect any
  and all messages.It is possible to get a signal for a port WITHOUT a message
  showing up.Plan for this.
SEE ALSO
  @{"GetMsg" Link "GetMsg()"}
@EndNode
@Node "--Overview--" "SAD/--Overview--"
@{b}@{u}Simple Amiga Debugging Kernel@{uu}@{ub}, known as "@{b}SAD@{ub}".It is in EXEC starting in V39.
@{"General description" link SAD_GENERALDESCRIPTION}
@{"Technical Issues" link SAD_TECHNICALISSUES}
@{"Command Overview" link SAD_COMMANDOVERVIEW}
@{"Technical Command Descriptions" link SAD_TECHNICALCOMMANDDESCRIPTION}
@{"Data Structure Issues" link SAD_DATASTRUCTUREISSUES}
@{i}Data Frames and the Registers@{ui}
  SAD generates a special data frame that can be used to read what
  registers contain and to change the contents of the registers.
  See the entry for @{"GET_CONTEXT_FRAME" Link "GET_CONTEXT_FRAME"} for more details.
BUGS
  In V39 EXEC, the @{"WRITE_BYTE" Link "WRITE_BYTE"} command was not connected and this
  caused all of the command numbers to be off-by-one.For example,
  the @{"READ_WORD" Link "READ_WORD"} command is listed as command $05 but in V39 is $04.
  However, the ACK of the commands are still correct.
  Also, in V39 EXEC, the @{"READ_WORD" Link "READ_WORD"} command would return the wrong data.
  To determine if you are in V39 or @{b}V40@{ub} SAD, you can issue a simple
  SAD command at the start of the session.By sending a @{"READ_WORD" Link "READ_WORD"}
  command, you may either get a @{"READ_WORD" Link "READ_WORD"} @{b}(V40)@{ub} or a @{"READ_LONG" Link "READ_LONG"} @{FG fill}(V39)@{FG text}
  ACK'ed back.So the data stream for a safe test would be:
    Send: $AF $05 $00 $F8 $00 $00               ; Read start of ROM...
    Recv: $00 $05 ....You have @{b}V40@{ub} SAD
    Recv: $00 $06 ....You have V39 SAD
  Note that you should be ready to read either 2 or 4 bytes of result depending
  on the ACK sent by the system.
@EndNode
@node SAD_GENERALDESCRIPTION "SAD_General Description"
The Simple Amiga Debugging Kernel (SAD) is a set of very simple control
routines stored in the Kickstart ROM that would let debuggers control the
Amiga's development enviroment from the outside.These tools would make it
possible to do remote machine development/debugging via just the on-board
serial port.
This set of control routines is very simple and yet completely flexible,
thus making it possible to control the whole machine.
@endnode
@node SAD_TECHNICALISSUES "SAD_Technical Issues"
SAD will make use of the motherboard serial port that exists in all
Amiga systems.The connection via the serial port lets the system be able
to execute SAD without needing any of the system software up and running.
(SAD will play with the serial port directly)
With some minor changes to the Amiga hardware, an NMI-like line could be
hooked up to a pin on the serial port.This would let external control of the
machine and would let the external controller stop the machine no matter what
state it is in.(NMI is that way)
In order to function correctly, SAD requires that some of the EXEC CPU control
functions work and that @{"ExecBase" Link "include:exec/execbase.h/Main" 34} be valid.Beyond that, SAD does not require the
OS to be running.
@endnode
@node SAD_COMMANDOVERVIEW "SAD_Command Overview"
@{b}@{u}The basic commands needed to operate SAD are as follows@{uu}@{ub}:
  Read and Write memory as byte, word, and longword.
  Get the register frame address (contains all registers)
  JSR to Address
  Return to system operation  (return from interrupt)
These basic routines will let the system do whatever is needed.
Since the JSR to address and memory read/write routines can be used to download
small sections of code that could be used to do more complex things, this basic
command set is thus flexible enough to even replace itself.
Caches will automatically be flushed as needed after each write.(A call to
@{"CacheClearU()" Link "CacheClearU()"} will be made after the write and before the command done sequence)
@endnode
@node SAD_TECHNICALCOMMANDDESCRIPTION "SAD_Technical Command Description"
Since the communications with SAD is via a serial port, data formats have been
defined for minimum overhead while still giving reasonable data reliability.SAD
will use the serial port at default 9600 baud but the external tools can change
the serial port's data rate if it wishes.It would need to make sure that it will
be able to reconnect.SAD sets the baud rate to 9600 each time it is entered.
However, while within SAD, a simple command to write a WORD to the SERPER
register would change the baud rate.This will remain in effect until you
exit and re-enter SAD or until you change the register again.
(This can be usefull if you need to transfer a large amount of data)
All commands have a basic format that they will follow.
All commands have both an ACK and a completion message.
Basic command format is:
  SENDER:  $AF <command byte> [<data bytes as needed by command>]
  Receive:
  @{i}Command ACK@{ui}  $00 <command byte>
  @{i}Command DONE@{ui} $1F <command byte> [<data if needed>]
  Waiting:                          $53 $41 $44 $BF
  Waiting when called from Debug(): $53 $41 $44 $3F
  Waiting when in dead-end crash:   $53 $41 $44 $21
The data sequence will be that SAD will emit a $BF and then wait for a command.
If no command is received within <2> seconds, it will emit $BF again and loop
back.(This is the "heart beat" of SAD)  When called from @{"Debug()" Link "Debug()"} and not the
NMI hook, SAD will use $3F as the "heart beat".
If SAD does not get a responce after <10> heartbeats, it will return to the
system.(Execute an RTS or RTE as needed)  This is to prevent a full hang.The
debugger at the other end can keep SAD happy by sending a NO-OP command.
All I/O in SAD times out.During the transmition of a command, if more than 2
seconds pass between bytes of data SAD will time out and return to the prompt.
This is mainly to help make sure that SAD can never get into an i-loop situation.
@endnode
@node SAD_DATASTRUCTUREISSUES "SAD_Data Structure Issues"
While executing in SAD, you may have full access to machine from the CPU
standpoint.However, this could also be a problem.It is important to understand
that when entered via NMI that many system lists may be in unstable state.
(NMI can happen in the middle of the @{"AllocMem" Link "AllocMem()"} routine or task switch, etc)
Also, since you are doing debugging, it is up to you to determine what
operations can be done and what can not be done.A good example is that if you
want to write a WORD or @{FG shine}long@{FG text} that the address will need
to be even on 68000 processors.Also,if you read or write memory that does not
exist, you may get a bus error.Following system structures may require that
you check the pointers at each step.
When entered via @{"Debug()" Link "Debug()"}, you are now running as a "task" so you will
be able to assume some things about system structures.This means that you
are in supervisor state and that you can assume that the system is at least
not between states.However, remember that since you are debugging the system,
some bad code could cause data structures to be invalid.Again,standard debugging
issues are in play.SAD just gives you the hooks to do whatever you need.
NOTE
  When SAD prompts with $BF you will be in full disable/forbid state.
  When $3F prompting,SAD will only do a @{"Forbid()" Link "Forbid()"}.It is possible for you
  to then disable interrupts as needed.This is done such that it is possible
  to "run" the system from SAD when called with @{"Debug()" Link "Debug()"}.
@endnode
@Node "ALLOCATE_MEMORY" "SAD/ALLOCATE_MEMORY"
@{b}@{u}ALLOCATE MEMORY@{uu}@{ub}
@{i}Command@{ui} $AF $0A
@{i}Data@{ui}    $qq $rr $ss $tt $hh $ii $jj $kk
  Allocate a chunk of memory that is <$qqrrsstt> bytes in size.
  Note that this call is only safe when SAD is in $3F prompting mode (called
  from @{"Debug()" Link "Debug()"}) and even then may be unsafe if the system is in bad shape.
  (You are debugging after all)  The returned address will be available to
  you until you release it.(It is obtained via a call to @{"AllocVec()" Link "AllocVec()"})  The
  type of memory allocated is <$hhiijjkk>.Note that the allocation may
  fail.In that case, the address returned will be $00000000.
@{i}Command ACK@{ui}  $00 $0A
@{i}Command DONE@{ui} $1F $0A $ww $xx $yy $zz
@EndNode
@Node "CALL_ADDRESS" "SAD/CALL_ADDRESS"
@{b}@{u}CALL ADDRESS@{uu}@{ub} - JSR to the given address.
@{i}Command@{ui} $AF $07
@{i}Data@{ui}    $ww $xx $yy $zz
  Call the following address as a subroutine.No registers will be
  set up but the context frame will exist.Standard calling
  conventions apply (d0/d1/a0/a1 are available, rest must be saved)
  The command will be ACK'ed when received.
@{i}Command ACK@{ui}  $00 $07
@{i}Command DONE@{ui} $1F $07
@EndNode
@Node "FREE_MEMORY" "SAD/FREE_MEMORY"
@{b}@{u}FREE MEMORY@{uu}@{ub}
@{i}Command@{ui} $AF $0B
@{i}Data@{ui}    $ww $xx $yy $zz
  Free the memory allocated with the ALLOCATE MEMORY command.This command
  has the same restrictions as ALLOCATE MEMORY.Memory is released by
  calling @{"FreeVec()" Link "FreeVec()"} on the address <$wwxxyyzz>
@{i}Command ACK@{ui}  $00 $0B
@{i}Command DONE@{ui} $1F $0B
@EndNode
@Node "GET_CONTEXT_FRAME" "SAD/GET_CONTEXT_FRAME"
@{b}@{u}GET CONTEXT FRAME@{uu}@{ub}
@{i}Command@{ui} $AF $09
@{i}Data@{ui}    <none>
  This command will return a pointer to the saved context.This will be
  a pointer to all of the registers that were saved on the stack along
  with some other details.Returns frame address <$wwxxyyzz>
  The pointer returned is to the following structure:
  STRUCTURE SAD_FRAME,0
    ; The first three are READ-ONLY...Mainly used to make it
    ; easier to understand what is going on in the system.
    ULONG SAD_VBR   ; Current VBR (always 0 on 68000 CPUs)
    ULONG SAD_AttnFlags ; ULONG copy of the flags (UPPER WORD==0)
    ULONG SAD_ExecBase  ; @{"ExecBase" Link "include:exec/execbase.h/Main" 34}
    ; These fields are the user registers...The registers are
    ; restored from these fields on exit from SAD...
    ; Note that USP is only valid if SR was *NOT* supervisor...
    ULONG SAD_USP   ; User stack pointer
    ULONG SAD_D0    ; User register d0
    ULONG SAD_D1    ; User register d1
    ULONG SAD_D2    ; User register d2
    ULONG SAD_D3    ; User register d3
    ULONG SAD_D4    ; User register d4
    ULONG SAD_D5    ; User register d5
    ULONG SAD_D6    ; User register d6
    ULONG SAD_D7    ; User register d7
    ULONG SAD_A0    ; User register a0
    ULONG SAD_A1    ; User register a1
    ULONG SAD_A2    ; User register a2
    ULONG SAD_A3    ; User register a3
    ULONG SAD_A4    ; User register a4
    ULONG SAD_A5    ; User register a5
    ULONG SAD_A6    ; User register a6
    ; This is for SAD internal use...It is the prompt that
    ; SAD is using...Changing this will have no effect on SAD.
    ULONG SAD_PROMPT  ; SAD Prompt Longword...(internal use)
    ; From here on down is the standard exception frame
    ; The first two entries (SR and PC) are standard on all 680x0 CPUs
    UWORD SAD_SR    ; Status register (part of exception frame)
    ULONG SAD_PC    ; Return address (part of exception frame)
@{i}Command ACK@{ui}  $00 $09
@{i}Command DONE@{ui} $1F $09 $ww $xx $yy $zz
@EndNode
@Node "NOP" "SAD/NOP"
@{b}@{u}NO-OP@{uu}@{ub} - Do nothing other than tell SAD you are still there...
@{i}Command@{ui} $AF $00
@{i}Data@{ui}    <none>
  This just tells SAD you are still there.Required so that timeouts do
  not exit SAD while you are not doing anything.
  This command will *NOT* be ACK'ed.It will just cause the timeout to
  be restarted.
@EndNode
@Node "READ_ARRAY" "SAD/READ_ARRAY"
@{b}@{u}READ ARRAY@{uu}@{ub} - Read a range of bytes.
@{i}Command@{ui} $AF $0F
@{i}Data@{ui}    $ww $xx $yy $zz $qq $rr $ss $tt
  Read a range of bytes from address <$wwxxyyzz> for <$qqrrsstt> bytes
  Will return that number of bytes...
  Command will be ACK'ed when received.
@{i}Command ACK@{ui}  $00 $0F
@{i}Command DONE@{ui} $1F $0F $uu [$uu ...]
@EndNode
@Node "READ_BYTE" "SAD/READ_BYTE"
@{b}@{u}READ BYTE@{uu}@{ub} - Read a byte from the given address.
@{i}Command@{ui} $AF $04
@{i}Data@{ui}    $ww $xx $yy $zz
  Read a byte from address <$wwxxyyzz>  Returns <$qq> as result
  Command will be ACK'ed when received.
@{i}Command ACK@{ui}  $00 $04
@{i}Command DONE@{ui} $1F $04 $qq
@EndNode
@Node "READ_LONG" "SAD/READ_LONG"
@{b}@{u}READ LONG@{uu}@{ub} - Read a @{FG shine}long@{FG text} from the given address.
@{i}Command@{ui} $AF $06
@{i}Data@{ui}    $ww $xx $yy $zz
  Read a @{FG shine}long@{FG text} from address <$wwxxyyzz>  Returns <$qqrrsstt> as result
  Command will be ACK'ed when received.
@{i}Command ACK@{ui}  $00 $06
@{i}Command DONE@{ui} $1F $06 $qq $rr $ss $tt
@EndNode
@Node "READ_WORD" "SAD/READ_WORD"
@{b}@{u}READ WORD@{uu}@{ub} - Read a word from the given address.@{b}(V40 SAD)@{ub}
@{i}Command@{ui} $AF $05
@{i}Data@{ui}    $ww $xx $yy $zz
  Read a word from address <$wwxxyyzz>  Returns <$qqrr> as result
  Command will be ACK'ed when received.
@{i}Command ACK@{ui}  $00 $05
@{i}Command DONE@{ui} $1F $05 $qq $rr
BUGS
  This command does not return correct values in pre-@{b}V40@{ub} EXEC.
@EndNode
@Node "RESET" "SAD/RESET"
@{b}@{u}RESET@{uu}@{ub} - Reset the computer...
@{i}Command@{ui} $AF $10
@{i}Data@{ui}    $FF $FF $FF $FF
  This command will reset the computer.the $FFFFFFFF value is there
  mainly to prevent false reset.This command will only be ACK'ed as
  the computer will be reset afterwards...
  Command will be ACK'ed when received.
@{i}Command ACK@{ui} $00 $10
@EndNode
@Node "RETURN_TO_SYSTEM" "SAD/RETURN_TO_SYSTEM"
@{b}@{u}RETURN TO SYSTEM@{uu}@{ub}
@{i}Command@{ui} $AF $08
@{i}Data@{ui}    $00 $00 $00 $00
  This command will return <exit> from SAD back to whatever started it.
  The 4 $00 are required as a "safty" to this command.The command
  will be ACK'ed only as it will have lost control of the system.
@{i}Command ACK@{ui} $00 $08
@EndNode
@Node "TURN_OFF_SINGLE" "SAD/TURN_OFF_SINGLE"
@{b}@{u}TURN OFF SINGLE STEPPING@{uu}@{ub}
@{i}Command@{ui} $AF $0D
@{i}Data@{ui}    $ww $xx $yy $zz
  This command will turn off SAD single stepping mode.You need to pass
  to it the address returned from the call to turn on single stepping mode.
@{i}Command ACK@{ui}  $00 $0D
@{i}Command DONE@{ui} $1F $0D
@EndNode
@Node "TURN_ON_SINGLE" "SAD/TURN_ON_SINGLE"
@{b}@{u}TURN ON SINGLE STEPPING@{uu}@{ub}
@{i}Command@{ui} $AF $0C
@{i}Data@{ui}    <none>
  This command will turn on SAD single stepping mode.This means that SAD
  will single step (via 68000 trace mode) the system.SAD will take over
  the TRACE exception vector during this time.This command will return
  the contents of the vector such that you can return this value when
  you wish to turn off single stepping mode.Note that turning on single
  stepping mode while in $BF prompting will cause the step to be taken
  and then SAD will execute in $3F mode (non-NMI)
  The command returns <$wwxxyyzz> which you must use when turning off
  the single-step mode.
@{i}Command ACK@{ui}  $00 $0C
@{i}Command DONE@{ui} $1F $0C $ww $xx $yy $zz
@EndNode
@Node "WRITE_ARRAY" "SAD/WRITE_ARRAY"
@{b}@{u}WRITE ARRAY@{uu}@{ub} - Write a range of bytes.
@{i}Command@{ui} $AF $0E
@{i}Data@{ui}    $ww $xx $yy $zz $qq $rr $ss $tt
  Write a range of bytes to address <$wwxxyyzz> for <$qqrrsstt> bytes
  After the computer sends the ACK, you must then send the byte stream...
  Command will be ACK'ed when received.
@{i}Command ACK@{ui}  $00 $0E
@{i}Command DONE@{ui} $1F $0E
@EndNode
@Node "WRITE_BYTE" "SAD/WRITE_BYTE"
@{b}@{u}WRITE BYTE@{uu}@{ub} - Write the given data to the address given.@{b}(V40 SAD)@{ub}
@{i}Command@{ui} $AF $01
@{i}Data@{ui}    $ww $xx $yy $zz $qq
  Write the byte <$qq> to address <$wwxxyyzz>
  Command will be ACK'ed when received.
@{i}Command ACK@{ui}  $00 $01
@{i}Command DONE@{ui} $1F $01
BUGS
  This command does not exists in pre-@{b}V40@{ub} EXEC.
  This command can be emulated with the @{"WRITE_ARRAY" Link "WRITE_ARRAY"} command with a length of 1.
@EndNode
@Node "WRITE_LONG" "SAD/WRITE_LONG"
@{b}@{u}WRITE LONG@{uu}@{ub} - Write the given data to the address given.
@{i}Command@{ui} $AF $03
@{i}Data@{ui}    $ww $xx $yy $zz $qq $rr $ss $tt
  Write the @{FG shine}long@{FG text} <$qqrrsstt> to address <$wwxxyyzz>
  Command will be ACK'ed when received.
@{i}Command ACK@{ui}  $00 $03
@{i}Command DONE@{ui} $1F $03
@EndNode
@Node "WRITE_WORD" "SAD/WRITE_WORD"
@{b}@{u}WRITE WORD@{uu}@{ub} - Write the given data to the address given.
@{i}Command@{ui} $AF $02
@{i}Data@{ui}    $ww $xx $yy $zz $qq $rr
  Write the word <$qqrr> to address <$wwxxyyzz>
  Command will be ACK'ed when received.
@{i}Command ACK@{ui}  $00 $02
@{i}Command DONE@{ui} $1F $02
@EndNode

