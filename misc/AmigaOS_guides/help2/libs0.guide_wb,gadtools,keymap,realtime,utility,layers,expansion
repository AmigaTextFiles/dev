@database "ROMlibs"
@master "Work:Programing/sc/OS3.1_Docs/doc/wb.doc"
@Node Main "ROMlibs.guide"
@{b}@{u}realtime.library@{uu}@{ub}:   @{b}@{u}keymap.library@{uu}@{ub}:
@{"LockRealTime()" Link "LockRealTime()"}     @{"SetKeyMapDefault()" Link "SetKeyMapDefault()"}
@{"CreatePlayer()" Link "CreatePlayer()"}     @{"AskKeyMapDefault()" Link "AskKeyMapDefault()"}
@{"SetPlayerAttrs()" Link "SetPlayerAttrs()"}   @{"MapRawKey()" Link "MapRawKey()"}
@{"GetPlayerAttrsA()" Link "GetPlayerAttrsA()"}  @{"MapANSI()" Link "MapANSI()"}
@{"DeletePlayer()" Link "DeletePlayer()"}     @{b}@{u}Other libraries@{uu}@{ub}:
@{"ExternalSync()" Link "ExternalSync()"}     @{"expansion.library" link EXPANSION.LIBRARY}
@{"FindConductor()" Link "FindConductor()"}    @{"gadtools.library" link GADTOOLS.LIBRARY}
@{"SetConductorState()" Link "SetConductorState()"}@{"layers.library" link LAYERS.LIBRARY}
@{"NextConductor()" Link "NextConductor()"}    @{"utility.library" link UTILITY.LIBRARY}
@{"UnlockRealTime()" Link "UnlockRealTime()"}
@{b}@{u}wb.library@{uu}@{ub}:         @{"All functios sorted" link ALL_FUNCTIONS_SORTED}
@{"AddAppIconA()" Link "AddAppIconA()"}
@{"RemoveAppIcon()" Link "RemoveAppIcon()"}
@{"AddAppWindowA()" Link "AddAppWindowA()"}
@{"RemoveAppWindow()" Link "RemoveAppWindow()"}
@{"AddAppMenuItemA()" Link "AddAppMenuItemA()"}
@{"RemoveAppMenuItem()" Link "RemoveAppMenuItem()"}
@{"WBInfo()" Link "WBInfo()"}
@EndNode
@node EXPANSION.LIBRARY "expansion.library"
@{b}@{u}expansion.library@{uu}@{ub}:
-configdev:       -expansion:
@{"AllocConfigDev()" Link "AllocConfigDev()"}@{"AllocExpansionMem()" Link "AllocExpansionMem()"}
@{"ConfigBoard()" Link "ConfigBoard()"}   @{"ReadExpansionByte()" Link "ReadExpansionByte()"}
@{"AddConfigDev()" Link "AddConfigDev()"}  @{"ReadExpansionRom()" Link "ReadExpansionRom()"}
@{"FindConfigDev()" Link "FindConfigDev()"} @{"WriteExpansionByte()" Link "WriteExpansionByte()"}
@{"FreeConfigDev()" Link "FreeConfigDev()"} @{"FreeExpansionMem()" Link "FreeExpansionMem()"}
@{"RemConfigDev()" Link "RemConfigDev()"}  -binding:
-nodes:          @{"ObtainConfigBinding()" Link "ObtainConfigBinding()"}
@{"AddBootNode()" Link "AddBootNode()"}   @{"SetCurrentBinding()" Link "SetCurrentBinding()"}
@{"MakeDosNode()" Link "MakeDosNode()"}   @{"GetCurrentBinding()" Link "GetCurrentBinding()"}
@{"AddDosNode()" Link "AddDosNode()"}    @{"ReleaseConfigBinding()" Link "ReleaseConfigBinding()"}
@endnode
@node GADTOOLS.LIBRARY "gadtools.library"
@{b}@{u}gadtools.library@{uu}@{ub}:
-menus:             -gadgets:
@{"GetVisualInfoA()" Link "GetVisualInfoA()"}   @{"CreateGadgetA()" Link "CreateGadgetA()"}
@{"CreateMenusA()" Link "CreateMenusA()"}     @{"CreateContext()" Link "CreateContext()"}
@{"LayoutMenusA()" Link "LayoutMenusA()"}     @{"DrawBevelBoxA()" Link "DrawBevelBoxA()"}
@{"LayoutMenuItemsA()" Link "LayoutMenuItemsA()"} @{"GT_SetGadgetAttrsA()" Link "GT_SetGadgetAttrsA()"}
@{"FreeMenus()" Link "FreeMenus()"}        @{"GT_GetGadgetAttrsA()" Link "GT_GetGadgetAttrsA()"}
@{"FreeVisualInfo()" Link "FreeVisualInfo()"}   @{"FreeGadgets()" Link "FreeGadgets()"}
-intuimessages:     -refreshing:
@{"GT_GetIMsg()" Link "GT_GetIMsg()"}       @{"GT_RefreshWindow()" Link "GT_RefreshWindow()"}
@{"GT_FilterIMsg()" Link "GT_FilterIMsg()"}    @{"GT_BeginRefresh()" Link "GT_BeginRefresh()"}
@{"GT_PostFilterIMsg()" Link "GT_PostFilterIMsg()"}@{"GT_EndRefresh()" Link "GT_EndRefresh()"}
@{"GT_ReplyIMsg()" Link "GT_ReplyIMsg()"}
@endnode
@node LAYERS.LIBRARY "layers.library"
@{b}@{u}layers.library@{uu}@{ub}:
-moving:                 -layerinfo's:
@{"InstallLayerHook()" Link "InstallLayerHook()"}      @{"NewLayerInfo()" Link "NewLayerInfo()"}
@{"BeginUpdate()" Link "BeginUpdate()"}           @{"InitLayers()" Link "InitLayers()"}
@{"CreateUpfrontLayer()" Link "CreateUpfrontLayer()"}    @{"LockLayerInfo()" Link "LockLayerInfo()"}
@{"CreateUpfrontHookLayer()" Link "CreateUpfrontHookLayer()"}@{"InstallLayerInfoHook()" Link "InstallLayerInfoHook()"}
@{"UpfrontLayer()" Link "UpfrontLayer()"}          @{"WhichLayer()" Link "WhichLayer()"}
@{"MoveLayerInFrontOf()" Link "MoveLayerInFrontOf()"}    @{"FattenLayerInfo()" Link "FattenLayerInfo()"}
@{"MoveLayer()" Link "MoveLayer()"}             @{"ThinLayerInfo()" Link "ThinLayerInfo()"}
@{"MoveSizeLayer()" Link "MoveSizeLayer()"}         @{"UnlockLayerInfo()" Link "UnlockLayerInfo()"}
@{"SizeLayer()" Link "SizeLayer()"}             @{"DisposeLayerInfo()" Link "DisposeLayerInfo()"}
@{"ScrollLayer()" Link "ScrollLayer()"}           -clips:
@{"CreateBehindLayer()" Link "CreateBehindLayer()"}     @{"DoHookClipRects()" Link "DoHookClipRects()"}
@{"CreateBehindHookLayer()" Link "CreateBehindHookLayer()"} @{"InstallClipRegion()" Link "InstallClipRegion()"}
@{"BehindLayer()" Link "BehindLayer()"}           @{"SwapBitsRastPortClipRect()" Link "SwapBitsRastPortClipRect()"}
@{"EndUpdate()" Link "EndUpdate()"}
@{"DeleteLayer()" Link "DeleteLayer()"}
-locks:
@{"LockLayer()" Link "LockLayer()"}
@{"LockLayers()" Link "LockLayers()"}
@{"UnlockLayer()" Link "UnlockLayer()"}
@{"UnlockLayers()" Link "UnlockLayers()"}
@endnode
@node UTILITY.LIBRARY "utility.library"
@{b}@{u}utility.library@{uu}@{ub}:
-tags:                 -named objects:         -hooks:
@{"AllocateTagItems()" Link "AllocateTagItems()"}    @{"AllocNamedObjectA()" Link "AllocNamedObjectA()"}    @{"CallHookPkt()" Link "CallHookPkt()"}
@{"FindTagItem()" Link "FindTagItem()"}         @{"AddNamedObject()" Link "AddNamedObject()"}
@{"NextTagItem()" Link "NextTagItem()"}         @{"FindNamedObject()" Link "FindNamedObject()"}
@{"TagInArray()" Link "TagInArray()"}          @{"NamedObjectName()" Link "NamedObjectName()"}
@{"MapTags()" Link "MapTags()"}             @{"FreeNamedObject()" Link "FreeNamedObject()"}
@{"GetTagData()" Link "GetTagData()"}          @{"ReleaseNamedObject()" Link "ReleaseNamedObject()"}
@{"ApplyTagChanges()" Link "ApplyTagChanges()"}     @{"AttemptRemNamedObject()" Link "AttemptRemNamedObject()"}
@{"FilterTagItems()" Link "FilterTagItems()"}      @{"RemNamedObject()" Link "RemNamedObject()"}
@{"FilterTagChanges()" Link "FilterTagChanges()"}    -math:
@{"CloneTagItems()" Link "CloneTagItems()"}       @{"SDivMod32()" Link "SDivMod32()"}
@{"RefreshTagItemClones()" Link "RefreshTagItemClones()"}@{"SMult32()" Link "SMult32()"}
@{"PackBoolTags()" Link "PackBoolTags()"}        @{"SMult64()" Link "SMult64()"}
@{"PackStructureTags()" Link "PackStructureTags()"}   @{"UDivMod32()" Link "UDivMod32()"}
@{"UnpackStructureTags()" Link "UnpackStructureTags()"} @{"UMult32()" Link "UMult32()"}
@{"FreeTagItems()" Link "FreeTagItems()"}        @{"UMult64()" Link "UMult64()"}
-strings:              @{"GetUniqueID()" Link "GetUniqueID()"}
@{"Stricmp()" Link "Stricmp()"}             -dates:
@{"Strnicmp()" Link "Strnicmp()"}            @{"Amiga2Date()" Link "Amiga2Date()"}
@{"ToLower()" Link "ToLower()"}             @{"Date2Amiga()" Link "Date2Amiga()"}
@{"ToUpper()" Link "ToUpper()"}             @{"CheckDate()" Link "CheckDate()"}
@endnode
@node ALL_FUNCTIONS_SORTED "all_functions_sorted"
@{"AddAppIconA()" Link "AddAppIconA()"}
@{"AddAppMenuItemA()" Link "AddAppMenuItemA()"}
@{"AddAppWindowA()" Link "AddAppWindowA()"}
@{"AddBootNode()" Link "AddBootNode()"}
@{"AddConfigDev()" Link "AddConfigDev()"}
@{"AddDosNode()" Link "AddDosNode()"}
@{"AddNamedObject()" Link "AddNamedObject()"}
@{"AllocateTagItems()" Link "AllocateTagItems()"}
@{"AllocConfigDev()" Link "AllocConfigDev()"}
@{"AllocExpansionMem()" Link "AllocExpansionMem()"}
@{"AllocNamedObjectA()" Link "AllocNamedObjectA()"}
@{"Amiga2Date()" Link "Amiga2Date()"}
@{"ApplyTagChanges()" Link "ApplyTagChanges()"}
@{"AskKeyMapDefault()" Link "AskKeyMapDefault()"}
@{"AttemptRemNamedObject()" Link "AttemptRemNamedObject()"}
@{"BeginUpdate()" Link "BeginUpdate()"}
@{"BehindLayer()" Link "BehindLayer()"}
@{"CallHookPkt()" Link "CallHookPkt()"}
@{"CheckDate()" Link "CheckDate()"}
@{"CloneTagItems()" Link "CloneTagItems()"}
@{"ConfigBoard()" Link "ConfigBoard()"}
@{"CreateBehindHookLayer()" Link "CreateBehindHookLayer()"}
@{"CreateBehindLayer()" Link "CreateBehindLayer()"}
@{"CreateContext()" Link "CreateContext()"}
@{"CreateGadgetA()" Link "CreateGadgetA()"}
@{"CreateMenusA()" Link "CreateMenusA()"}
@{"CreatePlayer()" Link "CreatePlayer()"}
@{"CreateUpfrontHookLayer()" Link "CreateUpfrontHookLayer()"}
@{"CreateUpfrontLayer()" Link "CreateUpfrontLayer()"}
@{"Date2Amiga()" Link "Date2Amiga()"}
@{"DeleteLayer()" Link "DeleteLayer()"}
@{"DeletePlayer()" Link "DeletePlayer()"}
@{"DisposeLayerInfo()" Link "DisposeLayerInfo()"}
@{"DoHookClipRects()" Link "DoHookClipRects()"}
@{"DrawBevelBoxA()" Link "DrawBevelBoxA()"}
@{"EndUpdate()" Link "EndUpdate()"}
@{"ExternalSync()" Link "ExternalSync()"}
@{"FattenLayerInfo()" Link "FattenLayerInfo()"}
@{"FilterTagChanges()" Link "FilterTagChanges()"}
@{"FilterTagItems()" Link "FilterTagItems()"}
@{"FindConductor()" Link "FindConductor()"}
@{"FindConfigDev()" Link "FindConfigDev()"}
@{"FindNamedObject()" Link "FindNamedObject()"}
@{"FindTagItem()" Link "FindTagItem()"}
@{"FreeConfigDev()" Link "FreeConfigDev()"}
@{"FreeExpansionMem()" Link "FreeExpansionMem()"}
@{"FreeGadgets()" Link "FreeGadgets()"}
@{"FreeMenus()" Link "FreeMenus()"}
@{"FreeNamedObject()" Link "FreeNamedObject()"}
@{"FreeTagItems()" Link "FreeTagItems()"}
@{"FreeVisualInfo()" Link "FreeVisualInfo()"}
@{"GetCurrentBinding()" Link "GetCurrentBinding()"}
@{"GetPlayerAttrsA()" Link "GetPlayerAttrsA()"}
@{"GetTagData()" Link "GetTagData()"}
@{"GetUniqueID()" Link "GetUniqueID()"}
@{"GetVisualInfoA()" Link "GetVisualInfoA()"}
@{"GT_BeginRefresh()" Link "GT_BeginRefresh()"}
@{"GT_EndRefresh()" Link "GT_EndRefresh()"}
@{"GT_FilterIMsg()" Link "GT_FilterIMsg()"}
@{"GT_GetGadgetAttrsA()" Link "GT_GetGadgetAttrsA()"}
@{"GT_GetIMsg()" Link "GT_GetIMsg()"}
@{"GT_PostFilterIMsg()" Link "GT_PostFilterIMsg()"}
@{"GT_RefreshWindow()" Link "GT_RefreshWindow()"}
@{"GT_ReplyIMsg()" Link "GT_ReplyIMsg()"}
@{"GT_SetGadgetAttrsA()" Link "GT_SetGadgetAttrsA()"}
@{"InitLayers()" Link "InitLayers()"}
@{"InstallClipRegion()" Link "InstallClipRegion()"}
@{"InstallLayerHook()" Link "InstallLayerHook()"}
@{"InstallLayerInfoHook()" Link "InstallLayerInfoHook()"}
@{"LayoutMenuItemsA()" Link "LayoutMenuItemsA()"}
@{"LayoutMenusA()" Link "LayoutMenusA()"}
@{"LockLayer()" Link "LockLayer()"}
@{"LockLayerInfo()" Link "LockLayerInfo()"}
@{"LockLayers()" Link "LockLayers()"}
@{"LockRealTime()" Link "LockRealTime()"}
@{"MakeDosNode()" Link "MakeDosNode()"}
@{"MapANSI()" Link "MapANSI()"}
@{"MapRawKey()" Link "MapRawKey()"}
@{"MapTags()" Link "MapTags()"}
@{"MoveLayer()" Link "MoveLayer()"}
@{"MoveLayerInFrontOf()" Link "MoveLayerInFrontOf()"}
@{"MoveSizeLayer()" Link "MoveSizeLayer()"}
@{"NamedObjectName()" Link "NamedObjectName()"}
@{"NewLayerInfo()" Link "NewLayerInfo()"}
@{"NextConductor()" Link "NextConductor()"}
@{"NextTagItem()" Link "NextTagItem()"}
@{"ObtainConfigBinding()" Link "ObtainConfigBinding()"}
@{"PackBoolTags()" Link "PackBoolTags()"}
@{"PackStructureTags()" Link "PackStructureTags()"}
@{"ReadExpansionByte()" Link "ReadExpansionByte()"}
@{"ReadExpansionRom()" Link "ReadExpansionRom()"}
@{"RefreshTagItemClones()" Link "RefreshTagItemClones()"}
@{"ReleaseConfigBinding()" Link "ReleaseConfigBinding()"}
@{"ReleaseNamedObject()" Link "ReleaseNamedObject()"}
@{"RemConfigDev()" Link "RemConfigDev()"}
@{"RemNamedObject()" Link "RemNamedObject()"}
@{"RemoveAppIcon()" Link "RemoveAppIcon()"}
@{"RemoveAppMenuItem()" Link "RemoveAppMenuItem()"}
@{"RemoveAppWindow()" Link "RemoveAppWindow()"}
@{"ScrollLayer()" Link "ScrollLayer()"}
@{"SDivMod32()" Link "SDivMod32()"}
@{"SetConductorState()" Link "SetConductorState()"}
@{"SetCurrentBinding()" Link "SetCurrentBinding()"}
@{"SetKeyMapDefault()" Link "SetKeyMapDefault()"}
@{"SetPlayerAttrs()" Link "SetPlayerAttrs()"}
@{"SizeLayer()" Link "SizeLayer()"}
@{"SMult32()" Link "SMult32()"}
@{"SMult64()" Link "SMult64()"}
@{"Stricmp()" Link "Stricmp()"}
@{"Strnicmp()" Link "Strnicmp()"}
@{"SwapBitsRastPortClipRect()" Link "SwapBitsRastPortClipRect()"}
@{"TagInArray()" Link "TagInArray()"}
@{"ThinLayerInfo()" Link "ThinLayerInfo()"}
@{"ToLower()" Link "ToLower()"}
@{"ToUpper()" Link "ToUpper()"}
@{"UDivMod32()" Link "UDivMod32()"}
@{"UMult32()" Link "UMult32()"}
@{"UMult64()" Link "UMult64()"}
@{"UnlockLayer()" Link "UnlockLayer()"}
@{"UnlockLayerInfo()" Link "UnlockLayerInfo()"}
@{"UnlockLayers()" Link "UnlockLayers()"}
@{"UnlockRealTime()" Link "UnlockRealTime()"}
@{"UnpackStructureTags()" Link "UnpackStructureTags()"}
@{"UpfrontLayer()" Link "UpfrontLayer()"}
@{"WBInfo()" Link "WBInfo()"}
@{"WhichLayer()" Link "WhichLayer()"}
@{"WriteExpansionByte()" Link "WriteExpansionByte()"}
@endnode
@Node "AddBootNode()" "expansion.library/AddBootNode"
@{b}@{u}AddBootNode@{uu}@{ub} -- Add a BOOTNODE to the system (V36).
  @{i}This function will do one of two things@{ui}:
    1> If dos is running, add a new disk type device immediatly.
    2> If dos is not yet running, save information for later use by the system.
  This routine makes sure that your disk device (or a device
  that wants to be treated as if it was a disk...) will be
  entered into the system.If the dos is already up and running,
  then it will be entered immediately.If the dos has not yet been
  run then the data will be recorded, and the dos will get it later.
  We try and boot off of each device in turn, based on priority.
  Floppies have a hard-coded priority.
  There is only one additional piece of magic done by AddBootNode.
  If there is no executable code specified in the deviceNode
  structure (e.g.dn_SegList, dn_Handler, and dn_Task are all
  null) then the standard dos file handler is used for your device.
  Documentation note: a "task" as used here is a dos-task, not
  an exec-task.A dos-task, in the strictest sense, is the
  address of an exec-style message port.In general, it is
  a pointer to a process's pr_MsgPort field (e.g.a constant
  number of bytes after an exec task).
  Autoboot from an expansion card before DOS is running requires
  the card's ConfigDev structure.
  Pass a NULL ConfigDev pointer to create a non-bootable node.
SYNOPSIS  BOOL AddBootNode( BYTE,ULONG,@{FG shine}struct@{FG text} @{"DeviceNode" Link "include:dos/filehandler.h/Main" 100} *,@{FG shine}struct@{FG text} @{"ConfigDev" Link "include:libraries/configvars.h/Main" 32} * );
  @{i}@{b}ok@{ub}@{ui} = AddBootNode( @{i}bootPri@{ui}, @{i}flags@{ui}, @{i}deviceNode@{ui}, @{i}configDev@{ui} )
   D0                D0       D1      A0          A1
  @{i}bootPri@{ui} -- a BYTE quantity with the boot priority for this disk.
    This priority is only for which disks should be looked at:
    the actual disk booted from will be the first disk with
    a valid boot block.If no disk is found then the "bootme"
    hand will come up and the bootstrap code will wait for
    a floppy to be inserted.Recommend priority assignments are:
    @{i}+5@{ui}   -- unit zero for the floppy disk.The floppy should
      always be highest priority to allow the user to
      abort out of a hard disk boot.
     @{i}0@{ui}   -- the run of the mill hard disk
    @{i}-5@{ui}   -- a "network" disk (local disks should take priority).
    @{i}-128@{ui} -- don't even bother to boot from this device.
  @{i}flags@{ui} -- additional flag bits for the call:
      ADNF_STARTPROC (bit 0) -- start a handler process immediately.
    Normally the process is started only when the device node
    is first referenced.This bit is meaningless if you
    have already specified a handler process (non-null dn_Task).
  @{i}deviceNode@{ui} -- a legal DOS device node, properly initialized.
    Typically this will be the result of a @{"MakeDosNode()" Link "MakeDosNode()"}.
    Special cases may require a custom-built device node.
  @{i}configDev@{ui} -- a valid board's ConfigDev structure.This is required
    for autoboot before DOS is running and if left NULL will
    result in an non-bootable node.
  @{i}@{b}ok@{ub}@{ui} - non-zero everything went ok, zero if we ran out of memory
    or some other weirdness happened.
NOTE
  This function eliminates the need to manually @{"Enqueue" Link "exec.guide/Enqueue()"} a BOOTNODE
  onto an expansion.library list.Be sure V36 expansion.library is
  available before calling this function!
SEE ALSO
  @{"AddDosNode" Link "AddDosNode()"}
@EndNode
@Node "AddConfigDev()" "expansion.library/AddConfigDev"
@{b}@{u}AddConfigDev@{uu}@{ub} - add a new @{"ConfigDev" Link "include:libraries/configvars.h/Main" 32} structure to the system.
  (Not typically called by user code)
  This routine adds the specified ConfigDev structure to the
  list of Configuration Devices in the system.
SYNOPSIS
  AddConfigDev( @{i}configDev@{ui} )
                 A0
  @{i}configDev@{ui} - a valid ConfigDev structure.
SEE ALSO
  @{"RemConfigDev" Link "RemConfigDev()"}
@EndNode
@Node "AddDosNode()" "expansion.library/AddDosNode"
@{b}@{u}AddDosNode@{uu}@{ub} -- mount a disk to the system.
  This is the old (pre V36) function that works just like
  @{"AddBootNode()" Link "AddBootNode()"}.It should only be used if you *@{b}MUST@{ub}* work
  in a 1.3 system and you don't need to autoboot.
SYNOPSIS  BOOL AddDosNode( BYTE,ULONG,@{FG shine}struct@{FG text} @{"DeviceNode" Link "include:dos/filehandler.h/Main" 100} *);
  @{i}@{b}ok@{ub}@{ui} = AddDosNode( @{i}bootPri@{ui}, @{i}flags@{ui}, @{i}deviceNode@{ui} )
   D0               D0        D1     A0
  @{i}@{b}ok@{ub}@{ui} - non-zero everything went ok, zero if we ran out of memory
    or some other weirdness happened.
EXAMPLE
  /* enter a bootable disk into the system.Start a file handler
  ** process immediately.*/
  @{FG shine}if@{FG text}(  AddDosNode( 0, ADNF_STARTPROC, MakeDosNode( @{i}paramPacket@{ui} ) )  )
    ...AddDosNode ok...
BUGS
  Before V36 Kickstart, no function existed to add BOOTNODES.
  If an older expansion.library is in use, driver code will need
  to manually construct a @{"BootNode" Link "include:libraries/expansionbase.h/Main" 33} and @{"Enqueue()" Link "exec.guide/Enqueue()"} it to eb_Mountlist.
  If you have a V36 or better expansion.library, your code should
  use @{"AddBootNode()" Link "AddBootNode()"}.
SEE ALSO
  @{"MakeDosNode" Link "MakeDosNode()"}, @{"AddBootNode" Link "AddBootNode()"}
@EndNode
@Node "AllocConfigDev()" "expansion.library/AllocConfigDev"
@{b}@{u}AllocConfigDev@{uu}@{ub} - allocate a @{"ConfigDev" Link "include:libraries/configvars.h/Main" 32} structure.
  This routine returns the address of a ConfigDev structure.
  It is provided so new fields can be added to the structure
  without breaking old, existing code.The structure is cleared
  when it is returned to the user.
SYNOPSIS
  @{i}@{b}configDev@{ub}@{ui} = AllocConfigDev()
   D0
  @{i}@{b}configDev@{ub}@{ui} - either a valid ConfigDev structure or NULL.
SEE ALSO
  @{"FreeConfigDev" Link "FreeConfigDev()"}
@EndNode
@Node "AllocExpansionMem()" "expansion.library/AllocExpansionMem"
@{b}@{u}AllocExpansionMem@{uu}@{ub} - allocate expansion memory.
  (Not typically called by user code)
  This function allocates numslots of expansion space (each slot
  is E_SLOTSIZE bytes).It returns the slot number of the
  start of the expansion memory.The EC_MEMADDR macro may be
  used to convert this to a memory address.
  Boards that fit the expansion architecture have alignment
  rules.Normally a board must be on a binary boundary of its
  size.Four and Eight megabyte boards have special rules.
  User defined boards might have other special rules.
  If AllocExpansionMem() succeeds, the startSlot will satisfy
  the following equation:
    (@{i}startSlot@{ui} - @{i}slotOffset@{ui}) MOD @{i}slotAlign@{ui} = 0
SYNOPSIS
  @{i}@{b}startSlot@{ub}@{ui} = AllocExpansionMem( @{i}numSlots@{ui}, @{i}slotOffset@{ui} )
   D0                             D0        D1
  @{i}numSlots@{ui} - the number of slots required.
  @{i}slotOffset@{ui} - an offset from that boundary for startSlot.
  @{i}@{b}startSlot@{ub}@{ui} - the slot number that was allocated, or -1 for error.
EXAMPLES
    AllocExpansionMem( 2, 0 )
  Tries to allocate 2 slots on a two slot boundary.
    AllocExpansionMem( 64, 32 )
  This is the allocation rule for 4 meg boards.It allocates
  4 megabytes (64 slots) on an odd 2 meg boundary.
SEE ALSO
  @{"FreeExpansionMem" Link "FreeExpansionMem()"}
@EndNode
@Node "ConfigBoard()" "expansion.library/ConfigBoard"
@{b}@{u}ConfigBoard@{uu}@{ub} - configure a board.
  This routine configures an expansion board.The board
  will generally live at E_EXPANSIONBASE, but the base is
  passed as a parameter to allow future compatibility.
  The configDev parameter must be a valid configDev that
  has already had @{"ReadExpansionRom()" Link "ReadExpansionRom()"} called on it.
  ConfigBoard will allocate expansion memory and place
  the board at its new address.It will update configDev
  accordingly.If there is not enough expansion memory
  for this board then an error will be returned.
SYNOPSIS
  @{i}@{b}error@{ub}@{ui} = ConfigBoard( @{i}board@{ui}, @{i}configDev@{ui} )
   D0                   A0     A1
  @{i}board@{ui} - the current address that the expansion board is responding.
  @{i}configDev@{ui} - an initialized @{"ConfigDev" Link "include:libraries/configvars.h/Main" 32} structure, returned by @{"AllocConfigDev" Link "AllocConfigDev()"}.
  @{i}@{b}error@{ub}@{ui} - non-zero if there was a problem configuring this board
    (Can return EE_OK or EE_NOEXPANSION)
SEE ALSO
  @{"FreeConfigDev" Link "FreeConfigDev()"}
@EndNode
@Node "FindConfigDev()" "expansion.library/FindConfigDev"
@{b}@{u}FindConfigDev@{uu}@{ub} - find a matching @{"ConfigDev" Link "include:libraries/configvars.h/Main" 32} entry.
  This routine searches the list of existing ConfigDev structures in the system
  and looks for one that has the specified manufacturer and product codes.
  If the oldConfigDev is NULL the the search is from the start of the list of
  configuration devices.If it is not null then it searches from the first
  configuration device entry AFTER oldConfigDev.
  A code of -1 is treated as a wildcard -- e.g.it matches
  any manufacturer (or product)
SYNOPSIS
  @{i}@{b}configDev@{ub}@{ui} = FindConfigDev( @{i}oldConfigDev@{ui}, @{i}manufacturer@{ui}, @{i}product@{ui} )
   D0                         A0            D0             D1
  @{i}oldConfigDev@{ui} - a valid ConfigDev structure, or NULL to start
    from the start of the list.
  @{i}manufacturer@{ui} - the manufacturer code being searched for, or
    -1 to ignore manufacturer numbers.
  @{i}product@{ui} - the product code being searched for, or -1 to ignore product numbers.
  @{i}@{b}configDev@{ub}@{ui} - the next ConfigDev entry that matches the
    manufacturer and product codes, or NULL if there are no more matches.
EXAMPLES
  /* to find all configdevs of the proper type */
  @{FG shine}struct@{FG text} ConfigDev *@{i}cd@{ui} = NULL;
  @{FG shine}while@{FG text}( @{i}cd@{ui} = FindConfigDev( @{i}cd@{ui}, MANUFACTURER, PRODUCT ) ) {
    /* do something with the returned ConfigDev */
  }
@EndNode
@Node "FreeConfigDev()" "expansion.library/FreeConfigDev"
@{b}@{u}FreeConfigDev@{uu}@{ub} - free a @{"ConfigDev" Link "include:libraries/configvars.h/Main" 32} structure.
  This routine frees a ConfigDev structure as returned by
  @{"AllocConfigDev" Link "AllocConfigDev()"}.
SYNOPSIS
  FreeConfigDev( @{i}configDev@{ui} )
                  A0
  @{i}configDev@{ui} - a valid ConfigDev structure.
SEE ALSO
  @{"AllocConfigDev" Link "AllocConfigDev()"}
@EndNode
@Node "FreeExpansionMem()" "expansion.library/FreeExpansionMem"
@{b}@{u}FreeExpansionMem@{uu}@{ub} - allocate standard device expansion memory.
  (Not typically called by user code)
  This function allocates numslots of expansion space (each slot
  is E_SLOTSIZE bytes).It is the inverse function of
  @{"AllocExpansionMem()" Link "AllocExpansionMem()"}.
SYNOPSIS
  FreeExpansionMem( @{i}startSlot@{ui}, @{i}numSlots@{ui} )
                     D0         D1
  @{i}startSlot@{ui} - the slot number that was allocated, or -1 for error.
  @{i}numSlots@{ui} - the number of slots to be freed.
EXCEPTIONS
  If the caller tries to free a slot that is already in the free list,
  FreeExpansionMem will @{"Alert()" Link "exec.guide/Alert()"} (e.g.crash the system).
SEE ALSO
  @{"AllocExpansionMem" Link "AllocExpansionMem()"}
@EndNode
@Node "GetCurrentBinding()" "expansion.library/GetCurrentBinding"
@{b}@{u}GetCurrentBinding@{uu}@{ub} - sets static board configuration area.
  This function writes the contents of the "currentBinding"
  structure out of a private place.It may be set via
  @{"SetCurrentBinding()" Link "SetCurrentBinding()"}.This is really a kludge, but it is
  the only way to pass extra arguments to a newly configured device.
  A @{"CurrentBinding" Link "include:libraries/configvars.h/Main" 62} structure has the name of the currently
  loaded file, the product string that was associated with
  this driver, and a pointer to the head of a singly linked
  list of @{"ConfigDev" Link "include:libraries/configvars.h/Main" 32} structures (linked through the cd_NextCD field).
  Many devices may not need this information; they have hard
  coded into themselves their manufacture number.It is
  recommended that you at least check that you can deal with
  the product code in the linked ConfigDev structures.
SYNOPSIS
  @{i}@{b}actual@{ub}@{ui} = GetCurrentBinding( @{i}currentBinding@{ui}, @{i}size@{ui} )
                               A0              D0:16
  @{i}currentBinding@{ui} - a pointer to a CurrentBinding structure
  @{i}size@{ui} - The size of the user's binddriver structure.
    Do not pass in less than sizeof(struct CurrentBinding).
  @{i}@{b}actual@{ub}@{ui} - the true size of a CurrentBinding structure is returned.
@EndNode
@Node "MakeDosNode()" "expansion.library/MakeDosNode"
@{b}@{u}MakeDosNode@{uu}@{ub} -- construct dos data structures that a disk needs.
  This routine manufactures the data structures needed to enter
  a dos disk device into the system.This consists of a @{"DeviceNode" Link "include:dos/filehandler.h/Main" 100},
  a @{"FileSysStartupMsg" Link "include:dos/filehandler.h/Main" 85}, a disk environment vector, and up to two
  bcpl strings.See the @{"libraries/dosextens.h" Link "include:libraries/dosextens.h/Main" 0} and
  @{"libraries/filehandler.h" Link "include:libraries/filehandler.h/Main" 0} include files for more information.
  MakeDosNode will allocate all the memory it needs, and then
  link the various structure together.It will make sure all
  the structures are long-word aligned (as required by the DOS).
  It then returns the information to the user so he can change
  anything else that needs changing.Typically he will then call
  @{"AddDosNode()" Link "AddDosNode()"} to enter the new device into the dos tables.
SYNOPSIS  @{FG shine}struct@{FG text} @{"DeviceNode" Link "include:dos/filehandler.h/Main" 100} *MakeDosNode( @{FG shine}void@{FG text} * );
  @{i}@{b}deviceNode@{ub}@{ui} = MakeDosNode( @{i}parameterPkt@{ui} )
   D0                        A0
  @{i}parameterPkt@{ui} - a longword array containing all the information needed to
    initialize the data structures.Normally I would have provided a structure
    for this, but the variable length of the packet caused problems.
    The two strings are null terminated strings, like all other exec strings.
    @{i}@{b}longword@{ub}@{ui}  @{i}@{b}description@{ub}@{ui}
    --------  -----------
    0   string with dos handler name
    1   string with exec device name
    2   unit number (for OpenDevice)
    3   flags (for OpenDevice)
    4   # of longwords in rest of environment
    5-n   file handler environment (see @{"libraries/filehandler.h)" Link "include:libraries/filehandler.h/Main" 0}
  @{i}@{b}deviceNode@{ub}@{ui} - pointer to initialize device node structure, or
    null if there was not enough memory.You may need to change
    certain fields before passing the DeviceNode to @{"AddDosNode()" Link "AddDosNode()"}.
EXAMPLES
  /* set up a 3.5" Amiga format floppy drive for unit 1 */
  @{FG shine}char@{FG text} execName[] = "trackdisk.device";
  @{FG shine}char@{FG text} dosName[] = "df1";
  ULONG @{i}parmPkt@{ui}[] = {
      (ULONG) @{i}dosName@{ui},
      (ULONG) @{i}execName@{ui},
      1,      /* unit number */
      0,      /* OpenDevice flags */
      /* here is the environment block */
      16,     /* table upper bound */
      512>>2,   /* # longwords in a block */
      0,      /* sector origin -- unused */
      2,      /* number of surfaces */
      1,      /* secs per logical block -- leave as 1 */
      11,     /* blocks per track */
      2,      /* reserved blocks -- 2 boot blocks */
      0,      /* ?? -- unused */
      0,      /* interleave */
      0,      /* lower cylinder */
      79,     /* upper cylinder */
      5,      /* number of buffers */
      MEMF_CHIP,    /* type of memory for buffers */
      (~0 >> 1),          /* largest transfer size (largest signed #) */
      ~1,     /* addmask */
      0,      /* boot priority */
      0x444f5300,   /* dostype: 'DOS\0' */
  };
  @{FG shine}struct@{FG text} @{"Device" Link "include:exec/devices.h/Main" 25} @{"Node" Link "include:exec/nodes.h/Main" 22} *@{i}node@{ui}, *@{i}MakeDosNode@{ui}();
  @{i}node@{ui} = MakeDosNode( @{i}parmPkt@{ui} );
SEE ALSO
  @{"AddDosNode" Link "AddDosNode()"}, @{"libraries/dosextens.h" Link "include:libraries/dosextens.h/Main" 0}, @{"libraries/filehandler.h" Link "include:libraries/filehandler.h/Main" 0}
@EndNode
@Node "ObtainConfigBinding()" "expansion.library/ObtainConfigBinding"
@{b}@{u}ObtainConfigBinding@{uu}@{ub} - try to get permission to bind drivers.
  ObtainConfigBinding gives permission to bind drivers to
  @{"ConfigDev" Link "include:libraries/configvars.h/Main" 32} structures.It exists so two drivers at once
  do not try and own the same ConfigDev structure.This
  call will block until it is safe proceed.
  It is crucially important that people lock out others
  before loading new drivers.Much of the data that is used
  to configure things is statically kept, and others need
  to be kept from using it.
  This call is built directly on Exec @{"SignalSemaphore" Link "include:exec/semaphores.h/Main" 40} code
  (e.g.ObtainSemaphore).
SYNOPSIS
  ObtainConfigBinding()
SEE ALSO
  @{"ReleaseConfigBinding()" Link "ReleaseConfigBinding()"}
@EndNode
@Node "ReadExpansionByte()" "expansion.library/ReadExpansionByte"
@{b}@{u}ReadExpansionByte@{uu}@{ub} - read a byte nybble by nybble.
  (Not typically called by user code)
  ReadExpansionByte reads a byte from a new-style expansion
  board.These boards have their readable data organized
  as a series of nybbles in memory.This routine reads
  two nybbles and returns the byte value.
  In general, this routine will only be called by @{"ReadExpansionRom" Link "ReadExpansionRom()"}.
  The offset is a byte offset, as if into a @{"ExpansionRom" Link "include:libraries/configregs.h/Main" 46} structure.
  The actual memory address read will be four times larger.
  The macros EROFFSET and ECOFFSET are provided to help get
  these offsets from C.
SYNOPSIS
  @{i}@{b}byte@{ub}@{ui} = ReadExpansionByte( @{i}board@{ui}, @{i}offset@{ui} )
   D0                        A0     D0
  @{i}board@{ui} - a pointer to the base of a new style expansion board.
  @{i}offset@{ui} - a logical offset from the board base
  @{i}@{b}byte@{ub}@{ui} - a byte of data from the expansion board.
EXAMPLES
  @{i}byte@{ui} = ReadExpansionByte( cd->BoardAddr, EROFFSET( er_Type ) );
  @{i}ints@{ui} = ReadExpansionByte( cd->BoardAddr, ECOFFSET( ec_Interrupt ) );
SEE ALSO
  @{"WriteExpansionByte" Link "WriteExpansionByte()"}, @{"ReadExpansionRom" Link "ReadExpansionRom()"}
@EndNode
@Node "ReadExpansionRom()" "expansion.library/ReadExpansionRom"
@{b}@{u}ReadExpansionRom@{uu}@{ub} - read a boards configuration ROM space.
  (Not typically called by user code)
  ReadExpansionRom reads a the ROM portion of an expansion device
  in to cd_Rom portion of a @{"ConfigDev" Link "include:libraries/configvars.h/Main" 32} structure.This routine knows
  how to detect whether or not there is actually a board there.
  In addition, the ROM portion of a new style expansion board
  is encoded in ones-complement format (except for the first
  two nybbles -- the er_Type field).ReadExpansionRom knows
  about this and un-complements the appropriate fields.
SYNOPSIS
  @{i}@{b}error@{ub}@{ui} = ReadExpansionRom( @{i}board@{ui}, @{i}configDev@{ui} )
   D0                        A0      A1
  @{i}board@{ui} - a pointer to the base of a new style expansion board.
  @{i}configDev@{ui} - the ConfigDev structure that will be read in.
  @{i}offset@{ui} - a logical offset from the configdev base
  @{i}@{b}error@{ub}@{ui} - If the board address does not contain a valid new style
    expansion board, then error will be non-zero.
EXAMPLES
  @{i}configDev@{ui} = AllocConfigDev();
  @{FG shine}if@{FG text}( ! configDev ) panic();
  @{i}error@{ui} = ReadExpansionBoard( @{i}board@{ui}, @{i}configDev@{ui} );
  @{FG shine}if@{FG text}( ! @{i}error@{ui} ) {
    configDev->@{i}cd_BoardAddr@{ui} = @{i}board@{ui};
    ConfigBoard( @{i}configDev@{ui} );
  }
SEE ALSO
  @{"ReadExpansionByte" Link "ReadExpansionByte()"}, @{"WriteExpansionByte" Link "WriteExpansionByte()"}
@EndNode
@Node "ReleaseConfigBinding()" "expansion.library/ReleaseConfigBinding"
@{b}@{u}ReleaseConfigBinding@{uu}@{ub} - allow others to bind to drivers.
  This call should be used when you are done binding drivers
  to @{"ConfigDev" Link "include:libraries/configvars.h/Main" 32} entries.It releases the SignalSemaphore; this
  allows others to bind their drivers to ConfigDev structures.
SYNOPSIS
  ReleaseConfigBinding()
SEE ALSO
  @{"ObtainConfigBinding()" Link "ObtainConfigBinding()"}
@EndNode
@Node "RemConfigDev()" "expansion.library/RemConfigDev"
@{b}@{u}RemConfigDev@{uu}@{ub} - remove a @{"ConfigDev" Link "include:libraries/configvars.h/Main" 32} structure from the system.
  (Not typically called by user code)
  This routine removes the specified ConfigDev structure from the
  list of Configuration Devices in the system.
SYNOPSIS
  RemConfigDev( @{i}configDev@{ui} )
                 A0
  @{i}configDev@{ui} - a valid ConfigDev structure.
SEE ALSO
  @{"AddConfigDev" Link "AddConfigDev()"}
@EndNode
@Node "SetCurrentBinding()" "expansion.library/SetCurrentBinding"
@{b}@{u}SetCurrentBinding@{uu}@{ub} - sets static board configuration area.
  This function records the contents of the "currentBinding" structure in a
  private place.It may be read via @{"GetCurrentBinding()" Link "GetCurrentBinding()"}.This is really a kludge,
  but it is the only way to pass extra arguments to a newly configured device.
  A @{"CurrentBinding" Link "include:libraries/configvars.h/Main" 62} structure has the name of the currently
  loaded file, the product string that was associated with
  this driver, and a pointer to the head of a singly linked
  list of @{"ConfigDev" Link "include:libraries/configvars.h/Main" 32} structures (linked through the cd_NextCD field).
  Many devices may not need this information; they have hard coded into
  themselves their manufacture number.It is recommended that you at least check
  that you can deal with the product code in the linked ConfigDev structures.
SYNOPSIS
  SetCurrentBinding( @{i}currentBinding@{ui}, @{i}size@{ui} )
                      A0              D0:16
  @{i}currentBinding@{ui} - a pointer to a CurrentBinding structure
  @{i}size@{ui} - The size of the user's binddriver structure.No more than this much
    data will be copied.If size is less than the library's idea a
    CurrentBinding size, then the library's structure will be null padded.
SEE ALSO
  @{"GetCurrentBinding" Link "GetCurrentBinding()"}
@EndNode
@Node "WriteExpansionByte()" "expansion.library/WriteExpansionByte"
@{b}@{u}WriteExpansionByte@{uu}@{ub} - write a byte nybble by nybble.
  (Not typically called by user code)
  WriteExpansionByte writes a byte to a new-style expansion board.
  These boards have their writeable data organized as a series
  of nybbles in memory.This routine writes two nybbles in a very
  careful manner to work with all types of new expansion boards.
  To make certain types of board less expensive, an expansion board's
  write registers may be organized as either a byte-wide or nybble-wide
  register.If it is nybble-wide then it must latch the less significant
  nybble until the more significant nybble is written.
  This allows the following algorithm to work with either type of board:
    write the low order nybble to bits D15-D12 of byte (offset*4)+2
    write the entire byte to bits D15-D8 of byte (offset*4)
  The offset is a byte offset into a @{"ExpansionRom" Link "include:libraries/configregs.h/Main" 46} structure.
  The actual memory address read will be four times larger.
  The macros EROFFSET and ECOFFSET are provided to help get
  these offsets from C.
SYNOPSIS
  WriteExpansionByte( @{i}board@{ui}, @{i}offset@{ui}, @{i}byte@{ui} )
                       A0     D0      D1
  @{i}board@{ui} - a pointer to the base of a new style expansion board.
  @{i}offset@{ui} - a logical offset from the configdev base
  @{i}byte@{ui} - the byte of data to be written to the expansion board.
EXAMPLES
  WriteExpansionByte( cd->@{i}BoardAddr@{ui}, ECOFFSET( @{i}ec_Shutup@{ui} ),  0 );
  WriteExpansionByte( cd->@{i}BoardAddr@{ui}, ECOFFSET( @{i}ec_Interrupt@{ui} ), 1 );
SEE ALSO
  @{"ReadExpansionByte" Link "ReadExpansionByte()"}, @{"ReadExpansionRom" Link "ReadExpansionRom()"}
@EndNode

@Node "BeginUpdate()" "layers.library/BeginUpdate"
@{b}@{u}BeginUpdate@{uu}@{ub} -- Prepare to repair damaged layer.
  Convert damage list to @{"ClipRect" Link "include:graphics/clip.h/Main" 63} list and swap in for programmer to redraw
  through.This routine simulates the ROM library environment.The idea is to
  only render in the "damaged" areas, saving time over redrawing all of the
  layer.The layer is locked against changes made by the layer library.
SYNOPSIS  @{FG shine}long@{FG text} BeginUpdate( @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *);
  @{i}@{b}result@{ub}@{ui} = BeginUpdate( @{i}l@{ui} )
   d0                    a0
  @{i}l@{ui} - pointer to a layer
  @{i}@{b}result@{ub}@{ui} - TRUE if damage list converted to ClipRect list successfully.
    FALSE if list conversion aborted.(probably out of memory)
BUGS
  If BeginUpdate returns FALSE, programmer must abort the attempt to refresh
  this layer and instead call EndUpdate( l, FALSE ) to restore original
  ClipRect and damage list.
SEE ALSO
  @{"EndUpdate" Link "EndUpdate()"}, @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}, @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0}
@EndNode
@Node "BehindLayer()" "layers.library/BehindLayer"
@{b}@{u}BehindLayer@{uu}@{ub} -- Put layer behind other layers.
  Move this layer to the most behind position swapping bits in and out of the
  display with other layers.If other layers are REFRESH then collect their
  damage lists and set the LAYERREFRESH bit in the Flags fields of those layers
  that may be revealed.If this layer is a backdrop layer then put this layer
  behind all other backdrop layers.If this layer is @{b}NOT@{ub} a backdrop layer then
  put in front of the top backdrop layer and behind all other layers.
SYNOPSIS  @{FG shine}long@{FG text} BehindLayer( @{FG shine}long@{FG text}, @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *);
  @{i}@{b}result@{ub}@{ui} = BehindLayer( @{i}dummy@{ui}, @{i}l@{ui} )
   d0                    a0     a1
  @{i}dummy@{ui} - unused
  @{i}l@{ui} - pointer to a layer
  @{i}@{b}result@{ub}@{ui} - TRUE if operation successful
    FALSE if operation unsuccessful (probably out of memory)
NOTE
  This operation may generate refresh events in other layers associated with
  this layer's @{"Layer_Info" Link "include:graphics/layers.h/Main" 29} structure.
SEE ALSO
  @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}, @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0}
@EndNode
@Node "CreateBehindHookLayer()" "layers.library/CreateBehindHookLayer"
@{b}@{u}CreateBehindHookLayer@{uu}@{ub} -- Create a new layer behind all existing layers,
  using supplied callback BackFill hook. (V36)
  Create a new Layer of position and size (x0,y0)->(x1,y1).Make this layer of
  type found in flags.size (x0,y0)->(x1,y1).Install Layer->BackFill callback Hook.
  If SuperBitMap, use bm2 as pointer to real SuperBitMap, and copy contents of
  Superbitmap into display layer.If this layer is a backdrop layer then place it
  behind all other layers including other backdrop layers.If this is not a
  backdrop layer then place it behind all nonbackdrop layers.
SYNOPSIS
  @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *CreateBehindHookLayer(@{FG shine}struct@{FG text} @{"Layer_Info" Link "include:graphics/layers.h/Main" 29} *, @{FG shine}struct@{FG text} @{"BitMap" Link "include:graphics/gfx.h/Main" 46} *,
    @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *, ...);
  @{i}@{b}result@{ub}@{ui} = CreateBehindHookLayer(@{i}li@{ui},@{i}bm@{ui},@{i}x0@{ui},@{i}y0@{ui},@{i}x1@{ui},@{i}y1@{ui},@{i}flags@{ui},@{i}hook@{ui},[,@{i}bm2@{ui}])
   d0                             a0 a1 d0  d1 d2 d3  d4    a3   [ a2 ]
  @{i}li@{ui} - pointer to LayerInfo structure
  @{i}bm@{ui} - pointer to common BitMap used by all Layers
  @{i}x0@{ui},@{i}y0@{ui} - upper left hand corner of layer
  @{i}x1@{ui},@{i}y1@{ui} - lower right hand corner of layer
  @{i}flags@{ui} - various types of layers supported as bit sets.
    (for bit definitions, see @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0} )
  @{i}hook@{ui} -  Layer->BackFill callback Hook (see @{"InstallLayerHook()" Link "InstallLayerHook()"})
    If hook is LAYERS_BACKFILL, the default backfill is used for the layer.
    (Same as pre-2.0) As of V39:
    If hook is LAYERS_NOBACKFILL, the layer will not be backfilled (NO-OP).
  @{i}bm2@{ui} - pointer to optional Super BitMap
  @{i}@{b}result@{ub}@{ui} - pointer to Layer structure if successful,NULL if not successful
NOTE
   When using SUPERBITMAP, you should also set LAYERSMART flag.
SEE ALSO
  @{"InstallLayerHook" Link "InstallLayerHook()"}, @{"DeleteLayer" Link "DeleteLayer()"}, @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}, @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0},
  @{"graphics/gfx.h" Link "include:graphics/gfx.h/Main" 0}, @{"utility/hooks.h" Link "include:utility/hooks.h/Main" 0}
@EndNode
@Node "CreateBehindLayer()" "layers.library/CreateBehindLayer"
@{b}@{u}CreateBehindLayer@{uu}@{ub} -- Create a new layer behind all existing layers.
  Create a new Layer of position and size (x0,y0)->(x1,y1).Make this layer of
  type found in flags.If SuperBitMap, use bm2 as pointer to real SuperBitMap,and
  copy contents of Superbitmap into display layer.If this layer is a backdrop
  layer then place it behind all other layers including other backdrop layers.
  If this is not a backdrop layer then place it behind all nonbackdrop layers.
SYNOPSIS
  @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *CreateBehindLayer(@{FG shine}struct@{FG text} @{"Layer_Info" Link "include:graphics/layers.h/Main" 29} *, @{FG shine}struct@{FG text} @{"BitMap" Link "include:graphics/gfx.h/Main" 46} *,
    @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, ...);
  @{i}@{b}result@{ub}@{ui} = CreateBehindLayer(@{i}li@{ui},@{i}bm@{ui},@{i}x0@{ui},@{i}y0@{ui},@{i}x1@{ui},@{i}y1@{ui},@{i}flags@{ui} [,@{i}bm2@{ui}])
   d0                         a0 a1 d0  d1 d2 d3  d4    [ a2 ]
  @{i}li@{ui} - pointer to LayerInfo structure
  @{i}bm@{ui} - pointer to common BitMap used by all Layers
  @{i}x0@{ui},@{i}y0@{ui} - upper left hand corner of layer
  @{i}x1@{ui},@{i}y1@{ui} - lower right hand corner of layer
  @{i}flags@{ui} - various types of layers supported as bit sets.
    (for bit definitions, see @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0} )
  @{i}bm2@{ui} - pointer to optional Super BitMap
  @{i}@{b}result@{ub}@{ui} - pointer to Layer structure if successful NULL if not successful
NOTE
  When using SUPERBITMAP, you should also set LAYERSMART flag.
SEE ALSO
  @{"DeleteLayer" Link "DeleteLayer()"}, @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}, @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0}, @{"graphics/gfx.h" Link "include:graphics/gfx.h/Main" 0}
@EndNode
@Node "CreateUpfrontHookLayer()" "layers.library/CreateUpfrontHookLayer"
@{b}@{u}CreateUpfrontHookLayer@{uu}@{ub} -- Create a new layer on top of existing layers,
  using supplied callback BackFill hook.(V36)
  Create a new Layer of position and size (x0,y0)->(x1,y1) and place it on top
  of all other layers.Make this layer of type found in flags.Install
  Layer->BackFill callback hook.If SuperBitMap, use bm2 as pointer to real
  SuperBitMap and copy contents of Superbitmap into display layer.
SYNOPSIS
  @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *CreateUpfrontHookLayer(@{FG shine}struct@{FG text} @{"Layer_Info" Link "include:graphics/layers.h/Main" 29} *, @{FG shine}struct@{FG text} @{"BitMap" Link "include:graphics/gfx.h/Main" 46} *,
    @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *, ...);
  @{i}@{b}result@{ub}@{ui} = CreateUpfrontHookLayer(@{i}li@{ui},@{i}bm@{ui},@{i}x0@{ui},@{i}y0@{ui},@{i}x1@{ui},@{i}y1@{ui},@{i}flags@{ui},@{i}hook@{ui},[,@{i}bm2@{ui}])
   d0                              a0 a1 d0  d1 d2 d3  d4    a3   [ a2 ]
  @{i}li@{ui} - pointer to LayerInfo structure
  @{i}bm@{ui} - pointer to common BitMap used by all Layers
  @{i}x0@{ui},@{i}y0@{ui} - upper left hand corner of layer
  @{i}x1@{ui},@{i}y1@{ui} - lower right hand corner of layer
  @{i}flags@{ui} - various types of layers supported as bit sets.
  @{i}hook@{ui} -  Layer->BackFill callback Hook (see @{"InstallLayerHook()" Link "InstallLayerHook()"})
    If hook is LAYERS_BACKFILL, the default backfill is used for the layer.
    (Same as pre-2.0) As of V39:
    If hook is LAYERS_NOBACKFILL, the layer will not be backfilled (NO-OP).
  @{i}bm2@{ui} - pointer to optional Super BitMap
  @{i}@{b}result@{ub}@{ui} - pointer to Layer structure if successful NULL if not successful
NOTE
  When using SUPERBITMAP, you should also set LAYERSMART flag.
SEE ALSO
  @{"InstallLayerHook" Link "InstallLayerHook()"}, @{"DeleteLayer" Link "DeleteLayer()"}, @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}, @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0},
  @{"graphics/gfx.h" Link "include:graphics/gfx.h/Main" 0}, @{"utility/hooks.h" Link "include:utility/hooks.h/Main" 0}
@EndNode
@Node "CreateUpfrontLayer()" "layers.library/CreateUpfrontLayer"
@{b}@{u}CreateUpfrontLayer@{uu}@{ub} -- Create a new layer on top of existing layers.
  Create a new Layer of position and size (x0,y0)->(x1,y1) and place it on top
  of all other layers.Make this layer of type found in flags if SuperBitMap,
  use bm2 as pointer to real SuperBitMap. and copy contents of Superbitmap into
  display layer.
SYNOPSIS
  @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *CreateUpfrontLayer(@{FG shine}struct@{FG text} @{"Layer_Info" Link "include:graphics/layers.h/Main" 29} *, @{FG shine}struct@{FG text} @{"BitMap" Link "include:graphics/gfx.h/Main" 46} *,
    @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, ...);
  @{i}@{b}result@{ub}@{ui} = CreateUpfrontLayer(@{i}li@{ui},@{i}bm@{ui},@{i}x0@{ui},@{i}y0@{ui},@{i}x1@{ui},@{i}y1@{ui},@{i}flags@{ui} [,@{i}bm2@{ui}])
   d0                          a0 a1 d0  d1 d2 d3  d4   [ a2 ]
  @{i}li@{ui} - pointer to LayerInfo structure
  @{i}bm@{ui} - pointer to common BitMap used by all Layers
  @{i}x0@{ui},@{i}y0@{ui} - upper left hand corner of layer
  @{i}x1@{ui},@{i}y1@{ui} - lower right hand corner of layer
  @{i}flags@{ui} - various types of layers supported as bit sets.
  @{i}bm2@{ui} - pointer to optional Super BitMap
  @{i}@{b}result@{ub}@{ui} - pointer to Layer structure if successful, NULL if not successful
NOTE
  When using SUPERBITMAP, you should also set LAYERSMART flag.
SEE ALSO
  @{"DeleteLayer" Link "DeleteLayer()"}, @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}, @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0}, @{"graphics/gfx.h" Link "include:graphics/gfx.h/Main" 0}
@EndNode
@Node "DeleteLayer()" "layers.library/DeleteLayer"
@{b}@{u}DeleteLayer@{uu}@{ub} -- delete layer from layer list.
  Remove this layer from the list of layers.Release memory associated with it.
  Restore other layers that may have been obscured by it.Trigger refresh in those
  that may need it.If this is a superbitmap layer make sure SuperBitMap is
  current.The SuperBitMap is not removed from the system but is available for
  program use even though the rest of the layer information has been deallocated.
SYNOPSIS  @{FG shine}long@{FG text} DeleteLayer( @{FG shine}long@{FG text}, @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *);
  @{i}@{b}result@{ub}@{ui} = DeleteLayer( @{i}dummy@{ui}, @{i}l@{ui} )
   d0                    a0     a1
  @{i}dummy@{ui} - unused
  @{i}l@{ui} - pointer to a layer
  @{i}@{b}result@{ub}@{ui} - TRUE if this layer successfully deleted from the system,
    FALSE if layer not deleted.(probably out of memory )
SEE ALSO
  @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}, @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0}
@EndNode
@Node "DisposeLayerInfo()" "layers.library/DisposeLayerInfo"
@{b}@{u}DisposeLayerInfo@{uu}@{ub} -- Return all memory for LayerInfo to memory pool
  Return LayerInfo and any other memory attached to this LayerInfo to memory
  allocator.
SYNOPSIS  @{FG shine}void@{FG text} DisposeLayerInfo( @{FG shine}struct@{FG text} @{"Layer_Info" Link "include:graphics/layers.h/Main" 29} *);
  DisposeLayerInfo( @{i}li@{ui} )
                     a0
  @{i}li@{ui} - pointer to LayerInfo structure
NOTE
  If you wish to delete the layers associated with this Layer_Info structure,
  remember to call @{"DeleteLayer()" Link "DeleteLayer()"} for each of the layers before calling
  DisposeLayerInfo().
EXAMPLE
  -- delete the layers associated this Layer_Info structure --
  DeleteLayer(@{i}li@{ui},@{i}simple_layer@{ui});
  DeleteLayer(@{i}li@{ui},@{i}smart_layer@{ui});
  -- see documentation on @{"DeleteLayer" Link "DeleteLayer()"} about deleting SuperBitMap layers --
  @{i}my_super_bitmap_ptr@{ui} = super_layer->@{i}SuperBitMap@{ui};
  DeleteLayer(@{i}li@{ui},@{i}super_layer@{ui});
  -- now dispose of the Layer_Info structure itself --
  DisposeLayerInfo(@{i}li@{ui});
SEE ALSO
  @{"DeleteLayer" Link "DeleteLayer()"}, @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}
@EndNode
@Node "DoHookClipRects()" "layers.library/DoHookClipRects"
@{b}@{u}DoHookClipRects@{uu}@{ub} - Do the given hook for each of the ClipRects.(V39)
  This function will call the given hook for each cliprect in the layer that
  can be rendered into.This is how the backfill hook in Layers is implemented.
  This means that hidden simple-refresh cliprects will be ignored.It will call
  the SuperBitMap cliprects, smart refresh off-screen cliprects, and all on
  screen cliprects.If the rect parameter is not NULL, the cliprects are bounded
  to the rectangle given.
SYNOPSIS
  @{FG shine}void@{FG text} DoHookClipRects(@{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *,@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *,@{FG shine}struct@{FG text} @{"Rectangle" Link "include:graphics/gfx.h/Main" 27} *);
  DoHookClipRects(@{i}hook@{ui},@{i}rport@{ui},@{i}rect@{ui})
                   a0   a1    a2
  @{i}hook@{ui} - pointer to layer callback Hook which will be called with
    @{i}object@{ui} == (@{FG shine}struct@{FG text} RastPort *) result->@{i}RastPort@{ui} and
    @{i}message@{ui} == [ (Layer *) @{i}layer@{ui}, (@{FG shine}struct@{FG text} Rectangle) bounds,
      (@{FG shine}long@{FG text}) offsetx, (@{FG shine}long@{FG text}) offsety ]
    This hook should fill the Rectangle in the RastPort
    with the BackFill pattern appropriate for offset x/y.
    If hook is LAYERS_BACKFILL, the default backfill is used for the layer.
    If hook is LAYERS_NOBACKFILL, the layer will not be backfilled (NO-OP).
  @{i}rport@{ui} - A pointer to the RastPort that is to be operated on.
    This function will lock the layer if the RastPort is layered...
    If the rport is non-layered your hook will be called with
    the rectangle as passed, the RastPort, and a NULL layer...
  @{i}rect@{ui} - The bounding rectangle that should be used on the layer.
    This rectangle "clips" the cliprects to the bound given.If this is NULL, no
    bounding will take place.@{b}*MUST*@{ub} not be NULL if the RastPort is non-layered!
NOTES
  The RastPort you are passed back is the same one passed to the function.
  You should *not* use "layered" rendering functions on this RastPort.
  Generally, you will wish to do @{"BitMap" Link "include:graphics/gfx.h/Main" 46} operations such as @{"BltBitMap()" Link "graphics.guide/BltBitMap()"}.
  The callback is a raw, low-level rendering call-back.If you need to call a
  rendering operation with a RastPort, make sure you use a copy of the RastPort
  and NULL the @{"Layer" Link "include:graphics/clip.h/Main" 27} pointer.
SEE ALSO
  @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0} @{"utility/hooks.h" Link "include:utility/hooks.h/Main" 0}
@EndNode
@Node "EndUpdate()" "layers.library/EndUpdate"
@{b}@{u}EndUpdate@{uu}@{ub} -- remove damage list and restore state of layer to normal.
  After the programmer has redrawn his picture he calls this routine to
  restore the ClipRects to point to his standard layer tiling.
  The layer is then unlocked for access by the layer library.
SYNOPSIS  @{FG shine}void@{FG text} EndUpdate( @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *, UWORD);
  EndUpdate( @{i}l@{ui}, @{i}flag@{ui} )
              a0  d0
  @{i}l@{ui} - pointer to a layer
  @{i}flag@{ui} - use TRUE if update was completed.The damage list is cleared,
    use FALSE if update not complete.The damage list is retained.
NOTE
  Use flag = FALSE if you are only making a partial update.You may use the other
  region functions (graphics functions such as @{"OrRectRegion" Link "graphics.guide/OrRectRegion()"}, @{"AndRectRegion" Link "graphics.guide/AndRectRegion()"},
  and @{"XorRectRegion" Link "graphics.guide/XorRectRegion()"} ) to clip adjust the DamageList to reflect a partial update.
EXAMPLE
  -- begin update for first part of two-part refresh --
  BeginUpdate(@{i}my_layer@{ui});
  -- do some refresh, but not all --
  my_partial_refresh_routine(@{i}my_layer@{ui});
  -- end update, false (not completely done refreshing yet) --
  EndUpdate(@{i}my_layer@{ui}, FALSE);
  -- begin update for last part of refresh --
  BeginUpdate(@{i}my_layer@{ui});
  -- do rest of refresh --
  my_complete_refresh_routine(@{i}my_layer@{ui});
  -- end update, true (completely done refreshing now) --
  EndUpdate(@{i}my_layer@{ui}, TRUE);
SEE ALSO
  @{"BeginUpdate" Link "BeginUpdate()"}, @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}, @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0}
@EndNode
@Node "FattenLayerInfo()" "layers.library/FattenLayerInfo"
@{b}@{u}FattenLayerInfo@{uu}@{ub} -- convert 1.0 LayerInfo to 1.1 LayerInfo. @{b}OBSOLETE@{ub}
  V1.1 software and any later releases need to have more info in the
  Layer_Info structure.To do this in a 1.0 supportable manner requires
  allocation and deallocation of the memory whenever most layer library
  functions are called.To prevent unnecessary allocation/deallocation
  FattenLayerInfo will preallocate the necessary data structures and fake out
  the layer library into thinking it has a LayerInfo gotten from @{"NewLayerInfo" Link "NewLayerInfo()"}.
  NewLayerInfo is the approved method for getting this structure.When a program
  needs to give up the LayerInfo structure it must call @{"ThinLayerInfo" Link "ThinLayerInfo()"} before
  freeing the memory.@{"ThinLayerInfo" Link "ThinLayerInfo()"} is not necessary if
  @{"New/DisposeLayerInfo" Link "DisposeLayerInfo()"} are used however.
SYNOPSIS  @{FG shine}long@{FG text} FattenLayerInfo( @{FG shine}struct@{FG text} @{"Layer_Info" Link "include:graphics/layers.h/Main" 29} *);
  FattenLayerInfo( @{i}li@{ui} )
                    a0
  @{i}li@{ui} - pointer to LayerInfo structure
SEE ALSO
  @{"NewLayerInfo" Link "NewLayerInfo()"}, @{"ThinLayerInfo" Link "ThinLayerInfo()"}, @{"DisposeLayerInfo" Link "DisposeLayerInfo()"}, @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}
@EndNode
@Node "InitLayers()" "layers.library/InitLayers"
@{b}@{u}InitLayers@{uu}@{ub} -- Initialize Layer_Info structure @{b}OBSOLETE@{ub}
  Initialize Layer_Info structure in preparation to use
  other layer operations on this list of layers.
  Make the Layers unlocked (open), available to layer operations.
SYNOPSIS  @{FG shine}void@{FG text} InitLayers( @{FG shine}struct@{FG text} @{"Layer_Info" Link "include:graphics/layers.h/Main" 29} *);
  InitLayers( @{i}li@{ui} )
               a0
  @{i}li@{ui} - pointer to LayerInfo structure
SEE ALSO
  @{"NewLayerInfo" Link "NewLayerInfo()"}, @{"DisposeLayerInfo" Link "DisposeLayerInfo()"}, @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}
@EndNode

@Node "InstallClipRegion()" "layers.library/InstallClipRegion"
@{b}@{u}InstallClipRegion@{uu}@{ub} -- Install clip region in layer
  Installs a transparent Clip region in the layer.All subsequent graphics calls
  will be clipped to this region.You @{b}MUST@{ub} remember to call
  InstallClipRegion(l,NULL) before calling DeleteLayer(l) or the Intuition
  function @{"CloseWindow()" Link "intuition.guide/CloseWindow()"} if you have installed a non-NULL ClipRegion in l.
SYNOPSIS  @{FG shine}struct@{FG text} @{"Region" Link "include:graphics/regions.h/Main" 28} *InstallClipRegion( @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *, @{FG shine}struct@{FG text} Region *);
  @{i}@{b}oldclipregion@{ub}@{ui} = InstallClipRegion( @{i}l@{ui},  @{i}region@{ui} )
   d0                                 a0  a1
  @{i}l@{ui} - pointer to a layer
  @{i}region@{ui} - pointer to a region
  @{i}@{b}oldclipregion@{ub}@{ui} - The pointer to the previous ClipRegion that
    was installed.Returns NULL if no previous ClipRegion installed.
NOTE
  If the system runs out of memory while computing the resulting ClipRects
  the LAYERS_CLIPRECTS_LOST bit will be set in l->Flags.
BUGS
  If the system runs out of memory during normal layer operations,
  the @{"ClipRect" Link "include:graphics/clip.h/Main" 63} list may get swept away and not restored.
  As soon as there is enough memory and the layer library
  gets called again the ClipRect list will be rebuilt.
SEE ALSO
  @{"BeginUpdate" Link "BeginUpdate()"} @{"EndUpdate" Link "EndUpdate()"},
  @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}, @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0}, @{"graphics/regions.h" Link "include:graphics/regions.h/Main" 0}
@EndNode
@Node "InstallLayerHook()" "layers.library/InstallLayerHook"
@{b}@{u}InstallLayerHook@{uu}@{ub} -- safely install a new Layer->BackFill hook.(V36)
  Installs a new Layer->Backfill Hook, waiting until it is safe to do so.
  Locks the layer while substituting the new Hook and removing the old one.
  If a new Hook is not provided, will install the default layer BackFill Hook.
SYNOPSIS  @{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *InstallLayerHook( @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *, @{FG shine}struct@{FG text} Hook *);
  @{i}@{b}oldhook@{ub}@{ui} = InstallLayerHook(@{i}layer@{ui}, @{i}hook@{ui})
   d0                         a0     a1
  @{i}layer@{ui} - pointer to the layer in which to install the Backfill Hook.
  @{i}hook@{ui}  - pointer to layer callback Hook which will be called with
    @{i}object@{ui} == (@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *) result->RastPort and
    @{i}message@{ui} == [ (Layer *) @{i}layer@{ui}, (@{FG shine}struct@{FG text} Rectangle) bounds,
      (@{FG shine}long@{FG text}) offsetx, (@{FG shine}long@{FG text}) offsety ]
    This hook should fill the @{"Rectangle" Link "include:graphics/gfx.h/Main" 27} in the RastPort
    with the BackFill pattern appropriate for offset x/y.
    If hook is LAYERS_BACKFILL, the default backfill is used for the layer.
    (Same as pre-2.0) As of V39:
    If hook is LAYERS_NOBACKFILL, the layer will not be backfilled (NO-OP).
  @{i}@{b}oldhook@{ub}@{ui} - pointer to the Layer->BackFill Hook that was previously active.
    Returns NULL if it was the default hook.
    In V39, it could return 1 if there was no hook.
EXAMPLE
  The following hook is a very simple example that does rather little
  but gives the basis idea of what is going on.
  * This is the code called by the layer hook...
  * Note that some other setup is required for this to work, including
  * the definition of the PrivateData structure (pd_...) and the
  * definition of the BitMapPattern structure (bmp_...)
  CoolHook: xdef  CoolHook
      movem.l d2-d7/a3-a6,-(sp) ; Save these...
      move.l  h_SubEntry(a0),a4 ; (my private data #1 here)
      move.l  h_Data(a0),a5   ; Put data into address reg
  * Now, we do the rendering...
  * Note that the layer may not be important...But it is here...
      move.l  (a1)+,a0    ; Get the layer...
  * a1 now points at the rectangle...
      move.l  pd_GfxBase(a4),a6 ; Point at @{"GfxBase" Link "include:graphics/gfxbase.h/Main" 24}
      move.l  bmp_Pattern(a5),d0  ; Get PatternBitMap
      beq SimpleCase    ; None?  Simple (0) case
  * Now do the complex case of a pattern...
      move.l  a1,a3     ; Pointer to rectangle
      addq.l  #8,a1     ; Get past rectangle
      move.l  (a1)+,d2    ; X Offset (For pattern)
      move.l  (a1)+,d3    ; Y Offset
    ; Whatever complex blitting you would do in the complex case goes here
  * No bitmap, so just do the simple (0) minterm case...
  SimpleCase: moveq.l #0,d2     ; Clear d2
      move.w  ra_MinX(a1),d2    ; Get X pos
  *
      moveq.l #0,d3
      move.w  ra_MinY(a1),d3    ; Get Y pos
  *
      moveq.l #0,d4
      move.w  ra_MaxX(a1),d4
      sub.l d2,d4
      addq.l  #1,d4     ; Get X size
  *
      moveq.l #0,d5
      move.w  ra_MaxY(a1),d5
      sub.l d3,d5
      addq.l  #1,d5     ; Get Y size
  *
      move.l  d2,d0     ; X Source
      move.l  d3,d1     ; Y Source
      moveq.l #0,d6     ; NULL minterm
      moveq.l #-1,d7      ; FF mask
  *
      move.l  rp_BitMap(a2),a1  ; Get bitmap
      move.l  a1,a0
      CALLSYS BltBitMap    ; Do the backfill-0
  *
  HookDone: movem.l (sp)+,d2-d7/a3-a6 ; Restore
      rts
NOTES
  The RastPort you are passed back is the same one passed to the function.
  You should *not* use "layered" rendering functions on this RastPort.
  Generally, you will wish to do @{"BitMap" Link "include:graphics/gfx.h/Main" 46} operations such as @{"BltBitMap()" Link "graphics.guide/BltBitMap()"}.
  The callback is a raw, low-level rendering call-back.If you need to call a
  rendering operation with a RastPort, make sure you use a copy of the RastPort
  and NULL the @{"Layer" Link "include:graphics/clip.h/Main" 27} pointer.
SEE ALSO
  @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0} @{"utility/hooks.h" Link "include:utility/hooks.h/Main" 0}
@EndNode
@Node "InstallLayerInfoHook()" "layers.library/InstallLayerInfoHook"
@{b}@{u}InstallLayerInfoHook@{uu}@{ub} - Install a backfill hook for non-layer.(V39)
  This function will install a backfill hook for the Layer_Info structure passed.
  This backfill hook will be used to clear the background area where no layer
  exists.The hook function is passed the @{"RastPort" Link "include:graphics/rastport.h/Main" 54} and the bounds just like
  the layer backfill hook.Note that this hook could be called for any layer.
SYNOPSIS
  @{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *InstallLayerInfoHook(@{FG shine}struct@{FG text} @{"Layer_Info" Link "include:graphics/layers.h/Main" 29} *,@{FG shine}struct@{FG text} Hook *);
  @{i}@{b}oldhook@{ub}@{ui}=InstallLayerInfoHook(@{i}li@{ui},@{i}hook@{ui})
   d0                           a0 a1
  @{i}li@{ui} - pointer to LayerInfo structure
  @{i}hook@{ui} -  pointer to layer callback Hook which will be called with
    @{i}object@{ui} == (@{FG shine}struct@{FG text} RastPort *) result->RastPort and
    @{i}message@{ui} == [ (ULONG) undefined, (@{FG shine}struct@{FG text} Rectangle) bounds ]
    This hook should fill the @{"Rectangle" Link "include:graphics/gfx.h/Main" 27} in the RastPort
    with the BackFill pattern appropriate for rectangle given.
    If hook is LAYERS_BACKFILL, the default backfill is used.(Same as pre-2.0)
    If hook is LAYERS_NOBACKFILL, there will be no backfill.(NO-OP).
  @{i}@{b}oldhook@{ub}@{ui} - Returns the backfill hook that was in the Layer_Info.
    Returns LAYERS_BACKFILL if the default was installed.
    Returns LAYERS_NOBACKFILL if there was a NO-OP hook.
    Returns -1 if there was some failure.
EXAMPLE
  See the example in @{"InstallLayerHook" Link "InstallLayerHook()"}.Note that both the @{"Layer" Link "include:graphics/clip.h/Main" 27} pointer
  and the OffsetX/Y values are not available in the LayerInfo backfill hook.
NOTES
  When the hook is first installed, it is @{b}*NOT*@{ub} called.It is up
  to the application to know if it is safe to fill in the area.
  Since the hook will be called when a layer is deleted, the easiest
  way to have layers call this hook is to create and delete a backdrop
  layer that is the size of the area.
  Also, note that currently the first long word of the hook message
  contains an undefined value.This value may look like a layer pointer.
  It is *not* a layer pointer.
  The RastPort you are passed back is the same one passed to the
  function.You should *not* use "layered" rendering functions
  on this RastPort.Generally, you will wish to do @{"BitMap" Link "include:graphics/gfx.h/Main" 46} operations
  such as @{"BltBitMap()" Link "graphics.guide/BltBitMap()"}.The callback is a raw, low-level rendering
  call-back.If you need to call a rendering operation with a RastPort,
  make sure you use a copy of the RastPort and NULL the Layer pointer.
SEE ALSO
  @{"InstallLayerHook" Link "InstallLayerHook()"}
@EndNode
@Node "LockLayer()" "layers.library/LockLayer"
@{b}@{u}LockLayer@{uu}@{ub} -- Lock layer to make changes to ClipRects.
  Make this layer unavailable for other tasks to use.If another task is
  already using this layer then wait for it to complete and then reserve
  the layer for your own use.
  (this function does the same thing as graphics.library/LockLayerRom)
SYNOPSIS  @{FG shine}void@{FG text} LockLayer( @{FG shine}long@{FG text}, @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *);
  LockLayer( @{i}dummy@{ui}, @{i}l@{ui} )
              a0     a1
  @{i}dummy@{ui} - unused
  @{i}l@{ui} - pointer to a layer
NOTES
  If you wish to lock MORE THAN ONE layer at a time, you must call
  @{"LockLayerInfo()" Link "LockLayerInfo()"} before locking those layers and then call @{"UnlockLayerInfo()" Link "UnlockLayerInfo()"}
  when you have finished.This is to prevent system "deadlocks".
  While you hold the lock on a layer, Intuition will block on operations such as
  windowsizing, dragging, menus, and depth arranging windows in this layer's
  screen.It is recommended that YOU do not make Intuition function calls
  while the layer is locked.
SEE ALSO
  @{"UnlockLayer" Link "UnlockLayer()"}, @{"LockLayerInfo" Link "LockLayerInfo()"}, @{"UnlockLayerInfo" Link "UnlockLayerInfo()"},
  @{"graphics.library/LockLayerRom" Link "graphics.guide/LockLayerRom()"}, @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}, @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0}
@EndNode

@Node "LockLayerInfo()" "layers.library/LockLayerInfo"
@{b}@{u}LockLayerInfo@{uu}@{ub} -- Lock the LayerInfo structure.
  Before doing an operation that requires the LayerInfo structure,
  make sure that no other task is also using the LayerInfo structure.
  LockLayerInfo() returns when the LayerInfo belongs to this task.
  There should be an @{"UnlockLayerInfo" Link "UnlockLayerInfo()"} for every LockLayerInfo.
SYNOPSIS  @{FG shine}void@{FG text} LockLayerInfo( @{FG shine}struct@{FG text} @{"Layer_Info" Link "include:graphics/layers.h/Main" 29} *);
  LockLayerInfo( @{i}li@{ui} )
                  a0
  @{i}li@{ui} - pointer to Layer_Info structure
NOTE
  All layer routines presently LockLayerInfo() when they start up and
  @{"UnlockLayerInfo()" Link "UnlockLayerInfo()"} as they exit.Programmers will need to use these
  Lock/Unlock routines if they wish to do something with the LayerStructure
  that is not supported by the layer library.
SEE ALSO
  @{"UnlockLayerInfo" Link "UnlockLayerInfo()"}, @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}
@EndNode
@Node "LockLayers()" "layers.library/LockLayers"
@{b}@{u}LockLayers@{uu}@{ub} -- lock all layers from graphics output.
  First calls @{"LockLayerInfo()" Link "LockLayerInfo()"}.Make all layers in this layer list locked.
SYNOPSIS  @{FG shine}void@{FG text} LockLayers( @{FG shine}struct@{FG text} @{"Layer_Info" Link "include:graphics/layers.h/Main" 29} *);
  LockLayers( @{i}li@{ui} )
               a0
  @{i}li@{ui} - pointer to Layer_Info structure
SEE ALSO
  @{"LockLayer" Link "LockLayer()"}, @{"LockLayerInfo" Link "LockLayerInfo()"}, @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}
@EndNode
@Node "MoveLayer()" "layers.library/MoveLayer"
@{b}@{u}MoveLayer@{uu}@{ub} -- Move layer to new position in @{"BitMap" Link "include:graphics/gfx.h/Main" 46}.
  Move this layer to new position in shared BitMap.If any refresh layers
  become revealed, collect damage and set REFRESH bit in layer Flags.
SYNOPSIS  @{FG shine}long@{FG text} MoveLayer( @{FG shine}long@{FG text}, @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *, @{FG shine}long@{FG text}, @{FG shine}long@{FG text});
  @{i}@{b}result@{ub}@{ui} = MoveLayer( @{i}dummy@{ui}, @{i}l@{ui}, @{i}dx@{ui}, @{i}dy@{ui} )
   d0                  a0     a1  d0  d1
  @{i}dummy@{ui} - unused
  @{i}l@{ui} - pointer to a nonbackdrop layer
  @{i}dx@{ui} - delta to add to current x position
  @{i}dy@{ui} - delta to add to current y position
  @{i}@{b}result@{ub}@{ui} - TRUE if operation successful, FALSE if failed (out of memory)
BUGS
  May not handle (dx,dy) which attempts to move the layer outside the
  layer's RastPort->BitMap bounds .
SEE ALSO
  @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}, @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0}
@EndNode
@Node "MoveLayerInFrontOf()" "layers.library/MoveLayerInFrontOf"
@{b}@{u}MoveLayerInFrontOf@{uu}@{ub} -- Put layer in front of another layer.
  Move this layer in front of target layer, swapping bits in and out of the
  display with other layers.If this is a refresh layer then collect damage
  list and set the LAYERREFRESH bit in layer->Flags if redraw required.
SYNOPSIS  @{FG shine}long@{FG text} MoveLayerInFrontOf( @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *, @{FG shine}struct@{FG text} Layer *);
  @{i}@{b}result@{ub}@{ui} = MoveLayerInFrontOf( @{i}layertomove@{ui}, @{i}targetlayer@{ui} )
                                a0           a1
  @{i}layertomove@{ui} - pointer to layer which should be moved
  @{i}targetlayer@{ui} - pointer to target layer in front of which to move layer
  @{i}@{b}result@{ub}@{ui} = TRUE if operation successful,FALSE if failed (probably out of memory)
NOTE
  This operation may generate refresh events in other layers associated with
  this layer's @{"Layer_Info" Link "include:graphics/layers.h/Main" 29} structure.
SEE ALSO
  @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}
@EndNode
@Node "MoveSizeLayer()" "layers.library/MoveSizeLayer"
@{b}@{u}MoveSizeLayer@{uu}@{ub} -- Position/Size layer
  Change upperleft and lower right position of Layer.
SYNOPSIS  @{FG shine}long@{FG text} MoveSizeLayer( @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text});
  @{i}@{b}result@{ub}@{ui} = MoveSizeLayer( @{i}layer@{ui}, @{i}dx@{ui}, @{i}dy@{ui}, @{i}dw@{ui}, @{i}dh@{ui} )
   d0                      a0     d0   d1  d2  d3
  @{i}dummy@{ui} - unused
  @{i}l@{ui} - pointer to a nonbackdrop layer
  @{i}dx@{ui},@{i}dy@{ui} - change upper left corner by (dx,dy)
  @{i}dw@{ui},@{i}dy@{ui} - change size by (dw,dh)
  @{i}@{b}result@{ub}@{ui} - TRUE if operation successful,
    FALSE if failed (due to out of memory),
    FALSE if failed (due to illegal layer->bounds)
SEE ALSO
  @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}, @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0}
@EndNode
@Node "NewLayerInfo()" "layers.library/NewLayerInfo"
@{b}@{u}NewLayerInfo@{uu}@{ub} -- Allocate and Initialize full Layer_Info structure.
  Allocate memory required for full Layer_Info structure.
  Initialize Layer_Info structure in preparation to use other layer operations
  on this list of layers.Make the Layer_Info unlocked (open).
SYNOPSIS  @{FG shine}struct@{FG text} @{"Layer_Info" Link "include:graphics/layers.h/Main" 29} *NewLayerInfo( @{FG shine}void@{FG text} );
  @{i}@{b}result@{ub}@{ui} = NewLayerInfo()
   d0
  @{i}@{b}result@{ub}@{ui}- pointer to Layer_Info structure if successful,
    NULL if not enough memory.
SEE ALSO
  @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}
@EndNode
@Node "ScrollLayer()" "layers.library/ScrollLayer"
@{b}@{u}ScrollLayer@{uu}@{ub} -- Scroll around in a superbitmap, translate coordinates
  in non-superbitmap layer.
  @{i}For a SuperBitMap Layer:@{ui}
  Update the SuperBitMap from the layer display, then copy bits between Layer
  and SuperBitMap to reposition layer over different portion of SuperBitMap.
  For nonSuperBitMap layers, all (x,y) pairs are adjusted by the scroll(x,y)
  value in the layer.To cause (0,0) to actually be drawn at (3,10) use
  ScrollLayer(-3,-10).This can be useful along with @{"InstallClipRegion" Link "InstallClipRegion()"}
  to simulate Intuition GZZWindows without the overhead of an extra layer.
SYNOPSIS  @{FG shine}void@{FG text} ScrollLayer( @{FG shine}long@{FG text}, @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *, @{FG shine}long@{FG text}, @{FG shine}long@{FG text});
  ScrollLayer( @{i}dummy@{ui}, @{i}l@{ui}, @{i}dx@{ui}, @{i}dy@{ui} )
               a0     a1  d0  d1
  @{i}dummy@{ui} - unused
  @{i}l@{ui} - pointer to a layer
  @{i}dx@{ui} - delta to add to current x scroll value
  @{i}dy@{ui} - delta to add to current y scroll value
BUGS
  May not handle (dx,dy) which attempts to move the layer outside the
  layer's SuperBitMap bounds.
SEE ALSO
  @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}
@EndNode
@Node "SizeLayer()" "layers.library/SizeLayer"
@{b}@{u}SizeLayer@{uu}@{ub} -- Change the size of this nonbackdrop layer.
  Change the size of this layer by (dx,dy).The lower right hand corner is
  extended to make room for the larger layer.If there is SuperBitMap for
  this layer then copy pixels into or out of the layer depending on whether
  the layer increases or decreases in size.Collect damage list for those
  layers that may need to be refreshed if damage occurred.
SYNOPSIS  @{FG shine}long@{FG text} SizeLayer( @{FG shine}long@{FG text}, @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *, @{FG shine}long@{FG text}, @{FG shine}long@{FG text});
  @{i}@{b}result@{ub}@{ui} = SizeLayer( @{i}dummy@{ui}, @{i}l@{ui}, @{i}dx@{ui}, @{i}dy@{ui} )
   d0                  a0     a1  d0  d1
  @{i}dummy@{ui} - unused
  @{i}l@{ui} - pointer to a nonbackdrop layer
  @{i}dx@{ui} - delta to add to current x size
  @{i}dy@{ui} - delta to add to current y size
  @{i}@{b}result@{ub}@{ui} - TRUE if operation successful, FALSE if failed (out of memory)
SEE ALSO
  @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}, @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0}
@EndNode
@Node "SwapBitsRastPortClipRect()" "layers.library/SwapBitsRastPortClipRect"
@{b}@{u}SwapBitsRastPortClipRect@{uu}@{ub} - Swap bits between common bitmap and obscured ClipRect.
  Support routine useful for those that need to do some operations not done
  by the layer library.Allows programmer to swap the contents of a small
  @{"BitMap" Link "include:graphics/gfx.h/Main" 46} with a subsection of the display.This is accomplished
  without using extra memory.The bits in the display RastPort are exchanged with
  the bits in the ClipRect's BitMap.
SYNOPSIS  @{FG shine}void@{FG text} SwapBitsRastPortClipRect( @{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, @{FG shine}struct@{FG text} @{"ClipRect" Link "include:graphics/clip.h/Main" 63} *);
  SwapBitsRastPortClipRect( @{i}rp@{ui}, @{i}cr@{ui} )
                             a0  a1
  @{i}rp@{ui} - pointer to rastport
  @{i}cr@{ui} - pointer to cliprect to swap bits with
NOTES
  The ClipRect structures which the layer library allocates are actually
  a little bigger than those described in the @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0} include file.
  So be warned that it is not a good idea to have instances of cliprects
  in your code.
  Because the blit operation started by this function is done asynchronously,
  it is imperative that a @{"WaitBlit()" Link "graphics.guide/WaitBlit()"} be performed before releasing or using
  the processor to modify any of the associated structures.
SEE ALSO
  @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0}, @{"graphics/rastport.h" Link "include:graphics/rastport.h/Main" 0}, @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0}
@EndNode
@Node "ThinLayerInfo()" "layers.library/ThinLayerInfo"
@{b}@{u}ThinLayerInfo@{uu}@{ub} -- convert 1.1 LayerInfo to 1.0 LayerInfo.@{b}OBSOLETE@{ub}
  Return the extra memory needed that was allocated with @{"FattenLayerInfo" Link "FattenLayerInfo()"}.
  This is must be done prior to freeing the Layer_Info structure itself.
  V1.1 software should be using @{"DisposeLayerInfo" Link "DisposeLayerInfo()"}.
SYNOPSIS  @{FG shine}void@{FG text} ThinLayerInfo( @{FG shine}struct@{FG text} @{"Layer_Info" Link "include:graphics/layers.h/Main" 29} *);
  ThinLayerInfo( @{i}li@{ui} )
                  a0
  @{i}li@{ui} - pointer to LayerInfo structure
SEE ALSO
  @{"DisposeLayerInfo" Link "DisposeLayerInfo()"}, @{"FattenLayerInfo" Link "FattenLayerInfo()"}, @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}
@EndNode
@Node "UnlockLayer()" "layers.library/UnlockLayer"
@{b}@{u}UnlockLayer@{uu}@{ub} -- Unlock layer and allow graphics routines to use it.
  When finished changing the ClipRects or whatever you were
  doing with this layer you must call UnlockLayer() to allow
  other tasks to proceed with graphic output to the layer.
SYNOPSIS  @{FG shine}void@{FG text} UnlockLayer( @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *);
  UnlockLayer( @{i}l@{ui} )
                a0
  @{i}l@{ui} - pointer to a layer
SEE ALSO
  @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}, @{"graphics/clip.h" Link "include:graphics/clip.h/Main" 0}
@EndNode
@Node "UnlockLayerInfo()" "layers.library/UnlockLayerInfo"
@{b}@{u}UnlockLayerInfo@{uu}@{ub} -- Unlock the LayerInfo structure.
  After the operation is complete that required a @{"LockLayerInfo" Link "LockLayerInfo()"},
  unlock the LayerInfo structure so that  other tasks may affect the layers.
SYNOPSIS  @{FG shine}void@{FG text} UnlockLayerInfo( @{FG shine}struct@{FG text} @{"Layer_Info" Link "include:graphics/layers.h/Main" 29} *);
  UnlockLayerInfo( @{i}li@{ui} )
                    a0
  @{i}li@{ui} - pointer to the Layer_Info structure
SEE ALSO
  @{"LockLayerInfo" Link "LockLayerInfo()"}, @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}
@EndNode
@Node "UnlockLayers()" "layers.library/UnlockLayers"
@{b}@{u}UnlockLayers@{uu}@{ub} -- Unlock all layers from graphics output.
  Restart graphics output to layers that have been waiting
  Make all layers in this layer list unlocked.
  Then call @{"UnlockLayerInfo" Link "UnlockLayerInfo()"}
SYNOPSIS  @{FG shine}void@{FG text} UnlockLayers( @{FG shine}struct@{FG text} @{"Layer_Info" Link "include:graphics/layers.h/Main" 29} *);
  UnlockLayers( @{i}li@{ui} )
                 a0
  @{i}li@{ui} - pointer to the Layer_Info 33} structure
SEE ALSO
  @{"LockLayers" Link "LockLayers()"}, @{"UnlockLayer" Link "UnlockLayer()"}, @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}
@EndNode
@Node "UpfrontLayer()" "layers.library/UpfrontLayer"
@{b}@{u}UpfrontLayer@{uu}@{ub} -- Put layer in front of all other layers.
  Move this layer to the most upfront position swapping bits in and out of the
  display with other layers.If this is a refresh layer then collect damage list
  and set the LAYERREFRESH bit in layer->Flags if redraw required.By clearing
  the BACKDROP bit in the layers Flags you may bring a Backdrop layer up to
  the front of all other layers.
SYNOPSIS  @{FG shine}long@{FG text} UpfrontLayer( @{FG shine}long@{FG text}, @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *);
  @{i}@{b}result@{ub}@{ui} = UpfrontLayer( @{i}dummy@{ui}, @{i}l@{ui} )
   d0                     a0     a1
  @{i}dummy@{ui} - unused
  @{i}l@{ui} - pointer to a nonbackdrop layer
  @{i}@{b}result@{ub}@{ui} - TRUE if operation successful,FALSE if failed (probably out of memory)
NOTE
  This operation may generate refresh events in other layers
  associated with this layer's @{"Layer_Info" Link "include:graphics/layers.h/Main" 29} structure.
SEE ALSO
  @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}
@EndNode
@Node "WhichLayer()" "layers.library/WhichLayer"
@{b}@{u}WhichLayer@{uu}@{ub} -- Which Layer is this point in?
  Starting at the topmost layer check to see if this point (x,y)
  occurs in this layer.If it does return the pointer to this
  layer.Return NULL if there is no layer at this point.
SYNOPSIS  @{FG shine}struct@{FG text} @{"Layer" Link "include:graphics/clip.h/Main" 27} *WhichLayer(@{FG shine}struct@{FG text} Layer_Info*, WORD, WORD);
  @{i}@{b}layer@{ub}@{ui} = WhichLayer( @{i}li@{ui}, @{i}x@{ui}, @{i}y@{ui} )
   d0                  a0  d0 d1
  @{i}li@{ui}  = pointer to LayerInfo structure
  (@{i}x@{ui},@{i}y@{ui}) = coordinate in the @{"BitMap" Link "include:graphics/gfx.h/Main" 46}
  @{i}@{b}layer@{ub}@{ui} - pointer to the topmost layer that this point is in,
    NULL if this point is not in a layer.
SEE ALSO
  @{"graphics/layers.h" Link "include:graphics/layers.h/Main" 0}
@EndNode

@Node "AddNamedObject()" "utility.library/AddNamedObject"
@{b}@{u}AddNamedObject@{uu}@{ub} -- add a named object to the given namespace.(V39)
  Adds a new item to a NameSpace.If the NameSpace doesn't support duplicate
  names, a search for a duplicate will be made, and 0 (failure) will be returned.
  Otherwise, the entry will be Enqueue()ed to the NameSpace.
SYNOPSIS  BOOL AddNamedObject(@{FG shine}struct@{FG text} NamedObject *, @{FG shine}struct@{FG text} NamedObject *);
  @{i}@{b}success@{ub}@{ui} = AddNamedObject(@{i}nameSpace@{ui}, @{i}object@{ui});
   D0                        A0         A1
  @{i}nameSpace@{ui} - the name space to add to (NULL for root namespace)
  @{i}object@{ui} - the object to add  (If NULL, will return failure)
  @{i}@{b}success@{ub}@{ui} - whether the operation succeeded.Check this always!
SEE ALSO
  @{"AttemptRemNamedObject()" Link "AttemptRemNamedObject()"}, @{"RemNamedObject()" Link "RemNamedObject()"}
@EndNode
@Node "AllocateTagItems()" "utility.library/AllocateTagItems"
@{b}@{u}AllocateTagItems@{uu}@{ub} -- allocate a tag list.(V36)
  Allocates the specified number of usable TagItems slots.
  Note that to access the TagItems in 'tagList', you should use
  the function @{"NextTagItem()" Link "NextTagItem()"}.This will insure you respect any
  chaining (TAG_MORE) and secret hiding places (TAG_IGNORE) that
  this function might generate.
SYNOPSIS  @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *AllocateTagItems(ULONG);
  @{i}@{b}tagList@{ub}@{ui} = AllocateTagItems(@{i}numTags@{ui});
   D0                         D0
  @{i}numTags@{ui} - the number of TagItem slots you want to allocate.
  @{i}@{b}tagList@{ub}@{ui} - the allocated chain of TagItem structures, or NULL if there was
    not enough memory.An allocated tag list must eventually be freed using
    @{"FreeTagItems()" Link "FreeTagItems()"}.
SEE ALSO
  @{"<utility/tagitem.h>" Link "include:utility/tagitem.h/Main" 0}, @{"FreeTagItems()" Link "FreeTagItems()"}, @{"CloneTagItems()" Link "CloneTagItems()"}
@EndNode
@Node "AllocNamedObjectA()" "utility.library/AllocNamedObjectA"
@{b}@{u}AllocNamedObjectA@{uu}@{ub} -- allocate a named object.(V39)
  Allocates a NamedObject and initializes it as needed to the
  name given.This object can then be used as an object in the
  namespaces.Tags can be given to make an object contain a
  namespace such that nested namespaces can be built.
  When the object is allocated, it automatically has one use.
  If you later wish to release this object such that others may
  remove it from the namespace you must do a @{"ReleaseNamedObject()" Link "ReleaseNamedObject()"}.
SYNOPSIS
  @{FG shine}struct@{FG text} NamedObject *AllocNamedObjectA(STRPTR, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  @{FG shine}struct@{FG text} NamedObject *AllocNamedObject (STRPTR, ULONG, ...);
  @{i}@{b}object@{ub}@{ui} = AllocNamedObjectA(@{i}name@{ui}, @{i}tagList@{ui});
   D0                         A0     A1
  @{i}@{b}object@{ub}@{ui} = AllocNamedObject (@{i}name@{ui}, Tag1, ...);
  @{i}name@{ui} - name for the object (must not be NULL)
  @{i}tagList@{ui} - tags with additional information for the allocation or NULL
  @{i}@{b}object@{ub}@{ui} - the object allocated, or NULL for failure.
    The object is defined as a pointer to a pointer.
    You can do what you wish with the pointer.(It may be NULL or contain
    a pointer to memory that you had asked for in the tags.)
@{"TAGS" link ALLOCNAMEDOBJECTA_TAGS}
SEE ALSO
  @{"FreeNamedObject()" Link "FreeNamedObject()"}, <utility/name.h>
@EndNode
@node ALLOCNAMEDOBJECTA_TAGS "AllocNamedObjectA_tags"
@{i}ANO_UserSpace@{ui} - ULONG tag, default 0.If this tag is non-NULL it defines
  the size (in bytes) of the user space to be allocated with the named
  object and that will be pointed to by the no_Object pointer.This memory
  is long-word aligned.If no space is defined, no_Object will be NULL.
@{i}ANO_NameSpace@{ui} - BOOL tag, default FALSE.If this tag is TRUE,
 the named object will also have a name space attached to it.
@{i}ANO_Priority@{ui}  - BYTE tag, default 0.This tag lets you pick a priority
  for the named object for when it is placed into a name space.
@{i}ANO_Flags@{ui}     - ULONG tag, default 0.This tag lets you set the flags
  of the NameSpace (if you allocated one)  There currently are only TWO flags.
  @{i}Do *@{b}NOT@{ub}* set *any* other bits as they are for future use!!!@{ui}
  (You can't read them anyway) The flags are:
    NSF_NODUPS  - Name space must be unique.
    NSF_CASE  - Name space is case sensitive
@endnode
@Node "Amiga2Date()" "utility.library/Amiga2Date"
@{b}@{u}Amiga2Date@{uu}@{ub} -- fill in a ClockData structure based on a system time stamp (V36)
  Fills in a ClockData structure with the date and time calculated
  from a ULONG containing the number of seconds from 01-Jan-1978 to the date.
SYNOPSIS  @{FG shine}void@{FG text} Amiga2Date(ULONG,@{FG shine}struct@{FG text} @{"ClockData" Link "include:utility/date.h/Main" 18} *);
  Amiga2Date(@{i}seconds@{ui},@{i}result@{ui});
              D0      A0
  @{i}seconds@{ui} - the number of seconds from 01-Jan-1978.
  @{i}result@{ui} - a pointer to a ClockData structure that will be altered
    by this function
SEE ALSO
  @{"CheckDate()" Link "CheckDate()"}, @{"Date2Amiga()" Link "Date2Amiga()"}
@EndNode
@Node "ApplyTagChanges()" "utility.library/ApplyTagChanges"
@{b}@{u}ApplyTagChanges@{uu}@{ub} -- change a tag list based on a second tag list.(V39)
  For any tag that appears in both 'list' and 'changeList', this
  function will change the ti_Data field of the tag in 'list' to
  match the ti_Data field of the tag in 'changeList'.In effect,
  'changeList' contains a series of new values for tags already in
  'list'.Any tag in 'changeList' that is not in 'list' is ignored.
SYNOPSIS  @{FG shine}void@{FG text} ApplyTagChanges(@{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *, @{FG shine}struct@{FG text} TagItem *);
  ApplyTagChanges(@{i}list@{ui},@{i}changeList@{ui});
                   A0   A1
  @{i}list@{ui} - a list of existing tags (may be NULL)
  @{i}changeList@{ui} - a list of tags to modify 'list' with (may be NULL)
SEE ALSO
  @{"<utility/tagitem.h>" Link "include:utility/tagitem.h/Main" 0}, @{"FilterTagChanges()" Link "FilterTagChanges()"}
@EndNode
@Node "AttemptRemNamedObject()" "utility.library/AttemptRemNamedObject"
@{b}@{u}AttemptRemNamedObject@{uu}@{ub} -- attempt to remove a named object.(V39)
  Attempts to remove an object from whatever NameSpace it's in.
  You must have found the object first (in order to get a use count)
  before trying to remove it.If the object is in use or is
  in the process of being removed, this function will return
  a failure code.If the object is fully removed, the object will
  then be available to be @{"FreeNamedObject()" Link "FreeNamedObject()"}.
SYNOPSIS  @{FG shine}long@{FG text} AttemptRemNamedObject(@{FG shine}struct@{FG text} NamedObject *);
  @{i}@{b}result@{ub}@{ui} = AttemptRemNamedObject(@{i}object@{ui});
   D0                             A0
  @{i}object@{ui} - the object to attempt to remove  The object must be valid
  @{i}@{b}success@{ub}@{ui}@{i}@{b}@{ub}@{ui} - FALSE if object is still in use (somewhere),
    TRUE if object was removed
SEE ALSO
  @{"RemNamedObject()" Link "RemNamedObject()"}, @{"AddNamedObject()" Link "AddNamedObject()"}, @{"ReleaseNamedObject()" Link "ReleaseNamedObject()"}
@EndNode
@Node "CallHookPkt()" "utility.library/CallHookPkt"
@{b}@{u}CallHookPkt@{uu}@{ub} -- invoke a Hook function callback.(V36)
  Performs the callback standard defined by a Hook structure.This function
  is really very simple; it effectively performs a JMP to Hook->h_Entry.
  It is probably just as well to do this operation in an assembly language
  function linked in to your program, possibly from a compiler supplied
  library or a builtin function.
  It is anticipated that C programs will often call a 'varargs' variant
  of this function which will be named @{"CallHook" Link "amiga_lib/CallHook()"}.This function must be
  provided in a compiler specific library, but an example of use would be:
  @{i}@{b}result@{ub}@{ui} = CallHook(@{i}hook@{ui},@{i}dataobject@{ui},COMMAND_ID,@{i}param1@{ui},@{i}param2@{ui});
  The function CallHook() can be implemented in many C compilers like this:
  ULONG CallHook(@{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *@{i}hook@{ui}, APTR @{i}object@{ui}, ULONG command, ...)
  {
      @{FG shine}return@{FG text}(CallHookPkt(@{i}hook@{ui},@{i}object@{ui},(APTR)@{i}&command@{ui}));
  }
SYNOPSIS  ULONG CallHookPkt(@{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *,APTR,APTR);
  @{i}@{b}return@{ub}@{ui} = CallHookPkt(@{i}hook@{ui},@{i}object@{ui},@{i}message@{ui});
   D0                   A0    A2     A1
  @{i}hook@{ui} - pointer to an initialized Hook structure as defined in
    @{"<utility/hooks.h>" Link "include:utility/hooks.h/Main" 0}
  @{i}object@{ui} - useful data structure in the particular context the hook is
    being used for.
  @{i}message@{ui} - pointer to a message to be passed to the hook.This is not
    an Exec @{"Message" Link "include:exec/ports.h/Main" 48} structure, but is a message in the OOP sense.
  @{i}@{b}return@{ub}@{ui} - the value returned by the hook function.
@{b}WARNING@{ub}
  The functions called through this function should follow normal
  register conventions unless @{b}EXPLICITLY@{ub} documented otherwise (and
  they have a good reason too).
SEE ALSO
  @{"<utility/hooks.h>" Link "include:utility/hooks.h/Main" 0}
@EndNode
@Node "CheckDate()" "utility.library/CheckDate"
@{b}@{u}CheckDate@{uu}@{ub} -- checks a ClockData structure for legal date.(V36)
  Determines if the ClockData structure contains legal date information
  and returns the number of seconds from 01-Jan-1978 to that date, or 0
  if the ClockData structure contains illegal data.
SYNOPSIS  ULONG CheckDate(@{FG shine}struct@{FG text} @{"ClockData" Link "include:utility/date.h/Main" 18} *);
  @{i}@{b}seconds@{ub}@{ui} = CheckDate(@{i}date@{ui});
   D0                  A0
  @{i}date@{ui} - a filled-in ClockData 18} structure
  @{i}@{b}seconds@{ub}@{ui} - 0 if date is invalid, otherwise the number of seconds from
    01-Jan-1978 to the date
BUGS
  The wday field of the ClockData structure is not checked.
SEE ALSO
  @{"Amiga2Date()" Link "Amiga2Date()"}, @{"Date2Amiga()" Link "Date2Amiga()"}
@EndNode
@Node "CloneTagItems()" "utility.library/CloneTagItems"
@{b}@{u}CloneTagItems@{uu}@{ub} - copy a tag list.(V36)
  Copies the essential contents of a tag list into a new tag list.
  The cloning is such that calling @{"FindTagItem()" Link "FindTagItem()"} with a given tag on
  the original or cloned tag lists will always return the same
  tag value.That is, the ordering of the tags is maintained.
SYNOPSIS  @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *CloneTagItems(@{FG shine}struct@{FG text} TagItem *);
  @{i}@{b}clone@{ub}@{ui} = CloneTagItems(@{i}original@{ui});
   D0                    A0
  @{i}original@{ui} - tag list to clone.
    May be NULL, in which case an empty tag list is returned.
  @{i}@{b}clone@{ub}@{ui} - copy of the original tag list, or NULL if there was not enough memory.
    This tag list must eventually by freed by calling @{"FreeTagItems()" Link "FreeTagItems()"}.
SEE ALSO
  @{"<utility/tagitem.h>" Link "include:utility/tagitem.h/Main" 0}, @{"AllocateTagItems()" Link "AllocateTagItems()"}, @{"FreeTagItems()" Link "FreeTagItems()"},
  @{"RefreshTagItemClones()" Link "RefreshTagItemClones()"}
@EndNode
@Node "Date2Amiga()" "utility.library/Date2Amiga"
@{b}@{u}Date2Amiga@{uu}@{ub} -- calculate seconds from 01-Jan-1978.(V36)
  Calculates the number of seconds from 01-Jan-1978 to the date
  specified in the ClockData structure.
SYNOPSIS  ULONG Date2Amiga(@{FG shine}struct@{FG text} @{"ClockData" Link "include:utility/date.h/Main" 18} *);
  @{i}@{b}seconds@{ub}@{ui} = Date2Amiga(@{i}date@{ui});
   D0                   A0
  @{i}date@{ui} - pointer to a ClockData structure containing the date of interest.
  @{i}@{b}seconds@{ub}@{ui} - the number of seconds from 01-Jan-1978 to the date specified.
@{b}WARNING@{ub}
  This function does no sanity checking of the data in the ClockData structure.
SEE ALSO
  @{"Amiga2Date()" Link "Amiga2Date()"}, @{"CheckDate()" Link "CheckDate()"}
@EndNode
@Node "FilterTagChanges()" "utility.library/FilterTagChanges"
@{b}@{u}FilterTagChanges@{uu}@{ub} -- eliminate tags which specify no change.(V36)
  This function goes through changeList.For each item found in changeList,
  if the item is also present in originalList, and their data values are
  identical, then the tag is removed from changeList. If the two tag's data
  values are different and the 'apply' value is non-zero, then the tag data
  in originalList will be updated to match the value from changeList.
SYNOPSIS  @{FG shine}void@{FG text} FilterTagChanges(@{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *, @{FG shine}struct@{FG text} TagItem *, ULONG);
  FilterTagChanges(@{i}changeList@{ui},@{i}originalList@{ui},@{i}apply@{ui});
                    A0         A1            D0
  @{i}changeList@{ui} - list of new tags (may be NULL)
  @{i}originalList@{ui} - a list of existing tags (may be NULL)
  @{i}apply@{ui} - boolean specification as to whether the data values in
    originalList are to be updated to the data values in changeList.
EXAMPLE
  Assume you have an attribute list for an object (originalList)
  which looks like this:
    {@{i}ATTR_Size@{ui},  "large"},
    {@{i}ATTR_Color@{ui}, "orange"},
    {@{i}ATTR_Shape@{ui}, "square"}
  If you receive a new tag list containing some changes (changeList),
  which looks like this:
    {@{i}ATTR_Size@{ui},  "large"},
    {@{i}ATTR_Shape@{ui}, "triangle"}
  If you call FilterTagChanges(), changeList will be modified to contain
  only those attributes which are different from those in originalList.
  All other items will have their tag values set to TAG_IGNORE.
  The resulting changeList will become:
    {@{i}TAG_IGNORE@{ui}, "large"},
    {@{i}ATTR_Shape@{ui}, "triangle"}
  If 'apply' was set to 0, originalList would be unchanged.
  If 'apply' was non-zero, originalList would be changed to:
    {@{i}ATTR_Size@{ui},  "large"},
    {@{i}ATTR_Color@{ui}, "orange"},
    {@{i}ATTR_Shape@{ui}, "triangle"}
SEE ALSO
  @{"<utility/tagitem.h>" Link "include:utility/tagitem.h/Main" 0}, @{"ApplyTagChanges()" Link "ApplyTagChanges()"}
@EndNode
@Node "FilterTagItems()" "utility.library/FilterTagItems"
@{b}@{u}FilterTagItems@{uu}@{ub} -- remove selected items from a tag list.(V36)
  Removes tag items from a tag list (by changing ti_Tag to TAG_IGNORE) depending
  on whether its ti_Tag value is found in an array of tag values.If the 'logic'
  parameter is TAGFILTER_AND, then all items not appearing in 'tagArray' are
  excluded from 'tagList'.If 'logic' is TAGFILTER_NOT, then items not found in
  'tagArray' are preserved, and the ones in the array are cast out.
SYNOPSIS  ULONG FilterTagItems(@{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *,@{i}Tag@{ui} *,ULONG);
  @{i}@{b}numValid@{ub}@{ui} = FilterTagItems(@{i}tagList@{ui},@{i}filterArray@{ui},@{i}logic@{ui});
   D0                         A0      A1          D0
  @{i}tagList@{ui} - input list of tag items which is to be filtered by having
    selected items changed to TAG_IGNORE.
  @{i}filterArray@{ui} - an array of tag values, terminated by TAG_DONE, as
    specified in the documentation for @{"TagInArray()" Link "TagInArray()"}.
  @{i}logic@{ui} - specification whether items in 'tagArray' are to be included
    or excluded in the filtered result.
  @{i}@{b}numValid@{ub}@{ui} - number of valid items left in resulting filtered list.
SEE ALSO
  @{"<utility/tagitem.h>" Link "include:utility/tagitem.h/Main" 0}, @{"TagInArray()" Link "TagInArray()"}
@EndNode
@Node "FindNamedObject()" "utility.library/FindNamedObject"
@{b}@{u}FindNamedObject@{uu}@{ub} -- find the next object of a given name.(V39)
  Finds an object and adds to the open count of the object.The object is
  guaranteed not to be freed until @{"ReleaseNamedObject()" Link "ReleaseNamedObject()"} is called.
  The name comparison is caseless, using the current locale string comparison
  routines.If name is NULL, then all objects will be matched.If lastObject is
  non-NULL, it must be an object from the same NameSpace found on a previous
  call to FindNamedObject().It will not be freed by this call.The search will
  start at the node after lastobject, if non-NULL.NameSpace is the name space
  from the named object given or the root name space if NULL is given.
SYNOPSIS
  @{FG shine}struct@{FG text} NamedObject *FindNamedObject(@{FG shine}struct@{FG text} NamedObject *, STRPTR,
    @{FG shine}struct@{FG text} NamedObject *);
  @{i}@{b}object@{ub}@{ui} = FindNamedObject(@{i}nameSpace@{ui}, @{i}name@{ui}, @{i}lastObject@{ui});
   D0                       A0          A1    A2
  @{i}nameSpace@{ui} - the name space to search
  @{i}name@{ui} - the name of the object to search for
  @{i}lastObject@{ui} - the starting point for the search or NULL
  @{i}@{b}object@{ub}@{ui} - the first match found, or NULL for no match
SEE ALSO
  @{"ReleaseNamedObject()" Link "ReleaseNamedObject()"}, <utility/name.h>
@EndNode
@Node "FindTagItem()" "utility.library/FindTagItem"
@{b}@{u}FindTagItem@{uu}@{ub} -- scan a tag list for a specific tag.(V36)
  Scans a tag list and returns a pointer to the first item with
  ti_Tag matching the 'tagValue' parameter.
SYNOPSIS  @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *FindTagItem(@{i}Tag@{ui},@{FG shine}struct@{FG text} TagItem *);
  @{i}@{b}tag@{ub}@{ui} = FindTagItem(@{i}tagValue@{ui},@{i}tagList@{ui});
   D0                 D0       A0
  @{i}tagValue@{ui} - tag value to search for
  @{i}tagList@{ui} - tag item list to search (may be NULL)
  @{i}@{b}tag@{ub}@{ui} - a pointer to the item with ti_Tag matching 'tagValue' or NULL
    if no match was found.
SEE ALSO
  @{"<utility/tagitem.h>" Link "include:utility/tagitem.h/Main" 0}, @{"GetTagData()" Link "GetTagData()"}, @{"PackBoolTags()" Link "PackBoolTags()"}, @{"NextTagItem()" Link "NextTagItem()"}
@EndNode
@Node "FreeNamedObject()" "utility.library/FreeNamedObject"
@{b}@{u}FreeNamedObject@{uu}@{ub} -- frees a name object.(V39)
  Free one of a number of structures used by utility.library.
  The item must not be a member of any NameSpace, and no one
  may have it open other than yourself.If the object also
  contained a NameSpace, that namespace must be empty.
  Any additional space allocated via the datasize parameter
  for AllocNamedObject() is also released.
SYNOPSIS  @{FG shine}void@{FG text} FreeNamedObject(@{FG shine}struct@{FG text} NamedObject *);
  FreeNamedObject(@{i}object@{ui});
                   A0
  @{i}object@{ui} - the object to be freed
SEE ALSO
  @{"AllocNamedObjectA()" Link "AllocNamedObjectA()"}
@EndNode
@Node "FreeTagItems()" "utility.library/FreeTagItems"
@{b}@{u}FreeTagItems@{uu}@{ub} -- free an allocated tag list.(V36)
  Frees the memory of a TagItem list allocated either by
  @{"AllocateTagItems()" Link "AllocateTagItems()"} or @{"CloneTagItems()" Link "CloneTagItems()"}.
SYNOPSIS  @{FG shine}void@{FG text} FreeTagItems(@{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  FreeTagItems(@{i}tagList@{ui});
                A0
  @{i}tagList@{ui} - list to free, must have been obtained from
    @{"AllocateTagItems()" Link "AllocateTagItems()"} or @{"CloneTagItems()" Link "CloneTagItems()"} (may be NULL)
SEE ALSO
  @{"<utility/tagitem.h>" Link "include:utility/tagitem.h/Main" 0}, @{"AllocateTagItems()" Link "AllocateTagItems()"}, @{"CloneTagItems()" Link "CloneTagItems()"}
@EndNode
@Node "GetTagData()" "utility.library/GetTagData"
@{b}@{u}GetTagData@{uu}@{ub} -- obtain the data corresponding to a tag.(V36)
  Searches a tag list for a matching tag, and returns the
  corresponding ti_Data value for the TagItem found.If no match is
  found, this function returns the value passed in as 'default'.
SYNOPSIS  ULONG GetTagData(@{i}Tag@{ui},ULONG,@{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  @{i}@{b}value@{ub}@{ui} = GetTagData(@{i}tagValue@{ui},@{i}defaultVal@{ui},@{i}tagList@{ui});
   D0                  D0       D1         A0
  @{i}tagValue@{ui} - tag value to search for.
  @{i}defaultVal@{ui} - value to be returned if tagValue is not found.
  @{i}tagList@{ui} - the tag list to search.
  @{i}@{b}value@{ub}@{ui} - the ti_Data value for the first matching TagItem, or 'default'
    if a ti_Tag matching 'Tag' is not found.
SEE ALSO
  @{"<utility/tagitem.h>" Link "include:utility/tagitem.h/Main" 0}, @{"FindTagItem()" Link "FindTagItem()"}, @{"PackBoolTags()" Link "PackBoolTags()"}, @{"NextTagItem()" Link "NextTagItem()"}
@EndNode
@Node "GetUniqueID()" "utility.library/GetUniqueID"
@{b}@{u}GetUniqueID@{uu}@{ub} -- return a relatively unique number.(V39)
  Returns a unique value each time it is called.This is useful for
  things that need unique ID such as the GadgetHelp ID, etc.
  Note that this is only unique for 4,294,967,295 calls to this
  function.Under normal use this is not a problem.
  This function is safe in interrupts.
SYNOPSIS
  @{i}@{b}id@{ub}@{ui} = GetUniqueID();
  D0
  ULONG GetUniqueID(@{FG shine}void@{FG text});
  @{i}@{b}id@{ub}@{ui} - a 32-bit value that is unique.
@EndNode
@Node "MapTags()" "utility.library/MapTags"
@{b}@{u}MapTags@{uu}@{ub} -- convert ti_Tag values in a list via map pairing.(V36)
  Apply a "mapping list" mapList to tagList.If the ti_Tag field of an item
  in tagList appears as ti_Tag in some item in mapList, overwrite ti_Tag
  with the corresponding ti_Data from the map list.
  The mapType parameter specifies how the mapping operation is to proceed,
  with the following available types:
    MAP_REMOVE_NOT_FOUND
    If a tag in tagList does not appear in the mapList, remove it from tagList.
    MAP_KEEP_NOT_FOUND
    To have items which do not appear in the mapList survive the mapping
    process as-is.
  MapTags() is central to BOOPSI gadget interconnections where you want to
  convert the tag values from one space (the sender) to another (the receiver).
  The procedure will change the values of the input tag list tagList
  (but not mapList).You can "filter" a list by passing MAP_REMOVE_NOT_FOUND
  as mapType, and having the data items in mapList equal the corresponding tags.
  You can perform the inverse filter ("everything but") by passing a mapType of
  MAP_KEEP_NOT_FOUND, and creating a map item for every tag you want to filter
  out, pairing it with a mapped data value of TAG_IGNORE.For safety and "order
  independence" of tag item arrays, if you attempt to map some tag to the value
  TAG_DONE, the value TAG_IGNORE will be substituted instead.
SYNOPSIS
  @{FG shine}void@{FG text} MapTags(@{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *,@{FG shine}struct@{FG text} TagItem *,ULONG);
  MapTags(@{i}tagList@{ui},@{i}mapList@{ui},@{i}mapType@{ui});
           A0      A1       D0
  @{i}tagList@{ui} - input list of tag items which is to be mapped to tag values
    as specified in mapList.
  @{i}mapList@{ui} - a "mapping list" tag list which pairs tag values expected to
    appear in tagList with new values to be substituted in the
    ti_Tag fields of tagList (may be NULL)
  @{i}mapType@{ui} - one of the available mapping types as defined in
    @{"<utility/tagitem.h>" Link "include:utility/tagitem.h/Main" 0}
EXAMPLE
  /* Consider this source list: */
    @{FG shine}struct@{FG text} TagItem @{i}list[]@{ui} =
    {
      {@{i}MY_SIZE@{ui}, 71},
      {@{i}MY_WEIGHT@{ui}, 200},
      {@{i}TAG_DONE@{ui}, }
    };
  /* And the mapping list: */
    @{FG shine}struct@{FG text} TagItem @{i}map[]@{ui} =
    {
      {@{i}MY_SIZE@{ui}, HIS_TALL},
      {@{i}TAG_DONE@{ui},  }
    };
  /* Then after MapTags(list,map,MAP_REMOVE_NOT_FOUND), 'list' will become: */
    {@{i}HIS_TALL@{ui}, 71},
    {@{i}TAG_IGNORE@{ui}, },
    {@{i}TAG_DONE@{ui}, }
  /* Or after MapTags(list,map,MAP_KEEP_NOT_FOUND), 'list' will
     become: */
    {@{i}HIS_TALL@{ui},  71},
    {@{i}MY_WEIGHT@{ui}, 200},
    {@{i}TAG_DONE@{ui},  }
BUGS
  Prior to V39, the mapType parameter did not work.The function
  always behaved as if the parameter was set to MAP_KEEP_NOT_FOUND.
SEE ALSO
  @{"<utility/tagitem.h>" Link "include:utility/tagitem.h/Main" 0}, @{"ApplyTagChanges()" Link "ApplyTagChanges()"}, @{"FilterTagChanges()" Link "FilterTagChanges()"}
@EndNode
@Node "NamedObjectName()" "utility.library/NamedObjectName"
@{b}@{u}NamedObjectName@{uu}@{ub} -- return the name of the object.(V39)
  Returns the name of the object passed in...
  Note that the name string is passed back as just a pointer to
  a read-only name.If the object goes away, so does the name.
SYNOPSIS  STRPTR NamedObjectName(@{FG shine}struct@{FG text} NamedObject *);
  @{i}@{b}name@{ub}@{ui} = NamedObjectName(@{i}object@{ui});
   D0                     A0
  @{i}object@{ui} - the object, may be NULL in which case this function returns NULL.
  @{i}@{b}name@{ub}@{ui} - pointer to the name string, or NULL if 'object' is NULL.
SEE ALSO
  @{"FindNamedObject()" Link "FindNamedObject()"}, @{"RemNamedObject()" Link "RemNamedObject()"}
@EndNode
@Node "NextTagItem()" "utility.library/NextTagItem"
@{b}@{u}NextTagItem@{uu}@{ub} -- iterate through a tag list.(V36)
  Iterates through a tag list, skipping and chaining as dictated by system tags.
  @{i}TAG_SKIP@{ui} will cause it to skip the entry and a number of following tags as
  specified in ti_Data.@{i}TAG_IGNORE@{ui} ignores that single entry, and @{i}TAG_MORE@{ui} has a
  pointer to another array of tags (and terminates the current array!).
  @{i}TAG_DONE@{ui} also terminates the current array.Each call returns either the next
  tagitem you should examine, or NULL when the end of the list has been reached.
SYNOPSIS  @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *NextTagItem(@{FG shine}struct@{FG text} TagItem **);
  @{i}@{b}tag@{ub}@{ui} = NextTagItem(@{i}tagItemPtr@{ui});
   D0                A0
  @{i}tagItemPtr@{ui} - doubly-indirect reference to a TagItem structure.
    The pointer will be changed to keep track of the iteration.
  @{i}@{b}nextTag@{ub}@{ui} - each TagItem in the array or chain of arrays that should be
    processed according to system tag values defined in @{"<utility/tagitem.h>" Link "include:utility/tagitem.h/Main" 0})
    is returned in turn with successive calls.
EXAMPLE
  Iterate(@{FG shine}struct@{FG text} TagItem *@{i}tags@{ui});
  {
    @{FG shine}struct@{FG text} TagItem *@{i}tstate@{ui};
    @{FG shine}struct@{FG text} TagItem *@{i}tag@{ui};
    @{i}tstate@{ui} = @{i}tags@{ui};
    @{FG shine}while@{FG text} (@{i}tag@{ui} = NextTagItem(@{i}&tstate@{ui}))
    {
      @{FG shine}switch@{FG text} (@{i}tag@{ui}->@{i}ti_Tag@{ui})
      {
        @{FG shine}case@{FG text} TAG1: ...
             @{FG shine}break@{FG text};
        @{FG shine}case@{FG text} TAG2: ...
             @{FG shine}break@{FG text};
        ...
      }
    }
  }
@{b}WARNING@{ub}
  Do @{b}NOT@{ub} use the value of *tagItemPtr, but rather use the pointer
  returned by NextTagItem().
SEE ALSO
  @{"<utility/tagitem.h>" Link "include:utility/tagitem.h/Main" 0}, @{"GetTagData()" Link "GetTagData()"}, @{"PackBoolTags()" Link "PackBoolTags()"}, @{"FindTagItem()" Link "FindTagItem()"}
@EndNode
@Node "PackBoolTags()" "utility.library/PackBoolTags"
@{b}@{u}PackBoolTags@{uu}@{ub} -- builds a "flag" word from a tag list.(V36)
  Picks out the boolean tag items in a tag list and converts them into bit-flag
  representations according to a correspondence defined by the tag list 'boolMap'.
  A boolean tag item is one where only the logical value of the ti_Data
  is relevant.If this field is 0 the value is FALSE, otherwise TRUE.
SYNOPSIS  ULONG PackBoolTags(ULONG,@{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *,@{FG shine}struct@{FG text} TagItem *);
  @{i}@{b}flags@{ub}@{ui} = PackBoolTags(@{i}initialFlags@{ui},@{i}tagList@{ui},@{i}boolMap@{ui});
   D0                    D0           A0      A1
  @{i}initialFlags@{ui} - a starting set of bit-flags which will be changed
    by the processing of TRUE and FALSE boolean tags in tagList.
  @{i}tagList@{ui} - a TagItem list which may contain several tag items defined to
    be boolean by their presence in boolMap.The logical value of ti_Data
    determines whether a tag item causes the bit-flag value related
    by boolMap to be set or cleared in the returned flag longword.
  @{i}boolMap@{ui} - a tag list defining the boolean tags to be recognized, and
    the bit (or bits) in the returned longword that are to be set or cleared
    when a boolean Tag is found to be TRUE or FALSE in tagList.
  @{i}@{b}flags@{ub}@{ui} - the accumulated longword of bit-flags, starting with
    initialFlags and modified by each boolean tag item encountered.
EXAMPLE
  /* define some nice user tag values ...*/
  @{FG shine}enum@{FG text} @{i}mytags@{ui} { @{i}tag1@{ui} = TAG_USER+1, @{i}tag2@{ui}, @{i}tag3@{ui}, @{i}tag4@{ui}, @{i}tag5@{ui} };
  /* this TagItem list defines the correspondence between boolean tags
   * and bit-flag values.*/
  @{FG shine}struct@{FG text} TagItem @{i}boolMap[]@{ui} =
  {
    {@{i}tag1@{ui}, 0x0001},
    {@{i}tag2@{ui}, 0x0002},
    {@{i}tag3@{ui}, 0x0004},
    {@{i}tag4@{ui}, 0x0008},
    {TAG_DONE, }
  };
  /* You are probably passed these by some client, and you want
   * to "collapse" the boolean content into a single longword.*/
  @{FG shine}struct@{FG text} TagItem @{i}boolExample[]@{ui} =
  {
    {@{i}tag1@{ui}, TRUE},
    {@{i}tag2@{ui}, FALSE},
    {@{i}tag5@{ui}, @{i}Irrelevant@{ui}},
    {@{i}tag3@{ui}, TRUE},
    {TAG_DONE, }
  };
  /* Perhaps 'boolFlags' already has a current value of 0x800002.*/
  @{i}boolFlags@{ui} = PackBoolTags(@{i}boolFlags@{ui},@{i}boolExample@{ui},@{i}boolMap@{ui});
  /* The resulting new value of 'boolFlags' will be 0x80005./*
@{b}WARNING@{ub}
  In a case where there is duplication of a tag in tagList, the
  last of the identical tags will hold sway.
SEE ALSO
  @{"<utility/tagitem.h>" Link "include:utility/tagitem.h/Main" 0}, @{"GetTagData()" Link "GetTagData()"}, @{"FindTagItem()" Link "FindTagItem()"}, @{"NextTagItem()" Link "NextTagItem()"}
@EndNode
@Node "PackStructureTags()" "utility.library/PackStructureTags"
@{b}@{u}PackStructureTags@{uu}@{ub} -- pack a structure with values from taglist.(V39)
  For each table entry, a @{"FindTagItem()" Link "FindTagItem()"} will be done and if the
  matching tag is found in the taglist, the data field will be
  packed into the given structure based on the packtable definition.
SYNOPSIS
  ULONG PackStructureTags(APTR,ULONG *,@{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  @{i}@{b}num@{ub}@{ui} = PackStructureTags(@{i}pack@{ui},@{i}packTable@{ui},@{i}tagList@{ui});
   D0                      A0    A1        A2
  @{i}pack@{ui} - a pointer to the data area to fill in.
  @{i}packTable@{ui} - a pointer to the packing information table.
    See @{"<utility/pack.h>" Link "include:utility/pack.h/Main" 26} for definition and macros.
  @{i}tagList@{ui} - a pointer to the taglist to pack into the structure
  @{i}@{b}num@{ub}@{ui} - the number of tag items packed
SEE ALSO
  @{"<utility/pack.h>" Link "include:utility/pack.h/Main" 0}, @{"FindTagItem()" Link "FindTagItem()"}, @{"UnpackStructureTags()" Link "UnpackStructureTags()"}
@EndNode
@Node "RefreshTagItemClones()" "utility.library/RefreshTagItemClones"
@{b}@{u}RefreshTagItemClones@{uu}@{ub} -- rejuvenate a clone from the original.(V36)
  If (and only if) the tag list 'clone' was created from 'original' by
  @{"CloneTagItems()" Link "CloneTagItems()"}, and if 'original' has not been changed in any way,
  you can reset the clone list to its original state by using this function.
SYNOPSIS  @{FG shine}void@{FG text} RefreshTagItemClones(@{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *,@{FG shine}struct@{FG text} TagItem *);
  RefreshTagItemClones(@{i}clone@{ui},@{i}original@{ui})
                        A0    A1
  @{i}clone@{ui} - return value from CloneTagItems(original)
  @{i}original@{ui} - a tag list that hasn't changed since @{"CloneTagItems()" Link "CloneTagItems()"}
SEE ALSO
  @{"<utility/tagitem.h>" Link "include:utility/tagitem.h/Main" 0}, @{"CloneTagItems()" Link "CloneTagItems()"}, @{"AllocateTagItems()" Link "AllocateTagItems()"},
  @{"FreeTagItems()" Link "FreeTagItems()"}, @{"ApplyTagChanges()" Link "ApplyTagChanges()"}
@EndNode
@Node "ReleaseNamedObject()" "utility.library/ReleaseNamedObject"
@{b}@{u}ReleaseNamedObject@{uu}@{ub} -- free a named object.(V39)
  Decrements the open count of the object.If the object has been
  removed, and the count goes to 0, the remover will be notified
  that the object is now free.
SYNOPSIS  @{FG shine}void@{FG text} ReleaseNamedObject(@{FG shine}struct@{FG text} @{"NamedObject" Link "include:utility/name.h/Main" 21} *);
  ReleaseNamedObject(@{i}object@{ui});
                      A0
  @{i}object@{ui} - the object to release.(No action if NULL)
SEE ALSO
  @{"FindNamedObject()" Link "FindNamedObject()"}, @{"RemNamedObject()" Link "RemNamedObject()"}
@EndNode
@Node "RemNamedObject()" "utility.library/RemNamedObject"
@{b}@{u}RemNamedObject@{uu}@{ub} -- remove a named object.(V39)
  This function will post a request to release the object from whatever
  NameSpace it is in.It will reply the message when the object is fully removed.
  The message.mn_Node.ln_Name field will contain the object pointer or NULL if
  the object was removed by another process.This function will effectively do
  a @{"ReleaseNamedObject()" Link "ReleaseNamedObject()"} thus you must have "found" the object first.
SYNOPSIS  @{FG shine}void@{FG text} RemNamedObject(@{FG shine}struct@{FG text} NamedObject *, @{FG shine}struct@{FG text} @{"Message" Link "include:exec/ports.h/Main" 48} *);
  RemNamedObject(@{i}object@{ui}, @{i}message@{ui});
                  A0      A1
  @{i}object@{ui} - the object to remove: Must be a valid NamedObject.
  @{i}message@{ui} - message to @{"ReplyMsg()" Link "exec.guide/ReplyMsg()"} (must be supplied)
  The message is replied with the ln_Name field either being the object or NULL.
  If it contains the object, the object is completely removed.
SEE ALSO
  @{"AttemptRemNamedObject()" Link "AttemptRemNamedObject()"}, @{"AddNamedObject()" Link "AddNamedObject()"}, @{"ReleaseNamedObject()" Link "ReleaseNamedObject()"}
@EndNode
@Node "SDivMod32()" "utility.library/SDivMod32"
@{b}@{u}SDivMod32@{uu}@{ub} -- signed 32 by 32 bit division and modulus.(V36)
  Divides the signed 32 bit dividend by the signed 32 bit divisor
  and returns a signed 32 bit quotient and remainder.
SYNOPSIS  @{FG shine}long@{FG text}:@{FG shine}long@{FG text} SDivMod32(@{FG shine}long@{FG text},@{FG shine}long@{FG text});
  @{i}@{b}quotient@{ub}@{ui}:@{i}@{b}remainder@{ub}@{ui} = SDivMod32(@{i}dividend@{ui},@{i}divisor@{ui});
   D0       D1                     D0       D1
  @{i}dividend@{ui} - signed 32 bit dividend.
  @{i}divisor@{ui} - signed 32 bit divisor.
  @{i}@{b}quotient@{ub}@{ui} - signed 32 quotient of the division.
  @{i}@{b}remainder@{ub}@{ui} - signed 32 remainder of the division.
@{"NOTES" link UTILITY_NOTES}
SEE ALSO
  @{"SMult32()" Link "SMult32()"}, @{"UDivMod32()" Link "UDivMod32()"}, @{"UMult32()" Link "UMult32()"}, @{"SMult64()" Link "SMult64()"}, @{"UMult64()" Link "UMult64()"}
@EndNode
@Node "SMult32()" "utility.library/SMult32"
@{b}@{u}SMult32@{uu}@{ub} -- signed 32 by 32 bit multiply with 32 bit result.(V36)
  Returns the signed 32 bit result of multiplying arg1 by arg2.
SYNOPSIS  @{FG shine}long@{FG text} SMult32(@{FG shine}long@{FG text},@{FG shine}long@{FG text});
  @{i}@{b}result@{ub}@{ui} = SMult32(@{i}arg1@{ui},@{i}arg2@{ui});
   D0                D0   D1
  @{i}arg1@{ui}, @{i}arg2@{ui} - numbers to multiply
  @{i}@{b}result@{ub}@{ui} - the signed 32 bit result of multiplying arg1 by arg2.
@{"NOTES" link UTILITY_NOTES}
SEE ALSO
  @{"SDivMod32()" Link "SDivMod32()"}, @{"UDivMod32()" Link "UDivMod32()"}, @{"UMult32()" Link "UMult32()"}, @{"SMult64()" Link "SMult64()"}, @{"UMult64()" Link "UMult64()"}
@EndNode
@Node "SMult64()" "utility.library/SMult64"
@{b}@{u}SMult64@{uu}@{ub} -- signed 32 by 32 bit multiply with 64 bit result.(V39)
  Returns the signed 64 bit result of multiplying arg1 by arg2.
SYNOPSIS  @{FG shine}long@{FG text} SMult64(@{FG shine}long@{FG text},@{FG shine}long@{FG text});
  @{i}@{b}result@{ub}@{ui} = SMult64(@{i}arg1@{ui},@{i}arg2@{ui});
   D0:D1             D0   D1
  @{i}arg1@{ui}, @{i}arg2@{ui} - numbers to multiply
  @{i}@{b}result@{ub}@{ui} - the signed 64 bit result of multiplying arg1 by arg2.
@{"NOTES" link UTILITY_NOTES}
SEE ALSO
  @{"SDivMod32()" Link "SDivMod32()"}, @{"UDivMod32()" Link "UDivMod32()"}, @{"UMult32()" Link "UMult32()"}, @{"UMult64()" Link "UMult64()"}
@EndNode
@Node "Stricmp()" "utility.library/Stricmp"
@{b}@{u}Stricmp@{uu}@{ub} -- case-insensitive string comparison.(V37)
  This function compares two strings, ignoring case using a generic
  case conversion routine.If the strings have different lengths,
  the shorter is treated as if it were extended with zeros.
SYNOPSIS  @{FG shine}long@{FG text} Stricmp(STRPTR,STRPTR);
  @{i}@{b}result@{ub}@{ui} = Stricmp(@{i}string1@{ui},@{i}string2@{ui});
   D0               A0       A1
  @{i}string1@{ui}, @{i}string2@{ui} - strings to be compared
  @{i}@{b}result@{ub}@{ui} - relationship between string1 and string2
    <0 means string1 < string2
    =0 means string1 = string2
    >0 means string1 > string2
@{"NOTES" link UTILITY_NOTES2}
SEE ALSO
  @{"Strnicmp()" Link "Strnicmp()"}, locale.library/StrnCmp()
@EndNode
@Node "Strnicmp()" "utility.library/Strnicmp"
@{b}@{u}Strnicmp@{uu}@{ub} -- length-limited case-insensitive string compare.(V37)
  This function compares two strings, ignoring case using a generic case
  conversion routine.If the strings have different lengths, the shorter
  is treated as if it were extended with zeros.This function never compares
  more than 'length' characters.
SYNOPSIS  @{FG shine}long@{FG text} Strnicmp(STRPTR,STRPTR,@{FG shine}long@{FG text});
  @{i}@{b}result@{ub}@{ui} = Strnicmp(@{i}string1@{ui},@{i}string2@{ui},@{i}length@{ui});
   D0                A0       A1      D0
  @{i}string1@{ui}, @{i}string2@{ui} - strings to be compared
  @{i}length@{ui} - maximum number of characters to examine
  @{i}@{b}result@{ub}@{ui} - relationship between string1 and string2
    <0 means string1 < string2
    =0 means string1 = string2
    >0 means string1 > string2
@{"NOTES" link UTILITY_NOTES2}
SEE ALSO
  @{"Stricmp()" Link "Stricmp()"}, locale.library/StrnCmp()
@EndNode
@node UTILITY_NOTES2 "utility_notes2"
Whenever locale.library is installed in a system, this function is
replaced by language-specific code.This means that depending on
which language the user has currently selected, identical pairs of
strings may return different values when passed to this function.
This fact must be taken into consideration when using this function.
@endnode
@Node "TagInArray()" "utility.library/TagInArray"
@{b}@{u}TagInArray@{uu}@{ub} -- check if a tag value appears in an array of tag values.(V36)
  Performs a quick scan to see if a tag value appears in an array terminated
  with TAG_DONE.Returns TRUE if the value is found. The 'tagArray' must be
  terminated by TAG_DONE.Note that this is an array of tag values, @{b}NOT@{ub} an
  array of TagItems.
SYNOPSIS  BOOL TagInArray(@{i}Tag@{ui},@{i}Tag@{ui} *);
  @{i}@{b}result@{ub}@{ui} = TagInArray(@{i}tagValue@{ui},@{i}tagArray@{ui});
   D0                  D0       A0
  @{i}tagValue@{ui} - tag value to search array for in array.
  @{i}tagArray@{ui} - a simple array of tag values terminated by TAG_DONE.
  @{i}@{b}result@{ub}@{ui} - TRUE if tagValue was found in tagArray.
SEE ALSO
  @{"<utility/tagitem.h>" Link "include:utility/tagitem.h/Main" 0}, @{"FilterTagItems()" Link "FilterTagItems()"}
@EndNode
@Node "ToLower()" "utility.library/ToLower"
@{b}@{u}ToLower@{uu}@{ub} -- convert a character to lower case.(V37)
  Converts a character to lower case, handling international character sets.
SYNOPSIS  UBYTE ToLower(UBYTE);
  @{i}@{b}char@{ub}@{ui} = ToLower(@{i}char@{ui});
   D0             D0
  @{i}char@{ui} - character to be converted.
  @{i}@{b}char@{ub}@{ui} - lower case version of the input character.
@{"NOTES" link UTILITY_NOTES2}
SEE ALSO
  @{"ToUpper()" Link "ToUpper()"}, locale.library/ConvToLower()
@EndNode
@Node "ToUpper()" "utility.library/ToUpper"
@{b}@{u}ToUpper@{uu}@{ub} -- convert a character to upper case.(V37)
  Converts a character to upper case, handling international character sets.
SYNOPSIS  UBYTE ToUpper(UBYTE);
  @{i}@{b}char@{ub}@{ui} = ToUpper(@{i}char@{ui});
   D0             D0
  @{i}char@{ui} - character to be converted.
  @{i}@{b}char@{ub}@{ui} - upper case version of input character.
@{"NOTES" link UTILITY_NOTES2}
SEE ALSO
  @{"ToLower()" link ToLower()}, locale.library/ConvToLower()
@EndNode
@Node "UDivMod32()" "utility.library/UDivMod32"
@{b}@{u}UDivMod32@{uu}@{ub} -- unsigned 32 by 32 bit division and modulus.(V36)
  Divides the unsigned 32 bit dividend by the unsigned 32 bit divisor
  and returns an unsigned 32 bit quotient and remainder.
SYNOPSIS  ULONG:ULONG UDivMod32(ULONG,ULONG);
  @{i}@{b}quotient@{ub}@{ui}:@{i}@{b}remainder@{ub}@{ui} = UDivMod32(@{i}dividend@{ui},@{i}divisor@{ui});
   D0       D1                     D0       D1
  @{i}dividend@{ui} - unsigned 32 bit dividend.
  @{i}divisor@{ui} - unsigned 32 bit divisor.
  @{i}@{b}quotient@{ub}@{ui} - unsigned 32 quotient of the division.
  @{i}@{b}remainder@{ub}@{ui} - unsigned 32 remainder of the division.
@{"NOTES" link UTILITY_NOTES}
SEE ALSO
  @{"SDivMod32()" Link "SDivMod32()"}, @{"SMult32()" Link "SMult32()"}, @{"UMult32()" Link "UMult32()"}
@EndNode
@Node "UMult32()" "utility.library/UMult32"
@{b}@{u}UMult32@{uu}@{ub} -- unsigned 32 by 32 bit multiply with 32 bit result.(V36)
  Returns the unsigned 32 bit result of multiplying arg1 by arg2.
SYNOPSIS  ULONG UMult32(ULONG,ULONG);
  @{i}@{b}result@{ub}@{ui} = UMult32(@{i}arg1@{ui},@{i}arg2@{ui});
   D0                D0   D1
  @{i}arg1@{ui}, @{i}arg2@{ui} - numbers to multiply
  @{i}@{b}result@{ub}@{ui} - the unsigned 32 bit result of multiplying arg1 by arg2.
@{"NOTES" link UTILITY_NOTES}
SEE ALSO
  @{"SDivMod32()" Link "SDivMod32()"}, @{"SMult32()" Link "SMult32()"}, @{"UDivMod32()" Link "UDivMod32()"}, @{"SMult64()" Link "SMult64()"}, @{"UMult64()" Link "UMult64()"}
@EndNode
@node UTILITY_NOTES "utility_notes"
Unlike other Amiga library function calls, the utility.library
32 bit math routines do @{b}NOT@{ub} require A6 to be loaded with a
pointer to the library base.A6 can contain anything the application
wishes.This is in order to avoid overhead in calling them.
In addition, the utility.library math routines preserve all
address registers including A0 and A1.
@endnode
@Node "UMult64()" "utility.library/UMult64"
@{b}@{u}UMult64@{uu}@{ub} -- unsigned 32 by 32 bit multiply with 64 bit result.(V39)
  Returns the unsigned 64 bit result of multiplying arg1 by arg2.
SYNOPSIS  ULONG UMult64(ULONG,ULONG);
  @{i}@{b}result@{ub}@{ui} = UMult64(@{i}arg1@{ui},@{i}arg2@{ui});
  D0:D1              D0   D1
  @{i}arg1@{ui}, @{i}arg2@{ui} - numbers to multiply
  @{i}@{b}result@{ub}@{ui} - the unsigned 64 bit result of multiplying arg1 by arg2.
@{"NOTES" link UTILITY_NOTES}
SEE ALSO
  @{"SDivMod32()" Link "SDivMod32()"}, @{"SMult32()" Link "SMult32()"}, @{"UDivMod32()" Link "UDivMod32()"}, @{"SMult64()" Link "SMult64()"}
@EndNode
@Node "UnpackStructureTags()" "utility.library/UnpackStructureTags"
@{b}@{u}UnpackStructureTags@{uu}@{ub} -- unpack a structure to values in taglist.(V39)
  For each table entry, a @{"FindTagItem()" Link "FindTagItem()"} will be done and if the
  matching tag is found in the taglist, the data in the structure
  will be placed into the memory pointed to by the tag's ti_Data.
  ti_Data *must* point to a LONGWORD.
SYNOPSIS  ULONG UnpackStructureTags(APTR,ULONG *,@{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  @{i}@{b}num@{ub}@{ui} = UnpackStructureTags(@{i}pack@{ui},@{i}packTable@{ui},@{i}tagList@{ui});
   D0                        A0    A1        A2
  @{i}pack@{ui} - a pointer to the data area to be unpacked
  @{i}packTable@{ui} - a pointer to the packing information table.
    See @{"<utility/pack.h>" Link "include:utility/pack.h/Main" 26} for definition and macros
  @{i}tagList@{ui} - a pointer to the taglist to unpack into
  @{i}@{b}num@{ub}@{ui} - the number of tag items unpacked
SEE ALSO
  @{"<utility/pack.h>" Link "include:utility/pack.h/Main" 0}, @{"FindTagItem()" Link "FindTagItem()"}, @{"PackStructureTags()" Link "PackStructureTags()"}
@EndNode
@Node "CreatePlayer()" "realtime.library/CreatePlayer"
@{b}@{u}CreatePlayerA@{uu}@{ub} -- create a player and link it to a conductor.(V37)
@{b}@{u}CreatePlayer@{uu}@{ub}  -- varargs stub for CreatePlayerA().(V37)
  Creates a player structure with the desired attributes.
SYNOPSIS
  @{FG shine}struct@{FG text} Player *CreatePlayerA(@{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  @{FG shine}struct@{FG text} Player *CreatePlayer (@{i}Tag@{ui}, ...);
  @{i}@{b}player@{ub}@{ui} = CreatePlayerA(@{i}tagList@{ui});
   D0                     A0
  @{i}@{b}player@{ub}@{ui} = CreatePlayer (@{i}firstTag@{ui}, ...);
  @{i}tagList@{ui} - pointer to an array of tags providing optional extra
    parameters, or NULL
  @{i}@{b}player@{ub}@{ui} - a pointer to a Player structure on success or NULL on failure.
    When NULL is returned, an error code can be returned in the longword
    variable pointed to by the optional PLAYER_ErrorCode tag.
@{"TAGS" link CREATEPLAYER_TAGS}(V37)
SEE ALSO
  @{"DeletePlayer()" Link "DeletePlayer()"}, GetPlayerAttrs(), @{"SetPlayerAttrs()" Link "SetPlayerAttrs()"}
@EndNode
@node CREATEPLAYER_TAGS "CreatePlayer_tags"
@{i}PLAYER_Name@{ui} (STRPTR) - name of the player (generally the application's name).
  Default is no name.
@{i}PLAYER_ID@{ui} (UWORD) - sets the player's ID value.Default is 0.
@{i}PLAYER_Hook@{ui} (@{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *) - function to call when time changes occur.
  Default is no function.The Hook is called with:
    A0 - address of "Hook structure
    A1 - message, currently pmTime or pmState
    A2 - address of Player structure
  Note that your hook function is not necessarily called TICK_FREQ times
  per second.This is the maximum number of times it can be called.
@{i}PLAYER_Conductor@{ui} (STRPTR) - name of the conductor to link with.
  If this conductor doesn't exist, it is created automatically.
  If ~0 is passed, creates a private conductor.
@{i}PLAYER_Conducted@{ui} (BOOL) - if TRUE sets the PLAYERF_CONDUCTED flag,
  FALSE clears the flag.Default is FALSE.
@{i}PLAYER_UserData@{ui} (void *) - sets the player's UserData value.
  Default is NULL.
@{i}PLAYER_Priority@{ui} (BYTE) - priority for the player, from -128 to +127.
  Default is 0.
@{i}PLAYER_ExtSync@{ui} (BOOL) - if TRUE, attempts to become external sync source.
@{i}PLAYER_Quiet@{ui} (BOOL) - when TRUE, this player is ignored.
  Mainly used by external sync applications.Default is FALSE.
@{i}PLAYER_Ready@{ui} (BOOL) - set/clear the "ready" flag.Default is FALSE.(V37)
@{i}PLAYER_Alarm@{ui} (BOOL) - if TRUE sets the PLAYERF_ALARMSET flag,
  FALSE clears the flag.Default is FALSE.
@{i}PLAYER_AlarmTime@{ui} (long) - sets this player's alarm time, and the
  PLAYERF_ALARMSET flag.
@{i}PLAYER_AlarmSigTask@{ui} (@{FG shine}struct@{FG text} @{"Task" Link "include:exec/tasks.h/Main" 24} *) - task to signal on notify or alarm.
  Default is no task.Having no task automatically forces the
  PLAYERF_ALARMSET flag off.
@{i}PLAYER_AlarmSigBit@{ui} (BYTE) - signal bit to use on alarm or -1 to disable.
  Default is -1.Having a signal bit of -1 automatically forces the
  PLAYERF_ALARMSET flag off.
@{i}PLAYER_ErrorCode@{ui} (long *) - optional pointer to a longword which will receive
  an error code whenever this function fails.
  Possible error values currently include:
    RTE_NOMEMORY - memory allocation failed
    RTE_NOTIMER  - timer (CIA) allocation failed
@endnode
@Node "DeletePlayer()" "realtime.library/DeletePlayer"
@{b}@{u}DeletePlayer@{uu}@{ub} -- delete a player.(V37)
  Deletes the specified player.Flushes the conductor that the player was
  connected to if this is the last player connected to that conductor.
SYNOPSIS  @{FG shine}void@{FG text} DeletePlayer(@{FG shine}struct@{FG text} Player *);
  DeletePlayer(@{i}player@{ui});
                A0
  @{i}player@{ui} - Player structure to delete, as allocated by
    @{"CreatePlayer()" Link "CreatePlayer()"}.May be NULL, in which case this function does nothing.
SEE ALSO
  @{"CreatePlayer()" Link "CreatePlayer()"}
@EndNode
@Node "ExternalSync()" "realtime.library/ExternalSync"
@{b}@{u}ExternalSync@{uu}@{ub} -- provide external source clock for a player's conductor.(V37)
  Allows external applications to constrain conductor time between
  minTime and maxTime, with the restraint that time can never run backwards.
  Does nothing if the given player is not the current External Sync source.
SYNOPSIS  BOOL ExternalSync(@{FG shine}struct@{FG text} Player *, @{FG shine}long@{FG text}, @{FG shine}long@{FG text});
  @{i}@{b}result@{ub}@{ui} = ExternalSync(@{i}player@{ui}, @{i}minTime@{ui}, @{i}maxTime@{ui});
   D0                    A0      D0        D1
  @{i}player@{ui} - player referencing the conductor to change
  @{i}minTime@{ui}, @{i}maxTime@{ui} - time constraints
  @{i}@{b}result@{ub}@{ui} - TRUE if everything went OK, FALSE if the player is not the
    current sync source or there is no conductor for the player.
@EndNode
@Node "FindConductor()" "realtime.library/FindConductor"
@{b}@{u}FindConductor@{uu}@{ub} -- find a conductor by name.(V37)
  Returns the conductor with the given name or NULL if not found.
  The conductor list must be locked before calling this function.This
  is done by calling LockRealTime(RT_CONDUCTORS).
SYNOPSIS  @{FG shine}struct@{FG text} Conductor *FindConductor(STRPTR);
  @{i}@{b}conductor@{ub}@{ui} = FindConductor(@{i}name@{ui});
   D0                        A0
  @{i}name@{ui} - name of conductor to find.
  @{i}@{b}conductor@{ub}@{ui} - pointer to a Conductor structure, or NULL if not found.
SEE ALSO
  @{"NextConductor()" Link "NextConductor()"}, @{"LockRealTime()" Link "LockRealTime()"}, @{"UnlockRealTime()" Link "UnlockRealTime()"}
@EndNode
@Node "GetPlayerAttrsA()" "realtime.library/GetPlayerAttrsA"
@{b}@{u}GetPlayerAttrsA@{uu}@{ub} -- get the attributes of a player.(V37)
@{b}@{u}GetPlayerAttrs@{uu}@{ub}  -- varargs stub for GetPlayerAttrsA().(V37)
  Retrieves the attributes of the specified player, according to the
  attributes chosen in the tag list.For each entry in the tag list,
  ti_Tag identifies the attribute, and ti_Data is a pointer to
  the longword variable where you wish the result to be stored.
SYNOPSIS
  ULONG GetPlayerAttrsA(@{FG shine}struct@{FG text} Player *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  ULONG GetPlayerAttrs (@{FG shine}struct@{FG text} Player *, @{i}Tag@{ui}, ...);
  @{i}@{b}numProcessed@{ub}@{ui} = GetPlayerAttrsA(@{i}player@{ui}, @{i}tagList@{ui});
   D0                             A0       A1
  @{i}@{b}numProcessed@{ub}@{ui} = GetPlayerAttrs (@{i}player@{ui}, @{i}firstTag@{ui}, ...);
  @{i}player@{ui} - pointer to the player in question.May be NULL, in which case
    this function returns 0
  @{i}tagList@{ui} - pointer to @{"TagItem" Link "include:utility/tagitem.h/Main" 31} list.
  @{i}@{b}numProcessed@{ub}@{ui} - the number of attributes successfully filled in.
@{"TAGS" link GETPLAYERATTRSA_TAGS}(V37)
SEE ALSO
  @{"CreatePlayer()" Link "CreatePlayer()"}, @{"SetPlayerAttrs()" Link "SetPlayerAttrs()"}
@EndNode
@node GETPLAYERATTRSA_TAGS "GetPlayerAttrsA_tags"
@{i}PLAYER_Name@{ui} (STRPTR) - return the name of the player,
  or NULL if this is an unnamed player.
@{i}PLAYER_Hook@{ui} (@{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *) - returns a pointer to the current function called
  when time changes occur, or NULL if no function is currently installed.
@{i}PLAYER_Conductor@{ui} (STRPTR) - returns the name of the conductor this player is
  currently linked with, or NULL if the player is not linked to a conductor.
@{i}PLAYER_ID@{ui} (UWORD) - gets the value of this player's ID.
@{i}PLAYER_Conducted@{ui} (BOOL) - returns TRUE if this player is currently
  being conducted.
  external sync source.
@{i}PLAYER_UserData@{ui} (void *) - returns the current value of this player's UserData.
@{i}PLAYER_Priority@{ui} (BYTE) - returns the priority for the player.
@{i}PLAYER_ExtSync@{ui} (BOOL) - returns TRUE if this player is the current
@{i}PLAYER_Quiet@{ui} (BOOL) - returns TRUE if this player is currently being ignored.
@{i}PLAYER_Ready@{ui} (BOOL) - gets the state of the "ready" flag.
@{i}PLAYER_Alarm@{ui} (BOOL) - returns TRUE if this player's alarm is currently on.
@{i}PLAYER_AlarmTime@{ui} (long) - gets the current alarm time for this player.
@{i}PLAYER_AlarmSigTask@{ui} (@{FG shine}struct@{FG text} @{"Task" Link "include:exec/tasks.h/Main" 24} *) - returns a pointer to the task to
  signal on notify or alarm, or NULL if there is no task to signal.
@{i}PLAYER_AlarmSigBit@{ui} (BYTE) - returns the signal bit to use on alarm
  or -1 if no signal.
@endnode
@Node "LockRealTime()" "realtime.library/LockRealTime"
@{b}@{u}LockRealTime@{uu}@{ub} -- prevent other tasks from changing internal structures.(V37)
  This routine will lock the internal sempahores in the RealTime library.
  If they are already locked by another task, this routine will wait
  until they are free.
SYNOPSIS  APTR LockRealTime(ULONG);
  @{i}@{b}lockHandle@{ub}@{ui} = LockRealTime(@{i}lockType@{ui});
   D0                         D0
  @{i}lockType@{ui} - the internal list to lock.Only RT_CONDUCTORS is currently defined.
  @{i}@{b}handle@{ub}@{ui} - if lockType is valid, returns a value that must be passed later to
   @{"UnlockRealTime()" Link "UnlockRealTime()"} to unlock the list.Returns NULL
   if passed an invalid lock type.
SEE ALSO
  @{"UnlockRealTime()" Link "UnlockRealTime()"}
@EndNode
@Node "NextConductor()" "realtime.library/NextConductor"
@{b}@{u}NextConductor@{uu}@{ub} -- return the next conductor on realtime.library's conductor list.(V37)
  Returns the next conductor on realtime.library's conductor list.
  If previousConductor is NULL, returns the first conductor in the list.Returns
  NULL if no more conductors.The conductor list must be locked before calling
  this function.This is done by calling LockRealTime(RT_CONDUCTORS).
SYNOPSIS  @{FG shine}struct@{FG text} Conductor *NextConductor(@{FG shine}struct@{FG text} @{i}Conductor@{ui} *);
  @{i}@{b}conductor@{ub}@{ui} = NextConductor(@{i}previousConductor@{ui});
   D0                        A0
  @{i}previousConductor@{ui} - previous conductor or NULL to get first conductor.
  @{i}@{b}conductor@{ub}@{ui} - next conductor on the list, or NULL if no more.
SEE ALSO
  @{"FindConductor()" Link "FindConductor()"}, @{"LockRealTime()" Link "LockRealTime()"}, @{"UnlockRealTime()" Link "UnlockRealTime()"}
@EndNode
@Node "SetConductorState()" "realtime.library/SetConductorState"
@{b}@{u}SetConductorState@{uu}@{ub} -- change the play state of a player's conductor.(V37)
  Changes the play state of the conductor referenced by the player.
  The states can be CONDSTATE_STOPPED, CONDSTATE_PAUSED, CONDSTATE_LOCATE,
  CONDSTATE_RUNNING, or the special value CONDSTATE_METRIC which asks the
  highest priority conducted node to do a CONDSTATE_LOCATE, or the special value
  CONDSTATE_SHUTTLE which informs the players that the clock value is changing,
  but the clock isn't actually running.Note that going from CONDSTATE_PAUSED
  to CONDSTATE_RUNNING does not reset the cdt_ClockTime of the conductor.
SYNOPSIS  @{FG shine}long@{FG text} SetConductorState(@{FG shine}struct@{FG text} Player *, ULONG, @{FG shine}long@{FG text});
  @{i}@{b}result@{ub}@{ui} = SetConductorState(@{i}player@{ui}, @{i}state@{ui}, @{i}time@{ui});
   D0                         A0       D0     D1
  @{i}player@{ui} - player referencing the conductor to change
  @{i}state@{ui} - new play state of conductor
  @{i}time@{ui} - start time offset in realtime.library heartbeat units
  @{i}@{b}result@{ub}@{ui} - 0 if everything went OK, or a realtime.library error code if
   an error occured.These currently include RTE_PLAYING and RTE_NOCONDUCTOR.
@EndNode
@Node "SetPlayerAttrs()" "realtime.library/SetPlayerAttrs"
@{b}@{u}SetPlayerAttrsA@{uu}@{ub} -- set the attributes of a player.(V37)
@{b}@{u}SetPlayerAttrs@{uu}@{ub}  -- varargs stub for SetPlayerAttrsA().(V37)
  Changes the attributes of the specified player, according to the attributes
  chosen in the tag list.If an attribute is not provided in the tag list,
  its value remains unchanged.
SYNOPSIS
  BOOL SetPlayerAttrsA(@{FG shine}struct@{FG text} Player *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  BOOL SetPlayerAttrs (@{FG shine}struct@{FG text} Player *, @{i}Tag@{ui}, ...);
  @{i}@{b}result@{ub}@{ui} = SetPlayerAttrsA(@{i}player@{ui}, @{i}tagList@{ui});
   D0                       A0       A1
  @{i}@{b}result@{ub}@{ui} = SetPlayerAttrs (@{i}player@{ui},@{i}firstTag@{ui}, ...);
  @{i}player@{ui} - player to set the attributes of.
  @{i}tagList@{ui} - pointer to an array of tags specifying the attributes to change,
    or NULL.
  @{i}@{b}result@{ub}@{ui} - TRUE if all went well, FALSE if there was an error.
    When an error occurs, an error code can be returned in the longword
    variable pointed to by the optional PLAYER_ErrorCode tag.
@{"TAGS" link SETPLAYERATTRS_TAGS}(V37)
SEE ALSO
  @{"CreatePlayer()" Link "CreatePlayer()"}, @{"DeletePlayer()" Link "DeletePlayer()"}, GetPlayerAttrs()
@EndNode
@node SETPLAYERATTRS_TAGS "SetPlayerAttrs_tags"
@{i}PLAYER_Name@{ui} (STRPTR) - name of the player (generally the application's name).
@{i}PLAYER_ID@{ui} (UWORD) - sets this player's ID value.
@{i}PLAYER_Hook@{ui} (@{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *) - function to call when time changes occur.
  @{i}The Hook is called with@{ui}:
    A0 - address of Hook structure
    A1 - message, currently pmTime or pmState
    A2 - address of Player structure
  Note that your hook function is not necessarily called TICK_FREQ times
  per second.This is the maximum number of times it can be called.
@{i}PLAYER_Conductor@{ui} (STRPTR) - name of the conductor to link with.
  If NULL, delink from conductor.
@{i}PLAYER_Conducted@{ui} (BOOL) - if TRUE sets the PLAYERF_CONDUCTED flag,
  FALSE clears the flag.
@{i}PLAYER_UserData@{ui} (void *) - sets this player's UserData value.(V37)
@{i}PLAYER_Priority@{ui} (BYTE) - priority for the player, from -128 to +127.
@{i}PLAYER_ExtSync@{ui} (BOOL) - if TRUE, attempt to become external sync source.
  If FALSE, release external sync.
@{i}PLAYER_Quiet@{ui} (BOOL) - when TRUE, this player is ignored.
  Mainly used by external sync applications.
@{i}PLAYER_Ready@{ui} (BOOL) - set/clear the "ready" flag.
@{i}PLAYER_Alarm@{ui} (BOOL) - if TRUE sets the PLAYERF_ALARMSET flag,
  FALSE clears the flag.
@{i}PLAYER_AlarmTime@{ui} (long) - sets this player's alarm time,
  and the PLAYERF_ALARMSET flag.
@{i}PLAYER_AlarmSigTask@{ui} (@{FG shine}struct@{FG text} @{"Task" Link "include:exec/tasks.h/Main" 24} *) - task to signal on notify or alarm.
  Setting this to NULL automatically clears the PLAYERF_ALARMSET flag.
@{i}PLAYER_AlarmSigBit@{ui} (BYTE) - signal bit to use on alarm or -1 to disable.
  Setting this to -1 automatically clears the PLAYERF_ALARMSET.
@{i}PLAYER_ErrorCode@{ui} (long *) - optional pointer to a longword which
  will receive an error code whenever this function fails.
  @{i}Possible error values currently include@{ui}:
    RTE_NOMEM   - memory allocation failed
    RTE_NOTIMER - timer (CIA) allocation failed
@endnode
@Node "UnlockRealTime()" "realtime.library/UnlockRealTime"
@{b}@{u}UnlockRealTime@{uu}@{ub} -- unlock internal lists.(V37)
  Undoes the effects of @{"LockRealTime()" Link "LockRealTime()"}.
SYNOPSIS  @{FG shine}void@{FG text} UnlockRealTime(APTR);
  UnlockRealTime(@{i}lockHandle@{ui});
                  A0
  @{i}lockHandle@{ui} - value returned by @{"LockRealTime()" Link "LockRealTime()"}.May be NULL.
SEE ALSO
  @{"LockRealTime()" Link "LockRealTime()"}
@EndNode
@Node "AskKeyMapDefault()" "keymap.library/AskKeyMapDefault"
@{b}@{u}AskKeyMapDefault@{uu}@{ub} -- Ask for a pointer to the current default keymap.(V36)
  Return a pointer to the keymap used by the keymap library for
  @{"MapRawKey" Link "MapRawKey()"} and @{"MapANSI" Link "MapANSI()"} when a keymap is not specified.
SYNOPSIS  @{FG shine}struct@{FG text} @{"KeyMap" Link "include:devices/keymap.h/Main" 21} *AskKeyMapDefault( @{FG shine}void@{FG text} );
  @{i}@{b}keyMap@{ub}@{ui} = AskKeyMapDefault()
   D0
  @{i}@{b}keyMap@{ub}@{ui} - a pointer to a keyMap structure.
    This key map is guaranteed to be permanently allocated: it will remain in
    memory till the machine is reset.
BUGS
  The keymap.h include file should be in the libraries/ or perhaps resources/
  directory, but is in the devices/ directory for compatibility reasons.
SEE ALSO
  @{"devices/keymap.h" Link "include:devices/keymap.h/Main" 0}, @{"keymap.library/SetKeyMapDefault()" Link "SetKeyMapDefault()"},
  console.device ...KEYMAP functions
@EndNode
@Node "MapANSI()" "keymap.library/MapANSI"
@{b}@{u}MapANSI@{uu}@{ub} -- Encode an ANSI string into keycodes.(V36)
  This console function converts an ANSI byte string to the code/qualifier pairs
  of type IECLASS_RAWKEY that would generate the string and places those pairs
  in a buffer.A code/qualifier pair is a pair of bytes suitable for putting in
  the ie_Code and low byte of ie_Qualifier,and for subsequent events,shifted to
  the ie_Prev1DownCode/ie_Prev1DownQual then ie_Prev2DownCode/ie_Prev2DownQual
  pairs for any dead or double dead key mapping.
SYNOPSIS  @{FG shine}long@{FG text} MapANSI( STRPTR, @{FG shine}long@{FG text}, STRPTR, @{FG shine}long@{FG text}, @{FG shine}struct@{FG text} @{"KeyMap" Link "include:devices/keymap.h/Main" 22} * );
  @{i}@{b}actual@{ub}@{ui} = MapANSI(@{i}string@{ui}, @{i}count@{ui}, @{i}buffer@{ui}, @{i}length@{ui}, @{i}keyMap@{ui})
   D0                A0      D0     A1      D1      A2
  @{i}string@{ui} - the ANSI string to convert.
  @{i}count@{ui} - the number of characters in the string.
  @{i}buffer@{ui} - a byte buffer large enough to hold all anticipated
    code/qualifier pairs generated by this conversion.
  @{i}length@{ui} - maximum anticipation, i.e.the buffer size in bytes
    divided by two (the size of the code/qualifier pair).
  @{i}keyMap@{ui} - a @{"KeyMap" Link "include:devices/keymap.h/Main" 22} structure pointer, or null if the default
    key map is to be used.
  @{i}@{b}actual@{ub}@{ui} - the number of code/qualifier pairs in the buffer,
    or negative to describe an error (see below).
ERRORS
  if @{i}@{b}actual@{ub}@{ui} is 0, a character in the string was not generatable from the keyMap.
  if @{i}@{b}actual@{ub}@{ui} is -1, a buffer overflow condition was detected.
  if @{i}@{b}actual@{ub}@{ui} is -2, an internal error occurred (e.g.no memory)
EXAMPLE
  ...
  @{b}#include@{ub} @{"<devices/inputevent.h>" Link "include:devices/inputevent.h/Main" 0}
  @{b}#define@{ub} STIMSIZE  3 /* two dead keys, one key */
  @{FG shine}unsigned@{FG text} @{FG shine}char@{FG text} @{i}rBuffer@{ui}[STIMSIZE*2];
  ...
  @{i}KeymapBase@{ui} = (@{FG shine}struct@{FG text} @{"Library" Link "include:exec/libraries.h/Main" 34} *) OpenLibrary("keymap.library", 0);
  ...
  event.@{i}ie_NextEvent@{ui} = 0;
  event.@{i}ie_Class@{ui} = IECLASS_RAWKEY;
  event.@{i}ie_SubClass@{ui} = 0;
  /* prove keymap code completeness and MapANSI reversibility */
  @{FG shine}for@{FG text} (@{i}code@{ui} = 0; @{i}code@{ui} < 256; @{i}code@{ui}++) {
    @{i}buffer@{ui}[0] = @{i}code@{ui};
    @{i}actual@{ui} = MapANSI(@{i}buffer@{ui}, 1, @{i}rBuffer@{ui}, STIMSIZE, 0);
    @{i}r@{ui} = @{i}rBuffer@{ui};
    event.@{i}ie_Prev2DownCode@{ui} = 0;
    event.@{i}ie_Prev2DownQual@{ui} = 0;
    event.@{i}ie_Prev1DownCode@{ui} = 0;
    event.@{i}ie_Prev1DownQual@{ui} = 0;
    @{FG shine}switch@{FG text} (@{i}actual@{ui}) {
      @{FG shine}case@{FG text} -2:
        printf("MapANSI internal error");
        @{FG shine}goto@{FG text} @{b}reportChar@{ub};
      @{FG shine}case@{FG text} -1:
        printf("MapANSI overflow error");
        @{FG shine}goto@{FG text} @{b}reportChar@{ub};
      @{FG shine}case@{FG text} 0:
        printf("MapANSI ungeneratable code");
        @{FG shine}goto@{FG text} @{b}reportChar@{ub};
      @{FG shine}case@{FG text} 3:
        event.@{i}ie_Prev2DownCode@{ui} = *@{i}r@{ui}++;
        event.@{i}ie_Prev2DownQual@{ui} = *@{i}r@{ui}++;
      @{FG shine}case@{FG text} 2:
        event.@{i}ie_Prev1DownCode@{ui} = *@{i}r@{ui}++;
        event.@{i}ie_Prev1DownQual@{ui} = *@{i}r@{ui}++;
      @{FG shine}case@{FG text} 1:
        event.@{i}ie_Code@{ui} = *@{i}r@{ui}++;
        event.@{i}ie_Qualifier@{ui} = *@{i}r@{ui};
      @{i}actual@{ui} = MapRawKey(@{i}&event@{ui}, @{i}buffer@{ui}, BUFFERLEN, 0);
      @{FG shine}if@{FG text} ((@{i}actual@{ui} != 1) || (@{i}buffer@{ui}[0] != @{i}code@{ui})) {
        printf("MapANSI not reversible");
        @{FG shine}for@{FG text} (@{i}i@{ui} = 0; @{i}i@{ui} < @{i}actual@{ui}; @{i}i@{ui}++)
          ReportChar(@{i}buffer@{ui}[@{i}i@{ui}]);
        printf(" from");
@{b}reportChar@{ub}:
          ReportChar(@{i}code@{ui});
          printf("\n");
      }
    }
  }
  ...
SEE ALSO
  @{"devices/inputevent.h" Link "include:devices/inputevent.h/Main" 0}, @{"devices/keymap.h" Link "include:devices/keymap.h/Main" 0}
@EndNode
@Node "MapRawKey()" "keymap.library/MapRawKey"
@{b}@{u}MapRawKey@{uu}@{ub} -- Decode single raw key input event to an ANSI string.(V36)
  This console function converts input events of type
  IECLASS_RAWKEY to ANSI bytes, based on the keyMap, and
  places the result into the buffer.
SYNOPSIS  WORD MapRawKey( @{FG shine}struct@{FG text} @{"InputEvent" Link "include:devices/inputevent.h/Main" 198} *, STRPTR, WORD, @{FG shine}struct@{FG text} Keymap * );
  @{i}@{b}actual@{ub}@{ui} = MapRawKey(@{i}event@{ui}, @{i}buffer@{ui}, @{i}length@{ui}, @{i}keyMap@{ui})
   D0                 A0      A1      D1      A2
  @{i}event@{ui} -  an InputEvent structure pointer.The event list is not traversed.
  @{i}buffer@{ui} - a byte buffer large enough to hold all anticipated characters
    generated by this conversion.
  @{i}length@{ui} - maximum anticipation, i.e.the buffer size in bytes.
  @{i}keyMap@{ui} - a @{"KeyMap" Link "include:devices/keymap.h/Main" 22} structure pointer, or null if the default
    key map is to be used.
  @{i}@{b}actual@{ub}@{ui} - the number of characters in the buffer,
    or -1 if a buffer overflow was about to occur.
ERRORS
  if @{i}@{b}actual@{ub}@{ui} is -1, a buffer overflow condition was detected.
  Not all of the characters in the buffer are valid.
EXAMPLE
  ...
  @{b}#define@{ub} BUFFERLEN 80  /* length of longest expected mapping /*
  @{FG shine}char@{FG text} @{i}buffer@{ui}[BUFFERLEN];
  @{FG shine}struct@{FG text} InputEvent ie;
  ...
  @{i}KeymapBase@{ui} = OpenLibrary("keymap.library", 0);
  ...
  ie.@{i}ie_Class@{ui} = IECLASS_RAWKEY;
  ie.@{i}ie_SubClass@{ui} = 0;
  @{FG shine}for@{FG text} (;;) {
    WaitPort(window->@{i}UserPort@{ui});
    @{FG shine}while@{FG text} (@{i}im@{ui} = (@{FG shine}struct@{FG text} @{"IntuiMessage" Link "include:intuition/intuition.h/Main" 761} *) GetMsg(window->@{i}UserPort@{ui})) {
      @{FG shine}switch@{FG text} (im->@{i}Class@{ui}) {
        @{FG shine}case@{FG text} RAWKEY:
            ie.@{i}ie_Code@{ui} = im->@{i}Code@{ui};
            ie.@{i}ie_Qualifier@{ui} = im->@{i}Qualifier@{ui};
            /* recover dead key codes & qualifiers */
            ie.@{i}ie_EventAddress@{ui} = (APTR *) *((ULONG *)im->@{i}IAddress@{ui});
            @{i}actual@{ui} = MapRawKey(@{i}&ie@{ui}, @{i}buffer@{ui}, BUFFERLEN, 0);
            @{FG shine}for@{FG text} (@{i}i@{ui} = 0; @{i}i@{ui} < @{i}actual@{ui}; @{i}i@{ui}++)
              ReportChar(@{i}buffer@{ui}[@{i}i@{ui}]);
            @{FG shine}break@{FG text};
          ...
       }
       ...
    }
  }
SEE ALSO
  @{"devices/inputevent.h" Link "include:devices/inputevent.h/Main" 0}, @{"devices/keymap.h" Link "include:devices/keymap.h/Main" 0}
@EndNode
@Node "SetKeyMapDefault()" "keymap.library/SetKeyMapDefault"
@{b}@{u}SetKeyMapDefault@{uu}@{ub} -- Set the current default keymap.(V36)
  A pointer to key map specified is cached by the keymap library
  for use by @{"MapRawKey" Link "MapRawKey()"} and @{"MapANSI" Link "MapANSI()"} when a keymap is not specified.
SYNOPSIS  @{FG shine}void@{FG text} SetKeyMapDefault(@{FG shine}struct@{FG text} @{"KeyMap" Link "include:devices/keymap.h/Main" 21} *);
  SetKeyMapDefault(@{i}keyMap@{ui})
                    A0
  @{i}keyMap@{ui} - a pointer to a keyMap structure.
    This key map must be permanently allocated: it must remain in memory till
    the machine is reset.It is appropriate that this keyMap be a node on the
    keymap.resource list.
BUGS
  The keymap.h include file should be in the libraries/ or perhaps resources/
  directory, but is in the devices/ directory for compatability reasons.
SEE ALSO
  @{"devices/keymap.h" Link "include:devices/keymap.h/Main" 0}, @{"keymap.library/AskKeyMapDefault()" Link "AskKeyMapDefault()"},
  console.device ...KEYMAP functions
@EndNode

@Node "CreateContext()" "gadtools.library/CreateContext"
@{b}@{u}CreateContext@{uu}@{ub} -- create a place for GadTools context data.(V36)
  Creates a place for GadTools to store any context data it might need for your
  window.In reality, an unselectable invisible gadget is created, with room for
  the context data.This function also establishes the linkage from a glist type
  pointer to the individual gadget pointers.Call this function before any of the
  other gadget creation calls.
SYNOPSIS  @{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *CreateContext(@{FG shine}struct@{FG text} Gadget **);
  @{i}@{b}gad@{ub}@{ui} = CreateContext(@{i}glistpointer@{ui});
   D0                  A0
  @{i}glistptr@{ui} - address of a pointer to a Gadget, which was previously set to NULL.
    When all the gadget creation is done, you may use that pointer as your
    NewWindow.FirstGadget, or in @{"intuition.library/AddGList()" Link "intuition.guide/AddGList()"},
    @{"intuition.library/RefreshGList()" Link "intuition.guide/RefreshGList()"}, @{"FreeGadgets()" Link "FreeGadgets()"}, etc.
  @{i}@{b}gad@{ub}@{ui} - pointer to context gadget, or NULL if failure.
EXAMPLE
  @{FG shine}struct@{FG text} Gadget *@{i}gad@{ui};
  @{FG shine}struct@{FG text} Gadget *@{i}glist@{ui} = NULL;
  @{i}gad@{ui} = CreateContext(@{i}&glist@{ui});
  /*  Other creation calls go here */
  @{FG shine}if@{FG text} (@{i}gad@{ui})
  {
      myNewWindow.@{i}FirstGadget@{ui} = @{i}glist@{ui};
      @{FG shine}if@{FG text} ( @{i}myWindow@{ui} = OpenWindow(@{i}&myNewWindow@{ui}) )
      {
    GT_RefreshWindow(@{i}win@{ui},NULL);
    /* other stuff */
    CloseWindow(@{i}myWindow@{ui});
      }
  }
  FreeGadgets(@{i}glist@{ui});
@EndNode
@Node "CreateGadgetA()" "gadtools.library/CreateGadgetA"
@{b}@{u}CreateGadgetA@{uu}@{ub} -- allocate and initialize a gadtools gadget.(V36)
@{b}@{u}CreateGadget@{uu}@{ub}  -- varargs stub for CreateGadgetA().(V36)
  CreateGadgetA() allocates and initializes a new gadget of the
  specified kind, and attaches it to the previous gadget.The gadget
  is created based on the supplied kind, NewGadget structure, and tags.
SYNOPSIS
  @{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *CreateGadgetA(ULONG,@{FG shine}struct@{FG text} Gadget *, @{FG shine}struct@{FG text} @{"NewGadget" Link "include:libraries/gadtools.h/Main" 79} *,
    @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  @{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *CreateGadget (ULONG,@{FG shine}struct@{FG text} Gadget *, @{FG shine}struct@{FG text} @{"NewGadget" Link "include:libraries/gadtools.h/Main" 79} *,
    Tag, ...);
  @{i}@{b}gad@{ub}@{ui} = CreateGadgetA(@{i}kind@{ui}, @{i}previous@{ui}, @{i}newgad@{ui}, @{i}tagList@{ui})
   D0                  D0    A0         A1      A2
  @{i}@{b}gad@{ub}@{ui} = CreateGadget (@{i}kind@{ui}, @{i}previous@{ui}, @{i}newgad@{ui}, @{i}firsttag@{ui}, ...)
  @{i}kind@{ui} - kind of gadget is to be created, one of the XXX_KIND values
    defined in @{"<libraries/gadtools.h>" Link "include:libraries/gadtools.h/Main" 0}
  @{i}previous@{ui} - pointer to the previous gadget that this new gadget
    is to be attached to.This function will fail if this value is NULL
  @{i}newgad@{ui} - a filled in NewGadget structure describing the desired
    gadget's size, position, label, etc.
  @{i}tagList@{ui} - pointer to an array of tags providing optional extra
    parameters, or NULL
  @{i}@{b}gad@{ub}@{ui} - pointer to the new gadget, or NULL if the allocation failed or if
    previous was NULL.
@{"TAGS" link CREATEGADGETA_TAGS}
NOTES
  Note that the ng_VisualInfo and ng_TextAttr fields of the NewGadget
  structure  must be set to valid VisualInfo and @{"TextAttr" Link "include:graphics/text.h/Main" 65} pointers,
  or this function will fail.
  Starting with V37, string and integer gadgets have the GFLG_TABCYCLE
  feature automatically.If the user presses Tab or Shift-Tab while in a
  string or integer gadget, the next or previous one in sequence will be
  activated.You will hear an IDCMP_GADGETUP message with a code of 0x09.
  Use {GA_TabCycle, FALSE} to supress this.
SEE ALSO
  @{"FreeGadgets()" Link "FreeGadgets()"}, GT_SetGadgetAttrs(), GetVisualInfo(),
  @{"<libraries/gadtools.h>" Link "include:libraries/gadtools.h/Main" 0}
@EndNode
@node CREATEGADGETA_TAGS "CreateGadgetA_tags"
@{b}@{u}All kinds@{uu}@{ub}:
@{i}GT_Underscore@{ui} - Indicates the symbol that precedes the character in the gadget
  label to be underscored.This can be to indicate keyboard equivalents for
  gadgets (note that GadTools does not process the keys - it just displays
  the underscore).For example, to underscore the "M" in "Mode":
    ng.ng_GadgetText = "_Mode:";
    @{i}gad@{ui} = CreateGadget(..._KIND, @{i}&ng@{ui}, @{i}prev@{ui}, GT_Underscore, '_', ...);(V37)
@{b}@{u}BUTTON_KIND@{uu}@{ub} (action buttons):
@{i}GA_Immediate@{ui} (BOOL) - Hear IDCMP_GADGETDOWN events from button gadget
  (defaults to FALSE).(V39)
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget,(defaults to FALSE).(V36)
@{b}@{u}CHECKBOX_KIND@{uu}@{ub} (on/off items):
@{i}GTCB_Scaled@{ui} (BOOL) - If true, then checkbox imagery will be scaled to
  fit the gadget's width & height.Otherwise, a fixed size of
  CHECKBOXWIDTH by CHECKBOXHEIGHT will be used.(defaults to FALSE).(V39)
@{i}GTCB_Checked@{ui} (BOOL) - Initial state of checkbox (defaults to FALSE).(V36)
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget,(defaults to FALSE).
@{b}@{u}CYCLE_KIND@{uu}@{ub} (multiple state selections):
@{i}GTCY_Labels@{ui} (STRPTR *) - Pointer to NULL-terminated array of strings
  that are the choices offered by the cycle gadget.This tag is required.(V36)
@{i}GTCY_Active@{ui} (UWORD) - The ordinal number (counting from zero) of
  the initially active choice of a cycle gadget (defaults to zero).(V36)
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget,(defaults to FALSE).(V37)
@{b}@{u}LISTVIEW_KIND@{uu}@{ub} (scrolling list):
@{i}GTLV_Labels@{ui} (@{FG shine}struct@{FG text} @{"List" Link "include:exec/lists.h/Main" 20} *) - List of nodes whose ln_Name fields
  are to be displayed in the listview.(V36)
@{i}GTLV_Top@{ui} (WORD) - Top item visible in the listview.This value
  will be made reasonable if out-of-range (defaults to 0).(V36)
@{i}GTLV_MakeVisible@{ui} (WORD) - Number of an item that should be forced
  within the visible area of the listview by doing minimal scrolling.
  This tag overrides GTLV_Top.(V39)
@{i}GTLV_CallBack@{ui} (@{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *) - Callback hook for various listview operations.
  As of V39, the only callback supported is for custom rendering of individual
  items in the listview.The call back hook is called with:
    A0 - @{FG shine}struct@{FG text} Hook *
    A1 - @{FG shine}struct@{FG text} LVDrawMsg *
    A2 - @{FG shine}struct@{FG text} @{"Node" Link "include:exec/nodes.h/Main" 22} *
  The callback hook *must* check the lvdm_MethodID field of the message and
  only do processing if it equals LV_DRAW.If any other value is passed,
  the callback hook must return LVCB_UNKNOWN
@{i}GTLV_MaxPen@{ui} (UWORD) - The maximum pen number used by rendering in a custom
  rendering callback hook.This is used to optimize the rendering and scrolling
  of the listview display (default is the maximum pen number used by all of
  TEXTPEN, BACKGROUNDPEN, FILLPEN, TEXTFILLPEN, and BLOCKPEN.(V39)
@{i}GTLV_ItemHeight@{ui} (UWORD) - The exact height of an item.This is normally useful
  for listviews that use the GTLV_CallBack rendering hook (defaults to
  ng->ng_TextAttr->ta_YSize).(V39)
@{i}LAYOUTA_Spacing@{ui} (UWORD) - Extra space to place between lines of listview
  (defaults to 0).(V36)
@{i}GTLV_ScrollWidth@{ui} (UWORD) - Width of scroll bar for listview.
  Must be greater than zero (defaults to 16).(V36)
@{i}GTLV_ShowSelected@{ui} (@{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *) - NULL to have the currently selected
  item displayed beneath the listview under V37 or with a highlight bar in V39.
  If not NULL, this is a pointer to an already-created GadTools STRING_KIND
  gadget to have an editable display of the currently selected item.If the tag
  is not present, the currently selected item will not be displayed.(V36)
@{i}GTLV_Selected@{ui} (UWORD) - Ordinal number of currently selected item,
  or ~0 to have no current selection (defaults to ~0).(V36)
@{i}GTLV_ReadOnly@{ui} (BOOL) - If TRUE, then listview is read-only
  (defaults to FALSE).(V36)
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget,(defaults to FALSE).(V39)
@{b}@{u}MX_KIND@{uu}@{ub} (mutually exclusive, radio buttons):
@{i}GTMX_Labels@{ui} (STRPTR *) - Pointer to a NULL-terminated array of strings which
  are to be the labels beside each choice in a set of mutually exclusive gadgets.
  This tag is required.(V36)
@{i}GTMX_TitlePlace@{ui} - One of PLACETEXT_LEFT, PLACETEXT_RIGHT, PLACETEXT_ABOVE, or
  PLACETEXT_BELOW, indicating where the title of the gadget is to be displayed.
  Without this tag, the NewGadget.ng_GadgetText field is ignored for MX_KIND
  gadgets.(V39)
@{i}GTMX_Scaled@{ui} (BOOL) - If true, then mx gadget imagery will be scaled to fit the
  gadget's width & height.Otherwise, a fixed size of MXWIDTH by MXHEIGHT will
  be used.When setting this tag to TRUE, you should typically set the height
  of the gadget to be (ng.ng_TextAttr->ta_YSize + 1).(defaults to FALSE.) (V39)
@{i}GTMX_Spacing@{ui} (UWORD) - The amount of space between each choice of a set of
  mutually exclusive gadgets.This amount is added to the font height to
  produce the vertical shift between choices (defaults to 1).(V36)
@{i}LAYOUTA_Spacing@{ui} - FOR COMPATIBILITY ONLY.Use GTMX_Spacing instead.
  The number of extra pixels to insert between each choice of a mutually
  exclusive gadget.This is added to the present gadget image height (9) to
  produce the true spacing between choices. (defaults to FontHeight-8,
  which is zero for 8-point font users).(V36)
@{i}GTMX_Active@{ui} (UWORD) - The ordinal number (counting from zero) of the initially
   active choice of an mx gadget (defaults to 0).(V36)
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget,(defaults to FALSE).(V39)
@{b}@{u}NUMBER_KIND@{uu}@{ub} (read-only numeric):
@{i}GTNM_Format@{ui} (STRPTR) - C-Style formatting string to apply on the number before
  display.Be sure to use the 'l' (long) modifier.This string is processed using
  @{"exec.library/RawDoFmt()" Link "exec.guide/RawDoFmt()"}, so refer to that function for details.
  (defaults to "%ld") (V39)
@{i}GTNM_Number@{ui} (LONG) - A signed long integer to be displayed as a read-only number
  (defaults to 0).(V36)
@{i}GTNM_BackPen@{ui} (UBYTE) - The pen to use when rendering the background
  of the number (defaults to leaving the background untouched).(V39)
@{i}GTNM_FrontPen@{ui} (UBYTE) - The pen to use when rendering the number
  (defaults to DrawInfo->dri_Pens[TEXTPEN]).(V39)
@{i}GTNM_Border@{ui} (BOOL) - If TRUE, this flag asks for a recessed border
  to be placed around the gadget.(V36)
@{i}GTNM_MaxNumberLen@{ui} (ULONG) - Maximum number of bytes that can be generated by
  applying the GTNM_Format formatting string to the number (excluding the
  NULL terminator).(defaults to 10).(V39)
@{i}GTNM_Clipped@{ui} (BOOL) - Determine whether text should be clipped to the gadget
  dimensions (defaults to FALSE for gadgets without borders, TRUE for gadgets
  with borders).(V39)
@{i}GTNM_Justification@{ui} (UBYTE) - Determines how the number is rendered within the
  gadget box.GTJ_LEFT will make the rendering be flush with the left side
  of the gadget, GTJ_RIGHT will make it flush with the right side, and
  GTJ_CENTER will center the number within the gadget box.
  Under V39, using this tag also required using {GTNM_Clipped, TRUE}, otherwise
  the text would not show up in the gadget.@{i}This has been fixed in V40@{ui}.
  (defaults to GTJ_LEFT).(V39)
@{b}@{u}INTEGER_KIND@{uu}@{ub} (numeric entry):
@{i}GTIN_EditHook@{ui} (@{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *) - Hook to use as a custom
  integer gadget edit hook (StringExtend->EditHook) for this gadget.GadTools
  will allocate the StringExtend->WorkBuffer for you.(defaults to NULL).(V37)
@{i}GA_TabCycle@{ui} (BOOL) - Set to TRUE so that pressing <TAB> or <Shift-TAB>
  will activate the next or previous such gadget.(defaults to TRUE,
  unlike regular Intuition string gadgets which default to FALSE).(V37)
@{i}GTIN_MaxChars@{ui} (UWORD) - The maximum number of digits that the integer gadget
  is to hold (defaults to 10).(V36)
@{i}GTIN_Number@{ui} (LONG) - The initial contents of the integer gadget
  (defaults to 0).(V36)
@{i}STRINGA_Justification@{ui} - Controls the justification of the contents of an
  integer gadget.Choose one of STRINGLEFT, STRINGRIGHT, or STRINGCENTER
  (defaults to STRINGLEFT).(V37)
@{i}STRINGA_ReplaceMode@{ui} (BOOL) - If TRUE, this integer gadget is in replace-mode
  (defaults to FALSE (insert-mode)).(V37)
@{i}STRINGA_ExitHelp@{ui} (BOOL) - Set to TRUE to have the help-key cause an
 exit from the integer gadget.You will then receive an IDCMP_GADGETUP
 event with Code = 0x5F (rawkey for help).(defaults to FALSE) (V37)
@{i}GA_Immediate@{ui} (BOOL) - Hear IDCMP_GADGETDOWN events from integer gadget
  (defaults to FALSE).(V39)
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget,(defaults to FALSE).(V36)
@{b}@{u}PALETTE_KIND@{uu}@{ub} (color selection):
@{i}GTPA_Depth@{ui} (UWORD) - Number of bitplanes in the palette (defaults to 1).(V36)
@{i}GTPA_NumColors@{ui} (UWORD) - Number of colors to display in the palette gadget.
  This override GTPA_Depth and allows numbers which aren't powers of 2.
  (defaults to 2) (V39)
@{i}GTPA_ColorTable@{ui} (UBYTE *) - Pointer to a table of pen numbers
  indicating  which colors should be used and edited by the palette gadget.
  This array must contain as many entries as there are colors displayed
  in the palette gadget.The array provided with this tag must remain
  valid for the life of the gadget or until a new table is provided.
  (default is NULL, which causes a 1-to-1 mapping of pen numbers).(V39)
@{i}GTPA_ColorOffset@{ui} (UBYTE) - First color to use in palette (defaults to 0).(V36)
@{i}GTPA_Color@{ui} (UBYTE) - Initially selected color of the palette.
  This number is a pen number, and not the ordinal color number within
  the palette gadget itself.(defaults to 1).(V36)
@{i}GTPA_IndicatorWidth@{ui} (UWORD) - The desired width of the current-color indicator,
  if you want one to the left of the palette.(V36)
@{i}GTPA_IndicatorHeight@{ui} (UWORD) - The desired height of the current-color indicator,
  if you want one above the palette.(V36)
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget,(defaults to FALSE).(V36)
@{b}@{u}SCROLLER_KIND@{uu}@{ub} (for scrolling through areas or lists):
@{i}PGA_Freedom@{ui} - Whether scroller is horizontal or vertical.
  Choose LORIENT_VERT or LORIENT_HORIZ (defaults to LORIENT_HORIZ).(V36)
@{i}GTSC_Arrows@{ui} (UWORD) - Asks for arrows to be attached to the scroller.
  The value supplied will be taken as the width of each arrow button for
  a horizontal scroller, or the height of each button for a vertical
  scroller (the other dimension will match the whole scroller).(V36)
@{i}GTSC_Visible@{ui} (WORD) - Number visible in scroller (defaults to 2).(V36)
@{i}GTSC_Top@{ui} (WORD) - Top visible in area scroller represents (defaults to 0).(V36)
@{i}GTSC_Total@{ui} (WORD) - Total in area scroller represents (defaults to 0).(V36)
@{i}GA_Immediate@{ui} (BOOL) - Hear every IDCMP_GADGETDOWN event from scroller
  (defaults to FALSE).(V36)
@{i}GA_RelVerify@{ui} (BOOL) - Hear every IDCMP_GADGETUP event from scroller
  (defaults to FALSE).(V36)
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget,(defaults to FALSE).(V36)
@{b}@{u}SLIDER_KIND@{uu}@{ub} (to indicate level or intensity):
@{i}PGA_Freedom@{ui} - Set to LORIENT_VERT or LORIENT_HORIZ to have a vertical or
  horizontal slider (defaults to LORIENT_HORIZ).(V36)
@{i}GTSL_LevelFormat@{ui} (STRPTR) - C-Style formatting string for slider level.
  Be sure to use the 'l' (@{FG shine}long@{FG text}) modifier.This string is processed using
  @{"exec.library/RawDoFmt()" Link "exec.guide/RawDoFmt()"}, so refer to that function for details.
  (defaults to "%ld").(V36)
@{i}GTSL_DispFunc@{ui} ( @{FG shine}long@{FG text} (*function)(@{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, WORD) ) - Function to
  calculate level to be displayed.A number-of-colors slider might want to set
  the slider up to think depth, and have a (1 << n) function here.Defaults
  to none.Your function must take a pointer to gadget as the first parameter,
  the level (a WORD) as the second, and return the result as a LONG.(V36)
@{i}GTSL_MaxLevelLen@{ui} (UWORD) - Maximum length in characters of level string when
  rendered beside slider (defaults to 2).(V36)
@{i}GTSL_LevelPlace@{ui} - One of PLACETEXT_LEFT, PLACETEXT_RIGHT, PLACETEXT_ABOVE, or
  PLACETEXT_BELOW, indicating where the level indicator is to go relative to
  slider (default to PLACETEXT_LEFT).(V36)
@{i}GTSL_Justification@{ui} (UBYTE) - Determines how the level display is to be justified
  within its alotted space.Choose one of GTJ_LEFT, GTJ_RIGHT, or GTJ_CENTER
  (defaults to GTJ_LEFT).(V39)
@{i}GTSL_Max@{ui} (WORD) - Maximum level for slider (defaults to 15).(V36)
@{i}GTSL_Min@{ui} (WORD) - Minimum level for slider (defaults to 0).(V36)
@{i}GTSL_Level@{ui} (WORD) - Current level of slider (defaults to 0).(V36)
@{i}GTSL_MaxPixelLen@{ui} (ULONG) - Indicates the maximum pixel size used up by the level
  display for any value of the slider.This is mostly useful when dealing with
  proportional fonts.(defaults to FontWidth*MaxLevelLen).(V39)
@{i}GA_Immediate@{ui} (BOOL) - If you want to hear each slider IDCMP_GADGETDOWN event
  (defaults to FALSE).(V36)
@{i}GA_RelVerify@{ui} (BOOL) - If you want to hear each slider IDCMP_GADGETUP event
  (defaults to FALSE).(V36)
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget,(defaults to FALSE).(V36)
@{b}@{u}TEXT_KIND@{uu}@{ub} (read-only text):
@{i}GTTX_Text@{ui} - Pointer to a NULL terminated string to be displayed, as a read-only
  text-display gadget, or NULL.(defaults to NULL) (V36)
@{i}GTTX_CopyText@{ui} (BOOL) -  This flag instructs the text-display gadget to copy the
  supplied text string, instead of using only pointer to the string.This only
  works for the initial value of GTTX_Text set at CreateGadget() time.If you
  subsequently change GTTX_Text, the new text will be referenced by pointer,
  not copied.Do not use this tag with a NULL GTTX_Text.(V37)
@{i}GTTX_BackPen@{ui} (UBYTE) - The pen to use when rendering the background of the text
  (defaults to leaving the background untouched).(V39)
@{i}GTTX_FrontPen@{ui} (UBYTE) - The pen to use when rendering the text
  (defaults to DrawInfo->dri_Pens[TEXTPEN]).(V39)
@{i}GTTX_Border@{ui} (BOOL) - If TRUE, this flag asks for a recessed border to be placed
  around the gadget.(V36)
@{i}GTTX_Justification@{ui} (UBYTE) - Determines how the text is rendered within the
  gadget box.GTJ_LEFT will make the rendering be flush with the left side
  of the gadget, GTJ_RIGHT will make it flush with the right side, and
  GTJ_CENTER will center the text within the gadget box.
  Under V39, using this tag also required using {GTNM_Clipped, TRUE},
  otherwise the text would not show up in the gadget.@{i}This has been fixed in V40@{ui}.
  (defaults to GTJ_LEFT).(V39)
@{i}GTTX_Clipped@{ui} (BOOL) - Determine whether text should be clipped to the gadget
  dimensions (defaults to FALSE for gadgets without borders).(V39)
@{b}@{u}STRING_KIND@{uu}@{ub} (text-entry):
@{i}GTST_EditHook@{ui} (struct @{"Hook" Link "include:utility/hooks.h/Main" 23} *) - Hook to use as a custom string gadget
  edit hook (StringExtend->EditHook) for this gadget.GadTools will allocate
  the StringExtend->WorkBuffer for you.(defaults to NULL).(V37)
@{i}GA_TabCycle@{ui} (BOOL) - Set to TRUE so that pressing <TAB> or <Shift-TAB> will
  activate the next or previous such gadget.(defaults to TRUE, unlike regular
  Intuition string gadgets which default to FALSE).(V37)
@{i}GTST_MaxChars@{ui} (UWORD) - The maximum number of characters that the string gadget
  is to hold.(V36)
@{i}GTST_String@{ui} (STRPTR) - The initial contents of the string gadget,
  or NULL (default) if string is to start empty.(V36)
@{i}STRINGA_Justification@{ui} - Controls the justification of the contents of a string
  gadget.Choose one of STRINGLEFT, STRINGRIGHT, or STRINGCENTER
  (defaults to STRINGLEFT).(V37)
@{i}STRINGA_ReplaceMode@{ui} (BOOL) - If TRUE, this string gadget is in replace-mode
  (defaults to FALSE (insert-mode)).(V37)
@{i}STRINGA_ExitHelp@{ui} (BOOL) - Set to TRUE to have the help-key cause an exit from
  the string gadget.You will then receive an IDCMP_GADGETUP event with
  Code = 0x5F (rawkey for help).(V37)
@{i}GA_Immediate@{ui} (BOOL) - Hear IDCMP_GADGETDOWN events from string gadget
  (defaults to FALSE).(V39)
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget,(defaults to FALSE).(V36)
@endnode
@Node "CreateMenusA()" "gadtools.library/CreateMenusA"
@{b}@{u}CreateMenusA@{uu}@{ub} -- allocate and fill out a menu structure.(V36)
@{b}@{u}CreateMenus@{uu}@{ub}  -- varargs stub for CreateMenus().(V36)
  CreateMenusA() allocates and initializes a complete menu structure based on
  the supplied array of NewMenu structures.Optionally, CreateMenusA() can
  allocate and initialize a complete set of menu items and sub-items for a
  single menu title.This is dictated by the contents of the array of NewMenus.
SYNOPSIS
  @{FG shine}struct@{FG text} @{"Menu" Link "include:intuition/intuition.h/Main" 61} *CreateMenusA(@{FG shine}struct@{FG text} @{"NewMenu" Link "include:libraries/gadtools.h/Main" 110} *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  @{FG shine}struct@{FG text} @{"Menu" Link "include:intuition/intuition.h/Main" 61} *CreateMenus (@{FG shine}struct@{FG text} @{"NewMenu" Link "include:libraries/gadtools.h/Main" 110} *, Tag, ...);
  @{i}@{b}menu@{ub}@{ui} = CreateMenusA(@{i}newmenu@{ui}, @{i}tagList@{ui})
   D0                  A0       A1
  @{i}@{b}menu@{ub}@{ui} = CreateMenus(@{i}newmenu@{ui}, @{i}firsttag@{ui}, ...)
  @{i}newmenu@{ui} - pointer to an array of initialized struct NewMenus.
  @{i}tagList@{ui} - pointer to an array of tags providing optional extra parameters,
    or NULL.
  @{i}@{b}menu@{ub}@{ui} - pointer to the resulting initialized menu structure (or the resulting
    FirstItem), with all the links for menu items and subitems in place.
    The result will be NULL if CreateMenusA() could not allocate memory
    for the menus, or if the NewMenu array had an illegal arrangement
    (eg.NM_SUB following NM_TITLE).(see also the GTMN_SecondaryError tag above).
@{"TAGS" link CREATEMENUSA_TAGS}
NOTES
  The strings you supply for menu text are not copied, and must be preserved
  for the life of the menu.The resulting menus have no positional information.
  You will want to call @{"LayoutMenusA()" Link "LayoutMenusA()"} (or @{"LayoutMenuItemsA()" Link "LayoutMenuItemsA()"}) to supply that.
  CreateMenusA() automatically provides you with a UserData field
  for each menu, menu-item or sub-item.Use the GTMENU_USERDATA(menu)
  or GTMENUITEM_USERDATA(menuitem) macro to access it.
BUGS
  Prior to V39, if you put images into menus using IM_ITEM or IM_SUB for a
  NewMenu->nm_Type, the image supplied had to be an ordinary struct @{"Image" Link "include:intuition/intuition.h/Main" 700}.
  Starting with V39, you can use boopsi images.
SEE ALSO
  @{"LayoutMenusA()" Link "LayoutMenusA()"}, @{"FreeMenus()" Link "FreeMenus()"}, gadtools.h/GTMENU_USERDATA(),
  gadtools.h/GTMENUITEM_USERDATA()
@EndNode
@node CREATEMENUSA_TAGS "CreateMenusA_tags"
@{i}GTMN_FullMenu@{ui} (BOOL) - Requires that the @{"NewMenu" Link "include:libraries/gadtools.h/Main" 110} specification describes a
  complete menu strip, not a fragment.If a fragment is found, @{"CreateMenusA()" link CreateMenusA}
  will fail with a secondary error of GTMENU_INVALID.(defaults to FALSE).(V37)
@{i}GTMN_FrontPen@{ui} (UBYTE) - Pen number to be used for menu text.
  (Under V39 and higher, this tag also exists for @{"LayoutMenusA()" Link "LayoutMenusA()"}
  and @{"LayoutMenuItemsA()" link LayoutMenuItemsA()}).(defaults to zero).
@{i}GTMN_SecondaryError@{ui} (ULONG *) - Supply a pointer to a NULL-initialized ULONG
  to receive a descriptive error code.Possible values:
  GTMENU_TRIMMED - NewMenu structure has too many menus, items,or subitems
    (CreateMenusA() will succeed, returning a trimmed-down menu structure).
  GTMENU_INVALID - NewMenu structure describes an illegal
    menu.(CreateMenusA() will fail with a NULL result).
  GTMENU_NOMEM - CreateMenusA() ran out of memory.(V37)
@endnode
@Node "DrawBevelBoxA()" "gadtools.library/DrawBevelBoxA"
@{b}@{u}DrawBevelBoxA@{uu}@{ub} -- draw a bevelled box.(V36)
@{b}@{u}DrawBevelBox@{uu}@{ub}  -- varargs stub for DrawBevelBoxA().(V36)
  This function renders a bevelled box of specified dimensions
  and type into the supplied RastPort.
SYNOPSIS
  @{FG shine}void@{FG text} DrawBevelBoxA(@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, WORD, WORD, WORD, WORD,
    @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *taglist);
  @{FG shine}void@{FG text} DrawBevelBox (@{FG shine}struct@{FG text} @{"RastPort" Link "include:graphics/rastport.h/Main" 54} *, WORD, WORD, WORD, WORD,
    Tag, ...);
  DrawBevelBoxA(@{i}rport@{ui}, @{i}left@{ui}, @{i}top@{ui}, @{i}width@{ui}, @{i}height@{ui}, @{i}tagList@{ui});
                 A0     D0    D1    D2     D3      A1
  DrawBevelBox (@{i}rport@{ui}, @{i}left@{ui}, @{i}top@{ui}, @{i}width@{ui}, @{i}height@{ui}, @{i}firsttag@{ui}, ...);
  @{i}rport@{ui} - RastPort into which the box is to be drawn.
  @{i}left@{ui} - left edge of the box.
  @{i}top@{ui} - top edge of the box.
  @{i}width@{ui} - width of the box.
  @{i}height@{ui} - height of the box.
  @{i}tagList@{ui} - pointer to an array of tags providing extra parameters
@{"TAGS" link DRAWBEVELBOXA_TAGS}
NOTES
  DrawBevelBox() is a rendering operation, not a gadget.That means you must
  refresh it at the appropriate time, like any other rendering operation.
SEE ALSO
  @{"GetVisualInfoA()" Link "GetVisualInfoA()"}, @{"<libraries/gadtools.h>" Link "include:libraries/gadtools.h/Main" 0}
@EndNode
@node DRAWBEVELBOXA_TAGS "DrawBevelBoxA_tags"
@{i}GTBB_Recessed@{ui} (BOOL) - Set to anything for a recessed-looking box.
  If absent, the box defaults, it would be raised.(V36)
@{i}GTBB_FrameType@{ui} (ULONG) - Determines what kind of box this function renders.
  BBFT_BUTTON generates a box like what is used around GadTools BUTTON_KIND gadgets.
  BBFT_RIDGE  generates a box like what is used around GadTools STRING_KIND gadgets.
  BBFT_ICONDROPBOX generates a box suitable for a standard icon drop box imagery.
  (defaults to BBFT_BUTTON).(V39)
@{i}GT_VisualInfo@{ui} (APTR) - You @{b}MUST@{ub} supply the value you obtained from an earlier
  call to @{"GetVisualInfoA()" Link "GetVisualInfoA()"} with this tag.(V36)
@endnode
@Node "FreeGadgets()" "gadtools.library/FreeGadgets"
@{b}@{u}FreeGadgets@{uu}@{ub} -- free a linked list of gadgets.(V36)
  Frees any GadTools gadgets found on the linked list of gadgets
  beginning with the specified one.Frees all the memory that was
  allocated by @{"CreateGadgetA()" Link "CreateGadgetA()"}.This function will return safely
  with no action if it receives a NULL parameter.
SYNOPSIS  @{FG shine}void@{FG text} FreeGadgets(@{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *glist);
  FreeGadgets(@{i}glist@{ui})
               A0
  @{i}glist@{ui} - pointer to first gadget in list to be freed.
SEE ALSO
  @{"CreateGadgetA()" Link "CreateGadgetA()"}
@EndNode
@Node "FreeMenus()" "gadtools.library/FreeMenus"
@{b}@{u}FreeMenus@{uu}@{ub} -- frees memory allocated by @{"CreateMenusA()" Link "CreateMenusA()"}.(V36)
  Frees the menus allocated by @{"CreateMenusA()" Link "CreateMenusA()"}.It is safe to
  call this function with a NULL parameter.
SYNOPSIS  @{FG shine}void@{FG text} FreeMenus(@{FG shine}struct@{FG text} @{"Menu" Link "include:intuition/intuition.h/Main" 61} *);
  FreeMenus(@{i}menu@{ui})
             A0
  @{i}menu@{ui} - pointer to menu structure (or first MenuItem) obtained
    from @{"CreateMenusA()" Link "CreateMenusA()"}.
SEE ALSO
  @{"CreateMenusA()" Link "CreateMenusA()"}
@EndNode
@Node "FreeVisualInfo()" "gadtools.library/FreeVisualInfo"
@{b}@{u}FreeVisualInfo@{uu}@{ub} -- return any resources taken by GetVisualInfo.(V36)
  FreeVisualInfo() returns any memory or other resources that
  were allocated by @{"GetVisualInfoA()" Link "GetVisualInfoA()"}.You should only call this function
  once you are done with using the gadgets (i.e.after @{"CloseWindow()" Link "intuition.guide/CloseWindow()"}),
  but while the screen is still valid (i.e.before @{"CloseScreen()" Link "intuition.guide/CloseScreen()"} or
  @{"UnlockPubScreen()" Link "intuition.guide/UnlockPubScreen()"}).
SYNOPSIS  @{FG shine}void@{FG text} FreeVisualInfo(APTR);
  FreeVisualInfo(@{i}vi@{ui})
                  A0
  @{i}vi@{ui} - pointer that was obtained by calling @{"GetVisualInfoA()" Link "GetVisualInfoA()"}.
    This value may be NULL.
SEE ALSO
  @{"GetVisualInfoA()" Link "GetVisualInfoA()"}
@EndNode
@Node "GetVisualInfoA()" "gadtools.library/GetVisualInfoA"
@{b}@{u}GetVisualInfoA@{uu}@{ub} -- get information GadTools needs for visuals.(V36)
@{b}@{u}GetVisualInfo@{uu}@{ub}  -- varargs stub for GetVisualInfoA().(V36)
  Get a pointer to a (private) block of data containing various bits of
  information that GadTools needs to ensure the best quality visuals.
  Use the result in the @{"NewGadget" Link "include:libraries/gadtools.h/Main" 79} structure of any gadget you create, or
  as a parameter to the various menu calls.Once the gadgets/menus are
  no longer needed (after the last CloseWindow), call @{"FreeVisualInfo()" Link "FreeVisualInfo()"}.
SYNOPSIS
  APTR @{i}vi@{ui} = GetVisualInfoA(@{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 97} *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  APTR @{i}vi@{ui} = GetVisualInfo (@{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 97} *, Tag, ...);
  @{i}@{b}vi@{ub}@{ui} = GetVisualInfoA(@{i}screen@{ui}, @{i}tagList@{ui})
   D0                  A0      A1
  @{i}@{b}vi@{ub}@{ui} = GetVisualInfo (@{i}screen@{ui}, @{i}firsttag@{ui}, ...)
  @{i}screen@{ui} - pointer to the screen you will be opening on.This parameter
    may be NULL, in which case this function fails.
  @{i}tagList@{ui} - pointer to an array of tags providing optional extra
    parameters, or NULL.
  @{i}@{b}vi@{ub}@{ui} - pointer to private data, or NULL for failure
TAGS
  There are currently no tags defined for this function.
SEE ALSO
  @{"FreeVisualInfo()" Link "FreeVisualInfo()"}, @{"intuition/LockPubScreen()" Link "intuition.guide/LockPubScreen()"}, @{"intuition/UnlockPubScreen()" Link "intuition.guide/UnlockPubScreen()"}
@EndNode
@Node "GT_BeginRefresh()" "gadtools.library/GT_BeginRefresh"
@{b}@{u}GT_BeginRefresh@{uu}@{ub} -- begin refreshing friendly to GadTools.(V36)
  Invokes the @{"intuition.library/BeginRefresh()" Link "intuition.guide/BeginRefresh()"} function in a manner
  friendly to the @{"Gadget" Link "include:intuition/intuition.h/Main" 215} Toolkit.This function call permits the
  GadTools gadgets to refresh themselves at the correct time.
  Call @{"GT_EndRefresh()" Link "GT_EndRefresh()"} function when done.
SYNOPSIS  @{FG shine}void@{FG text} GT_BeginRefresh(@{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *);
  GT_BeginRefresh(@{i}win@{ui})
                   A0
  @{i}win@{ui} - pointer to Window structure for which a IDCMP_REFRESHWINDOW
    IDCMP event was received.
NOTES
  The nature of GadTools precludes the use of the IDCMP flag WFLG_NOCAREREFRESH.
  You must handle IDCMP_REFRESHWINDOW events in at least the minimal way, namely:
    @{FG shine}case@{FG text} IDCMP_REFRESHWINDOW:
      GT_BeginRefresh(@{i}win@{ui});
      GT_EndRefresh(@{i}win@{ui}, TRUE);
      @{FG shine}break@{FG text};
SEE ALSO
  @{"intuition.library/BeginRefresh()" Link "intuition.guide/BeginRefresh()"}
@EndNode
@Node "GT_EndRefresh()" "gadtools.library/GT_EndRefresh"
@{b}@{u}GT_EndRefresh@{uu}@{ub} -- end refreshing friendly to GadTools.(V36)
  Invokes the @{"intuition.library/EndRefresh()" Link "intuition.guide/EndRefresh()"} function in a manner
  friendly to the @{"Gadget" Link "include:intuition/intuition.h/Main" 215} Toolkit.This function call permits
  GadTools gadgets to refresh themselves at the correct time.
  Call this function to @{"EndRefresh()" Link "intuition.guide/EndRefresh()"} when you have used
  @{"GT_BeginRefresh()" Link "GT_BeginRefresh()"}.
SYNOPSIS @{FG shine}void@{FG text} GT_EndRefresh(@{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, BOOL @{i}complete@{ui});
  GT_EndRefresh(@{i}win@{ui}, @{i}complete@{ui})
                 A0   D0
  @{i}win@{ui} - pointer to Window structure for which a IDCMP_REFRESHWINDOW
    IDCMP event was received.
  @{i}complete@{ui} - TRUE when done with refreshing.
SEE ALSO
  @{"intuition.library/EndRefresh()" Link "intuition.guide/EndRefresh()"}
@EndNode
@Node "GT_FilterIMsg()" "gadtools.library/GT_FilterIMsg"
@{b}@{u}GT_FilterIMsg@{uu}@{ub} -- filter an IntuiMessage through GadTools.(V36)
@{b}NOTE WELL@{ub}:@{i}Extremely few programs will actually need this function.
  You almost certainly should be using @{"GT_GetIMsg()" Link "GT_GetIMsg()"} and @{"GT_ReplyIMsg()" Link "GT_ReplyIMsg()"}
  only, and not GT_FilterIMsg() and @{"GT_PostFilterIMsg()" Link "GT_PostFilterIMsg()"}.@{ui}
  GT_FilterIMsg() takes the supplied IntuiMessage and asks the @{"Gadget" Link "include:intuition/intuition.h/Main" 215}
  Toolkit to consider and possibly act on it.Returns NULL if the message was
  only of significance to a GadTools gadget (i.e.not to you), else returns a
  pointer to a modified IDCMP message, which may contain additional information.
  You should examine the Class, Code, and IAddress fields of the returned message
  to learn what happened.Do not make interpretations based on the original imsg.
  You should use @{"GT_PostFilterIMsg()" Link "GT_PostFilterIMsg()"} to revert to the original
  IntuiMessage once you are done with the modified one.
SYNOPSIS  @{FG shine}struct@{FG text} @{"IntuiMessage" Link "include:intuition/intuition.h/Main" 764} *GT_FilterIMsg(@{FG shine}struct@{FG text} IntuiMessage *);
  @{i}@{b}modimsg@{ub}@{ui} = GT_FilterIMsg(@{i}imsg@{ui})
   D0                      A1
  @{i}imsg@{ui} - an IntuiMessage you obtained from a Window's UserPort.
  @{i}@{b}modimsg@{ub}@{ui} - a modified IntuiMessage, possibly with extra information
    from GadTools, or NULL.When NULL, the message passed in to
    the function should be sent back to Intuition via @{"ReplyMsg()" Link "exec.guide/ReplyMsg()"}
NOTES
  Starting with V39, this function actually expects and returns
  pointers to ExtIntuiMessage structures, but the prototype was not
  changed for source code compatibility with older software.
@{b}WARNING@{ub}
  If this function returns NULL, you must call ReplyMsg() on the
  IntuiMessage you passed in to GT_FilterIMsg().That is, if the
  message was processed by the toolkit you must reply this message
  to Intuition since gadtools will not do this automatically.
SEE ALSO
  @{"GT_GetIMsg()" Link "GT_GetIMsg()"}, @{"GT_PostFilterIMsg()" Link "GT_PostFilterIMsg()"}
@EndNode
@Node "GT_GetGadgetAttrsA()" "gadtools.library/GT_GetGadgetAttrsA"
@{b}@{u}GT_GetGadgetAttrsA@{uu}@{ub} -- request the attributes of a GadTools gadget.(V39)
@{b}@{u}GT_GetGadgetAttrs@{uu}@{ub}  -- varargs stub for GT_GetGadgetAttrsA().(V39)
  Retrieve the attributes of the specified gadget, according to the
  attributes chosen in the tag list.For each entry in the tag list,
  ti_Tag identifies the attribute, and ti_Data is a pointer to
  the long variable where you wish the result to be stored.
SYNOPSIS
  @{FG shine}long@{FG text} GT_GetGadgetAttrsA(@{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *,@{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *,
    @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  @{FG shine}long@{FG text} GT_GetGadgetAttrs (@{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *,@{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *,
    Tag, ...);
  @{i}@{b}numProcessed@{ub}@{ui} = GT_GetGadgetAttrsA(@{i}gad@{ui}, @{i}win@{ui}, @{i}req@{ui}, @{i}taglist@{ui})
                                     A0   A1   A2    A3
  @{i}@{b}numProcessed@{ub}@{ui} = GT_GetGadgetAttrs (@{i}gad@{ui}, @{i}win@{ui}, @{i}req@{ui}, @{i}firsttag@{ui}, ...)
  @{i}gad@{ui} - pointer to the gadget in question.May be NULL, in which case
    this function returns 0
  @{i}win@{ui} - pointer to the window containing the gadget.
  @{i}req@{ui} - reserved for future use, should always be NULL
  @{i}taglist@{ui} - pointer to @{"TagItem" Link "include:utility/tagitem.h/Main" 31} list.
  @{i}@{b}numProcessed@{ub}@{ui} - the number of attributes successfully filled in.
@{"TAGS" link GT_GETGADGETATTRSA_TAGS}(V39)
EXAMPLE
    @{FG shine}long@{FG text} @{i}top@{ui} = 0,@{i}selected@{ui} = 0,@{i}result@{ui};
    @{i}result@{ui} = GT_GetGadgetAttrs( @{i}listview_gad@{ui}, @{i}win@{ui}, NULL,GTLV_Top, @{i}&top@{ui},
      GTLV_Selected, @{i}&selected@{ui},TAG_DONE );
    @{FG shine}if@{FG text} ( @{i}result@{ui} != 2 )
    {
      printf( "Something's wrong!" );
    }
@{b}WARNING@{ub}
  The pointers you provide within the tag list to store the return values
  @{b}MUST POINT TO LONGWORDS@{ub}.That is, even if the type of a return value is
  defined as (UWORD *), you must pass a pointer to a longword of memory.
SEE ALSO
  GT_SetGadgetAttrs()
@EndNode
@node GT_GETGADGETATTRSA_TAGS "GT_GetGadgetAttrsA_tags"
@{b}@{u}BUTTON_KIND@{uu}@{ub}:
  @{i}GA_Disabled@{ui} (BOOL) - TRUE if this gadget is disabled.
@{b}@{u}CHECKBOX_KIND@{uu}@{ub}:
  @{i}GTCB_Checked@{ui} (BOOL) - TRUE if this gadget is currently checked.
  @{i}GA_Disabled@{ui} (BOOL) - TRUE if this gadget is disabled.
@{b}@{u}CYCLE_KIND@{uu}@{ub}:
  @{i}GTCY_Labels@{ui} (STRPTR *) - The NULL-terminated array of strings that are the
    choices offered by the cycle gadget.
  @{i}GTCY_Active@{ui} (UWORD) - The ordinal number (counting from zero) of the active
    choice of a cycle gadget.
  @{i}GA_Disabled@{ui} (BOOL) - TRUE if this gadget is disabled.
@{b}@{u}LISTVIEW_KIND@{uu}@{ub}:
  @{i}GTLV_Labels@{ui} (struct @{"List" Link "include:exec/lists.h/Main" 20} *) - The list of nodes whose ln_Name fields
    are displayed in the listview.
  @{i}GTLV_Top@{ui} (WORD) - Ordinal number of the top item visible in the listview.
  @{i}GTLV_Selected@{ui} (UWORD) - Ordinal number of currently selected item.
    Returns ~0 if no item is selected.
  @{i}GA_Disabled@{ui} (BOOL) - TRUE if this gadget is disabled.
@{b}@{u}MX_KIND@{uu}@{ub}:
  @{i}GTMX_Active@{ui} (UWORD) - The ordinal number (counting from zero) of the active
    choice of an mx gadget.
  @{i}GA_Disabled@{ui} (BOOL) - TRUE if this gadget is disabled.
@{b}@{u}NUMBER_KIND@{uu}@{ub}:
  @{i}GTNM_Number@{ui} - The signed long integer that is displayed in the read-only number.
@{b}@{u}INTEGER_KIND@{uu}@{ub}:
  @{i}GTIN_Number@{ui} (ULONG) - The contents of the integer gadget.
  @{i}GA_Disabled@{ui} (BOOL) - TRUE if this gadget is disabled.
@{b}@{u}PALETTE_KIND@{uu}@{ub}:
  @{i}GTPA_ColorTable@{ui} (UBYTE *) - Pointer to a table of pen numbers indicating
    which colors should be used and edited by the palette gadget.
    May be NULL, which causes a 1-to-1 mapping of pen numbers.
  @{i}GTPA_ColorOffset@{ui} (UBYTE) - First color used in palette.
  @{i}GTPA_Color@{ui} (UBYTE) - The selected color of the palette.
  @{i}GA_Disabled@{ui} (BOOL) - TRUE if this gadget is disabled.
@{b}@{u}SCROLLER_KIND@{uu}@{ub}:
  @{i}GTSC_Visible@{ui} (WORD) - Number visible in scroller.
  @{i}GTSC_Top@{ui} (WORD) - Top visible in scroller.
  @{i}GTSC_Total@{ui} (WORD) - Total in scroller area.
  @{i}GA_Disabled@{ui} (BOOL) - TRUE if this gadget is disabled.
@{b}@{u}SLIDER_KIND@{uu}@{ub}:
  @{i}GTSL_Max@{ui} (WORD) - Maximum level for slider.
  @{i}GTSL_Min@{ui} (WORD) - Minimum level for slider.
  @{i}GTSL_Level@{ui} (WORD) - Current level of slider.
  @{i}GA_Disabled@{ui} (BOOL) - TRUE if this gadget is disabled.
@{b}@{u}TEXT_KIND@{uu}@{ub}:
  @{i}GTTX_Text@{ui} - Pointer to the string to be displayed in the read-only
    text-display gadget.
@{b}@{u}STRING_KIND@{uu}@{ub}:
  @{i}GTST_String@{ui} (STRPTR) - Returns a pointer to the string gadget's buffer.
  @{i}GA_Disabled@{ui} (BOOL) - TRUE if this gadget is disabled.
@endnode
@Node "GT_GetIMsg()" "gadtools.library/GT_GetIMsg"
@{b}@{u}GT_GetIMsg@{uu}@{ub} -- get an IntuiMessage, with GadTools processing.(V36)
  Use GT_GetIMsg() in place of the usual @{"exec.library/GetMsg()" Link "exec.guide/GetMsg()"} when reading
  IntuiMessages from your window's UserPort.If needed, the GadTools dispatcher
  will be invoked, and suitable processing will be done for gadget actions.
  This function returns a pointer to a modified IntuiMessage (which is a copy
  of the original, possibly with some supplementary information from GadTools).
  If there are no messages (or if the only messages are meaningful
  only to GadTools, NULL will be returned.
SYNOPSIS  @{FG shine}struct@{FG text} @{"IntuiMessage" Link "include:intuition/intuition.h/Main" 764} *GT_GetIMsg(@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *);
  @{i}@{b}imsg@{ub}@{ui} = GT_GetIMsg(@{i}intuiport@{ui})
   D0                A0
  @{i}intuiport@{ui} - the Window->UserPort of a window that is using the
    @{"Gadget" Link "include:intuition/intuition.h/Main" 215} Toolkit.
  @{i}@{b}imsg@{ub}@{ui} - pointer to modified IntuiMessage, or NULL if there are
    no applicable messages.
NOTES
  Be sure to use @{"GT_ReplyIMsg()" Link "GT_ReplyIMsg()"} and not @{"exec.library/ReplyMsg()" Link "exec.guide/ReplyMsg()"} on
  messages obtained with GT_GetIMsg().
  If you intend to do more with the resulting message than read its fields,
  act on it, and reply it, you may find @{"GT_FilterIMsg()" Link "GT_FilterIMsg()"} more appropriate.
  Starting with V39, this function actually returns a pointer to an
  ExtIntuiMessage structure, but the prototype was not changed for
  source code compatibility with older software.
SEE ALSO
  @{"GT_ReplyIMsg()" Link "GT_ReplyIMsg()"}, @{"GT_FilterIMsg()" Link "GT_FilterIMsg()"}
@EndNode
@Node "GT_PostFilterIMsg()" "gadtools.library/GT_PostFilterIMsg"
@{b}@{u}GT_PostFilterIMsg@{uu}@{ub} -- return the unfiltered message after @{"GT_FilterIMsg()" Link "GT_FilterIMsg()"}
  was called, and clean up.(V36)
@{b}NOTE WELL@{ub}:@{i}Extremely few programs will actually need this function.
  You almost certainly should be using @{"GT_GetIMsg()" Link "GT_GetIMsg()"} and @{"GT_ReplyIMsg()" Link "GT_ReplyIMsg()"}
  only, and not GT_FilterIMsg() and GT_PostFilterIMsg().@{ui}
  Performs any clean-up necessitated by a previous call to GT_FilterIMsg().
  The original IntuiMessage is now yours to handle.Do not interpret the
  fields of the original IntuiMessage, but rather use only the one you got
  from GT_FilterIMsg().You may only do message related things at this point,
  such as queueing it up or replying it.Since you got the message with
  @{"exec.library/GetMsg()" Link "exec.guide/GetMsg()"}, your responsibilities do include replying it with
  @{"exec.library/ReplyMsg()" Link "exec.guide/ReplyMsg()"}.This function may be safely called with a NULL
  parameter.
SYNOPSIS  @{FG shine}struct@{FG text} @{"IntuiMessage" Link "include:intuition/intuition.h/Main" 764} *GT_PostFilterIMsg(@{FG shine}struct@{FG text} IntuiMessage *);
  @{i}@{b}imsg@{ub}@{ui} = GT_PostFilterIMsg(@{i}modimsg@{ui})
   D0                       A1
  @{i}modimsg@{ui} - a modified IntuiMessage obtained with GT_FilterIMsg(),
    or NULL in which case this function does nothing and returns NULL
  @{i}@{b}imsg@{ub}@{ui} - a pointer to the original IntuiMessage, if GT_FilterIMsg()
    returned non-NULL.
NOTES
  Be sure to use @{"exec.library/ReplyMsg()" Link "exec.guide/ReplyMsg()"} on the original IntuiMessage
  you obtained with @{"GetMsg()" Link "exec.guide/GetMsg()"}, (which is the what you passed to
  GT_FilterIMsg(), and not on the parameter of this function.
  Starting with V39, this function actually expects and returns
  pointers to ExtIntuiMessage structures, but the prototype was not
  changed for source code compatibility with older software.
SEE ALSO
  @{"GT_FilterIMsg()" Link "GT_FilterIMsg()"}
@EndNode
@Node "GT_RefreshWindow()" "gadtools.library/GT_RefreshWindow"
@{b}@{u}GT_RefreshWindow@{uu}@{ub} -- refresh all GadTools gadgets in a window.(V36)
  Perform the initial refresh of all the GadTools gadgets you have
  created.After you have opened your window, you must call this
  function.Or, if you have opened your window without gadgets,
  you add the gadgets with @{"intuition.library/AddGList()" Link "intuition.guide/AddGList()"},
  refresh them using @{"intuition.library/RefreshGList()" Link "intuition.guide/RefreshGList()"}, then call
  this function.
  You should not need this function at other times.
SYNOPSIS  @{FG shine}void@{FG text} GT_RefreshWindow(@{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *);
  GT_RefreshWindow(@{i}win@{ui}, @{i}req@{ui})
                    A0   A1
  @{i}win@{ui} - pointer to the Window containing GadTools gadgets.
  @{i}req@{ui} - reserved for future use, should always be NULL
SEE ALSO
  @{"GT_BeginRefresh()" Link "GT_BeginRefresh()"}
@EndNode
@Node "GT_ReplyIMsg()" "gadtools.library/GT_ReplyIMsg"
@{b}@{u}GT_ReplyIMsg@{uu}@{ub} -- reply a message obtained with GT_GetIMsg().(V36)
  Reply a modified IntuiMessage obtained with GT_GetIMsg().
  If you use @{"GT_GetIMsg()" Link "GT_GetIMsg()"}, use this function where you would normally
  have used @{"exec.library/ReplyMsg()" Link "exec.guide/ReplyMsg()"}.
  You may safely call this routine with a NULL pointer (nothing will be done).
SYNOPSIS  @{FG shine}void@{FG text} GT_ReplyIMsg(@{FG shine}struct@{FG text} @{"IntuiMessage" Link "include:intuition/intuition.h/Main" 764} *);
  GT_ReplyIMsg(@{i}imsg@{ui})
                A1
  @{i}imsg@{ui} - a modified IntuiMessage obtained with GT_GetIMsg(), or NULL
    in which case this function does nothing
NOTES
  When using GadTools, you @{b}MUST@{ub} explicitly GT_ReplyIMsg()
  all messages you receive.You cannot depend on @{"CloseWindow()" Link "intuition.guide/CloseWindow()"}
  to handle messages you have not replied.
  Starting with V39, this function actually expects a pointer to an
  ExtIntuiMessage structure, but the prototype was not changed for
  source code compatibility with older software.
SEE ALSO
  @{"GT_GetIMsg()" Link "GT_GetIMsg()"}
@EndNode
@Node "GT_SetGadgetAttrsA()" "gadtools.library/GT_SetGadgetAttrsA"
@{b}@{u}GT_SetGadgetAttrsA@{uu}@{ub} -- change the attributes of a GadTools gadget.(V36)
@{b}@{u}GT_SetGadgetAttrs@{uu}@{ub}  -- varargs stub for GT_SetGadgetAttrsA().(V36)
  Change the attributes of the specified gadget, according to the
  attributes chosen in the tag list.If an attribute is not provided
  in the tag list, its value remains unchanged.
SYNOPSIS
  @{FG shine}void@{FG text} GT_SetGadgetAttrsA(@{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *,@{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *,
    @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  @{FG shine}void@{FG text} GT_SetGadgetAttrs (@{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *,@{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *,
    Tag, ...);
  GT_SetGadgetAttrsA(@{i}gad@{ui}, @{i}win@{ui}, @{i}req@{ui}, @{i}tagList@{ui})
                      A0   A1   A2    A3
  GT_SetGadgetAttrs (@{i}gad@{ui}, @{i}win@{ui}, @{i}req@{ui}, @{i}firsttag@{ui}, ...)
  @{i}gad@{ui} - pointer to the gadget in question.Starting with V39, this
    value may be NULL in which case this function does nothing
  @{i}win@{ui} - pointer to the window containing the gadget.Starting with V39,
    this value may be NULL in which case the internal attributes of
    the gadgets are altered but no rendering occurs.
  @{i}req@{ui} - reserved for future use, should always be NULL
  @{i}tagList@{ui} - pointer to an array of tags providing optional extra
    parameters, or NULL.
@{"TAGS" link GT_SETGADGETATTRSA_TAGS}
NOTES
  This function may not be called inside of a @{"GT_BeginRefresh()" Link "GT_BeginRefresh()"} /
  @{"GT_EndRefresh()" Link "GT_EndRefresh()"} session.(As always, restrict yourself to simple
  rendering functions).
@EndNode
@node GT_SETGADGETATTRSA_TAGS "GT_SetGadgetAttrsA_tags"
@{b}@{u}BUTTON_KIND@{uu}@{ub}:(V36)
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget.
@{b}@{u}CHECKBOX_KIND@{uu}@{ub}:(V36)
@{i}GTCB_Checked@{ui} (BOOL) - State of checkbox.
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget.
@{b}@{u}CYCLE_KIND@{uu}@{ub}:
@{i}GTCY_Labels@{ui} (STRPTR *) - Pointer to NULL-terminated array of strings that are
    the choices offered by the cycle gadget.(V37)
@{i}GTCY_Active@{ui} (UWORD) - The ordinal number (counting from zero) of the active
  choice of a cycle gadget.(V36)
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget.(V37)
@{b}@{u}LISTVIEW_KIND@{uu}@{ub}:
@{i}GTLV_Labels@{ui} (struct @{"List" Link "include:exec/lists.h/Main" 20} *) - List of nodes whose ln_Name fields
  are to be displayed in the listview.Use a value of ~0 to
  "detach" your List from the display.You must detach your list
  before modifying the List structure, since GadTools reserves
  the right to traverse it on another task's schedule.When you
  are done, attach the list by using the tag pair {GTLV_Labels, list}.(V36)
@{i}GTLV_Top@{ui} (WORD) - Top item visible in the listview.This value
  will be made reasonable if out-of-range.(V36)
@{i}GTLV_MakeVisible@{ui} (WORD) - Number of an item that should be forced
  within the visible area of the listview by doing minimal scrolling.
  This tag overrides GTLV_Top.(V39)
@{i}GTLV_Selected@{ui} (UWORD) - Ordinal number of currently selected item.
  Starting with V39, you can provide ~0 to cause the currently
  selected item to be deselected.(V36)
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget.(V39)
@{b}@{u}MX_KIND@{uu}@{ub}:
@{i}GTMX_Active@{ui} (UWORD) - The ordinal number (counting from zero) of the active
  choice of an mx gadget.(V36)
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget.(V39)
@{b}@{u}NUMBER_KIND@{uu}@{ub}:(V39)
@{i}GTNM_BackPen@{ui} (UBYTE) - The pen to use when rendering the background of the
  number.
@{i}GTNM_FrontPen@{ui} (UBYTE) - The pen to use when rendering the number.
@{i}GTNM_Justification@{ui} (UBYTE) - Determines how the number is rendered
  within the gadget box.GTJ_LEFT will make the rendering be
  flush with the left side of the gadget, GTJ_RIGHT will make it
  flush with the right side, and GTJ_CENTER will center the number
  within the gadget box.
@{i}GTNM_Format@{ui} (STRPTR) - C-Style formatting string to apply on the number
  before display.Be sure to use the 'l' (@{FG shine}long@{FG text}) modifier.This string
  is processed using @{"exec.library/RawDoFmt()" Link "exec.guide/RawDoFmt()"}, so refer to that
  function for details.
@{i}GTNM_Number@{ui} (@{FG shine}long@{FG text}) - A signed long integer to be displayed in the number
  gadget.(V36)
@{b}@{u}INTEGER_KIND@{uu}@{ub}:(V36)
@{i}GTIN_Number@{ui} (ULONG) - New value of the integer gadget. 
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget.
@{b}@{u}PALETTE_KIND@{uu}@{ub}:
@{i}GTPA_ColorTable@{ui} (UBYTE *) - Pointer to a table of pen numbers indicating  which
  colors should be used and edited by the palette gadget.This array must contain
  as many entries as there are colors displayed in the palette gadget.The array
  provided with this tag must remain valid for the life of the gadget or until a
  new table is provided.A NULL table pointer causes a 1-to-1 mapping of pen
  numbers.(V39)
@{i}GTPA_ColorOffset@{ui} (UBYTE) - First color to use in palette (V39)
@{i}GTPA_Color@{ui} (UBYTE) - Selected color of the palette.This number is a pen number,
  and not the ordinal color number within the palette gadget itself.(V36)
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget.(V36)
@{b}@{u}SCROLLER_KIND@{uu}@{ub}:(V36)
@{i}GTSC_Visible@{ui} (WORD) - Number visible in scroller.
@{i}GTSC_Top@{ui} (WORD) - Top visible in scroller.
@{i}GTSC_Total@{ui} (WORD) - Total in scroller area.
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget.
@{b}@{u}SLIDER_KIND@{uu}@{ub}:
@{i}GTSL_LevelFormat@{ui} (STRPTR) - C-Style formatting string for slider level.
  Be sure to use the 'l' (@{FG shine}long@{FG text}) modifier.This string is processed using
  @{"exec.library/RawDoFmt()" Link "exec.guide/RawDoFmt()"}, so refer to that function for details.(V39)
@{i}GTSL_DispFunc@{ui} ( @{FG shine}long@{FG text} (*function)(@{FG shine}struct@{FG text} @{"Gadget" Link "include:intuition/intuition.h/Main" 215} *, WORD) ) - Function to calculate
  level to be displayed.A number-of-colors slider might want to set the slider
  up to think depth, and have a (1 << n) function here.Your function must take a
  pointer to gadget as the first parameter, the level (a WORD) as the second,
  and return the result as a @{FG shine}long@{FG text}.(V39)
@{i}GTSL_Max@{ui} (WORD) - Maximum level for slider.(V36)
@{i}GTSL_Min@{ui} (WORD) - Minimum level for slider.(V36)
@{i}GTSL_Justification@{ui} (UBYTE) - Determines how the level display is to be justified
  within its alotted space.Choose one of GTJ_LEFT,GTJ_RIGHT, or GTJ_CENTER.(V39)
@{i}GTSL_Level@{ui} (WORD) - Current level of slider.(V36)
@{i}GA_Disabled@{ui} (BOOL) - Set to TRUE to disable gadget.(V36)
@{b}@{u}TEXT_KIND@{uu}@{ub}:(V39)
@{i}GTTX_BackPen@{ui}  (UBYTE) - The pen to use when rendering the background
  of the text.
@{i}GTTX_FrontPen@{ui} (UBYTE) - The pen to use when rendering the text.
@{i}GTTX_Justification@{ui} (UBYTE) - Determines how the text is rendered within the
  gadget box.GTJ_LEFT will make the rendering be flush with the left side
  of the gadget, GTJ_RIGHT will make it flush with the right side,
  and GTJ_CENTER will center the text within the gadget box.
@{i}GTTX_Text@{ui} - New NULL terminated string to be displayed in the text
  gadget.NULL means to clear the gadget.(V36)
@{b}@{u}STRING_KIND@{uu}@{ub}:(V36)
@{i}GTST_String@{ui} (STRPTR) - New contents of the string gadget,
  or NULL to reset the gadget to the empty state.
@{i}GA_Disabled@{ui}@{i}@{ui} (BOOL) - Set to TRUE to disable gadget.
@endnode
@Node "LayoutMenuItemsA()" "gadtools.library/LayoutMenuItemsA"
@{b}@{u}LayoutMenuItemsA@{uu}@{ub} -- position all the menu items.(V36)
@{b}@{u}LayoutMenuItems@{uu}@{ub}  -- varargs stub for LayoutMenuItemsA().(V36)
  Lays out all the menu items and sub-items according to the supplied visual
  information and tag parameters.You would use this if you used @{"CreateMenusA()" Link "CreateMenusA()"}
  to make a single menu-pane (with sub-items, if any), instead of a whole menu
  strip.This routine attempts to columnize and/or shift the MenuItems in the
  event that a menu would be too tall or too wide.
SYNOPSIS
  BOOL LayoutMenuItemsA(@{FG shine}struct@{FG text} @{"MenuItem" Link "include:intuition/intuition.h/Main" 89} *, APTR, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  BOOL LayoutMenuItems (@{FG shine}struct@{FG text} @{"MenuItem" Link "include:intuition/intuition.h/Main" 89} *, APTR, Tag, ...);
  @{i}@{b}success@{ub}@{ui} = LayoutMenuItemsA(@{i}menuitem@{ui}, @{i}vi@{ui}, @{i}tagList@{ui})
   D0                         A0         A1  A2
  @{i}@{b}success@{ub}@{ui} = LayoutMenuItems (@{i}menuitem@{ui}, @{i}vi@{ui}, @{i}firsttag@{ui}, ...)
  @{i}menuitem@{ui} - pointer to first MenuItem in a linked list of items.
  @{i}vi@{ui} - pointer returned by @{"GetVisualInfoA()" Link "GetVisualInfoA()"}.
  @{i}tagList@{ui} - pointer to an array of tags providing optional extra
    parameters, or NULL.
  @{i}@{b}success@{ub}@{ui} - TRUE if successful, FALSE otherwise (signifies that
    the @{"TextAttr" Link "include:graphics/text.h/Main" 65} wasn't openable).
@{"TAGS" link LAYOUTMENUITEMSA_TAGS}
BUGS
  If a menu ends up being wider than the whole screen, it will
  run off the right-hand side.
SEE ALSO
  @{"CreateMenusA()" Link "CreateMenusA()"}, @{"GetVisualInfoA()" Link "GetVisualInfoA()"}
@EndNode
@node LAYOUTMENUITEMSA_TAGS "LayoutMenuItemsA_tags"
@{i}GTMN_Menu@{ui} (@{FG shine}struct@{FG text} @{"Menu" Link "include:intuition/intuition.h/Main" 61} *) - Pointer to the Menu structure whose FirstItem
  is the @{"MenuItem" Link "include:intuition/intuition.h/Main" 89} supplied above.If the menu items are such that they need
  to be columnized or shifted, the Menu structure is needed to perform the
  complete calculation.It is suggested you always provide this information.(V36)
For the following tags, please see the description under @{"LayoutMenusA()" Link "LayoutMenusA()"}.
Their behavior is identical when used in LayoutMenuItemsA().
@{i}GTMN_NewLookMenus@{ui}
@{i}GTMN_FrontPen@{ui}
@{i}GTMN_Checkmark@{ui}
@{i}GTMN_TextAttr@{ui}
@{i}GTMN_AmigaKey@{ui}
@endnode
@Node "LayoutMenusA()" "gadtools.library/LayoutMenusA"
@{b}@{u}LayoutMenusA@{uu}@{ub} -- position all the menus and menu items.(V36)
@{b}@{u}LayoutMenus@{uu}@{ub}  -- varargs stub for LayoutMenusA().(V36)
  Lays out all the menus, menu items and sub-items in the supplied
  menu according to the supplied visual information and tag parameters.
  This routine attempts to columnize and/or shift the MenuItems in
  the event that a menu would be too tall or too wide.
SYNOPSIS
  BOOL LayoutMenusA(@{FG shine}struct@{FG text} @{"Menu" Link "include:intuition/intuition.h/Main" 61} *, APTR, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  BOOL LayoutMenus (@{FG shine}struct@{FG text} @{"Menu" Link "include:intuition/intuition.h/Main" 61} *, APTR, Tag, ...);
  @{i}@{b}success@{ub}@{ui} = LayoutMenusA(@{i}menu@{ui}, @{i}vi@{ui}, @{i}tagList@{ui})
   D0                     A0     A1  A2
  @{i}@{b}success@{ub}@{ui} = LayoutMenus (@{i}menu@{ui}, @{i}vi@{ui}, @{i}firsttag@{ui}, ...)
  @{i}menu@{ui} - pointer to menu obtained from @{"CreateMenusA()" Link "CreateMenusA()"}.
  @{i}vi@{ui} - pointer returned by @{"GetVisualInfoA()" Link "GetVisualInfoA()"}.
  @{i}tagList@{ui} - pointer to an array of tags providing optional extra
    parameters, or NULL.
  @{i}@{b}success@{ub}@{ui} - TRUE if successful, FALSE otherwise (signifies that
    the @{"TextAttr" Link "include:graphics/text.h/Main" 65} wasn't openable).
@{"TAGS" link LAYOUTMENUSA_TAGS}
NOTES
  When using this function, there is no need to also call @{"LayoutMenuItemsA()" Link "LayoutMenuItemsA()"}.
BUGS
  If a menu ends up being wider than the whole screen, it will
  run off the right-hand side.
SEE ALSO
  @{"CreateMenusA()" Link "CreateMenusA()"}, @{"GetVisualInfoA()" Link "GetVisualInfoA()"}
@EndNode
@node LAYOUTMENUSA_TAGS "LayoutMenusA_tags"
@{i}GTMN_NewLookMenus@{ui} (BOOL) - If you ask for WA_NewLookMenus for your
  window, you should ask for this tag as well.This informs GadTools
  to use the appropriate checkmark, Amiga-key, and colors.(V39)
@{i}GTMN_FrontPen@{ui} (ULONG) - This tag has existed for CreateMenus(), but now
  LayoutMenusA() has it too.If a legitimate pen number is supplied, it is used
  for coloring the menu items (in preference to anything passed to
  CreateMenus()).If GTMN_NewLookMenus has been specified, this tag defaults
  to using the screen's BARDETAILPEN, else it defaults to "do nothing".
  For visual consistency, we recommend you omit this tag in all functions,
  and let the defaults be used.(V39)
@{i}GTMN_Checkmark@{ui} (@{FG shine}struct@{FG text} @{"Image" Link "include:intuition/intuition.h/Main" 700} *) - If you are using a custom image for a
  checkmark (WA_Checkmark), also pass it to GadTools, so it can lay the
  menus out accordingly.(V39)
@{i}GTMN_TextAttr@{ui} (@{FG shine}struct@{FG text} @{"TextAttr" Link "include:graphics/text.h/Main" 65} *) - Text Attribute to use for menu-items
  and sub-items.If not supplied, the screen's font will be used.This font
  must be openable via @{"OpenFont()" Link "graphics.guide/OpenFont()"} when this function is called.(V36)
@{i}GTMN_AmigaKey@{ui} (@{FG shine}struct@{FG text} @{"Image" Link "include:intuition/intuition.h/Main" 700} *) - If you are using a custom image for
  the Amiga-key in menus (WA_AmigaKey), also pass it to GadTools, so
  it can lay the menus out accordingly.(V39)
@endnode

@Node "AddAppIconA()" "workbench.library/AddAppIconA"
@{b}@{u}AddAppIconA@{uu}@{ub} - add an icon to workbench's list of appicons.(V36)
  Attempt to add an icon to workbench's list of appicons.If successful, the
  icon is displayed on the workbench (the same place disk icons are displayed).
  This call is provided to allow applications to be notified when a graphical
  object (non neccessarely associated with a file) gets 'manipulated'.
  (explained later).
  The notification consists of an @{"AppMessage" Link "include:workbench/workbench.h/Main" 117} (found in workbench.h/i)
  of type 'MTYPE_APPICON' arriving at the message port you specified.
  @{i}The types of 'manipulation' that can occur are@{ui}:
  1.Double-clicking on the icon.
    am_NumArgs will be zero and am_ArgList will be NULL.
  2.Dropping an icon or icons on your appicon.
    am_NumArgs will be the number of icons dropped on your app icon plus one.
    am_ArgList will be an array of ptrs to @{"WBArg" Link "include:workbench/startup.h/Main" 35} structures.
    Refer to the 'WBStartup Message' section of the RKM for more info.
  3.Dropping your appicon on another icon.
    NOT SUPPORTED.
SYNOPSIS
  @{FG shine}struct@{FG text} AppIcon *AddAppIconA(ULONG, ULONG, @{FG shine}char@{FG text} *, @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *,
    @{FG shine}struct@{FG text} @{"FileLock" Link "include:dos/dosextens.h/Main" 453} *, @{FG shine}struct@{FG text} @{"DiskObject" Link "include:workbench/workbench.h/Main" 60} *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  Alternate, varargs version:
  @{FG shine}struct@{FG text} AppIcon *AddAppIcon(ULONG, ULONG, @{FG shine}char@{FG text} *, @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *,
    @{FG shine}struct@{FG text} @{"FileLock" Link "include:dos/dosextens.h/Main" 453} *, @{FG shine}struct@{FG text} @{"DiskObject" Link "include:workbench/workbench.h/Main" 60} *, tag1, data1, ... ,TAG_END );
  @{i}@{b}AppIcon@{ub}@{ui} = AddAppIconA(@{i}id@{ui}, @{i}userdata@{ui}, @{i}text@{ui}, @{i}msgport@{ui}, @{i}lock@{ui}, @{i}diskobj@{ui}, @{i}taglist@{ui})
   D0                     D0  D1        A0    A1        A2    A3       A4
  @{i}id@{ui} - this variable is strictly for your own use and is ignored by workbench.
    Typical uses in C are in switch and case statements, and in assembly
    language table lookup.
  @{i}userdata@{ui} - this variable is strictly for your own use and is ignored
    by workbench.
  @{i}text@{ui} - name of icon (char *)
  @{i}lock@{ui} - NULL (Currently unused)
  @{i}msgport@{ui} - pointer to message port workbench will use to send you an AppMessage
    message of type 'MTYPE_APPICON' when your icon gets 'manipulated'
    (explained above).
  @{i}diskobj@{ui} - pointer to a DiskObject structure filled in as follows:
    do_Magic - NULL
    do_Version - NULL
    do_Gadget - a gadget structure filled in as follows:
      NextGadget - NULL
      LeftEdge - NULL
      TopEdge - NULL
      Width - width of icon hit-box
      Height - height of icon hit-box
      Flags - NULL or GADGHIMAGE
      Activation - NULL
      GadgetType - NULL
      GadgetRender - pointer to @{"Image" Link "include:intuition/intuition.h/Main" 700} structure filled in as follows:
        LeftEdge - NULL
        TopEdge - NULL
        Width - width of image (must be <= Width of hit box)
        Height - height of image (must be <= Height of hit box)
        Depth - # of bit-planes in image
        ImageData - pointer to actual word aligned bits (CHIP MEM)
        PlanePick - Plane mask ((1 << depth) - 1)
        PlaneOnOff - 0
        NextImage - NULL
      SelectRender - pointer to alternate @{"Image" Link "include:intuition/intuition.h/Main" 700} struct or NULL
      GadgetText - NULL
      MutualExclude - NULL
      SpecialInfo - NULL
      GadgetID - NULL
      UserData - NULL
      do_Type - NULL
      do_DefaultTool - NULL
      do_ToolTypes - NULL
      do_CurrentX - NO_ICON_POSITION (recommended)
      do_CurrentY - NO_ICON_POSITION (recommended)
      do_DrawerData - NULL
      do_ToolWindow - NULL
      do_StackSize - NULL
  (an easy way to create one of these (a @{i}DiskObject@{ui}) is to create an icon
  with the V2.0 icon editor and save it out.Your application can then call
  @{"GetDiskObject" Link "icon.library/GetDiskObject()"} on it and pass that to AddAppIcon.)
  @{i}taglist@{ui} - ptr to a list of tag items.Must be NULL for V2.0.
  @{i}@{b}AppIcon@{ub}@{ui} - a pointer to an appicon structure which you pass to @{"RemoveAppIcon" Link "RemoveAppIcon()"}
    when you want to remove the icon from workbench's list of appicons.
    NULL if workbench was unable to add your icon; typically happens
    when workbench is not running or under low  memory conditions.
EXAMPLE
  You could design a print-spooler icon and add it to the workbench.
  Any file dropped on the print spooler would be printed.If the
  user double-clicked (opened) your printer-spooler icon, you could
  open a window showing the status of the print spool, allow changes
  to print priorities, allow deletions, etc.If you registered this
  window as an 'appwindow' (explained in workbench.library AddAppWindow)
  files could also be dropped in the window and added to the spool.
SEE ALSO
  @{"RemoveAppIcon()" Link "RemoveAppIcon()"}
BUGS
  Currently @{"Info" Link "dos.guide/Info()"} cannot be obtained on appicons.
@EndNode
@Node "AddAppMenuItemA()" "workbench.library/AddAppMenuItemA"
@{b}@{u}AddAppMenuItemA@{uu}@{ub} - add a menuitem to workbench's list of appmenuitems.(V36)
  Attempt to add the text as a menuitem to workbench's list of appmenuitems
  (the 'Tools' menu strip).
SYNOPSIS
  @{FG shine}struct@{FG text} @{"AppMenuItem" Link "include:workbench/workbench.h/Main" 147} *AddAppMenuItemA(ULONG, ULONG, @{FG shine}char@{FG text} *, @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *,
    @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  Alternate, varargs version:
  @{FG shine}struct@{FG text} @{"AppMenuItem" Link "include:workbench/workbench.h/Main" 147} *AddAppMenuItem (ULONG, ULONG, @{FG shine}char@{FG text} *, @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *,
    tag1, data1, ... ,TAG_END );
  @{i}@{b}AppMenuItem@{ub}@{ui} = AddAppMenuItemA(@{i}id@{ui}, @{i}userdata@{ui}, @{i}text@{ui}, @{i}msgport@{ui}, @{i}taglist@{ui})
   D0                            D0   D1        A0    A1       A2
  @{i}id@{ui} - this variable is strictly for your own use and is ignored by workbench.
    Typical uses in C are in switch and case statements, and in assembly
    language table lookup.
  @{i}userdata@{ui} - this variable is strictly for your own use and is ignored
    by workbench.
  @{i}text@{ui} - text for the menuitem (char *)
  @{i}msgport@{ui} - pointer to message port workbench will use to send you an @{"AppMessage" Link "include:workbench/workbench.h/Main" 117}
    message of type 'MTYPE_APPMENUITEM' when your menuitem gets selected.
  @{i}taglist@{ui} - ptr to a list of tag items.Must be NULL for V2.0.
  @{i}@{b}AppMenuItem@{ub}@{ui} - a pointer to an appmenuitem structure which you pass to
    @{"RemoveAppMenuItem" Link "RemoveAppMenuItem()"} when you want to remove the menuitem from
    workbench's list of appmenuitems.NULL if workbench was unable to add your
    menuitem; typically happens when workbench is not running or under low
    memory conditions.
SEE ALSO
  @{"RemoveAppMenuItem()" Link "RemoveAppMenuItem()"}
BUGS
  Currently does not limit the system to 63 menu items...
  Any menu items after the 63rd will not be selectable.
@EndNode
@Node "AddAppWindowA()" "workbench.library/AddAppWindowA"
@{b}@{u}AddAppWindowA@{uu}@{ub} - add a window to workbench's list of appwindows.(V36)
  Attempt to add the window to workbench's list of appwindows. Normally
  non-workbench windows (those not opened by workbench) cannot have icons
  dropped in them.This call is provided to allow applications to be notified
  when an icon or icons get dropped inside a window that they have registered
  with workbench.The notification consists of an @{"AppMessage" Link "include:workbench/workbench.h/Main" 117} of type
  'MTYPE_APPWINDOW' arriving at the message port you specified.
  What you do with the list of icons (pointed to by am_ArgList) is up to you,
  but generally you would want to call @{"GetDiskObjectNew" Link "icon/GetDiskObjectNew()"} on them.
SYNOPSIS
  @{FG shine}struct@{FG text} @{"AppWindow" Link "include:workbench/workbench.h/Main" 145} *AddAppWindowA(ULONG, ULONG, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *,
    @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  Alternate, varargs version:
  @{FG shine}struct@{FG text} @{"AppWindow" Link "include:workbench/workbench.h/Main" 145} *AddAppWindow (ULONG, ULONG, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *,
    @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *, tag1, data1, ... ,TAG_END );
  @{i}@{b}AppWindow@{ub}@{ui} = AddAppWindowA(@{i}id@{ui}, @{i}userdata@{ui}, @{i}window@{ui}, @{i}msgport@{ui}, @{i}taglist@{ui})
   D0                        D0   D1        A0      A1       A2
  @{i}id@{ui} - this variable is strictly for your own use and is ignored by workbench.
    Typical uses in C are in switch and case statements,and in assembly
    language table lookup.
  @{i}userdata@{ui} - this variable is strictly for your own use and is ignored
    by workbench.
  @{i}window@{ui} - pointer to window to add.
  @{i}msgport@{ui} - pointer to message port workbench will use to send you an AppMessage
    message of type 'MTYPE_APPWINDOW' when your window gets an icon or icon is
    dropped in it.
  @{i}taglist@{ui} - ptr to a list of tag items.Must be NULL for V2.0.
  @{i}@{b}AppWindow@{ub}@{ui} - a pointer to an appwindow structure which you pass to
    @{"RemoveAppWindow" Link "RemoveAppWindow()"} when you want to remove the window from
    workbench's list of appwindows.NULL if workbench was unable to add your
    window; typically happens when workbench is not running or under low
    memory conditions.
SEE ALSO
  @{"RemoveAppWindow()" Link "RemoveAppWindow()"}
NOTES
  The V2.0 icon editor is an example of an app window.Note that app window
  applications generally want to call @{"GetDiskObjectNew" Link "icon.guide/GetDiskObjectNew()"} (as opposed to
  GetDiskObject) to get the disk object for the icon dropped in the window.
@EndNode
@Node "RemoveAppIcon()" "workbench.library/RemoveAppIcon"
@{b}@{u}RemoveAppIcon@{uu}@{ub} - remove an icon from workbench's list of appicons.(V36)
  Attempt to remove an appicon from workbench's list of appicons.
SYNOPSIS  BOOL RemoveAppIcon(@{FG shine}struct@{FG text} @{i}AppIcon@{ui} *);
  @{i}@{b}error@{ub}@{ui} = RemoveAppIcon(@{i}AppIcon@{ui})
   D0                    A0
  @{i}AppIcon@{ui} - pointer to an AppIcon structure returned by AddAppIcon.
  @{i}@{b}error@{ub}@{ui} - Currently always TRUE...
NOTES
  As with anything that deals with async operation, you will need to do a
  final check for messages on your App message port for messages that may have
  come in between the last time you checked and the call to removed the App.
SEE ALSO
  @{"AddAppIconA()" Link "AddAppIconA()"}
@EndNode
@Node "RemoveAppMenuItem()" "workbench.library/RemoveAppMenuItem"
@{b}@{u}RemoveAppMenuItem@{uu}@{ub} - remove a menuitem from workbench's list of appmenuitems.(V36)
  Attempt to remove an appmenuitem from workbench's list of appmenuitems.
SYNOPSIS  BOOL RemoveAppMenuItem(@{FG shine}struct@{FG text} @{"AppMenuItem" Link "include:workbench/workbench.h/Main" 147} *);
  @{i}@{b}error@{ub}@{ui} = RemoveAppMenuItem(@{i}AppMenuItem@{ui})
   D0                        A0
  @{i}AppMenuItem@{ui} - pointer to an AppMenuItem structure returned by AddAppMenuItem.
  @{i}@{b}error@{ub}@{ui} - Currently always TRUE...
NOTES
  As with anything that deals with async operation, you will need to do a
  final check for messages on your App message port for messages that may have
  come in between the last time you checked and the call to removed the App.
SEE ALSO
  @{"AddAppMenuItemA()" Link "AddAppMenuItemA()"}
@EndNode
@Node "RemoveAppWindow()" "workbench.library/RemoveAppWindow"
@{b}@{u}RemoveAppWindow@{uu}@{ub} - remove a window from workbench's list of appwindows.(V36)
  Attempt to remove an appwindow from workbench's list of appwindows.
SYNOPSIS  BOOL RemoveAppWindow(@{FG shine}struct@{FG text} @{"AppWindow" Link "include:workbench/workbench.h/Main" 145} *);
  @{i}@{b}error@{ub}@{ui} = RemoveAppWindow(@{i}AppWindow@{ui})
   D0                      A0
  @{i}AppWindow@{ui} - pointer to an AppWindow" structure returned by AddAppWindow.
  @{i}@{b}error@{ub}@{ui} - Currently always TRUE...
NOTES
  As with anything that deals with async operation, you will need to do a
  final check for messages on your App message port for messages that may have
  come in between the last time you checked and the call to removed the App.
SEE ALSO
  @{"AddAppWindowA()" Link "AddAppWindowA()"}
@EndNode
@Node "WBInfo()" "workbench.library/WBInfo"
@{b}@{u}WBInfo@{uu}@{ub} - Bring up the Information requrester.(V39)
  This is the LVO that Workbench calls to bring up the Icon Information
  requester.External applications may also call this requester.
  In addition, if someone were to wish to replace this requester
  with another one, they could do so via a @{"SetFunction" Link "exec.guide/SetFunction()"}.
SYNOPSIS  ULONG WBInfo(BPTR, STRPTR, @{FG shine}struct@{FG text} @{"Screen" Link "include:intuition/screens.h/Main" 120} *);
  @{i}@{b}worked@{ub}@{ui} = WBInfo(@{i}lock@{ui}, @{i}name@{ui}, @{i}screen@{ui})
   d0               a0    a1    a2
  @{i}lock@{ui}   - A lock on the parent directory
  @{i}name@{ui}   - The name of the icon contained within above directory
  @{i}screen@{ui} - A screen pointer on which the requester is to show up
  @{i}@{b}worked@{ub}@{ui} - Returns TRUE if the requester came up, FALSE if it did not.
NOTE
  Note that this LVO may be called many times by different tasks
  before other calls return.Thus, the code must be 100% re-entrant.
SEE ALSO
  icon.library
@EndNode

