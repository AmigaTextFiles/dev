@database "battclock"
@master "Work:Programing/sc/OS3.1_Docs/doc/battclock.doc"

@Node Main "battclock.doc"
@{b}@{u}cardres@{uu}@{ub}:             @{b}@{u}battmem@{uu}@{ub}:               @{b}@{u}battclock@{uu}@{ub}:
@{"BeginCardAccess()" Link "BeginCardAccess()"}   @{"ObtainBattSemaphore()" Link "ObtainBattSemaphore()"} @{"ReadBattClock()" Link "ReadBattClock()"}
@{"CardAccessSpeed()" Link "CardAccessSpeed()"}   @{"ReadBattMem()" Link "ReadBattMem()"}         @{"ResetBattClock()" Link "ResetBattClock()"}
@{"CardChangeCount()" Link "CardChangeCount()"}   @{"ReleaseBattSemaphore()" Link "ReleaseBattSemaphore()"}@{"WriteBattClock()" Link "WriteBattClock()"}
@{"CardForceChange()" Link "CardForceChange()"}   @{"WriteBattMem()" Link "WriteBattMem()"}
@{"CardInterface()" Link "CardInterface()"}     @{b}@{u}cia@{uu}@{ub}:
@{"CardMiscControl()" Link "CardMiscControl()"}   @{"AbleICR()" Link "AbleICR()"}
@{"CardProgramVoltage()" Link "CardProgramVoltage()"}@{"AddICRVector()" Link "AddICRVector()"}
@{"CardResetCard()" Link "CardResetCard()"}     @{"RemICRVector()" Link "RemICRVector()"}
@{"CardResetRemove()" Link "CardResetRemove()"}   @{"SetICR()" Link "SetICR()"}
@{"CopyTuple()" Link "CopyTuple()"}         @{b}@{u}disk@{uu}@{ub}:
@{"DeviceTuple()" Link "DeviceTuple()"}       @{"AllocUnit()" Link "AllocUnit()"}
@{"EndCardAccess()" Link "EndCardAccess()"}     @{"FreeUnit()" Link "FreeUnit()"}
@{"GetCardMap()" Link "GetCardMap()"}        @{"GetUnit()" Link "GetUnit()"}
@{"IfAmigaXIP()" Link "IfAmigaXIP()"}        @{"GetUnitID()" Link "GetUnitID()"}
@{"OwnCard()" Link "OwnCard()"}           @{"GiveUnit()" Link "GiveUnit()"}
@{"ReadCardStatus()" Link "ReadCardStatus()"}    @{"ReadUnitID()" Link "ReadUnitID()"}
@{"ReleaseCard()" Link "ReleaseCard()"}       @{b}@{u}misc@{uu}@{ub}:
@{b}@{u}potgo@{uu}@{ub}:               @{"AllocMiscResource()" Link "AllocMiscResource()"}
@{"AllocPotBits()" Link "AllocPotBits()"}      @{"FreeMiscResource()" Link "FreeMiscResource()"}
@{"FreePotBits()" Link "FreePotBits()"}       @{b}@{u}filesys@{uu}@{ub}:
@{"WritePotgo()" Link "WritePotgo()"}        @{"--background--" Link "--background--"}
@EndNode
@Node "BeginCardAccess()" "card.resource/BeginCardAccess"
@{b}@{u}BeginCardAccess@{uu}@{ub} -- Called before you begin credit-card memory access.
  This function should be called before you begin access to credit-card memory.
  Its effect will depend on the type of Amiga machine your code happens to be
  running on.On some machines it will cause an access light to be turned ON.
SYNOPSIS  BOOL BeginCardAccess( @{FG shine}struct@{FG text} CardHandle * );
  @{i}@{b}result@{ub}@{ui}=BeginCardAccess( @{i}handle@{ui} )
   d0                      a1
  @{i}handle@{ui} - Same handle as that used when @{"OwnCard()" Link "OwnCard()"} was called.
  TRUE if you are still the owner of the credit-card, and
  memory access is permitted.FALSE if you are no longer
  the owner of the credit-card (usually indicating that the card was removed).
NOTES
  This function may be called from within a task, or from a level 1
  or level 2 interrupt.
  It is highly recommended that you call this function
  before accessing credit-card memory, as well as checking
  the return value.If it is a return value of FALSE, you
  should stop accessing credit-card memory.
SEE ALSO
  @{"OwnCard()" Link "OwnCard()"}, @{"EndCardAccess()" Link "EndCardAccess()"}
@EndNode
@Node "CardAccessSpeed()" "card.resource/CardAccessSpeed"
@{b}@{u}CardAccessSpeed@{uu}@{ub} -- Select best possible memory access speed.
  This function is used to set memory access speed for all CPU
  accesses to card memory.
  Typically this information would be determined by first examining
  the Card Information Structure.
  Then you would use this function to let the card.resource
  select the best possible access speed for you, however note
  that the range of possible access speeds may vary on some
  machines (depending on the type of credit-card interface
  hardware being provided).
SYNOPSIS  ULONG CardAccessSpeed( @{FG shine}struct@{FG text} CardHandle *, ULONG );
  @{i}@{b}result@{ub}@{ui}=CardAccessSpeed( @{i}handle@{ui}, @{i}nanoseconds@{ui} );
   d0                      a1       d0
  @{i}handle@{ui} - Same handle as that used when @{"OwnCard()" Link "OwnCard()"} was called.
  @{i}nanoseconds@{ui} - Preferred access speed in nanoseconds.
  @{b}@{i}Speed@{ui}@{ub} - Access speed selected by resource (in nanoseconds).
  @{b}@{i}0@{ui}@{ub}  - Not successful.Either because the credit-card was
  removed, or the access speed you requested is slower than
  that supported by the credit-card interface hardware.
NOTES
  This function may be called from within a task, or from a level 1
  or level 2 interrupt.
SEE ALSO
  @{"OwnCard()" Link "OwnCard()"}
@EndNode
@Node "CardChangeCount()" "card.resource/CardChangeCount"
@{b}@{u}CardChangeCount@{uu}@{ub} -- Obtain card change count.
  This function returns the card change count.The
  counter is incremented by one for every removal, and
  for every successful insertion (a card which is inserted
  long enough to be debounced before it is removed again).
SYNOPSIS  ULONG CardChangeChange( @{FG shine}void@{FG text} );
  @{b}@{i}count@{ui}@{ub} = CardChangeCount()
   d0
  @{b}@{i}count@{ui}@{ub} - changed count number.
NOTES
  This function may be called from a task, or any level interrupt.
@EndNode
@Node "CardForceChange()" "card.resource/CardForceChange"
@{b}@{u}CardForceChange@{uu}@{ub} -- Force a card change.
  This function is not intended for general use.Its purpose is to force
  a credit-card change as if the user had removed, or inserted a card.
  This function is intended to be used by a utility program which needs
  to force the current card owner to release ownership of the card,
  thereby allowing the utility an opportunity to own the credit-card.
SYNOPSIS  BOOL CardForceChange( @{FG shine}void@{FG text} );
  @{b}@{i}success@{ui}@{ub} = CardForceChange()
   d0
  TRUE if the function succeeded, FALSE if card change is
  not allowed.This function will generally succeed, unless
  someone is using the card in reset remove mode at the time
  this function is called.
NOTES
  This function should only be called from a task.
@EndNode
@node CARDINTERFACE_NOTES "CardInterface_notes"
In general only I/O devices (e.g., a device which interfaces with a modem card)
would need to provide work-arounds, or alternative code.An example would be a
change in the way interrupt requests from the card are handled.Specific details
will be provided as need in the future.I/O devices) should abort properly if
this function returns a value which is unknown.
@{b}@{u}Current implementations (see card.h/i) - @{i}CARD_INTERFACE_AMIGA_0@{ui}@{uu}@{ub}:
  The card slot can be configured for use as an I/O interface by using the
  @{"CardMiscControl()" Link "CardMiscControl()"} function.The card slot inhibits writes to cards which do not
  negate the WP status bit.This can be overridden by using the
  @{"CardMiscControl()" Link "CardMiscControl()"} function.
  Changes in the interrupt request line are latched by a gate-array,
  and have to be obtained via the status change mechanism provided
  when you call the @{"OwnCard()" Link "OwnCard()"} function.The interrupt is cleared when you
  return from the status change interrupt.A level 2 interrupt is generated.
  Usually you will want to clear the interrupt on the card at this time,
  and @{"Signal()" Link "exec.guide/Signal()"} a task.The IRQ line is the same as the RDY/BSY line.
  Changes in BVD1, WP, and RDY/BSY are also latched by the gate-array,
  and are obtainable via the status change mechanism provided by
  the @{"OwnCard()" Link "OwnCard()"} function.A level 2 interrupt is generated.
  Changes in BVD2 (also used for digital audio) have to be monitored
  via polling.Generally this will cause no problem.Monitoring changes
  in BVD1 & BVD2 to monitor for low battery condition can be handled
  by a low priority tool which periodically checks the condition of
  both lines using the @{"ReadCardStatus()" Link "ReadCardStatus()"} function.
  As of card.resource V39 (check VERSION in resource base), the
  @{"CardMiscControl()" Link "CardMiscControl()"} function can be used to enable/disable status change
  interrupts for changes in BVD1, BVD2, and the RDY/BSY status line.
  Status change interrupts for WR (Write-protect enable/disable) are
  always enabled.The default state of enabled/disabled status change
  interrupts noted above are unchanged, and automatically reset to
  the defaults when a card is removed, or when even a task releases
  ownership of the card.Some PC oriented eight (8) bit cards may require
  you read odd-byte I/O address registers at the corresponding even-byte
  address plus 64K.There is sufficient I/O address space provided that
  exceeding I/O address space should not be a problem.
  Your code should wait at least 1 millisecond for Vpp to stabilize
  after voltage change (see @{"CardProgramVoltage()" Link "CardProgramVoltage()"}).
@endnode
@Node "CardInterface()" "card.resource/CardInterface"
@{b}@{u}CardInterface@{uu}@{ub} -- Determine the type of card interface.
  This function is used to determine the type of credit-card
  (hardware) interface available.For the most part the card.resource
  hides the hardware details from devices within its function calls.
  However should we need to provide a work-around because of differences,
  or limitations imposed by future interface hardware, this function
  must be used to identify which interface is available.
SYNOPSIS  ULONG CardInterface( @{i}void@{ui} );
  @{i}@{b}return@{ub}@{ui} = CardInterface()
   d0
  @{i}@{b}return@{ub}@{ui} - ULONG value as defined in card.h/i.
@{"NOTES" link CARDINTERFACE_NOTES}
SEE ALSO
  @{"CardMiscControl()" Link "CardMiscControl()"}, resources/card.i, resources/card.h
@EndNode
@Node "CardMiscControl()" "card.resource/CardMiscControl"
@{b}@{u}CardMiscControl@{uu}@{ub} -- Set/Clear miscellaneous control bits.
  Used to set/clear miscellaneous control bits (generally for use with I/O cards).
SYNOPSIS  UBYTE CardMiscControl( @{FG shine}struct@{FG text} CardHandle *, UBYTE );
  @{i}@{b}control_bits@{ub}@{ui}=CardMiscControl( @{i}handle@{ui}, @{i}control_bits@{ui} );
   d0                             a1      d1
  @{i}handle@{ui} - Same handle as that used when @{"OwnCard()" Link "OwnCard()"} was called.
  @{i}control_bits@{ui} - A mask value of control bits to be turned on/off.
    The bit values which might be usable are defined in card.h/i.
    For example, to enable digital audio, and disable hardware write-protect
    (if supported), you would call this function with these values --
      @{i}CARDF_DISABLE_WP@{ui}|@{i}CARDF_ENABLE_DIGAUDIO@{ui}
    Then to turn off digital audio, but leave write-protect
    disable, you would use a value of --
      @{i}CARDF_DISABLE_WP@{ui}
    Finally too reenable write protect, call this function with
      a mask value of 0.
  @{i}@{b}control_bits@{ub}@{ui} - The same mask value you called this function
    with if successful.If one, or more bits has been cleared in the
    return mask, this would indicate that the control bitis not
    being supported, or that the card has been removed by the user.
    For example, if you called this function with a mask value of --
      @{i}CARDF_DISABLE_WP@{ui}|@{i}CARDF_ENABLE_DIGAUDIO@{ui}
    And this function returned a value of --
      @{i}CARDF_DISABLE_WP@{ui}
    This would indicate that it is not possible to enable digital
    audio (most likely because this feature has not been implemented).
NOTES
  This function may be called from within a task, or from a level 1
  or level 2 interrupt.
@{b}!!!IMPORTANT!!!@{ub}
  You should @{b}ALWAYS@{ub} try to enable digital audio for I/O cards as this
  will also configure the card socket for the I/O interface (if supported).
  Not all cards will connect the write-enable line (e.g., some I/O cards).
  On some machines (e.g., the A600) it will not be possible to write to
  such cards unless you disable write-protection by using this function.
@{b}!!!NEW!!!@{ub}
  For card.resource V39 (check resource base for VERSION before using),
  new bits have been defined which let you enable/disable particular
  status change interrupts.See @{"CardInterface()" Link "CardInterface()"} for defaults.
  These new bits are backwards compatable with V37 for which only the
  @{i}CARDB_DISABLE_WP@{ui}, and @{i}CARDB_ENABLE_DIGAUDIO@{ui} bits were defined.These
  new bits allow you to enable, or disable specific status change
  interrupts including BVD1/SC, BVD2/DA, and BSY/IRQ.The defaults for
  these status change interrupts are unchanged from V37, and WR
  (Write-protect) status change interrupts are always enabled as they use to be.
@{b}@{u}An example of use@{uu}@{ub}:
    CARD_INTF_SETCLR!CARD_INTF_BVD1
  Would enable BVD1/SC status change interrupts, and not change
  the enable/disable state for BVD2/DA or BSY/IRQ status change
  interrupts.If the change was made successfully, the CARD_INTB_BVD1
  bit would be set in register D0 when this function returns.
SEE ALSO
  @{"CardInterface()" Link "CardInterface()"}, resources/card.h, resources/card.i
@EndNode
@Node "CardProgramVoltage()" "card.resource/CardProgramVoltage"
@{b}@{u}CardProgramVoltage@{uu}@{ub} -- Set programming voltage.
  Used to set programming voltages (e.g., for FLASH-ROM/EPROM cards).
SYNOPSIS  LONG CardProgramVoltage( @{FG shine}struct@{FG text} CardHandle *, ULONG );
  @{i}@{b}success@{ub}@{ui}=CardProgramVoltage( @{i}handle@{ui}, @{i}voltage@{ui} );
                               a1       d0
  @{i}handle@{ui} - Same handle as that used when @{"OwnCard()" Link "OwnCard()"} was called.
  @{i}voltage@{ui} - See card.i/h for valid values.
  @{i}@{b}1@{ub}@{ui} - Successful.
  @{i}@{b}0@{ub}@{ui} - Not successful.Most likely because the credit-card
    card has been removed, and you are no longer the owner.
  @{i}@{b}-1@{ub}@{ui} - This function is not being supported.On some machines with a
    minimal (hardware) credit-card interface, this feature may not be possible.
NOTES
  This function may be called from within a task, or from a level 1
  or level 2 interrupt.
@{b}!!!WARNING!!!@{ub}
  Flash-ROM programming requires careful coding to prevent
  leaving the Erase command on too long.Failure to observe
  the maximum time between the Erase command, and the Erase-Verify
  command can make a Flash-ROM card unusable.Some Flash-ROM cards
  may provide an internal watch-dog timer which protects the card.
  Because of the relatively long time (e.g., 10ms) between Erase, and
  Erase-Verify which must be observed, the need for such critical
  timing can be problematic on a multi-tasking machine.
  Vendors of Flash-ROM's recommend a high priority interrupt
  generated by a 10ms timer be used to turn off Erase.On the
  Amiga this can be accomplished by using a CIA-B interval timer.
  The timer.device also provides a mechanism for generating a low
  priority interrupt.The timer.device is easier to use than @{"CIA" Link "include:hardware/cia.h/Main" 29}
  interval timers, though not as accurate or as safe.
  Even if the Flash-ROM card provides an internal watch-dog timer,
  implementation of the code during Erase should assume that
  the Flash-ROM does not.
SEE ALSO
  @{"OwnCard()" Link "OwnCard()"}, resources/card.h, resources/card.i
@EndNode
@Node "CardResetCard()" "card.resource/CardResetCard"
@{b}@{u}CardResetCard@{uu}@{ub} -- Reset credit-card.
  Used to reset a credit-card.Some cards, such as some
  configurable cards can be reset.
  Asserts credit-card reset for at least 10us.
SYNOPSIS  BOOL CardResetCard( @{FG shine}struct@{FG text} CardHandle * );
  @{i}@{b}success@{ub}@{ui}=CardResetCard( @{i}handle@{ui} );
                          a1
  @{i}handle@{ui} - Same handle as that used when @{"OwnCard()" Link "OwnCard()"} was called.
  @{i}@{b}TRUE@{ub}@{ui} - Successful.
  @{i}@{b}FALSE@{ub}@{ui} - Not successful.Most likely because the credit-card
    card has been removed, and you are no longer the owner.
NOTES
  This function may be called from within a task, or from a level 1
  or level 2 interrupt.
@{b}***IMPORTANT***@{ub}
  It is the responsibility of the card owner to reset configurable
  cards, or any other type of card such as some I/O cards before
  calling @{"ReleaseCard()" Link "ReleaseCard()"} if the owner has made use of that card
  such that it is no longer in its reset state (unless you are
  releasing the card because it has been removed).
  If the card manufacturer indicates that a certain amount
  of time must elapse between end of reset, and completion
  of card initialization, you should wait at least that long
  before releasing the card (unless you are releasing the card
  because it has been removed).
SEE ALSO
  @{"OwnCard()" Link "OwnCard()"}, @{"ReleaseCard()" Link "ReleaseCard()"}
@EndNode
@Node "CardResetRemove()" "card.resource/CardResetRemove"
@{b}@{u}CardResetRemove@{uu}@{ub} -- Set/Clear reset on card removal.
  Used to set/clear HARDWARE RESET on card change detect.
  This function should generally not be used by devices
  which support HOT-REMOVAL.HARDWARE RESET on removal
  is generally intended for execute-in-place software, or
  ram cards whose memory has been added as system ram.
SYNOPSIS  BOOL CardResetRemove( @{FG shine}struct@{FG text} CardHandle *, ULONG );
  @{i}@{b}success@{ub}@{ui}=CardResetRemove( @{i}handle@{ui}, @{i}flag@{ui} );
                            a1      d0
  @{i}handle@{ui} - Same handle as that used when @{"OwnCard()" Link "OwnCard()"} was called.
  @{i}flag@{ui} - TRUE if you want to SET HARDWARE RESET on credit
    card removal.FALSE if you want to CLEAR HARDWARE RESET.
  @{i}@{b}1@{ub}@{ui} - Success.
  @{i}@{b}0@{ub}@{ui} - Function failed (most likely because the card was removed
    by the user, and you are no longer the owner of the card).
  @{i}@{b}-1@{ub}@{ui} - This function is not being made available.
NOTES
  This function should only be called from a task.
SEE ALSO
  @{"OwnCard()" Link "OwnCard()"}
@EndNode
@Node "CopyTuple()" "card.resource/CopyTuple"
@{b}@{u}CopyTuple@{uu}@{ub} -- Find/copy a credit card tuple.
  This function scans credit-card memory for a tuple, and if found,
  copies it into a supplied buffer.The entire tuple (including the
  tuple code, and link) are copied to the supplied buffer.The number
  of bytes copied to the buffer will be 2 bytes, plus the argument
  "size", or the value in the tuple LINK field (whichever is SMALLER).
  The software calling this function is responsible for examining the
  copy of the tuple (e.g., recognition of fields, recognition of stop
  bytes, etc.within the tuple).This function does the best job it can
  to find a tuple in attribute, or common memory.It follows tuple chains,
  and skips odd bytes in attribute memory.
  This function monitors for credit-card removal while reading data.
  If the credit-card is removed while a byte is being read, it will
  stop searching, and return FALSE.
  This function does not protect against another task writing to
  credit-card memory while data is being read.The device is responsible
  for single-threading reads/writes to the credit card as needed.
  This function can be used to find multiple tuple codes; this
  is a very rare case, so the mechanism provided for doing so is
  unusual.See INPUTS below for more information.
  This function does not read bytes within the body of any tuples
  except for the tuple you want copied, and the basic compatibility
  tuples this function understands (see list below).
  On some machines this function may slow down memory access speed while
  reading the tuple chain.This is done to prevent potential problems on
  slow cards.By examining the @{i}CISTPL_DEVICE@{ui}, and @{i}CISTPL_DEVICE_A@{ui} tuples,
  you can determine the best possible memory access speed for the type of
  card inserted.Because memory access speed may be slowed down, calls to
  this function should be single-threaded.
  The Card Information Structure must start with a @{i}CISTPL_DEVICE@{ui} tuple
  stored as the first tuple in attribute memory.If not, this function
  will search for a @{i}CISTPL_LINKTARGET@{ui} tuple stored at byte 0 of common
  memory.Therefore it is possible to store a CIS on cards which do not
  have any writeable attribute memory, though this may cause problems
  for other software implemented on other machines.For example, some
  SRAM cards do not come with writeable attribute memory, and/or some
  may have OPTIONAL EEPROM memory which may not have been initialized
  by the card manufacturer.While it could be argued that such cards
  do not conform to the PCMCIA PC Card Standard, such cards are cheaper,
  and therefore likely to be used.
SYNOPSIS  BOOL CopyTuple( @{FG shine}struct@{FG text} CardHandle *, UBYTE *, ULONG, ULONG );
  @{i}@{b}success@{ub}@{ui} = CopyTuple( @{i}CardHandle@{ui}, @{i}buffer@{ui}, @{i}tuplecode@{ui}, @{i}size@{ui} );
   d0                   a1          a0       d1         d0
  @{i}CardHandle@{ui} - Same handle as that used when @{"OwnCard()" Link "OwnCard()"} was called.
  @{i}buffer@{ui} - Pointer to a buffer where the tuple will be copied.
    The buffer should be at least as large as "size" + 8 (see use of "size"
    argument below).Therefore the minimum buffer size is 8 bytes.See NOTES below.
  @{i}tuplecode@{ui} - The tuple code you want to search for.This is
    a ULONG value.The upper 16 bits should be 0, or a number between
    1-32K where a value of 0 means you want to find the first tuple
    match, a value of 1 the second, etc.
    For example:@{i}0x41@{ui} means find the FIRST tuple equal to $41.
    @{i}((1<<16)|(0x41))@{ui} means find the SECOND tuple equal to $41.
    @{i}((2<<16)|(0x41))@{ui} means find the THIRD tuple equal to $41.
  @{i}size@{ui} - The maximum number of bytes you want copied (not
    including the tuple code, and link).The actual number of bytes copied
    may be less than "size" if the tuple link field is less than "size".
    A size of 0 will result in only the tuple code, and link being copied
    to your buffer if the tuple is found. If you do not care how many
    bytes are copied, any unsigned value of 255 or greater will do.In this
    case a maximum of 257 bytes might be copied to your buffer (if the tuple
    link field is the maximum of 255). Other sizes are useful if you know the
    size of the tuple you want copied, or you know there are active registers
    stored within the tuple, and only want to copy a portion of a tuple.
  @{i}@{b}TRUE@{ub}@{ui} if the tuple was found, and copied, else @{i}@{b}FALSE@{ub}@{ui}.
    This function may also return false if the CIS is believed to
    be corrupt, or if the card is removed while reading the tuples.
NOTES
  This function can be called multiple times (adjusting the "size"
  argument) to read a tuple of variable length, or unknown size.
  Your supplied buffered is used by this function for working
  storage - the contents of it will be modified even if this
  function fails to find the tuple you want a copy of.
  This function should @{b}NOT@{ub} be used to find/copy tuples of type :
  - @{i}CISTPL_LONGLINK_A@{ui}
  - @{i}CISTPL_LONGLINK_C@{ui}
  - @{i}CISTPL_NO_LINK@{ui}
  - @{i}CISTPL_LINKTARGET@{ui}
  - @{i}CISTPL_NULL@{ui}
  - @{i}CISTPL_END@{ui}
  These tuples are automatically handled for you by this function.
SEE ALSO
  @{"OwnCard()" Link "OwnCard()"}
@EndNode
@Node "DeviceTuple()" "card.resource/DeviceTuple"
@{b}@{u}DeviceTuple@{uu}@{ub} -- Decode a device tuple.
  Extracts SIZE, TYPE, and SPEED from a device tuple (generally
  obtained with @{"CopyTuple()" Link "CopyTuple()"}).
SYNOPSIS  ULONG DeviceTuple( UBYTE *, @{FG shine}struct@{FG text} DeviceTData *);
  @{i}@{b}return@{ub}@{ui}=DeviceTuple( @{i}tuple_data@{ui}, @{i}storage@{ui})
                       a0           a1
  @{i}tuple_data@{ui} - Pointer to a @{i}CISTPL_DEVICE@{ui} tuple (generally obtained
    with @{"CopyTuple()" Link "CopyTuple()"}).
  @{i}storage@{ui} - Pointer to a DeviceTData structure in which results are to be stored.
  @{FG shine}struct@{FG text} DeviceTData {
    ULONG @{b}dtd_DTsize@{ub};   /* Size of card (bytes) */
    ULONG @{b}dtd_DTspeed@{ub};    /* Speed in nanoseconds */
    UBYTE @{b}dtd_DTtype@{ub};   /* Type of card   */
    UBYTE @{b}dtd_DTflags@{ub};    /* Other flags    */
  };
  @{i}@{b}SIZE@{ub}@{ui} (same as @{i}dtd_DTsize@{ui}) if the @{"Device" Link "include:exec/devices.h/Main" 25} Tuple could be decoded.
  @{i}@{b}FALSE (0)@{ub}@{ui} if the tuple is believed to be invalid.
    @{b}@{u}The tuple is considered to be invalid if@{uu}@{ub}:
    - The tuple link value is 0.
    - The device type/speed byte is $00, or $FF.
    - The device type is @{i}DTYPE_EXTEND@{ui}, which is undefined as of this writing.
    - The extended speed byte is a value which is undefined as of this writing.
    - The extended speed byte is extended again which is undefined as of this
      writing.
    - The device Size byte is $FF.
NOTES
  Some cards may not have a size specified in the device tuple.An example
  would be an I/O card.The size would be returned as one (1) in this case.
  You should not call this function with a partial @{i}CISTPL_DEVICE@{ui}
  tuple, or the return values may be junk.
SEE ALSO
  @{"CopyTuple()" Link "CopyTuple()"}, resources/card.h, resources/card.i
@EndNode
@Node "EndCardAccess()" "card.resource/EndCardAccess"
@{b}@{u}EndCardAccess@{uu}@{ub} -- Called at the end of credit-card memory access.
  This function should be called when you are done accessing credit-card memory.
  Its effect will depend on the type of Amiga machine your code happens to be
  running on.On some machines it will cause an access light to be turned OFF
  in approximately 1/2 second.
  On machines which support an access light, the light will automatically be
  turned off when you call @{"ReleaseCard()" Link "ReleaseCard()"}.
SYNOPSIS  ULONG EndCardAccess( @{FG shine}struct@{FG text} CardHandle * );
  @{i}@{b}result@{ub}@{ui}=EndCardAccess( handle )
   d0                    a1
  @{i}handle@{ui} - Same handle as that used when @{"OwnCard()" Link "OwnCard()"} was called.
  @{i}@{b}TRUE@{ub}@{ui} if you are still the owner of the credit-card.
  @{i}@{b}FALSE@{ub}@{ui} if you are no longer the owner of the credit-card (usually
    indicating the card was removed).
NOTES
  This function may be called from within a task, or from a level 1 or level 2
  interrupt.It is highly recommended that you call this function after
  accessing credit-card memory, as well as checking the return value.
  If it is a return value of FALSE, you should stop accessing credit-card
  memory, and conclude that the card was removed before this function was
  called.On some machines it is possible that the credit-card will be
  removed before you receive the removed interrupt.
SEE ALSO
  @{"OwnCard()" Link "OwnCard()"}, @{"ReleaseCard()" Link "ReleaseCard()"}, @{"BeginCardAccess()" Link "BeginCardAccess()"}
@EndNode
@Node "GetCardMap()" "card.resource/GetCardMap"
@{b}@{u}GetCardMap@{uu}@{ub} -- Obtain pointer to CardMemoryMap structure.
  Obtain pointer to a CardMemoryMap structure.The structure is READ only.
  Devices should never assume credit-card memory appears at any
  particular place in memory.By using this function to obtain
  pointers to the base memory locations of the various credit-card
  memory types, your device will continue to work properly should
  credit cards appear in different memory locations in future hardware.
SYNOPSIS  @{FG shine}struct@{FG text} CardMemoryMap *GetCardMap( @{FG shine}void@{FG text} );
  @{i}@{b}pointer@{ub}@{ui}=GetCardMap()
   d0
  @{i}@{b}pointer@{ub}@{ui} - Pointer to CardMemoryMap structure -
    @{FG shine}struct@{FG text} CardMemoryMap {
      UBYTE *@{b}cmm_CommonMemory@{ub};
      UBYTE *@{b}cmm_AttributeMemory@{ub};
      UBYTE *@{b}cmm_IOMemory@{ub};
    };
    As of card.resource V39, this structure has been extended to include
    the size of these memory regions.See card.h/card.i for the new fields.
    If card.resource V39, use the constants.in the CardMemoryMap structure
    rather than hard coded constants for memory region size.
NOTES
  If any pointer in the structure is NULL, it means this type
  of credit-card memory is not being made available.
SEE ALSO
  resources/card.h, resources/card.i
@EndNode
@Node "IfAmigaXIP()" "card.resource/IfAmigaXIP"
@{b}@{u}IfAmigaXIP@{uu}@{ub} -- Check if a card is an Amiga execute-in-place card.
  Check to see if a card in the slot is an Amiga execute-in-place card.
  The Card Information Structure must have a valid @{i}CISTPL_AMIGAXIP@{ui} tuple.
  @{b}Tuples can be treated like structures@{ub}.
  The format of a @{i}CISTPL_AMIGAXIP@{ui} tuple is:
  @{FG shine}struct@{FG text} TP_AmigaXIP {
    UBYTE @{b}TPL_CODE@{ub};
    UBYTE @{b}TPL_LINK@{ub};
    UBYTE @{b}TP_XIPLOC@{ub}[4];
    UBYTE @{b}TP_XIPFLAGS@{ub};
    UBYTE @{b}TP_XIPRESRV@{ub};
  };
  The @{b}TPL_CODE@{ub} field must be equal to @{i}CISTPL_AMIGAXIP@{ui} (0x91).
  The @{b}TPL_LINK@{ub} field must be equal to the length of the body
    of a @{i}CISTPL_AMIGAXIP@{ui} tuple (0x06).
  The @{b}TP_XIPLOC@{ub} array is the memory location of your ROM-TAG stored in
    little-endian order.This value is stored as an "offset" into common
    memory as is the standard for storing 32 bit bit pointers in tuples.
    For example, a pointer to a ROM-TAG stored at an offset of 0x00000200
    would be stored as four bytes like so:
      0x00, 0x02, 0x00, 0x00
    Currently credit-card common memory is mapped starting at memory
    location 0x600000.Because a ROM-TAG is used, it is implied that
    execute-in-place code can be compiled/linked to use absolute
    references.It is believed that most developers will not want
    to have to write pc-relative code only.
  The @{b}TP_XIPFLAGS@{ub} field is treated as a set of flag bits.
    See card.i/h for defined bits.All undefined bits MUST be 0.
  The @{b}TP_XIPRESRV@{ub} field must be 0 for now.
  The system polls for cards which have a @{i}CISTPL_AMIGAXIP@{ui} tuple
  at the same time that it searches for devices to boot off.
  When a card with a valid @{i}CISTPL_AMIGAXIP@{ui} tuple is found, the system
  will call your ROM-TAG via Exec's @{"InitResident()" Link "exec.guide/InitResident()"} function.The system
  examines the return code from @{"InitResident()" Link "exec.guide/InitResident()"}.A NULL return in D0 means
  you are done with the card, and it can be removed by the user.A successful
  return indicates you are still using the card.Some programs (e.g., some games)
  may never return.The only requirement is that if you do return, you must leave
  the system in a "good" state (including returning most of, or all the memory
  you allocated).The standard convention for preserving registers apply.
  Note that your execute-in-place code will not be called a second time, unless
  you have returned a non-successful result.In this case your execute-in-place
  code @{b}MUST@{ub} assume the user can remove, and insert your card again.
  There are a variety of ways to check for re-insertion (e.g., search for a
  message port, device, library, task, etc., that you created).
  Note that your execute-in-place code runs in an environment similar to boot
  block games; before DOS has been initialized!
  Your execute-in-place code should @{b}NOT@{ub} try to initialize DOS because DOS
  requires a suitable disk-like device be at the head of the expansion base
  mountlist to boot off.If you need DOS, it is possible to boot off of a
  credit-card using carddisk.device.Such cards will require a valid
  @{i}CISTPL_DEVICE@{ui} tuple, and @{i}CISTPL_FORMAT@{ui} tuple.A portion of the card can be
  used for a minimal number of data blocks like the method described above.
  However this method is not recommended, though it is anticipated that some
  developers will have thought of, and used this method anyway.If you must do
  this, at least use the CardHandle returned by @{"OwnCard()" Link "OwnCard()"} to set hardware reset
  on removal else the machine will likely crash anyway if the card is removed
  while your execute-in-place code is running.
SYNOPSIS  @{FG shine}struct@{FG text} @{"Resident" Link "include:exec/resident.h/Main" 19} *IfAmigaXIP( struct CardHandle * );
  @{i}@{b}result@{ub}@{ui}=IfAmigaXIP( @{i}handle@{ui} )
   d0                 a2
  @{i}@{b}Pointer@{ub}@{ui} to a ROM-TAG on the card, or @{i}@{b}NULL@{ub}@{ui} indicating that:
    o The card does not meet the above requirements, or
    o The card has been removed, or
    o You are not the owner of the credit-card.
NOTES
  This function is being made public so developers can test
  that their execute-in-place credit-cards meet the requirements
  for an Amiga execute-in-place card.In general there is no reason
  for devices, or applications to use this function.
  Amiga execute-in-place software is identified via a tuple code
  reserved for manufacturer specific use, therefore the manufacturer
  of the card may freely use the @{i}CISTPL_VERS_1@{ui}, or @{i}CISTPL_VERS_2@{ui}
  tuples to place identification information on the credit-card.
  No attempt has been made to make use of the MS-DOS execute-in-place
  method; it is believed that most manufacturers of Amiga
  execute-in-place software will prefer a simple, and small
  scheme for running their execute-in-place code.
SEE ALSO
  @{"OwnCard()" Link "OwnCard()"}, resources/card.h, resources/card.i
@EndNode
@node OWNCARD_STRUCT_CARDHANDLE "OwnCard_struct_CardHandle"
@{b}@{u}The following fields in the structure must be filled in by the application@{uu}@{ub}
@{b}@{u}before calling OwnCard()@{uu}@{ub}:
  @{b}cah_CardNode.@{i}ln_Pri@{ui}@{ub} - See table below.
    The @{"Node" Link "include:exec/nodes.h/Main" 22} field is used by the resource to add your handle to a sorted list
    of CardHandle structures.This list is used by the resource to notify devices
    when the device owns the credit-card.
    Your device will only be notified (at most) one time per card insertion,
    and perhaps less often if some higher priority device on the notification
    list retains ownership of a card in the slot.
    @{b}@{u}Priority@{uu}@{ub}: @{b}@{u}Comments@{uu}@{ub}:
      >= 21   Reserved for future use
      10-20   To be used by third party devices (e.g., I/O CARD manufacturers)
              which look for specific card tuples to identify credit-cards.
      01-19   Reserved for future use
      00      To be used by general purpose devices which have loose
              card specification requirements.
      <= -1   Reserved for future use
  @{b}cah_CardNode.@{i}ln_Type@{ui}@{ub} - Must be set to 0 for now.
    This field may be used in the future to identify an extended
    CardHandle structure.
  @{b}cah_CardNode.@{i}ln_Name@{ui}@{ub} - Must be initialized to NULL,
    or name of device which owns this structure.
  @{b}cah_CardRemoved@{ub} - Pointer to an initialized interrupt structure.
    Only the @{i}is_Data@{ui}, and @{i}is_Code@{ui} fields need to be initialized.This is the
    interrupt code which will be called when a credit-card which your device
    owns is removed.Once you receive this interrupt, all credit-card interface
    control registers are reset (e.g., programming voltage, access speed, etc.),
    and you should stop accessing the card as soon as possible.
    Because your code is called on interrupt time, you should do the least
    amount possible, and use little stack space.This pointer can be NULL if
    you have asked for reset on card-removal, and you never turn reset off.
  @{b}cah_CardInserted@{ub} - Pointer to an initialized interrupt structure.
    Only the @{i}is_Data@{ui}, and @{i}is_Code@{ui} fields need to be initialized.This is the code
    which will be called when your CardHandle owns the credit-card in the slot.
    Note that your code may be called on the context of an interrupt, or a task
    in FORBID, therefore you should do the least amount possible, and use little
    stack space.
    Note that it is possible to receive a card removed interrupt immediately
    before you receive this interrupt if the card is removed while your
    CardInserted interrupt is being called.
    Your device owns the credit-card until the card is manually removed by the
    user, or you release the card by calling ReleaseCard()ReleaseCard()"}.
    Your device should examine the card in the slot (e.g., look for specific
    tuples), and decide if the card is of a type your device understands.If not,
    release ownership of the card by calling @{"ReleaseCard()" Link "ReleaseCard()"} so that other devices
    will be given a chance to examine the current card in the credit-card slot.
  @{b}cah_CardStatus@{ub} - Pointer to an initialized interrupt structure.
    Only the @{i}is_Data@{ui}, and @{i}is_Code@{ui} fields need to be initialized.
    Note that your code will be called on the context of an interrupt, therefore
    you should do the least amount possible, and use little stack space.
    Note that it is possible to receive a card removed interrupt immediately be-
    fore you receive this interrupt if the card is removed during this interrupt.
    If this pointer is NULL, you will not receive card status change interrupts.
    Your interrupt code will be called with a mask value in register D0, and a
    pointer to your data in A1.
    The mask value in D0 can be interpreted using the same bit definitions
    returned by @{"ReadCardStatus()" Link "ReadCardStatus()"}.
    Note that more than one bit may be set, and the mask only tells you what has
    changed, not the current state.Use @{"ReadCardStatus()" Link "ReadCardStatus()"} if you need to determine
    the current state of the status bits.
    Not all status change interrupts will necessarily be enabled on all systems.
    For example, on some systems BVD2/DA status change interrupts will not be
    enabled so that digital audio can occur without generating many interrupts.
    Status change interrupts are typically meant to be used for monitoring
    BSY/IRQ, WR, and BVD1/SC.Battery voltage low detection would best be done
    by a separate utility which periodically polls BVD1 & BVD2 by using the
    @{"ReadCardStatus()" Link "ReadCardStatus()"} function.
    Typically the mask value in D0 @{b}MUST@{ub} be returned unchanged on exit from your
    code.The return value in D0 is then used to clear the source(s) of the
    interrupt.In the rare case that you need to keep a status change interrupt
    active, clear the appropriate bit(s) in D0 before returning via RTS.Clear
    no bits other than those defined as valid bits for ReadCardStatus()!
  @{b}!!!NEW FOR V39!!!@{ub} - See definition of @{i}CARDB_POSTSTATUS@{ui} below.
  @{b}cah_CardFlags@{ub} - Optional flags (all other bits must be 0).
  - @{b}CARDB_RESETREMOVE@{ub} means you want the machine to reset if the
    credit-card in the slot is removed while you own the credit-card.
  - @{b}CARDB_IFAVAILABLE@{ub} means you only want ownership of the credit-card
    in the slot if it is immediately available.If it is available, your
    CardHandle structure will be added to a list so that you can be notified
    via an interrupt when the credit-card is removed by the user.
    If the credit-card is not immediately available (either because there is
    no credit-card in the slot, or because some other device owns the
    credit-card), your CardHandle structure will @{b}NOT@{ub} be added to the
    notification list.
  - @{b}CARDB_DELAYOWNERSHIP@{ub} means you never want a successful return from
    OwnCard() even if the credit-card is available.Rather you will be
    notified of ownership via your cah_CardInserted interrupt.If you
    use this flag, OwnCard() will always return -1.
    This flag cannot be used with the @{i}CARDB_IFAVAILABLE@{ui} flag.
  - @{b}CARDB_POSTSTATUS@{ub} is new for V39 card.resource (check resource base VERSION
    before using).It is meant to be used by drivers which want to service the
    card hardware @{b}AFTER@{ub} the status change interrupt has been cleared on the
    gate array.Previously a PORTS interrupt server had to be added to do this;
    this is somewhat more efficient, and easier to use.Your status change
    interrupt is first called with status change bits in register D0.You would
    examine these bits, and set a flag(s) for the POST callback.When you return
    from the status change interrupt, the interrupt on the gate array is cleared
    (based on what you return in register D0), and your status change interrupt
    is immediately called again, but this time with 0 in D0.The value you return
    in D0 for the POST callback case is ignored.
  @{b}ALL@{ub} other fields are used by the resource, and no fields in the structure
  may be modified while the structure is in use by the resource.If you need
  to make changes, you must remove your CardHandle (see @{"ReleaseCard()" Link "ReleaseCard()"}),
  make the changes, and then call OwnCard() again.
@endnode
@Node "OwnCard()" "card.resource/OwnCard"
@{b}@{u}OwnCard@{uu}@{ub} -- Own credit card registers, and memory.
  This function is used to obtain immediate, or deferred ownership of a
  credit-card in the credit-card slot.Typically an EXEC STYLE DEVICE will be
  written to interface between an application, and a credit card in the slot.
  While applications and libraries can attempt to own a credit-card in the card
  slot, the rest of this documentation assumes a device interface will be used.
  Because credit-cards can be inserted, or removed by the user at any time
  (otherwise known as HOT-INSERTION, and HOT-REMOVAL), the card.resource
  provides devices with a protocol which lets many devices bid for ownership
  of a newly inserted card.
  In general, devices should support HOT-REMOVAL, however there are legitimate
  cases where HOT-REMOVAL is not practical.For these cases this function allows
  you to own the resource using the @{i}CARDB_RESETREMOVE@{ui} flag.If the card is remo-
  ved before your device calls @{"ReleaseCard()" Link "ReleaseCard()"}, the machine will RESET.
SYNOPSIS  @{FG shine}struct@{FG text} CardHandle *OwnCard( @{FG shine}struct@{FG text} CardHandle * );
  @{i}@{b}return@{ub}@{ui} = OwnCard( @{i}handle@{ui} )
   d0                a1
  @{i}handle@{ui} - pointer to a CardHandle structure.
    @{FG shine}struct@{FG text} CardHandle {
      @{FG shine}struct@{FG text} @{"Node" Link "include:exec/nodes.h/Main" 22}      @{b}cah_CardNode@{ub};
      @{FG shine}struct@{FG text} @{"Interrupt" Link "include:exec/interrupts.h/Main" 23} *@{b}cah_CardRemoved@{ub};
      @{FG shine}struct@{FG text} @{"Interrupt" Link "include:exec/interrupts.h/Main" 23} *@{b}cah_CardInserted@{ub};
      @{FG shine}struct@{FG text} @{"Interrupt" Link "include:exec/interrupts.h/Main" 23} *@{b}cah_CardStatus@{ub};
      UBYTE      @{b}cah_CardFlags@{ub};
    };
    @{"Fields in the structure" link OWNCARD_STRUCT_CARDHANDLE} that must be filled in by the application
    before calling OwnCard().
   @{i}@{b}0@{ub}@{ui} - indicates success, your device owns the credit card.
  @{i}@{b}-1@{ub}@{ui} - indicates that the card cannot be owned
    (most likely because there is no card in the credit card slot).
  @{i}@{b}ptr@{ub}@{ui} - indicates failure.
    Returns pointer to the CardHandle structure which owns the credit card.
NOTES
  This function should only be called from a task.
  CardHandle interrupts are called with a pointer to your data in A1, and a
  pointer to your code in A5.With the exception of status change interrupts,
  D0-D1, A0-A1, and A5-A6 may be treated as scratch registers.Status change
  interrupts are also called with meaningful data in D0, and expect D0 be
  preserved upon RTS from your code.No other registers are guaranteed to
  contain initialized data.All other registers must be preserved.
SEE ALSO
  @{"ReleaseCard()" Link "ReleaseCard()"}, @{"ReadCardStatus()" Link "ReadCardStatus()"}, resources/card.i, resources/card.h
@EndNode
@Node "ReadCardStatus()" "card.resource/ReadCardStatus"
@{b}@{u}ReadCardStatus@{uu}@{ub} -- Read credit card status register.
  Returns current state of the credit card status register.
  See card.h/i for bit definitions.
  Note that the meaning of the returned status bits may vary
  depending on the type of card inserted in the slot, and
  mode of operation.Interpretation of the bits is left up
  to the application.
SYNOPSIS  UBYTE ReadCardStatus( @{FG shine}void@{FG text} );
  @{i}@{b}status@{ub}@{ui}=ReadCardStatus()
   d0
  A UBYTE value to be interpreted as @{i}@{b}status@{ub}@{ui} bits.
NOTES
  This function may be called from within a task, or from any level interrupt.
SEE ALSO
  resources/card.h, resources/card.i
@EndNode
@Node "ReleaseCard()" "card.resource/ReleaseCard"
@{b}@{u}ReleaseCard@{uu}@{ub} -- Release ownership of credit card.
  This function releases ownership of the credit card in the slot.
  The access light (if any) is automatically turned off (if it was turned on)
  when you release ownership of a card you owned, and all credit-card control
  registers are reset to their default state.
  @{b}@{u}You must call this function if@{uu}@{ub}:
  - You own the credit-card, and want to release it so that other devices
    on the notification list will have a chance to examine the credit-card
    in the card slot.
  - You took a Card Removed interrupt while you owned the credit-card.If so,
    you @{b}MUST@{ub} call this function, else no other task will be notified of newly
    inserted cards.On some machines the credit-card interface hardware may
    also be left disabled until you respond to the card removed interrupt by
    calling this function.
  - You want to remove yourself from the notification list
    (see optional flags below).
SYNOPSIS  @{FG shine}void@{FG text} ReleaseCard( @{FG shine}struct@{FG text} CardHandle *, ULONG );
  ReleaseCard( @{i}handle@{ui}, @{i}flags@{ui} )
                a1      d0
  @{i}handle@{ui} - Same handle as that used when @{"OwnCard()" Link "OwnCard()"} was called.
  @{i}flags@{ui} - Optional flags.
  - @{b}CARDB_REMOVEHANDLE@{ub} means you want remove your CardHandle structure from
    the notification list whether or not you currently own the credit-card
    in the card slot.The node structure in your CardHandle will be removed
    from the notification list, and ownership will be released if you were
    the owner of the card.
NOTES
  This function should only be called from a task.
SEE ALSO
  @{"OwnCard()" Link "OwnCard()"}, resources/card.i, resources/card.h
@EndNode
@Node "--background--" "FileSystem.resource/--background--"
PURPOSE
  The FileSystem.resource is where boot disk drivers rendezvous to share
  file system code segments for partitions specified by dos type.Prior to V36,
  it was created by the first driver that needed to use it.For V36, its creation
  is ensured by the rom boot process.
CONTENTS
  The FileSystem.resource is described in the include file
   @{"resources/filesysres.h" Link "include:resources/filesysres.h/Main" 0}.The nodes on it describe how to algorithmically
  convert the result of @{"MakeDosNode" Link "ROMlibs/MakeDosNode()"} (from the expansion.library) to a node
  appropriate for the dos type.
  @{"FileSysEntry" Link "include:resources/filesysres.h/Main" 32}:
    @{b}fse_Node@{ub} - on @{i}fsr_FileSysEntries@{ui} list @{i}ln_Name@{ui} is of creator of this entry
    @{b}fse_DosType@{ub} - DosType of this FileSys
      (e.g. 0x444f5301 for the fast file system).
    @{b}fse_Version@{ub} - high word is the version, low word is the revision.
    @{b}fse_PatchFlags@{ub} - bits set for those of the following that need to be
      substituted into a standard device node for this file system
      (e.g. $180 for substitute SegList & GlobalVec).
    @{b}fse_Type@{ub} - device node type: zero
    @{b}fse_Task@{ub} - standard dos "task" field
    @{b}fse_Lock@{ub} - must be zero
    @{b}fse_Handler@{ub} - for V36, if bit 31 is set, this is not an AmigaDOS partition.
    @{b}fse_StackSize@{ub} - stacksize to use when starting task
    @{b}fse_Priority@{ub} - task priority when starting task
    @{b}fse_Startup@{ub} - startup msg: @{"FileSysStartupMsg" Link "include:dos/filehandler.h/Main" 85} for disks
    @{b}fse_SegList@{ub} - segment of code to run to start new task
    @{b}fse_GlobalVec@{ub} - BCPL global vector when starting task
  No more entries need exist than those implied by @{i}fse_PatchFlags@{ui},
  so entries do not have a fixed size.For V36, for example, the
  entry for the fast file system (@{i}fse_DosType@{ui} 0x444f5301)
  contains a zero @{i}fse_PatchFlags@{ui}, and thus no entries beyond that.
@EndNode
@Node "AllocUnit()" "disk.resource/AllocUnit"
@{b}@{u}AllocUnit@{uu}@{ub} - allocate a unit of the disk.
  This routine allocates one of the units of the disk.It should be called
  before trying to use the disk (via GetUnit).
  In reality, it is perfectly fine to use @{"GetUnit/GiveUnit" Link "GiveUnit()"} if AllocUnit fails.
  Do @{b}NOT@{ub} call @{"FreeUnit" Link "FreeUnit()"} if AllocUnit did not succeed.This has been the case
  for all revisions of disk.resource.
SYNOPSIS  BOOL AllocUnit(LONG);
  @{b}@{i}Success@{ui}@{ub} = AllocUnit( @{i}unitNum@{ui} ), DRResource
   D0                   D0         A6
  @{i}unitNum@{ui} -- a legal unit number (zero through three)
  @{b}@{i}Success@{ui}@{ub} -- nonzero if successful, zero on failure.
@EndNode
@Node "FreeUnit()" "disk.resource/FreeUnit"
@{b}@{u}FreeUnit@{uu}@{ub} - deallocate the disk.
  This routine deallocates one of the units of the disk.It should be called
  when done with the disk.Do not call it if you did not successfully allocate
  the disk (there is no protection -- you will probably crash the disk system).
SYNOPSIS  @{FG shine}void@{FG text} FreeUnit(LONG);
  FreeUnit( @{i}unitNum@{ui} ), DRResource
   D0         A6
  @{i}unitNum@{ui} -- a legal unit number (zero through three)
BUGS
  Doesn't check if you own the unit, or even if anyone owns it.
@EndNode
@Node "GetUnit()" "disk.resource/GetUnit"
@{b}@{u}GetUnit@{uu}@{ub} - allocate the disk for a driver.
  This routine allocates the disk to a driver.It is either immediately available,
  or the request is saved until the disk is available.When it is available, your
  unitPointer is sent back to you (via ReplyMsg).You may then reattempt the
  GetUnit.Allocating the disk allows you to use the disk's resources.Remember
  however that there are four units to the disk; you are only one of them.
  Please be polite to the other units (by never selecting them, and by not
  leaving interrupts enabled, etc.).
  @{b}@{u}When you are done, please leave the disk in the following state@{uu}@{ub}:
  - dmacon dma bit ON
  - dsklen dma bit OFF (write a #DSKDMAOFF to dsklen)
  - adkcon disk bits -- any way you want
  - entena:disk sync and disk block interrupts -- Both DISABLED
  - @{"CIA" Link "include:hardware/cia.h/Main" 29} resource index interrupt -- DISABLED
  - 8520 outputs -- doesn't matter, because all bits will be set to inactive
    by the resource.
  - 8520 data direction regs -- restore to original state.
SYNOPSIS  @{FG shine}struct@{FG text} @{"DiscResourceUnit" Link "include:resources/disk.h/Main" 41} *GetUnit(struct DiscResourceUnit *);
  @{b}@{i}lastDriver@{ui}@{ub} = GetUnit( @{i}unitPointer@{ui} ), DRResource
   D0                    A1             A6
  @{i}unitPtr@{ui} - a pointer you your disk resource unit structure.
    Note that the message filed of the structure @{b}MUST@{ub} be a valid message,
    ready to be replied to.Make sure @{i}ln_Name@{ui} points to a null-terminated string,
    preferably one that identifies your program.
    @{i}NOTE@{ui}: GetUnit() does @{b}NOT@{ub} turn on the interrupts for you.
    You must use @{"AbleICR" Link "AbleICR()"} (for the index interrupt) or intena
    (for the diskbyte and diskblock interrupts) to turn them on.
    You should turn them off before calling @{"GiveUnit" Link "GiveUnit()"}, as stated above.
    You need to set up the three interrupt structures,in particular the
    @{i}IS_DATA@{ui} and @{i}IS_CODE@{ui} fields.Set them to NULL if you don't need that interrupt.
    Also, set the @{i}ln_Type@{ui} of the interrupt structure to @{i}NT_INTERRUPT@{ui}.
    @{b}WARNING:@{ub} don't turn on a disk resource interrupt unless
    the @{i}IS_CODE@{ui} for that interrupt points to executable code!
    @{i}IS_CODE@{ui} will be called with @{i}IS_DATA@{ui} in A1 when the interrupt occurs.
    Preserve all regs but D0/D1/A0/A1.Do not make assumptions about A0.
  @{b}@{i}lastDriver@{ui}@{ub} - if the disk is not busy, then the last unit
    to use the disk is returned.This may be used to see if a driver needs
    to reset device registers.(If you were the last user, then no one has
    changed any of the registers.If someone else has used it,then any allowable
    changes may have been made).If the disk is busy, then a null is returned.
SEE ALSO
  @{"GiveUnit" Link "GiveUnit()"}
@EndNode
@Node "GetUnitID()" "disk.resource/GetUnitID"
@{b}@{u}GetUnitID@{uu}@{ub} - find out what type of disk is out there.
  Gets the drive ID for a given unit.Note that this value may
  change if someone calls @{"ReadUnitID" Link "ReadUnitID()"}, and the drive id changes.
SYNOPSIS  LONG GetUnitID(LONG);
 @{b}@{i}idtype@{ui}@{ub} = GetUnitID( @{i}unitNum@{ui} ), DRResource
   D0                 D0         A6
  @{i}unitNum@{ui} -- a legal unit number (zero through three)
  @{b}@{i}idtype@{ui}@{ub} -- the type of the disk drive.
    Standard types are defined in the resource include file.
SEE ALSO
  @{"ReadUnitID" Link "ReadUnitID()"}
@EndNode
@Node "GiveUnit()" "disk.resource/GiveUnit"
@{b}@{u}GiveUnit@{uu}@{ub} - Free the disk back up.
  This routine frees the disk after a driver is done with it.
  If others are waiting, it will notify them.
SYNOPSIS  @{FG shine}void@{FG text} GiveUnit();
  GiveUnit(), DRResource
   A6
BUGS
  In pre-V36, GiveUnit didn't check if you owned the unit.A patch
  for this was part of 1.3.1 SetPatch.Fixed in V36.
SEE ALSO
  @{"GetUnit" Link "GetUnit()"}
@EndNode
@Node "ReadUnitID()" "disk.resource/ReadUnitID"
@{b}@{u}ReadUnitID@{uu}@{ub} - reread and return the type of drive.(V37)
  Rereads the drive id for a specific unit (for handling drives
  that change ID according to what sort of disk is in them.You
  @{b}MUST@{ub} have done a @{"GetUnit" Link "GetUnit()"} before calling this function!
SYNOPSIS  ULONG ReadUnitID(LONG);
  @{b}@{i}idtype@{ui}@{ub} = ReadUnitID( @{i}unitNum@{ui} ), DRResource
   D0                   D0         A6
  @{i}unitNum@{ui} -- a legal unit number (zero through three)
  @{b}@{i}idtype@{ui}@{ub} -- the type of the disk drive.
    Standard types are defined in the resource include file.
SEE ALSO
  @{"GetUnitID" Link "GetUnitID()"}
@EndNode
@Node "AbleICR()" "cia.resource/AbleICR"
@{b}@{u}AbleICR@{uu}@{ub} -- Enable/disable ICR interrupts.
  This function provides a means of enabling and disabling 8520 @{"CIA" Link "include:hardware/cia.h/Main" 29} interrupt
  control registers.In addition it returns the previous enable mask.
SYNOPSIS  WORD AbleICR( WORD );
  @{b}@{i}oldMask@{ui}@{ub} = AbleICR( @{i}mask@{ui} )
   D0                 D0
  @{i}mask@{ui} - A bit mask indicating which interrupts to be modified.
    If bit 7 is clear the mask indicates interrupts to be disabled.
    If bit 7 is set, the mask indicates interrupts to be enabled.
    Bit positions are identical to those in 8520 ICR.
  @{b}@{i}oldMask@{ui}@{ub} - The previous enable mask before the requested changes.
    To get the current mask without making changes, call the function
    with a null parameter.
EXAMPLES
  @{i}Get the current mask@{ui}:
    @{i}mask@{ui} = AbleICR(0)
  @{i}Enable both timer interrupts@{ui}:
    AbleICR(0x83)
  @{i}Disable serial port interrupt@{ui}:
    AbleICR(0x08)
EXCEPTIONS
  Enabling the mask for a pending interrupt will cause an immediate processor
  interrupt (that is if everything else is enabled).You may want to clear the
  pending interrupts with @{"SetICR()" Link "SetICR()"} prior to enabling them.
NOTE
  The CIA resources are special in that there is more than one of them
  in the system.Because of this, the C language stubs in amiga.lib for the
  CIA resources require an @{b}extra parameter@{ub} to specify which CIA resource to use.
  @{b}@{u}The synopsys for the amiga.lib stubs is as follows@{uu}@{ub}:
  WORD AbleICR( @{FG shine}struct@{FG text} @{"Library" Link "include:exec/libraries.h/Main" 34} *, WORD );
  @{b}@{i}oldMask@{ui}@{ub} = AbleICR( @{i}Resource@{ui}, @{i}mask@{ui} )
   D0                 A6        D0
SEE ALSO
  @{"SetICR()" Link "SetICR()"}
@EndNode
@Node "AddICRVector()" "cia.resource/AddICRVector"
@{b}@{u}AddICRVector@{uu}@{ub} -- attach an interrupt handler to a @{"CIA" Link "include:hardware/cia.h/Main" 29} bit.
  Assign interrupt processing code to a particular interrupt bit of the CIA ICR.
  If the interrupt bit has already been assigned, this function will fail, and
  return a pointer to the owner interrupt.If it succeeds, a null is returned.
  This function will also enable the CIA interrupt for the given ICR bit.
SYNOPSIS
  @{FG shine}struct@{FG text} @{"Interrupt" Link "include:exec/interrupts.h/Main" 23} *AddICRVector( WORD, @{FG shine}struct@{FG text} Interrupt * );
  @{i}@{b}interrupt@{ub}@{ui} = AddICRVector( @{i}iCRBit@{ui}, @{i}interrupt@{ui} )
   D0                        D0       A1
  @{i}iCRBit@{ui} - Bit number to set (0..4).
  @{i}interrupt@{ui} - Pointer to interrupt structure.
  @{i}@{b}interrupt@{ub}@{ui} - Zero if successful, otherwise returns a pointer to the
    current owner interrupt structure.
NOTE
  A processor interrupt may be generated immediatly if this call is successful.
  In general, it is probably best to only call this function while DISABLED so
  that the resource to which the interrupt handler is being attached may be set
  to a known state before the handler is called.You @{b}MUST NOT@{ub} change the state
  of the resource before attaching your handler to it.
  The CIA resources are special in that there is more than one of them in the
  system.Because of this, the C language stubs in amiga.lib for the CIA
  resources require an @{b}extra parameter@{ub} to specify which CIA resource to use.
  @{b}@{u}The synopsys for the amiga.lib stubs is as follows@{uu}@{ub}:
  @{FG shine}struct@{FG text} @{"Interrupt" Link "include:exec/interrupts.h/Main" 23} *AddICRVector( @{FG shine}struct@{FG text} @{"Library" Link "include:exec/libraries.h/Main" 34} *, WORD, @{FG shine}struct@{FG text} Interrupt *);
  @{i}@{b}interrupt@{ub}@{ui} = AddICRVector( @{i}Resource@{ui}, @{i}iCRBit@{ui}, @{i}interrupt@{ui} )
   D0                        A6         D0      A1
@{b}***WARNING***@{ub}
  Never assume that any of the CIA hardware is free for use.Always use the
  AddICRVector() function to obtain ownership of the CIA hardware registers
  your code will use.
  Note that there are two (2) interval timers per CIA.If your application
  needs one of the interval timers, you can try to obtain any one of the
  four (4) until AddICRVector() succeeds.If all four interval timers
  are in-use, your application should exit cleanly.
  If you just want ownership of a CIA hardware timer, or register, but do not
  want interrupts generated, use the AddICRVector() function to obtain ownership,
  and use the @{"AbleICR()" Link "AbleICR()"} function to turn off (or on) interrupts as needed.
  Note that CIA-B generates level 6 interrupts (which can degrade
  system performance by blocking lower priority interrupts).As usual,
  interrupt handling code should be optimized for speed.
  Always call @{"RemICRVector()" Link "RemICRVector()"} when your code exits to release
  ownership of any CIA hardware obtained with AddICRVector().
SEE ALSO
  @{"RemICRVector()" Link "RemICRVector()"}, @{"AbleICR()" Link "AbleICR()"}
@EndNode
@Node "RemICRVector()" "cia.resource/RemICRVector"
@{u}@{b}RemICRVector@{ub}@{uu} -- Detach an interrupt handler from a @{"CIA" Link "include:hardware/cia.h/Main" 29} bit.
  Disconnect interrupt processing code for a particular interrupt bit of the CIA
  ICR.This function will also disable the CIA interrupt for the given ICR bit.
SYNOPSIS  @{FG shine}void@{FG text} RemICRVector( WORD, @{FG shine}struct@{FG text} @{"Interrupt" Link "include:exec/interrupts.h/Main" 23} *);
  RemICRVector( @{i}iCRBit@{ui}, @{i}interrupt@{ui} )
                 D0       A1
  @{i}iCRBit@{ui} - Bit number to set (0..4).
  @{i}interrupt@{ui} - Pointer to interrupt structure.
NOTE
  The CIA resources are special in that there is more than one of them in the
  system.Because of this, the C language stubs in amiga.lib for the CIA
  resources require an @{b}extra parameter@{ub} to specify which CIA resource to use.
  @{b}@{u}The synopsys for the amiga.lib stubs is as follows@{uu}@{ub}:
  @{FG shine}void@{FG text} RemICRVector( @{FG shine}struct@{FG text} @{"Library" Link "include:exec/libraries.h/Main" 34} *, WORD, @{FG shine}struct@{FG text} @{"Interrupt" Link "include:exec/interrupts.h/Main" 23} *);
  RemICRVector( @{i}Resource@{ui}, @{i}iCRBit@{ui}, @{i}interrupt@{ui} )
                 A6         D0      A1
SEE ALSO
  @{"AddICRVector()" Link "AddICRVector()"}
@EndNode
@Node "SetICR()" "cia.resource/SetICR"
@{b}@{u}SetICR@{uu}@{ub} -- Cause, clear, and sample ICR interrupts.
  This function provides a means of reseting, causing, and
  sampling 8520 @{"CIA" Link "include:hardware/cia.h/Main" 29} interrupt control registers.
SYNOPSIS  WORD SetICR( WORD );
  @{i}@{b}oldMask@{ub}@{ui} = SetICR( @{i}mask@{ui} )
   D0                D0
  @{i}mask@{ui} - A bit mask indicating which interrupts to be effected.
    If bit 7 is clear the mask indicates interrupts to be reset.
    If bit 7 is set, the mask indicates interrupts to be caused.
    Bit positions are identical to those in 8520 ICR.
  @{i}@{b}oldMask@{ub}@{ui} - The previous interrupt register status before making the
    requested changes.To sample current status without making changes,
    call the function with a null parameter.
EXAMPLES
  @{i}Get the interrupt mask@{ui}:
    @{i}mask@{ui} = SetICR(0)
  @{i}Clear serial port interrupt@{ui}:
    SetICR(0x08)
NOTE
  The CIA resources are special in that there is more than one of them in the
  system.Because of this, the C language stubs in amiga.lib for the CIA
  resources require an @{b}extra parameter@{ub} to specify which CIA resource to use.
  @{b}@{u}The synopsys for the amiga.lib stubs is as follows@{uu}@{ub}:
  WORD SetICR( @{FG shine}struct@{FG text} @{"Library" Link "include:exec/libraries.h/Main" 34} *, WORD );
  @{i}@{b}oldMask@{ub}@{ui} = SetICR( @{i}Resource@{ui}, @{i}mask@{ui} )
   D0                A6        D0
@{b}***WARNING***@{ub}
  Never read the contents of the CIA interrupt control registers directly.
  Reading the contents of one of the CIA interrupt control registers clears
  the register.This can result in interrupts being missed by critical
  operating system code, and other applications.
EXCEPTIONS
  Setting an interrupt bit for an enabled interrupt will cause
  an immediate interrupt.
SEE ALSO
  @{"AbleICR()" Link "AbleICR()"}
@EndNode
@Node "AllocMiscResource()" "misc.resource/AllocMiscResource"
@{b}@{u}AllocMiscResource@{uu}@{ub} - allocate one of the miscelaneous resources.
  This routine attempts to allocate one of the miscellaneous resources
  If the resource had already been allocated, an error is returned.If
  you do get it, your name is associated with the resource (so a user
  can see who has it allocated).
  This function may not be called from interrupt code.
DESCRIPTION
  There are certain parts of the hardware that a multitasking-friendly
  program may need to take over.The serial port is a good example.By
  grabbing the @{i}misc.resource@{ui} for the serial port, the caller would
  "own" the hardware registers associated with that function.Nobody
  else, including the system serial driver, is allowed to interfere.
  @{b}Resources are called in exactly the same manner as libraries@{ub}.
  From assembly language, A6 must equal the resource base.The offsets
  for the function are listed in the resources/misc.i include file
  (@{i}MR_ALLOCMISCRESOURCE@{ui} for this function).
SYNOPSIS  @{FG shine}char@{FG text} * AllocMiscResource( ULONG, @{FG shine}char@{FG text} * );
  @{i}@{b}CurrentUser@{ub}@{ui} = AllocMiscResource( @{i}unitNum@{ui}, @{i}name@{ui} )
   D0                               D0        A1
  @{i}unitNum@{ui} - the number of the resource you want to allocate (eg.@{i}MR_SERIALBITS@{ui}).
  @{i}name@{ui} - a mnenonic name that will help the user figure out what piece of
    software is hogging a resource.
    (@{i}havoc breaks out if a name of null is passed in...@{ui})
  @{i}@{b}CurrentUser@{ub}@{ui} - if the resource is busy, then the name of the current user
    is returned.If the resource is free, then null is returned.
SEE ALSO
  resources/misc.i, @{"FreeMiscResource()" Link "FreeMiscResource()"}
@EndNode
@Node "FreeMiscResource()" "misc.resource/FreeMiscResource"
@{b}@{u}FreeMiscResource@{uu}@{ub} - make a resource available for reallocation.
  This routine frees one of the resources allocated by @{"AllocMiscResource" Link "AllocMiscResource()"}.
  The resource is made available for reuse.
  FreeMiscResource must be called from the same task that called
  AllocMiscResource.This function may not be called from interrupt code.
SYNOPSIS  @{FG shine}void@{FG text} FreeMiscResource( ULONG );
  FreeMiscResource( @{i}unitNum@{ui} )
                     D0
  @{i}unitNum@{ui} - the number of the miscellaneous resource to be freed.
  Frees the appropriate resource.
SEE ALSO
  resources/misc.i, @{"AllocMiscResource()" Link "AllocMiscResource()"}
@EndNode
@Node "AllocPotBits()" "potgo.resource/AllocPotBits"
@{b}@{u}AllocPotBits@{uu}@{ub} -- Allocate bits in the potgo register.
  The AllocPotBits routine allocates bits in the hardware potgo register
  that the application wishes to manipulate via @{"WritePotgo" Link "WritePotgo()"}.The request
  may be for more than one bit.A user trying to allocate bits may find that
  they are unavailable because they are already allocated, or because the
  start bit itself (bit 0) has been allocated, or if requesting the start bit,
  because input bits have been allocated.A user can block itself from allo-
  cation: i.e. it should FreePotgoBits the bits it has and re-AllocPotBits
  if it is trying to change an allocation involving the start bit.
SYNOPSIS  UWORD AllocPotBits( UWORD );
  @{b}@{i}allocated@{ui}@{ub} = AllocPotBits(@{i}bits@{ui})
   D0                       D0
  @{i}bits@{ui} - a description of the hardware bits that the application wishes
    to manipulate, loosely based on the register description itself:
      @{b}START@{ub} (bit 0) - set if you wish to use start (i.e.start the proportional
        controller counters) with the input ports you allocate (below).You must
        allocate all the @{i}DATxx@{ui} ports you want to apply @{i}START@{ui} to in this same
        call, with the @{i}OUTxx@{ui} bit clear.
      @{b}DATLX@{ub} (bit 8) - set if you wish to use the port associated with the
        left (0) controller, pin 5.
      @{b}OUTLX@{ub} (bit 9) - set if you promise to use the @{i}LX@{ui} port in output mode only.
        The port is not set to output for you at this time -- this bit set
        indicates that you don't mind if @{i}STARTs@{ui} are initiated at any time by
        others, since ports that are enabled for output are unaffected by @{i}START@{ui}.
      @{b}DATLY@{ub} (bit 10) - as @{i}DATLX@{ui} but for the left (0) controller, pin 9.
      @{b}OUTLY@{ub} (bit 11) - as @{i}OUTLX@{ui} but for @{i}LY@{ui}.
      @{b}DATRX@{ub} (bit 12) - the right (1) controller, pin 5.
      @{b}OUTRX@{ub} (bit 13) - @{i}OUT@{ui} for @{i}RX@{ui}.
      @{b}DATRY@{ub} (bit 14) - the right (1) controller, pin 9.
      @{b}OUTRY@{ub} (bit 15) - @{i}OUT@{ui} for @{i}RY@{ui}.
  @{b}@{i}allocated@{ui}@{ub} - the @{i}START@{ui} and @{i}DATxx@{ui} bits of those requested that were granted.
    The @{i}OUTxx@{ui} bits are don't cares.
@EndNode
@Node "FreePotBits()" "potgo.resource/FreePotBits"
@{b}@{u}FreePotBits@{uu}@{ub} -- Free allocated bits in the potgo register.
  The FreePotBits routine frees previously allocated bits in the
  hardware potgo register that the application had allocated via
  @{"AllocPotBits" Link "AllocPotBits()"} and no longer wishes to use.It accepts the  return
  value from @{"AllocPotBits" Link "AllocPotBits()"} as its argument.
SYNOPSIS  @{FG shine}void@{FG text} FreePotBits( UWORD );
  FreePotBits(@{i}allocated@{ui})
               D0
@EndNode
@Node "WritePotgo()" "potgo.resource/WritePotgo"
@{b}@{u}WritePotgo@{uu}@{ub} -- Write to the hardware potgo register.
  The WritePotgo routine sets and clears bits in the hardware
  potgo register.Only those bits specified by the mask are
  affected -- it is improper to set bits in the mask that you
  have not successfully allocated.The bits in the high byte
  are saved to be maintained when other users write to the
  potgo register.The @{i}START@{ui} bit is not saved, it is written
  only explicitly as the result of a call to this routine with
  the START bit set: other users will not restart it.
SYNOPSIS  @{FG shine}void@{FG text} WritePotgo( UWORD, UWORD );
  WritePotgo(@{i}word@{ui}, @{i}mask@{ui})
              D0    D1
  @{i}word@{ui} - the data to write to the hardware potgo register and
    save for further use, except the START bit, which is not saved.
  @{i}mask@{ui} - those bits in word that are to be written.
    Other bits may have been provided by previous calls to this routine,
    and default to zero.
@EndNode
@Node "ObtainBattSemaphore()" "battmem.resource/ObtainBattSemaphore"
@{b}@{u}ObtainBattSemaphore@{uu}@{ub} -- Obtain access to nonvolatile ram.(V36)
  Aquires exclusive access to the system nonvolatile ram.
SYNOPSIS  @{FG shine}void@{FG text} ObtainBattSemaphore( @{FG shine}void@{FG text} );
  ObtainBattSemaphore()
@EndNode
@Node "ReadBattMem()" "battmem.resource/ReadBattMem"
@{b}@{u}ReadBattMem@{uu}@{ub} -- Read a bitstring from nonvolatile ram.(V36)
  Read a bitstring from nonvolatile ram.
SYNOPSIS  ULONG ReadBattMem( APTR, ULONG, ULONG );
  @{b}@{i}Error@{ui}@{ub} = ReadBattMem( @{i}Buffer@{ui}, @{i}Offset@{ui}, @{i}Len@{ui} )
   D0                   A0       D0      D1
  @{i}Buffer@{ui} - Where to put the bitstring.
  @{i}Offset@{ui} - Bit offset of first bit to read.
  @{i}Len@{ui} - Length of bitstring to read.
  @{b}@{i}Error@{ui}@{ub} - Zero if no error.
NOTES
  The battery-backed memory is checksummed.If a checksum error is detected,
  all bits in the battery-backed memory are silently set to zero.
  Bits in the battery-backed memory that do not exist are read as zero.
  Partial byte reads (less than 8 bits) result in the bits read
  being put in the low-order bits of the destination byte.
@EndNode
@Node "ReleaseBattSemaphore()" "battmem.resource/ReleaseBattSemaphore"
@{b}@{u}ReleaseBattSemaphore@{uu}@{ub} -- Allow nonvolatile ram to others.(V36)
  Relinquish exclusive access to the system nonvolatile ram.
SYNOPSIS  @{FG shine}void@{FG text} ReleaseBattSemaphore( @{FG shine}void@{FG text} );
  ReleaseBattSemaphore()
@EndNode
@Node "WriteBattMem()" "battmem.resource/WriteBattMem"
@{b}@{u}WriteBattMem@{uu}@{ub} -- Write a bitstring to nonvolatile ram.(V36)
  Write a bitstring to the nonvolatile ram.
SYNOPSIS  ULONG WriteBattMem( APTR, ULONG, ULONG );
  @{b}@{i}Error@{ui}@{ub} = WriteBattMem( @{i}Buffer@{ui}, @{i}Offset@{ui}, @{i}Len@{ui} )
   D0                    A0       D0      D1
  @{i}Buffer@{ui} - Where to get the bitstring.
  @{i}Offset@{ui} - Bit offset of first bit to write.
  @{i}Len@{ui} - Length of bitstring to write.
  @{b}@{i}Error@{ui}@{ub} - Zero if no error.
NOTES
  The battery-backed memory is checksummed.If a checksum error is detected,
  all bits in the battery-backed memory are silently set to zero.
  Partial byte writes (less than 8 bits) result in the bits
  written being read from the low-order bits of the source byte.
@EndNode
@Node "ReadBattClock()" "battclock.resource/ReadBattClock"
@{b}@{u}ReadBattClock@{uu}@{ub} -- Read time from clock chip.(V36)
  This routine reads the time from the clock chip and returns it
  as the number of seconds from 01-jan-1978.
SYNOPSIS  ULONG ReadBattClock( @{FG shine}void@{FG text} );
  @{b}@{i}AmigaTime@{ui}@{ub} = ReadBattClock()
   D0
  @{b}@{i}AmigaTime@{ui}@{ub} - The number of seconds from 01-Jan-1978
    that the clock chip thinks it is.
NOTES
  If the clock chip returns an invalid date, the clock chip is reset
  and 0 is returned.
@EndNode
@Node "ResetBattClock()" "battclock.resource/ResetBattClock"
@{b}@{u}ResetBattClock@{uu}@{ub} -- Reset the clock chip.(V36)
  This routine does whatever is neeeded to put the clock chip
  into a working and usable state and also sets the date on the
  clock chip to 01-Jan-1978.
SYNOPSIS  @{FG shine}void@{FG text} ResetBattClock( @{FG shine}void@{FG text} );
  ResetBattClock()
@EndNode
@Node "WriteBattClock()" "battclock.resource/WriteBattClock"
@{b}@{u}WriteBattClock@{uu}@{ub} -- Set the time on the clock chip.(V36)
  This routine writes the time given in AmigaTime to the clock chip.
SYNOPSIS  @{FG shine}void@{FG text} WriteBattClock( ULONG );
  WriteBattClock( @{i}AmigaTime@{ui} )
                   D0
  @{i}AmigaTime@{ui} - The number of seconds from 01-Jan-1978 to the
    time that should be written to the clock chip.
@EndNode

