@database "dos"
@master "Work:Programing/sc/OS3.1_Docs/doc/dos.doc"

@Node Main "dos.doc"
@{b}@{u}File infos@{uu}@{ub}:                          @{b}@{u}DOS objects@{uu}@{ub}:    @{b}@{u}Device lists@{uu}@{ub}:
@{"CreateDir()" Link "CreateDir()"}         @{"Info()" Link "Info()"}         @{"IsFileSystem()" Link "IsFileSystem()"} @{"AssignLate()" Link "AssignLate()"}
@{"CurrentDir()" Link "CurrentDir()"}        @{"Rename()" Link "Rename()"}       @{"Lock()" Link "Lock()"}         @{"AssignLock()" Link "AssignLock()"}
@{"ParentDir()" Link "ParentDir()"}         @{"DateStamp()" Link "DateStamp()"}    @{"LockRecord()" Link "LockRecord()"}   @{"AssignPath()" Link "AssignPath()"}
@{"ParsePatternNoCase()" Link "ParsePatternNoCase()"}@{"SetFileSize()" Link "SetFileSize()"}  @{"LockRecords()" Link "LockRecords()"}  @{"AssignAdd()" Link "AssignAdd()"}
@{"MatchPatternNoCase()" Link "MatchPatternNoCase()"}@{"SetFileDate()" Link "SetFileDate()"}  @{"DupLock()" Link "DupLock()"}      @{"RemAssignList()" Link "RemAssignList()"}
@{"ParsePattern()" Link "ParsePattern()"}      @{"SetOwner()" Link "SetOwner()"}     @{"DupLockFromFH()" Link "DupLockFromFH()"}@{"GetDeviceProc()" Link "GetDeviceProc()"}
@{"MatchPattern()" Link "MatchPattern()"}      @{"SetProtection()" Link "SetProtection()"}@{"UnLock()" Link "UnLock()"}       @{"DeviceProc()" Link "DeviceProc()"}
@{"MatchFirst()" Link "MatchFirst()"}        @{"SetComment()" Link "SetComment()"}   @{"UnLockRecord()" Link "UnLockRecord()"} @{"FreeDeviceProc()" Link "FreeDeviceProc()"}
@{"MatchNext()" Link "MatchNext()"}         @{"Examine()" Link "Examine()"}      @{"UnLockRecords()" Link "UnLockRecords()"}@{"AttemptLockDosList()" Link "AttemptLockDosList()"}
@{"MatchEnd()" Link "MatchEnd()"}          @{"ExamineFH()" Link "ExamineFH()"}    @{"OpenFromLock()" Link "OpenFromLock()"} @{"LockDosList()" Link "LockDosList()"}
@{"SplitName()" Link "SplitName()"}         @{"ExNext()" Link "ExNext()"}       @{"ParentOfFH()" Link "ParentOfFH()"}   @{"UnLockDosList()" Link "UnLockDosList()"}
@{"PathPart()" Link "PathPart()"}          @{"ExAll()" Link "ExAll()"}        @{"NameFromFH()" Link "NameFromFH()"}   @{"MakeDosEntry()" Link "MakeDosEntry()"}
@{"FilePart()" Link "FilePart()"}          @{"ExAllEnd()" Link "ExAllEnd()"}     @{"NameFromLock()" Link "NameFromLock()"} @{"AddDosEntry()" Link "AddDosEntry()"}
@{"AddPart()" Link "AddPart()"}           @{"DeleteFile()" Link "DeleteFile()"}   @{"SameLock()" Link "SameLock()"}     @{"FindDosEntry()" Link "FindDosEntry()"}
@{b}@{u}Errors@{uu}@{ub}:              @{b}@{u}Dates@{uu}@{ub}:          @{"SameDevice()" Link "SameDevice()"}   @{"NextDosEntry()" Link "NextDosEntry()"}
@{"ErrorReport()" Link "ErrorReport()"}       @{"DateToStr()" Link "DateToStr()"}    @{"SetMode()" Link "SetMode()"}      @{"FreeDosEntry()" Link "FreeDosEntry()"}
@{"SetIoErr()" Link "SetIoErr()"}          @{"StrToDate()" Link "StrToDate()"}    @{"ChangeMode()" Link "ChangeMode()"}   @{"RemDosEntry()" Link "RemDosEntry()"}
@{"IoErr()" Link "IoErr()"}             @{"CompareDates()" Link "CompareDates()"} @{"MakeLink()" Link "MakeLink()"}
@{"Fault()" Link "Fault()"}             @{b}@{u}Notification@{uu}@{ub}:   @{"ReadLink()" Link "ReadLink()"}     @{"Same, but sorted" link SAME_BUT_SORTED}
@{"PrintFault()" Link "PrintFault()"}        @{"StartNotify()" Link "StartNotify()"}
@{"Exit()" Link "Exit()"}              @{"EndNotify()" Link "EndNotify()"}
@{b}@{u}Processes@{uu}@{ub}:                          @{b}@{u}Environment@{uu}@{ub}:   @{b}@{u}Segments@{uu}@{ub}:
@{"CreateProc()" Link "CreateProc()"}       @{"CliInitNewcli()" Link "CliInitNewcli()"}@{"SetVar()" Link "SetVar()"}      @{"InternalLoadSeg()" Link "InternalLoadSeg()"}
@{"CreateNewProc()" Link "CreateNewProc()"}    @{"CliInitRun()" Link "CliInitRun()"}   @{"FindVar()" Link "FindVar()"}     @{"InternalUnLoadSeg()" Link "InternalUnLoadSeg()"}
@{"SetConsoleTask()" Link "SetConsoleTask()"}   @{"FindCliProc()" Link "FindCliProc()"}  @{"GetVar()" Link "GetVar()"}      @{"LoadSeg()" Link "LoadSeg()"}
@{"GetConsoleTask()" Link "GetConsoleTask()"}   @{"MaxCli()" Link "MaxCli()"}       @{"DeleteVar()" Link "DeleteVar()"}   @{"NewLoadSeg()" Link "NewLoadSeg()"}
@{"SetFileSysTask()" Link "SetFileSysTask()"}   @{"Cli()" Link "Cli()"}          @{b}@{u}Buffered I/O@{uu}@{ub}:  @{"UnLoadSeg()" Link "UnLoadSeg()"}
@{"GetFileSysTask()" Link "GetFileSysTask()"}   @{"SetPrompt()" Link "SetPrompt()"}    @{"SelectInput()" Link "SelectInput()"} @{"AddSegment()" Link "AddSegment()"}
@{"SetCurrentDirName()" Link "SetCurrentDirName()"}@{"GetPrompt()" Link "GetPrompt()"}    @{"SelectOutput()" Link "SelectOutput()"}@{"FindSegment()" Link "FindSegment()"}
@{"GetCurrentDirName()" Link "GetCurrentDirName()"}@{"SetArgStr()" Link "SetArgStr()"}    @{"FPutC()" Link "FPutC()"}       @{"RemSegment()" Link "RemSegment()"}
@{"SetProgramDir()" Link "SetProgramDir()"}    @{"GetArgStr()" Link "GetArgStr()"}    @{"FGetC()" Link "FGetC()"}       @{b}@{u}Packets@{uu}@{ub}:
@{"GetProgramDir()" Link "GetProgramDir()"}    @{"RunCommand()" Link "RunCommand()"}   @{"UnGetC()" Link "UnGetC()"}      @{"AllocDosObject()" Link "AllocDosObject()"}
@{"SetProgramName()" Link "SetProgramName()"}   @{"Delay()" Link "Delay()"}        @{"Flush()" Link "Flush()"}       @{"DoPkt()" Link "DoPkt()"}
@{"GetProgramName()" Link "GetProgramName()"}   @{b}@{u}Unbuffered I/O@{uu}@{ub}: @{"FRead()" Link "FRead()"}       @{"SendPkt()" Link "SendPkt()"}
@{b}@{u}Commands@{uu}@{ub}:           @{"Open()" Link "Open()"}         @{"FWrite()" Link "FWrite()"}      @{"WaitPkt()" Link "WaitPkt()"}
@{"CheckSignal()" Link "CheckSignal()"}      @{"Seek()" Link "Seek()"}         @{"FPuts()" Link "FPuts()"}       @{"ReplyPkt()" Link "ReplyPkt()"}
@{"FindArg()" Link "FindArg()"}          @{"WaitForChar()" Link "WaitForChar()"}  @{"FGets()" Link "FGets()"}       @{"AbortPkt()" Link "AbortPkt()"}
@{"ReadItem()" Link "ReadItem()"}         @{"Input()" Link "Input()"}        @{"VFWritef()" Link "VFWritef()"}    @{"FreeDosObject()" Link "FreeDosObject()"}
@{"ReadArgs()" Link "ReadArgs()"}         @{"Output()" Link "Output()"}       @{"VFPrintf()" Link "VFPrintf()"}    @{b}@{u}Handler interface@{uu}@{ub}:
@{"FreeArgs()" Link "FreeArgs()"}         @{"IsInteractive()" Link "IsInteractive()"}@{"SetVBuf()" Link "SetVBuf()"}     @{"Format()" Link "Format()"}
@{"SystemTagList()" Link "SystemTagList()"}    @{"Read()" Link "Read()"}         @{"WriteChars()" Link "WriteChars()"}  @{"Relabel()" Link "Relabel()"}
@{"Execute()" Link "Execute()"}          @{"Write()" Link "Write()"}        @{"PutStr()" Link "PutStr()"}      @{"Inhibit()" Link "Inhibit()"}
@{"StrToLong()" Link "StrToLong()"}        @{"Close()" Link "Close()"}        @{"VPrintf()" Link "VPrintf()"}     @{"AddBuffers()" Link "AddBuffers()"}
@EndNode
@node SAME_BUT_SORTED "same_but_sorted"
@{"AbortPkt()" Link "AbortPkt()"}
@{"AddBuffers()" Link "AddBuffers()"}
@{"AddDosEntry()" Link "AddDosEntry()"}
@{"AddPart()" Link "AddPart()"}
@{"AddSegment()" Link "AddSegment()"}
@{"AllocDosObject()" Link "AllocDosObject()"}
@{"AssignAdd()" Link "AssignAdd()"}
@{"AssignLate()" Link "AssignLate()"}
@{"AssignLock()" Link "AssignLock()"}
@{"AssignPath()" Link "AssignPath()"}
@{"AttemptLockDosList()" Link "AttemptLockDosList()"}
@{"ChangeMode()" Link "ChangeMode()"}
@{"CheckSignal()" Link "CheckSignal()"}
@{"Cli()" Link "Cli()"}
@{"CliInitNewcli()" Link "CliInitNewcli()"}
@{"CliInitRun()" Link "CliInitRun()"}
@{"Close()" Link "Close()"}
@{"CompareDates()" Link "CompareDates()"}
@{"CreateDir()" Link "CreateDir()"}
@{"CreateNewProc()" Link "CreateNewProc()"}
@{"CreateProc()" Link "CreateProc()"}
@{"CurrentDir()" Link "CurrentDir()"}
@{"DateStamp()" Link "DateStamp()"}
@{"DateToStr()" Link "DateToStr()"}
@{"Delay()" Link "Delay()"}
@{"DeleteFile()" Link "DeleteFile()"}
@{"DeleteVar()" Link "DeleteVar()"}
@{"DeviceProc()" Link "DeviceProc()"}
@{"DoPkt()" Link "DoPkt()"}
@{"DupLock()" Link "DupLock()"}
@{"DupLockFromFH()" Link "DupLockFromFH()"}
@{"EndNotify()" Link "EndNotify()"}
@{"ErrorReport()" Link "ErrorReport()"}
@{"ExAll()" Link "ExAll()"}
@{"ExAllEnd()" Link "ExAllEnd()"}
@{"Examine()" Link "Examine()"}
@{"ExamineFH()" Link "ExamineFH()"}
@{"Execute()" Link "Execute()"}
@{"Exit()" Link "Exit()"}
@{"ExNext()" Link "ExNext()"}
@{"Fault()" Link "Fault()"}
@{"FGetC()" Link "FGetC()"}
@{"FGets()" Link "FGets()"}
@{"FilePart()" Link "FilePart()"}
@{"FindArg()" Link "FindArg()"}
@{"FindCliProc()" Link "FindCliProc()"}
@{"FindDosEntry()" Link "FindDosEntry()"}
@{"FindSegment()" Link "FindSegment()"}
@{"FindVar()" Link "FindVar()"}
@{"Flush()" Link "Flush()"}
@{"Format()" Link "Format()"}
@{"FPutC()" Link "FPutC()"}
@{"FPuts()" Link "FPuts()"}
@{"FRead()" Link "FRead()"}
@{"FreeArgs()" Link "FreeArgs()"}
@{"FreeDeviceProc()" Link "FreeDeviceProc()"}
@{"FreeDosEntry()" Link "FreeDosEntry()"}
@{"FreeDosObject()" Link "FreeDosObject()"}
@{"FWrite()" Link "FWrite()"}
@{"GetArgStr()" Link "GetArgStr()"}
@{"GetConsoleTask()" Link "GetConsoleTask()"}
@{"GetCurrentDirName()" Link "GetCurrentDirName()"}
@{"GetDeviceProc()" Link "GetDeviceProc()"}
@{"GetFileSysTask()" Link "GetFileSysTask()"}
@{"GetProgramDir()" Link "GetProgramDir()"}
@{"GetProgramName()" Link "GetProgramName()"}
@{"GetPrompt()" Link "GetPrompt()"}
@{"GetVar()" Link "GetVar()"}
@{"Info()" Link "Info()"}
@{"Inhibit()" Link "Inhibit()"}
@{"Input()" Link "Input()"}
@{"InternalLoadSeg()" Link "InternalLoadSeg()"}
@{"InternalUnLoadSeg()" Link "InternalUnLoadSeg()"}
@{"IoErr()" Link "IoErr()"}
@{"IsFileSystem()" Link "IsFileSystem()"}
@{"IsInteractive()" Link "IsInteractive()"}
@{"LoadSeg()" Link "LoadSeg()"}
@{"Lock()" Link "Lock()"}
@{"LockDosList()" Link "LockDosList()"}
@{"LockRecord()" Link "LockRecord()"}
@{"LockRecords()" Link "LockRecords()"}
@{"MakeDosEntry()" Link "MakeDosEntry()"}
@{"MakeLink()" Link "MakeLink()"}
@{"MatchEnd()" Link "MatchEnd()"}
@{"MatchFirst()" Link "MatchFirst()"}
@{"MatchNext()" Link "MatchNext()"}
@{"MatchPattern()" Link "MatchPattern()"}
@{"MatchPatternNoCase()" Link "MatchPatternNoCase()"}
@{"MaxCli()" Link "MaxCli()"}
@{"NameFromFH()" Link "NameFromFH()"}
@{"NameFromLock()" Link "NameFromLock()"}
@{"NewLoadSeg()" Link "NewLoadSeg()"}
@{"NextDosEntry()" Link "NextDosEntry()"}
@{"Open()" Link "Open()"}
@{"OpenFromLock()" Link "OpenFromLock()"}
@{"Output()" Link "Output()"}
@{"ParentDir()" Link "ParentDir()"}
@{"ParentOfFH()" Link "ParentOfFH()"}
@{"ParsePattern()" Link "ParsePattern()"}
@{"ParsePatternNoCase()" Link "ParsePatternNoCase()"}
@{"PathPart()" Link "PathPart()"}
@{"PrintFault()" Link "PrintFault()"}
@{"PutStr()" Link "PutStr()"}
@{"Read()" Link "Read()"}
@{"ReadArgs()" Link "ReadArgs()"}
@{"ReadItem()" Link "ReadItem()"}
@{"ReadLink()" Link "ReadLink()"}
@{"Relabel()" Link "Relabel()"}
@{"RemAssignList()" Link "RemAssignList()"}
@{"RemDosEntry()" Link "RemDosEntry()"}
@{"RemSegment()" Link "RemSegment()"}
@{"Rename()" Link "Rename()"}
@{"ReplyPkt()" Link "ReplyPkt()"}
@{"RunCommand()" Link "RunCommand()"}
@{"SameDevice()" Link "SameDevice()"}
@{"SameLock()" Link "SameLock()"}
@{"Seek()" Link "Seek()"}
@{"SelectInput()" Link "SelectInput()"}
@{"SelectOutput()" Link "SelectOutput()"}
@{"SendPkt()" Link "SendPkt()"}
@{"SetArgStr()" Link "SetArgStr()"}
@{"SetComment()" Link "SetComment()"}
@{"SetConsoleTask()" Link "SetConsoleTask()"}
@{"SetCurrentDirName()" Link "SetCurrentDirName()"}
@{"SetFileDate()" Link "SetFileDate()"}
@{"SetFileSize()" Link "SetFileSize()"}
@{"SetFileSysTask()" Link "SetFileSysTask()"}
@{"SetIoErr()" Link "SetIoErr()"}
@{"SetMode()" Link "SetMode()"}
@{"SetOwner()" Link "SetOwner()"}
@{"SetProgramDir()" Link "SetProgramDir()"}
@{"SetProgramName()" Link "SetProgramName()"}
@{"SetPrompt()" Link "SetPrompt()"}
@{"SetProtection()" Link "SetProtection()"}
@{"SetVar()" Link "SetVar()"}
@{"SetVBuf()" Link "SetVBuf()"}
@{"SplitName()" Link "SplitName()"}
@{"StartNotify()" Link "StartNotify()"}
@{"StrToDate()" Link "StrToDate()"}
@{"StrToLong()" Link "StrToLong()"}
@{"SystemTagList()" Link "SystemTagList()"}
@{"UnGetC()" Link "UnGetC()"}
@{"UnLoadSeg()" Link "UnLoadSeg()"}
@{"UnLock()" Link "UnLock()"}
@{"UnLockDosList()" Link "UnLockDosList()"}
@{"UnLockRecord()" Link "UnLockRecord()"}
@{"UnLockRecords()" Link "UnLockRecords()"}
@{"VFPrintf()" Link "VFPrintf()"}
@{"VFWritef()" Link "VFWritef()"}
@{"VPrintf()" Link "VPrintf()"}
@{"WaitForChar()" Link "WaitForChar()"}
@{"WaitPkt()" Link "WaitPkt()"}
@{"Write()" Link "Write()"}
@{"WriteChars()" Link "WriteChars()"}
@endnode
@Node "AbortPkt()" "dos.library/AbortPkt"
@{b}@{u}AbortPkt@{uu}@{ub} -- Aborts an asynchronous packet, if possible.(V36)
  This attempts to abort a packet sent earlier with @{"SendPkt" Link "SendPkt()"} to a
  handler.There is no guarantee that any given handler will allow
  a packet to be aborted, or if it is aborted whether function
  requested completed first or completely.After calling AbortPkt(),
  you must wait for the packet to return before reusing it or
  deallocating it.
SYNOPSIS  @{FG shine}void@{FG text} AbortPkt(@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *, @{FG shine}struct@{FG text} @{"DosPacket" Link "include:dos/dosextens.h/Main" 108} *)
  AbortPkt(@{i}port@{ui}, @{i}pkt@{ui})
            D1    D2
  @{i}port@{ui} - port the packet was sent to
  @{i}pkt@{ui} - the packet you wish aborted
BUGS
  As of V37, this function does nothing.
SEE ALSO
  @{"SendPkt()" Link "SendPkt()"}, @{"DoPkt()" Link "DoPkt()"}, @{"WaitPkt()" Link "WaitPkt()"}
@EndNode
@Node "AddBuffers()" "dos.library/AddBuffers"
@{b}@{u}AddBuffers@{uu}@{ub} -- Changes the number of buffers for a filesystem.(V36)
  Adds buffers to a filesystem.If it succeeds, the number of current
  buffers is returned in @{"IoErr()" Link "IoErr()"}.Note that "number" may be negative.
  The amount of memory used per buffer, and any limits on the number of
  buffers, are dependant on the filesystem in question.
  If the call succeeds, the number of buffers in use on the filesystem
  will be returned by @{"IoErr()" Link "IoErr()"}.
SYNOPSIS  BOOL AddBuffers(STRPTR, @{FG shine}long@{FG text})
  @{i}@{b}success@{ub}@{ui} = AddBuffers(@{i}filesystem@{ui}, @{i}number@{ui})
   D0                   D1           D2
  @{i}filesystem@{ui} - Name of device to add buffers to (with ':').
  @{i}number@{ui} - Number of buffers to add.May be negative.
  @{i}@{b}success@{ub}@{ui} - Success or failure of command.
BUGS
  The V36 ROM filesystem (FFS/OFS) doesn't return the right number of buffers
  unless preceded by an AddBuffers(fs,-1) (in-use buffers aren't counted).
  This is fixed in V37.
  The V37 and before ROM filesystem doesn't return success, it returns the number
  of buffers.The best way to test for this is to consider 0 (FALSE) failure,
  -1 (DOSTRUE) to mean that @{"IoErr()" Link "IoErr()"} will have the
  number of buffers, and any other positive value to be the number of buffers.
  It may be fixed in some future ROM revision.
SEE ALSO
  @{"IoErr()" Link "IoErr()"}
@EndNode
@Node "AddDosEntry()" "dos.library/AddDosEntry"
@{b}@{u}AddDosEntry@{uu}@{ub} -- Add a Dos @{"List" Link "include:exec/lists.h/Main" 20} entry to the lists.(V36)
  Adds a device, volume or assign to the dos devicelist.Can fail if it conflicts
  with an existing entry (such as another assign to the same name or another
  device of the same name).Volume nodes with different dates and the same name
  CAN be added, or with names that conflict with devices or assigns.
  @{i}Note@{ui}: the dos list does @{b}NOT@{ub} have to be locked to call this.Do not access
  dlist after adding unless you have locked the Dos Device list.
  An additional note concerning calling this from within a handler:
  in order to avoid deadlocks, your handler must either be multithreaded,
  or it must attempt to lock the list before calling this function.
  The code would look something like this:
  @{FG shine}if@{FG text} (AttemptLockDosList(LDF_xxx|LDF_WRITE))
  {
    @{i}rc@{ui} = AddDosEntry(...);
    UnLockDosList(LDF_xxx|LDF_WRITE);
  }
  If @{"AttemptLockDosList()" Link "AttemptLockDosList()"} fails (i.e.it's locked already), check for
  messages at your filesystem port (don't wait!) and try the
  @{"AttemptLockDosList()" Link "AttemptLockDosList()"} again.
SYNOPSIS  @{FG shine}long@{FG text} AddDosEntry(@{FG shine}struct@{FG text} @{"DosList" Link "include:dos/dosextens.h/Main" 369} *)
  @{i}@{b}success@{ub}@{ui} = AddDosEntry(@{i}dlist@{ui})
   D0                    D1
  @{i}dlist@{ui} - @{"Device" Link "include:exec/devices.h/Main" 25} list entry to be added.
  @{i}@{b}success@{ub}@{ui} - Success/Failure indicator
SEE ALSO
  @{"RemDosEntry()" Link "RemDosEntry()"}, @{"FindDosEntry()" Link "FindDosEntry()"}, @{"NextDosEntry()" Link "NextDosEntry()"}, @{"LockDosList()" Link "LockDosList()"},
  @{"MakeDosEntry()" Link "MakeDosEntry()"}, @{"FreeDosEntry()" Link "FreeDosEntry()"}, @{"AttemptLockDosList()" Link "AttemptLockDosList()"}
@EndNode
@Node "AddPart()" "dos.library/AddPart"
@{b}@{u}AddPart@{uu}@{ub} -- Appends a file/dir to the end of a path.(V36)
  This function adds a file, directory, or subpath name to a directory path name
  taking into account any required separator characters.If filename is a
  fully-qualified path it will totally replace the current value of dirname.
SYNOPSIS  BOOL AddPart( STRPTR, STRPTR, ULONG )
  @{i}@{b}success@{ub}@{ui} = AddPart( @{i}dirname@{ui}, @{i}filename@{ui}, @{i}size@{ui} )
   D0                 D1        D2        D3
  @{i}dirname@{ui} - the path to add a file/directory name to.
  @{i}filename@{ui} - the filename or directory name to add.
    May be a relative pathname from the current directory (example: foo/bar).
    Can deal with leading '/'(s), indicating one directory up per '/', or with a
    ':', indicating it's relative to the root of the appropriate volume.
  @{i}size@{ui} - size in bytes of the space allocated for dirname.Must not be 0.
  @{i}@{b}success@{ub}@{ui} - non-zero for ok, FALSE if the buffer would have overflowed.
    If an overflow would have occured, dirname will not be changed.
BUGS
  Doesn't check if a subpath is legal (i.e.doesn't check for ':'s) and
  doesn't handle leading '/'s in 2.0 through 2.02 (V36).V37 fixes
  this, allowing filename to be any path, including absolute.
SEE ALSO
  Filepart(), @{"PathPart()" Link "PathPart()"}
@EndNode
@Node "AddSegment()" "dos.library/AddSegment"
@{b}@{u}AddSegment@{uu}@{ub} - Adds a resident segment to the resident list.(V36)
  Adds a segment to the Dos resident list, with the specified Seglist
  and type (stored in seg_UC - normally 0).
  @{i}NOTE@{ui}: currently unused types may cause it to interpret other
  registers (d4-?) as additional parameters in the future.
  Do @{b}NOT@{ub} build @{"Segment" Link "include:dos/dosextens.h/Main" 296} structures yourself!
SYNOPSIS  BOOL AddSegment(STRPTR, BPTR, @{FG shine}long@{FG text})
  @{i}@{b}success@{ub}@{ui} = AddSegment(@{i}name@{ui}, @{i}seglist@{ui}, @{i}type@{ui})
   D0                   D1     D2       D3
  @{i}name@{ui} - name for the segment
  @{i}seglist@{ui} - Dos seglist of code for segment
  @{i}type@{ui} - initial usecount, normally 0
  @{i}@{b}success@{ub}@{ui} - success or failure
SEE ALSO
  @{"FindSegment()" Link "FindSegment()"}, @{"RemSegment()" Link "RemSegment()"}, @{"LoadSeg()" Link "LoadSeg()"}
@EndNode
@Node "AllocDosObject()" "dos.library/AllocDosObject"
@{b}@{u}AllocDosObject@{uu}@{ub} -- Creates a dos object.(V36)
  Create one of several dos objects, initializes it, and returns it
  to you.Note the DOS_STDPKT returns a pointer to the sp_Pkt of the structure.
  This function may be called by a task for all types and tags defined
  in the V37 includes (DOS_FILEHANDLE through DOS_RDARGS and ADO_FH_Mode
  through ADO_PromptLen, respectively).Any future types or tags
  will be documented as to whether a task may use them.
SYNOPSIS
  @{FG shine}void@{FG text} *AllocDosObject(ULONG, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *)
  @{FG shine}void@{FG text} *AllocDosObjectTagList(ULONG, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *)
  @{FG shine}void@{FG text} *AllocDosObjectTags(ULONG, ULONG, ...)
  @{i}@{b}ptr@{ub}@{ui} = AllocDosObject(@{i}type@{ui}, @{i}tags@{ui})
   D0                   D1     D2
  @{i}@{b}ptr@{ub}@{ui} = AllocDosObjectTagList(@{i}type@{ui}, @{i}tags@{ui})
   D0                          D1     D2
  @{i}ptr@{ui} = AllocDosObjectTags(@{i}type@{ui}, @{i}Tag1@{ui}, ...)
  @{i}type@{ui} - type of object requested
  @{i}tags@{ui} - pointer to taglist with additional information
  @{i}@{b}packet@{ub}@{ui} - pointer to the object or NULL
BUGS
  Before V39, DOS_CLI should be used with care since @{"FreeDosObject()" Link "FreeDosObject()"}
  can't free it.
SEE ALSO
  @{"FreeDosObject()" Link "FreeDosObject()"}, @{"<dos/dostags.h>" Link "include:dos/dostags.h/Main" 0}, @{"<dos/dos.h>" Link "include:dos/dos.h/Main" 0}
@EndNode

@Node "AssignAdd()" "dos.library/AssignAdd"
@{b}@{u}AssignAdd@{uu}@{ub} -- Adds a lock to an assign for multi-directory assigns.(V36)
  Adds a lock to an assign, making or adding to a multi-directory
  assign.Note that this only will succeed on an assign created with
  @{"AssignLock()" Link "AssignLock()"}, or an assign created with @{"AssignLate()" Link "AssignLate()"} which has been
  resolved (converted into a AssignLock()-assign).
  @{i}NOTE@{ui}: you should not use the lock in any way after making this call
  successfully.It becomes the part of the assign, and will be unlocked
  by the system when the assign is removed.If you need to keep the
  lock, pass a lock from @{"DupLock()" Link "DupLock()"} to @{"AssignLock()" Link "AssignLock()"}.
SYNOPSIS  BOOL AssignAdd(STRPTR,BPTR)
  @{i}@{b}success@{ub}@{ui} = AssignAdd(@{i}name@{ui},@{i}lock@{ui})
   D0                  D1    D2
  @{i}name@{ui} - Name of device to assign lock to (without trailing ':')
  @{i}lock@{ui} - Lock associated with the assigned name
  @{i}@{b}success@{ub}@{ui} - Success/failure indicator.On failure, the lock is not unlocked.
SEE ALSO
  @{"Lock()" Link "Lock()"}, @{"AssignLock()" Link "AssignLock()"}, @{"AssignPath()" Link "AssignPath()"}, @{"AssignLate()" Link "AssignLate()"}, @{"DupLock()" Link "DupLock()"},
  @{"RemAssignList()" Link "RemAssignList()"}
@EndNode
@Node "AssignLate()" "dos.library/AssignLate"
@{b}@{u}AssignLate@{uu}@{ub} -- Creates an assignment to a specified path later.(V36)
  Sets up a assignment that is expanded upon the FIRST reference to the
  name.The path (a string) would be attached to the node.When
  the name is referenced (Open("FOO:xyzzy"...), the string will be used
  to determine where to set the assign to, and if the directory can be
  locked, the assign will act from that point on as if it had been
  created by @{"AssignLock()" Link "AssignLock()"}.
  A major advantage is assigning things to unmounted volumes, which
  will be requested upon access (useful in startup sequences).
SYNOPSIS  BOOL AssignLate(STRPTR,STRPTR)
  @{i}@{b}success@{ub}@{ui} = AssignLate(@{i}name@{ui},@{i}path@{ui})
   D0                   D1   D2
  @{i}name@{ui} - Name of device to be assigned (without trailing ':')
  @{i}path@{ui} - Name of late assignment to be resolved on the first reference.
  @{i}@{b}success@{ub}@{ui} - Success/failure indicator of the operation
SEE ALSO
  @{"Lock()" Link "Lock()"}, @{"AssignAdd()" Link "AssignAdd()"}, @{"AssignPath()" Link "AssignPath()"}, @{"AssignLock()" Link "AssignLock()"},
@EndNode
@Node "AssignLock()" "dos.library/AssignLock"
@{b}@{u}AssignLock@{uu}@{ub} -- Creates an assignment to a locked object.(V36)
  Sets up an assign of a name to a given lock.Passing NULL for a lock
  cancels any outstanding assign to that name.If an assign entry of
  that name is already on the list, this routine replaces that entry.If
  an entry is on the list that conflicts with the new assign, then a
  failure code is returned.
  @{i}NOTE@{ui}: you should not use the lock in any way after making this call
  successfully.It becomes the assign, and will be unlocked by the
  system when the assign is removed.If you need to keep the lock,
  pass a lock from @{"DupLock()" Link "DupLock()"} to AssignLock().
SYNOPSIS  BOOL AssignLock(STRPTR,BPTR)
  @{i}@{b}success@{ub}@{ui} = AssignLock(@{i}name@{ui},@{i}lock@{ui})
   D0                   D1    D2
  @{i}name@{ui} - Name of device to assign lock to (without trailing ':')
  @{i}lock@{ui} - Lock associated with the assigned name
  @{i}@{b}success@{ub}@{ui} - Success/failure indicator.On failure, the lock is not unlocked.
SEE ALSO
  @{"Lock()" Link "Lock()"}, @{"AssignAdd()" Link "AssignAdd()"}, @{"AssignPath()" Link "AssignPath()"}, @{"AssignLate()" Link "AssignLate()"}, @{"DupLock()" Link "DupLock()"},
  @{"RemAssignList()" Link "RemAssignList()"}
@EndNode
@Node "AssignPath()" "dos.library/AssignPath"
@{b}@{u}AssignPath@{uu}@{ub} -- Creates an assignment to a specified path.(V36)
  Sets up a assignment that is expanded upon EACH reference to the name.
  This is implemented through a new device list type (DLT_ASSIGNPATH, or
  some such).The path (a string) would be attached to the node.When
  the name is referenced (Open("FOO:xyzzy"...), the string will be used
  to determine where to do the open.No permanent lock will be part of
  it.For example, you could AssignPath() c2: to df2:c, and references
  to c2: would go to df2:c, even if you change disks.
  The other major advantage is assigning things to unmounted volumes,
  which will be requested upon access (useful in startup sequences).
SYNOPSIS  BOOL AssignPath(STRPTR,STRPTR)
  @{i}@{b}success@{ub}@{ui} = AssignPath(@{i}name@{ui},@{i}path@{ui})
   D0                   D1   D2
  @{i}name@{ui} - Name of device to be assigned (without trailing ':')
  @{i}path@{ui} - Name of late assignment to be resolved at each reference
  @{i}@{b}success@{ub}@{ui} - Success/failure indicator of the operation
SEE ALSO
  @{"AssignAdd()" Link "AssignAdd()"}, @{"AssignLock()" Link "AssignLock()"}, @{"AssignLate()" Link "AssignLate()"}, @{"Open()" Link "Open()"}
@EndNode
@Node "AttemptLockDosList()" "dos.library/AttemptLockDosList"
@{b}@{u}AttemptLockDosList@{uu}@{ub} -- Attempt to lock the Dos Lists for use.(V36)
  Locks the dos device list in preparation to walk the list.If the
  list is 'busy' then this routine will return NULL.See @{"LockDosList()" Link "LockDosList()"}
  for more information.
SYNOPSIS  @{FG shine}struct@{FG text} @{"DosList" Link "include:dos/dosextens.h/Main" 369} *AttemptLockDosList(ULONG)
  @{i}@{b}dlist@{ub}@{ui} = AttemptLockDosList(@{i}flags@{ui})
   D0                         D1
  @{i}flags@{ui} - Flags stating which types of nodes you want to lock.
  @{i}@{b}dlist@{ub}@{ui} - Pointer to the beginning of the list or NULL.Not a valid node!
BUGS
  In V36 through V39.23 dos, this would return NULL or 0x00000001 for
  failure.Fixed in V39.24 dos (after kickstart 39.106).
SEE ALSO
  @{"LockDosList()" Link "LockDosList()"}, @{"UnLockDosList()" Link "UnLockDosList()"}, @{"Forbid()" Link "exec.guide/Forbid()"}, @{"NextDosEntry()" Link "NextDosEntry()"}
@EndNode
@Node "ChangeMode()" "dos.library/ChangeMode"
@{b}@{u}ChangeMode@{uu}@{ub} - Change the current mode of a lock or filehandle.(V36)
  This allows you to attempt to change the mode in use by a lock or
  filehandle.For example, you could attempt to turn a shared lock
  into an exclusive lock.The handler may well reject this request.
  @{b}Warning@{ub}: if you use the wrong type for the object, the system may crash.
SYNOPSIS  BOOL ChangeMode(ULONG, BPTR, ULONG)
  @{i}@{b}success@{ub}@{ui} = ChangeMode(@{i}type@{ui}, @{i}object@{ui}, @{i}newmode@{ui})
   D0                   D1     D2      D3
  @{i}type@{ui} - Either CHANGE_FH or CHANGE_LOCK
  @{i}object@{ui} - A lock or filehandle
  @{i}newmode@{ui} - The new mode you want
  @{i}@{b}success@{ub}@{ui} - Boolean
BUGS
  Did not work in 2.02 or before (V36).Works in V37.In the
  earlier versions, it can crash the machine.
SEE ALSO
  @{"Lock()" Link "Lock()"}, @{"Open()" Link "Open()"}
@EndNode
@Node "CheckSignal()" "dos.library/CheckSignal"
@{b}@{u}CheckSignal@{uu}@{ub} -- Checks for break signals.(V36)
  This function checks to see if any signals specified in the mask have
  been set and if so, returns them.Otherwise it returns FALSE.
  All signals specified in mask will be cleared.
SYNOPSIS  ULONG CheckSignal(ULONG)
  @{i}@{b}signals@{ub}@{ui} = CheckSignal(@{i}mask@{ui})
   D0                    D1
  @{i}mask@{ui} - Signals to check for.
  @{i}@{b}signals@{ub}@{ui} - Signals specified in mask that were set.
@EndNode
@Node "Cli()" "dos.library/Cli"
@{b}@{u}Cli@{uu}@{ub} -- Returns a pointer to the CLI structure of the process.(V36)
  Returns a pointer to the CLI structure of the current process, or NULL
  if the process has no CLI structure.
SYNOPSIS  @{FG shine}struct@{FG text} @{"CommandLineInterface" Link "include:dos/dosextens.h/Main" 311} *Cli(@{FG shine}void@{FG text})
  @{i}@{b}cli_ptr@{ub}@{ui} = Cli()
   D0
  @{i}@{b}cli_ptr@{ub}@{ui} - pointer to the CLI structure, or NULL.
@EndNode
@Node "CliInitNewcli()" "dos.library/CliInitNewcli"
@{b}@{u}CliInitNewcli@{uu}@{ub} -- Set up a process to be a shell from initial packet
  This function initializes a process and CLI structure for a new
  shell, from parameters in an initial packet passed by the system
  (NewShell or NewCLI, etc).The format of the data in the packet
  is purposely not defined.The setup includes all the normal fields
  in the structures that are required for proper operation (current
  directory, paths, input streams, etc).
  It returns a set of flags containing information about what type
  of shell invocation this is.
  @{b}@{u}Definitions for the values of fn@{uu}@{ub}:
    Bit 31  Set to indicate flags are valid
    Bit  3  Set to indicate asynch system call
    Bit  2  Set if this is a System() call
    Bit  1  Set if user provided input stream
    Bit  0  Set if RUN provided output stream
  If Bit 31 is 0, then you must check @{"IoErr()" Link "IoErr()"} to determine if an error
  occurred.If @{"IoErr()" Link "IoErr()"} returns a pointer to your process, there has
  been an error, and you should clean up and exit.The packet will
  have already been returned by CliInitNewcli().If it isn't a pointer
  to your process and Bit 31 is 0, reply the packet immediately.
  (@{b}Note@{ub}: this is different from what you do for CliInitRun().)
  This function is very similar to @{"CliInitRun()" Link "CliInitRun()"}.
SYNOPSIS  @{FG shine}long@{FG text} CliInitNewcli( @{FG shine}struct@{FG text} @{"DosPacket" Link "include:dos/dosextens.h/Main" 108} * )
  @{i}@{b}flags@{ub}@{ui} = CliInitNewcli( @{i}packet@{ui} )
   D0                     A0
  @{i}packet@{ui} - the initial packet sent to your process @{"MsgPort" Link "include:exec/ports.h/Main" 28}
  @{i}@{b}fn@{ub}@{ui} - flags or a pointer
SEE ALSO
  @{"CliInitRun()" Link "CliInitRun()"}, @{"ReplyPkt()" Link "ReplyPkt()"}, @{"WaitPkt()" Link "WaitPkt()"}, @{"IoErr()" Link "IoErr()"}
@EndNode
@Node "CliInitRun()" "dos.library/CliInitRun"
@{b}@{u}CliInitRun@{uu}@{ub} -- Set up a process to be a shell from initial packet
  This function initializes a process and CLI structure for a new
  shell, from parameters in an initial packet passed by the system
  (Run, System(), Execute()).The format of the data in the packet
  is purposely not defined.The setup includes all the normal fields
  in the structures that are required for proper operation (current
  directory, paths, input streams, etc).
  It returns a set of flags containing information about what type
  of shell invocation this is.
  @{b}@{u}Definitions for the values of fn@{uu}@{ub}:
    Bit 31  Set to indicate flags are valid
    Bit  3  Set to indicate asynch system call
    Bit  2  Set if this is a System() call
    Bit  1  Set if user provided input stream
    Bit  0  Set if RUN provided output stream
  If Bit 31 is 0, then you must check @{"IoErr()" Link "IoErr()"} to determine if an error
  occurred.If @{"IoErr()" Link "IoErr()"} returns a pointer to your process, there has
  been an error, and you should clean up and exit.The packet will
  have already been returned by @{"CliInitNewcli()" Link "CliInitNewcli()"}.If it isn't a pointer
  to your process and Bit 31 is 0, you should wait before replying
  the packet until after you've loaded the first command (or when you
  exit).This helps avoid disk "gronking" with the Run command.
  (@{b}Note@{ub}: this is different from what you do for CliInitNewcli().)
  If Bit 31 is 1, then if Bit 3 is one, @{"ReplyPkt()" Link "ReplyPkt()"} the packet
  immediately (Asynch System()), otherwise wait until your shell exits
  (Sync System(), @{"Execute()" Link "Execute()"}).
  (@{b}Note@{ub}: this is different from what you do for CliInitNewcli().)
  This function is very similar to @{"CliInitNewcli()" Link "CliInitNewcli()"}.
SYNOPSIS  @{FG shine}long@{FG text} CliInitRun( @{FG shine}struct@{FG text} @{"DosPacket" Link "include:dos/dosextens.h/Main" 108} * )
  @{i}@{b}flags@{ub}@{ui} = CliInitRun( @{i}packet@{ui} )
   D0                  A0
  @{i}packet@{ui} - the initial packet sent to your process @{"MsgPort" Link "include:exec/ports.h/Main" 28}
  @{i}@{b}fn@{ub}@{ui} - flags or a pointer
SEE ALSO
  @{"CliInitNewcli()" Link "CliInitNewcli()"}, @{"ReplyPkt()" Link "ReplyPkt()"}, @{"WaitPkt()" Link "WaitPkt()"}, System(), @{"Execute()" Link "Execute()"}, @{"IoErr()" Link "IoErr()"}
@EndNode
@Node "Close()" "dos.library/Close"
@{b}@{u}Close@{uu}@{ub} -- Close an open file.
  The file specified by the file handle is closed.You must close all
  files you explicitly opened, but you must not close inherited file
  handles that are passed to you (each filehandle must be closed once
  and @{b}ONLY@{ub} once).If Close() fails, the file handle is still
  deallocated and should not be used.
SYNOPSIS  BOOL Close(BPTR)
  @{i}@{b}success@{ub}@{ui}@{i}@{b}@{ub}@{ui} = Close( @{i}file@{ui} )
   D0               D1
  @{i}file@{ui} - BCPL pointer to a file handle
  @{i}@{b}success@{ub}@{ui} - returns if Close() succeeded.Note that it might fail depending on
    buffering and whatever IO must be done to close a file being written to.
    @{i}NOTE@{ui}: this return value did not exist before V36!
SEE ALSO
  @{"Open()" Link "Open()"}, @{"OpenFromLock()" Link "OpenFromLock()"}
@EndNode
@Node "CompareDates()" "dos.library/CompareDates"
@{b}@{u}CompareDates@{uu}@{ub} -- Compares two datestamps.(V36)
  Compares two times for relative magnitide.<0 is returned if date1 is
  later than date2, 0 if they are equal, or >0 if date2 is later than date1.
  @{b}NOTE@{ub}: this is @{b}NOT@{ub} the same ordering as strcmp!
SYNOPSIS  @{FG shine}long@{FG text} CompareDates(@{FG shine}struct@{FG text} @{"DateStamp" Link "include:dos/dos.h/Main" 52} *,@{FG shine}struct@{FG text} @{"DateStamp" Link "include:dos/dos.h/Main" 52} *)
  @{i}@{b}result@{ub}@{ui} = CompareDates(@{i}date1@{ui},@{i}date2@{ui})
   D0                     D1     D2
  @{i}date1@{ui}, @{i}date2@{ui} - DateStamps to compare
  @{i}@{b}result@{ub}@{ui} - <0, 0, or >0 based on comparison of two date stamps
SEE ALSO
  @{"DateStamp()" Link "DateStamp()"}, @{"DateToStr()" Link "DateToStr()"}, @{"StrToDate()" Link "StrToDate()"}
@EndNode
@Node "CreateDir()" "dos.library/CreateDir"
@{b}@{u}CreateDir@{uu}@{ub} -- Create a new directory.
  CreateDir creates a new directory with the specified name.An error
  is returned if it fails.Directories can only be created on
  devices which support them, e.g.disks.CreateDir returns an
  exclusive lock on the new directory if it succeeds.
SYNOPSIS  BPTR CreateDir(STRPTR)
  @{i}@{b}lock@{ub}@{ui} = CreateDir( @{i}name@{ui} )
   D0                D1
  @{i}name@{ui} - pointer to a null-terminated string
  @{i}@{b}lock@{ub}@{ui} - BCPL pointer to a lock or NULL for failure.
SEE ALSO
  @{"Lock()" Link "Lock()"}, @{"UnLock()" Link "UnLock()"}
@EndNode
@Node "CreateNewProc()" "dos.library/CreateNewProc"
@{b}@{u}CreateNewProc@{uu}@{ub} -- Create a new process.(V36)
  This creates a new process according to the tags passed in.See
  @{"dos/dostags.h" Link "include:dos/dostags.h/Main" 0} for the tags.
  You must specify one of NP_Seglist or NP_Entry.NP_Seglist takes a
  seglist (as returned by LoadSeg()).NP_Entry takes a function
  pointer for the routine to call.
  There are many options, as you can see by examining @{"dos/dostags.h" Link "include:dos/dostags.h/Main" 0}.
  The defaults are for a non-CLI process, with copies of your
  @{"CurrentDir" Link "CurrentDir()"}, HomeDir (used for PROGDIR:), priority, consoletask,
  windowptr, and variables.The input and output filehandles default
  to opens of NIL:, stack to 4000, and others as shown in dostags.h.
  This is a fairly reasonable default setting for creating threads, though you
  may wish to modify it (for example, to give a descriptive name to the process.)
  CreateNewProc() is callable from a task, though any actions that
  require doing Dos I/O (DupLock() of currentdir, for example) will not occur.
  @{i}NOTE@{ui}: if you call CreateNewProc() with both NP_Arguments, you must
  not specify an NP_Input of NULL.When NP_Arguments is specified, it
  needs to modify the input filehandle to make @{"ReadArgs()" Link "ReadArgs()"} work properly.
SYNOPSIS
  @{FG shine}struct@{FG text} @{"Process" Link "include:dos/dosextens.h/Main" 37} *CreateNewProc(@{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *)
  @{FG shine}struct@{FG text} @{"Process" Link "include:dos/dosextens.h/Main" 37} *CreateNewProcTagList(@{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *)
  @{FG shine}struct@{FG text} @{"Process" Link "include:dos/dosextens.h/Main" 37} *CreateNewProcTags(ULONG, ...)
  @{i}@{b}process@{ub}@{ui} = CreateNewProc(@{i}tags@{ui})
   D0                      D1
  @{i}@{b}process@{ub}@{ui} = CreateNewProcTagList(@{i}tags@{ui})
   D0                             D1
  @{i}@{b}process@{ub}@{ui} = CreateNewProcTags(@{i}Tag1@{ui}, ...)
  @{i}tags@{ui} - a pointer to a @{"TagItem" Link "include:utility/tagitem.h/Main" 31} array.
  process - The created process, or NULL.Note that if it returns NULL,
    you must free any items that were passed in via tags, such as
    if you passed in a new current directory with NP_CurrentDir.
BUGS
  In V36, NP_Arguments was broken in a number of ways, and probably
  should be avoided (instead you should start a small piece of your
  own code, which calls @{"RunCommand()" Link "RunCommand()"} to run the actual code you wish
  to run).In V37, NP_Arguments works, though see the note above.
SEE ALSO
  @{"LoadSeg()" Link "LoadSeg()"}, @{"CreateProc()" Link "CreateProc()"}, @{"ReadArgs()" Link "ReadArgs()"}, @{"RunCommand()" Link "RunCommand()"}, @{"<dos/dostags.h>" Link "include:dos/dostags.h/Main" 0}
@EndNode
@Node "CreateProc()" "dos.library/CreateProc"
@{b}@{u}CreateProc@{uu}@{ub} -- Create a new process.
  CreateProc() creates a new AmigaDOS process of name 'name'.AmigaDOS processes
  are a superset of exec tasks.
  A seglist, as returned by @{"LoadSeg()" Link "LoadSeg()"}, is passed as 'seglist'.
  This represents a section of code which is to be run as a new process.The code
  is entered at the first hunk in the segment list, which should contain suitable
  initialization code or a jump to such.A process control structure is allocated
  from memory and initialized.If you wish to fake a seglist (that will never
  have DOS @{"UnLoadSeg()" Link "UnLoadSeg()"} called on it), use this code:
    DS.L    0 ;Align to longword
    DC.L    16  ;Segment "length" (faked)
    DC.L    0 ;Pointer to next segment
    ...start of code...
  The size of the root stack upon activation is passed as 'stackSize'.
  'pri' specifies the required priority of the new process.The result
  will be the process msgport address of the new process, or zero if
  the routine failed.The argument 'name' specifies the new process name.
  A zero return code indicates error.
  The seglist passed to CreateProc() is not freed when it exits; it
  is up to the parent process to free it, or for the code to unload itself.
  Under V36 and later, you probably should use @{"CreateNewProc()" Link "CreateNewProc()"} instead.
SYNOPSIS  @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *CreateProc(STRPTR, @{FG shine}long@{FG text}, BPTR, @{FG shine}long@{FG text})
  @{i}@{b}process@{ub}@{ui} = CreateProc( @{i}name@{ui}, @{i}pri@{ui}, @{i}seglist@{ui}, @{i}stackSize@{ui} )
   D0                    D1    D2    D3       D4
  @{i}name@{ui} - pointer to a null-terminated string
  @{i}pri@{ui} - signed long (range -128 to +127)
  @{i}seglist@{ui} - BCPL pointer to a seglist
  @{i}stackSize@{ui} - integer (must be a multiple of 4 bytes)
  @{i}@{b}process@{ub}@{ui} - pointer to new process msgport
SEE ALSO
  @{"CreateNewProc()" Link "CreateNewProc()"}, @{"LoadSeg()" Link "LoadSeg()"}, @{"UnLoadSeg()" Link "UnLoadSeg()"}
@EndNode
@Node "CurrentDir()" "dos.library/CurrentDir"
@{b}@{u}CurrentDir@{uu}@{ub} -- Make a directory lock the current directory.
  CurrentDir() causes a directory associated with a lock to be made
  the current directory.The old current directory lock is returned.
  A value of zero is a valid result here, this 0 lock represents the
  root of file system that you booted from.
  Any call that has to @{"Open()" Link "Open()"} or @{"Lock()" Link "Lock()"} files (etc) requires that
  the current directory be a valid lock or 0.
SYNOPSIS  BPTR CurrentDir(BPTR)
  @{i}@{b}oldLock@{ub}@{ui} = CurrentDir( @{i}lock@{ui} )
   D0                    D1
  @{i}lock@{ui} - BCPL pointer to a lock
  @{i}@{b}oldLock@{ub}@{ui} - BCPL pointer to a lock
SEE ALSO
  @{"Lock()" Link "Lock()"}, @{"UnLock()" Link "UnLock()"}, @{"Open()" Link "Open()"}, @{"DupLock()" Link "DupLock()"}
@EndNode
@Node "DateStamp()" "dos.library/DateStamp"
@{b}@{u}DateStamp@{uu}@{ub} -- Obtain the date and time in internal format.
  DateStamp() takes a structure of three longwords that is set to the
  current time.The first element in the vector is a count of the
  number of days.The second element is the number of minutes elapsed
  in the day.The third is the number of ticks elapsed in the current
  minute.A tick happens 50 times a second.DateStamp() ensures that
  the day and minute are consistent.All three elements are zero if
  the date is unset.DateStamp() currently only returns even multiples of
  50 ticks.Therefore the time you get is always an even number of ticks.
  Time is measured from Jan 1, 1978.
SYNOPSIS  @{FG shine}struct@{FG text} @{"DateStamp" Link "include:dos/dos.h/Main" 52} *DateStamp(@{FG shine}struct@{FG text} @{"DateStamp" Link "include:dos/dos.h/Main" 52} *)
  @{i}@{b}ds@{ub}@{ui} = DateStamp( @{i}ds@{ui} );
   D0              D1
  @{i}ds@{ui} - pointer a struct @{"DateStamp" Link "include:dos/dos.h/Main" 52}
  The array is filled as described and returned (for pre-V36 compabability).
SEE ALSO
  @{"DateToStr()" Link "DateToStr()"}, @{"StrToDate()" Link "StrToDate()"}, @{"SetFileDate()" Link "SetFileDate()"}, @{"CompareDates()" Link "CompareDates()"}
@EndNode
@Node "DateToStr()" "dos.library/DateToStr"
@{b}@{u}DateToStr@{uu}@{ub} -- Converts a @{"DateStamp" Link "include:dos/dos.h/Main" 52} to a string.(V36)
  StamptoStr converts an AmigaDOS @{"DateStamp" Link "include:dos/dos.h/Main" 52} to a human
  readable ASCII string as requested by your settings in the
  @{"DateTime" Link "include:dos/datetime.h/Main" 25} structure.
SYNOPSIS  BOOL DateToStr(@{FG shine}struct@{FG text} @{"DateTime" Link "include:dos/datetime.h/Main" 25} *)
  @{i}@{b}success@{ub}@{ui} = DateToStr( @{i}datetime@{ui} )
   D0                   D1
  @{i}DateTime@{ui} - a pointer to an initialized @{"DateTime" Link "include:dos/datetime.h/Main" 25} structure.
  The DateTime structure should be initialized as follows:
  @{i}dat_Stamp@{ui} - a copy of the datestamp you wish to convert to ascii.
  @{i}dat_Format@{ui} - a format byte which specifies the format of the dat_StrDate.
    This can be any of the following (@{i}note@{ui}: If value used is something other
    than those below, the default of FORMAT_DOS is used):
      @{b}FORMAT_DOS@{ub}:   AmigaDOS format (dd-mmm-yy).
      @{b}FORMAT_INT@{ub}:   International format (yy-mmm-dd).
      @{b}FORMAT_USA@{ub}:   American format (mm-dd-yy).
      @{b}FORMAT_CDN@{ub}:   Canadian format (dd-mm-yy).
      @{b}FORMAT_DEF@{ub}:   default format for locale.
  @{i}dat_Flags@{ui} - a flags byte.The only flag which affects this function is:
    @{b}DTF_SUBST@{ub}:If set, a string such as Today, Monday, etc., will be
      used instead of the dat_Format specification if possible.
    @{b}DTF_FUTURE@{ub}:Ignored by this function.
  @{i}dat_StrDay@{ui} - pointer to a buffer to receive the day of the week string.
    (Monday, Tuesday, etc.).If null, this string will not be generated.
  @{i}dat_StrDate@{ui} - pointer to a buffer to receive the date string, in the format
    requested by dat_Format, subject to possible modifications by DTF_SUBST.
    If null, this string will not be generated.
  @{i}dat_StrTime@{ui} - pointer to a buffer to receive the time of day string.
    If NULL, this will not be generated.
  @{i}@{b}success@{ub}@{ui} - a zero return indicates that the DateStamp was invalid, and
    could not be converted.Non-zero indicates that the call succeeded.
SEE ALSO
  @{"DateStamp()" Link "DateStamp()"}, StrtoDate(), @{"<dos/datetime.h>" Link "include:dos/datetime.h/Main" 0}
@EndNode
@Node "Delay()" "dos.library/Delay"
@{b}@{u}Delay@{uu}@{ub} -- Delay a process for a specified time.
  The argument 'ticks' specifies how many ticks (50 per second) to
  wait before returning control.
SYNOPSIS  @{FG shine}void@{FG text} Delay(ULONG)
  Delay( @{i}ticks@{ui} )
          D1
  @{i}ticks@{ui} - integer
BUGS
  Due to a bug in the timer.device in V1.2/V1.3, specifying a timeout
  of zero for Delay() can cause the unreliable timer & floppy disk
  operation.This is fixed in V36 and later.
@EndNode
@Node "DeleteFile()" "dos.library/DeleteFile"
@{b}@{u}DeleteFile@{uu}@{ub} -- Delete a file or directory.
  This attempts to delete the file or directory specified by 'name'.
  An error is returned if the deletion fails.Note that all the files
  within a directory must be deleted before the directory itself can
  be deleted.
SYNOPSIS  BOOL DeleteFile(STRPTR)
  @{i}@{b}success@{ub}@{ui} = DeleteFile( @{i}name@{ui} )
   D0                    D1
  @{i}name@{ui} - pointer to a null-terminated string
  @{i}@{b}success@{ub}@{ui} - boolean
@EndNode
@Node "DeleteVar()" "dos.library/DeleteVar"
@{b}@{u}DeleteVar@{uu}@{ub} -- Deletes a local or environment variable.(V36)
  Deletes a local or environment variable.
SYNOPSIS  BOOL DeleteVar(STRPTR, ULONG ) 
  @{i}@{b}success@{ub}@{ui} = DeleteVar( @{i}name@{ui}, @{i}flags@{ui} )
   D0                   D1    D2
  @{i}name@{ui} - pointer to an variable name.Note variable names follow
    filesystem syntax and semantics.
  @{i}flags@{ui} - combination of type of var to delete (low 8 bits), and flags to
    control the behavior of this routine.Currently defined flags include:
      @{b}GVF_LOCAL_ONLY@{ub}  - delete a local (to your process) variable.
      @{b}GVF_GLOBAL_ONLY@{ub} - delete a global environment variable.
    The default is to delete a local variable if found, otherwise
    a global environment variable if found (only for LV_VAR).
  @{i}@{b}success@{ub}@{ui} - If non-zero, the variable was sucessfully deleted,
    FALSE indicates failure.
BUGS
  LV_VAR is the only type that can be global.
SEE ALSO
  @{"GetVar()" Link "GetVar()"}, @{"SetVar()" Link "SetVar()"}, @{"FindVar()" Link "FindVar()"}, @{"DeleteFile()" Link "DeleteFile()"}, @{"<dos/var.h>" Link "include:dos/var.h/Main" 0}
@EndNode
@Node "DeviceProc()" "dos.library/DeviceProc"
@{b}@{u}DeviceProc@{uu}@{ub} -- Return the process @{"MsgPort" Link "include:exec/ports.h/Main" 28} of specific I/O handler.
  DeviceProc() returns the process identifier of the process which
  handles the device associated with the specified name.If no
  process handler can be found then the result is zero.If the name
  refers to an assign then a directory lock is returned in @{"IoErr()" Link "IoErr()"}.
  This lock should not be UnLock()ed or Examine()ed (if you wish to do so,
  @{"DupLock()" Link "DupLock()"} it first).
SYNOPSIS  @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *DeviceProc (STRPTR)
  @{i}@{b}process@{ub}@{ui} = DeviceProc( @{i}name@{ui} )
   D0                    D1
BUGS
  In V36, if you try to DeviceProc() something relative to an assign
  made with @{"AssignPath()" Link "AssignPath()"}, it will fail.This is because there's no way
  to know when to unlock the lock.If you're writing code for V36 or later,
  it is highly advised you use @{"GetDeviceProc()" Link "GetDeviceProc()"} instead, or make your code
  conditional on V36 to use GetDeviceProc() / @{"FreeDeviceProc()" Link "FreeDeviceProc()"}.
SEE ALSO
  @{"GetDeviceProc()" Link "GetDeviceProc()"}, @{"FreeDeviceProc()" Link "FreeDeviceProc()"}, @{"DupLock()" Link "DupLock()"}, @{"UnLock()" Link "UnLock()"}, @{"Examine()" Link "Examine()"}
@EndNode
@Node "DoPkt()" "dos.library/DoPkt"
@{b}@{u}DoPkt@{uu}@{ub} -- Send a dos packet and wait for reply.(V36)
  Sends a packet to a handler and waits for it to return.Any secondary
  return will be available in D1 AND from @{"IoErr()" Link "IoErr()"}.DoPkt() will work
  even if the caller is an exec task and not a process; however it will
  be slower, and may fail for some additional reasons, such as being
  unable to allocate a signal.DoPkt() uses your pr_MsgPort for the
  reply, and will call pr_PktWait.(See BUGS regarding tasks, though).
  Only allows 5 arguments to be specified.For more arguments (packets
  support a maximum of 7) create a packet and use @{"SendPkt()/WaitPkt()" Link "WaitPkt()"}.
SYNOPSIS  @{FG shine}long@{FG text} DoPkt(@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *,@{FG shine}long@{FG text},@{FG shine}long@{FG text},@{FG shine}long@{FG text},@{FG shine}long@{FG text},@{FG shine}long@{FG text},@{FG shine}long@{FG text})
  @{i}@{b}result1@{ub}@{ui} = DoPkt(@{i}port@{ui},@{i}action@{ui},@{i}arg1@{ui},@{i}arg2@{ui},@{i}arg3@{ui},@{i}arg4@{ui},@{i}arg5@{ui})
   D0              D1    D2     D3   D4   D5   D6    D7
  @{i}port@{ui} - pr_MsgPort of the handler process to send to.
  @{i}action@{ui} - the action requested of the filesystem/handler
  @{i}arg1@{ui}, @{i}arg2@{ui}, @{i}arg3@{ui}, @{i}arg4@{ui}, @{i}arg5@{ui} - arguments, depend on the action,
    may not be required.
  @{i}@{b}result1@{ub}@{ui} - the value returned in dp_Res1, or FALSE if there was some
    problem in sending the packet or recieving it.
  @{i}@{b}result2@{ub}@{ui} - Available from @{"IoErr()" Link "IoErr()"} AND in register D1.
BUGS
  Using DoPkt() from tasks doesn't work in V36.Use @{"AllocDosObject()" Link "AllocDosObject()"},
  @{"PutMsg()" Link "exec.guide/PutMsg()"}, and @{"WaitPort()/GetMsg()" Link "exec.guide/GetMsg()"} for a workaround, or you can call
  @{"CreateNewProc()" Link "CreateNewProc()"} to start a process to do Dos I/O for you.In V37,
  DoPkt() will allocate, use, and free the @{"MsgPort" Link "include:exec/ports.h/Main" 28} required.
NOTES
  Callable from a task (under V37 and above).
SEE ALSO
  @{"AllocDosObject()" Link "AllocDosObject()"}, @{"FreeDosObject()" Link "FreeDosObject()"}, @{"SendPkt()" Link "SendPkt()"}, @{"WaitPkt()" Link "WaitPkt()"},
  @{"CreateNewProc()" Link "CreateNewProc()"}, @{"AbortPkt()" Link "AbortPkt()"}
@EndNode
@Node "DupLock()" "dos.library/DupLock"
@{b}@{u}DupLock@{uu}@{ub} -- Duplicate a lock.
  DupLock() is passed a shared filing system lock.This is the @{b}ONLY@{ub}
  way to obtain a duplicate of a lock...simply copying is not allowed.
  Another lock to the same object is then returned.It is not
  possible to create a copy of a exclusive lock.
  A zero return indicates failure.
SYNOPSIS  BPTR DupLock(BPTR)
  @{i}@{b}newlock@{ub}@{ui} = DupLock( @{i}lock@{ui} )
   D0                 D1
  @{i}lock@{ui} - BCPL pointer to a lock
  @{i}@{b}newLock@{ub}@{ui} - BCPL pointer to a lock
SEE ALSO
  @{"Lock()" Link "Lock()"}, @{"UnLock()" Link "UnLock()"}, @{"DupLockFromFH()" Link "DupLockFromFH()"}, @{"ParentOfFH()" Link "ParentOfFH()"}
@EndNode
@Node "DupLockFromFH()" "dos.library/DupLockFromFH"
@{b}@{u}DupLockFromFH@{uu}@{ub} -- Gets a lock on an open file.(V36)
  Obtain a lock on the object associated with fh.Only works if the
  file was opened using a non-exclusive mode.Other restrictions may be
  placed on success by the filesystem.
SYNOPSIS  BPTR DupLockFromFH(BPTR)
  @{i}@{b}lock@{ub}@{ui} = DupLockFromFH(@{i}fh@{ui})
   D0                   D1
  @{i}fh@{ui}   - Opened file for which to obtain the lock
  @{i}@{b}lock@{ub}@{ui} - Obtained lock or NULL for failure
SEE ALSO
  @{"DupLock()" Link "DupLock()"}, @{"Lock()" Link "Lock()"}, @{"UnLock()" Link "UnLock()"}
@EndNode
@Node "EndNotify()" "dos.library/EndNotify"
@{b}@{u}EndNotify@{uu}@{ub} -- Ends a notification request.(V36)
  Removes a notification request.Safe to call even if @{"StartNotify()" Link "StartNotify()"}
  failed.For NRF_SEND_MESSAGE, it searches your port for any messages
  about the object in question and removes and replies them before returning.
SYNOPSIS  @{FG shine}void@{FG text} EndNotify(@{FG shine}struct@{FG text} @{"NotifyRequest" Link "include:dos/notify.h/Main" 51} *)
  EndNotify(@{i}notifystructure@{ui})
             D1
  @{i}notifystructure@{ui} - a structure passed to @{"StartNotify()" Link "StartNotify()"}
SEE ALSO
  @{"StartNotify()" Link "StartNotify()"}, @{"<dos/notify.h>" Link "include:dos/notify.h/Main" 0}
@EndNode
@Node "ErrorReport()" "dos.library/ErrorReport"
@{b}@{u}ErrorReport@{uu}@{ub} -- Displays a Retry/Cancel requester for an error.(V36)
  Based on the request type, this routine formats the appropriate
  requester to be displayed.If the code is not understood, it returns
  DOS_TRUE immediately.Returns DOS_TRUE if the user selects CANCEL or
  if the attempt to put up the requester fails, or if the process
  pr_WindowPtr is -1.Returns FALSE if the user selects Retry.The
  routine will retry on DISKINSERTED for appropriate error codes.
  These return values are the opposite of what @{"AutoRequest" Link "intuition.guide/AutoRequest()"} returns.
  @{i}Note@{ui}: this routine sets @{"IoErr()" Link "IoErr()"} to code before returning.
SYNOPSIS  BOOL ErrorReport(@{FG shine}long@{FG text}, @{FG shine}long@{FG text}, ULONG, @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *)
  @{i}@{b}status@{ub}@{ui} = ErrorReport(@{i}code@{ui}, @{i}type@{ui}, @{i}arg1@{ui}, @{i}device@{ui})
   D0                   D1    D2     D3    D4
  @{i}code@{ui}   - Error code to put a requester up for.Current valid error codes are:
    ERROR_DISK_NOT_VALIDATED
    ERROR_DISK_WRITE_PROTECTED
    ERROR_DISK_FULL
    ERROR_DEVICE_NOT_MOUNTED
    ERROR_NOT_A_DOS_DISK
    ERROR_NO_DISK
    ABORT_DISK_ERROR  /* read/write error */
    ABORT_BUSY    /* you @{b}MUST@{ub} replace...*/
  @{i}type@{ui} - Request type:
    REPORT_LOCK   - arg1 is a lock (BPTR).
    REPORT_FH     - arg1 is a filehandle (BPTR).
    REPORT_VOLUME - arg1 is a volumenode (C pointer).
    REPORT_INSERT - arg1 is the string for the volumename (will be split on a ':').
      With ERROR_DEVICE_NOT_MOUNTED puts up the "Please insert..." requester.
  @{i}arg1@{ui} - variable parameter (see type)
  @{i}device@{ui} - (Optional) Address of handler task for which report is to be made.
    Only required for REPORT_LOCK, and only if arg1==NULL.
  @{i}@{b}status@{ub}@{ui} - Cancel/Retry indicator (0 means Retry)
SEE ALSO
  @{"Fault()" Link "Fault()"}, @{"IoErr()" Link "IoErr()"}
@EndNode
@Node "ExAll()" "dos.library/ExAll"
@{b}@{u}ExAll@{uu}@{ub} -- Examine an entire directory.(V36)
  Examines an entire directory.
  Lock must be on a directory.Size is the size of the buffer supplied.
  The buffer will be filled with (partial) @{"ExAllData" Link "include:dos/exall.h/Main" 39} structures, as
  specified by the type field.
  Type is a value from those shown below that determines which information is
  to be stored in the buffer.Each higher value adds a new thing to the list
  as described in the table below:-
    ED_NAME   FileName
    ED_TYPE   Type
    ED_SIZE   Size in bytes
    ED_PROTECTION Protection bits
    ED_DATE   3 longwords of date
    ED_COMMENT  Comment (will be NULL if no comment)
      @{i}Note@{ui}: the V37 ROM/disk filesystem returns this incorrectly as a BSTR.
      See BUGS for a workaround.
    ED_OWNER  owner user-id and group-id (if supported)  (V39)
  Thus, ED_NAME gives only filenames, and ED_OWNER gives everything.
  @{i}NOTE@{ui}: V37 dos.library, when doing ExAll() emulation, and RAM: filesystem
  will return an error if passed ED_OWNER.If you get ERROR_BAD_NUMBER,
  retry with ED_COMMENT to get everything but owner info.All filesystems
  supporting ExAll() must support through ED_COMMENT, and must check Type
  and return ERROR_BAD_NUMBER if they don't support the type.
  The V37 ROM/disk filesystem doesn't fill in the comment field correctly
  if you specify ED_OWNER.See BUGS for a workaround if you need to use ED_OWNER.
  The ead_Next entry gives a pointer to the next entry in the buffer.The
  last entry will have NULL in ead_Next.
  The control structure is required so that FFS can keep track if more than
  one call to ExAll is required.This happens when there are more names in
  a directory than will fit into the buffer.The format of the control
  structure is as follows:-
  @{i}NOTE@{ui}:the control structure @{b}MUST@{ub} be allocated by AllocDosObject!!!
  @{i}Entries@{ui}:This field tells the calling application how many entries are
    in the buffer after calling ExAll.Note: make sure your code
    handles the 0 entries case, including 0 entries with continue non-zero.
  @{i}LastKey@{ui}:This field @{b}ABSOLUTELY MUST@{ub} be initialised to 0 before calling
    ExAll for the first time.Any other value will cause nasty
    things to happen.If ExAll returns non-zero, then this field
    should not be touched before making the second and subsequent
    calls to ExAll.Whenever ExAll returns non-zero, there are more
    calls required before all names have been received.
    As soon as a FALSE return is received then ExAll has completed
    (if @{"IoErr()" Link "IoErr()"} returns ERROR_NO_MORE_ENTRIES - otherwise it returns
    the error that occured, similar to ExNext.)
  @{i}MatchString@{ui}:
    If this field is NULL then all filenames will be returned.If
    this field is non-null then it is interpreted as a pointer to
    a string that is used to pattern match all file names before
    accepting them and putting them into the buffer.The default
    AmigaDOS caseless pattern match routine is used.This string
    @{b}MUST@{ub} have been parsed by ParsePatternNoCase()!
  @{i}MatchFunc@{ui}:
    Contains a pointer to a hook for a routine to decide if the entry
    will be included in the returned list of entries.The entry is
    filled out first, and then passed to the hook.If no MatchFunc is
    to be called then this entry should be NULL.The hook is
    called with the following parameters (as is standard for hooks):
    BOOL = MatchFunc( @{i}hookptr@{ui}, @{i}data@{ui}, @{i}typeptr@{ui} )
                       a0       a1    a2
    (a0 = ptr to hook, a1 = ptr to filled in @{"ExAllData" Link "include:dos/exall.h/Main" 39}, a2 = ptr
      to longword of type).
    MatchFunc should return FALSE if the entry is not to be
    accepted, otherwise return TRUE.
  Note that Dos will emulate ExAll() using @{"Examine()" Link "Examine()"} and @{"ExNext()" Link "ExNext()"}
  if the handler in question doesn't support the ExAll() packet.
SYNOPSIS  BOOL ExAll(BPTR,STRPTR,@{FG shine}long@{FG text},@{FG shine}long@{FG text},@{FG shine}struct@{FG text} @{"ExAllControl" Link "include:dos/exall.h/Main" 62} *)
  @{i}@{b}continue@{ub}@{ui} = ExAll(@{i}lock@{ui}, @{i}buffer@{ui}, @{i}size@{ui}, @{i}type@{ui}, @{i}control@{ui})
   D0               D1     D2      D3    D4    D5
  @{i}lock@{ui} - Lock on directory to be examined.
  @{i}buffer@{ui} - Buffer for data returned (@{b}MUST@{ub} be at least word-aligned,
    preferably long-word aligned).
  @{i}size@{ui} - Size in bytes of 'buffer'.
  @{i}type@{ui} - Type of data to be returned.
  @{i}control@{ui} - Control data structure (see notes above).
    @{b}MUST@{ub} have been allocated by AllocDosObject!
  @{i}@{b}continue@{ub}@{ui} - Whether or not ExAll is done.
    If FALSE is returned, either ExAll has completed
    (IoErr() == ERROR_NO_MORE_ENTRIES), or an error occurred (check IoErr()).
    If non-zero is returned, you @{b}MUST@{ub} call ExAll again until it returns FALSE.
EXAMPLE
  @{i}eac@{ui} = AllocDosObject(DOS_EXALLCONTROL,NULL);
  @{FG shine}if@{FG text} (!@{i}eac@{ui}) ...
     ...
  @{i}eac@{ui}->@{i}eac_LastKey@{ui} = 0;
  @{FG shine}do@{FG text} {
    @{i}more@{ui} = ExAll(@{i}lock@{ui}, @{i}EAData@{ui}, @{FG shine}sizeof@{FG text}(@{i}EAData@{ui}), ED_FOO, @{i}eac@{ui});
    @{FG shine}if@{FG text} ((!@{i}more@{ui}) && (IoErr() != ERROR_NO_MORE_ENTRIES)) {
      \* ExAll failed abnormally *\
      @{FG shine}break@{FG text};
    }
    @{FG shine}if@{FG text} (@{i}eac@{ui}->@{i}eac_Entries@{ui} == 0) {
      \* ExAll failed normally with no entries *\
      @{FG shine}continue@{FG text}; \* ("more" is *usually* zero) *\
    }
    @{i}ead@{ui} = (@{FG shine}struct@{FG text} @{"ExAllData" Link "include:dos/exall.h/Main" 39} *) @{i}EAData@{ui};
    @{FG shine}do@{FG text} {
      \* use ead here *\
      ...
      \* get next ead *\
      @{i}ead@{ui} = @{i}ead@{ui}->@{i}ed_Next@{ui};
    } @{FG shine}while@{FG text} (@{i}ead@{ui});
  } @{FG shine}while@{FG text} (@{i}more@{ui});
     ...
  FreeDosObject(DOS_EXALLCONTROL,@{i}eac@{ui});
BUGS
  In V36, there were problems with ExAll (particularily with
  eac_MatchString, and ed_Next with the ramdisk and the emulation
  of it in Dos for handlers that do not support the packet.It is
  advised you only use this under V37 and later.
  The V37 ROM/disk filesystem incorrectly returned comments as BSTR's
  (length plus characters) instead of CSTR's (null-terminated).See
  the next bug for a way to determine if the filesystem is a V37
  ROM/disk filesystem.Fixed in V39.
  The V37 ROM/disk filesystem incorrectly handled values greater than
  ED_COMMENT.Because of this, ExAll() information is trashed if
  ED_OWNER is passed to it.Fixed in V39.To work around this, use
  the following code to identify if a filesystem is a V37 ROM/disk filesystem:
    // return TRUE if this is a V37 ROM filesystem, which doesn't (really)
    // support ED_OWNER safely
    BOOL CheckV37(BPTR @{i}lock@{ui})
    {
      @{FG shine}struct@{FG text} @{"FileLock" Link "include:dos/dosextens.h/Main" 453} *@{i}l@{ui} = BADDR(@{i}lock@{ui});
      @{FG shine}struct@{FG text} @{"Resident" Link "include:exec/resident.h/Main" 19} *@{i}resident@{ui};
      @{FG shine}struct@{FG text} @{"DosList" Link "include:dos/dosextens.h/Main" 369} *@{i}dl@{ui};
      BOOL @{i}result@{ui} = FALSE;
      @{i}dl@{ui} = LockDosList(LDF_READ|LDF_DEVICES);
      // if the lock has a volume and no device, we won't find it,
      // so we know it's not a V37 ROM/disk filesystem
      @{FG shine}do@{FG text} {
         @{i}dl@{ui} = NextDosEntry(@{i}dl@{ui},LDF_READ|LDF_DEVICES);
         @{FG shine}if@{FG text} (@{i}dl@{ui} && (@{i}dl@{ui}->@{i}dol_Task@{ui} == @{i}l@{ui}->@{i}fl_Task@{ui}))
         {
           // found the filesystem - test isn't actually required,
           // but we know the filesystem we're looking for will always
           // have a startup msg.If we needed to examine the message,
           // we would need a _bunch_ of checks to make sure it's not
           // either a small value (like port-handler uses) or a BSTR.
           @{FG shine}if@{FG text} (dl->dol_misc.@{i}dol_handler@{ui}.@{i}dol_Startup@{ui})
           {
             // try to make sure it's the ROM fs or l:FastFileSystem
             @{FG shine}if@{FG text} (@{i}resident@{ui} = FindRomTag(@{i}dl@{ui}->dol_misc.dol_handler.@{i}dol_SegList@{ui}))
             {
               @{FG shine}if@{FG text} (@{i}resident@{ui}->@{i}rt_Version@{ui} < 39 &&
               (strncmp(@{i}resident@{ui}->@{i}rt_IdString@{ui},"fs 37.", strlen("fs 37.")) == 0 ||
                strncmp(@{i}resident@{ui}->@{i}rt_Name@{ui},"ffs 37.", strlen("ffs 37.")) == 0))
               {
                 @{i}result@{ui} = TRUE;
               }
             }
           }
           @{FG shine}break@{FG text};
         }
      } @{FG shine}while@{FG text} (@{i}dl@{ui});
      UnLockDosList(LDF_READ|LDF_DEVICES);
      @{FG shine}return@{FG text} @{i}result@{ui};
    }
SEE ALSO
  @{"Examine()" Link "Examine()"}, @{"ExNext()" Link "ExNext()"}, @{"ExamineFH()" Link "ExamineFH()"}, @{"MatchPatternNoCase()" Link "MatchPatternNoCase()"},
  @{"ParsePatternNoCase()" Link "ParsePatternNoCase()"}, @{"AllocDosObject()" Link "AllocDosObject()"}, @{"ExAllEnd()" Link "ExAllEnd()"}
@EndNode
@Node "ExAllEnd()" "dos.library/ExAllEnd"
@{b}@{u}ExAllEnd@{uu}@{ub} -- Stop an @{"ExAll()" Link "ExAll()"}.(V39)
  Stops an @{"ExAll()" Link "ExAll()"} on a directory before it hits NO_MORE_ENTRIES.
  The full set of arguments that had been passed to @{"ExAll()" Link "ExAll()"} must be
  passed to ExAllEnd(), so it can handle filesystems that can't abort
  an @{"ExAll()" Link "ExAll()"} directly.
SYNOPSIS  ExAllEnd(BPTR,STRPTR,@{FG shine}long@{FG text},@{FG shine}long@{FG text},@{FG shine}struct@{FG text} @{"ExAllControl" Link "include:dos/exall.h/Main" 62} *)
  ExAllEnd(@{i}lock@{ui}, @{i}buffer@{ui}, @{i}size@{ui}, @{i}type@{ui}, @{i}control@{ui})
            D1     D2     D3     D4    D5
  @{i}lock@{ui} - Lock on directory to be examined.
  @{i}buffer@{ui} - Buffer for data returned
    (@{b}MUST@{ub} be at least word-aligned, preferably long-word aligned).
  @{i}size@{ui} - Size in bytes of 'buffer'.
  @{i}type@{ui} - Type of data to be returned.
  @{i}control@{ui} - Control data structure (see notes above).
    @{b}MUST@{ub} have been allocated by AllocDosObject!
SEE ALSO
  @{"ExAll()" Link "ExAll()"}, @{"AllocDosObject()" Link "AllocDosObject()"}
@EndNode
@Node "Examine()" "dos.library/Examine"
@{b}@{u}Examine@{uu}@{ub} -- Examine a directory or file associated with a lock.
  Examine() fills in information in the @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61} concerning the
  file or directory associated with the lock.This information
  includes the name, size, creation date and whether it is a file or
  directory.@{"FileInfoBlock" Link "include:dos/dos.h/Main" 61} must be longword aligned.Examine() gives
  a return code of zero if it fails.
  You may make a local copy of the @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61}, as long as it is
  never passed to @{"ExNext()" Link "ExNext()"}.
SYNOPSIS  BOOL Examine(BPTR,@{FG shine}struct@{FG text} @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61} *)
  @{i}@{b}success@{ub}@{ui} = Examine( @{i}lock@{ui}, @{i}FileInfoBlock@{ui} )
   D0                 D1     D2
  @{i}lock@{ui} - BCPL pointer to a lock
  @{i}infoBlock@{ui} - pointer to a @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61} (@{b}MUST@{ub} be longword aligned)
  @{i}@{b}success@{ub}@{ui} - boolean
SPECIAL NOTE
  @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61} must be longword-aligned.@{"AllocDosObject()" Link "AllocDosObject()"} will
  allocate them correctly for you.
SEE ALSO
  @{"Lock()" Link "Lock()"}, @{"UnLock()" Link "UnLock()"}, @{"ExNext()" Link "ExNext()"}, @{"ExamineFH()" Link "ExamineFH()"}, @{"<dos/dos.h>" Link "include:dos/dos.h/Main" 0}, @{"AllocDosObject()" Link "AllocDosObject()"},
  @{"ExAll()" Link "ExAll()"}
@EndNode
@Node "ExamineFH()" "dos.library/ExamineFH"
@{b}@{u}ExamineFH@{uu}@{ub} -- Gets information on an open file.(V36)
  Examines a filehandle and returns information about the file in the
  @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61}.There are no guarantees as to whether the fib_Size
  field will reflect any changes made to the file size it was opened,
  though filesystems should attempt to provide up-to-date information for it.
SYNOPSIS  BOOL ExamineFH(BPTR, @{FG shine}struct@{FG text} @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61} *)
  @{i}@{b}success@{ub}@{ui} = ExamineFH(@{i}fh@{ui}, @{i}fib@{ui})
   D0                  D1   D2
  @{i}fh@{ui} - Filehandle you wish to examine
  @{i}fib@{ui} - @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61}, must be longword aligned.
  @{i}@{b}success@{ub}@{ui} - Success/failure indication
SEE ALSO
  @{"Examine()" Link "Examine()"}, @{"ExNext()" Link "ExNext()"}, @{"ExAll()" Link "ExAll()"}, @{"Open()" Link "Open()"}, @{"AllocDosObject()" Link "AllocDosObject()"}
@EndNode
@Node "Execute()" "dos.library/Execute"
@{b}@{u}Execute@{uu}@{ub} -- Execute a CLI command.
  This function attempts to execute the string commandString as a
  Shell command and arguments.The string can contain any valid input
  that you could type directly in a Shell, including input and output
  redirection using < and >.@{i}Note@{ui} that Execute() doesn't return until
  the command(s) in commandstring have returned.
  The input file handle will normally be zero, and in this case
  Execute() will perform whatever was requested in the commandString
  and then return.If the input file handle is nonzero then after the
  (possibly empty) commandString is performed subsequent input is read
  from the specified input file handle until end of that file is reached.
  In most cases the output file handle must be provided, and is used by the
  Shell commands as their output stream unless output redirection was
  specified.If the output file handle is set to zero then the current window,
  normally specified as *, is used.@{i}Note@{ui} that programs running under the
  Workbench do not normally have a current window.
  Execute() may also be used to create a new interactive Shell process
  just like those created with the NewShell command.In order to do
  this you would call Execute() with an empty commandString, and pass
  a file handle relating to a new window as the input file handle.
  The output file handle would be set to zero.The Shell will read commands
  from the new window, and will use the same window for output.This new
  Shell window can only be terminated by using the EndCLI command.
  @{i}Under V37@{ui}, if an input filehandle is passed, and it's either interactive or
  a NIL: filehandle, the pr_ConsoleTask of the new process will be set to that
  filehandle's process (the same applies to @{"SystemTagList()" Link "SystemTagList()"}).
  For this command to work the program Run must be present in C: in
  versions before V36 (except that in 1.3.2 and any later 1.3 versions,
  the system first checks the resident list for Run).
SYNOPSIS  BOOL Execute(STRPTR, BPTR, BPTR)
  @{i}@{b}success@{ub}@{ui} = Execute( @{i}commandString@{ui}, @{i}input@{ui}, @{i}output@{ui} )
   D0                 D1              D2     D3
  @{i}commandString@{ui} - pointer to a null-terminated string
  @{i}input@{ui} - BCPL pointer to a file handle
  @{i}output@{ui} - BCPL pointer to a file handle
  @{i}@{b}success@{ub}@{ui} - BOOLEAN indicating whether Execute was successful
    in finding and starting the specified program.
    Note that this is @{b}NOT@{ub} the return code of the command(s).
SEE ALSO
  @{"SystemTagList()" Link "SystemTagList()"}, NewShell, EndCLI, Run
@EndNode
@Node "Exit()" "dos.library/Exit"
@{b}@{u}Exit@{uu}@{ub} -- Exit from a program.
  Exit() is currently for use with programs written as if they
  were BCPL programs.This function is not normally useful for other purposes.
  In general, therefore, please @{b}DO NOT CALL THIS@{ub} !
  In order to exit, C programs should use the C language exit() function
  (note the lower case letter "e").Assembly programs should place a return code
  in D0, and execute an RTS instruction with their original stack ptr.
SYNOPSIS  @{FG shine}void@{FG text} Exit(@{FG shine}long@{FG text})
  Exit( @{i}returnCode@{ui} )
         D1
  @{i}returnCode@{ui} - integer
IMPLEMENTATION
  The action of Exit() depends on whether the program which called it
  is running as a command under a CLI or not.If the program is running
  under the CLI the command finishes and control reverts to the CLI.In
  this case, returnCode is interpreted as the return code from the program.
  If the program is running as a distinct process, Exit() deletes the
  process and release the space associated with the stack, segment
  list and process structure.
SEE ALSO
  @{"CreateProc()" Link "CreateProc()"}, @{"CreateNewProc()" Link "CreateNewProc()"}
@EndNode
@Node "ExNext()" "dos.library/ExNext"
@{b}@{u}ExNext@{uu}@{ub} -- Examine the next entry in a directory.
  This routine is passed a directory lock and a @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61} that
  have been initialized by a previous call to @{"Examine()" Link "Examine()"}, or updated
  by a previous call to ExNext().ExNext() gives a return code of zero
  on failure.The most common cause of failure is reaching the end
  of the list of files in the owning directory.In this case, @{"IoErr" Link "IoErr()"}
  will return ERROR_NO_MORE_ENTRIES and a good exit is appropriate.
  @{b}@{u}So, follow these steps to examine a directory@{uu}@{ub}:
  1) Pass a Lock and a @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61} to @{"Examine()" Link "Examine()"}.The lock must
     be on the directory you wish to examine.
  2) Pass ExNext() the same lock and @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61}.
  3) Do something with the information returned in the @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61}.
     @{i}Note@{ui} that the fib_DirEntryType field is positive for directories,
     negative for files.
  4) Keep calling ExNext() until it returns FALSE.Check @{"IoErr()" Link "IoErr()"}
     to ensure that the reason for failure was ERROR_NO_MORE_ENTRIES.
  @{i}Note@{ui}: if you wish to recursively scan the file tree and you find
  another directory while ExNext()ing you must Lock that directory and
  @{"Examine()" Link "Examine()"} it using a new @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61}.Use of the same
  @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61} to enter a directory would lose important state
  information such that it will be impossible to continue scanning
  the parent directory.While it is permissible to @{"UnLock()" Link "UnLock()"} and @{"Lock()" Link "Lock()"}
  the parent directory between ExNext() calls, this is @{b}NOT@{ub} recommended.
  Important state information is associated with the parent lock, so if it is
  freed between ExNext() calls this information has to be rebuilt on each
  new ExNext() call, and will significantly slow down directory scanning.
  It is @{b}NOT@{ub} legal to @{"Examine()" Link "Examine()"} a file, and then to ExNext() from that
  @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61}.You may make a local copy of the @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61}, as
  long as it is never passed back to the operating system.
SYNOPSIS  BOOL ExNext(BPTR, @{FG shine}struct@{FG text} @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61} *)
  @{i}@{b}success@{ub}@{ui} = ExNext( @{i}lock@{ui}, @{i}FileInfoBlock@{ui} )
   D0                D1    D2
  @{i}lock@{ui} - BCPL pointer to a lock originally used for the @{"Examine()" Link "Examine()"} call
  @{i}infoBlock@{ui} - pointer to a @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61} used on the previous @{"Examine()" Link "Examine()"} or ExNext() call.
  @{i}@{b}success@{ub}@{ui} - boolean
SPECIAL NOTE
  @{"FileInfoBlock" Link "include:dos/dos.h/Main" 61} must be longword-aligned.@{"AllocDosObject()" Link "AllocDosObject()"} will
  allocate them correctly for you.
SEE ALSO
  @{"Examine()" Link "Examine()"}, @{"Lock()" Link "Lock()"}, @{"UnLock()" Link "UnLock()"}, @{"IoErr()" Link "IoErr()"}, @{"ExamineFH()" Link "ExamineFH()"}, @{"AllocDosObject()" Link "AllocDosObject()"},
  @{"ExAll()" Link "ExAll()"}
@EndNode
@Node "Fault()" "dos.library/Fault"
@{b}@{u}Fault@{uu}@{ub} -- Returns the text associated with a DOS error code.(V36)
  This routine obtains the error message text for the given error code.
  The header is prepended to the text of the error message, followed
  by a colon.Puts a null-terminated string for the error message into
  the buffer.By convention, error messages should be no longer than 80
  characters (+1 for termination), and preferably no more than 60.
  The value returned by @{"IoErr()" Link "IoErr()"} is set to the code passed in.If there
  is no message for the error code, the message will be "Error code <number>\n".
  The number of characters put into the buffer is returned, which will
  be 0 if the code passed in was 0.
SYNOPSIS  @{FG shine}long@{FG text} Fault(@{FG shine}long@{FG text}, STRPTR, STRPTR, @{FG shine}long@{FG text})
  @{i}@{b}len@{ub}@{ui} = Fault(@{i}code@{ui}, @{i}header@{ui}, @{i}buffer@{ui}, @{i}len@{ui})
   D0          D1    D2       D3      D4
  @{i}code@{ui} - Error code
  @{i}header@{ui} - header to output before error text
  @{i}buffer@{ui} - Buffer to receive error message.
  @{i}len@{ui} - Length of the buffer.
  @{i}@{b}len@{ub}@{ui} - number of characters put into buffer (may be 0)
SEE ALSO
  @{"IoErr()" Link "IoErr()"}, @{"SetIoErr()" Link "SetIoErr()"}, @{"PrintFault()" Link "PrintFault()"}
BUGS
  In older documentation, the return was shown as BOOL success.This
  was incorrect, it has always returned the length.
@EndNode
@Node "FGetC()" "dos.library/FGetC"
@{b}@{u}FGetC@{uu}@{ub} -- Read a character from the specified input (buffered).(V36)
  Reads the next character from the input stream.A -1 is returned
  when EOF or an error is encountered.This call is buffered.
  Use @{"Flush()" Link "Flush()"} between buffered and unbuffered I/O on a filehandle.
SYNOPSIS  @{FG shine}long@{FG text} FGetC(BPTR)
  @{i}@{b}char@{ub}@{ui} = FGetC(@{i}fh@{ui})
   D0           D1
  @{i}fh@{ui} - filehandle to use for buffered I/O
  @{i}@{b}char@{ub}@{ui} - character read (0-255) or -1
BUGS
  In V36, after an EOF was read, EOF would always be returned from
  FGetC() from then on.Starting in V37, it tries to read from the
  handler again each time (unless UnGetC(fh,-1) was called).
SEE ALSO
  @{"FPutC()" Link "FPutC()"}, @{"UnGetC()" Link "UnGetC()"}, @{"Flush()" Link "Flush()"}
@EndNode
@Node "FGets()" "dos.library/FGets"
@{b}@{u}FGets@{uu}@{ub} -- Reads a line from the specified input (buffered).(V36)
  This routine reads in a single line from the specified input stopping
  at a NEWLINE character or EOF.In either event, UP TO the number of
  len specified bytes minus 1 will be copied into the buffer.Hence if
  a length of 50 is passed and the input line is longer than 49 bytes,
  it will return 49 characters.It returns the buffer pointer normally,
  or NULL if EOF is the first thing read.
  If terminated by a newline, the newline @{b}WILL@{ub} be the last character in the
  buffer.This is a buffered read routine.The string read in IS null-terminated.
SYNOPSIS  STRPTR FGets(BPTR, STRPTR, ULONG)
  @{i}@{b}buffer@{ub}@{ui} = FGets(@{i}fh@{ui}, @{i}buf@{ui}, @{i}len@{ui})
   D0             D1  D2    D3
  @{i}fh@{ui} - filehandle to use for buffered I/O
  @{i}buf@{ui} - Area to read bytes into.
  @{i}len@{ui} - Number of bytes to read, must be > 0.
  @{i}@{b}buffer@{ub}@{ui} - Pointer to buffer passed in, or NULL for immediate EOF or for an error.
    If NULL is returned for an EOF, @{"IoErr()" Link "IoErr()"} will return 0.
BUGS
  In V36 and V37, it copies one more byte than it should if it doesn't
  hit an EOF or newline.In the example above, it would copy 50 bytes
  and put a null in the 51st.This is fixed in dos V39.Workaround
  for V36/V37: pass in buffersize-1.
SEE ALSO
  @{"FRead()" Link "FRead()"}, @{"FPuts()" Link "FPuts()"}, @{"FGetC()" Link "FGetC()"}
@EndNode
@Node "FilePart()" "dos.library/FilePart"
@{b}@{u}FilePart@{uu}@{ub} -- Returns the last component of a path.(V36)
  This function returns a pointer to the last component of a string path
  specification, which will normally be the file name.If there is only
  one component, it returns a pointer to the beginning of the string.
SYNOPSIS  STRPTR FilePart( STRPTR )
  @{i}@{b}fileptr@{ub}@{ui} = FilePart( @{i}path@{ui} )
   D0                  D1
  @{i}path@{ui} - pointer to an path string.May be relative to the current
    directory or the current disk.
  @{i}@{b}fileptr@{ub}@{ui} - pointer to the last component of the path.
EXAMPLE
  FilePart("xxx:yyy/zzz/qqq") would return a pointer to the first 'q'.
  FilePart("xxx:yyy") would return a pointer to the first 'y').
SEE ALSO
  @{"PathPart()" Link "PathPart()"}, @{"AddPart()" Link "AddPart()"}
@EndNode
@Node "FindArg()" "dos.library/FindArg"
@{b}@{u}FindArg@{uu}@{ub} - find a keyword in a template.(V36)
  Returns the argument number of the keyword, or -1 if it is not a
  keyword for the template.Abbreviations are handled.
SYNOPSIS  @{FG shine}long@{FG text} FindArg(STRPTR, STRPTR)
  @{i}@{b}index@{ub}@{ui} = FindArg(@{i}template@{ui}, @{i}keyword@{ui})
   D0              D1         D2
  @{i}keyword@{ui} - keyword to search for in template
  @{i}template@{ui} - template string to search
  @{i}@{b}index@{ub}@{ui} - number of entry in template, or -1 if not found
BUGS
  In earlier published versions of the autodoc, keyword and template
  were backwards.
SEE ALSO
  @{"ReadArgs()" Link "ReadArgs()"}, @{"ReadItem()" Link "ReadItem()"}, @{"FreeArgs()" Link "FreeArgs()"}
@EndNode
@Node "FindCliProc()" "dos.library/FindCliProc"
@{b}@{u}FindCliProc@{uu}@{ub} -- returns a pointer to the requested CLI process.(V36)
  This routine returns a pointer to the CLI process associated with the 
  given CLI number.If the process isn't an active CLI process, NULL is
  returned.@{i}NOTE@{ui}:should normally be called inside a @{"Forbid()" Link "exec.guide/Forbid()"}, if you
  must use this function at all.
SYNOPSIS  @{FG shine}struct@{FG text} @{"Process" Link "include:dos/dosextens.h/Main" 37} *FindCliProc(ULONG)
  @{i}@{b}proc@{ub}@{ui} = FindCliProc(@{i}num@{ui})
   D0                 D1
  @{i}num@{ui}  - @{"Task" Link "include:exec/tasks.h/Main" 24} number of CLI process (range 1-N)
  @{i}@{b}proc@{ub}@{ui} - Pointer to given CLI process
SEE ALSO
  @{"Cli()" Link "Cli()"}, @{"Forbid()" Link "exec.guide/Forbid()"}, @{"MaxCli()" Link "MaxCli()"}
@EndNode
@Node "FindDosEntry()" "dos.library/FindDosEntry"
@{b}@{u}FindDosEntry@{uu}@{ub} -- Finds a specific Dos @{"List" Link "include:exec/lists.h/Main" 20} entry.(V36)
  Locates an entry on the device list.Starts with the entry dlist.
  @{i}NOTE@{ui}:must be called with the device list locked, no references may be
  made to dlist after unlocking.
SYNOPSIS  @{FG shine}struct@{FG text} @{"DosList" Link "include:dos/dosextens.h/Main" 369} *FindDosEntry(@{FG shine}struct@{FG text} @{"DosList" Link "include:dos/dosextens.h/Main" 369} *,STRPTR,ULONG)
  @{i}@{b}newdlist@{ub}@{ui} = FindDosEntry(@{i}dlist@{ui},@{i}name@{ui},@{i}flags@{ui})
   D0                      D1    D2    D3
  @{i}dlist@{ui} - The device entry to start with.
  @{i}name@{ui} - Name of device entry (without ':') to locate.
  @{i}flags@{ui} - Search control flags.Use the flags you passed to @{"LockDosList" Link "LockDosList()"},
    or a subset of them.LDF_READ/LDF_WRITE are not required for this call.
  @{i}@{b}newdlist@{ub}@{ui} - The device entry or NULL
SEE ALSO
  @{"AddDosEntry()" Link "AddDosEntry()"}, @{"RemDosEntry()" Link "RemDosEntry()"}, @{"NextDosEntry()" Link "NextDosEntry()"}, @{"LockDosList()" Link "LockDosList()"},
  @{"MakeDosEntry()" Link "MakeDosEntry()"}, @{"FreeDosEntry()" Link "FreeDosEntry()"}
@EndNode
@Node "FindSegment()" "dos.library/FindSegment"
@{b}@{u}FindSegment@{uu}@{ub} - Finds a segment on the resident list.(V36)
  Finds a segment on the Dos resident list by name and type, starting
  at the segment @{b}AFTER@{ub} 'start', or at the beginning if start is NULL.
  If system is zero, it will only return nodes with a seg_UC of 0 or more.
  It does @{b}NOT@{ub} increment the seg_UC, and it does @{b}NOT@{ub} do any locking of the list.
  You must @{"Forbid()" Link "exec.guide/Forbid()"} lock the list to use this call.
  To use an entry you have found, you must:if the seg_UC is 0 or more, increment
  it, and decrement it (under Forbid()!) when you're done with the seglist.
  @{b}@{u}The other values for seg_UC are@{uu}@{ub}:
    -1   - system module, such as a filesystem or shell
    -2   - resident shell command
    -999 - disabled internal command, ignore
  Negative values should never be modified.All other negative values
  between 0 and -32767 are reserved to AmigaDos and should not be used.
SYNOPSIS  @{FG shine}struct@{FG text} @{"Segment" Link "include:dos/dosextens.h/Main" 296} *FindSegment(STRPTR, @{FG shine}struct@{FG text} @{"Segment" Link "include:dos/dosextens.h/Main" 296} *, @{FG shine}long@{FG text})
  @{i}@{b}segment@{ub}@{ui} = FindSegment(@{i}name@{ui}, @{i}start@{ui}, @{i}system@{ui})
   D0                    D1    D2      D3
  @{i}name@{ui} - name of segment to find
  @{i}start@{ui} - segment to start the search after
  @{i}system@{ui} - true for system segment, false for normal segments
  @{i}@{b}segment@{ub}@{ui} - the segment found or NULL
SEE ALSO
  @{"AddSegment()" Link "AddSegment()"}, @{"RemSegment()" Link "RemSegment()"}, @{"Forbid()" Link "exec.guide/Forbid()"}
@EndNode
@Node "FindVar()" "dos.library/FindVar"
@{b}@{u}FindVar@{uu}@{ub} -- Finds a local variable.(V36)
  Finds a local variable structure.
SYNOPSIS  @{FG shine}struct@{FG text} @{"LocalVar" Link "include:dos/var.h/Main" 25} * FindVar(STRPTR, ULONG )
  @{i}@{b}var@{ub}@{ui} = FindVar( @{i}name@{ui}, @{i}type@{ui} )
   D0             D1     D2
  @{i}name@{ui} - pointer to an variable name.Note variable names follow
    filesystem syntax and semantics.
  @{i}type@{ui} - type of variable to be found (see @{"<dos/var.h>" Link "include:dos/var.h/Main" 0})
  @{i}@{b}var@{ub}@{ui} - pointer to a @{"LocalVar" Link "include:dos/var.h/Main" 25} structure or NULL
SEE ALSO
  @{"GetVar()" Link "GetVar()"}, @{"SetVar()" Link "SetVar()"}, @{"DeleteVar()" Link "DeleteVar()"}, @{"<dos/var.h>" Link "include:dos/var.h/Main" 0}
@EndNode
@Node "Flush()" "dos.library/Flush"
@{b}@{u}Flush@{uu}@{ub} -- Flushes buffers for a buffered filehandle.(V36)
  Flushes any pending buffered writes to the filehandle.All buffered
  writes will also be flushed on @{"Close()" Link "Close()"}.If the filehandle was being
  used for input, it drops the buffer, and tries to @{"Seek()" Link "Seek()"} back to the
  last read position  (so subsequent reads or writes will occur at the
  expected position in the file).
SYNOPSIS  @{FG shine}long@{FG text} Flush(BPTR)
  @{i}@{b}success@{ub}@{ui} = Flush(@{i}fh@{ui})
   D0              D1
  @{i}fh@{ui}  - Filehandle to flush.
  @{i}@{b}success@{ub}@{ui} - Success or failure.
BUGS
  Before V37 release, Flush() returned a random value.As of V37,
  it always returns success (this will be fixed in some future release).
  The V36 and V37 releases didn't properly flush filehandles which
  have never had a buffered IO done on them.This commonly occurs
  on redirection of input of a command, or when opening a file for
  input and then calling @{"CreateNewProc()" Link "CreateNewProc()"} with NP_Arguments, or when
  using a new filehandle with @{"SelectInput()" Link "SelectInput()"} and then calling
  @{"RunCommand()" Link "RunCommand()"}.This is fixed in V39.A workaround would be to
  do @{"FGetC()" Link "FGetC()"}, then @{"UnGetC()" Link "UnGetC()"}, then Flush().
SEE ALSO
  FputC(), @{"FGetC()" Link "FGetC()"}, @{"UnGetC()" Link "UnGetC()"}, @{"Seek()" Link "Seek()"}, @{"Close()" Link "Close()"}, @{"CreateNewProc()" Link "CreateNewProc()"},
  @{"SelectInput()" Link "SelectInput()"}, @{"RunCommand()" Link "RunCommand()"}
@EndNode
@Node "Format()" "dos.library/Format"
@{b}@{u}Format@{uu}@{ub} -- Causes a filesystem to initialize itself.(V36)
  Interface for initializing new media on a device.This causes the
  filesystem to write out an empty disk structure to the media, which
  should then be ready for use.This assumes the media has been low-
  level formatted and verified already.
  The filesystem should be inhibited before calling Format() to make
  sure you don't get an ERROR_OBJECT_IN_USE.
SYNOPSIS  BOOL Format(STRPTR, STRPTR, ULONG)
  @{i}@{b}success@{ub}@{ui} = Format(@{i}filesystem@{ui}, @{i}volumename@{ui}, @{i}dostype@{ui})
   D0               D1           D2          D3
  @{i}filesystem@{ui} - Name of device to be formatted.':' must be supplied.
  @{i}volumename@{ui} - Name for volume (if supported).No ':'.
  @{i}dostype@{ui} - Type of format, if filesystem supports multiple types.
  @{i}@{b}success@{ub}@{ui} - Success/failure indicator.
BUGS
  Existed, but was non-functional in V36 dos.(The volumename wasn't
  converted to a BSTR.)  Workaround: require V37, or under V36
  convert volumename to a BPTR to a BSTR before calling Format().
  Note: a number of printed packet docs for ACTION_FORMAT are wrong
  as to the arguments.
@EndNode
@Node "FPutC()" "dos.library/FPutC"
@{b}@{u}FPutC@{uu}@{ub} -- Write a character to the specified output (buffered).(V36)
  Writes a single character to the output stream.This call is
  buffered.Use @{"Flush()" Link "Flush()"} between buffered and unbuffered I/O on a
  filehandle.Interactive filehandles are flushed automatically
  on a newline, return, '\0', or line feed.
SYNOPSIS  @{FG shine}long@{FG text} FPutC(BPTR, @{FG shine}long@{FG text})
  @{i}@{b}char@{ub}@{ui} = FPutC(@{i}fh@{ui}, @{i}char@{ui})
   D0           D1   D2
  @{i}fh@{ui} - filehandle to use for buffered I/O
  @{i}char@{ui} - character to write
  @{i}@{b}char@{ub}@{ui} - either the character written, or EOF for an error.
BUGS
  Older autodocs indicated that you should pass a UBYTE.The
  correct usage is to pass a long in the range 0-255.
SEE ALSO
  @{"FGetC()" Link "FGetC()"}, @{"UnGetC()" Link "UnGetC()"}, @{"Flush()" Link "Flush()"}
@EndNode
@Node "FPuts()" "dos.library/FPuts"
@{b}@{u}FPuts@{uu}@{ub} -- Writes a string the the specified output (buffered).(V36)
  This routine writes an unformatted string to the filehandle.No
  newline is appended to the string.This routine is buffered.
SYNOPSIS  @{FG shine}long@{FG text} FPuts(BPTR, STRPTR)
  @{i}@{b}error@{ub}@{ui} = FPuts(@{i}fh@{ui}, @{i}str@{ui})
   D0            D1  D2
  @{i}fh@{ui} - filehandle to use for buffered I/O
  @{i}str@{ui} - Null-terminated string to be written to default output
  @{i}@{b}error@{ub}@{ui} - 0 normally, otherwise -1.Note that this is opposite of
    most other Dos functions, which return success.
SEE ALSO
  @{"FGets()" Link "FGets()"}, @{"FPutC()" Link "FPutC()"}, @{"FWrite()" Link "FWrite()"}, @{"PutStr()" Link "PutStr()"}
@EndNode
@Node "FRead()" "dos.library/FRead"
@{b}@{u}FRead@{uu}@{ub} -- Reads a number of blocks from an input (buffered).(V36)
  Attempts to read a number of blocks, each blocklen long, into the
  specified buffer from the input stream.May return less than
  the number of blocks requested, either due to EOF or read errors.
  This call is buffered.
SYNOPSIS  @{FG shine}long@{FG text} FRead(BPTR, STRPTR, ULONG, ULONG)
  @{i}@{b}count@{ub}@{ui} = FRead(@{i}fh@{ui}, @{i}buf@{ui}, @{i}blocklen@{ui}, @{i}blocks@{ui})
   D0            D1  D2    D3        D4
  @{i}fh@{ui} - filehandle to use for buffered I/O
  @{i}buf@{ui} - Area to read bytes into.
  @{i}blocklen@{ui} - number of bytes per block.Must be > 0.
  @{i}blocks@{ui} - number of blocks to read.Must be > 0.
  @{i}@{b}count@{ub}@{ui} - Number of _blocks_ read, or 0 for EOF.
    On an error, the number of blocks actually read is returned.
BUGS
  Doesn't clear @{"IoErr()" Link "IoErr()"} before starting.If you want to find out
  about errors, use SetIoErr(0L) before calling.
SEE ALSO
  @{"FGetC()" Link "FGetC()"}, @{"FWrite()" Link "FWrite()"}, @{"FGets()" Link "FGets()"}
@EndNode
@Node "FreeArgs()" "dos.library/FreeArgs"
@{b}@{u}FreeArgs@{uu}@{ub} - Free allocated memory after @{"ReadArgs()" Link "ReadArgs()"}.(V36)
  Frees memory allocated to return arguments in from @{"ReadArgs()" Link "ReadArgs()"}.If
  @{"ReadArgs" Link "ReadArgs()"} allocated the @{"RDArgs" Link "include:dos/rdargs.h/Main" 95} structure it will be freed.If NULL
  is passed in this function does nothing.
SYNOPSIS  @{FG shine}void@{FG text} FreeArgs(@{FG shine}struct@{FG text} @{"RDArgs" Link "include:dos/rdargs.h/Main" 95} *)
  FreeArgs(@{i}rdargs@{ui})
            D1
  @{i}rdargs@{ui} - structure returned from @{"ReadArgs()" Link "ReadArgs()"} or NULL.
SEE ALSO
  @{"ReadArgs()" Link "ReadArgs()"}, @{"ReadItem()" Link "ReadItem()"}, @{"FindArg()" Link "FindArg()"}
@EndNode
@Node "FreeDeviceProc()" "dos.library/FreeDeviceProc"
@{b}@{u}FreeDeviceProc@{uu}@{ub} -- Releases port returned by @{"GetDeviceProc()" Link "GetDeviceProc()"}.(V36)
  Frees up the structure created by @{"GetDeviceProc()" Link "GetDeviceProc()"}, and any associated
  temporary locks.
  Decrements the counter incremented by @{"GetDeviceProc()" Link "GetDeviceProc()"}.The counter
  is in an extension to the 1.3 process structure.After calling
  FreeDeviceProc(), do not use the port or lock again!  It is safe to
  call FreeDeviceProc(NULL).
SYNOPSIS  @{FG shine}void@{FG text} FreeDeviceProc(@{FG shine}struct@{FG text} @{"DevProc" Link "include:dos/dosextens.h/Main" 418} *)
  FreeDeviceProc(@{i}devproc@{ui})
                  D1
  @{i}devproc@{ui} - A value returned by @{"GetDeviceProc()" Link "GetDeviceProc()"}
BUGS
  Counter not currently active in 2.0.
SEE ALSO
  @{"GetDeviceProc()" Link "GetDeviceProc()"}, @{"DeviceProc()" Link "DeviceProc()"}, @{"AssignLock()" Link "AssignLock()"}, @{"AssignLate()" Link "AssignLate()"},
  @{"AssignPath()" Link "AssignPath()"}
@EndNode
@Node "FreeDosEntry()" "dos.library/FreeDosEntry"
@{b}@{u}FreeDosEntry@{uu}@{ub} -- Frees an entry created by @{"MakeDosEntry" Link "MakeDosEntry()"}.(V36)
  Frees an entry created by @{"MakeDosEntry()" Link "MakeDosEntry()"}.This routine should be
  eliminated and replaced by a value passed to FreeDosObject()!
SYNOPSIS  @{FG shine}void@{FG text} FreeDosEntry(@{FG shine}struct@{FG text} @{"DosList" Link "include:dos/dosextens.h/Main" 369} *)
  FreeDosEntry(@{i}dlist@{ui})
                D1
  @{i}dlist@{ui} - @{"DosList" Link "include:dos/dosextens.h/Main" 369} to free.
SEE ALSO
  @{"AddDosEntry()" Link "AddDosEntry()"}, @{"RemDosEntry()" Link "RemDosEntry()"}, @{"FindDosEntry()" Link "FindDosEntry()"}, @{"LockDosList()" Link "LockDosList()"},
  @{"NextDosEntry()" Link "NextDosEntry()"}, @{"MakeDosEntry()" Link "MakeDosEntry()"}
@EndNode
@Node "FreeDosObject()" "dos.library/FreeDosObject"
@{b}@{u}FreeDosObject@{uu}@{ub} -- Frees an object allocated by @{"AllocDosObject()" Link "AllocDosObject()"}.(V36)
  Frees an object allocated by @{"AllocDosObject()" Link "AllocDosObject()"}.Do @{b}NOT@{ub} call for
  objects allocated in any other way.
SYNOPSIS  @{FG shine}void@{FG text} FreeDosObject(ULONG, @{FG shine}void@{FG text} *)
  FreeDosObject(@{i}type@{ui}, @{i}ptr@{ui})
                 D1    D2
  @{i}type@{ui} - type passed to @{"AllocDosObject()" Link "AllocDosObject()"}
  @{i}ptr@{ui} - ptr returned by @{"AllocDosObject()" Link "AllocDosObject()"}
BUGS
  Before V39, DOS_CLI objects will only have the struct
  @{"CommandLineInterface" Link "include:dos/dosextens.h/Main" 311} freed, not the strings it points to.This
  is fixed in V39 dos.Before V39, you can workaround this bug by
  using @{"FreeVec()" Link "exec.guide/FreeVec()"} on cli_SetName, cli_CommandFile, cli_CommandName,
  and cli_Prompt, and then setting them all to NULL.In V39 or
  above, do @{b}NOT@{ub} use the workaround.
SEE ALSO
  @{"AllocDosObject()" Link "AllocDosObject()"}, @{"FreeVec()" Link "exec.guide/FreeVec()"}, @{"<dos/dos.h>" Link "include:dos/dos.h/Main" 0}
@EndNode
@Node "FWrite()" "dos.library/FWrite"
@{b}@{u}FWrite@{uu}@{ub} -- Writes a number of blocks to an output (buffered).(V36)
  Attempts to write a number of blocks, each blocklen long, from the
  specified buffer to the output stream.May return less than the
  number of blocks requested, if there is some error such as a full
  disk or r/w error.This call is buffered.
SYNOPSIS  @{FG shine}long@{FG text} FWrite(BPTR, STRPTR, ULONG, ULONG)
  @{i}@{b}count@{ub}@{ui} = FWrite(@{i}fh@{ui}, @{i}buf@{ui}, @{i}blocklen@{ui}, @{i}blocks@{ui})
   D0             D1  D2    D3        D4
  @{i}fh@{ui} - filehandle to use for buffered I/O
  @{i}buf@{ui} - Area to write bytes from.
  @{i}blocklen@{ui} - number of bytes per block.Must be > 0.
  @{i}blocks@{ui} - number of blocks to write.Must be > 0.
  @{i}@{b}count@{ub}@{ui} - Number of _blocks_ written.On an error, the number of
    blocks actually written is returned.
BUGS
  Doesn't clear @{"IoErr()" Link "IoErr()"} before starting.If you want to find out
  about errors, use SetIoErr(0L) before calling.
SEE ALSO
  @{"FPutC()" Link "FPutC()"}, @{"FRead()" Link "FRead()"}, @{"FPuts()" Link "FPuts()"}
@EndNode
@Node "GetArgStr()" "dos.library/GetArgStr"
@{b}@{u}GetArgStr@{uu}@{ub} -- Returns the arguments for the process.(V36)
  Returns a pointer to the (null-terminated) arguments for the program
  (process).This is the same string passed in a0 on startup from CLI.
SYNOPSIS  STRPTR GetArgStr(@{FG shine}void@{FG text})
  @{i}@{b}ptr@{ub}@{ui} = GetArgStr()
   D0
  @{i}@{b}ptr@{ub}@{ui} - pointer to arguments
SEE ALSO
  @{"SetArgStr()" Link "SetArgStr()"}, @{"RunCommand()" Link "RunCommand()"}
@EndNode
@Node "GetConsoleTask()" "dos.library/GetConsoleTask"
@{b}@{u}GetConsoleTask@{uu}@{ub} -- Returns the default console for the process.(V36)
  Returns the default console task's port (pr_ConsoleTask) for the
  current process.
SYNOPSIS  @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *GetConsoleTask(@{FG shine}void@{FG text})
  @{i}@{b}port@{ub}@{ui} = GetConsoleTask()
   D0
  @{i}@{b}port@{ub}@{ui} - The pr_MsgPort of the console handler, or NULL.
SEE ALSO
  @{"SetConsoleTask()" Link "SetConsoleTask()"}, @{"Open()" Link "Open()"}
@EndNode
@Node "GetCurrentDirName()" "dos.library/GetCurrentDirName"
@{b}@{u}GetCurrentDirName@{uu}@{ub} -- returns the current directory name.(V36)
  Extracts the current directory name from the CLI structure and puts it 
  into the buffer.If the buffer is too small, the name is truncated
  appropriately and a failure code returned.If no CLI structure is
  present, a null string is returned in the buffer, and failure from
  the call (with @{"IoErr()" Link "IoErr()"} == ERROR_OBJECT_WRONG_TYPE);
SYNOPSIS  BOOL GetCurrentDirName(STRPTR, @{FG shine}long@{FG text})
  @{i}@{b}success@{ub}@{ui} = GetCurrentDirName(@{i}buf@{ui}, @{i}len@{ui})
   D0                          D1   D2
  @{i}buf@{ui} - Buffer to hold extracted name
  @{i}len@{ui} - Number of bytes of space in buffer
  @{i}@{b}success@{ub}@{ui} - Success/failure indicator
BUGS
  In V36, this routine didn't handle 0-length buffers correctly.
SEE ALSO
  @{"SetCurrentDirName()" Link "SetCurrentDirName()"}
@EndNode
@Node "GetDeviceProc()" "dos.library/GetDeviceProc"
@{b}@{u}GetDeviceProc@{uu}@{ub} -- Finds a handler to send a message to.(V36)
  Finds the handler/filesystem to send packets regarding 'name' to.
  This may involve getting temporary locks.It returns a structure
  that includes a lock and msgport to send to to attempt your operation.
  It also includes information on how to handle multiple-directory assigns
  (by passing the @{"DevProc" Link "include:dos/dosextens.h/Main" 418} back to GetDeviceProc() until it returns NULL).
  The initial call to GetDeviceProc() should pass NULL for devproc.If
  after using the returned @{"DevProc" Link "include:dos/dosextens.h/Main" 418}, you get an ERROR_OBJECT_NOT_FOUND,
  and (devproc->dvp_Flags & DVPF_ASSIGN) is true, you should call
  GetDeviceProc() again, passing it the devproc structure.It will
  either return a modified devproc structure, or NULL (with
  ERROR_NO_MORE_ENTRIES in IoErr()).Continue until it returns NULL.
  This call also increments the counter that locks a handler/fs into
  memory.After calling @{"FreeDeviceProc()" Link "FreeDeviceProc()"}, do not use the port or lock again!
SYNOPSIS  @{FG shine}struct@{FG text} @{"DevProc" Link "include:dos/dosextens.h/Main" 418} *GetDeviceProc(STRPTR, @{FG shine}struct@{FG text} @{"DevProc" Link "include:dos/dosextens.h/Main" 418} *)
  @{i}@{b}devproc@{ub}@{ui} = GetDeviceProc(@{i}name@{ui}, @{i}devproc@{ui})
   D0                      D1     D2
  @{i}name@{ui} - name of the object you wish to access.
    This can be a relative path ("foo/bar"), relative to the current volume
    (":foo/bar"), or relative to a device/volume/assign ("foo:bar").
  @{i}devproc@{ui} - A value returned by GetDeviceProc() before, or NULL
  @{i}@{b}devproc@{ub}@{ui} - a pointer to a @{"DevProc" Link "include:dos/dosextens.h/Main" 418} structure or NULL
BUGS
  Counter not currently active in 2.0.
  In 2.0 and 2.01, you HAD to check DVPF_ASSIGN before calling it again.
  This was fixed for the 2.02 release of V36.
SEE ALSO
  @{"FreeDeviceProc()" Link "FreeDeviceProc()"}, @{"DeviceProc()" Link "DeviceProc()"}, @{"AssignLock()" Link "AssignLock()"}, @{"AssignLate()" Link "AssignLate()"},
  @{"AssignPath()" Link "AssignPath()"}
@EndNode
@Node "GetFileSysTask()" "dos.library/GetFileSysTask"
@{b}@{u}GetFileSysTask@{uu}@{ub} -- Returns the default filesystem for the process.(V36)
  Returns the default filesystem task's port (pr_FileSystemTask) for the
  current process.
SYNOPSIS  @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *GetFileSysTask(@{FG shine}void@{FG text})
  @{i}@{b}port@{ub}@{ui} = GetFileSysTask()
   D0
  @{i}@{b}port@{ub}@{ui} - The pr_MsgPort of the filesystem, or NULL.
SEE ALSO
  @{"SetFileSysTask()" Link "SetFileSysTask()"}, @{"Open()" Link "Open()"}
@EndNode
@Node "GetProgramDir()" "dos.library/GetProgramDir"
@{b}@{u}GetProgramDir@{uu}@{ub} -- Returns a lock on the directory the program was loaded from.(V36)
  Returns a shared lock on the directory the program was loaded from.
  This can be used for a program to find data files, etc, that are stored
  with the program, or to find the program file itself.NULL returns are
  valid, and may occur, for example, when running a program from the
  resident list.You should @{b}NOT@{ub} unlock the lock.
SYNOPSIS  BPTR GetProgramDir(@{FG shine}void@{FG text})
  @{i}@{b}lock@{ub}@{ui} = GetProgramDir()
   D0
  @{i}@{b}lock@{ub}@{ui} - A lock on the directory the current program was loaded from,
    or NULL if loaded from resident list, etc.
BUGS
  Should return a lock for things loaded via resident.Perhaps should
  return currentdir if NULL.
SEE ALSO
  @{"SetProgramDir()" Link "SetProgramDir()"}, @{"Open()" Link "Open()"}
@EndNode
@Node "GetProgramName()" "dos.library/GetProgramName"
@{b}@{u}GetProgramName@{uu}@{ub} -- Returns the current program name.(V36)
  Extracts the program name from the CLI structure and puts it 
  into the buffer.If the buffer is too small, the name is truncated.
  If no CLI structure is present, a null string is returned in the buffer,
  and failure from the call (with @{"IoErr()" Link "IoErr()"} == ERROR_OBJECT_WRONG_TYPE);
SYNOPSIS  BOOL GetProgramName(STRPTR, @{FG shine}long@{FG text})
  @{i}@{b}success@{ub}@{ui} = GetProgramName(@{i}buf@{ui}, @{i}len@{ui})
   D0                       D1    D2
  @{i}buf@{ui} - Buffer to hold extracted name
  @{i}len@{ui} - Number of bytes of space in buffer
  @{i}@{b}success@{ub}@{ui} - Success/failure indicator
SEE ALSO
  @{"SetProgramName()" Link "SetProgramName()"}
@EndNode
@Node "GetPrompt()" "dos.library/GetPrompt"
@{b}@{u}GetPrompt@{uu}@{ub} -- Returns the prompt for the current process.(V36)
  Extracts the prompt string from the CLI structure and puts it 
  into the buffer.If the buffer is too small, the string is truncated
  appropriately and a failure code returned.If no CLI structure is
  present, a null string is returned in the buffer, and failure from
  the call (with @{"IoErr()" Link "IoErr()"} == ERROR_OBJECT_WRONG_TYPE);
SYNOPSIS  BOOL GetPrompt(STRPTR, @{FG shine}long@{FG text})
  @{i}@{b}success@{ub}@{ui} = GetPrompt(@{i}buf@{ui}, @{i}len@{ui})
   D0                  D1    D2
  @{i}buf@{ui} - Buffer to hold extracted prompt
  @{i}len@{ui} - Number of bytes of space in buffer
  @{i}@{b}success@{ub}@{ui} - Success/failure indicator
SEE ALSO
  @{"SetPrompt()" Link "SetPrompt()"}
@EndNode
@Node "GetVar()" "dos.library/GetVar"
@{b}@{u}GetVar@{uu}@{ub} -- Returns the value of a local or global variable.(V36)
  Gets the value of a local or environment variable.It is advised to
  only use ASCII strings inside variables, but not required.This stops
  putting characters into the destination when a \n is hit, unless
  GVF_BINARY_VAR is specified.(The \n is not stored in the buffer.)
SYNOPSIS  @{FG shine}long@{FG text} GetVar( STRPTR, STRPTR, @{FG shine}long@{FG text}, ULONG )
  @{i}@{b}len@{ub}@{ui} = GetVar( @{i}name@{ui}, @{i}buffer@{ui}, @{i}size@{ui}, @{i}flags@{ui} )
   D0            D1    D2       D3    D4
  @{i}name@{ui} - pointer to a variable name.
  @{i}buffer@{ui} - a user allocated area which will be used to store
    the value associated with the variable.
  @{i}size@{ui} - length of the buffer region in bytes.
  @{i}flags@{ui} - combination of type of var to get value of (low 8 bits), and flags
    to control the behavior of this routine.Currently defined flags include:
      @{b}GVF_GLOBAL_ONLY@{ub} - tries to get a global env variable.
      @{b}GVF_LOCAL_ONLY@{ub}  - tries to get a local variable.
      @{b}GVF_BINARY_VAR@{ub}  - don't stop at \n
      @{b}GVF_DONT_NULL_TERM@{ub} - no null termination
        (only valid for binary variables).(V37)
    The default is to try to get a local variable first, then
    to try to get a global environment variable.
  @{i}@{b}len@{ub}@{ui} - Size of environment variable.
    -1 indicates that the variable was not defined (if @{"IoErr()" Link "IoErr()"} returns
    ERROR_OBJECT_NOT_FOUND - it returns ERROR_BAD_NUMBER if you specify a size
    of 0).If the value would overflow the user buffer, the buffer is truncated.
    The buffer returned is null-terminated (even if GVF_BINARY_VAR is used,
    unless GVF_DONT_NULL_TERM is in effect).If it succeeds, len is the number
    of characters put in the buffer (not including null termination), and
    IoErr() will return the size of the variable (regardless of buffer size).
BUGS
  LV_VAR is the only type that can be global.
  Under V36, we documented (and it returned) the size of the variable,
  not the number of characters transferred.For V37 this was changed
  to the number of characters put in the buffer, and the total size
  of the variable is put in @{"IoErr()" Link "IoErr()"}.
  GVF_DONT_NULL_TERM only works for local variables under V37.For
  V39, it also works for globals.
SEE ALSO
  @{"SetVar()" Link "SetVar()"}, @{"DeleteVar()" Link "DeleteVar()"}, @{"FindVar()" Link "FindVar()"}, @{"<dos/var.h>" Link "include:dos/var.h/Main" 0}
@EndNode
@Node "Info()" "dos.library/Info"
@{b}@{u}Info@{uu}@{ub} -- Returns information about the disk.
  Info() can be used to find information about any disk in use.
  'lock' refers to the disk, or any file on the disk.The parameter
  block is returned with information about the size of the disk,
  number of free blocks and any soft errors.
SYNOPSIS  BOOL Info(BPTR, @{FG shine}struct@{FG text} @{"InfoData" Link "include:dos/dos.h/Main" 147} *)
  @{i}@{b}success@{ub}@{ui} = Info( @{i}lock@{ui}, @{i}parameterBlock@{ui} )
   D0              D1    D2
  @{i}lock@{ui} - BCPL pointer to a lock
  @{i}parameterBlock@{ui} - pointer to an @{"InfoData" Link "include:dos/dos.h/Main" 147} structure
    (longword aligned)
  @{i}@{b}success@{ub}@{ui} - boolean
SPECIAL NOTE:
  Note that @{"InfoData" Link "include:dos/dos.h/Main" 147} structure must be longword aligned.
@EndNode
@Node "Inhibit()" "dos.library/Inhibit"
@{b}@{u}Inhibit@{uu}@{ub} -- Inhibits access to a filesystem.(V36)
  Sends an ACTION_INHIBIT packet to the indicated handler.This stops
  all activity by the handler until uninhibited.When uninhibited,
  anything may have happened to the disk in the drive, or there may no
  longer be one.
SYNOPSIS  BOOL Inhibit(STRPTR,@{FG shine}long@{FG text})
  @{i}@{b}success@{ub}@{ui} = Inhibit(@{i}filesystem@{ui}, @{i}flag@{ui})
   D0                D1          D2
  @{i}filesystem@{ui} - Name of device to inhibit (with ':')
  @{i}flag@{ui} - New status.DOSTRUE = inhibited, FALSE = uninhibited
  @{i}@{b}success@{ub}@{ui} - Success/failure indicator
@EndNode
@Node "Input()" "dos.library/Input"
@{b}@{u}Input@{uu}@{ub} -- Identify the program's initial input file handle.
  Input() is used to identify the initial input stream allocated when
  the program was initiated.Never close the filehandle returned by Input!
SYNOPSIS  BPTR Input(@{FG shine}void@{FG text})
  @{i}@{b}file@{ub}@{ui} = Input()
   D0
  @{i}@{b}file@{ub}@{ui} - BCPL pointer to a file handle
SEE ALSO
  @{"Output()" Link "Output()"}, @{"SelectInput()" Link "SelectInput()"}
@EndNode
@Node "InternalLoadSeg()" "dos.library/InternalLoadSeg"
@{b}@{u}InternalLoadSeg@{uu}@{ub} -- Low-level load routine.(V36)
  Loads from fh.Table is used when loading an overlay, otherwise
  should be NULL.Functionarray is a pointer to an array of functions.
  Note that the current Seek position after loading may be at any point
  after the last hunk loaded.The filehandle will not be closed.If a
  stacksize is encoded in the file, the size will be stuffed in the
  long pointed to by stack.This long should be initialized to your
  default value: InternalLoadSeg() will not change it if no stacksize
  is found.Clears unused portions of Code and Data hunks (as well as
  BSS hunks).(This also applies to @{"LoadSeg()" Link "LoadSeg()"} and @{"NewLoadSeg()" Link "NewLoadSeg()"}).
  If the file being loaded is an overlaid file, this will return
  -(seglist).All other results will be positive.
  @{i}NOTE to overlay users@{ui}: InternalLoadSeg() does @{b}NOT@{ub} return seglist in
  both D0 and D1, as @{"LoadSeg" Link "LoadSeg()"} does.The current ovs.asm uses @{"LoadSeg()" Link "LoadSeg()"},
  and assumes returns are in D1.We will support this for @{"LoadSeg()" Link "LoadSeg()"} @{b}ONLY@{ub}.
SYNOPSIS  BPTR InternalLoadSeg(BPTR,BPTR,@{FG shine}long@{FG text} *,@{FG shine}long@{FG text} *)
  @{i}@{b}seglist@{ub}@{ui} = InternalLoadSeg(@{i}fh@{ui},@{i}table@{ui},@{i}functionarray@{ui},@{i}stack@{ui})
   D0                        D0 A0     A1            A2
  @{i}fh@{ui} - Filehandle to load from.
  @{i}table@{ui} - When loading an overlay, otherwise ignored.
  @{i}functionarray@{ui} - Array of function to be used for read, alloc, and free.
    @{i}FuncTable@{ui}[0] ->  @{i}@{b}Actual@{ub}@{ui} = ReadFunc(@{i}readhandle@{ui},@{i}buffer@{ui},@{i}length@{ui}),@{i}DOSBase@{ui}
                      D0                D1          A0     D0      A6
    @{i}FuncTable@{ui}[1] ->  @{i}@{b}Memory@{ub}@{ui} = AllocFunc(@{i}size@{ui},@{i}flags@{ui}), @{i}Execbase@{ui}
                      D0                 D0    D1      a6
    @{i}FuncTable@{ui}[2] ->  FreeFunc(@{i}memory@{ui},@{i}size@{ui}), @{i}Execbase@{ui}
                               A1     D0      a6
  @{i}stack@{ui} - Pointer to storage (ULONG) for stacksize.
  @{i}@{b}seglist@{ub}@{ui} - Seglist loaded or NULL.@{b}NOT@{ub} returned in D1!
BUGS
  Really should use tags.
SEE ALSO
  @{"LoadSeg()" Link "LoadSeg()"}, @{"UnLoadSeg()" Link "UnLoadSeg()"}, @{"NewLoadSeg()" Link "NewLoadSeg()"}, @{"InternalUnLoadSeg()" Link "InternalUnLoadSeg()"}
@EndNode
@Node "InternalUnLoadSeg()" "dos.library/InternalUnLoadSeg"
@{b}@{u}InternalUnLoadSeg@{uu}@{ub} -- Unloads a seglist loaded with @{"InternalLoadSeg()" Link "InternalLoadSeg()"}.(V36)
  Unloads a seglist using freefunc to free segments.Freefunc is called
  as for @{"InternalLoadSeg" Link "InternalLoadSeg()"}.
  @{i}NOTE@{ui}: will call @{"Close()" Link "Close()"} for overlaid seglists.
SYNOPSIS  BOOL InternalUnLoadSeg(BPTR,@{FG shine}void@{FG text} (*)(STRPTR,ULONG))
  @{i}@{b}success@{ub}@{ui} = InternalUnLoadSeg(@{i}seglist@{ui},@{i}FreeFunc@{ui})
   D0                          D1      A1
  @{i}seglist@{ui} - Seglist to be unloaded
  @{i}FreeFunc@{ui} - Function called to free memory
  @{i}@{b}success@{ub}@{ui} - returns whether everything went OK (since this may close files).
    Also returns FALSE if seglist was NULL.
BUGS
  Really should use tags.
SEE ALSO
  @{"LoadSeg()" Link "LoadSeg()"}, @{"UnLoadSeg()" Link "UnLoadSeg()"}, @{"InternalLoadSeg()" Link "InternalLoadSeg()"}, NewUnLoadSeg(), @{"Close()" Link "Close()"}
@EndNode
@Node "IoErr()" "dos.library/IoErr"
@{b}@{u}IoErr@{uu}@{ub} -- Return extra information from the system.
  Most I/O routines return zero to indicate an error.When this
  happens (or whatever the defined error return for the routine)
  this routine may be called to determine more information.It is
  also used in some routines to pass back a secondary result.
  @{i}Note@{ui}: there is no guarantee as to the value returned from IoErr()
  after a successful operation, unless to specified by the routine.
SYNOPSIS  @{FG shine}long@{FG text} IoErr(@{FG shine}void@{FG text})
  @{i}@{b}error@{ub}@{ui} = IoErr()
   D0
  @{i}@{b}error@{ub}@{ui} - integer
SEE ALSO
  @{"Fault()" Link "Fault()"}, @{"PrintFault()" Link "PrintFault()"}, @{"SetIoErr()" Link "SetIoErr()"}
@EndNode
@Node "IsFileSystem()" "dos.library/IsFileSystem"
@{b}@{u}IsFileSystem@{uu}@{ub} -- returns whether a Dos handler is a filesystem.(V36)
  Returns whether the device is a filesystem or not.A filesystem
  supports seperate files storing information.It may also support
  sub-directories, but is not required to.If the filesystem doesn't
  support this new packet, IsFileSystem() will use Lock(":",...) as
  an indicator.
SYNOPSIS  BOOL IsFileSystem(STRPTR)
  @{i}@{b}result@{ub}@{ui} = IsFileSystem(@{i}name@{ui})
   D0                    D1
  @{i}name@{ui} - Name of device in question, with trailing ':'.
  @{i}@{b}result@{ub}@{ui} - Flag to indicate if device is a file system
SEE ALSO
  @{"Lock()" Link "Lock()"}
@EndNode
@Node "IsInteractive()" "dos.library/IsInteractive"
@{b}@{u}IsInteractive@{uu}@{ub} -- Discover whether a file is "interactive".
  The return value 'status' indicates whether the file associated
  with the file handle 'file' is connected to a virtual terminal.
SYNOPSIS  BOOL IsInteractive(BPTR)
  @{i}@{b}status@{ub}@{ui} = IsInteractive( @{i}file@{ui} )
   D0                      D1
  @{i}file@{ui} - BCPL pointer to a file handle
  @{i}@{b}status@{ub}@{ui} - boolean
@EndNode
@Node "LoadSeg()" "dos.library/LoadSeg"
@{b}@{u}LoadSeg@{uu}@{ub} -- Scatterload a loadable file into memory.
  The file 'name' should be a load module produced by the linker.
  LoadSeg() scatterloads the CODE, DATA and BSS segments into memory,
  chaining together the segments with BPTR's on their first words.
  The end of the chain is indicated by a zero.There can be any number
  of segments in a file.All necessary relocation is handled by LoadSeg().
  In the event of an error any blocks loaded will be unloaded and a
  NULL result returned.
  If the module is correctly loaded then the output will be a pointer
  at the beginning of the list of blocks.Loaded code is unloaded via
  a call to @{"UnLoadSeg()" Link "UnLoadSeg()"}.
SYNOPSIS  BPTR LoadSeg(STRPTR)
  @{i}@{b}seglist@{ub}@{ui} = LoadSeg( @{i}name@{ui} )
   D0                 D1
  @{i}name@{ui} - pointer to a null-terminated string
  @{i}@{b}seglist@{ub}@{ui} - BCPL pointer to a seglist
SEE ALSO
  @{"UnLoadSeg()" Link "UnLoadSeg()"}, @{"InternalLoadSeg()" Link "InternalLoadSeg()"}, @{"InternalUnLoadSeg()" Link "InternalUnLoadSeg()"}, @{"CreateProc()" Link "CreateProc()"},
  @{"CreateNewProc()" Link "CreateNewProc()"}, @{"NewLoadSeg()" Link "NewLoadSeg()"}.
@EndNode
@Node "Lock()" "dos.library/Lock"
@{b}@{u}Lock@{uu}@{ub} -- Lock a directory or file.
  A filing system lock on the file or directory 'name' is returned if possible.
  If the accessMode is ACCESS_READ, the lock is a shared read lock;
  if the accessMode is ACCESS_WRITE then it is an exclusive write lock.
  Do not use random values for mode.
  If Lock() fails (that is, if it cannot obtain a filing system lock
  on the file or directory) it returns a zero.
  Tricky assumptions about the internal format of a lock are unwise,
  as are any attempts to use the fl_Link or fl_Access fields.
SYNOPSIS  BPTR Lock(STRPTR, @{FG shine}long@{FG text})
  @{i}@{b}lock@{ub}@{ui}  = Lock( @{i}name@{ui}, @{i}accessMode@{ui} )
   D0            D1     D2
  @{i}name@{ui} - pointer to a null-terminated string
  @{i}accessMode@{ui} - integer
  @{i}@{b}lock@{ub}@{ui} - BCPL pointer to a lock
SEE ALSO
  @{"UnLock()" Link "UnLock()"}, @{"DupLock()" Link "DupLock()"}, @{"ChangeMode()" Link "ChangeMode()"}, @{"NameFromLock()" Link "NameFromLock()"}, @{"DupLockFromFH()" Link "DupLockFromFH()"}
@EndNode
@Node "LockDosList()" "dos.library/LockDosList"
@{b}@{u}LockDosList@{uu}@{ub} -- Locks the specified Dos Lists for use.(V36)
  Locks the dos device list in preparation to walk the list.
  If the list is 'busy' then this routine will not return until it is 
  available.This routine "nests": you can call it multiple times, and
  then must unlock it the same number of times.The dlist
  returned is @{b}NOT@{ub} a valid entry: it is a special value.Note that
  for 1.3 compatibility, it also does a @{"Forbid()" Link "exec.guide/Forbid()"} - this will probably
  be removed at some future time.The 1.3 @{"Forbid()" Link "exec.guide/Forbid()"} locking of this
  list had some race conditions.The pointer returned by this is @{b}NOT@{ub}
  an actual @{"DosList" Link "include:dos/dosextens.h/Main" 369} pointer - you should use on of the other DosEntry
  calls to get actual pointers to @{"DosList" Link "include:dos/dosextens.h/Main" 369} structures (such as
  @{"NextDosEntry()" Link "NextDosEntry()"}), passing the value returned by LockDosList()
  as the dlist value.
  @{i}Note for handler writers@{ui}: you should never call this function with
  LDF_WRITE, since it can deadlock you (if someone has it read-locked
  and they're trying to send you a packet).Use @{"AttemptLockDosList()" Link "AttemptLockDosList()"}
  instead, and effectively busy-wait with delays for the list to be
  available.The other option is that you can spawn a process to
  add the entry safely.
  As an example, here's how you can search for all volumes of a specific
  name and do something with them:
  @{b}@{u}2.0 way@{uu}@{ub}:
    @{i}dl@{ui} = LockDosList(LDF_VOLUMES|LDF_READ);
    @{FG shine}while@{FG text} (@{i}dl@{ui} = FindDosEntry(@{i}dl@{ui},@{i}name@{ui},LDF_VOLUMES))
    {
      Add to list of volumes to process or break out of the while loop.
      (You could try using it here, but I advise against it for compatability
      reasons if you are planning on continuing to examine the list.)
    }
    process list of volumes saved above, or current entry if
    you're only interested in the first one of that name.
    UnLockDosList(LDF_VOLUMES|LDF_READ);
      \* must not use @{i}dl@{ui} after this! *\
  @{b}@{u}1.3/2.0 way@{uu}@{ub}:
    @{FG shine}if@{FG text} (@{i}version@{ui} >= 36)
      @{i}dl@{ui} = LockDosList(LDF_VOLUMES|LDF_READ);
    @{FG shine}else@{FG text} {
      Forbid();
      /* tricky! note @{i}dol_Next@{ui} is at offset 0! */
      @{i}dl@{ui} = &(...->@{i}di_DeviceList@{ui});
    }
    @{FG shine}while@{FG text} (@{i}version@{ui} >= 36 ? @{i}dl@{ui} = FindDosEntry(@{i}dl@{ui},@{i}name@{ui},LDF_VOLUMES) :
      @{i}dl@{ui} = yourfindentry(@{i}dl@{ui},@{i}name@{ui},DLT_VOLUME))
    {
      Add to list of volumes to process, or break out of the while loop.
      Do @{b}NOT@{ub} lock foo1/foo2 here if you will continue to examine the list -
      it breaks the forbid and the list may change on you.
    }
    process list of volumes saved above, or current entry if
    you're only interested in the first one of that name.
    @{FG shine}if@{FG text} (@{i}version@{ui} >= 36)
      UnLockDosList(LDF_VOLUMES|LDF_READ);
    @{FG shine}else@{FG text}
      Permit();
    \* must not use @{i}dl@{ui} after this! *\
    ...
    @{FG shine}struct@{FG text} @{"DosList" Link "include:dos/dosextens.h/Main" 369} *yourfindentry (@{FG shine}struct@{FG text} DosList *@{i}dl@{ui}, @{i}STRPTRname@{ui}, @{i}type@{ui})
    {
      \* tricky - depends on @{i}dol_Next@{ui} being at offset 0,
        and the initial ptr being a ptr to @{i}di_DeviceList@{ui}! *\
      @{FG shine}while@{FG text} (@{i}dl@{ui} = @{i}dl@{ui}->@{i}dol_Next@{ui})
      {
        @{FG shine}if@{FG text} (@{i}dl@{ui}->@{i}dol_Type@{ui} == @{i}type@{ui} && stricmp(@{i}name@{ui},BADDR(@{i}dl@{ui}->@{i}dol_Name@{ui})+1) == 0)
        {
          @{FG shine}break@{FG text};
        }
      }
      @{FG shine}return@{FG text} @{i}dl@{ui};
    }
SYNOPSIS  @{FG shine}struct@{FG text} @{"DosList" Link "include:dos/dosextens.h/Main" 369} *LockDosList(ULONG)
  @{i}@{b}dlist@{ub}@{ui} = LockDosList(@{i}flags@{ui})
   D0                  D1
  @{i}flags@{ui} - Flags stating which types of nodes you want to lock.
  @{i}@{b}dlist@{ub}@{ui} - Pointer to the head of the list.@{b}NOT@{ub} a valid node!
SEE ALSO
  @{"AttemptLockDosList()" Link "AttemptLockDosList()"}, @{"UnLockDosList()" Link "UnLockDosList()"}, @{"Forbid()" Link "exec.guide/Forbid()"}, @{"NextDosEntry()" Link "NextDosEntry()"}
@EndNode
@Node "LockRecord()" "dos.library/LockRecord"
@{b}@{u}LockRecord@{uu}@{ub} -- Locks a portion of a file.(V36)
  This locks a portion of a file for exclusive access.Timeout is how
  long to wait in ticks (1/50 sec) for the record to be available.
  @{b}@{u}Valid modes are@{uu}@{ub}:
    REC_EXCLUSIVE
    REC_EXCLUSIVE_IMMED
    REC_SHARED
    REC_SHARED_IMMED
  For the IMMED modes, the timeout is ignored.
  Record locks are tied to the filehandle used to create them.The
  same filehandle can get any number of exclusive locks on the same
  record, for example.These are cooperative locks, they only
  affect other people calling LockRecord().
SYNOPSIS  BOOL LockRecord(BPTR,ULONG,ULONG,ULONG,ULONG)
  @{i}@{b}success@{ub}@{ui} = LockRecord(@{i}fh@{ui},@{i}offset@{ui},@{i}length@{ui},@{i}mode@{ui},@{i}timeout@{ui})
   D0                   D1 D2      D3    D4    D5
  @{i}fh@{ui} - File handle for which to lock the record
  @{i}offset@{ui} - Record start position
  @{i}length@{ui} - Length of record in bytes
  @{i}mode@{ui} - Type of lock requester
  @{i}timeout@{ui} - Timeout interval in ticks.0 is legal.
  @{i}@{b}success@{ub}@{ui} - Success or failure
BUGS
  In 2.0 through 2.02 (V36), LockRecord() only worked in the ramdisk.
  Attempting to lock records on the disk filesystem causes a crash.
  This was fixed for V37.
SEE ALSO
  @{"LockRecords()" Link "LockRecords()"}, @{"UnLockRecord()" Link "UnLockRecord()"}, @{"UnLockRecords()" Link "UnLockRecords()"}
@EndNode
@Node "LockRecords()" "dos.library/LockRecords"
@{b}@{u}LockRecords@{uu}@{ub} -- Lock a series of records.(V36)
  This locks several records within a file for exclusive access.
  Timeout is how long to wait in ticks for the records to be available.
  The wait is applied to each attempt to lock each record in the list.
  It is recommended that you always lock a set of records in the same
  order to reduce possibilities of deadlock.
  The array of @{"RecordLock" Link "include:dos/record.h/Main" 28} structures is terminated by an entry with
  rec_FH of NULL.
SYNOPSIS  BOOL LockRecords(@{FG shine}struct@{FG text} @{"RecordLock" Link "include:dos/record.h/Main" 28} *,ULONG)
  @{i}@{b}success@{ub}@{ui} = LockRecords(@{i}record_array@{ui},@{i}timeout@{ui})
   D0                    D1           D2
  @{i}record_array@{ui} - @{"List" Link "include:exec/lists.h/Main" 20} of records to be locked
  @{i}timeout@{ui} - Timeout interval.0 is legal
  @{i}@{b}success@{ub}@{ui} - Success or failure
BUGS
  See @{"LockRecord()" Link "LockRecord()"}
SEE ALSO
  @{"LockRecord()" Link "LockRecord()"}, @{"UnLockRecord()" Link "UnLockRecord()"}, @{"UnLockRecords()" Link "UnLockRecords()"}
@EndNode
@Node "MakeDosEntry()" "dos.library/MakeDosEntry"
@{b}@{u}MakeDosEntry@{uu}@{ub} -- Creates a @{"DosList" Link "include:dos/dosextens.h/Main" 369} structure.(V36)
  Create a @{"DosList" Link "include:dos/dosextens.h/Main" 369} structure, including allocating a name and correctly
  null-terminating the BSTR.It also sets the dol_Type field, and sets
  all other fields to 0.This routine should be eliminated and replaced
  by a value passed to AllocDosObject()!
SYNOPSIS  @{FG shine}struct@{FG text} @{"DosList" Link "include:dos/dosextens.h/Main" 369} *MakeDosEntry(STRPTR, @{FG shine}long@{FG text})
  @{i}@{b}newdlist@{ub}@{ui} = MakeDosEntry(@{i}name@{ui}, @{i}type@{ui})
   D0                      D1    D2
  @{i}name@{ui} - name for the device/volume/assign node.
  @{i}type@{ui} - type of node.
  @{i}@{b}newdlist@{ub}@{ui} - The new device entry or NULL.
SEE ALSO
  @{"AddDosEntry()" Link "AddDosEntry()"}, @{"RemDosEntry()" Link "RemDosEntry()"}, @{"FindDosEntry()" Link "FindDosEntry()"}, @{"LockDosList()" Link "LockDosList()"},
  @{"NextDosEntry()" Link "NextDosEntry()"}, @{"FreeDosEntry()" Link "FreeDosEntry()"}
@EndNode
@Node "MakeLink()" "dos.library/MakeLink"
@{b}@{u}MakeLink@{uu}@{ub} -- Creates a filesystem link.(V36)
  Create a filesystem link from 'name' to dest.For "soft-links",
  dest is a pointer to a null-terminated path string.For "hard-links",
  dest is a lock (BPTR).'soft' is FALSE for hard-links, non-zero otherwise.
  Soft-links are resolved at access time by a combination of the
  filesystem (by returning ERROR_IS_SOFT_LINK to dos), and by
  Dos (using @{"ReadLink()" Link "ReadLink()"} to resolve any links that are hit).
  Hard-links are resolved by the filesystem in question.A series
  of hard-links to a file are all equivalent to the file itself.
  If one of the links (or the original entry for the file) is 
  deleted, the data remains until there are no links left.
SYNOPSIS  BOOL MakeLink( STRPTR, @{FG shine}long@{FG text}, @{FG shine}long@{FG text} )
  @{i}@{b}success@{ub}@{ui} = MakeLink( @{i}name@{ui}, @{i}dest@{ui}, @{i}soft@{ui} )
   D0                  D1    D2     D3
  @{i}name@{ui} - Name of the link to create
  @{i}dest@{ui} - CPTR to path string, or BPTR lock
  @{i}soft@{ui} - FALSE for hard-links, non-zero for soft-links
  @{i}@{b}Success@{ub}@{ui} - boolean
BUGS
  In V36, soft-links didn't work in the ROM filesystem.This was fixed for V37.
SEE ALSO
  @{"ReadLink()" Link "ReadLink()"}, @{"Open()" Link "Open()"}, @{"Lock()" Link "Lock()"}
@EndNode
@Node "MatchEnd()" "dos.library/MatchEnd"
@{b}@{u}MatchEnd@{uu}@{ub} -- Free storage allocated for @{"MatchFirst()/MatchNext()" Link "MatchNext()"}.(V36)
  Return all storage associated with a given search.
SYNOPSIS  @{FG shine}void@{FG text} MatchEnd(@{FG shine}struct@{FG text} @{"AnchorPath" Link "include:dos/dosasl.h/Main" 52} *)
  MatchEnd(@{i}AnchorPath@{ui})
            D1
  @{i}AnchorPath@{ui} - Anchor used for @{"MatchFirst()/MatchNext()" Link "MatchNext()"}
    @{b}MUST@{ub} be longword aligned!
SEE ALSO
  @{"MatchFirst()" Link "MatchFirst()"}, @{"ParsePattern()" Link "ParsePattern()"}, @{"Examine()" Link "Examine()"}, @{"CurrentDir()" Link "CurrentDir()"}, @{"Examine()" Link "Examine()"},
  @{"MatchNext()" Link "MatchNext()"}, @{"ExNext()" Link "ExNext()"}, @{"<dos/dosasl.h>" Link "include:dos/dosasl.h/Main" 0}
@EndNode
@Node "MatchFirst()" "dos.library/MatchFirst"
@{b}@{u}MatchFirst@{uu}@{ub} -- Finds file that matches pattern.(V36)
  Locates the first file or directory that matches a given pattern.
  MatchFirst() is passed your pattern (you do not pass it through
  @{"ParsePattern()" Link "ParsePattern()"} - MatchFirst() does that for you), and the control
  structure.MatchFirst() normally initializes your @{"AnchorPath" Link "include:dos/dosasl.h/Main" 52}
  structure for you, and returns the first file that matched your
  pattern, or an error.Note that @{"MatchFirst()/MatchNext()" Link "MatchNext()"} are unusual
  for Dos in that they return 0 for success, or the error code (see @{"<dos/dos.h>" Link "include:dos/dos.h/Main" 0}),
  instead of the application getting the error code from @{"IoErr()" Link "IoErr()"}.
  When looking at the result of @{"MatchFirst()/MatchNext()" Link "MatchNext()"}, the ap_Info
  field of your @{"AnchorPath" Link "include:dos/dosasl.h/Main" 52} has the results of an @{"Examine()" Link "Examine()"} of the object.
  You normally get the name of the object from fib_FileName, and the
  directory it's in from ap_Current->an_Lock.To access this object,
  normally you would temporarily @{"CurrentDir()" Link "CurrentDir()"} to the lock, do an action
  to the file/dir, and then @{"CurrentDir()" Link "CurrentDir()"} back to your original directory.
  This makes certain you affect the right object even when two volumes
  of the same name are in the system.You can use ap_Buf (with ap_Strlen)
  to get a name to report to the user.
  To initialize the @{"AnchorPath" Link "include:dos/dosasl.h/Main" 52} structure (particularily when reusing
  it), set ap_BreakBits to the signal bits (CDEF) that you want to take
  a break on, or NULL, if you don't want to convenience the user.
  ap_Flags should be set to any flags you need or all 0's otherwise.
  ap_FoundBreak should be cleared if you'll be using breaks.
  If you want to have the FULL PATH  of the files you found,
  allocate a buffer at the END of this structure, and put the size of
  it into ap_Strlen.If you don't want the full path name, make sure
  you set ap_Strlen to zero.In this case, the name of the file, and
  stats are available in the ap_Info, as per usual.
  Then call MatchFirst() and then afterwards, @{"MatchNext()" Link "MatchNext()"} with this
  structure.You should check the return value each time (see below)
  and take the appropriate action, ultimately calling @{"MatchEnd()" Link "MatchEnd()"} when
  there are no more files or you are done.You can tell when you are done
  by checking for the normal AmigaDOS return code ERROR_NO_MORE_ENTRIES.
  @{i}Note@{ui}: patterns with trailing slashes may cause @{"MatchFirst()/MatchNext()" Link "MatchNext()"}
  to return with an ap_Current->an_Lock on the object, and a filename
  of the empty string ("").
  See @{"ParsePattern()" Link "ParsePattern()"} for more information on the patterns.
SYNOPSIS  @{FG shine}long@{FG text} MatchFirst(STRPTR, @{FG shine}struct@{FG text} @{"AnchorPath" Link "include:dos/dosasl.h/Main" 52} *)
  @{i}@{b}error@{ub}@{ui} = MatchFirst(@{i}pat@{ui}, @{i}AnchorPath@{ui})
   D0                 D1   D2
  @{i}pat@{ui} - Pattern to search for
  @{i}AnchorPath@{ui} - Place holder for search.@{b}MUST@{ub} be longword aligned!
  @{i}@{b}error@{ub}@{ui} - 0 for success or error code.(Opposite of most Dos calls!)
BUGS
  In V36, there were a number of bugs with @{"MatchFirst()/MatchNext()" Link "MatchNext()"}.
  One was that if you entered a directory with a name like "df0:l"
  using DODIR, it would re-lock the full string "df0:l", which can
  cause problems if the disk has changed.It also had problems
  with patterns such as #?/abc/def - the ap_Current->an_Lock would
  not be on the directory def is found in.ap_Buf would be correct,
  however.It had similar problems with patterns with trailing
  slashes.These have been fixed for V37 and later.
  A bug that has not been fixed for V37 concerns a pattern of a
  single directory name (such as "l").If you enter such a directory
  via DODIR, it re-locks l relative to the current directory.Thus
  you must not change the current directory before calling @{"MatchNext()" Link "MatchNext()"}
  with DODIR in that situation.If you aren't using DODIR to enter
  directories you can ignore this.This may be fixed in some upcoming release.
SEE ALSO
  @{"MatchNext()" Link "MatchNext()"}, @{"ParsePattern()" Link "ParsePattern()"}, @{"Examine()" Link "Examine()"}, @{"CurrentDir()" Link "CurrentDir()"}, @{"Examine()" Link "Examine()"},
  @{"MatchEnd()" Link "MatchEnd()"}, @{"ExNext()" Link "ExNext()"}, @{"<dos/dosasl.h>" Link "include:dos/dosasl.h/Main" 0}
@EndNode
@Node "MatchNext()" "dos.library/MatchNext"
@{b}@{u}MatchNext@{uu}@{ub} - Finds the next file or directory that matches pattern.(V36)
  Locates the next file or directory that matches a given pattern.
  See @{"<dos/dosasl.h>" Link "include:dos/dosasl.h/Main" 0} for more information.Various bits in the flags
  allow the application to control the operation of MatchNext().
  See @{"MatchFirst()" Link "MatchFirst()"} for other notes.
SYNOPSIS  @{FG shine}long@{FG text} MatchNext(@{FG shine}struct@{FG text} @{"AnchorPath" Link "include:dos/dosasl.h/Main" 52} *)
  @{i}@{b}error@{ub}@{ui} = MatchNext(@{i}AnchorPath@{ui})
   D0                D1
  @{i}AnchorPath@{ui} - Place holder for search.@{b}MUST@{ub} be longword aligned!
  @{i}@{b}error@{ub}@{ui} - 0 for success or error code.(Opposite of most Dos calls)
BUGS
  See @{"MatchFirst()" Link "MatchFirst()"}.
SEE ALSO
  @{"MatchFirst()" Link "MatchFirst()"}, @{"ParsePattern()" Link "ParsePattern()"}, @{"Examine()" Link "Examine()"}, @{"CurrentDir()" Link "CurrentDir()"}, @{"Examine()" Link "Examine()"},
  @{"MatchEnd()" Link "MatchEnd()"}, @{"ExNext()" Link "ExNext()"}, @{"<dos/dosasl.h>" Link "include:dos/dosasl.h/Main" 0}
@EndNode
@Node "MatchPattern()" "dos.library/MatchPattern"
@{b}@{u}MatchPattern@{uu}@{ub} -- Checks for a pattern match with a string.(V36)
  Checks for a pattern match with a string.The pattern must be a
  tokenized string output by @{"ParsePattern()" Link "ParsePattern()"}.This routine is
  case-sensitive.
  @{i}NOTE@{ui}:this routine is highly recursive.You must have at least
  1500 free bytes of stack to call this (it will cut off it's
  recursion before going any deeper than that and return failure).
  That's _currently_ enough for about 100 levels deep of #, (, ~, etc.
SYNOPSIS  BOOL MatchPattern(STRPTR, STRPTR)
  @{i}@{b}match@{ub}@{ui} = MatchPattern(@{i}pat@{ui}, @{i}str@{ui})
   D0                   D1   D2
  @{i}pat@{ui} - Special pattern string to match as returned by @{"ParsePattern()" Link "ParsePattern()"}
  @{i}str@{ui} - String to match against given pattern
  @{i}@{b}match@{ub}@{ui} - success or failure of pattern match.
    On failure, @{"IoErr()" Link "IoErr()"} will return 0 or ERROR_TOO_MANY_LEVELS
    (starting with V37 - before that there was no stack checking).
SEE ALSO
  @{"ParsePattern()" Link "ParsePattern()"}, @{"MatchPatternNoCase()" Link "MatchPatternNoCase()"}, @{"MatchFirst()" Link "MatchFirst()"}, @{"MatchNext()" Link "MatchNext()"}
@EndNode
@Node "MatchPatternNoCase()" "dos.library/MatchPatternNoCase"
@{b}@{u}MatchPatternNoCase@{uu}@{ub} --  Checks for a pattern match with a string.(V37)
  Checks for a pattern match with a string.The pattern must be a
  tokenized string output by @{"ParsePatternNoCase()" Link "ParsePatternNoCase()"}.This routine is
  case-insensitive.
  @{i}NOTE@{ui}:this routine is highly recursive.You must have at least
  1500 free bytes of stack to call this (it will cut off it's
  recursion before going any deeper than that and return failure).
  That's _currently_ enough for about 100 levels deep of #, (, ~, etc.
SYNOPSIS  BOOL MatchPatternNoCase(STRPTR, STRPTR)
  @{i}@{b}match@{ub}@{ui} = MatchPatternNoCase(@{i}pat@{ui}, @{i}str@{ui})
   D0                         D1   D2
  @{i}pat@{ui} - Special pattern string to match as returned by @{"ParsePatternNoCase()" Link "ParsePatternNoCase()"}
  @{i}str@{ui} - String to match against given pattern
  @{i}@{b}match@{ub}@{ui} - success or failure of pattern match.
    On failure, @{"IoErr()" Link "IoErr()"} will return 0 or ERROR_TOO_MANY_LEVELS
    (starting with V37 - before that there was no stack checking).
BUGS
  See @{"ParsePatternNoCase()" Link "ParsePatternNoCase()"}.
SEE ALSO
  @{"ParsePatternNoCase()" Link "ParsePatternNoCase()"}, @{"MatchPattern()" Link "MatchPattern()"}, @{"MatchFirst()" Link "MatchFirst()"}, @{"MatchNext()" Link "MatchNext()"}
@EndNode
@Node "MaxCli()" "dos.library/MaxCli"
@{b}@{u}MaxCli@{uu}@{ub} -- returns the highest CLI process number possibly in use.(V36)
  Returns the highest CLI number that may be in use.CLI numbers are
  reused, and are usually as small as possible.To find all CLIs, scan
  using @{"FindCliProc()" Link "FindCliProc()"} from 1 to MaxCLI().The number returned by
  MaxCli() may change as processes are created and destroyed.
SYNOPSIS  @{FG shine}long@{FG text} MaxCli(@{FG shine}void@{FG text})
  @{i}@{b}number@{ub}@{ui} = MaxCli()
   D0
  @{i}@{b}number@{ub}@{ui} - The highest CLI number that _may_ be in use.
SEE ALSO
  @{"FindCliProc()" Link "FindCliProc()"}, @{"Cli()" Link "Cli()"}
@EndNode
@Node "NameFromFH()" "dos.library/NameFromFH"
@{b}@{u}NameFromFH@{uu}@{ub} -- Get the name of an open filehandle.(V36)
  Returns a fully qualified path for the filehandle.This routine is
  guaranteed not to write more than len characters into the buffer.The
  name will be null-terminated.See @{"NameFromLock()" Link "NameFromLock()"} for more information.
  Note: Older filesystems that don't support @{"ExamineFH()" Link "ExamineFH()"} will cause
  NameFromFH() to fail with ERROR_ACTION_NOT_SUPPORTED.
SYNOPSIS  BOOL NameFromFH(BPTR, STRPTR, @{FG shine}long@{FG text})
  @{i}@{b}success@{ub}@{ui} = NameFromFH(@{i}fh@{ui}, @{i}buffer@{ui}, @{i}len@{ui})
   D0                   D1  D2       D3
  @{i}fh@{ui} - Lock of object to be examined.
  @{i}buffer@{ui} - Buffer to store name.
  @{i}len@{ui} - Length of buffer.
  @{i}@{b}success@{ub}@{ui} - Success/failure indicator.
SEE ALSO
  @{"NameFromLock()" Link "NameFromLock()"}, @{"ExamineFH()" Link "ExamineFH()"}
@EndNode
@Node "NameFromLock()" "dos.library/NameFromLock"
@{b}@{u}NameFromLock@{uu}@{ub} -- Returns the name of a locked object.(V36)
  Returns a fully qualified path for the lock.This routine is
  guaranteed not to write more than len characters into the buffer.
  The name will be null-terminated.
  @{i}NOTE@{ui}:if the volume is not mounted, the system will request it
  (unless of course you set pr_WindowPtr to -1).If the volume is
  not mounted or inserted, it will return an error.If the lock
  passed in is NULL, "SYS:" will be returned.If the buffer is too short,
  an error will be returned, and @{"IoErr()" Link "IoErr()"} will return ERROR_LINE_TOO_LONG.
SYNOPSIS  BOOL NameFromLock(BPTR, STRPTR, @{FG shine}long@{FG text})
  @{i}@{b}success@{ub}@{ui} = NameFromLock(@{i}lock@{ui}, @{i}buffer@{ui}, @{i}len@{ui})
   D0                     D1    D2       D3
  @{i}lock@{ui} - Lock of object to be examined.
  @{i}buffer@{ui} - Buffer to store name.
  @{i}len@{ui} - Length of buffer.
  @{i}@{b}success@{ub}@{ui} - Success/failure indicator.
BUGS
  Should return the name of the boot volume instead of SYS: for a NULL lock.
SEE ALSO
  @{"NameFromFH()" Link "NameFromFH()"}, @{"Lock()" Link "Lock()"}
@EndNode
@Node "NewLoadSeg()" "dos.library/NewLoadSeg"
@{b}@{u}NewLoadSeg@{uu}@{ub} -- Improved version of @{"LoadSeg" Link "LoadSeg()"} for stacksizes.(V36)
  Does a @{"LoadSeg" Link "LoadSeg()"} on a file, and takes additional actions based on the
  tags supplied.
  Clears unused portions of Code and Data hunks (as well as BSS hunks).
  (This also applies to @{"InternalLoadSeg()" Link "InternalLoadSeg()"} and @{"LoadSeg()" Link "LoadSeg()"}).
  @{i}NOTE to overlay users@{ui}:NewLoadSeg() does @{b}NOT@{ub} return seglist in
  both D0 and D1, as @{"LoadSeg" Link "LoadSeg()"} does.The current ovs.asm uses @{"LoadSeg()" Link "LoadSeg()"},
  and assumes returns are in D1.We will support this for @{"LoadSeg()" Link "LoadSeg()"} @{b}ONLY@{ub}.
SYNOPSIS
  BPTR NewLoadSeg(STRPTR, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *)
  BPTR NewLoadSegTagList(STRPTR, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *)
  BPTR NewLoadSegTags(STRPTR, ...)
  @{i}@{b}seglist@{ub}@{ui} = NewLoadSeg(@{i}file@{ui}, @{i}tags@{ui})
   D0                   D1    D2
  @{i}@{b}seglist@{ub}@{ui} = NewLoadSegTagList(@{i}file@{ui}, @{i}tags@{ui})
   D0                          D1    D2
  @{i}@{b}seglist@{ub}@{ui} = NewLoadSegTags(@{i}file@{ui}, ...)
  @{i}file@{ui} - Filename of file to load
  @{i}tags@{ui} - pointer to tagitem array
  @{i}@{b}seglist@{ub}@{ui} - Seglist loaded, or NULL
BUGS
  No tags are currently defined.
SEE ALSO
  @{"LoadSeg()" Link "LoadSeg()"}, @{"UnLoadSeg()" Link "UnLoadSeg()"}, @{"InternalLoadSeg()" Link "InternalLoadSeg()"}, @{"InternalUnLoadSeg()" Link "InternalUnLoadSeg()"}
@EndNode
@Node "NextDosEntry()" "dos.library/NextDosEntry"
@{b}@{u}NextDosEntry@{uu}@{ub} -- Get the next Dos @{"List" Link "include:exec/lists.h/Main" 20} entry.(V36)
  Find the next Dos @{"List" Link "include:exec/lists.h/Main" 20} entry of the right type.You @{b}MUST@{ub} have locked
  the types you're looking for.Returns NULL if there are no more of
  that type in the list.
SYNOPSIS  @{FG shine}struct@{FG text} @{"DosList" Link "include:dos/dosextens.h/Main" 369} *NextDosEntry(@{FG shine}struct@{FG text} @{"DosList" Link "include:dos/dosextens.h/Main" 369} *,ULONG)
  @{i}@{b}newdlist@{ub}@{ui} = NextDosEntry(@{i}dlist@{ui},@{i}flags@{ui})
   D0                      D1    D2
  @{i}dlist@{ui} - The current device entry.
  @{i}flags@{ui} - What type of entries to look for.
  @{i}@{b}newdlist@{ub}@{ui} - The next device entry of the right type or NULL.
SEE ALSO
  @{"AddDosEntry()" Link "AddDosEntry()"}, @{"RemDosEntry()" Link "RemDosEntry()"}, @{"FindDosEntry()" Link "FindDosEntry()"}, @{"LockDosList()" Link "LockDosList()"},
  @{"MakeDosEntry()" Link "MakeDosEntry()"}, @{"FreeDosEntry()" Link "FreeDosEntry()"}
@EndNode
@Node "Open()" "dos.library/Open"
@{b}@{u}Open@{uu}@{ub} -- Open a file for input or output.
  The named file is opened and a file handle returned.If the
  accessMode is MODE_OLDFILE, an existing file is opened for reading
  or writing.If the value is MODE_NEWFILE, a new file is created for
  writing.MODE_READWRITE opens a file with an shared lock, but
  creates it if it didn't exist.Open types are documented in the
  @{"<dos/dos.h>" Link "include:dos/dos.h/Main" 0} or @{"<libraries/dos.h>" Link "include:libraries/dos.h/Main" 0} include file.
  The 'name' can be a filename (optionally prefaced by a device name),
  a simple device such as NIL:, a window specification such as CON: or RAW:
  followed by window parameters, or "*", representing the current window.
  Note that as of V36, "*" is obsolete, and CONSOLE: should be used instead.
  If the file cannot be opened for any reason, the value returned
  will be zero, and a secondary error code will be available by
  calling the routine @{"IoErr()" Link "IoErr()"}.
SYNOPSIS  BPTR Open(STRPTR, @{FG shine}long@{FG text})
  @{i}@{b}file@{ub}@{ui} = Open( @{i}name@{ui}, @{i}accessMode@{ui} )
   D0           D1    D2
  @{i}name@{ui} - pointer to a null-terminated string
  @{i}accessMode@{ui} - integer
  @{i}@{b}file@{ub}@{ui} - BCPL pointer to a file handle
SEE ALSO
  @{"Close()" Link "Close()"}, @{"ChangeMode()" Link "ChangeMode()"}, @{"NameFromFH()" Link "NameFromFH()"}, @{"ParentOfFH()" Link "ParentOfFH()"}, @{"ExamineFH()" Link "ExamineFH()"}
@EndNode
@Node "OpenFromLock()" "dos.library/OpenFromLock"
@{b}@{u}OpenFromLock@{uu}@{ub} -- Opens a file you have a lock on.(V36)
  Given a lock, this routine performs an open on that lock.If the open
  succeeds, the lock is (effectively) relinquished, and should not be
  UnLock()ed or used.If the open fails, the lock is still usable.
  The lock associated with the file internally is of the same access
  mode as the lock you gave up - shared is similar to MODE_OLDFILE,
  exclusive is similar to MODE_NEWFILE.
SYNOPSIS  BPTR OpenFromLock(BPTR)
  @{i}@{b}fh@{ub}@{ui} = OpenFromLock(@{i}lock@{ui})
   D0                D1
  @{i}lock@{ui} - Lock on object to be opened.
  @{i}@{b}fh@{ub}@{ui} - Newly opened file handle or NULL for failure
BUGS
  In the original V36 autodocs, this was shown (incorrectly) as
  taking a Mode parameter as well.The prototypes and pragmas were also wrong.
SEE ALSO
  @{"Open()" Link "Open()"}, @{"Close()" Link "Close()"}, @{"Lock()" Link "Lock()"}, @{"UnLock()" Link "UnLock()"}
@EndNode
@Node "Output()" "dos.library/Output"
@{b}@{u}Output@{uu}@{ub} -- Identify the programs' initial output file handle.
  Output() is used to identify the initial output stream allocated
  when the program was initiated.Never close the filehandle returned by Output().
SYNOPSIS  BPTR Output(@{FG shine}void@{FG text})
  @{i}@{b}file@{ub}@{ui} = Output()
   D0
  @{i}@{b}file@{ub}@{ui} - BCPL pointer to a file handle
SEE ALSO
  @{"Input()" Link "Input()"}
@EndNode
@Node "ParentDir()" "dos.library/ParentDir"
@{b}@{u}ParentDir@{uu}@{ub} -- Obtain the parent of a directory or file.
  The argument 'lock' is associated with a given file or directory.
  ParentDir() returns 'newlock' which is associated the parent
  directory of 'lock'.
  Taking the ParentDir() of the root of the current filing system
  returns a NULL (0) lock.Note this 0 lock represents the root of
  file system that you booted from (which is, in effect, the parent
  of all other file system roots.)
SYNOPSIS  BPTR ParentDir(BPTR)
  @{i}@{b}newlock@{ub}@{ui} = ParentDir( @{i}lock@{ui} )
   D0                   D1
  @{i}lock@{ui} - BCPL pointer to a lock
  @{i}@{b}newlock@{ub}@{ui} - BCPL pointer to a lock
SEE ALSO
  @{"Lock()" Link "Lock()"}, @{"DupLock()" Link "DupLock()"}, @{"UnLock()" Link "UnLock()"}, @{"ParentOfFH()" Link "ParentOfFH()"}, @{"DupLockFromFH()" Link "DupLockFromFH()"}
@EndNode
@Node "ParentOfFH()" "dos.library/ParentOfFH"
@{b}@{u}ParentOfFH@{uu}@{ub} -- returns a lock on the parent directory of a file.(V36)
  Returns a shared lock on the parent directory of the filehandle.
SYNOPSIS  BPTR ParentOfFH(BPTR)
  @{i}@{b}lock@{ub}@{ui} = ParentOfFH(@{i}fh@{ui})
   D0                D1
  @{i}fh@{ui} - Filehandle you want the parent of.
  @{i}@{b}lock@{ub}@{ui} - Lock on parent directory of the filehandle or NULL for failure.
SEE ALSO
  Parent(), @{"Lock()" Link "Lock()"}, @{"UnLock()" Link "UnLock()"} @{"DupLockFromFH()" Link "DupLockFromFH()"}
@EndNode
@Node "ParsePattern()" "dos.library/ParsePattern"
@{b}@{u}ParsePattern@{uu}@{ub} -- Create a tokenized string for @{"MatchPattern()" Link "MatchPattern()"}.(V36)
  Tokenizes a pattern, for use by @{"MatchPattern()" Link "MatchPattern()"}.Also indicates if
  there are any wildcards in the pattern (i.e.whether it might match
  more than one item).Note that Dest must be at least 2 times as
  large as Source plus bytes to be (almost) 100% certain of no
  buffer overflow.This is because each input character can currently
  expand to 2 tokens (with one exception that can expand to 3, but
  only once per string).Note: this implementation may change in the future,
  so you should handle error returns in all cases, but the size above
  should still be a reasonable upper bound for a buffer allocation.
  The patterns are fairly extensive, and approximate some of the ability of
  Unix/grep "regular expression" patterns.
  @{b}@{u}Here are the available tokens@{uu}@{ub}:
    @{b}?@{ub} Matches a single character.
    @{b}#@{ub} Matches the following expression 0 or more times.
    @{b}(ab|cd)@{ub} Matches any one of the items seperated by '|'.
    @{b}~@{ub} Negates the following expression.It matches all strings that do not match
      the expression (aka ~(foo) matches all strings that are not exactly "foo").
    @{b}[abc]@{ub} Character class: matches any of the characters in the class.
    @{b}[~bc]@{ub} Character class: matches any of the characters not in the class.
    @{b}a-z@{ub} Character range (only within character classes).
    @{b}%@{ub} Matches 0 characters always (useful in "(foo|bar|%)").
    @{b}@{ub}* Synonym for "#?", not available by default in 2.0.
      Available as an option that can be turned on.
  "@{i}Expression@{ui}" in the above table means either a single character (@{i}ex@{ui}: "#?"),
  or an alternation (@{i}ex@{ui}: "#(ab|cd|ef)"), or a character class (@{i}ex@{ui}: "#[a-zA-Z]").
SYNOPSIS  @{FG shine}long@{FG text} ParsePattern(STRPTR, STRPTR, @{FG shine}long@{FG text})
  @{i}@{b}IsWild@{ub}@{ui} = ParsePattern(@{i}Source@{ui}, @{i}Dest@{ui}, @{i}DestLength@{ui})
   d0                    D1      D2     D3
  @{i}source@{ui} - unparsed wildcard string to search for.
  @{i}dest@{ui} - output string, gets tokenized version of input.
  @{i}DestLength@{ui} - length available in destination
    (should be at least as twice as large as source + 2 bytes).
  @{i}@{b}IsWild@{ub}@{ui} - 1 means there were wildcards in the pattern,
     0 means there were no wildcards in the pattern,
    -1 means there was a buffer overflow or other error
BUGS
  In V37 this call didn't always set @{"IoErr()" Link "IoErr()"} to something useful on an
  error.Fixed in V39.
SEE ALSO
  @{"ParsePatternNoCase()" Link "ParsePatternNoCase()"}, @{"MatchPattern()" Link "MatchPattern()"}, @{"MatchFirst()" Link "MatchFirst()"}, @{"MatchNext()" Link "MatchNext()"}
@EndNode
@Node "ParsePatternNoCase()" "dos.library/ParsePatternNoCase"
@{b}@{u}ParsePatternNoCase@{uu}@{ub} -- Create a tokenized string for @{"MatchPatternNoCase()" Link "MatchPatternNoCase()"}.(V37)
  Tokenizes a pattern, for use by @{"MatchPatternNoCase()" Link "MatchPatternNoCase()"}.Also indicates
  if there are any wildcards in the pattern (i.e.whether it might match
  more than one item).Note that Dest must be at least 2 times as
  large as Source plus 2 bytes.
  For a description of the wildcards, see @{"ParsePattern()" Link "ParsePattern()"}.
SYNOPSIS  @{FG shine}long@{FG text} ParsePatternNoCase(STRPTR, STRPTR, @{FG shine}long@{FG text})
  @{i}@{b}IsWild@{ub}@{ui} = ParsePatternNoCase(@{i}Source@{ui}, @{i}Dest@{ui}, @{i}DestLength@{ui})
   d0                          D1      D2    D3
  @{i}source@{ui} - unparsed wildcard string to search for.
  @{i}dest@{ui} - output string, gets tokenized version of input.
  @{i}DestLength@{ui} - length available in destination
    (should be at least as twice as large as source + 2 bytes).
  @{i}@{b}IsWild@{ub}@{ui} - 1 means there were wildcards in the pattern,
     0 means there were no wildcards in the pattern,
    -1 means there was a buffer overflow or other error
BUGS
  In V37 this call didn't always set @{"IoErr()" Link "IoErr()"} to something useful on an
  error.Fixed in V39.
  In V37, it didn't properly convert character-classes ([x-y]) to
  upper case.Workaround: convert the input pattern to upper case
  using @{"ToUpper()" Link "utility/ToUpper()"} from utility.library before calling
  ParsePatternNoCase().Fixed in V39 dos.
SEE ALSO
  @{"ParsePattern()" Link "ParsePattern()"}, @{"MatchPatternNoCase()" Link "MatchPatternNoCase()"}, @{"MatchFirst()" Link "MatchFirst()"}, @{"MatchNext()" Link "MatchNext()"},
  @{"utility.library/ToUpper()" Link "utility/ToUpper()"}
@EndNode
@Node "PathPart()" "dos.library/PathPart"
@{b}@{u}PathPart@{uu}@{ub} -- Returns a pointer to the end of the next-to-last component of a path.(V36)
  This function returns a pointer to the character after the next-to-last
  component of a path specification, which will normally be the directory
  name.If there is only one component, it returns a pointer to the
  beginning of the string.The only real difference between this and
  @{"FilePart()" Link "FilePart()"} is the handling of '/'.
SYNOPSIS  STRPTR PathPart( STRPTR )
  @{i}@{b}fileptr@{ub}@{ui} = PathPart( @{i}path@{ui} )
   D0                  D1
  @{i}path@{ui} - pointer to an path string.
    May be relative to the current directory or the current disk.
  @{i}@{b}fileptr@{ub}@{ui} - pointer to the end of the next-to-last component of the path.
EXAMPLE
  PathPart("xxx:yyy/zzz/qqq") would return a pointer to the last '/'.
  PathPart("xxx:yyy") would return a pointer to the first 'y').
SEE ALSO
  @{"FilePart()" Link "FilePart()"}, @{"AddPart()" Link "AddPart()"}
@EndNode
@Node "PrintFault()" "dos.library/PrintFault"
@{b}@{u}PrintFault@{uu}@{ub} -- Returns the text associated with a DOS error code.(V36)
  This routine obtains the error message text for the given error code.
  This is similar to the @{"Fault()" Link "Fault()"} function, except that the output is
  written to the default output channel with buffered output.
  The value returned by @{"IoErr()" Link "IoErr()"} is set to the code passed in.
SYNOPSIS  BOOL PrintFault(@{FG shine}long@{FG text}, STRPTR)
  @{i}@{b}success@{ub}@{ui} = PrintFault(@{i}code@{ui}, @{i}header@{ui})
   D0                   D1    D2
  @{i}code@{ui} - Error code
  @{i}header@{ui} - header to output before error text
  @{i}@{b}success@{ub}@{ui} - Success/failure code.
SEE ALSO
  @{"IoErr()" Link "IoErr()"}, @{"Fault()" Link "Fault()"}, @{"SetIoErr()" Link "SetIoErr()"}, @{"Output()" Link "Output()"}, @{"FPuts()" Link "FPuts()"}
@EndNode
@Node "PutStr()" "dos.library/PutStr"
@{b}@{u}PutStr@{uu}@{ub} -- Writes a string the the default output (buffered).(V36)
  This routine writes an unformatted string to the default output.No
  newline is appended to the string and any error is returned.This
  routine is buffered.
SYNOPSIS  @{FG shine}long@{FG text} PutStr(STRPTR)
  @{i}@{b}error@{ub}@{ui} = PutStr(@{i}str@{ui})
   D0             D1
  @{i}str@{ui} - Null-terminated string to be written to default output
  @{i}@{b}error@{ub}@{ui} - 0 for success, -1 for any error.
    @{i}NOTE@{ui}:this is opposite most Dos function returns!
SEE ALSO
  @{"FPuts()" Link "FPuts()"}, @{"FPutC()" Link "FPutC()"}, @{"FWrite()" Link "FWrite()"}, @{"WriteChars()" Link "WriteChars()"}
@EndNode
@Node "Read()" "dos.library/Read"
@{b}@{u}Read@{uu}@{ub} -- Read bytes of data from a file.
  Data can be copied using a combination of Read() and @{"Write()" Link "Write()"}.
  Read() reads bytes of information from an opened file (represented
  here by the argument 'file') into the buffer given.The argument
  'length' is the length of the buffer given.
  The value returned is the length of the information actually read.
  So, when 'actualLength' is greater than zero, the value of 'actualLength'
  is the the number of characters read.Usually Read will try to fill up
  your buffer before returning.A value of zero means that end-of-file has
  been reached.Errors are indicated by a value of -1.
  @{i}Note@{ui}:this is an unbuffered routine (the request is passed directly
  to the filesystem.)  Buffered I/O is more efficient for small
  reads and writes; see @{"FGetC()" Link "FGetC()"}.
SYNOPSIS  @{FG shine}long@{FG text} Read(BPTR, @{FG shine}void@{FG text} *, @{FG shine}long@{FG text})
  @{i}@{b}actualLength@{ub}@{ui} = Read( @{i}file@{ui}, @{i}buffer@{ui}, @{i}length@{ui} )
   D0                   D1    D2       D3
  @{i}file@{ui} - BCPL pointer to a file handle
  @{i}buffer@{ui} - pointer to buffer
  @{i}length@{ui} - integer
  @{i}@{b}actualLength@{ub}@{ui} - integer
SEE ALSO
  @{"Open()" Link "Open()"}, @{"Close()" Link "Close()"}, @{"Write()" Link "Write()"}, @{"Seek()" Link "Seek()"}, @{"FGetC()" Link "FGetC()"}
@EndNode
@Node "ReadArgs()" "dos.library/ReadArgs"
@{b}@{u}ReadArgs@{uu}@{ub} - Parse the command line input.(V36)
  Parses and argument string according to a template.Normally gets
  the arguments by reading buffered IO from @{"Input()" Link "Input()"}, but also can be
  made to parse a string.@{b}MUST@{ub} be matched by a call to @{"FreeArgs()" Link "FreeArgs()"}.
  ReadArgs() parses the commandline according to a template that is
  passed to it.This specifies the different command-line options and
  their types.A template consists of a list of options.Options are
  named in "full" names where possible (for example, "Quick" instead of
  "Q").Abbreviations can also be specified by using "abbrev=option"
  (for example, "Q=Quick").
  Options in the template are separated by commas.To get the results
  of ReadArgs(), you examine the array of longwords you passed to it
  (one entry per option in the template).This array should be cleared
  (or initialized to your default values) before passing to ReadArgs().
  Exactly what is put in a given entry by ReadArgs() depends on the type
  of option.The default is a string (a sequence of non-whitespace
  characters, or delimited by quotes, which will be stripped by
  ReadArgs()), in which case the entry will be a pointer.
  Options can be followed by modifiers, which specify things such as
  the type of the option.Modifiers are specified by following the
  option with a '/' and a single character modifier.Multiple modifiers
  can be specified by using multiple '/'s.
  @{b}@{u}Valid modifiers are@{uu}@{ub}:
  @{b}/S@{ub} - Switch.This is considered a boolean variable, and will be
    set if the option name appears in the command-line.The entry
    is the boolean (0 for not set, non-zero for set).
  @{b}/K@{ub} - Keyword.This means that the option will not be filled unless
    the keyword appears.For example if the template is "Name/K",
    then unless "Name=<string>" or "Name <string>" appears in the
    command line, Name will not be filled.
  @{b}/N@{ub} - Number.This parameter is considered a decimal number, and will
    be converted by ReadArgs.If an invalid number is specified,
    an error will be returned.The entry will be a pointer to the
    longword number (this is how you know if a number was specified).
  @{b}/T@{ub} - Toggle.This is similar to a switch, but when specified causes
    the boolean value to "toggle".Similar to /S.
  @{b}/A@{ub} - Required.This keyword must be given a value during command-line
    processing, or an error is returned.
  @{b}/F@{ub} - Rest of line.If this is specified, the entire rest of the line
    is taken as the parameter for the option, even if other option
    keywords appear in it.
  @{b}/M@{ub} - Multiple strings.This means the argument will take any number
    of strings, returning them as an array of strings.Any arguments
    not considered to be part of another option will be added to this
    option.Only one /M should be specified in a template.Example:
    for a template "Dir/M,All/S" the command-line "foo bar all qwe"
    will set the boolean "all", and return an array consisting of
    "foo", "bar", and "qwe".The entry in the array will be a pointer
    to an array of string pointers, the last of which will be NULL.
    There is an interaction between /M parameters and /A parameters.
    If there are unfilled /A parameters after parsing, it will grab
    strings from the end of a previous /M parameter list to fill the
    /A's.This is used for things like Copy ("From/A/M,To/A").
  ReadArgs() returns a struct RDArgs if it succeeds.This serves as an
  "anchor" to allow @{"FreeArgs()" Link "FreeArgs()"} to free the associated memory.You can
  also pass in a struct RDArgs to control the operation of ReadArgs()
  (normally you pass NULL for the parameter, and ReadArgs() allocates
  one for you).This allows providing different sources for the arguments,
  providing your own string buffer space for temporary storage, and
  extended help text.See @{"<dos/rdargs.h>" Link "include:dos/rdargs.h/Main" 0} for more information on this.
  @{i}Note@{ui}: if you pass in a struct RDArgs, you must still call @{"FreeArgs()" Link "FreeArgs()"} to
  release storage that gets attached to it, but you are responsible for
  freeing the RDArgs yourself.
  If you pass in a RDArgs structure, you @{b}MUST@{ub} reset (clear or set)
  RDA_Buffer for each new call to RDArgs.The exact behavior if you don't do this
  varies from release to release and case to case; don't count on the behavior!
  See BUGS regarding passing in strings.
SYNOPSIS  @{FG shine}struct@{FG text} @{"RDArgs" Link "include:dos/rdargs.h/Main" 95} * ReadArgs(STRPTR, @{FG shine}long@{FG text} *, @{FG shine}struct@{FG text} @{"RDArgs" Link "include:dos/rdargs.h/Main" 95} *)
  @{i}@{b}result@{ub}@{ui} = ReadArgs(@{i}template@{ui}, @{i}array@{ui}, @{i}rdargs@{ui})
   D0                D1        D2     D3
  @{i}template@{ui} - formatting string
  @{i}array@{ui} - array of longwords for results, 1 per template entry
  @{i}rdargs@{ui} - optional rdargs structure for options.
    @{"AllocDosObject" Link "AllocDosObject()"} should be used for allocating them if you pass one in.
  @{i}@{b}result@{ub}@{ui} - a struct @{"RDArgs" Link "include:dos/rdargs.h/Main" 95} or NULL for failure.
BUGS
  In V36, there were a couple of minor bugs with certain argument
  combinations (/M/N returned strings, /T didn't work, and /K and
  /F interacted).Also, a template with a /K before any non-switch
  parameter will require the argument name to be given in order for
  line to be accepted (i.e."parm/K,xyzzy/A" would require
  "xyzzy=xxxxx" in order to work - "xxxxx" would not work).If you
  need to avoid this for V36, put /K parameters after all non-switch
  parameters.These problems should be fixed for V37.
  Currently (V37 and before) it requires any strings passed in to have
  newlines at the end of the string.This may or may not be fixed in the future.
SEE ALSO
  @{"FindArg()" Link "FindArg()"}, @{"ReadItem()" Link "ReadItem()"}, @{"FreeArgs()" Link "FreeArgs()"}, @{"AllocDosObject()" Link "AllocDosObject()"}
@EndNode
@Node "ReadItem()" "dos.library/ReadItem"
@{b}@{u}ReadItem@{uu}@{ub} - reads a single argument/name from command line.(V36)
  Reads a "word" from either @{"Input()" Link "Input()"} (buffered), or via @{"CSource" Link "include:dos/rdargs.h/Main" 61}, if it
  is non-NULL (see @{"<dos/rdargs.h>" Link "include:dos/rdargs.h/Main" 0} for more information).Handles
  quoting and some '*' substitutions (*e and *n) inside quotes (only).
  See @{"dos/dos.h" Link "include:dos/dos.h/Main" 0} for a listing of values returned by ReadItem()
  (ITEM_XXXX).A "word" is delimited by whitespace, quotes, '=', or an EOF.
  ReadItem always unreads the last thing read (UnGetC(fh,-1)) so the
  caller can find out what the terminator was.
SYNOPSIS  @{FG shine}long@{FG text} ReadItem(STRPTR, @{FG shine}long@{FG text}, @{FG shine}struct@{FG text} @{"CSource" Link "include:dos/rdargs.h/Main" 61} *)
  @{i}@{b}value@{ub}@{ui} = ReadItem(@{i}buffer@{ui}, @{i}maxchars@{ui}, @{i}input@{ui})
   D0               D1      D2         D3
  @{i}buffer@{ui} - buffer to store word in.
  @{i}maxchars@{ui} - size of the buffer
  @{i}input@{ui} - @{"CSource" Link "include:dos/rdargs.h/Main" 61} input or NULL (uses FGetC(Input()))
  @{i}@{b}value@{ub}@{ui} - See @{"<dos/dos.h>" Link "include:dos/dos.h/Main" 0} for return values.
BUGS
  Doesn't actually unread the terminator.
SEE ALSO
  @{"ReadArgs()" Link "ReadArgs()"}, @{"FindArg()" Link "FindArg()"}, @{"UnGetC()" Link "UnGetC()"}, @{"FGetC()" Link "FGetC()"}, @{"Input()" Link "Input()"}, @{"<dos/dos.h>" Link "include:dos/dos.h/Main" 0},
  @{"<dos/rdargs.h>" Link "include:dos/rdargs.h/Main" 0}, @{"FreeArgs()" Link "FreeArgs()"}
@EndNode
@Node "ReadLink()" "dos.library/ReadLink"
@{b}@{u}ReadLink@{uu}@{ub} -- Reads the path for a soft filesystem link.(V36)
  ReadLink() takes a lock/name pair (usually from a failed attempt
  to use them to access an object with packets), and asks the
  filesystem to find the softlink and fill buffer with the modified
  path string.You then start the resolution process again by
  calling @{"GetDeviceProc()" Link "GetDeviceProc()"} with the new string from ReadLink().
  Soft-links are resolved at access time by a combination of the
  filesystem (by returning ERROR_IS_SOFT_LINK to dos), and by
  Dos (using ReadLink() to resolve any links that are hit).
SYNOPSIS  BOOL ReadLink( @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *, BPTR, STRPTR, STRPTR, ULONG)
  @{i}@{b}success@{ub}@{ui} = ReadLink( @{i}port@{ui}, @{i}lock@{ui}, @{i}path@{ui}, @{i}buffer@{ui}, @{i}size@{ui})
   D0                  D1    D2    D3     D4      D5
  @{i}port@{ui} - msgport of the filesystem
  @{i}lock@{ui} - lock this path is relative to on the filesystem
  @{i}path@{ui} - path that caused the ERROR_IS_SOFT_LINK
  @{i}buffer@{ui} - pointer to buffer for new path from handler.
  @{i}size@{ui} - size of buffer.
  @{i}@{b}Success@{ub}@{ui} - boolean
BUGS
  In V36, soft-links didn't work in the ROM filesystem.This was fixed for V37.
SEE ALSO
  @{"MakeLink()" Link "MakeLink()"}, @{"Open()" Link "Open()"}, @{"Lock()" Link "Lock()"}, @{"GetDeviceProc()" Link "GetDeviceProc()"}
@EndNode
@Node "Relabel()" "dos.library/Relabel"
@{b}@{u}Relabel@{uu}@{ub} -- Change the volume name of a volume.(V36)
  Changes the volumename of a volume, if supported by the filesystem.
SYNOPSIS  BOOL Relabel(STRPTR,STRPTR)
  @{i}@{b}success@{ub}@{ui} = Relabel(@{i}volumename@{ui},@{i}name@{ui})
   D0                D1         D2
  @{i}volumename@{ui} - Full name of device to rename (with ':')
  @{i}newname@{ui} - New name to apply to device (without ':')
  @{i}@{b}success@{ub}@{ui} - Success/failure indicator
@EndNode
@Node "RemAssignList()" "dos.library/RemAssignList"
@{b}@{u}RemAssignList@{uu}@{ub} -- Remove an entry from a multi-dir assign.(V36)
  Removes an entry from a multi-directory assign.The entry removed is
  the first one for which @{"SameLock" Link "SameLock()"} with 'lock' returns that they are on
  the same object.The lock for the entry in the list is unlocked (not
  the entry passed in).
SYNOPSIS  BOOL RemAssignList(STRPTR,BPTR)
  @{i}@{b}success@{ub}@{ui} = RemAssignList(@{i}name@{ui},@{i}lock@{ui})
   D0                      D1   D2
  @{i}name@{ui} - Name of device to remove lock from (without trailing ':')
  @{i}lock@{ui} - Lock associated with the object to remove from the list
  @{i}@{b}success@{ub}@{ui} - Success/failure indicator.
BUGS
  In V36 through V39.23 dos, it would fail to remove the first lock
  in the assign.Fixed in V39.24 dos (after the V39.106 kickstart).
SEE ALSO
  @{"Lock()" Link "Lock()"}, @{"AssignLock()" Link "AssignLock()"}, @{"AssignPath()" Link "AssignPath()"}, @{"AssignLate()" Link "AssignLate()"}, @{"DupLock()" Link "DupLock()"},
  @{"AssignAdd()" Link "AssignAdd()"}, @{"UnLock()" Link "UnLock()"}
@EndNode
@Node "RemDosEntry()" "dos.library/RemDosEntry"
@{b}@{u}RemDosEntry@{uu}@{ub} -- Removes a Dos @{"List" Link "include:exec/lists.h/Main" 20} entry from it's list.(V36)
  This removes an entry from the Dos @{"Device" Link "include:exec/devices.h/Main" 25} list.The memory associated
  with the entry is @{b}NOT@{ub} freed.
  @{i}NOTE@{ui}: you must have locked the Dos List with the appropriate flags before
  calling this routine.Handler writers should see the @{"AddDosEntry()" Link "AddDosEntry()"} caveats
  about locking and use a similar workaround to avoid deadlocks.
SYNOPSIS  BOOL RemDosEntry(@{FG shine}struct@{FG text} @{"DosList" Link "include:dos/dosextens.h/Main" 369} *)
  @{i}@{b}success@{ub}@{ui} = RemDosEntry(@{i}dlist@{ui})
   D0                    D1
  @{i}dlist@{ui} - @{"Device" Link "include:exec/devices.h/Main" 25} list entry to be removed.
  @{i}@{b}success@{ub}@{ui} - Success/failure indicator
SEE ALSO
  @{"AddDosEntry()" Link "AddDosEntry()"}, @{"FindDosEntry()" Link "FindDosEntry()"}, @{"NextDosEntry()" Link "NextDosEntry()"}, @{"LockDosList()" Link "LockDosList()"},
  @{"MakeDosEntry()" Link "MakeDosEntry()"}, @{"FreeDosEntry()" Link "FreeDosEntry()"}
@EndNode
@Node "RemSegment()" "dos.library/RemSegment"
@{b}@{u}RemSegment@{uu}@{ub} - Removes a resident segment from the resident list.(V36)
  Removes a resident segment from the Dos resident segment list,
  unloads it, and does any other cleanup required.Will only succeed
  if the seg_UC (usecount) is 0.
SYNOPSIS  BOOL RemSegment(@{FG shine}struct@{FG text} @{"Segment" Link "include:dos/dosextens.h/Main" 296} *)
  @{i}@{b}success@{ub}@{ui} = RemSegment(@{i}segment@{ui})
   D0                   D1
  @{i}segment@{ui} - the segment to be removed
  @{i}@{b}success@{ub}@{ui} - success or failure.
SEE ALSO
  @{"FindSegment()" Link "FindSegment()"}, @{"AddSegment()" Link "AddSegment()"}
@EndNode
@Node "Rename()" "dos.library/Rename"
@{b}@{u}Rename@{uu}@{ub} -- Rename a directory or file.
  Rename() attempts to rename the file or directory specified as
  'oldName' with the name 'newName'.If the file or directory
  'newName' exists, Rename() fails and returns an error.Both
  'oldName' and the 'newName' can contain a directory specification.
  In this case, the file will be moved from one directory to another.
  @{i}Note@{ui}: it is impossible to Rename() a file from one volume to another.
SYNOPSIS  BOOL Rename(STRPTR, STRPTR)
  @{i}@{b}success@{ub}@{ui} = Rename( @{i}oldName@{ui}, @{i}newName@{ui} )
   D0                D1       D2
  @{i}oldName@{ui} - pointer to a null-terminated string
  @{i}newName@{ui} - pointer to a null-terminated string
  @{i}@{b}success@{ub}@{ui} - boolean
SEE ALSO
  @{"Relabel()" Link "Relabel()"}
@EndNode
@Node "ReplyPkt()" "dos.library/ReplyPkt"
@{b}@{u}ReplyPkt@{uu}@{ub} -- replies a packet to the person who sent it to you.(V36)
  This returns a packet to the process which sent it to you.In
  addition, puts your pr_MsgPort address in dp_Port, so using ReplyPkt()
  again will send the message to you.(This is used in "ping-ponging"
  packets between two processes).It uses result 1 & 2 to set the
  dp_Res1 and dp_Res2 fields of the packet.
SYNOPSIS  @{FG shine}void@{FG text} ReplyPkt(@{FG shine}struct@{FG text} @{"DosPacket" Link "include:dos/dosextens.h/Main" 108} *, @{FG shine}long@{FG text}, @{FG shine}long@{FG text})
  ReplyPkt(@{i}packet@{ui}, @{i}result1@{ui}, @{i}result2@{ui})
            D1      D2       D3
  @{i}packet@{ui} - packet to reply, assumed to set up correctly.
  @{i}result1@{ui} - first result
  @{i}result2@{ui} - secondary result
SEE ALSO
  @{"DoPkt()" Link "DoPkt()"}, @{"SendPkt()" Link "SendPkt()"}, @{"WaitPkt()" Link "WaitPkt()"}, @{"IoErr()" Link "IoErr()"}
@EndNode
@Node "RunCommand()" "dos.library/RunCommand"
@{b}@{u}RunCommand@{uu}@{ub} -- Runs a program using the current process.(V36)
  Runs a command on your process/cli.Seglist may be any language,
  including BCPL programs.Stacksize is in bytes.argptr is a null-
  terminated string, argsize is its length.Returns the returncode the
  program exited with in d0.Returns -1 if the stack couldn't be allocated.
  @{i}NOTE@{ui}: the argument string @{b}MUST@{ub} be terminated with a newline to work
  properly with @{"ReadArgs()" Link "ReadArgs()"} and other argument parsers.
  RunCommand also takes care of setting up the current input filehandle
  in such a way that @{"ReadArgs()" Link "ReadArgs()"} can be used in the program, and restores
  the state of the buffering before returning.It also sets the value
  returned by @{"GetArgStr()" Link "GetArgStr()"}, and restores it before returning.
  @{i}NOTE@{ui}: the setting of the argument string in the filehandle was added in V37.
  It's usually appropriate to set the command name (via @{"SetProgramName()" Link "SetProgramName()"})
  before calling RunCommand().RunCommand() sets the value returned by
  @{"GetArgStr()" Link "GetArgStr()"} while the command is running.
SYNOPSIS  @{FG shine}long@{FG text} RunCommand(BPTR, ULONG, STRPTR, ULONG)
  @{i}@{b}rc@{ub}@{ui} = RunCommand(@{i}seglist@{ui}, @{i}stacksize@{ui}, @{i}argptr@{ui}, @{i}argsize@{ui})
   D0              D1       D2          D3      D4
  @{i}seglist@{ui} - Seglist of command to run.
  @{i}stacksize@{ui} - Number of bytes to allocate for stack space
  @{i}argptr@{ui} - Pointer to argument command string.
  @{i}argsize@{ui} - Number of bytes in argument command.
  @{i}@{b}rc@{ub}@{ui} - Return code from executed command.-1 indicates failure
SEE ALSO
  @{"CreateNewProc()" Link "CreateNewProc()"}, @{"SystemTagList()" Link "SystemTagList()"}, @{"Execute()" Link "Execute()"}, @{"GetArgStr()" Link "GetArgStr()"},
  @{"SetProgramName()" Link "SetProgramName()"}, @{"ReadArgs()" Link "ReadArgs()"}
@EndNode
@Node "SameDevice()" "dos.library/SameDevice"
@{b}@{u}SameDevice@{uu}@{ub} -- Are two locks are on partitions of the device? (V37)
  SameDevice() returns whether two locks refer to partitions that
  are on the same physical device (if it can figure it out).This
  may be useful in writing copy routines to take advantage of
  asynchronous multi-device copies.
  Entry existed in V36 and always returned 0.
SYNOPSIS  BOOL SameDevice( BPTR, BPTR )
  @{i}@{b}same@{ub}@{ui} = SameDevice(@{i}lock1@{ui}, @{i}lock2@{ui})
   D0                D1      D2
  @{i}lock1@{ui},@{i}lock2@{ui} - locks
  @{i}@{b}same@{ub}@{ui} - whether they're on the same device as far as Dos can determine.
@EndNode
@Node "SameLock()" "dos.library/SameLock"
@{b}@{u}SameLock@{uu}@{ub} -- returns whether two locks are on the same object.(V36)
  Compares two locks.Returns LOCK_SAME if they are on the same object,
  LOCK_SAME_VOLUME if on different objects on the same volume, and
  LOCK_DIFFERENT if they are on different volumes.Always compare
  for equality or non-equality with the results, in case new return
  values are added.
SYNOPSIS  @{FG shine}long@{FG text} SameLock(BPTR, BPTR)
  @{i}@{b}value@{ub}@{ui} = SameLock(@{i}lock1@{ui}, @{i}lock2@{ui})
   D0               D1      D2
  @{i}lock1@{ui} - 1st lock for comparison
  @{i}lock2@{ui} - 2nd lock for comparison
  @{i}@{b}value@{ub}@{ui} - LOCK_SAME, LOCK_SAME_VOLUME, or LOCK_DIFFERENT
BUGS
  Should do more extensive checks for NULL against a real lock, checking
  to see if the real lock is a lock on the root of the boot volume.
  In V36, it would return LOCK_SAME_VOLUME for different volumes on the
  same handler.Also, LOCK_SAME_VOLUME was LOCK_SAME_HANDLER (now
  an obsolete define, see @{"<dos/dos.h>" Link "include:dos/dos.h/Main" 0}).
SEE ALSO
  @{"<dos/dos.h>" Link "include:dos/dos.h/Main" 0}
@EndNode
@Node "Seek()" "dos.library/Seek"
@{b}@{u}Seek@{uu}@{ub} -- Set the current position for reading and writing.
  Seek() sets the read/write cursor for the file 'file' to the
  position 'position'.This position is used by both @{"Read()" Link "Read()"} and
  @{"Write()" Link "Write()"} as a place to start reading or writing.The result is the
  current absolute position in the file, or -1 if an error occurs, in
  which case @{"IoErr()" Link "IoErr()"} can be used to find more information.'mode' can
  be OFFSET_BEGINNING, OFFSET_CURRENT or OFFSET_END.It is used to
  specify the relative start position.For example, 20 from current
  is a position 20 bytes forward from current, -20 is 20 bytes back from current.
  So that to find out where you are, seek zero from current.The end
  of the file is a Seek() positioned by zero from end.You cannot
  Seek() beyond the end of a file.
SYNOPSIS  @{FG shine}long@{FG text} Seek(BPTR, @{FG shine}long@{FG text}, @{FG shine}long@{FG text})
  @{i}@{b}oldPosition@{ub}@{ui} = Seek( @{i}file@{ui}, @{i}position@{ui}, @{i}mode@{ui} )
   D0                  D1    D2        D3
  @{i}file@{ui} - BCPL pointer to a file handle
  @{i}position@{ui} - integer
  @{i}mode@{ui} - integer
  @{i}@{b}oldPosition@{ub}@{ui} - integer
BUGS
  The V36 and V37 ROM filesystem (and V36/V37 l:fastfilesystem)
  returns the current position instead of -1 on an error.It sets
  @{"IoErr()" Link "IoErr()"} to 0 on success, and an error code on an error.This bug
  was fixed in the V39 filesystem.
SEE ALSO
  @{"Read()" Link "Read()"}, @{"Write()" Link "Write()"}, @{"SetFileSize()" Link "SetFileSize()"}
@EndNode
@Node "SelectInput()" "dos.library/SelectInput"
@{b}@{u}SelectInput@{uu}@{ub} -- Select a filehandle as the default input channel.(V36)
  Set the current input as the default input for the process.
  This changes the value returned by @{"Input()" Link "Input()"}. old_fh should
  be closed or saved as needed.
SYNOPSIS  BPTR SelectInput(BPTR)
  @{i}@{b}old_fh@{ub}@{ui} = SelectInput(@{i}fh@{ui})
   D0                   D1
  @{i}fh@{ui} - Newly default input handle
  @{i}@{b}old_fh@{ub}@{ui} - Previous default input filehandle
SEE ALSO
  @{"Input()" Link "Input()"}, @{"SelectOutput()" Link "SelectOutput()"}, @{"Output()" Link "Output()"}
@EndNode
@Node "SelectOutput()" "dos.library/SelectOutput"
@{b}@{u}SelectOutput@{uu}@{ub} -- Select a filehandle as the default output channel.(V36)
  Set the current output as the default output for the process.
  This changes the value returned by @{"Output()" Link "Output()"}. old_fh should
  be closed or saved as needed.
SYNOPSIS  BPTR SelectOutput(BPTR)
  @{i}@{b}old_fh@{ub}@{ui} = SelectOutput(@{i}fh@{ui})
   D0                    D1
  @{i}fh@{ui} - Newly desired output handle
  @{i}@{b}old_fh@{ub}@{ui} - Previous current output
SEE ALSO
  @{"Output()" Link "Output()"}, @{"SelectInput()" Link "SelectInput()"}, @{"Input()" Link "Input()"}
@EndNode
@Node "SendPkt()" "dos.library/SendPkt"
@{b}@{u}SendPkt@{uu}@{ub} -- Sends a packet to a handler.(V36)
  Sends a packet to a handler and does not wait.All fields in the
  packet must be initialized before calling this routine.The packet
  will be returned to replyport.If you wish to use this with
  @{"WaitPkt()" Link "WaitPkt()"}, use the address of your pr_MsgPort for replyport.
SYNOPSIS  @{FG shine}void@{FG text} SendPkt(@{FG shine}struct@{FG text} @{"DosPacket" Link "include:dos/dosextens.h/Main" 108} *,@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *,@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *)
  SendPkt(@{i}packet@{ui}, @{i}port@{ui}, @{i}replyport@{ui})
           D1      D2    D3
  @{i}packet@{ui} - packet to send, must be initialized and have a message.
  @{i}port@{ui} - pr_MsgPort of handler process to send to.
  @{i}replyport@{ui} - @{"MsgPort" Link "include:exec/ports.h/Main" 28} for the packet to come back to.
NOTES
  Callable from a task.
SEE ALSO
  @{"DoPkt()" Link "DoPkt()"}, @{"WaitPkt()" Link "WaitPkt()"}, @{"AllocDosObject()" Link "AllocDosObject()"}, @{"FreeDosObject()" Link "FreeDosObject()"}, @{"AbortPkt()" Link "AbortPkt()"}
@EndNode
@Node "SetArgStr()" "dos.library/SetArgStr"
@{b}@{u}SetArgStr@{uu}@{ub} -- Sets the arguments for the current process.(V36)
  Sets the arguments for the current program.The ptr @{b}MUST@{ub} be reset
  to it's original value before process exit.
SYNOPSIS  STRPTR SetArgStr(STRPTR)
  @{i}@{b}oldptr@{ub}@{ui} = SetArgStr(@{i}ptr@{ui})
   D0                 D1
  @{i}ptr@{ui} - pointer to new argument string.
  @{i}@{b}oldptr@{ub}@{ui} - the previous argument string
SEE ALSO
  @{"GetArgStr()" Link "GetArgStr()"}, @{"RunCommand()" Link "RunCommand()"}
@EndNode
@Node "SetComment()" "dos.library/SetComment"
@{b}@{u}SetComment@{uu}@{ub} -- Change a files' comment string.
  SetComment() sets a comment on a file or directory.The comment is
  a pointer to a null-terminated string of up to 80 characters in the
  current ROM filesystem (and RAM:).Note that not all filesystems
  will support comments (for example, NFS usually will not), or the
  size of comment supported may vary.
SYNOPSIS  BOOL SetComment(STRPTR, STRPTR)
  @{i}@{b}success@{ub}@{ui} = SetComment( @{i}name@{ui}, @{i}comment@{ui} )
   D0                    D1    D2
  @{i}name@{ui} - pointer to a null-terminated string
  @{i}comment@{ui} - pointer to a null-terminated string
  @{i}@{b}success@{ub}@{ui} - boolean
SEE ALSO
  @{"Examine()" Link "Examine()"}, @{"ExNext()" Link "ExNext()"}, @{"SetProtection()" Link "SetProtection()"}
@EndNode
@Node "SetConsoleTask()" "dos.library/SetConsoleTask"
@{b}@{u}SetConsoleTask@{uu}@{ub} -- Sets the default console for the process.(V36)
  Sets the default console task's port (pr_ConsoleTask) for the current process.
SYNOPSIS  @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *SetConsoleTask(@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *)
  @{i}@{b}oldport@{ub}@{ui} = SetConsoleTask(@{i}port@{ui})
   D0                       D1
  @{i}port@{ui} - The pr_MsgPort of the default console handler for the process
  @{i}@{b}oldport@{ub}@{ui} - The previous ConsoleTask value.
SEE ALSO
  @{"GetConsoleTask()" Link "GetConsoleTask()"}, @{"Open()" Link "Open()"}
@EndNode
@Node "SetCurrentDirName()" "dos.library/SetCurrentDirName"
@{b}@{u}SetCurrentDirName@{uu}@{ub} -- Sets the directory name for the process.(V36)
  Sets the name for the current dir in the cli structure.If the name
  is too long to fit, a failure is returned, and the old value is left
  intact.It is advised that you inform the user of this condition.
  This routine is safe to call even if there is no CLI structure.
SYNOPSIS  BOOL SetCurrentDirName(STRPTR)
  @{i}@{b}success@{ub}@{ui} = SetCurrentDirName(@{i}name@{ui})
   D0                          D1
  @{i}name@{ui} - Name of directory to be set.
  @{i}@{b}success@{ub}@{ui} - Success/failure indicator
BUGS
  This clips to a fixed (1.3 compatible) size.
SEE ALSO
  @{"GetCurrentDirName()" Link "GetCurrentDirName()"}
@EndNode
@Node "SetFileDate()" "dos.library/SetFileDate"
@{b}@{u}SetFileDate@{uu}@{ub} -- Sets the modification date for a file or dir.(V36)
  Sets the file date for a file or directory.Note that for the Old
  File System and the Fast File System, the date of the root directory
  cannot be set.Other filesystems may not support setting the date
  for all files/directories.
SYNOPSIS  BOOL SetFileDate(STRPTR, @{FG shine}struct@{FG text} @{"DateStamp" Link "include:dos/dos.h/Main" 52} *)
  @{i}@{b}success@{ub}@{ui} = SetFileDate(@{i}name@{ui}, @{i}date@{ui})
   D0                    D1    D2
  @{i}name@{ui} - Name of object
  @{i}date@{ui} - New modification date
  @{i}@{b}success@{ub}@{ui} - Success/failure indication
SEE ALSO
  @{"DateStamp()" Link "DateStamp()"}, @{"Examine()" Link "Examine()"}, @{"ExNext()" Link "ExNext()"}, @{"ExAll()" Link "ExAll()"}
@EndNode
@Node "SetFileSize()" "dos.library/SetFileSize"
@{b}@{u}SetFileSize@{uu}@{ub} -- Sets the size of a file.(V36)
  Changes the file size, truncating or extending as needed.Not all
  handlers may support this; be careful and check the return code.If
  the file is extended, no values should be assumed for the new bytes.
  If the new position would be before the filehandle's current position
  in the file, the filehandle will end with a position at the end-of-file.
  If there are other filehandles open onto the file, the new size will not
  leave any filehandle pointing past the end-of-file.You can check for this by
  looking at the new size (which would be different than what you requested).
  The seek position should not be changed unless the file is made smaller
  than the current seek position.However, see BUGS.
  Do @{b}NOT@{ub} count on any specific values to be in any extended area.
SYNOPSIS  @{FG shine}long@{FG text} SetFileSize(BPTR, @{FG shine}long@{FG text}, @{FG shine}long@{FG text})
  @{i}@{b}newsize@{ub}@{ui} = SetFileSize(@{i}fh@{ui}, @{i}offset@{ui}, @{i}mode@{ui})
   D0                    D1   D2      D3
  @{i}fh@{ui} - File to be truncated/extended.
  @{i}offset@{ui} - Offset from position determined by mode.
  @{i}mode@{ui} - One of OFFSET_BEGINNING, OFFSET_CURRENT, or OFFSET_END.
  @{i}@{b}newsize@{ub}@{ui} - position of new end-of-file or -1 for error.
BUGS
  The RAM: filesystem and the normal Amiga filesystem act differently
  in where the file position is left after SetFileSize().RAM: leaves
  you at the new end of the file (incorrectly), while the Amiga ROM
  filesystem leaves the seek position alone, unless the new position is
  less than the current position, in which case you're left at the new EOF.
  The best workaround is to not make any assumptions about the seek
  position after SetFileSize().
SEE ALSO
  @{"Seek()" Link "Seek()"}
@EndNode
@Node "SetFileSysTask()" "dos.library/SetFileSysTask"
@{b}@{u}SetFileSysTask@{uu}@{ub} -- Sets the default filesystem for the process.(V36)
  Sets the default filesystem task's port (pr_FileSystemTask) for the
  current process.
SYNOPSIS  @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *SetFileSysTask(@{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *)
  @{i}@{b}oldport@{ub}@{ui} = SetFileSysTask(@{i}port@{ui})
   D0                       D1
  @{i}port@{ui} - The pr_MsgPort of the default filesystem for the process
  @{i}@{b}oldport@{ub}@{ui} - The previous FileSysTask value
SEE ALSO
  @{"GetFileSysTask()" Link "GetFileSysTask()"}, @{"Open()" Link "Open()"}
@EndNode
@Node "SetIoErr()" "dos.library/SetIoErr"
@{b}@{u}SetIoErr@{uu}@{ub} -- Sets the value returned by @{"IoErr()" Link "IoErr()"}.(V36)
  This routine sets up the secondary result (pr_Result2) return code 
  (returned by the @{"IoErr()" Link "IoErr()"} function).
SYNOPSIS  @{FG shine}long@{FG text} SetIoErr(@{FG shine}long@{FG text});
  @{i}@{b}oldcode@{ub}@{ui} = SetIoErr(@{i}code@{ui})
   D0                 D1
  @{i}code@{ui} - Code to be returned by a call to @{"IoErr" Link "IoErr()"}.
  @{i}@{b}oldcode@{ub}@{ui} - The previous error code.
SEE ALSO
  @{"IoErr()" Link "IoErr()"}, @{"Fault()" Link "Fault()"}, @{"PrintFault()" Link "PrintFault()"}
@EndNode
@Node "SetMode()" "dos.library/SetMode"
@{b}@{u}SetMode@{uu}@{ub} - Set the current behavior of a handler.(V36)
  SetMode() sends an ACTION_SCREEN_MODE packet to the handler in
  question, normally for changing a CON: handler to raw mode or
  vice-versa.For CON:, use 1 to go to RAW: mode, 0 for CON: mode.
SYNOPSIS  BOOL SetMode(BPTR, @{FG shine}long@{FG text})
  @{i}@{b}success@{ub}@{ui} = SetMode(@{i}fh@{ui}, @{i}mode@{ui})
   D0                D1  D2
  @{i}fh@{ui} - filehandle
  @{i}mode@{ui} - The new mode you want
  @{i}@{b}success@{ub}@{ui} - Boolean
@EndNode
@Node "SetOwner()" "dos.library/SetOwner"
@{b}@{u}SetOwner@{uu}@{ub} -- Set owner information for a file or directory.(V39)
  SetOwner() sets the owner information for the file or directory.
  This value is a 32-bit value that is normally split into 16 bits
  of owner user id (bits 31-16), and 16 bits of owner group id (bits
  15-0).However, other than returning them as shown by Examine()/
  @{"ExNext()/ExAll()" Link "ExAll()"}, the filesystem take no interest in the values.
  These are primarily for use by networking software (clients and hosts),
  in conjunction with the FIBF_OTR_xxx and FIBF_GRP_xxx protection bits.
  This entrypoint did not exist in V36, so you must open at least V37
  dos.library to use it.V37 dos.library will return FALSE to this call.
SYNOPSIS  BOOL SetOwner (STRPTR, @{FG shine}long@{FG text})
  @{i}@{b}success@{ub}@{ui} = SetOwner( @{i}name@{ui}, @{i}owner_info@{ui} )
   D0                  D1     D2
  @{i}name@{ui} - pointer to a null-terminated string
  @{i}owner_info@{ui} - owner uid (31:16) and group id (15:0)
  @{i}@{b}success@{ub}@{ui} - boolean
SEE ALSO
  SetProtect(), @{"Examine()" Link "Examine()"}, @{"ExNext()" Link "ExNext()"}, @{"ExAll()" Link "ExAll()"}, @{"<dos/dos.h>" Link "include:dos/dos.h/Main" 0}
@EndNode
@Node "SetProgramDir()" "dos.library/SetProgramDir"
@{b}@{u}SetProgramDir@{uu}@{ub} -- Sets the directory returned by @{"GetProgramDir" Link "GetProgramDir()"}.(V36)
  Sets a shared lock on the directory the program was loaded from.
  This can be used for a program to find data files, etc, that are
  stored with the program, or to find the program file itself.NULL
  is a valid input.This can be accessed via @{"GetProgramDir()" Link "GetProgramDir()"} or
  by using paths relative to PROGDIR:.
SYNOPSIS  BPTR SetProgramDir(BPTR)
  @{i}@{b}oldlock@{ub}@{ui} = SetProgramDir(@{i}lock@{ui})
   D0                      D1
  @{i}lock@{ui} - A lock on the directory the current program was loaded from
  @{i}@{b}oldlock@{ub}@{ui} - The previous ProgramDir.
SEE ALSO
  @{"GetProgramDir()" Link "GetProgramDir()"}, @{"Open()" Link "Open()"}
@EndNode
@Node "SetProgramName()" "dos.library/SetProgramName"
@{b}@{u}SetProgramName@{uu}@{ub} -- Sets the name of the program being run.(V36)
  Sets the name for the program in the cli structure.If the name is
  too long to fit, a failure is returned, and the old value is left
  intact.It is advised that you inform the user if possible of this
  condition, and/or set the program name to an empty string.
  This routine is safe to call even if there is no CLI structure.
SYNOPSIS  BOOL SetProgramName(STRPTR)
  @{i}@{b}success@{ub}@{ui} = SetProgramName(@{i}name@{ui})
   D0                       D1
  @{i}name@{ui} - Name of program to use.
  @{i}@{b}success@{ub}@{ui} - Success/failure indicator.
BUGS
  This clips to a fixed (1.3 compatible) size.
SEE ALSO
  @{"GetProgramName()" Link "GetProgramName()"}
@EndNode
@Node "SetPrompt()" "dos.library/SetPrompt"
@{b}@{u}SetPrompt@{uu}@{ub} -- Sets the CLI/shell prompt for the current process.(V36)
  Sets the text for the prompt in the cli structure.If the prompt is
  too long to fit, a failure is returned, and the old value is left
  intact.It is advised that you inform the user of this condition.
  This routine is safe to call even if there is no CLI structure.
SYNOPSIS  BOOL SetPrompt(STRPTR)
  @{i}@{b}success@{ub}@{ui} = SetPrompt(@{i}name@{ui})
   D0                  D1
  @{i}name@{ui} - Name of prompt to be set.
  @{i}@{b}success@{ub}@{ui} - Success/failure indicator.
BUGS
  This clips to a fixed (1.3 compatible) size.
SEE ALSO
  @{"GetPrompt()" Link "GetPrompt()"}
@EndNode
@Node "SetProtection()" "dos.library/SetProtection"
@{b}@{u}SetProtection@{uu}@{ub} -- Set protection for a file or directory.
  SetProtection() sets the protection attributes on a file or
  directory.See @{"<dos/dos.h>" Link "include:dos/dos.h/Main" 0} for a listing of protection bits.
  Before V36, the ROM filesystem didn't respect the Read and Write bits.
  In V36 or later and in the FFS, the Read and Write bits are respected.
  The archive bit should be cleared by the filesystem whenever the file is
  changed.Backup utilities will generally set the bit after backing up each file.
  The V36 Shell looks at the execute bit, and will refuse to execute
  a file if it is set.
  Other bits will be defined in the @{"<dos/dos.h>" Link "include:dos/dos.h/Main" 0} include files.Rather
  than referring to bits by number you should use the definitions in
  @{"<dos/dos.h>" Link "include:dos/dos.h/Main" 0}.
SYNOPSIS  BOOL SetProtection (STRPTR, @{FG shine}long@{FG text})
  @{i}@{b}success@{ub}@{ui} = SetProtection( @{i}name@{ui}, @{i}mask@{ui} )
   D0                       D1    D2
  @{i}name@{ui} - pointer to a null-terminated string
  @{i}mask@{ui} - the protection mask required
  @{i}@{b}success@{ub}@{ui} - boolean
SEE ALSO
  @{"SetComment()" Link "SetComment()"}, @{"Examine()" Link "Examine()"}, @{"ExNext()" Link "ExNext()"}, @{"<dos/dos.h>" Link "include:dos/dos.h/Main" 0}
@EndNode
@Node "SetVar()" "dos.library/SetVar"
@{b}@{u}SetVar@{uu}@{ub} -- Sets a local or environment variable.(V36)
  Sets a local or environment variable.It is advised to only use
  ASCII strings inside variables, but not required.
SYNOPSIS  BOOL SetVar(STRPTR, STRPTR, @{FG shine}long@{FG text}, ULONG )
  @{i}@{b}success@{ub}@{ui} = SetVar( @{i}name@{ui}, @{i}buffer@{ui}, @{i}size@{ui}, @{i}flags@{ui} )
   D0                D1    D2       D3    D4
  @{i}name@{ui} - pointer to an variable name.
    Note variable names follow filesystem syntax and semantics.
  @{i}buffer@{ui} - a user allocated area which contains a string that is the
    value to be associated with this variable.
  @{i}size@{ui} - length of the buffer region in bytes.
    -1 means buffer contains a null-terminated string.
  @{i}flags@{ui} - combination of type of var to set (low 8 bits), and flags to
    control the behavior of this routine.Currently defined flags include:
      @{b}GVF_LOCAL_ONLY@{ub} - set a local (to your process) variable.
      @{b}GVF_GLOBAL_ONLY@{ub} - set a global environment variable.
    The default is to set a local environment variable.
  @{i}@{b}success@{ub}@{ui} - If non-zero, the variable was sucessfully set,
    FALSE indicates failure.
BUGS
  LV_VAR is the only type that can be global.
SEE ALSO
  @{"GetVar()" Link "GetVar()"}, @{"DeleteVar()" Link "DeleteVar()"}, @{"FindVar()" Link "FindVar()"}, @{"<dos/var.h>" Link "include:dos/var.h/Main" 0}
@EndNode
@Node "SetVBuf()" "dos.library/SetVBuf"
@{b}@{u}SetVBuf@{uu}@{ub} -- set buffering modes and size.(V39)
  Changes the buffering modes and buffer size for a filehandle.
  With buff == NULL, the current buffer will be deallocated and a
  new one of (approximately) size will be allocated.If buffer is
  non-NULL, it will be used for buffering and must be at least
  max(size,208) bytes long, and @{b}MUST@{ub} be longword aligned.If size
  is -1, then only the buffering mode will be changed.
  Note that a user-supplied buffer will not be freed if it is later
  replaced by another SetVBuf() call, nor will it be freed if the
  filehandle is closed.
  Has no effect on the buffersize of filehandles that were not created
  by @{"AllocDosObject()" Link "AllocDosObject()"}.
SYNOPSIS  @{FG shine}long@{FG text} SetVBuf(BPTR, STRPTR, @{FG shine}long@{FG text}, @{FG shine}long@{FG text})
  @{i}@{b}error@{ub}@{ui} = SetVBuf(@{i}fh@{ui}, @{i}buff@{ui}, @{i}type@{ui}, @{i}size@{ui})
   D0              D1  D2     D3    D4
  @{i}fh@{ui} - Filehandle
  @{i}buff@{ui} - buffer pointer for buffered I/O or NULL.@{b}MUST@{ub} be long-aligned!
  @{i}type@{ui} - buffering mode (see @{"<dos/stdio.h>" Link "include:dos/stdio.h/Main" 0})
  @{i}size@{ui} - size of buffer for buffered I/O
    (sizes less than 208 bytes will be rounded up to 208), or -1.
  @{i}@{b}error@{ub}@{ui} - 0 if successful.
    @{i}NOTE@{ui}:opposite of most dos functions!
    @{i}NOTE@{ui}:fails if someone has replaced the buffer without using SetVBuf() -
    @{"RunCommand()" Link "RunCommand()"} does this.Remember to
    check error before freeing user-supplied buffers!
BUGS
  Not implemented until after V39.From V36 up to V39, always returned 0.
SEE ALSO
  FputC(), @{"FGetC()" Link "FGetC()"}, @{"UnGetC()" Link "UnGetC()"}, @{"Flush()" Link "Flush()"}, @{"FRead()" Link "FRead()"}, @{"FWrite()" Link "FWrite()"}, @{"FGets()" Link "FGets()"},
  @{"FPuts()" Link "FPuts()"}, @{"AllocDosObject()" Link "AllocDosObject()"}
@EndNode
@Node "SplitName()" "dos.library/SplitName"
@{b}@{u}SplitName@{uu}@{ub} -- splits out a component of a pathname into a buffer.(V36)
  This routine splits out the next piece of a name from a given file name.
  Each piece is copied into the buffer, truncating at size-1 characters.
  The new position is then returned so that it may be passed in to the next
  call to splitname.If the separator is not found within 'size' characters,
  then size-1 characters plus a null will be put into the buffer,
  and the position of the next separator will be returned.
  If a a separator cannot be found, -1 is returned (but the characters
  from the old position to the end of the string are copied into the buffer,
  up to a maximum of size-1 characters).Both strings are null-terminated.
  This function is mainly intended to support handlers.
SYNOPSIS  WORD SplitName(STRPTR, UBYTE, STRPTR, WORD, @{FG shine}long@{FG text})
  @{i}@{b}newpos@{ub}@{ui} = SplitName(@{i}name@{ui}, @{i}separator@{ui}, @{i}buf@{ui}, @{i}oldpos@{ui}, @{i}size@{ui})
   D0                 D1    D2          D3   D4      D5
  @{i}name@{ui} - Filename being parsed.
  @{i}separator@{ui} - Separator charactor to split by.
  @{i}buf@{ui} - Buffer to hold separated name.
  @{i}oldpos@{ui} - Current position in the file.
  @{i}size@{ui} - Size of buf in bytes (including null termination).
  @{i}@{b}newpos@{ub}@{ui} - New position for next call to splitname.-1 for last one.
BUGS
  In V36 and V37, path portions greater than or equal to 'size' caused
  the last character of the portion to be lost when followed by a
  separator.Fixed for V39 dos.For V36 and V37, the suggested work-
  around is to call SplitName() with a buffer one larger than normal
  (for example, 32 bytes), and then set buf[size-2] to '0' (for example,
  buf[30] = '\0';).
SEE ALSO
  @{"FilePart()" Link "FilePart()"}, @{"PathPart()" Link "PathPart()"}, @{"AddPart()" Link "AddPart()"}
@EndNode
@Node "StartNotify()" "dos.library/StartNotify"
@{b}@{u}StartNotify@{uu}@{ub} -- Starts notification on a file or directory.(V36)
  Posts a notification request.Do not modify the notify structure while
  it is active.You will be notified when the file or directory changes.
  For files, you will be notified after the file is closed.Not all
  filesystems will support this: applications should @{b}NOT@{ub} require it.In
  particular, most network filesystems won't support it.
SYNOPSIS  BOOL StartNotify(@{FG shine}struct@{FG text} @{"NotifyRequest" Link "include:dos/notify.h/Main" 51} *)
  @{i}@{b}success@{ub}@{ui} = StartNotify(@{i}notifystructure@{ui})
   D0                    D1
  @{i}notifystructure@{ui} - A filled-in @{"NotifyRequest" Link "include:dos/notify.h/Main" 51} structure
  @{i}@{b}success@{ub}@{ui} - Success/failure of request
BUGS
  The V36 floppy/HD filesystem doesn't actually send notifications.The
  V36 ram handler (ram:) does.This has been fixed for V37.
SEE ALSO
  @{"EndNotify()" Link "EndNotify()"}, @{"<dos/notify.h>" Link "include:dos/notify.h/Main" 0}
@EndNode
@Node "StrToDate()" "dos.library/StrToDate"
@{b}@{u}StrToDate@{uu}@{ub} -- Converts a string to a @{"DateStamp" Link "include:dos/dos.h/Main" 52}.(V36)
  Converts a human readable ASCII string into an AmigaDOS DateStamp.
SYNOPSIS  BOOL StrToDate( @{FG shine}struct@{FG text} @{"DateTime" Link "include:dos/datetime.h/Main" 25} * )
  @{i}@{b}success@{ub}@{ui} = StrToDate( @{i}datetime@{ui} )
   D0                   D1
  @{i}DateTime@{ui} - a pointer to an initialized @{"DateTime" Link "include:dos/datetime.h/Main" 25} structure.
  The DateTime structure should be initialized as follows:
    @{i}dat_Stamp@{ui} - ignored on input.
    @{i}dat_Format@{ui} - a format byte which specifies the format of the dat_StrDat.
      This can be any of the following (@{i}note@{ui}:If value used is something
      other than those below,the default of FORMAT_DOS is used):
        FORMAT_DOS:   AmigaDOS format (dd-mmm-yy).
        FORMAT_INT:   International format (yy-mmm-dd).
        FORMAT_USA:   American format (mm-dd-yy).
        FORMAT_CDN:   Canadian format (dd-mm-yy).
        FORMAT_DEF:   default format for locale.
    @{i}dat_Flags@{ui} - a flags byte.The only flag which affects this function is:
      @{b}DTF_SUBST@{ub}:ignored by this function
      @{b}DTF_FUTURE@{ub}:If set, indicates that strings such as "Monday"
        (stored in dat_StrDate) refer to "next" monday.Otherwise,
        if clear, strings like "Monday" refer to "last" monday.
    @{i}dat_StrDay@{ui} - ignored bythis function.
    @{i}dat_StrDate@{ui} - pointer to valid string representing the date.
      This can be a "DTF_SUBST" style string such as "Today" "Tomorrow" "Monday",
      or it may be a string as specified by the dat_Format byte.This will be
      converted to the ds_Days portion of the DateStamp.
      If this pointer is NULL, DateStamp->ds_Days will not be affected.
    @{i}dat_StrTime@{ui} - Pointer to a buffer which contains the time in
      the ASCII format hh:mm:ss.This will be converted
      to the ds_Minutes and ds_Ticks portions of the DateStamp.
      If this pointer is NULL, ds_Minutes and ds_Ticks will be unchanged.
  @{i}@{b}success@{ub}@{ui} - a zero return indicates that a conversion could not be performed.
    A non-zero return indicates that the DateTime.dat_Stamp variable contains
    the converted values.
SEE ALSO
  @{"DateStamp()" Link "DateStamp()"}, @{"DateToStr()" Link "DateToStr()"}, @{"<dos/datetime.h>" Link "include:dos/datetime.h/Main" 0}
@EndNode
@Node "StrToLong()" "dos.library/StrToLong"
@{b}@{u}StrToLong@{uu}@{ub} -- string to long value (decimal).(V36)
  Converts decimal string into long value.Returns number of characters
  converted.Skips over leading spaces & tabs (included in count).If
  no decimal digits are found (after skipping leading spaces & tabs),
  StrToLong returns -1 for characters converted, and puts 0 into value.
SYNOPSIS  @{FG shine}long@{FG text} StrToLong(STRPTR, @{FG shine}long@{FG text} *)
  @{i}@{b}characters@{ub}@{ui} = StrToLong(@{i}string@{ui},@{i}value@{ui})
   D0                     D1      D2
  @{i}string@{ui} - Input string.
  @{i}value@{ui} - Pointer to long value.Set to 0 if no digits are converted.
  @{i}@{b}result@{ub}@{ui} - Number of characters converted or -1.
BUGS
  Before V39, if there were no convertible characters it returned the
  number of leading white-space characters (space and tab in this case).
@EndNode
@Node "SystemTagList()" "dos.library/SystemTagList"
@{b}@{u}SystemTagList@{uu}@{ub} -- Have a shell execute a command line.(V36)
  Similar to @{"Execute()" Link "Execute()"}, but does not read commands from the input
  filehandle.Spawns a Shell process to execute the command, and
  returns the returncode the command produced, or -1 if the command
  could not be run for any reason.The input and output filehandles
  will not be closed by System, you must close them (if needed) after
  System returns, if you specified them via SYS_Input or SYS_Output.
  By default the new process will use your current @{"Input()" Link "Input()"} and @{"Output()" Link "Output()"}
  filehandles.Normal Shell command-line parsing will be done
  including redirection on 'command'.The current directory and path
  will be inherited from your process.Your path will be used to find
  the command (if no path is specified).
  Note that you may @{b}NOT@{ub} pass the same filehandle for both SYS_Input
  and SYS_Output.If you want input and output to both be to the same
  CON: window, pass a SYS_Input of a filehandle on the CON: window,
  and pass a SYS_Output of NULL.The shell will automatically set
  the default @{"Output()" Link "Output()"} stream to the window you passed via SYS_Input,
  by opening "*" on that handler.
  If used with the SYS_Asynch flag, it @{b}WILL@{ub} close both it's input and
  output filehandles after running the command (even if these were
  your @{"Input()" Link "Input()"} and Output()!)
  Normally uses the boot (ROM) shell, but other shells can be specified
  via SYS_UserShell and SYS_CustomShell.Normally, you should send
  things written by the user to the UserShell.The UserShell defaults
  to the same shell as the boot shell.
  The tags are passed through to @{"CreateNewProc()" Link "CreateNewProc()"} (tags that conflict
  with SystemTagList() will be filtered out).This allows setting
  things like priority, etc for the new process.
  @{b}@{u}The tags that are currently filtered out are@{uu}@{ub}:
    NP_Seglist
    NP_FreeSeglist
    NP_Entry
    NP_Input
    NP_Output
    NP_CloseInput
    NP_CloseOutput
    NP_HomeDir
    NP_Cli
SYNOPSIS
  @{FG shine}long@{FG text} SystemTagList(STRPTR, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *)
  @{FG shine}long@{FG text} System(STRPTR, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *)
  @{FG shine}long@{FG text} SystemTags(STRPTR, ULONG, ...)
  @{i}@{b}error@{ub}@{ui} = SystemTagList(@{i}command@{ui}, @{i}tags@{ui})
   D0                    D1       D2
  @{i}@{b}error@{ub}@{ui} = System(@{i}command@{ui}, @{i}tags@{ui})
   D0             D1       D2
  @{i}@{b}error@{ub}@{ui} = SystemTags(@{i}command@{ui}, @{i}Tag1@{ui}, ...)
  @{i}command@{ui} - Program and arguments
  @{i}tags@{ui} - see @{"<dos/dostags.h>" Link "include:dos/dostags.h/Main" 0}.Note that both SystemTagList()-
    specific tags and tags from @{"CreateNewProc()" Link "CreateNewProc()"} may be passed.
  @{i}@{b}error@{ub}@{ui} - 0 for success, result from command, or -1.
    Note that on error, the caller is responsible for any filehandles
    or other things passed in via tags.-1 will only be returned if
    dos could not create the new shell.If the command is not found
    the shell will return an error value, normally RETURN_ERROR.
SEE ALSO
  @{"Execute()" Link "Execute()"}, @{"CreateNewProc()" Link "CreateNewProc()"}, @{"<dos/dostags.h>" Link "include:dos/dostags.h/Main" 0}, @{"Input()" Link "Input()"}, @{"Output()" Link "Output()"}
@EndNode
@Node "UnGetC()" "dos.library/UnGetC"
@{b}@{u}UnGetC@{uu}@{ub} -- Makes a char available for reading again.(buffered).(V36)
  Pushes the character specified back into the input buffer.Every time
  you use a buffered read routine, you can always push back 1 character.
  You may be able to push back more, though it is not recommended, since
  there is no guarantee on how many can be pushed back at a given moment.
  Passing -1 for the character will cause the last character read to
  be pushed back.If the last character read was an EOF, the next
  character read will be an EOF.
  @{i}Note@{ui}: UnGetC can be used to make sure that a filehandle is set up
  as a read filehandle.This is only of importance if you are writing
  a shell, and must manipulate the filehandle's buffer.
SYNOPSIS  @{FG shine}long@{FG text} UnGetC(BPTR, @{FG shine}long@{FG text})
  @{i}@{b}value@{ub}@{ui} = UnGetC(@{i}fh@{ui}, @{i}character@{ui})
   D0             D1  D2
  @{i}fh@{ui} - filehandle to use for buffered I/O
  @{i}character@{ui} - character to push back or -1
  @{i}@{b}value@{ub}@{ui} - character pushed back, or
    FALSE if the character cannot be pushed back.
BUGS
  In V36, UnGetC(fh,-1) after an EOF would not cause the next character
  read to be an EOF.This was fixed for V37.
SEE ALSO
  @{"FGetC()" Link "FGetC()"}, @{"FPutC()" Link "FPutC()"}, @{"Flush()" Link "Flush()"}
@EndNode
@Node "UnLoadSeg()" "dos.library/UnLoadSeg"
@{b}@{u}UnLoadSeg@{uu}@{ub} -- Unload a seglist previously loaded by @{"LoadSeg()" Link "LoadSeg()"}
  Unload a seglist loaded by @{"LoadSeg()" Link "LoadSeg()"}.'seglist' may be zero.
  Overlaid segments will have all needed cleanup done, including closing files.
SYNOPSIS  BOOL UnLoadSeg(BPTR)
  @{i}@{b}success@{ub}@{ui} = UnLoadSeg( @{i}seglist@{ui} )
   D0                   D1
  @{i}seglist@{ui} - BCPL pointer to a segment identifier
  @{i}@{b}success@{ub}@{ui} - returns 0 if a NULL seglist was passed or if it failed to close
    an overlay file.
    @{i}NOTE@{ui}: this function returned a random value before V36!
SEE ALSO
  @{"LoadSeg()" Link "LoadSeg()"}, @{"InternalLoadSeg()" Link "InternalLoadSeg()"}, @{"InternalUnLoadSeg()" Link "InternalUnLoadSeg()"}
@EndNode
@Node "UnLock()" "dos.library/UnLock"
@{b}@{u}UnLock@{uu}@{ub} -- Unlock a directory or file.
  The filing system lock (obtained from @{"Lock()" Link "Lock()"}, @{"DupLock()" Link "DupLock()"}, or
  @{"CreateDir()" Link "CreateDir()"}) is removed and deallocated.
SYNOPSIS  @{FG shine}void@{FG text} UnLock(BPTR)
  UnLock( @{i}lock@{ui} )
           D1
  @{i}lock@{ui} - BCPL pointer to a lock
NOTE
  Passing zero to UnLock() is harmless.
SEE ALSO
  @{"Lock()" Link "Lock()"}, @{"DupLock()" Link "DupLock()"}, @{"ParentOfFH()" Link "ParentOfFH()"}, @{"DupLockFromFH()" Link "DupLockFromFH()"}
@EndNode
@Node "UnLockDosList()" "dos.library/UnLockDosList"
@{b}@{u}UnLockDosList@{uu}@{ub} -- Unlocks the Dos @{"List" Link "include:exec/lists.h/Main" 20}.(V36)
  Unlocks the access on the Dos @{"Device" Link "include:exec/devices.h/Main" 25} @{"List" Link "include:exec/lists.h/Main" 20}.You @{b}MUST@{ub} pass the same
  flags you used to lock the list.
SYNOPSIS  @{FG shine}void@{FG text} UnLockDosList(ULONG)
  UnLockDosList(@{i}flags@{ui})
                 D1
  @{i}flags@{ui} - @{b}MUST@{ub} be the same flags passed to (Attempt)LockDosList()
SEE ALSO
  @{"AttemptLockDosList()" Link "AttemptLockDosList()"}, @{"LockDosList()" Link "LockDosList()"}, @{"Permit()" Link "exec.guide/Permit()"}
@EndNode
@Node "UnLockRecord()" "dos.library/UnLockRecord"
@{b}@{u}UnLockRecord@{uu}@{ub} -- Unlock a record.(V36)
  This releases the specified lock on a file.Note that you must use
  the same filehandle you used to lock the record, and offset and length
  must be the same values used to lock it.Every @{"LockRecord()" Link "LockRecord()"} call must
  be balanced with an UnLockRecord() call.
SYNOPSIS  BOOL UnLockRecord(BPTR,ULONG,ULONG)
  @{i}@{b}success@{ub}@{ui} = UnLockRecord(@{i}fh@{ui},@{i}offset@{ui},@{i}length@{ui})
   D0                     D1 D2      D3
  @{i}fh@{ui} - File handle of locked file
  @{i}offset@{ui} - Record start position
  @{i}length@{ui} - Length of record in bytes
  @{i}@{b}success@{ub}@{ui} - Success or failure.
BUGS
  See @{"LockRecord()" Link "LockRecord()"}
SEE ALSO
  @{"LockRecords()" Link "LockRecords()"}, @{"LockRecord()" Link "LockRecord()"}, @{"UnLockRecords()" Link "UnLockRecords()"}
@EndNode
@Node "UnLockRecords()" "dos.library/UnLockRecords"
@{b}@{u}UnLockRecords@{uu}@{ub} -- Unlock a list of records.(V36)
  This releases an array of record locks obtained using @{"LockRecords" Link "LockRecords()"}.
  You should @{b}NOT@{ub} modify the record_array while you have the records
  locked.Every @{"LockRecords()" Link "LockRecords()"} call must be balanced with an
  UnLockRecords() call.
SYNOPSIS  BOOL UnLockRecords(@{FG shine}struct@{FG text} @{"RecordLock" Link "include:dos/record.h/Main" 28} *)
  @{i}@{b}success@{ub}@{ui} = UnLockRecords(@{i}record_array@{ui})
   D0                      D1
  @{i}record_array@{ui} - @{"List" Link "include:exec/lists.h/Main" 20} of records to be unlocked
  @{i}@{b}success@{ub}@{ui} - Success or failure.
BUGS
  See @{"LockRecord()" Link "LockRecord()"}
SEE ALSO
  @{"LockRecords()" Link "LockRecords()"}, @{"LockRecord()" Link "LockRecord()"}, @{"UnLockRecord()" Link "UnLockRecord()"}
@EndNode
@Node "VFPrintf()" "dos.library/VFPrintf"
@{b}@{u}VFPrintf@{uu}@{ub} -- format and print a string to a file (buffered).(V36)
  Writes the formatted string and values to the given file.This
  routine is assumed to handle all internal buffering so that the
  formatting string and resultant formatted values can be arbitrarily long.
  Any secondary error code is returned in @{"IoErr()" Link "IoErr()"}.This routine is buffered.
SYNOPSIS
  @{FG shine}long@{FG text} VFPrintf(BPTR, STRPTR, @{FG shine}long@{FG text} *)
  @{FG shine}long@{FG text} FPrintf(BPTR, STRPTR, ...)
  @{i}@{b}count@{ub}@{ui} = VFPrintf(@{i}fh@{ui}, @{i}fmt@{ui}, @{i}argv@{ui})
   D0               D1  D2    D3
  @{i}@{b}count@{ub}@{ui} = FPrintf(@{i}fh@{ui}, @{i}fmt@{ui}, ...)
  @{i}fh@{ui} - Filehandle to write to
  @{i}fmt@{ui} - @{"RawDoFmt()" Link "exec.guide/RawDoFmt()"} style formatting string
  @{i}argv@{ui} - Pointer to array of formatting values
  @{i}@{b}count@{ub}@{ui} - Number of bytes written or -1 (EOF) for an error
BUGS
  The prototype for FPrintf() currently forces you to cast the first
  varargs parameter to long due to a deficiency in the program
  that generates fds, prototypes, and amiga.lib stubs.
SEE ALSO
  @{"VPrintf()" Link "VPrintf()"}, @{"VFWritef()" Link "VFWritef()"}, @{"RawDoFmt()" Link "exec.guide/RawDoFmt()"}, @{"FPutC()" Link "FPutC()"}
@EndNode
@Node "VFWritef()" "dos.library/VFWritef"
@{b}@{u}VFWritef@{uu}@{ub} - write a BCPL formatted string to a file (buffered).(V36)
  Writes the formatted string and values to the specified file.This
  routine is assumed to handle all internal buffering so that the
  formatting string and resultant formatted values can be arbitrarily
  long.The formats are in BCPL form.This routine is buffered.
  @{b}@{u}Supported formats are@{uu}@{ub}: (@{b}Note x is in base 36@{ub}!)
    %S  - string (CSTR)
    %Tx - writes a left-justified string in a field at least x bytes long.
    %C  - writes a single character
    %Ox - writes a number in octal, maximum x characters wide
    %Xx - writes a number in hex, maximum x characters wide
    %Ix - writes a number in decimal, maximum x characters wide
    %N  - writes a number in decimal, any length
    %Ux - writes an unsigned number, maximum x characters wide
    %$  - ignore parameter
  @{i}Note@{ui}: 'x' above is actually the character value - '0'.
SYNOPSIS
  @{FG shine}long@{FG text} VFWritef(BPTR, STRPTR, @{FG shine}long@{FG text} *)
  @{FG shine}long@{FG text} FWritef(BPTR, STRPTR, ...)
  @{i}@{b}count@{ub}@{ui} = VFWritef(@{i}fh@{ui}, @{i}fmt@{ui}, @{i}argv@{ui})
   D0               D1  D2    D3
  @{i}@{b}count@{ub}@{ui} = FWritef(@{i}fh@{ui}, @{i}fmt@{ui}, ...)
  @{i}fh@{ui} - filehandle to write to
  @{i}fmt@{ui} - BCPL style formatting string
  @{i}argv@{ui} - Pointer to array of formatting values
  @{i}@{b}count@{ub}@{ui} - Number of bytes written or -1 for error
BUGS
  As of V37, VFWritef() does @{b}NOT@{ub} return a valid return value.In
  order to reduce possible errors, the prototypes supplied for the
  system as of V37 have it typed as void.
SEE ALSO
  @{"VFPrintf()" Link "VFPrintf()"}, @{"VFPrintf()" Link "VFPrintf()"}, @{"FPutC()" Link "FPutC()"}
@EndNode
@Node "VPrintf()" "dos.library/VPrintf"
@{b}@{u}VPrintf@{uu}@{ub} -- format and print string (buffered).(V36)
  Writes the formatted string and values to @{"Output()" Link "Output()"}.This routine is
  assumed to handle all internal buffering so that the formatting string
  and resultant formatted values can be arbitrarily long.Any secondary
  error code is returned in @{"IoErr()" Link "IoErr()"}.This routine is buffered.
  @{i}Note@{ui}: @{"RawDoFmt" Link "exec.guide/RawDoFmt()"} assumes 16 bit ints, so you will usually need 'l's in
  your formats (ex: %ld versus %d).
SYNOPSIS
  @{FG shine}long@{FG text} VPrintf(STRPTR, @{FG shine}long@{FG text} *)
  @{FG shine}long@{FG text} Printf(STRPTR, ...)
  @{i}@{b}count@{ub}@{ui} = VPrintf(@{i}fmt@{ui}, @{i}argv@{ui})
   D0              D1   D2
  @{i}@{b}count@{ub}@{ui} = Printf(@{i}fmt@{ui}, ...)
  @{i}fmt@{ui} - exec.library @{"RawDoFmt()" Link "exec.guide/RawDoFmt()"} style formatting string
  @{i}argv@{ui} - Pointer to array of formatting values
  @{i}@{b}count@{ub}@{ui} - Number of bytes written or -1 (EOF) for an error
BUGS
  The prototype for Printf() currently forces you to cast the first
  varargs parameter to long due to a deficiency in the program
  that generates fds, prototypes, and amiga.lib stubs.
SEE ALSO
  @{"VFPrintf()" Link "VFPrintf()"}, @{"VFWritef()" Link "VFWritef()"}, @{"RawDoFmt()" Link "exec.guide/RawDoFmt()"}, @{"FPutC()" Link "FPutC()"}
@EndNode
@Node "WaitForChar()" "dos.library/WaitForChar"
@{b}@{u}WaitForChar@{uu}@{ub} -- Determine if chars arrive within a time limit.
  If a character is available to be read from 'file' within the
  time (in microseconds) indicated by 'timeout', WaitForChar()
  returns -1 (TRUE).If a character is available, you can use @{"Read()" Link "Read()"}
  to read it.Note that WaitForChar() is only valid when the I/O
  stream is connected to a virtual terminal device.If a character is
  not available within 'timeout', a 0 (FALSE) is returned.
SYNOPSIS  BOOL WaitForChar(BPTR, @{FG shine}long@{FG text})
  @{i}@{b}status@{ub}@{ui} = WaitForChar( @{i}file@{ui}, @{i}timeout@{ui} )
   D0                    D1    D2
  @{i}file@{ui} - BCPL pointer to a file handle
  @{i}timeout@{ui} - integer
  @{i}@{b}status@{ub}@{ui} - boolean
BUGS
  Due to a bug in the timer.device in V1.2/V1.3, specifying a timeout of zero
  for WaitForChar() can cause the unreliable timer & floppy disk operation.
SEE ALSO
  @{"Read()" Link "Read()"}, @{"FGetC()" Link "FGetC()"}
@EndNode
@Node "WaitPkt()" "dos.library/WaitPkt"
@{b}@{u}WaitPkt@{uu}@{ub} -- Waits for a packet to arrive at your pr_MsgPort.(V36)
  Waits for a packet to arrive at your pr_MsgPort.If anyone has
  installed a packet wait function in pr_PktWait, it will be called.
  The message will be automatically GetMsg()ed so that it is no longer
  on the port.It assumes the message is a dos packet.It is @{b}NOT@{ub}
  guaranteed to clear the signal for the port.
SYNOPSIS  @{FG shine}struct@{FG text} @{"DosPacket" Link "include:dos/dosextens.h/Main" 108} *WaitPkt(@{FG shine}void@{FG text});
  @{i}@{b}packet@{ub}@{ui} = WaitPkt()
   D0
  @{i}@{b}packet@{ub}@{ui} - the packet that arrived at the port (from ln_Name of message).
SEE ALSO
  @{"SendPkt()" Link "SendPkt()"}, @{"DoPkt()" Link "DoPkt()"}, @{"AbortPkt()" Link "AbortPkt()"}
@EndNode
@Node "Write()" "dos.library/Write"
@{b}@{u}Write@{uu}@{ub} -- Write bytes of data to a file.
  Write() writes bytes of data to the opened file 'file'.'length'
  indicates the length of data to be transferred; 'buffer' is a
  pointer to the buffer.The value returned is the length of
  information actually written.So, when 'length' is greater than
  zero, the value of 'length' is the number of characters written.
  Errors are indicated by a value of -1.
  @{i}Note@{ui}: this is an unbuffered routine (the request is passed directly
  to the filesystem.)  Buffered I/O is more efficient for small
  reads and writes; see @{"FPutC()" Link "FPutC()"}.
SYNOPSIS  @{FG shine}long@{FG text} Write (BPTR, @{FG shine}void@{FG text} *, @{FG shine}long@{FG text})
  @{i}@{b}returnedLength@{ub}@{ui} =  Write( @{i}file@{ui}, @{i}buffer@{ui}, @{i}length@{ui} )
   D0                       D1    D2       D3
  @{i}file@{ui} - BCPL pointer to a file handle
  @{i}buffer@{ui} - pointer to the buffer
  @{i}length@{ui} - integer
  @{i}@{b}returnedLength@{ub}@{ui} - integer
SEE ALSO
  @{"Read()" Link "Read()"}, @{"Seek()" Link "Seek()"}, @{"Open()" Link "Open()"}, @{"Close()" Link "Close()"}, @{"FPutC" Link "FPutC()"}
@EndNode
@Node "WriteChars()" "dos.library/WriteChars"
@{b}@{u}WriteChars@{uu}@{ub} -- Writes bytes to the the default output (buffered).(V36)
  This routine writes a number of bytes to the default output.The
  length is returned.This routine is buffered.
SYNOPSIS  @{FG shine}long@{FG text} WriteChars(STRPTR, @{FG shine}long@{FG text})
  @{i}@{b}count@{ub}@{ui} = WriteChars(@{i}buf@{ui}, @{i}buflen@{ui})
   D0                 D1    D2
  @{i}buf@{ui} - buffer of characters to write
  @{i}buflen@{ui} - number of characters to write
  @{i}@{b}count@{ub}@{ui} - Number of bytes written.-1 (EOF) indicates an error
SEE ALSO
  @{"FPuts()" Link "FPuts()"}, @{"FPutC()" Link "FPutC()"}, @{"FWrite()" Link "FWrite()"}, @{"PutStr()" Link "PutStr()"}
@EndNode

