@database "devices"
@Node Main "devices.guide"
@{b}@{u}Devices@{uu}@{ub}:
@{"Audio" link AUDIO}
@{"Clipboard" link CLIPBOARD}
@{"Console" link CONSOLE}
@{"Gameport" link GAMEPORT}
@{"Input" link INPUT}
@{"Keyboard" link KEYBOARD}
@{"Narrator" link NARRATOR}
@{"Parallel" link PARALLEL}
@{"Serial" link SERIAL}
@{"Timer" link TIMER}
@{"Trackdisk" link TRACKDISK}
@EndNode
@node AUDIO "audio.device"
@{"AbortIO()" Link "audio_AbortIO()"}
@{"ADCMD_ALLOCATE" Link "ADCMD_ALLOCATE"}
@{"ADCMD_FINISH" Link "ADCMD_FINISH"}
@{"ADCMD_FREE" Link "ADCMD_FREE"}
@{"ADCMD_LOCK" Link "ADCMD_LOCK"}
@{"ADCMD_PERVOL" Link "ADCMD_PERVOL"}
@{"ADCMD_SETPREC" Link "ADCMD_SETPREC"}
@{"ADCMD_WAITCYCLE" Link "ADCMD_WAITCYCLE"}
@{"BeginIO()" Link "audio_BeginIO()"}
@{"CloseDevice()" Link "audio_CloseDevice()"}
@{"CMD_CLEAR" Link "audio_CMD_CLEAR"}
@{"CMD_FLUSH" Link "audio_CMD_FLUSH"}
@{"CMD_READ" Link "audio_CMD_READ"}
@{"CMD_RESET" Link "audio_CMD_RESET"}
@{"CMD_START" Link "audio_CMD_START"}
@{"CMD_STOP" Link "audio_CMD_STOP"}
@{"CMD_UPDATE" Link "audio_CMD_UPDATE"}
@{"CMD_WRITE" Link "audio_CMD_WRITE"}
@{"Expunge()" Link "audio_Expunge()"}
@{"OpenDevice()" Link "audio_OpenDevice()"}
@endnode
@node CLIPBOARD "clipboard.device"
@{"CBD_CHANGEHOOK" Link "CBD_CHANGEHOOK"}
@{"CBD_CURRENTREADID" Link "CBD_CURRENTREADID"}
@{"CBD_CURRENTWRITEID" Link "CBD_CURRENTWRITEID"}
@{"CMD_WRITE" Link "CBD_CMD_WRITE"}
@{"CMD_READ" Link "CBD_CMD_READ"}
@{"CBD_POST" Link "CBD_POST"}
@{"CMD_UPDATE" Link "CBD_CMD_UPDATE"}
@endnode
@node CONSOLE "console.device"
@{"OpenDevice()" Link "console_OpenDevice()"}
@{"CDInputHandler()" Link "console_CDInputHandler()"}
@{"RawKeyConvert()" Link "console_RawKeyConvert()"}
@{"CD_SETDEFAULTKEYMAP" Link "console_CD_SETDEFAULTKEYMAP"}
@{"CD_ASKDEFAULTKEYMAP" Link "console_CD_ASKDEFAULTKEYMAP"}
@{"CD_SETKEYMAP" Link "console_CD_SETKEYMAP"}
@{"CD_ASKKEYMAP" Link "console_CD_ASKKEYMAP"}
@{"CMD_CLEAR" Link "console_CMD_CLEAR"}
@{"CMD_WRITE" Link "console_CMD_WRITE"}
@{"CMD_READ" Link "console_CMD_READ"}
@endnode
@node GAMEPORT "gameport.device"
@{"GPD_SETCTYPE" Link "GPD_SETCTYPE"}
@{"GPD_ASKCTYPE" Link "GPD_ASKCTYPE"}
@{"GPD_SETTRIGGER" Link "GPD_SETTRIGGER"}
@{"GPD_ASKTRIGGER" Link "GPD_ASKTRIGGER"}
@{"GPD_READEVENT" Link "GPD_READEVENT"}
@endnode
@node INPUT "input.device"
@{"IND_ADDHANDLER" Link "IND_ADDHANDLER"}
@{"IND_WRITEEVENT" Link "IND_WRITEEVENT"}
@{"IND_REMHANDLER" Link "IND_REMHANDLER"}
@{"IND_SETMPORT" Link "IND_SETMPORT"}
@{"IND_SETMTYPE" Link "IND_SETMTYPE"}
@{"IND_SETMTRIG" Link "IND_SETMTRIG"}
@{"IND_SETTHRESH" Link "IND_SETTHRESH"}
@{"IND_SETPERIOD" Link "IND_SETPERIOD"}
@{"PeekQualifier()" Link "PeekQualifier()"}
@endnode
@node KEYBOARD "keyboard.device"
@{"KBD_ADDRESETHANDLER" Link "KBD_ADDRESETHANDLER"}
@{"KBD_RESETHANDLERDONE" Link "KBD_RESETHANDLERDONE"}
@{"KBD_REMRESETHANDLER" Link "KBD_REMRESETHANDLER"}
@{"KBD_READMATRIX" Link "KBD_READMATRIX"}
@{"KBD_READEVENT" Link "KBD_READEVENT"}
@{"CMD_CLEAR" Link "KBD_CMD_CLEAR"}
@endnode
@node NARRATOR "narrator.device"
@{"OpenDevice()" Link "narrator_OpenDevice()"}
@{"AbortIO()" Link "narrator_AbortIO()"}
@{"CloseDevice()" Link "narrator_CloseDevice()"}
@{"CMD_START" Link "narrator_CMD_START"}
@{"CMD_WRITE" Link "narrator_CMD_WRITE"}
@{"CMD_READ" Link "narrator_CMD_READ"}
@{"CMD_FLUSH" Link "narrator_CMD_FLUSH"}
@{"CMD_RESET" Link "narrator_CMD_RESET"}
@{"CMD_STOP" Link "narrator_CMD_STOP"}
@endnode
@Node PARALLEL "parallel.device"
@{"CMD_CLEAR" Link "parallel_CMD_CLEAR"}
@{"CMD_FLUSH" Link "parallel_CMD_FLUSH"}
@{"CMD_READ" Link "parallel_CMD_READ"}
@{"CMD_RESET" Link "parallel_CMD_RESET"}
@{"CMD_START" Link "parallel_CMD_START"}
@{"CMD_STOP" Link "parallel_CMD_STOP"}
@{"CMD_WRITE" Link "parallel_CMD_WRITE"}
@{"OpenDevice()" Link "parallel_OpenDevice()"}
@{"PDCMD_QUERY" Link "PDCMD_QUERY"}
@{"PDCMD_SETPARAMS" Link "PDCMD_SETPARAMS"}
@EndNode
@node SERIAL "serial.device"
@{"SDCMD_SETPARAMS" Link "SDCMD_SETPARAMS"}
@{"SDCMD_QUERY" Link "SDCMD_QUERY"}
@{"SDCMD_BREAK" Link "SDCMD_BREAK"}
@{"OpenDevice()" Link "serial_OpenDevice()"}
@{"BeginIO()" Link "serial_BeginIO()"}
@{"AbortIO()" Link "serial_AbortIO()"}
@{"CloseDevice()" Link "serial_CloseDevice()"}
@{"CMD_CLEAR" Link "serial_CMD_CLEAR"}
@{"CMD_START" Link "serial_CMD_START"}
@{"CMD_WRITE" Link "serial_CMD_WRITE"}
@{"CMD_READ" Link "serial_CMD_READ"}
@{"CMD_FLUSH" Link "serial_CMD_FLUSH"}
@{"CMD_RESET" Link "serial_CMD_RESET"}
@{"CMD_STOP" Link "serial_CMD_STOP"}
@endnode
@node TIMER "timer.device"
@{"--background--" Link "--background--"}
@{"TR_SETSYSTIME" Link "TR_SETSYSTIME"}
@{"TR_GETSYSTIME" Link "TR_GETSYSTIME"}
@{"TR_ADDREQUEST" Link "TR_ADDREQUEST"}
@{"GetSysTime()" Link "GetSysTime()"}
@{"ReadEClock()" Link "ReadEClock()"}
@{"AddTime()" Link "AddTime()"}
@{"SubTime()" Link "SubTime()"}
@{"CmpTime()" Link "CmpTime()"}
@{"AbortIO()" Link "timer_AbortIO()"}
@endnode
@node TRACKDISK "trackdisk.device"
@{"TD_ADDCHANGEINT" Link "TD_ADDCHANGEINT"}
@{"TD_REMCHANGEINT" Link "TD_REMCHANGEINT"}
@{"TD_CHANGESTATE" Link "TD_CHANGESTATE"}
@{"TD_CHANGENUM" Link "TD_CHANGENUM"}
@{"TD_MOTOR" Link "TD_MOTOR"}
@{"TD_GETDRIVETYPE" Link "TD_GETDRIVETYPE"}
@{"TD_GETNUMTRACKS" Link "TD_GETNUMTRACKS"}
@{"TD_GETGEOMETRY" Link "TD_GETGEOMETRY"}
@{"TD_PROTSTATUS" Link "TD_PROTSTATUS"}
@{"TD_FORMAT" Link "TD_FORMAT"}
@{"TD_SEEK" Link "TD_SEEK"}
@{"TD_RAWREAD" Link "TD_RAWREAD"}
@{"TD_RAWWRITE" Link "TD_RAWWRITE"}
@{"TD_EJECT" Link "TD_EJECT"}
@{"CMD_CLEAR" Link "TD_CMD_CLEAR"}
@{"CMD_WRITE" Link "TD_CMD_WRITE"}
@{"CMD_READ" Link "TD_CMD_READ"}
@{"CMD_UPDATE" Link "TD_CMD_UPDATE"}
@endnode
@Node "audio_AbortIO()" "audio.device/AbortIO"
@{b}@{u}AbortIO@{uu}@{ub} - abort a device command.
  AbortIO tries to abort a device command.It is allowed to be
  unsuccessful.If the Abort is successful, the @{i}io_Error@{ui} field of the
  iORequest contains an indication that IO was aborted.
SYNOPSIS
  AbortIO(@{i}iORequest@{ui});
           A1
  @{i}iORequest@{ui} -- pointer to the I/O Request for the command to abort
@EndNode
@Node "ADCMD_ALLOCATE" "audio.device/ADCMD_ALLOCATE"
@{b}@{u}ADCMD_ALLOCATE@{uu}@{ub} -- allocate a set of audio channels.
  ADCMD_ALLOCATE is a command that allocates multiple audio channels.
  ADCMD_ALLOCATE takes an array of possible channel combinations
  (@{i}ioa_Data@{ui}) and an allocation precedence (@{i}ln_Pri@{ui}) and tries to allocate
  one of the combinations of channels.
  If the channel combination array is zero length (ioa_Length), the
  allocation succeeds; otherwise, ADCMD_ALLOCATE checks each combination,
  one at a time, in the specified order, to find one combination that does
  not require ADCMD_ALLOCATE to steal allocated channels.
  If it must steal allocated channels, it uses the channel combination
  that steals the lowest precedence channels.
  ADCMD_ALLOCATE cannot steal a channel of equal or greater precedence
  than the allocation precedence (@{i}ln_Pri@{ui}).
  If it fails to allocate any channel combination and the no-wait flag
  (@{i}ADIOF_NOWAIT@{ui}) is set ADCMD_ALLOCATE returns a zero in the unit field
  of the I/O request (@{i}io_Unit@{ui}) and an error (@{i}IOERR_ALLOCFAILED@{ui}).If the
  no-wait flag is clear, it places the I/O request in a list that tries
  to allocate again whenever @{"ADCMD_FREE" Link "ADCMD_FREE"} frees channels or @{"ADCMD_SETPREC" Link "ADCMD_SETPREC"}
  lowers the channels' precedences.
  If the allocation is successful, ADCMD_ALLOCATE checks if any channels
  are locked (@{i}ADCMD_LOCK@{ui}) and if so, replies (ReplyMsg) the lock I/O
  request with an error (@{i}ADIOERR_CHANNELSTOLEN@{ui}).Then it places the
  allocation I/O request in a list waiting for the locked channels to be
  freed.When all the allocated channels are un-locked, ADCMD_ALLOCATE:
  - resets (@{i}CMD_RESET@{ui}) the allocated channels,
  - generates a new allocation key (@{i}ioa_AllocKey@{ui}), if it is zero,
  - copies the allocation key into each of the allocated channels
  - copies the allocation precedence into each of the allocated channels, and
  - copies the channel bit map into the unit field of the I/O request.
  If channels are allocated with a non-zero allocation key,
  ADCMD_ALLOCATE allocates with that same key; otherwise, it generates a
  new and unique key.
  ADCMD_ALLOCATE is synchronous:
  - if the allocation succeeds and there are no locked channels to be stolen, or
  - if the allocation fails and the no-wait flag is set.
  In either case, ADCMD_ALLOCATE only replies (@{i}mn_ReplyPort@{ui}) if the quick flag
  (@{i}IOF_QUICK@{ui}) is clear; otherwise, the allocation is asynchronous, so it
  clears the quick flag and replies the I/O request after the allocation is
  finished.If channels are stolen, all audio device commands return an error
  (@{i}IOERR_NOALLOCATION@{ui}) when the former user tries to use them again.
  Do not use ADCMD_ALLOCATE in interrupt code.
  If you decide to store directly to the audio hardware registers, you
  must either lock the channels you've allocated, or set the precedence
  to maximum (@{i}ADALLOC_MAXPREC@{ui}) to prevent the channels from being stolen.
  Under all circumstances, unless channels are stolen, you must free
  (@{i}ADCMD_FREE@{ui}) all allocated channels when you are finished using them.
  @{i}ln_Pri@{ui} - allocation precedence (-128 thru 127)
  @{i}mn_ReplyPort@{ui} - pointer to message port that receives I/O request after the
    allocation completes is asynchronous or quick flag (@{i}ADIOF_QUICK@{ui}) is set
  @{i}io_Device@{ui} - pointer to device node, must be set by
    (or copied from I/O block set by) @{"OpenDevice" Link "audio_OpenDevice()"} function
  @{i}io_Command@{ui} - command number for ADCMD_ALLOCATE
  @{i}io_Flags@{ui} - flags, must be cleared if not used:
    @{b}IOF_QUICK@{ub} - (CLEAR) reply I/O request
      (SET) only reply I/O request only if asynchronous (see above text)
    @{b}ADIOF_NOWAIT@{ub} - (CLEAR) if allocation fails, wait till is succeeds
      (SET) if allocation fails, return error (@{i}ADIOERR_ALLOCFAILED@{ui})
  @{i}ioa_AllocKey@{ui} - allocation key, zero to generate new key; otherwise,
    it must be set by (or copied from I/O block set by) @{"OpenDevice" Link "audio_OpenDevice()"} function
    or previous ADCMD_ALLOCATE command
  @{i}ioa_Data@{ui} - pointer to channel combination options
    (byte array, bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}ioa_Length@{ui} - length of the channel combination option array
    (0 thru 16, 0 always succeeds)
  @{i}@{b}io_Unit@{ub}@{ui} - bit map of successfully allocated channels
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}@{b}io_Flags@{ub}@{ui} - @{i}IOF_QUICK@{ui} flag cleared if asynchronous (see above text)
  @{i}@{b}io_Error@{ub}@{ui} - error number:
    @{b}0@{ub} - no error
    @{b}ADIOERR_ALLOCFAILED@{ub} - allocation failed
  @{i}@{b}ioa_AllocKey@{ub}@{ui} - allocation key,
    set to a unique number if passed a zero and command succeeds
@EndNode
@Node "ADCMD_FINISH" "audio.device/ADCMD_FINISH"
@{b}@{u}ADCMD_FINISH@{uu}@{ub} -- abort writes in progress to audio channels.
  ADCMD_FINISH is a command for multiple audio channels.For each
  selected channel (@{i}io_Unit@{ui}), if the allocation key (@{i}ioa_AllocKey@{ui}) is
  correct and there is a write (@{i}CMD_WRITE@{ui}) in progress, ADCMD_FINISH
  aborts the current write immediately or at the end of the current
  cycle depending on the sync flag (@{i}ADIOF_SYNCCYCLE@{ui}).If the allocation
  key is incorrect ADCMD_FINISH returns an error (@{i}ADIOERR_NOALLOCATION@{ui}).
  ADCMD_FINISH is synchronous and only replies (@{i}mn_ReplyPort@{ui}) if the
  quick flag (@{i}IOF_QUICK@{ui}) is clear.Do not use ADCMD_FINISH in interrupt
  code at interrupt level 5 or higher.
  @{i}mn_ReplyPort@{ui} - pointer to message port that receives I/O request if the
    quick flag (@{i}IOF_QUICK@{ui}) is clear
  @{i}io_Device@{ui} - pointer to device node, must be set by
    (or copied from I/O block set by) @{"OpenDevice" Link "audio_OpenDevice()"} function
  @{i}io_Unit@{ui} - bit map of channels to finish
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}io_Command@{ui} - command number for ADCMD_FINISH
  @{i}io_Flags@{ui} - flags, must be cleared if not used:
    @{b}IOF_QUICK@{ub} - (CLEAR) reply I/O request
    @{b}ADIOF_SYNCCYCLE@{ub} - (CLEAR) finish immediately
      (SET) finish at the end of current cycle
  @{i}ioa_AllocKey@{ui} - allocation key, must be set by (or copied from I/O block set by)
    @{"OpenDevice" Link "audio_OpenDevice()"} function or @{"ADCMD_ALLOCATE" Link "ADCMD_ALLOCATE"} command
  @{i}@{b}io_Unit@{ub}@{ui} - bit map of channels successfully finished
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}@{b}io_Error@{ub}@{ui} - error number:
    @{b}0@{ub} - no error
    @{b}ADIOERR_NOALLOCATION@{ub} - allocation key (@{i}ioa_AllocKey@{ui})
     does not match key for channel
@EndNode
@Node "ADCMD_FREE" "audio.device/ADCMD_FREE"
@{b}@{u}ADCMD_FREE@{uu}@{ub} -- free audio channels for allocation.
  ADCMD_FREE is a command for multiple audio channels.For each selected channel
  (@{i}io_Unit@{ui}), if the allocation key (@{i}ioa_AllocKey@{ui}) is correct, ADCMD_FREE does
  the following:
  - restores the channel to a known state (@{i}CMD_RESET@{ui}),
  - changes the channels allocation key, and
  - makes the channel available for re-allocation.
  - If the channel is locked (ADCMD_LOCK) ADCMD_FREE unlocks it and clears
    the bit for the channel (@{i}io_Unit@{ui}) in the lock I/O request.
    If the lock I/O request has no channel bits set ADCMD_FREE replies the
    lock I/O request, and
  - checks if there are allocation requests (@{i}ADCMD_ALLOCATE@{ui}) waiting for
    the channel.
  Otherwise, ADCMD_FREE returns an error (@{i}ADIOERR_NOALLOCATION@{ui}).
  ADCMD_FREE is synchronous and only replies (@{i}mn_ReplyPort@{ui}) if the quick
  flag (@{i}IOF_QUICK@{ui}) is clear.Do not use ADCMD_FREE in interrupt code.
  @{i}mn_ReplyPort@{ui} - pointer to message port that receives I/O request
    if the quick flag (@{i}IOF_QUICK@{ui}) is clear
  @{i}io_Device@{ui} - pointer to device node, must be set by
    (or copied from I/O block set by) @{"OpenDevice" Link "audio_OpenDevice()"} function
  @{i}io_Unit@{ui} - bit map of channels to free
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}io_Command@{ui}  - command number for ADCMD_FREE
  @{i}io_Flags@{ui} - flags, must be cleared if not used:
    @{b}IOF_QUICK@{ub} - (CLEAR) reply I/O request
  @{i}ioa_AllocKey@{ui} - allocation key, must be set by (or copied from I/O block set by)
    @{"OpenDevice" Link "audio_OpenDevice()"} function or @{"ADCMD_ALLOCATE" Link "ADCMD_ALLOCATE"} command
  @{i}@{b}io_Unit@{ub}@{ui} - bit map of channels successfully freed
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}@{b}io_Error@{ub}@{ui} - error number:
    @{b}0@{ub} - no error
    @{b}ADIOERR_NOALLOCATION@{ub} - allocation key (@{i}ioa_AllocKey@{ui})
      does not match key for channel
@EndNode
@Node "ADCMD_LOCK" "audio.device/ADCMD_LOCK"
@{b}@{u}ADCMD_LOCK@{uu}@{ub} -- prevent audio channels from being stolen.
  ADCMD_LOCK is a command for multiple audio channels.For each selected channel
  (@{i}io_Unit@{ui}), if the allocation key (@{i}ioa_AllocKey@{ui}) is correct, ADCMD_LOCK locks
  the channel, preventing subsequent allocations (@{i}ADCMD_ALLOCATE@{ui} or OpenDevice)
  from stealing the channel.Otherwise, ADCMD_LOCK returns an error
  (@{i}ADIOERR_NOALLOCATION@{ui}) and will not lock any channels.
  Unlike setting the precedence (@{i}ADCMD_SETPREC@{ui}, @{"ADCMD_ALLOCATE" Link "ADCMD_ALLOCATE"} or OpenDevice)
  to maximum (@{i}ADALLOC_MAXPREC@{ui}) which would cause all subsequent allocations
  to fail, ADCMD_LOCK causes all higher precedence allocations, even no-wait
  (@{i}ADIOF_NOWAIT@{ui}) allocations, to wait until the channels are un-locked.
  Locked channels can only be unlocked by freeing them (@{i}ADCMD_FREE@{ui}),
  which clears the channel select bits (@{i}io_Unit@{ui}).ADCMD_LOCK does not
  reply the I/O request (@{i}mn_ReplyPort@{ui}) until all the channels it locks
  are freed, unless a higher precedence allocation attempts to steal one
  the locked channels.If a steal occurs, ADCMD_LOCK replies and returns
  an error (@{i}ADIOERR_CHANNELSTOLEN@{ui}).If the lock is replied (@{i}mn_ReplyPort@{ui})
  with this error, the channels should be freed as soon as possible.To
  avoid a possible deadlock, never make the freeing of stolen channels
  dependent on another allocations completion.
  ADCMD_LOCK is only asynchronous if the allocation key is correct, in
  which case it clears the quick flag (@{i}IOF_QUICK@{ui}); otherwise, it is
  synchronous and only replies if the quick flag (@{i}IOF_QUICK@{ui}) is clear.
  Do not use ADCMD_LOCK in interrupt code.
  @{i}mn_ReplyPort@{ui} - pointer to message port that receives I/O request
    if the quick flag (IOF_QUICK) is clear
  @{i}io_Device@{ui} - pointer to device node, must be set by
    (or copied from I/O block set by) @{"OpenDevice" Link "audio_OpenDevice()"} function
  @{i}io_Unit@{ui} - bit map of channels to lock
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}io_Command@{ui} - command number for ADCMD_LOCK
  @{i}io_Flags@{ui} - flags, must be cleared
  @{i}ioa_AllocKey@{ui} - allocation key, must be set by (or copied from I/O block set by)
    @{"OpenDevice" Link "audio_OpenDevice()"} function or @{"ADCMD_ALLOCATE" Link "ADCMD_ALLOCATE"} command
  @{i}@{b}io_Unit@{ub}@{ui} - bit map of successfully locked channels
    (bits 0 thru 3 correspond to channels 0 thru 3) not freed (@{i}ADCMD_FREE@{ui})
  @{i}@{b}io_Flags@{ub}@{ui} - @{b}IOF_QUICK@{ub} flag cleared if the allocation key is correct
    (no @{i}ADIOERR_NOALLOCATION@{ui} error)
  @{i}@{b}io_Error@{ub}@{ui} - error number:
    @{b}0@{ub} - no error
    @{b}ADIOERR_NOALLOCATION@{ub} - allocation key (@{i}ioa_AllocKey@{ui})
      does not match key for channel
    @{b}ADIOERR_CHANNELSTOLEN@{ub} - allocation attempting to steal locked channel
@EndNode
@Node "ADCMD_PERVOL" "audio.device/ADCMD_PERVOL"
@{b}@{u}ADCMD_PERVOL@{uu}@{ub} -- change the period and volume for writes in progress to audio
  channels.
  ADCMD_PERVOL is a command for multiple audio channels.For each selected
  channel (@{i}io_Unit@{ui}), if the allocation key (@{i}ioa_AllocKey@{ui}) is correct and
  there is a write (@{i}CMD_WRITE@{ui}) in progress, ADCMD_PERVOL loads a new volume
  and period immediately or at the end of the current cycle depending on the
  sync flag (@{i}ADIOF_SYNCCYCLE@{ui}).If the allocation key in incorrect, ADCMD_PERVOL
  returns an error (@{i}ADIOERR_NOALLOCATION@{ui}).
  ADCMD_PERVOL is synchronous and only replies (@{i}mn_ReplyPort@{ui}) if the quick
  flag (@{i}IOF_QUICK@{ui}) is clear.Do not use ADCMD_PERVOL in interrupt code at
  interrupt level 5 or higher.
  @{i}mn_ReplyPort@{ui} - pointer to message port that receives I/O request
    if the quick flag (IOF_QUICK) is clear
  @{i}io_Device@{ui} - pointer to device node, must be set by
    (or copied from I/O block set by) @{"OpenDevice" Link "audio_OpenDevice()"} function
  @{i}io_Unit@{ui} - bit map of channels to load period and volume
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}io_Command@{ui} - command number for ADCMD_PERVOL
  @{i}io_Flags@{ui} - flags, must be cleared if not used:
    @{b}IOF_QUICK@{ub} - (CLEAR) reply I/O request
    @{b}ADIOF_SYNCCYCLE@{ub} - (CLEAR) load period and volume immediately
     (SET) load period and volume at the end of the current cycle
  @{i}ioa_AllocKey@{ui} - allocation key, must be set by (or copied from I/O block set by)
    @{"OpenDevice" Link "audio_OpenDevice()"} function or @{"ADCMD_ALLOCATE" Link "ADCMD_ALLOCATE"} command
  @{i}ioa_Period@{ui} - new sample period in 279.365 ns increments (124 thru 65536,
    anti-aliasing filter works below 300 to 500 depending on waveform)
  @{i}ioa_Volume@{ui} - new volume (0 thru 64, linear)
  @{i}@{b}io_Unit@{ub}@{ui} - bit map of channels that successfully loaded period and volume
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}@{b}io_Error@{ub}@{ui} - error number:
    @{b}0@{ub} - no error
    @{b}ADIOERR_NOALLOCATION@{ub} - allocation key (@{i}ioa_AllocKey@{ui})
      does not match key for channel
@EndNode
@Node "ADCMD_SETPREC" "audio.device/ADCMD_SETPREC"
@{b}@{u}ADCMD_SETPREC@{uu}@{ub} -- set the allocation precedence for audio channels.
  ADCMD_SETPREC is a command for multiple audio channels.For each selected
  channel (@{i}io_Unit@{ui}), if the allocation key (@{i}ioa_AllocKey@{ui}) is correct,
  ADCMD_SETPREC sets the allocation precedence to a new value (@{i}ln_Pri@{ui})
  and checks if there are allocation requests (@{i}ADCMD_ALLOCATE@{ui}) waiting
  for the channel which now have higher precedence; otherwise,
  ADCMD_SETPREC returns an error (@{i}ADIOERR_NOALLOCATION@{ui}).ADCMD_SETPREC
  is synchronous and only replies (@{i}mn_ReplyPort@{ui}) if the quick flag
  (@{i}IOF_QUICK@{ui}) is clear.Do not use ADCMD_SETPREC in interrupt code.
  @{i}ln_Pri@{ui} - new allocation precedence (-128 thru 127)
  @{i}mn_ReplyPort@{ui} - pointer to message port that receives I/O request
    if the quick flag (@{i}IOF_QUICK@{ui}) is clear
  @{i}io_Device@{ui} - pointer to device node, must be set by
    (or copied from I/O block set by) @{"OpenDevice" Link "audio_OpenDevice()"} function
  @{i}io_Unit@{ui} - bit map of channels to set precedence
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}io_Command@{ui} - command number for ADCMD_SETPREC
  @{i}io_Flags@{ui} - flags, must be cleared if not used:
    @{b}IOF_QUICK@{ub} - (CLEAR) reply I/O request
  @{i}ioa_AllocKey@{ui}- allocation key, must be set by (or copied from I/O block set by)
    @{"OpenDevice" Link "audio_OpenDevice()"} function or @{"ADCMD_ALLOCATE" Link "ADCMD_ALLOCATE"} command
  @{i}@{b}io_Unit@{ub}@{ui} - bit map of channels that successfully set precedence
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}@{b}io_Error@{ub}@{ui} - error number:
    @{b}0@{ub} - no error
    @{b}ADIOERR_NOALLOCATION@{ub} - allocation key (@{i}ioa_AllocKey@{ui})
      does not match key for channel
@EndNode
@Node "ADCMD_WAITCYCLE" "audio.device/ADCMD_WAITCYCLE"
@{b}@{u}ADCMD_WAITCYCLE@{uu}@{ub} -- wait for an audio channel to complete the current cycle
  of a write.
  ADCMD_WAITCYCLE is a command for a single audio channel (@{i}io_Unit@{ui}).
  If the allocation key (@{i}ioa_AllocKey@{ui}) is correct and there is a write
  (@{i}CMD_WRITE@{ui}) in progress on selected channel, ADCMD_WAITCYCLE does not
  reply (@{i}mn_ReplyPort@{ui}) until the end of the current cycle.If there is
  no write is progress, ADCMD_WAITCYCLE replies immediately.If the
  allocation key is incorrect, ADCMD_WAITCYCLE returns an error
  (@{i}ADIOERR_NOALLOCATION@{ui}).ADCMD_WAITCYCLE returns an error
  (@{i}IOERR_ABORTED@{ui}) if it is canceled (AbortIO) or the channel is stolen
  (@{i}ADCMD_ALLOCATE@{ui}).ADCMD_WAITCYCLE is only asynchronous if it is
  waiting for a cycle to complete, in which case it clears the quick
  flag (@{i}IOF_QUICK@{ui}); otherwise, it is synchronous and only replies if the
  quick flag (@{i}IOF_QUICK@{ui}) is clear.Do not use @{i}ADCMD_WAITCYCLE@{ui} in
  interrupt code at interrupt level 5 or higher.
  @{i}mn_ReplyPort@{ui} - pointer to message port that receives I/O request,
    if the quick flag (@{i}IOF_QUICK@{ui}) is clear, or if a write is in
    progress on the selected channel and a cycle has completed
  @{i}io_Device@{ui} - pointer to device node, must be set by
    (or copied from I/O block set by) @{"OpenDevice" Link "audio_OpenDevice()"} function
  @{i}io_Unit@{ui} - bit map of channel to wait for cycle
    (bits 0 thru 3 correspond to channels 0 thru 3),
    if more than one bit is set lowest bit number channel is used
  @{i}io_Command@{ui} - command number for ADCMD_WAITCYCLE
  @{i}io_Flags@{ui} - flags, must be cleared if not used:
    @{b}IOF_QUICK@{ub} - (CLEAR) reply I/O request
      (SET) only reply I/O request if a write is in progress on the selected
        channel and a cycle has completed
  @{i}ioa_AllocKey@{ui} - allocation key, must be set by (or copied from I/O block set by)
    @{"OpenDevice" Link "audio_OpenDevice()"} function or @{"ADCMD_ALLOCATE" Link "ADCMD_ALLOCATE"} command
  @{i}@{b}io_Unit@{ub}@{ui} - bit map of channel that successfully waited for cycle
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}@{b}io_Flags@{ub}@{ui} - @{i}IOF_QUICK@{ui} flag cleared if a write is in progress on the
    selected channel
  @{i}@{b}io_Error@{ub}@{ui} - error number:
    @{b}0@{ub} - no error
    @{b}IOERR_ABORTED@{ub} - canceled (AbortIO) or channel stolen
    @{b}ADIOERR_NOALLOCATION@{ub} - allocation key (@{i}ioa_AllocKey@{ui})
      does not match key for channel
@EndNode
@Node "audio_BeginIO()" "audio.device/BeginIO"
@{b}@{u}BeginIO@{uu}@{ub} - dispatch a device command.
  BeginIO has the responsibility of dispatching all device commands.
  Immediate commands are always called directly, and all other commands
  are queued to make them single threaded.
SYNOPSIS
  BeginIO(@{i}iORequest@{ui});
           A1
  @{i}iORequest@{ui} -- pointer to the I/O Request for this command
@EndNode
@Node "audio_CloseDevice()" "audio.device/CloseDevice"
@{b}@{u}CloseDevice@{uu}@{ub} - terminate access to the audio device.
  The CloseDevice routine notifies the audio device that it will no longer
  be used.It takes an I/O audio request block (IOAudio) and clears the device
  pointer (@{i}io_Device@{ui}).If there are any channels allocated with the same
  allocation key (@{i}ioa_AllocKey@{ui}), CloseDevice frees (@{i}ADCMD_FREE@{ui}) them.
  CloseDevice decrements the open count, and if it falls to zero and
  an expunge (Expunge) is pending, the device is expunged.
SYNOPSIS
  CloseDevice(@{i}iORequest@{ui});
               A1
  @{i}iORequest@{ui} - pointer to audio request block (@{FG shine}struct@{FG text} @{"IOAudio" Link "include:devices/audio.h/Main" 30})
    @{b}io_Device@{ub} - pointer to device node, must be set by
      (or copied from I/O block set by) open (OpenDevice)
    @{b}io_Unit@{ub} - bit map of channels to free (@{i}ADCMD_FREE@{ui})
      (bits 0 thru 3 correspond to channels 0 thru 3)
    @{b}ioa_AllocKey@{ub}- allocation key, used to free channels
  @{i}@{b}iORequest@{ub}@{ui} - pointer to audio request block (@{FG shine}struct@{FG text} @{"IOAudio" Link "include:devices/audio.h/Main" 30})
    @{b}io_Device@{ub} - set to -1
    @{b}io_Unit@{ub} - set to zero
@EndNode
@Node "audio_CMD_CLEAR" "audio.device/CMD_CLEAR"
@{b}@{u}CMD_CLEAR@{uu}@{ub} -- throw away internal caches.
  CMD_CLEAR is a standard command for multiple audio channels.For each
  selected channel (@{i}io_Unit@{ui}), if the allocation key (@{i}ioa_AllocKey@{ui}) is
  correct, CMD_CLEAR does nothing; otherwise, CMD_CLEAR returns an error
  (@{i}ADIOERR_NOALLOCATION@{ui}).CMD_CLEAR is synchronous and only replies
  (@{i}mn_ReplyPort@{ui}) if the quick flag (@{i}IOF_QUICK@{ui}) is clear.
  @{i}mn_ReplyPort@{ui} - pointer to message port that receives I/O request after
    if the quick flag (@{i}IOF_QUICK@{ui}) is clear
  @{i}io_Device@{ui} - pointer to device node, must be set by
    (or copied from I/O block set by) @{"OpenDevice" Link "audio_OpenDevice()"} function
  @{i}io_Unit@{ui} - bit map of channels to clear
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}io_Command@{ui} - command number for CMD_CLEAR
  @{i}io_Flags@{ui} - flags, must be cleared if not used:
    @{b}IOF_QUICK@{ub} - (CLEAR) reply I/O request
  @{i}ioa_AllocKey@{ui} - allocation key, must be set by (or copied from I/O block set by)
    @{"OpenDevice" Link "audio_OpenDevice()"} function or @{"ADCMD_ALLOCATE" Link "ADCMD_ALLOCATE"} command
  @{i}@{b}io_Unit@{ub}@{ui} - bit map of channels successfully cleared #
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}@{b}io_Error@{ub}@{ui} - error number:
    @{b}0@{ub} - no error
    @{b}ADIOERR_NOALLOCATION@{ub} - allocation key (@{i}ioa_AllocKey@{ui})
      does not match key for channel
@EndNode
@Node "audio_CMD_FLUSH" "audio.device/CMD_FLUSH"
@{b}@{u}CMD_FLUSH@{uu}@{ub} -- cancel all pending I/O.
  CMD_FLUSH is a standard command for multiple audio channels.For each
  selected channel (@{i}io_Unit@{ui}), if the allocation key (@{i}ioa_AllocKey@{ui}) is
  correct, CMD_FLUSH aborts all writes (@{i}CMD_WRITE@{ui}) in progress or queued
  and any I/O requests waiting to synchronize with the end of the cycle
  (@{i}ADCMD_WAITCYCLE@{ui}); otherwise, CMD_FLUSH returns an error
  (@{i}ADIOERR_NOALLOCATION@{ui}).CMD_FLUSH is synchronous and only replies
  (@{i}mn_ReplyPort@{ui}) if the quick flag (@{i}IOF_QUICK@{ui}) is clear.Do not use
  CMD_FLUSH in interrupt code at interrupt level 5 or higher.
  @{i}mn_ReplyPort@{ui} - pointer to message port that receives I/O request
    if the quick flag (@{i}IOF_QUICK@{ui}) is clear
  @{i}io_Device@{ui} - pointer to device node, must be set by
    (or copied from I/O block set by) @{"OpenDevice" Link "audio_OpenDevice()"} function
  @{i}io_Unit@{ui} - bit map of channels to flush
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}io_Command@{ui} - command number for CMD_FLUSH
  @{i}io_Flags@{ui} - flags, must be cleared if not used:
    @{b}IOF_QUICK@{ub} - (CLEAR) reply I/O request
  @{i}ioa_AllocKey@{ui} - allocation key, must be set by (or copied from I/O block set by)
    @{"OpenDevice" Link "audio_OpenDevice()"} function or @{"ADCMD_ALLOCATE" Link "ADCMD_ALLOCATE"} command
  @{i}@{b}io_Unit@{ub}@{ui} - bit map of channels successfully flushed
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}@{b}io_Error@{ub}@{ui} - error number:
    @{b}0@{ub} - no error
    @{b}ADIOERR_NOALLOCATION@{ub} - allocation key (@{i}ioa_AllocKey@{ui})
      does not match key for channel
@EndNode
@Node "audio_CMD_READ" "audio.device/CMD_READ"
@{b}@{u}CMD_READ@{uu}@{ub} -- normal I/O entry point.
  CMD_READ is a standard command for a single audio channel (@{i}io_Unit@{ui}).
  If the allocation key (@{i}ioa_AllocKey@{ui}) is correct, CMD_READ returns a
  pointer (@{i}io_Data@{ui}) to the I/O block currently writing (@{i}CMD_WRITE@{ui}) on
  the selected channel; otherwise, CMD_READ returns an error
  (@{i}ADIOERR_NOALLOCATION@{ui}).If there is no write in progress, CMD_READ
  returns zero.CMD_READ is synchronous and only replies (@{i}mn_ReplyPort@{ui})
  if the quick bit (@{i}IOF_QUICK@{ui}) is clear.
  @{i}mn_ReplyPort@{ui} - pointer to message port that receives I/O request after
    if the quick flag (@{i}IOF_QUICK@{ui}) is clear
  @{i}io_Device@{ui} - pointer to device node, must be set by
    (or copied from I/O block set by) @{"OpenDevice" Link "audio_OpenDevice()"} function
  @{i}io_Unit@{ui} - bit map of channel to read
    (bit 0 thru 3 corresponds to channel 0 thru 3),
    if more then one bit is set lowest bit number channel read
  @{i}io_Command@{ui} - command number for CMD_READ
  @{i}io_Flags@{ui} - flags, must be cleared if not used:
    @{b}IOF_QUICK@{ub} - (CLEAR) reply I/O request
  @{i}ioa_AllocKey@{ui} - allocation key, must be set by (or copied from I/O block set by)
    @{"OpenDevice" Link "audio_OpenDevice()"} function or @{"ADCMD_ALLOCATE" Link "ADCMD_ALLOCATE"} command
  @{i}@{b}io_Unit@{ub}@{ui} - bit map of channel successfully read
    (bit 0 thru 3 corresponds to channel 0 thru 3)
  @{i}@{b}io_Error@{ub}@{ui} - error number:
    @{b}0@{ub} - no error
    @{b}ADIOERR_NOALLOCATION@{ub} - allocation key (@{i}ioa_AllocKey@{ui})
      does not match key for channel
  @{i}@{b}ioa_Data@{ub}@{ui} - pointer to I/O block for current write, zero if none is progress
@EndNode
@Node "audio_CMD_RESET" "audio.device/CMD_RESET"
@{b}@{u}CMD_RESET@{uu}@{ub} -- restore device to a known state.
  CMD_RESET is a standard command for multiple audio channels.For each
  selected channel (@{i}io_Unit@{ui}), if the allocation key (@{i}ioa_AllocKey@{ui}) is
  correct, CMD_RESET:
  - clears the hardware audio registers and attach bits,
  - sets the audio interrupt vector,
  - cancels all pending I/O (@{i}CMD_FLUSH@{ui}), and
  - un-stops the channel if it is stopped (@{i}CMD_STOP@{ui}),
  Otherwise, CMD_RESET returns an error (@{i}ADIOERR_NOALLOCATION@{ui}).
  CMD_RESET is synchronous and only replies (@{i}mn_ReplyPort@{ui}) if the quick
  flag (@{i}IOF_QUICK@{ui}) is clear.Do not use CMD_RESET in interrupt code at
  interrupt level 5 or higher.
  @{i}mn_ReplyPort@{ui} - pointer to message port that receives I/O request
    if the quick flag (@{i}IOF_QUICK@{ui}) is clear
  @{i}io_Device@{ui} - pointer to device node, must be set by
    (or copied from I/O block set by) @{"OpenDevice" Link "audio_OpenDevice()"} function
  @{i}io_Unit@{ui} - bit map of channels to reset
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}io_Command@{ui} - command number for CMD_RESET
  @{i}io_Flags@{ui} - flags, must be cleared if not used:
    @{b}IOF_QUICK@{ub} - (CLEAR) reply I/O request
  @{i}ioa_AllocKey@{ui} - allocation key, must be set by (or copied from I/O block set by)
    @{"OpenDevice" Link "audio_OpenDevice()"} function or @{"ADCMD_ALLOCATE" Link "ADCMD_ALLOCATE"} command
  @{i}@{b}io_Unit@{ub}@{ui} - bit map of channels to successfully reset
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}@{b}io_Error@{ub}@{ui} - error number:
    @{b}0@{ub} - no error
    @{b}ADIOERR_NOALLOCATION@{ub} - allocation key (@{i}ioa_AllocKey@{ui})
    does not match key for channel
@EndNode
@Node "audio_CMD_START" "audio.device/CMD_START"
@{b}@{u}CMD_START@{uu}@{ub} -- start device processing (like ^Q).
  CMD_START is a standard command for multiple audio channels.For each selected
  channel (@{i}io_Unit@{ui}), if the allocation key (@{i}ioa_AllocKey@{ui}) is correct and the
  channel was previously stopped (@{i}CMD_STOP@{ui}), CMP_START immediately starts
  all writes (@{i}CMD_WRITE@{ui}) to the channel.If the allocation key is incorrect,
  CMD_START returns an error (@{i}ADIOERR_NOALLOCATION@{ui}).CMD_START starts multiple
  channels simultaneously to minimize distortion if the channels are playing
  the same waveform and their outputs are mixed.CMD_START is synchronous and
  only replies (@{i}mn_ReplyPort@{ui}) if the quick flag (@{i}IOF_QUICK@{ui}) is clear.Do not
  use CMD_START in interrupt code at interrupt level 5 or higher.
  @{i}mn_ReplyPort@{ui} - pointer to message port that receives I/O request after
    if the quick flag (@{i}IOF_QUICK@{ui}) is clear
  @{i}io_Device@{ui} - pointer to device node, must be set by
    (or copied from I/O block set by) @{"OpenDevice" Link "audio_OpenDevice()"} function
  @{i}io_Unit@{ui} - bit map of channels to start
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}io_Command@{ui} - command number for CMD_START
  @{i}io_Flags@{ui} - flags, must be cleared if not used:
    @{b}IOF_QUICK@{ub} - (CLEAR) reply I/O request
  @{i}ioa_AllocKey@{ui} - allocation key, must be set by (or copied from I/O block set by)
    @{"OpenDevice" Link "audio_OpenDevice()"} function or @{"ADCMD_ALLOCATE" Link "ADCMD_ALLOCATE"} command
  @{i}@{b}io_Unit@{ub}@{ui} - bit map of channels successfully started
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}@{b}io_Error@{ub}@{ui} - error number:
    @{b}0@{ub} - no error
    @{b}ADIOERR_NOALLOCATION@{ub} - allocation key (@{i}ioa_AllocKey@{ui})
      does not match key for channel
@EndNode
@Node "audio_CMD_STOP" "audio.device/CMD_STOP"
@{b}@{u}CMD_STOP@{uu}@{ub} -- stop device processing (like ^S).
  CMD_STOP is a standard command for multiple audio channels.For each
  selected channel (@{i}io_Unit@{ui}), if the allocation key (@{i}ioa_AllocKey@{ui}) is
  correct, CMD_STOP immediately stops any writes (@{i}CMD_WRITE@{ui}) in progress;
  otherwise, CMD_STOP returns an error (@{i}ADIOERR_NOALLOCATION@{ui}).
  @{"CMD_WRITE" Link "audio_CMD_WRITE"} queues up writes to a stopped channel until @{"CMD_START" Link "audio_CMD_START"} starts
  the channel or @{"CMD_RESET" Link "audio_CMD_RESET"} resets the channel.CMD_STOP is synchronous
  and only replies (@{i}mn_ReplyPort@{ui}) if the quick flag (@{i}IOF_QUICK@{ui}) is clear.
  Do not use CMD_STOP in interrupt code at interrupt level 5 or higher.
  @{i}mn_ReplyPort@{ui}- pointer to message port that receives I/O request after
    if the quick flag (@{i}IOF_QUICK@{ui}) is clear
  @{i}io_Device@{ui} - pointer to device node, must be set by
    (or copied from I/O block set by) @{"OpenDevice" Link "audio_OpenDevice()"} function
  @{i}io_Unit@{ui} - bit map of channels to stop
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}io_Command@{ui} - command number for CMD_STOP
  @{i}io_Flags@{ui} - flags, must be cleared if not used:
    @{b}IOF_QUICK@{ub} - (CLEAR) reply I/O request
  @{i}ioa_AllocKey@{ui} - allocation key, must be set by (or copied from I/O block set by)
    @{"OpenDevice" Link "audio_OpenDevice()"} function or @{"ADCMD_ALLOCATE" Link "ADCMD_ALLOCATE"} command
  @{i}@{b}io_Unit@{ub}@{ui} - bit map of channels successfully stopped
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}@{b}io_Error@{ub}@{ui} - error number:
    @{b}0@{ub} - no error
    @{b}ADIOERR_NOALLOCATION@{ub} - allocation key (@{i}ioa_AllocKey@{ui})
      does not match key for channel
@EndNode
@Node "audio_CMD_UPDATE" "audio.device/CMD_UPDATE"
@{b}@{u}CMD_UPDATE@{uu}@{ub} -- force dirty buffers out.
  CMD_UPDATE is a standard command for multiple audio channels.For each
  selected channel (@{i}io_Unit@{ui}), if the allocation key (@{i}ioa_AllocKey@{ui}) is
  correct, CMD_UPDATE does nothing; otherwise, CMD_UPDATE returns an
  error (@{i}ADIOERR_NOALLOCATION@{ui}).CMD_UPDATE is synchronous and only
  replies (@{i}mn_ReplyPort@{ui}) if the quick flag (@{i}IOF_QUICK@{ui}) is clear.
  @{i}mn_ReplyPort@{ui}- pointer to message port that receives I/O request after
    if the quick flag (IOF_QUICK) is clear
  @{i}io_Device@{ui} - pointer to device node, must be set by
    (or copied from I/O block set by) @{"OpenDevice" Link "audio_OpenDevice()"} function
  @{i}io_Unit@{ui} - bit map of channels to update
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}io_Command@{ui} - command number for CMD_UPDATE
  @{i}io_Flags@{ui} - flags, must be cleared if not used:
    @{b}IOF_QUICK@{ub} - (CLEAR) reply I/O request
  @{i}ioa_AllocKey@{ui} - allocation key, must be set by (or copied from I/O block set by)
    @{"OpenDevice" Link "audio_OpenDevice()"} function or @{"ADCMD_ALLOCATE" Link "ADCMD_ALLOCATE"} command
  @{i}@{b}io_Unit@{ub}@{ui} - bit map of channels successfully updated
    (bits 0 thru 3 correspond to channels 0 thru 3)
  @{i}@{b}io_Error@{ub}@{ui} - error number:
    @{b}0@{ub} - no error
    @{b}ADIOERR_NOALLOCATION@{ub} - allocation key (@{i}ioa_AllocKey@{ui})
      does not match key for channel
@EndNode
@Node "audio_CMD_WRITE" "audio.device/CMD_WRITE"
@{b}@{u}CMD_WRITE@{uu}@{ub} -- normal I/O entry point.
  CMD_WRITE is a standard command for a single audio channel (@{i}io_Unit@{ui}).
  If the allocation key (@{i}ioa_AllocKey@{ui}) is correct, CMD_WRITE plays a
  sound using the selected channel; otherwise, it returns an error
  (@{i}ADIOERR_NOALLOCATION@{ui}).CMD_WRITE queues up requests if there is
  another write in progress or if the channel is stopped (@{i}CMD_STOP@{ui}).
  When the write actually starts; if the @{i}ADIOF_PERVOL@{ui} flag is set,
  CMD_WRITE loads volume (@{i}ioa_Volume@{ui}) and period (@{i}ioa_Period@{ui}), and if
  the @{i}ADIOF_WRITEMESSAGE@{ui} flag is set, CMD_WRITE replies the write
  message (@{i}ioa_WriteMsg@{ui}).CMD_WRITE returns an error (@{i}IOERR_ABORTED@{ui}) if
  it is canceled (AbortIO) or the channel is stolen (@{i}ADCMD_ALLOCATE@{ui}).
  CMD_WRITE is only asynchronous if there is no error, in which case it
  clears the quick flag (@{i}IOF_QUICK@{ui}) and replies the I/O request
  (mn_ReplyPort) after it finishes writting; otherwise, it is synchronous
  and only replies if the quick flag (@{i}IOF_QUICK@{ui}) is clear.Do not use
  CMD_WRITE in interrupt code at interrupt level 5 or higher.
  @{i}mn_ReplyPort@{ui}- pointer to message port that receives I/O request
    after the write completes
  @{i}io_Device@{ui} - pointer to device node, must be set by
    (or copied from I/O block set by) @{"OpenDevice" Link "audio_OpenDevice()"} function
  @{i}io_Unit@{ui} - bit map of channel to write
    (bit 0 thru 3 corresponds to channel 0 thru 3),
    if more then one bit is set lowest bit number channel is written
  @{i}io_Command@{ui} - command number for CMD_WRITE
  @{i}io_Flags@{ui} - flags, must be cleared if not used:
    @{b}ADIOF_PERVOL@{ub} - (SET) load volume and period
    @{b}ADIOF_WRITEMESSAGE@{ub} - (SET) reply message at write start
  @{i}ioa_AllocKey@{ui} - allocation key, must be set by (or copied from I/O block set by)
    @{"OpenDevice" Link "audio_OpenDevice()"} function or @{"ADCMD_ALLOCATE" Link "ADCMD_ALLOCATE"} command
  @{i}ioa_Data@{ui} - pointer to waveform array (signed bytes (-128 thru 127)
    in custom chip addressable ram and word aligned)
  @{i}ioa_Length@{ui} - length of the wave array in bytes
    (2 thru 131072, must be even number)
  @{i}ioa_Period@{ui} - sample period in 279.365 ns increments
    (124 thru 65536, anti-aliasing filter works below 300 to 500
    depending on waveform), if enabled by @{i}ADIOF_PERVOL@{ui}
  @{i}ioa_Volume@{ui} - volume (0 thru 64, linear), if enabled by @{i}ADIOF_PERVOL@{ui}
  @{i}ioa_Cycles@{ui} - number of times to repeat array (0 thru 65535, 0 for infinite)
  @{i}ioa_WriteMsg@{ui} - message replied at start of write,
    if enabled by @{i}ADIOF_WRITEMESSAGE@{ui}
  @{i}@{b}io_Unit@{ub}@{ui} - bit map of channel successfully written
    (bit 0 thru 3 corresponds to channel 0 thru 3)
  @{i}@{b}io_Flags@{ub}@{ui} - @{i}IOF_QUICK@{ui} flag cleared if there is no error
  @{i}@{b}io_Error@{ub}@{ui} - error number:
    @{b}0@{ub} - no error
    @{b}IOERR_ABORTED@{ub} - canceled (AbortIO) or channel stolen
    @{b}ADIOERR_NOALLOCATION@{ub} - allocation key (@{i}ioa_AllocKey@{ui})
      does not match key for channel
BUGS
  If CMD_WRITE starts the write immediately after stopping a previous
  write, you must set the @{i}ADIOF_PERVOL@{ui} flag or else the new data pointer
  (@{i}ioa_Data@{ui}) and length (@{i}ioa_Length@{ui}) may not be loaded.
@EndNode
@Node "audio_Expunge()" "audio.device/Expunge"
@{b}@{u}EXPUNGE@{uu}@{ub} - indicate a desire to remove the Audio device.
  The Expunge routine is called when a user issues a @{"RemDevice" Link "exec.guide/RemDevice()"} call.By
  the time it is called, the device has already been removed from the
  device list, so no new opens will succeed.The existence of any other
  users of the device, as determined by the device open count being
  non-zero, will cause the Expunge to be deferred.When the device is
  not in use, or no longer in use, the Expunge is actually performed.
@EndNode
@Node "audio_OpenDevice()" "audio.device/OpenDevice"
@{b}@{u}OpenDevice@{uu}@{ub} - open the audio device.
  The OpenDevice routine grants access to the audio device.It takes an
  I/O audio request block (@{i}iORequest@{ui}) and if it can successfully open
  the audio device, it loads the device pointer (@{i}io_Device@{ui}) and the
  allocation key (@{i}ioa_AllocKey@{ui}); otherwise, it returns an error
  (@{i}IOERR_OPENFAIL@{ui}).OpenDevice increments the open count keeping the
  device from being expunged (Expunge).If the length (@{i}ioa_Length@{ui}) is
  non-zero, OpenDevice tries to allocate (@{i}ADCMD_ALLOCATE@{ui}) audio channels
  from a array of channel combination options (@{i}ioa_Data@{ui}).If the
  allocation succeeds, the allocated channel combination is loaded into
  the unit field (@{i}ioa_Unit@{ui}); otherwise, OpenDevice returns an error
  (@{i}ADIOERR_ALLOCFAILED@{ui}).OpenDevice does not wait for allocation to
  succeed and closes (CloseDevice) the audio device if it fails.To
  allocate channels, OpenDevice also requires a properly initialized
  reply port (@{i}mn_ReplyPort@{ui}) with an allocated signal bit.
SYNOPSIS
  @{i}@{b}error@{ub}@{ui} = OpenDevice(@{FG shine}"@{i}audio.device@{ui}"@{FG text}, @{i}unitNumber@{ui}, @{i}iORequest@{ui}, @{i}flags@{ui});
  @{i}unitNumber@{ui} - not used
  @{i}iORequest@{ui} - pointer to audio request block (@{FG shine}struct@{FG text} @{"IOAudio" Link "include:devices/audio.h/Main" 30})
    @{b}ln_Pri@{ub} - allocation precedence (-128 thru 127),
      only necessary for allocation (non-zero length)
    @{b}mn_ReplyPort@{ub} - pointer to message port for allocation,
      only necessary for allocation (non-zero length)
    @{b}ioa_AllocKey@{ub} - allocation key; zero to generate new key.
      Otherwise, it must be set by (or copied from I/O block that is set by)
      previous OpenDevice function or @{"ADCMD_ALLOCATE" Link "ADCMD_ALLOCATE"} command (non-zero length)
    @{b}ioa_Data@{ub} - pointer to channel combination options
      (byte array, bits 0 thru 3 correspond to channels 0 thru 3),
      only necessary for allocation (non-zero length)
    @{b}ioa_Length@{ub} - length of the channel combination option array
      (0 thru 16), zero for no allocation
  @{i}flags@{ui} - not used
  @{i}@{b}iORequest@{ub}@{ui} - pointer to audio request block (@{FG shine}struct@{FG text} @{"IOAudio" Link "include:devices/audio.h/Main" 30})
    @{b}io_Device@{ub} - pointer to device node if OpenDevice succeeds, otherwise -1
    @{b}io_Unit@{ub} - bit map of successfully allocated channels
      (bits 0 thru 3 correspond to channels 0 thru 3)
    @{b}io_Error@{ub} - error number:
      @{b}0@{ub} - no error
      @{b}IOERR_OPENFAIL@{ub} - open failed
      @{b}ADIOERR_ALLOCFAILED@{ub} - allocation failed, no open
    @{b}ioa_AllocKey@{ub} - allocation key,
      set to a unique number if passed a zero and OpenDevice succeeds
  @{i}@{b}error@{ub}@{ui} - copy of @{i}io_Error@{ui}
@EndNode
@Node "console_CD_ASKDEFAULTKEYMAP" "console.device/CD_ASKDEFAULTKEYMAP"
@{b}@{u}CD_ASKDEFAULTKEYMAP@{uu}@{ub} -- get the current default keymap.
  Fill the io_Data buffer with the current console device default keymap,
  which is used to initialize console unit keymaps when opened, and by
  @{"RawKeyConvert" Link "console_RawKeyConvert()"} with a null keyMap parameter.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "console_OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice" Link "console_OpenDevice()"}
  @{i}io_Command@{ui}  CD_ASKDEFAULTKEYMAP
  @{i}io_Flags@{ui}    IOF_QUICK if quick I/O possible, else zero
  @{i}io_Length@{ui}   @{FG shine}sizeof@{FG text}(*keyMap)
  @{i}io_Data@{ui}     @{FG shine}struct@{FG text} @{"KeyMap" Link "include:devices/keymap.h/Main" 21} *keyMap
    pointer to a structure that describes the raw keycode to byte stream
    conversion.
RESULTS
  This function sets the io_Error field in the @{"IOStdReq" Link "include:exec/io.h/Main" 27}, and fills
  the structure pointed to by io_Data with the current device default key map.
SEE ALSO
  @{"exec/io.h" Link "include:exec/io.h/Main" 0}, @{"devices/keymap.h" Link "include:devices/keymap.h/Main" 0}, @{"devices/console.h" Link "include:devices/console.h/Main" 0}
@EndNode
@Node "console_CD_ASKKEYMAP" "console.device/CD_ASKKEYMAP"
@{b}@{u}CD_ASKKEYMAP@{uu}@{ub} -- Get the current key map structure for this console.
  Fill the io_Data buffer with the current KeyMap structure in use by this
  console unit.
IO REQUEST INPUT
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "console_OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice" Link "console_OpenDevice()"}
  @{i}io_Command@{ui}  CD_ASKKEYMAP
  @{i}io_Flags@{ui}    IOF_QUICK if quick I/O possible, else zero
  @{i}io_Length@{ui}   @{FG shine}sizeof@{FG text}(*keyMap)
  @{i}io_Data@{ui}     @{FG shine}struct@{FG text} @{"KeyMap" Link "include:devices/keymap.h/Main" 21} *keyMap
    pointer to a structure that describes the raw keycode to byte stream
    conversion.
IO REQUEST RESULT
  This function sets the io_Error field in the @{"IOStdReq" Link "include:exec/io.h/Main" 27}, and fills
  the structure the structure pointed to by io_Data with the current key map.
SEE ALSO
  @{"exec/io.h" Link "include:exec/io.h/Main" 0}, @{"devices/keymap.h" Link "include:devices/keymap.h/Main" 0}, @{"devices/console.h" Link "include:devices/console.h/Main" 0}
@EndNode
@Node "console_CD_SETDEFAULTKEYMAP" "console.device/CD_SETDEFAULTKEYMAP"
@{b}@{u}CD_SETDEFAULTKEYMAP@{uu}@{ub} -- set the current default keymap.
  This console command copies/uses the keyMap structure pointed to by io_Data to
  the console device default keymap, which is used to initialize console units
  when opened, and by @{"RawKeyConvert" Link "console_RawKeyConvert()"} with a null keyMap parameter.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "console_OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice" Link "console_OpenDevice()"}
  @{i}io_Command@{ui}  CD_SETDEFAULTKEYMAP
  @{i}io_Flags@{ui}    IOF_QUICK if quick I/O possible, else zero
  @{i}io_Length@{ui}   @{FG shine}sizeof@{FG text}(*keyMap)
  @{i}io_Data@{ui}     @{FG shine}struct@{FG text} @{"KeyMap" Link "include:devices/keymap.h/Main" 21} *keyMap
    pointer to a structure that describes the raw keycode to byte stream
    conversion.
RESULTS
  This function sets the io_Error field in the @{"IOStdReq" Link "include:exec/io.h/Main" 27}, and fills
  the current device default key map from the structure pointed to by io_Data.
BUGS
  As of V36, this command no longer copies the keymap structure, and the
  keymap must remain in memory until the default key map is changed.In general
  there is no reason for applications to use this command.The default key map
  will generally be set by the user using a system provided command/tool.
SEE ALSO
  @{"exec/io.h" Link "include:exec/io.h/Main" 0}, @{"devices/keymap.h" Link "include:devices/keymap.h/Main" 0}, @{"devices/console.h" Link "include:devices/console.h/Main" 0}
@EndNode
@Node "console_CD_SETKEYMAP" "console.device/CD_SETKEYMAP"
@{b}@{u}CD_SETKEYMAP@{uu}@{ub} -- set the current key map structure for this console.
  Set the current @{"KeyMap" Link "include:devices/keymap.h/Main" 21} structure used by this console unit to
  the structure pointed to by io_Data.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "console_OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice" Link "console_OpenDevice()"}
  @{i}io_Command@{ui}  CD_SETKEYMAP
  @{i}io_Flags@{ui}    IOF_QUICK if quick I/O possible, else zero
  @{i}io_Length@{ui}   @{FG shine}sizeof@{FG text}(*keyMap)
  @{i}io_Data@{ui}     @{FG shine}struct@{FG text} @{"KeyMap" Link "include:devices/keymap.h/Main" 21} *keyMap
    pointer to a structure that describes the raw keycode to byte stream
    conversion.
RESULTS
  This function sets the io_Error field in the @{"IOStdReq" Link "include:exec/io.h/Main" 27}, and fills
  the current key map from the structure pointed to by io_Data.
SEE ALSO
  @{"exec/io.h" Link "include:exec/io.h/Main" 0}, @{"devices/keymap.h" Link "include:devices/keymap.h/Main" 0}, @{"devices/console.h" Link "include:devices/console.h/Main" 0}
@EndNode
@Node "console_CDInputHandler()" "console.device/CDInputHandler"
@{b}@{u}CDInputHandler@{uu}@{ub} -- handle an input event for the console device.
  Accept input events from the producer, which is usually the rom input.task.
SYNOPSIS
  @{i}@{b}events@{ub}@{ui} = CDInputHandler(@{i}events@{ui}, @{i}consoleDevice@{ui})
                           a0      a1
  @{i}events@{ui} - a pointer to a list of input events.
  @{i}consoleDevice@{ui} - a pointer to the library base address of the console device.
    This has the same value as ConsoleDevice described below.
  @{i}@{b}events@{ub}@{ui} - a pointer to a list of input events not used by this handler.
NOTES
  This function is available for historical reasons.It is preferred that input
  events be fed to the system via the WriteEvent command of the input.device.
  This function is different from standard device commands in that it is a
  function in the console device library vectors.In order to obtain a valid
  library base pointer for the console device (a.k.a.ConsoleDevice) call
  OpenDevice("console.device", -1, @{"IOStdReq" Link "include:exec/io.h/Main" 27}, 0), and then grab the
  io_Device pointer field out of the IOStdReq and use as ConsoleDevice.
SEE ALSO
  input.device
@EndNode
@Node "console_CMD_CLEAR" "console.device/CMD_CLEAR"
@{b}@{u}CMD_CLEAR@{uu}@{ub} -- Clear console input buffer.
  Remove from the console input buffer any reports waiting to
  satisfy read requests.
IO REQUEST INPUT
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "console_OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice" Link "console_OpenDevice()"}
  @{i}io_Command@{ui}  CMD_CLEAR
  @{i}io_Flags@{ui}    IOB_QUICK set if quick I/O is possible, else 0
SEE ALSO
  @{"exec/io.h" Link "include:exec/io.h/Main" 0}, @{"devices/console.h" Link "include:devices/console.h/Main" 0}
@EndNode
@Node "console_CMD_READ" "console.device/CMD_READ"
@{b}@{u}CMD_READ@{uu}@{ub} -- return the next input from the keyboard.
  Read the next input, generally from the keyboard.The form of this input is
  as an ANSI byte stream: i.e.either ASCII text or control sequences.
  Raw input events received by the console device can be selectively filtered
  via the aSRE and aRRE control sequences (see the write command).
  Keys are converted via the keymap associated with the unit, which is
  modified with AskKeyMap and SetKeyMap.
  If, for example, raw keycodes had been enabled by writing <CSI>1{ to the
  console (where <CSI> is $9B or Esc[), keys would return raw keycode reports
  with the information from the input event itself, in the form:
  <CSI>1;0;<keycode>;<qualifiers>;0;0;<seconds>;<microseconds>q
  If there is no pending input, this command will not be satisfied, but if
  there is some input, but not as much as can fill io_Length, the request
  will be satisfied with the input currently available.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "console_OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice" Link "console_OpenDevice()"}
  @{i}io_Command@{ui}  CMD_READ
  @{i}io_Flags@{ui}    IOF_QUICK if quick I/O possible, else zero
  @{i}io_Length@{ui}   @{FG shine}sizeof@{FG text}(*buffer)
  @{i}io_Data@{ui}     @{FG shine}char@{FG text} buffer[]
    a pointer to the destination for the characters to read from the keyboard.
RESULTS
  This function sets the error field in the @{"IOStdReq"/io.h/Main" 28}, and fills in the
  io_Data area with the next input, and io_Actual with the number of bytes read.
SEE ALSO
  @{"exec/io.h" Link "include:exec/io.h/Main" 0}, @{"devices/console.h" Link "include:devices/console.h/Main" 0}
@EndNode
@Node "console_CMD_WRITE" "console.device/CMD_WRITE"
@{b}@{u}CMD_WRITE@{uu}@{ub} -- Write ANSI text to the console display.
  Write a text record to the display.
  Interpret the ANSI control characters in the data as described below.
  Note that the RPort of the console window is in use while this write command
  is pending.
IO REQUEST INPUT
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "console_OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice" Link "console_OpenDevice()"}
  @{i}io_Command@{ui}  CMD_WRITE
  @{i}io_Flags@{ui}    IOF_QUICK if quick I/O possible, else zero
  @{i}io_Length@{ui}   sizeof(*buffer), or -1 if io_Data is null terminated
  io_Data     a pointer to a buffer containing the ANSI text to write to the
    console device.
IO REQUEST RESULTS
  @{i}@{b}io_Error@{ub}@{ui}   the error result (no errors are reported as of V36)
  @{i}@{b}io_Actual@{ub}@{ui}  the number of bytes written from io_Data
  @{i}@{b}io_Length@{ub}@{ui}  zero
  @{i}@{b}io_Data@{ub}@{ui}    original io_Data plus io_Actual
@{"ANSI CODES SUPPORTED" link CONSOLE_CMD_WRITE_ANSICODES}
@{"NOTES" link CONSOLE_CMD_WRITE_NOTES}
BUGS
  Does not correctly display cursor in SuperBitMap layers for versions prior
  to V36.
  Concealed mode should not be used prior to V39 console.device.Prior to V39
  concealed mode masked all rastport output, the effect of which varied.
  As of V39, text output is simply hidden by setting the pen colors.
  Scrolling, clearing, cursor rendering, etc., are unaffected.For maximum
  compatability it is recommended you simply set the colors yourself,
  and not used concealed mode.
  V36-V37 character mapped mode console.device windows could crash, or behave
  erratically if you scroll text DOWN more than a full window's worth of text.
  This bug has been fixed in V39 console.The only work-around is to avoid
  sending scroll down, or cursor up commands which exceed the window
  rows (this is not a problem for unit 0 console windows).
SEE ALSO
  ROM Kernel Manual (Volume 1), @{"exec/io.h" Link "include:exec/io.h/Main" 0}
@EndNode
@node CONSOLE_CMD_WRITE_ANSICODES "console_CMD_WRITE_ANSIcodes"
Codes are specified in the standard fashion for ANSI documents,
as the two 4 bit nibbles that comprise the character code,
high nibble first, separated by a slash.Thus 01/11 (ESC) is
a character with the hex value 1B (or the decimal value 27).
A character on the Amiga falls into one of the following four ranges:
00/ 0-01/15 C0: ASCII control characters.See below.
02/ 0-07/15 G0: ASCII graphic characters.
  These characters have an image that is displayed.
  Note that the DEL character is displayed by the Console Device:
  it is not treated as control character here.
08/ 0-09/15 C1: ANSI 3.41 control characters.See below.
10/ 0-15/15 G1: ECMA 94 Latin 1 graphic characters.
@{b}@{u}Independent Control Functions (no introducer)@{uu}@{ub}:
  Code   Name  Definition
  ---------------------------------------------------------------
  00/ 7  BEL   BELL: actually an Intuition @{"DisplayBeep()" Link "intuition.guide/DisplayBeep()"}
  00/ 8  BS    BACKSPACE
  00/ 9  HT    HORIZONTAL TAB
  00/10  LF    LINE FEED
  00/11  VT    VERTICAL TAB
  00/12  FF    FORM FEED
  00/13  CR    CARRIAGE RETURN
  00/14  SO    SHIFT OUT: causes all subsequent G0 (ASCII) characters to be
    shifted to G1 (ECMA 94/1) characters.
  00/15  SI    SHIFT IN: cancels the effect of SHIFT OUT.
  01/11  ESC   ESCAPE
  Code or Esc Name Definition
  ---------------------------------------------------------------
  08/   4  D  IND  INDEX: move the active position down one line.
  08/   5  E  NEL  NEXT LINE
  08/   8  H  HTS  HORIZONTAL TABULATION SET
  08/  13  M  RI   REVERSE INDEX
  09/  11  [  CSI  CONTROL SEQUENCE INTRODUCER: see next list
@{b}@{u}ISO Compatible Escape Sequences (introduced by Esc)@{uu}@{ub}:
  Esc   Name Definition
  ---------------------------------------------------------------
  c     RIS  RESET TO INITIAL STATE: reset the console display.
@{b}@{u}Control Sequences, with the number of indicated parameters@{uu}@{ub}:
  i.e. <CSI><parameters><control sequence letter(s)>.
  Note the last entries consist of a space and a letter.
  CSI is either 9B or Esc[.
  A minus after the number of parameters (#p) indicates less is valid.
  Parameters are separated by semicolons,
  e.g.Esc[14;80H sets the cursor position to row 14, column 80.
  CSI #p  Name   Definition
  ---------------------------------------------------------------
  @@  1-  ICH    INSERT CHARACTER
  A   1-  CUU    CURSOR UP
  B   1-  CUD    CURSOR DOWN
  C   1-  CUF    CURSOR FORWARD
  D   1-  CUB    CURSOR BACKWARD
  E   1-  CNL    CURSOR NEXT LINE
  F   1-  CPL    CURSOR PRECEDING LINE
  H   2-  CUP    CURSOR POSITION
  I   1-  CHT    CURSOR HORIZONTAL TABULATION
  J   1-  ED     ERASE IN DISPLAY (only to end of display)
  K   1-  EL     ERASE IN LINE (only to end of line)
  L   1-  IL     INSERT LINE
  M   1-  DL     DELETE LINE
  P   1-  DCH    DELETE CHARACTER
  R   2   CPR    CURSOR POSITION REPORT (in Read stream only)
  S   1-  SU     SCROLL UP
  T   1-  SD     SCROLL DOWN
  W   n   CTC    CURSOR TABULATION CONTROL
  Z   1-  CBT    CURSOR BACKWARD TABULATION
  f   2-  HVP    HORIZONTAL AND VERTICAL POSITION
  g   1-  TBC    TABULATION CLEAR
  h   n   SM     SET MODE: see modes below.
  l   n   RM     RESET MODE: see modes below.
  m   n   SGR    SELECT GRAPHIC RENDITION
  n   1-  DSR    DEVICE STATUS REPORT
  t   1-  aSLPP  SET PAGE LENGTH (private Amiga sequence)
  u   1-  aSLL   SET LINE LENGTH (private Amiga sequence)
  x   1-  aSLO   SET LEFT OFFSET (private Amiga sequence)
  y   1-  aSTO   SET TOP OFFSET (private Amiga sequence)
  {   n   aSRE   SET RAW EVENTS (private Amiga sequence)
  |   8   aIER   INPUT EVENT REPORT (private Amiga Read sequence)
  }   n   aRRE   RESET RAW EVENTS (private Amiga sequence)
      1   aSKR   SPECIAL KEY REPORT (private Amiga Read sequence)
  p   1-  aSCR   SET CURSOR RENDITION (private Amiga sequence)
  q   0   aWSR   WINDOW STATUS REQUEST (private Amiga sequence)
  r   4   aWBR   WINDOW BOUNDS REPORT (private Amiga Read sequence)
  s   0   aSDSS  SET DEFAULT SGR SETTINGS (private Amiga sequence-V39)
  v   1   aRAV   RIGHT AMIGA V PRESS (private Amiga Read sequence-V37)
@{b}@{u}Modes, set with <CSI><mode-list>h, and cleared with <CSI><mode-list>l,where the
mode-list is one or more of the following parameters, separated by semicolons@{uu}@{ub}:
  Mode  Name Definition
  ---------------------------------------------------------------
  20    LNM  LINEFEED NEWLINE MODE: if a linefeed is a newline
  >1    ASM  AUTO SCROLL MODE: if scroll at bottom of window
  ?7    AWM  AUTO WRAP MODE: if wrap at right edge of window
@endnode
@node CONSOLE_CMD_WRITE_NOTES "console_CMD_WRITE_notes"
The console.device recognizes these SGR sequences.
Note that some of these are new to V36.
SGR (SELECT GRAPHICS RENDITION)
  Selects colors, and other display characteristics for text.
@{b}Syntax@{ub}:  <ESC>[graphic-rendition...m
@{b}Example@{ub}: <ESC>[1;7m   (sets bold, and reversed text)
@{b}Parameters@{ub}:
   0 - Normal colors, and attributes
   1 - Set bold
   2 - Set faint (secondary color)
   3 - Set italic
   4 - Set underscore
   7 - Set reversed character/cell colors
   8 - Set concealed mode.
  22 - Set normal color, not bold  (V36)
  23 - Italic off (V36)
  24 - Underscore off (V36)
  27 - Reversed off (V36)
  28 - Concealed off (V36)
  30-37 - Set character color
  39  - Reset to default character color
  40-47 - Set character cell color
  49  - Reset to default character cell color
  >0-7  - Set background color (V36)
    Used to set the background color before any text is written.
    The numeric parameter is prefixed by ">".This also means that if you
    issue an SGR command with more than one parameter, you must issue the
    digit only parameters first, followed by any prefixed parameters.
V39 console.device takes advantage of the ability to mask bitplanes for faster
scrolling, clearing, and rendering.The actual number of bitplanes scrolled
depends on which colors you set via the SGR sequences.
For those using the defaults of PEN color 1, and cell color 0, console.device
only needs to scroll 1 bitplane.The actual number of bitplanes scrolled is
reset when ESCc is sent, and when the console window is entirely cleared
(e.g., FF).In general this should cause no compatability problems, unless
you are mixing console rendering with graphic.library calls in the same
portions of your window.Console.device considers the number of bitplanes
it must scroll, and the screen display depth so that interleaved bitplane
scrolling can be taken advantage of in cases where performance is not
significantly affected (interleaved scrolling, and masking are mutually
exclusive).The determination of how many planes to scroll is undefined,
and may change in the future.
V39 console.device supports a new private sequence (aSDSS) intended for use
by users who prefer to change their default SGR settings.
When this private Amiga sequence is sent to the console, the current Pen color,
Cell color, Text style, and Reverse mode (on or off), are set as defaults.
When ESC[0m is issued, the settings are restored to the preferred settings.
ESC[39m, and ESC[49m are likewise affected.In general applications should not
make use of this private sequence as it is intended for users who would
normally include it as part of their shell startup script.
The normal defaults are reset when ESCc is issued.
@endnode
@Node "console_OpenDevice()" "console.device/OpenDevice"
@{b}@{u}OpenDevice@{uu}@{ub} -- a request to open a Console device.
  The open routine grants access to a device.There are two fields in the
  @{"IOStdReq" Link "include:exec/io.h/Main" 27} block that will be filled in:
  the io_Device field and possibly the io_Unit field.
  As of @{FG fill}(V37)@{FG text} the flags field may also be filled in with a value described below
  (see conunit.h or conunit.i).
  This open command differs from most other device open commands in that it
  requires some information to be supplied in the io_Data field of the
  IOStdReq block.This initialization information supplies the window that is
  used by the console device for output.The unit number that is a standard
  parameter for an open call is used specially by this device.
  See @{"conunit.h" Link "include:devices/conunit.h/Main" 0}, or conunit.i for defined valid unit numbers.
SYNOPSIS
  @{i}@{b}error@{ub}@{ui} = OpenDevice("console.device", @{i}unit@{ui}, @{i}IOStdReq@{ui}, @{i}flags@{ui} )
   d0                  a0               d0     a1        d1
  "console.device" - a pointer to the name of the device to be opened.
  @{i}unit@{ui} - the unit number to open on that device.
  @{i}IOStdReq@{ui} - a pointer to a standard request block
  @{i}0@{ui} - a flag field of zero (CONFLAG_DEFAULT)
  @{i}1@{ui} - a flag field of one  (CONFLAG_NODRAW_ON_NEWSIZE) @{FG fill}(V37)@{FG text}
@{"UNITS" link CONSOLE_OPENDEVICE_UNITS}
@{"FLAGS" link CONSOLE_OPENDEVICE_FLAGS}
  @{i}@{b}error@{ub}@{ui} - zero if successful, else an error is returned.
IO REQUEST
  @{i}io_Data@{ui}   struct @{"Window" Link "include:intuition/intuition.h/Main" 910} *window
    This is the window that will be used for this console.
    It must be supplied if the unit in the OpenDevice call is 0 (see above).
    The RPort of this window is potentially in use by the console whenever
    there is an outstanding write command.
NOTES
  As noted above, opening the console.device with a unit number of 3 allows the
  user to drag select text, and copy the selection with RIGHT AMIGA C.
  The snip is copied to a private buffered managed by the console.device
  (as of V36).The snip can be copied to any console.device window unless you
  are running a console to clipboard utility such as that provided with V37.
  The user pastes text into console.device windows by pressing RIGHT AMIGA V.
  Both RIGHT AMIGA V, and RIGHT AMIGA C are swallowed by the console.device
  (unless you have asked for key presses as RAW INPUT EVENTS).Text pasted in
  this way appears in the console read stream as if the user had typed all of
  the characters manually.Additional input (e.g., user input, RAW INPUT EVENTS)
  are queued up after pastes.Pastes can theoretically be quite large, though
  they are no larger than the amount of text which is visible in a
  console.device window.
  When running the console to clipboard utility, text snips are copied to the
  clipboard.device, and RIGHT AMIGA V key presses are broadcast as an escape
  sequence as part of the console.device read stream
  ("<CSI>0 v" - $9B,$30,$20,$76).
  It is left up to the application to decide what to do when this escape
  sequence is received.Ideally the application will read the contents of the
  clipboard,and paste the text by using successive writes to the console.device.
  Because the contents of the clipboard.device can be quite large, your program
  should limit the size of writes to something reasonable (e.g., no more than 1K
  characters per @{"CMD_WRITE" Link "console_CMD_WRITE"}, and ideally no more than 256 characters per write).
  Your program should continue to read events from the console.device looking
  for user input, and possibly RAW INPUT EVENTS.How you decide to deal with
  these events is left up to the application.
  If you are using a character mapped console you should receive Intuition
  events as RAW INPUT EVENTS from the console.device.By doing this you will
  hear about these events after the console device does.This allows the
  console.device to deal with events such as window resizing, and refresh
  before your application.
SEE ALSO
  @{"exec/io.h" Link "include:exec/io.h/Main" 0}, @{"intuition/intuition.h" Link "include:intuition/intuition.h/Main" 0}
@EndNode
@node CONSOLE_OPENDEVICE_UNITS "console_OpenDevice_units"
@{i}@{b}unit number@{ub}@{ui}: -1 (CONU_LIBRARY)
  Used to get a pointer to the device library vector which is returned in the
  io_Device field of the IOStdReq block.No actual console is opened.
  You must still close the device when you are done with it.
@{i}@{b}unit number@{ub}@{ui}: 0 (CONU_STANDARD)
  A unit number of zero binds the supplied window to a unique console.
  Sharing a console must be done at a level higher than the device.
@{i}@{b}unit number@{ub}@{ui}: 1 (CONU_CHARMAP) @{FG fill}(V36)@{FG text}
  A unit number of one is similar to a unit number of zero, but a console map
  is also created, and maintained by the console.device.The character map is
  used by the console device to restore obscured portions of windows which are
  revealed, and to redraw a window after a resize.Character mapped
  console.device windows must be opened as SIMPLE REFRESH windows.
  The character map is currently for internal use only, and is not accessible
  by the programmer.The character map stores characters, attributes, and style
  information for each character written with the @{"CMD_WRITE" Link "console_CMD_WRITE"} command.
@{i}@{b}unit number@{ub}@{ui}: 3 (CONU_SNIPMAP) @{FG fill}(V36)@{FG text}
  A unit number of three is similar to a unit number of one, but also gives
  the user the ability to highlight text with the mouse which can be copied
  by pressing RIGHT AMIGA C.See NOTES below.
@endnode
@node CONSOLE_OPENDEVICE_FLAGS "console_OpenDevice_flags"
@{i}@{b}flags@{ub}@{ui}: 0 (CONFLAG_DEFAULT)
  The flags field should be set to 0 under V34, or less.
@{i}@{b}flags@{ub}@{ui}: 1 (CONFLAG_NODRAW_ON_NEWSIZE) @{FG fill}(V37)@{FG text}
  The flags field can be set to 0, or 1 as of V37.
  The flags field is ignored under V36, so can be set, though it will have
  no effect.When set to 1, it means that you don't want the console.device
  to redraw the window when the window size is changed (assuming you have
  opened the console.device with a character map - unit numbers 1, or 3).
  This flag is ignored if you have opened a console.device with a unit number
  of 0.Typically you would use this flag when you want to perform your own
  window refresh on a newsize, and you want the benefits of a character mapped
  console.
@endnode
@Node "console_RawKeyConvert()" "console.device/RawKeyConvert"
@{b}@{u}RawKeyConvert@{uu}@{ub} -- decode raw input classes.
  This console function converts input events of type IECLASS_RAWKEY to
  ANSI bytes, based on the keyMap, and places the result into the buffer.
  ConsoleDevice in A6 if called from Assembly Language.
SYNOPSIS
  @{i}@{b}actual@{ub}@{ui} = RawKeyConvert(@{i}event@{ui}, @{i}buffer@{ui}, @{i}length@{ui}, @{i}keyMap@{ui})
   D0                     A0     A1      D1      A2
  @{i}event@{ui} - an @{"InputEvent" Link "include:devices/inputevent.h/Main" 198} structure pointer.
  @{i}buffer@{ui} - a byte buffer large enough to hold all anticipated characters
    generated by this conversion.
  @{i}length@{ui} - maximum anticipation, i.e.the buffer size in bytes.
  @{i}keyMap@{ui} - a @{"KeyMap" Link "include:devices/keymap.h/Main" 21} structure pointer,
    or null if the default console device key map is to be used.
  @{i}@{b}actual@{ub}@{ui} - the number of characters in the buffer,
    or -1 if a buffer overflow was about to occur.
ERRORS
  if actual is -1, a buffer overflow condition was detected.
  Not all of the characters in the buffer are valid.
NOTES
  This function is different from standard device commands in that it is a
  function in the console device library vectors.
  In order to obtain a valid library base pointer for the console device
  (a.k.a. ConsoleDevice) call OpenDevice("console.device", -1, @{"IOStdReq" Link "include:exec/io.h/Main" 27}, 0),
  and then grab the io_Device pointer field out of the IOStdReq and use as
  ConsoleDevice.
SEE ALSO
  @{"exec/io.h" Link "include:exec/io.h/Main" 0}, @{"devices/inputevent.h" Link "include:devices/inputevent.h/Main" 0}, @{"devices/keymap.h" Link "include:devices/keymap.h/Main" 0}
@EndNode

@Node "narrator_AbortIO()" "narrator.device/AbortIO"
@{b}@{u}AbortIO@{uu}@{ub} - Abort an IO request.
  Exec library call to abort a specified READ or WRITE request.
  The @{"IORequest" Link "include:exec/io.h/Main" 18} may be in the queue or currently active.If currently active,
  the request is immediately stopped and then removed.
SYNOPSIS
  AbortIO(@{i}IORequest@{ui})
           A1
  @{i}IORequest@{ui} - pointer to the block to be aborted.
  Returns @{i}@{b}io_Error@{ub}@{ui} field in the IORequest block set to #IOERR_ABORTED.
@EndNode
@Node "narrator_CloseDevice()" "narrator.device/CloseDevice"
@{b}@{u}CloseDevice@{uu}@{ub} -- Terminates access to the narrator device.
  Close invalidates the IO_UNIT and IO_DEVICE fields in the @{"IORequest" Link "include:exec/io.h/Main" 18} block,
  preventing subsequent IO until another @{"OpenDevice" Link "narrator_OpenDevice()"}.
  CloseDevice also reduces the open count.
  If the count goes to 0 and the expunge bit is set, the device is expunged.
  If the open count goes to zero and the delayed expunge bit is not set,
  CloseDevice sets the expunge bit.
SYNOPSIS
  CloseDevice(@{i}IORequest@{ui})
               A1
  @{i}IORequest@{ui} - a valid block with its io_Message structure, and
    io_Device and io_Unit fields properly initialized.
    These fields are initialized by @{"OpenDevice" Link "narrator_OpenDevice()"}.
  CloseDevice invalidates the unit and device pointers in the IORequest block.
@EndNode
@Node "narrator_CMD_FLUSH" "narrator.device/CMD_FLUSH"
@{b}@{u}CMD_FLUSH@{uu}@{ub} - Aborts all inprogress and queued requests.
  Aborts all inprogress and queued speech requests.
SYNOPSIS
  Standard device command.
INPUTS
  @{i}IORequest@{ui} - block with the io_Command field set to CMD_FLUSH.
    A valid @{"IORequest" Link "include:exec/io.h/Main" 18} block is one with its io_Message structure,and io_Device
    and io_Unit fields properly initialized.The easiest way to insure proper
    initialization is to make a copy of the IORequest block after a successful
    @{"OpenDevice" Link "narrator_OpenDevice()"} call.
  @{i}@{b}io_Error@{ub}@{ui} in IORequest block set to 0
SEE ALSO
  Exec input/output documentation.
@EndNode
@Node "narrator_CMD_Read" "narrator.device/CMD_Read"
@{b}@{u}CMD_READ@{uu}@{ub} - Query the narrator device for mouth shape or other synchronization
  events.
  Currently, there are three events which the user can inquire about from the
  narrator device.These are: @{b}mouth shape changes@{ub}, @{b}start of word@{ub}, and @{b}start of
  syllable@{ub}.Each read request returns information about any or all of these
  events as determined by the bits set in the sync field of the read @{"IORequest" Link "include:exec/io.h/Main" 18}
  block.In the case of mouth shape changes, each shape returned is guaranteed
  to be different from the previously returned shape to allow updating to be
  done only when necessary.Each read request is associated with a write request
  by information contained in the IORequest block used to open the device.
  Since the first field in the read IORequest block is a write IORequest
  structure,this association is easily made by copying the write IORequest block
  (after the @{"OpenDevice" Link "narrator_OpenDevice()"} call) into the voice field of the read IORequest block.
  If there is no write in progress or in the device input queue with the same
  pseudo unit number as the read request,the read will be returned to the user
  with an error.This is also how the user knows that the write request has
  finished and that s/he should not issue any more reads.Note that in this case
  the mouth shapes may not be different from previously returned values.
SYNOPSIS
  Standard device command.
INPUTS
  @{"mouth_rb" Link "include:devices/narrator.h/Main" 130} IORequest block with the voice field (a @{"narrator_rb" Link "include:devices/narrator.h/Main" 94} structure)
  copied from the associated write request with the following fields modified:
     @{i}io_Message@{ui} - Pointer to message port for read request
     @{i}io_Command@{ui} - @{"CMD_READ" Link "narrator_CMD_READ"}
     @{i}io_Error@{ui}   - Clear before issuing first read
     @{i}width@{ui}      - 0
     @{i}height@{ui}     - 0
RESULTS
  As long as the speech is in progress, each read returns the following
  information in the @{"mouth_rb" Link "include:devices/narrator.h/Main" 130} IORequest block:
    If mouth shape changes are requested the following fields are modified:
      @{i}@{b}width@{ub}@{ui}  - Contains mouth width value in arbitrary units
      @{i}@{b}height@{ub}@{ui} - Contains mouth height value in arbitrary units
      @{i}@{b}shape@{ub}@{ui}  - Compressed form of mouth shapes (internal use only)
    @{FG fill}******  NEW FOR V37 NARRATOR ******@{FG text}
    If word synchronization is requested:
       @{i}@{b}sync@{ub}@{ui} - Bit NDB_WORDSYNC is set
    If syllable synchronization is requested:
       @{i}@{b}sync@{ub}@{ui} - Bit NDB_SYLSYNC is set
  Note that any or all of the above fields can be set and it is the user's
  responsibility to check for all possibilities.
SEE ALSO
  @{"CMD_WRITE" Link "narrator_CMD_WRITE"}
  Exec input/output documentation.
@EndNode
@Node "narrator_CMD_RESET" "narrator.device/CMD_RESET"
@{b}@{u}CMD_RESET@{uu}@{ub} - Reset the device to a known state.
  Resets the device as though it has just be initialized.
  Aborts all read/write requests whether active of enqueued.
  Restarts device if it has been stopped.
SYNOPSIS
  Standard device command.
INPUTS
  @{i}IORequest@{ui} - block with the io_Command field set to CMD_RESET.
    A valid @{"IORequest" Link "include:exec/io.h/Main" 18} block is one with its io_Message structure, and io_Device
    and io_Unit fields properly initialized.The easiest way to insure proper
    initialization is to make a copy of the IORequest block after a successful
    @{"OpenDevice" Link "narrator_OpenDevice()"} call.
SEE ALSO
  Exec input/output documentation.
@EndNode
@Node "narrator_CMD_START" "narrator.device/CMD_START"
@{b}@{u}CMD_START@{uu}@{ub} - Restarts the device after a @{"CMD_STOP" Link "narrator_CMD_STOP"} command.
  CMD_START restarts the currently active speech (if any) and allows
  queued requests to start.
SYNOPSIS
  Standard device command.
INPUTS
  @{i}IORequest@{ui} - block with the io_Command field set to CMD_START
    A valid @{"IORequest" Link "include:exec/io.h/Main" 18} block is one with its io_Message structure, and io_Device
    and io_Unit fields properly initialized.The easiest way to insure proper
    initialization is to make a copy of the IORequest block after a successful
    @{"OpenDevice" Link "narrator_OpenDevice()"} call.
RESULTS
  @{i}@{b}io_Error@{ub}@{ui} set to 0.
SEE ALSO
  Exec input/output documentation.
@EndNode
@Node "narrator_CMD_STOP" "narrator.device/CMD_STOP"
@{b}@{u}CMD_STOP@{uu}@{ub}  - Stops the device.
  CMD_STOP halts the currently active speech (if any) and prevents
  any queued requests from starting.
SYNOPSIS
  Standard device command.
INPUTS
  @{i}IORequest@{ui} - block with the io_Command field set to CMD_STOP
    A valid @{"IORequest" Link "include:exec/io.h/Main" 18} block is one with its io_Message structure, and io_Device
    and io_Unit fields properly initialized.The easiest way to insure proper
    initialization is to make a copy of the IORequest block after a successful
    @{"OpenDevice" Link "narrator_OpenDevice()"} call.
RESULTS
  @{i}@{b}io_Error@{ub}@{ui} set to 0.
SEE ALSO
  Exec input/output documentation.
@EndNode
@Node "narrator_CMD_WRITE" "narrator.device/CMD_WRITE"
@{b}@{u}CMD_WRITE@{uu}@{ub} - Send speech request to the narrator device.
  Sends a phonetic string to the narrator device to be spoken and, optionally,
  is used to direct the narrator device to return mouth shape changes, and word
  and syllable sync events in response to read requests from the user.
  The phonetic string consists of ASCII characters representing the individual
  phonemes.Refer to the narrator device chapter of the libraries and devices
  volume of the ROM Kernel Manual for detailed information.
SYNOPSIS
  Standard device command.
INPUTS
  User @{"IORequest" Link "include:exec/io.h/Main" 18} block (@{FG shine}struct@{FG text} @{"narrator_rb" Link "include:devices/narrator.h/Main" 94} as defined in .h file).
  The @{"OpenDevice" Link "narrator_OpenDevice()"} call will initialize the IORequest block to a "standard male"
  voice.If you want to change any parms, do so after the @{"OpenDevice" Link "narrator_OpenDevice()"} call and
  before the @{"DoIO" Link "exec.guide/DoIO()"} (or SendIO/WaitIO).
  Note that the @{"OpenDevice" Link "narrator_OpenDevice()"} call does not initialize all the fields needed by
  the narrator device.
  The IORequest fields which must be set by the user before issuing the write
  request are:
    @{i}io_Command@{ui} - Set to CMD_WRITE
    @{i}io_Data@{ui}    - Pointer to phonetic string
    @{i}io_Length@{ui}  - Length of phonetic string
    @{i}ch_masks@{ui}   - Array of audio channel selection masks
      (see audio device documentation for description of this field)
    @{i}nm_masks@{ui}   - Number of audio channel selection masks
    @{FG fill}****** NEW FOR V37 NARRATOR ******@{FG text}
    @{i}flags@{ui} - The bit NDB_NEWIORB must be set in the flags field if
      any of the new features of the V37 narrator are used
  In addition to producing synthetic speech, the narrator device also provides
  features for synchronizing the speech to animation or other user defined
  events.There are three types of events that the user can request.They are
  @{b}mouth shape changes@{ub}, @{b}start of new word@{ub}, and @{b}start of new syllable@{ub}.Mouth shape
  changes are requested by setting the mouths field of the IORequest block to a
  non-zero value.Word and syllable sync events are requested by setting the
  NDB_WORDSYNC and/or NDB_SYLSYNC bits in the flags field of the IORequest block.
  Note that word and syllable sync only work in V37 and later versions of the
  narrator device.
RESULTS
  The narrator device range checks and performs other validity checks for all
  input parms.If any input is in error,the device sets the io_Error field of the
  IORequest block to an appropriate value (see include files for error codes).
  If everything is in order, the narrator device will produce the speech and
  clear the io_Error field.The io_Actual field is set to the length of the
  input string that was actually processed.
  If the return code indicates a phoneme error (ND_PhonErr), io_Actual is the
  NEGATIVE of the position in the input string where the error occured.
SEE ALSO
  Read command.
  Audio device documentation.
  Exec input/output documentation.
@EndNode
@Node "narrator_OpenDevice()" "narrator.device/OpenDevice"
@{b}@{u}OpenDevice@{uu}@{ub} - opens the narrator device.
  The OpenDevice routine grants access to the narrator device.OpenDevice
  checks the unit number, and if non-zero, returns an error (ND_UnitErr).
  If this is the first time the driver has been opened, OpenDevice will
  attempt to open the audio device and allocate the driver's static buffers.
  If either of these operations fail, an error is returned.
  See the .h and .i include files for possible error return codes.
  Next, OpenDevice (done for all opens, not just the first one) initializes
  various fields in the user's @{"IORequest" Link "include:exec/io.h/Main" 18} block (see below).If users wish to
  use non-default values for these parms, the values must be set after the open
  is done.OpenDevice also assigns a pseudo unit number to the IORB for use in
  synchronizing read and write requests. See the read command for more details.
  Finally, OpenDevice stores the device node pointer in the IORequest block and
  clears the delayed expunge bit.
  @{FG fill}***** NEW FOR V37 NARRATOR *****@{FG text}
  Several new fields in the IORequest block have been added for V37 narrator.
  These fields are initialized when the device is opened if the NDB_NEWIORB bit
  is set in the flags field of the user's IORequest block.
  Note that NDB_NEWIORB is set in the IORequest block, NOT in the "flags"
  input parm to the OpenDevice call.
SYNOPSIS
  @{i}@{b}error@{ub}@{ui} = OpenDevice("@{FG shine}narrator.device@{FG text}",  @{i}unit@{ui}, @{i}IORequest@{ui}, @{i}flags@{ui});
   D0                   A0                D0     A1         D1
INPUTS
  @{i}device@{ui}     - "@{FG shine}narrator.device@{FG text}"
  @{i}unit@{ui}       - 0
  @{i}IORequest@{ui}  - Pointer to the user's IORequest block
  @{i}flags@{ui}      - 0
RESULTS
  The narrator device will initialize the IORequest block as follows
  (assume IORB points to the IOrequest block):
    IORB->@{i}@{b}rate@{ub}@{ui} = 150;   /* Speaking rate in words/minute */
    IORB->@{i}@{b}pitch@{ub}@{ui} = 110;    /* Baseline pitch in Hertz      */
    IORB->@{i}@{b}mode@{ub}@{ui} = NATURALF0;   /* Pitch (F0) mode    */
    IORB->@{i}@{b}sex@{ub}@{ui} = MALE;   /* Sex of voice     */
    IORB->@{i}@{b}volume@{ub}@{ui} = 64   /* Volume, full on    */
    IORB->@{i}@{b}sampfreq@{ub}@{ui} = 22200    /* Audio sampling freq    */
    IORB->@{i}@{b}mouths@{ub}@{ui} = 0    /* Don't generate sync events */
  and if the NDB_NEWIORB bit is set:
    IORB->@{i}@{b}F0enthusiasm@{ub}@{ui} = 0    /* F0 excursion factor    */
    IORB->@{i}@{b}F0perturb@{ub}@{ui} = 32    /* F0 perturbation (in 32nds) */
    IORB->@{i}@{b}F1adj@{ub}@{ui} = 0     /* F1 adjustment in 5% steps */
    IORB->@{i}@{b}F2adj@{ub}@{ui} = 0     /* F2 adjustment in 5% steps */
    IORB->@{i}@{b}F3adj@{ub}@{ui} = 0     /* F3 adjustment in 5% steps */
    IORB->@{i}@{b}A1adj@{ub}@{ui} = 0     /* A1 adjustment in decibels  */
    IORB->@{i}@{b}A2adj@{ub}@{ui} = 0     /* A2 adjustment in decibels  */
    IORB->@{i}@{b}A3adj@{ub}@{ui} = 0     /* A3 adjustment in decibels  */
    IORB->@{i}@{b}articulate@{ub}@{ui} = 100    /* Transition time multiplier */
    IORB->@{i}@{b}centralize@{ub}@{ui} = 0    /* Degree of vowel centralization */
    IORB->@{i}@{b}centphon@{ub}@{ui} = ""   /* Pointer to central ASCII phon  */
    IORB->@{i}@{b}AVbias@{ub}@{ui} = 0    /* AV bias      */
    IORB->@{i}@{b}AFbias@{ub}@{ui} = 0    /* AF bias      */
    IORB->@{i}@{b}priority@{ub}@{ui} = 100    /* Priority while speaking  */
SEE ALSO
  The include files contain the complete @{"IORequest" Link "include:exec/io.h/Main" 18} block definition,
  default settings, and error return codes.
  Exec input/output documentation.
@EndNode
@Node "parallel_CMD_CLEAR" "parallel.device/CMD_CLEAR"
@{b}@{u}Clear@{uu}@{ub} -- clear the parallel port buffer.
  This command just RTS's (no buffer to clear).
IO REQUEST
  @{i}io_Message@{ui} - @{i}mn_ReplyPort@{ui} initialized
  @{i}io_Device@{ui} - set by @{"OpenDevice" Link "parallel_OpenDevice()"}
  @{i}io_Unit@{ui} - set by @{"OpenDevice" Link "parallel_OpenDevice()"}
  @{i}io_Command@{ui} - @{i}CMD_CLEAR@{ui} (05)
@EndNode
@Node "parallel_CMD_FLUSH" "parallel.device/CMD_FLUSH"
@{b}@{u}Flush@{uu}@{ub} -- clear all queued I/O requests for the parallel port.
  This command purges the read and write request queues for the
  parallel device.The currently active request is not purged.
IO REQUEST
  @{i}io_Message@{ui} - @{i}mn_ReplyPort@{ui} initialized
  @{i}io_Device@{ui} - set by @{"OpenDevice" Link "parallel_OpenDevice()"}
  @{i}io_Unit@{ui} - set by @{"OpenDevice" Link "parallel_OpenDevice()"}
  @{i}io_Command@{ui} - @{i}CMD_FLUSH@{ui} (08)
@EndNode
@Node "parallel_CMD_READ" "parallel.device/CMD_READ"
@{b}@{u}Read@{uu}@{ub} -- read input from parallel port.
  This command causes a stream of characters to be read from the parallel I/O
  register.The number of characters is specified in @{i}io_Length@{ui}.The EOF and EOL
  modes are supported, but be warned that using these modes can result in a
  buffer overflow if the proper EOL or EOF character is not received in time.
  These modes should be used only when the sender and receiver have been
  designed to cooperate.A safety guard can be implemented to EOF by setting
  @{i}io_Length@{ui} to a maximum allowed value.That cannot be done with EOL since
  the EOL mode is identified by @{i}io_Length@{ui}=-1.
  The parallel.device has no internal buffer; if no read request has
  been made, pending input (i.e.handshake request) is not acknowledged.
IO REQUEST
  @{i}io_Message@{ui} - @{i}mn_ReplyPort@{ui} initialized
  @{i}io_Device@{ui} - set by @{"OpenDevice" Link "parallel_OpenDevice()"}
  @{i}io_Unit@{ui} - set by @{"OpenDevice" Link "parallel_OpenDevice()"}
  @{i}io_Command@{ui} - @{i}CMD_READ@{ui} (02)
  @{i}io_Flags@{ui} - If @{i}IOF_QUICK@{ui} is set, driver will attempt Quick IO
  @{i}io_Length@{ui} - number of characters to receive.
  @{i}io_Data@{ui} - pointer where to put the data.
RESULTS
  @{i}@{b}io_Error@{ub}@{ui} -- if the Read succeded, then @{i}io_Error@{ui} will be null.
    If the Read failed, then @{i}io_Error@{ui} will contain an error code.
SEE ALSO
  @{"parallel.device/PDCMD_SETPARAMS" Link "PDCMD_SETPARAMS"}
@EndNode
@Node "parallel_CMD_RESET" "parallel.device/CMD_RESET"
@{b}@{u}Reset@{uu}@{ub} -- reinitializes the parallel device.
  This command resets the parallel device to its freshly initialized condition.
  It aborts all I/O requests both queued and current and sets the devices's
  flags and parameters to their boot-up time default values.At boot-up time
  the PTermArray is random, and it will be so also here.
IO REQUEST
  @{i}io_Message@{ui} - @{i}mn_ReplyPort@{ui} initialized
  @{i}io_Device@{ui} - set by @{"OpenDevice" Link "parallel_OpenDevice()"}
  @{i}io_Unit@{ui} - set by @{"OpenDevice" Link "parallel_OpenDevice()"}
  @{i}io_Command@{ui} - @{i}CMD_RESET@{ui} (01)
RESULTS
  @{i}@{b}io_Error@{ub}@{ui} -- if the Reset succeded, then @{i}io_Error@{ui} will be null.
    If the Reset failed, then the @{i}io_Error@{ui} will be non-zero.
@EndNode
@Node "parallel_CMD_START" "parallel.device/CMD_START"
@{b}@{u}Start@{uu}@{ub} -- restart paused I/O over the parallel port.
  This command restarts the current I/O activity on the parallel port by
  reactivating the handshaking sequence.
IO REQUEST
  @{i}io_Message@{ui} - @{i}mn_ReplyPort@{ui} initialized
  @{i}io_Device@{ui} - set by @{"OpenDevice" Link "parallel_OpenDevice()"}
  @{i}io_Unit@{ui} - set by @{"OpenDevice" Link "parallel_OpenDevice()"}
  @{i}io_Command@{ui} - @{i}CMD_START@{ui} (07)
SEE ALSO
  @{"parallel.device/CMD_STOP" Link "parallel_CMD_STOP"}
@EndNode
@Node "parallel_CMD_STOP" "parallel.device/CMD_STOP"
@{b}@{u}Stop@{uu}@{ub} -- pause current activity on the parallel device.
  This command halts the current I/O activity on the parallel device by
  discontinuing the handshaking sequence.The stop and start commands
  may not be nested.
IO REQUEST
  @{i}io_Message@{ui} - @{i}mn_ReplyPort@{ui} initialized
  @{i}io_Device@{ui} - set by @{"OpenDevice" Link "parallel_OpenDevice()"}
  @{i}io_Unit@{ui} - set by @{"OpenDevice" Link "parallel_OpenDevice()"}
  @{i}io_Command@{ui} - @{i}CMD_STOP@{ui} (06)
SEE ALSO
  @{"parallel.device/CMD_START" Link "parallel_CMD_START"}
@EndNode
@Node "parallel_CMD_WRITE" "parallel.device/CMD_WRITE"
@{b}@{u}Write@{uu}@{ub} -- send output to parallel port.
  This command causes a stream of characters to be written to the parallel
  output register.The number of characters is specified in @{i}io_Length@{ui}, unless
  -1 is used, in which case output is sent until a zero byte occurs in the data.
  This is independent of,and may be used simultaneously with setting the EOFMODE
  in @{i}io_ParFlags@{ui} and using the PTermArray to terminate the read or write.
IO REQUEST
  @{i}io_Message@{ui} - @{i}mn_ReplyPort@{ui} initialized
  @{i}io_Device@{ui} - set by @{"OpenDevice" Link "parallel_OpenDevice()"}
  @{i}io_Unit@{ui} - set by @{"OpenDevice" Link "parallel_OpenDevice()"}
  @{i}io_Command@{ui} - @{i}CMD_WRITE@{ui} (03)
  @{i}io_Flags@{ui} - If @{i}IOF_QUICK@{ui} is set, driver will attempt Quick IO
  @{i}io_Length@{ui} - number of characters to transmit,
    or if set to -1 send until zero byte encountered
  @{i}io_Data@{ui} - pointer to block of data to transmit
RESULTS
  @{i}@{b}io_Error@{ub}@{ui} -- If the Write succeded, then @{i}io_Error@{ui} will be null.
    If the Write failed, then @{i}io_Error@{ui} will contain an error code.
SEE ALSO
  @{"parallel.device/PDCMD_SETPARAMS" Link "PDCMD_SETPARAMS"}
@EndNode
@Node "parallel_OpenDevice()" "parallel.device/OpenDevice"
@{b}@{u}Open@{uu}@{ub} -- a request to open the parallel port.
  This function allows the requestor software access to the parallel
  device.Unless the shared-access bit (bit 5 of @{i}io_ParFlags@{ui}) is
  set, exclusive use is granted and no other access is allowed
  until the owner closes the device.
  A @{b}FAST_MODE@{ub}, can be specified (bit 3 of @{i}io_Parflags@{ui}) to speed up
  transfers to high-speed printers.Rather than waiting for the printer
  to acknowledge a character using the *ACK interrupt, this mode will
  send out data as long as the BUSY signal is low.The printer must be
  able to raise the BUSY signal within 3 micro-seconds on A2630s, otherwise
  data will be lost.Should be used only in an exclusive-access @{"Open()" Link "dos.guide/Open()"}.
  A @{b}@{u}SLOWMODE@{uu}@{ub} mode can be specified (bit 4 of @{i}io_ParFlags@{ui}) when very
  slow printers are used.If the printer acknowledges data at less
  than 5000 bytes per second, then this mode will actually save CPU
  time, although it consumes much more with high-speed printers.
  The PTermArray of the ioExtPar is initialized only if the EOFMODE
  bit (bit 1 of @{i}io_ParFlags@{ui}) is set.The PTermArray can be further
  modified using the @{"PDCMD_SETPARAMS" Link "PDCMD_SETPARAMS"} command.
SYNOPSIS
  @{i}@{b}error@{ub}@{ui} = OpenDevice(@{FG shine}"@{i}parallel.device@{ui}"@{FG text}, @{i}unit@{ui}, @{i}ioExtPar@{ui}, @{i}flags@{ui})
   D0                  A0                D0    A1        D1
  @{FG shine}"@{i}parallel.device@{ui}"@{FG text} - a pointer to literal string "parallel.device"
  @{i}unit@{ui} - Must be zero for future compatibility
  @{i}ioExtPar@{ui} - pointer to an IO Request block of structure IOExtPar to be
    initialized by the @{"Open()" Link "dos.guide/Open()"} function.
    The @{i}io_ParFlags@{ui} field must be set as desired.
  @{i}flags@{ui} - Must be zero for future compatibility
  @{i}@{b}d0@{ub}@{ui} -- same as @{i}io_Error@{ui}
  @{i}@{b}io_Error@{ub}@{ui} -- if the Open succeded, then @{i}io_Error@{ui} will be null.
    If the Open failed, then @{i}io_Error@{ui} will be non-zero.
SEE ALSO
  @{"exec/CloseDevice" Link "serial/CloseDevice()"}
@EndNode
@Node "PDCMD_QUERY" "parallel.device/PDCMD_QUERY"
@{b}@{u}Query@{uu}@{ub} -- query parallel port/line status.
  This command return the status of the parallel port lines and registers.
IO REQUEST
  @{i}io_Message@{ui} - must have @{i}mn_ReplyPort@{ui} initialized
  @{i}io_Device@{ui} - set by @{"OpenDevice" Link "parallel_OpenDevice()"}
  @{i}io_Unit@{ui} - set by @{"OpenDevice" Link "parallel_OpenDevice()"}
  @{i}io_Command@{ui} - @{i}PDCMD_QUERY@{ui} (09)
RESULTS
  @{i}@{b}io_Status@{ub}@{ui} - @{b}@{u}BIT@{uu}@{ub}: @{b}@{u}ACTIVE@{uu}@{ub}: @{b}@{u}FUNCTION@{uu}@{ub}:
               0    high   printer busy toggle (offline)
               1    high   paper out
               2    high   printer selected on the A1000 printer selected &
                           serial "Ring Indicator" on the A500/A2000
                           Use care when making cables.
               3     -     read=0,write=1
              4-7          reserved
BUGS
  In a earlier version of this AutoDoc, BUSY and PSEL were reversed.
  The function has always been correct.
@EndNode
@Node "PDCMD_SETPARAMS" "parallel.device/PDCMD_SETPARAMS"
@{b}@{u}SetParams@{uu}@{ub} -- change parameters for the parallel device.
  This command allows the caller to change the EOFMODE parameter for
  the parallel port device.It will disallow changes if any reads or
  writes are active or queued.
  The @{i}PARB_EOFMODE@{ui} bit of @{i}io_ParFlags@{ui} controlls whether the @{i}io_PTermArray@{ui} is
  to be used as an additional termination criteria for reads and writes.It
  may be set directly without a call to SetParams, setting it here performs the
  additional service of copying the PTermArray into the device default array
  which is used as the initial array for subsequent device opens.The Shared bit
  can be changed here, and overrides the current device access mode set at
  @{"OpenDevice" Link "parallel_OpenDevice()"} time.
IO REQUEST
  @{i}io_Message@{ui} - @{i}mn_ReplyPort@{ui} initialized
  @{i}io_Device@{ui} - preset by @{"OpenDevice" Link "parallel_OpenDevice()"}
  @{i}io_Unit@{ui} - preset by @{"OpenDevice" Link "parallel_OpenDevice()"}
  @{i}io_Command@{ui} - @{i}PDCMD_SETPARAMS@{ui} (0A)
    @{i}NOTE@{ui} that the following fields of your @{"IORequest" Link "include:exec/io.h/Main" 18} are filled by Open
    to reflect the parallel device's current configuration.
  @{i}io_PExtFlags@{ui} - must be set to zero, unless used
  @{i}io_ParFlags@{ui} - see definition in parallel.i or parallel.h
    @{i}NOTE@{ui} that x00 yields exclusive access, PTermArray inactive.
  @{i}io_PTermArray@{ui} - ASCII descending-ordered 8-byte array of termination characters.
    If less than 8 chars used, fill out array w/lowest valid value.Terminators
    are used only if @{i}EOFMODE@{ui} bit of @{i}io_Parflags@{ui} is set (e.g. x512F040303030303 ).
    This field is filled on @{"OpenDevice" Link "parallel_OpenDevice()"} only if the @{i}EOFMODE@{ui} bit is set.
RESULTS
  @{i}@{b}io_Error@{ub}@{ui} -- if the SetParams succeded, then @{i}io_Error@{ui} will be null.
    If the SetParams failed, then @{i}io_Error@{ui} will be non-zero.
@EndNode
@Node "TD_CMD_CLEAR" "trackdisk.device/CMD_CLEAR"
@{b}@{u}CMD_CLEAR/ETD_CLEAR@{uu}@{ub} -- mark the track buffer as containing invalid data.
  These commands mark the track buffer as invalid, forcing a
  reread of the disk on the next operation.ETD_UPDATE or @{"CMD_UPDATE" Link "TD_CMD_UPDATE"}
  would be used to force data out to the disk before turning the motor
  off.ETD_CLEAR or CMD_CLEAR are usually used after having locked out
  the trackdisk.device via the use of the disk resource, when you
  wish to prevent the track from being updated, or when you wish to
  force the track to be re-read.ETD_CLEAR or CMD_CLEAR will not do an
  update, nor will an update command do a clear.
IO REQUEST INPUT
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  CMD_CLEAR or ETD_CLEAR
  @{i}io_Flags@{ui}    0 or IOF_QUICK
  @{i}iotd_Count@{ui}  (ETD_CLEAR only) maximum allowable change counter value.
IO REQUEST RESULT
  @{i}@{b}io_Error@{ub}@{ui} - 0 for success,or an error code as defined in @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
SEE ALSO
  @{"CMD_WRITE" Link "TD_CMD_WRITE"}, @{"CMD_UPDATE" Link "TD_CMD_UPDATE"}
@EndNode
@Node "TD_CMD_READ" "trackdisk.device/CMD_READ"
@{b}@{u}CMD_READ/ETD_READ@{uu}@{ub} -- read sectors of data from a disk.
  These commands transfer data from the track buffer to a supplied buffer.
  If the desired sector is already in the track buffer, no disk activity is
  initiated.If the desired sector is not in the buffer, the track containing
  that sector is automatically read in.If the data in the current track buffer
  has been modified, it is written out to the disk before a new track is read.
  ETD_READ will read the sector label area if the iotd_SecLabel is non-NULL.
IO REQUEST INPUT
  @{i}io_Device@{ui}     preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}       preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}    CMD_READ or ETD_READ
  @{i}io_Flags@{ui}      0 or IOF_QUICK
  @{i}io_Data@{ui}       pointer to the buffer where the data should be put
  @{i}io_Length@{ui}     number of bytes to read, must be a multiple of TD_SECTOR.
  @{i}io_Offset@{ui}     byte offset from the start of the disk describing
      where to read data from, must be a multiple of TD_SECTOR.
  @{i}iotd_Count@{ui}    (ETD_READ only) maximum allowable change counter value.
  @{i}iotd_SecLabel@{ui} (ETD_READ only) NULL or sector label buffer pointer.
    If provided, the buffer must be a multiple of TD_LABELSIZE.
IO REQUEST RESULT
  @{i}@{b}io_Error@{ub}@{ui} - 0 for success,or an error code as defined in @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
NOTES
  Under versions of Kickstart earlier than V36, the io_Data had to point to a
  buffer in chip memory.This restriction is no longer present as of Kickstart
  V36 and beyond.
SEE ALSO
  @{"CMD_WRITE" Link "TD_CMD_WRITE"}
@EndNode
@Node "TD_CMD_UPDATE" "trackdisk.device/CMD_UPDATE"
@{b}@{u}CMD_UPDATE/ETD_UPDATE@{uu}@{ub} -- write out the track buffer if it is dirty.
  The trackdisk device does not write data sectors unless it is necessary
  (you request that a different track be used) or until the user requests that
  an update be performed.This improves system speed by caching disk operations.
  These commands ensure that any buffered data is flushed out to the disk.If the
  track buffer has not been changed since the track was read in, these commands
  do nothing.ETD_UPDATE command checks for diskchange.
IO REQUEST INPUT
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  CMD_UPDATE or ETD_UPDATE
  @{i}io_Flags@{ui}    0 or IOF_QUICK
  @{i}iotd_Count@{ui}  (ETD_UPDATE only) maximum allowable change counter value.
IO REQUEST RESULT
  @{i}@{b}io_Error@{ub}@{ui} - 0 for success,or an error code as defined in @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
SEE ALSO
  @{"CMD_WRITE" Link "TD_CMD_WRITE"}
@EndNode
@Node "TD_CMD_WRITE" "trackdisk.device/CMD_WRITE"
@{b}@{u}CMD_WRITE/ETD_WRITE@{uu}@{ub} -- write sectors of data to a disk.
  These commands transfer data from a supplied buffer to the track
  buffer.If the track that contains this sector is already in the track
  buffer, no disk activity is initiated.If the desired sector is not in
  the buffer, the track containing that sector is automatically read in.
  If the data in the current track buffer has been modified, it is
  written out to the disk before the new track is read in for modification.
  ETD_WRITE will write the sector label area if iotd_SecLabel is non-NULL.
IO REQUEST INPUT
  @{i}io_Device@{ui}      preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}        preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}     CMD_WRITE or ETD_WRITE
  @{i}io_Flags@{ui}       0 or IOF_QUICK
  @{i}io_Data@{ui}        pointer to the buffer where the data should be put
  @{i}io_Length@{ui}      number of bytes to write, must be a multiple of TD_SECTOR.
  @{i}io_Offset@{ui}      byte offset from the start of the disk describing where to
    write data to, must be a multiple of TD_SECTOR.
  @{i}iotd_Count@{ui}     (ETD_WRITE only) maximum allowable change counter value.
  @{i}iotd_SecLabel@{ui}  (ETD_WRITE only) NULL or sector label buffer pointer.
    If provided, the buffer must be a multiple of TD_LABELSIZE.
IO REQUEST RESULT
  @{i}@{b}io_Error@{ub}@{ui} - 0 for success,or an error code as defined in@{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
NOTES
  Under versions of Kickstart earlier than V36, the io_Data had to point to a
  buffer in chip memory.This restriction is no longer present as of Kickstart
  V36 and beyond.
SEE ALSO
  @{"CMD_READ" Link "TD_CMD_READ"}, @{"TD_FORMAT" Link "TD_FORMAT"}
@EndNode
@Node "TD_ADDCHANGEINT" "trackdisk.device/TD_ADDCHANGEINT"
@{b}@{u}TD_ADDCHANGEINT@{uu}@{ub} -- add a disk change software interrupt handler.
  This command lets you add a software interrupt handler to the disk device
  that gets invoked whenever a disk insertion or removal occurs.
  You must pass in a properly initialized Exec @{"Interrupt" Link "include:exec/interrupts.h/Main" 23} structure
  and be prepared to deal with disk insertions/removals immediately.
  From within the interrupt handler, you may only call the status commands
  that can use IOF_QUICK.
  To set up the handler, an Interrupt structure must be initialized.
  This structure is supplied as the io_Data to the TD_ADDCHANGEINT command.
  The handler then gets linked into the handler chain and gets invoked whenever
  a disk change happens.You must eventually remove the handler before you exit.
  This command only returns when the handler is removed.That is,the device holds
  onto the IO request until the @{"TD_REMCHANGEINT" Link "TD_REMCHANGEINT"} command is executed with that
  same IO request.Hence, you must use @{"SendIO()" Link "exec.guide/SendIO()"} with this command.
IO REQUEST INPUT
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  TD_ADDCHANGEINT
  @{i}io_Flags@{ui}    0
  @{i}io_Length@{ui}   @{FG shine}sizeof@{FG text}(@{FG shine}struct@{FG text} Interrupt)
  @{i}io_Data@{ui}     pointer to Interrupt structure
IO REQUEST RESULT
  @{i}@{b}io_Error@{ub}@{ui} - 0 for success,or an error code as defined in @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
SEE ALSO
  @{"TD_REMCHANGEINT" Link "TD_REMCHANGEINT"}, @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}, @{"<exec/interrupts.h>" Link "include:exec/interrupts.h/Main" 0},
  @{"exec.library/Cause()" Link "exec.guide/Cause()"}
@EndNode
@Node "TD_CHANGENUM" "trackdisk.device/TD_CHANGENUM"
@{b}@{u}TD_CHANGENUM@{uu}@{ub} - return the current value of the disk-change counter.
  This command returns the current value of the disk-change counter
  (as used by the enhanced commands).The disk change counter is incremented
  each time a disk is inserted or removed from the trackdisk unit.
IO REQUEST INPUT
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  TD_CHANGENUM
  @{i}io_Flags@{ui}    0 or IOF_QUICK
IO REQUEST RESULT
  @{i}@{b}io_Error@{ub}@{ui} - 0 for success,or an error code as defined in @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
  @{i}@{b}io_Actual@{ub}@{ui} - if io_Error is 0, this contains the current value of the
    disk-change counter.
@EndNode
@Node "TD_CHANGESTATE" "trackdisk.device/TD_CHANGESTATE"
@{b}@{u}TD_CHANGESTATE@{uu}@{ub} -- check if a disk is currently in a drive.
  This command checks to see if there is currently a disk in a drive.
IO REQUEST INPUT
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  TD_CHANGESTATE
  @{i}io_Flags@{ui}    0 or IOF_QUICK
IO REQUEST RESULT
  @{i}@{b}io_Error@{ub}@{ui} - 0 for success,or an error code as defined in @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
  @{i}@{b}io_Actual@{ub}@{ui} - if io_Error is 0, this tells you whether a disk is in the drive.
    0 means there is a disk, while anything else indicates there is no disk.
@EndNode
@Node "TD_EJECT" "trackdisk.device/TD_EJECT"
@{b}@{u}TD_EJECT@{uu}@{ub} -- eject (or load) the disk in the drive, if possible.
  This command causes the drive to attempt to eject the disk in it, if any.
  Note that the current trackdisk.device does not implement this command, but it
  might in the future, and other trackdisk-compatible drivers may implement
  this command.Some devices may be able to load disks on command also.
IO REQUEST INPUT
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  TD_EJECT
  @{i}io_Flags@{ui}    0 or IOF_QUICK
  @{i}io_Length@{ui}   0 (load, if supported) or 1 (eject)
IO REQUEST RESULT
  @{i}@{b}io_Error@{ub}@{ui} - 0 for success, or an error code as defined in @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
BUGS
  The pre-@{b}V40@{ub} autodoc didn't mention io_Length.Because of this, for devices
  that can never support load, a driver might want to eject if io_Length is 0.
@EndNode
@Node "TD_FORMAT" "trackdisk.device/TD_FORMAT"
@{b}@{u}TD_FORMAT/ETD_FORMAT@{uu}@{ub} -- format a track on a disk.
  These commands are used to write data to a track that either has not yet been
  formatted or has had a hard error on a standard write command.TD_FORMAT
  completely ignores all data currently on a track and does not check for disk
  change before performing the command.The io_Data field must point to at least
  one track worth of data.The io_Offset field must be track aligned, and the
  io_Length field must be in units of track length (that is, NUMSEC*TD_SECTOR).
  The device will format the requested tracks, filling each sector with the
  contents of the buffer pointed to by io_Data.You should do a read pass to
  verify the data.
  If you have a hard write error during a normal write, you may find it
  possible to use the TD_FORMAT command to reformat the track as part of
  your error recovery process.ETD_FORMAT will write the sector label area
  if iotd_SecLabel is non-NULL.
IO REQUEST INPUT
  @{i}io_Device@{ui}      preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}        preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}     TD_FORMAT or ETD_FORMAT
  @{i}io_Flags@{ui}       0 or IOF_QUICK
  @{i}io_Data@{ui}        points to a buffer containing the data to write to the track,
     must be at least as large as io_Length.
  @{i}io_Length@{ui}      number of bytes to format,
    must be a multiple of (TD_SECTORS * NUMSEC).
  @{i}io_Offset@{ui}      byte offset from the start of the disk for the track to format,
    must be a multiple of (TD_SECTORS * NUMSEC).
  @{i}iotd_Count@{ui}     (ETD_FORMAT only) maximum allowable change counter value.
  @{i}iotd_SecLabel@{ui}  (ETD_FORMAT only) NULL or sector label buffer pointer.
      If provided, the buffer must be a multiple of (TD_LABELSIZE * NUMSEC).
IO REQUEST RESULT
  @{i}@{b}io_Error@{ub}@{ui} - 0 for success,or an error code as defined in @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
NOTES
  Under versions of Kickstart earlier than V36, the io_Data had to point to a
  buffer in chip memory.This restriction is no longer present as of Kickstart
  V36 and beyond.
SEE ALSO
  @{"CMD_WRITE" Link "TD_CMD_WRITE"}, @{"TD_RAWWRITE" Link "TD_RAWWRITE"}
@EndNode
@Node "TD_GETDRIVETYPE" "trackdisk.device/TD_GETDRIVETYPE"
@{b}@{u}TD_GETDRIVETYPE@{uu}@{ub} -- return the type of disk drive for the unit that was opened.
  This command returns the type of the disk drive to the user.
  This number will be a small integer and will come from the set of
  DRIVEXXX constants defined in @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}.
  The only way you can actually use this command is if the trackdisk device
  understands the drive type of the hardware that is plugged in.This is because
  the@{"OpenDevice()" Link "exec.guide/OpenDevice()"} call will fail if the trackdisk device does not understand
  the drive type.To find raw drive identifiers see the disk.resource's
  @{"DR_GETUNITID" link rexources.guide/GetUnitID()} entry point.
IO REQUEST INPUT
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  TD_GETDRIVETYPE
  @{i}io_Flags@{ui}    0 or IOF_QUICK
IO REQUEST RESULT
  @{i}@{b}io_Error@{ub}@{ui} - 0 for success,or an error code as defined in @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
  @{i}@{b}io_Actual@{ub}@{ui} - if io_Error is 0 this contains the drive type connected to
    this unit.
SEE ALSO
  @{"TD_GETNUMTRACKS" Link "TD_GETNUMTRACKS"}, @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
@EndNode
@Node "TD_GETGEOMETRY" "trackdisk.device/TD_GETGEOMETRY"
@{b}@{u}TD_GETGEOMETRY@{uu}@{ub} -- return the geometry of the drive.
  This command returns a full set of information about the layout of the drive.
  The information is returned in the DriveGeometry structure pointed to by
  io_Data.
IO REQUEST INPUT
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  TD_GETGEOMETRY
  @{i}io_Flags@{ui}    0 or IOF_QUICK
  @{i}io_Data@{ui}     Pointer to a @{"DriveGeometry" Link "include:devices/trackdisk.h/Main" 135} structure
  @{i}io_Length@{ui}   @{FG shine}sizeof@{FG text}(@{FG shine}struct@{FG text} DriveGeometry)
IO REQUEST RESULT
  @{i}@{b}io_Error@{ub}@{ui} - 0 for success,or an error code as defined in @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
NOTE
  This information may change when a disk in inserted when certain hardware
  is present.
SEE ALSO
  @{"TD_GETDRIVETYPE" Link "TD_GETDRIVETYPE"}, @{"TD_GETNUMTRACKS" Link "TD_GETNUMTRACKS"}
@EndNode
@Node "TD_GETNUMTRACKS" "trackdisk.device/TD_GETNUMTRACKS"
@{b}@{u}TD_GETNUMTRACKS@{uu}@{ub} -- return the number of tracks for the type of disk drive for
  the unit that was opened.
  This command returns the number of tracks that are available on the disk unit.
IO REQUEST INPUT
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  TD_GETNUMTRACKS
  @{i}io_Flags@{ui}    0 or IOF_QUICK
IO REQUEST RESULT
  @{i}@{b}io_Error@{ub}@{ui} - 0 for success,or an error code as defined in @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
  @{i}@{b}io_Actual@{ub}@{ui} - if io_Error is 0 this contains the drive type connected to
    this unit.
SEE ALSO
  @{"TD_GETDRIVETYPE" Link "TD_GETDRIVETYPE"}
@EndNode
@Node "TD_MOTOR" "trackdisk.device/TD_MOTOR"
@{b}@{u}TD_MOTOR/ETD_MOTOR@{uu}@{ub} -- control the on/off state of a drive motor.
  This command gives control over the disk motor.The motor may be turned on
  or off.When it is on, the drive light automatically turns on as well.
  If the motor is just being turned on, the device will delay the
  proper amount of time to allow the drive to come up to speed.
  Normally, turning the drive on is not necessary, the device does this
  automatically if it receives a request when the motor is off.However,
  turning the motor off is the programmer's responsibility.In addition, the
  standard instructions to the user are that it is safe to remove a disk from
  a drive if and only if the motor is off (that is, if the disk light is off).
IO REQUEST INPUT
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  TD_MOTOR or ETD_MOTOR
  @{i}io_Flags@{ui}    0 or IOF_QUICK
  @{i}io_Length@{ui}   the requested state of the motor,
    0 to turn the motor off, and 1 to turn the motor on.
  @{i}iotd_Count@{ui}  (ETD_MOTOR only) maximum allowable change counter value.
IO REQUEST RESULT
  @{i}@{b}io_Error@{ub}@{ui} - 0 for success,or an error code as defined in @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
  @{i}@{b}io_Actual@{ub}@{ui} - if io_Error is 0 this contains the previous state of the
    drive motor.
@EndNode
@Node "TD_PROTSTATUS" "trackdisk.device/TD_PROTSTATUS"
@{b}@{u}TD_PROTSTATUS@{uu}@{ub} -- return whether the current disk is write-protected.
  This command is used to determine whether the current disk is write-protected.
IO REQUEST INPUT
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  TD_PROTSTATUS
  @{i}io_Flags@{ui}    0 or IOF_QUICK
IO REQUEST RESULT
  @{i}@{b}io_Error@{ub}@{ui} - 0 for success,or an error code as defined in @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
  @{i}@{b}io_Actual@{ub}@{ui} - if io_Error is 0, this tells you whether the disk in the drive is
    write-protected.
    0 means the disk is NOT write-protected,
    while any other value indicates it is.
@EndNode
@Node "TD_RAWREAD" "trackdisk.device/TD_RAWREAD"
@{b}@{u}TD_RAWREAD/ETD_RAWREAD@{uu}@{ub} -- read raw data from the disk.
  These commands read a track of raw data from disk and deposits it in the
  provided buffer.The data is taken straight from the disk with no processing
  done on it.It will appear exactly as the bits come out off the disk, hopefully
  in some legal MFM format.
  This interface is intended for sophisticated programmers only.
  Commodore-Amiga reserves the right to make enhancements to the disk format in
  the future.We will provide compatibility via the @{"CMD_READ" Link "TD_CMD_READ"} and ETD_READ
  commands, anyone using TD_RAWREAD is bypassing this upwards compatibility, and
  may thus stop working.
IO REQUEST INPUT
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  TD_RAWREAD or ETD_RAWREAD.
  @{i}io_Flags@{ui}    if the IOTDB_INDEXSYNC bit is set then the driver will make a best
    effort attempt to start reading from the index mark.
    Note that there will be at least some, and perhaps a great deal of delay
    (for example if interrupts have been disabled).
  @{i}io_Length@{ui}   Length of buffer in bytes, with a maximum of 32768 bytes.
  @{i}io_Data@{ui}     Pointer to CHIP memory buffer where
    raw track data is to be deposited.
  @{i}io_Offset@{ui}   The number of the track to read in.
  @{i}iotd_Count@{ui}  (ETD_RAWREAD only) maximum allowable change counter value.
IO REQUEST RESULT
  @{i}@{b}io_Error@{ub}@{ui} - 0 for success,or an error code as defined in @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
NOTES
  The track buffer provided MUST be in CHIP memory.
  There is a delay between the index pulse and the start of bits coming in from
  the drive (e.g.dma started).This delay is in the range of 135-200 microseconds.
  This delay breaks down as follows:
    55 microsecs is software interrupt overhead
      (this is the time from interrupt to the write of the DSKLEN register).
    66 microsecs is one horizontal line delay
      (remember that disk IO is synchronized with agnus' display fetches).
    The last variable (0-65 microsecs) is an additional scan line since DSKLEN
    is poked anywhere in the horizontal line.
  This leaves 15 microsecs unaccounted for...Sigh.
  In short, You will almost never get bits within the first 135 microseconds of
  the index pulse, and may not get it until 200 microseconds.At 4 microsecs/bit,
  this works out to be between 4 and 7 bytes of user data of delay.
BUGS
  This command does not work reliably under versions of Kickstart earlier
  than V36, especially on systems with 1 floppy drive.
SEE ALSO
  @{"TD_RAWWRITE" Link "TD_RAWWRITE"}
@EndNode
@Node "TD_RAWWRITE" "trackdisk.device/TD_RAWWRITE"
@{b}@{u}TD_RAWWRITE/ETD_RAWWRITE@{uu}@{ub} -- write raw data to the disk.
  This command writes a track of raw data from the provided buffer to the
  specified track on disk.The data is copied straight to the disk with no
  processing done on it.It will appear exactly on the disk as it is in the
  memory buffer, hopefully in a legal MFM format.
  This interface is intended for sophisticated programmers only.
  Commodore-Amiga reserves the right to make enhancements to the disk format in
  the future.We will provide compatibility via the @{"CMD_WRITE" Link "TD_CMD_WRITE"} and ETD_WRITE
  commands, anyone using TD_RAWWRITE is bypassing this upwards compatibility,
  and may thus stop working.
IO REQUEST INPUT
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  TD_RAWWRITE or ETD_RAWWRITE.
  @{i}io_Flags@{ui}    if the IOTDB_INDEXSYNC bit is set then the driver will make a best
    effort attempt to start writing from the index mark.
    Note that there will be at least some, and perhaps a great deal of delay
    (for example if interrupts have been disabled).
  @{i}io_Length@{ui}   Length of buffer in bytes, with a maximum of 32768 bytes.
  @{i}io_Data@{ui}     Pointer to CHIP memory buffer where raw track data is to be taken.
  @{i}io_Offset@{ui}   The number of the track to write to.
  @{i}iotd_Count@{ui}  (ETD_RAWWRITE only) maximum allowable change counter value.
IO REQUEST RESULT
  @{i}@{b}io_Error@{ub}@{ui} - 0 for success,or an error code as defined in @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
NOTES
  The track buffer provided MUST be in CHIP memory.
  There is a delay between the index pulse and the start of bits going out to
  the driver (e.g.write gate enabled).This delay is in the range of 135-200
  microseconds.This delay breaks down as follows:
    55 microsecs is software interrupt overhead
      (this is the time from interrupt to the write of the DSKLEN register).
    66 microsecs is one horizontal line delay
      (remember that disk IO is synchronized with agnus' display fetches).
    The last variable (0-65 microsecs) is an additional scan line since DSKLEN
    is poked anywhere in the horizontal line.
  This leaves 15 microsecs unaccounted for...Sigh.
  In short, You will almost never get bits within the first 135 microseconds of
  the index pulse, and may not get it until 200 microseconds.At 4 microsecs/bit,
  this works out to be between 4 and 7 bytes of user data of delay.
BUGS
  This command does not work reliably under versions of Kickstart earlier
  than V36, especially on systems with 1 floppy drive.
SEE ALSO
  @{"TD_RAWREAD" Link "TD_RAWREAD"}
@EndNode
@Node "TD_REMCHANGEINT" "trackdisk.device/TD_REMCHANGEINT"
@{b}@{u}TD_REMCHANGEINT@{uu}@{ub} -- remove a disk change software interrupt handler.
  This command removes a disk change software interrupt added
  by a previous use of @{"TD_ADDCHANGEINT" Link "TD_ADDCHANGEINT"}.
IO REQUEST INPUT
  The same IO request used for @{"TD_ADDCHANGEINT" Link "TD_ADDCHANGEINT"}.
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  TD_REMCHANGEINT
  @{i}io_Flags@{ui}    0
  @{i}io_Length@{ui}   @{FG shine}sizeof@{FG text}(@{FG shine}struct@{FG text} Interrupt)
  @{i}io_Data@{ui}     pointer to @{"Interrupt" Link "include:exec/interrupts.h/Main" 23} structure
IO REQUEST RESULT
  @{i}@{b}io_Error@{ub}@{ui} - 0 for success,or an error code as defined in @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
BUGS
  This command did not function properly under versions of Kickstart earlier
  than V36.A valid workaround under these older versions of Kickstart is:
    Forbid();
    Remove(@{i}ioRequest@{ui});
    Permit();
  Do not use this workaround in versions of Kickstart >= V36, use
  TD_REMCHANGEINT instead (for future compatibility with V38+).
SEE ALSO
  @{"TD_ADDCHANGEINT" Link "TD_ADDCHANGEINT"}, @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
@EndNode
@Node "TD_SEEK" "trackdisk.device/TD_SEEK"
@{b}@{u}TD_SEEK/ETD_SEEK@{uu}@{ub} -- control positioning of the drive heads.
  These commands are currently provided for internal diagnostics, disk repair,
  and head cleaning only.
  TD_SEEK and ETD_SEEK move the drive heads to the track specified.The io_Offset
  field should be set to the (byte) offset to which the seek is to occur.
  TD_SEEK and ETD_SEEK do not verify their position until the next read.
  That is, they only move the heads; they do not actually read any data.
IO REQUEST INPUT
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice()" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  TD_SEEK or ETD_SEEK
  @{i}io_Flags@{ui}    0 or IOF_QUICK
  @{i}io_Offset@{ui}   byte offset from the start of the disk describing
    where to move the head to.
  @{i}iotd_Count@{ui}  (ETD_SEEK only) maximum allowable change counter value.
IO REQUEST RESULT
  @{i}@{b}io_Error@{ub}@{ui} - 0 for success,or an error code as defined in @{"<devices/trackdisk.h>" Link "include:devices/trackdisk.h/Main" 0}
@EndNode
@Node "CBD_CHANGEHOOK" "clipboard.device/CBD_CHANGEHOOK"
@{b}@{u}CBD_CHANGEHOOK@{uu}@{ub} -- Add or remove a clip change hook.
  CBD_CHANGEHOOK allows specification of a hook to be called
  when the data on the clipboard has changed.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set up
  @{i}io_Device@{ui}   preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  CBD_CHANGEHOOK
  @{i}io_Length@{ui}   0 to remove, 1 to install this hook
  @{i}io_Data@{ui}     @{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *, the clip change hook
HOOK ENVIRONMENT
  @{i}@{b}hook message@{ub}@{ui} - a @{"ClipHookMsg" Link "include:devices/clipboard.h/Main" 64}, as defined in @{"devices/clipboard.h" Link "include:devices/clipboard.h/Main" 0}
    @{i}@{b}chm_Type@{ub}@{ui} - 0, indicating that the message has the following fields:
    @{i}@{b}chm_ClipID@{ub}@{ui} - the clip ID of the clip triggering the change
  @{i}@{b}hook object@{ub}@{ui} - @{i}io_Unit@{ui}
@EndNode
@Node "CBD_CURRENTREADID" "clipboard.device/CBD_CURRENTREADID"
@{b}@{u}CBD_CURRENTREADID@{uu}@{ub} - Determine the current read identifier.
  CBD_CURRENTREADID fills the io_ClipID with a clip identifier that
  can be compared with that of a post command: if greater than
  the post identifier then the post data held privately by an
  application is not valid for its own pasting.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set up
  @{i}io_Device@{ui}   preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  CBD_CURRENTREADID
RESULTS
  @{i}@{b}io_ClipID@{ub}@{ui} the ClipID of the current write is set
@EndNode
@Node "CBD_CURRENTWRITEID" "clipboard.device/CBD_CURRENTWRITEID"
@{b}@{u}CBD_CURRENTWRITEID@{uu}@{ub} -- Determine the current write identifier.
  CBD_CURRENTWRITEID fills the io_ClipID with a clip identifier that
  can be compared with that of a post command: if greater than the
  post identifier then the post is obsolete and need never be satisfied.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set up
  @{i}io_Device@{ui}   preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  CBD_CURRENTWRITEID
RESULTS
  @{i}@{b}io_ClipID@{ub}@{ui} the ClipID of the current write is set
@EndNode
@Node "CBD_POST" "clipboard.device/CBD_POST"
@{b}@{u}CBD_POST@{uu}@{ub} -- Post availability of a clip to the clipboard.
  Indicate to the clipboard device that data is available for use by accessors
  of the clipboard.This is intended to be used when a cut is large, in a private
  data format, and/or changing frequently, and it thus makes sense to avoid
  converting it to an IFF form and writing it to the clipboard unless another
  application wants it.The post provides a message port to which the clipboard
  device will send a satisfy message if the data is required.If the satisfy
  message is received, the write associated with the post must be performed.
  The act of writing the clip indicates that the message has been received:
  it may then be re-used by the clipboard device, and so must actually be
  removed from the satisfy message port so that the port is not corrupted.
  If the application wishes to determine if a post it has performed is still the
  current clip, it should check the post's io_ClipID with that returned by the
  @{"CBD_CURRENTREADID" Link "CBD_CURRENTREADID"} command.
  If the current read io_ClipID is greater, the clip is not still current.
  If an application has a pending post and wishes to determine if it should
  satisfy it (e.g. before it exits), it should check the post's io_ClipID
  with that returned by the @{"CBD_CURRENTWRITEID" Link "CBD_CURRENTWRITEID"} command.If the current write
  io_ClipID is greater, there is no need to satisfy the post.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set up
  @{i}io_Device@{ui}   preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  CBD_POST
  @{i}io_Data@{ui}     pointer to satisfy message port
  @{i}io_ClipID@{ui}   zero
RESULTS
  @{i}@{b}io_Error@{ub}@{ui}  non-zero if an error occurred
  @{i}@{b}io_ClipID@{ub}@{ui} the clip ID assigned to this post, to be used in the write command
    if this is satisfied
@EndNode
@Node "CBD_CMD_READ" "clipboard.device/CMD_READ"
@{b}@{u}CMD_READ@{uu}@{ub} -- Read from a clip on the clipboard.
  The read function serves two purposes.
  When io_Offset is within the clip, this acts as a normal read request,
  and io_Data is filled with data from the clipboard.The first read request
  should have a zero io_ClipID, which will be filled with the ID assigned
  for this read.Normal sequential access from the beginning of the clip is
  achieved by setting io_Offset to zero for the first read, then leaving it
  untouched for subsequent reads.If io_Data is null, then io_Offset is
  incremented by io_Actual as if io_Length bytes had been read: this is
  useful to skip to the end of file by using a huge io_Length.
  When io_Offset is beyond the end of the clip, this acts as a signal to the
  clipboard device that the application is through reading this clip.Realize
  that while an application is in the middle of reading a clip, any attempts
  to write new data to the clipboard are held off.This read past the end of
  file indicates that those operations may now be initiated.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set up
  @{i}io_Device@{ui}   preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  CMD_READ
  @{i}io_Length@{ui}   number of bytes to put in data buffer
  @{i}io_Data@{ui}     pointer to buffer of data to fill, or null to skip over data
  @{i}io_Offset@{ui}   byte offset of data to read
  @{i}io_ClipID@{ui}   zero if this is the initial read
RESULTS
  @{i}@{b}io_Error@@{ub}{ui}   non-zero if an error occurred
  @{i}@{b}io_Actual@@{ub}{ui}  filled with the actual number of bytes read
  @{i}@{b}io_Data@@{ub}{ui}    (the buffer now has io_Actual bytes of data)
  @{i}@{b}io_Offset@@{ub}{ui}  updated to next read position,
    which is beyond EOF if io_Actual != io_Length
  @{i}@{b}io_ClipID@@{ub}{ui}  the clip ID assigned to this read:
    do not alter for subsequent reads
@EndNode
@Node "CBD_CMD_UPDATE" "clipboard.device/CMD_UPDATE"
@{b}@{u}CMD_UPDATE@{uu}@{ub} -- Terminate the writing of a clip to the clipboard.
  Indicate to the clipboard that the previous write commands are complete
  and can be used for any pending pastes (reads).This command cannot be
  issued while any of the write commands are pending.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set up
  @{i}io_Device@{ui}   preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  CMD_UPDATE
  @{i}io_ClipID@{ui}   the ClipID of the write
RESULTS
  @{i}@{b}io_Error@{ub}@{ui}  non-zero if an error occurred
@EndNode
@Node "CBD_CMD_WRITE" "clipboard.device/CMD_WRITE"
@{b}@{u}CMD_WRITE@{uu}@{ub} -- Write to a clip on the clipboard.
  This command writes data to the clipboard.This data can be provided
  sequentially by clearing io_Offset for the initial write, and using the
  incremented value unaltered for subsequent writes.If io_Offset is ever
  beyond the current clip size, the clip is padded with zeros.
  If this write is in response to a @{"SatisfyMsg" Link "include:devices/clipboard.h/Main" 58} for a pending post,
  then the io_ClipID returned by the @{"CBD_POST" Link "CBD_POST"} command must be used.
  Otherwise, a new ID is obtained by clearing the io_ClipID for the first write.
  Subsequent writes must not alter the io_ClipID.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set up
  @{i}io_Device@{ui}   preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  CMD_WRITE
  @{i}io_Length@{ui}   number of bytes from io_Data to write
  @{i}io_Data@{ui}     pointer to block of data to write
  @{i}io_Offset@{ui}   usually zero if this is the initial write
  @{i}io_ClipID@{ui}   zero if this is the initial write, ClipID of
    the Post if this is to satisfy a post
RESULTS
  @{i}@{b}io_Error@{ub}@{ui}   non-zero if an error occurred
  @{i}@{b}io_Actual@{ub}@{ui}  filled with the actual number of bytes written
  @{i}@{b}io_Offset@{ub}@{ui}  updated to next write position
  @{i}@{b}io_ClipID@{ub}@{ui}  the clip ID assigned to this write:
    do not alter for subsequent writes
@EndNode

@Node "GPD_ASKCTYPE" "gameport.device/GPD_ASKCTYPE"
@{b}@{u}GPD_ASKCTYPE@{uu}@{ub} -- Acquire the current game port controller type.
  This command identifies the type of controller at the game port,
  so that the signals at the port may be properly interpreted.
  The controller type has been set by a previous SetCType.
  This command always executes immediately.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  GPD_ASKCTYPE
  @{i}io_Flags@{ui}    IOB_QUICK set if quick I/O is possible
  @{i}io_Length@{ui}   at least 1
  @{i}io_Data@{ui}     the address of the byte variable for the result
@EndNode
@Node "GPD_ASKTRIGGER" "gameport.device/GPD_ASKTRIGGER"
@{b}@{u}GPD_ASKTRIGGER@{uu}@{ub} -- Inquire the conditions for a game port report.
  This command inquires what conditions must be met by a game port unit before
  a pending Read request will be satisfied.These conditions, called triggers,
  are independent -- that any one occurs is sufficient to queue a game port
  report to the Read queue.These conditions are set by SetTrigger.
  This command always executes immediately.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  GPD_ASKTRIGGER
  @{i}io_Flags@{ui}    IOB_QUICK set if quick I/O is possible
  @{i}io_Length@{ui}   @{FG shine}sizeof@{FG text}(gamePortTrigger)
  @{i}io_Data@{ui}     a structure of type @{"GamePortTrigger" Link "include:devices/gameport.h/Main" 37},
    which has the following elements
      @{i}gpt_Keys@{ui} - GPTB_DOWNKEYS set if button down transitions trigger a report,
        and GPTB_UPKEYS set if button up transitions trigger a report
      @{i}gpt_Timeout@{ui} - a time which, if exceeded, triggers a report;
        measured in vertical blank units (60/sec)
      @{i}gpt_XDelta@{ui}  - a distance in x which, if exceeded, triggers a report
      @{i}gpt_YDelta@{ui}  - a distance in x which, if exceeded, triggers a report
@EndNode
@Node "GPD_READEVENT" "gameport.device/GPD_READEVENT"
@{b}@{u}GPD_READEVENT@{uu}@{ub} -- Return the next game port event.
  Read game port events from the game port and put them in the data area of the
  iORequest.If there are no pending game port events, this command will not be
  satisfied, but if there are some events,but not as many as can fill IO_LENGTH,
  the request will be satisfied with those currently available.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  GPD_READEVENT
  @{i}io_Flags@{ui}    IOB_QUICK set if quick I/O is possible
  @{i}io_Length@{ui}   the size of the io_Data area in bytes:
    there are @{FG shine}sizeof@{FG text}(@{i}inputEvent@{ui}) bytes per input event.
  @{i}io_Data@{ui}     a buffer area to fill with input events.
    The fields of the input event are:
      @{i}ie_NextEvent@{ui}  links the events returned
      @{i}ie_Class@{ui}  is IECLASS_RAWMOUSE
      @{i}ie_SubClass@{ui}  is 0 for the left, 1 for the right game port
      @{i}ie_Code@{ui}  contains any gameport button reports.
        No report is indicated by the value 0xff.
      @{i}ie_Qualifier@{ui}  only the relative and button bits are set
      @{i}ie_X@{ui}, @{i}ie_Y@{ui}  the x and y values for this report,
        in either relative or absolute device dependent units.
      @{i}ie_TimeStamp@{ui}  the delta time since the last report, given not as a
        standard timestamp, but as the frame count in the TV_SECS field.
RESULTS
  This function sets the error field in the iORequest, and fills the
  iORequest with the next game port events (but not partial events).
SEE ALSO
  @{"gameport.device/SetCType" link GPD_SETCTYPE}, @{"gameport.device/SetTrigger" link GPD_SETTRIGGER}
@EndNode
@Node "GPD_SETCTYPE" "gameport.device/GPD_SETCTYPE"
@{b}@{u}GPD_SETCTYPE@{uu}@{ub} -- Set the current game port controller type.
  This command sets the type of device at the game port, so that
  the signals at the port may be properly interpreted.The port
  can also be turned off, so that no reports are generated.
  This command always executes immediately.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  GPD_SETCTYPE
  @{i}io_Flags@{ui}    IOB_QUICK set if quick I/O is possible
  @{i}io_Length@{ui}   1
  @{i}io_Data@{ui}     the address of the byte variable describing the controller type,
    as per the equates in the gameport include file
@EndNode
@Node "GPD_SETTRIGGER" "gameport.device/GPD_SETTRIGGER"
@{b}@{u}GPD_SETTRIGGER@{uu}@{ub} -- Set the conditions for a game port report.
  This command sets what conditions must be met by a game port unit before a
  pending Read request will be satisfied.These conditions, called triggers,
  are independent -- that any one occurs is sufficient to queue a game port
  report to the Read queue.These conditions are inquired with AskTrigger.
  This command always executes immediately.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  GPD_SETTRIGGER
  @{i}io_Flags@{ui}    IOB_QUICK set if quick I/O is possible
  @{i}io_Length@{ui}   @{FG shine}sizeof@{FG text}(@{i}gamePortTrigger@{ui})
  @{i}io_Data@{ui}     a structure of type @{"GamePortTrigger" Link "include:devices/gameport.h/Main" 37}, which has the following elements
    @{i}gpt_Keys@{ui} - GPTB_DOWNKEYS set if button down transitions trigger a report,
      and GPTB_UPKEYS set if button up transitions trigger a report
    @{i}gpt_Timeout@{ui} - a time which, if exceeded, triggers a report;
      measured in vertical blank units (60/sec)
    @{i}gpt_XDelta@{ui} - a distance in x which, if exceeded, triggers a report
    @{i}gpt_YDelta@{ui} - a distance in x which, if exceeded, triggers a report
@EndNode
@Node "KBD_CMD_CLEAR" "keyboard.device/CMD_CLEAR"
@{b}@{u}CMD_CLEAR@{uu}@{ub} -- Clear the keyboard input buffer.
  Remove from the input buffer any keys transitions waiting to
  satisfy read requests.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  CMD_CLEAR
  @{i}io_Flags@{ui}    IOB_QUICK set if quick I/O is possible
@EndNode
@Node "KBD_ADDRESETHANDLER" "keyboard.device/KBD_ADDRESETHANDLER"
@{b}@{u}KBD_ADDRESETHANDLER@{uu}@{ub} -- Add a keyboard reset handler.
  Add a function to the list of functions called to clean up
  before a hard reset generated at the keyboard.
SYNOPSIS
  ResetHandler(@{i}handlerData@{ui})
                a1
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set
  @{i}io_Device@{ui}   preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  KBD_ADDRESETHANDLER
  @{i}io_Data@{ui}     a pointer to an interrupt structure.
  @{i}is_Data@{ui}     the handlerData pointer described above
  @{i}is_Code@{ui}     the Handler function address
NOTES
  Few of the Amiga keyboard models generate the communication codes
  used to implement this reset processing.Specifically, only the
  Euro a1000 (rare), and the B2000 keyboard generate them.
  The interrupt structure is kept by the keyboard device until a
  RemResetHandler command is satisfied for it, but the
  KBD_ADDRESETHANDLER command itself is replied immediately.
@EndNode
@Node "KBD_READEVENT" "keyboard.device/KBD_READEVENT"
@{b}@{u}KBD_READEVENT@{uu}@{ub} -- Return the next keyboard event.
  Read raw keyboard events from the keyboard and put them in the
  data area of the iORequest.If there are no pending keyboard
  events, this command will not be satisfied, but if there are
  some events, but not as many as can fill IO_LENGTH, the
  request will be satisfied with those currently available.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  KBD_READEVENT
  @{i}io_Flags@{ui}    IOB_QUICK set if quick I/O is possible
  @{i}io_Length@{ui}   the size of the io_Data area in bytes:
    there  are @{FG shine}sizeof@{FG text}(@{i}inputEvent@{ui}) bytes per input event.
  @{i}io_Data@{ui}     a buffer area to fill with input events.
    The fields of the input event are:
      @{i}ie_NextEvent@{ui}  links the events returned
      @{i}ie_Class@{ui}  is IECLASS_RAWKEY
      @{i}ie_Code@{ui}  contains the next key up/down reports
      @{i}ie_Qualifier@{ui}  only the shift and numeric pad bits are set
      @{i}ie_SubClass@{ui}, ie_X, ie_Y, ie_TimeStamp  are not used, and set to zero
RESULTS
  This function sets the error field in the @{"IORequest" Link "include:exec/io.h/Main" 18}, and fills
  the IORequest with the next keyboard events (but not partial events).
@EndNode
@Node "KBD_READMATRIX" "keyboard.device/KBD_READMATRIX"
@{b}@{u}KBD_READMATRIX@{uu}@{ub} -- Read the current keyboard key matrix.
  This function reads the up/down state of every key in the key matrix.
IO REQUEST INPUT
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  KBD_READMATRIX
  @{i}io_Flags@{ui}    IOB_QUICK set if quick I/O is possible
  @{i}io_Length@{ui}   the size of the io_Data area in bytes:
    this must be big enough to hold the key matrix.
  @{i}io_Data@{ui}     a buffer area to fill with the key matrix:
    an array of bytes whose component bits reflect each keys state: the state of
    the key for keycode n is at bit (n MOD 8) in byte (n DIV 8) of this matrix.
IO REQUEST OUTPUT
  @{i}@{b}io_Error@{ub}@{ui}
    IOERR_BADLENGTH - the io_Length was not exactly 13 bytes.
      The buffer is unchanged.This is only returned by V33/V34 kickstart.
  @{i}@{b}io_Actual@{ub}@{ui} the number of bytes filled in io_Data with key matrix data,
    i.e. the minimum of the supplied length and the internal key matrix size.
NOTE
  For V33/V34 Kickstart, io_Length must be set to exactly 13 bytes.
RESULTS
  This function sets the error field in the @{"IORequest" Link "include:exec/io.h/Main" 18}, and sets
  matrix to the current key matrix.
@EndNode
@Node "KBD_REMRESETHANDLER" "keyboard.device/KBD_REMRESETHANDLER"
@{b}@{u}KBD_REMRESETHANDLER@{uu}@{ub} -- Remove a keyboard reset handler.
  Remove a function previously added to the list of reset
  handler functions with @{"KBD_ADDRESETHANDLER" Link "KBD_ADDRESETHANDLER"}.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set
  @{i}io_Device@{ui}   preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  KBD_REMRESETHANDLER
  @{i}io_Data@{ui}     a pointer to the handler interrupt structure.
@EndNode
@Node "KBD_RESETHANDLERDONE" "keyboard.device/KBD_RESETHANDLERDONE"
@{b}@{u}KBD_RESETHANDLERDONE@{uu}@{ub} -- Indicate that reset handling is done.
  Indicate that reset cleanup associated with the handler has
  completed.This command should be issued by all keyboard
  reset handlers so that the reset may proceed.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set
  @{i}io_Device@{ui}   preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  KBD_RESETHANDLERDONE
  @{i}io_Data@{ui}     a pointer to the handler interrupt structure.
NOTES
  The keyboard processor itself performs the hardware reset, and
  will time out and perform the reset even if some reset handlers
  have not indicated yet that the reset may proceed.This timeout
  is several seconds.
@EndNode
@Node "IND_ADDHANDLER" "input.device/IND_ADDHANDLER"
@{b}@{u}IND_ADDHANDLER@{uu}@{ub} -- Add an input handler to the device.
  Add a function to the list of functions called to handle
  input events generated by this device.
SYNOPSIS
  @{i}@{b}newInputEvents@{ub}@{ui} = Handler(@{i}inputEvents@{ui}, @{i}handlerData@{ui});
   D0                       A0           A1
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set
  @{i}io_Device@{ui}   preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  IND_ADDHANDLER
  @{i}io_Data@{ui}     a pointer to an interrupt structure.
  @{i}is_Data@{ui}     the handlerData pointer described above
  @{i}is_Code@{ui}     the Handler function address
NOTES
  The interrupt structure is kept by the input device until a
  RemHandler command is satisfied for it.
@EndNode
@Node "IND_REMHANDLER" "input.device/IND_REMHANDLER"
@{b}@{u}IND_REMHANDLER@{uu}@{ub} -- Remove an input handler from the device.
  Remove a function previously added to the list of handler functions.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set
  @{i}io_Device@{ui}   preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  IND_REMHANDLER
  @{i}io_Data@{ui}     a pointer to the interrupt structure.
NOTES
  This command is not immediate
@EndNode
@Node "IND_SETMPORT" "input.device/IND_SETMPORT"
@{b}@{u}IND_SETMPORT@{uu}@{ub} -- Set the current mouse port.
  This command sets the gameport port at which the mouse is connected.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  IND_SETMPORT
  @{i}io_Flags@{ui}    IOB_QUICK set if quick I/O is possible
  @{i}io_Length@{ui}   1
  @{i}io_Data@{ui}     a pointer to a byte that is either 0 or 1,
    indicating that mouse input should be obtained from either the
    left or right controller port, respectively.
@EndNode
@Node "IND_SETMTRIG" "input.device/IND_SETMTRIG"
@{b}@{u}IND_SETMTRIG@{uu}@{ub} -- Set the conditions for a mouse port report.
  This command sets what conditions must be met by a mouse
  before a pending Read request will be satisfied.The trigger
  specification is that used by the gameport device.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  IND_SETMTRIG
  @{i}io_Flags@{ui}    IOB_QUICK set if quick I/O is possible
  @{i}io_Length@{ui}   @{FG shine}sizeof@{FG text}(@{i}gameportTrigger@{ui})
  @{i}io_Data@{ui}     a structure of type GameportTrigger,
    which has the following elements
      @{i}gpt_Keys@{ui} - GPTB_DOWNKEYS set if button down transitions trigger a report,
        and GPTB_UPKEYS set if button up transitions trigger a report
      @{i}gpt_Timeout@{ui} - a time which, if exceeded, triggers a report;
        measured in vertical blank units (60/sec)
      @{i}gpt_XDelta@{ui}  - a distance in x which, if exceeded, triggers a report
      @{i}gpt_YDelta@{ui}  - a distance in x which, if exceeded, triggers a report
@EndNode
@Node "IND_SETMTYPE" "input.device/IND_SETMTYPE"
@{b}@{u}IND_SETMTYPE@{uu}@{ub} -- Set the current mouse port controller type.
  This command sets the type of device at the mouse port, so
  the signals at the port may be properly interpreted.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  IND_SETMTYPE
  @{i}io_Flags@{ui}    IOB_QUICK set if quick I/O is possible
  @{i}io_Length@{ui}   1
  @{i}io_Data@{ui}     the address of the byte variable describing the controller type,
    as per the equates in the gameport include file
@EndNode
@Node "IND_SETPERIOD" "input.device/IND_SETPERIOD"
@{b}@{u}IND_SETPERIOD@{uu}@{ub} -- Set the key repeat period.
  This command sets the period at which a repeating key repeats.
  This command always executes immediately.
IO REQUEST - a timerequest
  tr_node.@{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  tr_node.@{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  tr_node.@{i}io_Unit@{ui}     preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  tr_node.@{i}io_Command@{ui}  IND_SETPERIOD
  tr_node.@{i}io_Flags@{ui}    IOB_QUICK set if quick I/O is possible
  tr_time.@{i}tv_secs@{ui}     the repeat period seconds
  tr_time.@{i}tv_micro@{ui}    the repeat period microseconds
@EndNode
@Node "IND_SETTHRESH" "input.device/IND_SETTHRESH"
@{b}@{u}IND_SETTHRESH@{uu}@{ub} -- Set the key repeat threshold.
  This command sets the time that a key must be held down before
  it can repeat.The repeatability of a key may be restricted
  (as, for example, are the shift keys).
  This command always executes immediately.
IO REQUEST - a timerequest
  tr_node.@{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  tr_node.@{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  tr_node.@{i}io_Unit@{ui}     preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  tr_node.@{i}io_Command@{ui}  IND_SETTHRESH
  tr_node.@{i}io_Flags@{ui}    IOB_QUICK set if quick I/O is possible
  tr_time.@{i}tv_secs@{ui}     the threshold seconds
  tr_time.@{i}tv_micro@{ui}    the threshold microseconds
@EndNode
@Node "IND_WRITEEVENT" "input.device/IND_WRITEEVENT"
@{b}@{u}IND_WRITEEVENT@{uu}@{ub} -- Propagate an input event to all handlers.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort set if quick I/O is not possible
  @{i}io_Device@{ui}   preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by the call to @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  IND_WRITEEVENT
  @{i}io_Flags@{ui}    IOB_QUICK set if quick I/O is possible
  @{i}io_Length@{ui}   should be @{FG shine}sizeof@{FG text}(@{FG shine}struct@{FG text} @{i}InputEvent@{ui})
  @{i}io_Data@{ui}     a pointer to the structure InputEvent:
    @{i}ie_NextEvent@{ui}  will be ignored.
    @{i}ie_Class@{ui}
    @{i}ie_SubClass@{ui}
    @{i}ie_Code@{ui}
    @{i}ie_Qualifier@{ui}
    @{i}ie_X@{ui}, @{i}ie_Y@{ui}    as desired
    @{i}ie_TimeStamp@{ui}  will be set by this call @{FG fill}(V36)@{FG text}
NOTES
  The contents of the input event are destroyed.
  This function was documented in V34 and earlier to allow
  chaining of events via ie_NextEvent.The implementation
  never allowed that.The documentation now reflects this.
  ie_TimeStamp is set only in V36 and later.Software written to run
  on earlier versions should set this field to the current time.
@EndNode
@Node "PeekQualifier()" "input.device/PeekQualifier"
@{b}@{u}PeekQualifier@{uu}@{ub} -- get the input device's current qualifiers.@{FG fill}(V36)@{FG text}
  This function takes a snapshot of what the input device thinks
  the current qualifiers are.
SYNOPSIS  UWORD PeekQualifier( @{FG shine}void@{FG text} );
  @{i}@{b}qualifier@{ub}@{ui} = PeekQualifier()
   d0
  @{i}@{b}qualifier@{ub}@{ui} - a word with the following bits set according to
    what the input device knows their state to be:
    IEQUALIFIER_LSHIFT, IEQUALIFIER_RSHIFT,
    IEQUALIFIER_CAPSLOCK, IEQUALIFIER_CONTROL, 
    IEQUALIFIER_LALT, IEQUALIFIER_RALT,
    IEQUALIFIER_LCOMMAND, IEQUALIFIER_RCOMMAND,
    IEQUALIFIER_LEFTBUTTON, IEQUALIFIER_RBUTTON,
    IEQUALIFIER_MIDBUTTON
NOTE
  This function is new for V36.
SEE ALSO
  @{"devices/inputevent.h" Link "include:devices/inputevent.h/Main" 0}
@EndNode
@Node "serial_AbortIO()" "serial.device/AbortIO"
@{b}@{u}AbortIO@{uu}@{ub} -- abort an I/O request.
  This is an exec.library call.
  This function attempts to aborts a specified read or write request.
  If the request is active, it is stopped immediately.
  If the request is queued, it is painlessly removed.
  The request will be returned in the same way any completed request is.
  After AbortIO(), you must generally do a @{"WaitIO()" Link "exec.guide/WaitIO()"}.
SYNOPSIS
  AbortIO(@{i}ioRequest@{ui})
           A1
  @{i}iORequest@{ui}  -- pointer to the @{"IORequest" Link "include:exec/io.h/Main" 18} Block that is to be aborted.
  @{i}@{b}io_Error@{ub}@{ui} -- if the Abort succeded, then io_Error will be #IOERR_ABORTED
    (-2) and the request will be flagged as aborted (bit 5 of io_Flags is set).
    If the Abort failed, then the Error will be zero.
BUGS
  Previous to version 34, the serial.device would often hang when aborting
  CTS/RTS handshake requests.This was the cause of the incorrect assumption that
  AbortIO() does not need to be followed by a wait for a reply (or a WaitIO()).
@EndNode
@Node "serial_BeginIO()" "serial.device/BeginIO"
@{b}@{u}BeginIO@{uu}@{ub} -- start up an I/O process.
  This is a direct function call to the device.It is intended for more advanced
  programmers.See exec's @{"DoIO()" Link "exec.guide/DoIO()"} and @{"SendIO()" Link "exec.guide/SendIO()"} for the normal method of
  calling devices.
  This function initiates a I/O request made to the serial device.
  Other than read or write, the functions are performed synchronously,
  and do not depend on any interrupt handling logic (or it's associated
  discontinuities), and hence should be performed as IO_QUICK.
  With some exceptions, reads and writes are merely initiated by BeginIO,
  and thusly return to the caller as begun, not completed.
  Completion is signalled via the standard @{"ReplyMsg" Link "exec.guide/ReplyMsg()"} routine.
  Multiple requests are handled via FIFO queueing.
  One exception to this non-QUICK handling of reads and writes is for READS when:
  - IO_QUICK bit is set
  - There are no pending read requests
  - There is already enough data in the input buffer to satisfy
    this I/O Request immediately.
  In this case, the IO_QUICK flag is not cleared, and the request
  is completed by the time it returns to the caller.There is no
  @{"ReplyMsg" Link "exec.guide/ReplyMsg()"} or signal bit activity in this case.
SYNOPSIS
  BeginIO(@{i}ioRequest@{ui}),@{i}deviceNode@{ui}
           A1         A6
  @{i}ioRequest@{ui}  -- pointer to an I/O Request Block of size io_ExtSerSize
    (see serial.i for size/definition),containing a valid command in io_Command
    to process, as well as the command's other required parameters.
  @{i}deviceNode@{ui} -- pointer to the "serial.device",
    as found in the IO_DEVICE of the ioRequest.
RESULTS
  @{i}@{b}io_Error@{ub}@{ui} -- if the BeginIO succeded, then Error will be null.
    If the BeginIO failed, then the Error will be non-zero.
    I/O errors won't be reported until the io completes.
SEE ALSO
  @{"devices/serial.h" Link "include:devices/serial.h/Main" 0}
@EndNode
@Node "serial_CloseDevice()" "serial.device/CloseDevice"
@{b}@{u}CloseDevice@{uu}@{ub} -- close the serial port.
  This is an exec call that terminates communication with the
  serial device.Upon closing, the device's input buffer is freed.
  Note that all IORequests MUST be complete before closing.
  If any are pending, your program must @{"AbortIO()" Link "serial_AbortIO()"} then @{"WaitIO()" Link "exec.guide/WaitIO()"}
  to complete them.
SYNOPSIS
  CloseDevice(@{i}deviceNode@{ui})
               A1
  @{i}deviceNode@{ui} - pointer to the device node, set by Open
SEE ALSO
  @{"serial.device/OpenDevice" Link "serial_OpenDevice()"}
@EndNode
@Node "serial_CMD_CLEAR" "serial.device/CMD_CLEAR"
@{b}@{u}Clear@{uu}@{ub} -- clear the serial port buffers.
  This command resets the serial port's read buffer pointers.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort initialized
  @{i}io_Device@{ui}   set by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Unit@{ui}     set by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Command@{ui}  CMD_CLEAR
RESULTS
  @{i}@{b}Error@{ub}@{ui} -- If the Clear succeded, then io_Error will be null.
    If the Clear failed, then the io_Error will be non-zero.
@EndNode
@Node "serial_CMD_FLUSH" "serial.device/CMD_FLUSH"
@{b}@{u}Flush@{uu}@{ub} -- clear all queued I/O requests for the serial port.
  This command purges the read and write request queues for the
  serial device.Flush will not affect active requests.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort initialized
  @{i}io_Device@{ui}   set by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Unit@{ui}     set by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Command@{ui}  CMD_FLUSH
RESULTS
  @{i}@{b}Error@{ub}@{ui} -- if the Flush succeded, then io_Error will be null.
    If the Flush failed, then the io_Error will be non-zero.
@EndNode
@Node "serial_CMD_READ" "serial.device/CMD_READ"
@{b}@{u}Read@{uu}@{ub} -- read input from serial port.
  This command causes a stream of characters to be read in from the serial port
  buffer.The number of characters is specified in io_Length.
  The Query function can be used to check how many characters are currently
  waiting in the serial port buffer.If more characters are requested than are
  currently available, the ioRequest will be queued until it can be satisfied.
  The best way to handle reads is to first Query to get the number of characters
  currently in the buffer.Then post a read request for that number of characters
  (or the maximum size of your buffer).If zero characters are in the buffer,
  post a request for 1 character.When at least one is ready, the device will
  return it.Now start over with another Query.
  Before the program exits, it must be sure to @{"AbortIO()" Link "serial_AbortIO()"} then @{"WaitIO()" Link "exec.guide/WaitIO()"}
  any outstanding ioRequests.
IO REQUEST
  @{i}io_Message@{ui}   A mn_ReplyPort is required
  @{i}io_Device@{ui}    set by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Unit@{ui}      set by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Command@{ui}   CMD_READ
  @{i}io_Flags@{ui} If  the IOB_QUICK bit is set, read will try to complete the IO quickly
  @{i}io_Length@{ui}    number of characters to receive.
  @{i}io_Data@{ui}      pointer to buffer
RESULTS
  @{i}@{b}Error@{ub}@{ui} -- if the Read succeded, then io_Error will be null.
    If the Read failed, then io_Error will be non-zero.io_Error will indicate
    problems such as parity mismatch, break, and buffer overrun.
SEE ALSO
  @{"serial.device/SDCMD_QUERY" Link "SDCMD_QUERY"}
  @{"serial.device/SDCMD_SETPARAMS" Link "SDCMD_SETPARAMS"}
BUGS
  Having multiple outstanding read IORequests at any one time will probably fail.
  Old documentation mentioned a mode where io_Length was set to -1.
  If you want a NULL terminated read, use the io_TermArray instead.
@EndNode
@Node "serial_CMD_RESET" "serial.device/CMD_RESET"
@{b}@{u}Reset@{uu}@{ub} -- reinitializes the serial port.
  This command resets the serial port to its freshly initialized
  condition.It aborts all I/O requests both queued and current,
  relinquishes the current buffer, obtains a new default sized
  buffer, and sets the port's flags and parameters to their 
  boot-up time default values.The functions places the reset
  parameter values in the ioRequest block.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort initialized
  @{i}io_Device@{ui}   set by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Unit@{ui}     set by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Command@{ui}  CMD_RESET
RESULTS
  @{i}@{b}Error@{ub}@{ui} -- if the Reset succeded, then Error will be null.
    If the Reset failed, then the Error will be non-zero.
@EndNode
@Node "serial_CMD_START" "serial.device/CMD_START"
@{b}@{u}Start@{uu}@{ub} -- restart paused I/O over the serial port.
  This function restarts all current I/O on the serial port by 
  sending an xON to the "other side", and submitting a "logical
  xON" to "our side", if/when appropriate to current activity.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort initialized
  @{i}io_Device@{ui}   set by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Unit@{ui}     set by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Command@{ui}  CMD_START
SEE ALSO
  @{"serial.device/CMD_STOP" Link "serial_CMD_STOP"}
@EndNode
@Node "serial_CMD_STOP" "serial.device/CMD_STOP"
@{b}@{u}Stop@{uu}@{ub} -- pause all current I/O over the serial port.
  This command halts all current I/O on the serial port by 
  sending an xOFF to the "other side", and submitting a "logical
  xOFF" to "our side", if/when appropriate to current activity.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort initialized
  @{i}io_Device@{ui}   set by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Unit@{ui}     set by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Command@{ui}  CMD_STOP
SEE ALSO
  @{"serial.device/CMD_START" Link "serial_CMD_START"}
@EndNode
@Node "serial_CMD_WRITE" "serial.device/CMD_WRITE"
@{b}@{u}Write@{uu}@{ub} -- send output to serial port.
  This command causes a stream of characters to be written out the serial port.
  The number of characters is specified in io_Length, unless -1 is used, in
  which case output is sent until a null(0x00) is encountered.
IO REQUEST
  @{i}io_Message@{ui}  must have mn_ReplyPort initialized
  @{i}io_Device@{ui}   set by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Unit@{ui}     set by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Command@{ui}  CMD_WRITE
  @{i}io_Flags@{ui}    Set IOF_QUICK to try quick I/O
  @{i}io_Length@{ui}   number of characters to transmit,
    or if set to -1 transmit until null encountered in buffer
  @{i}io_Data@{ui}     pointer to block of data to transmit
RESULTS
  @{i}@{b}Error@{ub}@{ui} -- if the Write succeded, then io_Error will be null.
    If the Write failed, then the io_Error will be non-zero.
SEE ALSO
  @{"serial.device/SDCMD_SETPARAMS" Link "SDCMD_SETPARAMS"}
@EndNode
@Node "serial_OpenDevice()" "serial.device/OpenDevice"
@{b}@{u}OpenDevice@{uu}@{ub} -- Request an opening of the serial device.
  This is an exec call.Exec will search for the serial.device, and if found,
  will pass this call on to the device.Unless the shared-access bit (bit 5 of
  io_SerFlags) is set, exclusive use is granted and no other access to that unit
  is allowed until the owner closes it.All the serial-specific fields in the
  ioRequest are initialized to their most recent values (or the @{"Preferences" Link "include:intuition/preferences.h/Main" 43}
  default, for the first time open).
  If support of 7-wire handshaking (i.e.RS232-C CTS/RTS protocol) is required,
  use the @{"serial.device/SDCMD_SETPARAMS" Link "SDCMD_SETPARAMS"} command.
  This feature should also be specified at inital OpenDevice() time.
SYNOPSIS  BYTE OpenDevice(STRPTR, ULONG, @{FG shine}struct@{FG text} IOExtSer *, ULONG);
  @{i}@{b}error@{ub}@{ui} = OpenDevice("serial.device", @{i}unit@{ui}, @{i}ioRequest@{ui}, @{i}flags@{ui})
   D0                  A0              D0     A1         D1
  "serial.device" - pointer to literal string "serial.device"
  @{i}unit@{ui} - Must be zero, or a user setable unit number.
    (This field is used by multiple port controllers)
    Zero specifies the default serial port.
  @{i}ioRequest@{ui}  - pointer to an ioRequest block of size io_ExtSerSize to be
    initialized by the serial.device.(see @{"devices/serial.h" Link "include:devices/serial.h/Main" 0} for the definition)
    @{b}NOTE@{ub} use of io_SerFlags (see FUNCTION above)
    @{b}IMPORTANT@{ub}: The ioRequest block MUST be of size io_ExtSerSize, and zeroed
    (with the exeptions as noted)!
  @{i}flags@{ui} - Must be zero for future compatibility
  @{i}@{b}D0@{ub}@{ui} - same as io_Error
  @{i}@{b}io_Error@{ub}@{ui}  - If the Open succeded, then io_Error will be null.
    If the Open failed, then io_Error will be non-zero.
  @{i}@{b}io_Device@{ub}@{ui} - A pointer to whatever device will handle the calls for this unit.
    This pointer may be different depending on what unit is requested.
BUGS
  If 7-wire handshaking is specified, a timeout "feature" is enabled.
  If the device holds off the computer for more than about 30-60 seconds,
  the device will return the write request with the error SerErr_TimerErr.
  Don't depend on this, however.If you want a timeout, set up the timer.device
  and wait for either timer, or serial IO to complete.
  On open, the serial.device allocates the misc.resource for the serial port.It
  does not return it until the serial.device is expunged from memory.It should
  return it when no more openers exist.This code can force a specified device
  to try and expunge.Of course, if the device is in use nothing will happen:
  @{b}#include@{ub} "exec/types.h"
  @{b}#include@{ub} "exec/execbase.h"
  @{b}#include@{ub} "proto/exec.h"
  @{FG shine}void@{FG text} FlushDevice(@{FG shine}char@{FG text} *);
  @{FG shine}extern@{FG text} @{FG shine}struct@{FG text} @{"ExecBase" Link "include:exec/execbase.h/Main" 35} *SysBase;
  @{FG shine}void@{FG text} main()
  {
    FlushDevice("serial.device"); /* or parallel.device */
  }
  /* Attempts to flush the named device out of memory.
   * If it fails, no status is returned; examination of the problem will reveal
   * that information has no valid use after the @{"Permit()" Link "exec.guide/Permit()"}.*/
  @{FG shine}void@{FG text} FlushDevice(@{i}name@{ui})
  @{FG shine}char@{FG text} *@{i}name@{ui};
  {
  @{FG shine}struct@{FG text} @{"Device" Link "include:exec/devices.h/Main" 25} *@{i}result@{ui};
      Forbid();
      @{FG shine}if@{FG text}( @{i}result@{ui}=(@{FG shine}struct@{FG text} @{"Device" Link "include:exec/devices.h/Main" 25} *)FindName(&SysBase->@{i}DeviceList@{ui},@{i}name@{ui}) )
        RemDevice(@{i}result@{ui});
      Permit();
  }
SEE ALSO
  @{"serial.device/CloseDevice" Link "serial_CloseDevice()"}
  @{"serial.device/SDCMD_SETPARAMS" Link "SDCMD_SETPARAMS"}
  @{"devices/serial.h" Link "include:devices/serial.h/Main" 0}
@EndNode
@Node "SDCMD_BREAK" "serial.device/SDCMD_BREAK"
@{b}@{u}Break@{uu}@{ub} -- send a break signal over the serial line.
  This command sends a break signal (serial line held low for an extended
  period) out the serial port.
  For the built-in port, this is accomplished by setting the UARTBRK bit of
  regisrer ADKCON.After a duration (user specifiable via setparams, default
  250000 microseconds) the bit is reset and the signal discontinued.
  If the QUEUEDBRK bit of io_SerFlags is set in the io_Request block, the
  request is placed at the back of the write-request queue and executed in turn.
  If the QUEUEDBRK bit is not set, the break is started immediately, control
  returns to the caller, and the timer discontinues the signal after the
  duration is completed.Be aware that calling BREAK may affect other commands
  such as ABORT, FLUSH, STOP, START, etc...
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort initialized
  @{i}io_Device@{ui}   set by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Unit@{ui}     set by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Command@{ui}  SDCMD_BREAK
  @{i}io_Flags@{ui}    set/reset IO_QUICK per above description
RESULTS
  @{i}@{b}Error@{ub}@{ui} -- if the Break succeded, then Error will be null.
    If the Break failed, then the Error will be non-zero.
@EndNode
@Node "SDCMD_QUERY" "serial.device/SDCMD_QUERY"
@{b}@{u}Query@{uu}@{ub} -- query serial port/line status.
  This command return the status of the serial port lines and registers.The
  number of unread bytes in the serial device's read buffer is shown i io_Actual.
  The break send & received flags are cleared by a query, and whenever a read
  @{"IORequest" Link "include:exec/io.h/Main" 18} is returned with a error in io_Error.
IO REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort initialized
  @{i}io_Device@{ui}   preset by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Unit@{ui}     preset by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Command@{ui}  SDCMD_QUERY
RESULTS
  @{i}@{b}io_Status@{ub}@{ui} BIT ACTIVE FUNCTION
   LSB       0   ---   reserved
             1   ---   reserved
             2   high  parallel "sel" on the A1000
                       On the A500 & A2000, "sel" is also connected to the serial
                       port's "Ring Indicator".Be cautious when making cables.
             3   low   Data Set Ready
             4   low   Clear To Send
             5   low   Carrier Detect
             6   low   Ready To Send
             7   low   Data Terminal Ready
   MSB       8   high  hardware overrun
             9   high  break sent (most recent output)
            10   high  break received (as latest input)
            11   high  transmit x-OFFed       
            12   high  receive x-OFFed       
         13-15   ---   reserved
  @{i}@{b}io_Actual@{ub}@{ui}   set to count of unread input characters
  @{i}@{b}io_Error@{ub}@{ui} -- Query will always succeded.
@EndNode
@Node "SDCMD_SETPARAMS" "serial.device/SDCMD_SETPARAMS"
@{b}@{u}SetParams@{uu}@{ub} -- change parameters for the serial port.
  This command allows the caller to change parameters for the serial device.
  Except for xON-xOFF enable/disable, it will reject a setparams call if
  any reads or writes are active or pending.
  @{b}Note specifically@{ub}:
    1.Valid input for io_Baud is between 112 and 292000 baud inclusive;
      asynchronous i/o above 32KB (especially on a busy system) may be ambitious.
    2.The EOFMODE and QUEUEDBRK bits of io_SerFlags can be set/reset
      in the io_Rqst block without a call to SetParams.The SHARED
      and 7WIRE bits of io_SerFlags can be used in @{"OpenDevice" Link "serial_OpenDevice()"} calls.
      ALL OTHER PARAMETERS CAN ONLY BE CHANGED BY THE SetParams COMMAND.
    3.RBufLen must be at least 64.The buffer may be any multiple of 64 bytes.
    4.If not used, io_ExtFlags MUST be set to zero.
    5.xON-xOFF is by default enabled.The XDISABLED bit is the only parameter
      that can be changed via a SetParams call while the device is active.
      Note that this will return the value SerErr_DevBusy in the io_Error field.
      xON/xOFF handshaking is inappropriate for certain binary transfer
      protocalls, such as Xmodem.The binary data might contain the
      xON (ASCII 17) and xOFF (ASCII 19) characters.
    6.If trying to run MIDI, you should set the RAD_BOOGIE bit of io_SerFlags to
      eliminate unneeded overhead.Specifically, this skips checks for parity,
      x-OFF handling, character lengths other than 8 bits, and testing for a
      break signal.Setting RAD_BOOGIE will also set the XDISABLED bit.
      Note that writing data (that's already in MIDI format) at MIDI rates is
      easily accomplished.Using this driver alone for MIDI reads may, however,
      may not be reliable,due to MIDI timestamping requirements,and possibility
      of overruns in a busy multitasking and/or display intensive environment.
    7.If you select mark or space parity (see io_ExtFlags in serial.h),
      this will cause the SERB_PARTY_ON bit to be set, and the setting
      of SERB_PARTY_ODD to be ignored.
    8.For best results, set the RAD_BOOGIE flag whenever possible.
      See #6 for details.
    9.Note that at this time parity is *not* calculated for the xON-xOFF
      characters.If you have a system that is picky about the parity of these,
      you must set your own xON-xOFF characters in io_CtlChar.
   10.7WIRE (CTS/RTS) handshake is bi-directional.
      The external side is expected to drop CTS several character times before
      the external buffer is full.The Amiga will drop RTS several character
      times before the Amiga's buffer is full.
IO REQUEST
  @{i}io_Message@{ui}    mn_ReplyPort initialized
  @{i}io_Device@{ui}     preset by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Unit@{ui}       preset by @{"OpenDevice" Link "serial_OpenDevice()"}
  @{i}io_Command@{ui}    SDCMD_SETPARAMS (0x0B)
    @{b}NOTE@{ub} that the following fields are filled in by Open to reflect the
    serial device's current configuration.
  @{i}io_CtlChar@{ui}    a longword containing byte values for the xON,xOFF,INQ,ACK
    fields (respectively) (INQ/ACK not used at this time)
  @{i}io_RBufLen@{ui}    length in bytes of input buffer
    @{b}NOTE@{ub} that any change in buffer size causes the current buffer to be
      deallocated and a new, correctly sized one to be allocated.
      Thusly, the CONTENTS OF THE OLD BUFFER ARE LOST.
  @{i}io_ExtFlags@{ui}      additional serial flags (bitdefs in @{"devices/serial.h)" Link "include:devices/serial.h/Main" 0}
    mark & space parity may be specified here.
  @{i}io_Baud@{ui}       baud rate for reads AND writes.(See 1 above)
  @{i}io_BrkTime@{ui}    duration of break signal in MICROseconds
  @{i}io_TermArray@{ui}  ASCII descending-ordered 8-byte array of termination characters.
    If less than 8 chars used, fill out array w/lowest valid value.
    Terminators are checked only if EOFMODE bit of io_Serflags is set.
    (e.g. x512F040303030303 )
  @{i}io_ReadLen@{ui}    number of bits in read word (1-8) not including parity
  @{i}io_WriteLen@{ui}   number of bits in write word (1-8) "      "       "
  @{i}io_StopBits@{ui}   number of stop bits (0, 1 or 2)
  @{i}io_SerFlags@{ui}   see @{"devices/serial.h" Link "include:devices/serial.h/Main" 0} for bit equates, NOTE that x00 yields
    exclusive access, xON/OFF-enabled, no parity checking, 3-wire protocol and
    TermArray inactive.
RESULTS
  @{i}@{b}Error@{ub}@{ui} -- if the SetParams succeded, then Error will be null.
    If the SetParams failed, then the Error will be non-zero.
SEE ALSO
  @{"exec/OpenDevice" Link "exec.guide/OpenDevice()"}
@EndNode              
@Node "--background--" "timer.device/--background--"
@{b}@{u}TIMER REQUEST@{uu}@{ub}
  A time request is a non standard IO Request.It has an @{"IORequest" Link "include:exec/io.h/Main" 18}
  followed by a @{"timeval" Link "include:devices/timer.h/Main" 26} structure or an eclockval structure.
@{b}@{u}TIMEVAL@{uu}@{ub}
  A timeval structure consists of two longwords.The first is
  the number of seconds, the latter is the fractional number
  of microseconds.The microseconds must always be "normalized"
  e.g.the longword must be between 0 and one million.
@{b}@{u}ECLOCKVAL@{uu}@{ub}
  A eclockval structure consists of two longwords.The first is
  the high order 32 bits of a 64 bit number and the second is the
  the low order 32 bits.The 64 bit number is a count of "E" clock
  ticks.The "E" clock frequency is related to the master clock
  frequency of the machine and can be determined by calling the
  @{"ReadEClock()" Link "ReadEClock()"} library like call.
@{"UNITS" link TIMER_BACKGROUND_UNITS}
LIBRARY
  In addition to the normal device calls, the timer also supports
  several direct, library like calls.
BUGS
  In the V1.2/V1.3 release, the timer device has problems with very short
  time requests.When one of these is made, other timer requests may be
  finished inaccurately.A side effect is that AmigaDOS requests such as
  "Delay(0);" or "WaitForChar(x,0);" are unreliable.
@EndNode
@node TIMER_BACKGROUND_UNITS "timer.device/--background--/units"
The timer contains five units -- two designed to accuratly measure
short intervals, one that has little system overhead and is very
stable over time, and two that work like an alarm clock.
@{i}UNIT_MICROHZ@{ui} - this unit uses the programmable timers in the 8520s to keep track
  of its time.It has precision down to about 2 microseconds, but will drift as
  system load increases.The accuracy of this unit is the same as that of the
  master clock of the machine.This unit uses a timeval in its @{"timerequest" Link "include:devices/timer.h/Main" 36}.
@{i}UNIT_VBLANK@{ui} - this unit uses a strobe from the power supply to keep track
  of its time or the "E" clock on machines without power supply strobes.It is
  very stable over time, but only has a resolution of that of the vertical blank
  interrupt.This unit is very cheap to use, and should be used by those who are
  waiting for long periods of time (typically 1/2 second or more).
  This unit uses a timeval in its timerequest.
@{i}UNIT_ECLOCK@{ui} - this unit is exacly the same as UNIT_MICROHZ except that it uses
  an eclockval instead of a timeval in its timerequest.
@{i}UNIT_WAITUNTIL@{ui} - this unit waits until the systime is greater than or equal
  to the time in the timeval in the timerequest.
  This unit has the same resolution and accuracy as that of UNIT_VBLANK.
@{i}UNIT_WAITECLOCK@{ui} - this unit waits until the E-Clock value as returned by
  @{"ReadEClock()" Link "ReadEClock()"} is greater than or equal to the eclockval in the timerequest.
  This unit has the same resolution and accuracy as that of UNIT_ECLOCK.
@endnode
@Node "timer_AbortIO()" "timer.device/AbortIO"
@{b}@{u}AbortIO@{uu}@{ub} -- Remove an existing timer request.
  This is an exec.library call.
  This routine removes a timerquest from the timer.It runs in the
  context of the caller.
SYNOPSIS  @{FG shine}long@{FG text} AbortIO( @{FG shine}struct@{FG text} @{"timerequest" Link "include:devices/timer.h/Main" 36} * );
  @{i}@{b}error@{ub}@{ui} = AbortIO( @{i}timerequest@{ui} )
   D0               A1
  @{i}timerequest@{ui} - the timer request to be aborted
   @{i}@{b}0@{ub}@{ui} if the request was aborted, io_Error will also be set to IOERR_ABORTED.
  @{i}@{b}-1@{ub}@{ui} otherwise
NOTES
  This function may be called from interrupts.
SEE ALSO
  @{"exec.library/AbortIO()" Link "exec.guide/AbortIO()"}
@EndNode
@Node "AddTime()" "timer.device/AddTime"
@{b}@{u}AddTime@{uu}@{ub} -- Add one time request to another.
  This routine adds one timeval structure to another.The
  results are stored in the destination (Dest + Source -> Dest)
  A0 and A1 will be left unchanged
SYNOPSIS  @{FG shine}void@{FG text} AddTime( @{FG shine}struct@{FG text} @{"timeval" Link "include:devices/timer.h/Main" 26} *, @{FG shine}struct@{FG text} timeval *);
  AddTime( @{i}Dest@{ui}, @{i}Source@{ui} )
            A0    A1
  @{i}Dest@{ui}, @{i}Source@{ui} -- pointers to timeval structures.
NOTES
  This function may be called from interrupts.
SEE ALSO
  @{"timer.device/CmpTime()" Link "CmpTime()"},
  @{"timer.device/SubTime()" Link "SubTime()"}
@EndNode
@Node "CmpTime()" "timer.device/CmpTime"
@{b}@{u}CmpTime@{uu}@{ub} -- Compare two timeval structures.
  This routine compares timeval structures.
  A0 and A1 will be left unchanged.
SYNOPSIS  @{FG shine}long@{FG text} CmpTime( @{FG shine}struct@{FG text} @{"timeval" Link "include:devices/timer.h/Main" 26} *, @{FG shine}struct@{FG text} timeval *);
  result = CmpTime( @{i}Dest@{ui}, @{i}Source@{ui} )
   D0                A0    A1
  @{i}Dest@{ui}, @{i}Source@{ui} -- pointers to timeval structures.
   @{i}@{b}0@{ub}@{ui} if Dest has same time as source
  @{i}@{b}-1@{ub}@{ui} if Dest has more time than source
  @{i}@{b}+1@{ub}@{ui} if Dest has less time than source
NOTES
  This function may be called from interrupts.
SEE ALSO
  @{"timer.device/AddTime()" Link "AddTime()"},
  @{"timer.device/SubTime()" Link "SubTime()"}
BUGS
  Older version of this document had the sense of the return
  codes wrong; the code hasn't changed but the document has.
@EndNode
@Node "GetSysTime()" "timer.device/GetSysTime"
@{b}@{u}GetSysTime@{uu}@{ub} -- Get the system time.@{FG fill}(V36)@{FG text}
  Ask the system what time it is.The system time starts off at zero at power on,
  but may be initialized via the @{"TR_SETSYSTIME" Link "TR_SETSYSTIME"} timer.device command.
  System time is monotonocally increasing and guarenteed to be unique
  (except when the system time is set back).
  A0 will be left unchanged.
  This function is less expensive to use than the @{"TR_GETSYSTIME" Link "TR_GETSYSTIME"} IORequest.
SYNOPSIS  @{FG shine}void@{FG text} GetSysTime( @{FG shine}struct@{FG text} @{"timeval" Link "include:devices/timer.h/Main" 26} * );
  GetSysTime( @{i}Dest@{ui} )
               A0
  @{i}Dest@{ui} -- pointer to a timeval structure to hold the system time.
  @{i}@{b}Dest@{ub}@{ui} -- the timeval structure will contain the system time.
NOTES
  This function may be called from interrupts.
SEE ALSO
  @{"timer.device/TR_GETSYSTIME" Link "TR_GETSYSTIME"},
  @{"timer.device/TR_SETSYSTIME" Link "TR_SETSYSTIME"},
@EndNode
@Node "ReadEClock()" "timer.device/ReadEClock"
@{b}@{u}ReadEClock@{uu}@{ub} -- Get the current value of the E-Clock.@{FG fill}(V36)@{FG text}
  This routine calculates the current 64 bit value of the E-Clock
  and stores it in the destination EClockVal structure.
  The count rate of the E-Clock is also returned.
  A0 will be left unchanged.
  This is a low overhead function designed so that very short intervals may be
  timed.
SYNOPSIS  ULONG ReadEClock ( @{FG shine}struct@{FG text} @{"EClockVal" Link "include:devices/timer.h/Main" 31} * );
  @{i}@{b}E_Freq@{ub}@{ui} = ReadEClock( @{i}Dest@{ui} )
   D0                   A0
  @{i}Dest@{ui} -- pointer to an EClockVal structure.
  @{i}@{b}Dest@{ub}@{ui} -- the EClockVal structure will contain the E-Clock time
  @{i}@{b}E_Freq@{ub}@{ui} -- The count rate of the E-Clock (tics/sec).
NOTES
  This function may be called from interrupts.
@EndNode
@Node "SubTime()" "timer.device/SubTime"
@{b}@{u}SubTime@{uu}@{ub} -- Subtract one time request from another.
  This routine subtracts one timeval structure from another.The
  results are stored in the destination (Dest - Source -> Dest)
  A0 and A1 will be left unchanged
SYNOPSIS  @{FG shine}void@{FG text} SubTime( @{FG shine}struct@{FG text} @{"timeval" Link "include:devices/timer.h/Main" 26} *, @{FG shine}struct@{FG text} timeval *);
  SubTime( @{i}Dest@{ui}, @{i}Source@{ui} )
            A0    A1
  @{i}Dest@{ui}, @{i}Source@{ui} -- pointers to timeval structures.
NOTES
  This function may be called from interrupts.
SEE ALSO
  @{"timer.device/AddTime()" Link "AddTime()"},
  @{"timer.device/CmpTime()" Link "CmpTime()"}
@EndNode
@Node "TR_ADDREQUEST" "timer.device/TR_ADDREQUEST"
@{b}@{u}TR_ADDREQUEST@{uu}@{ub} -- Submit a request to wait a period of time.
  Ask the timer to wait a specified amount of time before
  replying the @{"timerequest" Link "include:devices/timer.h/Main" 36}.
  The message may be forced to finish early with an @{"AbortIO()/WaitIO()" Link "exec.guide/WaitIO()"} pair.
TIMER REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort initialized
  @{i}io_Device@{ui}   preset by timer in @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by timer in @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  TR_ADDREQUEST
  @{i}io_Flags@{ui}    IOF_QUICK permitted (but ignored)
  @{i}tr_time@{ui}     a @{"timeval" Link "include:devices/timer.h/Main" 26} structure specifying how long the
    device will wait before replying
RESULTS
  @{i}@{b}tr_time@{ub}@{ui}  will be zeroed
NOTES
  This function may be called from interrupts.
  Previous to 2.0, the tr_time field was documented as containing junk when the
  timerequest was returned.
SEE ALSO
  @{"timer.device/AbortIO()" Link "timer_AbortIO()"},
  @{"timer.device/TimeDelay()" Link "amiga_lib/TimeDelay()"},
@EndNode
@Node "TR_GETSYSTIME" "timer.device/TR_GETSYSTIME"
@{b}@{u}TR_GETSYSTIME@{uu}@{ub} -- get the system time.
  Ask the system what time it is.The system time starts off at
  zero at power on, but may be initialized via the @{"TR_SETSYSTIME" Link "TR_SETSYSTIME"} call.
  System time is monotonically increasing, and guaranteed to be unique
  (except when the system time is set backwards).
TIMER REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort initialized
  @{i}io_Device@{ui}   preset by timer in @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by timer in @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  TR_GETSYSTIME
  @{i}io_Flags@{ui}    IOF_QUICK permitted
RESULTS
  @{i}@{b}tr_time@{ub}@{ui}  a @{"timeval" Link "include:devices/timer.h/Main" 26} structure with the current system time
NOTES
  This function may be called from interrupts.
SEE ALSO
  @{"timer.device/TR_SETSYSTIME" Link "TR_SETSYSTIME"},
  @{"timer.device/GetSysTime()" Link "GetSysTime()"},
@EndNode
@Node "TR_SETSYSTIME" "timer.device/TR_SETSYSTIME"
@{b}@{u}TR_SETSYSTIME@{uu}@{ub} -- Set the system time.
  Set the system idea of what time it is.The system starts out
  at time "zero" so it is safe to set it forward to the real time.
  However, care should be taken when setting the time backwards.
  System time is generally expected to monotonically increasing.
TIMER REQUEST
  @{i}io_Message@{ui}  mn_ReplyPort initialized
  @{i}io_Device@{ui}   preset by timer in @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Unit@{ui}     preset by timer in @{"OpenDevice" Link "exec.guide/OpenDevice()"}
  @{i}io_Command@{ui}  @{"TR_GETSYSTIME" Link "TR_GETSYSTIME"}
  @{i}io_Flags@{ui}    IOF_QUICK permitted
  @{i}tr_time@{ui}     a @{"timeval" Link "include:devices/timer.h/Main" 26} structure with the current system time
RESULTS
  @{i}@{b}tr_time@{ub}@{ui}  will contain junk
NOTES
  This function may be called from interrupts.
SEE ALSO
  @{"timer.device/TR_GETSYSTIME" Link "TR_GETSYSTIME"},
  @{"timer.device/GetSysTime()" Link "GetSysTime()"},
@EndNode

