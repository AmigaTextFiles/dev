@database "libs.guide"
@master "Work:Programing/sc/OS3.1_Docs/doc/commodities.doc"

@Node Main "libs.guide"
@{b}@{u}commodities.library@{uu}@{ub}:                    @{b}@{u}datatypes.library@{uu}@{ub}: @{u}@{b}nonvolatile.library@{ub}@{uu}:
@{u}Cx objects@{uu}:       @{u}IX & events@{uu}:          @{"--DT_background--" Link "DT_--background--"} @{"--NV_background--" Link "NV_--background--"}
@{"CxBroker()" Link "CxBroker()"}       @{"InvertKeyMap()" Link "InvertKeyMap()"}       @{"--DT_rexxhost--" Link "DT_--rexxhost--"}   @{"StoreNV()" Link "StoreNV()"}
@{"CreateCxObj()" Link "CreateCxObj()"}    @{"SetTranslate()" Link "SetTranslate()"}       @{u}DT objects@{uu}:        @{"SetNVProtection()" Link "SetNVProtection()"}
@{"AttachCxObj()" Link "AttachCxObj()"}    @{"AddIEvents()" Link "AddIEvents()"}         @{"NewDTObjectA()" Link "NewDTObjectA()"}    @{"GetCopyNV()" Link "GetCopyNV()"}
@{"InsertCxObj()" Link "InsertCxObj()"}    @{"ParseIX()" Link "ParseIX()"}            @{"AddDTObject()" Link "AddDTObject()"}     @{"GetNVList()" Link "GetNVList()"}
@{"SetCxObjPri()" Link "SetCxObjPri()"}    @{"SetFilter()" Link "SetFilter()"}          @{"PrintDTObjectA()" Link "PrintDTObjectA()"}  @{"GetNVInfo()" Link "GetNVInfo()"}
@{"EnqueueCxObj()" Link "EnqueueCxObj()"}   @{"SetFilterIX()" Link "SetFilterIX()"}        @{"RefreshDTObjectA()" Link "RefreshDTObjectA()"}@{"FreeNVData()" Link "FreeNVData()"}
@{"ActivateCxObj()" Link "ActivateCxObj()"}  @{"MatchIX()" Link "MatchIX()"}            @{"RemoveDTObject()" Link "RemoveDTObject()"}  @{"DeleteNV()" Link "DeleteNV()"}
@{"CxObjType()" Link "CxObjType()"}      @{u}@{b}diskfont.library@{ub}@{uu}:     @{"DisposeDTObject()" Link "DisposeDTObject()"} @{b}@{u}More libraries@{uu}@{ub}:
@{"CxObjError()" Link "CxObjError()"}     @{"AvailFonts()" Link "AvailFonts()"}         @{u}OOP@{uu}:               @{"icon.library" link Main2}
@{"ClearCxObjError()" Link "ClearCxObjError()"}@{"OpenDiskFont()" Link "OpenDiskFont()"}       @{"ObtainDataTypeA()" Link "ObtainDataTypeA()"} @{"iffparse.library" link Main2}
@{"RemoveCxObj()" Link "RemoveCxObj()"}    @{"NewScaledDiskFont()" Link "NewScaledDiskFont()"}  @{"GetDTString()" Link "GetDTString()"}     @{"lowlevel.library" link Main2}
@{"DeleteCxObj()" Link "DeleteCxObj()"}    @{"NewFontContents()" Link "NewFontContents()"}    @{"SetDTAttrsA()" Link "SetDTAttrsA()"}           
@{"DeleteCxObjAll()" Link "DeleteCxObjAll()"} @{"DisposeFontContents()" Link "DisposeFontContents()"}@{"GetDTAttrsA()" Link "GetDTAttrsA()"}    @{"All functions sorted" link ALL_FUNCTIONS_SORTED}
@{u}Cx messages@{uu}:      @{u}@{b}bullet.library@{ub}@{uu}:       @{"GetDTMethods()" Link "GetDTMethods()"}
@{"RouteCxMsg()" Link "RouteCxMsg()"}     @{"--bullet_background--" Link "bullet_--background--"}@{"GetDTTriggerMethods()" Link "GetDTTriggerMethods()"}
@{"DivertCxMsg()" Link "DivertCxMsg()"}    @{"OpenEngine()" Link "OpenEngine()"}         @{"DoAsyncLayout()" Link "DoAsyncLayout()"}
@{"CxMsgID()" Link "CxMsgID()"}        @{"SetInfoA()" Link "SetInfoA()"}           @{"DoDTMethodA()" Link "DoDTMethodA()"}
@{"CxMsgType()" Link "CxMsgType()"}      @{"ObtainInfoA()" Link "ObtainInfoA()"}        @{"ReleaseDataType()" Link "ReleaseDataType()"}
@{"CxMsgData()" Link "CxMsgData()"}      @{"ReleaseInfoA()" Link "ReleaseInfoA()"}
@{"DisposeCxMsg()" Link "DisposeCxMsg()"}   @{"CloseEngine()" Link "CloseEngine()"}
@EndNode
@Node Main2 "libs.guide"
@{b}@{u}iffparse.library@{uu}@{ub}:                                           @{u}@{b}lowlevel.library@{ub}@{uu}:
@{u}Chunks@{uu}:             @{u}Chunk tests@{uu}:         @{u}Clipboards@{uu}:        @{u}System control@{uu}:
@{"ParentChunk()" Link "ParentChunk()"}      @{"GoodID()" Link "GoodID()"}            @{"OpenClipboard()" Link "OpenClipboard()"}   @{"SystemControlA()" Link "SystemControlA()"}
@{"CurrentChunk()" Link "CurrentChunk()"}     @{"GoodType()" Link "GoodType()"}          @{"InitIFFasClip()" Link "InitIFFasClip()"}   @{u}Locale support@{uu}:
@{"PushChunk()" Link "PushChunk()"}        @{u}IFFs@{uu}:                @{"CloseClipboard()" Link "CloseClipboard()"}  @{"GetLanguageSelection()" Link "GetLanguageSelection()"}
@{"PopChunk()" Link "PopChunk()"}         @{"AllocIFF()" Link "AllocIFF()"}          @{b}@{u}icon.library@{uu}@{ub}:      @{u}Joystick control@{uu}:
@{"ReadChunkBytes()" Link "ReadChunkBytes()"}   @{"OpenIFF()" Link "OpenIFF()"}           @{u}Free lists@{uu}:        @{"SetJoyPortAttrsA()" Link "SetJoyPortAttrsA()"}
@{"ReadChunkRecords()" Link "ReadChunkRecords()"} @{"InitIFF()" Link "InitIFF()"}           @{"AddFreeList()" Link "AddFreeList()"}     @{"ReadJoyPort()" Link "ReadJoyPort()"}
@{"WriteChunkBytes()" Link "WriteChunkBytes()"}  @{"InitIFFasDOS()" Link "InitIFFasDOS()"}      @{"FreeFreeList()" Link "FreeFreeList()"}    @{u}Keyboard interrupts@{uu}:
@{"WriteChunkRecords()" Link "WriteChunkRecords()"}@{"EntryHandler()" Link "EntryHandler()"}      @{u}Revisions@{uu}:         @{"AddKBInt()" Link "AddKBInt()"}
@{"StopChunk()" Link "StopChunk()"}        @{"ExitHandler()" Link "ExitHandler()"}       @{"BumpRevision()" Link "BumpRevision()"}    @{"GetKey()" Link "GetKey()"}
@{"StopChunks()" Link "StopChunks()"}       @{"ParseIFF()" Link "ParseIFF()"}          @{u}Disk objects@{uu}:      @{"QueryKeys()" Link "QueryKeys()"}
@{"StopOnExit()" Link "StopOnExit()"}       @{"CloseIFF()" Link "CloseIFF()"}          @{"PutDefDiskObject()" Link "PutDefDiskObject()"}@{"RemKBInt()" Link "RemKBInt()"}
@{"FindCollection()" Link "FindCollection()"}   @{"FreeIFF()" Link "FreeIFF()"}           @{"PutDiskObject()" Link "PutDiskObject()"}   @{u}Vblank interrupts@{uu}:
@{"CollectionChunk()" Link "CollectionChunk()"}  @{u}Local items@{uu}:         @{"GetDefDiskObject()" Link "GetDefDiskObject()"}@{"AddVBlankInt()" Link "AddVBlankInt()"}
@{"CollectionChunks()" Link "CollectionChunks()"} @{"AllocLocalItem()" Link "AllocLocalItem()"}    @{"GetDiskObject()" Link "GetDiskObject()"}   @{"RemVBlankInt()" Link "RemVBlankInt()"}
@{"PropChunk()" Link "PropChunk()"}        @{"FindLocalItem()" Link "FindLocalItem()"}     @{"GetDiskObjectNew()" Link "GetDiskObjectNew()"}@{u}Timer interrupts@{uu}:
@{"PropChunks()" Link "PropChunks()"}       @{"LocalItemData()" Link "LocalItemData()"}     @{"FreeDiskObject()" Link "FreeDiskObject()"}  @{"AddTimerInt()" Link "AddTimerInt()"}
@{"FindProp()" Link "FindProp()"}         @{"SetLocalItemPurge()" Link "SetLocalItemPurge()"} @{"DeleteDiskObject()" Link "DeleteDiskObject()"}@{"StartTimerInt()" Link "StartTimerInt()"}
@{"FindPropContext()" Link "FindPropContext()"}  @{"StoreLocalItem()" Link "StoreLocalItem()"}    @{u}Tooltypes@{uu}:         @{"ElapsedTime()" Link "ElapsedTime()"}
@{u}ID conversion@{uu}:      @{"StoreItemInContext()" Link "StoreItemInContext()"}@{"FindToolType()" Link "FindToolType()"}    @{"StopTimerInt()" Link "StopTimerInt()"}
@{"IDtoStr()" Link "IDtoStr()"}          @{"FreeLocalItem()" Link "FreeLocalItem()"}     @{"MatchToolValue()" Link "MatchToolValue()"}  @{"RemTimerInt()" Link "RemTimerInt()"}
@EndNode
@node ALL_FUNCTIONS_SORTED "all_functions_sorted"
@{"--bullet_background--" Link "bullet_--background--"}
@{"--DT_background--" Link "DT_--background--"}
@{"--DT_rexxhost--" Link "DT_--rexxhost--"}
@{"--NV_background--" Link "NV_--background--"}
@{"ActivateCxObj()" Link "ActivateCxObj()"}
@{"AddDTObject()" Link "AddDTObject()"}
@{"AddFreeList()" Link "AddFreeList()"}
@{"AddIEvents()" Link "AddIEvents()"}
@{"AddKBInt()" Link "AddKBInt()"}
@{"AddTimerInt()" Link "AddTimerInt()"}
@{"AddVBlankInt()" Link "AddVBlankInt()"}
@{"AllocIFF()" Link "AllocIFF()"}
@{"AllocLocalItem()" Link "AllocLocalItem()"}
@{"AvailFonts()" Link "AvailFonts()"}
@{"AttachCxObj()" Link "AttachCxObj()"}
@{"BumpRevision()" Link "BumpRevision()"}
@{"ClearCxObjError()" Link "ClearCxObjError()"}
@{"CloseClipboard()" Link "CloseClipboard()"}
@{"CloseEngine()" Link "CloseEngine()"}
@{"CloseIFF()" Link "CloseIFF()"}
@{"CollectionChunk()" Link "CollectionChunk()"}
@{"CollectionChunks()" Link "CollectionChunks()"}
@{"CreateCxObj()" Link "CreateCxObj()"}
@{"CurrentChunk()" Link "CurrentChunk()"}
@{"CxBroker()" Link "CxBroker()"}
@{"CxMsgData()" Link "CxMsgData()"}
@{"CxMsgID()" Link "CxMsgID()"}
@{"CxMsgType()" Link "CxMsgType()"}
@{"CxObjError()" Link "CxObjError()"}
@{"CxObjType()" Link "CxObjType()"}
@{"DeleteCxObj()" Link "DeleteCxObj()"}
@{"DeleteCxObjAll()" Link "DeleteCxObjAll()"}
@{"DeleteDiskObject()" Link "DeleteDiskObject()"}
@{"DeleteNV()" Link "DeleteNV()"}
@{"DisposeCxMsg()" Link "DisposeCxMsg()"}
@{"DisposeDTObject()" Link "DisposeDTObject()"}
@{"DisposeFontContents()" Link "DisposeFontContents()"}
@{"DivertCxMsg()" Link "DivertCxMsg()"}
@{"DoAsyncLayout()" Link "DoAsyncLayout()"}
@{"DoDTMethodA()" Link "DoDTMethodA()"}
@{"ElapsedTime()" Link "ElapsedTime()"}
@{"EnqueueCxObj()" Link "EnqueueCxObj()"}
@{"EntryHandler()" Link "EntryHandler()"}
@{"ExitHandler()" Link "ExitHandler()"}
@{"FindCollection()" Link "FindCollection()"}
@{"FindLocalItem()" Link "FindLocalItem()"}
@{"FindProp()" Link "FindProp()"}
@{"FindPropContext()" Link "FindPropContext()"}
@{"FindToolType()" Link "FindToolType()"}
@{"FreeDiskObject()" Link "FreeDiskObject()"}
@{"FreeFreeList()" Link "FreeFreeList()"}
@{"FreeIFF()" Link "FreeIFF()"}
@{"FreeLocalItem()" Link "FreeLocalItem()"}
@{"FreeNVData()" Link "FreeNVData()"}
@{"GetCopyNV()" Link "GetCopyNV()"}
@{"GetDefDiskObject()" Link "GetDefDiskObject()"}
@{"GetDiskObject()" Link "GetDiskObject()"}
@{"GetDiskObjectNew()" Link "GetDiskObjectNew()"}
@{"GetDTAttrsA()" Link "GetDTAttrsA()"}
@{"GetDTMethods()" Link "GetDTMethods()"}
@{"GetDTString()" Link "GetDTString()"}
@{"GetDTTriggerMethods()" Link "GetDTTriggerMethods()"}
@{"GetKey()" Link "GetKey()"}
@{"GetLanguageSelection()" Link "GetLanguageSelection()"}
@{"GetNVInfo()" Link "GetNVInfo()"}
@{"GetNVList()" Link "GetNVList()"}
@{"GoodID()" Link "GoodID()"}
@{"GoodType()" Link "GoodType()"}
@{"IDtoStr()" Link "IDtoStr()"}
@{"InitIFF()" Link "InitIFF()"}
@{"InitIFFasClip()" Link "InitIFFasClip()"}
@{"InitIFFasDOS()" Link "InitIFFasDOS()"}
@{"InsertCxObj()" Link "InsertCxObj()"}
@{"InvertKeyMap()" Link "InvertKeyMap()"}
@{"LocalItemData()" Link "LocalItemData()"}
@{"MatchIX()" Link "MatchIX()"}
@{"MatchToolValue()" Link "MatchToolValue()"}
@{"NewDTObjectA()" Link "NewDTObjectA()"}
@{"NewFontContents()" Link "NewFontContents()"}
@{"NewScaledDiskFont()" Link "NewScaledDiskFont()"}
@{"ObtainDataTypeA()" Link "ObtainDataTypeA()"}
@{"ObtainInfoA()" Link "ObtainInfoA()"}
@{"OpenClipboard()" Link "OpenClipboard()"}
@{"OpenDiskFont()" Link "OpenDiskFont()"}
@{"OpenEngine()" Link "OpenEngine()"}
@{"OpenIFF()" Link "OpenIFF()"}
@{"ParentChunk()" Link "ParentChunk()"}
@{"ParseIFF()" Link "ParseIFF()"}
@{"ParseIX()" Link "ParseIX()"}
@{"PopChunk()" Link "PopChunk()"}
@{"PrintDTObjectA()" Link "PrintDTObjectA()"}
@{"PropChunk()" Link "PropChunk()"}
@{"PropChunks()" Link "PropChunks()"}
@{"PushChunk()" Link "PushChunk()"}
@{"PutDefDiskObject()" Link "PutDefDiskObject()"}
@{"PutDiskObject()" Link "PutDiskObject()"}
@{"QueryKeys()" Link "QueryKeys()"}
@{"ReadChunkBytes()" Link "ReadChunkBytes()"}
@{"ReadChunkRecords()" Link "ReadChunkRecords()"}
@{"ReadJoyPort()" Link "ReadJoyPort()"}
@{"RefreshDTObjectA()" Link "RefreshDTObjectA()"}
@{"ReleaseDataType()" Link "ReleaseDataType()"}
@{"ReleaseInfoA()" Link "ReleaseInfoA()"}
@{"RemKBInt()" Link "RemKBInt()"}
@{"RemoveCxObj()" Link "RemoveCxObj()"}
@{"RemoveDTObject()" Link "RemoveDTObject()"}
@{"RemTimerInt()" Link "RemTimerInt()"}
@{"RemVBlankInt()" Link "RemVBlankInt()"}
@{"RouteCxMsg()" Link "RouteCxMsg()"}
@{"SetCxObjPri()" Link "SetCxObjPri()"}
@{"SetDTAttrsA()" Link "SetDTAttrsA()"}
@{"SetFilter()" Link "SetFilter()"}
@{"SetFilterIX()" Link "SetFilterIX()"}
@{"SetInfoA()" Link "SetInfoA()"}
@{"SetJoyPortAttrsA()" Link "SetJoyPortAttrsA()"}
@{"SetLocalItemPurge()" Link "SetLocalItemPurge()"}
@{"SetNVProtection()" Link "SetNVProtection()"}
@{"SetTranslate()" Link "SetTranslate()"}
@{"StartTimerInt()" Link "StartTimerInt()"}
@{"StopChunk()" Link "StopChunk()"}
@{"StopChunks()" Link "StopChunks()"}
@{"StopOnExit()" Link "StopOnExit()"}
@{"StopTimerInt()" Link "StopTimerInt()"}
@{"StoreItemInContext()" Link "StoreItemInContext()"}
@{"StoreLocalItem()" Link "StoreLocalItem()"}
@{"StoreNV()" Link "StoreNV()"}
@{"SystemControlA()" Link "SystemControlA()"}
@{"WriteChunkBytes()" Link "WriteChunkBytes()"}
@{"WriteChunkRecords()" Link "WriteChunkRecords()"}
@endnode
@Node "AllocIFF()" "iffparse.library/AllocIFF"
@{b}@{u}AllocIFF@{uu}@{ub} -- create a new IFFHandle structure.(V36)
  Allocates and initializes a new IFFHandle structure.
  This function is the only supported way to create an IFFHandle
  structure since there are private fields that need to be initialized.
SYNOPSIS  @{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *AllocIFF( @{FG shine}void@{FG text} );
  @{i}@{b}iff@{ub}@{ui} = AllocIFF()
   D0
  @{i}@{b}iff@{ub}@{ui} - pointer to IFFHandle structure or NULL if the allocation failed.
SEE ALSO
  @{"FreeIFF()" Link "FreeIFF()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "AllocLocalItem()" "iffparse.library/AllocLocalItem"
@{b}@{u}AllocLocalItem@{uu}@{ub} -- create a local context item structure.(V36)
  Allocates and initializes a LocalContextItem structure with "dataSize"
  bytes of associated user data.This is the only supported way to
  create such an item.The user data can be accessed with the
  @{"LocalItemData()" Link "LocalItemData()"} function.An item created with this function
  automatically has its purge vectors set up correctly to dispose of
  itself and its associated user data area.Any additional cleanup
  should be done with a user-supplied purge vector.
SYNOPSIS  @{FG shine}struct@{FG text} @{"LocalContextItem" Link "include:libraries/iffparse.h/Main" 83} *AllocLocalItem(@{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text});
  @{i}@{b}item@{ub}@{ui} = AllocLocalItem(@{i}type@{ui}, @{i}id@{ui}, @{i}ident@{ui}, @{i}dataSize@{ui});
   D0                    D0     D1  D2     D3
  @{i}type@{ui},@{i}id@{ui} - additional longword identification values
  @{i}ident@{ui} - longword identifier for class of context item
  @{i}dataSize@{ui} - number of bytes of user data to allocate for this item
  @{i}@{b}item@{ub}@{ui} - pointer to initialized LocalContextItem,
    or NULL if the allocation failed.
SEE ALSO
  @{"FreeLocalItem()" Link "FreeLocalItem()"} @{"LocalItemData()" Link "LocalItemData()"} @{"StoreLocalItem()" Link "StoreLocalItem()"}
  @{"StoreItemInContext()" Link "StoreItemInContext()"} @{"SetLocalItemPurge()" Link "SetLocalItemPurge()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "CloseClipboard()" "iffparse.library/CloseClipboard"
@{b}@{u}CloseClipboard@{uu}@{ub} -- close and free an open ClipboardHandle.(V36)
  Closes the clipboard.device and frees the ClipboardHandle structure.
SYNOPSIS  @{FG shine}void@{FG text} CloseClipboard(@{FG shine}struct@{FG text} @{"ClipboardHandle" Link "include:libraries/iffparse.h/Main" 130} *);
  CloseClipboard(@{i}clipHandle@{ui});
                  A0
  @{i}clipHandle@{ui} - pointer to ClipboardHandle structure created with
    @{"OpenClipboard()" Link "OpenClipboard()"}.Starting with V39, this may be NULL.
SEE ALSO
  @{"OpenClipboard()" Link "OpenClipboard()"} @{"InitIFFasClip()" Link "InitIFFasClip()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "CloseIFF()" "iffparse.library/CloseIFF"
@{b}@{u}CloseIFF@{uu}@{ub} -- close an IFF context.(V36)
  Completes an IFF read or write operation by closing the IFF context
  established for this IFFHandle structure.The IFFHandle structure
  itself is left ready for re-use and a new context can be opened with
  @{"OpenIFF()" Link "OpenIFF()"}.This function can be used for cleanup if a read or write
  fails partway through.
  As part of its cleanup operation, CloseIFF() calls the client-supplied
  stream hook vector.The @{"IFFStreamCmd" Link "include:libraries/iffparse.h/Main" 55} packet will be set as follows:
    @{i}sc_Command@{ui}: IFFCMD_CLEANUP
    @{i}sc_Buf@{ui}: (Not applicable)
    @{i}sc_NBytes@{ui}: (Not applicable)
  This operation is @{b}NOT@{ub} permitted to fail; any error code returned
  will be ignored (best to return 0, though).@{b}DO NOT@{ub} write to this structure.
SYNOPSIS  @{FG shine}void@{FG text} CloseIFF(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *);
  CloseIFF(@{i}iff@{ui});
            A0                                                   
  @{i}iff@{ui} - pointer to IFFHandle structure previously opened with @{"OpenIFF()" Link "OpenIFF()"}.
    Starting with V39, this may be NULL.
SEE ALSO
  @{"OpenIFF()" Link "OpenIFF()"} @{"InitIFF()" Link "InitIFF()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "CollectionChunk()" "iffparse.library/CollectionChunk"
@{b}@{u}CollectionChunk@{uu}@{ub} -- declare a chunk type for collection.(V36)
  Installs an entry handler for chunks with the given type and id so
  that the contents of those chunks will be stored as they are
  encountered.This is like @{"PropChunk()" Link "PropChunk()"} except that more than one
  chunk of this type can be stored in lists which can be returned by
  @{"FindCollection()" Link "FindCollection()"}.The storage of these chunks still follows the
  property chunk scoping rules for IFF files so that at any given
  point, stored collection chunks will be valid in the current context.
SYNOPSIS  @{FG shine}long@{FG text} CollectionChunk(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, @{FG shine}long@{FG text}, @{FG shine}long@{FG text});
  @{i}@{b}error@{ub}@{ui} = CollectionChunk(@{i}iff@{ui}, @{i}type@{ui}, @{i}id@{ui});
   D0                      A0   D0     D1
  @{i}iff@{ui} - pointer to IFFHandle structure (does not need to be open)
  @{i}type@{ui} - type code for the chunk to declare (ex. "ILBM")
  @{i}id@{ui} - identifier for the chunk to declare (ex. "CRNG")
  @{i}@{b}error@{ub}@{ui} - 0 if successful or an @{i}IFFERR_#?@{ui} error code if unsuccessful.
SEE ALSO
  @{"CollectionChunks()" Link "CollectionChunks()"} @{"FindCollection()" Link "FindCollection()"} @{"PropChunk()" Link "PropChunk()"}
  @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "CollectionChunks()" "iffparse.library/CollectionChunks"
@{b}@{u}CollectionChunks@{uu}@{ub} -- declare many collection chunks at once.(V36)
  Declares multiple collection chunks from a list.The propArray argument
  is a pointer to an array of longwords arranged in pairs.
  @{i}The format for the list is as follows@{ui}:
    TYPE1, ID1, TYPE2, ID2, ..., TYPEn, IDn
  The argument numPairs is the number of pairs, CollectionChunks() just calls
  @{"CollectionChunk()" Link "CollectionChunk()"} numPairs times.
SYNOPSIS  @{FG shine}long@{FG text} CollectionChunks(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, @{FG shine}long@{FG text} *, @{FG shine}long@{FG text});
  @{i}@{b}error@{ub}@{ui} = CollectionChunks(@{i}iff@{ui}, @{i}propArray@{ui}, @{i}numPairs@{ui});
   D0                       A0   A1          D0
  @{i}iff@{ui} - pointer to IFFHandle structure (does not need to be open)
  @{i}propArray@{ui} - pointer to array of longword chunk types and identifiers
  @{i}numPairs@{ui} - number of pairs in array.
  @{i}@{b}error@{ub}@{ui} - 0 if successful or an @{i}IFFERR_#?@{ui} error code if unsuccessful
SEE ALSO
  @{"CollectionChunk()" Link "CollectionChunk()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "CurrentChunk()" "iffparse.library/CurrentChunk"
@{b}@{u}CurrentChunk@{uu}@{ub} -- get context node for current chunk.(V36)
  Returns the top context node for the given IFFHandle structure.The top
  context node corresponds to the chunk most recently pushed on the
  stack. @{i}which@{ui} is the chunk where the stream is currently positioned.
  The ContextNode structure contains information on the type of chunk
  currently being parsed (or written), its size and the current
  position within the chunk.
SYNOPSIS  @{FG shine}struct@{FG text} @{"ContextNode" Link "include:libraries/iffparse.h/Main" 68} *CurrentChunk(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *);
  @{i}@{b}top@{ub}@{ui} = CurrentChunk(@{i}iff@{ui});
   D0                 A0
  @{i}iff@{ui} - pointer to IFFHandle structure
  @{i}@{b}top@{ub}@{ui} - pointer to top context node or NULL if none
SEE ALSO
  @{"PushChunk()" Link "PushChunk()"} @{"PopChunk()" Link "PopChunk()"} @{"ParseIFF()" Link "ParseIFF()"} @{"ParentChunk()" Link "ParentChunk()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "EntryHandler()" "iffparse.library/EntryHandler"
@{b}@{u}EntryHandler@{uu}@{ub} -- add an entry handler to the IFFHandle context.(V36)
  Installs an entry handler vector for a specific type of chunk into
  the context for the given IFFHandle structure.Type and id are the
  longword identifiers for the chunk to handle.The handler is a client-
  supplied standard Hook structure, properly initialized, position
  tells where to put the handler in the context.The handler will be
  called whenever the parser enters a chunk of the given type, so the
  IFF stream will be positioned to read the first data byte in the
  chunk.The handler will execute in the same context as whoever
  called @{"ParseIFF()" Link "ParseIFF()"}.The handler will be called (through the hook)
  with the following arguments:
    A0: the Hook pointer you passed.
    A2: the 'object' pointer you passed.
    A1: pointer to a @{FG shine}long@{FG text} containing the value IFFCMD_ENTRY.
  The error code your call-back routine returns will affect the parser
  in three different ways:
  Return value:       Result:
  ---------------------------
  0: Normal success;  @{"ParseIFF()" Link "ParseIFF()"} will continue through the file.
  IFF_RETURN2CLIENT:  @{"ParseIFF()" Link "ParseIFF()"} will stop and return the value 0.
    (StopChunk() is internally implemented using this return value.)
  Any other value:    @{"ParseIFF()" Link "ParseIFF()"} will stop and return the value
    you supplied.This is how errors should be returned.
SYNOPSIS
  @{FG shine}long@{FG text} EntryHandler(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *, APTR);
  @{i}@{b}error@{ub}@{ui} = EntryHandler(@{i}iff@{ui}, @{i}type@{ui}, @{i}id@{ui}, @{i}position@{ui}, @{i}handler@{ui}, @{i}object@{ui});
   D0                   A0   D0     D1  D2        A1       A2
  @{i}iff@{ui} - pointer to IFFHandle structure.
  @{i}type@{ui} - type code for chunk to handle (ex. "ILBM").
  @{i}id@{ui} - ID code for chunk to handle (ex. "CMAP").
  @{i}position@{ui}- local context item position.One of the @{i}IFFSLI_#?@{ui} codes.
  @{i}handler@{ui} - pointer to Hook structure.
  @{i}object@{ui} - a client-defined pointer which is passed in A2 during callback.
  @{i}@{b}error@{ub}@{ui} - 0 if successful or an @{i}IFFERR_#?@{ui} error code if unsuccessful.
BUGS
  Returning the values @{i}IFFERR_EOF@{ui} or @{i}IFFERR_EOC@{ui} from the callback
  routine *may* confuse the parser.
  There is no way to explicitly remove a handler once installed.
  However, by installing a do-nothing handler using @{i}IFFSLI_TOP@{ui},
  previous handlers will be overridden until the context expires.
SEE ALSO
  @{"ExitHandler()" Link "ExitHandler()"} @{"StoreLocalItem()" Link "StoreLocalItem()"} @{"StoreItemInContext()" Link "StoreItemInContext()"}
  @{"<utility/hooks.h>" Link "include:utility/hooks.h/Main" 0} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "ExitHandler()" "iffparse.library/ExitHandler"
@{b}@{u}ExitHandler@{uu}@{ub} -- add an exit handler to the IFFHandle context.(V36)
  Installs an exit handler vector for a specific type of chunk into the
  context for the given IFFHandle structure.Type and id are the longword
  identifiers for the chunk to handle.The handler is a client-supplied
  standard Hook structure, properly initialized.Position tells
  where to put the handler in the context.The handler will be called
  just before the parser exits the given chunk in the "pause" parse
  state.The IFF stream may not be positioned predictably within the
  chunk.The handler will execute in the same context as whoever
  called @{"ParseIFF()" Link "ParseIFF()"}.The handler will be called (through the hook)
  with the following arguments:
    A0: the Hook pointer you passed.
    A2: the 'object' pointer you passed.
    A1: pointer to a @{FG shine}long@{FG text} containing the value IFFCMD_EXIT.
  The error code your call-back routine returns will affect the parser
  in three different ways:
  Return value:       Result:
  ---------------------------
  0: Normal success;  @{"ParseIFF()" Link "ParseIFF()"} will continue through the file.
  IFF_RETURN2CLIENT:  @{"ParseIFF()" Link "ParseIFF()"} will stop and return the value 0.
    (StopChunk() is internally implemented using this return value.)
  Any other value:    @{"ParseIFF()" Link "ParseIFF()"} will stop and return the value
    you supplied.This is how errors should be returned.
SYNOPSIS
  @{FG shine}long@{FG text} ExitHandler(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *,
    APTR object(;
  @{i}@{b}error@{ub}@{ui} = ExitHandler(@{i}iff@{ui}, @{i}type@{ui}, @{i}id@{ui}, @{i}position@{ui}, @{i}handler@{ui}, @{i}object@{ui});
   D0                  A0   D0     D1  D2        A1       A2
  @{i}iff@{ui} - pointer to IFFHandle structure.
  @{i}type@{ui} - type code for chunk to handle (ex. "ILBM").
  @{i}id@{ui} - identifier code for chunk to handle (ex. "CMAP").
  @{i}position@{ui} - local context item position.One of the @{i}IFFSLI_#?@{ui} codes.
  @{i}handler@{ui} - pointer to Hook structure.
  @{i}object@{ui} - a client-defined pointer which is passed in A2 during callback.
  @{i}@{b}error@{ub}@{ui} - 0 if successful or an @{i}IFFERR_#?@{ui} error code if unsuccessful.
BUGS
  Returning the values @{i}IFFERR_EOF@{ui} or @{i}IFFERR_EOC@{ui} from the callback
  routine *may* confuse the parser.
  There is no way to explicitly remove a handler once installed.
  However, by installing a do-nothing handler using @{i}IFFSLI_TOP@{ui},
  previous handlers will be overridden until the context expires.
SEE ALSO
  @{"EntryHandler()" Link "EntryHandler()"} @{"StoreLocalItem()" Link "StoreLocalItem()"} @{"StoreItemInContext()" Link "StoreItemInContext()"}
  @{"<utility/hooks.h>" Link "include:utility/hooks.h/Main" 0} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "FindCollection()" "iffparse.library/FindCollection"
@{b}@{u}FindCollection@{uu}@{ub} -- get a pointer to the current list of collection items.(V36)
  Returns a pointer to a list of CollectionItem structures for each of
  the collection chunks of the given type encountered so far in the
  course of parsing this IFF file.The items appearing first in the
  list will be the ones encountered most recently.
SYNOPSIS
  @{FG shine}struct@{FG text} @{"CollectionItem" Link "include:libraries/iffparse.h/Main" 114} *FindCollection(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, @{FG shine}long@{FG text}, @{FG shine}long@{FG text});
  @{i}@{b}ci@{ub}@{ui} = FindCollection(@{i}iff@{ui}, @{i}type@{ui}, @{i}id@{ui});
   D0                  A0   D0     D1
  @{i}iff@{ui} - pointer to IFFHandle structure.
  @{i}type@{ui} - type code to search for.
  @{i}id@{ui} - identifier code to search for.
  @{i}@{b}ci@{ub}@{ui} - pointer to last collection chunk encountered with links to previous ones.
SEE ALSO
  @{"CollectionChunk()" Link "CollectionChunk()"} @{"CollectionChunks()" Link "CollectionChunks()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "FindLocalItem()" "iffparse.library/FindLocalItem"
@{b}@{u}FindLocalItem@{uu}@{ub} -- return a local context item from the context stack.(V36)
  Searches the context stack of the given IFFHandle structure for a
  local context item which matches the given ident, type and id.This
  function searches the context stack from the most current context
  backwards, so that the item found (if any) will be the one with
  greatest precedence in the context stack.
SYNOPSIS
  @{FG shine}struct@{FG text} @{"LocalContextItem" Link "include:libraries/iffparse.h/Main" 83} *FindLocalItem(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text});
  @{i}@{b}lci@{ub}@{ui} = FindLocalItem(@{i}iff@{ui}, @{i}type@{ui}, @{i}id@{ui}, @{i}ident@{ui});
   D0                  A0   D0     D1  D2
  @{i}iff@{ui} - pointer to IFFHandle structure.
  @{i}type@{ui} - type code to search for.
  @{i}id@{ui} - ID code to search for.
  @{i}ident@{ui} - ident code for the class of context item to search for
    (ex. "exhd" -- exit handler).
  @{i}@{b}lci@{ub}@{ui} - pointer to local context item, or NULL if nothing matched.
SEE ALSO
  @{"StoreLocalItem()" Link "StoreLocalItem()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "FindProp()" "iffparse.library/FindProp"
@{b}@{u}FindProp@{uu}@{ub} -- search for a stored property chunk.(V36)
  Searches for the stored property which is valid in the given context.
  Property chunks are automatically stored by @{"ParseIFF()" Link "ParseIFF()"} when
  pre-declared by @{"PropChunk()" Link "PropChunk()"} or @{"PropChunks()" Link "PropChunks()"}.The StoredProperty structure,
  if found, contains a pointer to a data buffer containing the
  contents of the stored property.
SYNOPSIS  @{FG shine}struct@{FG text} @{"StoredProperty" Link "include:libraries/iffparse.h/Main" 97} *FindProp(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, @{FG shine}long@{FG text}, @{FG shine}long@{FG text});
  @{i}@{b}sp@{ub}@{ui} = FindProp(@{i}iff@{ui}, @{i}type@{ui}, @{i}id@{ui});
   D0            A0   D0     D1
  @{i}iff@{ui} - pointer to IFFHandle structure.
  @{i}type@{ui} - type code for chunk to search for (ex. "ILBM").
  @{i}id@{ui} - identifier code for chunk to search for (ex. "CMAP").
  @{i}@{b}sp@{ub}@{ui} - pointer to stored property, or NULL if none found.
SEE ALSO
  @{"PropChunk()" Link "PropChunk()"} @{"PropChunks()" Link "PropChunks()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "FindPropContext()" "iffparse.library/FindPropContext"
@{b}@{u}FindPropContext@{uu}@{ub} -- get the property context for the current state.(V36)
  Locates the context node which would be the scoping chunk for
  properties in the current parsing state.(Huh?)  This is used for
  locating the proper scoping context for property chunks i.e. the
  scope from which a property would apply.This is usually the FORM
  or LIST with the highest precedence in the context stack.
  If you don't understand this, read the IFF spec a couple more times.
SYNOPSIS  @{FG shine}struct@{FG text} @{"ContextNode" Link "include:libraries/iffparse.h/Main" 68} *FindPropContext(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *);
  @{i}@{b}cn@{ub}@{ui} = FindPropContext(@{i}iff@{ui});
   D0                   A0
  @{i}iff@{ui} - pointer to IFFHandle structure.
  @{i}@{b}cn@{ub}@{ui} - ContextNode of property scoping chunk.
SEE ALSO
  @{"CurrentChunk()" Link "CurrentChunk()"} @{"ParentChunk()" Link "ParentChunk()"} @{"StoreItemInContext()" Link "StoreItemInContext()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "FreeIFF()" "iffparse.library/FreeIFF"
@{b}@{u}FreeIFF@{uu}@{ub} -- deallocate an IFFHandle structure.(V36)
  Deallocates all resources associated with this IFFHandle structure.
  The structure @{b}MUST@{ub} have already been closed with @{"CloseIFF()" Link "CloseIFF()"}.
SYNOPSIS  @{FG shine}void@{FG text} FreeIFF(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *);
  FreeIFF(@{i}iff@{ui});
           A0
  @{i}iff@{ui} - pointer to IFFHandle structure to free.
    Starting with V39, this may be NULL.
SEE ALSO
  @{"AllocIFF()" Link "AllocIFF()"} @{"CloseIFF()" Link "CloseIFF()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "FreeLocalItem()" "iffparse.library/FreeLocalItem"
@{b}@{u}FreeLocalItem@{uu}@{ub} -- deallocate a local context item structure.(V36)
  Frees the memory for the local context item and any associated user
  memory as allocated with @{"AllocLocalItem()" Link "AllocLocalItem()"}.User purge vectors should
  call this function after they have freed any other resources
  associated with this item.
  Note that FreeLocalItem() does @{b}NOT@{ub} call the custom purge vector set
  up through SetLocalItemPurge(); all it does is free the local context
  item.(This implies that your custom purge vector would want to call
  this to ultimately free the LocalContextItem.)
SYNOPSIS  @{FG shine}void@{FG text} FreeLocalItem(@{FG shine}struct@{FG text} @{"LocalContextItem" Link "include:libraries/iffparse.h/Main" 83} *);
  FreeLocalItem(@{i}localItem@{ui});
                 A0
  @{i}localItem@{ui} - pointer to LocalContextItem created with @{"AllocLocalItem" Link "AllocLocalItem()"}.
    Starting with V39, this may be NULL.
SEE ALSO
  @{"AllocLocalItem()" Link "AllocLocalItem()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "GoodID()" "iffparse.library/GoodID"
@{b}@{u}GoodID@{uu}@{ub} -- test if an identifier follows the IFF 85 specification.(V36)
  Tests the given longword identifier to see if it meets all the EA IFF
  85 specifications for a chunk ID.If so, it returns non-zero, otherwise 0.
SYNOPSIS  @{FG shine}long@{FG text} GoodID(@{FG shine}long@{FG text});
  @{i}@{b}isok@{ub}@{ui} = GoodID(@{i}id@{ui});
   D0            D0
  @{i}id@{ui} - potential 32 bit identifier.
  @{i}@{b}isok@{ub}@{ui} - non-zero if this is a valid ID, 0 otherwise.
SEE ALSO
  @{"GoodType()" Link "GoodType()"}
@EndNode
@Node "GoodType()" "iffparse.library/GoodType"
@{b}@{u}GoodType@{uu}@{ub} -- test if a type follows the IFF 85 specification.(V36)
  Tests the given longword type identifier to see if it meets all the
  EA IFF 85 specifications for a FORM type (requirements for a FORM
  type are more stringent than those for a simple chunk ID).If it
  complies, GoodType() returns non-zero, otherwise 0.
SYNOPSIS  @{FG shine}long@{FG text} GoodType(@{FG shine}long@{FG text});
  @{i}@{b}isok@{ub}@{ui} = GoodType(@{i}type@{ui})
   D0              D0
  @{i}type@{ui} - potential 32 bit format type identifier.
  @{i}@{b}isok@{ub}@{ui} - non-zero if this is a valid type id, 0 otherwise.
SEE ALSO
  @{"GoodID()" Link "GoodID()"}
@EndNode
@Node "IDtoStr()" "iffparse.library/IDtoStr"
@{b}@{u}IDtoStr@{uu}@{ub} -- convert a longword identifier to a null-terminated string.(V36)
  Writes the ASCII equivalent of the given longword ID into buf as a
  null-terminated string.
SYNOPSIS  STRPTR IDtoStr(@{FG shine}long@{FG text}, STRPTR);
  @{i}@{b}str@{ub}@{ui} = IDtoStr(@{i}id@{ui}, @{i}buf@{ui});
   D0            D0  A0
  @{i}id@{ui} - longword ID.
  @{i}buf@{ui} - character buffer to accept string (at least 5 chars).
  @{i}@{b}str@{ub}@{ui} - the value of 'buf'.
@EndNode
@Node "InitIFF()" "iffparse.library/InitIFF"
@{b}@{u}InitIFF@{uu}@{ub} -- initialize an IFFHandle structure as a user stream.(V36)
  Initializes an IFFHandle as a general user-defined stream by
  allowing the user to declare a hook that the library will call to
  accomplish the low-level reading, writing, and seeking of the stream.
  Flags are the stream I/O flags for the specified stream; typically a
  combination of the @{i}IFFF_?SEEK@{ui} flags.
  The stream vector is called with the following arguments:
    A0: pointer to streamhook.
    A2: pointer to IFFHandle structure.
    A1: pointer to @{"IFFStreamCmd" Link "include:libraries/iffparse.h/Main" 55} structure.
@{"IFFStreamCmd packet" link INITIFF_IFFSTREAMCMD}
SYNOPSIS  @{FG shine}void@{FG text} InitIFF(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, @{FG shine}long@{FG text}, @{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *);
  InitIFF(@{i}iff@{ui}, @{i}flags@{ui}, @{i}streamHook@{ui});
           A0   D0      A1
  @{i}iff@{ui} - pointer to IFFHandle structure to initialize.
  @{i}flags@{ui} - stream I/O flags for the IFFHandle.
  @{i}streamHook@{ui} - pointer to Hook structure.
SEE ALSO
  @{"<utility/hooks.h>" Link "include:utility/hooks.h/Main" 0} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@node INITIFF_IFFSTREAMCMD "InitIFF_IFFStreamCmd"
@{b}@{u}The IFFStreamCmd packet appears as follows@{uu}@{ub}:
  @{i}sc_Command@{ui}: Contains an IFFCMD_#? value
  @{i}sc_Buf@{ui}:   Pointer to memory buffer
  @{i}sc_NBytes@{ui}:  Number of bytes involved in operation
@{b}@{u}The values taken on by @{uu}@{ub}@{i}@{u}sc_Command@{uu}@{ui}@{b}@{u}, and their meaning, are as follows@{uu}@{ub}:
@{b}IFFCMD_INIT@{ub} - Prepare your stream for reading.
  This is used for certain streams that can't be read immediately upon opening,
  and need further preparation.(The clipboard.device is an example of such a
  stream.) This operation is allowed to fail; any error code will be returned
  directly to the client, @{i}sc_Buf@{ui} and @{i}sc_NBytes@{ui} have no meaning here.
@{b}IFFCMD_CLEANUP@{ub} - Terminate the transaction with the associated stream.
  This is used with streams that can't simply be closed.(Again, the clipboard
  is an example of such a stream.) This operation is not permitted to fail;
  any error returned will be ignored (best to return 0, though), @{i}sc_Buf@{ui} and
  @{i}sc_NBytes@{ui} have no meaning here.
@{b}IFFCMD_READ@{ub} - Read from the stream.
  You are to read @{i}sc_NBytes@{ui} from the stream and place them in the buffer
  pointed to by @{i}sc_Buf@{ui}.Any (non-zero) error returned will be remapped by
  the parser into @{i}IFFERR_READ@{ui}.
@{b}IFFCMD_WRITE@{ub} - Write to the stream.
  You are to write @{i}sc_NBytes@{ui} to the stream from the buffer pointed to by
  @{i}sc_Buf@{ui}.Any (non-zero) error returned will be remapped by the parser into
  @{i}IFFERR_WRITE@{ui}.
@{b}IFFCMD_SEEK@{ub} - Seek on the stream.
  You are to perform a seek on the stream relative to the current position,
  @{i}sc_NBytes@{ui} is signed; negative values mean seek backward, positive values
  mean seek forward, @{i}sc_Buf@{ui} has no meaning here.Any (non-zero) error returned
  will be remapped by the parser into @{i}IFFERR_SEEK@{ui}.
All errors are returned in D0. A return of 0 indicates success.
@{b}UNDER NO CIRCUMSTANCES@{ub} are you permitted to write to the @{"IFFStreamCmd" Link "include:libraries/iffparse.h/Main" 55} structure.
@endnode
@Node "InitIFFasClip()" "iffparse.library/InitIFFasClip"
@{b}@{u}InitIFFasClip@{uu}@{ub} -- initialize an IFFHandle as a clipboard stream.(V36)
  Initializes the given IFFHandle to be a clipboard stream.The
  function initializes the stream processing vectors to operate on
  streams of the @{"ClipboardHandle" Link "include:libraries/iffparse.h/Main" 130} type.The iff_Stream field will still
  need to be initialized to point to a ClipboardHandle as returned from
  @{"OpenClipboard()" Link "OpenClipboard()"}.
SYNOPSIS  @{FG shine}void@{FG text} InitIFFasClip(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *);
  InitIFFasClip(@{i}iff@{ui});
                 A0
  @{i}iff@{ui} - pointer to IFFHandle structure.
SEE ALSO
  @{"InitIFF()" Link "InitIFF()"} @{"OpenClipboard()" Link "OpenClipboard()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "InitIFFasDOS()" "iffparse.library/InitIFFasDOS"
@{b}@{u}InitIFFasDOS@{uu}@{ub} -- initialize an IFFHandle as a DOS stream.(V36)
  The function initializes the given IFFHandle to operate on DOS
  streams.The iff_Stream field will need to be initialized as a BPTR
  returned from the DOS function @{"Open()" Link "dos.guide/Open()"}.
SYNOPSIS  InitIFFasDOS(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *);
  InitIFFasDOS(@{i}iff@{ui})
                A0
  @{i}iff@{ui} - pointer to IFFHandle structure.
SEE ALSO
  @{"InitIFF()" Link "InitIFF()"}
@EndNode
@Node "LocalItemData()" "iffparse.library/LocalItemData"
@{b}@{u}LocalItemData@{uu}@{ub} -- get pointer to user data for local context item.(V36)
  Returns pointer to the user data associated with the given local
  context item.The size of the data area depends on the "dataSize"
  argument used when allocating this item.If the pointer to the item
  given (localItem) is NULL, this function returns NULL.
SYNOPSIS  APTR LocalItemData(@{FG shine}struct@{FG text} @{"LocalContextItem" Link "include:libraries/iffparse.h/Main" 83} *);
  @{i}@{b}data@{ub}@{ui} = LocalItemData(@{i}localItem@{ui});
   D0                   A0
  @{i}localItem@{ui} - pointer to local context item or NULL.
  @{i}@{b}data@{ub}@{ui} - pointer to user data area or NULL if localItem is NULL.
BUGS
  Currently, there is no way to determine the size of the user data
  area; you have to 'know'.
SEE ALSO
  @{"AllocLocalItem()" Link "AllocLocalItem()"} @{"FreeLocalItem()" Link "FreeLocalItem()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "OpenClipboard()" "iffparse.library/OpenClipboard"
@{b}@{u}OpenClipboard@{uu}@{ub} -- create a handle on a clipboard unit.(V36)
  Opens the clipboard.device and opens a stream for the specified unit
  (usually @{i}PRIMARY_CLIP@{ui}).This handle structure will be used as the clipboard
  stream for IFFHandles initialized as clipboard streams by @{"InitIFFasClip()" Link "InitIFFasClip()"}.
SYNOPSIS  @{FG shine}struct@{FG text} @{"ClipboardHandle" Link "include:libraries/iffparse.h/Main" 130} *OpenClipboard(@{FG shine}long@{FG text});
  @{i}@{b}ch@{ub}@{ui} = OpenClipboard(@{i}unitNumber@{ui})
   D0                 D0
  @{i}unitNumber@{ui} - clipboard unit number (usually @{i}PRIMARY_CLIP@{ui}).
  @{i}@{b}ch@{ub}@{ui} - pointer to ClipboardHandle structure or NULL if unsuccessful.
BUGS
  This function had several bugs prior to V39.
  First bug was that if the clipboard.device couldn't open, two calls
  to @{"FreeSignal()" Link "exec.guide/FreeSignal()"} were made with uninitialized values as parameters.
  The result of this was a corrupt signal mask in the @{"Task" Link "include:exec/tasks.h/Main" 24} field.
  Second bug was that @{"OpenDevice()" Link "exec.guide/OpenDevice()"} was called with an IO request that
  didn't have a valid @{"MsgPort" Link "include:exec/ports.h/Main" 28} pointer in it.
  Third bug was that the two message ports allocated by the function
  (ClipboardHandle->@{i}cbh_CBport@{ui} and ClipboardHandle->@{i}cbh_SatisfyPort@{ui})
  were not being initialized correctly and would cause a system crash
  if a message ever got to either of them.
SEE ALSO
  @{"InitIFFasClip()" Link "InitIFFasClip()"} @{"CloseClipboard()" Link "CloseClipboard()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "OpenIFF()" "iffparse.library/OpenIFF"
@{b}@{u}OpenIFF@{uu}@{ub} -- prepare an IFFHandle to read or write a new IFF stream.(V36)
  Initializes an IFFHandle structure for a new read or write.The
  direction of the I/O is given by the value of rwMode, which can be
  either @{i}IFFF_READ@{ui} or @{i}IFFF_WRITE@{ui}.
  As part of its initialization procedure.OpenIFF() calls the client-supplied
  stream hook vector.The @{"IFFStreamCmd" Link "include:libraries/iffparse.h/Main" 55} packet will contain the following:
    @{i}sc_Command@{ui}: IFFCMD_INIT
    @{i}sc_Buf@{ui}:   (Not applicable)
    @{i}sc_NBytes@{ui}:  (Not applicable)
  This operation is permitted to fail.@{b}DO NOT@{ub} write to this structure.
SYNOPSIS  @{FG shine}long@{FG text} OpenIFF(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, @{FG shine}long@{FG text});
  @{i}@{b}error@{ub}@{ui} = OpenIFF(@{i}iff@{ui}, @{i}rwMode@{ui});
   D0              A0    D0
  @{i}iff@{ui} - pointer to IFFHandle structure.
    Starting with V39, this may be NULL, in which case @{i}IFFERR_NOMEM@{ui} is returned.
  @{i}rwMode@{ui} - @{i}IFFF_READ@{ui} or @{i}IFFF_WRITE@{ui}
  @{i}@{b}error@{ub}@{ui} - contains an error code or 0 if successful
SEE ALSO
  @{"CloseIFF()" Link "CloseIFF()"} @{"InitIFF()" Link "InitIFF()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "ParentChunk()" "iffparse.library/ParentChunk"
@{b}@{u}ParentChunk@{uu}@{ub} -- get the nesting context node for the given chunk.(V36)
  Returns a context node for the chunk containing the chunk for the
  given context node.This function effectively moves down the context
  stack into previously pushed contexts.For example, to get a
  ContextNode pointer for the enclosing FORM chunk while reading a data
  chunk, use: ParentChunk(CurrentChunk(iff)) to find this pointer.
  The ContextNode structure contains information on the type of chunk
  and its size.
SYNOPSIS  @{FG shine}struct@{FG text} @{"ContextNode" Link "include:libraries/iffparse.h/Main" 68} *ParentChunk(@{FG shine}struct@{FG text} ContextNode *);
  @{i}@{b}parent@{ub}@{ui} = ParentChunk(@{i}contextNode@{ui});
   D0                   A0
  @{i}contextNode@{ui} - pointer to a context node.
  @{i}@{b}parent@{ub}@{ui} - pointer to the enclosing context node or NULL if none.
SEE ALSO
  @{"CurrentChunk()" Link "CurrentChunk()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "ParseIFF()" "iffparse.library/ParseIFF"
@{b}@{u}ParseIFF@{uu}@{ub} -- parse an IFF file from an IFFHandle structure stream.(V36)
  This is the biggie.
  Traverses a file opened for read by pushing chunks onto the context
  stack and popping them off directed by the generic syntax of IFF
  files.As it pushes each new chunk, it searches the context stack
  for handlers to apply to chunks of that type.If it finds an entry
  handler it will invoke it just after entering the chunk.If it finds
  an exit handler it will invoke it just before leaving the chunk.
  Standard handlers include entry handlers for pre-declared property chunks and
  collection chunks and entry and exit handlers for for stop chunks - that is,
  chunks which will cause the ParseIFF() function to return control to the
  client.Client programs can also provide their own custom handlers.
SYNOPSIS  @{FG shine}long@{FG text} ParseIFF(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, @{FG shine}long@{FG text});
  @{i}@{b}error@{ub}@{ui} = ParseIFF(@{i}iff@{ui}, @{i}control@{ui});
   D0               A0    D0
  @{i}iff@{ui} - pointer to IFFHandle structure.
  @{"control" link PARSEIFF_CONTROLFLAGS} - control code flags (@{i}IFFPARSE_SCAN@{ui}, @{i}_STEP@{ui} or @{i}_RAWSTEP@{ui}).
  @{i}@{b}error@{ub}@{ui} - 0 or @{i}IFFERR_#?@{ui} value or return value from user handler.
SEE ALSO
  @{"PushChunk()" Link "PushChunk()"} @{"PopChunk()" Link "PopChunk()"} @{"EntryHandler()" Link "EntryHandler()"} @{"ExitHandler()" Link "ExitHandler()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
  @{"PropChunk()" Link "PropChunk()"} @{"CollectionChunk()" Link "CollectionChunk()"} @{"StopChunk()" Link "StopChunk()"} @{"StopOnExit()" Link "StopOnExit()"}
@EndNode
@node PARSEIFF_CONTROLFLAGS "ParseIFF_controlflags"
@{b}IFFPARSE_SCAN@{ub} - In this normal mode, ParseIFF() will only return control to
  the caller when either:
    1) an error is encountered,
    2) a stop chunk is encountered, or a user handle
      returns the special @{i}IFF_RETURN2CLIENT@{ui} code, or
    3) the end of the logical file is reached,
      in which case @{i}IFFERR_EOF@{ui} is returned.
  ParseIFF() will continue pushing and popping chunks until one of these
  conditions occurs.If ParseIFF() is called again after returning, it will
  continue to parse the file where it left off.
@{b}IFFPARSE_STEP@{ub} and @{b}_RAWSTEP@{ub} - In these two modes, ParseIFF() will return control
  to the caller after every step in the parse, specifically, after each push of
  a context node and just before each pop.If returning just before a pop,
  ParseIFF() will return @{i}IFFERR_EOC@{ui}, which is not an error, per se, but is just
  an indication that the most recent context is ending.In STEP mode, ParseIFF()
  will invoke the handlers for chunks, if any, before returning.In RAWSTEP mode,
  ParseIFF() will not invoke any handlers and will return right away.
  In both cases the function can be called multiple times to step through the
  parsing of the IFF file.
@endnode
@Node "PopChunk()" "iffparse.library/PopChunk"
@{b}@{u}PopChunk@{uu}@{ub} -- pop top context node off context stack.(V36)
  Pops top context chunk and frees all associated local context items.
  The function is normally called only for writing files and signals
  the end of a chunk.
SYNOPSIS  @{FG shine}long@{FG text} PopChunk(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *);
  @{i}@{b}error@{ub}@{ui} = PopChunk(@{i}iff@{ui});
   D0               A0
  @{i}iff@{ui} - pointer to IFFHandle structure.
  @{i}@{b}error@{ub}@{ui} - 0 if successful or an @{i}IFFERR_#?@{ui} error code if unsuccessful.
SEE ALSO
  @{"PushChunk()" Link "PushChunk()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "PropChunk()" "iffparse.library/PropChunk"
@{b}@{u}PropChunk@{uu}@{ub} -- specify a property chunk to store.(V36)
  Installs an entry handler for chunks with the given type and ID so
  that the contents of those chunks will be stored as they are
  encountered.The storage of these chunks follows the property chunk
  scoping rules for IFF files so that at any given point, a stored
  property chunk returned by @{"FindProp()" Link "FindProp()"} will be the valid property for
  the current context.
SYNOPSIS  @{FG shine}long@{FG text} PropChunk(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, @{FG shine}long@{FG text}, @{FG shine}long@{FG text});
  @{i}@{b}error@{ub}@{ui} = PropChunk(@{i}iff@{ui}, @{i}type@{ui}, @{i}id@{ui});
   D0                A0   D0     D1
  @{i}iff@{ui} - pointer to IFFHandle structure (does not need to be open).
  @{i}type@{ui} - type code for the chunk to declare (ex. "ILBM").
  @{i}id@{ui} - identifier for the chunk to declare (ex. "CMAP").
  @{i}@{b}error@{ub}@{ui} - 0 if successful or an @{i}IFFERR_#?@{ui} error code if unsuccessful.
SEE ALSO
  @{"PropChunks()" Link "PropChunks()"} @{"FindProp()" Link "FindProp()"} @{"CollectionChunk()" Link "CollectionChunk()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "PropChunks()" "iffparse.library/PropChunks"
@{b}@{u}PropChunks@{uu}@{ub} -- declare many property chunks at once.(V36)
  Declares multiple property chunks from a list.The propArray argument
  if a pointer to an array of longwords arranged in pairs, and has the
  following format:
    TYPE1, ID1, TYPE2, ID2, ..., TYPEn, IDn
  The argument numPairs is the number of pairs, PropChunks() just calls
  @{"PropChunk()" Link "PropChunk()"} numPairs times.
SYNOPSIS  @{FG shine}long@{FG text} PropChunks(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, @{FG shine}long@{FG text} *, @{FG shine}long@{FG text});
  @{i}@{b}error@{ub}@{ui} = PropChunks(@{i}iff@{ui}, @{i}propArray@{ui}, @{i}numPairs@{ui});
   D0                 A0   A1          D0
  @{i}iff@{ui} - pointer to IFFHandle structure.
  @{i}propArray@{ui} - pointer to array of longword chunk types and identifiers.
  @{i}numPairs@{ui} - number of pairs in the array.
  @{i}@{b}error@{ub}@{ui} - 0 if successful or an @{i}IFFERR_#?@{ui} error code if unsuccessful.
SEE ALSO
  @{"PropChunk()" Link "PropChunk()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "PushChunk()" "iffparse.library/PushChunk"
@{b}@{u}PushChunk@{uu}@{ub} -- push a new context node on the context stack.(V36)
  Pushes a new context node on the context stack by reading it from the
  stream if this is a read file, or by creating it from the passed
  parameters if this is a write file.Normally this function is only
  called in write mode, where the type and id codes specify the new
  chunk to create.If this is a leaf chunk, i.e. a local chunk inside
  a FORM or PROP chunk, then the type argument is ignored.If the size
  is specified then the chunk writing functions will enforce this size.
  If the size is given as @{i}IFFSIZE_UNKNOWN@{ui}, the chunk will expand to
  accommodate whatever is written into it.
SYNOPSIS  @{FG shine}long@{FG text} PushChunk(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, @{FG shine}long@{FG text}, @{FG shine}long@{FG text}, @{FG shine}long@{FG text});
  @{i}@{b}error@{ub}@{ui} = PushChunk(@{i}iff@{ui}, @{i}type@{ui}, @{i}id@{ui}, @{i}size@{ui});
   D0                A0   D0     D1  D2
  @{i}iff@{ui} - pointer to IFFHandle structure.
  @{i}type@{ui} - chunk type specifier (ex. ILBM) (ignored for read mode or leaf chunks).
  @{i}id@{ui} - chunk id specifier (ex. CMAP) (ignored for read mode).
  @{i}size@{ui} - size of the chunk to create or @{i}IFFSIZE_UNKNOWN@{ui} (ignored for read mode).
  @{i}@{b}error@{ub}@{ui} - 0 if successful or an @{i}IFFERR_#?@{ui} error code if not unsuccessful.
SEE ALSO
  @{"PopChunk()" Link "PopChunk()"} @{"WriteChunkRecords()" Link "WriteChunkRecords()"} @{"WriteChunkBytes()" Link "WriteChunkBytes()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "ReadChunkBytes()" "iffparse.library/ReadChunkBytes"
@{b}@{u}ReadChunkBytes@{uu}@{ub} -- read bytes from the current chunk into a buffer.(V36)
  Reads the IFFHandle stream into the buffer for the specified number
  of bytes.Reads are limited to the size of the current chunk and
  attempts to read past the end of the chunk will truncate.This
  function returns positive number of bytes read or a negative error code.
SYNOPSIS  @{FG shine}long@{FG text} ReadChunkBytes(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, APTR buf, @{FG shine}long@{FG text});
  @{i}@{b}actual@{ub}@{ui} = ReadChunkBytes(@{i}iff@{ui}, @{i}buf@{ui}, @{i}numBytes@{ui});
   D0                      A0   A1    D0
  @{i}iff@{ui} - pointer to IFFHandle structure.
  @{i}buf@{ui} - pointer to buffer area to receive data.
  @{i}numBytes@{ui} - number of bytes to read.
  @{i}@{b}actual@{ub}@{ui} - (positive) number of bytes read if successful or a
    (negative) @{i}IFFERR_#?@{ui} error code if unsuccessful.
SEE ALSO
  @{"ReadChunkRecords()" Link "ReadChunkRecords()"} @{"ParseIFF()" Link "ParseIFF()"} @{"WriteChunkBytes()" Link "WriteChunkBytes()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "ReadChunkRecords()" "iffparse.library/ReadChunkRecords"
@{b}@{u}ReadChunkRecords@{uu}@{ub} -- read record elements from the current chunk into a buffer.(V36)
  Reads records from the current chunk into buffer.Truncates attempts
  to read past end of chunk (only whole records are read; remaining
  bytes that are not of a whole record size are left unread and
  available for @{"ReadChunkBytes()" Link "ReadChunkBytes()"}).
SYNOPSIS  @{FG shine}long@{FG text} ReadChunkRecords(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, APTR, @{FG shine}long@{FG text}, @{FG shine}long@{FG text});
  @{i}@{b}actual@{ub}@{ui} = ReadChunkRecords(@{i}iff@{ui}, @{i}buf@{ui}, bytesPerRecord, numRecords);
   D0                        A0   A1   D0              D1
  @{i}iff@{ui} - pointer to IFFHandle structure.
  @{i}buf@{ui} - pointer to buffer area to receive data.
  @{i}bytesPerRecord@{ui}  - size of data records to read.
  @{i}numRecords@{ui} - number of data records to read.
  @{i}@{b}actual@{ub}@{ui} - (positive) number of whole records read if successful or a
    (negative) @{i}IFFERR_#?@{ui} error code if unsuccessful.
SEE ALSO
  @{"ReadChunkBytes()" Link "ReadChunkBytes()"} @{"ParseIFF()" Link "ParseIFF()"} @{"WriteChunkRecords()" Link "WriteChunkRecords()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "SetLocalItemPurge()" "iffparse.library/SetLocalItemPurge"
@{b}@{u}SetLocalItemPurge@{uu}@{ub} -- set purge vector for a local context item.(V36)
  Sets a local context item to use a client-supplied cleanup (purge)
  vector for disposal when its context is popped.The purge vector
  will be called when the @{"ContextNode" Link "include:libraries/iffparse.h/Main" 68} containing this local item is
  popped off the context stack and is about to be deleted itself.If
  the purge vector has not been set, the parser will use @{"FreeLocalItem()" Link "FreeLocalItem()"}
  to delete the item, but if this function is used to set the purge
  vector, the supplied vector will be called with the following arguments:
    A0: pointer to purgeHook.
    A2: pointer to LocalContextItem to be freed.
    A1: pointer to a @{FG shine}long@{FG text} containing the value @{i}IFFCMD_PURGELCI@{ui}.
  The user purge vector is then responsible for calling @{"FreeLocalItem()" Link "FreeLocalItem()"}
  as part of its own cleanup.Although the purge vector can return a value, it
  will be ignored - purge vectors must always work (best to return 0, though).
SYNOPSIS  @{FG shine}void@{FG text} SetLocalItemPurge(@{FG shine}struct@{FG text} @{"LocalContextItem" Link "include:libraries/iffparse.h/Main" 83} *, @{FG shine}struct@{FG text} @{"Hook" Link "include:utility/hooks.h/Main" 23} *);
  SetLocalItemPurge(@{i}localItem@{ui} @{i}purgeHook@{ui});
                     A0        A1
  @{i}localItem@{ui} - pointer to a local context item.
  @{i}purgeHook@{ui} - pointer to a Hook structure.
SEE ALSO
  @{"AllocLocalItem()" Link "AllocLocalItem()"} @{"FreeLocalItem()" Link "FreeLocalItem()"} @{"<utility/hooks.h>" Link "include:utility/hooks.h/Main" 0} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "StopChunk()" "iffparse.library/StopChunk"
@{b}@{u}StopChunk@{uu}@{ub} -- declare a chunk which should cause @{"ParseIFF" Link "ParseIFF()"} to return.(V36)
  Installs an entry handler for the specified chunk which will cause
  the @{"ParseIFF()" Link "ParseIFF()"} function to return control to the caller when this
  chunk is encountered.This is only of value when @{"ParseIFF()" Link "ParseIFF()"} is
  called with the @{i}IFFPARSE_SCAN@{ui} control code.
SYNOPSIS  @{FG shine}long@{FG text} StopChunk(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, @{FG shine}long@{FG text}, @{FG shine}long@{FG text});
  @{i}@{b}error@{ub}@{ui} = StopChunk(@{i}iff@{ui}, @{i}type@{ui}, @{i}id@{ui});
   D0                A0   D0     D1
  @{i}iff@{ui} - pointer to IFFHandle structure (need not be open).
  @{i}type@{ui} - type code for chunk to declare (ex. "ILBM").
  @{i}id@{ui} - identifier for chunk to declare (ex. "BODY").
  @{i}@{b}error@{ub}@{ui} - 0 if successful or an @{i}IFFERR_#?@{ui} error code if unsuccessful.
SEE ALSO
  @{"StopChunks()" Link "StopChunks()"} @{"ParseIFF()" Link "ParseIFF()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "StopChunks()" "iffparse.library/StopChunks"
@{b}@{u}StopChunks@{uu}@{ub} -- declare many stop chunks at once.(V36)
  (is to @{"StopChunk()" Link "StopChunk()"} as @{"PropChunks()" Link "PropChunks()"} is to PropChunk().)
SYNOPSIS  @{FG shine}long@{FG text} StopChunks(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, @{FG shine}long@{FG text} *, @{FG shine}long@{FG text});
  @{i}@{b}error@{ub}@{ui} = StopChunks(@{i}iff@{ui}, @{i}propArray@{ui}, @{i}numPairs@{ui});
   D0                 A0   A1          D0
  @{i}iff@{ui} - pointer to IFFHandle structure.
  @{i}propArray@{ui} - pointer to array of longword chunk types and identifiers.
  @{i}numPairs@{ui} - number of pairs in the array.
  @{i}@{b}error@{ub}@{ui} - 0 if successful or an @{i}IFFERR_#?@{ui} error code if unsuccessful.
SEE ALSO
  @{"StopChunk()" Link "StopChunk()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "StopOnExit()" "iffparse.library/StopOnExit"
@{b}@{u}StopOnExit@{uu}@{ub} -- declare a stop condition for exiting a chunk.(V36)
  Installs an exit handler for the specified chunk which will cause the
  @{"ParseIFF()" Link "ParseIFF()"} function to return control to the caller when this chunk
  is exhausted.@{"ParseIFF()" Link "ParseIFF()"} will return @{i}IFFERR_EOC@{ui} when the declared
  chunk is about to be popped.This is only of value when @{"ParseIFF()" Link "ParseIFF()"}
  is called with the @{i}IFFPARSE_SCAN@{ui} control code.
SYNOPSIS  @{FG shine}long@{FG text} StopOnExit(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, @{FG shine}long@{FG text}, @{FG shine}long@{FG text});
  @{i}@{b}error@{ub}@{ui} = StopOnExit(@{i}iff@{ui}, @{i}type@{ui}, @{i}id@{ui});
   D0                 A0   D0     D1
  @{i}iff@{ui} - pointer to IFFHandle structure (need not be open).
  @{i}type@{ui} - type code for chunk to declare (ex. "ILBM").
  @{i}id@{ui} - identifier for chunk to declare (ex. "BODY").
  @{i}@{b}error@{ub}@{ui} - 0 if successful or an @{i}IFFERR_#?@{ui} error code if unsuccessful.
SEE ALSO
  @{"ParseIFF()" Link "ParseIFF()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "StoreItemInContext()" "iffparse.library/StoreItemInContext"
@{b}@{u}StoreItemInContext@{uu}@{ub} -- store local context item in given context node.(V36)
  Adds the LocalContextItem to the list of items for the given context
  node.If an LCI with the same Type.ID, and Ident is already
  present in the ContextNode, it will be purged and replaced with the
  new one.This is a raw form of @{"StoreLocalItem()" Link "StoreLocalItem()"}.
SYNOPSIS
  @{FG shine}void@{FG text} StoreItemInContext(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, @{FG shine}struct@{FG text} @{"LocalContextItem" Link "include:libraries/iffparse.h/Main" 83} *,
    @{FG shine}struct@{FG text} @{"ContextNode" Link "include:libraries/iffparse.h/Main" 68} *);
  StoreItemInContext(@{i}iff@{ui}, @{i}localItem@{ui}, @{i}contextNode@{ui});
                      A0    A1         A2
  @{i}iff@{ui} - pointer to IFFHandle structure for this context.
  @{i}localItem@{ui} - pointer to a LocalContextItem to be stored.
  @{i}contextNode@{ui} - pointer to context node in which to store item.
SEE ALSO
  @{"StoreLocalItem()" Link "StoreLocalItem()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "StoreLocalItem()" "iffparse.library/StoreLocalItem"
@{b}@{u}StoreLocalItem@{uu}@{ub} -- insert a local context item into the context stack.(V36)
  Adds the local context item to the list of items for one of the
  context nodes on the context stack and purges any other item in the
  same context with the same ident, type and id.
  @{i}The position argument determines where in the stack to add the item@{ui}:
    @{b}IFFSLI_ROOT@{ub} - Add item to list at root (default) stack position.
    @{b}IFFSLI_TOP@{ub} - Add item to the top (current) context node.
    @{b}IFFSLI_PROP@{ub} - Add element in top property context.
      Top property context is either the top FORM chunk, or the top LIST chunk,
      whichever is closer to the top of the stack.
  Items added to the root context, or added to the top context before
  the IFFHandle has been opened or after it has been closed, are put in
  the default context.That is, they will be the local items found
  only after all other context nodes have been searched.Items in the
  default context are also immune to being purged until the IFFHandle
  structure itself is deleted with @{"FreeIFF()" Link "FreeIFF()"}.This means that handlers
  installed in the root context will still be there after an IFFHandle
  structure has been opened and closed.(Note that this implies that
  items stored in a higher context will be deleted when that context ends.)
SYNOPSIS
  @{FG shine}long@{FG text} StoreLocalItem(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, @{FG shine}struct@{FG text} @{"LocalContextItem" Link "include:libraries/iffparse.h/Main" 83} *, @{FG shine}long@{FG text});
  @{i}@{b}error@{ub}@{ui} = StoreLocalItem(@{i}iff@{ui}, @{i}localItem@{ui}, @{i}position@{ui});
   D0                     A0    A1         D0
  @{i}iff@{ui} - pointer to IFFHandle structure.
  @{i}localItem@{ui} - pointer to LocalContextItem structure to insert.
  @{i}position@{ui} - where to store the item (@{i}IFFSLI_ROOT@{ui}, @{i}_TOP@{ui} or @{i}_PROP@{ui}).
  @{i}@{b}error@{ub}@{ui} - 0 if successful or an @{i}IFFERR_#?@{ui} error code if unsuccessful.
SEE ALSO
  @{"FindLocalItem()" Link "FindLocalItem()"} @{"StoreItemInContext()" Link "StoreItemInContext()"} @{"EntryHandler()" Link "EntryHandler()"} @{"ExitHandler()" Link "ExitHandler()"}
  @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "WriteChunkBytes()" "iffparse.library/WriteChunkBytes"
@{b}@{u}WriteChunkBytes@{uu}@{ub} -- write data from a buffer into the current chunk.(V36)
  Writes "numBytes" bytes from the specified buffer into the current
  chunk.If the current chunk was pushed with @{i}IFFSIZE_UNKNOWN@{ui}, the size
  of the chunk gets increased by the size of the buffer written.If
  the size was specified for this chunk, attempts to write past the end
  of the chunk will be truncated.
SYNOPSIS  @{FG shine}long@{FG text} WriteChunkBytes(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, APTR, @{FG shine}long@{FG text});
  @{i}@{b}error@{ub}@{ui} = WriteChunkBytes(@{i}iff@{ui}, @{i}buf@{ui}, @{i}numBytes@{ui});
   D0                      A0   A1    D0
  @{i}iff@{ui} - pointer to IFFHandle structure.
  @{i}buf@{ui} - pointer to buffer area with bytes to be written.
  @{i}numBytes@{ui} - number of bytes to write.
  @{i}@{b}error@{ub}@{ui} - (positive) number of bytes written if successful or a
    (negative) @{i}IFFERR_#?@{ui} error code if unsuccessful.
SEE ALSO
  @{"PushChunk()" Link "PushChunk()"} @{"PopChunk()" Link "PopChunk()"} @{"WriteChunkRecords()" Link "WriteChunkRecords()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "WriteChunkRecords()" "iffparse.library/WriteChunkRecords"
@{b}@{u}WriteChunkRecords@{uu}@{ub} -- write records from a buffer to the current chunk.(V36)
  Writes record elements from the buffer into the top chunk.This
  function operates much like @{"ReadChunkBytes()" Link "ReadChunkBytes()"}.
SYNOPSIS  @{FG shine}long@{FG text} WriteChunkRecords(@{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *, APTR, @{FG shine}long@{FG text}, @{FG shine}long@{FG text});
  @{i}@{b}error@{ub}@{ui} = WriteChunkRecords(@{i}iff@{ui}, @{i}buf@{ui}, @{i}recsize@{ui}, @{i}numrec@{ui});
   D0                        A0   A1    D0       D1
  @{i}iff@{ui} - pointer to IFFHandle structure.
  @{i}buf@{ui} - pointer to buffer area containing data.
  @{i}recsize@{ui} - size of data records to write.
  @{i}numrec@{ui} - number of data records to write.
  @{i}@{b}error@{ub}@{ui} - (positive) number of whole records written if successful
    or a (negative) @{i}IFFERR_#?@{ui} error code if unsuccessful.
SEE ALSO
  @{"WriteChunkBytes()" Link "WriteChunkBytes()"} @{"<libraries/iffparse.h>" Link "include:libraries/iffparse.h/Main" 0}
@EndNode
@Node "NV_--background--" "nonvolatile.library/--background--"
PURPOSE
  The nonvolatile library provides a simple means for an application
  developer to manage nonvolatile storage.
OVERVIEW
  The nonvolatile library is meant to be used transparently across all
  configurations.Currently, nonvolatile storage may consist of NVRAM
  and/or disk devices.nonvolatile.library will automatically access
  the best nonvolatile storage available in the system.Disk based
  storage will be selected first and if not available, NVRAM storage
  will be accessed.
* @{b}NVRAM@{ub}
  On low-end diskless Amiga platforms, NVRAM may be available.This
  RAM will maintain its data contents when the system is powered down.
  This is regardless of whether batteries or battery-backed clock are
  present.The data stored in NVRAM is accessible only through the
  ROM-based nonvolatile library funtion calls.The size of NVRAM storage
  is dependant on the system platform and is attainable through the
  @{"GetNVInfo()" Link "GetNVInfo()"} function.
* @{b}Disk@{ub}
  In keep with the general configurability of the Amiga, the actual
  disk location used by nonvolatile library when storing to disk
  may be changed by the user.
  The prefs directory is used on the Amiga for storing many user
  configurable options.The location for nonvolatile disk storage is
  contained in the file @{i}prefs/env-archive/sys/nv_location@{ui}.This file
  should contain a data string that specifies a lockable location.
  If the string does not specify a lockable location, the file will
  be ignored.
  When opened, the nonvolatile library will search all drives within
  the system until it finds this file and successfully accomplishes
  a Lock on the location specified in the file.To force a rescan of
  all drives, the library may be closed and reopened or execute the
  @{"GetNVInfo()" Link "GetNVInfo()"} function.
  @{b}@{u}A simple method for creating a floppy disk for saving nonvolatile@{uu}@{ub}
  @{b}@{u}data is the following@{uu}@{ub}:
  - Format a disk with the volume name @{b}NV@{ub}
  - Create a file @{b}prefs/env-archive/sys/nv_location@{ub} on this disk with
    the following contents: @{b}NV:nonvolatile@{ub}
  - Create a directory @{i}nonvolatile@{ui}
  @{b}@{u}The following is a script file that can be used to make a floppy@{uu}@{ub}
  @{b}@{u}for use with nonvolatile library@{uu}@{ub}:
    .KEY DRIVE/A,DISK
    .BRA {
    .KET }
    @{FG shine}format@{FG text} Drive {DRIVE} Name {DISK$NV} noicons ffs
    @{FG shine}makedir@{FG text} {DRIVE}@{i}prefs@{ui}
    @{FG shine}makedir@{FG text} {DRIVE}@{i}nonvolatile@{ui}
    @{FG shine}makedir@{FG text} {DRIVE}prefs/@{i}env-archive@{ui}
    @{FG shine}makedir@{FG text} {DRIVE}prefs/env-archive/@{i}sys@{ui}
    @{FG shine}echo@{FG text} @{i}{DISK$NV}:nonvolatile@{ui} >{DRIVE}prefs/env-archive/sys/@{i}nv_location@{ui}
@{b}!!!NOTE!!!@{ub}
  Because NVRAM performs disk access, you must open and use its
  functionality from a DOS process, not an EXEC task.Normally
  your CDGS application is invoked as a DOS process so this
  requirement generally should cause you no concern.You just
  need to be aware of this requirement should you create an
  EXEC task and try to invoke nonvolatile.library from that task.
@EndNode
@Node "DeleteNV()" "nonvolatile.library/DeleteNV"
@{b}@{u}DeleteNV@{uu}@{ub} -- remove an entry from nonvoltatile storage.@{b}(V40)@{ub}
  Searches the nonvolatile storage for the indicated entry and removes it.
  The strings appName and itemName may not contain the '/' or ':'
  characters.It is recommended that these characters be blocked
  from user input when requesting AppName and ItemName strings.
SYNOPSIS  BOOL DeleteNV(STRPTR, STRPTR, BOOL);
  @{i}@{b}success@{ub}@{ui} = DeleteNV(@{i}appName@{ui}, @{i}itemName@{ui}, @{i}killRequesters@{ui});
   D0                 A0       A1         D1
  @{i}appName@{ui} - NULL terminated string identifing the application that
    created the data.Maximum length is 31.
  @{i}ItemName@{ui} - NULL terminated string uniquely identifing the data
     within the application.Maximum length is 31.
  @{i}killRequesters@{ui} - suppress system requesters flag.
    TRUE if all system requesters are to be suppressed during this function.
    FALSE if system requesters are allowed.
  @{i}@{b}success@{ub}@{ui} - TRUE will be returned if the entry is found and deleted.
      If the entry is not found, FALSE will be returned.
@EndNode
@Node "FreeNVData()" "nonvolatile.library/FreeNVData"
@{b}@{u}FreeNVData@{uu}@{ub} -- release the memory allocated by a function of this library.@{b}(V40)@{ub}
  Frees a block of memory that was allocated by any of the following:
  @{"GetCopyNV()" Link "GetCopyNV()"}, @{"GetNVInfo()" Link "GetNVInfo()"}, @{"GetNVList()" Link "GetNVList()"}.
SYNOPSIS  @{FG shine}void@{FG text} FreeNVData(APTR);
  FreeNVData(@{i}data@{ui});
              A0
  @{i}data@{ui} - pointer to the memory block to be freed.
    If passed NULL, this function does nothing.
SEE ALSO
  @{"GetCopyNV()" Link "GetCopyNV()"}, @{"GetNVInfo()" Link "GetNVInfo()"}, @{"GetNVList()" Link "GetNVList()"}
@EndNode
@Node "GetCopyNV()" "nonvolatile.library/GetCopyNV"
@{b}@{u}GetCopyNV@{uu}@{ub} -- return a copy of an item stored in nonvolatile storage.@{b}(V40)@{ub}
  Searches the nonvolatile storage for the indicated appName and
  itemName.A pointer to a copy of this data will be returned.
  The strings appName and itemName may not contain the '/' or ':'
  characters.It is recommended that these characters be blocked
  from user input when requesting appName and itemName strings.
SYNOPSIS  APTR GetCopyNV(STRPTR, STRPTR, BOOL);
  @{i}@{b}data@{ub}@{ui} = GetCopyNV(@{i}appName@{ui}, @{i}itemName@{ui}, @{i}killRequesters@{ui});
   D0               A0        A1        D1
  @{i}appName@{ui} - NULL terminated string indicating the application name
    to be found.Maximum length is 31.
  @{i}itemName@{ui} - NULL terminated string indicated the item within the
     application to be found.Maximum length is 31.
  @{i}killRequesters@{ui} - Suppress system requesters flag.
    TRUE if all system requesters are to be suppressed during this function.
    FALSE if system requesters are allowed.
  @{i}@{b}data@{ub}@{ui} - pointer to a copy of the data found in the nonvolatile storage
   assocated with appName and itemName.NULL will be returned if there
   is insufficient memory or the appName/itemName does not exist.
SEE ALSO
  @{"FreeNVData()" Link "FreeNVData()"}, <libraries/nonvolatile.h>
@EndNode
@Node "GetNVInfo()" "nonvolatile.library/GetNVInfo"
@{b}@{u}GetNVInfo@{uu}@{ub} -- report information on the current nonvolatile storage.@{b}(V40)@{ub}
  Finds the user's preferred nonvolatile device and reports information about it.
SYNOPSIS  @{FG shine}struct@{FG text} @{"NVInfo" Link "include:libraries/nonvolatile.h/Main" 29} *GetNVInfo(BOOL);
  @{i}@{b}information@{ub}@{ui} = GetNVInfo(@{i}killRequesters@{ui});
   D0                      D1
  @{i}killRequesters@{ui} - suppress system requesters flag.
    TRUE if all system requesters are to be suppressed during this function.
    FALSE if system requesters are allowed.
  @{i}@{b}information@{ub}@{ui} - pointer to an NVInfo structure.
    This structure contains information on the NV storage media with the
    largest storage.@{b}@{u}The structure contains 2 longword fields@{uu}@{ub}:
    @{b}nvi_MaxStorage@{ub} and @{b}nvi_FreeStorage@{ub}.
    Both values are rounded down to the nearest ten.
    The @{b}nvi_MaxStorage@{ub} field is defined as the total amount of nonvolatile
    storage available on this device.
    The @{b}nvi_FreeStorage@{ub} is defined as the amount of available space for
    NVDISK or the amount of non-locked storage for NVRAM.For NVDISK,
    the @{i}nvi_FreeStorage@{ui} takes into account the amount of overhead room
    required to store a new App/Item.This amount is 3 blocks to allow
    room for storing a new Item file and possibly a new App directory.
    For NVRAM, the amount of overhead is 5 bytes.However, the amount of
    room required to store a new NVRAM item depends on the length of
    the App and Item names.Refer to @{"StoreNV()" Link "StoreNV()"} function for storage details.
    This function may return NULL in the case of failure.
SEE ALSO
  @{"FreeNVData()" Link "FreeNVData()"}, @{"StoreNV()" Link "StoreNV()"}, <libraries/nonvolatile.h>
@EndNode
@Node "GetNVList()" "nonvolatile.library/GetNVList"
@{b}@{u}GetNVList@{uu}@{ub} -- return a list of the items stored in nonvolatile storage.@{b}(V40)@{ub}
  Returns a pointer to an Exec list of nonvolatile Items associated
  with the appName requested.
  The string appName may not contain the '/' or ':' characters.
  It is recommended that these characters be blocked from user input
  when requesting an appName string.
SYNOPSIS  @{FG shine}struct@{FG text} @{"MinList" Link "include:exec/lists.h/Main" 32} *GetNVList(STRPTR, BOOL);
  @{i}@{b}list@{ub}@{ui} = GetNVList(@{i}appName@{ui}, @{i}killRequesters@{ui});
   D0               A0       D1
  @{i}appName@{ui} - NULL terminated string indicating the application name to be matched.
    Maximum length is 31.
  @{i}killRequesters@{ui} - Suppress system requesters flag.
    TRUE if all system requesters are to be suppressed during this function.
    FALSE if system requesters are allowed.
  @{i}@{b}list@{ub}@{ui} - a pointer to an Exec MinList of NVEntries.
    A NULL will be returned if there is insufficient memory.
    If there are no entries in the nonvolatile storage for
    the AppName, an empty list will be returned.
NOTE
  The protection field contains more bits than are required for
  storing the delete protection status.These bits are reserved
  for other system usage and may not be zero.When checking for
  the delete status use either the field mask @{i}NVIF_DELETE@{ui}, or the
  bit definition @{i}NVIB_DELETE@{ui}.
SEE ALSO
  @{"FreeNVData()" Link "FreeNVData()"}, @{"SetNVProtection()" Link "SetNVProtection()"}
@EndNode
@Node "SetNVProtection()" "nonvolatile.library/SetNVProtection"
@{b}@{u}SetNVProtection@{uu}@{ub} -- set the protection flags.@{b}(V40)@{ub}
  Sets the protection attributes for an item currently in the
  nonvolatile storage.
  Although 'mask' is long only the delete bit, @{i}NVEF_DELETE@{ui}/@{i}NVEB_DELETE@{ui},
  may be set.If any other bits are set this function will return FALSE.
  The strings appName and itemName may not contain the '/' or ':'
  characters.It is recommended that these characters be blocked
  from user input when requesting AppName and ItemName strings.
SYNOPSIS  BOOL SetNVProtection(STRPTR, STRPTR, @{FG shine}long@{FG text}, BOOL);
  @{i}@{b}success@{ub}@{ui} = SetNVProtection(@{i}appName@{ui}, @{i}itemName@{ui}, @{i}mask@{ui}, @{i}killRequesters@{ui});
   D0                        A0        A1        D2    D1
  @{i}appName@{ui} - NULL terminated string indicating the application name to be matched.
    Maximum length is 31.
  @{i}itemName@{ui} - NULL terminated string indicated the item within the
    application to be found.Maximum length is 31.
  @{i}mask@{ui} - the new protection mask.
    Only set the delete bit otherwise this function @{b}WILL CRASH@{ub}.
  @{i}killRequesters@{ui} - suppress system requesters flag.
    TRUE if all system requesters are to be suppressed during this function.
    FALSE if system requesters are allowed.
  @{i}@{b}success@{ub}@{ui} - FALSE if the protection could not be change
    (ie the data does not exist).
SEE ALSO
  @{"GetNVList()" Link "GetNVList()"}, <libraries/nonvolatile.h>
@EndNode
@Node "StoreNV()" "nonvolatile.library/StoreNV"
@{b}@{u}StoreNV@{uu}@{ub} -- store data in nonvolatile storage.@{b}(V40)@{ub}
  Saves some data in nonvolatile storage.The data is tagged with
  AppName and ItemName so it can be retrieved later.No single
  item should be larger than one fourth of the maximum storage as
  returned by @{"GetNVInfo()" Link "GetNVInfo()"}.
  There is no data compression associated with this function.
  The strings, AppName and ItemName, should be short, but descriptive.
  They need to be short since the string is stored with the data and
  the nonvolatile storage for a stand alone game system is limited.
  The game system allows the user to selectively remove entries from
  storage, so the string should be desriptive.
  The strings AppName and ItemName may not contain the '/' or ':'
  characters.It is recommended that these characters be blocked
  from user input when requesting AppName and ItemName strings.
SYNOPSIS  UWORD StoreNV(STRPTR, STRPTR, APTR, ULONG, BOOL);
  @{i}@{b}error@{ub}@{ui} = StoreNV(@{i}appName@{ui}, @{i}itemName@{ui}, @{i}data@{ui}, @{i}length@{ui}, @{i}killRequesters@{ui});
   D0              A0        A1        A2    D0      D1
  @{i}appName@{ui} - NULL terminated string identifying the application
    creating the data.Maximum length is 31.
  @{i}itemName@{ui} - NULL terminated string uniquely identifying the data
    within the application.Maximum length is 31.
  @{i}data@{ui} - pointer to the memory block to be stored.
  @{i}length@{ui} - number of bytes to be stored in the units of tens of bytes.
    For example, if you have 23 bytes to store length = 3;
    147 byte then length = 15.
  @{i}killRequesters@{ui} - suppress system requesters flag.
    TRUE if all system requesters are to be suppressed during this function.
    FALSE if system requesters are allowed.
  @{i}@{b}error@{ub}@{ui} - 0                means no error,
          NVERR_BADNAME    error in AppName, or ItemName.
          NVERR_WRITEPROT  Nonvolatile storage is read only.
          NVERR_FAIL       Failure in writing data
                           (nonvolatile storage full, or write protected).
          NVERR_FATAL      Fatal error when accessing nonvolatile storage,
                           possible loss of previously saved nonvolatile data.
SEE ALSO
  @{"GetCopyNV()" Link "GetCopyNV()"}, @{"GetNVInfo()" Link "GetNVInfo()"}
@EndNode
@Node "AddKBInt()" "lowlevel.library/AddKBInt"
@{b}@{u}AddKBInt@{uu}@{ub} -- adds a routine to the keyboard interrupt.@{b}(V40)@{ub}
  This routine extends the functionality of the keyboard interrupt to
  include intRoutine.Since this is an extention of the normal
  keyboard interrupt all of the keyboard handshaking is handled.The
  keyboard error codes are filtered out and not passed to intRoutine.
  The routine is called whenever the user enters a key on the keyboard.
  The routine is called from within an interrupt, so normal
  restrictions apply.The routine must preserve the following
  registers: A2, A3, A4, A7, D2-D7.Other registers are
  scratch, except for D0, which @{b}MUST BE SET@{ub} TO 0 upon exit.
  On entry to the routine, A1 holds 'intData' and A5 holds 'intRoutine',
  and D0 contains the rawkey code read from the keyboard.
  The routine is not called when a reset is received from the keyboard.
  This is a low level function that does not fit the normal Amiga
  multitasking model.The interrupt installed will have no knowledge
  of which window/screen currently has input focus.
  If your program is to exit without reboot, you @{b}MUST@{ub} call @{"RemKBInt()" Link "RemKBInt()"}
  before exiting.
  Only one interrupt routine may be added to the system.@{b}ALWAYS@{ub}
  check the return value in case some other task has previously
  used this function.
SYNOPSIS  APTR AddKBInt(APTR, APTR);
  @{i}@{b}intHandle@{ub}@{ui} = AddKBInt(@{i}intRoutine@{ui}, @{i}intData@{ui});
   D0                   A0           A1
  @{i}intRoutine@{ui} - the routine to invoke every vblank.This routine should be
    as short as possible to minimize its effect on overall system performance.
  @{i}intData@{ui} - data passed to the routine in register A1.
    If more than one long word of data is required this should be
    a pointer to a structure that contains the required data.
  @{i}@{b}intHandle@{ub}@{ui} - a handle used to manipulate the interrupt,
    or NULL if it was not possible to attach the routine.
SEE ALSO
  @{"RemKBInt()" Link "RemKBInt()"}
@EndNode
@Node "AddTimerInt()" "lowlevel.library/AddTimerInt"
@{b}@{u}AddTimerInt@{uu}@{ub} -- adds an interrupt that is executed at regular intervals.@{b}(V40)@{ub}
  Calling this routine causes the system to allocate a @{"CIA" Link "include:hardware/cia.h/Main" 29} timer
  and set up 'intRoutine' to service any interrupts caused by the timer.
  Although the timer is allocated it is neither running, nor enabled.
  StartIntTimer() must be called to establish the time interval and
  start the timer.
  The routine is called from within an interrupt, so normal
  restrictions apply.The routine must preserve the following
  registers: A2, A3, A4, A7, D2-D7.Other registers are scratch,
  except for D0, which @{b}MUST BE SET@{ub} TO 0 uponexit.On entry to
  the routine, A1 holds 'intData' and A5 holds 'intRoutine'.
  Only a single CIA timer will be allocated by this routine.So this
  routine may only be called once without an intervening call to
  @{"RemTimerInt()" Link "RemTimerInt()"}.
  The CIA timer used by this routine is not guaranteed to always be
  the same.This routine utilizes the CIA resource and uses an
  unallocated CIA timer.
  If your program is to exit without reboot, you @{b}MUST@{ub} match all
  calls to this function with calls to @{"RemTimerInt()" Link "RemTimerInt()"} before exiting.
  Even if you only use the function once in your program; checking
  the return value will make your program more tolerant for
  mulititasking on the Amiga computer platforms.
SYNOPSIS  APTR AddTimerInt(APTR, APTR);
  @{i}@{b}intHandle@{ub}@{ui} = AddTimerInt(@{i}intRoutine@{ui}, @{i}intData@{ui});
   D0                      A0           A1
  @{i}intRoutine@{ui} - the routine to invoke upon timer interrupts.
    This routine should be as short as possible to minimize
    its effect on overall system performance.
  @{i}intData@{ui} - data passed to the routine in register A1.
    If more than one long word of data is required this should be
    a pointer to a structure that contains the required data.
  @{i}@{b}intHandle@{ub}@{ui} - a handle used to manipulate the interrupt,
    or NULL if it was not possible to attach the routine.
SEE ALSO
  @{"RemTimerInt()" Link "RemTimerInt()"}, @{"StopTimerInt()" Link "StopTimerInt()"}, @{"StartTimerInt()" Link "StartTimerInt()"}
@EndNode
@Node "AddVBlankInt()" "lowlevel.library/AddVBlankInt"
@{b}@{u}AddVBlankInt@{uu}@{ub} -- adds a routine executed every vertical blank.@{b}(V40)@{ub}
  Lets you attach a routine to the system which will get called
  everytime a vertical blanking interrupt occurs.
  The routine is called from within an interrupt, so normal
  restrictions apply.The routine must preserve the following
  registers: A2, A3, A4, A7, D2-D7.Other registers are scratch,
  except for D0, which @{b}MUST BE SET@{ub} TO 0 upon exit.
  On entry to the routine, A1 holds 'intData' and A5 holds 'intRoutine'.
  If your program is to exit without reboot, you @{b}MUST@{ub} call
  @{"RemVBlankInt()" Link "RemVBlankInt()"} before exiting.
  Only one interrupt routine may be added to the system.@{b}ALWAYS@{ub} check
  the return value in case some other task has previously used this function.
SYNOPSIS  APTR AddVBlankInt(APTR, APTR);
  @{i}@{b}intHandle@{ub}@{ui} = AddVBlankInt(@{i}intRoutine@{ui}, @{i}intData@{ui});
   D0                       a0           a1
  @{i}intRoutine@{ui} - the routine to invoke every vblank.
    This routine should be as short as possible to minimize
    its effect on overall system performance.
  @{i}intData@{ui} - data passed to the routine in register A1.
    If more than one long word of data is required this should be
    a pointer to a structure that contains the required data.
  @{i}@{b}intHandle@{ub}@{ui} - a handle used to manipulate the interrupt,
    or NULL if it was not possible to attach the routine.
SEE ALSO
  @{"RemVBlankInt()" Link "RemVBlankInt()"}
@EndNode
@Node "ElapsedTime()" "lowlevel.library/ElapsedTime"
@{b}@{u}ElapsedTime@{uu}@{ub} -- returns the time elapsed since it was last called.@{b}(V40)@{ub}
  This function utilizes the @{"timer.device/ReadEClock()" Link "devices.guide/ReadEClock()"} function to get
  an accurate elapsed time value.Since the context needs to be established
  the first call to this routine will return a nonsense value.
  The return value for this function only allows for sixteen bits worth
  for the integer number of seconds and sixteen bits for the fractional
  number of seconds.
  With sixteen bits worth of integer seconds this function can be used
  to timer an interval up to about 16 hours.If the actual time interval
  is larger this function will return this maximum value.
  The sixteen bits for fractional seconds gives a resolution of approximately
  20 microseconds.However, it is not recomended to expect this function
  to be accurate for a time interval of less than 200 microseconds.
SYNOPSIS  ULONG ElapsedTime(@{FG shine}struct@{FG text} @{"EClockVal" Link "include:devices/timer.h/Main" 31} *);
  @{i}@{b}fractionalSeconds@{ub}@{ui} = ElapsedTime(@{i}context@{ui});
   D0                              A0
  @{i}context@{ui} - pointer to an EClockVal structure.
    The first time you call this function, you should initialize the structure
    to 0s.You should then reuse the same structure for subsequent calls to this
    function, as this is how the elapsed time is calculated.
  @{i}@{b}fractionalSeconds@{ub}@{ui} - The elapsed time as a fixed point 32-bit number with the
    point fixed in the middle.That is, the upper order sixteen bits represent
    the number of seconds elapsed.The low order sixteen bit represent the
    fractional number of seconds elapsed.This value is limited to about
    sixteen hours.Although this value is precise to nearly 20 microseconds
    it is only accurate to within 200 microseconds.
@{b}WARNING@{ub}
  The first call to this function will return a non-sense value.Only
  rely on its result starting with the second call.
SEE ALSO
  @{"timer.device/ReadEClock()" Link "devices.guide/ReadEClock()"}
@EndNode
@Node "GetKey()" "lowlevel.library/GetKey"
@{b}@{u}GetKey@{uu}@{ub} -- returns the currently pressed rawkey code and qualifiers.@{b}(V40)@{ub}
  This function returns the currently pressed non-qualifier key and
  all pressed qualifiers.This function is safe within an interrupt.
  This is a low level function that does not fit the normal Amiga
  multitasking model.The values returned by this function are
  not modified by which window/screen currently has input focus.
SYNOPSIS  ULONG GetKey(@{FG shine}void@{FG text});
  @{i}@{b}key@{ub}@{ui} = GetKey();
   D0
  @{i}@{b}key@{ub}@{ui} - key code for the last non-qualifier key pressed in the low order word.
    If no key is pressed this word will be FF.The upper order word contains
    the qualifiers which can be found within the long word as follows:
      @{b}Qualifier@{ub}      @{b}Key@{ub}
      LLKB_LSHIFT    Left Shift
      LLKB_RSHIFT    Rigt Shift
      LLKB_CAPSLOCK  Caps Lock
      LLKB_CONTROL   Control
      LLKB_LALT      Left Alt
      LLKB_RALT      Right Alt
      LLKB_LAMIGA    Left Amiga
      LLKB_RAMIGA    Right Amiga
SEE ALSO
  <libraries/lowlevel.h>
@EndNode
@Node "GetLanguageSelection()" "lowlevel.library/GetLanguageSelection"
@{b}@{u}GetLanguageSelection@{uu}@{ub} -- returns the current language selection.@{b}(V40)@{ub}
  Determine what the user has specified as a language.
SYNOPSIS  ULONG GetLanguageSelection (@{FG shine}void@{FG text});
  @{i}@{b}language@{ub}@{ui} = GetLanguageSelection();
   D0
  @{i}@{b}language@{ub}@{ui} - user specified language, or zero if none has yet been specified.
    See <libraries/lowlevel.h> for a definition
    of the currently supported language.
SEE ALSO
  <libraries/lowlevel.h>, locale.doc
@EndNode
@Node "QueryKeys()" "lowlevel.library/QueryKeys"
@{b}@{u}QueryKeys@{uu}@{ub} -- return the states for a set of keys.@{b}(V40)@{ub}
  Scans the keyboard to determine which of the rawkey codes
  listed in the QueryArray are currently pressed.The state for each
  key is returned in the array.
  This function may be invoked from within an interrupt, but the size
  of QueryArray should be kept as small as possible.
  This is a low level function that does not fit the normal Amiga
  multitasking model.The values returned have no knowledge
  of which window/screen currently has input focus.
SYNOPSIS  @{FG shine}void@{FG text} QueryKeys(@{FG shine}struct@{FG text} @{"KeyQuery" Link "include:libraries/lowlevel.h/Main" 30} *, UBYTE);
  QueryKeys(@{i}queryArray@{ui}, @{i}arraySize@{ui});
             A0          D1
  @{i}queryArray@{ui} - an array of KeyQuery structures.
    The kq_KeyCode fields of these structures should be
    filled with the rawkey codes you wish to query about.
    Upon return from this function, the kq_Pressed field
    of these structures will be set to TRUE if the
    associated key is down, and FALSE if not.
  @{i}arraySize@{ui} - number of key code entries in queryArray
SEE ALSO
  <libraries/lowlevel.h>
@EndNode
@Node "ReadJoyPort()" "lowlevel.library/ReadJoyPort"
@{b}@{u}ReadJoyPort@{uu}@{ub} -- return the state of the selected joy/mouse port.@{b}(V40)@{ub}
  This function is used to determine what device is attached to the
  joy port and the current position/button state.The user may attach
  a mouse, game controller, or joystick to the port and this function
  will dynamically detect which device is attached and return the
  appropriatly formatted portState.
  To determine the type of controller that is attached, this function
  clocks the game controller and/or interprets changes in the joy
  port data.Valid clocked data from the game controller is immediately
  detected.However, to accuratly determine if a mouse or joystick is
  attached, several calls to this function are required along with some
  movement at the joy port by the user.
  This function always executes immediatly.
  This is a low level single threaded function that does not fit the
  normal Amiga multitasking model.Only one task can be executing
  this routine at any time.All others will return immediately with
  @{i}JP_TYPE_NOTAVAIL@{ui}.
  The nature of this routine is not meant to encourage non-multitasking
  friendly programming practices like polling loops.If your task
  is waiting for a transition to be returned use a @{"WaitTOF()" Link "graphics.guide/WaitTOF()"} between
  calls to minimize the total system impact.
  When called the first time, for each port, this function attempts to
  acquire certain system resources.In order to aquire these resources
  this function @{b}MUST@{ub} be called from a task, or a DOS process.If this
  function fails to aquire the necessary resources, it will
  return with @{i}JP_TYPE_NOTAVAIL@{ui}.Once the resources are aquired (return
  value other than @{i}JP_TYPE_NOTAVAIL@{ui}) this function may be used in interrupts.
SYNOPSIS  ULONG ReadJoyPort(ULONG);
  @{i}@{b}portState@{ub}@{ui} = ReadJoyPort(@{i}portNumber@{ui});
   D0                      D0
  @{i}portNumber@{ui} - port to read, in the range 0 to 3.
  @{i}@{b}portState@{ub}@{ui} - bit map that identifies the device and the current
    state of that device.The format of the bit map is
    dependant on the type of device attached.
    The following constants from <libraries/lowlevel.h> are used to
    determine which device is attached and the state of that device.
    The type of device can be determined by applying
    the mask @{b}@{i}JP_TYPE_MASK@{ui}@{ub} to the return value and comparing
    the resultant value with the following:
      @{b}JP_TYPE_NOTAVAIL@{ub}  port data unavailable
      @{b}JP_TYPE_GAMECTLR@{ub}  game controller
      @{b}JP_TYPE_JOYSTK@{ub}    joystick
      @{b}JP_TYPE_MOUSE@{ub}     mouse
      @{b}JP_TYPE_UNKNOWN@{ub}   unknown device
    If @{i}type@{ui} = @{b}JP_TYPE_GAMECTLR@{ub} the bit map of portState is:
      @{i}JPF_BUTTON_BLUE@{ui}     Blue - Stop
      @{i}JPF_BUTTON_RED@{ui}      Red - Select
      @{i}JPF_BUTTON_YELLOW@{ui}   Yellow - Repeat
      @{i}JPF_BUTTON_GREEN@{ui}    Green - Shuffle
      @{i}JPF_BUTTON_FORWARD@{ui}  Charcoal - Forward
      @{i}JPF_BUTTON_REVERSE@{ui}  Charcoal - Reverse
      @{i}JPF_BUTTON_PLAY@{ui}     Grey - Play/Pause
      @{i}JPF_JOY_UP@{ui}          Up
      @{i}JPF_JOY_DOWN@{ui}        Down
      @{i}JPF_JOY_LEFT@{ui}        Left
      @{i}JPF_JOY_RIGHT@{ui}       Right
    If @{i}type@{ui} = @{b}JP_TYPE_JOYSTK@{ub} the bit map of portState is:
      @{i}JPF_BUTTON_BLUE@{ui}  Right
      @{i}JPF_BUTTON_RED@{ui}   Fire
      @{i}JPF_JOY_UP@{ui}       Up
      @{i}JPF_JOY_DOWN@{ui}     Down
      @{i}JPF_JOY_LEFT@{ui}     Left
      @{i}JPF_JOY_RIGHT@{ui}    Right
    If @{i}type@{ui} = @{b}JP_TYPE_MOUSE@{ub} the bit map of portState is:
      @{i}JPF_BUTTON_BLUE@{ui}  Right mouse
      @{i}JPF_BUTTON_RED@{ui}   Left mouse
      @{i}JPF_BUTTON_PLAY@{ui}  Middle mouse
      @{i}JP_MVERT_MASK@{ui}    Mask for vertical counter
      @{i}JP_MHORZ_MASK@{ui}    Mask for horizontal counter
SEE ALSO
  SetJoyPortAttrs()
@EndNode
@Node "RemKBInt()" "lowlevel.library/RemKBInt"
@{b}@{u}RemKBInt@{uu}@{ub} -- remove a previously installed keyboard interrupt.@{b}(V40)@{ub}
  Remove a keyboard interrupt routine previously added with @{"AddKBInt()" Link "AddKBInt()"}.
SYNOPSIS  @{FG shine}void@{FG text} RemKBInt(APTR);
  RemKBInt(@{i}intHandle@{ui});
            A1
  @{i}intHandle@{ui} - handle obtained from @{"AddKBInt()" Link "AddKBInt()"}.
    This may be NULL, in which case this function does nothing.
SEE ALSO
  @{"AddKBInt()" Link "AddKBInt()"}
@EndNode
@Node "RemTimerInt()" "lowlevel.library/RemTimerInt"
@{b}@{u}RemTimerInt@{uu}@{ub} -- remove a previously installed timer interrupt.@{b}(V40)@{ub}
  Removes a timer interrupt routine previously installed with AddTimerInt.
SYNOPSIS  @{FG shine}void@{FG text} RemTimerInt(APTR);
  RemTimerInt(@{i}intHandle@{ui});
               A1
  @{i}intHandle@{ui} - handle obtained from @{"AddTimerInt()" Link "AddTimerInt()"}.
    This may be NULL, in which case this function does nothing.
SEE ALSO
  @{"AddTimerInt()" Link "AddTimerInt()"}, @{"StopTimerInt()" Link "StopTimerInt()"}, @{"StartTimerInt()" Link "StartTimerInt()"}
@EndNode
@Node "RemVBlankInt()" "lowlevel.library/RemVBlankInt"
@{b}@{u}RemVBlankInt@{uu}@{ub} -- remove a previously installed vertical blank routine.@{b}(V40)@{ub}
  Removes a vertical blank interrupt routine previously added with
  @{"AddVBlankInt()" Link "AddVBlankInt()"}.
SYNOPSIS  @{FG shine}void@{FG text} RemVBlankInt(APTR);
  RemVBlankInt(@{i}intHandle@{ui});
                A1
  @{i}intHandle@{ui} - handle obtained from @{"AddVBlankInt()" Link "AddVBlankInt()"}.
    This may be NULL, in which case this function does nothing.
SEE ALSO
  @{"AddVBlankInt()" Link "AddVBlankInt()"}
@EndNode
@Node "SetJoyPortAttrsA()" "lowlevel.library/SetJoyPortAttrsA"
@{b}@{u}SetJoyPortAttrsA@{uu}@{ub} -- change the attributes of a port.@{b}(V40.27)@{ub}
@{b}@{u}SetJoyPortAttrs@{uu}@{ub}  -- varargs stub for SetJoyPortAttrsA().@{b}(V40.27)@{ub}
  This function allows modification of several attributes held by
  @{"ReadJoyPort()" Link "ReadJoyPort()"} about both it's operation and the type of controller
  currently plugged into the port.
  ReadJoyPort()'s default behavior is to attempt to automatically
  sense the type of controller plugged into any given port, when
  asked to read that port.This behavior is beneficial, to allow
  simple detection of the type of controller plugged into the port.
  Unfortunately, rare cases are possible where extremely fine
  mouse movements appear to be real joystick movements.Also, this
  ability to auto-sense the controller type causes most reads to
  take longer than if there were no auto-sensing.
  SetJoyPortAttrs() is intended to provide for both of these cases.
  It allows the programmer to notify @{"ReadJoyPort()" Link "ReadJoyPort()"} to stop spending
  time attempting to sense which type of controller is in use -- and,
  optionally, to force @{"ReadJoyPort()" Link "ReadJoyPort()"} into utilizing a certain controller type.
SYNOPSIS
  BOOL SetJoyPortAttrsA(ULONG, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  BOOL SetJoyPortAttrs (Tag, ...);
  @{i}@{b}success@{ub}@{ui} = SetJoyPortAttrsA(@{i}portNumber@{ui}, @{i}tagList@{ui});
   D0                         D0           A1
  @{i}@{b}Success@{ub}@{ui} = SetJoyPortAttrs (@{i}portNumber@{ui}, @{i}firstTag@{ui}, ...);
  @{i}portNumber@{ui} - the joyport in question (0-3).
  @{i}tagList@{ui} - a pointer to an array of tags providing parameters to
    SetJoyPortAttrs(); if NULL, the function will return TRUE, but do nothing.
@{"TAGS" link SETJOYPORTATTRSA_TAGS}
  success - TRUE if everything went according to plan, or FALSE upon failure
SEE ALSO
  @{"ReadJoyPort()" Link "ReadJoyPort()"}, <libraries/lowlevel.h>
@EndNode
@node SETJOYPORTATTRSA_TAGS "SetJoyPortAttrsA_tags"
@{b}SJA_Type@{ub} (ULONG) - Sets the current controller type to the mouse,
  joystick, or game controller.Supply one of
  @{i}SJA_TYPE_GAMECTLR@{ui}, @{i}SJA_TYPE_MOUSE@{ui}, @{i}SJA_TYPE_JOYSTK@{ui},
  or @{i}SJA_TYPE_AUTOSENSE@{ui}.If @{i}SJA_TYPE_AUTOSENSE@{ui} is used,
  @{"ReadJoyPort()" Link "ReadJoyPort()"} will attempt to determine the type of
  controller plugged into the given port automatically.
  If one of the other types is used, @{"ReadJoyPort()" Link "ReadJoyPort()"} will
  make no attempt to read the given controller as
  anything other than the type specified.The default
  type is @{i}SJA_AUTOSENSE@{ui}.
  @{i}Note@{ui} -- if you set the type to anything other than
  auto-sense, it's your responsibility to return it
  to auto-sense mode before exiting.
@{b}SJA_Reinitialize@{ub} (@{FG shine}void@{FG text}) - Return a given port to it's initial state,
  forcing a port to deallocate any allocated resources;
  return the implied type to @{i}SJA_TYPE_AUTOSENSE@{ui}.
@endnode
@Node "StartTimerInt()" "lowlevel.library/StartTimerInt"
@{b}@{u}StartTimerInt@{uu}@{ub} -- start the timer associated with the timer interrupt.@{b}(V40)@{ub}
  This routine starts a stopped timer that is assocatied with a
  timer interrupt created by @{"AddTimerInt()" Link "AddTimerInt()"}.
SYNOPSIS  @{FG shine}void@{FG text} StartTimerInt(APTR, ULONG, BOOL);
  StartTimerInt(@{i}intHandle@{ui}, @{i}timeInterval@{ui}, @{i}continuous@{ui});
                 A1         D0             D1
  @{i}intHandle@{ui} - handle obtained from @{"AddTimerInt()" Link "AddTimerInt()"}.
  @{i}timeInterval@{ui} - number of micoseconds between interrupts.
    The maximum value allowed is 90,000.If higher values
    are passed there will be unexpected results.
  @{i}continuous@{ui} - FALSE for a one shot interrupt.TRUE for multiple interrupts.
SEE ALSO
  @{"AddTimerInt()" Link "AddTimerInt()"}, @{"RemTimerInt()" Link "RemTimerInt()"}, @{"StopTimerInt()" Link "StopTimerInt()"}
@EndNode
@Node "StopTimerInt()" "lowlevel.library/StopTimerInt"
@{b}@{u}StopTimerInt@{uu}@{ub} -- stop the timer associated with the timer interrupt.@{b}(V40)@{ub}
  Stops the timer associated with the timer interrupt handle passed.
  This is used to stop a continuous timer started by @{"StartTimerInt()" Link "StartTimerInt()"}.
SYNOPSIS  @{FG shine}void@{FG text} StopTimerInt(APTR);
  StopTimerInt(@{i}intHandle@{ui});
                A1
  @{i}intHandle@{ui} - handle obtained from @{"AddTimerInt()" Link "AddTimerInt()"}.
SEE ALSO
  @{"AddTimerInt()" Link "AddTimerInt()"}, @{"RemTimerInt()" Link "RemTimerInt()"}, @{"StartTimerInt()" Link "StartTimerInt()"}
@EndNode
@Node "SystemControlA()" "lowlevel.library/SystemControlA"
@{b}@{u}SystemControlA@{uu}@{ub} - Method for selectively disabling OS features.@{b}(V40)@{ub}
@{b}@{u}SystemControl@{uu}@{ub}  - varargs stub for SystemControlA().
  This function is used to alter the operation of the system.Some of
  the alterations involve controlling what are normally regarded as
  system resources.In order to minimize confusion only one task is
  allowed to control any part of the system resources.This prevents
  the possiblity of two tasks fighting, each controlling a part of the
  system.If a tag is identified as task exclusive, it means that
  only one task can hold (set to TRUE) that tag.If
  another task attempts to set the same tag to TRUE, the call to
  SystemControl() will fail.
  It is important to remember that SystemControl() can fail.
  This is a low level function and certain tags do not fit the normal
  Amiga multitasking model.
SYNOPSIS
  ULONG SystemControlA(@{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  ULONG SystemControl (Tag, ...);
  @{i}@{b}failTag@{ub}@{ui} = SystemControlA(@{i}tagList@{ui});
   D0                       A1
  @{i}@{b}failTag@{ub}@{ui} = SystemControl (@{i}firstTag@{ui}, ...);
  @{i}tagList@{ui} - pointer to an array of tags listing the features of the
    system to be enabled/disabled.
@{"TAGS" link SYSTEMCONTROLA_TAGS}
  @{i}@{b}failTag@{ub}@{ui} - zero if all tags succeeded.
    A non-zero return indicates a tag that has failed.It is possible
    that other tags may fail as well.If any tag fails there will be
    no change in the system due to other tags.
SEE ALSO
  <libraries/lowlevel.h>
@EndNode
@node SYSTEMCONTROLA_TAGS "SystemControlA_tags"
@{b}SCON_TakeOverSys@{ub} (BOOL)
  TRUE - Takes over the CPU to ensure that a program gets every ounce of
    CPU time (with the exception of crucial interrupts).When in this mode, the
    CPU will belong completely to the program.@{"Task" Link "include:exec/tasks.h/Main" 24} switching will be disabled
    and the program will get all CPU cycles.This means any calls to the OS that
    involve multitasking in some way will not execute correctly.Other tasks will
    not run until this tag is used with FALSE.However, during a @{"Wait()" Link "exec.guide/Wait()"} on a
    signal, multitasking will automatically be turned back on until the signal is
    received.Once received, multitasking will again be disabled and the CPU will
    be exclusive to the owning program.
  FALSE - Relinquishes the CPU and reenables multitasking.
    This tag is task exculsive.This tag nests.A task may take over the CPU
    several times before relinquishing it.
@{b}SCON_KillReq@{ub} (BOOL)
  TRUE - Disables system requesters.
  These are the reasons for @{b}NOT@{ub} disabling system requesters:
    1- No calls in the program will cause a system requester.
    2- The only thing that could cause a requester to appear is the lack of a
       CD in the drive and @{i}SCON_CDReboot@{ui} is set to @{i}CDReboot_On@{ui}, therefore a
       requester can't appear.
    3- The only disk I/O is via a CD with @{i}SCON_CDReboot@{ui}
       set to @{i}CDReboot_On@{ui} and/or nonvolatile.library.
  When requesters should not be disabled.GAME PROGRAMS:
    No DOS calls are used after loading; or @{i}SCON_CDReboot@{ui} is CDReboot_On;
    and nonvolatile.library is used for loading and saving user data.
    This fits the above case since; After loading either DOS calls are not used
    fitting reason 1, or the game is accessing the CD and has @{i}SCON_CDReboot@{ui} set
    to @{i}CDReboot_On@{ui} fitting reason 2.The game accesses high scores, game position,
    etc through nonvolatile.library, fitting reason 3.
  FALSE - Enables requesters for the program.
    This tag nests.Tasks may disable requesters several times before
    enabling them.However, there must be a matching number of calls.
@{b}SCON_CDReboot@{ub} (ULONG)
  @{i}CDReboot_On@{ui} - Ejecting the CD will cause a reboot of the system.
    Use this only if the program cannot deal with error conditions.
  @{i}CDReboot_Off@{ui} - Ejecting the CD will not cause a reboot of the system.
    Use this if the program needs to insert CDs while running.
  @{i}CDReboot_Default@{ui} - Restore the default reboot behavior for this system.
    This should be used upon exit, if this tag had been used to change the
    reboot behaviour.For the CD32 this value is synonomous with @{i}CDReboot_On@{ui}.
    For Amiga computers this value is synonomous with @{i}CDReboot_Off@{ui}.
    Note that the default reboot behavior differs depending on the platform.
    If a program requires a specific behavior it must use this function to
    set the behavior.For example, a CD audio mixer would use this tag with
    the data @{i}CDReboot_Off@{ui}.This will allow the changing of audio CDs on the
    game machine as well as Amiga computers.
    If, however, there is no error detection code at all this tag should be
    used with the data @{i}CDReboot_On@{ui}.
    It is hoped that no program will require @{i}CDReboot_On@{ui}.If all programs check
    for error condition and recover gracefully such a call should never be
    necessary.With the default behavior the CD32 will always reset on disk
    ejects, and programs run from Amiga computers will not reset.Thus,
    leaving the default will increase the market for a program to include
    both types of platforms.This tag does not nest.
@{b}SCON_StopInput@{ub} (BOOL) - When TRUE, stops input.device from using any
    CPU cycles.Also prevents input.device from passing along any
    events from either the keyboard and/or port 0.
    This tag is task exclusive.This tag is @{b}NOT@{ub} reversible.
    Attempting to reverse will result in confused/garbled input events.
@{b}SCON_AddCreateKeys@{ub} (ULONG) - Starts creating rawkey codes for the
    joystick/game controller on the given unit.The unit value is checked for
    validity and must be either 0 or 1.Each different unit used results in some
    code added to the VBlank interrupt chain.
    This tag nests.The tag @{i}SCON_RemCreateKeys@{ui} is used to undo this tag.Tasks may
    create rawkey codes several times before stopping them.
    Note that when operating in an Intuition window, the controller's blue
    button is the equivilent of the mouse menu button.Therefore, Intuition
    will be capturing most blue button events.If notificiation of these
    events is important, review the documentation for @{i}WFLG_RMBTRAP@{ui} in the
    @{"intuition.library/OpenWindow()" Link "intuition.guide/OpenWindow()"} autodoc.
@{b}SCON_RemCreateKeys@{ub} (ULONG) - stops rawkey codes for the joystick/game
    controller on the given unit.The unit value is checked for
    validity and must be either 0 or 1.
@endnode
@Node "AvailFonts()" "diskfont.library/AvailFonts"
@{b}@{u}AvailFonts@{uu}@{ub} -- Inquire available memory & disk fonts.
  AvailFonts fills a user supplied buffer with the structure, described below,
  that contains information about all the fonts available in memory and/or on
  disk.Those fonts available on disk need to be loaded into memory and opened
  via @{"OpenDiskFont" Link "OpenDiskFont()"}, those already in memory are accessed via @{"OpenFont" Link "graphics.guide/OpenFont()"}.
  The @{"TextAttr" Link "include:graphics/text.h/Main" 65} structure required by the open calls is part of the information
  @{"AvailFonts" Link "include:diskfont/diskfont.h/Main" 94} supplies.
  When AvailFonts fails, it returns the number of extra bytes it needed to
  complete the command.Add this number to your current buffer size, allocate a
  new buffer, and try again.
SYNOPSIS
  @{FG shine}long@{FG text} AvailFonts(@{FG shine}struct@{FG text} @{"AvailFontsHeader" Link "include:diskfont/diskfont.h/Main" 104} *buffer, @{FG shine}long@{FG text} bufBytes, ULONG flags);
  @{i}@{b}error@{ub}@{ui} = AvailFonts(@{i}buffer@{ui}, @{i}bufBytes@{ui}, @{i}flags@{ui});
                      A0      D0         D1
  @{i}buffer@{ui} - memory to be filled with @{FG shine}struct@{FG text} AvailFontsHeader
    followed by an array of @{"AvailFonts" Link "include:diskfont/diskfont.h/Main" 94} elements, which
    contains entries for the available fonts and their names.
  @{i}bufBytes@{ui} - the number of bytes in the buffer
  @{i}flags@{ui}:
    @{b}AFF_MEMORY@{ub} is set to search memory for fonts to fill the structure,
    @{b}AFF_DISK@{ub} is set to search the disk for fonts to fill the structure.
    @{b}AFF_SCALED@{ub} is set to not filter out memory fonts that are not designed.
    @{b}AFF_BITMAP@{ub} is set to filter out fonts that are not stored in Amiga font
      format, i.e.to filter out outline fonts.Any combination may be specified.
    @{b}AFF_TAGGED@{ub} is set to fill the buffer with @{"TAvailFonts" Link "include:diskfont/diskfont.h/Main" 99} elements instead of
      @{"AvailFonts" Link "include:diskfont/diskfont.h/Main" 94} elements.
  @{i}@{b}buffer@{ub}@{ui} - filled with structure AvailFontsHeader followed by the
    [T]AvailFonts elements, There will be duplicate entries for fonts found both
    in memory and on disk, differing only by type.
    The existance of a disk font in the buffer indicates that it exists as an
    entry in a font contents file -- the underlying font file has not been
    checked for validity, thus an @{"OpenDiskFont" Link "OpenDiskFont()"} of it may fail.
  @{i}@{b}error@{ub}@{ui} - if non-zero, this indicates the number of bytes needed
    for AvailFonts in addition to those supplied.Thus structure
    elements were not returned because of insufficient bufBytes.
EXAMPLE
  @{FG shine}int@{FG text} @{i}afShortage@{ui}, @{i}afSize@{ui};
  @{FG shine}struct@{FG text} AvailFontsHeader *@{i}afh@{ui};
  ...
  @{i}afSize@{ui} = 400;
  @{FG shine}do@{FG text} {
    @{i}afh@{ui} = (@{FG shine}struct@{FG text} AvailFontsHeader *) AllocMem(@{i}afSize@{ui}, 0);
    @{FG shine}if@{FG text} (@{i}afh@{ui}) {
      @{i}afShortage@{ui} = AvailFonts(@{i}afh@{ui}@{i}@{ui}, @{i}afSize@{ui}, AFF_MEMORY|AFF_DISK);
      @{FG shine}if@{FG text} (@{i}afShortage@{ui}) {
        FreeMem(@{i}afh@{ui}, @{i}afSize@{ui});
        @{i}afSize@{ui} += @{i}afShortage@{ui};
      }
    }
    @{FG shine}else@{FG text} {
      fail("AllocMem of AvailFonts buffer afh failed\n");
      @{FG shine}break@{FG text};
    }
  }
  @{FG shine}while@{FG text} (@{i}afShortage@{ui});
  /* if (@{i}afh@{ui}) non-zero here, then:
   * 1.it points to a valid AvailFontsHeader
   * 2.it must have FreeMem(@{i}afh@{ui}, @{i}afSize@{ui}) called for it after use */
@EndNode
@Node "DisposeFontContents()" "diskfont.library/DisposeFontContents"
@{b}@{u}DisposeFontContents@{uu}@{ub} -- Free the result from @{"NewFontContents" Link "NewFontContents()"}.(V34)
  This function frees the array of @{"FontContents" Link "include:diskfont/diskfont.h/Main" 27} entries
  returned by @{"NewFontContents" Link "NewFontContents()"}.
SYNOPSIS  @{FG shine}void@{FG text} DisposeFontContents( @{FG shine}struct@{FG text} @{"FontContentsHeader" Link "include:diskfont/diskfont.h/Main" 53} * );
  DisposeFontContents(@{i}fontContentsHeader@{ui})
                       A1
  @{i}fontContentsHeader@{ui} - a @{FG shine}struct@{FG text} FontContentsHeader pointer
    returned by @{"NewFontContents" Link "NewFontContents()"}.
EXCEPTIONS
  This command was first made available as of version 34.
  A fontContentsHeader other than one acquired by a call
  @{"NewFontContents" Link "NewFontContents()"} will crash.
SEE ALSO
  @{"NewFontContents" Link "NewFontContents()"} to get structure freed here.
@EndNode
@Node "NewFontContents()" "diskfont.library/NewFontContents"
@{b}@{u}NewFontContents@{uu}@{ub} -- Create a @{"FontContents" Link "include:diskfont/diskfont.h/Main" 27} image for a font.(V34)
  This function creates a new array of FontContents entries
  that describe all the fonts associated with the fontName,
  specifically, all those in the font directory whose name
  is that of the font sans the ".font" suffix.
SYNOPSIS  @{FG shine}struct@{FG text} @{"FontContentsHeader" Link "include:diskfont/diskfont.h/Main" 53} *NewFontContents( BPTR, @{FG shine}char@{FG text} * );
  @{i}@{b}fontContentsHeader@{ub}@{ui} = NewFontContents(@{i}fontsLock@{ui},@{i}fontName@{ui})
   D0                                   A0         A1
  @{i}fontsLock@{ui} - a DOS lock on the FONTS: directory (or other
    directory where the font contents file and associated
    font directory resides).
  @{i}fontName@{ui} - the font name, with the ".font" suffix,
    which is also the name of the font contents file.
  @{i}@{b}fontContentsHeader@{ub}@{ui} - a structure FontContentsHeader pointer.
EXCEPTIONS
  This command was first made available as of version 34.
  D0 is zero if the fontName is does not have a ".font" suffix,
  if the fontName is too long, if a DOS error occurred, or if
  memory could not be allocated for the fontContentsHeader.
SEE ALSO
  @{"DisposeFontContents" Link "DisposeFontContents()"} to free the structure acquired here.
@EndNode
@Node "NewScaledDiskFont()" "diskfont.library/NewScaledDiskFont"
@{b}@{u}NewScaledDiskFont@{uu}@{ub} -- Create a DiskFont scaled from another.(V36)
SYNOPSIS
  @{FG shine}struct@{FG text} @{"DiskFontHeader" Link "include:diskfont/diskfont.h/Main" 63} *NewScaledDiskFont( @{FG shine}struct@{FG text} @{"TextFont" Link "include:graphics/text.h/Main" 89} *,
    @{FG shine}struct@{FG text} @{"TTextAttr" Link "include:graphics/text.h/Main" 72} *);
  @{i}@{b}header@{ub}@{ui} = NewScaledDiskFont(@{i}srcFont@{ui}, @{i}destTextAttr@{ui})
   D0                         A0        A1
  @{i}srcFont@{ui} - the font from which the scaled font is to be constructed.
  @{i}destTextAttr@{ui} - the desired attributes for the new scaled font.
    This may be a structure of type @{"TextAttr" Link "include:graphics/text.h/Main" 65} or TTextAttr.
  @{b}@{i}header@{ui}@{ub} - a pointer to a DiskFontHeader structure.
    This is not being managed by the diskfont.library, however.
NOTES
  o This function may use the blitter.
  o Fonts containing characters that render wholly outside
    the character advance cell are currently not scalable.
  o The font, and memory allocated for the scaled font can
    can be freed by calling @{"StripFont()" Link "graphics.guide/StripFont()"} on the font,
    and then calling @{"UnLoadSeg()" Link "dos.guide/UnLoadSeg()"} on the segment created by this function.
  Both the TextFont structure, and segment pointer are contained
  within the DiskFontHeader structure.The DiskFontHeader structure
  will also be freed as part of the @{"UnLoadSeg()" Link "dos.guide/UnLoadSeg()"} call.
  @{"StripFont()" Link "graphics.guide/StripFont()"} is a new graphics.library call as of V36.
@EndNode
@Node "OpenDiskFont()" "diskfont.library/OpenDiskFont"
@{b}@{u}OpenDiskFont@{uu}@{ub} - load and get a pointer to a disk font.
  This function finds the font with the specified textAttr on disk, loads it
  into memory, and returns a pointer to the font that can be used in subsequent
  @{"SetFont" Link "graphics.guide/SetFont()"} and @{"CloseFont" Link "graphics.guide/CloseFont()"} calls.It is important to match this call with a
  corresponding @{"CloseFont" Link "graphics.guide/CloseFont()"} call for effective management of font memory.
  If the font is already in memory, the copy in memory is used.
  The disk copy is not reloaded.
SYNOPSIS
  @{i}@{b}font@{ub}@{ui} = OpenDiskFont(@{i}textAttr@{ui})
   D0                  A0
  @{i}textAttr@{ui} - a @{"TextAttr" Link "include:graphics/text.h/Main" 65} structure
    that describes the text font attributes desired.
  D0 is zero if the desired font cannot be found.
NOTES
  @{i}As of V36, OpenDiskFont() will automatically attempt to construct a font
  for you if@{ui}:
  - You have requested a font size which does not exist as a designed font, and
  - You have not set the DESIGNED bit in the @{i}ta_Flags@{ui} field of the TextAttr, or
    @{"TTextAttr" Link "include:graphics/text.h/Main" 72} structure.
  Constructed fonts are created by scaling a designed font.A designed font is
  one which typically resides on disk, or in ROM (e.g., a font which has been
  designed by hand using a drawing tool).Designed fonts generally look better
  than fonts constructed by the font scaler, but designed fonts also require
  disk space for each font size.Always set the DESIGNED bit if you do not
  want constructed fonts, or use @{"AvailFonts()" Link "AvailFonts()"} to find out which font sizes
  already exist.
  As of V37 the diskfont.library supported built-in outline fonts.Then in V38
  the outline font engine was moved to a new library, "bullet.library."
BUGS
  This routine will not work well with font names whose file
  name components are longer than the maximum allowed (30 characters).
@EndNode
@Node "DT_--background--" "datatypes.library/--background--"
PURPOSE
  The datatypes.library provides transparent data handling
  abilities to applications.Application developers can register
  their data format with datatypes.library and provide a class
  library for handling their data within other applications.
OVERVIEW
* @{b}Object Oriented@{ub}
  datatypes.library implementation is object oriented, using the
  boopsi functions of Intuition.Each data class is implemented
  as a shared system library.
* @{b}Embedded Objects@{ub}
  datatypes.library provides the ability to embed different object
  types within an application.For example, an application can
  embed an picture object or even an AmigaGuide document browser
  within their application's window.Objects can also be embedded
  within other objects.
* @{b}Gadget-like@{ub}
  Embedded objects are actually boopsi gadgets.That means that
  input handling is done on Intuition's task.Time intensive
  operations, such as layout when the window size changes, are
  off-loaded to a sub-process.Printing, clipboard operations,
  file read/write are also off-loaded to a separate process on an
  as-needed basis.
* @{b}Trigger Methods@{ub}
  Sometimes it is necessary for an application to provide
  additional controls for navigating through an object.For
  example, with an AmigaGuide object it is necessary to have
  controls for "Contents", "Index", "Browse >", "Browse <".Each
  class implements a method that returns the trigger methods, and
  the appropriate labels, that a class supports.
* @{b}Format Conversion@{ub}
  As long as the objects are sub-classes of the same class, data
  from one format can be written out as another format.For
  example, it is possible to read in an ILBM file and write out a
  JPEG file, since both data types are sub-classes of PICTURE.
* @{b}Future Compatible@{ub}
  Each class implements a method that returns the supported
  methods within a class.This way an application can ask an
  object if it is capable of any particular method, such as
  DTM_WRITE for example.
* @{b}Data Type Detection@{ub}
  datatypes.library provides the ability to examine a file or
  the clipboard to determine what type of data it contains.
@EndNode
@Node "DT_--rexxhost--" "datatypes.library/--rexxhost--"
HOST INTERFACE
  datatypes.library provides an ARexx function host interface that
  enables ARexx programs to take advantage of the features of data
  types.The functions provided by the interface are directly
  related to the functions described herein, with the differences
  mostly being in the way they are called.
  The function host library vector is located at offset -30 from
  the library.This is the value you provide to ARexx in the
  AddLib() function call.
FUNCTIONS
  ExamineDT(FILENAME/A,VARIABLENAME,STEM/S,VAR/S)
EXAMPLE
  /* datatypes.rexx */
  @{FG shine}PARSE@{FG text} @{FG shine}ARG@{FG text} @{i}fname@{ui}
  @{FG shine}OPTIONS@{FG text} @{FG shine}RESULTS@{FG text}
  /* Load the datatypes.library as a function host */
  @{FG shine}IF@{FG text} @{FG shine}~SHOW@{FG text}('L','datatypes.library') @{FG shine}THEN@{FG text}
    @{FG shine}CALL@{FG text} @{FG shine}ADDLIB@{FG text}('datatypes.library',0,-30)
    @{FG shine}IF@{FG text} @{i}fname@{ui}="" @{FG shine}THEN DO@{FG text}
      @{FG shine}SAY@{FG text} "Usage:"
      @{FG shine}SAY@{FG text} "  rx datatypes <filename>"
      @{FG shine}EXIT@{FG text}
   @{FG shine}END@{FG text}
   @{FG shine}SAY@{FG text} 'var test'
   @{i}type@{ui} = ExamineDT(@{i}fname@{ui},,VAR)
   @{FG shine}SAY@{FG text} @{i}type@{ui}
   @{FG shine}SAY@{FG text} 'stem test'
   @{FG shine}CALL@{FG text} ExamineDT(@{i}fname@{ui},@{i}dtstem@{ui}.,STEM)
   @{FG shine}SAY@{FG text} '      Disk Key:' dtstem.@{i}DiskKey@{ui}
   @{FG shine}SAY@{FG text} 'Dir Entry Type:' dtstem.@{i}DirEntryType@{ui}
   @{FG shine}SAY@{FG text} '     File Name:' dtstem.@{i}FileName@{ui}
   @{FG shine}SAY@{FG text} '    Protection:' dtstem.@{i}Protection@{ui}
   @{FG shine}SAY@{FG text} '    Entry Type:' dtstem.@{i}EntryType@{ui}
   @{FG shine}SAY@{FG text} '          Size:' dtstem.@{i}Size@{ui}
   @{FG shine}SAY@{FG text} '        Blocks:' dtstem.@{i}NumBlocks@{ui}
   @{FG shine}SAY@{FG text} '          Date:' dtstem.@{i}Date@{ui}
   @{FG shine}SAY@{FG text} '       Comment:' dtstem.@{i}Comment@{ui}
   @{FG shine}SAY@{FG text} '          Type:' dtstem.@{i}BaseType@{ui}
   @{FG shine}SAY@{FG text} '     File Type:' dtstem.@{i}DataType@{ui}
   @{FG shine}SAY@{FG text} '     Base Name:' dtstem.@{i}BaseName@{ui}
 @{FG shine}EXIT@{FG text}
@EndNode
@Node "AddDTObject()" "datatypes.library/AddDTObject"
@{b}@{u}AddDTObject@{uu}@{ub} - Add an object to a window or requester.(V39)
  This function adds a single object to the gadget list of the given
  window or requester at the position in the list specified by the
  position argument.
  When the object is added to the gadget list, the object will
  receive a @{i}GM_LAYOUT@{ui} message with the @{i}gpl_Initial@{ui} field set to one.
SYNOPSIS
  @{FG shine}long@{FG text} AddDTObject (@{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *, Object *, @{FG shine}long@{FG text});
  @{i}@{b}realposition@{ub}@{ui} = AddDTObject (@{i}window@{ui}, @{i}requester@{ui}, @{i}object@{ui}, @{i}position@{ui});
   d0                          a0      a1          a2      d0
  @{i}window@{ui} - Pointer to the window.
  @{i}requester@{ui} - Must be NULL.
  @{i}object@{ui} - Pointer to an object as returned by @{"NewDTObjectA()" Link "NewDTObjectA()"}.
  @{i}position@{ui} - Integer position in the list for the new gadget.
    -1 to add to the end of the list.
  Returns the position of where the object was actually added.
SEE ALSO
   @{"RemoveDTObject()" Link "RemoveDTObject()"}, @{"intuition.library/AddGList()" Link "intuition.guide/AddGList()"}
@EndNode
@Node "DisposeDTObject()" "datatypes.library/DisposeDTObject"
@{b}@{u}DisposeDTObject@{uu}@{ub} - Delete a data type object.(V39)
  This function is used to dispose of a data type object that was
  obtained with @{"NewDTObjectA()" Link "NewDTObjectA()"}.
SYNOPSIS  @{FG shine}void@{FG text} DisposeDTObject (Object *);
  DisposeDTObject (@{i}o@{ui});
                   a0
  @{i}o@{ui} - Pointer to an object as returned by @{"NewDTObjectA()" Link "NewDTObjectA()"}.
    NULL is a valid input.
SEE ALSO
  @{"NewDTObjectA()" Link "NewDTObjectA()"}
@EndNode
@Node "DoAsyncLayout()" "datatypes.library/DoAsyncLayout"
@{b}@{u}DoAsyncLayout@{uu}@{ub} - Call the @{i}DTM_ASYNCLAYOUT@{ui} method on a separate process.(V39)
  This function is used to asyncronously perform the object's
  @{i}DTM_ASYNCLAYOUT@{ui} method.This is used to offload the layout method
  from input.device.
  The @{i}DTM_ASYNCLAYOUT@{ui} method must exit when @{i}SIGBREAKF_CTRL_C@{ui} signal
  is set.This indicates that the data has become obsolete and
  the @{i}DTM_ASYNCLAYOUT@{ui} method will be called again.
SYNOPSIS  ULONG DoAsyncLayout (Object *, @{FG shine}struct@{FG text} gpLayout *);
  @{i}@{b}retval@{ub}@{ui} = DoAsyncLayout (@{i}object@{ui}, @{i}gpl@{ui});
   d0                      a0      a1
  @{i}object@{ui} - Pointer to the data types object.
  @{i}gpl@{ui} - Pointer to a gpLayout message.
@EndNode
@Node "DoDTMethodA()" "datatypes.library/DoDTMethodA"
@{b}@{u}DoDTMethodA@{uu}@{ub} - Do a datatypes method.(V39)
  This function is used to perform a datatypes method.
SYNOPSIS
  ULONG DoDTMethodA (Object *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *, Msg);
  ULONG DoDTMethod  (Object *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *, ULONG, ...);
  @{i}@{b}retval@{ub}@{ui} = DoDTMethodA (@{i}o@{ui}, @{i}win@{ui}, @{i}req@{ui}, @{i}msg@{ui});
   d0                    a0 a1    a2   a3
  @{i}@{b}retval@{ub}@{ui} = DoDTMethod  (@{i}o@{ui}, @{i}win@{ui}, @{i}req@{ui}, @{i}data@{ui}, ...);
  @{i}o@{ui} - Pointer to an object as returned by @{"NewDTObjectA()" Link "NewDTObjectA()"}.
  @{i}win@{ui} - Window that the object is attached to.
  @{i}req@{ui} - Requester that the object is attached to.
  @{i}msg@{ui} - The message to send to the object.
  Returns the value returned by the method.
SEE ALSO
  intuition.library/DoGadgetMethod()
@EndNode
@Node "GetDTAttrsA()" "datatypes.library/GetDTAttrsA"
@{b}@{u}GetDTAttrsA@{uu}@{ub} - Obtain attributes for an object.(V39)
  This function is used to get the attributes of a data type object.
SYNOPSIS
  ULONG GetDTAttrsA (Object *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  ULONG GetDTAttrs  (Object *, Tag tag1, ...);
  @{i}@{b}retval@{ub}@{ui} = GetDTAttrsA (@{i}o@{ui}, @{i}attrs@{ui});
   d0                    a0  a2
  @{i}@{b}retval@{ub}@{ui} = GetDTAttrs  (@{i}o@{ui}, @{i}tag1@{ui}, ...);
  @{i}o@{ui} - Pointer to an object as returned by @{"NewDTObjectA()" Link "NewDTObjectA()"}.
  @{i}attrs@{ui} - Attributes to get, terminated with TAG_DONE.
    The data element of each pair contains the address of the storage variable.
  @{i}@{b}retval@{ub}@{ui} - Contains the number of attributes the system was able to obtain.
SEE ALSO
  @{"SetDTAttrsA()" Link "SetDTAttrsA()"}, @{"intuition.library/GetAttr()" Link "intuition.guide/GetAttr()"}
@EndNode
@Node "GetDTMethods()" "datatypes.library/GetDTMethods"
@{b}@{u}GetDTMethods@{uu}@{ub} - Obtain methods an object supports.(V39)
  This function is used to obtain a list of methods that an object supports.
SYNOPSIS  ULONG GetDTMethods (Object *);
  @{i}@{b}methods@{ub}@{ui} = GetDTMethods (@{i}object@{ui});
   d0                      a0
  @{i}object@{ui} - Pointer to an object as returned by @{"NewDTObjectA()" Link "NewDTObjectA()"}.
  Returns a pointer to a ~0 terminated ULONG array.This array is
  only valid until the object is disposed off.
SEE ALSO
  @{"GetDTTriggerMethods()" Link "GetDTTriggerMethods()"}
@EndNode
@Node "GetDTString()" "datatypes.library/GetDTString"
@{b}@{u}GetDTString@{uu}@{ub} - Obtain a DataTypes string.(V39)
  This function is used to obtain a pointer to a localized DataTypes string.
SYNOPSIS  STRPTR GetDTString (ULONG id);
  @{i}@{b}str@{ub}@{ui} = GetDTString (@{i}id@{ui});
   d0                 d0
  @{i}id@{ui} - ID of the string to obtain.
  Returns a pointer to a NULL terminated string.
@EndNode
@Node "GetDTTriggerMethods()" "datatypes.library/GetDTTriggerMethods"
@{b}@{u}GetDTTriggerMethods@{uu}@{ub} - Obtain trigger methods supported by an object.(V39)
  This function is used to obtain a list of trigger methods that an
  object supports.This is so that an application can provide
  the appropriate controls for an object.For example, an AmigaGuide
  object needs controls for "Contents", "Index", "Retrace", "Browse <",
  and "Browse >",
SYNOPSIS  @{FG shine}struct@{FG text} DTMethods *GetDTTriggerMethods (Object *);
  @{i}@{b}methods@{ub}@{ui} = GetDTTriggerMethods (@{i}object@{ui});
   d0                             a0
  @{i}object@{ui} - Pointer to an object as returned by @{"NewDTObjectA()" Link "NewDTObjectA()"}.
  Returns a pointer to a NULL terminated DTMethod list.This list is
  only valid until the object is disposed off.
EXAMPLE
  @{i}To call the method@{ui}:
    @{"DoMethod" Link "amiga_lib.guide/DoMethod()"} (@{i}object@{ui}, DTM_TRIGGER, dtm[@{i}button@{ui}]->@{i}dtm_Method@{ui});
SEE ALSO
  @{"GetDTMethods()" Link "GetDTMethods()"}
@EndNode
@Node "NewDTObjectA()" "datatypes.library/NewDTObjectA"
@{b}@{u}NewDTObjectA@{uu}@{ub} - Create an data type object.(V39)
  This is the method for creating datatype objects from
  'boopsi' classes.Boopsi' stands for "basic object-oriented
  programming system for Intuition".)
  You further specify initial "create-time" attributes for the
  object via a TagItem list, and they are applied to the
  resulting datatype object that is returned.
SYNOPSIS
  Object *NewDTObjectA (APTR, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  Object *NewDTObject  (APTR, Tag tag1, ...);
  @{i}@{b}o@{ub}@{ui} = NewDTObjectA (@{i}name@{ui}, @{i}attrs@{ui});
   d0                d0    a0
  @{i}@{b}o@{ub}@{ui} = NewDTObject  (@{i}name@{ui}, @{i}tag1@{ui}, ...);
  @{i}name@{ui} - Name of the data source.Usually an existing file name.
  @{i}attrs@{ui} - Pointer to a taglist containing additional arguments.
@{"TAGS" link NEWDTOBJECTA_TAGS}
  Returns boopsi object, which may be used in different contexts such
  as a gadget or image, and may be manipulated by generic functions.
  You eventually free the object using @{"DisposeDTObject()" Link "DisposeDTObject()"}.
  A NULL return indicates failure.Use @{"IoErr()" Link "dos.guide/IoErr()"} to get error value.
  Following is a summary of the error number used and there meaning
  as it relates to DataTypes:
    @{b}ERROR_REQUIRED_ARG_MISSING@{ub} - Indicates that a required attribute
      wasn't passed in.
    @{b}ERROR_BAD_NUMBER@{ub} - An invalid group ID was passed in.
    @{b}ERROR_OBJECT_WRONG_TYPE@{ub} - Object data type doesn't match @{i}DTA_GroupID@{ui}.
    @{b}ERROR_NO_FREE_STORE@{ub} - Not enough memory.
    @{b}DTERROR_UNKNOWN_DATATYPE@{ub} - Unable to open the class library
      associated with the data type.
    @{b}DTERROR_COULDNT_OPEN@{ub} - Unable to open the data object.
    @{b}ERROR_NOT_IMPLEMENTED@{ub} - Unknown handle type.
NOTES
  This function invokes the OM_NEW "method" for the class specified.
EXAMPLE
  STRPTR @{i}fileName@{ui} = "s:startup-sequence"
  Object *@{i}o@{ui};
  /* Simplest use is to just open an existing file */
  @{FG shine}if@{FG text} (@{i}o@{ui} = NewDTObject ((APTR)@{i}fileName@{ui}, NULL))
  {
    /* Free the object when we are done with it */
    DisposeDTObject (@{i}o@{ui});
  }
SEE ALSO
  @{"AddDTObject()" Link "AddDTObject()"}, @{"DisposeDTObject()" Link "DisposeDTObject()"}, @{"RemoveDTObject()" Link "RemoveDTObject()"},
  intuition.library/NewObjectA()
@EndNode
@node NEWDTOBJECTA_TAGS "NewDTObjectA_tags"
@{b}DTA_SourceType@{ub} - Specify the type of source data; such as coming
  from a file or clipboard (defaults to @{i}DTST_FILE@{ui}).
  If source type is clipboard, then the name field contains the
  numeric clipboard unit.
@{b}DTA_Handle@{ub} - Can optionally be used instead of the name field.
  Must be a valid @{"FileHandle" Link "include:dos/dosextens.h/Main" 89} if @{i}DTA_SourceType@{ui} is @{i}DTST_FILE@{ui}.
  Must be a valid @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} if @{i}DTA_SourceType@{ui} is @{i}DTST_CLIPBOARD@{ui}.
@{b}DTA_DataType@{ub} - Specify the class of data.Data is a pointer to a
  valid DataType.This is only used when attempting to create
  a new object that doesn't have any source data.
@{b}DTA_GroupID@{ub} - Specify that the object must be of this type, or
  NewDTObject() will fail with @{"IoErr()" Link "dos.guide/IoErr()"} of @{i}ERROR_OBJECT_WRONG_TYPE@{ui}.
@{b}GA_Left@{ub}, @{b}GA_RelRight@{ub}, @{b}GA_Top@{ub}, @{b}GA_RelBottom@{ub}, @{b}GA_Width@{ub}, @{b}GA_RelWidth@{ub},
@{b}GA_Height@{ub}, @{b}GA_RelHeight@{ub} - Specify the placement of the object
  within the destination window.
@{b}GA_ID@{ub} - Specify the object ID.
@{b}GA_UserData@{ub} - Specify the application specific data for the object.
@endnode
@Node "ObtainDataTypeA()" "datatypes.library/ObtainDataTypeA"
@{b}@{u}ObtainDataTypeA@{uu}@{ub} - Examines a handle and return its DataType.(V39)
  This function examines the data that the handle points to,
  and returns a DataType record that describes the data.
SYNOPSIS
  @{FG shine}struct@{FG text} DataType *ObtainDataTypeA (ULONG, APTR, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  @{FG shine}struct@{FG text} DataType *ObtainDataType  (ULONG, APTR, Tag tag1, ...);
  @{i}@{b}dtn@{ub}@{ui} = ObtainDataTypeA (@{i}type@{ui}, @{i}handle@{ui}, @{i}attrs@{ui});
   d0                     d0    a0       a1
  @{i}@{b}dtn@{ub}@{ui} = ObtainDataType  (@{i}type@{ui}, @{i}handle@{ui}, @{i}tag1@{ui}, ...);
  @{i}type@{ui} - Type of handle.
  @{i}handle@{ui} - Handle to examine.
    For @{i}DTST_FILE@{ui}, handle must be BPTR lock.
    For @{i}DTST_CLIPBOARD@{ui}, handle must be @{FG shine}struct@{FG text} @{"IFFHandle" Link "include:libraries/iffparse.h/Main" 34} *.
  @{i}attrs@{ui} - Additional attributes (currently none are defined).
  Success returns a pointer to a DataType.You must call
  FreeDataType() when you are done with the handle.
  A NULL return indicates failure.Use @{"IoErr()" Link "dos.guide/IoErr()"} to get error value.
  @{i}Following is a summary of the error number used and their meaning
  as it relates to DataTypes@{ui}:
    @{b}ERROR_NO_FREE_STORE@{ub} - Not enough memory.
    @{b}ERROR_OBJECT_NOT_FOUND@{ub} - Unable to open the data object.
    @{b}ERROR_NOT_IMPLEMENTED@{ub} - Unknown handle type.
NOTES
  The datatypes.library maintains a sorted list of all the
  DataType descriptors.The descriptor can consist of a
  function, a data mask for the first 64 bytes of the data,
  and a name pattern.
  @{i}The sort order for the list is@{ui}:
  - Descriptors with a function and no mask or name pattern.
  - Descriptors with a function and a mask or name pattern.
  - Descriptors with no function and a mask or name pattern.
  Within each group, they are also sorted in descending priority
  and descending mask length.
SEE ALSO
  FreeDataType()
@EndNode
@Node "PrintDTObjectA()" "datatypes.library/PrintDTObjectA"
@{b}@{u}PrintDTObjectA@{uu}@{ub} - Call the @{i}DTM_PRINT@{ui} method on a separate process.(V39)
  This function is used to asyncronously perform the object's @{i}DTM_PRINT@{ui} method.
  Once the application has performed the PrintDTObjectA() function,
  it must not manipulate the printerIO union until it receives a
  @{i}IDCMP_IDCMPUPDATE@{ui} message that contains the @{i}DTA_PrinterStatus@{ui} tag.
  To abort a print, the application sends the @{i}DTM_ABORTPRINT@{ui} method
  to the object.This in turn signals the print process with a @{i}SIGBREAKF_CTRL_C@{ui}.
SYNOPSIS
  ULONG PrintDTObjectA (Object *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *,
    @{FG shine}struct@{FG text} dtPrint *);
  ULONG PrintDTObject  (Object *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *,
    ULONG, ...);
  @{i}@{b}retval@{ub}@{ui} = PrintDTObjectA (@{i}object@{ui}, @{i}window@{ui}, @{i}requester@{ui}, @{i}msg@{ui});
   d0                       a0      a1       a2         a3
  @{i}@{b}retval@{ub}@{ui} = PrintDTObject  (@{i}object@{ui}, @{i}window@{ui}, @{i}requester@{ui}, @{i}data@{ui}, ...);
  @{i}object@{ui} - Pointer to the DataTypes object.
  @{i}window@{ui} - Pointer to the window that the object has been added to.
  @{i}requester@{ui} - Pointer to the requester that the object has been added to.
  Returns TRUE if successful, FALSE on error.
@EndNode
@Node "RefreshDTObjectA()" "datatypes.library/RefreshDTObjectA"
@{b}@{u}RefreshDTObjectA@{uu}@{ub} - Refresh a datatypes object.(V39)
  Refreshes the specified object, by sending the @{i}GM_RENDER@{ui} method to the object.
SYNOPSIS
  @{FG shine}void@{FG text} RefreshDTObjectA (Object *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *,
    @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  @{FG shine}void@{FG text} RefreshDTObject  (Object *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *,
    Tag tag1, ...);
  RefreshDTObjectA (@{i}object@{ui}@{i}@{ui}, @{i}window@{ui}, @{i}req@{ui}, @{i}attrs@{ui})
                     a0      a1      a2    a3
  RefreshDTObject  (@{i}object@{ui}, @{i}window@{ui}, @{i}req@{ui}, @{i}tag1@{ui}, ...);
  @{i}object@{ui} - Pointer to an object as returned by @{"NewDTObjectA()" Link "NewDTObjectA()"}.
  @{i}window@{ui} - Pointer to the window.
  @{i}req@{ui} - Must be NULL.
  @{i}attrs@{ui} - Additional attributes (currently none are defined).
SEE ALSO
  @{"AddDTObject()" Link "AddDTObject()"}, @{"RemoveDTObject()" Link "RemoveDTObject()"}, @{"intuition.library/RefreshGList()" Link "intuition.guide/RefreshGList()"}
@EndNode
@Node "ReleaseDataType()" "datatypes.library/ReleaseDataType"
@{b}@{u}ReleaseDataType@{uu}@{ub} - Release a DataType structure.(V39)
  This function is used to release a DataType structure obtained
  by @{"ObtainDataTypeA()" Link "ObtainDataTypeA()"}.
SYNOPSIS  @{FG shine}void@{FG text} ReleaseDataType (@{FG shine}struct@{FG text} DataType *);
  ReleaseDataType (@{i}dtn@{ui});
                    a0
  @{i}dtn@{ui} - DataType structure returned by @{"ObtainDataTypeA()" Link "ObtainDataTypeA()"}.
    NULL is a valid input.
SEE ALSO
  @{"ObtainDataTypeA()" Link "ObtainDataTypeA()"}
@EndNode
@Node "RemoveDTObject()" "datatypes.library/RemoveDTObject"
@{b}@{u}RemoveDTObject@{uu}@{ub} - Remove an object from a window.(V39)
  Removes the object from the window's object list.This will wait
  until the AsyncLayout process is complete.The object will
  receive a @{i}DTM_REMOVEDTOBJECT@{ui} message to inform the object it has
  been removed.
SYNOPSIS  @{FG shine}long@{FG text} RemoveDTObject (@{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, Object *);
  @{i}@{b}position@{ub}@{ui} = RemoveDTObject (@{i}window@{ui}, @{i}object@{ui});
   d0                         a0      a1
  @{i}window@{ui} - Pointer to the window.
  @{i}object@{ui} - Pointer to an object as returned by @{"NewDTObjectA()" Link "NewDTObjectA()"}.
  Returns the ordinal position of the removed object.If the
  object wasn't found in the appropriate list then a -1 is returned.
SEE ALSO
  @{"AddDTObject()" Link "AddDTObject()"}, @{"intuition.library/RemoveGList()" Link "intuition.guide/RemoveGList()"}
@EndNode
@Node "SetDTAttrsA()" "datatypes.library/SetDTAttrsA"
@{b}@{u}SetDTAttrsA@{uu}@{ub} - Set attributes for an object.(V39)
  This function is used to set the attributes of a data type object.
SYNOPSIS
  ULONG SetDTAttrsA (Object *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *,
    @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  ULONG SetDTAttrs  (Object *, @{FG shine}struct@{FG text} @{"Window" Link "include:intuition/intuition.h/Main" 910} *, @{FG shine}struct@{FG text} @{"Requester" Link "include:intuition/intuition.h/Main" 145} *,
    Tag tag1, ...);
  @{i}@{b}retval@{ub}@{ui} = SetDTAttrsA (@{i}o@{ui}, @{i}win@{ui}, @{i}req@{ui}, @{i}attrs@{ui});
   d0                    a0  a1   a2   a3
  @{i}@{b}retval@{ub}@{ui} = SetDTAttrs  (@{i}o@{ui}, @{i}win@{ui}, @{i}req@{ui}, @{i}tag1@{ui}, ...);
  @{i}o@{ui} - Pointer to an object as returned by @{"NewDTObjectA()" Link "NewDTObjectA()"}.
  @{i}win@{ui} - Window that the object has been added to.
  @{i}attrs@{ui} - Attributes to set, terminated with TAG_DONE.
TAGS
  see <datatypes/datatypesclass.h> for tags.
SEE ALSO
  @{"GetDTAttrsA()" Link "GetDTAttrsA()"}, @{"intuition.library/SetGadgetAttrsA()" Link "intuition.guide/SetGadgetAttrsA()"}
@EndNode
@Node "bullet_--background--" "bullet.library/--background--"
AMIGA FONTS
  The existence of a disk font is indicated by the existence of
  its associated font contents file, whose name has the suffix
  ".font".It is this name that is used in the actual font
  open call of the application.Amiga fonts are collected in
  the directory path(s) associated with the FONTS: assign.It
  is this assign that is searched if no explicit path name is
  provided in the font open call: use of an explicit path is
  generally discouraged.The actual bitmaps of traditional
  Amiga fonts are stored in a directory with the name of the
  font contents file stripped of its ".font" suffix.This
  directory is usually in the same directory as the font
  contents file.This traditional arrangement is supported by
  the FixFonts system application.
  @{i}For example@{ui}:
  o FONTS: is assigned to Sys:Fonts/
  o Sys:Fonts/garnet.font exists and describes that the
    font "garnet.font" exists
  o Sys:Fonts/garnet/ contains the bitmap images for sizes 9 and 16
  Other variations of file placement may exist, but they
  require custom tools to maintain -- tools available not from
  Commodore, but from other sources such as Fish disks.
  Font contents files are flagged with magic numbers that not
  only verify that they are a font contents files but also what
  variation of file structure they contain.
OUTLINE TYPEFACES
  The existence of an outline typeface is indicated by a magic
  number in the font contents file.They are further described
  in the associated outline typeface tag file, whose name is
  the that of the font contents file with the suffix ".otag"
  substituted for ".font".This tag file contains a tag list
  that is to be processed and passed to the outline engine
  (i.e.bullet.library) in order to select the associated
  typeface.It also contains information applications may use
  to guide their use of the typeface.
OTAG SPECIFICATION EXAMPLE
  Here are the steps necessary to go from an arbitrary font name
  into an environment where glyphs from that font can be accessed:
  1.Read the header from the font contents (.font) file and
    verify that the magic cookie @{i}fch_ID@{ui} is @{i}OFCH_ID@{ui}.
    If it is not, then this is an Amiga bitmap font, not an outline font.
  2.Read the associated outline tag (.otag) file into memory:
    a.Validate that the @{i}OT_FileIdent@{ui} exists and matches the file size.
    b.Allocate a memory buffer and read the file into it.
    c.Resolve addresses: for each tag with the @{i}OT_Indirect@{ui} bit set,
      add the memory buffer origin to the associated data.
  3.Find the @{i}OT_Engine@{ui} tag and ensure that you have the proper engine open:
    a.If you already have an engine handle for this engine name,
      you skip these steps.
    b.append the suffix ".library" to the engine name.
    (e.g."bullet" becomes "bullet.library").
    c.use exec's @{"OpenLibrary()" Link "exec.guide/OpenLibrary()"} to open the library.
    d.use the engine's @{"OpenEngine()" Link "OpenEngine()"} to acquire an engine handle.
  4.Pass the full path name of the .otag file to the engine
    with the @{i}OT_OTagPath@{ui} tag using SetInfo().
  5.Pass the memory copy of the .otag file to the engine with
    the @{i}OT_OTagList@{ui} tag using SetInfo().This step may be combined
    with step 4, passing first the path then the list in one call.
  The library is now ready to accept glyph metric information
  (e.g.size and glyph code) and produce glyph bitmaps.
DISKFONT USE OF OTAG ENTRIES
  The diskfont library uses other entries from the outline tag
  (.otag) file.@{b}@{u}The following are used both during inquiry of@{uu}@{ub}
  @{b}@{u}what typefaces exist (AvailFonts) and during creation of an@{uu}@{ub}
  @{b}@{u}Amiga @{uu}@{ub}@{"TextFont" Link "include:graphics/text.h/Main" 89}@{b}@{u} (OpenDiskFont)@{uu}@{ub}:
  o @{b}OT_IsFixed@{ub} is used to determine whether these outlines
    describe a @{i}PROPORTIONAL@{ui} flagged font.
  o @{b}OT_StemWeight@{ub} is used to determine whether these outlines
    describe a @{i}BOLD@{ui} style font.
  o @{b}OT_SlantStyle@{ub} is used to determine whether these outlines
    describe an @{i}ITALIC@{ui} style font.
  o @{b}OT_HorizStyle@{ub} is used to determine whether these outlines
    describe an @{i}EXTENDED@{ui} style font.
  @{b}@{u}The following are used only during OpenDiskFont@{uu}@{ub}:
  o @{b}OT_YSizeFactor@{ub} is used to convert the Amiga pixel height
    specification, which describes the distance from the
    lowest decender to the highest ascender, into a point
    size specification, which is related (via @{i}YSizeFactor@{ui})
    to a nominal character height.
  o @{b}OT_SpaceWidth@{ub} is used as the width of the space character.
  @{b}@{u}The following is used only during AvailFonts@{uu}@{ub}:
  o @{b}OT_AvailSizes@{ub} is used to generate a list of sizes available for the font.
@EndNode
@Node "CloseEngine()" "bullet.library/CloseEngine"
@{b}@{u}CloseEngine@{uu}@{ub} -- Release an engine handle.
  This function releases the engine handle acquired with
  OpenEngine.It first releases any data acquired with ObtainInfoA
  associated with the engineHandle that has not yet been released.
SYNOPSIS  @{FG shine}void@{FG text} CloseEngine(@{FG shine}struct@{FG text} GlyphEngine *);
  CloseEngine(@{i}engineHandle@{ui})
               A0
  @{i}engineHandle@{ui} -- the handle acquired via OpenEngine.
    If zero, no operation is performed.
  This function has no result.The only error that can occur is
  when the when an invalid engineHandle is supplied: the
  application is assumed not to do that.
EXAMPLE
  EndGame(@{i}code@{ui}, @{i}arg1@{ui}, @{i}arg2@{ui}, @{i}arg3@{ui}, @{i}arg3@{ui})
  {
    ...
    CloseEngine(@{i}EngineHandle@{ui});
    ...
  }
SEE ALSO
  @{"OpenEngine()" Link "OpenEngine()"}
@EndNode
@Node "ObtainInfoA()" "bullet.library/ObtainInfoA"
@{b}@{u}ObtainInfoA@{uu}@{ub} -- Inquire tagged font and/or glyph metrics.
@{b}@{u}ObtainInfo@{uu}@{ub}  -- varargs form of ObtainInfoA.
  This function accepts a tagList whose tag field elements are valid for inquiry,
  and whose associated data fields are pointers to the destination in which to
  place the requested data.
  Tag items that refer to data indirectly (@{i}OT_Indirect@{ui} is set) return pointers
  that may be allocated or cached by the library.This data must be treated as
  read-only data.
  When the application is done with the data acquired via ObtainInfoA,
  it must perform a ReleaseInfoA to allow the library to release the data.
SYNOPSIS
  ULONG ObtainInfoA(@{FG shine}struct@{FG text} GlyphEngine *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  ULONG ObtainInfo (@{FG shine}struct@{FG text} GlyphEngine *, Tag, ...);
  @{i}@{b}error@{ub}@{ui} = ObtainInfoA(@{i}engineHandle@{ui}, @{i}tagList@{ui})
                       A0             A1
  @{i}@{b}error@{ub}@{ui} = ObtainInfo (@{i}engineHandle@{ui}, @{i}firstTag@{ui}, ...)
  @{i}engineHandle@{ui} -- the handle acquired via OpenEngine.
  @{i}tagList@{ui} -- a tagList containing @{i}OT_@{ui} tags valid for inquiry paired
    with the destination pointers for the inquiry results.All destinations are
    longwords, whether they are pointers or values, and regardless of whether
    the value could fit in a smaller variable.
  This function returns a zero success indication, or a non-zero error code.
EXAMPLE
  ULONG @{i}pointSize@{ui};
  @{FG shine}struct@{FG text} GlyphMap *@{i}glyph@{ui};
  ...
  @{FG shine}if@{FG text} (!ObtainInfo(EngineHandle, @{i}OT_Glyph@{ui}, @{i}&glyph@{ui}, TAG_DONE)) {
    ...
    ReleaseInfo(EngineHandle, @{i}OT_Glyph@{ui}, @{i}glyph@{ui}, TAG_DONE);
  }
SEE ALSO
  @{"ReleaseInfoA()" Link "ReleaseInfoA()"}, diskfont/diskfonttag.h, diskfont/oterrors.h
@EndNode
@Node "OpenEngine()" "bullet.library/OpenEngine"
@{b}@{u}OpenEngine@{uu}@{ub} -- Acquire engine handle.
  This function establishes a context for access to the bullet
  library.This context remains valid until it is closed via
  CloseEngine.Each specific context isolates the specification
  of the various font attributes from other contexts concurrently
  accessing the bullet library.A context can be shared among different tasks.
SYNOPSIS  @{FG shine}struct@{FG text} GlyphEngine *OpenEngine( @{FG shine}void@{FG text} )
  @{b}@{i}engineHandle@{ui}@{ub} = OpenEngine()
  This function returns an engineHandle,
  or NULL if for some reason no engineHandle can be created.
EXAMPLE
  @{i}BulletBase@{ui} = OpenLibrary("bullet.library", 0);
  @{FG shine}if@{FG text} (!@{i}BulletBase@{ui})
    EndGame(ERROR_LibOpen, "bullet.library", 0);
  @{i}EngineHandle@{ui} = OpenEngine();
  @{FG shine}if@{FG text} (!@{i}EngineHandle@{ui})
    EndGame(ERROR_InternalCall, "OpenEngine");
SEE ALSO
  @{"CloseEngine()" Link "CloseEngine()"}
@EndNode
@Node "ReleaseInfoA()" "bullet.library/ReleaseInfoA"
@{b}@{u}ReleaseInfoA@{uu}@{ub} -- Release data obtained with ObtainInfoA.
@{b}@{u}ReleaseInfo@{uu}@{ub}  -- varargs form of ReleaseInfoA.
  This function releases the data obtained with ObtainInfoA.
  Data associated with tags that are not indirect, i.e.for which
  OT_Indirect is not set, need not be released, but it is not an
  error to do so.Released data may be immediately freed or may
  become a candidate to be expunged from memory when the system
  reaches a low memory condition, depending on the library's
  internal implementation.
  Each ReleaseInfoA tag item must be associated with a prior ObtainInfoA.
SYNOPSIS
  ULONG ReleaseInfoA(@{FG shine}struct@{FG text} GlyphEngine *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  ULONG ReleaseInfo (@{FG shine}struct@{FG text} GlyphEngine *, Tag, ...);
  @{i}@{b}error@{ub}@{ui} = ReleaseInfoA(@{i}engineHandle@{ui}, @{i}tagList@{ui})
                        A0             A1
  @{i}@{b}error@{ub}@{ui} = ReleaseInfo (@{i}engineHandle@{ui}@{i}@{ui}, @{i}firstTag@{ui}, ...)
  @{i}engineHandle@{ui} -- the handle acquired via OpenEngine.
  @{i}tagList@{ui} -- a tagList containing OT_ tags valid for inquiry
    paired with the data previously acquired for them with ObtainInfoA.
    Null pointers quietly accepted and ignored for indirect data.
  This function has no result.The only error that can occur is when the Obtain
  and Release pairs are mismatched: the application is assumed not to do that.
EXAMPLE
  ULONG @{i}pointSize@{ui};
  @{FG shine}struct@{FG text} GlyphMap *@{i}glyph@{ui};
  ...
  @{i}error@{ui} = ObtainInfo(@{i}EngineHandle@{ui}, @{i}OT_Glyph@{ui}, @{i}&glyph@{ui}, TAG_DONE);
  ...
  ReleaseInfo(@{i}EngineHandle@{ui}, @{i}OT_Glyph@{ui}, @{i}glyph@{ui}, TAG_DONE);
SEE ALSO
  ReleaseInfoA(), diskfont/diskfonttag.h, diskfont/oterrors.h
@EndNode
@Node "SetInfoA()" "bullet.library/SetInfoA"
@{b}@{u}SetInfoA@{uu}@{ub} - Set font and/or glyph metrics.
@{b}@{u}SetInfo@{uu}@{ub}  - varargs form of SetInfoA.
  This function accepts a tagList whose tag field elements are
  valid for specification, and whose associated data fields are
  used to supply the specified data.
  Data that is supplied via an indirect pointer (OT_Indirect) to
  an array or structure is copied from that array or structure
  into the internal memory of the library.Changes to the data
  after this call do not affect the engine.
SYNOPSIS
  ULONG SetInfoA(@{FG shine}struct@{FG text} GlyphEngine *, @{FG shine}struct@{FG text} @{"TagItem" Link "include:utility/tagitem.h/Main" 31} *);
  ULONG SetInfo (@{FG shine}struct@{FG text} GlyphEngine *, Tag, ...);
  @{i}@{b}error@{ub}@{ui} = SetInfoA(@{i}engineHandle@{ui}, @{i}tagList@{ui})
                    A0             A1
  @{i}@{b}error@{ub}@{ui} = SetInfo (@{i}engineHandle@{ui}, @{i}firstTag@{ui}, ...)
  @{i}engineHandle@{ui} -- the handle acquired via OpenEngine.
  @{i}tagList@{ui} -- a tagList containing OT_ tags valid for
    specification paired with the specification data.
  This function returns a zero success indication, or a non-zero error code.
EXAMPLE
  @{FG shine}if@{FG text} (!(@{i}error@{ui} = SetInfo(@{i}EngineHandle@{ui}, @{i}OT_PointHeight@{ui}, @{i}fpoints@{ui}, @{i}OT_GlyphCode@{ui},
    @{i}GC_daggerdbl@{ui}, TAG_DONE)) {
    @{i}error@{ui} = ObtainInfo(@{i}EngineHandle@{ui}, @{i}OT_Glyph@{ui}, @{i}&glyph@{ui});
    ...
    ReleaseInfo(@{i}EngineHandle@{ui}, @{i}OT_Glyph@{ui}, @{i}glyph@{ui});
  }
SEE ALSO
  diskfont/diskfonttag.h, diskfont/oterrors.h,
@EndNode
@Node "AddFreeList()" "icon.library/AddFreeList"
@{b}@{u}AddFreeList@{uu}@{ub} - add memory to a free list.
  This routine adds the specified memory to the free list.
  The free list will be extended (if required).If there
  is not enough memory to complete the call, a null is returned.
  Note that AddFreeList does @{b}NOT@{ub} allocate the requested memory.
  It only records the memory in the free list.
SYNOPSIS  BOOL AddFreeList(@{FG shine}struct@{FG text} @{"FreeList" Link "include:workbench/workbench.h/Main" 81} *, APTR, ULONG);
  @{i}@{b}status@{ub}@{ui} = AddFreeList(@{i}free@{ui}, @{i}mem@{ui}, @{i}len@{ui})
   D0                   A0    A1    A2
  @{i}free@{ui} -- a pointer to a FreeList structure
  @{i}mem@{ui} -- the base of the memory to be recorded
  @{i}len@{ui} -- the length of the memory to be recorded
  @{i}@{b}status@{ub}@{ui} -- TRUE if the call succeeded else FALSE;
SEE ALSO
  @{"AllocEntry()" Link "exec.guide/AllocEntry()"}, @{"FreeEntry()" Link "exec.guide/FreeEntry()"}, @{"FreeFreeList()" Link "FreeFreeList()"}
@EndNode
@Node "BumpRevision()" "icon.library/BumpRevision"
@{b}@{u}BumpRevision@{uu}@{ub} - reformat a name for a second copy.
  BumpRevision takes a name and turns it into a "copy_of_name".
  It knows how to deal with copies of copies.The routine
  will truncate the new name to the maximum dos name size
  (currently 30 characters).
SYNOPSIS  @{FG shine}char@{FG text} *BumpRevision(@{FG shine}char@{FG text} *, @{FG shine}char@{FG text} *);
  @{i}@{b}result@{ub}@{ui} = BumpRevision(@{i}newbuf@{ui}, @{i}oldname@{ui})
   D0                    A0       A1
  @{i}newbuf@{ui} - the new buffer that will receive the name
    (it must be at least 31 characters long).
  @{i}oldname@{ui} - the original name
  @{i}@{b}result@{ub}@{ui} - a pointer to newbuf
EXAMPLE
  @{i}oldname@{ui}        @{i}newbuf@{ui}
  -------        ------
  "foo"        "copy_of_foo"
  "copy_of_foo"      "copy_2_of_foo"
  "copy_2_of_foo"      "copy_3_of_foo"
  "copy_199_of_foo"    "copy_200_of_foo"
  "copy foo"       "copy_of_copy foo"
  "copy_0_of_foo"      "copy_1_of_foo"
  "012345678901234567890123456789" "copy_of_0123456789012345678901"
@EndNode
@Node "DeleteDiskObject()" "icon.library/DeleteDiskObject"
@{b}@{u}DeleteDiskObject@{uu}@{ub} - Delete a Workbench disk object from disk.(V37)
  This routine will try to delete a Workbench disk object from disk.
  The name parameter will have a ".info" postpended to it, and the
  info file of that name will be deleted.If the call fails, it will
  return zero.The reason for the failure may be obtained via @{"IoErr()" Link "dos.guide/IoErr()"}.
  This call also updates the Workbench screen if needed.
  Using this routine protects you from any future changes to the way
  icons are stored within the system.
SYNOPSIS  BOOL DeleteDiskObject(@{FG shine}char@{FG text} *);
  @{i}@{b}result@{ub}@{ui} = DeleteDiskObject(@{i}name@{ui})
   D0                        A0
  @{i}name@{ui} -- name of the object (@{FG shine}char@{FG text} *)
  @{i}@{b}result@{ub}@{ui} -- TRUE if it worked, false if not.
EXAMPLE
  @{i}error@{ui}=NULL;
  /*Check if you have the right library version*/
  @{FG shine}if@{FG text} (((@{FG shine}struct@{FG text} @{"Library" Link "include:exec/libraries.h/Main" 34} *)IconBase)->@{i}lib_Version@{ui} > 36)
  {
    @{FG shine}if@{FG text} (!DeleteDiskObject(@{i}name@{ui})) @{i}error@{ui}=@{i}IoErr@{ui}();
  } @{FG shine}else@{FG text} {
    /* Delete name plus ".info" */
  }
  @{FG shine}if@{FG text} (@{i}error@{ui})
  {
    /* Do error routine...*/
  }
SEE ALSO
  @{"PutDiskObject()" Link "PutDiskObject()"}, @{"GetDiskObject()" Link "GetDiskObject()"}, @{"FreeDiskObject()" Link "FreeDiskObject()"}
@EndNode
@Node "FindToolType()" "icon.library/FindToolType"
@{b}@{u}FindToolType@{uu}@{ub} - find the value of a ToolType variable.
  This function searches a tool type array for a given entry,
  and returns a pointer to that entry.This is useful for
  finding standard tool type variables.The returned
  value is not a new copy of the string but is only
  a pointer to the part of the string after typeName.
SYNOPSIS  @{FG shine}char@{FG text} *FindToolType(@{FG shine}char@{FG text} **, @{FG shine}char@{FG text} *);
  @{i}@{b}value@{ub}@{ui} = FindToolType(@{i}toolTypeArray@{ui}, @{i}typeName@{ui})
   D0                   A0              A1
  @{i}toolTypeArray@{ui} - an array of strings (@{FG shine}char@{FG text} **).
  @{i}typeName@{ui} - the name of the tooltype entry (@{FG shine}char@{FG text} *).
  @{i}@{b}value@{ub}@{ui} - a pointer to a string that is the value bound to typeName,
    or NULL if typeName is not in the toolTypeArray.
EXAMPLE
  @{i}Assume the tool type array has two strings in it@{ui}:
    "FILETYPE=text"
    "TEMPDIR=:t"
  FindToolType( @{i}toolTypeArray@{ui}, "FILETYPE" ) returns "text"
  FindToolType( @{i}toolTypeArray@{ui}, "filetype" ) returns "text"
  FindToolType( @{i}toolTypeArray@{ui}, "TEMPDIR" )  returns ":t"
  FindToolType( @{i}toolTypeArray@{ui}, "MAXSIZE" )  returns NULL
SEE ALSO
  @{"MatchToolValue()" Link "MatchToolValue()"}
@EndNode
@Node "FreeDiskObject()" "icon.library/FreeDiskObject"
@{b}@{u}FreeDiskObject@{uu}@{ub} - free all memory in a Workbench disk object.
  This routine frees all memory in a Workbench disk object, and the
  object itself.It is implemented via @{"FreeFreeList()" Link "FreeFreeList()"}.
  @{"GetDiskObject()" Link "GetDiskObject()"} takes care of all the initialization required
  to set up the object's free list.This procedure may ONLY
  be called on a DiskObject allocated via @{"GetDiskObject()" Link "GetDiskObject()"}.
SYNOPSIS  @{FG shine}void@{FG text} FreeDiskObject(@{FG shine}struct@{FG text} @{"DiskObject" Link "include:workbench/workbench.h/Main" 60} *);
  FreeDiskObject(@{i}diskobj@{ui})
                  A0
  @{i}diskobj@{ui} -- a pointer to a DiskObject structure
SEE ALSO
  @{"GetDiskObject()" Link "GetDiskObject()"}, @{"PutDiskObject()" Link "PutDiskObject()"}, @{"DeleteDiskObject()" Link "DeleteDiskObject()"}, @{"FreeFreeList()" Link "FreeFreeList()"}
@EndNode
@Node "FreeFreeList()" "icon.library/FreeFreeList"
@{b}@{u}FreeFreeList@{uu}@{ub} - free all memory in a free list.
  This routine frees all memory in a free list, and the
  free list itself.It is useful for easily getting
  rid of all memory in a series of structures.There is
  a free list in a Workbench object, and this contains
  all the memory associated with that object.
  A FreeList is a list of @{"MemList" Link "include:exec/memory.h/Main" 53} structures.See the
  @{"MemList" Link "include:exec/memory.h/Main" 53} and @{"MemEntry" Link "include:exec/memory.h/Main" 40} documentation for more information.
  If the FreeList itself is in the free list, it must be
  in the first @{"MemList" Link "include:exec/memory.h/Main" 53} in the FreeList.
SYNOPSIS  @{FG shine}void@{FG text} FreeFreeList(@{FG shine}struct@{FG text} @{"FreeList" Link "include:workbench/workbench.h/Main" 81} *);
  FreeFreeList(@{i}free@{ui})
                A0
  @{i}free@{ui} -- a pointer to a FreeList structure
SEE ALSO
  @{"AllocEntry()" Link "exec.guide/AllocEntry()"}, @{"FreeEntry()" Link "exec.guide/FreeEntry()"}, @{"AddFreeList()" Link "AddFreeList()"}
@EndNode
@Node "GetDefDiskObject()" "icon.library/GetDefDiskObject"
@{b}@{u}GetDefDiskObject@{uu}@{ub} - read default wb disk object from disk.(V36)
  This routine reads in a default Workbench disk object from disk.
  The valid def_types can be found in @{"workbench/workbench.h" Link "include:workbench/workbench.h/Main" 0} and
  currently include WBDISK thru WBGARBAGE.If the call fails, it will
  return zero.The reason for the failure may be obtained via @{"IoErr()" Link "dos.guide/IoErr()"}.
  Using this routine protects you from any future changes to the way
  default icons are stored within the system.
SYNOPSIS  @{FG shine}struct@{FG text} @{"DiskObject" Link "include:workbench/workbench.h/Main" 60} *GetDefDiskObject(@{FG shine}long@{FG text});
  @{i}@{b}diskobj@{ub}@{ui} = GetDefDiskObject(@{i}def_type@{ui})
   D0                         D0
  @{i}def_type@{ui} - default icon type (WBDISK thru WBKICK).
    Note that the define 'WBDEVICE' is not currently supported.
  @{i}@{b}diskobj@{ub}@{ui} -- the default Workbench disk object in question
SEE ALSO
  @{"PutDefDiskObject" Link "PutDefDiskObject()"}
@EndNode
@Node "GetDiskObject()" "icon.library/GetDiskObject"
@{b}@{u}GetDiskObject@{uu}@{ub} - read in a Workbench disk object from disk.
  This routine reads in a Workbench disk object in from disk.The
  name parameter will have a ".info" postpended to it, and the
  info file of that name will be read.If the call fails, it will
  return zero.The reason for the failure may be obtained via @{"IoErr()" Link "dos.guide/IoErr()"}.
  Using this routine protects you from any future changes to the way
  icons are stored within the system.
  A @{"FreeList" Link "include:workbench/workbench.h/Main" 81} structure is allocated just after the DiskObject
  structure; @{"FreeDiskObject" Link "FreeDiskObject()"} makes use of this to get rid of
  the memory that was allocated.
SYNOPSIS  @{FG shine}struct@{FG text} @{"DiskObject" Link "include:workbench/workbench.h/Main" 60} *GetDiskObject(@{FG shine}char@{FG text} *);
  @{i}@{b}diskobj@{ub}@{ui} = GetDiskObject(@{i}name@{ui})
   D0                      A0
  @{i}name@{ui} -- name of the object (@{FG shine}char@{FG text} *)
    or NULL if you just want a DiskObject structure allocated for you
    (useful when calling AddAppIcon in workbench.library).
  @{i}@{b}diskobj@{ub}@{ui} -- the Workbench disk object in question
SEE ALSO
  @{"GetDiskObjectNew()" Link "GetDiskObjectNew()"}, @{"PutDiskObject()" Link "PutDiskObject()"}, @{"DeleteDiskObject()" Link "DeleteDiskObject()"},
  @{"FreeDiskObject()" Link "FreeDiskObject()"}
@EndNode
@Node "GetDiskObjectNew()" "icon.library/GetDiskObjectNew"
@{b}@{u}GetDiskObjectNew@{uu}@{ub} - read in a Workbench disk object from disk.(V36)
  This routine reads in a Workbench disk object in from disk.The
  name parameter will have a ".info" postpended to it, and the
  info file of that name will be read.If the call fails, it will
  return zero.The reason for the failure may be obtained via @{"IoErr()" Link "dos.guide/IoErr()"}.
  Using this routine protects you from any future changes to the way
  icons are stored within the system.
  A @{"FreeList" Link "include:workbench/workbench.h/Main" 81} structure is allocated just after the DiskObject
  structure; @{"FreeDiskObject" Link "FreeDiskObject()"} makes use of this to get rid of
  the memory that was allocated.
  This call is functionally identical to @{"GetDiskObject" Link "GetDiskObject()"} with one exception.
  If its call to @{"GetDiskObject" Link "GetDiskObject()"} fails, this function calls @{"GetDefDiskObject" Link "GetDefDiskObject()"}.
  This is useful when there is no .info file for the icon you are trying
  to get a disk object for.Applications that use workbench application
  windows @{b}MUST@{ub} use this call if they want to handle the user dropping an
  icon (that doesn't have a .info file) on their window.The V2.0 icon
  editor program is an example of a workbench application window that
  uses this call.
SYNOPSIS  @{FG shine}struct@{FG text} @{"DiskObject" Link "include:workbench/workbench.h/Main" 60} *GetDiskObjectNew(@{FG shine}char@{FG text} *);
  @{i}@{b}diskobj@{ub}@{ui} = GetDiskObjectNew(@{i}name@{ui})
   D0                         A0
  @{i}name@{ui} -- name of the object (@{FG shine}char@{FG text} *)
    or NULL if you just want a DiskObject structure allocated for you
    (useful when calling AddAppIcon in workbench.library).
  @{i}@{b}diskobj@{ub}@{ui} -- the Workbench disk object in question
SEE ALSO
  @{"FreeDiskObject()" Link "FreeDiskObject()"}, @{"GetDiskObject()" Link "GetDiskObject()"}, @{"PutDiskObject()" Link "PutDiskObject()"}, @{"DeleteDiskObject()" Link "DeleteDiskObject()"}
@EndNode
@Node "MatchToolValue()" "icon.library/MatchToolValue"
@{b}@{u}MatchToolValue@{uu}@{ub} - check a tool type variable for a particular value.
  MatchToolValue is useful for parsing a tool type value for
  a known value.It knows how to parse the syntax for a tool
  type value (in particular, it knows that '|' separates
  alternate values).Note that the parsing is case insensitive.
SYNOPSIS  BOOL MatchToolValue(@{FG shine}char@{FG text} *, @{FG shine}char@{FG text} *);
  @{i}@{b}result@{ub}@{ui} = MatchToolValue(@{i}typeString@{ui}, @{i}value@{ui})
   D0                      A0           A1
  @{i}typeString@{ui} - a ToolType value (as returned by FindToolType)
  @{i}value@{ui} - you are interested if value appears in typeString
  @{i}@{b}result@{ub}@{ui} - TRUE if the value was in typeString else FALSE.
EXAMPLE
  @{i}Assume there are two type strings@{ui}:
    @{i}type1@{ui} = "text"
    @{i}type2@{ui} = "a|b|c"
  MatchToolValue( @{i}type1@{ui}, "text" ) returns TRUE
  MatchToolValue( @{i}type1@{ui}, "TEXT" ) returns TRUE
  MatchToolValue( @{i}type1@{ui}, "data" ) returns FALSE
  MatchToolValue( @{i}type2@{ui}, "a" ) returns TRUE
  MatchToolValue( @{i}type2@{ui}, "b" ) returns TRUE
  MatchToolValue( @{i}type2@{ui}, "d" ) returns FALSE
  MatchToolValue( @{i}type2@{ui}, "a|b" ) returns FALSE
SEE ALSO
  @{"FindToolType()" Link "FindToolType()"}
@EndNode
@Node "PutDefDiskObject()" "icon.library/PutDefDiskObject"
@{b}@{u}PutDefDiskObject@{uu}@{ub} - write disk object as the default for its type.(V36)
  This routine writes out a DiskObject structure, and its associated
  information.If the call fails, a zero will be returned.The reason
  for the failure may be obtained via @{"IoErr()" Link "dos.guide/IoErr()"}.
  Note that this function calls @{"PutDiskObject" Link "PutDiskObject()"} internally which means
  that this call (if sucessful) notifies workbench that an icon has
  been created/modified.
  Using this routine protects you from any future changes to the way
  default icons are stored within the system.
SYNOPSIS  BOOL PutDefDiskObject(@{FG shine}struct@{FG text} @{"DiskObject" Link "include:workbench/workbench.h/Main" 60} *);
  @{i}@{b}status@{ub}@{ui} = PutDefDiskObject(@{i}diskobj@{ui})
   D0                        A0
  @{i}diskobj@{ui} -- a pointer to a DiskObject
  @{i}@{b}status@{ub}@{ui} -- TRUE if the call succeeded else FALSE
SEE ALSO
  @{"GetDefDiskObject" Link "GetDefDiskObject()"}
@EndNode
@Node "PutDiskObject()" "icon.library/PutDiskObject"
@{b}@{u}PutDiskObject@{uu}@{ub} - write out a DiskObject to disk.
  This routine writes out a DiskObject structure, and its
  associated information.The file name of the info file
  will be the name parameter with a ".info" postpended to it.
  If the call fails, a zero will be returned.The reason for
  the failure may be obtained via @{"IoErr()" Link "dos.guide/IoErr()"}.
  As of release V2.0, PutDiskObject (if successful) notifies workbench
  that an icon has been created/modified.
  Using this routine protects you from any future changes to the way
  icons are stored within the system.
SYNOPSIS  BOOL PutDiskObject(@{FG shine}char@{FG text} *, @{FG shine}struct@{FG text} @{"DiskObject" Link "include:workbench/workbench.h/Main" 60} *);
  @{i}@{b}status@{ub}@{ui} = PutDiskObject(@{i}name@{ui}, @{i}diskobj@{ui})
   D0                     A0     A1
  @{i}name@{ui} -- name of the object (pointer to a character string)
  @{i}diskobj@{ui} -- a pointer to a DiskObject
  @{i}@{b}status@{ub}@{ui} -- TRUE if the call succeeded else FALSE
NOTES
  It is recommended that if you wish to copy an icon from one place
  to another than you use @{"GetDiskObject()" Link "GetDiskObject()"} and PutDiskObject()
  and do not copy them directly.
SEE ALSO
  @{"GetDiskObject()" Link "GetDiskObject()"}, @{"FreeDiskObject()" Link "FreeDiskObject()"}, @{"DeleteDiskObject()" Link "DeleteDiskObject()"}
@EndNode
@Node "ActivateCxObj()" "commodities.library/ActivateCxObj"
@{b}@{u}ActivateCxObj@{uu}@{ub} -- change the activation state of a commodity object.(V36)
  Commodity objects of all types maintain an activation state.
  If an object is "active", then it performs its particular action
  whenever a commodity message arrives.If the object is "inactive"
  no action is taken, and the message goes on to its next destination.
  All objects are created in the "active" state except brokers
  which are created "inactive".Thus, after you create your
  broker and hang a tree of objects off of it, you must remember
  to use this function to activate it.This causes it to divert all
  messages to your tree of objects.
  This function activates 'co' if 'true' is different than 0.and
  deactivates it otherwise.The previous activation state is returned.
SYNOPSIS  @{FG shine}long@{FG text} ActivateCxObj(CxObj *,@{FG shine}long@{FG text});
  @{i}@{b}previous@{ub}@{ui} = ActivateCxObj(@{i}co@{ui},@{i}true@{ui});
   D0                       A0  D0
  @{i}co@{ui} - the commodity object to affect (may be NULL)
  @{i}true@{ui} - 0 to deactivate the object, anything else to activate it
  @{i}@{b}previous@{ub}@{ui} - the previous activation state: 0 if the object was inactive
    or if 'co' was NULL, anything else if the object was active
SEE ALSO
  @{"CxBroker()" Link "CxBroker()"}
@EndNode
@Node "AddIEvents()" "commodities.library/AddIEvents"
@{b}@{u}AddIEvents@{uu}@{ub} -- add input events to commodities' input stream.(V36)
  This function adds a null-terminated linked list of input events to
  the input stream processed by commodities.It is a touch easier than
  using the input device directly.
  The contents of the input events are copied into commodity messages,
  so they may be disposed of as soon as this call returns.
  The messages are initially routed to the first broker in
  commodities' object list.
SYNOPSIS  @{FG shine}void@{FG text} AddIEvents(@{FG shine}struct@{FG text} @{"InputEvent" Link "include:devices/inputevent.h/Main" 255} *);
  AddIEvents(@{i}events@{ui})
              A0
  @{i}events@{ui} - the list of input events to add (may be NULL)
WARNING
  The @{"cx_lib/InvertString()" Link "amiga_lib.guide/InvertString()"} function creates lists of input events that
  are in reverse order.Thus, passing the result of @{"InvertString()" Link "amiga_lib.guide/InvertString()"}
  to this function will insert a series of input events that will
  generate a string that's a mirror image of the string passed to
  @{"InvertString()" Link "amiga_lib.guide/InvertString()"} originally.
  The solution to the above is to either flip the string before
  passing it to @{"InvertString()" Link "amiga_lib.guide/InvertString()"}, or flip the resulting list of input events.
BUGS
  Prior to V40, this function did not copy the data pointed to by
  ie_EventAddress for any events of type @{i}IECLASS_NEWPOINTERPOS@{ui}.
SEE ALSO
  @{"cx_lib/FreeIEvents()" Link "amiga_lib.guide/FreeIEvents()"}
@EndNode
@Node "AttachCxObj()" "commodities.library/AttachCxObj"
@{b}@{u}AttachCxObj@{uu}@{ub} -- attach a commodity object to the end of an existing
  list of objects.(V36)
  Adds 'co' to the list of objects pointed to by 'headObj'.The
  new object is added at the end of the list.
SYNOPSIS  @{FG shine}void@{FG text} AttachCxObj(CxObj *,CxObj *);
  AttachCxObj(@{i}headObj@{ui},@{i}co@{ui});
               A0      A1
  @{i}headObj@{ui} - pointer to a list of objects.
    If this value is NULL, then the entire tree of objects pointed to by 'co'
    is deleted and becomes invalid.
  @{i}co@{ui} - the object to add to the list (may be NULL)
    If 'co' is NULL, this function will record that fact in the
    internal accumulated error of 'headObj'.This error record
    can be retrieved using @{"CxObjError()" Link "CxObjError()"} and cleared using
    @{"ClearCxObjError()" Link "ClearCxObjError()"}.
BUGS
  Until V38, passing a NULL 'headObj' parameter would cause low-memory
  access and unpredictable results.
SEE ALSO
  @{"CxObjError()" Link "CxObjError()"}, @{"ClearCxObjError()" Link "ClearCxObjError()"}
@EndNode
@Node "ClearCxObjError()" "commodities.library/ClearCxObjError"
@{b}@{u}ClearCxObjError@{uu}@{ub} -- clear the accumulated error value of a commodity object.(V36)
  This function clears the accumulated error value of commodity object 'co'.
  It is unwise to do this to a filter if @{i}COERR_BADFILTER@{ui} is set.
  This will fool commodities into thinking the filter is OK.Set
  another valid filter, or leave the error value alone.
SYNOPSIS  @{FG shine}void@{FG text} ClearCxObjError(CxObj *);
  ClearCxObjError(co);
                   A0
  @{i}co@{ui} - the object to affect (may be NULL)
SEE ALSO
  @{"CxObjError()" Link "CxObjError()"}
@EndNode
@Node "CreateCxObj()" "commodities.library/CreateCxObj"
@{b}@{u}CreateCxObj@{uu}@{ub} -- create a new commodity object.(V36)
  This function creates a commodity object of type 'type'.It is not
  proper to call this function directly.Each object creation routine
  except @{"CxBroker()" Link "CxBroker()"} is defined as a macro in @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}
  These are independently documented.
  All functions which operate on a commodity object are made with
  a reference to the thirty-two bit value returned by this function
  (or by @{"CxBroker()" Link "CxBroker()"}).
SYNOPSIS  CxObj *CreateCxObj(ULONG,@{FG shine}long@{FG text},@{FG shine}long@{FG text});
  @{i}@{b}co@{ub}@{ui} = CreateCxObj(@{i}type@{ui},@{i}arg1@{ui},@{i}arg2@{ui});
   D0               D0    A0   A1
  @{i}type@{ui} - the type of object to create as defined in @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}
  @{i}arg1@{ui} - first argument, meaning depends on 'type'
  @{i}arg2@{ui} - second argument, meaning depends on 'type'
  @{i}@{b}co@{ub}@{ui} - a pointer to the new object or NULL if it could not be created.
    A NULL return indicates typically a lack of system memory.Minor
    problems in creating an object, such as providing a bad filter
    description to @{"cx_lib/CxFilter()" Link "amiga_lib.guide/CxFilter()"}, typically don't cause failure,
    but are recorded in an internal error field in the new object
    which can be accessed via @{"CxObjError()" Link "CxObjError()"}.
SEE ALSO
  @{"CxObjError()" Link "CxObjError()"}, @{"cx_lib/CxFilter()" Link "amiga_lib.guide/CxFilter()"}, @{"cx_lib/CxSender()" Link "amiga_lib.guide/CxSender()"},
  @{"cx_lib/CxSignal()" Link "amiga_lib.guide/CxSignal()"}, @{"cx_lib/CxTranslate()" Link "amiga_lib.guide/CxTranslate()"}, @{"cx_lib/CxDebug()" Link "amiga_lib.guide/CxDebug()"},
  @{"cx_lib/CxCustom()" Link "amiga_lib.guide/CxCustom()"}, @{"CxBroker()" Link "CxBroker()"}
@EndNode
@Node "CxBroker()" "commodities.library/CxBroker"
@{b}@{u}CxBroker@{uu}@{ub} -- create a commodity broker.(V36)
  This function creates a broker from the specification found in the
  NewBroker structure pointed to by 'nb'.The purpose and meaning of the
  fields of the NewBroker structure are described below.Also see
  @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0} for more info.
SYNOPSIS  CxObj *CxBroker(@{FG shine}struct@{FG text} NewBroker *,@{FG shine}long@{FG text} *);
  @{i}@{b}broker@{ub}@{ui} = CxBroker(@{i}nb@{ui},@{i}error@{ui});
   D0                A0 D0
  @{i}nb@{ui} - an initialized @{"NewBroker structure" link CXBROKER_NEWBROKER}
  @{i}error@{ui} - a pointer to a longword where to store a failure code (may be NULL)
  @{i}@{b}broker@{ub}@{ui} - a pointer to the broker object or NULL upon failure.
    If the 'error' pointer is not NULL, a further diagnostic code is
    placed at that address.
    @{i}Error codes are defined in@{ui} @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0} @{i}and include@{ui}:
    @{b}CBERR_OK@{ub} - No problems; broker created OK.
    @{b}CBERR_SYSERR@{ub} - System problems, not your fault, sign of low memory.
    @{b}CBERR_DUP@{ub} - The @{i}nb_Unique@{ui} field specified that only one broker of
      '@{i}nb_Name@{ui}' should be allowed, and one already exists.
    @{b}CBERR_VERSION@{ub} - The version specified in '@{i}nb_Version@{ui}' is unknown
      to the library.
SEE ALSO
  @{"SetCxObjPri()" Link "SetCxObjPri()"}, @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}
@EndNode
@node CXBROKER_NEWBROKER "CxBroker_NewBroker"
@{FG shine}struct@{FG text} @{"NewBroker" Link "include:libraries/commodities.h/Main" 40}
{
  BYTE             @{i}nb_Version@{ui};
  STRPTR           @{i}nb_Name@{ui};
  STRPTR           @{i}nb_Title@{ui};
  STRPTR           @{i}nb_Descr@{ui};
  WORD             @{i}nb_Unique@{ui};
  WORD             @{i}nb_Flags@{ui};
  BYTE             @{i}nb_Pri@{ui};
  @{FG shine}struct@{FG text} @{"MsgPort" Link "include:exec/ports.h/Main" 28} *@{i}nb_Port@{ui};
  WORD             @{i}nb_ReservedChannel@{ui};
};
@{b}nb_Version@{ub} - This is the way that future versions of commodities can identify
  which version of the NewBroker structure you are using.This should be
  set to @{i}NB_VERSION@{ui} as defined in @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}
@{b}nb_Name@{ub} - This is the name of the broker.This name is used to find the broker
  in commodities' object list and is the name shown in the listview
  gadget of the Exchange program.The name string is copied in the
  broker object upon creation so it can be discarded right after
  CxBroker() returns.The maximum length of the name string is defined
  by a constant in @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}.
@{b}nb_Title@{ub}, @{b}nb_Descr@{ub} - These are two strings which appear to the user in the
  Exchange program and describe the application the broker is representing.
  Note that these strings are copied into the broker object so they
  can be discarded right after CxBroker() returns.The maximum length
  of these strings that will be recognized are defined by constants in
  @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}.
@{b}nb_Unique@{ub} - This field indicates what should happen if a broker of the
  same name (@{i}nb_Name@{ui}) already exists in commodities' object list.
  Constants in @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0} allow the caller to specify whether
  another broker is to be created, and whether any existing broker of
  the same name should be notified that an attempt at creating a
  duplicate has been made.
@{b}nb_Pri@{ub} - This specifies with what priority the new broker is to be inserted
  within commodities' object list.Higher priority nodes appear
  earlier in a list.It is strongly recommended that the ToolTypes
  environment of an application be used to allow the end-user to set
  the priority of the broker.
@endnode
@Node "CxMsgData()" "commodities.library/CxMsgData"
@{b}@{u}CxMsgData@{uu}@{ub} -- obtain a pointer to a commodity message's data area.(V36)
  Most commodity messages contain meaningful data such as an @{"InputEvent" Link "include:devices/inputevent.h/Main" 255}
  structure.This function returns a pointer to this data.
  You may get a commodity message from a synchronous (custom object) or
  asynchronous (sender object) source.In the second case, 'data' is
  not valid after you have replied to the message.
SYNOPSIS  APTR CxMsgData(@{FG shine}struct@{FG text} CxMsg *);
  @{i}@{b}data@{ub}@{ui} = CxMsgData(@{i}cxm@{ui});
   D0               A0
  @{i}cxm@{ui} - the commodity message to get the data pointer from (may be NULL)
  @{i}@{b}data@{ub}@{ui} - a pointer to the message's data, or NULL if 'cxm' is NULL.
    The meaning of the data varies depending on which kind of
    object is being inspected.
BUGS
  Until V38, passing a NULL 'cxm' parameter would cause low-memory
  access and unpredictable results.
  Until @{b}V40@{ub}, whenever the data pointer is a (@{FG shine}struct@{FG text} InputEvent), the
  ie_EventAddress field of these structures was not reliable whenever
  the message was generated by a sender object.
SEE ALSO
  @{"cx_lib/CxSender()" Link "amiga_lib.guide/CxSender()"}, @{"cx_lib/CxCustom()" Link "amiga_lib.guide/CxCustom()"}
@EndNode
@Node "CxMsgID()" "commodities.library/CxMsgID"
@{b}@{u}CxMsgID@{uu}@{ub} -- obtain the ID of a commodity message.(V36)
  This function returns the value associated with the cause or source
  of the commodity message 'cxm'.Values are provided by the application
  when a sender or custom object is created.
SYNOPSIS  @{FG shine}long@{FG text} CxMsgID(@{FG shine}struct@{FG text} CxMsg *);
  @{i}@{b}id@{ub}@{ui} = CxMsgID(@{i}cxm@{ui});
   D0           A0
  @{i}cxm@{ui} - the commodity message to inquire about (must @{b}NOT@{ub} be NULL)
  @{i}@{b}id@{ub}@{ui} - if not specified by the application, the ID value of a
    commodity message will be 0.It is suggested that using
    non-zero values in your program as a rule may identify
    some possible errors.
SEE ALSO
  @{"cx_lib/CxSender()" Link "amiga_lib.guide/CxSender()"}, @{"cx_lib/CxCustom()" Link "amiga_lib.guide/CxCustom()"}
@EndNode
@Node "CxMsgType()" "commodities.library/CxMsgType"
@{b}@{u}CxMsgType@{uu}@{ub} -- obtain the type of a commodity message.(V36)
  This function returns the type of a commodity message.Possible values
  of 'type' are defined in @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}.Most commodity
  messages are of type @{i}CXM_IEVENT@{ui}.
SYNOPSIS  ULONG CxMsgType(@{FG shine}struct@{FG text} CxMsg *);
  @{i}@{b}type@{ub}@{ui} = CxMsgType(@{i}cxm@{ui});
   D0               A0
  @{i}cxm@{ui} - the commodity message to inquire about (must @{b}NOT@{ub} be NULL)
  @{i}@{b}type@{ub}@{ui} - the type of the commodity message, possible values are defined
    in @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}
@EndNode
@Node "CxObjError()" "commodities.library/CxObjError"
@{b}@{u}CxObjError@{uu}@{ub} -- obtain a commodity object's accumulated error.(V36)
  When a function acting on an object fails, it records the failure
  in the object.This function returns the accumulated error value.
  The values are represented by flag bits defined in
  @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}.Several errors may be recorded by multiple
  bits in 'error'.
SYNOPSIS  @{FG shine}long@{FG text} CxObjError(CxObj *);
  @{i}@{b}error@{ub}@{ui} = CxObjError(@{i}co@{ui});
   D0                 A0
  @{i}co@{ui} - the commodity object to get the accumulated error from (may be NULL)
  @{i}@{b}error@{ub}@{ui} - the accumulated error, or 0 if 'co' is NULL
    @{"errors" link CXOBJERROR_ERRORS}
SEE ALSO
  @{"SetFilter()" Link "SetFilter()"}, @{"SetFilterIX()" Link "SetFilterIX()"}, @{"AttachCxObj()" Link "AttachCxObj()"}, @{"ActivateCxObj()" Link "ActivateCxObj()"},
  @{"ClearCxObjError()" Link "ClearCxObjError()"}
@EndNode
@node CXOBJERROR_ERRORS "CxObjError_errors"
@{b}COERR_ISNULL@{ub} - The value of parameter 'co' was in fact NULL.
  This error means "the problem with the object you inquire about is
  that it failed to be created."
@{b}COERR_NULLATTACH@{ub} - Using the commodities' list manipulation functions,
  an attempt was made to add a NULL object to the list belonging to 'co'.
  @{i}This allows a line of code as follows to exist in an error-tolerant program@{ui}:
    AttachCxObj(@{i}filter@{ui},CxSender(@{i}myport@{ui},MY_ID));
@{b}COERR_BADFILTER@{ub} - The most recent filter specification for a filter object
  was faulty.This happens if no sense can be made out of a
  description string, or if an input expression (IX) has an
  invalid format or version byte.When this bit is set in a
  filter's error field, the filter will match nothing, but this
  is not the proper way to "turn off" a filter, use @{"ActivateCxObj()" Link "ActivateCxObj()"}.
@{b}COERR_BADTYPE@{ub} - A type specific operation, such as @{"SetFilterIX()" Link "SetFilterIX()"}, was called
  for object 'co', but 'co' isn't of the proper type.
@endnode
@Node "CxObjType()" "commodities.library/CxObjType"
@{b}@{u}CxObjType@{uu}@{ub} -- obtain the type of a commodity object.(V36)
  This function should not really be necessary.It returns
  the type of a commodity object, which you should already
  know, since you created it in the first place.
SYNOPSIS  ULONG CxObjType(CxObj *);
  @{i}@{b}type@{ub}@{ui} = CxObjType(@{i}co@{ui});
   D0               A0
  @{i}co@{ui} - the commodity object to inquire about (may be NULL)
  @{i}@{b}type@{ub}@{ui} - the type of the commodity object, possible values are
    defined in @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}.
    Returns @{i}CX_INVALID@{ui} if 'co' is NULL.
SEE ALSO
  @{"CreateCxObj()" Link "CreateCxObj()"}
@EndNode
@Node "DeleteCxObj()" "commodities.library/DeleteCxObj"
@{b}@{u}DeleteCxObj@{uu}@{ub} -- delete a commmodity object.(V36)
  Deletes a commodity object of any type.If the object
  is linked into a list, it is first removed.Note that
  the handle 'co' is invalid after this function is called.
  Also note that deleting an object which has other objects attached
  to it may be undesirable.Use the function @{"DeleteCxObjAll()" Link "DeleteCxObjAll()"}
  to delete an entire sub-tree of objects.
SYNOPSIS  @{FG shine}void@{FG text} DeleteCxObj(CxObj *);
  DeleteCxObj(@{i}co@{ui});
               A0
  @{i}co@{ui} - the commodity object to delete (may be NULL)
SEE ALSO
  @{"DeleteCxObjAll()" Link "DeleteCxObjAll()"}
@EndNode
@Node "DeleteCxObjAll()" "commodities.library/DeleteCxObjAll"
@{b}@{u}DeleteCxObjAll@{uu}@{ub} -- recursively delete a tree of commodity objects.(V36)
  This function deletes the commodity object 'co', and
  recursively deletes all objects attached to it, and the
  objects attached to them, etc.
  If 'co' is linked into a list, it is first removed.Note
  that the handle 'co' is invalid after this function is called.
  This function is useful when an application exits: most
  applications can clean up completely by deleting the
  entire sub-tree of objects starting at their broker.
SYNOPSIS  @{FG shine}void@{FG text} DeleteCxObjAll(CxObj *);
  DeleteCxObjAll(@{i}co@{ui});
                  A0
  @{i}co@{ui} - the first commodity object to delete (may be NULL)
SEE ALSO
  @{"DeleteCxObj()" Link "DeleteCxObj()"}
@EndNode
@Node "DisposeCxMsg()" "commodities.library/DisposeCxMsg"
@{b}@{u}DisposeCxMsg@{uu}@{ub} -- delete a commodity message.(V36)
  This function eliminates the commodity message pointed to by 'cxm'.
  Can be used to 'swallow' input events by disposing of every commodity
  message of type @{i}CXM_IEVENT@{ui}.
  This function can only be called from within a custom object running
  on the input handler's context.It cannot be called from code running
  on a commodities' context, such as when receiving a @{i}CXM_IEVENT@{ui} message
  from a sender object.CxMsg sent to a commodity program from a sender
  object must be sent back using @{"ReplyMsg()" Link "exec.guide/ReplyMsg()"}.
SYNOPSIS  @{FG shine}void@{FG text} DisposeCxMsg(@{FG shine}struct@{FG text} CxMsg *);
  DisposeCxMsg(@{i}cxm@{ui});
                A0
  @{i}cxm@{ui} - the commodity message to delete (must @{b}NOT@{ub} be NULL)
@EndNode
@Node "DivertCxMsg()" "commodities.library/DivertCxMsg"
@{b}@{u}DivertCxMsg@{uu}@{ub} -- send a commodity message down an object list.(V36)
  This function sends the commodity message 'cxm' down the list of
  objects attached to 'headObj'.The pointer 'returnObj' is first
  pushed onto the routing stack of 'cxm' so that when the end of the
  list of 'headObj' is reached the SUCCESSOR of 'returnObj' is the
  next destination.
  For example, when a filter finds a match with a message, the
  message is diverted down the filter's list like this:
    DivertCxMsg(cxm,filter,filter);
SYNOPSIS  @{FG shine}void@{FG text} DivertCxMsg(@{FG shine}struct@{FG text} CxMsg *,CxObj *,CxObj *);
  DivertCxMsg(@{i}cxm@{ui},@{i}headObj@{ui},@{i}returnObj@{ui});
               A0  A1       A2
  @{i}cxm@{ui} - the commodity message to divert (must @{b}NOT@{ub} be NULL)
  @{i}headObj@{ui} - the list of objects to divert the message to
  @{i}returnObj@{ui} - the object to use as a place holder
SEE ALSO
  @{"RouteCxMsg()" Link "RouteCxMsg()"}
@EndNode
@Node "EnqueueCxObj()" "commodities.library/EnqueueCxObj"
@{b}@{u}EnqueueCxObj@{uu}@{ub} -- insert a commodity object within a list of objects.
  This function puts object 'co' into the list of object 'headObj'.
  The insertion point is determined by the object's priority.The
  objects are kept in the list from the highest priority to the
  lowest.New nodes are inserted in front of the first node with a
  lower priority.Hence a FIFO queue for nodes of equal priority.
  The priority of the commodity object can be set using @{"SetCxObjPri()" Link "SetCxObjPri()"}.
  based on object priority.(V36)
SYNOPSIS  @{FG shine}void@{FG text} EnqueueCxObj(CxObj *,CxObj *);
  EnqueueCxObj(@{i}headObj@{ui},@{i}co@{ui});
                A0      A1
  @{i}headObj@{ui} - pointer to a list of objects.
    If this value is NULL, then the entire tree of objects pointed to
    by 'co' is deleted and becomes invalid.
  @{i}co@{ui} - the object to add to the list (may be NULL)
NOTE
  If 'co' is NULL, this function will record that fact in the
  internal accumulated error of 'headObj'.This error record
  can be retrieved using @{"CxObjError()" Link "CxObjError()"} and cleared using @{"ClearCxObjError()" Link "ClearCxObjError()"}.
BUGS
  Until V38, passing a NULL 'headObj' parameter would cause low-memory
  access and unpredictable results.
SEE ALSO
  @{"SetCxObjPri()" Link "SetCxObjPri()"}, @{"CxObjError()" Link "CxObjError()"}, @{"ClearCxObjError()" Link "ClearCxObjError()"}
@EndNode
@Node "InsertCxObj()" "commodities.library/InsertCxObj"
@{b}@{u}InsertCxObj@{uu}@{ub} -- insert a commodity object in a list after a given object.(V36)
  Adds 'co' to the list of objects pointed to by 'headObj' after object 'pred'.
SYNOPSIS  @{FG shine}void@{FG text} InsertCxObj(CxObj *,CxObj *,CxObj *);
  InsertCxObj(@{i}headObj@{ui},@{i}co@{ui},@{i}pred@{ui});
               A0      A1 A2
  @{i}headObj@{ui} - pointer to a list of objects.
    If this value is NULL, then the entire tree of objects pointed to
    by 'co' is deleted and becomes invalid.
  @{i}co@{ui} - the object to add to the list (may be NULL)
  @{i}pred@{ui} - the object after which 'co' should be inserted.
    If this is NULL then 'co' is added to the head of the list.
NOTE
  If 'co' is NULL, this function will record that fact in the
  internal accumulated error of 'headObj'.This error record
  can be retrieved using @{"CxObjError()" Link "CxObjError()"} and cleared using @{"ClearCxObjError()" Link "ClearCxObjError()"}.
BUGS
  Until V38, passing a NULL 'headObj' parameter would cause low-memory
  access and unpredictable results.
SEE ALSO
  @{"CxObjError()" Link "CxObjError()"}, @{"ClearCxObjError()" Link "ClearCxObjError()"}
@EndNode

@Node "InvertKeyMap()" "commodities.library/InvertKeyMap"
@{b}@{u}InvertKeyMap@{uu}@{ub} -- generate an input event from an ANSI code.(V36)
  This function uses the system call @{"MapANSI()" Link "ROMlibs.guide/MapANSI()"} to figure out what
  InputEvent translates to an ANSI character code 'ansiCode'.The
  InputEvent pointed to by 'event' is filled in with that information.
  The KeyMap 'km' is used for the translation, unless it is NULL, in
  which case the current system default keymap is used.
SYNOPSIS  BOOL InvertKeyMap(ULONG,@{FG shine}struct@{FG text} @{"InputEvent" Link "include:devices/inputevent.h/Main" 255} *,@{FG shine}struct@{FG text} @{"KeyMap" Link "include:devices/keymap.h/Main" 21} *);
  @{i}@{b}success@{ub}@{ui} = InvertKeyMap(@{i}ansiCode@{ui},@{i}event@{ui},@{i}km@{ui})
   D0                     D0       A0     A1
  @{i}ansiCode@{ui} - the ANSI code to convert to an input event
  @{i}event@{ui} - the InputEvent to fill-in
  @{i}km@{ui} - the keymap to use for the translation,
    or NULL to use the current system default keymap.
  @{i}@{b}success@{ub}@{ui} - TRUE if the translation worked, FALSE otherwise.
BUGS
  This function currently handles one-deep dead keys (such as
  <alt f>o ).It does not look up the high key map (keystrokes
  with scan codes greater than 0x40).
  Prior to @{b}V40@{ub}, this function was not initializing the @{i}ie_SubClass@{ui}
  and @{i}ie_TimeStamp@{ui} fields of the InputEvent structure.A simple work
  around to the problem is to clear these values to 0 before making
  a call to this function:
    @{FG shine}struct@{FG text} InputEvent @{i}ie@{ui};
      ie.@{i}ie_SubClass@{ui}           = 0;
      ie.ie_TimeStamp.@{i}tv_secs@{ui}  = 0;
      ie.ie_TimeStamp.@{i}tv_micro@{ui} = 0;
    @{FG shine}if@{FG text} (InvertKeyMap(@{i}ansiCode@{ui},@{i}&ie@{ui},NULL))
      ...
SEE ALSO
  @{"cx_lib/InvertString()" Link "amiga_lib.guide/InvertString()"}
@EndNode
@Node "MatchIX()" "commodities.library/MatchIX"
@{b}@{u}MatchIX@{uu}@{ub} -- see if an input event matches an initialized input expression.(V38)
  This function determines whether an input event matches an
  initialized input expression.Applications generally do not
  need to call this function as filter objects will normally provide
  all the event filtering needed.Nevertheless, MatchIX()
  can come in handy as it is the same function used to match an
  event to the various filter objects when an event makes its way
  through the input network.
SYNOPSIS  BOOL MatchIX(@{FG shine}struct@{FG text} @{"InputEvent" Link "include:devices/inputevent.h/Main" 255} *,IX *);
  @{i}@{b}match@{ub}@{ui} = MatchIX(@{i}event@{ui},@{i}ix@{ui});
   D0              A0     A1
  @{i}event@{ui} - the input event to match against the input expression
  @{i}ix@{ui} - the input expression for the comparison
  @{i}@{b}match@{ub}@{ui} - TRUE if the input event matches the input expression,
    or FALSE if not
SEE ALSO
  @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}, @{"ParseIX()" Link "ParseIX()"}
@EndNode
@Node "ParseIX()" "commodities.library/ParseIX"
@{b}@{u}ParseIX@{uu}@{ub} -- initialize an input expression given a description string.(V36)
  Given an input description string and an allocated input
  expression, sets the fields of the input expression to
  correspond to the description string.
SYNOPSIS  @{FG shine}long@{FG text} ParseIX(STRPTR,IX *);
  @{i}@{b}failureCode@{ub}@{ui} = ParseIX(@{i}description@{ui},@{i}ix@{ui});
   D0                    A0           A1
  @{i}description@{ui} - the string to parse
  @{i}ix@{ui} - the input expression to hold the result of the parse
  @{i}@{b}failureCode@{ub}@{ui} -  0 if all went well,
    -1 if tokens after end (code spec)
    -2 if 'description' was NULL
SEE ALSO
  @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}, @{"MatchIX()" Link "MatchIX()"}
@EndNode
@Node "RemoveCxObj()" "commodities.library/RemoveCxObj"
@{b}@{u}RemoveCxObj@{uu}@{ub} -- remove a commodity object from a list.(V36)
  This function removes 'co' from any list it may be a part of.
  Will not crash if 'co' is NULL, or if it has not been inserted
  in a list.
SYNOPSIS  @{FG shine}void@{FG text} RemoveCxObj(CxObj *);
  RemoveCxObj(@{i}co@{ui});
               A0
  @{i}co@{ui} - the object to remove (may be NULL)
SEE ALSO
  @{"AttachCxObj()" Link "AttachCxObj()"}, @{"EnqueueCxObj()" Link "EnqueueCxObj()"}, @{"InsertCxObj()" Link "InsertCxObj()"}
@EndNode
@Node "RouteCxMsg()" "commodities.library/RouteCxMsg"
@{b}@{u}RouteCxMsg@{uu}@{ub} -- set the next destination of a commodity message.(V36)
  Establishes the next destination of a commodity message
  to be 'co', which must be a valid commodity object, and
  must be linked in ultimately to commodities' object list.
  Routing of an object is analogous to a 'goto' in a program.
  There is no effect on the message's routing stack.
SYNOPSIS  @{FG shine}void@{FG text} RouteCxMsg(@{FG shine}struct@{FG text} CxMsg *,CxObj *);
  RouteCxMsg(@{i}cxm@{ui},@{i}co@{ui});
              A0  A1
  @{i}cxm@{ui} - the commodity message to route (must @{b}NOT@{ub} be NULL)
  @{i}co@{ui} - the commodity object to route the message to (must @{b}NOT@{ub} be NULL)
SEE ALSO
  @{"DivertCxMsg()" Link "DivertCxMsg()"}
@EndNode
@Node "SetCxObjPri()" "commodities.library/SetCxObjPri"
@{b}@{u}SetCxObjPri@{uu}@{ub} -- set the priority of a commodity object.(V36)
  This function sets the priority of a commodity object for the
  purposes of @{"EnqueueCxObj()" Link "EnqueueCxObj()"}.
  It is strongly recommended that the ToolTypes environment be
  utilized to provide end-user control over the priority of
  brokers, but application specific ordering of other objects
  within their lists is not dictated.
SYNOPSIS  @{FG shine}long@{FG text} SetCxObjPri(CxObj *,@{FG shine}long@{FG text});
  @{i}@{b}oldPri@{ub}@{ui} = SetCxObjPri(@{i}co@{ui},@{i}pri@{ui})
   D0                   A0 D0
  @{i}co@{ui} - the commodity object to affect (may be NULL)
  @{i}pri@{ui} - the object's new priority in the range -128 to +127.
    A value of 0 is normal.
  @{i}@{b}oldPri@{ub}@{ui} - the previous priority of the object or 0 if 'co' was NULL.
     This value is only returned in V38 and beyond.
BUGS
  This function will not reposition an object within its list when
  its priority changes.To attain the same effect, first remove the
  object from its list using @{"RemoveCxObj()" Link "RemoveCxObj()"}, set its priority using
  SetCxObjPri(), and reinsert it in the list using @{"EnqueueCxObj()" Link "EnqueueCxObj()"}.
SEE ALSO
  @{"EnqueueCxObj()" Link "EnqueueCxObj()"}
@EndNode
@Node "SetFilter()" "commodities.library/SetFilter"
@{b}@{u}SetFilter@{uu}@{ub} -- change the matching condition of a commodity filter.(V36)
  This function changes the matching condition of a commodity input
  filter to that described by the input description string 'text'.
SYNOPSIS  @{FG shine}void@{FG text} SetFilter(CxObj *,STRPTR);
  SetFilter(@{i}filter@{ui},@{i}text@{ui});
             A0     A1
  @{i}filter@{ui} - the filter object to affect (may be NULL)
  @{i}text@{ui} - the new matching conditions for the filter
NOTE
  The internal error of 'filter' will have the @{i}COERR_BADFILTER@{ui}
  bit set or cleared depending on the failure or success of this
  function.
SEE ALSO
  @{"SetFilterIX()" Link "SetFilterIX()"}, @{"CxObjError()" Link "CxObjError()"}
@EndNode
@Node "SetFilterIX()" "commodities.library/SetFilterIX"
@{b}@{u}SetFilterIX@{uu}@{ub} -- change the matching condition of a commodity filter.(V36)
  This function changes the matching condition of a commodity input
  filter to that described by the binary input expression pointed by 'ix'.
  Input expressions are defined in @{"<libraries/commodities.h>" Link "include:libraries/commodities.h/Main" 0}.
  It is important to remember that the first field of the input
  expression structure must indicate which version of the
  input expression structure is being used.
SYNOPSIS  @{FG shine}void@{FG text} SetFilterIX(CxObj *,IX *);
  SetFilterIX(@{i}filter@{ui},@{i}ix@{ui});
               A0     A1
  @{i}filter@{ui} - the filter object to affect (may be NULL)
  @{i}ix@{ui} - the new matching conditions for the filter
NOTE
  The internal error of 'filter' will have the @{i}COERR_BADFILTER@{ui}
  bit set or cleared depending on the failure or success of this
  function.
SEE ALSO
  @{"SetFilter()" Link "SetFilter()"}, @{"CxObjError()" Link "CxObjError()"}
@EndNode
@Node "SetTranslate()" "commodities.library/SetTranslate"
@{b}@{u}SetTranslate@{uu}@{ub} -- replace a translator object's translation list.(V36)
  This function replaces the translation list of a commodity
  translator object with the linked list starting at 'events'.
  A NULL value for 'events' indicates that the object 'translator'
  should swallow all commodity messages that are sent its way.
  Note that the input events are not copied into commodities' private
  memory, but the value of 'events' is used -- asynchronously to the
  application program -- to find a chain of InputEvents in the
  application's data space.At the time of translation, each input event
  is copied into its own new commodity message.
  The above means that no other commodities' user, nor commodities.library
  itself will be modifying your list of InputEvents.On the other hand,
  your program must not corrupt the input event chain that has been
  presented to a translator.
SYNOPSIS  @{FG shine}void@{FG text} SetTranslate(CxObj *,@{FG shine}struct@{FG text} @{"InputEvent" Link "include:devices/inputevent.h/Main" 255} *);
  SetTranslate(@{i}translator@{ui},@{i}events@{ui});
                A0         A1
  @{i}translator@{ui} - the translator object to affect (may be NULL)
  @{i}events@{ui} - the new input event translation list
BUGS
  The list of input events manipulated by a translator object is
  inserted in reverse order in the commodities network, and come out
  of the network in reverse order as well.The @{"cx_lib/InvertString()" Link "amiga_lib.guide/InvertString()"}
  function creates lists of input events that are in reverse order so
  they can be used directly with translator objects.
SEE ALSO
  @{"<devices/inputevent.h>" Link "include:devices/inputevent.h/Main" 0}, @{"cx_lib/CxTranslate()" Link "amiga_lib.guide/CxTranslate()"}
@EndNode
