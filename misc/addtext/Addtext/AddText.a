
*****************************************************************************
* Project Details                                                           *
* ---------------                                                           *
* Project Name:    ADDTEXT                                                  *
* Project Version: 1                                                        *
* Copyright:       A N Peck                                                 *
* Date:            Wednesday 22nd February 1995                             *
*                                                                           *
* Contact:                                                                  *
* 68 Woralul ST                                                             *
* Waramanga ACT 2611                                                        *
* AUSTRALIA                                                                 *
*                                                                           *
* E-mail: Anthony.Peck@Radford.act.edu.au                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* File Summary:                                                             *
* ------------                                                              *
* Assembly version of Addtext                                               *
*                                                                           *
* Thanx to the following software and authors/publishers:                   *
*                                                                           *
* Phxass/Phxlnk - F.Wille                                                   *
* EdWordPro - M. Reddy                                                      *
* S-Text - C. Wyndham                                                       *
* S-Exec - C. Wyndham                                                       *
* Hextract - C. Wyndham                                                     *
* Makeicon - R. Lang                                                        *
* DevPac - HiSoft                                                           *
* DPaint - Electronic Arts                                                  *
* Convbrush - D. Kinder                                                     *
* RevHead - D.M. Balean                                                     *
* Zap - T. Rossi                                                            *
* ADis - M. Apel                                                            *
* FastWindows - R. Plant                                                    *
* Memon - D. Ekholm                                                         *
* PictSaver - P. Nielson                                                    *
*                                                                           *
* 1875 lines in 2.53 sec = 44466 lines/min.                                 *
* Global symbols: 184                                                       *
* Local symbols:  34                                                        *
* Code:   1 section(s)    3487 bytes                                        *
* Data:   1 section(s)    4336 bytes                                        *
* BSS:    none                                                              *
*                                                                           *
* Thanx to my bestest friend and loyal supporter Kym.  She makes great      *
* coffee and even better kids!                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* Date        Time         Version                                          *
*                                                                           *
* 01-Jan-1995 18.55.42.14  2                                                *
* First coding.                                                             *
*                                                                           *
* 01-Jan-1995 19.58.29.05  2                                                *
* Changed window definitions.                                               *
*                                                                           *
* 02-Jan-1995 14.12.51.01  2                                                *
* Added "Generate" gadget and cleaned up some labelling.                    *
*                                                                           *
* 02-Jan-1995 22.41.12.01  2                                                *
* Optimised window routines for backwards compatibility.                    *
*                                                                           *
* 03-Jan-1995 22.47.59.16  2                                                *
* Corrected fault in program timing.  Added credits window and gadget.      *
*                                                                           *
* 04-Jan-1995 13.18.53.22  2                                                *
* Updated window definitions to include gadget activation and immediate     *
* window activation.  Changed window loop to include gadget branching.      *
*                                                                           *
* 04-Jan-1995 20.48.40.47  2                                                *
* Rewrote loops and message handlers.  Gave into using includes so rewrote  *
* library opening routines and exec calls.                                  *
*                                                                           *
* 04-Jan-1995 21.43.51.31  2                                                *
* Added Infile, Outfile and Option Gadgets.                                 *
*                                                                           *
* 10-Jan-1995 13.23.43.36  2                                                *
* Changed message loops to catch gadget IDCMP messages.  Altered credits    *
* brush and data file.                                                      *
*                                                                           *
* 30-Jan-1995 11.01.07.45  2                                                *
* Major revision.  Ditched includes, totally redesigned windows and         *
* Gadgets (Gadgets now have alternate images).  Option gadgets mutually     *
* exclusive.  Wb startup code modified.  New Gfx.                           *
*                                                                           *
* 31-Jan-1995 18.36.05.06  2                                                *
* Defined and placed string gadgets.                                        *
*                                                                           *
* 03-Feb-1995 23.14.08.27  2                                                *
* Finalised string gadgets, changed most gadgets to use default font        *
* instead of image (what a risk!).  EdWordPro used text casing to make code *
* look pretty, and added some headings, sectionalising code.                *
*                                                                           *
* 04-Feb-1995 14.21.53.37  2                                                *
* Added file and option error routines and messages.                        *
*                                                                           *
* 04-Feb-1995 22.19.12.14  2                                                *
* Improved error trapping and coded file access.                            *
*                                                                           *
* 05-Feb-1995 21.58.07.09  2                                                *
* Sort of finished!  Some testing and debugging needed.  Add final file     *
* manipulation and start/end line codes/definitions.                        *
*                                                                           *
* 06-Feb-1995 22.07.10.06  2                                                *
* Cleared a couple of bugs and cleaned up exit routine.  Some commenting    *
* left and then it's a wrap.                                                *
*                                                                           *
* 07-Feb-1995 11.50.31.33  2                                                *
* Added disable gadget feature.  Widened windows.  Modified IDCMP handling  *
* and changed Optionflag routine.                                           *
*                                                                           *
* 07-Feb-1995 23.00.24.18  2                                                *
* Minor debugging and major commenting.  Smashed some little bugs/hidden    *
* features(!).                                                              *
*                                                                           *
* 08-Feb-1995 23.15.07.18  2                                                *
* Finished.  Stomped a bug which involved linefeed handling.  Finalised     *
* comments and converted all outstanding decimal values to hexidecimal.     *
*                                                                           *
* 18-Feb-1995 22.52.20.19  2                                                *
* O.K!  So I couldn't stay away from it!  Here I've added the ARP file      *
* requester routines, and a little "beep" when the program has finished.    *
* I just need to ADD the Dirbuff to the Filebuff and then it's complete     *
* (except maybe for an ASL requester as well...)                            *
*                                                                           *
* 22-Feb-1995 08.50.20.23  2                                                *
* Sorted out Dir+File routines (a bit sneakily, but then again the latest   *
* edition to the Peck household thinks lack of sleep will help his dad, so  *
* my efficiency rating has dropped somewhat).  I promise NOT to do anymore  *
* updating!                                                                 *
*                                                                           *
* 23-Mar-1995 19.15.20.23  2                                                *
* Small Arp bug stomped.                                                    *
*                                                                           *
* 22-Apr-1995 22.44.29.12  2                                                *
* Some compatability problems with pre-WB2 systems.  My mum picked this one *
* up.  Good one mum!  I knew that 1.2 A500 would come in handy one day...   *
* While I was here I added a small requester routine in case the outfile    *
* already exists.                                                           *
*                                                                           *
* 24-Feb-1996 21:59:22.43 2                                                 *
* Added Asl requester.  I should fix up some memory routines but I can't be *
* bothered!  Sorry!                                                         *
*                                                                           *
*****************************************************************************

*********************************************************************
*                                                                   *
* Some Useful Definitions                                           *
* -----------------------                                           *
*                                                                   *
* You'll find all of these in the various includes that come with   *
* a compiler like DevPac.  Some are defined in structures such as   *
* "GADGET", while others are library offsets.  If you are stuck for *
* such definitions, check out HexTract by Chas Wyndham (Fish 817).  *
*                                                                   *
*********************************************************************

; Simple equivalents

ExecBase                = $04      ; ExecBase (!)
Wd_rport                = $32      ; Window RastPort (Window structure)
Wd_userport             = $56      ; Window UserPort (Window structure)
Pr_cli                  = $AC      ; CLI offset in process structure
Pr_msgport              = $5C      ; Message port for process structue
Im_class                = $14      ; Class for IDCMP message
Iaddress                = $1C      ; Address of IDCMP message
Gg_gadgetid             = $26      ; Gadget ID (Gadget structure)
Gadgetup                = $40      ; Gadget pressed
Gadclosewindow          = $200     ; Close window pressed
GadFlags                = $0C      ; Gadget status (Gadget structure)
NumChars                = $10      ; Number of chars in stringinfo
Mode_OLDFILE            = $03ED    ; Access mode for open file
Mode_NEWFILE            = $03EE    ; Access mode for open file
LF                      = $0A      ; LineFeed
CR                      = $0D      ; Carriage Return
Apost                   = $27      ; Apostrophe 

; Library Vector Offsets

_LVOOpenlibrary         = -$0228   ; Exec function
_LVOCloselibrary        = -$019E   ; Exec function
_LVOArpFileRequest      = -$0126   ; ARP function
_LVOTackOn              = -$0270   ; ARP function
_LVOAllocAslRequest     = -$0030   ; Asl function
_LVOAslRequest          = -$003C   ; Asl function
_LVOFreeFileRequest     = -$0024   ; Asl function
_LVOOpenwindow          = -$CC     ; Intuition function
_LVOOpen                = -$1E     ; Dos function
_LVOClose               = -$24     ; Dos function
_LVORead                = -$2A     ; Dos function
_LVODelay               = -$C6     ; Dos function
_LVOWrite               = -$30     ; Dos function
_LVODrawimage           = -$72     ; Intuition function
_LVOWaitport            = -$0180   ; Exec function
_LVOFindtask            = -$0126   ; Exec function
_LVOForbid              = -$84     ; Exec function
_LVOClosewindow         = -$48     ; Intuition function
_LVOSetwindowtitles     = -$0114   ; Intuition function
_LVOGetmsg              = -$0174   ; Exec function
_LVOReplymsg            = -$017A   ; Exec function
_LVOOffGadget           = -$AE     ; Exec function
_LVOAddGadget           = -$2A     ; Intuition function
_LVORefreshgadgets      = -$DE     ; Intuition function
_LVODisplayBeep         = -$60     ; Intuition function
_LVOAutoRequest         = -$015C   ; Intuition function

*********************************************************************
*                                                                   *
* Some Useful Macros                                                *
* ------------------                                                *
*                                                                   *
* Macros waste memory and increase the size of the code, but they   *
* make life a bit easier and the code a bit more readable.  All of  *
* these are used to access the appropriate library functions.  The  *
* library bases are loaded, the LVO prefix is added, and then the   *
* function is called.  Simple!                                      *
*                                                                   *
*********************************************************************

EXEC            Macro
        MOVE.L  ExecBase,A6        ; Move Exec into a6
        JSR     _LVO\1(A6)         ; Add Library offset and call function
                Endm

CALLINT         Macro
        MOVE.L  _intuitionbase,A6  ; Move Intuition into a6
        JSR     _LVO\1(A6)         ; Add Library offset and call function
                Endm

CALLDOS         Macro
        MOVE.L  _dosbase,A6        ; Move Dos into a6
        JSR     _LVO\1(A6)         ; Add Library offset and call function
                Endm

CALLREQ         MACRO
        MOVE.L  _reqbase,A6        ; Move REQ LIB into a6
        JSR     _LVO\1(A6)         ; Add Library offset and call function
                ENDM

*********************************************************************
*                                                                   *
* Wb Startup Code                                                   *
* ---------------                                                   *
*                                                                   *
* I modified this slightly from that which is provided with the     *
* includes that come with DevPac.  You can get similiar code        *
* in the Public Domain, see STARTUPS on Fish 101.  All they do is   *
* allow you to start your program from WB.                          *
*                                                                   *
*********************************************************************

        MOVEM.L  D0/A0,-(SP)        ;    save initial values
        CLR.L    Returnmsg          ;    clear message
        SUB.L    A1,A1              ;    subtract address
        EXEC     Findtask           ;    find us
        MOVE.L   D0,A4              ;    move process to a4
        TST.L    Pr_cli(A4)         ;    test if CLI
        BEQ      Fromworkbench      ;    otherwise go to workbench
        MOVEM.L  (SP)+,D0/A0        ;    restore registers
        BRA      End_startup        ;    and run the program

Fromworkbench:

        LEA      Pr_msgport(A4),A0  ;    load the message port
        EXEC     Waitport           ;    wait for a message
        LEA      Pr_msgport(A4),A0  ;    load the message port
        EXEC     Getmsg             ;    then get it
        MOVE.L   D0,Returnmsg       ;    save it for later reply
        MOVEM.L  (SP)+,D0/A0        ;    restore registers

End_startup:

        BSR      Start              ;    call the program
        MOVE.L   D0,-(SP)           ;    save it
        TST.L    Returnmsg          ;    test if message
        BEQ      Exittodos          ;    if I was a CLI
        EXEC     Forbid             ;    forbid WB to close
        MOVE.L   Returnmsg(Pc),A1   ;    load message
        EXEC     Replymsg           ;    message received!

Exittodos:

        MOVE.L   (SP)+,D0           ;    exit code
        RTS

*********************************************************************
*                                                                   *
* Program Starts Here                                               *
* -------------------                                               *
*                                                                   *
* The above code points to this Start identifier, which is where    *
* the actual program starts!                                        *
*                                                                   *
*********************************************************************

Start:

; The following subroutines can be found in the "SUBROUTINES" section.

        BSR     Openint             ; Open intuition library
        BSR     Opendos             ; Open dos library
        BSR     Win                 ; Open window
        BSR     Marketing_Win       ; Draw images on window

Aslavail:

; We'll find out if the Asl library is available.  If so, we can add two
; gadgets to the window which will enable the lazy user to select the
; infile and outfile using the Asl file requester.

        LEA      Aslname,A1         ; Load ASL library into a1
        MOVE.L   #$00,D0            ; Any version will do
        EXEC     Openlibrary        ; Macro opens library
        BEQ      ArpAvail           ; If there's a problem, go for Arp
        MOVE.L   D0,_reqbase        ; Save the return address
        MOVE.L   Winhd,A0           ; Load window handle to A0
        LEA      Inreq,A1           ; Load the Req gadget for infile
        CALLINT  AddGadget          ; Add it to the list
        MOVE.L   Winhd,A0           ; Load window handle to A0
        LEA      Outreq,A1          ; Load the Req gadget for outfile
        CALLINT  AddGadget          ; Add it to the list
        BRA      RefGads            ; Go and refresh the gadgets

ArpAvail:

; We'll find out if the ARP library is available.  If so, we can add two
; gadgets to the window which will enable the lazy user to select the
; infile and outfile using the ARP file requester.

        LEA      Arpname,A1         ; Load ARP library into a1
        MOVE.L   #$00,D0            ; Any version will do
        EXEC     Openlibrary        ; Macro opens library
        BEQ      Mainloop           ; If there's a problem, continue
        MOVE.B   #1,IsArpOpen       ; Flag that library
        MOVE.L   D0,_reqbase        ; Save the return address
        MOVE.L   Winhd,A0           ; Load window handle to A0
        LEA      Inreq,A1           ; Load the Req gadget for infile
        CALLINT  AddGadget          ; Add it to the list
        MOVE.L   Winhd,A0           ; Load window handle to A0
        LEA      Outreq,A1          ; Load the Req gadget for outfile
        CALLINT  AddGadget          ; Add it to the list
        BRA      RefGads            ; Go and refresh the gadgets

Mainloop:

; This window is where all the action occurs.  From here the user
; selects the files to be processed, and the conversion option required.

        BSR      Waitformess        ; Bide time until user inputs
        MOVE.L   Winhd,A0           ; Move window handle into a0
        MOVE.L   Wd_userport(A0),A0 ; UserPort offset
        EXEC     Getmsg             ; Macro gets window message
        MOVE.L   D0,A1              ; Message transferred to a1
        MOVE.L   A1,Message         ; Message saved for analysis
        EXEC     Replymsg           ; Message received!
        MOVE.L   Message,A0         ; Load message into a0
        MOVE.L   Im_class(A0),D0    ; Message class offset
        CMPI.L   #Gadclosewindow,D0 ; Was the close gadget pressed
        BEQ      Cleanup            ; Yes!  Outta here...
        MOVE.L   Message,A0         ; ...else Load message into a0
        MOVE.L   Iaddress(A0),A0    ; Gadget address offset
        MOVE.L   Gg_gadgetid(A0),D0 ; Gadget ID offset

        CMPI.L   #$10000,D0         ; Was the "GENERATE" gadget pressed
        BEQ      Errors             ; Yes!  See if there are any errors

        CMPI.L   #$20000,D0         ; Was the "SCRIPT" gadget pressed
        BEQ      Gadscriptact       ; Yes!  Activate Script Option

        CMPI.L   #$30000,D0         ; Was the "PASCAL" gadget pressed
        BEQ      Gadpasact          ; Yes!  Activate Pascal Option

        CMPI.L   #$40000,D0         ; Was the "C" gadget pressed
        BEQ      Gadcact            ; Yes!  Activate C Option

        CMPI.L   #$70000,D0         ; Was the "Infile" req gadget pressed
        BEQ      Gadifreq           ; Yes!  Activate ARP requester

        CMPI.L   #$80000,D0         ; Was the "Outfile" req gadget pressed
        BEQ      Gadofreq           ; Yes!  Activate ARP requester

        BRA      Mainloop           ; Go Mainloop ->

Gadscriptact:

; This next section firstly checks the Optionflag.  If this gadget has
; already been activated then the flag is reset to zero, else it is set
; to 1.  Then the other gadgets are checked.  If they are activated, they
; are deactivated.  Finally the gadgets are "Refreshed" and we are then
; sent back to the Mainloop.  The $0006 refers to the image type and
; gadget activation mode, while the $0086 is the same flag but now the
; gadget has been activated.

        CMP.B   #$01,Optionflag     ; Is the option already flagged?
        BEQ     1$                  ; Yes!  Branch to reset...
        MOVE.B  #$01,Optionflag     ; ...else set to 1...
        BRA     2$                  ; ...then jump to second marker
1$:     CLR.B   Optionflag          ; Clear the option flag
2$:     LEA     Gadscript,A2        ; Load the script gadget structure
        MOVE.L  GadFlags(A2),D0     ; Move to flag offset
        CMPI.W  #$0086,D0           ; Is the gadget already pressed?
        BEQ     RefGads             ; Yes!  Refresh and go...
        LEA     Gadpascal,A0        ; Load next gadget
        CMPI.W  #$0006,GadFlags(A0) ; Is the gadget not pressed?
        BEQ     3$                  ; Yes! Refresh and go...
        MOVE.W  #$0006,GadFlags(A0) ; ...else "unpress" gadget
3$:     LEA     Gadc,A0             ; Load next gadget
        CMPI.W  #$0006,GadFlags(A0) ; Is the gadget not pressed?
        BEQ     4$                  ; Yes! Refresh and go...
        MOVE.W  #$0006,GadFlags(A0) ; ...else "unpress" gadget
4$:     BRA     RefGads             ; Go Refresh ->

Gadpasact:

; This next section firstly checks the Optionflag.  If this gadget has
; already been activated then the flag is reset to zero, else it is set
; to 2.  Then the other gadgets are checked.  If they are activated, they
; are deactivated.  Finally the gadgets are "Refreshed" and we are then
; sent back to the Mainloop.  The $0006 refers to the image type and
; gadget activation mode, while the $0086 is the same flag but now the
; gadget has been activated.

        CMP.B   #$02,Optionflag     ; Is the option already flagged?  
        BEQ     1$                  ; Yes!  Branch to reset...
        MOVE.B  #$02,Optionflag     ; ...else set to 2...
        BRA     2$                  ; ...then jump to second marker
1$:     CLR.B   Optionflag          ; Clear the option flag
2$:     LEA     Gadpascal,A2        ; Load the script gadget structure
        MOVE.L  GadFlags(A2),D0     ; Move to flag offset
        CMPI.W  #$0086,D0           ; Is the gadget already pressed?
        BEQ     RefGads             ; Yes!  Refresh and go...
        LEA     Gadc,A0             ; Load next gadget
        CMPI.W  #$0006,GadFlags(A0) ; Is the gadget not pressed?
        BEQ     3$                  ; Yes! Refresh and go...
        MOVE.W  #$0006,GadFlags(A0) ; ...else "unpress" gadget
3$:     LEA     Gadscript,A0        ; Load next gadget
        CMPI.W  #$0006,GadFlags(A0) ; Is the gadget not pressed?
        BEQ     4$                  ; Yes! Refresh and go...
        MOVE.W  #$0006,GadFlags(A0) ; ...else "unpress" gadget
4$:     BRA     RefGads             ; Go Refresh ->

Gadcact:

; This next section firstly checks the Optionflag.  If this gadget has
; already been activated then the flag is reset to zero, else it is set
; to 3.  Then the other gadgets are checked.  If they are activated, they
; are deactivated.  Finally the gadgets are "Refreshed" and we are then
; sent back to the Mainloop.  The $0006 refers to the image type and
; gadget activation mode, while the $0086 is the same flag but now the
; gadget has been activated.

        CMP.B   #$03,Optionflag     ; Is the option already flagged?
        BEQ     1$                  ; Yes!  Branch to reset...
        MOVE.B  #$03,Optionflag     ; ...else set to 3...
        BRA     2$                  ; ...then jump to second marker
1$:     CLR.B   Optionflag          ; Clear the option flag
2$:     LEA     Gadc,A2             ; Load the script gadget structure
        MOVE.L  GadFlags(A2),D0     ; Move to flag offset
        CMPI.W  #$0086,D0           ; Is the gadget already pressed?
        BEQ     RefGads             ; Yes!  Refresh and go...
        LEA     Gadscript,A0        ; Load next gadget
        CMPI.W  #$0006,GadFlags(A0) ; Is the gadget not pressed?
        BEQ     3$                  ; Yes! Refresh and go...
        MOVE.W  #$0006,GadFlags(A0) ; ...else "unpress" gadget
3$:     LEA     Gadpascal,A0        ; Load next gadget
        CMPI.W  #$0006,GadFlags(A0) ; Is the gadget not pressed?
        BEQ     4$                  ; Yes! Refresh and go...
        MOVE.W  #$0006,GadFlags(A0) ; ...else "unpress" gadget
4$:     BRA     RefGads             ; Go Refresh ->

Gadifreq:

; If the Infile Requester Gadget is pressed, we need to fire up a
; requester, and we start with the preferable Asl requester.

        TST.B   IsArpOpen          ; Are we Arping today?
        BNE     Arpifreq           ; Yes, so outta this Asl territory

        MOVE.L  #0,A0              ; I'll be initiating a...
        CLR.L   D0                 ; ...File Requester...
        CALLREQ AllocAslRequest    ; ...if that's OK with you!
        MOVE.L  D0,A4              ; Else move the requester to A4
        MOVE.L  D0,A0              ; A copy to A0
        CALLREQ AslRequest         ; And fire it up!
        MOVE.L  4(A4),A1           ; Move the resultant file info to A1
        MOVE.L  8(A4),A2           ; and the Path info to A2

        LEA     Infilebuff,A0      ; Get the buffer ready in A0
        MOVE.L  #$64,D0            ; And the size is 100
        BSR     ClearBuff;         ; Clear it baby!

        LEA     Infilebuff,A3      ; Now load it to A3
        MOVE.B  #$64,D3            ; And it's size to D3

        TST.B   (A2)               ; Any path info?
        BEQ     3$                 ; No so move on to the file info

1$      MOVE.B  (A2)+,D0           ; Else move a byte to D0
        TST.B   D0                 ; Test it's validity
        BEQ     2$                 ; No good so finished
        MOVE.B  D0,(A3)+           ; else move it to the Infile buffer
        SUB.B   #1,D3              ; decrement counter
        TST.B   D3                 ; at zero yet?
        BNE     1$                 ; No so back for another character

; If we've run outta space we gotta tell the punters.

        MOVE.L  #$00,A0            ; All screens to beep!
        CALLINT DisplayBeep        ; Beep the display to wake up user
        LEA     BigPath,A1         ; ...else load the message pointer...
        BRA     ErrorMessage       ; ...and display the error

2$      MOVE.B  -1(A3),D0          ; What was that last one?
        CMP.B   #$3A,D0            ; Was it a full colon?
        BEQ     3$                 ; Yep, so move on to file info
        MOVE.B  #$2F,(A3)+         ; Move in a "/"
        SUB.B   #1,D3              ; decrement counter
        TST.B   D3                 ; at zero yet?
        BNE     3$                 ; No so move along to file info

; It'd be a bummer if the backslash was the last character, but it could
; happen so we will notify the user.

        MOVE.L  #$00,A0            ; All screens to beep!
        CALLINT DisplayBeep        ; Beep the display to wake up user
        LEA     BigPath,A1         ; ...else load the message pointer...
        BRA     ErrorMessage       ; ...and display the error

3$      MOVE.B  (A1)+,D0           ; Move the file info character
        TST.B   D0                 ; Hello?
        BEQ     4$                 ; Yikes, outta here.
        MOVE.B  D0,(A3)+           ; else add it to infile buffer
        SUB.B   #1,D3              ; and decrement counter
        TST.B   D3                 ; at zero yet?
        BNE     3$                 ; Nope, so another character?

        MOVE.L  #$00,A0            ; All screens to beep!
        CALLINT DisplayBeep        ; Beep the display to wake up user
        LEA     BigPath,A1         ; ...else load the message pointer...
        BRA     ErrorMessage       ; ...and display the error

4$      MOVE.L  A4,A0              ; The last hurrah
        CALLREQ FreeFileRequest    ; is to free the requester

        BRA     RefGads            ; and then off to refresh gadgets

Arpifreq:

; We simply load the requester to A0 and then call the library function.
; The Arp function "TackOn" adds the file name to the pathname.

        LEA      Infilebuff,A0      ; Load the Infile buffer
        MOVE.L   #$64,D0            ; ...and the size of the buffer
        BSR      ClearBuff          ; We may need this buffer clear!
        LEA      ArpDirBuff,A0      ; Load the Arp Directory buffer
        MOVE.L   #$46,D0            ; ...and the size of the buffer
        BSR      ClearBuff          ; We may need this buffer clear!
        LEA      Arpfrequest,A0     ; Load the requester structure
        CALLREQ  ArpFileRequest     ; Call the Requester
        LEA      ArpDirBuff,A0      ; Load the Arp Directory buffer
        LEA      ArpFileBuff,A1     ; Load the Arp File buffer
        CALLREQ  TackOn             ; Macro calls function
        LEA      ArpDirBuff,A0      ; Reload Arp Directory buffer
        LEA      Infilebuff,A1      ; Load the Infile buffer
1$      MOVE.B   (A0)+,D0           ; Move a character to D0
        CMPI.B   #$00,D0            ; Is it a dud?
        BEQ      2$                 ; Yes -> move along...
        MOVE.B   D0,(A1)+           ; ...else add it to Infile buffer
        BRA      1$                 ; ...and return
2$      BRA      RefGads            ; clean up gadgets ->

Gadofreq:

; If the Outfile Requester Gadget is pressed, we need to fire up a
; requester, and we start with the preferable Asl requester.

        TST.B   IsArpOpen          ; Are we Arping today?
        BNE     Arpofreq           ; Yes, so outta this Asl territory

        MOVE.L  #0,A0              ; I'll be initiating a...
        CLR.L   D0                 ; ...File Requester...
        CALLREQ AllocAslRequest    ; ...if that's OK with you!
        MOVE.L  D0,A4              ; Else move the requester to A4
        MOVE.L  D0,A0              ; A copy to A0
        CALLREQ AslRequest         ; And fire it up!
        MOVE.L  4(A4),A1           ; Move the resultant file info to A1
        MOVE.L  8(A4),A2           ; and the Path info to A2

        LEA     Outfilebuff,A0     ; Get the buffer ready in A0
        MOVE.L  #$64,D0            ; And the size is 100
        BSR     ClearBuff;         ; Clear it baby!

        LEA     Outfilebuff,A3     ; Now load it to A3
        MOVE.B  #$64,D3            ; And it's size to D3

        TST.B   (A2)               ; Any path info?
        BEQ     3$                 ; No so move on to the file info

1$      MOVE.B  (A2)+,D0           ; Else move a byte to D0
        TST.B   D0                 ; Test it's validity
        BEQ     2$                 ; No good so finished
        MOVE.B  D0,(A3)+           ; else move it to the Infile buffer
        SUB.B   #1,D3              ; decrement counter
        TST.B   D3                 ; at zero yet?
        BNE     1$                 ; No so back for another character

; If we've run outta space we gotta tell the punters.

        MOVE.L  #$00,A0            ; All screens to beep!
        CALLINT DisplayBeep        ; Beep the display to wake up user
        LEA     BigPath,A1         ; ...else load the message pointer...
        BRA     ErrorMessage       ; ...and display the error

2$      MOVE.B  -1(A3),D0          ; What was that last one?
        CMP.B   #$3A,D0            ; Was it a full colon?
        BEQ     3$                 ; Yep, so move on to file info
        MOVE.B  #$2F,(A3)+         ; Move in a "/"
        SUB.B   #1,D3              ; decrement counter
        TST.B   D3                 ; at zero yet?
        BNE     3$                 ; No so move along to file info

; It'd be a bummer if the backslash was the last character, but it could
; happen so we will notify the user.

        MOVE.L  #$00,A0            ; All screens to beep!
        CALLINT DisplayBeep        ; Beep the display to wake up user
        LEA     BigPath,A1         ; ...else load the message pointer...
        BRA     ErrorMessage       ; ...and display the error

3$      MOVE.B  (A1)+,D0           ; Move the file info character
        TST.B   D0                 ; Hello?
        BEQ     4$                 ; Yikes, outta here.
        MOVE.B  D0,(A3)+           ; else add it to infile buffer
        SUB.B   #1,D3              ; and decrement counter
        TST.B   D3                 ; at zero yet?
        BNE     3$                 ; Nope, so another character?

        MOVE.L  #$00,A0            ; All screens to beep!
        CALLINT DisplayBeep        ; Beep the display to wake up user
        LEA     BigPath,A1         ; ...else load the message pointer...
        BRA     ErrorMessage       ; ...and display the error

4$      MOVE.L  A4,A0              ; The last hurrah
        CALLREQ FreeFileRequest    ; is to free the requester

        BRA     RefGads            ; and then off to refresh gadgets

Arpofreq:

; We simply load the requester to A0 and then call the library function.
; The Arp function "TackOn" adds the file name to the pathname.

        LEA      Outfilebuff,A0     ; Load the Outfile buffer
        MOVE.L   #$64,D0            ; ...and the size of the buffer
        BSR      ClearBuff          ; We may need this buffer clear!
        LEA      ArpDirBuff,A0      ; Load the Arp Directory buffer
        MOVE.L   #$46,D0            ; ...and the size of the buffer
        BSR      ClearBuff          ; We may need this buffer clear!
        LEA      Arpfrequest,A0     ; Load the requester structure
        CALLREQ  ArpFileRequest     ; Call the Requester
        LEA      ArpDirBuff,A0      ; Load the Arp Directory buffer
        LEA      ArpFileBuff,A1     ; Load the Arp File buffer
        CALLREQ  TackOn             ; Macro calls function
        LEA      ArpDirBuff,A0      ; Reload Arp Directory buffer
        LEA      Outfilebuff,A1     ; Load the Outfile buffer
1$      MOVE.B   (A0)+,D0           ; Move a character to D0
        CMPI.B   #$00,D0            ; Is it a dud?
        BEQ      2$                 ; Yes -> move along...
        MOVE.B   D0,(A1)+           ; ...else add it to Outfile
        BRA      1$                 ; ...and return
2$      BRA      RefGads            ; clean up gadgets ->

RefGads:

; Here we refresh the gadgets after changes have been made.

        LEA      Gadgenerate,A0     ; Load address of first gadget
        MOVE.L   Winhd,A1           ; Load window pointer
        MOVE.L   #$00,A2            ; No requester
        CALLINT  Refreshgadgets     ; Macro calls function
        BRA      Mainloop           ; Go Mainloop ->

Errors:

; If the "GENERATE" gadget was pressed, we need to check to see that some
; basic condition have been satisfied.  E.g. Has an infile and outfile
; been selected?  Has an option been selected?  Can I find and open the
; files?

        CLR.L   D0                  ; First a clean slate

Checkinfile:

        LEA     Infileinfo,A0       ; Load the infile structure
        MOVE.W  NumChars(A0),D0     ; Move to number of characters offset
        TST.B   D0                  ; Test if anything was entered
        BNE     Checkoutfile        ; If OK move on...
        MOVE.L  #$00,A0             ; All screens to beep!
        CALLINT DisplayBeep         ; Beep the display to wake up user
        LEA     NoInfile,A1         ; ...else load the message pointer...
        BRA     ErrorMessage        ; ...and display the error

Checkoutfile:

        LEA     Outfileinfo,A0      ; Load the outfile structure
        MOVE.W  NumChars(A0),D0     ; Move to number of characters offset
        TST.B   D0                  ; Test if anything was entered
        BNE     Checkoptionflag     ; If OK move on...
        MOVE.L  #$00,A0             ; All screens to beep!
        CALLINT DisplayBeep         ; Beep the display to wake up user
        LEA     NoOutfile,A1        ; ...else load the message pointer...
        BRA     ErrorMessage        ; ...and display the error

Checkoptionflag:

        MOVE.B  Optionflag,D0       ; Move optionflag to D3
        TST.B   D0                  ; Test if option has been selected
        BNE     OpenFiles           ; If OK move on...
        MOVE.L  #$00,A0             ; All screens to beep!
        CALLINT DisplayBeep         ; Beep the display to wake up user
        LEA     NoOption,A1         ; ...else load the message pointer...
        BRA     ErrorMessage        ; ...and display the error

OpenFiles:

; Now that any errors have been dealt with, we can open the infile and 
; the outfile.

        MOVE.L  #Infilebuff,D1      ; Move the name of the infile to D1
        MOVE.L  #Mode_OLDFILE,D2    ; Opening as an existing file
        CALLDOS Open                ; Macro calls open function
        TST.B   D0                  ; Open OK?
        BNE     1$                  ; Yes! Move on...
        MOVE.L  #$00,A0             ; All screens to beep!
        CALLINT DisplayBeep         ; Beep the display to wake up user
        LEA     NoInfileAcc,A1      ; ...else load the message pointer...
        BRA     ErrorMessage        ; ...and display the error
1$      MOVE.L  D0,Infilehd         ; Save the infile handle

; We need to check if the outfile exists, and alert the user...

        MOVE.L  #Outfilebuff,D1     ; Move the name of the outfile to D1
        MOVE.L  #Mode_OLDFILE,D2    ; Opening as a old file first
        CALLDOS Open                ; Macro calls open function
        MOVE.L  D0,Outfilehd        ; Save the file handle
        TST.B   D0                  ; Test if the file already exists
        BEQ     2$                  ; If "NO" then move on ->
        MOVE.L  Winhd,A0            ; ...else load the window handle to A0
        LEA     Atext,A1            ; ...and the main body text to A1
        LEA     Ltext,A2            ; ...and the left text to A2
        LEA     Rtext,A3            ; ...and the right text to A3
        MOVE.L  #$00,D0             ; left button responds to mouse click
        MOVE.L  #$00,D1             ; right button responds to mouse click
        MOVE.L  #$C4,D2             ; requester length
        MOVE.L  #$35,D3             ; requester height
        CALLINT AutoRequest         ; call the requester
        TST.B   D0                  ; Test if clicked the right button
        BEQ     2$                  ; Yes...so move on

; Closing the files just in case we don't get back here again!

        MOVE.L  Infilehd,D1         ; No...so load infile handle...
        CALLDOS Close               ; ...and close the file...
        MOVE.L  Outfilehd,D1        ; Load the outfile handle
        CALLDOS Close               ; ...and close the file...
        MOVE.L  #$00,A0             ; All screens to beep!
        CALLINT DisplayBeep         ; Beep the display to wake up user
        BRA     Mainloop            ; Head back to main window
2$      MOVE.L  Outfilehd,D1        ; Load the outfile handle
        CALLDOS Close               ; Macro calls function

; Now we open the old file, knowing that all is OK with the user...

        MOVE.L  #Outfilebuff,D1     ; Move the name of the outfile to D1
        MOVE.L  #Mode_NEWFILE,D2    ; Opening as a new file now
        CALLDOS Open                ; Macro calls open function
        TST.B   D0                  ; Open OK?
        BNE     3$                  ; Yes! Move on...
        MOVE.L  Infilehd,D1         ; If error load infile handle...
        CALLDOS Close               ; ...and close the file...
        MOVE.L  #$00,A0             ; All screens to beep!
        CALLINT DisplayBeep         ; Beep the display to wake up user
        LEA     NoOutfileAcc,A1     ; ...then load the message pointer...
        BRA     ErrorMessage        ; ...and display the error
3$      MOVE.L  D0,Outfilehd        ; Save the outfile handle
        
CloseGadgets:

; Now that all the errors have been dealt with and the files are open, we
; can start the real work.  It's a good idea to shut down the gadgets and
; display a suitable message, just to show the user that something is
; happening.

        CMP.L   #$00,_ARPbase       ; Is ARP open (and the REQ gadgets)?
        BEQ     1$                  ; No! Move along...
        LEA     Inreq,A0            ; Load gadget into A0
        MOVE.L  Winhd,A1            ; Move window handle into A1
        MOVE.L  #$00,A2             ; No requester
        CALLINT OffGadget           ; Macro turns off gadget
        LEA     Outreq,A0           ; Load gadget into A0
        MOVE.L  Winhd,A1            ; Move window handle into A1
        MOVE.L  #$00,A2             ; No requester
        CALLINT OffGadget           ; Macro turns off gadget
1$      LEA     Gadgenerate,A0      ; Load gadget into A0
        MOVE.L  Winhd,A1            ; Move window handle into A1
        MOVE.L  #$00,A2             ; No requester
        CALLINT OffGadget           ; Macro turns off gadget
        LEA     Gadscript,A0        ; Load gadget into A0
        MOVE.L  Winhd,A1            ; Move window handle into A1
        MOVE.L  #$00,A2             ; No requester
        CALLINT OffGadget           ; Macro turns off gadget
        LEA     Gadpascal,A0        ; Load gadget into A0
        MOVE.L  Winhd,A1            ; Move window handle into A1
        MOVE.L  #$00,A2             ; No requester
        CALLINT OffGadget           ; Macro turns off gadget
        LEA     Gadc,A0             ; Load gadget into A0
        MOVE.L  Winhd,A1            ; Move window handle into A1
        MOVE.L  #$00,A2             ; No requester
        CALLINT OffGadget           ; Macro turns off gadget
        LEA     Gadgenerate,A0      ; Load first gadget into A0
        MOVE.L  Winhd,A1            ; Move window handle into A1
        MOVE.L  #$00,A2             ; No requester
        CALLINT Refreshgadgets      ; Macro calls function
        LEA     Working,A1          ; Load working message to A1
        MOVE.L  Winhd,A0            ; Move window handle into a0
        LEA     Screentitle,A2      ; Load the screen title into a2
        CALLINT Setwindowtitles     ; Macro changes screen title

WhichOption:

; This code checks to see which of the option buttons was activated, and
; then loads data particular to that option into various registers, ready
; for use later, as well as writing a little message to the outfile about
; how the text got there in the first place (vanity oh vanity).

        CMP.B   #$01,Optionflag     ; Is script the option selected?
        BNE     1$                  ; No!  Move on...
        MOVE.L  Outfilehd,D1        ; Move Outfile handle to D1
        MOVE.L  #Scblurb,D2         ; Move the message to D2
        MOVE.L  #SIZEScBlurb,D3     ; Move the size of the message to D3
        CALLDOS Write               ; Macro write to file
        MOVE.L  #Scstart,D4         ; Move startline to D4
        MOVE.L  #Scend,D5           ; Move endline to D5
        MOVE.L  #SIZEScstart,D6     ; Size of startline to D6
        MOVE.L  #SIZEScend,D7       ; Size of endline to D7
        BRA     Primeloop           ; Go Primeloop ->
1$      CMP.B   #$02,Optionflag     ; Is Pascal the option selected?
        BNE     2$                  ; No!  Move on..(C option by default)
        MOVE.L  Outfilehd,D1        ; Move Outfile handle to D1
        MOVE.L  #Pasblurb,D2        ; Move the message to D2
        MOVE.L  #SIZEPasBlurb,D3    ; Move the size of the message to D3
        CALLDOS Write               ; Macro write to file
        MOVE.L  #Passtart,D4        ; Move startline to D4
        MOVE.L  #Pasend,D5          ; Move endline to D5
        MOVE.L  #SIZEPasstart,D6    ; Size of startline to D6
        MOVE.L  #SIZEPasend,D7      ; Size of endline to D7
        BRA     Primeloop           ; Go Primeloop ->
2$      MOVE.L  Outfilehd,D1        ; Move Outfile handle to D1
        MOVE.L  #Cblurb,D2          ; Move the message to D2
        MOVE.L  #SIZECBlurb,D3      ; Move the size of the message to D3
        CALLDOS Write               ; Macro write to file
        MOVE.L  #Cstart,D4          ; Move startline to D4
        MOVE.L  #Cend,D5            ; Move endline to D5
        MOVE.L  #SIZECstart,D6      ; Size of startline to D6
        MOVE.L  #SIZECend,D7        ; Size of endline to D7

Primeloop:

; The reading and writing of the files now takes place.  Firstly, the loop
; should be "primed", just in case the first character is a dud (e.g. if
; the infile is empty (in which case all the user gets is an outfile
; containing the blurb message we wrote above).
                                     
        MOVE.L  Infilehd,D1         ; Move infile handle into D1
        MOVE.L  #Infilechar,D2      ; Move the Infilechar buffer to D2
        MOVE.L  #$01,D3             ; Reading just one byte
        CALLDOS Read                ; Macro calls function
        TST.B   D0                  ; Read OK
        BEQ     Closefiles          ; No! Close all files
        CMP.B   #LF,Infilechar      ; Was character a linefeed?
        BEQ     1$                  ; Yes! Go startline and endline
        CMP.B   #CR,Infilechar      ; Was character a carriage return?
        BEQ     1$                  ; Yes! Go startline and endline
        BSR     Startline           ; Write the start of the line
        BSR     WriteChar           ; Then write the character  
        BRA     ReadChar            ; Branch to Read the next char
1$      BSR     Startline           ; Write the start of the line
        BRA     Endline             ; Go endline ->

ReadChar:

; This is the top of the loop that does all the work.

        MOVE.L  Infilehd,D1         ; Move infile handle into D1
        MOVE.L  #Infilechar,D2      ; The buffer for the character
        MOVE.L  #$01,D3             ; Just one byte to read
        CALLDOS Read                ; Macro calls function
        TST.B   D0                  ; Any Problems?
        BEQ     LastChar            ; Yes!  Head off to finish up ->
        CMP.B   #Apost,Infilechar   ; else check if character was '
        BNE     1$                  ; No!  Next ->
        CMP.B   #$02,Optionflag     ; Are we in Pascal mode?
        BNE     1$                  ; No!  Next ->
        MOVE.L  Outfilehd,D1        ; ...else load outfile handle...
        MOVE.L  #Apostrophe,D2      ; ...load an apostrophe string...
        MOVE.L  #$01,D3             ; ...just the one thanx!
        CALLDOS Write               ; Macro calls function
1$      CMP.B   #LF,Infilechar      ; Was the character a linefeed?
        BEQ     Endline             ; Yes!  Head off ->
        CMP.B   #CR,Infilechar      ; Was the character a carriage return?
        BEQ     Endline             ; Yes!  Head off ->
        BSR     WriteChar           ; After those checks, write ->
        BRA     ReadChar            ; Back to start of loop

Endline:

; This bit of code is called when a linefeed or carriage return is read,
; thus signalling the end of a line. 

        MOVE.L  Outfilehd,D1        ; Load the outfile handle
        MOVE.L  D5,D2               ; Load the end option stored in D5
        MOVE.L  D7,D3               ; Load the length of the end option
        CALLDOS Write               ; Macro calls function
        BSR     Startline           ; Start the next line
        BRA     ReadChar            ; Loop again!

LastChar:

; If there was a problem reading the file, I'm assuming we're finished,
; and so we need to firstly finish the line.

        MOVE.L  Outfilehd,D1        ; Load the outfile handle
        MOVE.L  D5,D2               ; Load the end option stored in D5
        MOVE.L  D7,D3               ; Load the length of the end option
        CALLDOS Write               ; Macro calls function

Closefiles:

; After closing off the last line, we need to close the open files.

        MOVE.L  Infilehd,D1         ; Load the infile handle
        CALLDOS Close               ; Macro calls function
        MOVE.L  Outfilehd,D1        ; Load the outfile handle
        CALLDOS Close               ; Macro calls function

LastMessage:

; The last stage of the program is to notify the user that all operations
; have ceased.

        LEA     AllOk,A1            ; Load the final message into A1
        MOVE.L  Winhd,A0            ; Move window handle into a0
        LEA     Screentitle,A2      ; Load the screen title into a2
        CALLINT Setwindowtitles     ; Macro changes screen title
        MOVE.L  #$00,A0             ; All screens to beep!
        CALLINT DisplayBeep         ; Beep the display to wake up user
        MOVE.L  #$46,D1             ; Delay closing by 1.4 seconds(!)
        CALLDOS Delay               ; Macro calls function
        BRA     Cleanup             ; finito and gone ->

ErrorMessage:

        MOVE.L  Winhd,A0            ; Move window handle into a0
        LEA     Screentitle,A2      ; Load the screen title into a2
        CALLINT Setwindowtitles     ; Macro changes screen title
        BRA     Mainloop            ; Back to the mainloop ->

*********************************************************************
*                                                                   *
* Subroutines                                                       *
* -----------                                                       *
*                                                                   *
* These sections of code are either re-used several times, or are   *
* just easy to put somewhere at the end of the program where no-one *
* will mind too much!                                               *
*                                                                   *
*********************************************************************

Openint:

; The opening of the intuition library, including an error branch if things
; don't go according to plan!

        LEA      Intname,A1         ; Load intuition library into a1
        EXEC     Openlibrary        ; Macro opens library
        BEQ      Exittodos          ; If it doesn't open, we quit
        MOVE.L   D0,_intuitionbase  ; Save the return address
        RTS                         ; ...and back at you ->

Opendos:

; The opening of the dos library, including an error branch if things
; don't go according to plan!

        LEA      Dosname,A1         ; Load dos library into a1
        MOVE.L   #$00,D0            ; Any version will do
        EXEC     Openlibrary        ; Macro opens library
        BEQ      NoDos              ; If there's a problem, close down
        MOVE.L   D0,_dosbase        ; Save the return address
        RTS                         ; ...and back at you ->

NoDos:

; If dos fails to open, we need to close intuition.

        BSR     Closeint            ; Jump to close intuition subroutine
        BRA     Exittodos           ; Then off!

Win:

; This little bit opens the second window.

        LEA     Win_defs,A0        ; Load window definitions to a0
        BSR     Openwin             ; Open the window
        RTS                         ; ...and back at you ->

Marketing_Win:

; Here the title is drawn, and the screen title changed.

        BSR     Drawtitle           ; Draw title on window
        BSR     Changetitle         ; Alter screen title
        RTS                         ; ...and back at you ->

Waitformess:

; Rather than check all the time if the window has spoken to intuition,
; we use the userport of the window structure to wait for a message
; before doing anything else.  Low maintenance!

        MOVE.L   Winhd,A0           ; Move window handle into a0
        MOVE.L   Wd_userport(A0),A0 ; UserPort offset at byte 86
        EXEC     Waitport           ; Macro waits for message from window
        RTS                         ; ...and back at you ->

Drawtitle:

; This loads the image data, the x and y offsets for the image on the
; window, and then draws the title onto the window.

        MOVE.L  Winhd,A0            ; Move window handle into a0
        MOVE.L  Wd_rport(A0),A0     ; RastPort offset found at byte 50
        MOVE.L  #$17,D0             ; x-offset in window loaded to d0
        MOVE.L  #$0D,D1             ; y-offset in window loaded to d1
        LEA     Title,A1            ; Load image data to a1
        CALLINT Drawimage           ; Macro draws image
        RTS                         ; ...and back at you ->

Changetitle:

; Here we change the workbench screen title.

        MOVE.L  Winhd,A0           ; Move window handle into a0
        MOVEA.L #-1,A1             ; Move current window title into a1
        LEA     Screentitle,A2     ; Load the screen title into a2
        CALLINT Setwindowtitles    ; Macro changes screen title
        RTS                        ; ...and back at you ->

Openwin:

; Just calls the function and stores the window handle.

        CALLINT Openwindow          ; Macro opens window
        MOVE.L  D0,Winhd            ; Save return address (window handle)
        RTS                         ; ...and back at you ->

Startline:

; Called when we need to write the "echo", "writeln" or "printf" commands.

        MOVE.L  Outfilehd,D1        ; Load the outfile handle
        MOVE.L  D4,D2               ; Load the end option stored in D2
        MOVE.L  D6,D3               ; Load the length of the end option
        CALLDOS Write               ; Macro calls function
        RTS                         ; ...and back at you ->

WriteChar:

; If all has gone well, we can write the character into the outfile.

        MOVE.L  Outfilehd,D1        ; Load the outfile handle
        MOVE.L  #Infilechar,D2      ; Load the character buffer
        MOVE.L  #$01,D3             ; Just the one!
        CALLDOS Write               ; Macro calls function
        RTS                         ; ...and back at you ->

ClearBuff:

; Here we clear memory buffers

1$      SUBQ.B	#$01,D0             ; Subtract one from counter
	MOVE.B  #$00,(A0)+          ; Move a dud into buffer
	CMPI.B	#$00,D0             ; Are we at zero yet?
	BNE	1$                  ; No, so go back...
        RTS                         ; outta here ->
        
Cleanup:

; Finally it's over, but before we can go home we need to do some quick
; housekeeping!

        CMP.L   #$00,_ARPbase       ; Is ARP open?
        BEQ     1$                  ; No...then move on...
        BSR     Closearp            ; ...else close arp
1$      BSR     Closewin            ; Close window
        BSR     Closedos            ; Close dos
        BSR     Closeint            ; Close intuition
	RTS

Closewin:

; Closes the window.

        MOVE.L  Winhd,A0            ; Move window handle into a0
        CALLINT Closewindow         ; Macro closes window down
        RTS                         ; ...and back at you ->

Closedos:

; Closes the dos library.

        MOVE.L   _dosbase,A1        ; Move dos base into a1
        EXEC     Closelibrary       ; Macro closes dos
        RTS                         ; ...and back at you ->

Closeint:

; Closes the intuition library.

        MOVE.L   _intuitionbase,A1  ; Move intuition base into a1
        EXEC     Closelibrary       ; Macro closes intuition
        RTS                         ; ...and back at you ->

Closearp:

; Closes the arp library.

        MOVE.L   _ARPbase,A1        ; Move arp base into a1
        EXEC     Closelibrary       ; Macro closes arp
        RTS                         ; ...and back at you ->

*********************************************************************
*                                                                   *
* Structures and Memory Allocation                                  *
* --------------------------------                                  *
*                                                                   *
* Here are the definitions held for the structures used in the      *
* program, as well as memory blocks Set aside for definitions such  *
* as the messages.                                                  *
*                                                                   *
*********************************************************************
    
Win_defs:

; Window structure

        DC.W    $C2                ; x-offset on screen
        DC.W    $32                ; y-offset on screen
        DC.W    $F6                ; window width
        DC.W    $8C                ; window height
        DC.B    $01                ; print colour
        DC.B    $03                ; background colour
        DC.L    $00000240          ; IDCMP flags: CLOSEWINDOW|GADGETDOWN
        DC.L    $0000100e          ; ACTIVATE|WINDOWDRAG|WINDOWDEPTH
                                   ; WINDOWCLOSE
        DC.L    Gadgenerate        ; First Gadget 
        DC.L    $00                ; Standard Checkmark
        DC.L    Winname            ; Window name 
        DC.L    $00                ; screen pointer
        DC.L    $00                ; no custom bitmap
        DC.W    $00,$00,$00,$00    ; intuition sets these given that...
        DC.W    $01                ; this is a WORKBENCH screen 

Gadgenerate:

; Gadget structure

        DC.L    Gadscript          ; next gadget
        DC.W    $8C                ; x-offset on window
        DC.W    $76                ; y-offset on window
        DC.W    $59                ; gadget width
        DC.W    $0C                ; gadget height
        DC.W    $04                ; Alternative Image type
        DC.W    $01                ; RELVERIFY
        DC.W    $01                ; BOOLEAN
        DC.L    Generate           ; Data for picture of gadget
        DC.L    $00                ; Alternative image
        DC.L    $00                ; no text around gadget
        DC.L    $00,$00            ; no exclude,no special info
        DC.W    $01                ; Gadget Identification
        DC.L    $00                ; no User Data

Gadscript:

; Gadget structure

        DC.L    Gadpascal          ; next gadget
        DC.W    $19                ; x-offset on window
        DC.W    $61                ; y-offset on window
        DC.W    $11                ; gadget width
        DC.W    $09                ; gadget height
        DC.W    $06                ; Inverted gadget
        DC.W    $0101              ; TOGGLESELECT|RELVERIFY
        DC.W    $01                ; BOOLEAN
        DC.L    Buttonoff          ; Data for picture of gadget
        DC.L    Buttonon           ; Alternative image
        DC.L    Scripttxt          ; text around gadget
        DC.L    $00                ; no mutual exclude
        DC.L    $00                ; no special info
        DC.W    $02                ; Gadget Identification
        DC.L    $00                ; no User Data

Gadpascal:

; Gadget structure

        DC.L    Gadc               ; next gadget
        DC.W    $19                ; x-offset on window
        DC.W    $6D                ; y-offset on window
        DC.W    $11                ; gadget width
        DC.W    $09                ; gadget height
        DC.W    $06                ; Alternative Image type
        DC.W    $0101              ; TOGGLESELECT|RELVERIFY
        DC.W    $01                ; BOOLEAN
        DC.L    Buttonoff          ; Data for picture of gadget
        DC.L    Buttonon           ; Alternative image
        DC.L    Pascaltxt          ; text around gadget
        DC.L    $00                ; no mutual exclude
        DC.L    $00                ; no special info
        DC.W    $03                ; Gadget Identification
        DC.L    $00                ; no User Data

Gadc:

; Gadget structure

        DC.L    Gadinfile          ; next gadget
        DC.W    $19                ; x-offset on window
        DC.W    $79                ; y-offset on window
        DC.W    $11                ; gadget width
        DC.W    $09                ; gadget height
        DC.W    $06                ; Alternative Image type
        DC.W    $0101              ; TOGGLESELECT|RELVERIFY
        DC.W    $01                ; BOOLEAN
        DC.L    Buttonoff          ; Data for picture of gadget
        DC.L    Buttonon           ; Alternative image
        DC.L    Ctxt               ; text around gadget
        DC.L    $00                ; no mutual exclude
        DC.L    $00                ; no special info
        DC.W    $04                ; Gadget Identification
        DC.L    $00                ; no User Data

Gadinfile:

; Gadget structure

        DC.L    Gadoutfile         ; next gadget
        DC.W    $38                ; x-offset on window
        DC.W    $40                ; y-offset on window
        DC.W    $69                ; gadget width
        DC.W    $0E                ; gadget height
        DC.W    $04                ; Inverted Image type
        DC.W    $01                ; RELVERIFY
        DC.W    $04                ; STRING
        DC.L    File               ; Data for picture of gadget
        DC.L    $00                ; Alternative image
        DC.L    Infiletxt          ; text around gadget
        DC.L    $00                ; no mutual exclude
        DC.L    Infileinfo         ; special string info
        DC.W    $05                ; Gadget Identification
        DC.L    $00                ; no User Data

Gadoutfile:

; Gadget structure

        DC.L    0                  ; no next gadget
        DC.W    $38                ; x-offset on window
        DC.W    $52                ; y-offset on window
        DC.W    $69                ; gadget width
        DC.W    $0E                ; gadget height
        DC.W    $04                ; Inverted Image type
        DC.W    $01                ; RELVERIFY
        DC.W    $04                ; STRING
        DC.L    File               ; Data for picture of gadget
        DC.L    $00                ; Alternative image
        DC.L    Outfiletxt         ; text around gadget
        DC.L    $00                ; no mutual exclude
        DC.L    Outfileinfo        ; special string info
        DC.W    $06                ; Gadget Identification
        DC.L    $00                ; no User Data

Inreq:

; Gadget structure

        DC.L    Outreq             ; next gadget
        DC.W    $18                ; x-offset on window
        DC.W    $3D                ; y-offset on window
        DC.W    $14                ; gadget width
        DC.W    $0E                ; gadget height
        DC.W    $04                ; Inverted Image type
        DC.W    $01                ; RELVERIFY
        DC.W    $01                ; BOOLEAN
        DC.L    FReq               ; Data for picture of gadget
        DC.L    $00                ; no other image
        DC.L    $00                ; no text around gadget
        DC.L    $00,$00            ; no exclude,no special info
        DC.W    $07                ; Gadget Identification
        DC.L    $00                ; no User Data

Outreq:

; Gadget structure

        DC.L    $00                ; no more gadgets for this window
        DC.W    $18                ; x-offset on window
        DC.W    $4F                ; y-offset on window
        DC.W    $14                ; gadget width
        DC.W    $0E                ; gadget height
        DC.W    $04                ; Inverted Image type
        DC.W    $01                ; RELVERIFY
        DC.W    $01                ; BOOLEAN
        DC.L    FReq               ; Data for picture of gadget
        DC.L    $00                ; no other image
        DC.L    $00                ; no text around gadget
        DC.L    $00,$00            ; no exclude,no special info
        DC.W    $08                ; Gadget Identification
        DC.L    $00                ; no User Data

Scripttxt:

; Intuitext structure

        DC.B    $02,$00,$01        ; FrontPen,BackPen,DrawMode

        Even                       ; Fill to make even address for word

        DC.W    $19,$01            ; Left edge, top edge
        DC.L    $00                ; No special font
        DC.L    Scriptx            ; The actual text
        DC.L    $00                ; No next text (try saying that fast!)

Pascaltxt:

; Intuitext structure

        DC.B    $02,$00,$01        ; FrontPen,BackPen,DrawMode

        Even                       ; Fill to make even address for word

        DC.W    $19,$01            ; Left edge, top edge
        DC.L    $00                ; No special font
        DC.L    Pascaltx           ; The actual text
        DC.L    $00                ; No next text 

Ctxt:

; Intuitext structure

        DC.B    $02,$00,$01        ; FrontPen,BackPen,DrawMode

        Even                       ; Fill to make even address for word

        DC.W    $19,$01            ; Left edge, top edge
        DC.L    $00                ; No special font
        DC.L    Ctx                ; The actual text
        DC.L    $00                ; No next text 

Infiletxt:

; Intuitext structure

        DC.B    $03,$00,$01        ; FrontPen,BackPen,DrawMode

        Even                       ; Fill to make even address for word

        DC.W    $73,$01            ; Left edge, top edge
        DC.L    $00                ; No special font
        DC.L    Infiletx           ; The actual text
        DC.L    $00                ; No next text 

Outfiletxt:

; Intuitext structure

        DC.B    $03,$00,$01        ; FrontPen,BackPen,DrawMode

        Even                       ; Fill to make even address for word

        DC.W    $73,$01            ; Left edge, top edge
        DC.L    $00                ; No special font
        DC.L    Outfiletx          ; The actual text
        DC.L    $00                ; No next text 

Atext:

; Intuitext structure

        DC.B    $02,$01,$01        ; FrontPen,BackPen,DrawMode

        Even                       ; Fill to make even address for word

        DC.W    $0D,$08            ; Left edge, top edge
        DC.L    $00                ; No special font
        DC.L    Atx                ; The actual text
        DC.L    $00                ; No next text

Ltext:

; Intuitext structure

        DC.B    $02,$01,$01        ; FrontPen,BackPen,DrawMode

        Even                       ; Fill to make even address for word

        DC.W    $06,$03            ; Left edge, top edge
        DC.L    $00                ; No special font
        DC.L    Ltx                ; The actual text
        DC.L    $00                ; No next text 

Rtext:

; Intuitext structure

        DC.B    $02,$01,$01        ; FrontPen,BackPen,DrawMode

        Even                       ; Fill to make even address for word

        DC.W    $06,$03            ; Left edge, top edge
        DC.L    $00                ; No special font
        DC.L    Rtx                ; The actual text
        DC.L    $00                ; No next text 

Infileinfo:

; Stringinfo structure

        DC.L    Infilebuff         ; Buffer for input text
        DC.L    Undobuff           ; Buffer for undo function (Amiga-Q)
        DC.W    $00                ; Buffer start position
        DC.W    $64                ; Number of characters
        DC.W    $00,$00,$00        ; DispPos,UndoPos,NumChars
        DC.W    $00,$00,$00        ; DispCount,CLeft,CTop
        DC.L    $00,$00,$00        ; Layer,LongInt,Keymap

Outfileinfo:

; Stringinfo structure

        DC.L    Outfilebuff        ; Buffer for input text
        DC.L    Undobuff           ; Buffer for undo function (Amiga-Q)
        DC.W    $00                ; Buffer start position
        DC.W    $64                ; Number of characters
        DC.W    $00,$00,$00        ; DispPos,UndoPos,NumChars
        DC.W    $00,$00,$00        ; DispCount,CLeft,CTop
        DC.L    $00,$00,$00        ; Layer,LongInt,Keymap

Arpfrequest:

; ARP requester structure.  I had tonnes of trouble with this one, and
; I'd like to thank George Knight, and his article on ARP requesters 
; from Megadisc #30B for assistance.  I'm still not too sure, so the
; structure explanations are brief.  Good Luck!

        DC.L    Winname            ; Window name
        DC.L    ArpFileBuff        ; buffer for file information
        DC.L    ArpDirBuff         ; buffer for dir information
        DC.L    0                  ; Window or NULL
        DC.B    40                 ; Function Flags
        DC.B    0                  ; Reserved - set to NULL
        DC.L    0                  ; Func to call for wildcards
        DC.L    0                  ; RESERVED

; Memory allocations

_ARPbase:       DS.L    $01        ; memory for arp base
_intuitionbase: DS.L    $01        ; memory for intuition base
_dosbase:       DS.L    $01        ; memory for dos base
_reqbase:       DS.L    $01        ; memory for req base
Winhd:          DS.L    $01        ; memory for window handle
Infilehd:       DS.L    $01        ; memory for infile handle
Outfilehd:      DS.L    $01        ; memory for outfile handle
Message:        DS.L    $01        ; memory for return message
Returnmsg:      DS.L    $01        ; memory for WB return message
Infilechar:     DS.B    $01        ; memory for one infile character
Infilebuff:     DS.B    $64        ; memory for name of infile
Outfilebuff:    DS.B    $64        ; memory for name of outfile
Undobuff:       DS.B    $64        ; memory for undo
ArpFileBuff:    DS.B    $1E        ; memory for File (from ARP requester)
ArpDirBuff:     DS.B    $46        ; memory for Dir (from ARP requester)
Optionflag:     DC.B    $00        ; memory for option flag
IsArpOpen:      DC.B    $00        ; memory for Requester flag

;       Script text
        
Scriptx:        DC.B    "Script",$00
Scstart:        DC.B    "echo ",$22
SIZEScstart:    =       *-Scstart  ; current address minus the last label
Scend:          DC.B    $22,LF     
SIZEScend:      =       *-Scend    ; current address minus the last label
Scblurb:        DC.B    LF,"; Courtesy of ADDTEXT - A N Peck (1995)",LF,LF
SIZEScBlurb:    =       *-Scblurb  ; current address minus the last label

;       Pascal text

Pascaltx:       DC.B    "Pascal",$00
Passtart:       DC.B    "Writeln (",Apost
SIZEPasstart:   =       *-Passtart ; current address minus the last label
Pasend:         DC.B    Apost,$29,$3B,LF
SIZEPasend:     =       *-Pasend   ; current address minus the last label
Pasblurb:       DC.B    LF,"{ Courtesy of ADDTEXT - A N Peck (1995) }",LF,LF
SIZEPasBlurb:   =       *-Pasblurb ; current address minus the last label

;       C text

Ctx:            DC.B    "C",$00
Cstart:         DC.B    "Printf (",$22
SIZECstart:     =       *-Cstart   ; current address minus the last label
Cend:           DC.B    $5C,$6E,$22,$29,$3B,LF
SIZECend:       =       *-Cend     ; current address minus the last label
Cblurb:         DC.B    LF,"/* Courtesy of ADDTEXT - A N Peck (1995) */",LF,LF
SIZECBlurb:     =       *-Cblurb   ; current address minus the last label

;       Other text

Infiletx:       DC.B    "Infile",$00
Outfiletx:      DC.B    "Outfile",$00
Atx:            DC.B    "Copy over old file?",$00
Ltx:            DC.B    "No",$00
Rtx:            DC.B    "Yes",$00
Winname:        DC.B    "Your choice:",$00 
Screentitle:    DC.B    "FREEWARE - 1995",$00
BigPath:        DC.B    "Path too long!",$00
NoInfile:       DC.B    "Select Infile!",$00
NoOutfile:      DC.B    "Select Outfile!",$00
NoOption:       DC.B    "Select Option!",$00
NoInfileAcc:    DC.B    "Can",Apost,"t access Infile!",$00
NoOutfileAcc:   DC.B    "Can",Apost,"t open Outfile!",$00 
Apostrophe:     DC.B    Apost,$00
Working:        DC.B    "Working...",$00
AllOk:          DC.B    "Finished!  Bye...",$00
Intname:        DC.B    "intuition.library",$00  ; intuition library name
Dosname:        DC.B    "dos.library",$00        ; dos library name
Arpname:        DC.B    "arp.library",$00        ; arp library name
Aslname:        DC.B    "asl.library",$00        ; arp library name

*********************************************************************
*                                                                   *
* Data                                                              *
* ----                                                              *
*                                                                   *
* Here are the images used, all converted by the wonderful program  *
* Convbrush by David Kinder.  There are various other similar       *
* utilities, but I like this one because it was written in Pascal!  *
* Using such images blows out the size of the executable a bit, but *
* gosh it looks pretty!                                             *
*                                                                   *
*********************************************************************

        Section Image,Data_C

Title           DC.W    0,0,189,41,2
                DC.L    Titledat
                DC.B    3,0
                DC.L    0
Titledat        DC.W    32767,65535,65535,65535,65535,65535,65535,65535
                DC.W    65535,65535,65535,65520,65535,65535,65535,65535
                DC.W    65535,65535,65535,65535,65535,65535,65535,65528
                DC.W    65535,65535,65535,65535,65535,65535,65535,65535
                DC.W    65535,65535,65535,65528,57344,00000,00000,00000
                DC.W    00000,00000,00000,00000,00000,00000,00000,00056
                DC.W    57344,00000,00000,00000,00000,00000,00000,00000
                DC.W    00000,00000,00000,00056,57344,03871,61431,65535
                DC.W    65535,49344,36979,52880,00000,00000,00000,00056
                DC.W    57344,08127,65535,65535,65535,57633,26764,12648
                DC.W    00000,00000,00000,00056,57344,08127,65535,65535
                DC.W    65535,58065,10421,61264,00000,00000,00000,00056
                DC.W    57344,08159,65535,65535,65535,58065,18612,43296
                DC.W    00000,00000,00000,00056,57344,16351,65535,65535
                DC.W    65535,57873,26765,61264,00000,00000,00000,00056
                DC.W    57344,16351,65535,65535,65535,58065,26804,12648
                DC.W    00000,00000,00000,00056,57344,16351,65535,64511
                DC.W    65215,16672,36931,52880,00000,00000,00000,00056
                DC.W    57344,16383,65535,64510,64575,00000,00000,00000
                DC.W    00000,00000,00000,00056,57344,16383,65535,64510
                DC.W    65087,00198,01100,58145,10243,47104,00000,00056
                DC.W    57344,32767,65535,64510,65087,00297,02739,05330
                DC.W    54276,17408,00000,00056,57344,32767,65535,64511
                DC.W    65343,00726,35757,27474,54283,43008,00000,00056
                DC.W    57344,32767,65535,64511,65343,00553,02733,06994
                DC.W    54276,43008,00000,00056,57344,32767,65535,64511
                DC.W    65471,00726,35117,22622,55047,26624,00000,00056
                DC.W    57344,32767,65535,64511,65471,00297,02739,27459
                DC.W    12424,43008,00000,00056,57344,65535,65535,65535
                DC.W    65535,32966,01100,38076,52999,04096,00000,00056
                DC.W    57344,65535,65531,65535,65535,32768,00000,00000
                DC.W    00000,00000,00000,00056,57344,32767,61425,64511
                DC.W    65471,00275,14536,39207,12312,60942,12560,00056
                DC.W    57344,00000,00000,00000,00000,00684,50485,26328
                DC.W    51237,04369,19112,00056,57344,00000,00000,00000
                DC.W    00000,00747,23250,23127,46170,59918,46280,00056
                DC.W    57344,00000,00000,00000,00000,00683,18133,23188
                DC.W    46170,35337,35496,00056,57344,00000,00000,00000
                DC.W    00000,00584,22039,17110,33858,59927,46760,00056
                DC.W    57344,00151,00256,08191,65472,00683,23253,23256
                DC.W    46171,06672,52292,00056,57344,00511,33664,04607
                DC.W    08128,00276,42280,42279,18468,58383,13240,00056
                DC.W    57344,00511,51072,07934,61376,00000,00000,00000
                DC.W    00000,00000,00000,00056,57344,00511,33664,08191
                DC.W    65472,00201,15288,51315,00000,00000,00000,00056
                DC.W    57344,00255,37760,08123,64448,00310,50245,13452
                DC.W    32768,00000,00000,00056,57344,00255,65472,08135
                DC.W    64576,00726,47834,54363,16384,00000,00000,00056
                DC.W    57344,00103,37760,08191,65472,00726,51910,54363
                DC.W    16384,00000,00000,00056,57344,00000,00000,00000
                DC.W    00000,00534,63190,05976,16384,00000,00000,00056
                DC.W    57344,00000,00000,00000,00000,00729,35546,53387
                DC.W    16384,00000,00000,00056,57344,00000,00000,00000
                DC.W    00000,00294,28965,12148,32768,00000,00000,00056
                DC.W    57344,00000,00000,00000,00000,00000,00000,00000
                DC.W    00000,00000,00000,00056,57344,00000,00000,00000
                DC.W    00000,00000,00000,00000,00000,00000,00000,00056
                DC.W    65535,65535,65535,65535,65535,65535,65535,65535
                DC.W    65535,65535,65535,65528,65535,65535,65535,65535
                DC.W    65535,65535,65535,65535,65535,65535,65535,65528
                DC.W    32767,65535,65535,65535,65535,65535,65535,65535
                DC.W    65535,65535,65535,65520
                DC.W    32767,65535,65535,65535,65535,65535,65535,65535
                DC.W    65535,65535,65535,65520,40960,00000,00000,00000
                DC.W    00000,00000,00000,00000,00000,00000,00000,00040
                DC.W    49151,65535,65535,65535,65535,65535,65535,65535
                DC.W    65535,65535,65535,65512,40960,00000,00000,00000
                DC.W    00000,00000,00000,00000,00000,00000,00000,00040
                DC.W    40960,00000,00000,00000,00000,00000,00000,00000
                DC.W    00000,00000,00000,00040,40960,00000,00000,00000
                DC.W    00000,00000,00000,00000,00000,00000,00000,00040
                DC.W    40960,03103,36807,64507,52991,00192,36979,52880
                DC.W    00000,00000,00000,00040,40960,03084,50790,55705
                DC.W    36059,00288,53322,04256,00000,00000,00000,00040
                DC.W    40960,03596,26164,51593,34969,00288,45131,04288
                DC.W    00000,00000,00000,00040,40960,05644,26164,51592
                DC.W    53401,00480,36978,04256,00000,00000,00000,00040
                DC.W    40960,05644,26160,49536,53272,00288,36931,52880
                DC.W    00000,00000,00000,00040,40960,05644,26160,49552
                DC.W    24600,00000,00000,00000,00000,00000,00000,00040
                DC.W    40960,04876,26160,49648,24600,00000,00000,00000
                DC.W    00000,00000,00000,00040,40960,04876,26160,49552
                DC.W    28696,00000,00000,00000,00000,00000,00000,00040
                DC.W    40960,08972,26160,49536,28696,00198,01100,58145
                DC.W    10243,47104,00000,00040,40960,08972,26160,49536
                DC.W    38936,00265,01106,38049,10244,04096,00000,00040
                DC.W    40960,16268,26160,49544,38936,00454,01362,58529
                DC.W    10243,04096,00000,00040,40960,08588,26160,49545
                DC.W    03096,00297,01746,42913,10240,36864,00000,00040
                DC.W    40960,08588,50784,49561,03096,00198,01100,38076
                DC.W    52999,04096,00000,00040,40960,29663,36801,58363
                DC.W    40508,00000,00000,00000,00000,00000,00000,00040
                DC.W    40960,00000,00000,00000,00000,00000,00000,00000
                DC.W    00000,00000,00000,00040,40960,00000,00000,00000
                DC.W    00000,00000,00000,00000,00000,00000,00000,00040
                DC.W    40960,00000,00000,00000,00000,00275,14536,39207
                DC.W    12312,60942,12560,00040,40960,00000,00000,00000
                DC.W    00000,00276,42285,42408,18469,01025,17200,00040
                DC.W    40960,00000,00000,00000,00000,00340,47402,42347
                DC.W    18469,01030,28944,00040,40960,00000,00000,16383
                DC.W    65504,00439,43496,48425,30781,01032,18704,00040
                DC.W    40960,00000,00000,08192,00032,00276,42280,42279
                DC.W    18468,58383,13240,00040,40960,00151,00256,11832
                DC.W    58272,00000,00000,00000,00000,00000,00000,00040
                DC.W    40960,00144,33536,08517,05152,00000,00000,00000
                DC.W    00000,00000,00000,00040,40960,00147,00256,08322
                DC.W    02080,00000,00000,00000,00000,00000,00000,00040
                DC.W    40960,00100,00256,08517,05152,00201,15288,51315
                DC.W    00000,00000,00000,00040,40960,00103,37760,11832
                DC.W    58272,00297,16677,10276,32768,00000,00000,00040
                DC.W    40960,00000,00000,08192,00032,00297,12601,10276
                DC.W    32768,00000,00000,00040,40960,00000,00000,16383
                DC.W    65504,00489,02345,59431,32768,00000,00000,00040
                DC.W    40960,00000,00000,00000,00000,00294,28965,12148
                DC.W    32768,00000,00000,00040,40960,00000,00000,00000
                DC.W    00000,00000,00000,00000,00000,00000,00000,00040
                DC.W    40960,00000,00000,00000,00000,00000,00000,00000
                DC.W    00000,00000,00000,00040,40960,00000,00000,00000
                DC.W    00000,00000,00000,00000,00000,00000,00000,00040
                DC.W    49151,65535,65535,65535,65535,65535,65535,65535
                DC.W    65535,65535,65535,65512,40960,00000,00000,00000
                DC.W    00000,00000,00000,00000,00000,00000,00000,00040
                DC.W    32767,65535,65535,65535,65535,65535,65535,65535
                DC.W    65535,65535,65535,65520

Generate        DC.W    $00,$00,$59,$0D,$02
                DC.L    Generatedat
                DC.B    $03,$00
                DC.L    $00
Generatedat     DC.W    00000,00000,00000,00000,00000,00128,00000,00000
                DC.W    00000,00000,00000,00384,00000,00463,48379,51007
                DC.W    31744,00384,00000,01023,65535,61439,65024,00384
                DC.W    00000,02047,65535,65535,64512,00384,00000,01982
                DC.W    32743,65502,61440,00384,00000,02047,32759,65502
                DC.W    63488,00384,00000,02046,32743,65502,61440,00384
                DC.W    00000,02047,65535,65502,64512,00384,00000,01023
                DC.W    65535,65502,65024,00384,00000,00463,46843,28044
                DC.W    31744,00384,00000,00000,00000,00000,00000,00384
                DC.W    32767,65535,65535,65535,65535,65408
                DC.W    65535,65535,65535,65535,65535,65280,49152,00000
                DC.W    00000,00000,00000,00000,49152,00000,00000,00000
                DC.W    00000,00000,49152,00463,48379,51007,31744,00000
                DC.W    49152,00812,14019,28556,24576,00000,49152,00780
                DC.W    14019,28044,24576,00000,49152,00782,14051,28044
                DC.W    28672,00000,49152,00876,14019,53132,24576,00000
                DC.W    49152,00876,14019,28044,24576,00000,49152,00463
                DC.W    46843,28044,31744,00000,49152,00000,00000,00000
                DC.W    00000,00000,49152,00000,00000,00000,00000,00000
                DC.W    32768,00000,00000,00000,00000,00000

Buttonon        DC.W    $00,$00,$11,$09,$02
                DC.L    Buttonondat
                DC.B    $03,$00
                DC.L    $00
Buttonondat     DC.W    16380,00000,24576,00000,51184,00000,53240,00000
                DC.W    53240,00000,53240,00000,51184,00000,24576,00000
                DC.W    08192,00000
                DC.W    00002,00000,00003,00000,02033,32768,04089,32768
                DC.W    04089,32768,04089,32768,02033,32768,00003,00000
                DC.W    08190,00000

Buttonoff       DC.W    $00,$00,$11,$09,$02
                DC.L    Buttonoffdat
                DC.B    $03,$00
                DC.L    $00
Buttonoffdat    DC.W    00002,00000,00003,00000,00001,32768,00001,32768
                DC.W    00001,32768,00001,32768,00001,32768,00003,00000
                DC.W    08190,00000
                DC.W    16380,00000,24576,00000,49152,00000,49152,00000
                DC.W    49152,00000,49152,00000,49152,00000,24576,00000
                DC.W    08192,00000

FReq            DC.W    0,0,20,14,2
                DC.L    FReqdat
                DC.B    3,0
                DC.L    0
FReqdat         DC.W    00000,04096,00000,12288,00060,12288,00066,12288
                DC.W    03969,12288,04033,12288,03135,12288,03073,12288
                DC.W    03073,12288,03073,12288,04095,12288,00000,12288
                DC.W    00000,12288,32767,61440
                DC.W    65535,57344,49152,00000,49152,00000,49152,00000
                DC.W    49152,00000,49152,00000,49152,00000,49152,00000
                DC.W    49152,00000,49152,00000,49152,00000,49152,00000
                DC.W    49152,00000,32768,00000

File            DC.W    -$07,-$03,$72,$0E,$02
                DC.L    Filedat
                DC.B    $03,$00
                DC.L    $00
Filedat         DC.W    00000,00000,00000,00000,00000,00000,00000,00000
                DC.W    32767,65535,65535,65535,65535,65535,65535,16384
                DC.W    16384,00000,00000,00000,00000,00000,00000,16384
                DC.W    16384,00000,00000,00000,00000,00000,00000,16384
                DC.W    16384,00000,00000,00000,00000,00000,00000,16384
                DC.W    16384,00000,00000,00000,00000,00000,00000,16384
                DC.W    16384,00000,00000,00000,00000,00000,00000,16384
                DC.W    16384,00000,00000,00000,00000,00000,00000,16384
                DC.W    16384,00000,00000,00000,00000,00000,00000,16384
                DC.W    16384,00000,00000,00000,00000,00000,00000,16384
                DC.W    16384,00000,00000,00000,00000,00000,00000,16384
                DC.W    16384,00000,00000,00000,00000,00000,00000,16384
                DC.W    00000,00000,00000,00000,00000,00000,00000,16384
                DC.W    65535,65535,65535,65535,65535,65535,65535,49152
                DC.W    65535,65535,65535,65535,65535,65535,65535,32768
                DC.W    32768,00000,00000,00000,00000,00000,00000,32768
                DC.W    32768,00000,00000,00000,00000,00000,00000,32768
                DC.W    32768,00000,00000,00000,00000,00000,00000,32768
                DC.W    32768,00000,00000,00000,00000,00000,00000,32768
                DC.W    32768,00000,00000,00000,00000,00000,00000,32768
                DC.W    32768,00000,00000,00000,00000,00000,00000,32768
                DC.W    32768,00000,00000,00000,00000,00000,00000,32768
                DC.W    32768,00000,00000,00000,00000,00000,00000,32768
                DC.W    32768,00000,00000,00000,00000,00000,00000,32768
                DC.W    32768,00000,00000,00000,00000,00000,00000,32768
                DC.W    32768,00000,00000,00000,00000,00000,00000,32768
                DC.W    65535,65535,65535,65535,65535,65535,65535,32768
                DC.W    00000,00000,00000,00000,00000,00000,00000,00000

                End     ; Adios Amigas
                



