
highlight converts source code to HTML, XHTML, RTF or La(Tex) with syntax
highlighting (HTML formatted by Cascading Style Sheets).

--------------
Deutsch: siehe unten...
---------------

highlight converts sourcecode to (x)html, RTF or TEX files with syntax highlighting.
(X)HTML is formatted by Cascading Style Sheets. So you can store the style information
in one file and change the style anytime without problems, affecting all html files
which reference the style file.
The former formatting with <font>-tags is deprecated by the W3C and should not be
used any longer. CSS-formatted files are also smaller sized than the <font>-
formatted ones.

FEATURES:
- highlighting of keywords, strings, numbers, escape characters, directive lines
  and comments
- output of linenumbers
- output in HTML, XHTML 1.0, RTF, TeX or LaTeX format
- choice to include the CSS-definitions into the output file or to save them in
  a seperate CSS-file ((X)HTML only)
- 2 built-in highlight-styles (emacs and kwrite)


HOW IT WORKS:

You can get the help by typing highlight -h:

  -b, --batch=<wildcard>         convert all matching files in current directory
                                 (Example: highlight -b cpp)
  -d, --hilfe                    gibt eine deutsche Hilfe aus
  -f, --fragment                 omit file header and footer
  -h, --help                     print this help
  -i, --input=<file>             name of input file
  -l, --linenumbers              print line numbers in output file
  -S, --syntax=<type>          specify type of source code
  -o, --output=<file>            name of output file
  -s, --style=<style>            specify CSS-style which should be used
                                 (emacs | kwrite)
  -t, --deletetabs=<num>         replace tabs by num spaces
  -v, --verbose                  print debug info to stderr
  -L, --latex                    generate LaTeX file
  -R, --rtf                      generate RTF file
  -T, --tex                      generate TeX file
  -X, --xhtml                    generate XHTML 1.0 file

      --version                  print version and copyright information

  (X)HTML options:
  -c, --cssfilename=<file>       name of CSS-definition file
  -I, --includecss               include CSS-definition in HTML-file


highlight uses stdin/stdout if no in-/outfile-parameters are given.
The following commands write the content of hello.c to hello.html:

highlight -o hello.html -i hello.c
highlight -o hello.html hello.c
highlight -o hello.html -L c < hello.c
highlight -L c < hello.c > hello.html

If no inputfile is given, you have to pass highlight the usual file-suffix of
the sourcecode files via -L. If you want to convert a c-file, highlight looks
after the c.lang - language definition file, for example. If there exist
multiple suffixes (like c, C, cc, cpp with c/c++ - files), highlight tries
to fetch the matching language definition file.

In batch mode, highlight will save the generated files with the original filename,
appending .html or .xhtml, if -x is set.

Example:

highlight -xb cpp
converts all *.cpp files in the current directory to xhtml files.

Concerning (X)HTML output:
You may include the CSS-definitions in the html output file, or save them in
an external css file. If you do not set any option regarding this, highlight
saves the css crap in "highlight.css" in the same directory where you invoked
it, and inserts a link to "highlight.css" in the outfile. You can set the name
of the css file by -c. highlight will try to save the css definitions in the
given path.
Beware: Existing css files will not be overwritten.

LANGUAGE DEFINITION FILES:

It is easy to make own definition files. Just put all keywords and symbols (like
comment etc) of the programming language in the right category. Save the new file
in /usr/share/highlight or /usr/local/bin/highlight with the following name:
<usual suffix of sourcecode files>.lang
Examples: PHP -> php.lang, Java -> java.lang

FORMAT OF FILE:

Comments start with # as the first character in a line.

Scr2css will read the following parameters:

# List of keywords:
KEYWORDS=<List>

# List of types and type-modifiers
TYPESMODS=<List>

# List of String delimiters
STRINGDELIMITERS=<List>

# List of strings which start one line comments
SINGLELINECOMMENT=<List>

# comment begin and end (delimiters of multi-line comments)
MULTILINECOMMENT=<comment_begin comment_end>

# set to true/yes if programming language is case sensitive
ISCASESENSITIVE=<true|yes / false>

# beginning string of preprocessor directive lines
# ending symbols are not recogniced yet (like Pascal {$..} )
DIRECTIVE=<1 string>

# List of escape characters in Strings (normally "\")
ESCCHAR=<List>

IMPORTANT: All keywords etc must be in ONE line! Strings after a newline will
be ignored! (maybe fixed in release 0.2)

You may copy keywords from  syntax files of other programmes like VIM.


Example:

---

#Content of pas.lang (Pascal/Objekt Pascal)

KEYWORDS=true false if else then nil maxint [...] implementation uses private public

TYPESMODS=array boolean char integer file pointer real set string text record

STRINGDELIMITERS=" '

SINGLELINECOMMENT=//

MULTILINECOMMENT={ }

ISCASESENSITIVE=false

---

It would be cool to receive some new definition files (saalen@gmx.de) ;))

------------------------
André Simon
saalen@gmx.de
http://www.saalen.de.vu/



##############################################################################




DEUTSCH:

highlight konvertiert Sourcecode in XHTML, HTML, RTF oder (LA)TEX-Dateien mit
Syntaxhervorhebung. HTML wird mit Cascading Style Sheets formatiert.
So kann man die Gestaltung der HTML-Dateien in einer zentralen CSS-Datei speichern
und jederzeit ohne Probleme aendern. Die bisher uebliche Art der Schriftformatierung
mit <font>-Tags wurde vom W3C-Konsortium auf die Abschussliste gesetzt und sollte
daher nicht mehr eingesetzt werden. Ausserdem sind die CSS-formatierten HTML-
Dateien kleiner als diejenigen, die mit <font> formatiert werden.

FEATURES:

- Hervorhebung von Schlüsselwörtern, Strings, Zahlen, Escape Character, Direktiven
  und Kommentaren
- Ausgabe im HTML-, XHTML-, RTF-, TeX, oder LaTeX- Format
- Ausgabe von Zeilennummern
- Speichern der CSS-Definition wahlweise in separater Datei oder innerhalb der
  Ausgabedatei
- 2 eingebaute CSS-Stile (emacs and kwrite)


FUNKTIONSWEISE:

Die Parameter von highlight koennen mit "highlight -h" abgerufen werden:

  -b, --batch=<wildcard>         konvertiert alle Dateien mit der Endung <wildcard>
                                 im aktuellen Verzeichnis (Beispiel: highlight -b cpp)
  -d, --hilfe                    gibt diese Hilfe aus
  -f, --fragment                 Header/Footer wird weggelassen
  -h, --help                     prints english help
  -i, --input=<file>             Name der Eingabedatei
  -l, --linenumbers              gibt Zeilennummern in Ausgabe aus
  -S, --syntax=<type>            gibt den Typ des Quelltextes an
  -o, --output=<file>            Name der Ausgabedatei
  -s, --style=<style>            gibt den zu verwendenden Farbstil an
                                 (emacs | kwrite)
  -t, --deletetabs=<num>         ersetzt Tabs durch num Leerzeichen
  -v, --verbose                  gibt Debug-Info nach stderr aus
  -L, --latex                    gibt eine LaTeX - Datei aus
  -R, --rtf                      gibt eine RTF- Datei aus
  -T, --tex                      gibt eine TeX - Datei aus
  -X, --xhtml                    gibt eine XHTML 1.0 - Datei aus

      --version                  gibt Versionshinweis aus

  (X)HTML -Optionen:
  -c, --cssfilename=<file>       Name der CSS-Definitionsdatei
  -I, --includecss               fuegt CSS-Definition in HTML-Datei ein


Nuetzlich ist die automatische Aus- und Eingabe nach stdout bzw. stdin, wenn
die entsprechenden Parameter (Name der Ein- bzw Ausgabedatei) beim Aufruf
weggelassen werden.

Folgende Aufrufe schreiben den Inhalt von hallo.c nach hallo.html:

highlight -o hallo.html -i hallo.c
highlight -o hallo.html hallo.c
highlight -o hallo.html -L c < hallo.c
highlight -L c < hallo.c > hallo.html

Wenn kein Name der Eingabedatei angegeben wird, muss mit -L die uebliche
Endung dieser Datei angegeben werden, weil highlight zB bei einer .c-Datei
nach der Sprachdefinitionsdatei c.lang sucht. highlight ist allerdings in der
Lage, bei mehreren gebraeuchlichen Endungen die passende lang-Datei zu finden
(zB C, cpp, cc, h bei C/C++ -Sourcecode).

Im Batchmodus speichert highlight die generierten Dateien unter dem Originalnamen mit
der Endung .html (.xhtml, wenn -x gesetzt wurde) ab.

Beispiel:

highlight -xb cpp
Konvertiert alle *.cpp Dateien im aktuellen Verzeichnis in XHTML-Dateien.

Zur (X)HTML-Ausgabe:
Man kann angeben, ob die CSS-Definitionen innerhalb der HTML-Datei gespeichert
werden sollen oder in einer zentralen css-Datei ausgelagert werden.
Wird kein diesbezüglicher Parameter angegeben, werden die CSS-Definitionen in der
Datei highlight.css im aktuellen Verzeichnis  gespeichert und innerhalb der neuen
HTML-Datei wird ein Verweis auf "highlight.css" angelegt.
Mit der -c Option kann dieser Verweis jedoch angepasst werden (zB dann noetig,
wenn sich die HTML-Dateien in einem anderen Verzeichnis als die CSS-Datei befinden.)
highlight versucht dann, unter dem angegebenen Pfad die CSS-Datei anzulegen.
Achtung: highlight ueberschreibt dabei keine vorhandenen CSS-Dateien!

SPRACHDEFINITIONSDATEIEN:

Es ist ziemlich simpel, eigene Sprachdefinitionen zu erstellen. Man muss bloss
alle Schluesselwoerter und Symbole (wie zB Anfang von Kommentaren) der jeweiligen
Programmiersprache bestimmten Parametern zuweisen. Die Datei muss dann im
Verzeichnis von highlight (/usr/share/highlight oder /usr/local/bin/highlight) unter
folgendem Namen gespeichert werden:
<Uebliche Endung der Sourcecodedateien>.lang
Bei PHP also php.lang, bei C c.lang etc.

Format der Datei:

Kommentare beginnen mit #.
# muss das erste Zeichen in der Zeile sein!

highlight liest folgende Parameter ein:

# Liste der Schluesselwoerter
KEYWORDS=<Liste Bez.>

# Liste der Typen und Typ-Modifizierer
TYPESMODS=<Liste Bez.>

# Liste der Stringbegrenzer
STRINGDELIMITERS=<Liste Bez.>

# Liste der Bezeichner, die einen einzeiligen Kommentar einleiten
SINGLELINECOMMENT=<Liste Bez.>

# Kommentarbeginn  und -ende beim mehrzeilgen Kommentar
MULTILINECOMMENT=<Bez. Kommentarbeginn UND Bez. Kommentarende>

# Falls Programmiersprache case-sensitive ist, auf true/yes setzen
ISCASESENSITIVE=<true|yes / false>

# Einleitender Bezeichner von Compilerdirektiven
# zur Zeit werden keine abschliessenden Symbole erkannt, wie sie zB in Pascal noetig waeren ( {$..} )
DIRECTIVE=< 1 Bez.>

# Liste der Escapecharacter innerhalb von Strings (normalerweise \)
ESCCHAR=<Liste Bez.>

WICHTIG: Alle Bezeichner muessen in EINER Zeile stehen! Bei Zeilenumbruch wird
die Eingabe abgebrochen (das wird evtl. in highlight 0.2 verbessert).

Beim Erstellen neuer Dateien kann man die Schluesselwoerter aus Dateien anderer
Programme mit Syntaxhighlighting (z.B VIM) kopieren.


Beispiel:

---

#Inhalt von pas.lang (Pascal/Objekt Pascal)


KEYWORDS=true false if else then nil maxint [...] implementation uses private public

TYPESMODS=array boolean char integer file pointer real set string text record

STRINGDELIMITERS=" '

SINGLELINECOMMENT=//

MULTILINECOMMENT={ }

ISCASESENSITIVE=false

---

Waere cool, ein paar neue Definitionen zu bekommen (saalen@gmx.de) ;))

------------------------

André Simon
saalen@gmx.de
http://www.saalen.de.vu/
