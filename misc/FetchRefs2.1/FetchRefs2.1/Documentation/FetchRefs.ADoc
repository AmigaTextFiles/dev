TABLE OF CONTENTS

FetchRefs/FR_ADD
FetchRefs/FR_CLEAR
FetchRefs/FR_GET
FetchRefs/FR_NEW
FetchRefs/FR_QUIT
FetchRefs/FR_FILE
FetchRefs/FR_REQ
FetchRefs/FR_ADD                                       FetchRefs/FR_ADD

   NAME
	FR_ADD -- load additional index files

   SYNOPSIS
	FR_ADD FILES/M

	FR_ADD [wildcard [...]]

   FUNCTION
	FR_ADD will load extra	index files and add  them to the  internal
	list. The index files already in memory are not removed.

   INPUTS
	FILES/M - wildcard specification(s) for the index files to load.

   RESULTS
	None.

   BUGS
	None known.

   SEE ALSO
	FR_CLEAR, FR_NEW

FetchRefs/FR_CLEAR                                     FetchRefs/FR_CLEAR

   NAME
	FR_CLEAR -- remove any index files from memory

   SYNOPSIS
	FR_CLEAR

   FUNCTION
	Frees all memory allocated  to store loaded  index files. Most	of
	the memory FetchRefs uses is the index so this will put  FetchRefs
	into a low-memory sleep  mode. By later  calling FR_ADD or  FR_NEW
	the original state can be restored.

   INPUTS
	None.

   RESULTS
	None.

   BUGS
	None known.

   SEE ALSO
	FR_ADD, FR_NEW

FetchRefs/FR_GET                                       FetchRefs/FR_GET

   NAME
	FR_GET -- get a reference into a file or the clipboard

   SYNOPSIS
	FR_GET FIND/A,TO/A,PUBSCREEN,FILEREF/S,CASE/S

	FR_GET <keyword> <filename> [public screen name] [FILEREF] [CASE]

   FUNCTION
	Searches the index list for a  name matching the FIND keyword  and
	writes it to the file specified by TO.

	The FIND argument  is a wildcard.  Thus you can  search on  things
	like 'Open#?'  and get  a  long list  of functions  starting  with
	'Open'. Many more wildcards exist; all the standard AmigaDOS  ones
	are accepted.  However,  though  FR_GET  supports  wildcards,  the
	provided ARexx scripts do not!

	If you need wildcarding capabilities you  can put the cursor on  a
	space (see below)  before executing  the ARexx  script. This  will
	open `the <Select reference> window'  where all  wildcards can  be
	used in the pattern string gadget.

	When no matches are found, an error is returned. If excatly one is
	found, the reference is written  to the filename specified by  the
	TO argument.

	If the	supplied  keyword/wildcard  turns  out	to  match  several
	references, a window is opened. Read more about this window in the
	section named `the <Select reference> window', please. The  window
	will also open if the empty  string '' matches the wildcard.  This
	means that you can  position the cursor on  a space character  and
	invoke FetchRefs. Then the  window will open and  you can enter  a
	search pattern. Useful if you are going to look something up  that
	is not in your current source view.

	The screen on which the above mentioned window is to be opened	is
	specifed by using the PUBSCREEN argument. You specify the name	of
	a public screen  which may  not be  in private	mode (they  rarely
	are). If the  specified screen is  not available (non-existent  or
	non-public) or	if  you  do  not specify  PUBSCREEN  at  all  then
	FetchRefs will open  the window  on the  currently active  screen.
	Should this  not be  public, the  default public  screen  (usually
	Workbench) is used.
	No matter where the  window opens that screen  will be brought	to
	front (if it  is not already  there). When you  have finished  the
	selection and the window  closes, the screen  is again put  behind
	the other screens  (but only  if it was  brought to  front in  the
	first place).

	If the FILEREF argument is given,  each of the files in the  index
	file will be considered  a reference themselves.  The name of  the
	reference is the  filename without any	leading path or  suffixes.
	For example,  the  file 'DINCLUDE:Amiga30/exec/types.h'  would  be
	considered a match if  you search for  the reference 'types'.  The
	reason for  this truncation  is mainly	due to	the way  FetchRefs
	works otherwise; types.h must be  truncated at the dot if  'types'
	was a C structure and not  a file name - and FetchRefs really  has
	no way of knowing what it actually is, until the match is  already
	found; so, the most sensible idea seemed to trucate everything	at
	the first non alpha-numeric character.

	Depending on whether you set the CASE flag or not, the	comparison
	of the reference names is  either case sensitive (CASE  specified)
	or not. If you are very good at memorizing capitalization you  may
	want to turn it on -  personally I prefer to keep the search  case
	insensitive.

	To write  the reference  to the  clipboard instead  of a  file,  a
	filename of 'CLIPnn'  can be specified.  nn is the  number of  the
	clipboard unit	you  wish to  use.  The  'CLIP' word  must  be  in
	uppercase, otherwise the name is considered an usual file name.

   INPUTS
	FIND/A	  - name of reference to search for. Wildcards accepted.
	TO/A	  - file name to put the result into. 'CLIPnn' specifies
		    the clipboard unit nn.
	PUBSCREEN - public screen to open the "select reference" window
		    on. Default is the currently active screen (if public,
		    otherwise the default public screen).
	FILEREF   - let a reference search on the base name of a file
		    match with the entire file.
	CASE	  - activate case sensitive search.

   RESULTS
	Two results are returned.

	rc will be
	    0 if the reference was successfully written
	    5 if `the <Select reference> window' was cancelled/closed
	   10 if no match was found for the specified search pattern
	   20 if an error (no memory, etc.) happend during the fetch

	rc2 contains  additional information;  if  rc is  0 then  it  will
	contain a number specifying what  line the editor should move  the
	cursor to after having loaded  the generated file. This line  will
	contain the core of  the requested reference. If  rc is 5, 10,	or
	20, rc2 will be a string  describing what went wrong. This can	be
	passed on to the user through the editor (requester, title line).

   BUGS
	None known.

   SEE ALSO

FetchRefs/FR_NEW                                       FetchRefs/FR_NEW

   NAME
	FR_NEW -- clear internal index list and load a new

   SYNOPSIS
	FR_NEW FILES/M

	FR_NEW [wildcard ...]

   FUNCTION
	This is a combination  of FR_CLEAR and FR_ADD  and results in  the
	internal list being  set to  nothing but what's  specified by  the
	FILES arguments.

   INPUTS
	FILES/M - wildcard specification(s) describing what files to load
		  instead of the current list.

   RESULTS
	None.

   BUGS
	None known.

   SEE ALSO
	FR_ADD, FR_CLEAR

FetchRefs/FR_QUIT                                      FetchRefs/FR_QUIT

   NAME
	FR_QUIT -- force FetchRefs to quit

   SYNOPSIS
	FR_QUIT

   FUNCTION
	Will send a ^C signal to the FetchRefs process that owns the ARexx
	port. This  will force	FetchRefs to  free all	allocated  memory,
	close down the ARexx port, and exit.

	A similar  effect can  be achived  by using  the C:Break  program,
	running FetchRefs again, or by sending a ^C by any other means.

   INPUTS
	None.

   RESULTS
	None.

   BUGS
	None known.

   SEE ALSO

FetchRefs/FR_FILE                                      FetchRefs/FR_FILE

   NAME
	FR_FILE -- get the file(s) name(s) where the specified reference
	can be found.

   SYNOPSIS
	FR_FILE FIND/A,CASE/S

   FUNCTION
	This function is like @{"FR_GET" LINK 3.3.}, but it return the names of the files.
	where the reference(s) was found.

   INPUTS
	FIND/A	  - name of reference to search for. Wildcards accepted.
	CASE	  - activate case sensitive search.

   RESULTS
	Two results are returned.

	rc will be
		0 if the reference was successfully found
	       10 if no match was found for the specified search pattern
	       20 if an error (no memory, etc.) happend during the fetch

	rc2 contains  additional information;  if  rc is  0 then  it  will
	contain the name of the file where the reference is present. If
	several files were found, their names are separated by line feeds.
	If  rc is not 0, rc2 will be a string  describing what went wrong.
	This can  be passed on to the user through the editor (requester,
	title line).

   BUGS
	None known.

   SEE ALSO

FetchRefs/FR_REQ                                       FetchRefs/FR_REQ

   NAME
	FR_REQ -- get a reference into a file or the clipboard and open
	the FetchRefs requester

   SYNOPSIS
	FR_REQ FIND/A,TO/A,PUBSCREEN,FILEREF/S,CASE/S

	FR_REQ <keyword> <filename> [public screen name] [FILEREF] [CASE]

   FUNCTION
	Searches the index list for a  name matching the FIND keyword  and
	writes it to the file specified by TO.

	The FIND argument  is a wildcard.  Thus you can  search on  things
	like 'Open#?'  and get  a  long list  of functions  starting  with
	'Open'. Many more wildcards exist; all the standard AmigaDOS  ones
	are accepted.  However,  though  FR_GET  supports  wildcards,  the
	provided ARexx scripts do not!

	If you need wildcarding capabilities you  can put the cursor on  a
	space (see below)  before executing  the ARexx  script. This  will
	open `the <Select reference> window'  where all  wildcards can  be
	used in the pattern string gadget.

	When no matches are found, an error is returned. If excatly one is
	found, the reference is written  to the filename specified by  the
	TO argument.

	In every case  (one or more references found,  or no  reference at
	all,  a window is opened.  Read  more  about this  window  in  the
	section named `the <Select reference> window', please. The  window
	will also open if the empty  string '' matches the wildcard.  This
	means that you can  position the cursor on  a space character  and
	invoke FetchRefs. Then the  window will open and  you can enter  a
	search pattern. Useful if you are going to look something up  that
	is not in your current source view.

	The screen on which the above mentioned window is to be opened	is
	specifed by using the PUBSCREEN argument. You specify the name	of
	a public screen  which may  not be  in private	mode (they  rarely
	are). If the  specified screen is  not available (non-existent  or
	non-public) or	if  you  do  not specify  PUBSCREEN  at  all  then
	FetchRefs will open  the window  on the  currently active  screen.
	Should this  not be  public, the  default public  screen  (usually
	Workbench) is used.
	No matter where the  window opens that screen  will be brought	to
	front (if it  is not already  there). When you  have finished  the
	selection and the window  closes, the screen  is again put  behind
	the other screens  (but only  if it was  brought to  front in  the
	first place).

	If the FILEREF argument is given,  each of the files in the  index
	file will be considered  a reference themselves.  The name of  the
	reference is the  filename without any	leading path or  suffixes.
	For example,  the  file 'DINCLUDE:Amiga30/exec/types.h'  would  be
	considered a match if  you search for  the reference 'types'.  The
	reason for  this truncation  is mainly	due to	the way  FetchRefs
	works otherwise; types.h must be  truncated at the dot if  'types'
	was a C structure and not  a file name - and FetchRefs really  has
	no way of knowing what it actually is, until the match is  already
	found; so, the most sensible idea seemed to trucate everything	at
	the first non alpha-numeric character.

	Depending on whether you set the CASE flag or not, the	comparison
	of the reference names is  either case sensitive (CASE  specified)
	or not. If you are very good at memorizing capitalization you  may
	want to turn it on -  personally I prefer to keep the search  case
	insensitive.

	To write  the reference  to the  clipboard instead  of a  file,  a
	filename of 'CLIPnn'  can be specified.  nn is the  number of  the
	clipboard unit	you  wish to  use.  The  'CLIP' word  must  be  in
	uppercase, otherwise the name is considered an usual file name.

   INPUTS
	FIND/A	  - name of reference to search for. Wildcards accepted.
	TO/A	  - file name to put the result into. 'CLIPnn' specifies
		    the clipboard unit nn.
	PUBSCREEN - public screen to open the "select reference" window
		    on. Default is the currently active screen (if public,
		    otherwise the default public screen).
	FILEREF   - let a reference search on the base name of a file
		    match with the entire file.
	CASE	  - activate case sensitive search.

   RESULTS
	Two results are returned.

	rc will be
	    0 if the reference was successfully written
	    5 if `the <Select reference> window' was cancelled/closed
	   10 if no match was found for the specified search pattern
	   20 if an error (no memory, etc.) happend during the fetch

	rc2 contains  additional information;  if  rc is  0 then  it  will
	contain a number specifying what  line the editor should move  the
	cursor to after having loaded  the generated file. This line  will
	contain the core of  the requested reference. If  rc is 5, 10,	or
	20, rc2 will be a string  describing what went wrong. This can	be
	passed on to the user through the editor (requester, title line).

   BUGS
	None known.

   SEE ALSO

