<html>
<head>
<title>
IRKit KT Module Reference Documentation
</title>
</head>
<body>
<h1>IRKit KT Module Reference Documentation</h1>
<!-- -->
This page is still under construction.

<h3><a name="cs">Main Control Screen</a></h3>
<!-- -->
Global variable aIRKitScreen.  This control screen usually takes the same 
resolution and scan frequency as the main Workbench screen, but it normally 
overscan in order that the large <a href="#easel">main easel</a> can be 
smoothly scrolled.  It is usually 8 colours or more, normally grey.  It 
normally comes up as the program opens, often about half way up the monitor 
screen, and typically shows at the start a small <a 
href="panels.html#icp">initial control panel</a> and a <a 
href="#naming.strip">naming strip</a> along the top.
<p>
The main control screen is where <a href="#panels">panels</a> appear. 
These are of the traditional point-and-click GUI requester type, though 
most act more like multi-threaded windows such that other panels and also 
the main easel can still receive user actions while they are up.  Some act 
as requesters, in that only they can receive actions.

<h4><a name="naming.strip">Naming Strip</a></h4>
<!-- -->
The naming strip lies along the top of the <a href="#cs">main control 
screen</a> and has an area in the middle in which the meanings of items and 
attribute are displayed when the mouse passes over them.  It also has a 
number of buttons:
<p>
<ul>
<li>A double-ended up-down arrow:  Toggles the position of the control 
screen between top and its <a href="#park.pos">parking position</a>.
<li>A funny 'P':  Hit this to set the <a href="#park.pos">parking 
position</a>.
<li>A tick:  not yet used.
<li>A cross:  not yet used.
</ul>

<p>
<a NAME="park.pos">The parking position of the control screen is where it 
returns to in order that you can see the <a href="#easel">main easel</a>. 
Normally this will be somewhere down the bottom of the viewing area, but 
you can set it by dragging the screen to a new position using the thin two-
pixel screen line and then hitting the funny P gadget.

<h3><a name="easel">Main Easel</a></h3>
<!-- -->
In many programs built under IRKit there is a large main easel on which you 
can 'draw' knowledge.  This is usually larger than the main monitor area 
and smoothly scrollable.  It is your main work area, and sits just behind 
the <a href="#cs">control screen</a> and its various panels which help 
control details of your work.
<p>
There is usually one main easel per knowledge base so that if you have two 
knowledge bases loaded then two main easels are active.  In principle a 
knowledge base can have several easels, but at present no program does so.
<p>
As far as the operating system is concerned, the main easel is an Amiga 
screen in its own right, with screen bar and 'front-behind' gadget in top 
right corner.  It has one window, which is borderless and backdrop, and it 
is this that detects user activity and generates the IDCMP messsages.
<p>
As far as IRKit is concerned (or, rather, User Action Kit) the main easel 
is operated by one module and owned by either the same module or another. 
In Istar it is operated by BA module on behalf of its owner, KT, while in 
Annotator it is operated by DW module on behalf of Ann.

<h3><a name="box">Boxes on Main Easel</a></h3>
<!-- -->
On the main easel are either boxes or boxgroups, linked by lines that are 
arrows.  A <a NAME="boxgroup">boxgroup</a> is a group of boxes that move 
together, and are usually arranged in a vertical column.  Boxes can have <a 
NAME="labels">labels</a> in them.
<p>
A boxgroup normally <a href="#expression">expresses</a> an item and each 
box in the group normally expresses an attribute of the item.  However, in 
many boxgroups the topmost box expresses the item itself; by this means you 
can create relationships among the items.  Some boxgroups consist of single 
boxes only.  In most such cases, these express <a href="#freeatts">free 
attributes</a>.
<p>
You create a new box(group) (and its item) by pressing the LMB onto the 
easel, dragging to the correct position, and releasing.  You can move the 
boxgroup by pressing the LMB in the middle of one of its boxes and 
dragging.  You can resize a boxgroup as a whole by holding the Right Shift 
key down as you drag the edge or corner of the boxgroup.
<p>
The type of box is indicated by colours, line pattern and size and shape. 
This can be set for the item or attribute type and also varied for the 
individual instance.
<p>
Boxes on their own (single box in boxgroup) can express either items with 
no attributes, or free attributes.  If they cannot be distinguished by 
colour, shape, etc., they can be distinguished by clicking on them to see 
what panel comes up.
<p>
Clicking on various boxes (not boxgroups) in Istar gives different actions 
and according to whether you click with left or right mouse button:
<p>
<a NAME="click.table">  <TABLE BORDER></a>
    <TR>
  <td>
Semantic Object
  </td>
  <td>
LMB Click
  </td>
  <td>
RMB Click
  </td>
    </TR>

    <TR>
  <td>
Item Attribute
  </td>
  <td>
Attribute Action Panel
  </td>
  <td>
Attribute Details Panel
  </td>
    </TR>

    <TR>
  <td>
Free Attribute
  </td>
  <td>
Attribute Action Panel
  </td>
  <td>
Attribute Details Panel
  </td>
    </TR>

    <TR>
  <td>
Item: Most types
  </td>
  <td>
(nothing)
  </td>
  <td>
Item Details Panel
  </td>
    </TR>

    <TR>
  <td>
Item: Text Fragment
  </td>
  <td>
Text Panel
  </td>
  <td>
Item Details Panel
  </td>
    </TR>

    <TR>
  <td>
Item: Document
  </td>
  <td>
Lays out document on own screen/window
  </td>
  <td>
Item Details Panel
  </td>
    </TR>

    <TR>
  <td>
Item: Form
  </td>
  <td>
Override Form
  </td>
  <td>
Item Details Panel
  </td>
    </TR>

    <TR>
  <td>
Relationship
  </td>
  <td>
(nothing)
  </td>
  <td>
Relationship Details Panel
  </td>
    </TR>
      </TABLE>

<h3><a name="arrows">Arrows, Links, Lines</a></h3>
<!-- -->
Arrows, links, lines between boxes, express <a 
href="#relationships">relationships</a>.  Links are drawn only between 
boxes, and not between boxgroups.  (This is why if an item is to have 
relationships, it must be expressed by its own box.)  What this means is 
that inference relationships, for instance, can exist between the 
attributes of items - which is not easy in some software.
<p>
Links have no direction arrowheads on them; they normally flow left-to-
right by convention, and leave a box by a target point one quarter of the 
way in from the right, and arrive at a box by a target one quarter of the 
way in from the left.  (If you cannot see clearly which target a link 
leaves a box by, then move the box around a little, and you will see all 
its links following it.)
<p>
You draw an arrow by pressing LMB over the right or left edge of a box, and 
dragging the resultant line until it reaches another box.  You can insert 
bends as you draw by hitting the space bar.  You can bend an existing link 
by simply pulling it with the mouse, LMB.  You can move a bend by pulling 
the bend vertex with the mouse, LMB.  You can redirect a link from one box 
to another by holding down the Left Shift and pulling the end of the link 
over to the new box.
<p>
Clicking on a relationship link with RMB brings up its details; see <a 
href="#click.table">Click Table</a>.

<h3><a name="items">Items</a></h3>
<!-- -->
Items are conceptual things that represent important in your domain of 
knowledge, and are expressed on the <a href="#easel">main easel</a> by <a 
href="#boxgroups">boxgroups</a> and, sometimes, their own boxes.  Items can 
have <a href="#attributes">attributes</a> and can form <a 
href="#relationships">relationships</a> with other items.
<p>
<a NAME="item.name">
Each item has (can have) a <a href="#names">name</a> and <a 
href="#meaning">meaning</a></a>.  The meaning is a kind of long name, or 
what is often placed in a comment in a programming language.  This allows 
the precise meaning of the item to be held in the KB and made immediately 
available, and readily changed as different shades of meaning occur to the 
knowledge engineer.
<p>
Items have a defined <a href="#item.types">type</a>.
<p>
There are two classes of item:  normal items which represent something in 
your domain and which have properties held as <a 
href="#attributes">attributes</a>, and <a href="#freeatts">free attribute 
items</a> whose purpose is merely to support a single attribute.
<p>
The <a href="#kb.panel">KB Panel</a> has a list of <a 
href="#item.types">item types</a> from which to choose to draw.  You create 
a new item by drawing a box on the easel.  Normally free attribute items 
types are indicated by 'Free' in their name.
<p>
Details of each item can be found on the <a href="panels.html#idp">Item 
Details Panel</a>, on which you can alter the item from normal to free 
attribute item and back again.  With this panel you can alter the 
attributes of the item, renaming them, recolouring them, removing them, 
rearranging them and creating new ones.
<p>
<a NAME="adv.add.att">It is a feature of the IRKit system that you can add 
new attributes at any time to any item, without having to add them to the 
item type first.  In this way you can add extra information about 
individual items that pertain only to it and not to all items of its type.

      <h4><a name="names">
Names
      </a></h4><!-- -->
Anything can be named, individually, though for some things like 
relationships it makes little sense to name them.  (If you wish to name a 
relationship then hit the 'Treat as Item' button.)
      <p>
The naming mechanism allows both synonyms and homonyms, though in practice 
there is no gadget by which you can create a synonym at present.

<h3><a name="attributes">Attributes</a></h3>
<!-- -->
Attributes are holders of <a href="#values">values</a>.  They are often 
used to represent salient properties of <a href="#items">items</a>, but can 
be <a href="#freeatts">free attributes</a>.  Each attribute is expressed by 
a <a NAME="att.box">box</a> on the easel, which normally has a <a 
href="#labels">label</a> and may give some graphic expression of the 
attribute's <a href="#values">value</a>.
<p>
When an attribute is used to hold a property of an item its <a 
href="#boxes">box</a> is normally held in a boxgroup with those of other 
attributes.  In this case the attribute is in some way subservient to the 
item, and is equivalent to the attribute in a tuple in a relational 
database, or to the 'A' part of the OAV triple (object-attribute-value). 
In some senses such attributes can be seen as a kind of relationship 
between an <a href="#items">item</a> and a <a href="#values">value</a>, but 
in IRKit and Istar they have a much richer structure than this would imply.
<p>
Attributes have a <a href="#domains">domain</a> (or <a 
href="#domains">attribute type</a>).  This is often little different from a 
<a href="#value.types">value type</a> but usually implies some domain 
semantics and constraints.  For instance, the Enumeration value type (a 
member of a set) can be used for weekdays, in which there are seven 
possible value, or months, in which case there are twelve.  It is 
permissible to change the type (domain) of an attribute, and Istar will 
attempt to make a reasonable conversion of its value from one type to the 
other (e.g. an integer 57 will be converted to the string "57"). 
Sometimes, of course, conversion is not possible.  In any case you should 
check the value after changing the type.
<p>
As with <a href="#item.name">items</a> attributes can have names and 
meanings.
<p>
<a NAME="deriv">
Attributes can have their values derived in a number of ways</a>, the most 
common ones being:
<p>
<ul>
<li>constant value
<li>user supplied
<li>inferred from the values of other attributes by an <a 
href="#infce">inference engine</a>
<li>asynchronous, which is user-supplied but the inference engine does not 
wait for an answer to be given
<li>(later) supplied from other external sources e.g. other programs or the 
internet.
</ul>

<p>
Attributes normally hold two values, their main one and an <a 
href="#override">override value</a>.  The latter allows temporarily 
changing the value for the purposes of for example what-iffing or fixing.
<p>
These and other details of attributes are examined and altered via the <a 
href="panels.html#adp">Attribute Details Panel</a>.
<p>
<a NAME="adv.att.rels">
Unlike much other software, attributes can be treated as items and thus 
have <a href="#relationships">relationships</a> with other attributes, and 
even with other items.  The main types of relationship between attributes 
is that of <a href="#infce">inference</a>, by which an attribute has its 
value calculated automatically from the values of other attributes.  Other 
relationship types that attributes have include inclusion in a <a 
href="#forms">Form Item</a>.

      <h4><a name="ans.known">
<code>ANSWERED</code> and <code>KNOWN</code>
      </a></h4><!-- -->
Attributes have a state of being <code>ANSWERED</code></a> or not.  When 
<code>ANSWERED</code> they hold a value, when not, they are empty. 
<code>ANSWERED</code> is different from <code>KNOWN</code>. 
<code>KNOWN</code> refers to when the attribute has a value, but that value 
is not known.  The difference is illustrated by attempting to fill the 
attribute HouseNumber with a value by asking the question "What is the 
number of your friend's house?", to which the reply might be:
<p>
<ul>
<li>"Number 7" - it becomes both <code>ANSWERED</code> and 
<code>KNOWN</code>,
<li>"I don't know" - it becomes <code>ANSWERED</code> but not 
<code>KNOWN</code>, and
<li>"I'm not going to tell you" - it remains not answered 
<code>ANSWERED</code>, and if you *must* assign a value to it, it will be 
not (yet) <code>KNOWN</code>.
</ul>

<p>

      <h4><a name="im">
Inference Method
      </a></h4><!-- -->
Each attribute can carry an inference method, which is used when the <a 
href="#deriv">derivation</a> is 'inferred'.  Istar offers a host of these, 
from simple arithmetic like adding or subtracting, through probabilistic 
and Bayesian algorithms, to administrative ones like finding the first 
known attribute and how many have been answered.  What inference methods 
are valid depends on the attribute's <a href="#value.types">value type</a>; 
for instance, you can add two integers, two floating point numbers, two 
angles, but it doesn't make sense to try to add two booleans.  Sometimes an 
inference method seems to make half sense, such as adding two strings to 
mean concatenation, but whether this is allowed or not depends on the 
precise combination; in this case, you must use the inference method 
<code>Concatenate</code> rather than <code>add</code>.  A full list of <a 
href="im.html">inference methods</a> is available.

      <h4><a name="override">
Overriding an Attribute
      </a></h4><!-- -->

Overriding an attribute means (temporarily) replacing its main value with 
one supplied by you.  It is useful particularly when you distrust the 
inference that the KB has made - perhaps because you know you are working 
in an exceptional situation for which the normal knowledge is not entirely 
suitable.  You can force the value to be something of your own choice.
      <p>
To override an attribute, you must:
      <p>
      <ul>
<li>On the <a href="panels.html#adp">Attributes Details Panel</a> tick the 
'Can Override' button.
      <p>
<li><a href="driving.html#ok-act">Switch</a> to the <a 
href="panels.html#atac">Action Panel</a> and hit the 'Override' button.
      <p>
<li>Answer the <a href="panels.html#VAL">question panel</a> that appears.
      </ul>
      <p>
(There are also other ways of overriding, but that is the official way.)
      <p>
Note that once an attribute value has been overridden it is not reset by a 
'Reset' button; you must de-override it manually.  This might be changed in 
future, to allow some degree of automatic resetting.

<h3><a name="freeatts">Free Attributes</a></h3>
<!-- -->
Free attributes are single attributes within an item whose only purpose is 
to hold the attribute.  Thus such items are de-emphasized and have no box 
to express them.  It is inappropriate to consider such attributes as merely 
part of a relational tuple or as the 'A' of an OAV triple.  They are more 
like global variables in a programming language, but without many of the 
problems of global variables since their <a 
href="#relationships">relationships</a> are explicit rather than implicit.
<p>
Istar makes much use of free attributes for its inference net.
<p>
Free attribute items are defined internally has having exactly one 
attribute and not being expressed by a box of their own.

<h3><a name="values">Values</a></h3>
<!-- -->
Values are the contents of <a href="#attributes">attributes</a>.  They can 
be quantitative, of various <a href="value.types.html">kinds</a>, or 
qualitative.  When they are <a href="#expression">expressed</a> this is 
often by a line drawn in an <a href="#att.box">attribute box</a>.
<p>
While attributes have persistence values on their own do not.  e.g. 
HouseNumber is an attribute, but 'seven' is a numeric value.  It only 
persists once it has been placed into an attribute.  Attributes can be <a 
href="#ans.known"><code>ANSWERED</code> but values are 
<code>KNOWN</code></a>.
<p>
Whereas new <a href="#domains">attribute types</a> can be created, the 
range of value types is fixed.

<h3><a name="item.types">Item Types</a></h3>
<!-- -->
Each item is of a certain type.  That is, it is linked internally to a type 
block, which defines some things about it.  Item type blocks are also used 
in the creation of new items, and therefore hold the list of attributes 
that items of that type should have when first created.  Item types are 
normally not expressed visually on the <a href="#easel">easel</a>.
<p>
You can alter an item type via the <a href="panels.html#itp">Item Type 
Panel</a>, which is accessed by hitting the 'See' button on the <a 
href="panels.html#itl">KB Panel Item Type List</a>.  You can create a new 
item type by hitting the 'New' button.  You can get rid of an item type by 
hitting the 'Rid' button - but beware: this will also get rid of all its 
instances (individual items), though you do get a warning of this.
<p>
Each item type can have two <a NAME="std.reltypes">standard relationship 
types</a>, one when drawing relationships from the left edge of itemboxes 
of this type, and one when drawing from right.  This makes it easier when 
drawing relationships since the user does not have to take trouble to alter 
the relationship type.

<h3><a name="domains">Domains</a></h3>
<!-- -->
Domains are attribute types.  The word 'domain' comes from relational 
database theory, and means the set of values that an attribute can take. 
With some domains, such as of integers, the set is infinite, but with 
enumerated types, it is limited.
<p>
Thus a domain (or attribute type) comprises a <a href="#item.name">name and 
meaning</a>, a <a href="#value.types">value type</a>, possibly some 
constraint on permissible values, and possibly a set of names on the 
permitted values.  At present, the only constraint in a domain that is not 
inherent in the value type itself is that used in enumerated and ordinal 
types, in which an integer is used to identify members of a set such as 
weekdays.  Each such value is given a value name such as 'Monday'.  In 
addition, each domain in Istar also has details of the <a 
href="#att.box">attribute box</a> that would express each attribute of this 
domain.
<p>
Attribute types can be examined and altered via the <a 
href="panels.html#atp">Attribute Type Panel</a>, in which each of these 
details can be altered.

<h3><a name="value.types">Value Types</a></h3>
<!-- -->
Value types are built-in.  e.g. integer, floating-point number, 
probability, proportion, string, bayesian, boolean, etc.  Each value type 
has some means of internal storate, plus some defined operational semantics 
for how it is manipulated.  For instance, while integers can take any 
value, probabilities can only be between 0 and 1, so adding two 
probabilities of 0.7 together does not give 1.4.  There is automatic 
conversion between value types as far as possible.  See <a 
href="value.types.html">value.types.html</a> for those currently available.
<p>
The intention is that such things as colours, pictures, sound samples and 
even animations can be treated as values, each with their defined semantics 
or combination, conversion and comparison.

<h3><a name="relationships">Relationships</a></h3>
<!-- -->
Relationships are deliberate links between items, and also anything 
treatable as an item.  In inference attributes are treated like items and 
have an inference relationship between them.  Some are visible, <a 
href="#expression">expressed</a> as lines on the easel.  Others are 
normally invisible, created for various administrative purposes.
      <p>
<a NAME="ante">
<a NAME="cons">
<a NAME="invrel">
Most relationships are directional, having an <b>antecedent</b> (or source) 
and a <b>consequent</b> (or destination).  For instance, in "Andy hit 
Connie" Andy is the antecedent of the 'hit' relationship, and Connie is the 
consequent.  In Istar, Annotator and other programs based on IRKit, all 
relationships have <b>inverses</b> automatically, so that if you draw in a 
'hit' link between items Andy and Connie then you automatically get the two 
half-links "Andy hit Connie" and "Connie was-hit-by Andy".  In a lot of 
other software you would have to create both links individually - and 
maintain both too.
</a></a></a>
<p>
To draw a relationship, press the LMB over the left or right edge of a box 
that expresses an item or an attribute, and drag the moving line over to 
another box, and release LMB.  Then a relationship is created in the 
background that is expressed by this line.  The type of relationship 
created is defined by the <a href="#std.reltypes">standard relationship 
types</a> that the item type has.

      <h3><a name="lists">
Lists
      </a></h3><!-- -->

(Not to be confused with <a href="panels.html#panel.lists">Panel lists</a>, 
below.)
      <p>

Lists are ordered sets of things in the knowledge base, and you can use 
them for various purposes, and in future even more purposes.  They are 
created via the <a href="panels.html#list">Lists Panel</a> , which is 
brought up when you hit the Lists button on the <a 
href="panels.html#kbp">KB Panel</a>.  Database-aware people will see they 
are like 'relations' in a relational database, that are produced as a 
result of a relational operation.  (NOTE:  In that sentence 'relation' has 
almost *nothing* to do with relationship!  It is a jargon term of the 
database community.)  The purposes for which you might use a List include:
      <p>
<ul>
<li>  Goal Lists.  A <a href="#goal.list">Goal List</a> is a list of 
attributes from which backward chaining occurs when you hit the 
'InferGoals' button (and ResetGoals pre v1.1)  on the <a 
href="panels.html#kbp">KB Panel</a>.  See below.
      <p>
<li>  Volunteer Lists.  A <a href="#vol.lists">Volunteer List</a> is a 
similar list of attributes, normally question attributes, for which the 
user gives an answer and then their values are propagated throughout the 
KB.
      <p>
<li>  Override Lists.  <a href="#vol.lists">Lists of attributes</a> to <a 
href="#override">override</a> for various purposes.
      <p>
<li>  Analysis Lists.  These are lists of attributes, items or 
relationships that are in some way meaningful to you, normally for the 
purpose of analysis.  e.g. List of all attributes with more than 4 
antecedents.  e.g. List of all answered attributes.  They are useful 
especially when tracking things down in the KB.
      <p>
<li>  Shown Lists.  You can 'show' any List on the main Easel, hiding all 
things that do not belong to the list.
      <p>
<li>  These are only the start.  In future, you might be able to make up a 
list from items of a given type and then change the type of all of them, 
e.g. when 'vehicles' type must be split into two types 'cars' and 
'bicycles'.
</ul>
      <p>
You can add items or attributes manually to lists, one by one by selecting 
the list as the <a href="#goal.list">current goal list</a> and hitting the 
'Add Goal' button in the <a href="panels.html#atac">Attribute Action 
Panel</a>.
      <p>
Actually, lists are just a certain type of item, of the 'List' type - see 
in the <a href="panels.html#itl">Item Type List</a> - which are linked via 
a certain type of relationship, of the 'Contains' type, to the things that 
are to be included in the list.  So, if you wish, you can make up a list by 
drawing such links, though you would not normally do so.
      <p>



<h4><a name="vol.lists">Volunteer and Override Lists</a></h4>
<!-- -->

These are similar to <a href="#goal.list">Goal Lists</a>, but while Goal 
Lists normally comprise attributes to the right hand side of the Easel, 
Volunteer Lists comprise questions and other attributes to the left and 
Override Lists comprise attributes from the middle.  They are actually 
treated all the same as far as Istar is concerned, it is just that to the 
knowledge engineer and user they have slightly different purposes:
      <p>
<ul>
<li>  Goal Lists:  To start a complete inference process.
<li>  Volunteer Lists:  To provide certain information before the start of 
the inference process.
<li>  Override Lists:  To override some calculations made during the 
inference process.
</ul>
      <p>
To operate a Volunteer or Override List, select it as current goal list and 
hit ResetGoals and InferGoals.
      <p>

      <h3><a name="forms">
Forms
      </a></h3><!-- -->
Forms are a type of item to which Istar accords special meaning - they take 
effect during the <a href="#infce">inference process</a> and allow several 
attributes to be grouped together so that the user answers them all before 
hitting the 'OK' button.  This reduces the feeling of randomness the user 
might get if all questions are asked one by one.
      <p>
Select 'Form' in the <a href="panels.html#itl">Item Types List</a> and draw 
- a larger than normal box.  Then draw links from this box to each 
attribute that is to be in the form (not from the attribute to form) and 
when run all the attributes connected to the form will appear on the single 
form.  (Actually, from version 1.08, only unanswered attributes appear on 
the form.)  The <a href="panels.html#idp">Item Details Panel</a> detects 
that an item is a form, and allows you to enter text that will be placed at 
the top of the form.
      <p>
In future versions we hope to offer a more flexible form, but at present it 
can hold about half a dozen attributes at a time in a single column.  From 
version 1.08, by virtue of only holding unanswered attributes, if a form 
has more than it can hold, it will come up repeatedly until all its 
attributes have been answered.

      <h3><a name="infce">
Inference</a></h3>
<!-- -->

Inference is the process of calculating the value of one attribute from 
those of others that are its antecedents.  It is more than just doing the 
calculation since the antecedent attributes might not yet be answered, so 
their values must be obtained.  Also, the antecedents might themselves have 
antecedents, to any degree.
<p>
So inference operates in a cycle until the given ('goal') attribute is 
answered:
<p>
<ul>
<li><a href="#bwd.chain">Backward chain</a> to find an attribute that is 
directly or indirectly antecedent to the goal and has not itself been 
answered.
<p>
<li>Ask the user for its value (or obtain its value in some other way).
<p>
<li>Propagate the new answered value using <a href="#fwd.chain">forward 
chaining</a>.
<p>
<li>Are we finished yet?  Is the goal now answered?  If not, repeat.
</ul>

<h4><a name="bwd.chain">Backward Chaining</a></h4>
<!-- -->
Backward chaining is the process of searching from a goal attribute through 
its antecedent links to find an attribute that has yet to be answered (if 
any).  It will normally only search over the Inference type of 
relationship.  In Istar the goal is normally over the right hand side of 
the easel and backward chaining searches to the left.  Note that the search 
might be over a network rather than a strict tree.

<h4><a name="fwd.chain">Forward Chaining</a></h4>
<!-- -->
Forward chaining is the process of propagating the value of an attribute 
forward through all its consequents, until all reachable parts of the 
consequent net have been visited.  At each attribute so visited it 
calculates a new value for it from its immediate antecedents (at least one 
of which will have received a new value), then if the new value differs 
from the old one it will do the same thing for all of its immediate 
consequent attributes.  And it will keep on doing this until all have been 
visited.  Simple depth- and breadth-first searching will sometimes fail, 
and we had to devise a special algorithm for Istar that would ensure that 
all antecedents of an attribute were visited before the attribute itself.

      <h4><a name="goals">
Goals
      </a></h4><!-- -->
Goals are attributes which are the starting point for an <a 
href="#infce">inference cycle</a>.  That is, <a href="#bwd.chain">backward 
chaining</a> starts from a goal.
      <p>
Note however that <a href="#fwd.chain">forward chaining</a> does not stop 
at a goal; if the goal has any consequents, then it carries on into and 
through those to all parts of the net that can be reached.
      <p>
<a NAME="goal.list">
Goal lists</a> are <a href="#lists">lists</a> of attributes that can be 
used as goals together; each is used as a goal until answered and then the 
next unanswered attribute in the list is taken as the new goal.  This 
process stops only when all goals in the list have been answered.  You 
choose one of the existing lists to be the current goal list by means of 
the Goal List button on the <a href="panels.html#kbp">KB Panel</a>.
      <p>
At the creation of the knowledge base you are supplied with two empty lists 
automatically, named 'Goal List' and 'Override List' with the former 
selected as current Goal List.
      <p>
Goal lists are fully-fledged items, and you can treat them as such.  Look 
at a list's contents by bringing up its <a href= "panels.html#idp">item 
details panel</a> (by hitting the 'S' button next to the Goal List gadget 
on the KB panel).  You can create new ones by selecting 'Lists' item type 
and drawing a box of that type on the easel (often in an empty space away 
from the main KB); the two original List items have no easelpiece.  You can 
get rid of a goal list as you would any item by bringing up its item 
details panel and hitting the 'Delete' button.
      <p>
You, the knowledge engineer, are responsible for giving goal lists their 
contents; they do not automatically receive any.  There are three ways of 
doing this, two of which simply add attributes to the current goal list one 
by one.
      <p>
      <ul>
<li> The most foolproof way:  Bring up the <a href= 
"panels.html#aap">action panel</a> for the attribute you want to add to the 
goal list, and press the 'Add Goal' button.  (Then hit 'Done' to send it 
away again.)
<li> The easiest way:  'Pick up' the attribute box on the easel with the 
mouse as though to move it, and hit the 'G' key.  You will find the mouse 
operation has been aborted.  (Note: before version 1.13, you did not 'pick 
up' the attribute, but just pressed 'G' key when mouse happened to be over 
the attribute; that was dangerous.)
<li> To add several attributes in one operation:  Use the <a href= 
"panels.html#listp">List-making panel</a> to select those attributes you 
want.  Useful to select 'all attributes which are terminal'.  This creates 
a brand new list automatically.  This can be useful, for example, in a 
large KB which has lots of goals.
      <p>
      </ul>
To manipulate the contents of a goal list, bring up its item details panel, 
and employ the services of the <a href= "panels.html#panel.list">list 
gadget</a> to the right, which allows you to:
      <ul>
<li> change the order in the list ('1' and 'n' button)
<li> examine the entity in the goal list e.g. to change its name ('See' 
button)
<li> remove it from the goal list ('Rid' button; that only removes it from 
goal list and does not delete the entity itself)
      </ul>


<h3><a name="expression">Expression of Knowledge by Graphics</a></h3>
<!-- -->
In Istar and similar software, what you see on the <a href="#easel">main 
easel</a> is usually an expression of some piece of knowledge or 
information.  That is, there is a thing (object) that is the graphic and 
some internal thing (object) that the graphic expresses.  Thus, normally, 
<a href="#box">boxes</a> express <a href="#items">items</a> or <a 
href="#attributes">attributes</a> and links between the boxes express <a 
href="#relationships">relationships</a>.  Some lines inside boxes express 
<a href="#values">values</a>.  The items, attributes, relationships and 
values are the semantics of the knowledge base.  The graphic can be a group 
of others, as in a <a href="#boxgroup">boxgroup</a>.
<p>
There is a two-way data-link between graphics and their semantics.  So, 
given a semantic, we can find and, if we wish to, change all its graphics. 
Likewise, if you click on a graphic, its semantic can be found easily.  In 
this way your drawing actions can be translated into semantic knowledge. 
The arrangement in IRKit, on which Istar is based, is similar to the MVC 
(Model-View-Controller) of Smalltalk fame.
<p>
Any semantic can be expressed by more than one graphic, so that, for 
instance, it is possible for a given item to appear in more than one easel, 
and even several times on the same easel.  Also, in Istar, items can be 
expressed by a boxgroup and also by the topmost box in the boxgroup.
<p>
But each graphic can express only one semantic.  Thus when you click on, or 
drag, a graphic and it signals some action on the underlying semantic, then 
the action is unambiguous.  Or, rather, there is no doubt as to which 
semantic the action should be directed to.

<h3><a name="meaning">The Meaning of a Thing</a></h3>

Items, attributes, relationships and their types can all have meanings 
attached to them.  This is a kind of long name.  For items and attributes 
it flashes up in the <a href="#naming.strip">naming strip</a> when the 
mouse passes over it.


<h3><a name="panels">Panels</a></h3>
<!-- -->
Panels are windows that handle detail, and usually appear on the <a 
href="#cs">control screen</a> which is raised to let the panel be seen.
There are two main types of panel - those designed for use by developers of 
a knowledge base and those designed for use by end users of the knowledge 
base - i.e. those who run it.
<p>
Developer panels mainly sit on the <a href="#cs">main control screen</a> 
and use small e.g. Topaz8 font for their gadgets.  They are normally 
asynchronous (multi-threaded) in operation in that you can have any number 
up at once and almost all of them will be active and so will the main 
easel.  Their purpose is to allow you to build and refine a knowledge base.
<p>
The main developer panels include:
<p>
<ul>
<li><a href="panels.html#icp">Initial Control Panel</a>.
<li><a href="panels.html#kbp">Main Knowledge Base (KB) Panel</a>.
<li><a href="panels.html#kbap">Knowledge Base Details Panel</a>.
<li><a href="panels.html#prefs">Preferences Panel</a>.
<p>
<li><a href="panels.html#idt">Item Details Panel</a>.
<li><a href="panels.html#itp">Item Type Panel</a>.
<li><a href="panels.html#adp">Attribute Details Panel</a>.
<li><a href="panels.html#atp">Attribute Type Panel</a>.
<li><a href="panels.html#ndp">New Domain Panel</a>.
<li><a href="panels.html#atl">Attribute Types List Panel</a>.
<li><a href="panels.html#ri">Relationship Instance Details Panel</a>.
<li><a href="panels.html#rtp">Relationship Type Panel</a>.
<p>
<li><a href="panels.html#list">Lists Panel</a>.
<li><a href="panels.html#find.name">Finding Something by Name</a>.
</ul>
<p>
End user panels sit on the <a href="#cs">main control screen</a> at 
present, but in future can sit on another screen.  They are used while the 
KB is running, such as to ask user for values during an inference cycle. 
They are mainly synchronous in operation, in that the user must reply to 
the current panel, before any other input can be given.  But some are 
asynchronous.
<p>
The main end user panels are:
<ul>
<li><a href="panels.html#VAL">VAL</a>: Value Entry, which asks user for a 
single value.
<li><a href="panels.html#FORM">FORM</a>: Multi-value forms, which presents 
several values to user in one go.
</ul>


<hr>
Copyright (c) <a href="http://www.basden.u-net.com/andrew.html">Andrew 
Basden</a> 13 February 1998.
</body></html>
