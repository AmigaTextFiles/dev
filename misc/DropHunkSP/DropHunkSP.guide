@DATABASE DropHunk.guide
@$VER: DropHunkSP.guide 1.0.0 (01.01.2015) - Spanish translation by Dámaso 'AmiSpaTra' Domínguez. All rights reserved.
@INDEX Hunks
@HELP Help
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@NODE Main "Guía en español de 'DropHunk 1.0'"

@{b}DropHunk v1.0 (noviembre de 1998)@{ub}

DropHunk  es  una herramienta, que sólo puede ser invocada desde la interfaz de
línea  de  comandos (conocida como CLI o Shell, según la  versión  del  sistema
operativo  con la que trabaje),  que  muestra  todas  las partes de  un fichero
binario compatible  con  AmigaDOS®,  ya sea  de  tipo objeto,  ya sea  de  tipo
cargador,  donde  cada  parte  del fichero se denomina literalmente "hunk", que
literalmente  traducido equivale a "pedazo", aunque aquí, en esta traducción al
español, nos referiremos a ellos como "segmentos".

Sólo  hay  tres  segmentos  que  se  exigen  para  generar un fichero que pueda
cargarse  y  ser  ejecutado  por  el AmigaOS®.  Estos tres segmentos tienen los
siguientes identificadores:

  HUNK_CODE
  HUNK_DATA
  HUNK_BSS

De ellos, hay sólo un segmento imprescindible para producir un fichero cargador
y es el que tiene el identificador HUNK_CODE.  Un fichero ejecutable tendrá una
estructura como ésta:

  HUNK_HEADER
  HUNK_CODE
  HUNK_END

Los  compiladores  y  enlazadores crearán otra forma de fichero ejecutable para
Amiga que podría tener un estructura como ésta:

  HUNK_HEADER

  HUNK_CODE
  HUNK_RELOC32
  HUNK_END

  HUNK_DATA
  HUNK_RELOC32
  HUNK_END

  HUNK_BSS
  HUNK_RELOC32
  HUNK_END

DropHunk  no  muestra  los segmentos HUNK_END y HUNK_BREAK porque el listado de
salida de un fichero objeto o cargador es más legible sin ellos.

DropHunk  no imprime en pantalla los errores que se puedan producir (como el de
"fichero no encontrado") generando en su lugar un código de retorno válido para
la interfaz  de línea de comandos:  Utilice  el comando "Why"  disponible en el
cajón de comandos "C:"  para obtener  una descripción legible por el ser humano
de un posible fallo de DropHunk.

Además  algunos  tipos  de  segmentos  actualmente  no soportados como HUNK_EXT
combinado con EXT_COMMON abortarán el procesado de un fichero objeto/cargador.

Para invocar a DropHunk llámelo desde la interfaz de línea de comandos así:

  DropHunk <fichero, junto a su ruta de acceso si es menester>

Si  el  nombre del fichero o su ruta de acceso contiene espacios (caracteres en
blanco) utilice las comillas dobles para encerrar la cadena:

1> DropHunk "trabajo-II:aplic/fuente/ejecutable/silencio ruidoso"

Para  ejecutar  DropHunk  necesita  un  ordenador Amiga o Draco con al menos la
versión   33  de  Kickstart  (Kickstart/sistema  operativo  v1.2)  o  superior.
DropHunk  visualizará  cualquier  sección  que  pueda manejarse incluso bajo la
versión 1.2 del sistema operativo.

Cualquier  persona  física  y  compañía puede utilizar DropHunk sin permiso por
escrito  del  autor  siempre  que  no me haga responsable de cualquier daño que
pueda producirse.

Cualquier  persona  puede  mejorar  el  código fuente que se incluye, aunque el
código fuente original sigue perteneciéndome.

Autor:

  Jörg van de Loo ("ONIX")
  Hövel 15
  47559 Kranenburg
  República Federal Alemana (FRG)

@{u}Traducción al español 1.0.0 (01/01/2015)@{uu}

Esta  traducción actualmente no es oficial y es propiedad única y exclusiva de:
Copyright 2015 Dámaso "AmiSpaTra" Domínguez.  No tengo problema en que el autor
del  paquete  original la integre, incluso sin consultármelo (salvo a un par de
programadores  que expresamente se lo he prohibido), en la distribución oficial
siempre  que  entienda  que  su  permiso se limita a dicha inclusión:  No tiene
legitimidad  ni  autorización  para  cambiar ni una sola coma (ni siquiera para
corregir  errores  o  actualizar  el  documento) y mucho menos para autorizar a
terceros para hacerlo.

Este  trabajo como la inmensa de la mayoría de los que lo han precedido sólo se
ofrece  de  forma  gratuita  para  que los usuarios de habla hispana sepan cómo
funciona  el  correspondiente  paquete.   Todos  los  demás  derechos  de dicha
traducción  están  reservados de manera que NO puede ser distribuida por cauces
ajenos  a  los  elegidos  por  su  autor, ni puede ser actualizada, modificada,
corregida,  reempaquetada,  utilizada  como  base  para  una nueva traducción o
tutorial,  etcétera  sin  permiso  previo y por escrito de su autor, o sea, yo,
Dámaso  "AmiSpaTra" Domínguez.  Si no le gusta la traducción, ya sabe lo que ha
de  hacer:   Elaborar  la  suya  propia  a  partir  *únicamente*  de la versión
original.  Esta traducción no ofrece garantía de ningún tipo.

                               @{b}Dámaso D. Estévez@{ub}

            AmiSpaTra - @{b}http://www.xente.mundo-r.com/amispatra/@{ub}
         Página con noticias y traducciones en español para Amiga

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node Hunks "Segmentos soportados por el AmigaDOS®"

  @{"HUNK_UNIT        " link HUNK_UNIT}
  @{"HUNK_NAME        " link HUNK_NAME}
  @{"HUNK_CODE        " link HUNK_CODE}
  @{"HUNK_DATA        " link HUNK_DATA}
  @{"HUNK_BSS         " link HUNK_BSS}
  @{"HUNK_RELOC32     " link HUNK_RELOC32}
  @{"HUNK_RELOC16     " link HUNK_RELOC16}
  @{"HUNK_RELOC8      " link HUNK_RELOC8}
  @{"HUNK_EXT         " link HUNK_EXT}
  @{"HUNK_SYMBOL      " link HUNK_SYMBOL}
  @{"HUNK_DEBUG       " link HUNK_DEBUG}
  @{"HUNK_END         " link HUNK_END}
  @{"HUNK_HEADER      " link HUNK_HEADER}
  HUNK_Unknown         (*1)   !!!
  @{"HUNK_OVERLAY     " link HUNK_OVERLAY}
  @{"HUNK_BREAK       " link HUNK_BREAK}
  @{"HUNK_DREL32      " link HUNK_DREL32}
  @{"HUNK_DREL16      " link HUNK_DREL16}
  @{"HUNK_DREL8       " link HUNK_DREL8}
  @{"HUNK_LIB         " link HUNK_LIB}   (*1)
  @{"HUNK_INDEX       " link HUNK_INDEX}   (*1)
  @{"HUNK_RELOC32SHORT" link HUNK_RELOC32SHORT}
  @{"HUNK_RELRELOC32  " link HUNK_RELRELOC32}   (*1)
  @{"HUNK_ABSRELOC16  " link HUNK_ABSRELOC16}   (*1)

  @{"EXT_SYMB         " link EXT_SYMB}
  @{"EXT_DEF          " link EXT_DEF}
  @{"EXT_ABS          " link EXT_ABS}
  @{"EXT_RES          " link EXT_RES}
  @{"EXT_REF32        " link EXT_REF32}
  @{"EXT_COMMON       " link EXT_COMMON}
  @{"EXT_REF16        " link EXT_REF16}
  @{"EXT_REF8         " link EXT_REF8}
  @{"EXT_DEXT32       " link EXT_DEXT32}   (*1)
  @{"EXT_DEXT16       " link EXT_DEXT16}   (*1)
  @{"EXT_DEXT8        " link EXT_DEXT8}   (*1)
  @{"EXT_RELREF32     " link EXT_RELREF32}   (*1)
  @{"EXT_RELCOMMON    " link EXT_RELCOMMON}   (*1)
  @{"EXT_ABSREF16     " link EXT_ABSREF16}   (*1)
  @{"EXT_ABSREF8      " link EXT_ABSREF8}   (*1)


                                    ---=---

                             (*1) - No soportado.

                        !!! - Si dispone de información
                   sobre este segmento, por favor, envíemela.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_UNIT "Segmento HUNK_UNIT"

Un  segmento  HUNK_UNIT sólo  se utiliza, y permite, en los ficheros objeto del
Amiga  o para ficheros objeto de múltiples partes, también llamados bibliotecas
de  enlace.   Este segmento los identifica como ficheros objeto listos para ser
utilizados por un programa enlazador de Amiga.  Este tipo de segmento ha de ser
el primero de dicho fichero.

@{u}Formato@{uu}

  1ª palabra larga:

    HUNK_UNIT

  2ª palabra larga:

    Longitud del nombre del fichero completo expresado en el número de palabras
    largas utilizadas para el nombre o, si no tiene nombre, cero.

  Si la segunda palabra larga no es cero, el 9º octeto:

    Primer carácter (letra) del nombre.

  Debido  al  formato segmentado del Amiga, el nombre ha de terminar alineado a
  nivel de palabra larga.

@{u}Ejemplo@{uu}

  00 00 03 E7
  00 00 00 03
  _ C p y L i b . a s m 00

@{u}Notas@{uu}

No  hay  necesidad  de terminar el nombre de esta cadena con un octeto nulo, ya
que  el  nombre  nombre  de  la  sección  no  es  una cadena en formato C ni la
equivalente cadena BCPL.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_NAME "Segmento HUNK_NAME"

El  segmento  HUNK_NAME  se  permite  en  los  ficheros  objeto  y  cargadores.
Habitualmente se utiliza en los ficheros objeto y del enlazador únicamente.  Se
utiliza para dar un nombre a una sección del fichero.

@{u}Formato@{uu}

  1ª palabra larga:

    HUNK_NAME

  2ª palabra larga:

    Longitud del nombre de esta sección expresada en palabras largas utilizadas
    o, si no tiene nombre, cero.

  Si la segunda palabra larga no es nula, el 9º octeto:

    Primer carácter (letra) del nombre.

  Debido  al  formato segmentado del Amiga, el nombre ha de terminar alineado a
  nivel de palabra larga.

@{u}Ejemplo@{uu}

  00 00 03 E8
  00 00 00 02
  T E X T . A S M

@{u}Notas@{uu}

No  hay  necesidad  de terminar el nombre de esta cadena con un octeto nulo, ya
que  el  nombre  nombre  de  la  sección  no  es  una cadena en formato C ni la
equivalente cadena BCPL.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_CODE "Segmento HUNK_CODE"

El  segmento  HUNK_CODE  es el más importante en los ficheros cargadores aunque
también se presenta en los ficheros objeto.

En los ficheros cargadores ha de ser el primer segmento a cargar, comenzando el
programa  con  la  primera palabra utilizada de este segmento, habitualmente el
código   de  puesta  en  marcha  o  inicialización.   Por  ello  éste  contiene
instrucciones del juego soportado por el microprocesador.

@{u}Formato@{uu}

  1ª palabra larga:

    HUNK_CODE

  2ª palabra larga:

    Cantidad  de  palabras  largas  utilizadas  que contengan instrucciones del
    microprocesador o cero (no hay instrucciones del microprocesador).

  Si la segunda palabra larga NO es cero, la 5ª palabra:

    Primera instrucción.

@{u}Ejemplo@{uu}

  00 00 03 E9   HUNK_CODE
  00 00 00 01
  70 FF 4E 75

@{u}Notas@{uu}

Debido  al  formato  segmentado  del  Amiga,  esta  sección  ha  de completarse
alineándose a nivel de palabra larga incluso si hay una instrucción menos de la
exigida  para  conseguir  dicha  alineación.   En este caso los ensambladores y
compiladores completan este segmento automáticamente con una palabra nula o con
las  instrucciones  RTS  (retorno  de  subrutina)  o  NOP  (no ejecutar ninguna
operación) representadas por las palabras 00 00, 4E 75 o 4E 71 respectivamente.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_DATA "Segmento HUNK_DATA"

Habitualmente  un  segmento HUNK_DATA contiene datos estáticos o inicializados.
A  menudo las tablas (incluso de punteros) se localizan aquí o por contra datos
sin inicializar.

@{u}Formato@{uu}

  1ª palabra larga:

    HUNK_DATA

  2ª palabra larga:

    Cantidad de palabras largas que contienen los datos.

  Si la segunda palabra larga NO es cero, el 9º octeto:

    Primer octeto de datos.

@{u}Ejemplo@{uu}

  00 00 03 EA   HUNK_DATA
  00 00 00 01
  O N I X

@{u}Notas@{uu}

Debido  al  formato  segmentado  del  Amiga,  esta  sección  ha  de completarse
alineándose a nivel de palabra larga incluso si hay menos datos de los exigidos
para conseguir dicha alineación.  En este caso los ensambladores y compiladores
completan este segmento automáticamente con una palabra nula.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_BSS "Segmento HUNK_BSS"

Un segmento HUNK_BSS  es un almacén virtual presente desde el primer momento en
tiempo de ejecución, lo que significa que sólo el tamaño de las palabras largas
que  ha  de  estar presente en el tiempo de ejecución se escribe en el fichero.
Por  ello  el  área  de  memoria  utilizada  en  el  tiempo  de ejecución no se
inicializa,  aunque  esto  sólo es válido para aquellas Kickstart con versiones
comprendidas  entre  la  30  y  la  35.   A  partir  de la versión 36(*1) de la
Kickstart,  el  módulo de la biblioteca DOS ha sufrido una increíble revisión y
hay  cambios:   Bajo  esta  Kickstart (y naturalmente versiones posteriores) se
garantiza  que  el área de memoria BSS está inicializada con ceros antes de que
el  programa se ponga en marcha.  Esto asegura algunas instrucciones dentro del
fichero  cargador porque la limpieza de esta área memoria no era exigida por la
propia aplicación.

@{u}Formato@{uu}

  1ª palabra larga:

    HUNK_BSS

  2ª palabra larga:

    La  cantidad  de  palabras  largas  que  han  de reservarse antes de que la
    aplicación se ponga en marcha.

@{u}Ejemplo@{uu}

  00 00 03 EB   HUNK_BSS
  00 00 00 11

En  este  ejemplo  la  sección BBS tiene un tamaño de 17*4 octetos.  Puesto que
esta  sección  no  contiene  nada,  no  se  escribirán más datos en disco.  Una
sección  BBS  se  utiliza  preferiblemente  para  contener variables que pueden
inicializarse  en primer lugar durante el tiempo de ejecución como puede ser el
punto base de una biblioteca.


                                    ---=---

                    (*1) Nota del traductor: AmigaOS v1.2.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_RELOC32 "Segmento HUNK_RELOC32"

Un  segmento  HUNK_RELOC32 se utiliza en el momento de la carga para recalcular
una  dirección  específica.   Puesto  que  el  Amiga,  en general, no tiene una
configuración  de  memoria  rígida  ya que un mismo programa se puede cargar en
cualquier  lugar  de  la  memoria, se ha tenido que implementar el concepto que
permite  mover  un  programa  a  posiciones  de memoria diferentes sin tocar el
fichero cargador.

Esto  se ha hecho de forma muy inteligente:  Cualquier ejecutable para Amiga se
escribe para la dirección física '0', de manera que cuando haya que cargarlo en
una  posición  física  real como la '5000', se utiliza el segmento HUNK_RELOC32
para  recalcularlo.   El  valor  inicial a donde apunta HUNK_RELOC32 se cargará
como  valor a sumar a la dirección real desde este segmento, por ejemplo, si el
valor  inicial es igual a '430' y la dirección física es '5000', el nuevo valor
será '5430'.

@{u}Formato@{uu}

  1ª palabra larga:

    HUNK_RELOC32

  2ª palabra larga:

    La  cantidad  de  direcciones que han de ser recalculadas antes de poner en
    marcha el programa.

  3ª palabra larga:

    El número del "segmento" cuyas direcciones han de ser corregidas.

  4ª palabra larga:

    El desplazamiento dentro del "segmento" que ha de ser corregido.

  ...

    Los demás desplazamientos que pueda haber.

@{u}Ejemplo@{uu}

  00 00 03 EC   HUNK_RELOC32
  00 00 00 01   ¡Referencia al "segmento" número dos! (*1)
  00 00 00 02   Hemos de corregir dos desplazamientos (*1).
  00 00 00 04   El primer desplazamiento (palabra larga) a corregir
                en el segmento número dos es la palabra larga
                en la posición 4º.
  00 00 00 4C   El segundo desplazamiento (palabra larga) a corregir
                en el segmento número dos es la palabra larga
                en la posición 76º.
  00 00 03 EC   HUNK_RELOC32
  00 00 00 03   ¡Referencia al segmento número cuatro! (*1)
  00 00 00 02   Corrige dos desplazamientos (*1).
  00 00 00 10   El primer desplazamiento (palabra larga) a corregir
                en el segmento número cuatro es
                la palabra larga en la posición 16ª.
  00 00 00 20   El segundo(*2) desplazamiento (palabra larga) a corregir
                en el segmento número cuatro es
                la palabra larga en la posición 32ª.


                                    ---=---

       *1 Nota del traductor: El ejemplo no me cuadra con la descripción
            del formato en la segunda y tercera palabras largas...
                       ¡¡parecen intercambiadas!! r8-?.

             *2 Nota del traductor: Literalmente dice "primer"...
           otra vez para el mismo segmento, lo que parece un error.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_RELOC16 "Segmento HUNK_RELOC16"

Este segmento  es  idéntico a @{"HUNK_RELOC32" LINK HUNK_RELOC32} con la excepción de que en lugar de
un  desplazamiento  expresado  como palabra larga se utiliza uno expresado como
palabra.  En la mayoría de los casos, esto se produce cuando se utiliza el modo
de direccionamiento relativo al contador de programa o PC.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_RELOC8 "Segmento HUNK_RELOC8"

Este segmento  es  idéntico a @{"HUNK_RELOC32" LINK HUNK_RELOC32} con la excepción de que en lugar de
un  desplazamiento  expresado  como palabra larga se utiliza uno expresado como
octeto.

Me  temo que soy demasiado estúpido para entender para qué sirve este segmento.
Me  han  dicho  que esta reubicación se utiliza con el modo de direccionamiento
relativo  al  contador  de  programa o PC, pero nunca he visto fichero objeto o
cargador alguno que utilice un modo de direccionamiento de este tipo de 8 bits,
y  más  cuando el M68000 no es capaz de producir dichos fragmentos, hasta donde
yo sé.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_EXT "Segmento HUNK_EXT"

Este segmento contiene referencias y sólo se permite en ficheros objeto ¡porque
las  referencias  siempre  apuntarán a algo desconocido!  Un programa enlazador
normalmente inicializará estas referencias.

@{u}Formato@{uu}

  1ª palabra larga:

    HUNK_EXT

  4º octeto:

    Indicador del tipo externo que sigue.

  5º-7º octeto:

    Tres (3) valores de tamaño octeto  para la longitud del nombre expresado en
    número de palabras largas.

  3ª palabra larga:

    Inicio del nombre del símbolo.

 ... palabra larga (la posición
 dependerá de la longitud del nombre del símbolo):

   * Si es SYM, DEF, ABS, RES y así sucesivamente,  esta palabra larga contiene
     el valor.

   * Si es REF32, REF16, REF8 y así sucesivamente,  esta palabra larga contiene
     la  cantidad  de  referencias hechas a este símbolo y la siguiente palabra
     larga  contiene  el  desplazamiento  a  nivel  de octeto con respecto a la
     dirección del objeto referenciado en la que ha de escribirse.

   * Si  es  COMMON,  éste  es  el inicio del bloque común COMMON y entonces el
     desplazamiento  a  nivel de octeto que sigue es como se describe más atrás
     (REF32 ...) .

@{u}Ejemplo@{uu}

  00 00 03 EF   HUNK_EXT

  81 00 00 02
  _stdout 00
  00 00 00 01   Una referencia dentro de este segmento a esta referencia.
  00 00 00 02   El valor de referencia ha de escribirse
                con un desplazamiento de '2' dentro de este segmento.
  81 00 00 02
  _strlen 00
  00 00 00 01   Una referencia dentro de este segmento a esta referencia.
  00 00 00 0E   El valor de referencia ha de escribirse
                con un desplazamiento de '14' dentro de este segmento.

  81 00 00 02
  _DOSBase
  00 00 00 01   Una referencia dentro de este segmento a esta referencia.
  00 00 00 1C   El valor de referencia ha de escribirse
                con un desplazamiento de '28' dentro de este segmento.

  00 00 00 00   No hay más entradas.

La estructura de este segmento difiere de un tipo a otro...

* EXT_SYM, EXT_DEF, EXT_ABS, EXT_RES tienen la misma estructura.

* EXT_RES32, EXT_COMMON, EXT_REF16, EXT_REF8, tienen la misma estructura con la
  excepción  de  EXT_COMMON, donde entre el nombre y el valor de referencia, se
  escribe el tamaño del bloque COMMON.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_SYMBOL "Segmento HUNK_SYMBOL"

El segmento HUNK_SYMBOL  no es  para  un programa enlazador:  Se utiliza  en la
depuración de un fichero cargador.

@{u}Formato@{uu}

  1ª palabra larga:

    HUNK_SYMBOL

  2ª palabra larga:

    Cantidad de palabras largas utilizadas para el nombre.

  3ª palabra larga:

    Inicio del nombre.

  ... palabra larga:

    Desplazamiento dentro de este segmento al que este símbolo está asignado.

@{u}Ejemplo@{uu}

  00 00 03 F0   HUNK_SYMBOL
  00 00 00 01   Longitud del nombre expresado en palabras largas.
  _end          Nombre (1 palabra larga = 4 octetos/caracteres)
  00 00 00 26   Octeto de desplazamiento al que el símbolo se refiere.

  00 00 00 02   Longitud del nombre expresado en palabras largas.
  _rela         Nombre (2 palabras largas = 5 caracteres ...
     00 00 00             ... + 3 octetos nulos de relleno).
  00 00 00 00   Octeto de desplazamiento al que el símbolo se refiere.

  00 00 00 00   No hay más entradas.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_DEBUG "Segmento HUNK_DEBUG"

El segmento HUNK_DEBUG no está limitado a ningún subtipo de fichero ni definida
su  estructura:  Es  labor  del  autor  del  compilador (constructor)  cómo  se
implementa y cómo se traduce este segmento.

@{u}Formato@{uu}

  1ª palabra larga:

    HUNK_DEBUG

  2ª palabra larga:

    Cantidad de palabras largas utilizadas que siguen.

  3ª palabra larga:

    Contenidos especificados por el autor...

@{u}Ejemplo@{uu}

  00 00 03 F1   HUNK_DEBUG
  00 00 00 1A   Cantidad de palabras largas que siguen.
  00 00 00 00   Los contenidos...
  LINE
  00 00 00 03
  Untitled.s
        00 00
  00 00 00 08
  00 00 00 00
  00 00 00 09
  ...

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_END "Segmento HUNK_END"

El segmento HUNK_END  finaliza  un segmento  y  no tiene contenidos  (el propio
identificador  es el propio segmento completo).  Ha de estar presente para cada
sección, es decir, en  CODE, DATA, BBS  y tanto en los ficheros objeto  como en
los cargadores.

@{u}Formato@{uu}

    HUNK_END

@{u}Ejemplo@{uu}

  00 00 03 F2

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_HEADER "Segmento HUNK_HEADER"

El segmento HUNK_HEADER  le indica  al AmigaDOS®  que  el fichero es un fichero
cargador:  ¡Este identificador no puede utilizarse en ficheros objeto! Contiene
los atributos de la memoria  y tamaños así como la cantidad de segmentos de que
consta este fichero.  El fichero que es movido desde un medio de almacenamiento
a la memoria ¡dependerá de la descripción de este segmento!

@{u}Formato@{uu}

  1ª palabra larga:

    HUNK_HEADER

  2ª palabra larga:

    Longitud  del  nombre  para  esta  sección  expresado  en  palabras  largas
    utilizadas para el nombre o cero (si no tiene nombre).

  Si la segunda palabra larga no es nula, el 9º octeto:

    Primer  carácter  (letra)  del  nombre.   Debido  al formato segmentado del
    Amiga, el nombre ha de terminar alineado a nivel de palabra larga.

  Y así sucesivamente para cada segmento/sección.

  Si la segunda palabra larga es nula:

    Fin de la lista de nombres

  Siguiente palabra larga:

    El número del segmento más alto (¡¡contando desde la unidad!!)

  Siguiente palabra larga:

    El número del primer segmento a cargar en memoria.

  Siguiente palabra larga:

    El número del último segmento a cargar en memoria.

  Tabla de palabras largas:

    Contiene la longitud de cada sección expresada en palabras largas.

@{u}Ejemplo@{uu}

  00 00 03 F3   HUNK_HEADER
  00 00 00 00   Cantidad de palabras largas utilizadas para contener
                el nombre de este segmento (valor nulo => no hay nombre).
  00 00 00 05   El número del segmento más alto es '5'.
  00 00 00 00   El primer segmento a cargar es el número '0'.
  00 00 00 04   El último segmento a cargar es el número '4' (el más alto).
  00 00 00 A6   El segmento nº '0' necesita 664 octetos de memoria (RAM).
  00 00 12 60   El segmento nº '1' necesita 18.816 octetos de memoria (RAM).
  00 00 04 39   El segmento nº '2' necesita 4.324 octetos de memoria (RAM).
  40 00 00 20   El segmento nº '3' necesita 128 octetos de memoria (RAM) y
                ha de residir en la memoria exclusiva (activado el bit nº 30).
  40 00 04 A5   El segmento nº '4' necesita 4.756 octetos de memoria (RAM) y
                ha de residir en la memoria exclusiva (activado el bit nº 30).

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_OVERLAY "Segmento HUNK_OVERLAY"

Como  el  nombre  ya  indica  este  segmento  fuerza  que otra parte de éste se
sobreescriba  sobre  un  segmento  ya  cargado.  Este segmento actualmente está
abandonado,  ya  que el único programa que lo ha utilizado ha sido DPaint®, así
que no profundizaré en él.

@{u}Formato@{uu}

  1ª palabra larga

    HUNK_OVERLAY

  2ª palabra larga

    Tamaño de la tabla.

  3ª palabra larga

    Cantidad de sobreescrituras a ejecutar.

  4ª palabra larga

    El inicio de los propios datos.

@{u}Ejemplo@{uu}

  Lo siento, pero es demasiado complicado explicarlo.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_BREAK "Segmento HUNK_BREAK"

El segmento HUNK_BREAK se utiliza en conjunción con @{"HUNK_OVERLAY" LINK HUNK_OVERLAY}. Es realmente
difícil  explicar  esta  prestación  del  AmigaDOS®  y  no  lo haré aquí, salvo
mencionar que HUNK_BREAK es similar a @{"HUNK_END" link HUNK_END}.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_DREL32 "Segmento HUNK_DREL32"

El segmento HUNK_DREL32 es similar a @{"HUNK_RELOC32" LINK HUNK_RELOC32} pero difiere en que en lugar
de   palabras  (16  bits)  se  almacenan palabras largas (32 bits). HUNK_DREL32
es idéntica  a @{"HUNK_RELOC32SHORT" LINK HUNK_RELOC32SHORT}, pero HUNK_DREL32  no se permite  en ficheros
cargadores si no fuese  por un error en la versión 37 de la biblioteca DOS que
los soporta.  @{"HUNK_RELOC32SHORT" LINK HUNK_RELOC32SHORT}  puede utilizarse sólo a partir de la versión
3.0 del sistema operativo.

@{u}Formato@{uu}

  1ª palabra larga

    HUNK_DREL32

  3ª palabra

    Cantidad de reubicaciones.

  4ª palabra

    Número de segmentos para los que son estas reubicaciones.

  5ª palabra

    Desplazamiento que ha de corregirse.

  6ª palabra

    Otro desplazamiento que ha de corregirse y así sucesivamente.

@{u}Ejemplo@{uu}

  00 00 03 F7   HUNK_DREL32
  00 03 00 00   Cantidad de reubicaciones (3) para el segmento número '0'.
  00 20 00 0E   Desplazamientos a corregir en las posiciones 32ª y 14ª.
  00 1C 00 00   Desplazamiento a corregir en la posición 28ª y
                relleno para completar la alineación a nivel de palabra larga.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_DREL16 "Segmento HUNK_DREL16"

El segmento HUNK_DREL16  es idéntico a @{"HUNK_DREL32" LINK HUNK_DREL32} y es esencialmente para los
modos de direccionamiento  relativo del contador  del procesador o PC. Consulte
también el segmento @{"HUNK_RELOC16" link HUNK_RELOC16}.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_DREL8 "Segmento HUNK_DREL8"

El segmento HUNK_DREL8  es idéntico a @{"HUNK_DREL32" LINK HUNK_DREL32} y es principalmente para los
modos  de  direccionamiento  relativos  del  contador del procesador  o  PC, o,
supongo,  para  desplazamientos  de  la  base.   Consulte  también  el segmento
@{"HUNK_RELOC8" link HUNK_RELOC8}.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_LIB "Segmento HUNK_LIB"

Ni idea de para qué sirve.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_INDEX "Segmento HUNK_INDEX"

Ni idea de para qué sirve.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_RELOC32SHORT "Segmento HUNK_RELOC32SHORT"

El segmento HUNK_RELOC32SHORT es similar a @{"HUNK_RELOC32" LINK HUNK_RELOC32} pero difiere en que se
almacenan  palabras  (16  bits)  en  lugar  de  palabras largas (32 bits) en el
fichero.  Puesto que el valor de una palabra está limitado a 65536 octetos sólo
puede  accederse  a  las referencias comprendidas dentro de este rango con este
segmento.  HUNK_RELOC32SHORT sólo puede utilizarse a partir de la versión 3 del
sistema  operativo  (hasta  donde yo sé) porque existe desde la versión 37[*1],
aunque en ésta no funcionaba.  Si desarrolla programas para la versión 37 de la
biblioteca   DOS   utilice   en   su   lugar  HUNK_DREL32  que  es  idéntica  a
HUNK_RELOC32SHORT.

@{u}Format@{uu}

  1ª palabra larga

    HUNK_RELOC32SHORT

  3ª palabra

    Número de reubicaciones.

  4ª palabra

    Número del segmento en que el que ha de aplicarse las reubicaciones.

  5ª palabra

    Desplazamiento que ha de corregirse.

  ...

    Y posteriores desplazamientos a corregir.

@{u}Ejemplo@{uu}

  00 00 03 FC	HUNK_RELOC32SHORT
  00 03 00 00	Cantidad de reubicaciones (3) para el segmento nº '0'.
  00 20 00 0E	Desplazamiento a corregir en la posición 32ª y 14ª.
  00 1C 00 00	Desplazamiento a corregir en la posición 28ª y
                relleno para completar la alineación a nivel de palabra larga.

@{u}Notas@{uu}

Debido  al  formato  segmentado  del  Amiga,  esta  sección  ha  de completarse
alineándose a nivel de palabra larga incluso si hay menos datos de los exigidos
para conseguir dicha alineación.  En este caso los ensambladores y compiladores
completan este segmento automáticamente con una palabra nula.


                                   ---==---

                    [*1] Nota del traductor: AmigaOS v2.x.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_RELRELOC32 "Segmento HUNK_RELRELOC32"

Necesito  información sobre este segmento (HUNK_RELRELOC32).  Actualmente, sólo
puedo suponer su uso.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node HUNK_ABSRELOC16 "Segmento HUNK_ABSRELOC16"

No soportado por el sistema hasta donde yo sé...

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node EXT_SYMB "HUNK_EXT: EXT_SYMB"

Indica que le sigue un nombre simbólico.  Normalmente, éste es el nombre de una
etiqueta o función que se hace pública.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node EXT_DEF "HUNK_EXT: EXT_DEF"

Indica  que  le sigue una definición.  Puede ser una referencia a una variable,
etiqueta   o   función.   Se  almacena  el  nombre  de  esta  referencia  y  el
desplazamiento dentro de este segmento.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node EXT_ABS "HUNK_EXT: EXT_ABS"

Indica  que  le sigue una referencia absoluta.  Por ejemplo, almacena el nombre
de una función de una biblioteca y su desplazamiento.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node EXT_RES "HUNK_EXT: EXT_RES"

Indica  que  le  sigue  una  referencia  absoluta  a  una biblioteca residente.
Abandonado como nombre y referencia.

@endnode

@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node EXT_REF32 "HUNK_EXT: EXT_REF32"

Indica que ha de corregirse una dirección absoluta.  Abandonado como nombre, la
frecuencia de la corrección y el o los desplazamientos en sí mismos.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node EXT_COMMON "HUNK_EXT: EXT_COMMON"

Similar al segmento @{"EXT_REF32" link EXT_REF32}, pero con un bloque común implicado.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node EXT_REF16 "HUNK_EXT: EXT_REF16"

Similar al segmento @{"EXT_REF32" link EXT_REF32}, pero con desplazamientos de 16 bits.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node EXT_REF8 "HUNK_EXT: EXT_REF8"

Similar al segmento @{"EXT_REF32" link EXT_REF32}, pero con un desplazamiento de 8 bits.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node EXT_DEXT32 "HUNK_EXT: EXT_DEXT32"

Ni idea de para qué sirve.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node EXT_DEXT16 "HUNK_EXT: EXT_DEXT16"

Ni idea de para qué sirve.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node EXT_DEXT8 "HUNK_EXT: EXT_DEXT8"

Ni idea de para qué sirve.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node EXT_RELREF32 "HUNK_EXT: EXT_RELREF32"

Ni idea de para qué sirve.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node EXT_RELCOMMON "HUNK_EXT: EXT_RELCOMMON"

Ni idea de para qué sirve.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node EXT_ABSREF16 "HUNK_EXT: EXT_ABSREF16"

Ni idea de para qué sirve.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node EXT_ABSREF8 "HUNK_EXT: EXT_ABSREF8"

Ni idea de para qué sirve (¿para un desplazamiento de base/externo?).

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node Help "Guía de ayuda de 'DropHunk'"

AYUDA

Para saber sobre los diferentes tipos de segmentos del Amiga, presione el botón
[Índice] (o [Index] en la versión en inglés).

Si  quiere  conocer algunas generalidades del AmigaDOS, de los enlazadores o de
la estructura de los segmentos utilice los botones que hay a continuación y que
hacen referencia a estos temas.

Si  quiere  consejos  generales  sobre  la optimización de la estructura de las
secciones,  presione el botón [Algunos consejos] y después elija un botón en la
barra de botones[*1].

Generalidades:

  @{" AmigaDOS               " link AmigaDOS}
  @{" Enlazadores para Amiga " link AmigaLink}
  @{" Segmentos del Amiga    " link GHunks}

@{"Algunos consejos " link Hints}


                                   ---==---

   [*1] Nota del traductor: Ni idea de qué barra de botones se refiere r8-?,
                      ya que la sección no tiene botones
                (salvo los ofrecidos por el propio visualizador
           de ficheros guía como "Índice", "Repasar", "Leer >"...).

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node AmigaDOS "El trasfondo del AmigaDOS"

La  primera  versión  del AmigaDOS era un núcleo operativo modificado de disco,
desarrollado  por  la  Universidad  de Cambridge llamado TRIPOS, incorporándose
también  algunos  conceptos  del UNIX.  Las primeras versiones (inferiores a la
versión 36 de la Kickstart) fueron escritas utilizando un lenguaje que generaba
código BCPL:  Este código referencia siempre las direcciones de forma diferente
a las reales,  de manera  que las reales  son 1/4 de las BCPL,  por ejemplo, la
dirección 16 se convierte bajo BCPL en 4.

@endnode
@REMARK !¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node AmigaLink "Enlazadores que soportan el AmigaDOS"

Los  conceptos  actuales  de un enlazador estándar siguen siendo los mismos que
los  de  los primeros enlazadores a finales de la década de los cincuenta en el
siglo  pasado:  Esencialmente nada ha cambiado.  Un enlazador toma un fichero o
varios  y los fusiona en un único fichero listo para ejecutarse bajo un sistema
operativo y microprocesador específico.

El  fichero  objeto escrito por usted (por ejemplo) es uno de estos ficheros en
los  que  el  enlazador investiga para buscar las variables referenciadas y los
datos  estáticos  no  implementados.   Los  copiará en su fichero objeto si los
encuentra  en  alguno  de  los  demás  ficheros  objeto.  Algunas partes de las
instrucciones para el microprocesador también se copiarán en su fichero objeto.

Básicamente en el Amiga ha de enlazar tres ficheros objeto:

  startup.o
  main.o
  amiga.lib

El  fichero  "startup.o"  contiene  el  código llamado de arranque escrito como
primera entrada del programa cuando el ejecutable se pone en marcha.

En  el  fichero  "main.o" están sus instrucciones de la CPU para que la máquina
haga lo que usted desea.

El  fichero  "amiga.lib"  se  trata  de  un  fichero  con multitud de funciones
específicas  del  Amiga  y  declaraciones  que  en  su  mayoría  se utilizan en
cualquier programa ejecutable.

Tras  procesar  estas  tres  partes  con el enlazador se genera un programa que
puede ejecutarse bajo su microprocesador Motorola 68k.

Esta tarea la hacen actualmente los siguientes enlazadores:

  ALink, escrito como el primer enlazador disponible para el Amiga,
  BLink, escrito como sustituto de ALink,
  LC del paquete SAS-C,
  LN del paquete AZTEC-C,
  PhxLnk, un moderno enlazador,
  y multitud de enlazadores que vienen con un paquete para desarrollo.

Incluso  ALink actualmente es capaz de realizar todos los pasos necesarios para
generar un fichero cargador para el Amiga.

Un  caso especial, como no estándares, son los enlazadores C++.  Estos insertan
código  o  inicializan  variables sin existir declaraciones en su código fuente
(información  oculta) lo que en la mayoría de los casos infla su ejecutable sin
que usted sepa porqué.  Cuando use clases, no verá el trabajo que se realiza en
la  trastienda debido a éstas.  Puesto que un compilador traduce sólo código de
un  lenguaje  a  otro  (es decir de un formato legible por el ser humano a otro
legible  por  la  máquina),  el  enlazador  ha  de  unir  e  inicializar dichos
fragmentos.

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node GHunks "Propósitos generales de los segmentos"

Un programa de Amiga normal consta en tres (3) segmentos lógicos:  CODE, DATA y
BSS.   El  primero  contiene  el  código o instrucciones que el microprocesador
comprende,  el  segundo  contiene  las variables estáticas o inicializadas y el
tercero,  el  segmento BSS, es un almacenamiento virtual, sólo físico en tiempo
de ejecución.

Debido  a  que  el  Amiga  tiene  una gestión dinámica de la memoria donde nada
se carga directamente en memoria sin más, puesto que el fichero no tiene porqué
cargarse  siempre  en la misma área de memoria,  y más,  cuando otros programas
puede  haber  solicitado  previamente  dicha área de memoria,  se ha tenido que
elaborar una solución que aporte flexibilidad...

Y  ésta se basa en que cualquier programa de Amiga es escrito para la dirección
física cero.  Cuando se carga realmente el código, por ejemplo, en la dirección
'5000',  todas  las  direcciones absolutas se corrigen para ejecutarse en dicha
ubicación...  y para ello se utilizan los segmentos HUNK_RELOC.xx.

@endnode
@REMARK !¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@node Hints "Consejos"

@{u}El propio programa enlazador@{uu}

Lo  primero  de todo es que un enlazador ha de utilizar el segmento HUNK_HEADER
para  solicitar el espacio de trabajo de correcto.  A continuación, el segmento
HUNK_DATA  ha  de  ser analizado desde el final hasta la parte inferior para un
bloque  conectado con cero octetos.  Esto exige un compilador que almacene cero
octetos al final del área DATA.  Sólo los datos que no son nulos se guardan con
el  fichero  objeto o cargador.  El tamaño en el segmento HUNK_HEADER indica al
sistema cuántos octetos han de reservarse para este segmento.

El  siguiente paso es, que debería utilizar el segmento RELOC_SHORT en lugar de
de  la  versión LONG.  Otra buena idea es optimizar el código de manera que los
saltos  largos  jsr/jmp sean convertidos a jsr(pc), jmp(pc) o bsr/bra.  Esto es
hacer trampa porque otras direcciones relativas también han de ser corregirse.

Saltos  de 32 kilooctetos no deberían optimizarse, como por ejemplo jsr _pos ->
jsr (_pos.l, pc) <- ¡no lo use!

@endnode
@REMARK *¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨*
@REMARK * EOF *
