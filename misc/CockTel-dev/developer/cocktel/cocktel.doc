TABLE OF CONTENTS

vpack.library/VIPK_CreateA
vpack.library/VIPK_Delete
vpack.library/VIPK_Pack
vpack.library/VIPK_Unpack

apack.library/AUPK_CreateA
apack.library/AUPK_Delete
apack.library/AUPK_Pack
apack.library/AUPK_Unpack

adigi.device/OpenDevice
adigi.device/CMD_READ

vdigi.device/OpenDevice
vdigi.device/CMD_READ
vdigi.device/CMDVDIGI_ASK





vpack.library/VIPK_CreateA                     vpack.library/VIPK_CreateA

   NAME
        VIPK_CreateA - Erzeugt ein Arbeitsobjekt

   SYNOPSIS
        APTR  VIPK_CreateA(tags);
        D0.l                A0.l

        APTR  VIPK_CreateA(const struct TagItem*);

   FUNCTION
        Erzeugt ein Arbeitsobjekt zur Video - pack/unpack - Bearbeitung.
        Die Library kann in dieser Struktur private Daten ablegen.
        Es muß gewährleistet sein, daß die Library wiedereintrittsfähig
        (reentrant) ist. Am Programmende wird das Arbeitsobjekt mit
        VIPK_Delete() entfernt.

   INPUTS
        tags      - Datas

   RESULT
        Arbeitsobjekt oder NULL als Fehler.

   NOTE
        {
          struct TagItem Tags[]={
            VTHTAG_MODE,  VTHTMD_PACK
            TAG_DONE
          };

          APTR PackObject=VIPK_CreateA(Tags);  /* Arbeitsobjekt zum Packen erstellen */
          if(PackObject) {
            ...
            ...
            VIPK_Delete(PackObject);
          }
        }
   BUGS

   SEE ALSO
        VIPK_Delete()


vpack.library/VIPK_Delete                      vpack.library/VIPK_Delete

   NAME
        VIPK_Delete - Löscht ein Arbeitsobjekt

   SYNOPSIS
        VIPK_Delete(obj);
                    A0.l

        VOID  VIPK_Delete(APTR obj);

   FUNCTION
        Löscht ein mittels VIPK_CreateA() erzeugtes Arbeitsobjekt.

   INPUTS
        obj       - Arbeitsobjekt

   RESULT
   NOTE
   BUGS

   SEE ALSO
        VIPK_CreateA()


vpack.library/VIPK_Pack                        vpack.library/VIPK_Pack

   NAME
        VIPK_Pack - Video-Frame packen

   SYNOPSIS
        ULONG VIPK_Pack(obj, vth, buffer,bufSize,frameMode,packMode)
        D0.l            A0.l A1.l  A2.l   D0.l      D1.l     D2.l

        ULONG VIPK_Pack(APTR obj,const struct COCKTEL_VideoTransHeader* vth,
                 UBYTE* buffer,ULONG bufSize,ULONG frameMode,ULONG packMode);

   FUNCTION
        Packt ein Video-Frame und schreibt die Daten nach 'buffer'.

   INPUTS
        obj       - Arbeitsobjekt
        vth       - vth_Width,vth_Height: enthalten die Frame-Maße
                    vth_DigiType: zeigt das Format an
        buffer    - Schreibpuffer für die gepackten Daten.
                    Die Packroutine muß diesen Puffer füllen. 'buffer' wird
                    an die Gegenstelle übertragen und die VIPK_Unpack() übergeben
        bufSize   - max. Byte-Länge von 'buffer'
        frameMode - VTHPKMD_FULL:  Der Packer muß ein Keyframe erzeugen
                    VTHPKMD_DELTA: Der Packer kann ein Delta-Frame erzeugen.
                                   Die Bildgröße und der Farbmodus wurden nicht
                                   verändert.
        packMode  - 0x0000 => 0xffff, 0x0000==nicht gepackt (minimal gepackt)
                    0xffff==voll gepackt, 0x8000=> gute Packrate bei guter Qualität

   RESULT
        Anzahl der geschriebenen Bytes in 'buffer'.
   NOTE
   BUGS

   SEE ALSO
        VIPK_Unpack()


vpack.library/VIPK_Unpack                      vpack.library/VIPK_Unpack

   NAME
        VIPK_Unpack - Video-Frame entpacken

   SYNOPSIS
        ULONG VIPK_Unpack(obj, vth, buffer,bufSize)
          D0.l            A0.l A1.l  A2.l   D0.l

        ULONG VIPK_Unpack(APTR obj,const struct COCKTEL_VideoTransHeader* vth,
                 UBYTE* buffer,ULONG bufSize,ULONG frameMode,ULONG packMode);

   FUNCTION
        Entpackt ein Videoframe aus den Daten von 'buffer'.

   INPUTS
        obj       - Arbeitsobjekt
        vth       - vth_Width,vth_Height: enthalten die Frame-Maße
                    vth_DigiType: zeigt das Format an
        buffer    - Lesepuffer, der die Daten von VIPK_Pack() enthält.
        bufSize   - beschriebene Länge in 'buffer'

   RESULT
        - (0.l)
   NOTE
   BUGS

   SEE ALSO
        VIPK_Pack()


apack.library/AUPK_CreateA                     apack.library/AUPK_CreateA

   NAME
        AUPK_CreateA - Erzeugt ein Arbeitsobjekt

   SYNOPSIS
        APTR  AUPK_CreateA(tags);
        D0.l                A0.l

        APTR  AUPK_CreateA(const struct TagItem*);

   FUNCTION
        Erzeugt ein Arbeitsobjekt zur Audio - pack/unpack - Bearbeitung.
        Die Library kann in dieser Struktur private Daten ablegen.
        Es muß gewährleistet sein, daß die Library wiedereintrittsfähig
        (reentrant) ist. Am Programmende wird das Arbeitsobjekt mit
        AUPK_Delete() entfernt.

   INPUTS
        tags      - Datas

   RESULT
        Arbeitsobjekt oder NULL als Fehler.

   NOTE
        {
          struct TagItem Tags[]={
            ATHTAG_MODE,  ATHTMD_PACK
            TAG_DONE
          };

          APTR PackObject=AUPK_CreateA(Tags);  /* Arbeitsobjekt zum Packen erstellen */
          if(PackObject) {
            ...
            ...
            AUPK_Delete(PackObject);
          }
        }
   BUGS

   SEE ALSO
        AUPK_Delete()


apack.library/AUPK_Delete                      apack.library/AUPK_Delete

   NAME
        AUPK_Delete - Löscht ein Arbeitsobjekt

   SYNOPSIS
        AUPK_Delete(obj);
                    A0.l

        VOID  AUPK_Delete(APTR obj);

   FUNCTION
        Löscht ein mittels AUPK_CreateA() erzeugtes Arbeitsobjekt.

   INPUTS
        obj       - Arbeitsobjekt

   RESULT
   NOTE
   BUGS

   SEE ALSO
        AUPK_CreateA()


apack.library/AUPK_Pack                        apack.library/AUPK_Pack

   NAME
        AUPK_Pack - Audio-Frame packen

   SYNOPSIS
       ULONG AUPK_Pack(obj, ath, src, srcSize,buffer,bufSize);
        D0.l           A0.l A1.l A2.l  D0.l    A3.l   D2.l

       ULONG AUPK_Pack(APTR obj,struct COCKTEL_AudioTransHeader* ath,
                  const BYTE* src,size_t srcSize,UBYTE* buffer,size_t bufSize);

   FUNCTION
        Packt ein Audio-Frame und schreibt die Daten nach 'buffer'.

   INPUTS
        obj       - Arbeitsobjekt
        ath       -
        src       - Sample-Daten als 8Bit vom Digitizer
        srcSize   - Länge des Samples - zu packende Bytes
        buffer    - Schreibpuffer für die gepackten Daten.
                    Die Packroutine muß diesen Puffer füllen. 'buffer' wird
                    an die Gegenstelle übertragen und die AUPK_Unpack() übergeben
        bufSize   - max. Byte-Länge von 'buffer'

   RESULT
        Anzahl der geschriebenen Bytes in 'buffer'.

   NOTE
   BUGS

   SEE ALSO
        AUPK_Unpack()


apack.library/AUPK_Unpack                      apack.library/AUPK_Unpack

   NAME
        AUPK_Unpack - Audio-Frame entpacken

   SYNOPSIS
        ULONG AUPK_Unpack(obj, ath, src, buffer);
         D0.l             A0.l A1.l A2.l D0.l

        ULONG AUPK_Unpack(APTR obj,const struct COCKTEL_AudioTransHeader* ath,
                  const UBYTE* src,BYTE* buffer);


   FUNCTION
        Entpackt ein Audioframe aus den Daten von 'src'.

   INPUTS
        obj       - Arbeitsobjekt
        ath       -
        src       - Lesepuffer, der die Daten von AUPK_Pack() enthält.
        buffer    - Schreibpuffer für die entpackten Daten (abspielfähig)

   RESULT
        - (0.l)
   NOTE
   BUGS

   SEE ALSO
        AUPK_Pack()



adigi.device/OpenDevice                        adigi.device/OpenDevice

   NAME
        OpenDevice - Device öffnen und io-Daten setzen

   SYNOPSIS
        error = OpenDevice("adigi.device", unit, ioRequest, flags)
        D0.l                  A0.l          D0.l   A1.l     D1.l

	BYTE OpenDevice(STRPTR, ULONG, struct COCKTEL_SDigiIO*, ULONG);

   FUNCTION
        Vorbereiten des 'ioRequest' zur Bearbeitung.

   INPUTS
        unit      - Device-Unit
        ioRequest - Zu initialisierendes IO-Objekt. Das Device muß
                    io_Frquence, io_MinBPS,io_MaxBPS setzen.
                    io_Frquence: Grundfrequenz zur Berechnung der io_MicroDelay-Var.
                    Bei CMD_READ berechnet das Hauptprogramm die gewünschte Sample-Rate aus
                    (io_Frquence / BytesPerSec) und setzt io_MicroDelay.
                    Für das Device ist io_MicroDelay die zu überspringenden Zykeln je
                    Sample-Erfassung.
                    io_MinBPS,io_MaxBPS: Zeigen dem Hauptprogramm die minimale und
                    maximale Samplerate in Bytes per Sec.
        flags     - 0

   RESULT
     io_Error     - aufgetretener Error

   NOTE
   BUGS
   SEE ALSO



adigi.device/CMD_READ                          adigi.device/CMD_READ

   NAME
        Read - Sample Datas

   FUNCTION
        Startet den Sampleprozeß und liest io_Data mit io_Length Bytes ein.

   INPUTS
        io_Message   -  mn_ReplyPort wird erwartet
        io_Device    -  gesetzt von OpenDevice
        io_Unit      -  gesetzt von OpenDevice
        io_Command   -  CMD_READ
        io_Flags     -  IOB_QUICK wird nicht unterstützt
        io_Length    -  Anzahl der zu lesenden Bytes
        io_Data      -  Zeiger auf (BYTE*) mit einer Länge von io_Length.
                        Das Device muß diesen Puffer mit Audio-8-Bit Datas füllen.
        io_MicroDelay-  Für das Device ist io_MicroDelay die zu überspringenden Zykeln je
                        Sample-Erfassung. (siehe OpenDevice)

   RESULT
        io_Error     - aufgetretener Error
        io_Actual    - wirklich gelesene Anzahl von Bytes (normalerweise == io_Length)
   NOTE
        io_Data und io_Length dürfen NICHT modifiziert werden.

   BUGS
   SEE ALSO



vdigi.device/OpenDevice                        vdigi.device/OpenDevice

   NAME
        OpenDevice - Device öffnen und io-Daten setzen

   SYNOPSIS
        error = OpenDevice("vdigi.device", unit, ioRequest, flags)
        D0.l                  A0.l          D0.l   A1.l     D1.l

	BYTE OpenDevice(STRPTR, ULONG, struct COCKTEL_VDigiIO*, ULONG);

   FUNCTION
        Vorbereiten des 'ioRequest' zur Bearbeitung.

   RESULT
     io_Error     - aufgetretener Error

   NOTE
     Verhalten wie Standard-Device.

   BUGS
   SEE ALSO


vdigi.device/CMD_READ                          vdigi.device/CMD_READ

   NAME
        Read - Sample Datas

   FUNCTION
        Startet den Sampleprozeß und liest io_Data mit io_Length Bytes ein.

   INPUTS
        io_Message   -  mn_ReplyPort wird erwartet
        io_Device    -  gesetzt von OpenDevice
        io_Unit      -  gesetzt von OpenDevice
        io_Command   -  CMD_READ
        io_Flags     -  IOB_QUICK wird nicht unterstützt

        io_DigiType  -  gefordertes Format,
                        je nach Type (VDIGI_GRAY,VDIGI_RGB,...) wird
                        (io_Gray,io_RGB,...) verwendet. Das Device muß die angegebenen
                        Puffer in der Größe von io_Width*io_Height füllen.
        io_Width     -  geforderte Pixelbreite
        io_Height    -  geforderte Pixelhöhe

   RESULT
        io_Error     - aufgetretener Error
                       IOERR_NoVideoSignal: kein Videosignal vorhanden
                       IOERR_UnknownDType: io_DigiType beinhaltet einen unbekannten Typ
   NOTE
     Sämtliche Zeiger von (io_Gray, io_RGB, ...) dürfen NICHT modifiziert werden.

   BUGS
   SEE ALSO

vdigi.device/CMDVDIGI_ASK                      vdigi.device/CMDVDIGI_ASK

   NAME
        CMDVDIGI_ASK - Formatanfrage

   FUNCTION
        Das Device wird nach dem korrekten Grafikformat befragt.

   INPUTS
        io_Message   -  mn_ReplyPort wird erwartet
        io_Device    -  gesetzt von OpenDevice
        io_Unit      -  gesetzt von OpenDevice
        io_Command   -  CMDVDIGI_ASK
        io_Flags     -  IOB_QUICK wird unterstützt

        io_DigiType  -  gefordertes Format: (VDIGI_GRAY, VDIGI_RGB, ...)
        io_Width,
        io_Height    -  gewünschte Pixelbreite / Pixelhöhe
                        Das Device kann diese Werte modifizieren bzw. auf eine
                        interne Größe erweitern oder verkleinern.
                        Beim Ask füllt das Hauptprogramm io_Width und io_Height mit
                        den gewünschten Werten. Eine Breite von 320 ist die
                        maximale Kleinbildgrenze.
   RESULT
        io_Error     - aufgetretener Error
                       IOERR_UnknownDType: io_DigiType beinhaltet einen unbekannten Typ
   NOTE
       Die Vorgaben vom Device (io_Width, io_Height) sind für das Hauptprogramm
       Fakt und werden 100%ig eingehalten.

   BUGS
   SEE ALSO

