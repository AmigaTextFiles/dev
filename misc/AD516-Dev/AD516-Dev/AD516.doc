Sunrize AD516 Developer's documentation
(C) Copyright 2001-2002 Chris Brenner


Disclaimer
----------
This information is provided AS-IS. No warranties of any kind are made with
respect to this information. In no event will the author of this document be
liable for any direct, indirect, or consequential damages resulting from the
use of the information provided in this document, even if the author has
been advised of the possibility of such damages.


Credits
-------
Some of the information included in this document was taken from the Sunrize
Studio16 developer's documentation, most notably the cardcmds.h file.

cardcmds.h
(C) Copyright 1992 Sunrize Industries


Overview
--------
Most of the information in this document was gleaned from observing the
behavior of the AD516 card, and then making educated guesses about it. As
such, much of this information is subject to change as new discoveries are
made.

The Sunrize AD516 has two physical analog input channels, two physical
analog output channels, and eight virtual output channels which can be mixed
and routed to the physical output channels. It is essentially an intelligent
peripheral with an on-board DSP capable of automatically processing PCM data.

Programming for direct use of the AD516 card is not terribly difficult, but
there are a few pitfalls to be aware of. These will be will be pointed out
in the following sections. In general, programming for the AD516 can be
broken down into the following steps.

1. Find the base address of the AD516.

2. Install an interrupt server to handle interrupts generated by the AD516.

3. Load the DSP operating code into the AD516.

4. Send configuration commands to the AD516.

5.
   a. Send a block of PCM data, and command the AD516 to play it.

   b. Put the AD516 into record mode and read blocks of PCM data.

6. Send configuration commands to shut down the AD516.

7. Remove the interrupt server.


Communicating with the AD516
----------------------------
There are three registers on the AD516. These are the STATUS, PORT, and FIFO
registers. The STATUS register is in reality a byte sized read-only
register, but it can be accessed as a word --  Be aware that the status bit
definitions in the AD516 include file are only valid for byte sized accesses
to the STATUS register. For word sized accesses, the LSB is meaningless and
the status bits are located in the MSB of the word. In the event that the
AD516 generated an interrupt, writing to the STATUS register will clear the
interrupt. The PORT and FIFO registers are both word sized read/write
registers.

Commands are sent to the AD516 by writing the PORT register, and the WROK68
status bit must be clear before doing so. Some commands return a result. In
this case, the PORT register must be read before doing anything else with
the card. The RDOK68 status bit must be clear before reading from the PORT
register.

The FIFO register is used to send and retrieve PCM data to and from the
AD516, and there are some pretty rigid constraints on this activity. It is
necessary to wait for the WROKFIFO status bit to become set before writing a
word to the FIFO register. There is however, no need to check a status bit
before reading from the register. When using the AD516 for playback, 1024
words of PCM data for each active channel must be written once every
interrupt. Failure to adhere to this constraint will result in garbled and
distorted sound. When recording, 1024 words will be available from the FIFO
register once every record interrupt.

The registers are located at offsets from the base address of the AD516
card. This address can be found by calling FindConfigDev() using SUNRIZEID
and AD516ID as arguments, and then reading cd_BoardAddr in the returned
ConfigDev structure.


Handling AD516 Interrupts
-------------------------
The AD516 card generates an interrupt when it is ready to accept another
block of PCM data for playback, or when it is ready to provide a block of
PCM data during recording. The frequency of the interrupts is determined by
the period in which 1024 samples can be processed at the current sampling
frequency. For instance, if the sampling frequency is set to 44.1 KHz then
the interrupt frequency is 44100/1024 = 43.06641 interrupts/sec. As always,
the period is the recriprocal of the frequency, so in this case the interrupt
period will be 1/(43.06641 interrupts/sec) = 0.0232201 sec/interrupt.

When the AD516 is recording, it generates either one or two extra interrupts
during the normal play interrupt period depending on whether it is recording
from one or both inputs respectively. The time between interrupts is shown
below as a percentage of the play interrupt period. Note that play
interrupts are constantly generated, but record interrupts are only
generated when record mode is enabled.

Playback:

 P<---------------------------------100%--------------------------------->P


Single Input Recording:

 P<---------------------------99.9%--------------------------->L<--0.1%-->P


Two Input Recording:

 P<-------------------95%------------------>L<------4.9%------>R<--0.1%-->P

P = play interrupt
L = single or left channel record interrupt
R = right channel record interrupt


Since the AD516 generates INT6 interrupts, it is necessary to install an
interrupt server instead of an interrupt handler. To do this call
AddIntServer() with the intNum argument set to EXTERN. The interrupt code
will need to access the AD516 registers, so steps should be taken to ensure
that the base address of the card is accessible. An easy way to do this is
to put the base address of the card into is_Data in the Interrupt structure
that is being passed to AddIntServer().

The interrupt code will have to do its work in a very specific way, and the
order in which the AD516 registers are read and written during an interrupt
is critical for proper operation of the card. The following code fragment
shows how to handle an AD516 interrupt, and can be used as a template for
your own code. Assume that a1 holds the base address of the AD516 on entry
into the interrupt routine (you can assume this if you had passed this
address before installing the interrupt server).

IntCode  btst.b  #AD516INT,STATUS(a1)
         beq.s   AD516int
         moveq   #0,d0
         rts
AD516int btst.b  #RDOK68,STATUS(a1)
         bne.s   AD516int
         move.w  d0,STATUS(a1)
         move.w  PORT(a1),d0
         .
         .your code goes here
         .
         moveq  #1,d0
         rts

The very first thing that your interrupt code must do is make sure that the
interrupt was generated by the AD516. To do this check to see if the
AD516INT bit in the STATUS register is clear. If it's not, then the
interrupt was generated by another device. In this case return with the Z
flag set so that the interrupt will be passed along to the next server.

Once it has been determined that this is an AD516 interrupt, a number of
steps must be performed in a specific order. First, wait until it is safe to
read the PORT register, then clear the interrupt by writing anything to the
STATUS register, and finally read the PORT register. The meaning of the word
returned from reading the PORT register is still mostly a mystery, but I
have discovered what two of the bits represent. If the RECINT bit is clear,
then this interrupt was generated because the card is recording from either
one or both inputs, and it is time to read a block of PCM data from the FIFO.
If the RECINTLEFT bit is clear, then the interrupt was generated for single
input recording or to indicate the left channel during two input recording.
If it is set, then the interrupt was generated to indicate the right channel
during two input recording.

After the important steps have been taken, your interrupt code can do what
is necessary for your software. This can include signalling a task, sending
a message, or issuing a software interrupt. After your code is finished, it
should return with the Z flag clear so that the interrupt chain terminates.


Loading the DSP operating code
------------------------------
After a hardware reset, the AD516 is dormant and requires its own software
in order to become functional. There are two ways to load the operating code
into the AD516. The first method is to start the Studio16 software, and then
shut it down. The on-board operating code will remain active until the Amiga
is reset. The other method involves writing your own software to load the
operating code into the AD516.

Writing software to load the operating code into the AD516 is simply a
matter of sending the LoadCode command and the proper arguments followed by
the code itself. Take a look at the example source code, or the source code
in the LoadCode directory of the AD1012 developer information that can be
found on Aminet.

As stated above, the AD516 is in a dormant state after a hardware reset, and
must be made to respond in order to load the operating code into it. There
is a macro in the include file called WAKEUP that does this.

The DSP operating code is embedded in the AD516Handler. Take a look at
DumpDSPCode.s in the examples directory to see how to grab it for your own
use.


Initializing the AD516
----------------------
The following code fragment should be used to initialize the AD516 card
after the DSP operating code has been successfully loaded. Outside of
enabling interrupts, I'm not exactly sure what this does. I only know that
it is required.


   COMMAND   ReadPM
   READPORT  d0
   COMMAND   MODE|ON
   READPORT  d0
   COMMAND   PLAY_BLOCK|ON


Setting the Sampling Frequency
------------------------------
The sampling frequency affects both playback and record as well as the
interrupt frequency. It is a global setting, and because of this, the AD516
is incapable of simultaneous playback of two or more samples of differing
sampling rates. The following code uses the macros defined in the include
file and demonstrates the method for altering the sampling frequency.

   COMMAND   MODE|OFF
   READPORT  d0
   COMMAND   CntrlRegAdj,FrequencyArg1,FrequencyArg2
   COMMAND   MODE|ON
   READPORT  d0

The values for FrequencyArg1 and FrequencyArg2 are provided in the following
table.

Freq(Hz) Arg1(hex) Arg2(hex)
----------------------------
 5513    2104      2200
 6615    213C      2200
 8000    2104      1200
 9600    213C      1200
11025    210C      2200
16000    210C      1200
18900    2114      2200
22050    211C      2200
27429    2114      1200
32000    211C      1200
33075    2134      2200
37800    2124      2200
44100    212C      2200
48000    2134      1200


Setting the Input Gain
----------------------
The input gain allows an extra amount of gain over the standard setting of
0 db. Use the following command to set the input gain.

   COMMAND   DataRegAdj,MixArg,GainArg

The mix argument controls channel mixing. If mixing is disabled, then no
audio will be fed to the physical outputs.

$3F3F disables mixing
$4000 enables mixing

The values for the gain argument are provided in the following table.

Gain(db) Arg(hex)
------------------
 0       C0F0
 1       C1F1
 3       C2F2
 4       C3F3
 6       C4F4
 7       C5F5
 9       C6F6
10       C7F7
12       C8F8
13       C9F9
15       CAFA
16       CBFB
18       CCFC
19       CDFD
21       CEFE
22       CFFF

The following enables mixing, and sets the input gain to 0 db.

   COMMAND   DataRegAdj,#$4000,#$C0F0


Setting the Channel Volume Levels
---------------------------------
There are ten volume level settings on the AD516. Channel 0 corresponds to
the physical input, Channel 1 - Channel 8 corresponds to the virtual
outputs, and Channel 9 corresponds to the physical output. The volume level
for a channel is set by sending the appropriate volume command followed by
two arguments. The first argument controls the left volume level, and the
second argument controls the right. The arguments are word-sized with $8000
corresponding to a normal level of 0 db. The two extremes $0000 and $ffff
correspond to negative infinity db, and +6 db respectively. The following
example shows how to set Channel 1 and Channel 2 to normal volume levels.

   COMMAND   Chan1Vol,#$8000,#$8000
   COMMAND   Chan2Vol,#$8000,#$8000

Note that setting a volume level for Channel 0 allows the physical inputs
to be mixed with the virtual outputs. This can be used to monitor the inputs
during recording.


Setting the Playback Gains
--------------------------
The playback gain commands are basically mirrors of the channel volume
commands. These are used to set the gain and pan for a sample that is to be
played through one of the virtual output channels. The odd thing about these
commands is that they appear to be duplicates of the volume level commands,
but the numeric ID is backwards. For example, the Chan1Vol command is $011d,
but the Chan1Gain command is $080b. Chan2Vol is $021d, but Chan2Gain is
$070b. I guess these were done to correspond to the playback commands, which
appear to be backwards themselves. In any case, the arguments for the gain
commands are the same as for the volume commands. In this example, the
sample to be played through channel 1 will be panned full left, and the
sample through channel 2 will be panned full right.

   COMMAND   Chan1Gain,#$8000,#0
   COMMAND   Chan2Gain,#0,#$8000


Playing Samples
---------------
Once the card is configured to the proper settings, it is ready to start
processing PCM data. As stated earlier, in order to play samples through the
AD516, it is absolutely necessary to write EXACTLY 1024 words for each
active channel to the FIFO register once every interrupt. If you are double
buffering, and exhaust a buffer short of writing 1024 words, be sure to
borrow samples from the other buffer in order to write a total of 1024 words
within that interrupt period. Failure to do this will result in garbled and
distorted sound.

Playing a sample is simply a matter of first writing a number of words to
the FIFO register, and then sending a playback command which tells the AD516
how many samples were written, and which channel to play them through. As
stated earlier, EXACTLY 1024 words for each active channel must be written
to the FIFO once every interrupt. However, this can be done by breaking up
the data into a number of smaller blocks for a total 1024 words. The
following code fragment demonstrates how to play a single audio stream
through channel 1. Assume a1 has the address of one PCM buffer, and a2 has
the address of another, and that d1 and d2 have the number of samples
remaining in each buffer.

       move.l    d1,d0
       subq      #1,d0
Loop1  WRITEFIFO (a1)+
       dbra      d0,Loop1
       move.l    d1,d0
       lsl.l     #4,d0
       addq      #8,d0
       lsl.l     #1,d0
       WRITEPORT d0

       move.l    #1024,d3
       sub.l     d1,d3
       move.l    d3,d0
       subq      #1,d0
Loop2  WRITEFIFO (a2)+
       dbra      d0,Loop2
       move.l    d3,d0
       lsl.l     #4,d0
       addq      #8,d0
       lsl.l     #1,d0
       WRITEPORT d0
       sub.l     d3,d2

At first a loop counter is initialized, and the samples remaining in the
first buffer, which is assumed in this example to be a quantity less than
1024, are written to the FIFO register. The playback command is built in the
following steps. The length of the block just sent is put into d0 and
shifted left four times. Since the sample is being played through channel 1,
eight is added to d0. Remember, I told you that the playback commands were
backwards. If the data was to be played through channel 2, then seven would
have been added to d0. Finally, d0 is shifted left once more and written to
the PORT register.

Since there were less than 1024 words available in the first buffer, the
remaining words will have to come from the second buffer. Using d3, the
length of the block just written is subtracted from 1024 in order to find
the number of words needed from the second buffer. A loop counter is
initialized with this value and the remaining words, for a total of 1024,
are written from the second buffer to the FIFO register. Again, the playback
command is built by taking the length of the block written, shifting it left
four times, adding eight, and then shifting the whole thing left one more
time. Finally, after the playback command is written to the PORT register,
the length counter for the second buffer is adjusted.

This example demonstrated how to build the playback command on-the-fly.
However, many times it will be known in advance exactly how many words will
be written to the FIFO register, and which channel the sample is being
played through. In this case it would be easier to code the playback command
directly. For example, if you know that 1024 words will be sent and that
channel 1 is the destination, you could simply write $8010 to the PORT
register after the block has been sent.

In order to make things a little easier, there are playback commands defined
in the include file. These are for situations when you are hardcoding the
playback channel. For example, if you are hardcoding the PCM data to be
played through channel 1, but don't know the length, you would do the
following, assuming the length is in d0.

    lsl.l      #5,d0
    addq       #PlayChan1,d0
    WRITEPORT  d0

Or, if you know the length will always be 1024 words, you would code the
following.

    WRITEPORT  #PlayChan1|$8000

Depending on the Amiga's processor speed, it is possible to play up to eight
channels simultaneously. This is done by sending a block of 1024 words to
the card, and then writing a playback command that directs it to a channel,
sending another block, and writing another playback command that directs
that block to a different channel, and so on. This must all be done in a
single interrupt period or else the sound will be garbled and distorted, and
if the processor in the Amiga is only just fast enough to keep up with this
task then there will be no time left over for any other tasks.

To avoid the possibility of distorted sound during playback, your code
should send your PCM data to the AD516 as soon after the interrupt as
possible, and this process should not be interrupted by any other task. I
have found that creating a separate, high priority task that handles all
communication with the AD516 is a good way to accomplish this.


Recording
---------
Using the AD516 to record audio is simply a matter of setting the input gain
if necessary, issuing a record command, and then reading PCM data from the
FIFO register. Upon receipt of an interrupt, the RECINT bit will indicate
whether or not there is PCM data in the FIFO. If the RECINT bit is clear,
then EXACTLY 1024 words are available. Failure to sync your FIFO reads with
the RECINT bit may result in garbage being read from the FIFO. See the
section on interrupt handling for more information on the RECINT bit. When
recording from both inputs, the RECLEFT bit in the STATUS register will
indicate from which input the PCM data available in the FIFO came. If this
bit is clear, then the data is from the left input.

To enable recording from the left input, issue a record command using INPUTL
for the argument, and then read two words from the PORT register.

   COMMAND   RecordInOn,#INPUTL
   READPORT  d0
   READPORT  d0

To enable recording from the right input, use INPUTR in place of INPUTL. The
record command will return two words. The meaning of these words is still a
mystery, but it is important to read them. Otherwise the AD516 will lock up
the next time an attempt is made to write to the PORT register.

Once the AD516 is set into record mode, it will start buffering PCM data as
it reads from the inputs, and then send an interrupt with the RECINT bit
clear when the FIFO should be read. Exactly 1024 words must be read from
the FIFO when this happens.

If recording is enabled for both inputs, then the blocks of PCM data will
alternate between left and right. The RECINTLEFT bit can be used by your
interrupt code to help your software differentiate between left and right
record interrupts. The RECLEFT bit in the STATUS register can be used to
determine from which input this block of 1024 words came. In any case,the
very first block of 1024 words availble from the FIFO after recording has
been initiated will be from the left input. The next block of 1024 words
will be from the right, the block after that will be from the left, and so
on.

Since it is known that exactly 1024 words will be read from the FIFO, and
this will never change, the code that does this can be optimized to increase
the efficiency of this process. Instead of coding a loop that iterates 1024
times and reads a word from the FIFO each iteration, it is more efficient to
code a loop that iterates only 32 times and reads 32 words from the FIFO
each iteration.

To turn off record mode, issue the RecordOff command using one of the record
control arguments. For example, the following will stop the AD516 from
recording the left input audio.

   COMMAND   RecordOff,#INPUTL


Reading Channel Peaks
---------------------
The AD516 provides a convenient way to read peak levels for each channel.
The HiLowReq command will return twenty words which represent the current
left/right peaks for channels 0-9. The value returned by each read will be
between $0000 and $8000. The PORT register must be read exactly twenty times
after issuing a HiLowReq command, otherwise the AD516 will lock up the next
time an attempt is made to write the PORT register. The following example
shows how to read the current left and right peaks for the physical inputs.

   COMMAND   HiLowReq
   READPORT  LeftInputPeak
   READPORT  RightInputPeak

   moveq     #8,d1
1$ READPORT  d0
   READPORT  d0
   dbra      d1,1$


Shutting Down
-------------
In order to prevent locking up the system when your program exits, it is
necessary to shut down the AD516 card before removing your interrupt server.
Otherwise, if the AD516 asserts an interrupt, and there is no routine to
to clear it, the system will be interrupted again immediately after the last
server in the system interrupt chain returns. The only way out of this loop
is to reset the computer.

The following code fragment should be used to shut down the AD516 card.

   COMMAND   PLAY_BLOCK|OFF
   COMMAND   MODE|OFF
   READPORT  d0

