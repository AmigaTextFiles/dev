
				  MISC.DOC
			 (SUP32.LIB and DRES.LIBRARY)


WildCmp 							WildCmp

    CBOOL  = WildCmp(wildcard, filename)
    char *wildcard;
    char *filename;

    The wildcard characters supported are * and ?.  The wildcard is
    compared against the filename and (1) returned on success, (0) on
    failure.


WaitMsg 							WaitMsg

    msg    = WaitMsg(msg)
    EXECMSG *msg;

    This routines Waits for a message to be returned just like WaitIO()
    waits for an io request to complete.  The message is REMOVED from the
    reply port after it has returned.

    the message must have a valid mn_ReplyPort() and must have been queued
    with PutMsg(), which sets the ln_Type to NT_MESSAGE, and replied with
    ReplyMsg(), which sets the ln_Type to NT_REPLYMSG.


CheckMsg							CheckMsg

    msg/NULL = CheckMsg(msg)
    EXECMSG *msg;

    This routine checks to see if the message has been returned.  The
    same restrictions apply as for WaitMsg().  the message is NOT removed.
    The message is returned if it has been returned (not removed), or
    NULL otherwise.


CheckPort							CheckPort

    msg/NULL = CheckPort(port)
    EXECMSG *msg;
    PORT *port;

    This routine works like WaitPort(), but (1) does not block, and
    (2) does not remove the message.  If the port is not empty the first
    message is returned (not removed), else NULL is returned if the port
    is empty.


LockAddr							LockAddr

    (void) LockAddr(&lock)
    long lock[2];

    The lock structure (8 bytes) MUST initially be 0.  This routine obtains
    an exclusive lock on the structure and blocks until that lock can be
    obtained.  The structure must be word-aligned.

    Unless it is forced to block, this subroutine is extremely fast.  This
    routine does not allocate any signals, but uses the reserved EXEC
    semaphore signal.


LockAddrB							LockAddrB

    (void) LockAddr(bitno, &lock)
    long bitno;
    long lock[2];

    The lock structure actually supports up to 8 independant exclusive
    locks.  LockAddr() is a special case which uses bit # 0.  This call
    works as in LockAddr() but you may specify the bit you wish to lock
    (0 to 7).  If you specify 0, this call is equivalent to LockAddr().


UnLockAddr							UnLockAddr

    (void) UnLockAddr(&lock)
    long lock[2];

    Remove an exclusive lock you had previously obtained.  If other tasks
    are waiting for this lock, ALL are awakened even though only one will
    get the lock next.	This ensures that the highest priority task will
    get the lock next.

    This routine is extremely fast if nobody else is waiting for the lock,
    else it has to Signal() them.  You MUST have previously obtained the
    lock.


UnLockAddrB							UnLockAddrB

    (void) UnLockAddrB(bitno, &lock)
    long bitno;
    long lock[2];

    Again, this routine works the same as UnLockAddr() with the exception
    that you may specify one of the 8 bits to unlock (0 to 7).


DoSyncMsg							DoSyncMsg

    (void) DoSyncMsg(port, msg)
    PORT *port;
    EXECMSG *msg;

    This routine PutMsg()s a message and waits for it to be returned.  This
    routine creates its own reply port on the stack and stuffs it into
    mn_ReplyPort for you.  Thus, virtually no setup is required to use
    this routine.


FindName2							FindName2

    node/NULL = FindName2(list, name)

    This routine is identical to the EXEC FindName() call with the exception
    that it ignores nodes whos ln_Name fields are NULL.  ln_Name fields in
    the list nodes must contain either NULL or a valid string pointer.


GetTaskData							GetTaskData

    ptr = GetTaskData(name, bytes)
    APTR ptr;
    char *name;
    long bytes;

    This routine retrieves/allocates task-private named storage.  For a
    specific name, the first GetTaskData() call will allocate the specified
    # of bytes and zero them.  Space to hold the name itself is also
    allocated (i.e. you can use a temporary buffer to hold 'name' when you
    make this call).  Future calls return the pointer to the already
    allocated storage without modifying it.

    The storage is automatically freed if the TASK is removed... note that
    the task is not normally removed when a C program exits back into a
    CLI enviroment... it uses the CLI's task to run the program.  The
    task's memory list is used to implement this function.

    If 0 bytes are specified, the routine fails (returns NULL) if the named
    buffer does not already exist.


FreeTaskData							FreeTaskData

    (void) FreeTaskData(name)
    char *name;

    If the task-private name exists, the storage associated with it is
    freed.  This works with memlist entries allocated with GetTaskData()
    or by the user, assuming the ln_Name field points to a valid string.

    (note:  FreeEntry() is used after the associated MemList structure is
     unlinked frlom the list.  ln_Name is not specifically freed but the
     way GetTaskData() works, the second entry is actually the storage
     associated with the ln_Name)


