
SUPLIB.DOC	General C Support Library

			    COMPILATION

    Compile all modules using a precompiled symbol table of all the
    AMIGA include's (*/*.H) ... do *NOT* include standard aztec
    includes (stdio.h, etc...).  The Makefile for the precompiled symbol
    table is in the LOCAL directory.

    You must use the +L option (32 bit ints) for ALL COMPILATIONS, including
    the generation of the symbol table when compiling SUPLIB (SUP32.LIB).
    Also, use +B (no .begin reference), +CD (large code and data) model
    when compiling this source.


				    MODULES

    QINT:	These are exception based prioritized software interrupt
		routines.  see QINT.DOC

    ASYNCOP:	Asynchronous function execution.  Make asynchronous
		function calls (not incredibly fast).

    XFIO:	Asyncronous file IO.  Allows sequential asyncronous access
		to files for both reading (reads ahead asyncronously) and
		writing (writes asyncronously).  Usually employed by CPU
		bound programs not wishing to be slowed down even more by
		the disk.  Extremely useful for implementation of capture
		and serial protocols.

    DIO:	Device IO package.  This is a Generic interface for handling
		the Amiga's EXEC devices.  It makes your code smaller and
		much easier to read.  You no longer need to be a guru to
		use devices.

    BSTRING:	memory move/set/compare routines.  Operations are done in
		longwords when possible.

    SYS:	System enhancement calls

    MISC:	misc. routines (break checking, openning/closing libraries),
		date and time routines, setfiledate, etc...


    ---------------------------------------------------------------------

			       QINTS

    SEE QINT.DOC


			      ASYNCH OP

handle= NewAsyncOp()

	Create a new task for handling asynchronous function calls.

(void)  StartAsyncOp(handle, func, arg1, arg2, arg3)

	Queue up a function for the handle.  Multiple functions may
	be queueud.  NOTE:  The registers A4 and A5 will be initialized
	to what they were when NewAsyncOp() was called.

	The function must preserve D4-D7/A2-A3.  D0-D3/A0-A1/A4-A6 may
	be destroyed by the function.


bool  = CheckAsyncOp(handle, n)

	Return TRUE if a minimum of N async operations started with
	StartAsyncOp() have completed, FALSE otherwise.  The number
	of async operations in progress is the number started minus
	the number already waited for.

(void)= WaitAsyncOp(handle, n)

	Wait for N of the operations in progress to complete.  -1 can
	be specified to wait for ALL the operations in progress to
	complete.

	For example, if you queue up 3 commands, CheckAsyncOp(handle, 3)
	will check if all 3 have completed, and WaitAsyncOp(handle, 3)
	waits and removes their reply messages as well as adjusts the
	number of 'operations in progress' to 0.

	I.E, if you were to WaitAsyncOp(handle, 2) instead of 3, after
	it returns there will be 1 operation in progress left.	If you
	were to do another StartAsyncOp(), there would now by 2 in
	progress.

(void)  CloseAsyncOp(handle)

	Wait for all operations in progress to end (WaitAsyncOp(handle,-1)),
	then remove the task.

				 XFIO


    xfi =   xfopen(file, mode, bytes)
    err =   xfclose(xfi)
     n	=   xfread(xfi, buf, n)
     n	=   xfgets(xfi, buf, max)
    err =   xfwrite(xfi, buf, n)

		mode is "r", "w", or "w+".  No seeking is allowed as you can
		see.  If you openned for reading, you may NOT use xfwrite(),
		and if you openned for writing, you may NOT use xfread().

		r   read
		w   write-newfile
		w+  write-append

		The specified buffer size (bytes) is used to create two
		buffers of (bytes/2) bytes, double buffering either
		asyncronous read ahead, or asyncronous writes.

		'err' returns 1 if a write error occured.  err is returned
		by xfclose() (xfclose() waits for any asyncronous writes
		to complete and thus can return whether they failed or not).
		Once set, err stays set forever.

		XFREAD: 0 is returned on EOF or error
		XFGETS: the length of the string is returned.  0 is a valid
			length (a blank line).  -1 is returned on EOF or
			error.	The newline is removed and a string
			terminator (0) added.


				DIO

	 SEE DIO.DOC


			       BSTRING

(void)  bmov(src,dest,bytes)
bool  = bcmp(src,dest,bytes)
(void)  bset(src, bytes, c)
(void)  bzero(src, bytes)

	These functions do various memory operations.  bcmp() is does an
	unsigned comparison, of course.  bcmp() only checks for
	equivalence, returning TRUE (1) if the buffers are the same,
	FALSE (0) otherwise.  bcmp() uses longword compares when possible.

	bmov() does an ascending or decending copy as appropriate.
	bmov(), bzero(), and bset() use longword and MULTIPLE REGISTER
	operations when possible.

	These functions are the same as the BSet(), BZero(), BMov(), and
	BCmp() in my run-time library DRES.LIBRARY.

bool =	checkbreak()

	Check whether the process has received a ^C or ^D signal.  ^D
	is also checked here allowing a more reliable break-mechanism,
	as Aztec and Lattice stdio routines will clear ^C even when
	break is disabled.

(void)  resetbreak()
(void)  disablebreak()
(void)  enablebreak()

	resetbreak() clears both the ^C and ^D signals.  disablebreak()
	and enablebreak() modify the global variable Enable_Abort and
	thus stdio's automatic break detection/abort.


bool  = openlibs(flags)
bool  = closelibs(flags)

	See the flag definitions in XMISC.H.  openlibs() opens all
	specified libraries, returning 0 if one or more could not
	be openned.  closelibs() closes all specified libraries.
	openlibs() does not open a library that is already open (if you
	make the call more than once), and simply uses the already
	open descriptor.

	closelibs(-1) closes ALL libraries openned with openlibs(), but
	NOT libraries openned otherwise.

	Note that you cannot open or close DOS or EXEC.  This is because
	the C startup will do this for you, and also to prevent linker
	warning messages.

Window= GetConWindow()

	This functions retrieves the struct Window * from the console
	device associated with this process.  NULL is returned if the
	window could not be found (still, operation may not be dependable
	if the process's console is not a console device).

buf   = datetos(date, buf, ctl)
	DATESTAMP *date;
	char *buf;
	char *ctl;

	This function converts a DOS DateStamp structure into a string
	and places it in the specified buffer.	ctl specifies the format
	of the date by pieces (ctl can be NULL, indicating "D M Y h:m:s").

	If not NULL, ctl is a string containing combinations of the
	following characters.  Spacing must also be specified.	Any
	unrecognized characters are passed to the output buffer verbatim.

	    D	The day 	23
	    M	The month	Jul
	    Y	The year	1988
	    h	The hour	03
	    m	The minute	23
	    s	The seconds	04

	This function is equivalent to DateToS() in my run time library
	DRES.LIBRARY

(void)  llink(list, en)         (OBSOLETE)
(void)  lunlink(en)             (OBSOLETE)

	see XMISC.H .  Simple doubly-linked list routines.  XLIST is both
	the list base and an element.  The list base should be initialized
	to zero before use.

(void)  mountrequest(bool)

	enable or disable the DOS requester which comes up when you attempt
	to open a path not currently mounted.  Normal mode is TRUE (1),
	meaning that you get the requester.  This routine remembers the
	previous contents of pr_WindowPtr.  The call mountrequest(0) may
	be made multiple times and then mountrequest(1) will restore the
	original contents of pr_WindowPtr.

RemSemaphore()
FindSemaphore()     (SEE EXEC DOCUMENTATION FOR CALLING PARAMETERS)
AddSemaphore()

	These functions fix the broken bindings in older Lattice and
	Aztec libraries.

bool  = setfiledate(file, date)
	char *file;
	DATESTAMP *date;

	This function implements the new ACTION_SET_DATE packet and
	sets the timestamp of a file.  You cannot set the timestamp
	for the root of a filesystem with this call.

	This function is equivalent to the SetFileDate() function in
	DRES.LIBRARY.

bool =	wildcmp(wildstr, namestr)

	compare the wildcard string (containing '*'s and '?'s) with
	the file name (namestr) and return TRUE (1) if they compare,
	and FALSE (0) otherwise.

	This function is equivalent to the WildCmp() function in
	DRES.LIBRARY.

(void)  fhprintf(fh, ctrlstr, args...)

	uses the EXEC formatted printing call to format text and then
	writes it to an AMIGADOS file handle.


rval  = AutoAllocMiscResource(resno, value)

	resno: MR_SERIALPORT, SERIALBITS, PARALLELPORT, or PARALLELBITS
	value:	-1 to allocate, 0 to check.

	This functions allocates or checks the specified resource.  0
	(ZERO) is returned on SUCCESS (allocated or could allocate),

	NON-ZERO is returned if the resource is already allocated by
	somebody else.

(void)= AutoFreeMiscResource(resno)

	Free's a resource you allocated.  YOU MUST OWN THE RESOURCE!

	Neither of these functions require you to open the misc.resource
	resource.

font  = GetFont(name, ysize)

	This function searches both memory and the disk for the requested
	font, and automatically opens/closes the diskfont library if it is
	not already open.  It opens the font, incrementing the reference
	count.

(void)  InitDeemuNW(ary, nw)
	short *ary;
	NW *nw;

	ary points to the 'NW','  ' Deemu[] array entry.  The NewWindow
	structure is initialized according to the Deemu entry.	Currently,
	TopEdge, LeftEdge, Width, Height, DetailPen and BlockPen will
	be initialized... less if the Deemu entry contains less information.

char   *GetDEnv(name)
	char *name;

	Return a string to the enviroment variable name, returning NULL
	if it does not exist.

bool	SetDEnv(name, str)
	char *name, *str;

	Set the enviroment variable name to the string str.  Return C-TRUE
	(1) on success, or C-FALSE (0) on failure.



