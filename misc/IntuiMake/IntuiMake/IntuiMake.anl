                              IntuiMake v1.2

                 © 1993 Björn E. Trost und Dirk O. Remmelt.



i. Rechte und Pflichten der Autoren

   IntuiMake v1.2 wurde mit größtmöglicher Sorgfalt entwickelt und
   getestet. Dennoch können Fehler im Programm selbst und in mit
   IntuiMake erzeugten Programmen nicht ausgeschlossen werden.
   Die Autoren können für solche Fehler nicht haftbar gemacht werden.



ii. Rechte und Pflichten des Benutzers

   Mit IntuiMake wird Entwicklern ein Werkzeug zur Programmentwicklung
   zur Verfügung gestellt, mit dem sie ohne Probleme größere Programm-
   projekte entwicklen können. Dazu sind keine Vorkenntnisse erforderlich,
   da IntuiMake, wie der Name ja schon sagt, nicht mit Skript-Dateien arbeitet,
   wie sie sonst üblich sind.

   IntuiMake darf frei kopiert und in PD-Serien aufgenommen werden,
   sofern der Verkaufspreis einer Diskette nicht DM 5,- übersteigt. Wird
   IntuiMake in eine Serie aufgenommen, so bitten die Autoren um die
   Übersendung einer Kopie.

   IntuiMake darf nicht rekompiliert oder in irgendeiner Form verändert
   werden. Dies betrifft vor allem Copyrightmeldungen und Versionsnummern.

   IntuiMake ist keine Shareware, es besteht jedoch die Möglichkeit der
   Registrierung. Registrierte Anwender erhalten Upgrades, eine mit TeX
   gesetzte, ausführliche Anleitung und einen umfassenden Support. Eine
   Registrierkarte befindet sich als Datei `Register.txt' in diesem
   Paket. Interessierte Anwender können sie ausdrucken und absenden.

   Natürlich sind auch Zuschriften jeglicher Art ohne Registrierung
   willkommen. Falls Rückantwort gewünscht wird, bitte das Rückporto
   beilegen.



iii. DerInhalt dieses Paketes

   Dieses Softwarepaket sollte folgende Dateien enthalten:

   · IntuiMake:              Das ausführbare Programm.
   · IntuiMake.anl:          Diese Anleitung.
   · NewlookMake:            Eine spezielle Version von IntuiMake.
   · Register.txt:           Registrierungskarte.
   · example/first.c
   · example/first_protos.h
   · example/headerfile.h
   · example/makefile
   · example/main.c
   · example/second.c
   · example/second_protos.h
   · example/test
   · example/obj/first.o
   · example/obj/main.o
   · example/obj/second.o



1. Die Aufgaben eines Make

   Ein Make dient dazu, ein aus mehreren Modulen bestehendes Programm
   möglichst komfortabel zu kompilieren. Vor allem das Kompilieren eines
   oderer mehrerer Module bei Änderung eines Headerfiles soll automatisiert
   werden.

   IntuiMake ist in der Version 1.2 auf den Aztec-Compiler von Manx
   ausgelegt.



2. Das Starten, benötigte Dateien, etc.

   IntuiMake benötigt OS2.0, die ASL-library in LIBS: und sonst nichts.
   Standardmäßig wird das Makefile unter dem Namen `makefile' im aktuellen
   Verzeichnis erzeugt.

   Gestartet wird IntuiMake am zweckmäßigsten mit `Intuimake'. Die
   Angabe eines Dateinamens wie z.B. `IntuiMake GenialesMake' ist
   optional. IntuiMake verwendet dann das angegebene Makefile statt des
   Standard-Makefiles im aktuellen Verzeichnis.

   IntuiMake öffnet daraufhin ein Fenster, das auf der Workbench verschieb-
   und in der Größe veränderbar ist.Die Einstellungen des Makefiles
   werden nun nachgeladen und IntuiMake ist einsatzbereit.

   Es ist nicht sinnvoll, IntuiMake von der Workbench aus zu starten, da
   die Ausgaben des Compilers und Linkers nicht umgeleitet werden. Man
   sollte also mit einer geöffnete CLI/Shell und IntuiMake gleichzeitig
   arbeiten. Zum Glück hat dieser unser Rechner ein Multitasking-
   Betriebssystem.



3. Der Bildschirm nach dem Starten.

   Nach dem Starten und Einladen des eventuell vorhandenen Makefiles öffnet
   sich das Hauptfenster. Der größte Teil beansprucht ein Anzeigefeld für sich,
   in dem alle Module, die zum Programm gehören, dargestellt werden.

   Darunter befinden sich die Systemsymbole zum Starten des Kompilier- und
   Linkvorgangs, zum Starten eines Editors, zum Ausführen und Debuggen des
   Programms.

   Der rechte Teil des Bildschirm besteht aus Eingabefeldern für Symbolnamen,
   Namen der zu erzeugenden Dateien, Versionsnummer und einem Schalter
   zum Aktivieren der Debuginformationen.

   Das Fenster kann beliebig vergrößert und auf dem Bildschirm positioniert
   werden. Diese Einstellungen werden im Makefile gespeichert.



4. Die Menüs


4.1 Project

4.1.1 Save makefile
        Hiermit kann ein erstelltes Makefile abgespeichert werden. Als
        Filename wird `makefile' bzw. der beim Start angegebene Name
        verwendet.
4.1.2 Save makefile as ...
        Manchmal ist es sinnvoll, mit mehreren verschiedenen Makefiles zu
        arbeiten. Dann kann man mit diesem Menüpunkt mit Hilfe des
        ASL-Dateiauswahlfensters einen geeigneten Namen festlegen.
4.1.3 Load makefile ...
        Um ein Makefile während der Laufzeit zu laden, selektiert man
        diesen Menüpunkt und wählt im ASL-Dateiauswahlfenster das
        gewünschte Makefile an.
4.1.4 Delete objectfiles ...
        Die Aufgabe eines Make's ist es, möglichst viele Schritte zu
        automatisieren. Nun gibt es jedoch Dinge, die eine Kompilation
        eines Moduls erfordern, ohne daß IntuiMake dies erkennen würde, wie
        z.B. das Kopieren eines älteren Moduls zu den aktuellen Modulen. Um
        das betreffende Modul dennoch kompilieren zu lassen, kann man die
        erzeugte Objektdatei löschen. Dies kann man mittels Mehrfachauswahl
        (Shift-Taste gedrückt halten) im ASL-Dateiauswahlfenster erledigen.
4.1.5 Edit preferences ...
        Im Voreinstellungsfenster können viele Einstellungen vorgenommen
        werden:
4.1.5.1 Comparing
        IntuiMake bietet die Möglichkeit, zwei Sätze von Modulen zu
        vergleichen, z.B. um Unterschiede zu einer alten Version
        festzustellen. Dazu müssen die beiden Pfade eingegeben werden,
        in denen sich die Modulsätze befinden. Im Eingabefeld `Output'
        wird die Ausgabedatei festgelegt.
4.1.5.2 Scanning
        Die automatische Suche nach Abhängigkeiten kann beschleunigt
        werden, indem man in den Dateien nach den `#include'-Anweisungen
        eine Zeichenfolge, in Kommentaren, angibt, die das Ende der
        `#include'-Anweisungen signalisiert.
        Diese Zeichenfolge kann mit `EndString' angegeben werden.
        Eine Zeichenfolge, mit der der Beginn der Durchforstung angegeben
        werden kann, kann man im Eingabefeld `BeginString' festlegen. Ob
        diese Zeichenfolge auch genutzt werden soll, kann mit dem Schalter
        daneben bestimmt werden. Diese Zeichenfolgen können für Assembler-
        und C-Dateien getrennt eingestellt werden.
        Für zukünftige Erweiterungen gedacht sind die Blättersymbole,
        mit denen die Syntax festgelegt wird, mit der Dateien included
        werden. Dies dient vor allem der Unterscheidung von Headerdateien,
        die mit `<...>', also Systemheaderdateien, und mit `"..."', also
        Projektheaderdateien, included werden.
4.1.5.3 Paths
        Mit dem Blättersymbol kann man bestimmen, ob eine ausführbare
        Datei oder eine Linker-Bibliothek erzeugt werden soll. Soll eine
        Linker-Bibliothek erzeugt werden, müssen sich die von Manx
        mitgelieferten Programme `Lb' und `Ord' im Suchpfad befinden.
        Im Hauptfenster kann man mit `Edit' das aktuelle Modul edieren. Dazu
        muß im Eingabefeld `Editor' der verwendete Editor, z.B. `Ced',
        eingetragen werden.
        Soll eine vorkompilierte Headerdatei benutzt werden, so ist sie
        hier im Eingabefeld `-hi file' anzugeben. Soll sie auch in den
        Kompiliervorgang eingebunden werden, so muß die -hi Options bei
        den Compiler-Optionen aktiviert sein.
        Um alle Module, die Headerdateien und das Makefile zu archivieren
        ist das Eingabefeld `Archive' vorhanden. Hier muß die Datei
        angegeben werden, in die das Archiv geschrieben werden soll.
        Im Eingabefeld `Sourcecode' ist der Pfad einzutragen,
        in dem sich die Module befinden. Die erzeugten Objektdateien
        können auf Wunsch in ein Verzeichnis geschrieben werden, das
        im Eingabefeld `Objectcode' festgelegt wird.
4.1.6 Edit linkeroptions ...
        Hier kann man die Optionen für den Linker eingeben. Sie sind im
        Handbuch genau erklärt. In das Eingabefeld `Additional modules'
        werden die Bibliotheken und Module eingetragen, die nicht in der
        Modulliste vorkommen, z.B. `-lmf -lc'.
4.1.7 About ...
        Es erscheint ein mit MaxonPAINT erstelltes Informationsfenster.
4.1.8 Quit
        Verlassen von IntuiMake.


4.2 Action

4.2.1 Make ...
        Hiermit wird der Kompilier- und Linkvorgang gestartet. Es erscheint
        ein Fenster, das das Modul anzeigt, das zur Zeit kompiliert wird.
        Mit dem Symbol zum Schließen des Fensters kann das Kompilieren
        abgebrochen werden. Dann, oder bei Fehlern während des Kompilierens,
        kann man mit dem Symbolen `Edit' die fehlerhafte Datei ediert
        werden. `Retry' beginnt den Kompiervorgang an der abgebrochenen
        Stelle. `Next' beginnt mit dem nächsten Modul, `Make' schließlich
        beginnt von vorne.
4.2.2 Edit
        Startet den in den Voreinstellungen eingestellten Editor mit
        dem aktuellen Modul. Mit einem Doppelklick auf das Modulauswahlfeld
        kann ebenfalls eine Datei editiert werden.
4.2.3 Run
        Startet das erzeugte Programm.
4.2.4 Debug
        Startet den Debugger `sdb' von Manx.

        Die oben aufgeführten Menüpunkte können auch alle über die Symbole
        unter dem Modulauswahlfeld aktiviert werden, was mit Sicherheit
        schneller geht.


4.3 Modules
        IntuiMake kann Module in C und in Assembler verwalten. Assemblermodule
        sollten die Endung `.asm' haben.

4.3.1 Insert modules...
        Hier wählt man mit Hilfe des ASL-Dateiauswahlfensters die Module
        an, die zu dem zu erstellenden Programm gehören. Eine
        Mehrfachauswahl mit Hilfe der Shift-Taste ist möglich.
        Auch zu einem späteren Zeitpunkt ist es möglich, Module zu bereits
        bestehenden Modulen hinzuzufügen.
4.3.2 Delete module
        Wenn man diesen Menüpunk selektiert, wird das zur Zeit angezeigte
        Modul gelöscht.
4.3.3 Scan module
        IntuiMake bietet die Möglichkeit, abhängige Headerfiles eines
        Moduls automatisch zu erkennen. Dazu wird das angewählte Modul auf
        `#include"' durchforstet. Es werden rekursiv die weiteren
        Headerfiles durchsucht, bis alle Abhängigkeiten festgestellt worden
        sind.
        Um den Scan-Vorgang zu beschleunigen, bietet IntuiMake die
        Möglichkeit, bei Auffinden einer bestimmten Zeichenfolge den
        Scan-Vorgang des Headerfiles oder Moduls abzubrechen. Dies ist
        besonders bei großen Modulen sinnvoll. Die Zeichenfolge kann
        in den Voreinstellungen festgelegt werden  und sollte nach allen
        `#include'-Anweisungen stehen.
4.3.4 Scan all modules
        Hiermit werden alle Module nach abhängigen Headerfiles durchsucht.
        Ein Abbruch ist durch Selektieren des Symbols zum Schließen des
        Fensters möglich.
4.3.5 Compare set of modules
        Arbeiten an einem Projekt mehrere Autoren an mehreren Rechnern,
        müssen die geänderten Module irgendwann zusammengefügt werden.
        Zu diesem Zweck bietet IntuiMake die Möglichkeit an, alle
        eingetragenen Module auf Änderungen zu untersuchen. Es wird das
        Programm `Diff' aufgerufen, das dem Aztec-Compiler beiliegt.
        In den Voreinstellungen müssen die Pfade festgelegt werden, in
        denen sich die zwei zu untersuchenden Modulsätze befinden.
        Die Module werden bei Anwahl dieses Menüpunktes auf Änderungen
        untersucht und das Ergebnis in die angegebene Datei geschrieben.
4.3.6 Archive set of modules        
        Mit dem Programm `Lha', das sich im aktuellen Suchpfad befinden muß,
        werden bei Anwahl dieses Menüpunktes alle Moduldateien, Headerdateien
        und das Makefile gespeichert. Dazu muß in den Voreinstellungen
        im Eingabefeld `Archive' ein Dateiname angegeben werden.
4.3.7 Edit options
        Um die Optionen zum Kompilieren oder Assemblieren einzustellen,
        wählt man diesen Menüpunkt an. IntuiMake bietet bis zu fünf
        beliebig programmierbare Voreinstellungen (Default) und eine
        modulspezifische Einstellung (Custom) an. Die Default-Einstellungen
        gelten für alle Module, die diesen Default eingestellt haben, während
        die modulspezifische Einstellung nur für das augenblickliche Module
        gelten.
        Um eine Default-Einstellunge zu ändern ändert man einfach die
        Einstellungen und selektiert `As default'.



5. Defines

   An den Compiler kann man Defines übergeben. IntuiMake unterstützt
   bis zu fünf solcher Symbole, die in die Eingabefelder eingetragen
   werden können. Mit dem Schalter links des Eingabefeldes kann man
   festlegen, ob der Define übergeben wird. Dies ist dann sinnvoll,
   wenn man im Programm eine Abfrage, wie z.B.

        #ifdef DEMO
               Save ();
        #else
               puts ("Demoversion!");
        #endif

   hat



6. Erstellen eines Projektes

   In diesem Abschnitt soll beschrieben werden, wie man IntuiMake
   konfiguriert und anschließend damit arbeitet. Zu diesem Zweck
   ist im Programmpaket von IntuiMake ein Beispielprojekt enthalten,
   das aus drei Modulen besteht, die miteinander verknüpft sind.


6.1 Ein Beispiel

  Hier sind nun die Module:

        /* main.c
        **
        **
        */

        #include "first_protos.h"
        #include "second_protos.h"
        /* SCAN_END */

        void main (void)
        {
          Test1 ("Test it:", 1);
          Test2 ("Just do it:");
        }




        /* headerfile.h
        **
        ** SCAN_END
        */

        struct MyStruct
        {
          int  a;
          long b;
        };




        /* first.c
        **
        **
        */

        #include "headerfile.h"
        /* SCAN_END */

        void Test1 (char *message, long var)
        {
          struct MyStruct mystruct = {1, 2L};

          printf ("%s %d\n%d\n%d\n", message, mystruct.a, mystruct.b, var);

        }




        /* second.c
        **
        **
        */

        #include "headerfile.h"
        /* SCAN_END */

        void Test2 (char *message)
        {
          struct MyStruct mystruct = {3, 4L};

          printf ("%s %d\n%d\n", message, mystruct.a, mystruct.b);
        }




        /* first_protos.h
        **
        ** SCAN_END
        */

        void Test1 (char *message, long var);




        /* second_protos.h
        **
        ** SCAN_END
        */

        void Test2 (char *message);




   In `headerfile.h' wird eine Struktur `MyStruct' definiert, die
   in den Modulen `first' und `second' benötigt wird. Sie muß dort
   also included werden. `main' benötigt diese Struktur nicht. Hier
   werden jedoch die Prototypdeklarationen der verwendeten Funktionen
   `Test1' und `Test2' benötigt. Also müssen `first_protos.h' und
   `second_protos.h' included werden.

   Somit sind die Abhängigkeiten klar, bei einer Änderung einer Datei,
   von der andere anhängig sind, müssen diese alle neu kompiliert
   werden. Hier nun das Schaubild, aber keine Angst, man braucht bei
   IntuiMake keine Schaubilder zu malen, das hier soll nur der
   Verdeutlichung dienen:

   (a -----> b     bedeutet, daß b von a abhängig ist.)



            first_protos.h -----> main.c <----- second_protos.h



            first.c <----- headerfile.h -----> second.c


   Ändert man z.B. die Funktion `Test1' in

               void Test1 (char *message1, short var)

   um, muß auch die zugehörige Datei `first_protos.h" geändert werden.
   Das bewirkt, daß main.c neu kompiliert werden muß, da sich der
   Aufruf von `Test1' geändert hat. Second.c muß nicht kompiliert
   werden.

   Ändert man in `headerfile.h' die Struktur `MyStruct' um, z.B. in

               struct MyStruct
               {
                 short a;
                 long b;
               };

   so müssen `first.c' und `second.c' kompiliert werden, da sie beide
   auf `MyStruct' zugreifen. `main.c' benötigt diese Struktur nicht
   und muß daher nicht kompiliert werden.

   Soweit die nötigen Erläuterungen. Und nun das schöne daran: Das
   alles muß man sich nicht merken, diese Arbeit wird von IntuiMake
   erledigt.



6.2 Die Einstellungen für obiges Beispiel

   Um aus den Quelltexten ein lauffähiges Programm zu generieren, sind
   zunächst einige Schritte zu erledigen, die hier beschrieben werden:

   Zunächst muß IntuiMake aus dem CLI/Shell aufgerufen werden:
         <IntuiMake> bzw. <run IntuiMake>

   Nach erfolgreichem Starten müssen dann die Module eingetragen
   werden. Dazu wählt man den Menüpunkt `Modules/Insert modules ...'
   an. Es erscheint das ASL-Auswahlfenster, mit dem man mit gedrückter
   Shift-Taste die Dateien auswählt, die zum Programm gehören. In
   obigem Beispiel also `main.c', `first.c' und `second.c'. Die
   Header- und Prototypdateien dürfen nicht angewählt werden.

   Die gewählten Dateien erscheinen nun alphabetisch geordnet im
   Modulauswahlfenster. Dort können sie auch später angewählt werden.

   Als nächstes legt man die Compileroptionen fest, die jedes Modul
   benötigt: Man wählt das Modul im Anzeigefenster aus, für das man
   die Optionen festlegen möchte. Sodann wählt man
   `Modules/Edit options' an. Es erscheint ein Fenster mit allen
   möglichen Optionen, deren Bedeutung man im Handbuch zum Aztec-
   Compiler nachschlagen kann.

   Mit dem Blättersymbol kann man aus fünf Voreinstellungen die
   richtigen wählen, oder für das Modul eigene bestimmen. Die
   Voreinstellungen sind sinnvoll, wenn man für einen Teil seiner
   Module die gleichen Optionen verwendet. Dann legt wählt man
   die Voreinstellung an, die programmiert werden soll, stellt die
   Optionen wie gewünscht ein und klickt auf `As default'. Die
   Optionen werden dann gespeichert und sind dann auch in den
   anderen Modulen verwendbar.

   Sind die Optionen festgelegt, trägt man im Eingabefeld die
   Versionsnummer des Programms ein, z.B. `1.2'. IntuiMake erzeugt
   automatisch einen systemkonformen Versionstring.

   Darunter legt man den Name des Programms fest, das erzeugt werden
   soll.

   Schließlich muß nach mit `Project/Edit linker options ...' das
   Fenster zum Einstellen der Linkeroptionen geöffnet werden.
   Für obiges Beispiel muß im Eingabefeld `Additional modules;
   noch `-lc' eingetragen werden, damit die von Manx mitgelieferte
   l-Bibliothek mitgelinkt wird.

   Sind alle Einstellungen soweit durchgeführt, muß man mit
   `Modules/Scan all modules ...' die Module nach Abhängigkeiten
   durchforsten. Ist dies erledigt, sollte man mit
   `Project/Save makefile' das eben erzeugte Makefile abspeichern.

   Nun kann mit `Action/Make' der Kompilier- und Linkvorgang
   gestartet werden.

   Es erscheint ein Ausgabefenster, im dem angezeigt wird, wie
   viele Module bereits kompiliert wurden. Trat während das
   Kompilierens ein Fehler auf, kann mit `Edit' der Fehler beseitigt
   und mit `Retry' ein neuer Versuch unternommen werden.

   Nach erfolgreichem Kompilieren kann mit `Run' das Programm
   gestartet werden.


7. Wann muß ein Module neu kompiliert werden?

   Nachfolgend eine Liste der Ereignisse, die dazu führen, daß ein
   Modul kompiliert werden muß:

        · Es existiert keine Objektdatei.
        · Die Moduldatei wurde verändert.
        · Eine Headerdatei, von der das Modul abhängig ist, wurde verändert.
        · Der Zustand eines Defines hat sich verändert und der Define wird
          im Modul verwendet.



I. Credits

  Kein Programm, und sei es auch noch so schlecht, ohne Credits: Unser Dank
  geht zunächst an die Firmen Commodore Business Machines Inc. und Commodore
  Büromaschinen GmbH für die zahlreichen undokumentierten Späße, die sie sich
  seit der Einführung des Amiga erlaubt haben. Danke, Commodore!

  Weiterhin muß der Firma Manx Software Systems für die Mitlieferung eines
  nichtfunktionierenden Make's, für eine maximale Schachtelungstiefe von 3
  bei der Fragezeichenoperation und eine total veraltete Entwicklungsumgebung
  gedankt werden. Danke, Manx!

  Auf keinen Fall darf die Firma Frank Strauß Elektronik, Kaiserslautern,
  vergessen werden, die ihre Kundenkartei großzügig an diverse Zeitungsverlage
  weitergibt. Wie soll denn der Amiga-User auch sonst auf dem Laufenden
  betreffend PC-Markt bleiben. Danke, FSE!

  Und nochmal ein dickes Dankeschön an FSE für die sang- und klanglose
  Einstellung des Amiga-Supports. Danke, FSE!

  Aber genug des Zynischen, ein ganz großes Dankeschön an Maxon Computer,
  Eschborn, für einen vorbildlichen Entwicklersupport. Danke, Maxon.



II. 44,1 kHz

  · Badesalz: Och joh!
  · Badesalz: Nicht ohne meinen Pappa
  · Badesalz: DiWoDaSo

  · Eric Clapton: Unplugged         \   `Boah, was'n Brett, unn die Giddar,
  · Bruce Springsteen: (Un)Plugged   |   wie de Hendrix. Waahnsinn.'
  · Neil Young: Unplugged           /

  · Emerson, Lake & Palmer: Live at the Royal Albert Hall
  · Rush: Exit...stage left
  · Deep Purple: Made in Japan
  · Toto: Absolutely live



III. Epilog

  Aufkommende Fragen, Verbesserungsvorschläge und Lobeshymnen an

                              Björn E. Trost
                          Auf dem Bännjerrück 39
                           67663 Kaiserslautern

                                   bzw.

                              Dirk O. Remmelt
                             Lutrinastraße 11
                           67655 Kaiserslautern



  Kaiserslautern, im November 1993
