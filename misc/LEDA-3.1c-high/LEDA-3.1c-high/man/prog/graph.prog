{\bf Depth First Search}

\#include \<LEDA/graph.h\>\nl
\#include \<LEDA/stack.h\>
\medskip
\cleartabs
\+list\<node\> DFS($graph\& G,\  node\  v,\  node\_array\<bool\>\& reached$)\cr
\+$\{$\ \ &\cr 
\+  &list\<node\>  $L$;\cr
\+  &stack\<node\> $S$;\cr
\+  &node $w$;\cr
\smallskip
\+  &\If ( ! $reached[v]$ )\cr
\+  &\ \ \ &$\{$ &$reached[v]$ = true;\cr
\+  &      &     &$L$.append($v$);\cr
\+  &      &     &$S$.push($v$);\cr
\+  &      &\ $\}$\cr
\smallskip
\+  &{\bf while} ( !$S$.empty() )\cr
\+  &      &$\{$ &$v = S$.pop(); \cr
\+  &      &     &{\bf forall\_adj\_nodes}($w,v$) \cr
\+  &      &     &\ \ \ &{\bf if} ( !$reached[w]$ ) \cr
\+  &      &     &      &$\{$ &$reached[w]$ = true;\cr
\+  &      &     &      &     &$L$.append($w$);\cr
\+  &      &     &      &     &$S$.push($w$);\cr
\+  &      &     &      &\ $\}$\cr
\+  &      &\ $\}$\cr
\smallskip
\+  &return $L$;\cr
\+$\}$\cr

\vfill\eject

{\bf Breadth First Search}

\#include \<LEDA/graph.h\>\nl
\#include \<LEDA/queue.h\>
\medskip
\cleartabs
\+void BFS($graph\&\ G,\ node\ v,\ node\_array\<int\>\&\ dist$)\cr
\+$\{$\ \ &\cr
\+  &queue\<node\> $Q$;\cr
\+  &node $w$;\cr
\smallskip
\+  &{\bf forall\_nodes}($w,G$) $dist[w] = -1$;\cr
\smallskip
\+  &$dist[v] = 0$;\cr
\+  &$Q$.append($v$);\cr
\smallskip
\+  &{\bf while} ( !$Q$.empty() )\cr
\+  &\ \ &$\{$ &$v = Q$.pop();\cr
\+  &    &     &{\bf forall\_adj\_nodes}($w,v$)\cr
\+  &    &     &\ \ \ &{\bf if} ($dist[w] < 0$) \cr
\+  &    &     &      &$\{$ &$Q$.append($w$); \cr
\+  &    &     &      &     &$dist[w] = dist[v]+1$;\cr
\+  &    &     &      &\ $\}$\cr
\+  &    &\ $\}$\cr
\smallskip
\+$\}$\cr

{\bf Connected Components}

\#include \<LEDA/graph.h\>
\medskip
\cleartabs
\+int COMPONENTS($ugraph\&\ G,\ node\_array\<int\>\&\ compnum$)\cr
\+$\{$ \ & \cr
\+  &node $v,w$;\cr
\+  &list\<node\> $S$;\cr
\+  &int $count = 0$;\cr
\smallskip
\+  &node\_array(bool) $reached(G,false)$;\cr
\smallskip
\+  &\Forallnodes($v,G$) \cr
\+  &\ \ \ &\If ( !$reached[v]$ ) \cr
\+  &      &\ \ &$\{$ &$S$ = DFS($G,v,reached$);\cr
\+  &      &    &     &\Forall($w,S$) $compnum[w] = count$;\cr
\+  &      &    &     &$count++$; \cr
\+  &      &    &\ $\}$\cr
\smallskip
\+  &\Return $count$;\cr
\+\ $\}$\cr

\vfill\eject



{\bf Depth First Search Numbering}

\#include \<LEDA/graph.h\>
\medskip
\cleartabs
\+int $dfs\_count1,\ dfs\_count2$;\cr
\medskip
\+void d\_f\_s($node\ v,\ node\_array\<bool\>\&\ S$,
                                        &$node\_array\<int\>\&\ dfsnum$, \cr
\+                                      &$node\_array\<int\>\&\ compnum$,\cr
\+                                      &$list\<edge\>\ T$ )\cr
\cleartabs
\+$\{$ \ &// recursive DFS\cr
\smallskip
\+  &node $w$;\cr
\+  &edge $e$;\cr
\smallskip
\+  &$S[v] = true$;\cr
\+  &$dfsnum[v] = ++dfs\_count1$;\cr
\smallskip
\+  &\Foralladjedges($e,v$) \cr
\+  &\ \ \ &$\{$ &$w = G$.target(e);\cr
\+  &      &    &\If ( !$S[w]$ ) \cr
\+  &      &    &\ \ &$\{$ &$T$.append($e$);\cr
\+  &      &    &    &    &d\_f\_s($w,S,dfsnum,compnum,T$);\cr
\+  &      &    &    &\ $\}$\cr
\+  &      &\ $\}$\cr
\smallskip
\+  &$compnum[v] = ++dfs\_count2$;\cr
\+\ $\}$ \cr
\bigskip
\bigskip
\cleartabs
\+list\<edge\> DFS\_NUM($graph\&\ G,\ node\_array\<int\>\&\ dfsnum,\ node\_array\<int\>\&\ compnum$ )\cr
\+$\{$ \ & \cr
\+  &list\<edge\> $T$;\cr
\+  &node\_array\<bool\> $reached(G,false)$;\cr
\+  &node $v$;\cr
\+  &$dfs\_count1 = dfs\_count2 = 0$;\cr
\+  &\Forallnodes($v,G$) \cr
\+  & \ \ \ \If ( !$reached[v]$ ) d\_f\_s($v,reached,dfsnum,compnum,T$);\cr
\+  &\Return $T$;\cr
\+\ $\}$\cr

\vfill\eject



{\bf Topological Sorting}

\#include \<LEDA/graph.h\>
\medskip
\cleartabs
\+bool TOPSORT($graph\&\ G,\ node\_array\<int\>\& ord$)\cr
\+$\{$\ \ &\cr 
\+  &node\_array\<int\> INDEG($G$);\cr
\+  &list\<node\> ZEROINDEG;\cr
\smallskip
\+  &int $count=0$;\cr
\+  &node $v,w$;\cr
\+  &edge $e$;\cr
\smallskip
\+  &{\bf forall\_nodes}($v,G$)\cr
\+  &\ \ \ {\bf if} ((INDEG[$v$]=$G$.indeg($v$))==0) ZEROINDEG.append($v$); \cr
\smallskip
\+  &{\bf while} (!ZEROINDEG.empty())\cr
\+  &\ \ &$\{$ &$v$ = ZEROINDEG.pop();\cr
\+  &    &    &$ord[v] = ++count$;\cr
\smallskip
\+  &    &    &{\bf forall\_adj\_nodes}($w,v$) \cr
\+  &    &    &\ \ \ {\bf if} ($--$INDEG[$w$]==0) ZEROINDEG.append($w$);\cr
\+  &    &\ $\}$\cr
\smallskip
\+  &{\bf return} (count==G.number\_of\_nodes()); \cr
\smallskip
\+\ $\}$\cr

\bigskip
//TOPSORT1 sorts node and edge lists according to the topological ordering:
\bigskip
\cleartabs
\+$bool$ TOPSORT1($graph\&\ G$)\cr
\+$\{$\ \ &node\_array\<int\> node\_ord($G$);\cr
\+        &edge\_array\<int\> edge\_ord($G$);\cr
\smallskip
\+        &{\bf if} (TOPSORT(G,node\_ord))\cr
\+        &$\{$\ &edge $e$;\cr
\+        &      &{\bf forall\_edges}($e,G$) edge\_ord[$e$]=node\_ord[$target(e)$];\cr
\+        &      &$G$.sort\_nodes(node\_ord);\cr
\+        &      &$G$.sort\_edges(edge\_ord);\cr
\+        &      &{\bf return} true;\cr
\+        &$\ \}$\cr
\+        &{\bf return} false;\cr
\+$\ \}$\cr

\vfill\eject






{\bf Strongly Connected Components}

\#include \<LEDA/graph.h\>\nl
\#include \<LEDA/array.h\>
\medskip
\cleartabs
\+int STRONG\_COMPONENTS($graph\&\ G,\ node\_array\<int\>\&\ compnum$)\cr
\+$\{$ \ &\cr
\+  &node $v,w$;\cr
\+  &int $n = G$.number\_of\_nodes();\cr
\+  &int $count = 0$;\cr
\+  &int $i$;\cr
\smallskip
\+  &array\<node\> $V(1,n)$;\cr
\+  &list\<node\> $S$;\cr
\+  &node\_array\<int\>  $dfs\_num(G), compl\_num(G)$;\cr
\+  &node\_array\<bool\> $reached(G,false)$;\cr
\smallskip
\+  &DFS\_NUM($G,dfs\_num,compl\_num$);\cr
\smallskip
\+  &\Forallnodes($v,G$) $V[compl\_num[v]] = v$;\cr
\smallskip
\+  &$G$.rev();\cr
\smallskip
\+  &\For($i=n;\ i>0;\ i--$)\cr
\+  &\ \ \ &\If ( !$reached[V[i]]$ ) \cr
\+  &      &\ \ &$\{$ &$S$ = DFS($G,V[i],reached$);\cr
\+  &      &    &     &\Forall($w,S$) $compnum[w] = count$;\cr
\+  &      &    &     &$count++$;\cr
\+  &      &    &\ $\}$\cr
\smallskip
\+  &\Return $count$;\cr
\smallskip
\+\ $\}$\cr

\vfill\eject





{\bf Dijkstra's Algorithm}


\#include \<LEDA/graph.h\>\nl 
\#include \<LEDA/node\_pq.h\>
\medskip
\cleartabs
\+void DIJKSTRA(& graph\& $G$, node $s$, edge\_array\<int\>\& $cost$, \cr
\+              & node\_array\<int\>\& $dist$, node\_array\<edge\>\& $pred$ )\cr
\+\cleartabs 
  $\{$ & node\_pq\<int\> $PQ(G)$;\cr
\smallskip
\+     &int $c$;\cr
\+     &node $u,v$;\cr
\+     &edge $e$;\cr
\smallskip
\+     &{\bf forall\_nodes}($v,G$)\cr
\+     &\ \ \ &$\{$ & $ pred[v] = 0$;\cr
\+     &      &     & $dist[v] = infinity$;\cr
\+     &      &     & $PQ$.insert($v,dist[v])$;\cr
\+     &      &\ $\}$\cr
\smallskip
\+     &$dist[s] = 0$;\cr
\+     &$PQ$.decrease\_inf($s,0)$;\cr
\smallskip
\+     &{\bf while} ( ! $PQ$.empty())\cr
\+     &\ \ \ &$\{$ &$u = PQ$.del\_min()\cr
\smallskip
\+     &      &     &{\bf forall\_adj\_edges}($e,u$)\cr
\+     &      &     &\ \ \ &$\{$ &$v = G.target(e) $;       \cr
\+     &      &     &      &     &$c = dist[u] + cost[e] $;\cr
\+     &      &     &      &     &{\bf if} ( $c < dist[v] $)\cr
\+     &      &     &      &     &\ \ &$\{$ &$dist[v] = c$;\cr
\+     &      &     &      &     &    &     &$pred[v] = e$;\cr
\+     &      &     &      &     &    &     &$PQ$.decrease\_inf($v,c$);\cr
\+     &      &     &      &     &    &\ $\}$\cr
\+     &      &     &      &\ $\}$ /$*$ forall\_adj\_edges $*$/\cr
\smallskip
\+     &      &\ $\}$ /$*$ while $*$/\cr
\smallskip
\+$\}$\cr

\vfill\eject

{\bf Bellman/Ford Algorithm}

\#include \<LEDA/graph.h\>\nl
\#include \<LEDA/queue.h\>
\medskip
\cleartabs
\+bool BELLMAN\_FORD(&$graph\&\ G,\ node\ s,\ edge\_array\<int\>\&\ cost$,\cr
\+                   &$node\_array\<int\>\&\ dist,\ node\_array\<edge\>\&\ pred$)\cr
\+\cleartabs
  $\{$ \ 
    &node\_array\<bool\> $in\_Q(G,false)$;\cr
\+  &node\_array\<int\>  $count(G,0)$;\cr
\smallskip
\+  &int $n = G$.number\_of\_nodes();\cr
\+  &queue\<node\> $Q(n)$;\cr
\smallskip
\+  &node $u,v$;\cr
\+  &edge $e$;\cr
\+  &int  $c$;\cr
\smallskip
\+  &\Forallnodes($v,G$) \ &$\{$ &$pred[v] = 0$;\cr
\+  &                      &     &$dist[v] =  infinity$; \cr
\+  &                      &\ $\}$\cr
\+  &\cleartabs
     $dist[s] = 0$;\cr
\+  &$Q$.append($s$);\cr
\+  &$in\_Q[s] = true$;\cr
\smallskip
\+  &while (!$Q$.empty())\cr
\+  &\ \ \ &$\{$ &$u = Q$.pop();\cr
\+  &      &     &$in\_Q[u] = false$;\cr
\smallskip
\+  &      &     &\If ($++count[u] > n$)  {\bf return} false;\quad //negative cycle\cr
\smallskip
\+  &      &     &\Foralladjedges($e,u$) \cr
\+  &      &     &\ \ \ &$\{$ &$v$ = $G$.target($e$);\cr
\+  &      &     &      &$c = dist[u] + cost[e]$;\cr
\smallskip
\+  &      &     &      &\If ($c < dist[v]$) \cr
\+  &      &     &      &\ \ &$\{$ &$dist[v] = c$; \cr
\+  &      &     &      &    &     &$pred[v] = e$;\cr
\+  &      &     &      &    &     &\If (!$in\_Q[v]$)  \cr
\+  &      &     &      &    &     &\ \ &$\{$ &$Q$.append($v$);\cr
\+  &      &     &      &    &     &    &     &$in\_Q[v]=true$;\cr
\+  &      &     &      &    &     &    &\ $\}$\cr
\+  &      &     &      &    &\ $\}$\cr
\+  &      &     &      &\ $\}$ /$*$ forall\_adj\_edges $*$/\cr
\+  &      &\ $\}$ /$*$ while $*$/\cr
\+  &{\bf return} true;\cr
\+\ $\}$\cr
\vfill\eject

{\bf All Pairs Shortest Paths}

\#include \<LEDA/graph.h\>
\medskip
\cleartabs
\+void all\_pairs\_shortest\_paths(graph\& $G$, &edge\_array\<double\>\& $cost$,\cr
\+                                              &node\_matrix\<double\>\& $DIST$)\cr
\cleartabs 
\+$\{$\ &\cr
\+      &// computes for every node pair $(v,w)$ $DIST(v,w)$ = cost of the least cost\cr
\+      &// path from $v$ to $w$, the single source shortest paths algorithms BELLMAN\_FORD\cr
\+      &// and DIJKSTRA are used as subroutines\cr
\smallskip
\+      &edge $e$;\cr
\+      &node $v$;\cr
\+      &double $C = 0$;\cr
\smallskip
\+      &{\bf forall\_edges}($e,G$) $C += fabs(cost[e]$);\cr
\+      &node $s = G$.new\_node(); \hskip 3truecm         & // add $s$ to $G$\cr
\+      &{\bf forall\_nodes}($v,G$) $G$.new\_edge($s,v$); & // add edges ($s,v$) to $G$\cr
\smallskip
\+      &node\_array\<double\> $dist1(G)$;\cr
\+      &node\_array\<edge\>   $pred(G)$;\cr
\+      &edge\_array\<double\> $cost1(G)$;\cr
\+      &{\bf forall\_edges}($e,G$) 
                 $cost1[e] = (G$.source$(e)==s)$ ? $C : cost[e]$;\cr
\smallskip
\+      &BELLMAN\_FORD($G,s,cost1,dist1,pred$);\cr
\smallskip
\+      &$G$.del\_node($s$);                              & // delete $s$ from $G$\cr
\+      &edge\_array(double) $cost2(G)$;\cr
\+      &{\bf forall\_edges}($e,G$) $cost2[e] = dist1[G.source(e)] + cost[e] - dist1[G.target(e)]$;\cr
\smallskip
\+      &{\bf forall\_nodes}($v,G$)  DIJKSTRA($G,v,cost2,DIST[v],pred$);\cr
\smallskip
\+      &{\bf forall\_nodes}($v,G$)\cr
\+      &\quad {\bf forall\_nodes}($w,G$) $DIST(v,w) = DIST(v,w) - dist1[v] + dist1[w]$;\cr
\+ $\}$\cr

\vfill\eject


{\bf Minimum Spanning Tree}


\#include \<LEDA/graph.h\>\nl
\#include \<LEDA/node\_partition.h\>
\medskip
\cleartabs
\+void MIN\_SPANNING\_TREE(graph\& $G$, edge\_array\<double\>\& $cost$, list\<edge\>\& $EL$)\cr
\+$\{$\ \ &\cr 
\+       &node $v,w$;\cr
\+       &edge $e$;\cr
\+       &node\_partition $Q(G)$;\cr
\smallskip
\+       &$G$.sort\_edges($cost$);\cr
\smallskip
\+       &$EL$.clear();\cr
\+       &{\bf forall}\_edges($e,G$)\cr
\+       &\ \ \ &$\{$ &$v = G.source(e)$;\cr
\+       &      &     &$w = G.target(e)$;\cr
\+       &      &     &{\bf if} ($!(Q$.same\_block($v,w$))\cr
\+       &      &     &\ \ &$\{$ & $Q$.union\_blocks($v,w$);\cr
\+       &      &     &    &     & $EL$.append($e$);\cr
\+       &      &     &    &\ $\}$\cr
\+       &      &\ $\}$\cr
\+\ $\}$\cr

\vfill\eject
