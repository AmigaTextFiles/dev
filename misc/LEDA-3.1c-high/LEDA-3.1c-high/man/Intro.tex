{\magtwo Introduction}

One of the major differences between combinatorial computing
and other areas of computing such as statistics, numerical
analysis and linear programming is the use of complex data types. 
Whilst the built-in types, such as integers, reals, vectors, and matrices,
usually suffice in the other areas, combinatorial computing relies heavily 
on types like stacks, queues, dictionaries, sequences, sorted sequences, 
priority queues, graphs, points, segments, $\ldots$
In the fall of 1988, we started a project (called {\bf LEDA} for Library of
Efficient Data types and Algorithms) to build a small, but growing library 
of data types and algorithms in a form which allows them to be used by 
non-experts. We hope that the system will narrow the gap between algorithms
research, teaching, and implementation. The main features of LEDA are:

\beginitem
\item {1.}
    LEDA provides a sizable collection of data types and algorithms in a form 
    which allows them to be used by non-experts. In the current version, this
    collection includes most of the data types and algorithms described in the 
    text books of the area. 

\item {2.}
    LEDA gives a precise and readable specification for each of the data types 
    and algorithms mentioned above.  The specifications are short (typically, 
    not more than a page), general (so as to allow several implementations), 
    and abstract (so as to hide all details of the implementation). 

\item {3.}
    For many efficient data structures access by position is important. In 
    LEDA, we use an item concept to cast positions into an abstract form. We 
    mention that most of the specifications given in the LEDA manual use this 
    concept, i.e., the concept is adequate for the description of many data 
    types. 

\item {4.}
    LEDA contains efficient implementations for each of the data types, e.g., 
    Fibonacci heaps for priority queues, skip lists and dynamic perfect 
    hashing for dictionaries, ...


\item {5.}
    LEDA contains a comfortable data type graph. It offers the standard 
    iterations such as ``for all nodes v of a graph G do'' or ``for all 
    neighbors w of v do'', it allows to add and delete vertices and edges 
    and it offers arrays and matrices indexed by nodes and edges,...  
    The data type graph allows to write programs for graph problems in a 
    form close to the typical text book presentation.


\item {6.}
    LEDA is implemented by a \CC class library. It can be used with allmost
    any \CC compiler (e.g., cfront2, cfront3, g++-1, g++-2, bcc, ztc).


\vfill\eject
\item {7.}
    {LEDA is available by anonymous ftp from \nl
     {\bf ftp.cs.uni-sb.de}        (134.96.7.254) /pub/LEDA\nl
%    {\bf ftp.maths.warwick.ac.uk} (137.205.232.4) /pub/sources/c++\nl
    The Distribution contains all sources, installation instructions, a 
    technical report, and the LEDA user manual.}


\item {8.}
    LEDA is not in the public domain, but can be used freely for research 
    and teaching. A commercial license is available from the autor.

\enditem

This manual contains the specifications of all data types and algorithms 
currently available in LEDA. Users should be familiar with the \CC 
programming language (see [S91] or [L89]). The main concepts and some 
implementation details of LEDA are described in [MN89] and [N92]. The manual 
is structured as follows: In chapter one, which is a prerequisite for all
other chapters, we discuss the basic concepts and notations used in LEDA.
The other chapters define the data types and algorithms available in
LEDA and give examples of their use. These chapters can be consulted
independently from one another.

\bigskip
\bigskip
{\magonebf Version 3.0}

The most important changes with respect to previous versions are
\beginitem
\item {a)}
Parameterized data types are realized by \CC templates. In particular, 
{\it declare} macros used in previous versions are now obsolete and the 
syntax for a parameterized data type $D$ with type parameters $T_1,\dots,T_k$ 
is $D\<T_1,\dots,T_k\>$ (cf.~section~1.2). For \CC compilers not 
supporting templates there is still a non-template variant (LEDA-N-3.0) 
available.

\item {b)}
Arbitrary data types (not only pointer and simple types) can be used as
actual type parameters (cf.~section~1.2). 

\item {c)}
For many of the parameterized data types (in the current version: dictionary, 
priority queue, d\_array, and sortseq) there exist variants taking an additional
data structure parameter for choosing a particular implementation 
(cf.~section~1.3).

\item {d)}
The LEDA memory management system can be customized for user-defined classes
(cf.~section~7.3)

\item{e)}
The efficiency of many data types and algorithms has been improved.
\enditem

See also the ``Changes" file in the LEDA root directory.


\vfill\eject

