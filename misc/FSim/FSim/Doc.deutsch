
                                  FSim

                   Die Prozeßsimulation für den Amiga

                            J. Hartkopf 1992


0	Einleitung

   Dies ist die Dokumentation von FSim V1.0, der Prozeßsimulation für den
   Amiga. Beim Programmieren von FSim benutzte ich einige Object Files
   die von Electronic Arts auf Fish 185 veröffentlicht worden sind
   und die ich diesem Paket beigefügt habe.

   Beachte: Der Autor von FSim übernimmt mit der Veröffentlichung dieses Paketes
   keinerlei Gewährleistungen und leistet in keiner Beziehung einen
   Schadensersatz. Er lehnt jede Verantwortung für Schäden oder Datenverlust
   ab, die bei Anwendung verursacht werden könnten.

   Das Programm FSim darf als Gesamtpaket frei kopiert werden.
   Eine kommerzielle Vermarktung ist nicht gestattet und bedarf der 
   audrücklichen Genehmigung des Autors.


   Bitte sendet aufgetretene Fehler, Kritik oder gute Ideen an

 	J. Hartkopf
	Vorwerk 21
	W-2058 Schnakenbek


   Gut, hier ist ein Überblick über den Inhalt dieser Dokumentation:


   1       Was ist FSim ?

   2       Funktionsweise

   3       Benötigte Programme

   4       Installieren von FSim


   5       Erzeugen einer Simulation - Benutzung des FSimParser

   5.1     FSimParser starten

   5.2     Das Main Window
   5.2.1   FSimParser konfigurieren
   5.2.2   Ein Modell laden
   5.2.3   Analysieren und compilieren eines Modells
   5.2.4   FSimParser verlassen

   5.3     Das Run/Save window


   6       Das Userinterface der Simulation

   6.1     Starten einer Simulation

   6.2     Das Main Window
   6.2.1   Simulationslauf starten
   6.2.2   Simulationslauf unterbrechen
   6.2.3   Anfangswerte der Differentialgleichungen ändern
   6.2.4   Modellparameter ändern
   6.2.5   Ändern des graphischen Darstellungsbereiches
   6.2.6   Skalieren der X-Achse
   6.2.7   Verlassen der Simulation

   6.3     Das ´Data Handling´ window
   6.3.1   Simulationsparameter speichern
   6.3.2   Simualtiosergebnisse speichern
   6.3.3   Simulationsdaten in File ausgeben



   7.      Modellieren einer Simulation

   7.1     Modellprogrammierung und Abweichungen vom C Standard

   7.2     Systemvariable

   7.3     Die vier Funktionen eines Modells

   7.3.1   Die ´SimSys´ Funktion
   7.3.1.1 Differentialgleichungen
   7.3.1.2 Statische Funktionen
   7.3.1.3 Output Definitionen

   7.3.2   Die ´IniX´ Funktion
   7.3.3   Die ´IniPar´ Funktion
   7.3.4   Die ´IniDEQ´ Funktion


   8       Bugs

   9       Die Zukunft von FSim




1       Was ist FSim ?

   Während meines Studiums der Verfahrenstechnik war es Thema der Diplomarbeit
   einen Bioreaktor mittels eines industriellen Prozeßleitsystems zu 
   automatisieren. Die Entwicklung und das Erproben neuer Regelungsstrategien
   in der Biotechnologie ist begrenzt durch einen hohen experimentellen Aufwand.
   Eine sehr effektive Methode stellt die Online Emulation der 
   biotechnologischen Anlage mittels eines Simulationssystems dar. 
   Bei der Entwicklung von Regelungsstrategien ist der Simulator, ein VMEbus-
   System, anstelle der biotechnologischen Anlage mit dem Leitsystem verbunden.
   Als ich die Effektivität dieser Methode zu schätzen lernte, war alsbald
   die Idee geboren, eine (Offline) Simulation für den Amiga zu erstellen.
   Sie sollte in der Lage sein ( seinem Vorbild gleich ) komplexe Systeme
   aus Differentialgleichungen und Statischen Gleichungen zu berechnen und
   dessen Resultate in einer graphischen Form darzustellen.
   Die Grundidee: Ein Anwender mit nur geringen Kenntnissen der C Programmierung
   soll in die Lage versetzt werden, ein komplexes Modell zu erstellen und dies
   an eine komfortablen Benutzeroberfläche anzubinden. Diese Oberfläche erlaubt 
   es, einen interaktiven Einfluß auf die Simulation auszuüben und die dabei
   erzielten Ergebnisse zu speichern.
   FSim ist nicht unbedingt ein professionelles Simulationsystem, und es gibt
   noch einige Probleme. Jedoch besitzt es die Merkmale und Eigenschaften 
   kommerzieller Produkte, und ist somit für denjenigen interessant, der
   beginnt sich mit dem Thema Systemsimulation zu befassen.


2       Funktionsweise

   Soll eine Simulation erstellen werden die einen speziellen Prozeß in Natur
   oder Technik beschreibt, benötigen wir zunächst eine mathematische
   Modellbeschreibung. Diese muß im C Syntax als ASCII File vorliegen und der
   Anwender muß in der Lage sein, alle Funktionen in C zu formuliern.
   Wie dies zu bewerkstellen ist, wird an Hand der Beispiele im Verzeichnis
   <Model_Runable> deutlich gemacht ( siehe auch: Kapitel 7. ).
   Das Modell, niedergelegt im C Syntax, wird vom Programm namens ´FSimParser´
   bearbeitet. Das erste Resultat dieses Prozesses ist ein Code namens 
   ´FSim.c´. In einem zweiten Schritt ruft der FSimParser Compiler und Linker
   auf, die ein Object File ´FSim.o´ erzeugen und diesen mit einigen anderen
   Object Files zum ablauffähigen Programm ´FSim´ binden. Um dies zu 
   bewerkstelligen, wird ein Batch File ´s:MakeSim.bat´ abgearbeitet, welches
   Compiler und Linker aufruft.

   
              FSimParser         C compiler          linker   
        model ----------> FSim.c ----------> FSim.o --------> FSim
                                                        |    
                                                        |      
                                           Main.o ------| 
                                           SaveILBM.o---| 
                                           Packer.o-----|
                                           ilbmw.o -----|
                                           iffw.o-------|


   Der vom Parser erstellte Code ´FSim.c´ enthält ein System verschiedener 
   Funktionen um Differentialgleichungen nach der Methode von Runge und Kutta
   in definierten Schritten zu lösen. Der eingebundene Objectcode ´Main.o´ 
   enthält alle Routinen der Graphikausgabe und der Benutzeroberfläche. 
   Die übrigen Object Files sind von Electronic Arts auf der Fish Disk
   185 veröffentlicht worden, mit deren Hilfe es möglich ist die 
   Simulationsergebnisse als IFF ILBM zu speichern.

   In den folgenden Kapiteln wird die Installation, die Handhabung des 
   FSimParsers und dessen Ergebnis, also des compilierten Simulationsmodells, 
   beschrieben.



3       Benötigte Programme

   Wenn mit FSim gearbeitet werden soll, werden einige Dateien und Programme
   benötigt,die aus Copyrightgründen nicht beigefügt werden können.
   Da FSim aus dem Nutzerspezifischen Modellcode einen neuen Quellcode in 
   C erzeugt, werden ein Compiler und Linker benötigt.
   In dieser Version unterstützt FSim lediglich den Lattice/SAS compiler V5.x.
   Dieser muß auf dem logischen Laufwerk LC: zur Verfügung stehen, anderenfalls
   wird FSim nicht einwandfrei funktionieren.
   
   Auf dem logischen Laufwerk C: wird benötigt:

   - RUN       < WB Disk >
   - SORT      < WB Disk >
   - COPY      < WB Disk >
   - MuchMore  < sollte auf dieser Disk enthalten sein >

   Im Verzeichnis LIBS: benötigen wir das

   - Icon.library
   - Arp.library



4       Installieren von FSim

   Es stehen zwei Wege offen um FSim zu installieren:

   INSTALLATION ÜBER CLI.

     Wenn die alt bewährten Methoden zum Zuge kommen sollen, dann

      - CLI öffnen

      - Verzeichnis wechseln mit ´cd FSim´

      - Durch abschicken des Kommandos ´execute install.bat dh0:´ 
        wird FSim dann auf dem Laufwerk DH0: installiert.


   INSTALLATION MITTELS INSTALLATIONSPROGRAMM

     Der alternative Weg FSim zu installieren:

      - Ein Doppelclick auf das ´Install_It´ Icon startet das FSim
        Installationsprogramms. Ein Mouseclick in dessen String Gadget 
        läßt den Cursor erscheinen. Nach Eingabe des Laufwerkes auf 
        dem FSim installiert werden soll und Betätigen des ´DoIt´ Gadgets 
        wird der Vorgang gestartet.
        
    

   LETZTER SCHRITT

      - Gleichgültig auf welche Weise FSim installiert worden ist, 
        als letzter Schritt muss in die Startup-Sequence die Zeile

                     assign FSim: <drive>FSimX

        eingefügt und das System neu gestartet werden.



5       Erzeugen einer Simulation - Benutzung des FSimParser

   Nachdem das Modell als ASCII File definiert worden ist, wird dies 
   analysiert und um einige Formeln ergänzt werden, die es der Simulation 
   erlauben Differentialgleichungen zu lösen. Daraufhin ist der Code 
   zu compilieren und das resultierende Object File an die Benutzeroberfläche
   anzubinden. All dies wird vom FSimParser bewerkstelligt.


5.1     FSimParser starten

   In dieser Version kann der FSimParser lediglich vom CLI aus durch 
   wechseln des Verzeichnisses mit ´cd FSim:´ und Eingabe von 
   ´FSimParser´ gestartet werden. Wenn jemand so verwegen ist den Parser 
   von der Workbench aus zu starten, wird er unmittelbar vom Guru
   heimgesucht werden. Vielleicht ändere ich dies in einer nächsten Version.

5.2     Das Main window

   Sobald der Parser gestartet worden ist, öffnet sich ein Main Window mit
   vier Gadgets, dem

   - Configure Gadget
   - Load Gadget
   - Parse Gadget
   - Exit Gadget

   Wir werden nun sehen was damit anzufangen ist...


5.2.1   FSimParser Konfigurieren

   Nach Anklicken des ´Configure´ Gadget öffnet sich das Konfigurierungsfenster.
   Da einige Funktionen von FSim einen Editor aufrufen, ist der Benutzer 
   angehalten Pfad und Name seines bevorzugten Editors 
   anzugeben (Memacs,DME...).
   Wie in Abschnitt 2 angedeutet, benötigt der FSimParser ein Batchfile um
   Compiler und Linker zu starten. Pfad und Name werden auch hier definiert.
   Um Pfad oder Name von Editor oder Batch File zu ändern, wird nach einem
   Mouseclick der neue Pfad oder Name eingegeben. Nach Betätigen des ´Exit´
   Gadgets wird die aktuelle Konfigurierung zwar benutzt, doch sobald der
   FSimParser verlassen wird, sind alle Änderungen verloren. Um dies zu 
   vermeiden, können alle Änderungen durch Betätigen des ´Save´ Gadgets
   gespeichert werden.


5.2.2   Ein Modell laden

   Nach Betätigen des ´Load´ Gadgets öffnet sich der Arp- File- Requester
   und wartet auf Eingabe von Pfad und Namen des zu ladenden Modells.
   Nach Auswahl des zu ladenden Modells und Betätigen des ´OK´ Gadgets wird
   dieses als temporäres Files ´RAM:Mod.tmp´ geladen und der Parser ist 
   bereit seine Arbeit aufzunehmen.


5.2.3   Analysieren und compilieren eines Modells

   Mit einem Mouseclick auf das ´Parse´ Gadget wird der Parser dazu 
   veranlaßt das Modell zu untersuchen und den Code ´Ram:FSim.c´ zu erzeugen.
   Nachdem dieser Code compiliert ist, öffnet der Parser ein CLI Fenster um
   das Batch File abzuarbeiten.

   Wenn alles glatt gelaufen ist, erscheint an Stelle des CLI das RUN/SAVE
   Fenster. Mehr darüber: Kapitel 5.3

   Wenn irgendetwas schiefläuft mit Compiler oder Linker, ist der Anwender
   dazu angehalten das Fenster mit ´EndCli´ zu schliessen. Sobald dies 
   geschehen ist, öffnet sich ein Fenster mit drei Gadgets.

   - Das ´Aha´ Gadget
     Mit einem Mouseclick auf das ´Aha´ Gadget nimmt der Anwender das
     Scheitern von Compiler oder Linker zur Kenntnis und gelangt zurück 
     zum Main-Fenster.

   - Das ´Edit´ Gadget
     Durch Anklicken des ´Edit´ Gadgets wird der im ´Configure´ Fenster
     definierte Editor gestartet der (mit ein wenig Glück) das zu
     bearbeitende Modell aufruft. Wird der Editor verlassen, startet ein
     Re-load Prozess, d.h.: das ( hoffentlich korrigierte ) Modell wird
     selbsttätig in das Ram: kopiert, wo es dem Parser wieder zur Verfügung
     steht.

   - Das ´Show´ Gadget
     Das Programm ´Muchmore´ zeigt die beim Abarbeiten des Batch File 
     aufgetretene Fehler an, nachdem der Benutzer das ´Show´ Gadget betätigt hat.
     Mit ´q´ wird Muchmore beendet und FSim kehrt zum Error Fenster zurück.


5.2.4   FSimParser verlassen

   Nach Betätigen des ´Exit´ Gadgets im Main Window wird das Programm
   erwartungsgemäß beendet. 


5.3     Das Run/Save window

   Haben Parser, Compiler und Linker ihre Arbeit erfolgreich beendet, so stehen
   ein C Code und ein ablauffähiges Modell zur Verfügung. Im dem sich dann 
   öffnenden Run/Save Window können die enstandenen Files auf ein Medium 
   gespeichert oder der Simulation direkt gestartet werden.
   
   - Die ´Save´ Gadgets
     Mit diesen beiden Gadgets kann entweder der vom Parser gebildete C 
     Quellcode oder das comilierte und gebundene Modell gesichert werden.

   - Das ´Run´ Gadget
     schließt die Nutzeroberfläche des Parsers und und startet die Simulation.
     Achtung: In diesem Fall ist wird die Simulation als unabhängiger Prozeß
     gestartet und der Parser befindet weiterhin im System. So kann es 
     vorkommen, das die Simulation ein wenig langsam abläuft oder auf Grund von 
     Speicherplatzmangel gar nichts passiert. In diesem Fall sollte der Parser
     verlassen und die Simulation von der Workbench aus gestartet
     werden ( siehe auch 6.1). 
     

6       Das Userinterface der Simulation

   In den nächsten Abschnitten soll die Handhabung der compilierten Simulation
   beschrieben werden. Unter anderem soll auf die Einflußmöglichkeiten der
   Graphik, auf die Manipulation des Prozeßes selbst, sowie auf die Sicherung 
   der aus der Simulation resultierenden Daten behandelt werden.

6.1     Starten einer Simulation

   Im Gegensatz zum FSimParser, der lediglich von CLI gestartet werden kann, ist
   es bei den ablauffähigen Simulationen möglich, sie entweder vom CLI oder der
   Workbench zu starten. Zur Erinnerung: Eine dritte Möglichkeit um die Simulation 
   zu starten, bietet der FSimParser. In diesem Falle bleibt der Parser jedoch
   im System, belegt Speicherplatz und beansprucht Rechenzeit.


6.2     Das main window

   Nach dem Starten der Simulation erscheint das Main-Menü. Hierin ist es 
   möglich, eine der acht Menüpunkte mittels eines roten Rahmens zu wählen und
   mit einem Mouseclick zu aktivieren.


6.2.1   Simulationslauf starten

   Durch Anwählen des Menüpunktes ´Simulation´ wird der Simulationsprozeß
   gestartet. Ist die Option ´Data Push´ angewählt ( siehe 6.3.3 ), so gilt
   diese lediglich für einen Simulationslauf, und wird nach Ende der Simulation
   wieder inaktiviert.

6.2.2   Simulationslauf unterbrechen

   Während der laufenden Simulation ist es jederzeit möglich diese durch
   Betätigen der linken Mousetaste zu unterbrechen. Es erscheint das 
   sog. ´Break´ Menü, in dem vier Punkte zur Auswahl stehen.

   - ´Stop simulation´
     bricht den Simulationslauf ab, und das Main-Menü erscheint wieder.

   - ´Continue Simulation´
     nimmt die Simulation wieder dort auf, wo sie abgebrochen wurde.

   - ´Show Results´
     bringt den Output Screen in den Vordergrund ohne die Simulation wieder
     aufzunehmen. Durch drücken der linken Mousetaste erscheint wieder
     das ´Break´ Menü.

   - ´Parameter´
     öffnet das sogenannte Parameter Fenster. Hier hat der Anwender die 
     Möglichkeit Parameter der Simulation abzuändern, in dessen Folge die 
     Simulation eine andere Charakteristik besitzt ( siehe auch 6.2.4).
   

6.2.3   Anfangswerte der Differentialgleichungen ändern

   Eine Simulation die Differentialgleichungen zum Inhalt hat, errechnet
   ihre Werte schrittweise, wobei Ergebnissen des Schrittes zuvor einfliessen.
   Zu Simulationsbeginn existiert jedoch kein Ergenis aus einem vorhergehenden
   Schritt, so daß also für jede DGL die Anfangswerte definiert sein müssen.
   Im ´Initial Value´ Fenster ist es möglich die Modell definierten Werte
   abzuändern. Wie im Main-Menü wird die zu Ändernde Variable durch einen 
   roten Rahmen gekennzeichnet und mit der linken Mousetaste ausgewählt. 
   Im Input Feld links oben wird der Variablen ein neuer Wert zugeordnet. 
   Wenn im Fenster nicht genügend Platz ist um alle Werte anzuzeigen, 
   so werden diese auf mehrere Seiten dargestellt und können mit dem ´More´ 
   Gadget (nächste Seite) bzw. dem ´Less´ Gadget (vorige Seite) eingesehen 
   werden.


6.2.4   Modellparameter ändern

   Wenn der Anwender den Einfluß gewisser Parameter auf das Modell studieren
   will, so ist es notwendig die Parameter zu variieren. Die Möglichkeit 
   besteht durch Anwählen des Menüpunktes ´Parameter´ im Main-Menü. 
   Eine Möglichkeit den Einfluß der Parameter zu beobachten besteht in der 
   Unterbrechung der Simulation, dem Ändern der Parameter und der 
   Simulationsfortsetzung. Die Bedienung des ´Parameter´ Windows erfolgt
   analog zur Bedienung des ´Initial Values´ Fenster.
   Achtung: Wir die Simulation beendet und mit ´Exit FSim´ verlassen, so sind
   alle vorgenommenen Änderungen verloren (Abhilfe: siehe 6.3.1).
   

6.2.5   Ändern des graphischen Darstellungsbereiches

   Die Minimal/Maximalgrenzen der Simulationsgraphik sind vom Anwender im Modell
   vordefiniert. Diese Begrenzung des Graphen kann jedoch überschritten werden
   sobald eine Änderung der Parameter vorgenommen wird. Tritt dieser Fall ein,
   so ist es angezeigt die Darstellungsgrenzen unter dem Menüpunkt ´Graph´
   zu ändern.


6.2.6   Skalieren der X-Achse

   Wird der Menüpunkt ´Interval X-Axis´ aktiviert, öffnet sich ein Fenster
   mit drei Gadgets. Mit diesen drei Gadgets haben wir einen Einfluß auf
   die Skalierung der X-Achse, der Simulationsschrittweite und der 
   Simulationsgeschwindigkeit.

   - ´X-Axis Max´

     Der Intervall der darzustellenden Graphik beginnt mit dem Wert 0 und
     endet bei einem Wert ´EndTime´. Während der Simulation wird eine
     Systemvariable namens ´time´ schrittweise erhöht, bis diese den Wert
     ´EndTime´ überschreitet und die Simulation in Folge davon abgebrochen 
     wird. Das Anklicken des ´X-Axis Max´ Gadget aktiviert den Cursor, 
     woraufhin der Wert ´EndTime´ vom Anwender eingegeben, bzw. 
     variiert werden kann.
     
   - ´Calculation Step´
     Während der Simulation werden die Daten des zu simulierende Systems
     in definierten zyklisch errechnet. Wir erinnern uns: die Systemvariable
     ´time´ wird bei jedem Zyklus um einen Wert ´step´ vergrößert. Eine 
     Änderung des Wertes von ´step´ hat zwei Effekte zur Folge: Zum Einen
     erhöht eine Vergrößerung des Schrittweite die Simulationsgeschwindigkeit,
     zum Anderen verschlechtert sich der Fehler beim Errechnen der 
     Differentialgleichungen. Die Abweichung kann so groß werden, daß der
     differentielle Bereich des Runge/Kutta Verfahrens verlassen wird. 
     In diesem Fall kann man nicht mehr von Systemsimulation sprechen, und
     die Graphikausgabe zeichnet wilde Muster. Um die Simulationsschrittweite
     zu ändern, wird analog wie zur Änderung des Darstellungsbereiches 
     der X-Achse vorgegangen.


6.2.7   Verlassen der Simulation

   Durch Anwahl des Punktes ´Exit´ wird die Simulation verlassen.


6.3     Das ´Data Handling´ window

   Die Anwahl des Menüpunktes ´Data Handling´ öffnet ein Fenste das dem
   Anwender erlaubt Simulationsdaten und Parameter auf verschiedene Weise 
   zu sichern:

6.3.1   Simulationsparameter speichern

   Sobald der Anwender die Simulation mit ´Exit´ beendet, sind alle Änderungen
   der Parameter, Anfangswerte sowie die Darstellungsgrenzen verloren. Sollen 
   diese dauerhaft geändert werden, müssen die sie im ASCII Modell variiert
   werden. Dazu ist es sinnvoll die aktuellen Daten der Parameter und 
   Anfangswerte des Modells als ASCII File zu speichern. 
   Im ´Data Handling´ Window werden Name und Pfad des Files angezeigt. 
   Ein Mouseclick in das String Gadget öffnet den Arp Requester und fragt nach
   der nach Pfad und Namen fragt. Die Betätigung des ´Save´ Gadgets startet
   dann die Sicherungsprozedur.


6.3.2   Simualtiosergebnisse speichern

   Analog zur Vergehensweise in 6.3.1 besteht die Möglichkeit die 
   Simulationsergebnisse als IFF Bild zu speichern. Ein Mouseclick auf das
   ´Save´ Gadget speichert den Graphikscreen. Während des Sicherungsvorgangs
   wird der Graphik als Frontscreen gezeigt.


6.3.3   Simulationsdaten in File ausgeben

   Eine andere Variante Simulationsdaten festzuhalten, bietet sich mit der
   ´Push´ Option. Ein Mouseclick auf auf das ´Data Push´ Gadget aktiviert oder
   inaktiviert die Option, wobei der augenblickliche Status mit ´no´ oder ´yes´
   angezeigt wird. Zeigt das Gadget ´yes´, so werden während der Simulatio 
   die ausgegeben Variablen zusätzlich in einem ASCII File abgelegt. 
   Pfad und Name des anzulegenden Files wird mitels eines File Requesters
   eingeben, der sich öffnet nachdem das String Gadget angeklickt worden ist. 
   Achtung: Die Data Push Option ist nur für einen  Simulationslauf gültig, 
   d.h. nach Abbruch oder Beenden der Simulation wird die Option wieder 
   inaktiviert.
  

7.      Modellieren einer Simulation

   Im folgenden Abschnitt soll angedeutet werden in welcher Weise wie eine 
   Simulation modelliert wird, die vom FSimParser zu einem ablauffähigen 
   Programm erweitert wird. 
   Dieser Version sind zwar einige Beispiele beigefügt, jedoch würde
   es diesen Rahmen sprengen die naturwissenschaftlich/technischen 
   Hintergründe und Gesetzmäßigkeiten zu erläutern.


7.1     Modellprogrammierung und Abweichungen vom C Standard

   Wie in Abschnitt 2 erwähnt, erstellt der FSimParser aus dem ASCII
   Modell einen C Quellcode, was dem Anwender dazu zwingt die Modellinhalte 
   in C Syntax niederzulegen. In dieser Version des FSimParsers sind einige 
   Abweichungen und Ausnahmen vom Standardsyntax zu beachten.

   - Es ist zwecklos Variablentype wie etwa

     int        ene, mene, miste;
     bool       es, rappelt, in, der;
     float      kiste;

     zu definieren, da der FSimParser selbsttätig die Variablentypen
     festlegt (siehe 7.2).

   - Es ist strikt verboten ein Gleichzeichen ´=´ innerhalb von Kommentaren
     anzuwenden, wie z.B.

        /* HT = Heat transfer  [KW/h] */

   - PräProzessor Kommandos wie z.B.

        #define BlaBlaBla   08_15

     sind nicht zulässig, da ´#´ unter FSim_V1.0  ein geschütztes Zeichen 
     ist ( siehe 7.3.1.1 ).


7.2     Systemvariable

   Wie schon unter 7.1 erwähnt, ist es nicht zulässig irgendwelche
   Variablentypen zu definieren. Der Parser durchsucht das ganze Modell 
   nach Variablen und deklariert diese durchweg als FLOAT.
   Es ist erlaubt Variablen und Parameter frei zu benennen, mit Ausnahmen 
   der Bezeichnungen

      endtime   ( Der name des ´Endes´ der X-Achse!)
      time      ( Der aktuelle Wert der X-Achse bewegt sich zwischen 
                ( 0 und endtime !)
      step      ( Die Simulationsschrittweite! )

   
   Es ist jedoch erlaubt diese Systeminternen Variablen innerhalb des 
   Modells zu benutzen. 

   Beispiel: Der Ausdruck
   
      up = contant * time / endtime;

   erzeugt eine kontinuierlich ansteigende Gerade die bei Null beginnt und
   am Ende der Simulation den Wert ´Constant´ erreicht.

7.3     Die vier Funktionen eines Modells

   Zur Erstellung einer Simulation werden vom Parser innerhalb des Modell vier 
   Funktion gesucht:

      - Die ´SimSys´ Funktion
      - Die ´IniX´   Funktion
      - Die ´IniPar´ Funktion
      - Die ´IniDEQ´ Funktion

   Alle diese Funktionen müssen im Modell auftauchen, selbst wenn sie nicht
   benutzt werden sollten. Ist dies nicht der Fall, so quittiert der Parser dies
   mit einer Fehlermeldung. In den folgenden Abschnitten soll erläutert werden
   wie diese Funktionen angewendet werden. Dabei soll ein Modell namens
   `Fox and Rabbit´ als Beispiel dienen, was in einfacher Weise die Population 
   von Räuber und Beute auf einem begrenzten Lebensraum simuliert.
   Hier ist es:

   void SimSys()   { 
         MYrabbit =   MYrabbitMax - fox     * MYrabbitDeath;
         MYfox    = - MYfoxDeath  + rabbit  * MYfoxMax;

         #fox     =   fox * MYfox;
         #rabbit  =   rabbit  * MYrabbit;

         out(0,   fox      , 0.0   ,300.0);
         out(1,   MYfox    ,-0.5   ,0.5);
         out(2,   rabbit   , 0.0   ,2000.0);
         out(3,   MYrabbit ,-0.5   ,0.5);
         }

   void IniX()
         {
         endtime  = 220.;
         step     = 0.5;
         }

   void IniPar()   
         {
         MYrabbitMax    = 0.1;
         MYrabbitdeath  = 0.001;
         MYfoxMax       = 0.0001;
         MYfoxdeath     = 0.05;
         }

   void IniDEQ()
         {
         fox      = 80.0;
         rabbit   = 80.0;
         }


   Das Modell gibt die Population von Fuchs und Hase natürlich nicht nicht
   der Wahrheit entsprechend wieder, aber es zeigt mit welch einfachen Mitteln
   eine dynamisches Modell erstellt werden kann.


7.3.1   Die ´SimSys´ Funktion

   Innerhalb der ´SymSys´ Funktion werden sämtliche für die Simulation relevanten
   Gleichungen und Funktionen beschrieben:


7.3.1.1 Differentialgleichungen

   FSim erlaubt es dem Anwender innerhalb der SymSys-Funktion 
   Differentialgleichungen erster Ordnung zu definiern wie z.B.


   .   dX
   X = -- = f( X, c1, c2 ... )
       dt

   Der FSimParser definiert alle zur Lösung dieser Gleichungen notwendigen
   Funktionen und errechnet den Wert X aus dessen erster Ableitung.

   ACHTUNG: Die erste Ableitung einer Variablen wird mit einem ´#´
            gekennzeichnet !!!

   Beispiel:

   DGL´s erster Ordnung wie


   dX
   -- = X + 1
   dt

     , 
    X = X + 1

    . 
    X = X + 1

   werden im Modell als

   #X = X + 1

   notiert.


   ES IST NICHT ERLAUBT eine DGL 2. oder höherer Ordnung wie etwa
 

    2
   d X    dX
   ---  = --  +  X
     2
   dt     dt

      ,,   ,
     X  = X + X   

     ..   .
     X  = X + X

   als 

   ##X = #X + X

   zu notieren.


   In diesem Fall ist die DGL zweiter Ordnung in zwei DGL erster Ordnung 

     X = X + A         #X = X + A

     A = X             #A = X

   zu überführen.

   So, dies waren die FSim- spezifischen Regeln zur Erstellung von DGL´s.
   Versuchen wir jetzt doch einmal diese auf unsere Räuber/Beute Population
   anzuwenden.
   Wir wissen:

   - Die Zunahme der Räuberpopulation ist abhängig von der momentan vorliegeden
     Räuberanzahl und einer Wachstumsrate ´MYfox´. Wir formulieren:

       .    dfox
      fox = ---- = fox * MYfox
             dt
                                     
     In unserem Modell notieren wir für diese DGL:

      #fox   =   fox * MYfox;

   - Analog zur Räuberpopulation stellen wir die DGL für die Beutepopulation 
     auf. Auch hier ist diese abhängig von der Anzahl der vorhandenen 
     Beutetiere und einer Wachstumsrate ´MYrabbit´:


        .      drabbit
      rabbit = ------- = rabbit * MYrabbit
                 dt

     Im Modell halten wir die DGL als

      #rabbit   =   rabbit  * MYrabbit;

     fest.

   Unser Modell ist noch nicht komplett, da wir noch die Wachstumsraten 
   bestimmen müssen, welche die DGL´s erst miteinander koppeln.


7.3.1.2 Statische Funktionen

   In den ersten Zeilen der SymSys-Funktion wird die spezifische
   Wachstumsrate von Räuber und Beute als MYfox und MYrabbit ermittelt.
   Die Beutepopulation wächst mit einer maximal möglichen, MYrabbitMAX (sofern
   genügend Futter vorhanden ist). Einige fallen jedoch von den Räuber zum
   Opfer, was der hemmungslosen Vermehrung der Beutetiere entgegenwirkt.
   Wie viele Beutetiere verspeist werden, ist in erster Linie von der 
   Räuberpopulation abhängig und geht proportional zur Anzahl der Räuber
   mit einem Faktor ´MYrabbitDeath´ in die Simulation ein.
   
      MYrabbit =   MYrabbitMAX - fox  * MYrabbitDeath;

   Sind nicht genügend Beutetiere vorhanden, so wird nun ein Teil der vorher
   mit der Rate MYfoxMAX proper wachsenden Räuberpopulation elendiglich 
   verhungern, was die Wachstumsrate MYfox stark vermindern wird: Sie sterben 
   mit der Rate MYfoxDeath.

      MYfox    = - MYfoxDeath + rabbit  * MYfoxMAX;

   Solange die Wachstumsrate großer Null ist, wächst jede der beiden
   Populationen. Ist die Rate kleiner Null, so geht geht sie entweder auf 
   Grund der Überzahl der Räuber oder wegen der zu geringen Beuteanzahl zu 
   Grunde.

7.3.1.3 Output Definitionen

   Als letztes haben wir innerhalb der SymSys-Funktion die auzugebenden 
   Variablen zu definieren. Es ist möglich bis zu sieben Kanäle mit den 
   Nummern 0 bis 6 zu belegen.

         out(Kanal, variable, min, max );

   Zunächst ist die Kanalnummer zu bestimmen, der von der jeweilig 
   dazustellenden Variablen gefolgt wird. Weiterhin ist es notwendig den 
   Darstellungsbereich der auszugebenden Variablen mit ´Min´ und ´Max´ 
   festzulegen.

   Beispiel:

       In unserem Modell wollen wir die Räuber- und die Beutepopulation 
       darstellen. Wir nehmen an, daß die Räuberpopulation zwischen 0 und 300 
       schwanken wird und die der Beute zwischen 0 und 2000. 
       Wir definieren:

         out(0,   fox       ,0.0   ,300.0);         
         out(2,   rabbit    ,0.0   ,2000.0);

       ACHTUNG: Die Minimal/Maximalwerte müssen als FLOATing point angegeben 
                werden.
                Wird dies nicht beachtet und die Grenzen als INTEGER angegeben
                wie z.B.:

         out(0,   fox       ,0    ,300);         
         out(2,   rabbit    ,0   ,2000);

                hat dies eine fehlerhafte Ausgabe zur Folge.


7.3.2   Die ´IniX´ Funktion

   In dieser Funktion definieren wir den Simulationsintervall. Während der 
   Simulation wird die Variable ´time´ um den Wert ´step´ schrittweise erhöht 
   werden, bis ´time´ den Wert von ´endtime´ überschreitet und die Simulation
   beendet ist.

   void IniX()
         {
         endtime   = 220.;
         step      = 0.5;
         }


7.3.3   Die ´IniPar´ Funktion

   In der SysSys-Funktion benutzen wir einige Parameter, kümmern uns dort
   aber nicht weiter um eine Wertzuordnung. Es ist zwar möglich diese 
   Wertzuordnung innerhalb der SymSys-Funktion vorzunehmen, doch können diese 
   während der Simulation nicht variiert werden. Um die Parameter über die
   Benutzeroberfläche auch wührend der Simulation ändern, ist die 
   Wertzuordnung in der ´IniPar´ Funktion vorzunehmen.

   void IniPar()
         {
         MYrabbitmax     = 0.1;
         MYrabbitdeath   = 0.001;
         MYfoxmax        = 0.0001;
         MYfoxdeath      = 0.05;
         }


7.3.4   Die ´IniDEQ´ Funktion

   Wie schon beschrieben, muß jeder DGL ein Anfangswert zuordnet sein,
   was in der ´IniDEQ´-Funktion vorgenommen wird. Für unser Modell gilt:

   void IniDEQ()
         {
         fox         = 80.0;
         rabbit      = 80.0;
         }



8       Bugs

   Es ist noch einiges faul im Staate Dänemark, d.h. mit FSim.
   Negativ ist:

       - der Parser kann nur von der Workbench gestartet werden.

       - wird eine Variable oder Parameter unter den Menüpunkten ´Graph´,
         ´Parameter´ oder ´Initial Values´ gewählt, so erscheint dessen
         Wert im Input Feld nicht immer wie erwartet.

   Es mag schon gut möglich sein daß, sich noch mehr Bugs im Programm tummeln
   die ich noch nicht wahrgenommen habe. Wenn jemand auf darauf stoßen sollte,
   so wäre ich dankbar, mich davon wissen zu lassen.

9       Die Zukunft von FSim

   In diese Version von FSim habe ich versucht die Grundfunktionen eines 
   Simulationssystems zu programmieren und bin zufrieden daß dies so weit ganz 
   gut funktioniert.

   Einiges wäre natürlich noch zu erledigen, z.B.

   - Die Bugs entfernen
   - Der Anwender sollt seine eigenen Funktionen formulieren können
   - FSim sollte unter Matthew Dillon´s DICE Compiler zum Laufen gebracht werden
   
   Wie schon gesagt: Im Moment bin ich dankbar das FSim funktioniert. Vielleicht
   werden die oberen Punkte in einer nächsten Version verwirklicht.
   Wenn jemand FSim benutzt und ein brauchbares und interessantes Modell 
   erstellt hat, bitte laßt mich dann nicht als Unwissender zu Grunde gehen.
   Viel Spaß!

                J. Hartkopf
 
