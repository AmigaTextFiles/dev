@DATABASE DBaseManager.guide - Copyright (c) 1999 by J.T. Steichen
@MASTER DBaseManager.doc
@C 1999 by James T. Steichen

@TAB       3
@WORDWRAP
@WIDTH     80
@FONT      helvetica.font 13

@TOC   Main
@INDEX Main

@MACRO ArgName "@{B}@{FG SHINE}$1@{UB}@{FG TEXT}"

@NODE "Main" "GOOSA - DBaseManager Documentation:"

   The Port name for @{B}DBaseManager@{UB} is @{FG SHINE}GoosaDBase@{FG TEXT}.  @{B}GOOSA@{UB} automatically knows
   to listen & speak to this @{I}ARexxPortName@{UI}.  The following functions are 
   ones that @{B}GOOSA@{UB} actually uses in order to communicate with @{B}DBaseManager@{UB}:

   @{"CREATE 'filename'" LINK "CreateFunc"}   
   @{"OPEN   'filename'" LINK "OpenFunc"}     

   @{"CLOSE" LINK "CloseFunc"}  

   @{"SEARCH 'key' 'contents'" LINK "SearchFunc"}   

   @{"WRITE 'filename' attribcode [record #]" LINK "WriteFunc"} - Add a record to the database.
   @{"READ  'filename' attribcode identifier" LINK "ReadFunc"} - Get a record from the database.

   @{"DELETE   'key'" LINK "DeleteFunc"}   
   @{"UNDELETE 'key'" LINK "UndeleteFunc"}   

   @{"NEXT " LINK "NextFunc"} - Get the next     record from the database.
   @{"PREV " LINK "PrevFunc"} - Get the previous record from the database.
   @{"FIRST" LINK "FirstFunc"} - Get the first    record from the database.
   @{"LAST " LINK "LastFunc"} - Get the last     record from the database.

   @{"KILLDBASEMANAGER" LINK "KillDBaseManagerFunc"}

   Here are some unused ones, in case you're interested:

   @{" Unused Functions " LINK "UnusedFuncs"}

@ENDNODE

@NODE "CreateFunc" "DBaseManager - Create function:"
@PREV Main

   @{FG SHINE} @{JCENTER}
   CREATE "filename" @{FG TEXT} @{JLEFT}

   If @{B}GOOSA@{UB} doesn't find a @{B}.dbf@{UB} file, it will call this function &
   create a new DataBase.

@ENDNODE

@NODE "OpenFunc" "DBaseManager - Open function:"
@PREV Main

   @{FG SHINE} @{JCENTER}
   OPEN "filename" @{FG TEXT} @{JLEFT}

   When @{B}GOOSA@{UB} needs to open a DataBase, it calls this function.

@ENDNODE

@NODE "CloseFunc" "DBaseManager - Close function:"
@PREV Main

   @{FG SHINE} @{JCENTER}
   CLOSE @{FG TEXT} @{JLEFT}  

   @{B}GOOSA@{UB} calls this function when it's done with the DataBase.

@ENDNODE

@NODE "SearchFunc" "DBaseManager - Search function:"
@PREV Main

   @{FG SHINE} @{JCENTER}
   SEARCH "key", "contents" @{FG TEXT} @{JLEFT}
                        
   Search the database for the object @{ArgName "contents"} of type @{ArgName "key"}.
   Valid names for @{Argname "key"} are:  
   @{FG SHINE} @{I}
   REQ,       CAP,      SUPER, SUB,

   ATTRIBUTE, RELATION, ASSOC, COMP,  PROC,

   STATE,     CDE,      IDE,   BDE,   OCT,

   PDE,       NORMAL,   USERREQ @{FG TEXT} @{UI}

@ENDNODE

@NODE "WriteFunc" "DBaseManager - Write function:"
@PREV Main

   @{FG SHINE} @{JCENTER}
   WRITE "filename" attribcode [record #] @{FG TEXT} @{JLEFT}

   @{B}GOOSA@{UB} writes the record to a temporary file specified in 
   @{ArgName "filename"}.  @{ArgName "attribcode"} tells what the Attribute Code is.  Each field 
   in the temporary file is separated by an ASCII @{B}$1C@{UB} (FS).  @{B}DBaseManager@{UB} 
   reads in the temporary file's contents & adds them to the database.  The
   valid range for @{ArgName "attribcode"} is 1 through 18.  @{B}DBaseManager@{UB} then 
   deletes the temporary file.
   @{FG SHINE}
   NOTE:@{FG TEXT}  @{ArgName "record #"} will probably be the record number; 
          @{B}currently NOT implemented!@{UB}

@ENDNODE

@NODE "ReadFunc" "DBaseManager - Read function:"
@PREV Main

   @{FG SHINE} @{JCENTER}
   READ "filename" attribcode identifier @{FG TEXT} @{JLEFT}
     
   Read a record from the database & place in a temporary file that 
   @{B}GOOSA@{UB} will read it from.  @{ArgName "attribcode"} is a RecTypes[] string.
   @{ArgName "identifier"} is the record identifier.  @{ArgName "filename"} is the temporary 
   filename.  Each field in the temporary file is separated by an ASCII 
   @{B}$1C@{UB} (FS).  Valid strings for @{ArgName "attribcode"} are:
        
   @{FG SHINE} @{I}
   REQ,       CAP,      SUPER, SUB,

   ATTRIBUTE, RELATION, ASSOC, COMP,  PROC,

   STATE,     CDE,      IDE,   BDE,   OCT,

   PDE,       NORMAL,   USERREQ @{FG TEXT} @{UI}

@ENDNODE

@NODE "DeleteFunc" "DBaseManager - Delete function:"
@PREV Main

   @{FG SHINE} @{JCENTER}
   DELETE "key" @{FG TEXT} @{JLEFT}
                      
   Mark a record as deleted.  @{ArgName "key"} specifies the record key or identifier.

@ENDNODE

@NODE "UndeleteFunc" "DBaseManager - Undelete function:"
@PREV Main

   @{FG SHINE} @{JCENTER}
   UNDELETE "key" @{FG TEXT} @{JLEFT}
   
   Unmark a record as being deleted.  ARG_1 is the record key or 
   identifier (shortname1).

@ENDNODE

@NODE "NextFunc" "DBaseManager - Next function:"
@PREV Main

   @{FG SHINE} @{JCENTER}
   NEXT @{FG TEXT} @{JLEFT}
                              
   Get the next record from the database.

@ENDNODE

@NODE "PrevFunc" "DBaseManager - Prev function:"
@PREV Main

   @{FG SHINE} @{JCENTER}
   PREV @{FG TEXT} @{JLEFT}
                              
   Get the previous record from the database.

@ENDNODE

@NODE "FirstFunc" "DBaseManager - First function:"
@PREV Main

   @{FG SHINE} @{JCENTER}
   FIRST @{FG TEXT} @{JLEFT}

   Get the first record from the database.

@ENDNODE

@NODE "LastFunc" "DBaseManager - Last function:"
@PREV Main

   @{FG SHINE} @{JCENTER}
   LAST @{FG TEXT} @{JLEFT} 

   Get the last record from the database.

@ENDNODE

@NODE "KillDBaseManagerFunc" "DBaseManager - KillDBaseManager function:"
@PREV Main

   @{FG SHINE} @{JCENTER}
   KILLDBASEMANAGER @{FG TEXT} @{JLEFT}

   Shut everything down.

@ENDNODE

@NODE "UnusedFuncs" "GOOSA - Unused DBaseManager functions:"
@PREV Main

   @{FG SHINE} @{JCENTER}
   GET record_number  @{FG TEXT} @{JLEFT}
                           
   @{B}GOOSA@{UB} asked to get @{ArgName "record_number"} from the database files into 
   e->CurrentRecordBuff.

   @{FG SHINE} @{JCENTER}
   PUT record_number @{FG TEXT} @{JLEFT}
                           
   @{B}GOOSA@{UB} asked to put @{ArgName "record_number"} from the e->CurrentRecordBuff 
   into the database files.

   @{FG SHINE} @{JCENTER}
   INITMEMOBUFF memo # @{FG TEXT} @{JLEFT}

   @{ArgName "memo #"} specifies which memo to initialize.

   @{FG SHINE} @{JCENTER}
   ADDTOMEMO memo # "tempfilename" @{FG TEXT} @{JLEFT}

   Add @{ArgName "tempfilename"} string contents to the memo buffer specified 
   by @{ArgName "memo #"}.

   @{FG SHINE} @{JCENTER}
   WRITEMEMO memo # "tempfilename" @{FG TEXT} @{JLEFT}

   Write @{ArgName "tempfilename"} contents to the memo buffer specified by @{ArgName "memo #"} to 
   the database files.

   @{FG SHINE} @{JCENTER}
   GETMEMO   memo # "tempfilename" @{FG TEXT} @{JLEFT}  

   Get the memo specified by @{ArgName "memo #"} from the current record & place it into
   the file specified by @{ArgName "tempfilename"}.

   @{FG SHINE} @{JCENTER}
   GETERRORMSG error # @{FG TEXT} @{JLEFT}

   Translate the @{ArgName "error #"} into a an error message string.  This 
   function should only be used from ARexx, since @{B}GOOSA@{UB} doesn't need it.

   @{FG SHINE} @{JCENTER}
   DISPLAY record # @{FG TEXT} @{JLEFT}

   Print out @{ArgName "record #"} specified by ARG_1.  Not needed by @{B}GOOSA@{UB}, for 
   debugging purposes only.

@ENDNODE
