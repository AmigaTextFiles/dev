diff -cr ram:patch-2.1/backupfile.c dh1:patch-2.1/backupfile.c
*** ram:patch-2.1/backupfile.c	Thu Jun 10 06:58:04 1993
--- dh1:patch-2.1/backupfile.c	Wed Jun 23 18:01:04 1993
***************
*** 34,39 ****
--- 34,44 ----
  #include <unistd.h>
  #endif
  
+ #ifdef AMIGA
+ #include <sys/dir.h>
+ #define direct dirent
+ #define NLENGTH(direct) ((direct)->d_namlen)
+ #else
  #if defined(DIRENT) || defined(_POSIX_VERSION)
  #include <dirent.h>
  #define NLENGTH(direct) (strlen((direct)->d_name))
***************
*** 50,55 ****
--- 55,61 ----
  #include <ndir.h>
  #endif /* NDIR */
  #endif /* DIRENT or _POSIX_VERSION */
+ #endif /* AMIGA */
  
  #ifndef isascii
  #define ISDIGIT(c) (isdigit ((unsigned char) (c)))
***************
*** 65,76 ****
--- 71,90 ----
  #define REAL_DIR_ENTRY(dp) ((dp)->d_ino != 0)
  #endif
  
+ #ifdef AMIGA
+ #define max(a,b) (((a)>(b))?(a):(b))
+ #endif /* AMIGA */
+ 
  /* Which type of backup file names are generated. */
  enum backup_type backup_type = none;
  
  /* The extension added to file names to produce a simple (as opposed
     to numbered) backup file name. */
+ #ifndef AMIGA
  char *simple_backup_suffix = "~";
+ #else /* AMIGA */
+ char *simple_backup_suffix = "!";
+ #endif /* AMIGA */
  
  char *basename ();
  char *dirname ();
***************
*** 86,97 ****
--- 100,120 ----
  basename (name)
       char *name;
  {
+ #ifndef AMIGA
    char *r = name, *p = name;
  
    while (*p)
      if (*p++ == '/')
        r = p;
    return r;
+ #else /* AMIGA */
+   char *base1, *base2, *base;
+ 
+   base1 = rindex (name, '/');
+   base2 = rindex (name, ':');
+   base = max (base1, base2);
+   return base ? base + 1 : name;
+ #endif /* AMIGA */
  }
  
  #ifndef NODIR
***************
*** 112,121 ****
--- 135,152 ----
      {
        char *s = malloc (strlen (file) + strlen (simple_backup_suffix) + 1);
        strcpy (s, file);
+ #ifndef AMIGA
        addext (s, simple_backup_suffix, '~');
+ #else /* AMIGA */
+       addext (s, simple_backup_suffix, '!');
+ #endif /* AMIGA */
        return s;
      }
+ #ifndef AMIGA
    base_versions = concat (basename (file), ".~");
+ #else /* AMIGA */
+   base_versions = concat (basename (file), ".!");
+ #endif /* AMIGA */
    if (base_versions == 0)
      return 0;
    dir = dirname (file);
***************
*** 180,186 ****
--- 211,221 ----
    backup_name = malloc (strlen (file) + 16);
    if (backup_name == 0)
      return 0;
+ #ifndef AMIGA
    sprintf (backup_name, "%s.~%d~", file, version);
+ #else /* AMIGA */
+   sprintf (backup_name, "%s.!%d!", file, version);
+ #endif /* AMIGA */
    return backup_name;
  }
  
***************
*** 202,208 ****
--- 237,247 ----
      {
        for (p = &backup[base_length]; ISDIGIT (*p); ++p)
  	version = version * 10 + *p - '0';
+ #ifndef AMIGA
        if (p[0] != '~' || p[1])
+ #else /* AMIGA */
+       if (p[0] != '!' || p[1])
+ #endif /* AMIGA */
  	version = 0;
      }
    return version;
***************
*** 235,240 ****
--- 274,280 ----
  dirname (path)
       char *path;
  {
+ #ifndef AMIGA
    char *newpath;
    char *slash;
    int length;    /* Length of result, not including NUL. */
***************
*** 260,265 ****
--- 300,334 ----
    strncpy (newpath, path, length);
    newpath[length] = 0;
    return newpath;
+ #else /* AMIGA */
+   char *newpath;
+   char *slash, *colon, *dirsep;
+   int length;    /* Length of result, not including NUL. */
+ 
+   slash = rindex (path, '/');
+   colon = rindex (path, ':');
+   dirsep = max (slash, colon);
+   if (dirsep == 0)
+ 	{
+ 	  /* File is in the current directory.  */
+ 	  path = "";
+ 	  length = 0;
+ 	}
+   else
+ 	{
+ 	  /* Remove one trailing slash from result, if exists. */
+ 	  if (dirsep > path && *dirsep == '/')
+ 		--dirsep;
+ 
+ 	  length = dirsep - path + 1;
+ 	}
+   newpath = malloc (length + 1);
+   if (newpath == 0)
+     return 0;
+   strncpy (newpath, path, length);
+   newpath[length] = 0;
+   return newpath;
+ #endif /* AMIGA */
  }
  
  /* If ARG is an unambiguous match for an element of the
***************
*** 379,385 ****
      }
  #endif
    if (slen_max == -1) {
! #if HAVE_LONG_FILE_NAMES
      slen_max = 255;
  #else
      slen_max = 14;
--- 448,454 ----
      }
  #endif
    if (slen_max == -1) {
! #ifdef HAVE_LONG_FILE_NAMES
      slen_max = 255;
  #else
      slen_max = 14;
diff -cr ram:patch-2.1/getopt.c dh1:patch-2.1/getopt.c
*** ram:patch-2.1/getopt.c	Wed Jun 09 13:05:42 1993
--- dh1:patch-2.1/getopt.c	Wed Jun 23 17:55:51 1993
***************
*** 42,50 ****
--- 42,52 ----
  #endif /* alloca.h */
  #endif /* not __GNUC__ */
  
+ #ifndef AMIGA
  #if !__STDC__ && !defined(const) && IN_GCC
  #define const
  #endif
+ #endif /* !AMIGA */
  
  /* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */
  #ifndef _NO_PROTO
diff -cr ram:patch-2.1/getopt1.c dh1:patch-2.1/getopt1.c
*** ram:patch-2.1/getopt1.c	Fri May 07 21:29:54 1993
--- dh1:patch-2.1/getopt1.c	Wed Jun 23 17:56:28 1993
***************
*** 22,30 ****
--- 22,32 ----
  
  #include "getopt.h"
  
+ #ifndef AMIGA
  #if !__STDC__ && !defined(const) && IN_GCC
  #define const
  #endif
+ #endif /* !AMIGA */
  
  #include <stdio.h>
  
diff -cr ram:patch-2.1/inp.c dh1:patch-2.1/inp.c
*** ram:patch-2.1/inp.c	Tue Jun 08 17:23:00 1993
--- dh1:patch-2.1/inp.c	Wed Jun 23 17:58:26 1993
***************
*** 79,86 ****
--- 79,88 ----
      int ifd, statfailed;
      Reg1 char *s;
      Reg2 LINENUM iline;
+ #ifndef AMIGA
      char lbuf[MAXLINELEN];
      int output_elsewhere = strcmp(filename, outname);
+ #endif /* !AMIGA */
  
      statfailed = stat(filename, &filestat);
      if (statfailed && ok_to_create_file) {
***************
*** 90,95 ****
--- 92,98 ----
  	close(creat(filename, 0666));
  	statfailed = stat(filename, &filestat);
      }
+ #ifndef AMIGA
      /* For nonexistent or read-only files, look for RCS or SCCS versions.  */
      if (statfailed
  	|| (! output_elsewhere
***************
*** 155,160 ****
--- 158,168 ----
  	}
      }
      filemode = filestat.st_mode;
+ #else /* AMIGA */
+     if (statfailed)
+ 	fatal2("can't find %s\n", filename);
+     filemode = filestat.st_mode;
+ #endif /* AMIGA */
      if (!S_ISREG(filemode))
  	fatal2("%s is not a normal file--can't patch\n", filename);
      i_size = filestat.st_size;
diff -cr ram:patch-2.1/patch.c dh1:patch-2.1/patch.c
*** ram:patch-2.1/patch.c	Sun May 30 18:46:14 1993
--- dh1:patch-2.1/patch.c	Wed Jun 23 17:40:27 1993
***************
*** 90,95 ****
--- 90,99 ----
   * 
   */
  
+ #ifdef AMIGA
+ #include <dos.h>
+ #include <proto/exec.h>
+ #endif /* AMIGA */
  #include "INTERN.h"
  #include "common.h"
  #include "EXTERN.h"
***************
*** 116,121 ****
--- 120,129 ----
  bool similar();
  void re_input();
  void my_exit();
+ #ifdef AMIGA
+ void amiga_exit();
+ static char curpath[256];
+ #endif /* AMIGA */
  
  /* TRUE if -E was specified on command line.  */
  static int remove_empty_files = FALSE;
***************
*** 140,149 ****
--- 148,169 ----
      bool rev_okayed = 0;
      int i;
  
+ #ifdef AMIGA
+     if (!onexit (amiga_exit)) {
+       fputs ("Couldn't set exit trap.\n", stderr);
+       exit (20);
+     }
+     if (getcwd(curpath,256) == NULL) {
+       fputs ("Couldn't get current path.\n", stderr);
+       exit (20);
+     }
+ #endif /* AMIGA */
+ 
      setbuf(stderr, serrbuf);
      for (i = 0; i<MAXFILEC; i++)
  	filearg[i] = Nullch;
  
+ #ifndef AMIGA
      myuid = getuid();
  
      /* Cons up the names of the temporary files.  */
***************
*** 178,183 ****
--- 198,223 ----
        strcat (TMPPATNAME, "/patchpXXXXXX");
        Mktemp(TMPPATNAME);
      }
+ #else /* AMIGA */
+     /* Cons up the names of the temporary files.  */
+     {
+       struct Task *Task;
+ 
+       Task = FindTask (NULL);
+ 
+       TMPOUTNAME = (char *) malloc (20);
+       sprintf (TMPOUTNAME, "T:patcho%08lx", Task);
+ 
+       TMPINNAME = (char *) malloc (20);
+       sprintf (TMPINNAME, "T:patchi%08lx", Task);
+ 
+       TMPREJNAME = (char *) malloc (20);
+       sprintf (TMPREJNAME, "T:patchr%08lx", Task);
+ 
+       TMPPATNAME = (char *) malloc (20);
+       sprintf (TMPPATNAME, "T:patchp%08lx", Task);
+     }
+ #endif /* AMIGA */
  
      {
        char *v;
***************
*** 364,370 ****
--- 404,414 ----
  		&& statbuf.st_size == 0) {
  		if (verbose)
  		    say2("Removing %s (empty after patching).\n", realout);
+ #ifndef AMIGA
  	        while (unlink(realout) >= 0) ; /* while is for Eunice.  */
+ #else /* AMIGA */
+ 	        Unlink(realout);
+ #endif /* AMIGA */
  	    }
  	}
  	Fclose(rejfp);
***************
*** 942,945 ****
--- 986,1003 ----
      }
      Unlink(TMPPATNAME);
      exit(status);
+ }
+ 
+ void
+ amiga_exit()
+ {
+     unlink(TMPINNAME);
+     if (!toutkeep) {
+ 	Unlink(TMPOUTNAME);
+     }
+     if (!trejkeep) {
+ 	Unlink(TMPREJNAME);
+     }
+     Unlink(TMPPATNAME);
+     chdir(curpath);
  }
diff -cr ram:patch-2.1/pch.c dh1:patch-2.1/pch.c
*** ram:patch-2.1/pch.c	Tue Jun 01 03:54:18 1993
--- dh1:patch-2.1/pch.c	Wed Jun 23 17:41:09 1993
***************
*** 1246,1251 ****
--- 1246,1252 ----
  void
  do_ed_script()
  {
+ #ifndef AMIGA
      Reg1 char *t;
      Reg2 long beginning_of_this_line;
      Reg3 bool this_line_is_command = FALSE;
***************
*** 1302,1305 ****
--- 1303,1310 ----
      else
  	chmod(outname, filemode);
      set_signals(1);
+ #else /* AMIGA */
+     fprintf (stderr, "Ed scripts are not supported in the Amiga version of patch!\n");
+     my_exit (20);
+ #endif /* AMIGA */
  }
diff -cr ram:patch-2.1/util.c dh1:patch-2.1/util.c
*** ram:patch-2.1/util.c	Mon May 31 22:34:50 1993
--- dh1:patch-2.1/util.c	Wed Jun 23 17:50:11 1993
***************
*** 66,71 ****
--- 66,72 ----
      }
  
      if (stat(to, &filestat) == 0) {	/* output file exists */
+ #ifndef AMIGA
  	dev_t to_device = filestat.st_dev;
  	ino_t to_inode  = filestat.st_ino;
  	char *simplename = bakname;
***************
*** 74,79 ****
--- 75,90 ----
  	    if (*s == '/')
  		simplename = s+1;
  	}
+ #else /* AMIGA */
+ 	char *simplename = bakname;
+ 
+ 	for (s=bakname; *s; s++) {
+ 	    if (*s == '/' || *s == ':')
+ 		simplename = s+1;
+ 	}
+ #endif /* AMIGA */
+ 
+ #ifndef AMIGA
  	/* Find a backup name that is not the same file.
  	   Change the first lowercase char into uppercase;
  	   if that isn't sufficient, chop off the first char and try again.  */
***************
*** 87,92 ****
--- 98,108 ----
  		Strcpy(simplename, simplename+1);
  	}
  	while (unlink(bakname) >= 0) ;	/* while() is for benefit of Eunice */
+ #else /* AMIGA */
+         /* The stuff above is not very meaningful on the Amiga */
+         Unlink(bakname);
+ #endif /* AMIGA */
+ 
  #ifdef DEBUGGING
  	if (debug & 4)
  	    say3("Moving %s to %s.\n", to, bakname);
***************
*** 96,108 ****
--- 112,132 ----
  		 strerror(errno));
  	    return -1;
  	}
+ #ifndef AMIGA
  	while (unlink(to) >= 0) ;
+ #else /* AMIGA */
+         Unlink(to);
+ #endif /* AMIGA */
      }
  #ifdef DEBUGGING
      if (debug & 4)
  	say3("Moving %s to %s.\n", from, to);
  #endif
+ #ifndef AMIGA
      if (rename(from, to) < 0) {		/* different file system? */
+ #else /* AMIGA */
+     if (rename(from, to) != 0) {	/* different file system? */
+ #endif /* AMIGA */
  	Reg4 int tofd;
  	
  	tofd = creat(to, 0666);
***************
*** 225,230 ****
--- 249,255 ----
      my_exit(1);
  }
  
+ #ifndef AMIGA
  /* Get a response from the user, somehow or other. */
  
  void
***************
*** 269,274 ****
--- 294,334 ----
      if (!tty2)
  	say1(buf);
  }
+ #else  /* AMIGA */
+ /* The closest thing to "/dev/tty" on the Amiga is called "*".
+    Open it in any case, because stdin may be redirected, and the
+    user can't tell the difference if it's not redirected :-).
+    I think this will work with the ARP shell under Kick 1.3 too,
+    but I have no way to tell... */
+ 
+ void
+ ask(pat,arg1,arg2,arg3)
+ char *pat;
+ long arg1,arg2,arg3;
+ {
+     int console;
+     long r;
+ 
+ 
+     Sprintf (buf, pat, arg1, arg2, arg3);
+     console = open ("*", O_RDWR | O_CREAT);
+     if (console >= NULL)
+       {
+         write (console, buf, strlen (buf));
+         r = read (console, buf, sizeof (buf));
+         Close (console);
+       }
+     else
+       {				/* no terminal at all--default it */
+ 	buf[0] = '\n';
+ 	r = 1;
+       }
+     if (r <= 0)
+         buf[0]=0;
+     else
+         buf[r]=0;
+ }
+ #endif  /* AMIGA */
  #endif /* lint */
  
  /* How to handle certain events when not in a critical region. */
***************
*** 278,294 ****
--- 338,362 ----
  int reset;
  {
  #ifndef lint
+ #ifndef AMIGA
      static RETSIGTYPE (*hupval)(),(*intval)();
+ #else /* AMIGA */
+     static RETSIGTYPE (*intval)();
+ #endif /* AMIGA */
  
      if (!reset) {
+ #ifndef AMIGA
  	hupval = signal(SIGHUP, SIG_IGN);
  	if (hupval != SIG_IGN)
  	    hupval = (RETSIGTYPE(*)())my_exit;
+ #endif /* !AMIGA */
  	intval = signal(SIGINT, SIG_IGN);
  	if (intval != SIG_IGN)
  	    intval = (RETSIGTYPE(*)())my_exit;
      }
+ #ifndef AMIGA
      Signal(SIGHUP, hupval);
+ #endif /* !AMIGA */
      Signal(SIGINT, intval);
  #endif
  }
***************
*** 299,305 ****
--- 367,375 ----
  ignore_signals()
  {
  #ifndef lint
+ #ifndef AMIGA
      Signal(SIGHUP, SIG_IGN);
+ #endif /* !AMIGA */
      Signal(SIGINT, SIG_IGN);
  #endif
  }
***************
*** 337,343 ****
--- 407,417 ----
      if (dirvp < 0)
  	return;
  
+ #ifndef AMIGA
      strcpy(buf, "mkdir");
+ #else /* AMIGA */
+     strcpy(buf, "makedir");
+ #endif /* AMIGA */
      s = buf;
      for (i=0; i<=dirvp; i++) {
  	struct stat sbuf;
***************
*** 364,370 ****
--- 438,446 ----
      char *fullname;
      char *name;
      Reg1 char *t;
+ #ifndef AMIGA
      char tmpbuf[200];
+ #endif /* !AMIGA */
      int sleading = strip_leading;
  
      if (!at)
***************
*** 375,395 ****
--- 451,491 ----
      if (debug & 128)
  	say4("fetchname %s %d %d\n",at,strip_leading,assume_exists);
  #endif
+ #ifndef AMIGA
      if (strnEQ(at, "/dev/null", 9))	/* so files can be created by diffing */
  	return Nullch;			/*   against /dev/null. */
+ #else /* AMIGA */
+     /* This probably doesn't make much sense since you can't diff
+        against NIL: on the Amiga... */
+     if (strnEQ(at, "NIL:", 9))	/* so files can be created by diffing */
+ 	return Nullch;			/*   against NIL:. */
+ #endif /* AMIGA */
+ 
      name = fullname = t = savestr(at);
  
+ #ifndef AMIGA
      /* Strip off up to `sleading' leading slashes and null terminate.  */
      for (; *t && !isspace(*t); t++)
  	if (*t == '/')
  	    if (--sleading >= 0)
  		name = t+1;
+ #else /* AMIGA */
+     /* Strip off up to `sleading' leading slashes or colons and null terminate.  */
+     /* Please note that filenames with spaces are not handled correctly due
+        to the output format of diff and the assumptions that patch has to
+        make because of this output format. */
+     for (; *t && !isspace(*t); t++)
+ 	if (*t == '/' || *t == ':')
+ 	    if (--sleading >= 0)
+ 		name = t+1;
+ #endif /* AMIGA */
      *t = '\0';
  
      /* If no -p option was given (957 is the default value!),
         we were given a relative pathname,
         and the leading directories that we just stripped off all exist,
         put them back on.  */
+ #ifndef AMIGA
      if (strip_leading == 957 && name != fullname && *fullname != '/') {
  	name[-1] = '\0';
  	if (stat(fullname, &filestat) == 0 && S_ISDIR (filestat.st_mode)) {
***************
*** 397,406 ****
--- 493,512 ----
  	    name=fullname;
  	}
      }
+ #else /* AMIGA */
+     if (strip_leading == 957 && name != fullname && strchr(fullname,':') == NULL) {
+ 	name[-1] = '\0';
+ 	if (stat(fullname, &filestat) == 0 && S_ISDIR (filestat.st_mode)) {
+ 	    name[-1] = '/';
+ 	    name=fullname;
+ 	}
+     }
+ #endif /* AMIGA */
  
      name = savestr(name);
      free(fullname);
  
+ #ifndef AMIGA
      if (stat(name, &filestat) && !assume_exists) {
  	char *filebase = basename(name);
  	int pathlen = filebase - name;
***************
*** 418,423 ****
--- 524,533 ----
  	free(name);
  	name = Nullch;
      }
+ #else /* AMIGA */
+     if (stat(name, &filestat) && !assume_exists)
+         name = Nullch;
+ #endif /* AMIGA */
  
      return name;
  }
