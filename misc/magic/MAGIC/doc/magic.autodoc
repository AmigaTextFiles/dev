TABLE OF CONTENTS

magic.library/--background--
magic.library/--messages--
magic.library/AddMagicImage
magic.library/AllocMagicImageA
magic.library/AttemptLockMagicImage
magic.library/CloseMagicImage
magic.library/CycleMagicImage
magic.library/FreeMagicImage
magic.library/GetMagicImageDataA
magic.library/IsMagicMessage
magic.library/LockMagicImage
magic.library/OpenMagicImageA
magic.library/PickMagicImageA
magic.library/PutMagicImageDataA
magic.library/RedrawMagicImage
magic.library/RemMagicImage
magic.library/RestoreMagicImage
magic.library/SaveMagicImage
magic.library/SetDefaultMagicImage
magic.library/UnlockMagicImage
magic.library/UpdateMagicImage
magic.library/zzzzz



magic.library/--background--                     magic.library/--background--

    - What is MAGIC?

    MAGIC is a purely marketing-inspired name for a system of sharing 24-bit
    image data between MAGIC-aware applications.

    - Why is this needed?

    The primary reason is to make things easier on the user.  It is very
    awkward to have to save an image out of one program, then run a different
    program and then re-load the image to work on it again.  MAGIC allows the
    image data to be "shared" between the two applications _while they are
    running_.

    - What's wrong with the clipboard or HotLinks?

    MAGIC is specifically oriented towards 24-bit image data (although it is
    certainly extensible to other types of data, but that is beyond the scope
    of this document).  MAGIC is also an "in-memory" system, where the image
    data is kept in memory instead of on disk.  MAGIC is also very transparent
    to the user; there is no need to "publish" or "subscribe".

    - How's it work?

    The first step is to run a server program that can be run in the
    background to manage MAGIC images and provide a convenient function
    library.  This server program can be placed in a user's WBStartup
    drawer (if they're running 1.3, user's deserve the associated hassles).

    When an application wishes to make an image "public" (available to other
    MAGIC-aware applications), he opens the server-created library (called
    "magic.library") and goes through the steps of creating a MAGIC image.
    The image is then added to the public image list and may from then on be
    "opened" by any other application.

    The application that creates a MAGIC image and makes it public is known
    throughout this document as the "owner" of an image.  Those applications
    that open a MAGIC image for use are known as "openers" (creative, huh? :).

    - How about all those different image data organizations?

    This was a major obstacle in the MAGIC system; everyone seems to have a
    different way of storing image data (there's nothing wrong with this, it
    just makes sharing data a little tough).  MAGIC overcomes this like this:

    The owner of an image determines the image data organization (the "native"
    organization).  Since the openers may be expecting a different
    organization, translation functions are provided which allow the opener to
    translate the image data into a known format.  This incurs a bit of a
    speed penalty when processing the image, but this seemed the most logical
    way of approaching the problem.

    If the owner of an image is using seperate contiguous blocks for the RGB
    data, it may optionally provide this information so that other
    applications that can handle this organization may use the pointers
    directly.  This seems to be the most popular image data organization, and
    is currently in use by several Amiga products.

    - Is it easy to support?

    One of the goals was to make the task of integrating MAGIC into existing
    applications fairly painless.  True, some work will be required, but we
    think the benefits are well worth it.

    - Does MAGIC cost anything?

    No.  The server program and documentation for creating MAGIC-aware
    applications will be freely distributable.

    - Are there any gotchas?

    Your application must be able to support multi-tasking access to
    your image data, because more than one application may be updating
    their displays based on your image data.  In most cases where the
    image data is stored in memory, this will not be a problem.

    - Well, you convinced me.  I'll start supporting it right away!

    Cool beans. :)

    - Is there anything else I should know?

    Yeah, too many questions can get on a person's nerves.

    - Sorry.

    No problem.


magic.library/--messages--                         magic.library/--messages--

    The following types of messages may be sent to your application
    from MAGIC:

        MMSG_CLOSE

            This is a request for you to close your handle on a
            particular MAGIC image, as someone else is trying to
            release the image.

        MMSG_TOFRONT

            This is a request to bring your application's interface
            to the front and activate it.

        MMSG_REDRAW

            This is a request to redraw some or all of a MAGIC
            image's display.

        MMSG_UPDATE

            This is sent when the physical dimensions of a MAGIC
            image are being changed.  (NOTE:  This version of MAGIC
            does not yet handle physically changing the size of images
            very well.)

        MMSG_SAVEUNDO

            Request the owner of a MAGIC image to save a copy of some
            or all of the image in an "undo" buffer, presumably before
            some action is done to the image.

        MMSG_RESTOREUNDO

            Request the owner of a MAGIC image to undo the last changes
            to a MAGIC image.


magic.library/AddMagicImage                       magic.library/AddMagicImage

    NAME
        AddMagicImage -- Make a MAGIC image available to other tasks.

    SYNOPSIS
        success = AddMagicImage ( image );
        D0.L                      A0

        BOOL AddMagicImage ( struct MagicImage * );

    FUNCTION
        Make a previously allocated and initialized MagicImage structure
        available for other applications to open and access.  Only the
        owner of an image should make it public.

    INPUTS
        image -- a pointer to an initialized MagicImage structure,
            which should only be allocated with the AllocMagicImageA()
            function.

    RESULTS
        success -- TRUE if the image was successfully added, or FALSE on
            failure.

    EXAMPLE

    NOTES

    BUGS

    SEE ALSO


magic.library/AllocMagicImageA                 magic.library/AllocMagicImageA

    NAME
        AllocMagicImageA -- Allocate and initialize a MagicImage structure.
        AllocMagicImage -- varargs stub for AllocMagicImageA().

    SYNOPSIS
        image = AllocMagicImageA ( taglist );
        D0.L                       A0

        struct MagicImage *AllocMagicImageA ( struct TagItem * );

        image = AllocMagicImage ( firstTag, ... );

        struct MagicImage *AllocMagicImage ( Tag, ... );

    FUNCTION
        Allocate and initialize a new MagicImage structure.  You *must*
        use this function to create the structure to be upwardly compatible.

    INPUTS
        taglist -- tags used to initialize the PublicImage structure.

                AMI_Width:
                    (LONG) Width of image data in pixels.

                AMI_Height:
                    (LONG) Height of image data in pixels.

                AMI_Depth:
                    (LONG) Depth of image data in 8-bit planes (eg. 1 for an
                    8-bit greyscale image or 3 for a 24-bit RGB color
                    image).

                AMI_Name:
                    (char *) Name of the public image buffer.  Defaults to a
                    unique name.

                AMI_ImageData:
                    (APTR) Information need by the owner of this image to
                    decipher it's contents.  Could be nothing more than a
                    pointer to an array of RGB plane pointers.

                AMI_GetDataCode:
                    (int (*)()) Hook function to convert the native format
                    of this image buffer into lines of RGB data.  The
                    function will fail if this tag is not given.

                AMI_PutDataCode:
                    (int (*)()) Hook function to store lines of RGB data
                    into this image buffer, converting to its native
                    format as necessary.  The function will fail if this
                    tag is not given.

                AMI_Red:
                    (UBYTE *) Pointer to contiguous block of chunky red
                    image data, if you are able to provide this information.
                    If not specified, an application will be forced to go
                    through a translation process to get to your image data.

                AMI_Green:
                    (UBYTE *) Pointer to contiguous block of chunky green
                    image data, if you are able to provide this information.

                AMI_Blue:
                    (UBYTE *) Pointer to contiguous block of chunky blue
                    image data, if you are able to provide this information.

                AMI_Alpha:
                    (UBYTE *) Pointer to contiguous block of chunky 8-bit
                    alpha channel data, if you are able to provide this
                    information.

                AMI_AspectX:
                    (LONG) Horizontal pixel aspect ratio of the new image.
                    Defaults to 1.

                AMI_AspectY:
                    (LONG) Vertical pixel aspect ratio of the new image.
                    Defaults to 1.

                AMI_DPIX:
                    (LONG) Horizontal pixels per inch of the new image.
                    Defaults to 300.

                AMI_DPIY:
                    (LONG) Vertical pixels per inch of the new image.
                    Defaults to 300.

                AMI_OwnerName:
                    (char *) Provide the name of the application that
                    created this image.  Other applications can use
                    this information.  Defaults to NULL, meaning the
                    owner will remain anonymous.

    RESULTS
        image -- pointer to MagicImage structure.

    EXAMPLE

    NOTES
        The TAG_SKIP and TAG_MORE tags are not supported.

    BUGS

    SEE ALSO


magic.library/AttemptLockMagicImage       magic.library/AttemptLockMagicImage

    NAME
        AttemptLockMagicImage -- Attempt to obtain a lock on a MAGIC image.

    SYNOPSIS
        success = AttemptLockMagicImage ( magicHandle, type );
        D0.L                              A0           D0.L

        BOOL AttemptLockMagicImage ( struct MagicHandle *, LONG );

    FUNCTION
        Attempt to get a read or write lock on the specified public image.  You
        should always obtain a write lock before attempting to modify a
        public image, so two tasks will not try to modify an image at
        the same time.

        If the image is write locked by another task, this function will fail
        immediately.  Use LockMagicImage() if you want to wait for the image
        to become available.

    INPUTS
        magicHandle -- pointer to a valid image handle as obtained from
            OpenPublicImageA().

        type -- type of lock to obtain, LMI_Read or LMI_Write.

    RESULTS
        success -- TRUE if the lock was obtained, FALSE on failure.

    EXAMPLE

    NOTES

    BUGS

    SEE ALSO


magic.library/CloseMagicImage                   magic.library/CloseMagicImage

    NAME
        CloseMagicImage -- Close a public MAGIC image.

    SYNOPSIS
        success = CloseMagicImage ( magicHandle );
        D0.L                        A0

        BOOL CloseMagicImage ( struct MagicImage * );

    FUNCTION
        Close a previously opened public image, freeing it to be removed
        by its owner.

    INPUTS
        magicHandle -- pointer to a valid image handle as obtained from
            OpenMagicImageA().

    RESULTS
        success -- TRUE if successful, FALSE on failure.

    EXAMPLE

    NOTES

    BUGS

    SEE ALSO



magic.library/CycleMagicImage                   magic.library/CycleMagicImage

    NAME
        CycleMagicImage -- Cycle to next application using a MAGIC image.

    SYNOPSIS
        CycleMagicImage ( magicHandle );
                          A0

        void CycleMagicImage ( struct MagicHandle * );

    FUNCTION
        Bring the interface of the next application that has access to the
        given image to the front.  This can be used as a convenience to the
        user when switching between applications.

        This function is asynchronous, meaning it returns immediately.

        This works by sending a MMSG_TOFRONT message to the next application
        in line that has opened the image.

    INPUTS
        magicHandle -- pointer to a valid image handle as obtained from
            OpenMagicImageA().

    RESULTS
        None.

    EXAMPLE

    NOTES

    BUGS

    SEE ALSO


magic.library/FreeMagicImage                     magic.library/FreeMagicImage

    NAME
        FreeMagicImage -- Free a MAGIC image structure.

    SYNOPSIS
        FreeMagicImage ( magicImage );
                         A0

        void FreeMagicImage ( struct MagicImage * );

    FUNCTION
        Frees all memory associated with a MagicImage structure.  This call
        must only be used on MagicImage's created with the AllocMagicImageA()
        function.

    INPUTS
        magicImage -- pointer to a MagicImage structure to free.

    RESULTS
        None.

    EXAMPLE

    NOTES
        This function does not check to see if anyone has opened the image in
        question; only the owner of an image should free the associated
        MagicImage structure when everyone has closed it.

    BUGS

    SEE ALSO


magic.library/GetMagicImageDataA             magic.library/GetMagicImageDataA

    NAME
        GetMagicImageDataA -- Retreive rows of image data.
        GetMagicImageData -- varargs stub to GetMagicImageDataA.

    SYNOPSIS
        success = GetMagicImageDataA ( magicHandle, yoffset, rows, tagList );
        D0.L                           A0           D0.L     D1.L  A1

        BOOL GetMagicImageDataA ( struct MagicHandle *, LONG, LONG,
                                  struct TagItem * );

        success = GetMagicImageData ( magicHandle, yoffset, rows, ... );

        BOOL GetMagicImageData ( struct MagicHandle *, LONG, LONG, ... );

    FUNCTION
        Copies image data from the given MAGIC image into caller-supplied
        buffers, calling the image's translation function (set by the owner of
        the image).

    INPUTS
        magicHandle -- pointer to a valid image handle as obtained from
            OpenPublicImageA().

        yoffset -- topmost row to start copying from, starting from 0.

        rows -- number of rows of image data to copy.

        tagList -- tags describing the image data to get:

                GMI_Red:
                    (UBYTE *) Copies red image data into the caller's buffer,
                    1 byte per pixel.  If the image buffer is greyscale, the
                    greyscale data will be copied.

                GMI_Green:
                    (UBYTE *) Copies green image data into the caller's
                    buffer, 1 byte per pixel.

                GMI_Blue:
                    (UBYTE *) Copies blue image data into the caller's buffer,
                    1 byte per pixel.

                GMI_RGB:
                    (UBYTE *) Copies RGB imgae data into the caller's buffer,
                    3 bytes per pixel in the format RGBRGBRGB...

                GMI_ARGB:
                    (UBYTE *) Copies RGB image data + alpha channel
                    information into the caller's buffer, 4 bytes per pixel in
                    the format ARGBARGBARGB...

                GMI_Alpha:
                    (UBYTE *) Copies alpha channel information into the
                    caller's buffer, 1 byte per pixel.

    RESULTS
        success -- TRUE if all data was succesfully copied, or FALSE if
            something failed.

    EXAMPLE

    NOTES
        You should always obtain a read lock before reading image data!

    BUGS

    SEE ALSO


magic.library/IsMagicMessage                     magic.library/IsMagicMessage

    NAME
        IsMagicMessage -- Validate a MagicMessage.

    SYNOPSIS
        success = IsMagicMessage ( message );
        D0.L                       A0

        BOOL IsMagicMessage ( struct Message * );

    FUNCTION
        Check to see if the given message structure is actually a
        MagicMessage.  This may be used when you are receiving several message
        types from different sources at the same message port.

    INPUTS
        message -- pointer to a Message to check.

    RESULTS
        success -- TRUE if the message is a MagicMessage, FALSE if it is not.

    EXAMPLE

    NOTES

    BUGS

    SEE ALSO


magic.library/LockMagicImage                     magic.library/LockMagicImage

    NAME
        LockMagicImage -- Obtain a lock on a public MAGIC image.

    SYNOPSIS
        success = LockMagicImage ( magicHandle, type );
        D0.L                       A0           D0.L

        BOOL LockMagicImage ( struct MagicHandle *, LONG );

    FUNCTION
        Obtain a read or write lock on the specified public image.  You should
        always get a write lock before attempting to modify a public, so that
        two tasks will not try to modify an image at the same time.  It is also
        important to obtain a read lock before examining image data.

        If the specified image is not available to be locked, this function will
        wait until it becomes available.

    INPUTS
        magicHandle -- pointer to a valid image handle as obtained from
            OpenPublicImageA().

        type -- type of lock to obtain, LMI_Read or LMI_Write.

    RESULTS
        success -- TRUE if the lock was obtained, or FALSE on failure.  The
            function can only fail by supplying an invalid lock type.

    EXAMPLE

    NOTES

    BUGS

    SEE ALSO


magic.library/OpenMagicImageA                   magic.library/OpenMagicImageA

    NAME
        OpenMagicImageA -- Obtain access to a public MAGIC image.
        OpenMagicImage -- varargs stub to OpenMagicImageA().

    SYNOPSIS
        magicHandle = OpenMagicImageA ( magicImage, name, tagList );
        D0.L                            A0          A1    A2

        struct MagicHandle *OpenMagicImageA ( struct MagicImage *,
                                              char *, struct TagItem * );

        magicHandle = OpenMagicImage ( magicImage, name, ... );

        struct MagicHandle *OpenMagicImage ( struct MagicImage *,
                                             char *, ... );

    FUNCTION
        Attempt to open a public image for use by an application.  Once the
        image is opened, an application may access the image data either
        directly or through translation functions (the application should make
        sure to obtain an appropriate lock before accessing/modifying the
        image data).  The image handle returned is used in many other
        magic.library functions.

    INPUTS
        magicImage -- pointer to the MagicImage structure you want to open for
            your use.  If NULL, then the name parameter is used to determine
            the public image you want to open.

        name -- pointer to (case sensitive) NUL-terminated name of the public
            image you want to open.  If both the magicImage and name
            parameters are NULL, then the default (or active) public image
            will be returned.

        tagList -- tags used in opening the image:

                OMI_MsgPort:
                    (struct MsgPort *) Pointer to a message port which the
                    MagicServer program will use to send you messages
                    concerning this image (such as when to redraw, etc.).

                OMI_OwnerPort:
                    (struct MsgPort *) Only the owner of an image should use
                    this tag.  It is identical to OMI_MsgPort, but when the
                    owner of an image opens it (as it must do like anyone
                    else), it should use this tag instead.

    RESULTS
        magicHandle -- image handle used by other magic.library functions, or
            NULL if the image could not be opened for some reason.

    EXAMPLE

    NOTES
        Note that the owner of an image must also open it (ie. use
        OpenMagicImage after calling AddMagicImage).  This is so the owner
        will receive the same messages everyone else will.

    BUGS

    SEE ALSO


magic.library/PickMagicImageA                   magic.library/PickMagicImageA

    NAME
        PickMagicImageA -- Select MAGIC image from requester.
        PickMagicImage -- varargs stub to PickMagicImageA.

    SYNOPSIS
        magicImage = PickMagicImageA ( screen, tagList );
        D0.L                           A0      A1

        struct MagicImage *PickMagicImageA ( struct Screen *,
                                             struct TagItem * );

        magicImage = PickMagicImage ( screen, firstTag, ... );

        struct MagicImage *PickMagicImage ( struct Screen *, ... );

    FUNCTION
        Open a standard requester on the caller's choice of
        screen to allow the user to choose a MAGIC image.
        In the default case, all currently available MAGIC images
        will be shown, but tags may be specified to filter out
        certain images.

    INPUTS
        screen -- Screen on which to open, or NULL to open on the default
            public screen (ie. Workbench).  Note that the screen will be
            shifted up to make room for the requester if necessary.

        tagList -- Tags controlling the image list:

                PMI_MinWidth:
                    (LONG) Only show images whose width is at least this
                    value.

                PMI_MinHeight:
                    (LONG) Only show images whose height (in pixels) is at
                    least this value.

                PMI_MinDepth:
                    (LONG) Only show images whose depth (in byte planes) is at
                    least this value.  Can be used to filter out 8-bit
                    greyscale images.

                PMI_MaxWidth:
                    (LONG) Only show images whose width (in pixels) is less
                    than this value.

                PMI_MaxHeight:
                    (LONG) Only show images whose height (in pixels) is less
                    than this value.

                PMI_MaxDepth:
                    (LONG) Only show images whose depth (in byte planes) is
                    less than this value.  Can be used to filter out color
                    images.

                PMI_ShowSize:
                    (BOOL) If TRUE, display the sizes of images along with
                    their names.

                PMI_ShowOwner :
                    (BOOL) If TRUE, display the owner of images along with
                    their names.

                PMI_All :
                    (BOOL) If TRUE, show all available images without
                    filtering.

                PMI_ExcludeOwner:
                    (char *) Exclude all images that were created by the given
                    owner.  This can be used to filter out images created by
                    the caller.

    RESULTS
        magicImage -- Pointer to MagicImage selected by the user, or NULL if
            the user cancels the operation.  The image must still be opened
            before it can be used.

    EXAMPLE

    NOTES
        The TAG_SKIP and TAG_MORE tags are not supported.
        This function requires GadTools V37+.

    BUGS

    SEE ALSO


magic.library/PutMagicImageDataA             magic.library/PutMagicImageDataA

    NAME
        PutMagicImageDataA -- Write pixel data into a public MAGIC image.
        PutMagicImageData -- varargs stub to PutMagicImageDataA.

    SYNOPSIS
        success = PutMagicImageDataA ( magicHandle, yoffset, rows, tagList );
        D0.L                           A0           D0.L     D1.L  A1

        BOOL PutMagicImageDataA ( struct MagicHandle *, LONG, LONG,
                                  struct TagItem * );

        success = PutMagicImageData ( magicHandle, yoffset, rows, ... );

        BOOL PutMagicImageData ( struct MagicHandle *, LONG, LONG, ... );

    FUNCTION
        Copies image data from the caller-supplied buffers into the given
        MAGIC image, calling the image's translation function (set by the
        owner of the image).

    INPUTS
        magicHandle -- pointer to a valid image handle as obtained from
            OpenPublicImageA().

        yoffset -- topmost row to start copying from, starting from 0.

        rows -- number of rows of image data to copy.

        tagList -- tags describing the image data to get:

                GMI_Red:
                    (UBYTE *) Stores red image data, as supplied in the
                    caller's buffer, 1 byte per pixel.

                GMI_Green:
                    (UBYTE *) Stores green image data, as supplied in the
                    caller's buffer, 1 byte per pixel.

                GMI_Blue:
                    (UBYTE *) Stores blue image data as supplied in the
                    caller's buffer, 1 byte per pixel.

                GMI_RGB:
                    (UBYTE *) Stores RGB image data as supplied in the
                    caller's buffer, 3 bytes per pixel in the format
                    RGBRGBRGB...

                GMI_ARGB:
                    (UBYTE *) Stores RGB image data + alpha channel
                    information as supplied in the caller's buffer,
                    4 bytes per pixel in the format ARGBARGBARGB...

                GMI_Alpha:
                    (UBYTE *) Stores alpha channel information as supplied in
                    the caller's buffer, 1 byte per pixel.

    RESULTS
        success -- TRUE if all data was succesfully copied, or FALSE if
            something failed.

    EXAMPLE

    NOTES
        You should always obtain a write lock before writing image data!

    BUGS

    SEE ALSO


magic.library/RedrawMagicImage                 magic.library/RedrawMagicImage

    NAME
        RedrawMagicImage -- Refresh display of MAGIC image.

    SYNOPSIS
        RedrawMagicImage ( magicHandle, left, top, width, height );
                           A0           D0.L  D1.L D2.L   D3.L

        void RedrawMagicImage (struct MagicHandle *, LONG, LONG, LONG, LONG);

    FUNCTION
        Signal all the openers of the given image to refresh their displays of
        the image.  All openers are signalled EXCEPT THE ONE THAT CALLED THIS
        FUNCTION!

        This function is asynchronous, meaning it returns immediately.

        This works by sending a MMSG_REDRAW to all tasks that have opened this
        image, except the task calling this function.

    INPUTS
        magicHandle -- pointer to a valid image handle as obtained from
            OpenMagicImageA().

        left, top -- upper left corner of area to redraw, starting from 0,0 in
            the far upper left of the image.

        width, height -- size of the area to redraw, in pixels.

    RESULTS
        None.

    EXAMPLE

    NOTES
        Due to possible bottlenecks when redrawing several displays at once,
        an application should lower its priority when redrawing due to a
        MMSG_REDRAW message.

    BUGS

    SEE ALSO


magic.library/RemMagicImage                       magic.library/RemMagicImage

    NAME
        RemMagicImage -- Remove MAGIC image from public scrutiny.

    SYNOPSIS
        success = RemMagicImage ( magicImage );
        D0.L                      A0

        BOOL RemMagicImage ( struct MagicImage * );

    FUNCTION
        Remove the given MagicImage from the public list of images.  Only the
        owner of an image should use this function.  Once the image is removed
        it may be freed at will.

        If other applications still have a handle on this image (ie. they have
        opened it), the magic server will send a MMSG_CLOSE to all the
        applications that have it open so they will release the image.

    INPUTS
        magicImage -- pointer to a MagicImage structure to be removed.

    RESULTS
        success -- TRUE if the image was removed, or FALSE if the image could
            not be removed for some reason.

    EXAMPLE

    NOTES
        The owner of an image *MUST* close the image BEFORE calling
        RemMagicImage or a deadlock will occur.

    BUGS

    SEE ALSO


magic.library/RestoreMagicImage               magic.library/RestoreMagicImage

    NAME
        RestoreMagicImage -- Request owner to restore undo copy of image.

    SYNOPSIS
        success = RestoreMagicImage ( magicHandle );
        D0.L                          A0

        BOOL RestoreMagicImage ( struct MagicHandle * );

    FUNCTION
        Send a request to the owner of a MAGIC image to restore the latest
        undo copy into the image.

        The function does not return until the restoration is complete.

        This works by sending a MMSG_RESTOREUNDO message to the owner of the
        image.

    INPUTS
        magicHandle -- pointer to a valid image handle as obtained from
            OpenMagicImageA().

    RESULTS
        success -- TRUE if the copy was successfully restored, or FALSE if
            something went wrong.

    EXAMPLE

    NOTES
        The owner of an image may choose to ignore the request.

        The owner of an image should never call this function, or a deadlock
        will occur.

    BUGS

    SEE ALSO


magic.library/SaveMagicImage                     magic.library/SaveMagicImage

    NAME
        SaveMagicImage -- Request owner to save an undo copy of image.

    SYNOPSIS
        success = SaveMagicImage ( magicHandle, left, top, width, height );
        D0.L                       A0           D0.L  D1.L D2.L   D3.L

        BOOL SaveMagicImage ( struct MagicHandle *, LONG, LONG, LONG, LONG );

    FUNCTION
        Request the owner of the given MAGIC image to store a copy of the area
        indicated in a temporary "undo" buffer which may be restored later.
        The owner of an image is responsible for making and restoring undo
        copies.

        This function does not return until the save is complete.

        This works by sending an MMSG_SAVEUNDO message to the owner of an
        image and waiting for a reply.

    INPUTS
        magicHandle -- pointer to a valid image handle as obtained from
            OpenMagicImageA().

        left, top -- upper left corner of area to save, starting from 0,0 in
            the far upper left of the image.

        width, height -- size of the area to save, in pixels.

    RESULTS
        success -- TRUE if the undo copy was successfully saved, or FALSE if
            it was not.

    EXAMPLE

    NOTES
        The owner of an image may choose to ignore the request, or save the
        full area of an image instead of the requested subset.

        The owner of an image should never call this function, or a deadlock
        will occur.

    BUGS

    SEE ALSO


magic.library/SetDefaultMagicImage         magic.library/SetDefaultMagicImage

    NAME
        SetDefaultMagicImage -- Select the "default" MAGIC image.

    SYNOPSIS
        success = SetDefaultMagicImage ( magicImage );
        D0.L                             A0

        BOOL SetDefaultMagicImage ( struct MagicImage * );

    FUNCTION
        Set the "default" image that will be opened when no parameters are
        given to OpenMagicImageA().  This function is reserved for "MAGIC
        image manager" type programs, and shouldn't be used arbitrarily.

    INPUTS
        magicImage -- pointer to a MagicImage structure as returned by
            AllocMagicImageA() or obtained through the MagicBase list.

    RESULTS
        success -- TRUE if the image was successfully set, or FALSE on
            failure.

    EXAMPLE

    NOTES

    BUGS

    SEE ALSO


magic.library/UnlockMagicImage                 magic.library/UnlockMagicImage

    NAME
        UnlockMagicImage -- Release a lock on a public MAGIC image.

    SYNOPSIS
        UnlockMagicImage ( magicHandle );
                           A0

        void UnlockMagicImage ( struct MagicHandle * );

    FUNCTION
        Releases either a read or write lock that you have previously obtained
        on an image.  The image is then free to be used by others or removed.

    INPUTS
        magicHandle -- pointer to a valid image handle as obtained from
            OpenPublicImageA().

    RESULTS
        None.

    EXAMPLE

    NOTES

    BUGS

    SEE ALSO


magic.library/UpdateMagicImage                 magic.library/UpdateMagicImage

    NAME
        UpdateMagicImage -- Signal image openers of size change.

    SYNOPSIS
        UpdateMagicImage ( magicHandle );
                           A0

        void UpdateMagicImage ( struct MagicHandle * );

    FUNCTION
        Signal all openers of an image that the owner has changed the physical
        dimensions of the image (eg. width, height, depth).  Only the owner of
        an image may (safely) change the physical dimensions.

        This function does not return until all openers have updated.

        This works by sending a MMSG_UPDATE to all openers of the image
        (except the one calling this function!).

    INPUTS
        magicHandle -- pointer to a valid image handle as obtained from
            OpenMagicImageA().

    RESULTS
        None.

    EXAMPLE

    NOTES

    BUGS

    SEE ALSO


magic.library/zzzzz
