@DATABASE "Hunk"
@$VER: Hunk.guide 1.03 (16.07.2022)
@(C) THOR Software
@SMARTWRAP
@AUTHOR Thomas Richter
@NODE MAIN "Hunk Guide"
@INDEX INDEX
                        The Hunk Processor Guide

Guide Version 1.03                              Hunk Version 2.22

                        © 2000 THOR-Software

_____________________________________________________________________________


Table of Contents


I.      @{"The Licence" link Licence}

                The THOR Software Licence, as always


II.     @{"What is it: Overview" link Overview}

                What it does...


III.    @{"Requirements" link requirements}

                You need to provide...


IV.     @{"Installation" link Install}

                How to install Hunk.


V.      @{"Starting up: A Tutorial session" link Tutorial}

                A small step by step introduction.


VI.     @{"Hunk Processor Menus" link Menus}

                Details about the menu.


VII.    @{"Hunk Version History" link History}

                What happened before...


@{CODE}

        © THOR-Software


        Thomas Richter
        Rühmkorffstraße 10A

        12209 Berlin

        Germany

EMail:  thomas.richter\@alumni.tu-berlin.de

@{BODY}

Hunk is FREEWARE and copyrighted © 1991-1998 by
Thomas Richter. No commercial use without permission of the
author.


The GUIDE (this file) is copyrighted © 1998 Thomas Richter, as well!
However, it is NOT freely distributable! Read the @{"licence" link Licence}!


@ENDNODE
@NODE Licence "The THOR-Software Licence"

                      The THOR-Software Licence (v3, January 2nd 2021)

This License applies to the computer programs known as "The Hunk Processor",
or short "Hunk". The "Program", below, refers to such program. The
"Archive" refers to the package of distribution, as prepared by the author
of the Program, Thomas Richter. Each licensee is addressed as "you".

The Program and the data in the archive are freely distributable
under the restrictions stated below, but are also Copyright (c)
Thomas Richter.

Distribution of the Program, the Archive and the data in the Archive by a
commercial organization without written permission from the author to any
third party is prohibited if any payment is made in connection with such
distribution, whether directly (as in payment for a copy of the Program) or
indirectly (as in payment for some service related to the Program, or
payment for some product or service that includes a copy of the Program
"without charge"; these are only examples, and not an exhaustive
enumeration of prohibited activities).


However, the following methods of distribution involving payment shall not
in and of themselves be a violation of this restriction:

(i) Distributing the Program on a physical data carrier (e.g. CD-ROM,
    DVD, USB-Stick, Disk...) provided that:

a) the Archive is reproduced entirely and verbatim on such data carrier,
   including especially this licence agreement;

b) the data carrier is made available to the public for a nominal
   fee only, i.e. for a fee that covers the costs of the data carrier,
   and shipment of the data carrier;

c) a data carrier with the Program installed is made available to the
   author for free except for shipment costs, and

d) provided further that all information on said data carrier is
   redistributable for non-commercial purposes without charge.


Redistribution of a modified version of the Archive, the Program or the
contents of the Archive is prohibited in any way, by any organization,
regardless whether commercial or non-commercial. Everything must be kept
together, in original and unmodified form.



Limitations.


THE PROGRAM IS PROVIDED TO YOU "AS IS", WITHOUT WARRANTY. THERE IS NO
WARRANTY FOR THE PROGRAM, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. THE ENTIRE
RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD
THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
SERVICING, REPAIR OR CORRECTION.


IF YOU DO NOT ACCEPT THIS LICENCE, YOU MUST DELETE THE PROGRAM, THE ARCHIVE
AND ALL DATA OF THIS ARCHIVE FROM YOUR STORAGE SYSTEM. YOU ACCEPT THIS
LICENCE BY USING OR REDISTRIBUTING THE PROGRAM.

                                                        Thomas Richter

@ENDNODE
@NODE Overview "What the Hunk Processor is used for"

The Hunk Processor is a development tool for editing executable files in
a "post production phase". Therefore, a basic knownledge of the "hunk"
structure of an Amiga binary file is required - no information about it is
contained in this guide, check the @{"literature" link books} for these
AmigaDos internals. Thus, it's mainly a tool for the Amiga Expert and not
designed for the "average user".


With the hunk processor, you can


@{CODE}

- edit and modify the hunk structure of amiga binaries
- change the memory types of hunks, i.e. "Hunk" replaces the "ATOM" tool.
- merge hunks or relocation information to shorten binaries or to overcome
  compiler or linker limitations.
- add or remove relocation entries to apply bug fixes to binaries in an
  easy and powerful way.
- optimize binaries by replacing commonly used subroutines or code sequences
  with more advanced ones.
- the whole process can be automized by a powerful ARexx interface.

@{BODY}

Limitations: Yes, there are some.


- The Hunk Processor will remove all debug information from a binary,
without asking you. Mainly because it can't keep it consistent to the
changes made. That's usually no limitation since this information is not
needed to run the program in general. Some programs keep private data there,
as to store registration information and more.


- The Hunk Processor can't be used to edit "overlayed" files. Their number
is very limited indeed, the whole AmiNet doesn't carry much more than one or
two of them.


- The Hunk Processor doesn't support executables with "resident library
references". These binaries are no longer supported by AmigaDOS 2.00
anyways, and haven't been used in any program I know before.


@ENDNODE
@NODE Requirements "Requirements"
Requirements to be able to run "Hunk".

- First, an Amiga computer. Every model, every OS will do. "Hunk" will be
happy even with Os 1.2.


- Memory: Yes, you will need some. Hunk is a relatively small program, but
the complete binary to be edited with Hunk must fit into memory. Thus, the
required memory depends mainly on the size of the executables you want to
modify.


- Knowledge: "Hunk" is not for the "average user". You need to understand
the structure of an Amiga executable files, how it is build out of several
"hunks" and their meanings. No information about this structure is contained
in this guide, check the @{"literature" link books}.


- Additional programs: ARexx would be fine, it's at least required to get
all of the power. It's included in the Amiga Os distributions 2.04 and up.
If you need Hunk to patch binaries, a monitor and a linker would be fine,
too.

@ENDNODE
@NODE books "Recommended readings"

A remarkably good documentation about the hunk structure of binaries can be
found here:


Ralph Babel:    The Amiga Guru Book             (Taunusstein 1993)


It covers AmigaDos up to revision 2.1. No changes have been made to the
hunk structure since then, so it's still up to date for the needs of "Hunk".



A remarkably bad source, but still the "official" documentation is:


Bantam Books:   The AmigaDOS Manual (3rd Edition) (The Bantam Amiga Library)


Contains quite a lot of little tiny errors here and there and doesn't
explain all up to detail as it should. Don't buy it, but if you see it in a
library, it's worth a look.



Another unuseful book is the following, for german readers:


Dittrich,Gelfand,Schemmel:      Amiga Intern, Band I    (DataBecker 1988)


This book is rather old, and the hunk chapter is more or less a german
translation of the ADos manual from Bantam books. Don't buy it unless you
get it really cheap or see it in a library.


You might find various docs about Hunks on the "Aminet", but I can't tell
much about them because I haven't tried them. (Oops, except my Overlay.doc.
But that won't help you with Hunk because it can't handle overlays...)

@ENDNODE
@NODE Requester "The Hunk File Requester"
"Hunk" doesn't use standard ASL or ReqTools requesters for its use. The only
reason for that is that neither ASL nor ReqTools was available at the time
"Hunk" was created, thus, it comes with it's own file requester - which is
by no means harder to use.


If "Hunk" requests a selection of a file, the whole top part of the "Hunk"
screen is used for the requester, containing the file list. The bottom
left/right scroller is not used for it, however.

The rightmost scroller and arrow pair adjust the visible selection of files
in that window.

The entries in the file list fall into three cathegories:


o) @{FG Shadow}Dark text@{FG Text}. These are ordinary files. If you pick
one of these with the mouse, the requester is aborted and the selected file
is loaded.


o) @{FG Shine}White text@{FG Text}, meaning directories. If you pick one of
those, "Hunk" will enter the selected directory.


o) @{FG Fill}Third color@{FG Text} (grey, blue or whatever your favourite
screen colors look like) indicate "special" entries Hunk added to the list
for your convenience. Depending which part of the file system tree you're
scanning, Hunk presents the following extra entries:


@{FG Fill}\ (Parent)@{FG Text}: This enters the parent directory of the
current directory.


@{FG Fill} (Volumes)@{FG Text}: Show the list of available volumes and
assigns. Volume entries are shown first, in @{FG Shine}white
color@{FG Text}, assigns are sorted in below in @{FG Shadow}dark color @{FG Text}.
Selecting either of them will enter the requested volume or assign.


Hunk adds the @{FG Fill}(Volume)@{FG Text} entry only to the top directory
of a volume, thus if no parent is available. You also get the volume list
quickly by erasing the contents of the "Drawer" gadget below the file list
and pressing @{B}RETURN@{UB}.


@{FG Fill}: (Root)@{FG Text}: This is a special entry "Hunk" adds to the
volume list. It enters the root directory of the volume "Hunk" was started
from. You get it, too, by entering a single colon ":" into the "Drawer"
gadget below the file list.


The file requester contains two additional gadgets right below the
left/right scroller. The left one, "Drawer" contains the name of the current
directory whose contents is shown above. You may enter the name of the
drawer you'd like to visit right here, for quick access, and press
@{B}RETURN@{UB}.


The gadget to the right, called "File" is blank whenever "Hunk" requests a
file. Once you made your selection, Hunk inserts the name of the selected
file here. If you know the file name you'd like to modify and don't want to
scan the list on top, just enter it here.


If "Hunk" shows the requester to save a file, you're free to enter a
different file name here, to change the file name and save the file under
another name.


@ENDNODE
@NODE Install "Installation"
Installation of the Hunk Processor is rather easy: Just copy the complete
"Hunk" drawer like it came with the distribution wherever you want to keep
it. There's no need to build assigns nor to make any changes to your startup
sequence.


You may want to store this guide either in the "Hunk" drawer together with
the program, or keep it elsewhere with all other documentations you've got.


It is however recommended to keep the Hunk ARexx scripts and the external
optimizers in the same directory where Hunk was copied to.

@ENDNODE
@NODE Guidelines "Which programs should be processed?"
Most programs will work happely with a changed hunk structure, but not all.
There's no general guide line which files work and which won't, it's all a
matter of experience. Just go and try. Some general rules:


Do @{B}not@{UB} apply any changes to:


- Compressed ("packed") files, as most standard unpackers require the
precise hunk structure as it is. As an example, "PowerPacked" files
shouldn't be processed.


- Programs that can be launched and stay resident in the background. Some of
them require their hunk structure, too, for starting up. "BenchTrash" is one
example.


- Pre-2.0 CLI commands like the BCPL versions of "Copy", "Dir" and "Ed". The
standard BCPL startup code requires the hunk linkage as it is. The 2.0
"C" versions can be modified without this problem.


- Some other files show problems whenever certain modifications are made.
AmigaBasic is one example: The hunk linkage is required for certain
background processes that handle the "Bob animation" for example.


- Programs that work with self-modifying code. If you optimize the code of
these programs, you're likely to break them. There's no general rule which
programs do and which don't. Self modifying code is a "no-no" for higher
advanced CPUs like the 68040 and 68060 anyways.

@ENDNODE
@NODE Failures "Hunk failure codes"
As every other complex program, Hunk creates failure codes that are
displayed in the failure requester. These failure codes are passed to an
external ARexx host as well.


@{B}Cathegory one: Arexx failure codes@{UB}

These error codes are generated by invalid arguments to ARexx functions:

@{CODE}
        3       Out of memory.

        9       String too long.
                The ARexx message was too long, or contained an oversized
                string.

        10      Invalid message packet.
                Hunk received an illegal message at its message port.

        14      Required library not found.
                An ARexx failure code generated if a function library was
                not available. Not produced by Hunk itself.

        15      Function not found.
                Hunk received an unknown ARexx command.

        17      Wrong number of arguments.
                The requested command takes more or less arguments than
                provided.

        18      Invalid argument to function.
                The argument provided is not of the correct type, or not
                in the required range.

        19      Function not available.
                The current internal state of Hunk makes this function
                currently unavailable - like requesting a hunk related
                function without having loaded a binary.

        40      Invalid variable name.
                The name of a variable - possibly to place the result of
                an operation in - was malformed.


        41      Invalid expression.
                The argument was syntactically malformed, i.e. a string
                where a number was required.

        46      Boolean value not 0 or 1.
                A boolean argument was requested, but the argument provided
                was neither 0 nor 1.


@{B}Cathegory two: Hunk failure codes@{UB}

Generated by internal error conditions of hunk itself.


        50      Out of memory.

        51      Can't open screen & window.
                Hunk failed to open its screen and its window.
                Probably a font was unavailable? Hunk requires the
                Ruby.15 font for its title.

        52      Unexpected EOF.
                The executable run out of data - it's probably damaged.

        53      Bad objectcode format.
                The objectcode was illegal, probably an overlayed
                file, a file that uses resident libraries or
                special memory attributes.

        54      Hunks not mergeable.
                You tried to merge one hunk to a second hunk that contains
                blank space at its end.

        60      Can't open printer.
                Hunk can't open the printer for dumping the hunk list.

        61      Printer fault.
                Some printer problem showed up. It's probably out of
                paper or offline.

        64      Syntax error.
                A syntax error in a .hop file has been detected. A
                more specific failure code is given in the message
                window. Check the @{"hunk optimizer" link HopFiles} section
                for details.

        65      Phase error.
                A variable in a .hop file was used in a different way
                than it was defined in first place. Check again the
                @{"hunk optimizer" link HopFiles} section for details.



@{B}Cathegory three: AmigaDos failure codes@{UB}

These failure codes are generated by the AmigaDOS and indicate I/O failure
conditions:

        103     Out of memory.


        202     Object in use.
                You tried to write on top of a file that is
                currently in use by a different application.

        203     Object exists.
                You tried to create an object that already exists,
                like you tried to create a file of a name of an
                already existing directory.

        204
        205
        206     Object not found.
                You specified a file or directory name that was
                either invalid or not existent.

        212     Object wrong type.
                You selected a directory where a file was required,
                or the other way round.

        213     Disk not validated.
                You tried to write to a disk that is not yet
                validated.

        216     Directory not empty.
                Somebody tried to remove a directory which is not
                yet empty.

        218     Device not mounted.
                You selected a volume that is currently not inserted.

        221     Disk is full.
                You tried to write an executable to volume that is
                full.


        214
        222
        223     Write protected.
                Hunk can't write to a specified object because it was
                write protected - either by software or by hardware.

        225     Not a dos disk.
                The disk you tried to read from or write to is not
                a valid AmigaDos disk and can't be accessed from the
                filing system.

        226     No disk in drive.
                No disk was inserted.


        xxx     Unknown error.
                An error unknown to Hunk occurred.

@ENDNODE
@NODE HunkReq "The Hunk requester"
As soon as "Hunk" loaded a binary, the topmost requester changes from a file
requester to a hunk requester. It contains informations about all hunks in
the file just loaded.

Since the status line is too long to fit on the screen completely, you need
to use the left/right scroller and arrow gadgets below the requeser to
scroll it to the left or right of the screen.


Information for each hunk:


o) Hunk number:         This is just the number (= index) of the hunk. Hunks
are numbered from zero up.


o) Merge destination:   If the hunk is going to be merged to another hunk,
this information is printed right to the hunk number. This is also called a
"merge link". Selecting "Start Merging" from the
@{"Proc Menu" link ProcMenu} will perform the linkage.


o) Hunk Type:           Can be either CODE, DATA or BSS. CODE is supposed
to be constant space, and does therefore not necessarely contain program
CODE. Some compilers place constant strings in this section, too. DATA is
usually alterable memory that contains global variable definitions and other
data that is going to be changed by the program. BSS is initialized
clear blank space. Since the Amiga Os does not protect memory in any way, a
program might easely alter its own CODE segment as well, even though I would
call that bad style.


o) Size:                The total size of the hunk, i.e. the number of bytes
it occupies in memory, without the hunk linkage and the hunk length fields.


o) Data:                The total size of defined data in this hunk. A hunk
may define less bytes than it occupies in memory, the remaining bytes are
allocated from memory, but not loaded from disk. They are called...


o) BSS:                 Number of undefined bytes in this hunk, thus the
difference between "Size" and "Data". This memory is cleared by AmigaDOS
2.00 and later, but left uninitialized by ADos 1.2 and 1.3. Be careful about
using it - as a hunk declared as "BSS" explicitly is always cleared.


o) Memory Type:         The type of memory that should be allocated for the
program. Can be PUBLIC, CHIP or FAST. FAST should not be used since PUBLIC
defaults to FAST if FAST mem is available. CHIP mem is for graphics and
other buffers that needs to be accessed by the custom chips.


@{B}WARNING@{UB}:       Hunk does not yet support other types of memory,
even though other memory attributes can be encoded into the hunk structure.
I haven't seen a single program that requires these special memory types,
though.


As a final remark, let me add that the name "PUBLIC" is probably a bit
misleading. It should actually say "ANY", as this is the correct memory
type. I haven't changed that for tradition. (-:


o) Memory location:     Prints where "Hunk" keeps the hunk data in memory.
This information is only useful if you're going to change the binary with a
monitor. It's probably more useful to build an ARexx script to extract this
information.


The background color of the text in the hunk requester encodes the "merge
links" of the hunk, i.e. whether this hunk is going to be linked to a
different hunk or used as a destination hunk for merging.


@{FG Shine}White color@{FG Text} indicates that this hunk is a destination
hunk of a merge operation, i.e. other hunks will be merged to this hunk once
the actual merging is performed with the @{"Proc menu" link ProcMenu}.


@{FG Fill}Blue or grey color@{FG Text} is used for hunks that are going to
be merged with some different hunk, i.e. with a hunk underlined in white.
They will vanish as soon as the merge operation is complete.


@ENDNODE
@NODE Tutorial "Starting up: A Tutorial session"
For people that can't wait, here's a tutorial session of "Hunk". It shows
how an executable file can be compressed and optimized using the powers of
"Hunk".


o) @{"Install" link Install} the hunk processor, if not already done.


o) Select a "victim" to be processed by "Hunk". A very fruitful program in
this sense is "AmigaBasic", if you still have it. Never mind if you don't,
just pick any executable - "Hunk" itself works fine, too. The tutorial has
been setup with "Hunk" as its own victim, so better try with this file
first.


o) Make a copy of the program, since we're going to mess around a bit with
it. Place this copy in the "Ram Disk".

@{B}This is a general guide line. Never ever (!) make any modifications to a
file without making backup first. "Hunk" may easely break binaries.@{UB}

I can't give a general rule which programs will continue to work and which
won't, but some @{"guidelines" link Guidelines} are available.


o) Run the Hunk Processor.


o) Select "Ram Disk" from the @{"file requester" link Requester} on the top
half of the screen. Hunk will now load the root directory of the RAM: drive.


o) Pick the program you want to modify from the list, i.e. select "Hunk".


The Hunk Processor loads now the requested binary - or shows a
@{"failure requester" link Failures} if this isn't possible.

Status information about the file is shown in the bottom part of the screen,
the "message window".


As soon as Hunk as loaded the binary, let's check what "Hunk" found out
about the file:


The top requester has been modified into a @{"hunk requester" link HunkReq}.
It shows all status informations about the hunks of the executable file.
Since there's too much to know about these hunks, the status extends to the
right of the requester and can be made visible by scrolling the contents of
the requester to the left with the scroller and arrow gadgets below the hunk
list.

If the file contains too many hunks to be visible in the requester at once,
scroll it vertically with the scroller gadget and the arrows at the right
edge of it.


o) Scroll the requester to the left and right. Check out what's to be known
about the hunks of the file: The hunk number, its type and size, the number
of defined data in this hunk, the size of blank space of the hunk, the
memory attributes and where it has been placed in memory. Details about this
information can be found @{"here" link HunkReq}.


We'll now merge the data hunk of the file with the code hunk, and attach the
BSS hunk to their combination, too. That will avoid relocation information
and will shorten the file.


o) Select "Set Hunk To Merge To" from the "Edit" menu, that is the third
menu from the left. This tells "Hunk" that you want to pick a hunk from the
list - as the message window below tells you.


o) Click on the first hunk "Hunk #: 0" in the requester window.


This line will be printed with a white background now, to indicate that this
hunk is the destination of a merge operation.


Hunk is now ready to accept the hunks to be merged to this hunk.


o) Click on the last hunk "Hunk #: 3".


This hunk line will be printed with a special (mostly grey or blue)
background, in the same colour as the message window. The text itself
changes now, too, and contains information where to link this hunk to.


We can't add the "BSS" hunk # 2 at the same step since then "Hunk" will
try to merge data and bss hunk the wrong order - BSS hunk first, Data hunk
second. "Hunk" will warn you if you try to anyways.


Thus, we need to perform two merging operations.


o) Select "Start Merging" from the @{"Proc Menu" link ProcMenu}.


Hunk prints status information about the merging process.


Once it is done, the @{"hunk requester" link HunkReq} showns only
three hunks instead of four.


o) Pick "Set Hunk To Merge To" of the @{"Edit Menu" link EditMenu}.


o) Select "Hunk 0" from the requester menu.


o) Select the BSS hunk, "Hunk 2" from the requester list.


Select "Start Merging" from the @{"Proc Menu" link ProcMenu} again.


Hunk is now merging the BSS space to the combined code/data hunk.


o) Scroll the hunk requester to the left to be able to read the hunk "BSS"
size: It's no longer zero, since it contains now the former BSS hunk.


@{B}Warning@{UB}: There's a tiny difference between the BSS hunk and the BSS
space assigned to a hunk, at least for AmigaOs 1.2 and 1.3. Whereas the
former hunk is always cleared when the program is loaded, the BSS space at
the end of a data or code hunk is not cleared by OS revisions before 2.00.


@{B}Warning@{UB}: As I said, merging without much knowledge is a hairy
buisness. You just broke the copy of "Hunk" in the ram disk... The current
startup code requires the hunk linkage for the BSS hunk, at least. Since we
removed it now, this copy of Hunk will crash your system on startup.
Anyways, don't care about this problem right now.


o) We don't want to merge Hunk #1 with Hunk #0 because it requires ChipMem.
We could, in principle, merge Hunk #1 with Hunk #0 and change the memory
type of the resulting hunk to "CHIP", but this will spoil some graphics
memory and slow down the code.


There's however another step we can perform:


o) Since most of the objects referenced in the code of hunk #0 are now in
hunk #0 itself, we might ask hunk to optimize the code a bit and replace the
addressing of these objects from absolute to relative. This will save
another bunch of bytes of relocation information. Two different optimization
methods are available:


- The build-in optimizer. It's rather fast, but doesn't cover all
optimizations possible. Only the most common ones are present. It's also not
extendable nor controlable.


- External optimizers in the form of ".hop" = "Hunk OPtimizer" scripts in a
special scripting language. These are extendable by the user and rather
flexible. Check @{"here" link HopFiles} for details.


We select here - mainly for educational purposes - the external optimizer
package.


o) Select "Apply Patch..." from the "Proc" menu.


Hunk loads now the contents of the "Hoppers" directory of its home
directory; it shows a list of available patches. Most of them patch standard
math libaries to extended 68020 routines.


o) Locate the "General.hop" file and click on it.


Hunk processes the file - in two steps, first parsing and then applying the
patch - and is able to safe as much as 1000 bytes - mainly in unnecessary
relocation information.


o) As we're done now, you can safe the file to the RAM disk. Select "Save"
from the "Project" menu.


This ends the tutorial session.


@{B}Just a final warning@{UB}: Don't try to run the modified version of
"Hunk" - that will most likely crash your system. As I wrote "Hunk", I know
which hunk information is required and which isn't. In this case, the BSS
segment linkage is required and shouldn't be removed.

@ENDNODE
@NODE Menus "Hunk Processor Menus"
Here's the list of available menus and their usage:

        @{"The Project Menu" link ProjMenu}

        Used for loading and saving of binaries, and

        launching of ARexx scripts.


        @{"The Proc Menu" link ProcMenu}

        Process the loaded executable.


        @{"The Edit Menu" link EditMenu}

        Edit the merge links, show the relocation

        information.


        @{"The Reloc Menu" link RelocMenu}

        Edit the relocation lists of a hunk, add and

        remove relocation entries and more.


        @{"The Settings Menu" link SettingsMenu}

        Adjust the @{"AutoMerger" link AutoMerger} and

        other preferences.


@ENDNODE
@NODE ProjMenu "The Project Menu"
The project menu loads and saves the executable files to be processed by
hunk, prints their structure, runs ARexx scripts and quits Hunk.


@{B}Open...@{UB}


Load a binary, selected by the @{"file requester" link Requester}.
Cancel the current project.


@{B}Revert@{UB}


Revert all changes made, i.e. reload a changed binary and undo all changes
made.


@{B}Save@{UB}


If a project has been loaded, save it back to disk using its old name. It
aborts the current project, too, as work has been finished.


@{B}Save As...@{UB}


Presents the @{"file requester" link Requester} again to pick up a new name
for the project. You might either select a name from the requester, or enter
a new name into the "Drawer" or "File" gadget of the file requester.


@{B}Print@{UB}


Prints the hunk structure of the current project, if one has been loaded.
The relocation entry list is not printed because it is usally too long to be
useful. If this is needed, try the "PrintReloc.rexx"
@{"script" link IncludedScripts} instead.



@{B}ARexx Command...@{UB}


Opens the @{"file requester" link Requester} again and shows the "Rexx"
drawer of the distribution. Pick an ARexx script from the requester to
perform more complicated operations on the project. Hunk changes the
"Project" menu a bit as soon as the file requester gets active, select
"Cancel" (Amiga-Q) from this changed project menu to abort the operation.


Check also:     @{"Included scripts" link IncludedScripts} and

                @{"The ARexx interface" link ARexxInter}.


@{B}About@{UB}


Shows the version information.


@{B}Quit@{UB}


Aborts the Hunk Processor.


@ENDNODE
@NODE ProcMenu "The Proc Menu"
The Proc (or Process) window performs and launches several operations on the
hunk data.


@{B}Relocate Code@{UB}


Relocate the code loaded, i.e. apply the relocations found in the RELOC
hunks of the executable file. The result is that code in memory is in a form
that is ready to execute. Useful if you want to run or scan parts of the
code with a monitor.


@{B}Delocate Code@{UB}


Undoes the relocation. Hunk will revert the changes made with "Relocate" and
insert only offsets relative to other hunks instead of absolute addresses.
The resulting code cannot be run, but is easier to modify.


See also: @{"How to patch in a subroutine" link SubPatch}


@{B}Optimize@{UB}


Run the internal optimizer on all CODE hunks of the project. It removes most
absolute references by replacing the instructions with PC-relative variants
if possible. Quite the same patches are available as ".hop"
@{"script" link HopFiles}, but the internal optimizer is usually much
faster.


@{B}Warning@{UB}: Applying patches might break several executables, even
though Hunk patches properly. The reasons are for example usage of self
modifying code. (Yuk!).



@{B}Apply Patch...@{UB}


Shows again a @{"file requester" link Requester} of the "Hoppers" directory.
These @{"script files" link HopFiles} encode several optimizations and other
automized patches that can be applied to an executable. If you pick one of
these files, "Hunk" will parse them and perform the patches encoded in this
file.

You can abort this requester by selecting "Cancel" from the "Project Menu",
which has been modified for this operation.


See also: @{"External Hunk OPtimizers" link HopFiles}.



@{B}Warning@{UB}: The same warning about modifying programs with patches as
above applies again. Don't try it unless you know what you're doing, and
always keep a backup of the program.



@{B}Start Merging@{UB}


Merges the hunks selected for merging by the @{"Edit Menu" link EditMenu}.
"Hunk" will automatically change the relocation data if required, correct
the offsets of the hunks in the merged data and merge the relocation list of
the resulting hunks.



@{B}Set Hunk Type to@{UB}


Change the hunk type manually. First, select the desired new hunk type from
the sub menu of this item, then click on the hunk entries of the
@{"hunk requester" link HunkReq} whose type you want to change.


@{B}Warning@{UB}: Changing a hunk type from CODE or DATA to BSS or vice
versa is probably not a very smart idea since the data in the hunk will get
lost or uninitialized data will be created.


Changing of the hunk type will not make any difference as long as the
project is still loaded. Save it to disk to see a difference.


@{B}Warning@{UB}: The current AmigaDOS doesn't handle CODE and DATA hunks
different in any way. There's however no reason to mess with these types.



@{B}Set Hunk Memory to@{UB}


Changes the memory attribute flags of several hunks. Select as a first step
the desired memory type from the sub menu of this item, then click on the
hunks in the @{"hunk requester" link HunkReq} whose memory type you want to
change.


"PUBLIC" memory matches all types and should probably called "ANY" instead
of "PUBLIC" (this is a historical convention used here). If FastMem is
available, the hunk will be loaded to fast mem.


"CHIP" memory is required if the custom chips need access to this memory,
namely in-line graphics, hardware disk buffers, sprite definitions and
hardware sample data must be loaded in this memory type. Some ancient
programs don't set this bit correctly.

Thus, "Hunk" can be used as a more comfortable "ATOM"-like utility.


"FAST" memory is exclusively addressable by the CPU. There's most likely no
reason to specify "FAST" instead of "PUBLIC" since the later defaults to
"FAST" anyways if some fastmem is available.



@{B}Set Hunk Data Size@{UB}


Used to change the size of defined data in a hunk. Select this menu item as
first step, then pick up the hunks from the
@{"hunk requester" link HunkReq} whose size you'd like to adjust.


@{B}Warning@{UB}: There's usually no need for this operation unless you're
sure what you're doing. Increasing the size will result in undefined data
contained at the hunk end, making the hunk shorter will result in loss of
data.

Another caveat of this operation is that it will only change some
administration structures inside of the hunk processor, no actual data
moving or extending of the hunk memory is performed. To see any effect
of this operation, save the changed executable first and re-load it again.



@{B}Set Hunk Bss Size@{UB}


Change the size of blank space at the end of the hunk. Select this menu
item, then pick the hunk(s) from the @{"hunk requester" link HunkReq} whose
BSS size you'd like to adjust. The Hunk BSS memory is allocated by the DOS
when loading the program from disk, but not defined in the file. ADos 2.0
initializes this space with zero, unlike ADos 1.3. So be a bit careful with
this hunk-inside BSS space, use a BSS segment instead if you need some space
that is definitely initialized with zeros - as BSS segments are properly
zeroed by every OS version.


@{B}Warning@{UB}: This operation doesn't have any effect to the actual data
in memory. It changes only some administration structures of "Hunk". To see
any effect, save the file back to disk if you're done, then reload it.



@{B}Strip Trailing Zeros@{UB}


Removes trailing zeros of a DATA or CODE hunk and declares that part as
"BSS" section of the hunk. Thus, an automized "Set BSS Size" option.

The resulting executable will be some bytes shorter since the zeroes need
not to be stored on disk, at least not for ADos 2.0.


@{B}Warning@{UB}: This operation shouldn't be used if you want to load your
binaries with ADos 1.2 or 1.3, as the BSS space of the CODE and DATA hunks
is not correctly filled with zeros. Additionally, this operation doesn't
have any effect about the data in memory. Just save the project to disk and
reload it to see an effect.



@{B}Remove Hunk...@{UB}


Removes a hunk completely from the file. First, select this menu item, then
pick up the hunks from the @{"hunk requester" link HunkReq} you want to
remove from the executable.


@{B}Warning@{UB}: That's usually not a smart thing to do since all data in
the selected hunks will be unavailable and lost. This operation should be
performed on hunks of size 0 ONLY, and only if you're sure the hunk linkage
they define is not used by the program in any way.



@{B}Note@{UB}: You might miss an "Add Hunk" entry here. This operation is
currently not performed by the hunk processor since there's no way to define
the data within the hunk in question. However, any standard linker can do
that for you. Just try "BLink" or "SLink", they can easely link two
executables as well.


@ENDNODE
@NODE EditMenu "The Edit Menu"
This menu is mainly used to setup the merge-links before the actual merge
operation is performed with the @{"Proc menu" link ProcMenu}, i.e. to define
which hunk is to be linked to which other hunk.

It is also used to change or modify the relocation data for a specific hunk
and to run the @{"AutoMerger" link AutoMerger}. It does not perform any
operations on the hunk itself.



@{B}Set Hunk to Merge to@{UB}


Used to pick up a hunk from the @{"hunk requester" link HunkReq} that is
used as destination of a merge operation, i.e. other hunks will be merged to
this hunk. To perform this definition, select this menu item first and pick
up the desired destination hunk as next step.

As soon as the destination hunk has been selected, pick up the hunks from
the @{"hunk requester" link HunkReq} that need to be merged to this hunk.


This does @{B}not yet@{UB} perform the actual merge operation, it just
defines "merge links" about what has to be done later on. To run the merging
once you marked all hunks as desired, select the "Start Merging" item of the
@{"Proc menu" link ProcMenu}.



@{B}Add Hunk To Merge List@{UB}


This menu item is usually not needed since "Hunk" performs it automatically
as soon as you've picked up a destination hunk for merging with the first
menu item. Anyways, it defines that the next hunks selected are going to be
merged with the hunk defined with the former menu item.


As above, that does not yet perform the actual merge process, it only
defines the hunks that are to be merged.



@{B}Remove Hunk from Merge List@{UB}


Unlinks merge links you've set accidentially or you don't want to perform.
First, select this menu item. Then pick up those hunks from the
@{"hunk requester" link HunkReq} that are either destination or source of a
merge operation, i.e. either entries with @{FG Shine}white@{FG Text} or
@{FG Fill}blue or grey@{FG Text} background.


"Hunk" will unlink all linkages going to this hunk in the first case or only
remove the single hunk.


This menu item is useful to remove manually hunks from the merge list
created by the @{"AutoMerger" link AutoMerger}; as above, it neither
performs any merging, nor undoes it. It just clears the "merge marks" of the
selected hunks.



@{B}Clear All Merge Links@{UB}


Unlink all merge links you've set before, i.e. all hunks are marked as not
to be merged at all. Works similar to the menu item above, but affects all
hunks.



@{B}Use Auto Merger@{UB}


It's often a pain to set all merge links by hand. Hunk's "Auto Merger" can
do that for you as well. It picks hunks that match certain requirements and
marks them for linkage. Because this algorithm is a bit more involved, it is
discribed in the @{"AutoMerger section" link AutoMerger} in detail.

As all the menu items above, the auto merger does not perform any action on
the binary. It just presents its recommendation of which hunks to merge and
which not. That's again done by the "Start Merging" item of the
@{"Proc Menu" link ProcMenu}.

After using the auto merger, you should check the resulting merge links and
adjust them with this menu if necessary.



@{B}Show Reloc Data of Hunk@{UB}


Hunk can be used as well to modify the relocation entries of a hunk, i.e.
the offsets in this hunk that contain absolute addresses requiring
relocation after having loaded a binary.


To edit the relocation data of a hunk, pick first this menu item and,
afterwards, the hunk whose reloc data you'd like to edit.


Hunk will now go into the "Relocation Overview" of that hunk and adjusts
its display accordingly. First, the "Proc" and "Edit" menus get unavailable
as they operate on complete hunks and not on relocation data.

Second, the @{"Reloc menu" link RelocMenu} will be made selectable and
presents another set of operations "Hunk" can perform on this relocation
data.

Third, the contents of the requester changes. It presents now the relocation
data overview of the hunk you've selected. All the relocation entries in
this table are corrections to be made in this selected hunk, but the data
to be relocated in the hunk might of course refer to different hunks.


The first column in the reloc overview requester is the hunk whose base
address must be patched in after loading. The next column is the number of
relocations that must be performed relative to this hunk, the last column
presents where this data is kept in memory - which is usually uninteresting
unless you want to patch this by hand with a monitor.


Details about how the "Reloc" menu works can be found
@{"in the Reloc menu section" link RelocMenu}.

@ENDNODE
@NODE RelocMenu "The Reloc Menu"
This menu is used to perform changes on the relocation data of a selected
hunk. It is usually not available unless you picked a hunk to be modified by
first selecting "Show Reloc Data of Hunk" from the
@{"Edit menu" link EditMenu} and then choosing a hunk from the requester.


If this menu is active, the requester will either show the relocation
overview list - which is the default when this menu is entered by the "Show
Reloc..." item of the "Edit" menu - or the contents of a specific relocation
list itself.


The relocation overview list presents all hunks in the binary whose address
must be patched into the selected hunk in the first column of the requester,
and the number of relocation entries relative to this hunk in the second
column.


Thus, if you're watching the relocation overview list of hunk #0 and it
contains a line like this

@{CODE}
Relative to Hunk #       0   Size        C  in Memory at   41F4C8
Relative to Hunk #       1   Size        2  in Memory at   41F518
@{BODY}

then the absolute address of hunk #0 must be used twelve (hex 0xC) times
within this hunk itself, i.e. twelve addresses in this hunk refer to
absolute addresses in the hunk itself.

The next line says that data in the hunk #1 is only referenced twice from
within hunk #0, and so on.


Now about the items in this menu:



@{B}Add Reloc List to Hunk@{UB}


Adds another hunk to the list whose base address needs to be known for
relocation. The hunk number must then be entered into the requester that
pops up. The new entry will then show up in the requester.



@{B}Remove Reloc List from Hunk@{UB}


This item removes hunks from the list, i.e. no corrections will be made
relative to the removed hunk.

To perform this operation, pick first this menu item and select afterwards
the hunk numbers from the requester you'd like to remove.


@{B}BE WARNED!@{UB} This operation is very dangerous! Removing any relocation list
from the overview requester will remove ALL relocation entries to the hunk
selected and will most likely corrupt the binary. Before using this
drastical method, check whether this relocation list contains any relocation
entries with the "Show Reloc List" item below. REMOVE ONLY EMPTY RELOCATION
LISTS from this requester.



@{B}Show Reloc List@{UB}


This menu item is used to enter the table of relocation entries itself, i.e.
the table that contains the actual offsets that need correction. To do so,
pick first this menu item and, afterwards, the hunk number from the
relocation overview requester.


This will again modify the menu and the requester: It will make the "Edit
Reloc List" item below available; it will also show the contents of this
relocation list in the requester. This is just a list of offsets relative to
the base address of the base hunk where the base address of the selected
hunk will be patched in.


To continue the example from above:


If you pick "Hunk #1" from the reloc overview requester, this list might
look for example as follows:


@{CODE}
Offset Relative to Hunk Base :      C18
Offset Relative to Hunk Base :     15FA
@{BODY}

which means that two addresses in hunk #0 must be relocated to the base
address of hunk #1, namely the offsets 0xC18 and 0x15fa relative to the
beginning of hunk #0.

To go a bit into the details, the loader of the Os, namely the LoadSeg()
function, will pick the long words at the address of hunk #0 plus 0xc18 and
plus 0x15fa respectively and will add to these long words the base address
of hunk #1.


The next menu item presents now the required functions to modify this list:



@{B}Edit Reloc List@{UB}


This menu item is only available if the reloc list has been entered with
the "Show Reloc List" item above. It presents in the form of a sub menu all
functions available for modifying the relocation entries.


        @{B}Add Reloc Entry@{UB}

Add a relocation entry to the relocation list. Just enter the offset
relative to the beginning of the base hunk in the requester that pops up.


@{B}BE WARNED!@{UB} Unless you've modified the binary in memory with a monitor,
adding relocation entries doesn't make too much sense. It will in most cases
corrupt your binary because the Os loader function will patch into the base
hunk after loading. Use this function with some care.


The offset to enter in the requester MUST BE EVEN, or the Os might crash
when loading the modified binary. A correct binary will NEVER contain any
relocation entries of odd addresses.

Another point is that the offset shouldn't overlap with another entry in
the list. "Hunk" will check these conditions for you and will warn you if
they aren't satisfied.


        @{B}Remove Reloc Entry@{UB}

Remove a relocation entry from the list. After selecting this submenu, pick
the relocation entries in the requester that should be removed.


@{B}BE WARNED!@{UB} Careless removal of relocation entries will most likely
corrupt the binary. This is most likely only required if you modified the
hunk data with a monitor yourself.


A tutorial and examples how to use these functions can be found in the
section @{"How to patch in a subroutine" link SubPatch}.


        @{B}Back to Reloc List@{UB}

Quits this requester and shows the relocation overview requester again.



@{B}Merge Relocs@{UB}


It might happen that the relocation overview requester contains two or
more lists that refer to the same hunk. These lists can be safely and
without any loss of data merged into one common relocation list.


This menu item will try to merge as much relocation lists as possible, you
do not need to pick any hunk from the list.



@{B}Sort Reloc Entries@{UB}


The relocation entries in a relocation list need not to be kept in order,
but it's often convenient to have them in a sorted form - at least when you
want to modify the table. The Os loader itself does not care about the order
at all, so this operation is always safe.


To perform the sorting, select first this menu item, then pick the hunks
from the requester whose reloc list should be sorted.



@{B}Back to Hunk Structure@{UB}


This item cancels the relocation overview requester and returns control back
to the hunk requester. It will also make the "Reloc" menu unavailable again.


@ENDNODE
@NODE SettingsMenu "The Settings Menu"
The Settings menu is used to customize "Hunk" for your personal needs, and
for configuration of the @{"Auto Merger" link AutoMerger}. The hunk settings
are stored in the @{"ToolTypes" link ToolTypes} of the "Hunk" icon.



@{B}Merge Hunk Types@{UB}


This menu item is part of the @{"Auto Merger" link AutoMerger} settings. By
looking at this menu, the AutoMerger checks whether two hunks of different
type may be marked for merging or not.


        @{B}Only Hunks of Equal Type@{UB}

The auto merger will only mark hunks of the same type for merging, i.e. will
only merge CODE hunks to CODE hunks, DATA hunks to DATA hunks and BSS hunks
to BSS hunks.


        @{B}Code->Data->BSS@{UB}

The auto merger will additionally allow DATA hunks to be merged to
CODE hunks and BSS hunks to be merged to DATA hunks. Hunks of the same type
will be merged, too.


        @{B}All Types@{UB}

The auto merger will ignore the hunk type when merging with the only
exception that BSS hunks may be excluded explicitly with the "Allow BSS
Merging" in the "Merge Path" menu.



@{B}Merge Path@{UB}


This sub menu controls various options of the
@{"Auto Merger" link AutoMerger} again.


        @{B}Merge Different Memory@{UB}

Allow merging of hunks of different memory types as far as possible. CHIP
mem requiring hunks will be merged to PUBLIC mem hunks, changing the hunk
type to CHIP. FAST mem hunks will be merged to PUBLIC mem hunks, again
changing the memory type to FAST. However, CHIP mem and FAST mem hunks won't
be merged at all, even with this flag enabled. The default is to merge only
hunks of identically memory requirements.


        @{B}Only Adjacent Hunks@{UB}

Merge only adjacent hunks, i.e. "nearest neighbours" in the hunk table.
Especially, "Hunk" won't reorder the hunks if this checkmark is set. Leaving
this check mark is slightly safer because the merge process won't destroy
the order of the code in the segment list, but the auto merger will be less
powerful if this item is checked. It might mark only very few possible merge
links.


        @{B}Enable BSS Merging@{UB}

Due to some special tricks, it is possible to add a BSS hunk to the end of a
DATA or CODE hunk. However, the merged BSS segment will not be initialized
by the pre-V37 Os and programs requiring this won't work correctly with the
obsolete versions of the Os. Another drawback of merging a BSS hunk to a
DATA or CODE hunk is that no other CODE or DATA hunks can be merged to the
resulting "mixed" hunk with additional BSS data at the end. "Hunk" is not
the only program that uses this trick of placing addtional BSS data in a
DATA or CODE hunk; it's actually quite popular amonst C compilers, even this
method is "sort of" undocumented.

My recommendation is to run the @{"Auto Merger" link AutoMerger} in a first
step without this flag, and then run it in a second pass with this item
checked to get even the last BSS hunks merged.



@{B}Max. Hunk Size@{UB}


This menu is used to setup the threshold for hunks to be merged. Hunks
larger than the size checked in this menu won't be merged at all, with the
two extremes to allow only merging of completely empty hunks or to allow
merging of all hunks, regardless of the size.



@{B}Write Reloc32Short@{UB}


If this menu item is checked, "Hunk" will try to write the optimized
"short" version of the relocation data which saves about two bytes per
relocation entry. However, programs using this enhanced hunk type can't be
loaded by pre-37 versions of the Os - call that either a drawback or an
improvement.... (-:


Another caveat is that certain old-fashined programs that need to load
binaries by themselves aren't able to process this hunk type as well. For
example, Nico Français' popular "PowerPacker" program won't be able to pack
programs using this hunk - so don't set this item if you want to pack the
binaries afterwards.



@{B}Allow Reloc Split@{UB}


If the relocation list contains offsets larger than 64K, then the improved
"Reloc32Short" hunk can't be used since the offsets won't fit into the
shortened two-byte slots of this hunk type. "Hunk" will fall back to
the standard relocation hunk type in this case, unless this menu item is
checked; If it is, then the relocation data will be split into two separate
relocation lists, one that contains the relocation offsets that fit into two
byte slots, and another for the long beyond-64K offsets.


However, since most programs seldom contain hunks larger than 64K, this
option makes usually no difference.



@{B}Verify Requests@{UB}


This is a "safety" option. If it is enabled, "Hunk" will warn you about
dangerous actions, as removal of complete hunks and relocation lists, and
ask you first with a requester before performing. It is therefore
recommended to leave this item checked.

If not checked, "Hunk" won't annoy you with the requesters.



@{B}Reverse Sort@{UB}


Selects the order in which the relocation lists will be sorted, if ever. The
standard order is ascending, i.e. low offsets first.

If this item is checked, the order will be reversed to "high offsets first".



@{B}Keep Debug Data@{UB}


Permanently disabled because this option is not yet implemented, but
planned.



@{B}Save Settings@{UB}


Write the settings to the "Hunk" icon. They are kept there in the form of
@{"ToolTypes" link ToolTypes}.


@ENDNODE
@NODE ToolTypes "Recognized Tool Types"
"Hunk" keeps its settings - which are adjustable by the
@{"Settings Menu" link SettingsMenu} - in its program icon. I still prefer
this way to keeping them in the ENV: archive because you neither need an
editor to adjust them - the workbench is enough - nor need to worry about
the file name assigned to the preferences file.


Anyways, here's the list of "ToolTypes" that are read on startup:


@{B}MERGEDIFFMEM@{UB}


Tells "Hunk", or specifically the @{"Auto Merger" link AutoMerger} whether
it is O.K. to merge hunks of different memory requirements. This setting can
be either "TRUE" to allow it, or "FALSE".


Details on what this means are in the
@{"Auto Merger" link AutoMerger} and in the
@{"Settings Menu" link SettingsMenu} section.



@{B}ADJACENTONLY@{UB}


If set to "TRUE", the @{"Auto Merger" link AutoMerger} will only mark
adjacent hunks for merging. If set to "FALSE", the relative hunk position
won't matter.



@{B}MERGEBSS@{UB}


"TRUE" means that BSS hunks may be merged by the
@{"Auto Merger" link AutoMerger} , "FALSE" means that they won't.


For caveats when setting this to "TRUE", read the
@{"Settings Menu" link SettingsMenu} chapter.



@{B}SHORTRELOC@{UB}


Set this to "TRUE" to allow "Hunk" to write the optimized "Reloc32Short"
relocation information hunks. Leave that item "FALSE" for compatibility to
pre-V37 and other third-party programs.




@{B}NOVERIFY@{UB}


If set to "TRUE", safety requesters will be disabled. Defaults to "FALSE" to
ask you before preforming something dangerous.



@{B}SORTREVERSE@{UB}


Another binary switch that specifies the direction in which relocation lists
are sorted. "FALSE" is the default and selects ascending order, "TRUE"
selects descending order.



@{B}SPLITRELOCS@{UB}


If set to "TRUE", "Hunk" will split the reloc hunks in a Reloc32Short and a
standard Reloc32 hunk if offsets larger than 64K are contained in a
relocation list. This makes only a difference if "SHORTRELOC" is set to
"TRUE", too.

Details are again in the @{"Settings Menu" link SettingsMenu} chapter.



@{B}KEEPDEBUGDATA@{UB}


Not yet supported, but reserved for future plans.




@{B}MERGETHRESHOLD@{UB}


Selects the upper threshold for hunk merging. Hunks larger than this won't
be touched by the @{"Auto Merger" link AutoMerger}.

This tooltype can be set to the following values:


@{CODE}
EMTPY           merge only emtpy hunks
64              merge hunks smaller than 64 bytes
256             ...256 bytes...
1K,4K,16K
64K,256K        guess what...
ALL             merge all hunks
@{BODY}

The default is "16K". Even though other numbers might make sense, only the
strings in the table above are recognized by "Hunk".



@{B}MERGEMODE@{UB}


Selects, which hunk types are free for merging. This affects again only the
@{"Auto Merger" link AutoMerger}.

The following values are recognized:

@{CODE}
EQUAL           merge only hunks of equal type
CODEDATABSS     merge additinally DATA to CODE and, if enabled, BSS to DATA.
ALL             ignore the hunk type
@{BODY}



@{B}WINDOW@{UB}


Used to setup a stream - in the form of a file name - "Hunk" will place its
output in. This tooltype is only used when Hunk was launched from the
workbench, and the only part of Hunk that uses this stream is the ARexx
interface. Defaults to a console window.


@ENDNODE
@NODE AutoMerger "The automatic merge link creator"
When using "Hunk"'s hunk merger, you're of course free to setup all merge
links with the @{"Edit Menu" link EditMenu} by hand, but this will be rather
annoying if the number of hunks is large.


The "Auto Merger" will help you out here by making recommendations for the
merge links. Since placing these links doesn't involve any merge operation
at all, you'll be able to edit or correct these recommendations manually in
a second step. The final merge operation is then, as usual, started by the
"Start Merging" item of the @{"Proc Menu" link ProcMenu}.


The details of the algorithm used by the "Auto Merger" are setup by the
@{"Settings Menu" link SettingsMenu} on the right hand side of the screen.
The "Auto Merger" looks simply at all pairs of hunks, checking whether this
pair fullfills the requirements selected in these menus and whether these
hunks can be merged at all. If so, the merge link is set.



We're now going to discuss an example how to use the "Auto Merger":


@{CODE}
o Open the binary you'd like to merge, i.e. "AmigaBasic" or "Hunk".

o Change the settings in the following way:

        - Of the "Merge Hunk Type", select "Only Hunks of Equal Type"
        - Of the "Merge Path" menu, select the "Only Adjacent Hunks" item,
          make sure all other items are disabled.
        - Set the "Max. Hunk Size" menu item below to "4K".

@{BODY}
This is one of the safest settings. It will merge in most cases only the
tiny segments of the C stub routines.


o Start now the Auto Merger with "Use Auto Merger" of the @{"Edit Menu" link EditMenu}.


Check now if the result pleases you. This first step might not be able to
set much merge links, but it usually won't corrupt binaries.


Let's run the next step, the removal of empty hunks:

@{CODE}
o Set the "Max Hunk Size" to "Only Empty Hunks".

o Set the "Merge Hunk Types" to "All Types".

o Enable the "BSS Merging" in the "Merge Path".

o Run the Auto Merger again.

@{BODY}

This will merge empty hunks to the hunk in front of it. It will not remove
DATA or CODE hunks behind BSS hunks because they can't be linked to a BSS
hunk. We must allow the Auto Merger to link these hunks to a different hunk
somewhere to get rid of them.

You may well choose to stop now using the Auto Merger and to mark the few
remaining hunks by hand.


Anyways, here's the next step for even better performance:

@{CODE}
o Set the "Merge Hunk Types" to "Only Hunks of Equal Type"

o Disable the "Only Adjacent Hunks" setting in the "Merge Path" item.

o Run the Auto Merger again.

@{BODY}

This should finally remove all empty hunks.


The next possible step is to merge non-adjacent hunks up to a certain size.
This is simply done by

@{CODE}
o Selecting a larger "Max Hunk Size", say, 256 bytes.

o Running the Auto Merger again.

@{BODY}

By selecting larger and larger thresholds, you can get almost all hunks
marked for merging.


In a last final step, you might also try to merge the BSS hunks to one of
the CODE or DATA hunks in front of them:

@{CODE}
o Select "All Types" from the "Merge Hunk Types" of the settings menu.

o Enable "Only Adjacent Hunks" of the "Merge Path" item.

o Enable the BSS merging in the same menu.

@{BODY}

If you're finally done, select "Start Merging" from the Process Menu.


You may now try to run the Auto Merger again to gain even more hunks; after
merging the file successful, you might be able to shorten the file even more
by running the optimizer of the @{"Proc Menu" link ProcMenu} or one of the
@{"external optimizers" link HopFiles}. Since you've merged now several
hunks together, former references from one hunk to another hunk will have
been turned into references of the hunk to itself. It is possible to remove
these references by changing the code in these hunks into using PC relative
addressing modes.


Remember, the more steps you go, the more likely it is that the resulting
binary will be corrupted. It's not that "Hunk" is faulty in performing its
job, it's just that some files really require their hunk structure. For
example, you shouldn't try to merge MY FILES because I had most times good
reasons to select the hunk structure in the way I did.


Moreover, you should probably try a monitor and check by hand which hunks
can be removed safely. It's not wise to merge hunks...


- if the program uses its segment list directly in some way to find
its own hunks. This is for example done by the startup code of most old BCPL
programs.


- if the program uses seglist splitting to run some part of itself in
background.


- if the program uses parts of its own seglist as input seglist for
CreateProc()

@ENDNODE
@NODE SubPatch "How to patch in a subroutine"
This tiny tutorial shows how "Hunk" can be used to patch in code into
complete binaries. This is for example useful for creating permanent patches
to AI disk based libraries and has been used by me - to give an example - to
build the "FontCache" improved diskfont.library.


"Hunk" makes this job a bit easier, but still not "too easy". You need still
a lot of assembly knowledge to perform it, so beware! This is definitely
nothing for "newbies"....


However, "Hunk" alone is not sufficient for this task. You need to provide:


- An assembler to create an executable file from your source.

- A linker that is able to link binaries together.

- A debugger to investigate the binary that should be patched.

- Assembly knowledge is of course mandatory.


First, use the monitor and load the binary to find a good point where to
place your patch. That's not too simple, and I can't give general guidelines
about this. If you found the right place, write down the code at this
position and write down the hunk number and offset of this code to the
beginning of the hunk. In order to make room for the call of your patch, a
part of the code has to go into the patch code.


In a second step, write the patch code. Don't forget to put in the part of
the code you wrote down in step one. Leave possible calls back to the main
program open and insert a "JSR $AAAAAAAA" instead. Using address zero as
temporary jump destination is not a wise idea since the optimizer of the
assembler might try to optimize them to a word sized jump, but we need a
long jump here as placeholder. Assemble this code to an executable file.


The third step requires the linker; this linker must be able to process
executables, not only object modules. Link your patch executable to the end
of the program to be patched and place the output somewhere in RAM: Don't
overwrite the original program, you'll need it again if the patch fails.


Run "Hunk" and open the composed binary. The next step will be to merge the
patch hunks to the hunks of the program. This should be done manually in
order to keep the structure of the program intact.

The hunks of your patch will be the last hunks in the file. You might want
to open the original again to be able to compare which hunks are new to the
file. If you found the patch hunks and the right places where they should
go,


o pick the "Select Hunk to Merge To" from the
@{"Edit menu" link EditMenu}.


o pick the destination hunk your patch hunk should be merged to. Write down
its size! This will be the offset of your patch in the compound hunk, you'll
need that later.


o pick the patch hunk to be merged.


o Continue with the steps above until all patch hunks have found their
destination.


o Pick "Start Merging" from the @{"Proc Menu" link ProcMenu} to launch the
merge process.


The next step is the hardest. You'll need to run the debugger again and to
fiddle in your patch into the binary. This should be done with "Hunk"
on-line because it will help you to add or remove the necessary relocation
information you can't patch in by just using the monitor. As we need a
readable code with all jump destinations filled in,


o select "Relocate Code" from the @{"Proc Menu" link ProcMenu}. This will
perform all required code relocations and leaves an executable code in
memory. The only difference between this code and using the Os to load the
code for you is that "Hunk" keeps the relocation information.


o check the requester. Write down the start addresses of the hunks you'll
need to adjust. That's the rightmost number in a row of the requester;
you'll have to scroll the requester contents all the way to the left to be
able to read it.


o Enter this address in the monitor and add the offset of the location you
wrote down before to investigate the code where the call to your patch has
to go.


o Replace the code at this location that went into your patch by a series of
NOPs (hex 0x4e71). Watch out for possible absolute references in this
portion of the code! To be on the safe side, use "Hunk"'s "Delocate Code"
function and check if all the NOPs still remain NOPs. If not, some part of
this code has been relocated. If this happens, you've to remove the
relocation entries by hand:


o Calculate the offsets of the relocated addresses to the beginning of the
hunk. Then select "Show Reloc Data of Hunk" from the
@{"Edit Menu" link EditMenu} of Hunk to enter the relocation list overview
and pick the hunk to be patched afterwards.


o Pick now each entry in this requester, one by another and check the
relocation list whether this certain offset you wrote down is contained in
this list - it must be somewhere in here! If you found this offset, select
"Remove Reloc Entry" of the "Edit Reloc List" item and click at this offset
to remove it, then go back to the reloc list overview with "Amiga-," or back
to the hunk requester with "Amiga-." if you're done.


o Go on like this until all relocation data in this range have been removed.
Check this by placing again NOPs in this region and running "Relocate" and
"Delocate" again until all NOPs really stay NOPs.


o The next step is to patch in a call to your code: First, select "Relocate"
again to see the right code. Find out the position of your patch code in
memory by adding the base address of the hunk to the hunk length of the
un-merged hunk of the original file. Since your code has been merged to this
hunk, it will appear at the end of the composed hunk at right this offset.


o Place a "JSR xxxxx" at the patch position, hex "0x4eb9 xxxx xxxx" where
xxxx xxxx is the absolute address of your patch code from the last step.


o A binary like this won't work obviously because this address must be
corrected if the file gets loaded to a different position. Hence, we need to
add a relocation entry for this call. To do so, first find out the offset of
the ADDRESS PART of the JSR to the beginning of the hunk - that is the
address of the "0x4eb9" you patched in, plus two, minus the base address of
the hunk. Write down this number.


o Locate the hunk in the requester and write down its number, leftmost in
the requester. Select again "Show Reloc Data of Hunk" and pick the hunk to
enter the relocation overview list. Pick again the same hunk since this has
to be a relocation from this hunk relative to itself. If no entry for the
hunk is available, you've to create a new relocation list for this hunk; you
can skip this next step if there already is a relocation list.


o Select "Add Reloc List to Hunk" from the @{"Reloc Menu" link RelocMenu}.
Enter the hunk number in the requester. This will build the new relocation
list.


o Select "Show Reloc List" from the same menu. Pick the hunk of the same
number again.


o Select the "Add Reloc Entry" sub-item from the menu item right below.
Enter the offset you wrote down before.


o Go back to the hunk structure with "Amiga-." and run "Delocate" again.
Switch to the monitor and check whether the address part of this jump has
changed from an absolute address to a relative offset. The jump will now of
course go "into the nirvana" because the code is not relocated correctly;
however, if nothing changed or the code looks just messy, something went
wrong in the step before. In this case, remove again the faulty relocation
entry and check if you made any mistakes in the calculation.


o You might still require to patch in the correct addresses for the "JSR
$AAAAAAA" of your patch code if you need to call parts of the original code.


o In this case, find out the offsets of the "AAAA AAAA" parts of the jumps
relative to the beginning of the hunk. Then "Relocate" the code again, patch
in the correct jump destinations with the monitor.


o You need now again to add the relocation offsets for these jumps
again. This is again done as before, possibly by selecting a different hunk
for the destination from the relocation overview list if the jump goes to a
different hunk.


o Don't forget to check the final code again with "Relocate" and "Delocate"
if all relocations work as they should.


o If this is done, the job of "Hunk" is complete. You may now "Save" the
final code back to a safe place and check if it works. Phew!



@ENDNODE
@NODE IncludedScripts "ARexx scripts contained in the package"
The "Hunk" package comes with six useful ARexx scripts in the "Rexx" drawer;
three of the programs are scripts files that should be executed from the
shell with the "Rx" command and run "Hunk" to modify object files by a shell
shortcut. The three remaining files are macro files that are supposed to be
used by "Hunk" itself; they are executed by the "Arexx Command" item in the
@{"Project Menu" link ProjMenu}.

____________________________________________________________________________


@{B}PA.rexx@{UB}:


Synopsis:               RX PA.rexx


This is a script file that should be invoked from the shell with the "Rx"
command. It is used to patch one or more binaries and "PowerPack" them
automatically in a second step.


Requirements and caveats:


o You need to provide the "PowerPacker 4.2" or higher program, © Nico
François which is not included in this package.


o Since the PowerPacker does not support the "Reloc32Short" Hunk,
you've to disable the "Write Reloc32Short" item in the
@{"Settings Menu" link SettingsMenu}.


o Due to a bug in the RTPatch program, the "RequestFile" shell command
doesn't work properly with this patch installed. You've to disable this
patch before using "PA.rexx".


Usage:


Quite simple. Open a shell, go to the "Hunk/Rexx" directory and enter "rx
PA.rexx", press @{B}RETURN@{UB}. If you run the program for the first time, it will
ask you to locate the "Hunk" and the "PowerPacker" program - please pick
these programs with the file requester. The location of the two programs is
saved in the environment variables "ENV:Hunk" and "ENV:PowerPacker". If you
move the programs to a different directory, you should delete these
variables to make the script asking you again about the locations.

If the two programs have been located, another file requester pops up. Use
it to select one or more binaries to patch and compress; press "O.K." in the
requester to complete your choice.

The script will now start its job and will process all selected files by the
two programs automatically.


____________________________________________________________________________


@{B}ShortRelocs.rexx@{UB}


Synopsis:       RX ShortRelocs.rexx <FullPath>


This script file converts all relocation entries in a file to "Reloc32Short"
and removes all unnecessary zeros at the end of DATA or CODE hunks by
placing them in the BSS space of these hunks. Thus, it compacts files just
by reorganizing them. The resulting file will work just the same way as the
original program since no patches have been applied. This operation is
always safe.



Requirements and caveats:


o This script takes a single argument, namely the file to process. This file
name must be THE COMPLETE path of the object to process. A path relative to
the current directory is not enough.


o Since the "Reloc32Short" hunk type is only available for V37 and later
versions of the Os and since the hunk BSS space is not cleared for ealier
releases, this script should only applied to programs that are not
considered to be run under V34 or earlier versions.



Usage:


Open a shell, go to the "Hunk/Rexx" directory and enter "RX ShortRelocs.rexx
<pathname>" with <pathname> substituted by the FULL PATH of the binary to
process. If the script is called for the first time, it will pop up a
requester asking you for the place where the "Hunk" program is stored. The
location is then kept in the environment variable "ENV:Hunk" for later
usage. If you move "Hunk" to a different directory, you might want to delete
this variable to make the script asking you again about the correct location
of "Hunk".

Except for this first step, the script runs automatically and will overwrite
the binary by a compacted version.


____________________________________________________________________________


@{B}PatchFile.rexx@{UB}


Synopsis:       RX PathFile.rexx <fullpath> <patchfile>


This script is a convenient way using "Hunk" to apply a patch to a file by a
single shell command. The <fullpath> file is patched using one of the
@{".hop scripts" link HopFiles} given by the <patchfile> argument.



Requirements and caveats:


o The file name argument must be THE COMPLETE ABSOLUTE path to the object to
be patched. A pathname relative to the current directory is not enough.


o Due to the way how the patch works in general, this operation is not 100%
safe. It may corrupt file binary. It is therefore recommended that you make
a backup of the destination file before you try to patch it.



Usage:


Open a shell, go into the "Hunk/Rexx" directory and enter "RX PatchFile.rexx
<pathname> <patchfile>", with <pathname> = the full absolute path to the
object to be patched and <patchfile> = the name of the
@{".hop script" link HopFiles} to be applied. The last argument is just a
filename, not a complete path.

If you run this script for the first time, it will ask you to locate the
"Hunk" program on your harddrive with a file requester. This position is
then saved into the environment variable "ENV:Hunk" for later invocations.
Delete it manually if you move "Hunk" to a different directory so the script
may ask you again.

Except for this first step, the script operates automatically and replaces
the binary with a patched version.


____________________________________________________________________________


@{B}PrintReloc.rexx@{UB}



Synopsis:       To be invoked from inside "Hunk" with the "Arexx Command..."
item in the @{"Project Menu" link ProjMenu}.


This is an automated rexx script for "Hunk" that prints all hunk data and
relocation entries. Unlike the "Print" item in the
@{"Project Menu" link ProjMenu}, this script prints the relocation entries,
too. Beware, the output might be very large!


____________________________________________________________________________


@{B}Patch00.rexx@{UB}


Synopsis:       To be used by "Hunk" by the "Arexx Command..." item.



Another automated script that runs all possible patches for the MC68K
processor on the loaded file. Lemme remind you that patching binaries is
always a dangerous thing!


____________________________________________________________________________


@{B}Patch20.rexx@{UB}


Synopsis:       To be used by "Hunk" by the "Arexx Command..." item.



An automated script that runs all possible patches for the MC68020 and later
processors. Somewhat more optimizations are possible for the later members
of the 68K family, but the patched binary will be no longer executable on a
plain MC68K. Moreover, remember that patching files is always a bit
dangerous. You'd better make a backup of the binary before trying to patch
it.

@ENDNODE
@NODE ARexxInter "The ARexx interface"
"Hunk" comes with an ARexx interface which allows automatic processing of
files. All commands you can perform by hand are also available thru this
interface, plus some more.



@{B}General notes:@{UB}


- Some ARexx commands put results back into variable names you specify with
the command. Due to the way AREXX works, you must prevent expansion of these
variables before they get passed to "Hunk". This is done simply by putting
the variable name into single or double quotes. For some commands, this
variable argument is optional. The result is in this case returned in
"RESULT". To be able to read this variable, it must be enabled with the
ARexx command "OPTIONS RESULTS".


- The name of the Rexx host port is "HUNK.1" for the first "Hunk" process
running, "HUNK.2" for the second etc.


- The hunk related commands expect up to three arguments. The first argument
is the hunk index, which is identical to the hunk number. The second
argument is the index of the relocation list in all available relocation
lists, counting from zero. IT IS NOT the hunk this relocation list is
relative to. The third argument is the index of the relocation entry in the
relocation list, again counting from zero down. IT IS NOT the address of the
relocation entry. The "POSITION" command can be used to specify defaults and
the "INDEX" command to convert from the hunk numbers or relocation offsets
to the indices.


-Unlike the rest of ARexx, hexadecimal numeric arguments are written with a
preceding dollar "$" sign, not with the ugly ARexx '..'x notation.



@{B}The list of all available commands:@{UB}


An argument in square brackets "[]" is optional and can be omitted. A
vertical dash "|" is placed between the possible choices of the argument. An
equal sign "=" lists equivalent choices or spellings of arguments.



@{B}NEW ['variable'] : initialize HUNK, return portname.@{UB}

This command quits the currently loaded file, if any, and displays the file
requester. If the 'variable' argument is given, the name of the AREXX port
is put into that variable.



@{B}CLEAR : clear old project, display new requester.@{UB}

Similar to NEW except that it doesn't return the port name.



@{B}OPEN [filename] : open new project.@{UB}

Loads the given binary.



@{B}SAVE [filename] : save project, change name.@{UB}

Change the name of the binary to the given file name and save it under this
name. If the filename is omitted, the save requester is shown.



@{B}SAVEAS [filename] : save project or display requester.@{UB}

Similar to SAVE except that the file is saved even without the filename,
using the old file name.



@{B}CLOSE : close project, display save requester.@{UB}

Identical to SAVE without a parameter: Displays the SAVE requester.



@{B}PRINT : print project information.@{UB}

Identical to the "Print" item in the @{"Project Menu" link ProjMenu}.



@{B}QUIT : quit "Hunk".@{UB}

Exit the program.



@{B}HELP [command] : display specific help about a command.@{UB}

Prints informations about ARexx commands. The output will be shown
either on the shell "Hunk" was started from, or in a console window selected
with the WINDOW @{"tooltype" link ToolTypes}.


If an argument is given, detailed help about the command is printed.



@{B}FAULT error# ['variable'] : supply description of error.@{UB}

Put a short description text of the given error code into the variable, or
into RESULT.



@{B}POSITION hunk [reloc [entry]] : specify default position for hunk functions.@{UB}

This command is used to setup default arguments for commands that address
hunks. hunk, reloc and entry are the index of the hunk, the index of the
relocation list - not the hunk the relocation list is relative to! - and
entry the index of the relocation entry in this list. All indices count from
zero up.


All commands requiring a hunk/reloc/entry argument may get their defaults
from here, and place their arguments, if any, back into the default. These
defaults are also available thru the LASTHUNK, LASTENTRY and LASTRELOC
commands.


@{B}WINDOWTOFRONT : move HUNK screen frontmost.@{UB}

The name might be a bit unorthogonal, but this really puts the screen to the
front. The name ought to be like this due to the user style guide.


@{B}WINDOWTOBACK : move HUNK screen behind.@{UB}

Put the HUNK screen behind all other screens.


@{B}ACTIVATEWINDOW : activate HUNK window.@{UB}

Similar to WINDOWTOFRONT, but sets additonally the input scope to the Hunk
screen.


@{B}LOCKGUI : lock graphic interface, block user.@{UB}

This command locks the user interface of Hunk. A busy-pointer will be shown
instead of the standard mouse pointer and all user inputs will be ignored so
that they can't interact with the script. MAKE SURE EVERY LOCKGUI IS MATCHED
BY UNLOCKGUI or you'll leave the user with an unuseful screen.


@{B}UNLOCKGUI : unlock graphic interface, allow user interference.@{UB}

Unlocks the user interface again and displays the standard mouse pointer.
All LOCKGUI/UNLOCKGUI calls nest, i.e. EVERY LOCKGUI must be matched by one
and only one UNLOCKGUI.


@{B}NOP : do nothing.@{UB}

Takes no arguments and does nothing at all. Just taking CPU power... (-:


@{B}HUNK [hunk] 'stemvar' : get hunk information.@{UB}

Puts informations about the given hunk into a stem variable. If the hunk
index is omitted, the default from the POSITION command is used.

The following stem fields are filled:

@{CODE}
stem.ADDRESS            Address of the hunk data in memory.

stem.POSITION           The number of the hunk (identical to the index)

stem.TYPE               The type of the hunk as decimal number; 1001 is
                        CODE, 1002 is DATA, 1003 is BSS.

stem.SIZE               Number of defined bytes in this hunk.

stem.BSS                Number of bytes in the BSS part of the hunk.
                        stem.BSS+stem.SIZE give the total size of bytes in
                        this hunk.

stem.MEMTYPE            The memory attributes for this flag. The same number
                        that is to be passed to AllocMem().

stem.COUNT              Number of relocation lists for this hunk.
@{BODY}



@{B}RELOC [hunk [reloc]] 'stemvar' : get relocation information.@{UB}

Places information about the relocation list of the given by the hunk index
and the index of the relocation list within this hunk into the 'stemvar'. If
"hunk" or "reloc" are omitted, the defaults of the POSITION command are
used.


The following stem fields are filled in:

@{CODE}
stem.ADDRESS            The address where the relocation data are kept.

stem.SIZE               The number of relocation entries kept in this list.

stem.COUNT              ditto.

stem.HUNK               The hunk this relocation information is relative to.
@{BODY}


@{B}ENTRY [hunk [reloc [entry]] 'stemvar' : get entry information.@{UB}

Get information about an entry of the relocation list of hunk # 'hunk',
relocation list # 'reloc', entry number 'entry'. If one or more position
arguments are omitted, they are taken from the defaults of the POSITION
command. The results are placed in the stem variable 'stemvar; the following
fields are filled in:


@{CODE}
stem.OFFSET             The offset of the address to be relocated relative
                        to the given hunk.
@{BODY}


@{B}VERIFY on|off : enable/disable requester.@{UB}

This disables with "off" or enables with "on" the verification requesters.
VERIFY OFF is mandatory if the GUI is locked or the user doesn't have a
chance to satisfy the requester.


@{B}COUNT [hunk [reloc]] 'variable' : count nodes in given object.@{UB}

COUNT counts the number of hunks, the number of relocation lists of that
hunk or the number of entries in that relocation list, dependent on how many
arguments are given. For one argument - the variable name - the result is
the number of hunks, for two arguments the number of relocation lists in
that hunk, and for three arguments the number of entries in the relocation
list of the given index is put into the variable.


@{B}NAME ['variable'] : get name of actual project.@{UB}

Put the file name of the currently loaded project into the given variable,
or into RESULT.


@{B}RELOCATE : relocate all hunks to absolute addresses.@{UB}

Identical to the "Relocate" item in the @{"Proc Menu" link ProcMenu}. It
applies all relocations in the relocation lists to the hunks.


@{B}DELOCATE : delocate all hunks to relative offsets.@{UB}

The reverse operation to RELOCATE. Identical to the menu item of the same
name.


@{B}OPTIMIZE : optimize code hunks - remove all absolute data if possible.@{UB}

Applies the internal code optimizer to all CODE hunks which tries to remove
all absolute references if possible. The internal optimizer is pretty fast,
but not as smart as the @{".hop files" link HopFiles}.


@{B}APPLYPATCH file : apply an HOp patch file to the loaded binary.@{UB}

Loads the @{".hop file" link HopFiles} "file" and applies the patches
described in that file to the binary. The argument is a file name relative
to the "Hoppers" directory.


@{B}STARTMERGE : start merging with marked hunks.@{UB}

Applies all the merge operations setup by the merge links; identical to the
"Start Merging" item of the @{"Proc Menu" link ProcMenu}.


@{B}MERGERELOCS : merge all reloc sections possible.@{UB}

Merges all relocation lists possible. Identical to the menu item of the
same name.


@{B}SETHUNKTYPE [hunk] TO CODE=1001=0|DATA=1002=1|BSS=1003=2 : change type of hunk.@{UB}

Change the hunk type. If the "hunk" argument is omitted, the default of the
POSITION argument is used. The choices "CODE" or the numbers 1001 or 0
select CODE as new hunk type, DATA,1002 or 1 selects DATA and BSS or 1003 or
2 changes the type to BSS.


@{B}SETMEMTYPE [hunk] TO PUBLIC=1|CHIP=3|FAST=5 : set memory type of hunk.@{UB}

Change the type of the memory the hunk is placed in. If the "hunk" argument
is missing, the default of the POSITION command is used. THIS COMMAND DOES
NOT place the data in a new buffer, it just changes the internal settings.
To have any effect, the binary must be saved, and relocated afterwards.


@{B}MERGETO [hunk] : set hunk to merge to.@{UB}

Selects a hunk that the following hunks should be merged to, i.e. the merge
destination. If missing, the hunk index is taken from the defaults.


@{B}ADDMERGE [hunk] : add a hunk to a merge list of another hunk.@{UB}

Add the given hunk to the merge destination selected with MERGETO. If the
argument is missing, the default of POSITION is used.


@{B}REMMERGE [hunk] : remove a hunk from a merge list.@{UB}

Remove the hunk from the merge list, or clear the merge list the given hunk
is the destination of. Again, the default is used if the argument is
missing.


@{B}CLEARLINKS : clear all merge links.@{UB}

Removes all merge links completely.


@{B}AUTOLINKS : create merge lists automatically.@{UB}

Invokes the @{"Auto Merger" link AutoMerger} to build the merge links
automatically.


@{B}EDITRELOC [hunk] : edit reloc nodes of a hunk.@{UB}

Enter the relocation overview requester of the given hunk, show the
relocation lists in the requester. If the hunk index is omitted, use the
defaults of the POSITION command.


@{B}ADDRELOC hunk : add relocation list relative to 'hunk' to EDITRELOC hunk.@{UB}

Adds a relocation list relative to the given hunk to the hunk currently
edited, i.e. the hunk given to the EDITRELOC command. An EDITRELOC command
must have been specified before, thus the hunk overview list must be active.


@{B}REMRELOC reloc : remove relocation entry #reloc from EDITRELOC hunk.@{UB}

Removes a relocation list from the hunk selected before with EDITRELOC. BE
WARNED! The argument is again THE INDEX of the relocation list within the
list of all relocation lists, NOT the number of the hunk the list is
relative to.


@{B}MERGERELOC : merge relocation lists of EDITRELOC hunk.@{UB}

Merges all relocation lists of the hunk entered before with EDITRELOC.


@{B}SORTRELOC reloc : sort entries of relocation list #reloc relative to EDITRELOC hunk.@{UB}

Sorts the relocation lists whose index is "reloc" of the hunk entered
before with EDITRELOC. The argument is again AN INDEX, not a hunk number.
The sort direction depends on the settings menu and the SETREVERSE command.


@{B}SETREVERSE on|off : enable/disable reverse hunk sort.@{UB}

Selects the direction for sorting, as if the
@{"Settings Menu" link SettingsMenu} has been used. If the argument is "on",
reverse (descending) sorting is selected. "off" is the default and selects
ascending sorting.


@{B}EDITENTRY reloc : edit relocation entry #reloc of EDITRELOC hunk.@{UB}

Enters one of the relocation lists of the hunk specified with EDITRELOC. The
argument is an index, not a hunk number. The relocation list is then shown
entry by entry in the requester.


@{B}ADDENTRY offset : add relocation entry to EDITRELOC,EDITENTRY.@{UB}

If the hunk and the relocation list have been specified with EDITRELOC and
EDITENTRY, this command adds a relocation entry to the relocation list.


@{B}REMENTRY entry : remove relocation entry #entry from EDITRELOC,EDITENTRY.@{UB}

Remove an entry from the relocation list selected by EDITRELOC and
EDITENTRY. The "entry" argument is the index of the entry within the list,
not the relocation offset itself.


@{B}EDITHUNK : back to hunk structure.@{UB}

Quits the relocation overview or relocation list requester, cancels the
EDITRELOC and EDITENTRY commands and returns to the hunk requester. Must be
used to make any of the non-relocation/entry specific commands working
again.


@{B}SELECTMENU menu item [subitem] : remote select a menu point.@{UB}

Selects a menu item as if you've done that with the mouse yourself. "menu"
is the index of the menu counting from zero up from the left to the right.
"item" is the item to select, counting from zero, downwards. "subitem" is
the subitem index, if required.

This command cannot be used to change the state of a "checkmark" item in the
settings menu. Special commands are available for this.


@{B}INDEX [hunk [reloc]] OF hunk [hunk [offset]] 'stemvar' : returns indices of hunk, relative to hunk, and given offset.@{UB}

This command converts hunk and offset values to the indices required by most
other commands. Of all the position arguments, one to three arguments must
be present alltogether; thus, if the first "hunk" argument is present, only
the second "hunk" and "offset" are valid behind the keyword "OF" because the
hunk position is already known. The first two arguments "hunk" and "reloc"
specify a relocation or hunk index in the usual notation, by an index within
the list. The second arguments behind "OF" are, however, real hunk numbers
or real offsets. The following stem fields are filled in:


@{CODE}
stemvar.HUNK            the hunk index of the specified object
stemvar.RELOC           the reloc list index of the specified object
stemvar.ENTRY           the index of the specified entry.
@{BODY}

To give an example,


@{I}
INDEX 0 0 OF $4e 'stem'
@{UI}


will find the indices of the relocation entry at offset $4e in the
first hunk, the first relocation list within this hunk. However,


@{I}
INDEX OF 0 1 $4e 'stem'
@{UI}


will find the indices of the relocation entry at byte 0x4e of the hunk #0
which is relative to hunk #1.


You've now my permission to be confused.... (-:


@{B}CURRENTHUNK ['variable'] : returns number of EDITRELOC hunk.@{UB}

Returns the index of the hunk selected with EDITRELOC before or places the
value in the given variable.


@{B}CURRENTRELOC ['variable'] : returns number of EDITENTRY reloc.@{UB}

Returns the index of the currently with EDITENTRY selected relocation list.


@{B}LASTHUNK ['variable'] : returns number of POSITION hunk.@{UB}

Places the hunk index selected with the POSITION command in the given
variable, or returns it in RESULT.


@{B}LASTRELOC ['variable'] : returns number of POSITION reloc.@{UB}

Puts the relocation list index selected with the last POSITION command in
the given variable, or returns it in RESULT:


@{B}LASTENTRY ['variable'] : returns number of POSITION entry.@{UB}

Returns the with POSITION selected relocation entry index in the variable,
or in RESULT.


@{B}SETMERGETYPE 0=EQUAL|1=CDB|2=ALL : set merge hunk types.@{UB}

Changes the settings of the @{"Auto Merger" link AutoMerger} of which hunks
can be merged toghether. 0=EQUAL allows only merging of hunks of equal type,
1=CDB merges hunks in the direction "DATA to CODE", "BSS to DATA", 2=ALL
ignores the hunk types for merging.


@{B}MERGEDIFFMEM on|off : enable/disable merging of hunks in different memory types.@{UB}

Allows or forbids the merging of hunks in different memory types, as in the
"Merge Different Memory" item of the @{"Settings Menu" link SettingsMenu}.
The argument "off" forbids this merging operation, "on" allows merging of
different memory types.


@{B}MERGEADONLY on|off : merge only adjacent hunks/position does not matter.@{UB}

Allows or forbids the merging of hunks that are not adjacent. If "on", only
adjacent hunks will be marked for merging by the
@{"AutoMerger" link AUTOMERGER}; if "off", the hunk position is ignored.


@{B}MERGEBSS on|off : enable/disable merging of BSS segments.@{UB}

Enables or disables the merging of BSS segments. If "on", it is enabled.
"off" forbids merging of BSS hunks.


@{B}SETMERGETHRES 0=0|1=64|2=256|3=1K|4=4K|5=16K|6=64K|7=256K|8=ALL : set merge threshold hunk size.@{UB}

Sets the maximal hunk size that is still considered to be mergeable.


@{B}WRITE32SHORT on|off : enable/disable writing of RELOC32SHORT hunk.@{UB}

Enables writing of the Reloc32Short relocation hunk with "on", or disables
it with "off". Details and caveats of this hunk are found in the
@{"Settings Menu" link SettingsMenu}.


@{B}KEEPDEBUG on|off : enable/disable keeping of debug data.@{UB}

Currently unsupported, does nothing.


@{B}SPLITRELOCS on|off : allow/forbid the splitting of RELOC data for RELOC32SHORT@{UB}

If set to "on", Hunk will try to split large relocation entries in a part
that fits into a Reloc32Short hunk and a remainder which is kept in a
standard relocation hunk. If "off", this is never attempted.


@{B}SETDATASIZE [hunk] TO bytes : change data size of hunk to bytes.@{UB}

This command adjusts the data size of a given hunk. The adjustment is only
made in the internal data, no additional memory is allocated for example. To
have any effect of this command, save the binary and reload it again.


@{B}SETBSSSIZE [hunk] TO bytes : change bss size of hunk to bytes.@{UB}

Sets the size of the BSS section of a hunk. Again, this command doesn't
allocate any new memory, it just changes some internal data. The file must
be saved and reloaded to have any effect.


@{B}STRIPZEROS [hunk] : strip trailing zeros from a hunk.@{UB}

Checks the given hunk for trailing zeros and removes them by declaring this
data as BSS. Again, this doesn't affect the copy of the file in RAM, it just
changes the internal data counters.


@{B}REMHUNK [hunk] : delete a hunk.@{UB}

Removes the hunk given by the index from the binary. Watch out for pending
relocation information!


@{B}RX name : start arexx script.@{UB}

Starts an ARexx script. The script should be located in the "Rexx" drawer of
the "Hunk" directory.


@{B}PEEKBYTE offset ['variable'] : read byte from POSITION.@{UB}

Reads a byte from the hunk number set by the POSITION command; "offset" is
the byte offset from the beginning of the hunk, "variable" the name of the
variable to put the byte read into. The variable should be included in
single quotes to avoid that ARexx evaluates it. If omitted, the value is
returned in RESULT.


PEEKBYTE cannot read the BSS region of a hunk, it will cause a failure in
this case; this won't make too much sense anyways because the BSS region is
always set to zero.


Example:        Read the byte at offset 10 from hunk 3

@{CODE}
POSITION 3
PEEKBYTE 10 'byte'
say byte
@{BODY}


@{B}PEEKWORD offset ['variable'] : read word from POSITION.@{UB}

Read a word from the given offset, which is allowed to be odd. The hunk is
specified with POSITION.


@{B}PEEKLONG offset ['variable'] : read long from POSITION.@{UB}

Read a long word from the given offset, which is allowed to be odd. The hunk
is specified with POSITION.


@{B}PEEKSTRING offset limit ['variable'] : read string from POSITION.@{UB}

Read a NUL terminated string starting at the given offset. This function
reads at most "limit" bytes starting at "offset". It terminates if all
characters are read or a NUL is encountered. The result is put as a string
into the given variable, or into RESULT.


@{B}POKEBYTE offset value : write byte to POSITION.@{UB}

Write the given byte into the hunk specified by the POSITION command,
"offset" bytes from the beginning of the hunk.


"POKEBYTE" cannot be used to set the BSS region of the hunk; this is rather
senseless anyhow.


@{B}WARNING@{UB}: "Hunk" does usually check if the offset is in range, but
in case you alter the size of the hunk, "Hunk" will not be able to check the
range correctly. After having modified the size of a hunk, save the binary
back to disk and reload it to be on the safe side.


@{B}POKEWORD offset value : write word to POSITION.@{UB}

Write the given word into the hunk specified by the POSITION command,
"offset" bytes from the beginning of the hunk. "offset" is allowed to be
odd.


@{B}POKELONG offset value : write long to POSITION.@{UB}

Write the given long word into the hunk, "offset" bytes from the beginning.
"offset" is allowed to be odd.


@{B}POKESTRING offset string : write string to POSITION.@{UB}

Write a NUL terminated string into the hunk specified by the POSITION
command, starting at "offset" bytes from the beginning. The 'NUL' character
terminating the string is written as well.

@ENDNODE
@NODE HopFiles "External Hunk OPtimizers"
The external hunk optimizer script files, or for short ".hop" files or
"hoppers" provide information to modify binaries "in place" without touching
the source code. They can be used for post-processing binaries by a sort-of
"peephole optimizer" that replaces code sequences by optimized versions of
this code. Since this modification is done without using the source code, it
may happen that these modifications corrupt the binary if the code is used
in a non-standard way. Possible problems arise from self-modifying code
(urgh!) or from programs that depend in some other way in the precise
outline of their binary, e.g. programs that checksum their own code.
Therefore, using the "hoppers" is never 100% waterproof and it is highly
recommended that you try a patch on a copy of the binary first. The hoppers
in the "Hunk" package replace only code segments by 100% functional
identically but probably shorter or faster sequences, but this is
no guarantee for their usefulness. To say this in one word: Just be careful
with this stuff!



@{"Using the hoppers" link HopUsage}

        How to run them and what the hoppers in this archive do.



The hoppers are plain ASCII files that can be written by any text editor of
your choice. A very primitive "programming language" expresses what to patch
where and to replace it by what.


@{"Writing your own hoppers" link HopWrite}


        The syntax of the .hop files. This is definitely for experts only.


@ENDNODE
@NODE HopUsage "Using the hoppers"
@TOC HopFiles
To apply a patch in the form of a hop file,


o Load the binary to be patched with the @{"Project Menu" link ProjMenu}


o Select "Apply Patch..." from the @{"Proc Menu" link ProcMenu}


o Select the patch from the requester list in the top half of the screen.


The "Hunk" package comes with the following scripts:

____________________________________________________________________________


Name:                   Ace_235.hop

Contributed by:         L. Lucius, adapted by Thomas Richter.

Function:

Replaces the multiply, division and modulus subroutines of the ACE 2.35
compiler output by MC68020 specific improved versions.


Restrictions:           The output can't be run by the 68000 and the 68010.


____________________________________________________________________________


Name:                   AmigaE_32a.hop

Contributed by:         L. Lucius, adapted by Thomas Richter.

Function:

Replaces the multiply, division and modulus subroutines of the AmigaE
compiler, version 3.2a, by MC68020 specific improved versions.


Restrictions:           The output can't be run by the 68000 and the 68010.


____________________________________________________________________________


Name:                   AmigaLib.hop

Contributed by:         L. Lucius, adapted by Thomas Richter.

Function:

Replaces the multiply, division and modulus subroutines of the amiga.lib,
used as link library by various compilers, by MC68020 specific improved
versions.


Restrictions:           The output can't be run by the 68000 and the 68010.


____________________________________________________________________________


Name:                   Asl_Add.hop

Contributed by:         Jess Sosnoski

Function:

Replaces the "asl.? #1,dx" and "lsl.? #1,dx" commands by the faster
"add.? dx,dx" command.


Restrictions:           None

____________________________________________________________________________


Name:                   Dice_206.hop

Contributed by:         L. Lucius, adapted by Thomas Richter.

Function:

Replaces the multiply, division and modulus subroutines of the Dice
2.06 C C compiler (the freeware version) by MC68020 specific improved
versions.


Restrictions:           The output can't be run by the 68000 and the 68010.


____________________________________________________________________________


Name:                   AmigaE_32a.hop

Contributed by:         L. Lucius, adapted by Thomas Richter.

Function:

Replaces the multiply, division and modulus subroutines of the AmigaE
compiler, version 3.2a, by MC68020 specific improved versions.


Restrictions:           The output can't be run by the 68000 and the 68010.


____________________________________________________________________________

Name:                   General.hop

Contributed by:         Thomas Richter

Function:

Replaces the absolute addressing mode of the most popular commands by PC
relative versions, if possible, thus reducing the size of the relocation
table.


Restrictions:           The modified program may run slower on the newer
members of the MC68K family since the gained space is filled by NOPs.

____________________________________________________________________________

Name:                   General020.hop

Contributed by:         Thomas Richter

Function:

Replaces the absolute addressing mode of the most popular commands by PC
relative versions, if possible, thus reducing the size of the relocation
table. This is the version for the MC68020 and later processors.


Restrictions:           The output can't be run by the 68000 and the 68010
but will be faster for the newer processors than the General.hop output.

____________________________________________________________________________


Name:                   HCE_NorthC.hop

Contributed by:         L. Lucius, adapted by Thomas Richter.

Function:

Replaces the multiply, division and modulus subroutines of the HCE 1.0 and
the NorthC 1.2 compiler by MC68020 specific improved versions.


Restrictions:           The output can't be run by the 68000 and the 68010.


____________________________________________________________________________


Name:                   HCE_NorthC.hop

Contributed by:         L. Lucius, adapted by Thomas Richter.

Function:

Replaces the multiply, division and modulus subroutines of the HCE 1.0 and
the NorthC 1.2 compiler by MC68020 specific improved versions.


Restrictions:           The output can't be run by the 68000 and the 68010.


____________________________________________________________________________


Name:                   Jump.hop

Contributed by:         Jess Sosnoski

Function:

Replaces long branches by word sized and word sized branches by short
branches whenever possible. Replaces subroutine jumps at the end of routines
by direct branches to the routines, saving some stack. Replaces relative
jumps by branches.


Restrictions:           The stack outline of some routines might differ, but
this is usually not a problem.

____________________________________________________________________________


Name:                   Lattice.hop

Contributed by:         L. Lucius, adapted by Thomas Richter.

Function:

Replaces the multiply, division and modulus subroutines of the Lattice C
compiler by MC68020 specific improved versions.


Restrictions:           The output can't be run by the 68000 and the 68010.

____________________________________________________________________________


Name:                   Libnix.hop

Contributed by:         L. Lucius, adapted by Thomas Richter.

Function:

Replaces the multiply, division and modulus subroutines of the Libnix
library, used by the GNU GCC C compiler by MC68020 specific improved
versions.


Restrictions:           The output can't be run by the 68000 and the 68010.

____________________________________________________________________________


Name:                   Manx.hop

Contributed by:         L. Lucius, adapted by Thomas Richter.

Function:

Replaces the multiply, division and modulus subroutines of the Manx Aztec C
compiler by MC68020 specific improved versions.


Restrictions:           The output can't be run by the 68000 and the 68010.

____________________________________________________________________________


Name:                   Oberon-A_16.hop

Contributed by:         L. Lucius, adapted by Thomas Richter.

Function:

Replaces the multiply, division and modulus subroutines of the Oberon A
1.6 compiler by MC68020 specific improved versions.


Restrictions:           The output can't be run by the 68000 and the 68010.

____________________________________________________________________________


Name:                   OberonII-30.hop

Contributed by:         L. Lucius, adapted by Thomas Richter.

Function:

Replaces the multiply, division and modulus subroutines of the Oberon
2.30 compiler by MC68020 specific improved versions.


Restrictions:           The output can't be run by the 68000 and the 68010.

____________________________________________________________________________


Name:                   PCQ_12b.hop

Contributed by:         L. Lucius, adapted by Thomas Richter.

Function:

Replaces the multiply, division and modulus subroutines of the free PCQ
pascal compiler 1.2b compiler by MC68020 specific improved versions.


Restrictions:           The output can't be run by the 68000 and the 68010.


Note:                   This might even work with newer versions of PCQ.

____________________________________________________________________________


Name:                   SASC_6xx.hop

Contributed by:         L. Lucius, adapted by Thomas Richter.

Function:

Replaces the multiply, division and modulus subroutines of the SAS
C compiler, versions 6.00 or better by MC68020 specific improved versions.


Restrictions:           The output can't be run by the 68000 and the 68010.

____________________________________________________________________________

Name:                   Silver.hop

Contributed by:         L. Lucius, adapted by Thomas Richter.

Function:

Replaces the fixed point multiply subroutines of TurboSilver by MC68020
specific improved versions.


Restrictions:           The output can't be run by the 68000 and the 68010.

____________________________________________________________________________

Name:                   Silver_MULU_256.hop

Contributed by:         L. Lucius, adapted by Thomas Richter.

Function:


Replaces the long x long multiply subroutines of TurboSilver by MC68020
specific improved versions.


Restrictions:           The output can't be run by the 68000 and the 68010.

____________________________________________________________________________

@ENDNODE
@NODE HopWrite "Writing your own hoppers" link HopWrite
@TOC HopFiles
This section discusses the syntax of the hunk optimizer scripts. Before
you're going to write your own "hopper", you should have some experience
with programming languages and know a lot of the MC68000 object codes - not
to be mixed with assembly language, which is almost but not completely the
same. The hoppers operate on object code level, hence you need a book on how
the MC68K family opcodes are encoded - or an assembler.


Basic operation of the hoppers:


The .hop files implement a very simple "pattern matching" on object code
level. If the input pattern of the binary matches a certain "string" of
numbers, these numbers are replaced by the "output pattern", both given in
the script in the form of binary numbers. The power of the hoppers lies in
specific "wild cards" in the pattern matching and the possibility of
assigning the contents of the code to variables that can be used again in
the generation of the output code.


Two types of variables are available: Numeric variables and address
variables. The contents of the later kind will be automatically converted
from offsets relative the current position to absolute offsets and will
insert or remove relocation information if necessary. If the offset is out
of range, the replacement will be canceled automatically, thus "Hunk" will
never create invalid offsets.


Syntactical elements of the .hop language:


@{B}Comments, blank lines@{UB}


Blank lines are ignored. Comments are introduced by a semicolon ";".
Everything behind the semicolon, including the semicolon itself is ignored.


@{B}Commands@{UB}

These commands control the function of a ".hop" script. Commands begin
ALWAYS with a hash-mark "#" on the first column of a line. The current
version of "Hunk" knows the following commands:


#match

        Starts the input pattern. The code below is used as input pattern.
If any match is found in the binary, the pattern below #match is replaced by
the pattern behind #replace.


#replace

        Starts the output pattern. This is the code that replaces the input
pattern if a match is found and all offsets can be made fitting. A #replace
command must always preceeded by the input pattern defined with #match some
lines above.


#end

        Ends the output pattern and one patch. Must be preceeded by a
#replace some lines above.


#code

        Will make the input pattern matching only contents of CODE hunks.
Must be given below #match but before the input pattern.


#data

        The input pattern matches only DATA hunks. Must be given below
#match but in front of the input pattern.


#all

        The input pattern matches all hunks. This is the default.



@{B}The pattern definition@{UB}


Everything that's neither a command nor a comment is a pattern. A pattern is
simply one or more hexadecimal or binary numbers that represent data in the
hunk. Patterns work always in full words, that is a pattern won't patch
anything at an odd address; but this restriction can be somewhat weakened by
using wild cards.


The pattern data between #match and #replace describes the input data to be
replaced, the pattern between #replace and #end is the output pattern that
is patched in.


Patterns in hexadecimal notations are simply represented by a four digit =
one "word" hexadecimal number in standard notation. Additional to the
sixteen hex digits 0..9 and A..F, the wildcards X,Y and R can be used. See
below for more information about them.


Patterns in binary notation start with a percent "%" sign, followed by the
sixteen digits, either 0..1 or the wild cards X and Y, that are required to
define a binary word.


More than one pattern word can be placed in a row simply by putting white
spaces between the pattern words. The RRRR wildcard is special in this sense
that it must always come in complete pairs in one line.


@{B}Wildcards@{UB}


Three wildcards, X,Y and R can be used in the pattern data whenever a
hexadecimal or binary digit would be appropriate.


@{B}The X wildcard@{UB}


This is simply a "do not care" digit. It is ignored for the input pattern
and set to zero for the output pattern. However, the value of the "X" bits
can be assigned to a variable on input and be read from a variable on
output. Thus, you'll be able to save some input bits and put them back in
the output stream. The "X" wildcard should be used whenever pure data has to
be set or replaced. There are more appropriate wildcards for offsets or
addresses.


@{B}The Y wildcard@{UB}


The "Y" wildcard represents also a "do not care" digit, but it works a bit
different for variable assignment and in the way it is interpreted. The
value of the "Y" bits on input is seen to be an offset relative to the
current address of the pattern and converted to an absolute offset relative
to the hunk basis before it is assigned to a variable. Thus, "Y" represents
"any offset" instead of "any number".


The "Y" wildcard behaives a bit different on an output assignment, too. If
an assignment is made to "Y" bits in the output pattern, the assigned value
is first read as an absolute offset relative to the hunk basis. This offset
is then converted to a signed displacement relative to the current address.

"Hunk" tries now to fit this offset in the output "Y" bits. If this is not
possible because the offset is too large, the replacement will be canceled
at all. Hunk will, therefore, never generate out-of-range offsets. Remember
that this is quite different to the "X" bits which are simply "cut down" on
output.


@{B}The "R" wildcard@{UB}


This wildcard matches again "any data" in the hunk, but the match is only
successful if an relocation entry TO THE SAME HUNK for this data exists,
i.e. the address represents an absolute address within the code. Since the
Os is only able to relocate complete long words, the "R" wildcard must
always come in two pairs of a full word "R" pattern like "RRRR RRRR". It is
illegal to use only one word of "R"s or even use a partial word of "R"'s.

On a match on input, the relocation entry IS REMOVED from the code; it's
value should therefore be better assigned to a variable or it is lost.

On output, placing an "RRRR RRRR" in the output pattern creates a relocation
entry, the value of this entry should be taken from a variable, of course.


"R" and "Y" variables fit together. The implicit conversions for "Y" and "R"
are made in a way such that an absolute address of a relocated address of
"RRRR RRRR" can be assigned to a variable which is later on assigned to an
offset of "Y"'s. Hunk will keep track of whether the offset fits really into
the output "Y" replacement and will cancel the replacement process if not.
The process works of course also in the different way 'round, replacing
displacements by matching with "Y" and generating relocation entries with
"RRRR RRRR" on output.


@{B}Variable assignments@{UB}


On input, two assignment operators "#=" and "\@=" can be used to put the
bits of the "X","Y" or "R" wildcard into a variable. The assignment operator
has to be put behind the pattern, followed by a unique variable name,
consisting of any combinations of the letters "A-Z" and "a-z". The
difference between "#=" and "\@=" is that the first assigns the "X" bits of
the pattern - "#" for numeric - whereas the later assigns the offsets read
by the "Y" and "R" bits - "\@" for address. It is therefore possible to
define two variables per line, one taking care of the "X" bits and another
for the "Y" and "R" bits, simply by writing the two assignments behind each
other:


%11101010110101101XXX YYYY      #= EA   \@= displacement


will assign the three lowest order "XXX" bits to the variable "EA" and the
displacement in the next word to "displacement". It is important to note
that no bits are shifted "in place", neither on input nor on output. If the
"X" bits are placed in the bit positions 21-15, that is where they are
placed in the variable as well.


Quite the same operators exist for output assignments as well, they just
work in the opposide direction in the sense that they transfer the variable
contents back to pattern from the right to the left. Again, "\@=" fills "R"
and "Y" wildcards, "#=" fills the "X" wildcard. As on input, no bit shifting
occurs.


To be able to do this, four


@{B}Operators@{UB}


exist, exclusively for the "#=" assignment on output. These operators must
be placed behind the variable name and must be followed by a number. None of
these operators change actually the contents of the variable, they just
operate on the contents before assigning it.


"<<" and ">>" will shift the variable contents by the amount of bits given
behind the operator to the left resp. to the right before making the
assignment. Thus,


%11101010110XXX101000  #= EA << 3


will shift the contents of "EA" three bits to the left, then masking the
result into the "XXX" at bit positions 6-8. THE RESULT MIGHT BE ZERO if the
corresponding bits in the variable have not been filled. "Hunk" doesn't care
about this!


Another set of operators are the "duplicate and shift" operators, "|<" and
"|>". They copy the variable contents, shift the copy by the given amounts
of bytes and logical "or" the result again with the variable contents before
assigning the resulting value. Thus,


%11101010110XXX101XXX  #= EA |< 3


will put the lowest three bits of the variable "EA" into bit positions 0-2
and, due to the copy and shift operation, into 6-8 bits of the output as
well.

@ENDNODE
@NODE HISTORY "Version History"

Version 2.10:

Removed a bug in the Rexx interface, added the external hunk
optimizers, added the possibility to split the relocation data in long
and short relocation hunks. Thanks to Jörg Riemer for the useful discussion
about this problem.


Version 2.11:

Fixed another set of bugs in the ARexx interface. Added an automatic patch
script. Added the option to remove trailing zeros. Improved the file
requester. Removed a bug from the file requester.


Version 2.11.1:

Hunk unchanged, but updated the General020 optimizer a bit.
Replaced the NOP that's patched in by a LEA (A6),A6 to avoid pipeline stalls
of the 68060 processor. Updated the PA.rexx script to run the PowerPacker
and to allow multiselection. However, this doesn't work with RTPatch due to
a bug in this patch.


Version 2.12:

Improved the ".hop" syntax a bit and added two new ".hop" scripts, based on
ideas by "Jess". Thanks! Drew a new icon. Added another set of ARexx
scripts.


Version 2.12.1:

Not a new release, but added another ".hop" script by Jess Sosnoski,
Jump.hop - a general branch optimizer. Thanks, Jess!


Version 2.13:

Fixed a lot of bugs in the ARexx interface again. Changed the syntax or the
names of certain ARexx commands "for general entertainment". (-:


Version 2.14:

Added the PEEK and POKE related ARexx commands.


Version 2.15:

Fixed a problem with one of the memory copy operations. It used overlapping
domains which are not officially supported by the Os. Fixed.


Version 2.20:

Rewrote the GUI components of Hunk, they do no longer require a private
screen. Hunk will now open on the workbench. Removed quite a lot of obsolete
1.3 specific code and replaced it by more modern solutions. Added Boopsis
for the gadgets. The result looks still the same, but it wouldn't have
looked the same if I had used plain intuition gadgets.


Version 2.22

Fixed the width of the hunk relocation requester.

@ENDNODE
@NODE INDEX "Index"
                               The Index
@{CODE}
        A...

        @{"ARexx interface" link AREXXINTER}
        @{"ARexx scripts contained in the package" link INCLUDEDSCRIPTS}
        @{"Automatic merge link creator" link AUTOMERGER}

        E...

        @{"Edit Menu" link EDITMENU}
        @{"External Hunk OPtimizers" link HOPFILES}

        F...

        @{"Failure codes" link FAILURES}
        @{"File Requester" link REQUESTER}

        H...

        @{"History" link HISTORY}
        @{"Hoppers, .hop-Files" link HOPFILES}
        @{"Hoppers, using them" link HOPUSAGE}
        @{"Hunk failure codes" link FAILURES}
        @{"Hunk Processor Menus" link MENUS}
        @{"Hunk requester" link HUNKREQ}

        I...

        @{"Installation" link INSTALL}

        L...

        @{"Language, of .hop files" link HOPWRITE}
        @{"Licence Agreement" link LICENCE}

        O...

        @{"Overview" link OVERVIEW}

        P...

        @{"Patch in a subroutine" link SUBPATCH}
        @{"Proc Menu" link PROCMENU}
        @{"Project Menu" link PROJMENU}

        R...

        @{"Recognized Tool Types" link TOOLTYPES}
        @{"Recommended readings" link BOOKS}
        @{"Reloc Menu" link RELOCMENU}
        @{"Requester" link HUNKREQ}
        @{"Requirements" link REQUIREMENTS}

        S...

        @{"Settings Menu" link SETTINGSMENU}
        @{"Syntax of .hop files" link HOPWRITE}

        T...

        @{"Tool Types" link TOOLTYPES}
        @{"Tutorial session" link TUTORIAL}


        U...

        @{"Using the hoppers" link HOPUSAGE}

        V...

        @{"Version History" link HISTORY}

        W...

        @{"Which programs should be processed?" link GUIDELINES}
        @{"Writing your own hoppers" link HOPWRITE}


@{BODY}
@ENDNODE

