[LANGUAGE english; PARENT keywords; PAGE 11-62]
[C;6;B]		NODATAOVERLAID
[7]Default: data in overlay are allowed
[J;1;N]
  Only the commercial version will have this instruction fully \
supported. Registred people will receive that version.

  This instruction will suppress any DATA or BSS hunk from \
overlaid units. This is useful when you do not want to know \
how DATA and BSS hunks are managed. Note that you still \
have to forget the usage of any kind of data within your \
hunks of code (except for case tables or that kind of \
'code' things.)
  This instruction is useless on executable files. Those \
files are supposed functional and cannot be changed.

  In one way this is not the most intelligent usage of \
overlaid program. But your C may not give you a choice.

  Example of code:


  This first example will need the NODATAOVERLAID:
[5]
    char *getdefaultstring()
    {
        return ("I am the default string");
    }
[INDENT 4; 2]
    using a compilation mode which forbid strings \
to be compiled within the code hunk.
[INDENT; 1]
  or
[5]
      section text,code

    getdefaultstring:
      move.l #defaultstring,d0
      rts

      section data,data

    defaultstring:
      dc.b "I am the default string",0
[1]
  This second example is not a valid overlay object:
[5]
    char *getdefaultstring()
    {
        return ("I am the default string");
    }
[INDENT 4; 2]
    using a compilation mode which forces strings to be \
compiled within the code hunk.
[INDENT; 1]
  or
[5]
      section text,code

    getdefaultstring:
      move.l #defaultstring,d0
      rts

    defaultstring:
      dc.b "I am the default string",0
[1]
  Note: in both cases the function is suppositivly called \
from an external hunk. This kind of function may be called \
by the overlaid unit it-self.

  This third example shows the best way to do it:
[5]
    char *defaultstr = "I am the default string";

    char *getdefaultstring()
    {
        char *s;
        s = malloc(strlen(defaultstr));
        ... /* handle memory errors */
        strcpy(s, defaultstr);
        return (s)
    }
[1]
  or
[5]
    char *defaultstr = "I am the default string";

    char *getdefaultstring(char *s) /* s has to be large enough */
    {
        strcpy(s, defaultstr);
        return (s)
    }
[1]
  or
[5]
      section text,code

    ;input: a0 as the destination buffer
    getdefaultstring:
      lea     defaultstring,a1
      move.l  a1,d0
    .cpy
      move.b  (a1)+,(a0)+
      bne.b   .cpy
      rts

      section data,data

    defaultstring
      dc.b "I am the default string",0
[1]
  See also:
[L;3][LINK alv]			    ALV
[LINK autooverlay]		    AUTOOVERLAY
[LINK filename]			    <filename>
[LINK nodataoverlaid]		    NODATAOVERLAID
[LINK nospecialdebug]		    NOOVLDEBUG
[LINK overlay]			    OVERLAY
[LINK overlayobject]		    OVERLAYOBJECT
[LINK shortreloc]		    SHORTRELOCOVERLAY
[5; LINK about; GOTO address]	    Become Registred
