
README for SHADOW distribution Version 4.3.  Dated: 01 Feb 1992


There are three separate example programs included here, with one file
(Gui/gui.c) shared by both Browser/Browser and SWRI/Control.


Test/PerfTest:

The Test/PerfTest allows you to test various speeds of some of SHADOWs
capabilities.  For instance, its semaphoring speed, and its AVL tree
handling.  You might note that these numbers are similar, implying that
the overhead of the semaphoring routine is the bottleneck.  You would
be right -- the semaphore routines could be improved somewhat.

Here is an example run of this program:
   1.Work:JazzBench/Kernel/Examples/Test> PerfTest ?

   Okay, this is how you want to run this program:
           PerfTest MEMORY/S,METHOD/S,TEST/S,AVL/S,SEMAPHORE/S,STRING/S

   1.Work:JazzBench/Kernel/Examples/Test> PerfTest SEMAPHORE AVL
   Beginning SHADOW AVLTree speed test of FindBinNode:
   SHADOW AVLTree speed test completed.
           8476 SHADOW AVLTree FindBinNode()/second

   Beginning SHADOW AVLTree speed test Add/Remove:
   SHADOW AVLTree speed test completed.
           2794 SHADOW AVLTree Adds-Removes/second

   Beginning SHADOW semaphore speed test:
   SHADOW semaphore test completed.
           8695 SHADOW semaphore Psem()-VSem()/second

   Attempting to purge SHADOW and PPIPC libraries.


Browser/Browser:   <-- you want topaz 11 in fonts: !!!

The browser is a pretty advanced program which allows you to get a
run-time updated view of all classes and objects in the system.  It
allows you to view all instances on class lists, all methods, all
arguments for a method, and all attributes.

In addition, as classes are created and destroyed, the Browser program's
displays are updated automatically.  The same is true for the number of
patches which are located in the Method display window.

To see this, run the Browser:
      Shell Prompt 1> run Browser

Now select the MetaClass name in the scrolling list.  You should see
the information updated below to show that you have selected the Meta
properly.  Now hit the Instances button.  Another window will open,
showing you a list of all the classes that exist in SHADOW at that time.

Move that window elsewhere -- the upper right hand corner of the screen is
best.  Go back to the shell, and:
      [Ouput from Browser removed]
      Shell Prompt 1> cd /SWRI
      Shell Prompt 1> execute script

You will see several more windows open, and most interestingly, the list
of classes in the Browser has gotten longer!

Now find the Meta listing again, and this time select MetaCluster, and
then hit the Instances button.  The new window will display two clusters.
Select the 'SWRI NDE Control Cluster' cluster and hit the Methods button.
Now select the only Method listed.

The patch number should say '2'.  The two patches were created by the
filter and by the outputfilter programs.  Now find the SWRI window with
the large QUIT button, and hit that button, watching the Patches number.

You should see that number fall to zero.  In addition, the Class listing
should get shorter as well as the Cluster listing.

But Wait!  We're looking at a METHOD in the "SWRI NDE Control Cluster",
right?  And it's gone???  Wrong.  If you type 'status' in your shell,
you'll see that the Control program is still running, and it will
continue to exist as long as you have a pointer to a class where one
of its methods refers to that program.  Close the Method Window, do a
'status' again, and Control should be gone!  The joys of resource tracking
folks!

That gives you an idea about the browser.  Feel free to abuse it and send
me bug reports!


SWRI/lotsOfProgram:  <--- topaz 11 in fonts: !!!

Use the script to start everything up.  You should notice several things.
First, the program doesn't do anything terribly useful :).

But seriously, try running 'outputfilter' after starting up the script.
You'll notice that although another outputFilter window starts up, the
new process exits.  That's because it automatically detects that the
program is already running, and merely instantiates itself again.

In addition, sending a ^C to any of the program quits the programs --
all of the instances of those programs, in fact.  And sending a ^C to the
Control program shuts the entire system down.

So what does this thing do?

Well, Input creates a bunch of random data, sticks it onto a composite,
and sends the composite a method.

Filter Patches that method during startup.  When it receives the method,
it takes the composite, copies the data into a new object on the
composite, and smooths out the data in the new object.

OutputFilter Patches the method during startup as well.  When it receives
the method, it finds this modified data and displays it.

Output Patches the method too.  When it receives the method, it finds the
unmodified data and displays it.

Not too interesting, but displays co-operating processes, etc. etc.


Gui/gui.c:

File included for both SWRI/Control and Browser/Browser.
