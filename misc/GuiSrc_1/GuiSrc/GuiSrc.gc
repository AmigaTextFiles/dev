G4C
;DONE EXP 000 eliminate FSearch.gc ?
;EXP000 srcgui: => general directory chosen by user
; do not change/use LV1 : MkProtos, MkDef, FcA1, DTAlpha, Restore(LV2) 
; are using/changing LV 1 : FcA2
; do not change LV2 FcA2
; uses only LV1 <Alpha>
WINBIG 0 10 600 434 GuiSrc.gc
 
WINTYPE 11110001
WINBACKGROUND SOLID 19 17

xONLOAD
 Gosub #this Default

xROUTINE Default
 PortNm = CYGNUSED
 SrcDir = "srcGui:"
 StrucDir = "srcStruc:"
 ProtoFile = "srcGui:gui_protos.h"
 ProtoName = gui_protos.h
 FuncAlphaPath = "SrcStruc:functionsStructure"
 ProtoPath = "SrcStruc:function_protos"
 StrEq = "=========================================="
 LV1Mode = Defs 
 NwInit = 0
 MkDef = "0"
 Edit_ = 0
 MinExp = 5 ; minimum number of expected functions, if less program assumes a wrong file was chosen as ProtoFile
 IFEXISTS ASSIGN ~srcGui:
	GuiOpen #this
	Gosub #this Init
 ENDIF 
 LVUse #this 1
 LVChange $FuncAlphaPath
 LVUse #this 2
 LVChange $ProtoPath
 
 GuiOpen #this
 
xONRELOAD
 Gosub #this Default

xONCLOSE
 GuiQuit #this

TEXTFILE t:GSrc_lic&credits
 This SW is copyrighted to me,Joseph Duchâtelet the author.
 No guarantee is given.
 You are free to use it as is and or adapt it for your private needs.
 No commercial use allowed without my written permission.
 In case you want to spread any adaption, it should respect the same 
 terms  and mention this initial copyright.
 
 The program makes use of Gui4Cli which is copyrighted to Dimitris 
 Keletsekis and of his search replacement fsearch
 see http://users.hol.gr/~dck/gcmain.htm or Aminet.
 reach him at dck@hol.gr or join the Gui4Cli maillist.
### 

TEXTFILE t:GSrc_Goal 
 This program helps you analyse and clean up an existing set of sourcefiles appearing in one directory.
 We call this the Source Directory (SrcDir) which will be assigned to "srcGui:"
 The files herein are supposed to be the source files for only one program.
 There may be subdirectories in SrcDir, but they should not contain function defining source files.
 
 The program expects one of the source files to contain mainly the function prototypes and maybe 
 the extern declarations of used datatypes. We call this the ProtoFile.
 

 This program allows automatic generation of the following lists:
 -  a compact list of the function prototypes appearing in this ProtoFile. 
	It eliminates comments, extern data lines, blank lines , and present them in 
	LV2 (right ListView). This is done automatically on launch of the program if no
	(permanent) assigns (srcGui: SrcStruc: ) were made allready.
 - an alphabetically ordered list, derived form the former) and showing each source file that 
	defines 	at least one function. Each such filename is followed by the alphabetic list of 
	the functions it defines;
	This list will be presented in LV1 (Left Listview)
 
 Buttons allow you 
 - to vary the order of representation in LV2 , function-alphabetically <FcA1> & <FcA2> 
	or datatype-alphabetically <DTAlpha> 
	or restore to the original generated list <restore> which follows the order of appearance 
	in the ProtoFile 
 - list all calls and function definitions contained in the (alpha ordered) source files in LV1
 	<MkCalls>
 - list only the functionnames in LV1 in alphabetic order <Alpha>
 
 Doubleclicking on a (function)line in LV1 or LV2 opens new gui's that allow by clicking on 
 a line to edit the file containing the given line. If the line has a linenumber visible,
 the editor will jump to this line. 

 The generated lists are saved in a "stucture directory" called StrucDir and assigned to srcStruc:
 
 If you want to analyse a new sourcedirectory hit the <Init> button.
 If you did update your sources since the program was started, you can update the LV2 and LV1 with
 <MkProtos> and <MkDef> IN THIS ORDER  
###


TEXTFILE env:.GSrc_MkDef
 Searching for the function definitions will be an interactive process unless
 you did take care to standardise the appearance of the function prototype and 
 the function definition: they should be identical (blanks, * ) up to the first 
 open bracket "("
 Indeed  the proto's and the function definition will often differ slightly
 eg struct lister * makelister (... 
                                      versus 
    struct lister *makelister (...
 It can take time to correct these differences. 
 You are requested to hit <MkDef> repeatedly till all differences are eliminated
###

TEXTFILE t:GSrc_Limits
 When the functions SetGadget is defined in some file say and  
		SetGad in an other, SetGad will also appear as if defined in the first one

 
###


xROUTINE BUTTON 0 0 60 14 Function ; <<Function>>
 GadHelp " Search for function definition" 
 LVUse #this $$LV.ID
 LVMulti First
 IF $$LV.LINE > ''
	Gosub #this FindFunc$$LV.ID
 ELSE
	EzReq "Select a function to find before using this button or doubleclick on it in LV" ok var 
 ENDIF
	
xROUTINE xBUTTON 60 0 60 14 Calls  ; <<Calls>>
	GadHelp " Search for function calls for first selected function of left LV" 
	LVUse #this 1
	LVMulti first
	IF $$LV.LINE > ""
		Gosub #this FindCalls $LVVar1
	ELSE 
		EzReq "Select a function to search calls for" ok var
	ENDIF



xROUTINE FindCalls FuncName 
 IF $FuncName > ""
	CLI 'c:FSearch >t:GSc_Calls  $SrcDir TXT="$FuncName" VERBOSE LINE NOBIN'
	GuiLoad :GuiSrc.lr
 	LVUse GuiSrc.lr 1
	LVChange t:GSc_Calls
 ELSE
	EzReq "Searchstring empty" ok var
 ENDIF
	


xROUTINE xBUTTON 180 0 60 14 Info  ; <<Info>>
 Gadhelp "for development use"
 LVUse #this 2
 EzReq "total lines LV $$LV.ID = $$LV.TOTAL\nLV2 Line = *$LVVar2\*" ok var

xBUTTON 120 0 60 14 Alpha  ; <<Alpha>>
 GadHelp "List only Function names alphabetically (no source files)"
 IF $LV1Mode = Defs
 	LVUse #this 1
 	LVChange $FuncAlphaPath
 	Gosub #this FuncAlpha/ ; EXP works only onformat =====/ underlined in LV1
	LV1Mode = Alpha
 ENDIF

xROUTINE FuncAlpha/
 LVuse #this 1
 LVSearch "/" CI first
 WHILE $$LV.LINE > ''
	LVDel -1
	LVSearch "/" CI first
 ENDWHILE
 LVSort ASC
 LVGo first
 WHILE $$LV.REC = ""
 	LVDel -1
	LVGo first
 ENDWHILE
	

xBUTTON 240 0 60 14 Restore  ; <<Restore>>
 Gadhelp "Present function definitions per file as seen on open & saved in functionsStructure"
 LVUse #this 1
 LVChange $FuncAlphaPath
 LV1Mode = Defs

xBUTTON 300 0 60 14 MkProtos  ; <<MkProtos>>
 GadHelp "(Re)generate the function prototypes list from prototype file"
 Gosub #this MkProtos

xROUTINE MkProtos
 SetGad #this 2 HIDE
 ; SetGad #this 2 OFF
 LVUse #this 2
 LVChange $ProtoFile
 Gosub #this CommentsAway

 
 LVGo first

 WHILE $$LV.LINE > "" ; cutvar ?
	2Del = 0
 ;say "$LVVar2 $$LV.LINE"
	IF $LVVar2 = ''
		2Del = 1
	ELSE
		ParseVar LVVar2
		
		IF $$Parse.0 = extern
			2Del = 1
		ENDIF
	ENDIF
;EzReq "$$Parse.0 $LVVar2" ok var
	IF $2Del = 1
		LVDel -1
;say $$LV.LINE
		
	ENDIF
	LVGo Next
 ENDWHILE
 LVGo first
 Extract LVVar2 CLEAN 1stLine
 WHILE $1stLine = ""
	LVDel -1
 	LVGo first
	Extract LVVar2 CLEAN 1stLine
 ENDWHILE
 EzReq "Save this file ? " ok|no var

 IF $var = 1
	LVSave $ProtoPath ;
	EzReq "Saved as $ProtoPath" ok var
 ENDIF
 SetGad #this 2 SHOW
 SetGad #this 2 ON
 ;Redraw #this ; DIM gives a crash on AMI if OFF & ON
 LVMulti SHOW ; idem 
 
 

xROUTINE CommentsAway
 LVSearch "/*" CS first
 BegPosX = $$Search.Pos
 BegPosY = $$LV.LINE
 WHILE $$LV.LINE > ''
	SearchVar LVVar2 "*/" CS first
	EndPos = $$Search.Pos ; in same line
	IF $EndPos > ''
		NwLine = $LVVar2[0][$BegPosX] ;delete rest of line
		LVPut $NwLine
	ELSE
		LVSearch "*/" CS first
		EndPosX = $$Search.Pos ; plus 2 ,does not matter
		EndPosY = $$LV.LINE
		Gosub #this DeletePt2Ln $BegPosX $BegPosY $EndPosY ; delete in between
	ENDIF
	LVGo #$BegPosY
	LVSearch "/*" CS first
 	BegPosX = $$Search.Pos
 	BegPosY = $$LV.LINE
 ENDWHILE



xROUTINE DeletePt2Ln BPosX BPosY EPosY
;say $BPosY      ; 0
 LVGo #$BPosY
 LineDif = $($EPosY - $BPosY) ;2
 IF $BPosY = $EndPosY ; same line
	; Lg_ = $($EPosX - $BPosX)
	NwLine = $LVVar2[0][$BPosX]
	LVPut $NwLine
 ELSE
	IF  $LineDif > 1 ; at least one intermediate line
		WHILE $$LV.LINE < $EPosY ; 2
			LVGo Next
			LVMulti ON
		ENDWHILE
	ENDIF
	LVClip CUT SELECTED ADD "" 0 ; eliminate Linediff - 2 intermediate lines
	EposY = $BPosY
	++EPosY ; begin and endline now only differ 1 line
 ;EZReq "1 $$LV.LINE" OK var"
	; where are we on first line ?
	LVGo #$BPosY
	NwLine = $LVVar2[0][$BPosX]
	LVPut $NwLine
	;LVGo Next
	;NwLine = ""
	;LVPut $NwLine
	
 ENDIF
;EZReq "2 $$LV.LINE" OK var


xROUTINE DeletePt2Pt BPosX BPosY EPosX EPosY ;in fact deletes till end of line EposY
 LVGo #$BPosY
 LineDif = $($EPosY - $BPosY)
 IF $BPosY = $EndPosY
	Lg_ = $($EPosX - $BPosX)
	NwLine = $LVVar2[0][$BPosX]\#$LVVar2[$EPosX]
	LVPut $NwLine
 ELSE
	IF  $LineDif > 2 ; at least one intermediate line
		WHILE $$LV.LINE < $EPosY
			LVGo Next
			LVMulti ON
		ENDWHILE
	ENDIF
	LVClip CUT SELECTED ADD "" 0 ; eliminate intermediate lines
	EposY = BPosY
	++EPosY ; begin and endline now only differ 1 line
	; where are we on first line ?
	NwLine = $LVVar2[0][$BPosX]
	LVPut $NwLine
	LVGo Next
	NwLine = $LVVar2[$EPosX]
	LVPut $NwLine
 ENDIF
	
  
xBUTTON 60 0 60 14 MkCalls  ; <<MkCalls>>
 GadHelp " Construct an alphahabetic list of functioncalls per file to be used in LV1"
 LVUse #this 2
 IF $$LV.TOTAL > $MinExp
 	Gosub #this MkCalls
 ENDIF

xROUTINE MkCalls
 SetGad #this 1 HIDE
 LVUse #this 101
 LVClear
 LVUse #this 1
 LVClear
 ; treat all proto lines in LV2
 LVUse #this 2 ; EXP should contain the reduced protofile generated with <MkProtos>
 LVGo first 
 WHILE $$LV.LINE > ""
	; reduce $LVVar2 to functionname
	SearchVar LVVar2 "(" CS first
 	Pos = $$Search.Pos
	IF $Pos = ""
		stop
	ENDIF
 	Func2find = $LVVar2[0][$Pos]
 	ParseVar Func2find
 	Last = $($$PARSE.TOTAL - 1)
 	FuncName = $$Parse.$Last
	SetWinTitle #this *$FuncName\*
	CLI 'c:FSearch >t:GSc_Calls  $SrcDir TXT="$FuncName"  NOBIN'
	; put search result in LV 101
	LVUse #this 102
	LVChange t:GSc_Calls
	; eliminate the lines that point to gui_protos.h EXP
	LVSearch $ProtoName CI first ; EXP 
	WHILE $$LV.LINE > ''
		LVDel -1
		LVSearch $ProtoName CI first ; EXP
	ENDWHILE
	LVRep "$SrcDir" "" CI ; / not eliminated, if assign as done, no problem 
	LVSort ASC
	LVGo first
	WHILE $$LV.LINE > ""
		NwLine = "$LVVar102 $FuncName" ; file funcname , EXP no calls in subdirectories expected
		LVPut $NwLine
		LVGo Next
	ENDWHILE
	LVMulti ALL
	LVClip COPY SELECTED PASTE #this 1 ; ?? not really needed just to follow things
	LVClip CUT SELECTED ADD #this 101
	LVUse #this 2
	LVGo Next
 ENDWHILE
 ; now LV101 contains pairs 'file functionnames'
 LVUse #this 101
 LVSort ASC
 LVMulti ALL 
 LVClip CUT SELECTED PASTE #this 1
 LVUse #this 1
 LVSave t:GSrc.calls
 LVGo first
 WHILE $LVVar1[0][1] = " " ; eliminate the occurences in gui_protos.h
	LVMulti ON
	LVgo Next
 ENDWHILE
 LVClip CUT SELECTED PASTE #this 101
 LVUse #this 101
 LVSave t:GSrc.acalls ; just the functionnames as in gui_proto.h sorted alphabetically
 LVClear
 Gosub #this Make/
 LV1Mode = Calls
 SetGad #this 1 SHOW
 LVMulti SHOW

xROUTINE Make/
 LVUse #this 1
 LVgo first
 ParseVar LVVar1
 CrtFile = $$Parse.0
 RepVar LVVar1 $CrtFile $CrtFile\/ CS
 LVPut $LVVar1
 LVGo Next
 
 
 WHILE $$LV.LINE > ""
	ParseVar LVVar1
	IF $$Parse.0 = $CrtFile
		RepVar LVVar1 $CrtFile "" CS
	ELSE
		CrtFile = $$Parse.0
 		RepVar LVVar1 $CrtFile $CrtFile\/ CS
		
	ENDIF
	LVPut $LVVar1
	LVGo Next
 ENDWHILE
 ; Set DEBUG ON
 LVGo first
 I = 1
 WHILE $$LV.LINE > ""
 ;AND $I < 5
	SearchVar LVVar1 "/" CS first
	Pos = $$Search.Pos
	
	IF $Pos > "" 
		++Pos
		++I
		File_ = $LVVar1[0][$Pos]
		FuncName = $LVVar1[$Pos]
		LVPut $File_
		LVGo Next ; DIMNw have an internal varible with line length
		--Pos
		LVInsert -1 "$StrEq[0][$Pos]\/" ;
		LVGo Next
		LVInsert -1 $FuncName ; positioned on inserted line (Funcname)
	ELSE
	ENDIF
	LVGo Next
 ENDWHILE
 
 

xBUTTON 0 0 60 14 MkDef  ; <<MkDef>>
 GadHelp " Construct an alpahabetic list of functions per file in LV 1 "
 LVUse #this 2
 IF $$LV.TOTAL > $MinExp
 	Gosub #this MkDef
 ENDIF

xROUTINE MkDef
 IF $MkDef = "0"  ; 1st call on the current protofile
	EzReq "$.GSrc_MkDef" ok var
	Line2Srch = ""
 	Gosub #this Make_
 ELSE  ; as long as whole textfile  not finished 
	EzReq " we continue from $Line2Srch" ok var ; EXP once
	Gosub #this Make_
 ENDIF

xROUTINE Make_
 SetGad #this 1 HIDE
 LVUse #this 101
 LVClear
 LVUse #this 1
 LVClear
 LVUse #this 2 ; EXP should contain the reduced protofile generated with >MkProtos>
 LVGo first 
 LVSearch $Line2Srch CS first
 WHILE $$LV.LINE > ""
	; reduce $LVVar2 to functionname
	SearchVar LVVar2 "(" CS first
	; EzReq $LVVar2 ok var
 	Pos = $$Search.Pos
	IF $Pos = ""
		stop
	ENDIF
 	Func2find = $LVVar2[0][$Pos]
 	ParseVar Func2find
 	Last = $($$PARSE.TOTAL - 1)
 	FuncName = $$Parse.$Last
	SetWinTitle #this *$FuncName\*
	Func2Find = $Func2find
	RepVar Func2Find "*" "**" CS
	CLI 'c:FSearch >t:GSc_Calls  $SrcDir TXT="$Func2Find"  NOBIN'
	;
	LVUse #this 102
	LVChange t:GSc_Calls
	LVGo last ; empty final line
	LVDel -1
	IF $$LV.TOTAL = 0
		EzReq "No matches found for *$Func2find\* \n,verify the matches on $FuncName ?" ok|no var
		Gosub #this VerifFuncName ; 1
	ELSE
		;EzReq $$LV.TOTAL ok var
		LVSearch $ProtoName CI first
		WHILE $$LV.LINE > ''
			LVDel -1
			LVSearch $ProtoName CI first
		ENDWHILE
		IF $$LV.TOTAL = 0
			EzReq "Only matches for $Func2find found in proto files\n We will verify the matches on $FuncName ?" ok var
			Gosub #this VerifFuncName ; 2
		ELSE 
			LVRep "$SrcDir" "" CI ; / not eliminated 
			LVSort ASC
			;EzReq $$LV.TOTAL ok var
			LVGo first
			WHILE $$LV.LINE > ""
				NwLine = "$LVVar102 $FuncName" ; file funcname , no calls in subdirectories
				LVPut $NwLine
				LVGo Next
			ENDWHILE
			LVMulti ALL
			LVClip COPY SELECTED PASTE #this 1
			LVClip CUT SELECTED ADD #this 101
		ENDIF
	ENDIF
	LVUse #this 2
	LVGo Next
 ENDWHILE
 MkDef = 0
 LVUse #this 101
 LVSort ASC
 LVMulti ALL 
 LVClip CUT SELECTED PASTE #this 1 ; LV1 now contains sorted file functionname pairs
 LVSave t:GSrca2.defs
 Gosub #this Make/
 LV1Mode = Defs
 SetGad #this 1 SHOW
 LVMulti SHOW


xROUTINE VerifFuncName
 IF $var = 0
	.GSc_Calls = ''
	CLI 'c:FSearch >env:.GSc_Calls  $SrcDir TXT="$FuncName" HL VERBOSE NOBIN LINE '
	LVUse #this 1
	LVChange env:.GSc_Calls ; Exp hopefully not again empty (proto left over for not used function
	LVGo first
	LVInsert -1 "CALLS & FUNCTION FOUND:"
	LVUse #this 2
	LVSearch $Func2find CS first
	LVMulti NONE
	LVMulti ON
	Update #this 2 $$LV.LINE
	EzReq "You are able now to edit the docs in LV1 by double clicking on wanted line\n When done click again on <MkDef> button to continue " ok var
	IF $var = 0
		Line2Srch = $Func2find
		LV1Mode = Edit ;_ = "1"
		MkDef = "1"
		stop
	ENDIF
 ENDIF
 

xBUTTON 360 0 60 14 FcA1  ; <<FcA1>>
 Gadhelp "Sort alphabetically on Function, based on LV1 with /'s 'Open' format"
 IF $LV1Mode = Defs
	SetGad #this 1 HIDE
 	SetGad #this 2 HIDE
 	Gosub #this FuncAlpha/ ; sort LV 1 and eliminate files
 	EzReq "LV 1 has $$LV.TOTAL lines " OK var
 	Gosub #this FuncAlpha2
	SetGad #this 1 SHOW
   SetGad #this 2 SHOW
	Redraw #this
 ELSE
	EzReq "LV1 does not contain proper list" ok var
 ENDIF
 

xROUTINE FuncAlpha2 ; LV2  
 Ttl_LV1 = $$LV.TOTAL
 EzReq "LV 1 has $$LV.TOTAL lines " OK var
 LVUse #this 2
 Ttl_LV2 = $$LV.TOTAL
 EzReq "LV 2 has $$LV.TOTAL lines"  OK var
 LVMulti ALL
 LVClip COPY SELECTED PASTE #this 101
 LVClear
 LVUse #this 101
 LVMulti ALL
 LVUse #this 1
 LVGo first
 WHILE $$LV.LINE > ''
	LVUse #this 101 ; all the LV2 lines
	
	LVSearch $LVVar1 CS first
	IF $$LV.LINES > ""
		LVMulti OFF
		LVUse #this 2
		LVAdd $LVVar101
	ENDIF
	
	LVUse #this 1
	LVGo Next
 ENDWHILE
 LVUse #this 2
 IF $$LV.TOTAL != $Ttl_LV1
	 IF $var = 1
		; save LV2
		LVUse #this 101
		LVClip COPY SELECTED PASTE #this 2
	 ENDIF
 ENDIF
			


xBUTTON 420 0 60 14 FcA2  ; <<FcA2>>
 Gadhelp "ReGenerate LV1 and Sort LV2 alphabetically on function content of LV2"
 SetGad #this 1 HIDE
 SetGad #this 2 HIDE
 LVUse #this 1 
 LVClear 
 LVUse #this 2
 LVGo first
 WHILE $$LV.LINE > ''
	SearchVar LVVar2 "(" CS first
	Pos = $$Search.Pos
 	Func2find = $LVVar2[0][$Pos]
	ParseVar Func2find
	Last = $($$PARSE.TOTAL - 1)
 	FuncName = $$Parse.$Last
   LVUse #this 1
	LVAdd $FuncName
	LVUse #this 2
	LVGo Next
 ENDWHILE
 LVUse #this 1
 LVSort ASC
 Gosub #this FuncAlpha2
 SetGad #this 1 SHOW
 LVMulti SHOW
 SetGad #this 2 SHOW
 LVUse #this 2
 LVMulti SHOW
 
	

xBUTTON 480 0 60 14 DTAlpha  ; <<DTAlpha>>
 Gadhelp "Sort alphabetically datatype included"
 LVUse #this 2
 LVSort ASC

xBUTTON 540 0 60 14 Restore  ; <<Restore>>
 LVUse #this 2
 GadHelp "See protos in $ProtoName order as on open"
 LVChange "srcCmt:_General_Gui4Cli/function_protos"
 

xLISTVIEW 0 14 300 406  '' LVVar1 $FuncAlphaPath 30 MULTI ; was srcCmt:_General_Gui4Cli/functionsStructure 30 MULTI
 GadID 1 
 GadHelp "Search function calls & function definition"
 GadFont #MONO 8 000
 IF $LV1Mode = Edit ; _ = "1"  ; LV 1 contains highlighted result of search ; => doubleclicking on line with nr => Ed positioned on this linenr
	say "*$LVVar1[0][1] *\n*$LVVar1 *\n"
	IF $LVVar1[0][1] = ' '
	OR $LVVar1[0][4] = '›33m'

		IF $LVVar1[0][4] = '›33m'						; cut off highlighting
			cutvar LVVar1[4] cut word  1 resnum
		ELSE
			cutvar LVVar1 cut word 1 resnum			; get the line number
		ENDIF
		extract resnum clean resnum
		cutvar resnum	cut char -1 ''
		WHILE $$lv.rec[0][4] != '›32m'					; get the parent file
		;OR $$lv.rec[0][4] == '›33m'
		;AND $$lv.line > ''
			lvgo	prev
		ENDWHILE
		
		resfile	= $$lv.rec
		;IF $resfile[0][4] = '›32m'	; cut off highlighting
			cutvar resfile[4] cut word 1	resfile
			cutvar resfile cut char -4 temp	  		; trim the csi
		;ENDIF

	ENDIF
 	Gosub #this LoadFile "$resfile" "$resnum"

	;Exp RUN Ed on line to correct see FSearch whit = 32m blue 33m bactonormal 31m
 
 ELSEIF $LV1Mode = Calls  ; LV1 contains the result of the <MkCalls>
	SearchVar LVVar1 "/" CS first
	IF $$Search.Pos > ""
		IF $LVVar1[0][1] != "="
			Gosub #this EditFile $LVVar1
		;ELSE
		ENDIF
	ELSE
		FuncName = $LVVar1[1]

		; find filename
		WHILE $$Search.Pos = ""
			LVGo Prev
			SearchVar LVVar1 "/" CS first
		ENDWHILE
		LVGo Prev
		;Gosub #this Edit&SchFile $LVVar1 $FuncName
		Gosub #this ShowAllSches $LVVar1 $FuncName
 	ENDIF
 ELSE    ; IF $LV1Mode = Defs
 	Gosub #this FindCalls $LVVar1 ; was FindFunc1
 ENDIF


xROUTINE ShowAllSches FileNme SearchWd
 GuiLoad :GuiSrc.lr2
 Joinfile $SrcDir $FileNme FilePath
 LVUse GuiSrc.lr2 1
 LVChange $FilePath
 LVSearch $SearchWd CS first
 WHILE $$Search.Pos > ""
	LVMulti ON
	LVSearch $SearchWd CS next
 ENDWHILE
 LVMulti first
 Update GuiSrc.lr2 1 $$LV.LINE
 SetWinTitle GuiSrc.lr2 "GuiSrc.lr2 $FileNme"
 

xROUTINE EditFile FileNme
	sendrexx $PortNm 'jump to file $FileNme'
	if $$rexxret = 0	; file not loaded
		sendrexx $PortNm 'open new'
		sendrexx $PortNm 'open $FileNme'
	endif
	sendrexx $PortNm 'expand view'

xROUTINE Edit&SchFile filenme searchWd
	sendrexx $PortNm 'jump to file $filenme'
	if $$rexxret = 0	; file not loaded
		sendrexx $PortNm 'open new'
		sendrexx $PortNm 'open $filenme'
	endif
	sendrexx $PortNm 'expand view'
	sendrexx $PortNm 'search for $searchWd 1 0 1 0'

xROUTINE FindFunc1 ; finds only occurences as in proto
 LVUse #this 2
 LVSearch $LVVar1 CS first
 IF $$LV.LINE > ""
 	Gosub #this FindFunc2
 ELSE
	EzReq "No proto for this function" ok var
 ENDIF


xROUTINE GetFunc ; used inline no gosub yet
 SearchVar LVVar2 "(" CS first
 Pos = $$Search.Pos
 Func2find = $LVVar2[0][$Pos]

xROUTINE FindFunc2
 SearchVar LVVar2 "(" CS first
 Pos = $$Search.Pos
 Func2find = $LVVar2[0][$Pos]
 Func2Find = $Func2find
 RepVar Func2Find "*" "**" CS
 Gosub #this FindCalls $Func2Find ;  EXP **



xLISTVIEW 300 14 300 406  '' LVVar2 $ProtoPath 30 MULTI ; was srcCmt:_General_Gui4Cli/function_protos 30 MULTI
 GadID 2
 GadHelp "Search function calls & function definition"
 Gosub #this FindFunc2
;EzReq $Func2find ok var
 ParseVar Func2find
 Last = $($$PARSE.TOTAL - 1)
 FuncName = $$Parse.$Last
 LVUse #this 1
 LVMulti NONE
;EzReq $FuncName ok var
 LVSearch $FuncName CS first
 IF $$LV.LINE > ""
	LVMulti ON
 ENDIF
 Update #this 1 $$LV.LINE


xBUTTON 60 420 60 14 Help ; <<Help>>
 Help_ = 1
 GuiLoad :GuiSrc.lr2
 LVUse GuiSrc.lr2 1
 LVChange t:GSrc_Goal 
 SetWinTitle GuiSrc.lr2 "HELP : Goal & usage" ; DIM $$WIN.TITLE would be usefull

xBUTTON 0 420 60 14 Init ; <<Init>>
 GadHelp "Initiate a new source analyse. Choose the sourcedirectory  etc " 
 CLI "assign srcGui: remove"
 CLI "assign srcStruc: remove"
 Gosub #this Init

xROUTINE Init  ; EXP assigns may not exist but the files to be generated may be present, 
 ; EXP they also may have to be updated
 ReqFile -1 -10 $*ReqW $*ReqH "Choose source directory" DIR SrcDir 'guis:' ; was srcgui:
 IF $SrcDir > ""
 ANDIFEXISTS DIRECTORY $SrcDir 
	assign srcGui: $SrcDir
	SrcDir = "srcGui:"
	ReqFile -1 -10 $*ReqW $*ReqH "Choose protos file" LOAD ProtoFile $ProtoFile
	; ProtoFile defined
	Extract ProtoFile FILE ProtoName
	ReqW = $($*ReqW + 100)
	ReqFile -1 -10 $*ReqW $*ReqH "Choose 'structures' directory where to save generated lists" DIR StrucDir 'srcgui:'
 	IF $StrucDir > "" ; EXP and exists
	ANDIFEXISTS DIRECTORY $StrucDir 
		assign srcStruc: $StrucDir
		
 		NwInit = 1
; EXP Should be followed by construction and saving of LV1 (MkCalls EXP MkDef)& 2 (MkProtos at least)
; save as ? memorized in .GSr_
		IFEXISTS FILE $ProtoPath
			EzReq "$ProtoPath exists Update or Load it ?" "Update|Load" var
			IF $var = 1
 				Gosub #this MkProtos
				LVUse #this 2
				LVSave $ProtoPath
			ELSE
				LVUse #this 2
				LVChange $ProtoPath
			ENDIF
		ELSE
			Gosub #this MkProtos
			LVUse #this 2
			LVSave $ProtoPath
		ENDIF
		IFEXISTS FILE $FuncAlphaPath
			EzReq "$FuncAlphaPath exists Update or Load it ?" "Update|Load" var
			IF $var = 1
				LVUse #this 2
				IF $$LV.TOTAL > $MinExp
 					Gosub #this MkDef
				ENDIF
				LVUse #this 1
			LVSave $FuncAlphaPath 
			ELSE
				LVUse #this 1
				LVChange $FuncAlphaPath
			ENDIF
		ELSE
			MkDef = 0
			Gosub #this MkDef
			LVUse #this 1
			LVSave $FuncAlphaPath 
		ENDIF
	ELSE ; no StrucDir
		; EXP reset to original 
		EzReq "You did not choose an existing structure directory\n Start Program again" ok var
		GuiQuit #this
	ENDIF
 ELSE ; no such SrcDir
	EzReq "You did not choose an existing source directory\n Start Program again" ok var
	GuiQuit #this
	; EXP reset to original, ask additional info or QUIT ??
 ENDIF

xROUTINE xBUTTON 60 420 60 14 Save ; <<Save>>
 LVUse #this 1
 LVSave t:saved
 RUN "Ed t:saved"


xROUTINE xBUTTON 300 420 60 14 Del ; <<Del>>
 GadHelp " Delete Selected lines" 
 LVUse #this 2
 LVClip CUT SELECTED ADD "" 0

xROUTINE xBUTTON 120 420 60 14 AssRem ; <<AssRem>>
 CLI "assign srcGui: remove"
 CLI "assign srcStruc: remove"

xLISTVIEW 300 500 300 406  '' LVVar101 "" 30 MULTI
 GadID 101

xLISTVIEW 300 500 300 406  '' LVVar102 "" 30 MULTI
 GadID 102

xRoutine LoadFile filename offset ; Borrowed from Dimitris
	sendrexx $PortNm 'jump to file $filename'
	if $$rexxret = 0	; file not loaded
		sendrexx $PortNm 'open new'
		sendrexx $PortNm 'open $filename'
	endif
	sendrexx $PortNm 'expand view'

	if $offset > 0
			sendrexx $PortNm 'jump to line $offset'
	endif
