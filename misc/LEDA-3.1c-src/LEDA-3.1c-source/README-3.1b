
--------------------------------------------------------------------------------
               LEDA-3.1b   (LEDA 3.1 Beta Test Release)
--------------------------------------------------------------------------------

This is a pre-release of Version 3.1 to be released this summer.
You can use it at your own risk. This file describes some of
the changes and new features (not complete!). Some of this stuff
may still be changed. Please report any problems, bugs, remarks, 
and suggestions to leda@mpi-sb.mpg.de or leda-bugs@mpi-sb.mpg.de

Many changes were made to make LEDA work with new compilers (g++-2.5.8,
lucid-c++, borland-4.0, ...) and with more machines/systems (silicon graphics,
linux, ...). Below you find a list of the most important bugs that have been 
fixed since release 3.0. There are also some new data types and algorithms 
(especially in the graph and window section) described at the end of 
this file. Note that the user manual is not up to date at the moment.


Remark:
We have received many problems reports on difficulties with g++
and with parameterized data types if the actual type arguments are
of a (user-defined) class type. Note that g++ (also the latest version)
often cannot handle function templates correctly. As a work-around for
this bug LEDA uses the "LEDA_TYPE_PARAMETER" macro as describen in
the "Changes" file and in example programs "prog/basic/pair.c",
"prog/basic/param.c". 


Bugs (in version 3.0) fixed:
--------------------------------------------------------------------------------
- skiplist copy constructor
- memory leaks in leda panels
- nested forall-loops
- string::read now can read strings of arbitrary length
- made dlist::bucket_sort stable 
- memory bug in dp_hash (dynamic perfect hashing) fixed
- k_heap::del_item fixed
- made rs_tree::change_inf (dictionary) clear old and copy new information
- dlist::search (replaced != by call of virtual cmp function)
- fixed bug in queue::append (replaced Convert by Copy)
- bugs in MAX_WEIGHT_BIPARTITE_MATCHING fixed (by M. Paul)
- prio.h: added missing ostream argument cout to Print calls
- stack::push(x)    replaced Convert(x) by Copy(x)
- segment::angle()  now returns zero for segments of length zero
- memory leak in draw_(filled_)polygon fixed
- bug in ab_tree::clear() fixed (forgot to set counter to zero)
- made dlist update operations protected
- missing operation ugraph::read(istream&) inserted
 


NEW FEATURES

--------------------------------------------------------------------------------
Basics
--------------------------------------------------------------------------------

- nested forall loops 

- singly linked lists   slist<T>   (<LEDA/slist.h>)

- compare and ord function arguments (used in list::sort, array::sort, 
  list::bucket_sort, ...) have to use const reference parameters, i.e.,
  have to be of type

  int cmp(const T&, const T&) 

  int ord(const T&)




--------------------------------------------------------------------------------
Graphs
--------------------------------------------------------------------------------

Adjacency lists are now realized by deriving edges from a base list-element 
class (obj_link). 


Definition:

... with each node is associated the list of incoming edges (in-edges)
and the list of outgoing edges (out-edges) ...


edge G.new_edge(v,w)
       appends new edge(v,w) to the list of out-edges of v and to the list of
       in-edges of w

edge G.new_edge(e1,w,d1)
       inserts new edge(source(e1),w) before/after (if d1=before/after) edge e1
       into out-list of source(e1) and appends it to the in-list of w

edge G.new_edge(e1,e2,d1,d2)
       inserts new edge(source(e1),target(e2)) before/after (if d1=before/after)
       edge e1 into the out-list of source(e1) and before/after (if d2=...)
       edge e2 into the in-list of target(e2)

node G.opposite(v,e) 


edge G.first_adj_edge();
edge G.first_in_edge();
edge G.last_adj_edge();
edge G.last_in_edge();
edge G.adj_succ(e);
edge G.in_succ(e);
edge G.cyclic_adj_succ(e);
edge G.cyclic_in_succ(e);
edge G.adj_pred(e);
edge G.in_pred(e);
edge G.cyclic_adj_pred(e);
edge G.cyclic_in_pred(e);


Iterations:
-----------

forall_out_edges(e,v)   iterates over all out-edges of v
forall_in_edges(e,v)    iterates over all in-edges of v
forall_inout_edges(e,v) iterates over both out-edges and in-edges

forall_adj_edges(e,v) == forall_out_edges(e,v)


Example applications of forall_in/out_edges macros :
MAX_FLOW  (graph_alg/_maxflow.c)
MIN_COST_MAX_FLOW  (graph_alg/_mcmflow.c)


Undirected graphs (ugraph)
-------------------------
forall_adj_edges(e,v)  == forall_inout_edges(e,v) 
(this is the only difference between directed and undirected graphs)

Here is still a problem: since forall_inout_edges is realized by a nested
for-loop, the "break" command does not work as expected. You have to use
the predefined LEDA macro "ADJ_BREAK" instead.


other operations:


void G.hide_edge(edge e)         removes an edge (temporarily) from its 
                                 adjacency list, however, not from E
                                 (list of all edges)
                                
void G.restore_edge(edge e)      puts e back into its adjacency list



node_data<T>
------------

A faster and dynamic version of "node_array",
occupies an additional pointer in the node data structure

RESTRICTIONS:
- T has to be a pointer type or int
- only one instance possible for every graph

header file:  <LEDA/graph.h>

example:  LEDA/prog/graph/shorttest.c



node_list
---------

Faster version of "list<node>"

RESTRICTIONS:
- every node can be in at most one node_list
- restricted set of operations:

  void L.append(node v)
  void L.push(node v) 
  void L.insert(node v, node w)
  node L.pop()      
  void L.del(node v)
  bool L.member(node v)  (L(v) = L.member(v))
  node L.first()
  node L.last()
  node L.succ(node v)
  node L.pred(node v) 
  node L.cyclic_succ(node v) 
  node L.cyclic_pred(node v) 
  forall(v,L)

header file:  <LEDA/graph.h>

example:  LEDA/prog/graph/shorttest.c



b_node_pq<int n>
----------------

bounded integer priority queue:  maximal difference of priorities <= n, 
the minimum priority is non-decreasing, each node can be in at most one queue

Declaration: 
   a) b_node_pq<n>  PQ;          // if PQ empty PQ.del_min() returns nil
   b) b_node_pq<n>  PQ(node v);  // if PQ empty PQ.del_min() returns v 

Operations:
   node PQ.del_min()
   void PQ.insert(node,int) 
   void PQ.del(node)


Implementation: cyclic array of buckets (node_list)

header file:  <LEDA/b_node_pq.h>

example:  LEDA/prog/graph/shorttest.c



--------------------------------------------------------------------------------
Algorithms:
--------------------------------------------------------------------------------

The Efficiency of many Graphlgorithms has been improved,
in particular: MAX_FLOW, MAX_WEIGHT_BIPARTITE_MATCHING, ...

 
void random_planar_graph(graph& G,int n)    
                                 generates a random planar graph G with n nodes

void random_planar_graph(graph& G, node_array<double>& xcoord, 
                                   node_array<double>& ycoord, 
                                   int n)
                                 generates an embedded planar graph G with n 
                                 nodes and double coordinates xcoord[v] and
                                 ycoord[v] in [0..1] for each node v.
                               

bool PLANAR(G)                   planarity test (should work now)

bool PLANAR(G,list<edge> E)      returns a Kuratowski-subgraph E, if
                                 G is not planar (slow!)


int MIN_COST_MAX_FLOW(const graph& G,node s,node t,const edge_array<int>& cap,
                                                   const edge_array<int>& cost,
                                                   edge_array<int>& flow);

                                 cmoputes  maximal flow  with minimal cost



--------------------------------------------------------------------------------
window/graphics
--------------------------------------------------------------------------------

- pure X implementation of the window stuff, i.e., you do not
  have to link with openlook/xview libraries (-lolgx -lxview)
  any more. The window library is called "libWx.a".

  CC  ... -lP -lG -lL -lWx -lX11 -lm


- more than one window 
  (see prog/graphics/windows.c)

- positioning of windows: window w(l,w,x,y)
  where x and y is an integer or one of the following values:
  window::min :   at left/upper screen boundary
  window::max :   at right/lower screen boundary
  winodw::center: center in corresponding dimension
  (see prog/graphics/windows.c)

- default window label
  can be specified in constructor
  window w(l,w,x,y,label="")
  window w(l,w,label="")
  window w(label="")
  (see prog/graphics/windows.c)

- colors
  16 predefined colors:
  white, black, blue, red, green, yellow, violet, orange,
  cyan, brown, pink, green2, blue2, grey1, grey2, grey3
  colors can be specified by name, i.e., a string from /usr/lib/X11/rgb.txt
  (see prog/graphics/blue.c)


- positioning of panels (does not work sith all window managers)

 P.open();             // center on screen
 P.open(x,y);          // screen position (x,y)
 P.open(W);            // center on window W
 P.open(W,x,y);        // position (x,y) on W




graph editor
-----------

A simple graph editor:
(sources in src/window/graph_edit.c)

void graph_edit(window& W, GRAPH<point,int>& G, bool dir=true,bool redraw=true);

                              G can be edited in winodw W
                              if dir=true G is drawn directed
                              if redraw=true G is redrawn at the beginning

header: <LEDA/graph_edit.h>

example: prog/graphics/matching.c





Drawing arcs:
------------

void W.draw_arc(point p,point q,double r,color=black)
void W.draw_arc_arrow(point p,point q,double r,color=black)
void W.draw_arc_edge(point p,point q,double r,color=black)
void W.draw_arc_edge_arrow(point p,point q,double r,color=black)
                         
                               draws a circular arc (edge, arrow)
                               with radius r from p to q with the
                               center lying  to the right of the 
                               directed segment p--->q. p--->q
                               can also be specified by a segment (s)
                               or 4 double coordinates (px,py,qx,qy)



Fonts:
-----

LEDA uses three text fonts:

text_font:  for normal text (W.draw_text, ...)
bold_font:  for node labels (W.draw_text_node, W.draw_int_node, ...)
mesg_font:  for messages (W.message)

You can load different fonts with:

bool W.load_text_font(string fn)
bool W.load_bold_font(string fn)
bool W.load_message_font(string fn)

All 3 functions return false, if the corresponding font is not available.




Additional operations:
---------------------

int  W.read_event(int& but, double& x, double& y)
                                   waits for next event in window W and returns
                                   it. but = mouse button, (x,y) position in W. 
                                   Possible events are defined in 
                                   impl/x_window.h:
                                   button_press_event
                                   button_release_event
                                   motion_event ... 

(see prog/graphics/event.c)



void W.flush()                     flush output buffer
void W.set_flush(bool b)           if b = true  flush after each output
                                   
void W.set_frame_label(string s)   set frame label (temporarily) to s
void W.reset_frame_label()         restore standard frame label

unsigned W.button_press_time()     return time-stamp of last button click (msec)




(non-member) functions:
----------------------

int read_mouse(window*& w, double& x, double& y)
                                   waits for mouse input
                                   w = pointer to the corresonding window,
                                   (x,y) = position in *w
                                   returns pressed button
(see prog/graphics/windows.c)


                                 
void put_back_event()
                                   puts last event back to the stream of events

(see prog/graphics/windows.c)


