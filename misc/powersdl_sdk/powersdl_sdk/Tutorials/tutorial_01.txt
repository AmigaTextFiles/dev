SDL Tutorial based on: http://cone3d.gamedev.net
************************************************

Getting started with SDL!

What you need:

	- a C/C++ compiler
	- SDL includes
	- SDL static/shared libraries
	- an editor


How do you do:

You only need to add the include file SDL/SDL.h
to the top of your program like this:

	#include <SDL/SDL.h>

Initalizing SDL is done through the SDL_Init()
function. SDL_Init returns less than 0 on failure.
It takes one parameter: what to initalize.
To initalize the video screen pass to it the
constant SDL_INIT_VIDEO.
To initalize the audio, pass to it the
constant SDL_INIT_AUDIO.
To initalize the video and audio, pass to
it SDL_INIT_VIDEO|SDL_INIT_AUDIO.
There are many more things that you can
pass (seperating them with |'s when
passing many at once).
Here are the things you can pass:

SDL_INIT_TIMER
SDL_INIT_AUDIO
SDL_INIT_VIDEO
SDL_INIT_CDROM
SDL_INIT_JOYSTICK
SDL_INIT_NOPARACHUTE
SDL_INIT_EVENTTHREAD
SDL_INIT_EVERYTHING

So in conclusion if we would want to init
the video and the audio we get:

	if( SDL_Init(SDL_INIT_VIDEO|SDL_INIT_AUDIO) <0 )
	{
  		printf("Unable to init SDL: %s\n", SDL_GetError());
  		return 1;
	}

If an error occured, then the function SDL_GetError()
would return a string about the error.

When exiting your C++ program, you must execute
the function SDL_Quit(). That will clear up everything.
If you wouldn't execute it before exiting your
program, starge things may occur.
To tell the compiler that you want to run
SDL_Quit on exit, tell it like this:

	atexit(SDL_Quit);

That way you don't need to put SDL_Quit() before
every return [nr]; in main().


In SDL you have many surfaces. Everything is a surface.
You can draw on a surface and you can also draw a
surface on an other surface.
In SDL the screen is also a surface. A surface in
our program is actually a pointer to the structure
SDL_Surface. To get the screen surface do this:

	SDL_Surface *screen;

I'm sure you have seen at some point in your life
that some game asked you for a screen resolution
to run at. If not, well then PLAY MORE GAMES.
If you would want to use the surface screen
(remember, screen is just the name of a pointer
to the structure SDL_Surface) as the surface you
can draw on (and you will see what you have drawn
on your monitor) then use the function SDL_SetVideoMode();

	screen = SDL_SetVideoMode(640, 480, 0,
                             SDL_HWSURFACE|SDL_DOUBLEBUF);

The first three parameters are the width,
height and bits per pixel of the screen.
If you type in 0 for the BPP then SDL would
automatically select the best available BPP.
The fourth parameter is used to give some
special flags.
You must (almost) always give it SDL_HWSURFACE
(or SDL_SWSURFACE) if you want a screen to draw on.
Here's a list of what you may give it:

SDL_SWSURFACE - Create the video surface in system memory 
SDL_HWSURFACE - Create the video surface in video memory 
SDL_ASYNCBLIT - Enables the use of asynchronous updates
		of the display surface. This will usually
		slow down blitting on single CPU machines,
		but may provide a speed increase on SMP systems. 
SDL_ANYFORMAT - Normally, if a video surface of the requested		bits-per-pixel (bpp) is not available, SDL will
		emulate one with a shadow surface.
		Passing SDL_ANYFORMAT prevents this and causes
		SDL to use the video surface, regardless of
		its pixel depth. 
SDL_HWPALETTE - Give SDL exclusive palette access. Without this
		flag you may not always get the the colors you
		request with SDL_SetColors or SDL_SetPalette. 
SDL_DOUBLEBUF - Enable hardware double buffering; only valid with
		SDL_HWSURFACE. Calling SDL_Flip will flip the
		buffers and update the screen. All drawing will
		take place on the surface that is not displayed at
		the moment. If double buffering could not be enabled
		then SDL_Flip will just perform a SDL_UpdateRect
		on the entire screen. 
SDL_FULLSCREEN - SDL will attempt to use a fullscreen mode.
		If a hardware resolution change is not possible
		(for whatever reason), the next higher resolution
		will be used and the display window centered on a
		black background. 
SDL_OPENGL - 	Create an OpenGL rendering context.
		You should have previously set OpenGL video
		attributes with SDL_GL_SetAttribute. 
SDL_OPENGLBLIT - Create an OpenGL rendering context, like above,
		but allow normal blitting operations.
		The screen (2D) surface may have an alpha channel,
		and SDL_UpdateRects must be used for updating
		changes to the screen surface. 
SDL_RESIZABLE - Create a resizable window. When the window is
		resized by the user a SDL_VIDEORESIZE event is
		generated and SDL_SetVideoMode can be called
		again with the new size. 
SDL_NOFRAME - 	If possible, SDL_NOFRAME causes SDL to create
		a window with no title bar or frame decoration.
		Fullscreen modes automatically have this flag set. 

My recommendation: give it SDL_HWSURFACE|SDL_DOUBLEBUF and in case
of an error try again with SDL_SWSURFACE.

SDL_SetVideoMode returns a pointer to SDL_Surface if sucessful
or NULL if not. To check for errors use this block of code:

	if ( screen == NULL )
	{
  		printf("Unable to set 640x480 video: %s\n", SDL_GetError());
  		return 1;
	}

And that's all about initalizing SDL. You can now start drawing.
But before we get into drawing stuff I'll tell you about some
new datatypes that SDL gave us so you don't get confused when
you run into them. They are:

Uint8 - the equilant of an unsigned char
Uint16 - a 16 bit (2 byte) unsigned integer
Uint32 - a 32 bit (4 byte) unsigned integer
Uint64 - a 64 bit (8 byte) unsigned integer
Sint8 - the equilant of a signed char
Sint16 - a 16 bit (2 byte) signed integer
Sint32 - a 32 bit (4 byte) signed integer
Sint64 - a 64 bit (8 byte) signed integer

And one more thing: Sometimes when you get errors on initalizing
stuff you don't need to exit completly. For example when
initalizing SDL_INIT_VIDEO passed and SDL_INIT_AUDIO did not,
you can still continue with the program, only without audio.
To check (for example) if the audio initalization suceeded,
use the SDL_WasInit() function. Here's some code:

	Uint32 init = SDL_WasInit(SDL_INIT_AUDIO);
	if(init & SDL_INIT_AUDIO)
	{
		sound = 1;  // Audio init sucessful, use sound
	} else {
  		sound = 0;  // Audio init unsucessful, don't use sound
	}

You should add the code somewhere between the

	if( SDL_Init(SDL_INIT_VIDEO|SDL_INIT_AUDIO) <0 )
	{
  		printf("Unable to init SDL: %s\n", SDL_GetError());
  		return 1;
	}

code in your own programs (I won't add it in the tuts (for now)
for simplicity). 


Drawing pixels isn't very easy at first, but when you have
a function that does it for you it can't get any easier.
The function that I use for drawing pixels is taken from the
SDL intro (found on www.libsdl.org). It looks like this:

NOTE: you don't need to understand all of it. Just know that is works

	void DrawPixel(SDL_Surface *screen, int x, int y,
                                    Uint8 R, Uint8 G, Uint8 B)
	{
  		Uint32 color = SDL_MapRGB(screen->format, R, G, B);
  		switch (screen->format->BytesPerPixel)
  		{
    			case 1: // Assuming 8-bpp
      				{
        			Uint8 *bufp;
        			bufp = (Uint8 *)screen->pixels + y*screen->pitch + x;
        			*bufp = color;
      				}
      				break;
    			case 2: // Probably 15-bpp or 16-bpp
      				{
        			Uint16 *bufp;
        			bufp = (Uint16 *)screen->pixels + y*screen->pitch/2 + x;
        			*bufp = color;
      				}
      				break;
    			case 3: // Slow 24-bpp mode, usually not used
      				{
        			Uint8 *bufp;
        			bufp = (Uint8 *)screen->pixels + y*screen->pitch + x * 3;
        			if(SDL_BYTEORDER == SDL_LIL_ENDIAN)
        			{
          				bufp[0] = color;
          				bufp[1] = color >> 8;
          				bufp[2] = color >> 16;
        			} else {
         				bufp[2] = color;
          				bufp[1] = color >> 8;
          				bufp[0] = color >> 16;
        			}
      				}
      				break;
    				case 4: // Probably 32-bpp
      				{
        				Uint32 *bufp;
       					bufp = (Uint32 *)screen->pixels + y*screen->pitch/4 + x;
        				*bufp = color;
      				}
      				break;
  		}
	}

You pass it the surface you want to draw on, the x and
y of the point and the RGB of the color you want to
draw the point in.

The following paragraph is a crash course in RGB.
Don't read it if you don't want to.

Look at your monitor very closely with a magnifying
glass (note: you may hurt your eyes if you do it a lot).
Look at some white part of the screen.
You will see many dots: red, green and blue.
Now look at some other part of the screen (in some other color).
You will see that the red, green and blue are not brightly
lit, but have different tones. With different RGB values
you can display all the colours there are. 

We will also need 2 more functions. With some computers
(videocards) you need to lock a screen before you
can draw on it.
SDL_MUSTLOCK(SDL_Surface *screen) tells us if we
need to lock the screen and
SDL_LockSurface(SDL_Surface *screen) and
SDL_UnlockSurface(SDL_Surface *screen) do the locking
and unlocking. Here are 2 functions that make it
all easier:

	void Slock(SDL_Surface *screen)
	{
  		if ( SDL_MUSTLOCK(screen) )
  		{
    			if ( SDL_LockSurface(screen) < 0 )
    			{
      				return;
    			}
  		}
	}

	void Sulock(SDL_Surface *screen)
	{
  		if ( SDL_MUSTLOCK(screen) )
  		{
    			SDL_UnlockSurface(screen);
  		}
	}

Just call Slock(screen) to lock the screen
and Sulock(screen) to unlock it.


By now you should have something like this:

	#include <stdio.h>
	#include <stdlib.h>

	#include <SDL/SDL.h>

	// The functions are not shown to save space
	void DrawPixel(SDL_Surface *screen, int x, int y,
                                    Uint8 R, Uint8 G, Uint8 B);
	void Slock(SDL_Surface *screen);
	void Sulock(SDL_Surface *screen);


	int main(int argc, char *argv[])
	{
		// INITIALIZATION
  		if ( SDL_Init(SDL_INIT_AUDIO|SDL_INIT_VIDEO) < 0 )
  		{
    			printf("Unable to init SDL: %s\n", SDL_GetError());
    			exit(1);
  		}
  		atexit(SDL_Quit);

  		// SETUP VIDEO MODE
		SDL_Surface *screen;
  		screen=SDL_SetVideoMode(640,480,32,SDL_HWSURFACE|SDL_DOUBLEBUF);
  		if ( screen == NULL )
  		{
    			printf("Unable to set 640x480 video: %s\n", SDL_GetError());
    			exit(1);
  		}

  		// DRAWING GOES HERE

  		return 0;
	}

Now run it! You should get a blank window that comes
and goes quickly. Add SDL_FULLSCREEN to the flags list
to see the screen turn black for some time.
Now let's get drawing!

We will use a simple method when drawing everything:
we draw everything into a buffer and when everything
is drawn we draw the buffer on the screen.
This will be much useful than drawing each pixel
on the screen and updating the screen then.
This method is faster and there won't be any flickering.

We want to make the entire screen colorful
(like you saw on the screenshot). For that we loop
through all the x, y coordinates and draw a colorful
pixel there. Before the loop we add the screen
locking function and after it we add the unlocking
function. Drawpixel draws a colorful pixel
(changes the color of a pixel) inside the screen
surface (the buffer) and we use SDL_Flip to draw
the buffer (screen surface) on the actual computer
screen.

	Slock(screen);
	for(int x=0;x<640;x++)
	{
  		for(int y=0;y<480;y++)
  		{
    			DrawPixel(screen, x,y,y/2,y/2,x/3);
  		}
	}
	Sulock(screen);
	SDL_Flip(screen);

NOTE: Actually drawing everything on the screen all
the time can be quite slow at times.
Usually when you only need to draw one part of
the screen you only draw one part of the screen.
More in a future lesson.

Replace the "// DRAWING GOES HERE" with the drawing
code block and run the program. You should see the
black window as a colorful window now. But still it
only stays for a very little time. To make the colorful
window stay longer put the drawing code inside a for loop:

	for(i=0;i<100;i++)
	{
  		Slock(screen);
  		for(int x=0;x<640;x++)
  		{
    			for(int y=0;y<480;y++)
    			{
      				DrawPixel(screen, x,y,y/2,y/2,x/3);
    			}
  		}
  		Sulock(screen);
  		SDL_Flip(screen);
	}

That will draw the same block of code 100 times
and then exit. But still there is a better way.

We put the entire drawing code inside a new function:

	void DrawScene(SDL_Surface *screen)
	{
  		Slock(screen);
  		for(int x=0;x<640;x++)
  		{
    			for(int y=0;y<480;y++)
    			{
      				DrawPixel(screen, x,y,y/2,y/2,x/3);
    			}
  		}
  		Sulock(screen);
  		SDL_Flip(screen);
	}

And now in main() we start a thing called a game loop.
A game loop is a loop that runs until it is exited.
With each run of the loop some stuff occur. Our game
loop is a while loop that runs as long as a previously
defined integer done equals 0.

	int done=0;

	while(done == 0)
	{
  		// CODE
	}

Inside our game loop we check if ESCAPE or if the
X button on the window has been pressed. If so we make
done equal 1 and the loop just won't run next time.

All SDL event thingys are in the structure SDL_Event.
We need to have one instance of it to check for events.

	SDL_Event event;

We then poll for events (until there are no more to poll).

	while ( SDL_PollEvent(&event) )
	{

	}

With each while(...) {...} the SDL_Event structure will
contain some info about some events. We then check for the
event type (inside the SDL_PollEvent while loop)

	if ( event.type == SDL_QUIT )  {  done = 1;  }

	if ( event.type == SDL_KEYDOWN )
	{
  		// CODE
	}

If we get the quit event (the close button on the window
being pressed) then we make done equal 1.
If we get a key down event then we must also check
which key got pressed:

	if ( event.key.keysym.sym == SDLK_ESCAPE ) { done = 1; }

All key names start with SDLK_.
Check the file SDL_keysym.h for more SDLK_ key names.
After the event checking we call:

	DrawScene(screen);

And that's it! Here's the full source code:

	tutorial_01.c


 