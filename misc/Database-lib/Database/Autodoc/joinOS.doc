TABLE OF CONTENTS

joinOS.library/AbortDosPkt
joinOS.library/Adds64
joinOS.library/AllocDOSObject
joinOS.library/AllocPoolMem
joinOS.library/AllocVector
joinOS.library/AllocateTagList
joinOS.library/AsyncCopyFile                           
joinOS.library/AvailMemory
joinOS.library/ChangeTagList                           
joinOS.library/ClearMem
joinOS.library/ClearMemHeader
joinOS.library/CloneTagList                            
joinOS.library/CountNodes                              
joinOS.library/CreateMemPool
joinOS.library/CreateSignalSemaphore                   
joinOS.library/DOUBLELONG2Str
joinOS.library/Date2Str
joinOS.library/DatesCompare
joinOS.library/DayOfWeek
joinOS.library/Delete
joinOS.library/DeleteMemPool
joinOS.library/DeleteSignalSemaphore
joinOS.library/Divs64
joinOS.library/Divu64
joinOS.library/DoDosPkt
joinOS.library/ErrorText
joinOS.library/ExamineAll
joinOS.library/ExamineAllEnd
joinOS.library/FillMem
joinOS.library/FilterChangeTags
joinOS.library/FilterTagList
joinOS.library/FindArgument
joinOS.library/FindDOSEntry
joinOS.library/FindFirstMatch
joinOS.library/FindMatchEnd
joinOS.library/FindNextMatch
joinOS.library/FindTag
joinOS.library/FreeArguments
joinOS.library/FreeDOSObject
joinOS.library/FreePoolMem
joinOS.library/FreeTagList
joinOS.library/FreeVector
joinOS.library/GetSysBase
joinOS.library/GetTagItem
joinOS.library/IsAmigaDosError
joinOS.library/IsValidDate
joinOS.library/IsValidMemList
joinOS.library/LockDOSList
joinOS.library/Long2Str
joinOS.library/MakeUniqueName
joinOS.library/MapTagList
joinOS.library/MoveMem
joinOS.library/Muls64
joinOS.library/Mulu64
joinOS.library/Neg64
joinOS.library/NextDOSEntry
joinOS.library/NextTag
joinOS.library/PackBooleanTags
joinOS.library/PackStructTags
joinOS.library/ParseArgs
joinOS.library/ParseItem
joinOS.library/PathFromLock
joinOS.library/PatternMatch
joinOS.library/PatternMatchNoCase
joinOS.library/PatternParse
joinOS.library/PatternParseNoCase
joinOS.library/PrintError
joinOS.library/RefreshTagListClones
joinOS.library/ReplyDosPkt
joinOS.library/ReportError
joinOS.library/SemaphoreRelease
joinOS.library/SendDosPkt
joinOS.library/SetIOErr
joinOS.library/Sqrt32
joinOS.library/Str2DOUBLELONG
joinOS.library/Str2Date
joinOS.library/Str2Long
joinOS.library/TagIsInArray
joinOS.library/TempFileName
joinOS.library/TextBox
joinOS.library/TextBoxA
joinOS.library/UnLockDOSList
joinOS.library/UnpackStructTags
joinOS.library/Upper
joinOS.library/WaitDosPkt

joinOS.library/AbortDosPkt                            joinOS.library/AbortDosPkt

 NAME
    AbortDosPkt - try to abort a pending packet

 SYNOPSIS
    void AbortDosPkt (struct MsgPort*, struct DosPacket*)
    AbortDosPkt (mp, dp)
                 D1  D2

 FUNCTION
    AbortPkt() is supposed to request that a packet that has been send
    asynchronously, e.g. by means of SendPkt(), be aborted.

    AbortPkt() must be followed by a WaitPkt().

 INPUTS
    mp - message port the packet has been send to.
    dp - packet to be aborted.

 BUGS
    Originaly this function is a no-op, as the original AmigaDos design did
    not allow for packets to be aborted.
    (Under Windoof I/O-functions could also not be aborted.)

    This implementation tries nevertheless to remove the packet, if it's
    not the first message in the message ports list.

    THIS IS DANGEROUS, THERE MIGHT BE APPLICATIONS WHICH SCAN THE PORTS
    MESSAGE LIST BY THEIR OWN AND PROCESS THE FOUND MESSAGES IN DIFFERENT
    ORDERS, THIS WOULD PRODUCE A SYSTEM CRASH !

 SEE ALSO
    DoDosPkt(), SendDosPkt, ReplyDosPkt, WaitDosPkt()

joinOS.library/Adds64                                      joinOS.library/Adds64

 NAME
    Adds64 - add two 64 bit signed integers

 SYNOPSIS
    void Adds64 (LONGLONG *, LONGLONG *)
    Adds64 (arg1, arg2)
             A0    A1

 FUNCTION
    This function adds two signed 64-bit integers.

 INPUTS
    arg1 - a pointer to the first 64 bit integer, the result of this
          function is stored in this integer
    arg2 - a pointer to the second 64 bit integer, that should be added
          to the first one.

 SEE ALSO
    Divu64(), Divs64(), Mulu64(), Muls64(), Neg64()

joinOS.library/AllocDOSObject                      joinOS.library/AllocDOSObject

 NAME
    AllocDOSObject - allocate and initialize dos-specific data structures

 SYNOPSIS
    APTR AllocDOSObject (ULONG, struct TagItem*)
    object = AllocDOSObject (Type, Tags)
      D0                      D1    D2

 FUNCTION
    Allocates and initializes a DOS-specific data structure.
    This function and the oponent function FreeDosObject() are used for
    allocation and disposal of DOS-related structures in a save way without
    the need to take care about future versions of the OS and improvements
    or changes to the structures.
    For application programs only the types DOS_FIB and DOS_EXALLCONTROL are
    usefull.

 INPUTS
    Type - specifies the type of object that should be allocated, can be any
          of the following types:
       DOS_FILEHANDLE - a FileHandle for use in file-I/O-functions.
       DOS_FIB        - a FileInfoBlock as used for Examine() or ExNext().
       DOS_EXALLCONTROL - a ExAllControl function as used for ExAll().
       DOS_STDPKT     - a DosPacket for packed-oriented IO
       DOS_CLI        - a CommandLineInterface structure
       DOS_RDARGS     - a RDArgs structure
    Tags - additional information specifying the object to be allocated.
          currently not implemented, you should always pass NULL.

 RESULT
    If the function succeeds, a pointer to the allocated object is returned.
    If the function fails, NULL is returned.

 NOTE
    You have to use FreeDosEntry() for deallocation of objects allocated
    using this function, don't free them by directly calling any deallocation
    function (FreeMem() or FreeVec()).

 BUGS
    The AmigaOS function AllocDOSObject() for AmigaOS < v36 doesn't allocate
    DOS_CLI objects, it will return ERROR_NOT_IMPLEMENTED instead.

 SEE ALSO
    FreeDOSObject()

joinOS.library/AllocPoolMem                          joinOS.library/AllocPoolMem

 NAME
    AllocPoolMem - Get a block of memory from the memory pool.

 SYNOPSIS
    void *AllocPoolMem (void *, ULONG)
    memBlock = AllocPoolMem (PoolHeader, size)
       D0                       A0        D0

 FUNCTION
    Get a block of memory from the memory pool.
    If there isn't enough free memory in the puddles, or no big enough free
    memory block, or the requested size exceeds the <TreshSize> of the pool,
    a new puddle is added to the pool.

 INPUTS
    PoolHeader - the pointer to the pool header as returned from
                   CreateMemPool().
    size       - the size of the requested memory block in bytes.

 RESULT
    If the function succeeds, a pointer to the memory block is returned.
    If the function fails (system gone out of memory), NULL is returned.

 SEE ALSO
    FreePoolMem(), CreateMemPool(), DeleteMemPool()

joinOS.library/AllocVector                            joinOS.library/AllocVector

 NAME
    AllocVector - allocate a memory block, remember its size

 SYNOPSIS
    APTR AllocVector (ULONG, ULONG)
    memory = AllocVector (size, attributes)
      A0                   D0       D1

 FUNCTION
    This function works identically to AllocMem(), but tracks the size of an
    allocation.
    See AllocMem() for details.

 INPUTS
    size        - the size of the desired memory block in bytes. If 0 is
                   passed for this argument, 0 bytes will be allocated (NULL
                   will be returned.
    attributes  - attributes as used for AllocMem().

 RESULT
    If the function succeeds, a pointer to the allocated memory-block is
    returned.
    If the function fails, NULL is returned.

 BUGS
    See AllocMem().

 SEE ALSO
    FreeVector()

joinOS.library/AllocateTagList                    joinOS.library/AllocateTagList

 NAME
    AllocateTagList - allocate a tag list

 SYNOPSIS
    struct TagItem *AllocateTagList (ULONG)
    tagList = AllocateTagList (numTags)
     D0                          D0

 FUNCTION
    Allocates the specified number of usable TagItems slots.

    Note that to access the TagItems in 'tagList', you should use
    the function NextTag(). This will insure you respect any
    chaining (TAG_MORE) and secret hiding places (TAG_IGNORE) that
    this function might generate.

 INPUTS
    numTags - the number of TagItem slots you want to allocate. If 0 is
             passed for this argument, a TagItem list with no "useable"
             slot is created (i.e. a TagItem list which only contains
             a TAG_DONE).

 RESULTS
    tagList  - the allocated chain of TagItem structures, or NULL if
           there was not enough memory. An allocated tag list must
           eventually be freed using FreeTagList().
 
 SEE ALSO
    <joinOS/misc/tagitem.h>, FreeTagList(), CloneTagList()

joinOS.library/AsyncCopyFile                        joinOS.library/AsyncCopyFile

 NAME
    AsyncCopyFile - perform an asynchroneous copy of a file

 SYNOPSIS
    BOOL AsyncCopyFile (STRPTR, STRPTR, BOOL)
    success = AsyncCopyFile (source, dest, fExist)
      D0                       A0     A1     D0

 FUNCTION
    This function copies a file. It uses two small buffers of about 32kB for
    this purpose and tries to copy the file asynchroneous, i.e. whenever a
    buffer is filled from the source, it is written to the destination
    while the next buffer is filled from the source.

    If a large file is copied and two different devices are used for I/O
    (e.g. copying from one harddisk to another) this will save nearly half
    of the time. In worst case nothing is won and nothing is lost in
    comparison to synchrone transfer.

    If there is not enough free memory available for 32kB buffers, smaller
    buffers are used, at least 1kB.

 INPUTS
    source - a pointer to the NUL-terminated C-string with the filename (and
             path) of the file to be copied.
    dest - a pointer to the NUL-terminated C-string with the filename (and
             path) of the file to be created.
    fExist - a boolean value, TRUE indicates that the function should fail,
             if the destination file exists; FALSE indicates that an existing
             file should be overwritten silently.

 RESULT
    If the function succeeds, TRUE is returned, else FALSE is returned.
    See IoErr() for the cause of a failure.

 NOTES
    The process' messageport is used for I/O, take care that you only call
    this function from an AmigaDOS process and that there is no packet
    pending, when this function is called or you would meet the Guru
    (AN_AsyncPkt).

 BUGS
    Because the AmigaOS is a multitasking OS, there is a very small chance
    that an existing file is erroneous overwritten, if it is created between
    the test of its existance and the opening for output.

joinOS.library/AvailMemory                            joinOS.library/AvailMemory

 NAME
    AvailMemory - determine the amount of free memory

 SYNOPSIS
    ULONG AvailMemory (struct List *, ULONG)
    freeMem = AvailMemory (memList, Attributes)
      D0                     A0         D0

 FUNCTION
    This function returns the amount of free memory of a list of MemHeaders.
    To find out what the largest block of a particular MemHeaders list is,
    add MEMF_LARGEST into the requirements argument. Returning the largest
    block is a slow operation.

    If the list of MemHeaders is shared between applications, you have to
    guard this function by a Forbid()/Permit() pair, or better you protect
    the list with a semaphore.

 INPUTS
    memList - the list header of a list of MemHeaders
    Attributes - a requirement mask as specified in AllocMem(). Any of the
                AllocMem bits are valid, as is MEMF_LARGEST which returns the
                size of the largest block matching the requirements.

 RESULT
    The total free space remaining in the list (or the largest free block)
    is returned.

 NOTE
    In the current implementation, requirement flags are ignored except
    MEMF_LARGEST.

joinOS.library/ChangeTagList                        joinOS.library/ChangeTagList

 NAME
    ChangeTagList - change a tag list based on a second tag list.

 SYNOPSIS
    void ChangeTagList (struct TagItem *, struct TagItem *)
    ChangeTagList (list, changeList)
                    A0      A1

 FUNCTION
    For any tag that appears in both 'list' and 'changeList', this
    function will change the ti_Data field of the tag in 'list' to
    match the ti_Data field of the tag in 'changeList'. In effect,
    'changeList' contains a series of new values for tags already in
    'list'. Any tag in 'changeList' that is not in 'list' is ignored.

 INPUTS
    list - a list of existing tags (may be NULL)
    changeList - a list of tags to modify 'list' with (may be NULL)

 SEE ALSO
    <joinOS/misc/tagitem.h>, FilterChangeTags()

joinOS.library/ClearMem                                  joinOS.library/ClearMem

 NAME
    ClearMem - Fills a block of memory with ZERO.

 SYNOPSIS
    void ClearMem (APTR, ULONG)
    ClearMem (mem, size)
              A0    D0

 FUNCTION
    This function clears a block of memory.
    This means the whole block of memory if filled with ZERO.
    It can deal with arbitrary length, with its pointers on arbitrary
    alignments.
    The internal implementation of this function will change from system to
    system, and may be implemented via hardware DMA.

 INPUTS
    mem   - a pointer to the data region that should be cleared.
    size  - the size (in bytes) of the memory area. Zero clears zero bytes.

 SEE ALSO
    FillMem()

joinOS.library/ClearMemHeader                      joinOS.library/ClearMemHeader

 NAME
    ClearMemHeader - initializes a MemHeader structure

 SYNOPSIS
    void ClearMemHeader (struct MemHeader *)
    ClearMemHeader (membh)
                     A0

 FUNCTION
    This function is a support function for the pool-memory functions or every
    application that uses MemHeader structures on its own.
    This function initializes a MemHeader structure, as if there is no memory
    of the MemChunk list allocated. This function should only be called if you
    are sure that none of the memory managed by this MemHeader is in use, so
    you can "Deallocate()" all memory used by this MemHeader in one call,
    instead of deallocating every "Allocate'd()" MemChunk.

 INPUT
    membh - a pointer to the MemHeader structure that should be "reseted".

 NOTE
    Only the MemHeader structure passed as argument is initilized, if there
    is linked any other MemHeader structure with the Node structure part at
    the begin of the MemHeader, it stays untouched.

joinOS.library/CloneTagList                          joinOS.library/CloneTagList

 NAME
    CloneTagList - copy a tag list

 SYNOPSIS
    struct TagItem *CloneTagList (struct TagItem *)
    clone = CloneTagList (original)
       D0                    A0

 FUNCTION
    Copies the essential contents of a tag list into a new tag list.

    The cloning is such that calling FindTag() with a given tag on
    the original or cloned tag lists will always return the same
    tag value. That is, the ordering of the tags is maintained.

 INPUTS
    original - tag list to clone. May be NULL, in which case an
                empty tag list is returned.

 RESULTS
    clone - copy of the original tag list, or NULL if there was not enough
             memory. This tag list must eventually by freed by calling
             FreeTagItems().

 SEE ALSO
    <joinOS/misc/tagitem.h>, AllocateTagList(), FreeTagList(),
    RefreshTagListClones()

joinOS.library/CountNodes                              joinOS.library/CountNodes

 NAME
    CountNodes - counts the number of nodes in a list

 SYNOPSIS
    ULONG CountNodes (struct List *)
    numNodes = CountNodes (list)
       D0                   A0

 FUNCTION
    This functions counts the number of nodes found in a particular list.

 INPUT
    list - the list, which nodes should be count

 RESULT
    The number of nodes found in the list is returned.

joinOS.library/CreateMemPool                        joinOS.library/CreateMemPool

 NAME
    CreateMemPool - allocate and prepare a new pool memory header.

 SYNOPSIS
    void *CreateMemPool (ULONG, ULONG, ULONG)
    poolHeader = CreateMemPool (MemFlags, PuddleSize, ThreshSize)
        D0                        D0         D1           D2

 FUNCTION
    Allocate and prepare a new pool memory header.
    The pool memory header is allocated and initialized and the first puddle
    is allocated. (On AmigaOS >= V39 it's undefined if the first puddle is
    allocated by pool creation or by the first allocate of memory of the
    pool).

 INPUTS
    MemFlags    - specify the kind of memory of the pool, these are the same
       flags as taken by AllocMem().
    PuddleSize  - specifies the size of the "puddles".
    TreshSize   - the largest allocation that goes into normal puddles.
       Allocations larger than the <ThreshSize> are allocation in their own
       puddles. This must be less or equal to <PuddleSize>, CreateMemPool()
       will fail if it is not).

 RESULT
    If the function succeeds, a pointer to the new pool header is returned.
    If the function fails, NULL is returned.

 NOTE
    Don't mismatch this function with the CreatePooled() function of the
    AmigaOS >= V39.
    The MEMF_CLEAR memflag is ignored, the memory returned from
    AllocPoolMem() is NOT zero-initialized.

 SEE ALSO
    AllocPoolMem(), FreePoolMem(), DeleteMemPool()

joinOS.library/CreateSignalSemaphore        joinOS.library/CreateSignalSemaphore

 NAME
    CreateSignalSemaphore - allocates and initializes a SignalSemaphore

 SYNOPSIS
    struct SignalSemaphore *CreateSignalSemaphore (STRPTR, BYTE)
    sigSem = CreateSignalSemaphore (name, pri)
      D0                             A0   D0:8

 FUNCTION
    This function allocates and initializes a SignalSemaphore for the use
    with the semaphore functions.
    If a name if passed to this function, the semaphore will be made public
    by this function.
    This function is new for all operating systems, but you should use it
    also for AmigaOS functions, because it is save in use. (Under AmigaOS
    previour V36 the function AddSemaphore() has a bug and doesn't work.

    If you want to create SignalSemaphores in the old fashioned manner, use
    the AllocMem() function with the memory attribute MEMF_PUBLIC for
    allocating the memory for the semaphore, or the semaphore will not be
    found by other processes.
    You should not try to use SignalSemaphores initialized by InitSemaphore()
    as public semaphores. If you try to make a Semaphore public that is in
    use, that will fail.

 INPUTS
    name - a (optional) name of the semaphore, if this is NULL, the semaphore
           is not made public. This name will be copied to a new allocated
          buffer, so it has not to stay valid after this function succeeds.
    pri - the priority, used for linking it into the systems list of
          semaphores, if you often search the semaphore give it a higher
          priority, normaly you should pass 0.

 RESULT
    If the function succeeds, a pointer to a fully initialized and
    "ready to use" SignalSemaphore is returned. If a name is passed to this
    function, the semaphore would be made public.
    If the function fails, NULL is returned.

 NOTE
    Be shure that the name of a SignalSemaphore you create without using
    this function is unique in the whole Windoof system or you will produce
    unpredictable results. There is no combatible way to determine, if a
    chosen name is not used by any other Windoof process for its semaphore.
    Use the following code segment for testing:

 struct SignalSemaphore *OwnSemaphoreCreation (STRPTR name)
 {
    struct SignalSemaphore *sigSem = NULL;

    Forbid();
    if (sigSem = FindSemaphore (semaphoreName))
    {
       // There is already a public semaphore with the same name in Exec's
       // public semaphore list...
       sigSem = NULL;
    }
    else
    {
       // Create the semaphore in the old fashion manner, be shure you use
       // MEMF_PUBLIC | MEMF_CLEAR for allocating the SignalSemaphore
       // structure and MEMF_PUBLIC for the name pointed by
       // sigSem->ss_Link.ln_Name...

       AddSemaphore(sigSem);
    }
    return sigSem;
 }

 SEE ALSO
    DeleteSignalSemaphore()

joinOS.library/DOUBLELONG2Str                      joinOS.library/DOUBLELONG2Str

 NAME
    DOUBLELONG2Str - create a decimal string according to a DOUBLELONG value

 SYNOPSIS
    LONG DOUBLELONG2Str (DOUBLELONG *, STRPTR)
    bytesCopied = DOUBLELONG2Str (value, buffer)
        D0                         A0      A1

 FUNCTION
    This function copies the decimal string that corresponds to the
    specified DOUBLELONG value into a buffer.

 INPUTS
    value - a pointer to the DOUBLELONG value that should be converted
    buffer - a pointer to the buffer, where the corresponding decimal
             string should be stored. This buffer has to be at least
             22 bytes large.

 RESULT
    The number of bytes copied to the destination buffer (without the
    terminating NUL-byte) is returned.

 SEE ALSO
    Str2DOUBLELONG()

joinOS.library/Date2Str                                  joinOS.library/Date2Str

 NAME
    Date2Str - convert a DateStamp into a human readable string

 SYNOPSIS
    BOOL Date2Str (struct DateTime*)
    success = Date2Str (DateTime)
       D0                  D1

 FUNCTION
    DateToStr converts an AmigaDOS DateStamp to a human
    readable ASCII string as requested by your settings in the
    DateTime structure.

 INPUTS
    DateTime - a pointer to an initialized DateTime structure.

    The DateTime structure should be initialized as follows:

    dat_Stamp - a copy of the datestamp you wish to convert to ascii.

    dat_Format - a format byte which specifies the format of the dat_StrDate.
       This can be any of the following (note: If value used is something
       other than those below, the default of FORMAT_DOS is used):

       FORMAT_DOS:   AmigaDOS format (dd-mmm-yy).
       FORMAT_INT:   International   format (yy-mm-dd).
       FORMAT_USA:   American format (mm-dd-yy).
       FORMAT_CDN:   Canadian format (dd-mm-yy).
       FORMAT_DEF:   default format for locale.

    dat_Flags - a flags byte. The only flag which affects this function is:

       DTF_SUBST:    If set, a string such as Today, Monday, etc., will be
                used instead of the dat_Format specification if possible.
       DTF_FUTURE:   Ignored by this function.

    dat_StrDay - pointer to a buffer to receive the day of the week string.
       (Monday, Tuesday, etc.). If null, this string will not be generated.

    dat_StrDate -  pointer to a buffer to receive the date string, in the
       format requested by dat_Format, subject to possible modifications by
       DTF_SUBST. If null, this string will not be generated.

    dat_StrTime -  pointer to a buffer to receive the time of day string.
       If NULL, this will not be generated.

    If non-NULL, all string buffers must be at least 16 bytes (LEN_DATSTRING)
    in size.

 RESULT
    success  - a zero return indicates that the DateStamp was invalid, and
    could not be converted. Non-zero indicates that the call succeeded.

 SEE ALSO
    Str2Date(), IsValidDate(), Long2Str()

joinOS.library/DatesCompare                          joinOS.library/DatesCompare

 NAME
    DatesCompare - compare two DateStamps

 SYNOPSIS
    LONG DatesCompare (const struct DateStamp*, const struct DateStamp*)
    result = DatesCompare (First, Second)
      D0                    D1      D2

 FUNCTION
    Compare two DateStamps for their relative magnitude.

 INPUTS
    First    - the first DateStamp that should be compared against ...
    Second   - the second DateStamp.

 RESULT
    < 0 => the second DateStamp is earlier than the first DateStamp.
    = 0 => the second DateStamp equals the first DateStamp.
    > 0 => the second DateStamp is later than the first DateStamp.

 SEE ALSO
    Date2Str(), IsValidDate()

joinOS.library/DayOfWeek                                joinOS.library/DayOfWeek

 NAME
    DayOfWeek - return a number representing the weekday

 SYNOPSIS
    ULONG DayOfWeek (ULONG)
    week = DayOfWeek (days_passed)

 FUNCTION
    This function returns the no. of the weekday (0 = sunday, 1 = monday ...)
    for a specified day.

 INPUT
    days - number of days passed since 01.01.1978.

 RESULT
    The number of the weekday (0 - 6).

 SEE ALSO
    Date2Str()

joinOS.library/Delete                                      joinOS.library/Delete

 NAME
    Delete - delete a filesystem object

 SYNOPSIS
    success = Delete (name)
    LONG Delete (STRPTR)

 FUNCTION
    This function attempts to delete a file or directory.
    An error is returned if the deletion fails.
    Note that all the files within a directory must be deleted before the
    directory itself can be deleted.

 INPUT
    name - a NUL-terminated C-string that identifies the filesystem object
          to be removed.

 RESULT
    If the function succeeds, DOSTRUE is returned.
    If the function fails, DOSFALSE is returned.

 NOTE
    On Amiga systems this function is implemented as macro that expands to
    a function call of the dos.library function DeleteFile().

joinOS.library/DeleteMemPool                        joinOS.library/DeleteMemPool

 NAME
    DeleteMemPool - destroy a memory pool

 SYNOPSIS
    void DeleteMemPool (void *)
    DeleteMemPool (PoolHeader)
                   A0

 FUNCTION
    Free all allocated blocks of memory and destroy the pool.
    Be sure that your application doesn' access the memory any more, otherwise
    this will result in a system crash.
    Doing a DeleteMemPool() will free all puddles and thus all of the
    allocations done with AllocPoolMem() in that pool. (No need to
    FreePoolMem() each allocation)

 INPUT
    PoolHeader  - the pointer to the pool header as returned from
                   CreateMemPool().

 NOTE
    Don't confuse with the AmigaOS V39 function DeletePool().

 SEE ALSO
    AllocPoolMem(), FreePoolMem(), CreateMemPool(), DeleteMemPool()

joinOS.library/DeleteSignalSemaphore        joinOS.library/DeleteSignalSemaphore

 NAME
    DeleteSignalSemaphore - destroy a SignalSemaphore

 SYNOPSIS
    void DeleteSignalSemaphore (struct SignalSemaphore *)
    DeleteSignalSemaphore (sigSem)
                             A0

 FUNCTION
    This functions destroys a SignalSemaphore previously allocated using
    CreateSignalSemaphore(). This function is new for every system, but should
    be used for writing portable code.

    Only the task that has created the semaphore should destroy it, otherwise
    you will have problems under Windoof.

 INPUT
    sigSem - the SignalSemaphore to be destroyed.

 NOTE
    If you destroy a semaphore by your own, you have to take care that
    noone else accesses it while you destroy it. And take care that you close
    the Windoof semaphore handle, stored in the ss_Sem field. THIS COULD NOT
    BE DONE IN COMPATIBLE CODE.

 SPECIAL NOTE
    If you previously created a local (nameless) semaphore using
    CreateSignalSemaphore() and have made it public ba adding a name on your
    own to 'sigSem->ss_Link.ln_Name', you have to remove the semaphore by
    your own from the systems list (RemSemaphore()) and clear this pointer
    before you call this function (sigSem->ss_Link.ln_Name = NULL) or the
    buffer the name is located in will be freed using:

       FreeMem (sigSem->ss_Link.ln_Name, strlen (sigSem->ss_Link.ln_Name)+1);

    If you haven't allocated the name buffer in a according way, this will
    result in a system crash.

 SEE ALSO
    CreateSignalSemaphore()

joinOS.library/Divs64                                      joinOS.library/Divs64

 NAME
    Divs64 - a signed 64 bit integer division

 SYNOPSIS
    void Divs64 (DOUBLELONG *, LONG)
    Divs64 (divident, divisor)
               A0       D0

 FUNCTION
    This function performs a division of a signed 64 bit integer through a
    32 bit signed integer. The result is also a signed 64 bit integer.

 INPUTS
    divident - a pointer to the 64 bit signed integer, the divident of this
                operation. The result of this function is stored in this
                variable.
    divisor - the 32 bit signed integer used as divisor of the operation

 NOTE
    If a division by zero occurs the division functions returns a result with
    all bits set, the caller of this functions should take care, that such a
    case never occures, because this result could also be produced by valid
    divisors (e.g. 0xFFFF FFFF FFFF FFFF / 1)

 SEE ALSO
    Adds64(), Divu64(), Mulu64(), Muls64(), Neg64()

joinOS.library/Divu64                                      joinOS.library/Divu64

 NAME
    Divu64 - an unsigned 64 bit integer division

 SYNOPSIS
    void Divu64 (DOUBLELONG *, ULONG)
    Divu64 (divident, divisor)
               A0       D0

 FUNCTION
    This function performs a division of an unsigned 64 bit integer through
    32 bit unsigned integer. The result is also an unsigned 64 bit integer.

 INPUTS
    divident - a pointer to the 64 bit unsigned integer, the divident of this
                operation. The result of this function is stored in this
                variable.
    divisor - the 32 bit unsigned integer used as divisor of the operation

 NOTE
    If a division by zero occurs the division functions returns a result with
    all bits set, the caller of this functions should take care, that such a
    case never occures, because this result could also be produced by valid
    divisors (e.g. 0xFFFF FFFF FFFF FFFF / 1)

 SEE ALSO
    Adds64(), Divs64(), Mulu64(), Muls64(), Neg64()

joinOS.library/DoDosPkt                                  joinOS.library/DoDosPkt

 NAME
    DoDosPkt - send a packet synchronously (i.e. wait for the reply)

 SYNOPSIS
    LONG DoDosPkt (struct MsgPort*, LONG, LONG, LONG, LONG, LONG, LONG)
    result = DoDosPkt (mp, type, arg1, arg2, arg3, arg4, arg5)
      D0               D1   D2    D3    D4    D5    D6    D7

 FUNCTION
    DoPkt() sends a packet to a port (usually that of a handler process),
    waits for the reply and returns both the primary and the secondary result
    to the caller. Depending on whether DoPkt() has been invoked from a
    processor or from a task environment, the secondary result is returned in
    IoErr() or under AmigaOS in register D1, under other systems it is not
    returned !
    If more than five packet parameters must be passed, one should use the
    functions SendPkt() and WaitPkt() instead of DoPkt().

    Even though the dos.library attempts to temporary allocate the resources
    required to make this function usable from a task, DoPkt() should -
    contrary to the official documentation - never be called from anything
    but a process, since DoPkt() does not know about the handler- and packet-
    specific value returned in dp_Res1 in the event of failure.

    For processes pr_MsgPort is used as the reply port, so calling DoPkt()
    or any other synchronous packet function while asynchronous packets with
    a reply port of pr_MsgPort are still pending is likely to crash the
    system with an AN_AsyncPkt Guru message.

 INPUTS
    mp - a pointer to the port, the packet should be send to.
    type - the action (dp_Type) e.g. ACTION_FINDINPUT.
    arg1...arg5 - packet parameters dp_Arg1 to dp_Arg5

 RESULT
    The primary result (dp_Res1) of the I/O is returned, if the calling
    instance is a process, the secondary result (dp_Res2) is returned in
    IoErr().

 SEE ALSO
    AbortDosPkt(), SendDosPkt, ReplyDosPkt, WaitDosPkt()

joinOS.library/ErrorText                                joinOS.library/ErrorText

 NAME
    ErrorText - get the descriptive text to an errorcode

 SYNOPSIS
    LONG ErrorText (LONG, STRPTR, STRPTR, LONG)
    bytescopied =  ErrorText (code, text, buffer, bufsize)
        D0                     D1    D2     D3       D4

 FUNCTION
    Convert an (AmigaDOS) error code into a descriptive text.
    This is the Windoof-version, it also converts the Windoof
    error codes into a descriptive text using FormatMessage().
    The resulting text shouldn't be longer than FAULT_MAX chars
    (defined in <dos/dos.h> or "AmigaDOS.h").

 INPUTS
    code - the error number, which errortext is requested, if the errorcode
           isn't known, the text "Error <code>" is returned
    text - a preceding text, copied before the error text followed by a
           colon. If the is NULL nothing precedes the error text.
    buffer - the buffer where the error text should be copied to.
    bufsize - the bytesize of the buffer.

 RESULT
    The function should return the number of bytes copied to the buffer,
    which will be 0 if an errorcode of 0 is passed.

 BUGS
    The Amiga Guru Book says: The returncode is unusable, but the official
    documentation doesn't reports this bug !
    In older official documentation, this returnvalue was shown as BOOL,
    this was incorrect, it always returned the length.

 SEE ALSO
    PrintError(), ReportError(), SetIOErr(), <joinOS/dos/AmigaDOS.h>

joinOS.library/ExamineAll                              joinOS.library/ExamineAll

 NAME
    ExamineAll - Examine an entire directory.

 SYNOPSIS
    LONG ExamineAll (BPTR, struct ExAllData*, ULONG, ULONG, struct ExAllControl*
)
    success = ExamineAll (fl, buffer, bufSize, type, exAllControl)
      D0                  D1    D2      D3      D4       D5

 FUNCTION
    ExamineAll() is the function replacement for ExAll(), which is called,
    if a dos.library with a Version < 36 is found in the system, or if the
    called handler failed with ERROR_ACTION_NOT_KNOWN.
    See ExAll() for a description of this function.

 INPUTS
    fl - a BPTR to the FileLock of the directory that should be
          examined. If the Lock is not a directory, DOSFALSE is returned
          and an IoErr() of ERROR_INVALID_LOCK is set.
    buffer - the buffer where the ExAllData structures should be stored in.
          (MEMF_PUBLIC, MUST be at least WORD-aligned, preferably long-word
          aligned)
    bufSize - the byte size of the buffer. If the desired buffer is to small
          to hold a single directory entry the ExAll() function will NEVER
          return DOSFALSE.
    type - the type of data that should be received (See "AmigaDOS.h").
    exAllControl - the structure used to control ExAll(), it must be allocated
          using AllocDosObject (DOS_EXALLCONTROL,NULL) and all fields must be
          initialized properly before the first call to ExAll(). Don't alter
          the fields of the structure between subsequent calls to ExAll().

 RESULT
    If the function succeeds, either DOSTRUE is returned or DOSFALSE and a
    secondary result (IoErr()) equal to ERROR_NO_MORE_ENTRIES.
    If the function fails, DOSFALSE is returned and a secondary result not
    equal to ERROR_NO_MORE_ENTRIES.

 NOTE
    The filtering by using the eac_MatchFunc call-back function is currently
    not implemented.

 SEE ALSO
    ExamineAllEnd()

joinOS.library/ExamineAllEnd                        joinOS.library/ExamineAllEnd

 NAME
    ExamineAllEnd - Stop an ExamineAll

 SYNOPSIS
    void ExamineAllEnd (BPTR, struct ExAllData*, ULONG, ULONG, struct ExAllContr
ol*)
    ExamineAllEnd (fl, buffer, bufSize, type, exAllControl)
                   D1    D2      D3      D4       D5

 FUNCTION
    Stops an ExamineAll() on a directory before it hits NO_MORE_ENTRIES.
    The full set of arguments that has been passed to ExamineAll() must be
    passed to ExamineAllEnd(), so it can handle filesystems that can't abort
    an ExamineAll() directly.

 INPUTS
    fl       - a BPTR to the FileLock, previously passed to ExamineAll().
    buffer   - a pointer to the buffer for the data to be returned (MUST be
                at least WORD-aligned, preferably long-word aligned).
    bufSize  - the byte-size of the buffer
    type     - type of date to be returned as previously passed to ExamineAll().
    exAllControl - a pointer to the ExAllControl-structure used for ExamineAll()
.

 SEE ALSO
    ExamineAll()

joinOS.library/FillMem                                    joinOS.library/FillMem

 NAME
    FillMem - fill a block of memory with a specified byte-value

 SYNOPSIS
    void FillMem (APTR, ULONG, UBYTE)
    FillMem (mem, size, byte)
             A0    D0   d1:8

 FUNCTION
    This function fills a block of memory with the specified value.
    This means every byte in the block of memory get the specified value.
    It can deal with arbitrary length, with its pointers on arbitrary
    alignments.
    The internal implementation of this function will change from system to
    system, and may be implemented via hardware DMA.

 INPUTS
    mem   - a pointer to the data region that should be filled.
    size  - the size (in bytes) of the memory area. Zero fills zero bytes.
    byte - the value that should be copied into every byte of the memory

 SEE ALSO
    ClearMem()

joinOS.library/FilterChangeTags                  joinOS.library/FilterChangeTags

 NAME
    FilterChangeTags - eliminate tags which specify no change

 SYNOPSIS
    void FilterChangeTags(struct TagItem *, struct TagItem *, ULONG)
    FilterChangeTags(changeList, originalList, apply)
                      A0          A1         D0

 FUNCTION
    This function goes through changeList. For each item found in
    changeList, if the item is also present in originalList, and their
    data values are identical, then the tag is removed from changeList.
    If the two tag's data values are different and the 'apply' value is
    non-zero, then the tag data in originalList will be updated to match
    the value from changeList.

 INPUTS
    changeList - list of new tags (may be NULL)
    originalList - a list of existing tags (may be NULL)
    apply - boolean specification as to whether the data values in
             originalList are to be updated to the data values in
             changeList.

 EXAMPLE
    Assume you have an attribute list for an object (originalList)
    which looks like this:

       {ATTR_Size,  "large"},
       {ATTR_Color, "orange"},
       {ATTR_Shape, "square"}

    If you receive a new tag list containing some changes (changeList),
    which looks like this:

       {ATTR_Size,  "large"},
       {ATTR_Shape, "triangle"}

    If you call FilterChangeTags(), changeList will be modified to
    contain only those attributes which are different from those
    in originalList. All other items will have their tag values set to
    TAG_IGNORE. The resulting changeList will become:

       {TAG_IGNORE, "large"},
       {ATTR_Shape, "triangle"}

    If 'apply' was set to 0, originalList would be unchanged. If 'apply'
    was non-zero, originalList would be changed to:

       {ATTR_Size,  "large"},
       {ATTR_Color, "orange"},
       {ATTR_Shape, "triangle"}

 SEE ALSO
    <joinOS/misc/tagitem.h>, ChangeTagList()

joinOS.library/FilterTagList                        joinOS.library/FilterTagList

 NAME
    FilterTagList - remove selected items from a tag list

 SYNOPSIS
    ULONG FilterTagList (struct TagItem *, Tag *, ULONG)
    numValid = FilterTagList (tagList, filterArray, logic)
      D0                        A0         A1        D0

 FUNCTION
    Removes tag items from a tag list (by changing ti_Tag to
    TAG_IGNORE) depending on whether its ti_Tag value is
    found in an array of tag values.

    If the 'logic' parameter is TAGFILTER_AND, then all items
    not appearing in 'tagArray' are excluded from 'tagList'.

    If 'logic' is TAGFILTER_NOT, then items not found in 'tagArray'
    are preserved, and the ones in the array are cast out.

 INPUTS
    tagList  - input list of tag items which is to be filtered by having
               selected items changed to TAG_IGNORE.
    filterArray - an array of tag values, terminated by TAG_DONE, as
                specified in the documentation for TagInArray().
    logic - specification whether items in 'tagArray' are to be included
          or excluded in the filtered result.

 RESULTS
    numValid - number of valid items left in resulting filtered list.

 SEE ALSO
    <utility/tagitem.h>, TagIsInArray()

joinOS.library/FindArgument                          joinOS.library/FindArgument

 NAME
    FindArgument - search a template string for a keyword

 SYNOPSIS
    LONG FindArgument (STRPTR, STRPTR)
    argNum = FindArgument (template, keyword)
      D0                      D1        D2

 FUNCTION
    This function searches the specified keyword in the template string.
    The template string is a sequence of comma-separated keywords the second
    string is matched against. If the keyword is found, the index of it in
    the template string is returned.
    The following characters have special meanings within a template string
    and thus cannot be part of a keyword:
     - the comma (',') is used to separate keywords
     - the equal sign ('=') can be used to define aliases
     - everything beyond a slash ('/'), including the slash itself, up to the
       next comma (or up to the end of the template string) is ignored. This
       is used by ParseArgs() to store the template modifier as part of the
       template string.
    The string comparison is case-insensitive.

 INPUTS
    template - a pointer to the template string (C string) to search keyword
                in
    keyword - a pointer to the keyword of an argument as defined by the
                template string

 RESULT
    If the specified keyword could be found, the index of the respective
    keyword will be returned, zero being the first keyword, one the second,
    etc.;
    if the function fails to find the specified keyword in the template
    string, -1 is returned.

 SEE ALSO
    <joinOS/dos/rdArgs.h>, ParseArgs(), FreeArguments(), ParseItem()

joinOS.library/FindDOSEntry                          joinOS.library/FindDOSEntry

 NAME
    FindDOSEntry - find an entry by name in the dos list

 SYNOPSIS
    struct DosList *FindDOSEntry(struct DosList *, const char *, ULONG)
    entry = FindDOSEntry(Previous, Name, AccessFlags)
      D0                   D1       D2       D3

 FUNCTION
    Find an entry by name in the list of devices, volumes and assignments.
    The function behaves similarly to NextDosEntry(), but it will return
    an entry only if its name (dol_Name) matches the one passed as second
    argument to this function.
    The DOS list must be locked for the specified type of entry using
    LockDosList() or AttemptLockDosList() before you call this function.

    Because these functions are not available under AmigaOS versions below
    v36 (2.0), you have to embed the parsing of the doslist by a Forbid()/
    Permit() pair. Copy the information you need from the doslist and free
    it as fast as possible, the buffer you use for copying should be
    allocated outside of the Forbid()/Permit() pair, because the allocation
    may break the forbidden state.

 INPUTS
    Previous - the last processed Dos list entry as returned by a previous
             call to FindDosEntry() or NextDosEntry() or the value returned
             by a successful AttemptLockDosEntry() or LockDosEntry().
    Name     - the name of the searched entry (NUL-terminated C-string)
    AccessFlags - the type of entry that is searched, be shure that the DOS
             list is locked for that type of entry.

 RESULT
    If an entry with the specified name is found in the DOS list behind
    the previous found entry, a pointer to that entry is returned.
    If no matching entry is found, NULL is returned.

 SEE ALSO
    LockDOSList(), UnLockDOSList(), NextDOSEntry()

joinOS.library/FindFirstMatch                      joinOS.library/FindFirstMatch

 NAME
    FindFirstMatch - find the first object matching a specified pattern

 SYNOPSIS
    errorcode = FindFirstMatch (pattern, anchor)
       D0                         D1       D2
    LONG FindFirstMatch (STRPTR, struct AnchorPath *)

 FUNCTION
    This function - in conjunction witch MatchNext() -  searches in the
    directory-tree of a volume for all filesystem objects that match the
    specified pattern.
    This way it's easy to access all matching objects without the need of
    recursive programming.

    When an application is done using MatchFirst() and MatchNext(),
    it must call MatchEnd(), even if an error has occured.

 INPUTS
    pattern  - the pattern that should be looked out for. A pattern string
       is any AmigaDos filesystem-path that could include wildcards
       (e.g. "Dh0:foo/#?"). The patterns are parsed on a per-directory-level,
       so it is not possible to make a directory separator partof a pattern-
       expression (e.g. "(#?|#?/#?)").
       If the pattern includes a volume name, the volume name must not
       include any pattern, if no volume is specified, the current directory
       is the root-directory of the search.
       In opposite to the AmigaDOS pattern matching functions, the asterisk
       is NEVER accepted as the universal wild card.
    anchor   - a pointer to a user-allocated and initialized AnchorPath
       structure. Since it contains a FileInfoBlock structure it must be
       longword aligned.
       The following fields of the AnchorPath structure must be initialized:
          ap_Flags - set to APF_FollowHLinks if hard links to directories
             (which might cause a program without further checks to loop
             endlessly) should be followed. Otherwise set this field to 0.
          ap_BreakBits - set this field to the breakbits  (SIGBREAKF_CTRL_?)
             that you want to take a break on, or 0L, if you don't want to
             convenience the user.
          ap_Strlen - If you need the full path of the found objects, you
             must allocate a buffer at the end of this structure (allocate
             sizeof (struct AnchorPath) + buffersize) and put the size of the
             buffer into this field, If you don't want the full path name,
             make sure you set ap_Strlen to zero.  In this case, the name of
             the file, and stats are available in the ap_Info, as per usual.
          ap_FoundBreak - should be set to zero, if this field is required
             by the application.
          The reserved fields should be initialized with zero, so it's best
          to allocate this structure with the MEMF_CLEAR specifier.

 RESULT
    The function returnes the AmigaDos errorcode of an error that prevents
    the parsing of the volumes-tree, or 0 in the event of success.
    If no object matching the specified pattern could be found
    ERROR_OBJECT_NOT_FOUND or ERROR_NO_MORE_ENTRIES is returned.
    If the pattern does only specify a single file (pattern without wildcards)
    which couldn't be locked shared, ERROR_OBJECT_IN_USE is returned.
    If the pattern is too complex to be parsed, ERROR_TOO_MANY_LEVELS is set.
    If the pattern is illegal (e.g. missing a closing bracket or a separator
    is part of a pattern expression "(#?/#?)" ERROR_BAD_TEMPLATE is returned.

    Every other errorcode (like ERROR_NO_FREE_STORE) that could occure by
    using Lock(), Examine(), or ExNext() could also be returned.

    If the returned value is 0, the matching object could be accessed using
    the directory lock <anchor->ap_Current->an_Lock> and the filename found
    in <anchor->ap_Info.fib_FileName>.

 SEE ALSO
    FindNextMatch(), FindMatchEnd()

joinOS.library/FindMatchEnd                          joinOS.library/FindMatchEnd

 NAME
    FindMatchEnd - deallocate all resources used for matching

 SYNOPSIS
    void FindMatchEnd (struct AnchorPath *)
    FindMatchEnd (anchor)
                    D1

 FUNCTION
    This function dealloctes all resources that have been allocated by the
    functions MatchFirst() and MatchNext() during previous calls to them.
    The AnchorPath structure itself remains valid, but must be reinitialized
    before it can be reused.
    All locks that are done by MatchFirst() and MatchNext() are
    unlocked with this function, so be shure that you don't use them any
    more.

 INPUT
    anchor - the AnchorPath structure used during MatchFirst and MatchNext

 SEE ALSO
    FindFirstMatch(), FindNextMatch()

joinOS.library/FindNextMatch                        joinOS.library/FindNextMatch

 NAME
    FindNextMatch - find the next matching filesystem object

 SYNOPSIS
    LONG FindNextMatch (struct AnchorPath *)
    error = FindNextMatch (anchor)
      D0                    D1

 FUNCTION
    This function searches the next filesystem object that matches the
    pattern passed previously to MatchFirst()
    If the last returned object was a directory and you want to process
    all object in that directory you must set the flag ADF_DODIR (by
    "or"ing it in: "anchor->ap_Flags |= ADF_DODIR"). This flag is cleared
    after every call to this function.
    Because hardlinks may produce endless loops, if they are followed, it
    must be explicitly sayed that they should be followed by setting the
    flag ADF_FollowHLinks.
    Softlinks to directories are not processed by this function.

 INPUT
    anchor - a pointer to the AnchorPath structure that was used for a
             previous call to MatchFirst().

 RESULT
    If the function succeed and another matching object could be found, zero
    is returned. If not another matching object could be found,
    ERROR_NO_MORE_ENTRIES is returned.
    Use the lock <anchor->ap_Current->an_Lock> to access the directory the
    object is found in, and <anchor->ap_Info.fib_FileName> to access the
    object.
    If entered (by setting the flag APF_DODIR), directory style objects are
    returned twice, before entering the directory and after all entries in
    that directory are done, so you are able to handle the directory before
    you process the contents of it, and after you done processing the entries
    in that directory.
    The second time a directory object is returned the flag ADF_DIDDIR is set.

 NOTE
    It might produce unpredictable results if you call this function after a
    previous call to this or to MatchFirst() fails with any other error
    than ERROR_OBJECT_NOT_FOUND, ERROR_NO_MORE_ENTRIES, or ERROR_NO_FREE_STORE
    So you better avoid calling this function after any failure.
    But nevertheless don't forget to call MatchEnd() after you are done
    using these function.

 BUGS
    The function may return wrong full paths to the found objects, if the
    volumes directory tree is changed between the call to MatchFirst()
    and MatchEnd(), which could be done by renaming or moving a directory
    that is one of the parents of the processed directories, so you should
    only use this names (anchor->an_Buf) for statistical purpose.

 SEE ALSO
    FindFirstMatch(), FindMatchEnd()

joinOS.library/FindTag                                    joinOS.library/FindTag

 NAME
    FindTag - scan a tag list for a specific tag

 SYNOPSIS
    struct TagItem *FindTag (Tag,struct TagItem *)
    tag = FindTag (tagValue, tagList)
     D0               D0        A0

 FUNCTION
    Scans a tag list and returns a pointer to the first item with
    ti_Tag matching the 'tagValue' parameter.

 INPUTS
    tagValue - tag value to search for
    tagList  - tag item list to search (may be NULL)

 RESULTS
    tag - a pointer to the item with ti_Tag matching 'tagValue' or NULL
          if no match was found.

 SEE ALSO
    <joinOS/misc/tagitem.h>, GetTagItem(), PackBooleanTags(), NextTag()

joinOS.library/FreeArguments                        joinOS.library/FreeArguments

 NAME
    FreeArguments - free all allocated memory used for parsing arguments

 SYNOPSIS
    void FreeArguments (struct RDArgs *)
    FreeArguments (rdArgs)
                    D1

 FUNCTION
    Free the whole RDArgs structure.
    All entries and the strings allocated by ParseArgs() are freed.
    If the RDArgs structure itself was allocated by ParseArgs() it is also
    freed, else the user is responsible for freeing the RDArgs structure.

 INPUT
    rdArgs - a pointer to the RDArgs structure as previously returned from
              ParseArgs()

 RESULT
    The function has no returncode, the whole ArgFormat structure is freed.
    Don't access this structure any more.

 NOTE
    It is save to call this function with a NULL-pointer.

 SEE ALSO
    <joinOS/dos/rdArgs.h>, ParseArgs()

joinOS.library/FreeDOSObject                        joinOS.library/FreeDOSObject

 NAME
    FreeDOSObject - deallocate a dos specific structure

 SYNOPSIS
    void FreeDOSObject (ULONG, void*)
    FreeDOSObject (Type, Object)
                    D1     D2

 FUNCTION
    Deallocate a specific DOS structure previously allocated using
    AllocDosObject().
    All objects that are allocated using AllocDosObject() *MUST* be
    deallocated using this function.

 INPUTS
    Type - specifies the type of object that should be deallocated, can be
          any of the following types:
       DOS_FILEHANDLE - a FileHandle for use in file-I/O-functions.
       DOS_FIB        - a FileInfoBlock as used for Examine() or ExNext().
       DOS_EXALLCONTROL - a ExAllControl function as used for ExAll().
       DOS_STDPKT     - a DosPacket for packed-oriented IO
       DOS_CLI        - a CommandLineInterface structure
       DOS_RDARGS     - a RDArgs structure
    Object - a pointer to the object that should be deallocated as previously
             gotten from AllocDosObject().

 BUGS
    Under AmigaOS the buffers cli_SetName, cli_CommandName, cli_CommandFile,
    and cli_Prompt of a CommandLineInterface structure are NOT freed.

 SEE ALSO
    AllocDOSObject()

joinOS.library/FreePoolMem                            joinOS.library/FreePoolMem

 NAME
    FreePoolMem - put a memory block back into the pool

 SYNOPSIS
    void FreePoolMem (void *, void *, ULONG)
    FreePoolMem (PoolHeader, mem, size)
                    A0       A1    D0

 FUNCTION
    Put a memory block previous gotten with AllocPoolMem() back to the memory
    pool. If an aditional puddle, the memory belonged to, isn't used any more,
    the puddle is removed and the memory of that puddle is freed.

 INPUTS
    PoolHeader - the pointer to the pool header as returned from
            CreateMemPool().
    mem - a pointer to the memory previousle allocated with AllocPoolMem().
            NEVER EVER try to put memory back to the pool that wasn't allocated
            using AllocPoolMem().
    size - the size of the returned memory block in bytes. Freeing partial
            blocks of memory is "unwise", it may not work on AmigaOS V39 and
            above, and you should notice that memory blocks are always longword
            aligned (position and size of the blocks).

 SEE ALSO
    AllocPoolMem(), CreateMemPool(), DeleteMemPool()

joinOS.library/FreeTagList                            joinOS.library/FreeTagList

 NAME
    FreeTagList - free an allocated tag list

 SYNOPSIS
    void FreeTagList (struct TagItem *)
    FreeTagList (tagList)
                   A0

 FUNCTION
    Frees the memory of a TagItem list allocated either by
    AllocateTagList() or CloneTagList().

 INPUTS
    tagList - list to free, must have been obtained from
               AllocateTagList() or CloneTagList() (may be NULL)

 SEE ALSO
    <joinOS/misc/tagitem.h>, AllocateTagList(), CloneTagList()

joinOS.library/FreeVector                              joinOS.library/FreeVector

 NAME
    FreeVector - free a memory block, allocated by AllocVec()

 SYNOPSIS
    void FreeVector(APTR)
    FreeVector(mem)
                A0

 FUNCTION
    This functions frees the memory previously allocated using AllocVec().

 INPUT
    mem - pointer to the memory block that should be freed.

 SEE ALSO
    AllocVector()

joinOS.library/GetSysBase                              joinOS.library/GetSysBase

 NAME
    GetSysBase - Get the address of Execs library node

 SYNOPSIS
    SysBase = GetSysBase ()
    struct ExecBase *GetSysBase (void)

 FUNCTION
    This function returns the address, where the Exec library base is found
    in memory.

 RESULT
    The address of the Exec library base is returned.

 NOTE
    This function is implemented as macro for Amiga systems.

joinOS.library/GetTagItem                              joinOS.library/GetTagItem

 NAME
    GetTagItem - obtain the data corresponding to a tag.

 SYNOPSIS
    ULONG GetTagItem (Tag, ULONG, struct TagItem *)
    value = GetTagItem (tagValue, defaultVal, tagList)
      D0                   D0          D1       A0

 FUNCTION
    Searches a tag list for a matching tag, and returns the
    corresponding ti_Data value for the TagItem found. If no match is
    found, this function returns the value passed in as 'default'.

 INPUTS
    tagValue - tag value to search for.
    defaultVal - value to be returned if tagValue is not found.
    tagList - the tag list to search.

 RESULTS
    value - the ti_Data value for the first matching TagItem, or 'default'
             if a ti_Tag matching 'Tag' is not found.

 SEE ALSO
    <joinOS/misc/tagitem.h>, FindTag(), PackBooleanTags(), NextTag()

joinOS.library/IsAmigaDosError                    joinOS.library/IsAmigaDosError

 NAME
    IsAmigaDosError - determine if an errorcode is a valid AmigaDos errorcode

 SYNOPSIS
    BOOL IsAmigaDosError(LONG)
    amigaError = IsAmigaDosError(ec)

 FUNCTION
    This macro checks, wheather a given error number is an AmigaDOS error
    code or a system dependent (Windoof) error code.
    This macro is usefull to determine, if the occured error is an error
    that could be handled by an application. Every system dependent error
    that is expected by the joinOS.library, is converted to an AmigaDOS
    error code, so you are able to write system independent error-handling
    function.
    If this function returns FALSE, the occured error hasn't been expected
    by the joinOS.library and therefor you could be shure, it's a hard
    error that could be displayed to the user, but not be handled without
    the users choise.

 INPUT
    ec - an error number as returned by Ioerr()

 RESULT
    TRUE -> if the error number belongs to an AmigaDOS error code.
    FALSE -> if the error number belongs to a system (Windoof) specific
    error code.

 SEE ALSO
    <joinOS/dos/AmigaDOS.h>

joinOS.library/IsValidDate                            joinOS.library/IsValidDate

 NAME
    IsValidDate - Check if a DateStamp contains a valid date.

 SYNOPSIS
    BOOL IsValidDate(struct DateStamp *)
    success IsValidDate (ds)

 FUNCTION
    Test whether a given DateStamp structure holds a valid date or not.
    It is only testet if every value of the structure is greater or equal to
    null and that at least one value is greater then null.

 INPUT
    ds - a pointer to the DateStamp structure which contents should be testet

 RESULT
    boolean, TRUE if the structure contains a valid date, FALSE if not.

 SEE ALSO
    Date2Str()

joinOS.library/IsValidMemList                      joinOS.library/IsValidMemList

 NAME
    IsValidMemList - check the returnvalue of AllocEntry()

 SYNOPSIS
    BOOL IsValidMemList (struct MemList *);

    succeed = IsValidMemList (memList);

 FUNCTION
    Because of the different return values - returned by AllocEntry() under
    the different systems that indicates failure, you should use this macro
    to test the result of the function AllocEntry() to write compatible code.

 INPUT
    memList - a pointer to a MemList structure as returned by AllocEntry().

 RESULT
    A boolean value indicating that the MemList structure is a valid MemList
    structure is returned.
    If TRUE is returned, AllocEntry() has succeed, else AllocEntry() failed
    and memList is the requirement that failed (something like MEMF_CHIP or
    MEMF_FAST etc.).

 EXAMPLE
       if (IsValidMemList(memlist = AllocEntry (aMemList)))
       {
          // succeed
       }
       else
       {
          // failure, memlist is the type of memory we failed to allocate
       }

joinOS.library/LockDOSList                            joinOS.library/LockDOSList

 NAME
    LockDOSList - wait for access to the dos list

 SYNOPSIS
    struct DosList *LockDOSList (ULONG)
    initialValue = LockDOSList (AccessFlags)
         D0                         D1

 FUNCTION
    Try to gain access to the list of devices, volumes and assignments.
    If the function succeeds, no real pointer to a DosList node is returned, 
    but just an initial value usable for FindDosEntry(), NextDosEntry().
    If the desired type of entry, with the desired type of access isn't
    available, the function will wait until it gets access. (Be careful
    not to produce deadlocks).
    After you finished parsing the DOS list you have to call UnLockDosList(),
    to free the DOS list again.
    DON'T CALL ANY IO-FUNCTION WHILE YOU HOLD THE LOCK OF THE DOS LIST, OR
    THE PROGRAM COULD END IN A DEADLOCK.

 INPUTS
    AccessFlags - Flags specifying the type of entry that should be locked
                   and the type of lock that should be used:

    Any combination of the type of entry is possible:
       LDF_DEVICES - the list of devices should be locked
       LDF_VOLUMES - the list of volumes should be locked
       LDF_ASSIGNS - the list of assignments should be locked.
       LDF_ALL - shortcut for: LDF_DEVICES | LDF_VOLUMES | LDF_ASSIGNS

    One of the lock specifier must be used:
       LDF_READ    - read (shared) access to the DOS list entries.
       LDF_WRITE   - write (exclusive) access to the DOS list entries.

 RESULT
    An initial value for use in NextDosEntry() or FindDosEntry() is returned.

 NOTE
    Since there is no way to lock the DosList under AmigaOS 1.3 (v34), the
    functions LockDOSList() and UnLockDOSList() are implemented as
    Forbid()/Permit() pair for these systems, so it is incredibly important
    to unlock the DosList as fast as possible, because the multitasking is
    disabled while the list is locked.

 SEE ALSO
    UnLockDOSList(), FindDOSEntry(), NextDOSEntry()

joinOS.library/Long2Str                                  joinOS.library/Long2Str

 NAME
    Long2Str - convert a decimal string to a long number

 SYNOPSIS
    LONG Long2Str (LONG, char*)
    bytesCopied = Long2Str (Value, Buffer)
        D0                     D1     D2

 FUNCTION
    This function converts a given long integer into a human-readable form.
    The LONG is stored as decimal string in the specified buffer. Be shure
    that there is enough space in the buffer to hold the number, otherwise
    you risk to meet the Guru.

 INPUTS
    value  - a long integer value, to be converted into a string.
    buffer - the buffer where the resulting string should be stored.

 RESULT
    If everything wents fine, the number of bytes copied to the buffer
    (without the terminating NUL-byte) is returned.

 SEE ALSO
    Str2Long(), Date2Str()

joinOS.library/MakeUniqueName                      joinOS.library/MakeUniqueName

 NAME
    MakeUniqueName - create an unique name

 SYNOPSIS
    void MakeUniqueName (UBYTE *, ULONG)
    MakeUniqueName (Buffer, Count)
                      A0     D0

 FUNCTION
    This function can be used to create unique names. It copies a (unique)
    name, created using the (unique) count-value into a specified buffer.

    This function copies in a loop an ASCII-character generated from Count
    modulo 64 into the specified buffer, then it divides Count by 64 and does
    the next character until Count is zero.

    A terminating NUL is added to the string.

 INPUTS
    Buffer - a pointer to the destination buffer for the unique name.
             Take care that the buffer is large enough, at a maximum 7
             characters are added to the buffer (incl. the terminating NUL).
    Count - the value used to generate the unique name. If you increase this
             number after every call to this function, it can generate more
             than 4 billion unique names.

joinOS.library/MapTagList                              joinOS.library/MapTagList

 NAME
    MapTagList - convert ti_Tag values in a list via map pairing.

 SYNOPSIS
    void MapTagList (struct TagItem *, struct TagItem *, ULONG)
    MapTagList (tagList, mapList, mapType)
                  A0        A1       D0

 FUNCTION
    Apply a "mapping list" mapList to tagList.

    If the ti_Tag field of an item in tagList appears as ti_Tag in some
    item in mapList, overwrite ti_Tag with the corresponding ti_Data
    from the map list.

    The mapType parameter specifies how the mapping operation is to
    proceed, with the following available types:

       MAP_REMOVE_NOT_FOUND
       If a tag in tagList does not appear in the mapList, remove
       it from tagList.

       MAP_KEEP_NOT_FOUND
       To have items which do not appear in the mapList survive the
       mapping process as-is.

    MapTags() is central to BOOPSI gadget interconnections where you want
    to convert the tag values from one space (the sender) to another (the
    receiver).

    The procedure will change the values of the input tag list
    tagList (but not mapList).

    You can "filter" a list by passing MAP_REMOVE_NOT_FOUND as mapType,
    and having the data items in mapList equal the corresponding tags.

    You can perform the inverse filter ("everything but") by passing
    a mapType of MAP_KEEP_NOT_FOUND, and creating a map item for every tag
    you want to filter out, pairing it with a mapped data value of
    TAG_IGNORE.

    For safety and "order independence" of tag item arrays, if you
    attempt to map some tag to the value TAG_DONE, the value TAG_IGNORE
    will be substituted instead.

 INPUTS
    tagList  - input list of tag items which is to be mapped to tag values
               as specified in mapList.
    mapList - a "mapping list" tag list which pairs tag values expected to
               appear in tagList with new values to be substituted in the
               ti_Tag fields of tagList (may be NULL)
    mapType - one of the available mapping types as defined in
               <joinOS/misc/tagitem.h>

 EXAMPLE
    /* Consider this source list: */
    struct TagItem list[] =
    {
       {MY_SIZE,   71},
       {MY_WEIGHT, 200},
       {TAG_DONE,  }
    };

    /* And the mapping list: */
    struct TagItem map[] =
    {
       {MY_SIZE,   HIS_TALL},
       {TAG_DONE,  }
     };

    /* Then after MapTagList(list,map,MAP_REMOVE_NOT_FOUND),
     * 'list' will become:
     */
       {HIS_TALL,71},
       {TAG_IGNORE,},
       {TAG_DONE,}

    /* Or after MapTagList (list,map,MAP_KEEP_NOT_FOUND),
     * 'list' will become:
     */
       {HIS_TALL,  71},
       {MY_WEIGHT, 200},
       {TAG_DONE,  }

 SEE ALSO
    <joinOS/misc/tagitem.h>, ChangeTagList(), FilterChangeTags()

joinOS.library/MoveMem                                    joinOS.library/MoveMem

 NAME
    MoveMem - copy a block of memory

 SYNOPSIS
    void MoveMem (APTR, APTR, ULONG)
    MoveMem (source, dest, length)

 FUNCTION
    MoveMem is a general purpose, fast memory copy function. It can deal with
    arbitrary length, with its pointers on arbitrary alignments.

    The function can deal with arbitrary overlapping memory blocks.

    The internal implementation of this function will change from system to
    system, and may be implemented via hardware DMA.

 INPUTS
    source   - a pointer to the source data region.
    dest     - a pointer to the destination data region.
    length   - the size (in bytes) of the memory area. Zero copies zero bytes.

joinOS.library/Muls64                                      joinOS.library/Muls64

 NAME
    Muls64 - a multiplication of two signed 32 bit values

 SYNOPSIS
    void Muls64 (LONG, LONG, DOUBLELONG *)
    Muls64 (arg1, arg2,result)
             D0    D1    A0

 FUNCTION
    This function performs a multiplication of two signed 32 bit integers.
    The result of this function is a signed 64 bit integer.

 INPUTS
    arg1 - the first multiplicator, a  signed 32 bit integer
    arg2 - the second multiplicator, a signed 32 bit integer
    result - a pointer to a signed 64 bit integer, where the result of this
             operation should be stored.

 SEE ALSO
    Adds64(), Divu64(), Divs64(), Mulu64(), Neg64()

joinOS.library/Mulu64                                      joinOS.library/Mulu64

 NAME
    Mulu64 - a multiplication of two unsigned 32 bit values

 SYNOPSIS
    void Mulu64 (ULONG, ULONG, DOUBLELONG *)
    Mulu64 (arg1, arg2,result)
             D0    D1    A0

 FUNCTION
    This function performs a multiplication of two unsigned 32 bit integers.
    The result of this function is a signed 64 bit integer.

 INPUTS
    arg1 - the first multiplicator, an unsigned 32 bit integer
    arg2 - the second multiplicator, an unsigned 32 bit integer
    result - a pointer to an unsigned 64 bit integer, where the result of
             this operation should be stored.

 NOTE
    Because the result is stored as signed 64 bit integer, an overflow can
    occure, if both 32 bit integers are very large. In this case the result
    will bve a negative value. If this value is interpreted as unsigned
    value it contains the exact result.

 SEE ALSO
    Adds64(), Divu64(), Divs64(), Muls64(), Neg64()

joinOS.library/Neg64                                        joinOS.library/Neg64

 NAME
    Neg64 - negate a 64 bit value

 SYNOPSIS
    void Neg64 (DOUBLELONG *)
    Neg64 (arg)
           A0

 FUNCTION
    This function negates a 64 bit signed integer.

 INPUT
    arg - a pointer to the 64 bit signed integer, the result of this
          function is stored in the integer (i.e. it is overwritten).

 SEE ALSO
    Adds64(), Divu64(), Divs64(), Mulu64(), Muls64()

joinOS.library/NextDOSEntry                          joinOS.library/NextDOSEntry

 NAME
    NextDOSEntry  - get next entry from the dos list

 SYNOPSIS
    struct DosList *NextDOSEntry(struct DosList *, ULONG)
    nextEntry = NextDOSEntry(Previous, AccessFlags)
       D0                      D1          D2

 FUNCTION
    Get next entry in the list of devices, volumes and assignments.
    NextDosEntry() traverses the DOS list, which must have been locked previousl
y.
    The control flags specified must be a subset of the access flags specified
    during LockDosList() or AttemptLockDosList(); they determine what types of
    entries are to be returned.

    Because these functions are not available under AmigaOS versions below
    v36 (2.0), you have to embed the parsing of the doslist by a Forbid()/
    Permit() pair. Copy the information you need from the doslist and free
    it as fast as possible, the buffer you use for copying should be
    allocated outside of the Forbid()/Permit() pair, because the allocation
    may break the forbidden state.

 INPUTS
    Previous - the last processed Dos list entry as returned by a previous
             call to FindDosEntry() or NextDosEntry() or the value returned
             by a successful AttemptLockDosEntry() or LockDosEntry().
    AccessFlags - the type of entry that is searched.

 RESULT
    If the function succeeds, a pointer to the next entry matching the control
    flags is returned.
    If the function fails, NULL is returned.

 SEE ALSO
    LockDOSList(), UnLockDOSList(), FindDOSEntry()

joinOS.library/NextTag                                    joinOS.library/NextTag

 NAME
    NextTag - iterate through a tag list

 SYNOPSIS
    struct TagItem *NextTag (struct TagItem **)
    tag = NextTag (tagItemPtr)
     D0                    A0

 FUNCTION
    Iterates through a tag list, skipping and chaining as dictated by
    system tags. TAG_SKIP will cause it to skip the entry and a number
    of following tags as specified in ti_Data. TAG_IGNORE ignores that
    single entry, and TAG_MORE has a pointer to another array of tags (and
    terminates the current array!). TAG_DONE also terminates the current
    array. Each call returns either the next tagitem you should examine,
    or NULL when the end of the list has been reached.

 INPUTS
    tagItemPtr - doubly-indirect reference to a TagItem structure.
                  The pointer will be changed to keep track of the
                  iteration.

 RESULTS
    nextTag - each TagItem in the array or chain of arrays that should be
               processed according to system tag values defined in
               <joinOS/misc/tagitem.h>) is returned in turn with successive
               calls.

 EXAMPLE
    Iterate(struct TagItem *tags);
    {
       struct TagItem *tstate;
       struct TagItem *tag;

       tstate = tags;
       while (tag = NextTag(&tstate))
       {
          switch (tag->ti_Tag)
          {
             case TAG1: ...
                break;

             case TAG2: ...
                break;

             ...
          }
       }
    }

 WARNING
    Do NOT use the value of *tagItemPtr, but rather use the pointer returned
    by NextTag().

 SEE ALSO
    <joinOS/misc/tagitem.h>, GetTagItem(), PackBooleanTags(), FindTag()

joinOS.library/PackBooleanTags                    joinOS.library/PackBooleanTags

 NAME
    PackBooleanTags - builds a "flag" word from a tag list

 SYNOPSIS
    ULONG PackBooleanTags (ULONG, struct TagItem *, struct TagItem *)
    flags = PackBooleanTags (initialFlags, tagList, boolMap)
      D0                         D0          A0       A1

 FUNCTION
    Picks out the boolean tag items in a tag list and converts
    them into bit-flag representations according to a correspondence
    defined by the tag list 'boolMap'.

    A boolean tag item is one where only the logical value of
    the ti_Data is relevant. If this field is 0, the value is
    FALSE, otherwise TRUE.

 INPUTS
    initialFlags - a starting set of bit-flags which will be changed
                    by the processing of TRUE and FALSE boolean tags
                    in tagList.
    tagList  - a TagItem list which may contain several tag items defined to
               be boolean by their presence in boolMap. The logical value of
               ti_Data determines whether a tag item causes the bit-flag
               value related by boolMap to be set or cleared in the returned
               flag longword.
    boolMap  - a tag list defining the boolean tags to be recognized, and
               the bit (or bits) in the returned longword that are to be set
               or cleared when a boolean Tag is found to be TRUE or FALSE in
               tagList.

 RESULTS
    flags - the accumulated longword of bit-flags, starting with
             initialFlags and modified by each boolean tag item
             encountered.

 EXAMPLE
    /* define some nice user tag values ... */
    enum mytags { tag1 = TAG_USER+1, tag2, tag3, tag4, tag5 };

    /* this TagItem list defines the correspondence between boolean tags
     * and bit-flag values.
     */
    struct TagItem boolMap[] =
    {
       {tag1,     0x0001},
       {tag2,     0x0002},
       {tag3,     0x0004},
       {tag4,     0x0008},
       {TAG_DONE, }
    };

    /* You are probably passed these by some client, and you want
     * to "collapse" the boolean content into a single longword.
     */
    struct TagItem boolExample[] =
    {
       {tag1,     TRUE},
       {tag2,     FALSE},
       {tag5,     Irrelevant},
       {tag3,     TRUE},
       {TAG_DONE, }
    };

    /* Perhaps 'boolFlags' already has a current value of 0x800002.
     */
    boolFlags = PackBoolTags (boolFlags, boolExample, boolMap);

    /* The resulting new value of 'boolFlags' will be 0x80005. */

 WARNING
    In a case where there is duplication of a tag in tagList, the
    last of the identical tags will hold sway.

 SEE ALSO
    <joinOS/misc/tagitem.h>, GetTagItem(), FindTag(), NextTag()

joinOS.library/PackStructTags                      joinOS.library/PackStructTags

 NAME
    PackStructTags - pack a structure with values from a taglist

 SYNOPSIS
    ULONG PackStructTags (APTR, ULONG *, struct TagItem *)
    num = PackStructTags (pack, packTable, tagList)
    D0                     A0       A1        A2

 FUNCTION
    For each table entry, a FindTag() will be done and if the
    matching tag is found in the taglist, the data field will be
    packed into the given structure based on the packtable
    definition.

 INPUTS
    pack - a pointer to the data area to fill in.
    packTable - a pointer to the packing information table.
                 See <joinOS/misc/tagItems.h> for definition and macros.
    tagList - a pointer to the taglist to pack into the structure

 RESULTS
    num - the number of tag items packed

 SEE ALSO
    <joinOS/misc/tagItems.h>, FindTag(), UnpackStructTags()

joinOS.library/ParseArgs                                joinOS.library/ParseArgs

 NAME
    ParseArgs - parse the command line input

 SYNOPSIS
    struct RDArgs *ParseArgs (STRPTR, LONG*, struct RDArgs*)
    result = ParseArgs (template, array, rdArgs)
          D0                           D1

 FUNCTION
    ReadArgs provides a simple, yet powerful and consistent means of
    analyzing commandline input for shell processes; it can also be used to
    parse other types of data (e.g. configuration files). For this purpose
    it uses a so-called "template" that describes the number and types of
    parameters requested.
    This function processes the whole input and parses all arguments, so the
    input could be discarded after this function returns.
    In opposite to the AmigaOS function ReadArgs(), this function works
    also under AmigaOS 1.3 and uses a lightly different template-string,
    You could specifiy the additional parameters date (/D) and time (/H).

    After you're done processing the arguments, you have to free the allocated
    buffers and structures using FreeArguments().

 INPUT
    template -  a pointer to the template string, used to process the input:
       A template is a list of keywords followed optionaly by an alias and
       modifiers, separated with commas.
       template = {keyword[=alias]{/modifier}[,]}keyword[=alias]{/modifier}
       Every entry in the template defines a parameter that could be entered,
       the arguments must not be entered in the order specified by the
       template, they could be entered with or without a leading keyword
       (except for parameters specified with the /K modifier, see below)
       If a keyword is provided explicitly when a command is entered, it can
       be separated from the argument by an equal sign (e.g. "TO=dest") or
       with any number of spaces (e.g. "TO dest").
       The type of a parameter is - if not different defined - a string.

       Valid modifiers are:
       /S - Switch. This is considered a boolean variable, and will be set, it
             the optional name appears in the command-line. The entry is the
             boolean (0 for not set, non-zero for set)

       /T - Toggle. This is similar to a switch, but it must be specified, if
             the boolean value it TRUE or FALSE, by passing "off", "on", "no",
             or "yes" as argument, where "on" and "yes" are specifying TRUE.
             If the toggle is not specified, the according entry in the array
             will not be changed.

       /N - Number. This parameter is considered a decimal number, and will
             be converted by ReadArgs. If an invalid number is specified an
             error will be returned. This could produce unintelligible
             results, if you try to pass a string consisting of decimal
             digits to a parameter without specifing the keyword.
             The according entry in the array will be a pointer (!) to the
             longword number (this is how you know if a number was specified)

       /K - Keyword. This means that the option will not be filled unless the
             keyword appears. For example if the template is "Name/K", then
             unless "Name=<string>" or "Name <string>" appears in the command
             line, Name will not be filled.

       /A - Required. This argument must be given a value during command line
             processing, or an error is returned.

       /F - Rest of line. If this is specified, the entire rest of the line
             is taken without further processing as the parameter of this
             option. You should define a "final" parameter in the template
             string in combination with the "keyword" /K option, or you could
             have counterintuitive results, because all unfilled parameters
             will get a argument and only the rest will be passed to this one

       /M - Multiple. Any number of arguments can be supplied for this
             parameter, returning them as an array of string. In opposite to
             the AmigaDos argument parsing function, this function is able to
             parse multiple numerical arguments (/M/N) which will result in
             an array of long's. Only a single multiple parameter is allowed
             for a template, and you should avoid using multiple and "final"
             parameters in the same template, since the final parameter will
             not get any argument, if it's keyword is not specified.
             Any argument not considered to be part of another option will be
             added to this parameter (except for numerical multiple parameter
             which will only get numerical arguments).
             There is an interaction between /M parameters and /A parameters.
             If there are unfilled /A parameters after parsing, it will grap
             arguments from the end of the /M parameter list to fill the /A's
             this will only work, if the /A's have the same type as the /M.

       The next argument types are additional types, only accessable using
       ParseArgs(), FreeArguments(), ParseItem(), and FindArgument() instead
       of ReadArgs(), FreeArgs(), ReadItem, and FindArg():

       /D - Date. This parameter exspects a date-string. The result will be
          a pointer to a long with the number of days since 01.01.1978 (The
          value of the long could be placed in a DateStamp structures ds_Days
          field). If no date string is found, the entry in the array is not
          changed, if a found date string is not valid (see DateStamp() for
          details about valid dates),it would be passed to a string argument!
          By default a date-string must be entered in the DOS format
          "dd-mmm-yy" (e.g. "12-May-01"). The format of the date string could
          be changed by setting a flag in the RDA_Flags field of the RDArgs
          structure passed to ParseArgs():
             RDAF_DATE_INT - international format "yy-mm-dd" (e.g."01-05-12")
             RDAF_DATE_USA - US-American format "mm-dd-yy" (e.g. "05-12-01")
             RDAF_DATE_CDN - Canadian format "dd-mm-yy" (e.g. "12-05-01")
             RDAF_DATE_DEF - default format of current locale used (currently
                         not supported, defaults to DOS format).
          As a result of this, a date string has to be entered always in DOS
          format if no RDArgs structure is passed to ParseArgs().

          You could also enter "Yesterday", "Today", or "Tomorrow" instead of
          a date, the number of days will be calculated according to the
          current system date.
          If you enter the name of a weekday (e.g. "Monday"), the number of
          days will be calculated to the last of that weekdays (last monday)
          except if you set the flag RDAF_FUTURE, which will result the
          number of days to next weekday of the specified name (next monday).

       /H - Time. This parameter allows to enter a time in the format "hh:mm"
          or "hh:mm:ss". If a valid time string is found, the result will be
          a long pointer to the number of seconds passed since midnight.
          If the entered time string is not valid (e.g. "25:34", "12:67", or
          "13:"), the argument is passed to an empty string parameter!


    rdArgs - a pointer to a user-supplied RDArgs structure, or NULL. IF it is
       NULL, the structure is allocated inside of this function. If you
       allocate it in your user-application (using
       AllocDOSObject(DOS_RDARGS, NULL) ) you could control the operation of
       ParseArgs(). See "rdArgs.h" for information how to initialize the
       structure.
          RDAF_NOPROMPT - suppresses the output of the template string, if
             the first character found is the unquoted question mark.
             As a consequence, extended help is disabled, too. This may be
             useful for noninteractive input streams or in an unquoted
             question mark may occur as a valid input item.
             If RDA_Source.CS_Buffer is NULL, this flag will cause the
             function to fail immediately if any required argument is defined
             by the template.
          RDAF_STDIN - if an argumentstring is to be requested from the user
             (af_Input == NULL, or first character found is the unquoted
             question mark and AFF_NOPROMPT is not set) this flag will cause
             the function to ask the user for that arguments via the stdin,
             independent of the defined inputstream in <af_Input>.
             This flag is currently ignored, the arguments are always
             requested from stdin, if needed and AFF_NOPROMPT is not set.
          RDAF_DATE_??? - if a date-argument is defined in the template, these
             flags define how the date has to be entered, they are mutualy
             exclusive:
             (default) - the date has to be in the format "dd-Mmm-yy" or
                      "dd-mm-yy".
             INT - the date has to be in the format "yy-mm-dd"
             USA - the date has to be in the format "mm-dd-yy"
             CDN - the date has to be in the format "dd-mm-yy"
             DEF - the date has to be in the default format of the current
                      locale being used.
                   This flag is currently not supported and defaults to DOS.
          RDAF_WEEKDAY - if this flag is specified, you could also enter a day
             of the week ("Monday" - "Sunday", "Yesterday", "Today", or
             "Tomorrow") to specify a date. Days of a week refers to days in
             the past (e.g. "Monday" == last monday).
       The other fields of the structure must be initialized with zeros.

 RESULT
    A pointer to the RDArgs structure with the parsed arguments is returned,
    or NULL in the event of an error. See IoErr() for the according AmigaDos
    errorcode in that case.
    If the function succeeds, the parsed arguments are stored in the array
    that was passed as second argument to this function.
    If the function fails, you need not to call FreeArguments() (but it is
    save to do it anyway).

 NOTE
    After this function succeeds, you must not alter the RDArgs structure
    until you finally called FreeArguments().

    You should always use the ParseArgs()-function call (or alias), so you
    could be shure that this implementation is called, so the application
    will have the same behaviour on every machine.

 BUGS
    A leading equal sign in the argument string is silently skipped.

    The AmigaDOS-manual documents that a /M parameter will get at least one
    argument or the function will fail, the Amiga-RKM documents that a /M
    could get zero to many arguments. This implementation accepts zero
    entries for a /M parameter, so you should define it with the /A modifier
    to be shure that it always gets at least one argument.

    It might not work to parse the initial arguments passed to a new process
    on every system, so you should always pass the argument-string you got
    at application-start to the CSource structure part of the RDArgs struct
    to parse this command line. The startupcode "Startup.c" part of this
    "packet" will pass the commandline to the arguments of the Main()
    function, which is always the entry-function of applications written
    using this library and the according startup-module.

    If MAX_MULTIARGS arguments are passed to a multiple argument parameter,
    the array of that parameter is NOT terminated by a NULL value.

 SEE ALSO
    <joinOS/dos/rdArgs.h>, FreeArguments(), ParseItem(), FindArgument()

joinOS.library/ParseItem                                joinOS.library/ParseItem

 NAME
    ParseItem - read one item from a specified input source

 SYNOPSIS
    LONG ParseItem (UBYTE*, ULONG, struct CSource *)
    result = ParseItem (buffer, bufSize, source)
      D0                 D1      D2       D3

 FUNCTION
    ParseItem() reads one item from a specified input source, usually the
    buffered current input stream (if source is NULL), which - upon CLI
    start-up - contains the command-line arguments. If the data are to be
    read from a different input stream, then a non-NULL CSource pointer
    must be passed. See "rdArgs.h" for details how to initialize a CSource
    structure.
    The following values can be returned by ParseItem():
       ITEM_EQUAL - the first character found in the source is the equal
             sign.
       ITEM_ERROR - an error occured, usually buffer overflow.
       ITEM_NOTHING - line feed, carriage return or EOF found.
       ITEM_UNQUOTED - an unquoted item found
       ITEM_QUOTED -  a quoted item found
    A line feed or an end of file are considered terminators for all types
    of items. In addition, unquoted items are terminated by a space, a tab,
    an equals sign, or a semicolon. Items starting with a quotation mark are
    terminated by a second one; the quotation marks themselves are not copied
    to the destination buffer. Quoted items may contain the following escape
    sequences:
       *" - for "
       ** - for *
       *E or *e - for the escape character (ASCII $1B = ESC)
       *N or *n - for the line-feed ('\n', ASCII $0A = LF)
       *R or *r - for the carriage return ('\r', ASCII $0C = CR)

 INPUTS
    buffer - a pointer to the buffer, where the current item should be copied
             to.
    bufSize - the byte-size of the buffer ( > 0 )
    source - a pointer to a CSource structure, defining the input-source or
             NULL, if STDIN should be used as source.

 RESULT
    The function returns an identifier, that describes the found item.

 BUGS
    The token delimiter encountered directly after an unquoted item is
    currently not pushed back into the input stream, so an equal sign
    following an unquoted item is silently skipped.

    The function may fail with a secondary result (IoErr()) of
    ERROR_BUFFER_OVERFLOW by quoted items, even if they fit into the buffer,
    because they are copied first time as is, before the quotes are removed
    and escape sequences are transformed (which will shorten the string).

    The function currently reads all characters from an input-source under
    AmigaOS v35 and below, if the source is an interactive stream (CSource
    is equal NULL, and STDIN is the console), so all items following the
    current one are lost!

    Workaround:
       If you whish to read from an interactive file, read the bytes to a
       local buffer, and pass this buffer via CSource to this function.
    The following pseudo-code shows how to manage this:

    BOOL SaveProcessAllItems (struct CSource *source)
    {
       UBYTE *buffer = NULL;
       UBYTE itemBuf[ARG_BUFFER_SIZE];
       struct CSource *cs = NULL;
       LONG itemType;
       BOOL result = FALSE;
       LONG bytesRead;
       BPTR input;

       if (!source && (((struct Library *)DOSBase)->lib_Version < 36))
       {
          if (input = Input())
          {
             if (((struct FileHandle *)BADDR(input))->fh_Port)
             {
                // STDIN is interactive...
                if (buffer = AllocMem (ARG_BUFFER_SIZE, MEMF_PUBLIC|MEMF_CLEAR))
                {
                   if ((bytesRead = Read (fh, buffer, ARG_BUFFER_SIZE)) != -1)
                   {
                      if (bytesRead < ARG_BUFFER_SIZE)
                      {
                         if (cs = AllocMem (sizeof(struct CSource),MEMF_PUBLIC))
                         {
                            cs->CS_Buffer = buffer;
                            cs->CS_Length = bytesRead;
                            cs->CS_CurChr = 0;
                         }
                      }
                      else SetIOErr (ERROR_LINE_TOO_LONG);
                   }
                }
             }
          }
       }
       else cs = source;

       if (cs || (((struct Library *)DOSBase)->lib_Version >= 36))
       {
          result = TRUE;
          do
          {
             result = ParseItem (itemBuf, ARG_BUFFER_SIZE, cs);
             // now process the item, however you want
             ...
          }
          while ((result != ITEM_NOTHING) && (result != ITEM_ERROR));

          if (result == ITEM_ERROR) result = FALSE;
       }
       if (cs && (cs != source))
          FreeMem (cs, sizeof (struct CSource));
       if (buffer)
          FreeMem (buffer, ARG_BUFFER_SIZE);

       return result;
    }

 SEE ALSO
    <joinOS/dos/rdArgs.h>, ParseArgs(), FreeArguments(), FindArgument()

joinOS.library/PathFromLock                          joinOS.library/PathFromLock

 NAME
    PathFromLock - retrieve the full path to an object a lock references

 SYNOPSIS
    LONG PathFromLock (BPTR, UBYTE *, ULONG)
    success = PathFromLock (fl, buffer, bufSize)
      D0                    D1    D2      D3

 FUNCTION
    This functions builds the full path name of an object descriped by a
    lock. If the buffer is too small, the function will fail.
    If the ZERO lock is passed, this function converts the ZERO lock to
    a hard coded name "SYS:", regardless of the boot volume's actual volume
    name. The function will request unmounted volumes.

 INPUTS
    fl - a BCPL pointer to the FileLock which filepath is requested.
    buffer   - the buffer (MEMF_PUBLIC) where the path should be copied to
    bufSize  - the byte size of the buffer, at least one.

 RESULT
    If the function succeeds, DOSTRUE is returned.
    If the function fails, DOSFALSE is returned, the contents of the buffer.
    is undefined.

joinOS.library/PatternMatch                          joinOS.library/PatternMatch

 NAME
    PatternMatch - check, whether a string could be "produced" with the
                   specified pattern (case-sensitive).

 SYNOPSIS
    BOOL PatternMatch (UBYTE*, const UBYTE*)
    success = PatternMatch (Pattern, TokenString)
       D0                    D1         D2

 FUNCTION
    This function checks whether a string could be "produced" with the
    specified pattern. The pattern must be previously be converted to a
    TokenString using PatternParse().
    This function compares case-sensitive, see PatternMatchNoCase() for
    a not case-sensitive matching function.

 INPUT
    Pattern - the previously parsed pattern from PatternParse(). The token
             string that was produced by that function must be passed here.
    TokenString - the C string that should be matched against the pattern,
             this string could include all ASCII chars except the not
             printable characters in the range of 0x80 upto 0x8F (ANSI)
             which are used as control-characters for the parsed pattern.

 RESULT
    If the function succeeds, TRUE is returned and all values are updated.
    If the function fails, FALSE is returned, IoErr() is set to according
    AmigaDos-errorcode, probably ERROR_TOO_MANY_LEVELS or ERROR_BAD_TEMPLATE.

 NOTE
    The used pattern string is not compatible to the token string produced
    by the AmigaDos ParsePattern() function. So never call this function
    with a pattern string produced by AmigaDos ParsePattern().

    This function might match slightly different strings than the equivalent
    AmigaDos function MatchPattern(), especialy by patterns containing
    nested '#','~',() groups.

 SPECIAL NOTE
    The function requires approximately 2000 bytes of free available stack
    space, low stack situations are NOT checked.

 BUGS
    The amount of stack used, especialy in ERROR_TOO_MANY_LEVELS situations,
    is currently not tested and may exceed 2000 bytes.

    The names of the arguments of this function are irritating, Pattern is
    the token string produced by PatternParse() and TokenString is the string
    to compare with.

 SEE ALSO
    <joinOS/dos/MatchPattern.h>, PatternMatchNoCase(), PatternParse()

joinOS.library/PatternMatchNoCase              joinOS.library/PatternMatchNoCase

 NAME
    PatternMatchNoCase - check, whether a string could be "produced" with the
                         specified pattern (not case-sensitive).

 SYNOPSIS
    BOOL PatternMatchNoCase (UBYTE*, const UBYTE*)
    success = PatternMatchNoCase (Pattern, TokenString)
       D0                           D1        D2

 FUNCTION
    This function checks whether a string could be "produced" with the
    specified pattern. The pattern must be previously be converted to a
    TokenString using ParsePatternNoCase().
    This function compares case-insensitive, see PatternMatch() for a
    case-sensitive matching function.

 INPUT
    Pattern - the previously parsed pattern from PatternParseNoCase().
             The token string that was produced by that function must be
             passed here.
    TokenString - the C string that should be matched against the pattern,
             this string could include all ASCII chars except the not
             printable characters in the range of 0x80 upto 0x8F (ANSI)
             which are used as control-characters for the parsed pattern.

 RESULT
    If the function succeeds, TRUE is returned and all values are updated.
    If the function fails, FALSE is returned, IoErr() is set to according
    AmigaDos-errorcode, probably ERROR_TOO_MANY_LEVELS or ERROR_BAD_TEMPLATE.

 NOTE
    The used pattern string is not compatible to the token string produced
    by the AmigaDos ParsePatternNoCase() function. So never call this
    function with a pattern string produced by AmigaDos ParsePatternNoCase().

    This function might match slightly different strings than the equivalent
    AmigaDos function MatchPatternNoCase(), especialy by patterns containing
    nested '#','~',() groups.

 SPECIAL NOTE
    The function requires approximately 2000 bytes of free available stack
    space, low stack situations are NOT checked.

 BUGS
    The amount of stack used, especialy in ERROR_TOO_MANY_LEVELS situations,
    is currently not tested and may exceed 2000 bytes.

    The names of the arguments of this function are irritating, "Pattern" is
    the token string produced by PatternParse() and "TokenString" is the
    string to compare with.

 SEE ALSO
    <joinOS/dos/MatchPattern.h>, PatternMatch(), PatternParseNoCase()

joinOS.library/PatternParse                          joinOS.library/PatternParse

 NAME
    PatternParse - parse a pattern and produce a according tokenstring

 SYNOPSIS
    LONG PatternParse (const UBYTE *, UBYTE *, ULONG)
    result = PatternParse (rawPattern, tokenBuffer, bufSize)
     D0                     D1           D2          D3

 FUNCTION
    If you wish to use the pattern matching function PatternMatch() -
    for case-sensitiv pattern matching - you have to call this function
    previously, to parse the pattern, so it could be processed by that
    function.
    The produced tokenstring, that must be passed to PatternMatch() later,
    is stored in the user-defined buffer.

 INPUT
    rawPattern - the pattern that should be parsed (C string), see
                "MatchPattern.h" for details, how to build a pattern string.
                This string could include all ASCII chars except the not
                printable characters in the range of 0x80 upto 0x8F (ANSI)
                which are used as control-characters for the parsed pattern.
    tokenBuffer - the buffer where the produced tokenstring should be stored.
                This buffer must be at least strlen(rawPattern)*2+2 bytes in
                size.
    bufSize - the size of the tokenbuffer.

 RESULT
    The function returns a returnvalue, indicating success and the type of
    pattern parsed:
       -1 = buffer overflow or other error
       0  = pattern contains no wildcard (in the case of a filepath, you
             could simply call Lock() or Open() with that path and need not
             to do any pattern matching)
       1  = pattern contains wildcards, tokenbuffer holds the compiled token
             string, that might be passed to PatternMatch().

 SPECIAL NOTE
    The function requires approximately 2000 bytes of free available stack
    space, low stack situations are NOT checked.

 BUGS
    The amount of stack used, especialy in ERROR_TOO_MANY_LEVELS situations,
    is currently not tested and may exceed 2000 bytes.

 SEE ALSO
    <joinOS/dos/MatchPattern.h>, PatternMatch(), PatternParseNoCase()

joinOS.library/PatternParseNoCase              joinOS.library/PatternParseNoCase

 NAME
    PatternParseNoCase - parse a pattern and produce a according tokenstring

 SYNOPSIS
    LONG PatternParseNoCase (const UBYTE *, UBYTE *, ULONG)
    result = PatternParseNoCase (rawPattern, tokenBuffer, bufSize)
     D0                     D1           D2          D3

 FUNCTION
    If you wish to use the pattern matching function PatternMatchNoCase() -
    for case-insensitiv pattern matching - you have to call this function
    previously, to parse the pattern, so it could be processed by that
    function.
    The produced tokenstring, that must be passed to PatternMatchNoCase()
    later, is stored in the user-defined buffer.

 INPUT
    rawPattern - the pattern that should be parsed (C string), see
                "MatchPattern.h" for details, how to build a pattern string.
                This string could include all ASCII chars except the not
                printable characters in the range of 0x80 upto 0x8F (ANSI)
                which are used as control-characters for the parsed pattern.
    tokenBuffer - the buffer where the produced tokenstring should be stored.
                This buffer must be at least strlen(rawPattern)*2+2 bytes in
                size.
    bufSize - the size of the tokenbuffer.

 RESULT
    The function returns a returnvalue, indicating success and the type of
    pattern parsed:
       -1 = buffer overflow or other error
       0  = pattern contains no wildcard (in the case of a filepath, you
             could simply call Lock() or Open() with that path and need not
             to do any pattern matching)
       1  = pattern contains wildcards, tokenbuffer holds the compiled token
             string, that might be passed to PatternMatchNoCase().

 NOTE
    The produced token string is not compatible to the token string produced
    by the AmigaDos ParsePatternNoCase() function. So never call the AmigaDos
    MatchPatternNoCase() function with this token string.

 SPECIAL NOTE
    The function requires approximately 2000 bytes of free available stack
    space, low stack situations are NOT checked.

 BUGS
    The amount of stack used, especialy in ERROR_TOO_MANY_LEVELS situations,
    is currently not tested and may exceed 2000 bytes.

 SEE ALSO
    <joinOS/dos/MatchPattern.h>, PatternMatchNoCase(), PatternParse()

joinOS.library/PrintError                              joinOS.library/PrintError

 NAME
    PrintError - print an error text to stdout.

 SYNOPSIS
    LONG PrintError (LONG, STRPTR)
    known = PrintError (ErrorCode, Text)
     D0                    D1       D2

 FUNCTION
    Print a descriptive text coresponding to a DOS error code to the current
    output. Unless the error code is zero, PrintFault() outputs the error
    message generated by Fault() -- plus a trailing line feed -- to the
    standard output stream as determined by Output(). In addition it will
    set the value returned by subsequent calls to IoErr() to the error value
    passed to this function.

 INPUTS
    ErrorCode - The error code which descriping text should be printed.
    Text      - text to precede the error message.

 RESULT
    For known error codes, this function returns DOSTRUE, otherwise DOSFALSE
    is returned (this includes the errorcode zero).

 SEE ALSO
    ErrorText(), ReportError(), SetIOErr(), <joinOS/dos/AmigaDOS.h>

joinOS.library/RefreshTagListClones          joinOS.library/RefreshTagListClones

 NAME
    RefreshTagListClones - rejuvenate a clone from the original

 SYNOPSIS
    void RefreshTagListClones (struct TagItem *, struct TagItem *)
    RefreshTagListClones (clone, original)
                           A0       A1

 FUNCTION
    If (and only if) the tag list 'clone' was created from 'original' by
    CloneTagList(), and if 'original' has not been changed in any way,
    you can reset the clone list to its original state by using this
    function.

 INPUTS
    clone - return value from CloneTagList(original)
    original - a tag list that hasn't changed since CloneTagList()

 SEE ALSO
    <joinOS/misc/tagitem.h>, CloneTagList(), AllocateTagList(),
    FreeTagList(), ChangeTagList()

joinOS.library/ReplyDosPkt                            joinOS.library/ReplyDosPkt

 NAME
    ReplyDosPkt - reply a packet to the originator

 SYNOPSIS
    void ReplyDosPkt (struct DosPacket*, LONG, LONG)
    ReplyDosPkt (dp, res1, res2)
                 D1   D2    D3

 FUNCTION
    ReplyPkt() returns a packet to the reply port (as stored in dp_Port)
    defined by the originaring process. Before actually sending the reply,
    the dp_Port field is altered to point to the pr_MsgPort of the process
    that is about to return the packet, so it is possible to "ping-pong"
    packets between two processes.
    The other arguments of this function are transfered to dp_Res1 and
    dp_Res2, respectively. If the result fields must not be altered, the
    following technique can be used to preserve their contents:

       ReplyPkt (dp, dp->dp_Res1, dp->dp_Res2)

 INPUTS
    dp - a pointer to the packet to be returned
    res1 - primary result to be put into dp_Res1
    res2 - secondary result to be put into dp_Res2

 NOTE
    If the dp_Port field of the DosPacket is NULL, this functions tries - in
    opposite to the function under AmigaDos - to free the memory the packet
    uses. 
    This special option requires that the packet is a StandardPacket allocated
    using 'AllocDosObject(DOS_STDPKT, NULL)'.
    If the passed packet is not a StandardPacket, this will result in a Guru
    (AN_BadFreeAddr) which is even better than to crash the whole machine,
    which is the case under AmigaDos.

 SEE ALSO
    AbortDosPkt(), DoDosPkt(), SendDosPkt, WaitDosPkt()

joinOS.library/ReportError                            joinOS.library/ReportError

 NAME
    ReportError - Format and display a requester after an AmigaDOS I/O error.

 SYNOPSIS
    LONG ReportError (LONG, ULONG, ULONG, struct MsgPort *)
    retry = ReportError (code, type, arg1, mp)
     D0                   D1    D2    D3   D4

 FUNCTION
    This function "pops-up" a requester according to the specified error code.
    The user is able to chose if the faulty operation should be retried or
    not.
    Only if one of the following error codes is passed to this function a
    requester will be shown up, if any other value is passed, this function
    simply returns DOSTRUE without showing a requester:

       ERROR_DISK_NOT_VALIDATED
       ERROR_DISK_WRITE_PROTECTED
       ERROR_DEVICE_NOT_MOUNTED
       ERROR_DISK_FULL
       ERROR_NOT_A_DOS_DISK
       ERROR_NO_DISK
       ABORT_BUSY
       ABORT_DISK_ERROR

 INPUTS
    code - the AmigaDos error code to be processed (see above for valid values)
    type - the type of the third parameter
    arg1 - additional information, depending on 'type', if 'type' is:
          REPORT_STREAM - 'arg1' is a BPTR to struct FileHandle
          REPORT_TASK   - <not supported>
          REPORT_LOCK   - 'arg1' is a BPTR to struct FileLock
          REPORT_VOLUME - 'arg1' is a pointer to a struct DosList
          REPORT_INSERT - 'arg1' is pointer to a C-string
    mp - a pointer to a handler's messageport, if 'type' == REPORT_LOCK and
          'arg1' is equal NULL.<
          
 RESULT
    The function returns DOSTRUE, if the <code> isn't understood or the
    requester couldn't be displayed or the user selects "Cancel". If the user
    selects "Retry" 0 (DOSFALSE) is returned.

 SEE ALSO
    ErrorText(), PrintError()

joinOS.library/SemaphoreRelease                  joinOS.library/SemaphoreRelease

 NAME
    SemaphoreRelease - release a SignalSemaphore

 SYNOPSIS
    void SemaphoreRelease (struct SignalSemaphore *)
    SemaphoreRelease (sigSem)
                        A0

 FUNCTION
    SemaphoreRelease() is the inverse of ObtainSemaphore(). It makes
    the semaphore lockable to other users. If tasks are waiting for
    the semaphore and this this task is done with the semaphore then
    the next waiting task is signalled.

    Each ObtainSemaphore() call must be balanced by exactly one
    SemaphoreRelease() call.  This is because there is a nesting count
    maintained in the semaphore of the number of times that the current
    task has locked the semaphore. The semaphore is not released to
    other tasks until the number of releases matches the number of
    obtains.

    Needless to say, havoc breaks out if the task releases more times
    than it has obtained.

 INPUT
    signalSemaphore -- an initialized signal semaphore structure

 NOTE
    This call is guaranteed to preserve all registers.
    This call is new for every system, because of a name-conflict betweem
    AmigaOS ReleaseSemaphore() and Windoof ReleaseSemaphore().

    This function is implemented as macro on Amiga systems.

 BUGS
    In the current implementation every task can release a shared locked
    semaphore, not only the one that has obtained it.

joinOS.library/SendDosPkt                              joinOS.library/SendDosPkt

 NAME
    SendDosPkt - send a packet asynchronously

 SYNOPSIS
    void SendDosPkt (struct DosPacket*, struct MsgPort*, struct MsgPort*)
    SendDosPkt (dp, mp, rp)
                D1  D2  D3

 FUNCTION
    SendPkt() sends a packet asynchronously, i.e. it does not wait for the
    reply and may thus safely be called from a task. The packet must have
    been properly initialized.
    If WaitPkt() is to be used to wait for the reply of an asynchronous
    packet, SendPkt()'s reply port argument (rp) must point to the process's
    pr_MsgPort. Calling DoPkt() or any other asynchronous packet function
    while asynchronous packets with a reply port of pr_MsgPort are still
    pending is likely to crash the system with an AN_AsyncPkt Guru.

 INPUTS
    dp - a pointer to the completely initialized DosPacket. This packet
          has to be accompanied by a valid Message structure.
    mp - the message port the packet is to be sent to (usually a handler
          process's message port as retrieved by GetDeviceProc()).
    rp - the message port the packet is to be replied to (dp_Port)

 SEE ALSO
    AbortDosPkt(), DoDosPkt(), ReplyDosPkt, WaitDosPkt()

joinOS.library/SetIOErr                                  joinOS.library/SetIOErr

 NAME
    SetIOErr - Set the secondary result of a process

 SYNOPSIS
    LONG SetIOErr (LONG)
    lastresult = SetIOErr (result)
        D0                   D1

 FUNCTION
    This function sets the secondary result of an process, which might be
    subsequently be retrieved via IoErr().

 INPUT
    result - the secondary result that should be set.

 RESULT
    The secondary result, stored for the process before this function is
    called, is returned.

 SEE ALSO
    ErrorText(), <joinOS/dos/AmigaDOS.h>

joinOS.library/Sqrt32                                      joinOS.library/Sqrt32

 NAME
    Sqrt32 - calculate the squareroot of a 32-bit integer

 SYNOPSIS
    ULONG Sqrt32 (ULONG)
    result = Sqrt32 (value)
      D0              D0

 FUNCTION
    This function calculates the squareroot of an unsigned long integer.
    It operates with integers only, and uses an algorithm that finds
    the value by approximation. First it looks for good startvalues, then
    it loops until the squareroot is found.
    Even if the algorithm doesn't use a numerical way (it uses a kind of
    "try on error"), it is quite fast.

 INPUT
    value - the value, the squareroot is looking for

 RESULT
    The squareroot of the specified value (with a maximum error of 1) is
    returned.

joinOS.library/Str2DOUBLELONG                      joinOS.library/Str2DOUBLELONG

 NAME
    Str2DOUBLELONG - convert a decimal string to a DOUBLELONG

 SYNOPSIS
    LONG Str2DOUBLELONG (STRPTR, DOUBLELONG *)
    bytesRead = Str2DOUBLELONG (string, value)
       D0                        A0       A1

 FUNCTION
    This function converts a string consisting of decimal digits in ASCII
    into a DOUBLELONG value (64bit integer). The string may contain leading
    white spaces (spaces or tabulators) and a sign ('+' or '-'), which must
    precede the digits directly.
    The number of characters read, including possible white space and the
    sign, is returned.

 INPUTS
    string - a pointer to the string that should be parsed.
    value  - a pointer to the DOUBLELONG that should receive the result.

 RESULT
    The function returns the number of bytes read, if the value returned is
    at least one and the last character read (return value minus one yields
    the string offset) is a digit, then the input string did contain a valid
    number. Otherwise the variable pointed to by 'value' contains zero. Upon
    overflow, the value of this variable is undefined.

 SEE ALSO
    DOUBLELONG2Str()

joinOS.library/Str2Date                                  joinOS.library/Str2Date

 NAME
    Str2Date - convert strings to date and time values

 SYNOPSIS
    BOOL Str2Date (struct DateTime*)
    success = Str2Date (DateTime)
       D0                  D1

 FUNCTION
    Converts a human readable ASCII string into an AmigaDOS DateStamp.

 INPUTS
    DateTime - a pointer to an initialized DateTime structure.

    The DateTime structure should be initialized as follows:

    dat_Stamp  - ignored on input.

    dat_Format - a format byte which specifies the format of the
       dat_StrDat. This can be any of the following (note: If value used is
       something other than those below, the default of FORMAT_DOS is used):

       FORMAT_DOS:   AmigaDOS format "dd-mmm-yy" (e.g. "12-May-01") or - in
             opposite to the AmigaDOS function: "dd-mm-yy" (e.g. "12-05-01")

       FORMAT_INT:   International format "yy-mm-dd" (e.g. "01-05-12")

       FORMAT_USA:   American format "mm-dd-yy" (e.g. "05-12-01")

       FORMAT_CDN:   Canadian format "dd-mm-yy" (e.g. "12-05-01")

       FORMAT_DEF:   default format for locale (currently not supported).

    dat_Flags - a flags byte. The only flag which affects this function is:

       DTF_SUBST:  ignored by this function
       DTF_FUTURE:  If set, indicates that strings such as (stored in
          dat_StrDate) "Monday" refer to "next" monday. Otherwise, if clear,
          strings like "Monday" refer to "last" monday.

    dat_StrDay - ignored by this function.

    dat_StrDate -  pointer to valid string representing the date.
       This can be a "DTF_SUBST" style string such as "Today" "Tomorrow"
       "Monday", or it may be a string as specified by the dat_Format byte.
       This will be converted to the ds_Days portion of the DateStamp.
       If this pointer is NULL, DateStamp->ds_Days will not be affected.

    dat_StrTime -  Pointer to a buffer which contains the time in the ASCII
       format hh:mm:ss. This will be converted to the ds_Minutes and ds_Ticks
       portions of the DateStamp. If this pointer is NULL, ds_Minutes and
       ds_Ticks will be unchanged.

 RESULT
    success  - a zero return indicates that a conversion could not be
    performed. A non-zero return indicates that the DateTime.dat_Stamp
    variable contains the converted values.

 BUGS
    This function accepts dates in the range from 1-Jan-1978 until 31-Dec-2077
    which might not work under AmigaOS, because the system only accepts date
    stamps between 1-Jan-1978 and 31-Dec-2045.

 SEE ALSO
    Date2Str(), Str2Long()

joinOS.library/Str2Long                                  joinOS.library/Str2Long

 NAME
    Str2Long - convert a string representing a decimal value to a long

 SYNOPSIS
    LONG Str2Long (STRPTR, LONG*)
    LONG Str2Long (String, Value)
     D0               D1     D2

 FUNCTION
    This function converts a string consisting of decimal digits in ASCII
    into a signed long integer value. The string may contain leading white
    spaces (spaces or tabulators) and a negative sign, which must precede
    the digits directly.
    The number of characters read, including possible white space and the
    sign, is returned.

 INPUTS
    String - a pointer to the string that should be parsed.
    Value  - a pointer to the unsigned long that should receive the result.

 RESULT
    The function returns the number of bytes read, if the value returned is
    at least one and the last character read (return value minus one yields
    the string offset) is a digit, then the input string did contain a valid
    number. Otherwise the variable pointed to by <Value> contains zero. Upon
    overflow, the value of this variable is undefined.

 SEE ALSO
    Long2Str(), Str2Date()

joinOS.library/TagIsInArray                          joinOS.library/TagIsInArray

 NAME
    TagIsInArray - check if a tag value appears in an array of tag values.

 SYNOPSIS
    BOOL TagIsInArray (Tag, Tag *)
    result = TagIsInArray (tagValue, tagArray)
      D0                    D0        A0

 FUNCTION
    Performs a quick scan to see if a tag value appears in an array
    terminated with TAG_DONE. Returns TRUE if the value is found.

    The 'tagArray' must be terminated by TAG_DONE. Note that this is an
    array of tag values, NOT an array of TagItems.

 INPUTS
    tagValue - tag value to search array for in array.
    tagArray - a simple array of tag values terminated by TAG_DONE.

 RESULTS
    result - TRUE if tagValue was found in tagArray.

 SEE ALSO
    <joinOS/misc/tagitem.h>, FilterTagList()

joinOS.library/TempFileName                          joinOS.library/TempFileName

 NAME
    TempFileName - create a filename for a temporary file

 SYNOPSIS
    STRPTR TempFileName (STRPTR, STRPTR, STRPTR)
    tempfile = TempFileName (tempdir, prefix, extension)
      A0                       A0       A1        A2

 FUNCTION
    This function tries to create a new unique name for a temporary file.
    The created filename is tested, i.e. the function takes care that no
    file-system object with that name is currently existing.

    The filename will be created according to the following pattern:

       [<tempdir>]"~"[<prefix>]<unique string>[.(<extension>|"tmp")]

    The "unique string" will be created from the current system-time and
    always be 6 characters wide (AmigaOS) respectively 4 characters wide
    (Windoof, if no extension is specified).

 INPUTS
    tempdir - a pointer to a NUL-terminated C-string with the path to the
             directory, where the temporary file should be created. If
             NULL is passed for this argument, the systems directory for
             temporary files will be used.
    prefix - a pointer to a NUL-terminated C-string with a prefix used for
             the filename to be created, at most the first two characters
             of this string will be copied between the leading tilde 
             character ('~') and the unique string created from system-time.
             If NULL is passed for this argument, no prefix is used.
    extension - a pointer to a NUL-terminated C-string that will be used as
             extension of the filename, the filename will be followed by a
             dot ('.') and this extension (i.e. the extension-string passed
             with this argument should not be preceded by a dot). If NULL is
             passed for this argument, the filename will get the extension
             "tmp". If a pointer to an empty string ("") is passed, the
             fillname will not have any extension.

 RESULT
    A pointer to a new allocated buffer containing the created filename will
    be returned. You have to free this string after usage using the function
    FreeVector().
    If anything wents wrong, NULL is returned, see IoErr() for the cause of
    the failure.

 NOTES
    Like every function accessing AmigaDOS the calling task needs to be an
    AmigaDOS process. This function may lead the calling process to wait for
    the reply of a packet send to a handler, so don't use it in time-critical
    functions.

    Even if the created filename is testet, there is no guarantee that the
    filename is not in use, when you try to create such a file, because the
    AmigaOS is a multitasking OS, a file-system object with the returned
    name might be created at any time by a concurrent task.

    The system-time is used to create an unique name, it has an accuracy of
    one fiftieth of a second, so if you call this function very often in
    short intervals, it will slow down, because the created filenames will
    often match an already existing file-system object.

    The unique name part of the created filename will only be created from
    the time elapsed since midnight, if a temporary file "lifes" longer than
    24 hours, the name may collide with a new tenporary filename (this
    collision will be detected by this function, but will take some time).

    This function is able to create over 16 million different filenames
    in the same directory with the same prefix and extension, but the more
    files are existing, the more the function will slow down because of
    collisions with existing files, so the number of usable filenames is
    quite less than this value. Use different prefixes and extensions for
    your temporary files, and delete the temporary files after usage, to
    avoid name-collisions (and safe some memory respectively disk-space).

 EXAMPLE
       STRPTR tempFile;
       BPTR fh;

       if (tempFile = TempFileName (NULL, "A", ".test"))
       {
          // the created filename would be something like "T:~A09C4FE.test"

          if (fh = Open (tempFile, MODE_NEWFILE))
          {
             // work with the temporary file...
             ...
             // Close the temporary file and delete it...

             Close (fh);
             Delete (tempFile);
          }
          // Free the temporary filename...

          FreeVector (tempFile);
       }

joinOS.library/TextBox                                    joinOS.library/TextBox

 NAME
    TextBox - vararg interface stub for TextBoxA()

 SYNOPSIS
    LONG TextBox (APTR, const char *, const char *, UWORD, ULONG, ...)
    result = TextBoxA (window, caption, textFormat, type, arg1)

 FUNCTION
    This is a vararg interface stub for the TextBoxA() function of the
    joinOS.library.

 INPUTS
    window - a pointer to the Window structure of a window that is located
             on the screen, the requester should appear.
             If this argument is NULL, and the calling task is an AmigaDOS-
             process, the field 'pr_WindowPtr' is taken into account. If this
             field is NULL, or -1, or the calling task is just an Exec Task,
             the requester will open on the default public screen.
    caption - The text that should be displayed as title of the requester.
    textFormat - the printf-alike formating text for the messages bodytext.
    type  - The requester type and button-types used for this requester,
             see <joinOS/misc/TextBox.h> for details.
    arg1  - the first of the variable number of arguments, that are used to
             build the bodytext of the requester, according to the printf-
             alike formating string passed in 'textFormat'.

 RESULT
    The function returns the number of the gadget the user pressed, or
    -1 if the requester couldn't be displayed or is killed by a system event.
    The gadgets are numbered: 1,2,...,n,0 from left to right.

joinOS.library/TextBoxA                                  joinOS.library/TextBoxA

 NAME
    TextBoxA - create a modal dialog displaying a descriptive text

 SYNOPSIS
    LONG TextBoxA (APTR, const char *, const char *, UWORD, ULONG *)
    result = TextBoxA (window, caption, textFormat, type, args)
      D0                 A0       A1        A2      D0:16  A3

 FUNCTION
    Display a message to the user, use the system dependent ways to display
    the message. The last argument is used for varargs arguments to be used
    to specify the message.

 INPUTS
    window - a pointer to the Window structure of a window that is located
             on the screen, the requester should appear.
             If this argument is NULL, and the calling task is an AmigaDOS-
             process, the field 'pr_WindowPtr' is taken into account. If this
             field is NULL, or -1, or the calling task is just an Exec Task,
             the requester will open on the default public screen.
    caption - The text that should be displayed as title of the requester.
    textFormat - the printf-alike formating text for the messages bodytext.
    type  - The requester type and button-types used for this requester,
             see <joinOS/misc/TextBox.h> for details.
    args  - a pointer to the first of the variable number of arguments,
             that are used to build the bodytext of the requester, according
             to the printf-alike formating string passed in 'textFormat'.
 NOTE
    The resulting textbody for the Requester shouldn't exceed 256 bytes.

 RESULT
    The function returns the number of the gadget the user pressed, or
    -1 if the requester couldn't be displayed or is killed by a system event.
    The gadgets are numbered: 1,2,...,n,0 from left to right.

 SPECIAL NOTES
    "joinOS.lib" contains an interface stub for a vararg version called
    TextBox().

joinOS.library/UnLockDOSList                        joinOS.library/UnLockDOSList

 NAME
    UnLockDOSList - free the access to the dos list

 SYNOPSIS
    void UnLockDOSList (ULONG)
    UnLockDOSList (AccessFlags)
                       D1

 FUNCTION
    Unlock a Dos list previously locked using LockDosList() or
    AttemptLockDosList().
    The calls to AttemptLockDosList() and LockDosList() are nested, so every
    successfull call to this functions must be matched by the same number of
    calls to this function.
    Unlock the dos list as fast as you can, other processes may wait to get
    access to it.

 INPUT
    AccessFlags - the same accessflags as you specified by the previous call
                   to LockDosList() or AttemptLockDosList().
 NOTE
    NEVER call this function if the previous call to AttemptLockDosList()
    failed.
    Since there is no way to lock the DosList under AmigaOS 1.3 (v34), the
    functions LockDOSList() and UnLockDOSList() are implemented as
    Forbid()/Permit() pair for these systems, so it is incredibly important
    to unlock the DosList as fast as possible, because the multitasking is
    disabled while the list is locked.

 SEE ALSO
    LockDOSList(), FindDOSEntry(), NextDOSEntry()

joinOS.library/UnpackStructTags                  joinOS.library/UnpackStructTags

 NAME
    UnpackStructTags  - unpack a structure of values into a taglist

 SYNOPSIS
    ULONG UnpackStructTags (APTR, ULONG *, struct TagItem *)
    num = UnpackStructTags (pack, packTable, tagList)
    D0                       A0      A1        A2

 FUNCTION
    For each table entry, a FindTag() will be done and if the matching tag
    is found in the taglist, the data in the structure will be placed into
    the memory pointed to by the tag's ti_Data. ti_Data *must* point to a
    LONGWORD.

 INPUTS
    pack - a pointer to the data area to be unpacked
    packTable - a pointer to the packing information table.
           See <joinOS/misc/tagItems.h> for definition and macros
    tagList - a pointer to the taglist to unpack into

 RESULTS
    num - the number of tag items unpacked

 SEE ALSO
    <joinOS/misc/tagItems.h>, FindTag(), PackStructTags()

joinOS.library/Upper                                        joinOS.library/Upper

 NAME
    Upper - convert a character to an upper character

 SYNOPSIS
    upper = Upper (lower)
     D0             D0
    char Upper (const char)

 FUNCTION
    This function returns the upper character of the specified character.
    All characters - including the special characters (like '') - are
    converted to upper characters. If the specified character is a number
    or something like a punctuation mark, or even already an upper character
    the character is returned unchanged.

 INPUT
    lower - the character that should be transformed to its upper equivalent.

 RESULT
    The equivalent upper character to the specified one is returned.
    If there is no equivalent upper character, or the specified one is
    already an upper one, the same character is returned.

 NOTE
    This function is usually implemented as macro.

joinOS.library/WaitDosPkt                              joinOS.library/WaitDosPkt

 NAME
    WaitDosPkt - wait for a packet to arrive at current process's pr_MsgPort

 SYNOPSIS
    struct DosPacket *WaitDosPkt (void)
    dp = WaitDosPkt ()
    D0

 FUNCTION
    Packets that have been sent by an application to a handler and the
    replies thereto returned to the originating process by the handler can
    be waited for by calling this function. WaitPkt() returns a pointer to
    the packet associated with the first message enqueued at the process's
    message port (pr_MsgPort); this requires taht the Message field
    "mn_Node.ln_Name" point to an associated DosPacket structure, of course.
    The message is removed automatically from the message port; it is pointed
    to by the dp_Link field. If no message is pending, this call will wait
    for one to arrive. It will not Wait() if a packet has already been
    enqueued at the port, so calling this function may or may not clear the
    process's message-port signal (SIGF_DOS).

 RESULT
    The first packet found in the process's message port is returned.

 SEE ALSO
    AbortDosPkt(), DoDosPkt(), SendDosPkt, ReplyDosPkt

