@DATABASE "joinOS"
@MASTER   "joinOS.doc"
@REMARK   This file was created by ADtoHT 2.1 on 07-May-04 15:18:35
@REMARK   Do not edit
@REMARK   ADtoHT is © 1993-1995 Christian Stieber

@$VER: joinOS.guide (joinOS.library 1.0) (07.05.04)
@author "Peter Riede"
@(c) "Copyright © 2004 by Peter "Noster" Riede"

@NODE MAIN "joinOS.doc"

---------------------------------------------------------------------------
                            @{b}@{fg shine}joinOS.library 1.0@{fg text}@{ub}
                                  @{b}AUTODOC@{ub}

                   A shared runtime library for creating
                      system independent source code
                       @{fg shine}Copyright © 2004 Peter Riede
                           All Rights Reserved.@{fg text}

                           I hope you like it.
---------------------------------------------------------------------------

This  library has been written to make it easier to write applications that
are  independent to the underlying operating system.  This library contains
several  function that @{i}make the life easier @{ui}and allow to write applications
that run on every AmigaOS from 1.3 upto 3.9 without missing the benefits of
the  newer  versions.   Whenever  you  need  to  access  a  function of the
dos.library of utility.library of the Amiga, you should first look if there
isn't an according function in this library.

A Windows© port of this library (containing all functions from exec.library
and  dos.library  that  are  part  of every AmigaOS) is in work and will be
released soon.  So you will be able to write system independent code in the
@{i}Amiga-way @{ui}of coding.

@{"AbortDosPkt()" LINK "AbortDosPkt"}         @{"Adds64()" LINK "Adds64"}                @{"AllocateTagList()" LINK "AllocateTagList"}
@{"AllocDOSObject()" LINK "AllocDOSObject"}      @{"AllocPoolMem()" LINK "AllocPoolMem"}          @{"AllocVector()" LINK "AllocVector"}
@{"AsyncCopyFile()" LINK "AsyncCopyFile"}       @{"AvailMemory()" LINK "AvailMemory"}           @{"ChangeTagList()" LINK "ChangeTagList"}
@{"ClearMem()" LINK "ClearMem"}            @{"ClearMemHeader()" LINK "ClearMemHeader"}        @{"CloneTagList()" LINK "CloneTagList"}
@{"CountNodes()" LINK "CountNodes"}          @{"CreateMemPool()" LINK "CreateMemPool"}         @{"CreateSignalSemaphore()" LINK "CreateSignalSemaphore"}
@{"Date2Str()" LINK "Date2Str"}            @{"DatesCompare()" LINK "DatesCompare"}          @{"DayOfWeek()" LINK "DayOfWeek"}
@{"Delete()" LINK "Delete"}              @{"DeleteMemPool()" LINK "DeleteMemPool"}         @{"DeleteSignalSemaphore()" LINK "DeleteSignalSemaphore"}
@{"Divs64()" LINK "Divs64"}              @{"Divu64()" LINK "Divu64"}                @{"DoDosPkt()" LINK "DoDosPkt"}
@{"DOUBLELONG2Str()" LINK "DOUBLELONG2Str"}      @{"ErrorText()" LINK "ErrorText"}             @{"ExamineAll()" LINK "ExamineAll"}
@{"ExamineAllEnd()" LINK "ExamineAllEnd"}       @{"FillMem()" LINK "FillMem"}               @{"FilterChangeTags()" LINK "FilterChangeTags"}
@{"FilterTagList()" LINK "FilterTagList"}       @{"FindArgument()" LINK "FindArgument"}          @{"FindDOSEntry()" LINK "FindDOSEntry"}
@{"FindFirstMatch()" LINK "FindFirstMatch"}      @{"FindMatchEnd()" LINK "FindMatchEnd"}          @{"FindNextMatch()" LINK "FindNextMatch"}
@{"FindTag()" LINK "FindTag"}             @{"FreeArguments()" LINK "FreeArguments"}         @{"FreeDOSObject()" LINK "FreeDOSObject"}
@{"FreePoolMem()" LINK "FreePoolMem"}         @{"FreeTagList()" LINK "FreeTagList"}           @{"FreeVector()" LINK "FreeVector"}
@{"GetSysBase()" LINK "GetSysBase"}          @{"GetTagItem()" LINK "GetTagItem"}            @{"IsAmigaDosError()" LINK "IsAmigaDosError"}
@{"IsValidDate()" LINK "IsValidDate"}         @{"IsValidMemList()" LINK "IsValidMemList"}        @{"LockDOSList()" LINK "LockDOSList"}
@{"Long2Str()" LINK "Long2Str"}            @{"MakeUniqueName()" LINK "MakeUniqueName"}        @{"MapTagList()" LINK "MapTagList"}
@{"MoveMem()" LINK "MoveMem"}             @{"Muls64()" LINK "Muls64"}                @{"Mulu64()" LINK "Mulu64"}
@{"Neg64()" LINK "Neg64"}               @{"NextDOSEntry()" LINK "NextDOSEntry"}          @{"NextTag()" LINK "NextTag"}
@{"PackBooleanTags()" LINK "PackBooleanTags"}     @{"PackStructTags()" LINK "PackStructTags"}        @{"ParseArgs()" LINK "ParseArgs"}
@{"ParseItem()" LINK "ParseItem"}           @{"PathFromLock()" LINK "PathFromLock"}          @{"PatternMatch()" LINK "PatternMatch"}
@{"PatternMatchNoCase()" LINK "PatternMatchNoCase"}  @{"PatternParse()" LINK "PatternParse"}          @{"PatternParseNoCase()" LINK "PatternParseNoCase"}
@{"PrintError()" LINK "PrintError"}          @{"RefreshTagListClones()" LINK "RefreshTagListClones"}  @{"ReplyDosPkt()" LINK "ReplyDosPkt"}
@{"ReportError()" LINK "ReportError"}         @{"SemaphoreRelease()" LINK "SemaphoreRelease"}      @{"SendDosPkt()" LINK "SendDosPkt"}
@{"SetIOErr()" LINK "SetIOErr"}            @{"Sqrt32()" LINK "Sqrt32"}                @{"Str2Date()" LINK "Str2Date"}
@{"Str2DOUBLELONG()" LINK "Str2DOUBLELONG"}      @{"Str2Long()" LINK "Str2Long"}              @{"TagIsInArray()" LINK "TagIsInArray"}
@{"TempFileName()" LINK "TempFileName"}        @{"TextBox()" LINK "TextBox"}               @{"TextBoxA()" LINK "TextBoxA"}
@{"UnLockDOSList()" LINK "UnLockDOSList"}       @{"UnpackStructTags()" LINK "UnpackStructTags"}      @{"Upper()" LINK "Upper"}
@{"WaitDosPkt()" LINK "WaitDosPkt"}          

@ENDNODE
@NODE "AbortDosPkt" "joinOS.library/AbortDosPkt()"
@{b}

 NAME@{ub}
        AbortDosPkt - try to abort a pending packet@{b}

 SYNOPSIS@{ub}
        void AbortDosPkt (struct MsgPort*, struct DosPacket*)
        AbortDosPkt (mp, dp)
                     D1  D2@{b}

 FUNCTION@{ub}
        AbortPkt() is supposed to request that a packet that has been send
        asynchronously, e.g. by means of SendPkt(), be aborted.

        AbortPkt() must be followed by a WaitPkt().@{b}

 INPUTS@{ub}
        mp - message port the packet has been send to.
        dp - packet to be aborted.@{b}

 BUGS@{ub}
        Originaly this function is a no-op, as the original AmigaDos design did
        not allow for packets to be aborted.
        (Under Windoof I/O-functions could also not be aborted.)

        This implementation tries nevertheless to remove the packet, if it's
        not the first message in the message ports list.

        THIS IS DANGEROUS, THERE MIGHT BE APPLICATIONS WHICH SCAN THE PORTS@{b}
    MESSAGE LIST BY THEIR OWN AND PROCESS THE FOUND MESSAGES IN DIFFERENT@{ub}
        ORDERS, THIS WOULD PRODUCE A SYSTEM CRASH !@{b}

 SEE ALSO@{ub}
        @{"DoDosPkt()" LINK "DoDosPkt"}, @{"SendDosPkt" LINK "SendDosPkt"}, @{"ReplyDosPkt" LINK "ReplyDosPkt"}, @{"WaitDosPkt()" LINK "WaitDosPkt"}

@ENDNODE
@NODE "Adds64" "joinOS.library/Adds64()"
@{b}

 NAME@{ub}
        Adds64 - add two 64 bit signed integers@{b}

 SYNOPSIS@{ub}
        void Adds64 (LONGLONG *, LONGLONG *)
        Adds64 (arg1, arg2)
                 A0    A1@{b}

 FUNCTION@{ub}
        This function adds two signed 64-bit integers.@{b}

 INPUTS@{ub}
        arg1 - a pointer to the first 64 bit integer, the result of this
              function is stored in this integer
        arg2 - a pointer to the second 64 bit integer, that should be added
              to the first one.@{b}

 SEE ALSO@{ub}
        @{"Divu64()" LINK "Divu64"}, @{"Divs64()" LINK "Divs64"}, @{"Mulu64()" LINK "Mulu64"}, @{"Muls64()" LINK "Muls64"}, @{"Neg64()" LINK "Neg64"}

@ENDNODE
@NODE "AllocDOSObject" "joinOS.library/AllocDOSObject()"
@{b}

 NAME@{ub}
        AllocDOSObject - allocate and initialize dos-specific data structures@{b}

 SYNOPSIS@{ub}
        APTR AllocDOSObject (ULONG, struct TagItem*)
        object = AllocDOSObject (Type, Tags)
          D0                      D1    D2@{b}

 FUNCTION@{ub}
        Allocates and initializes a DOS-specific data structure.
        This function and the oponent function FreeDosObject() are used for
        allocation and disposal of DOS-related structures in a save way without
        the need to take care about future versions of the OS and improvements
        or changes to the structures.
        For application programs only the types @{"DOS_FIB" LINK "include/AmigaDOS.h/File" 493} and @{"DOS_EXALLCONTROL" LINK "include/AmigaDOS.h/File" 492} are
        usefull.@{b}

 INPUTS@{ub}
        Type - specifies the type of object that should be allocated, can be any
              of the following types:
           @{"DOS_FILEHANDLE" LINK "include/AmigaDOS.h/File" 491} - a FileHandle for use in file-I/O-functions.
           @{"DOS_FIB" LINK "include/AmigaDOS.h/File" 493}        - a FileInfoBlock as used for Examine() or ExNext().
           @{"DOS_EXALLCONTROL" LINK "include/AmigaDOS.h/File" 492} - a ExAllControl function as used for ExAll().
           @{"DOS_STDPKT" LINK "include/AmigaDOS.h/File" 494}     - a DosPacket for packed-oriented IO
           @{"DOS_CLI" LINK "include/AmigaDOS.h/File" 495}        - a CommandLineInterface structure
           @{"DOS_RDARGS" LINK "include/AmigaDOS.h/File" 496}     - a RDArgs structure
        Tags - additional information specifying the object to be allocated.
              currently not implemented, you should always pass NULL.@{b}

 RESULT@{ub}
        If the function succeeds, a pointer to the allocated object is returned.
        If the function fails, NULL is returned.@{b}

 NOTE@{ub}
        You have to use FreeDosEntry() for deallocation of objects allocated
        using this function, don't free them by directly calling any deallocation
        function (FreeMem() or FreeVec()).@{b}

 BUGS@{ub}
        The AmigaOS function AllocDOSObject() for AmigaOS < v36 doesn't allocate
        @{"DOS_CLI" LINK "include/AmigaDOS.h/File" 495} objects, it will return @{"ERROR_NOT_IMPLEMENTED" LINK "include/AmigaDOS.h/File" 376} instead.@{b}

 SEE ALSO@{ub}
        @{"FreeDOSObject()" LINK "FreeDOSObject"}

@ENDNODE
@NODE "AllocPoolMem" "joinOS.library/AllocPoolMem()"
@{b}

 NAME@{ub}
        AllocPoolMem - Get a block of memory from the memory pool.@{b}

 SYNOPSIS@{ub}
        void *AllocPoolMem (void *, ULONG)
        memBlock = AllocPoolMem (PoolHeader, size)
           D0                       A0        D0@{b}

 FUNCTION@{ub}
        Get a block of memory from the memory pool.
        If there isn't enough free memory in the puddles, or no big enough free
        memory block, or the requested size exceeds the <TreshSize> of the pool,
        a new puddle is added to the pool.@{b}

 INPUTS@{ub}
        PoolHeader - the pointer to the pool header as returned from
                       @{"CreateMemPool()" LINK "CreateMemPool"}.
        size       - the size of the requested memory block in bytes.@{b}

 RESULT@{ub}
        If the function succeeds, a pointer to the memory block is returned.
        If the function fails (system gone out of memory), NULL is returned.@{b}

 SEE ALSO@{ub}
        @{"FreePoolMem()" LINK "FreePoolMem"}, @{"CreateMemPool()" LINK "CreateMemPool"}, @{"DeleteMemPool()" LINK "DeleteMemPool"}

@ENDNODE
@NODE "AllocVector" "joinOS.library/AllocVector()"
@{b}

 NAME@{ub}
        AllocVector - allocate a memory block, remember its size@{b}

 SYNOPSIS@{ub}
        APTR AllocVector (ULONG, ULONG)
        memory = AllocVector (size, attributes)
          A0                   D0       D1@{b}

 FUNCTION@{ub}
        This function works identically to AllocMem(), but tracks the size of an
        allocation.
        See AllocMem() for details.@{b}

 INPUTS@{ub}
        size        - the size of the desired memory block in bytes. If 0 is
                       passed for this argument, 0 bytes will be allocated (NULL
                       will be returned.
        attributes  - attributes as used for AllocMem().@{b}

 RESULT@{ub}
        If the function succeeds, a pointer to the allocated memory-block is
        returned.
        If the function fails, NULL is returned.@{b}

 BUGS@{ub}
        See AllocMem().@{b}

 SEE ALSO@{ub}
        @{"FreeVector()" LINK "FreeVector"}

@ENDNODE
@NODE "AllocateTagList" "joinOS.library/AllocateTagList()"
@{b}

 NAME@{ub}
        AllocateTagList - allocate a tag list@{b}

 SYNOPSIS@{ub}
        struct TagItem *AllocateTagList (ULONG)
        tagList = AllocateTagList (numTags)
         D0                          D0@{b}

 FUNCTION@{ub}
        Allocates the specified number of usable TagItems slots.

        Note that to access the TagItems in 'tagList', you should use
        the function @{"NextTag()" LINK "NextTag"}. This will insure you respect any
        chaining (TAG_MORE) and secret hiding places (TAG_IGNORE) that
        this function might generate.@{b}

 INPUTS@{ub}
        numTags - the number of TagItem slots you want to allocate. If 0 is
                 passed for this argument, a TagItem list with no "useable"
                 slot is created (i.e. a TagItem list which only contains
                 a TAG_DONE).@{b}

 RESULTS@{ub}
        tagList  - the allocated chain of TagItem structures, or NULL if
               there was not enough memory. An allocated tag list must
               eventually be freed using @{"FreeTagList()" LINK "FreeTagList"}.@{b}

 SEE ALSO@{ub}
        <joinOS/misc/tagitem.h>, @{"FreeTagList()" LINK "FreeTagList"}, @{"CloneTagList()" LINK "CloneTagList"}

@ENDNODE
@NODE "AsyncCopyFile" "joinOS.library/AsyncCopyFile()"
@{b}

 NAME@{ub}
        AsyncCopyFile - perform an asynchroneous copy of a file@{b}

 SYNOPSIS@{ub}
        BOOL AsyncCopyFile (STRPTR, STRPTR, BOOL)
        success = AsyncCopyFile (source, dest, fExist)
          D0                       A0     A1     D0@{b}

 FUNCTION@{ub}
        This function copies a file. It uses two small buffers of about 32kB for
        this purpose and tries to copy the file asynchroneous, i.e. whenever a
        buffer is filled from the source, it is written to the destination
        while the next buffer is filled from the source.

        If a large file is copied and two different devices are used for I/O
        (e.g. copying from one harddisk to another) this will save nearly half
        of the time. In worst case nothing is won and nothing is lost in
        comparison to synchrone transfer.

        If there is not enough free memory available for 32kB buffers, smaller
        buffers are used, at least 1kB.@{b}

 INPUTS@{ub}
        source - a pointer to the NUL-terminated C-string with the filename (and
                 path) of the file to be copied.
        dest - a pointer to the NUL-terminated C-string with the filename (and
                 path) of the file to be created.
        fExist - a boolean value, TRUE indicates that the function should fail,
                 if the destination file exists; FALSE indicates that an existing
                 file should be overwritten silently.@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned, else FALSE is returned.
        See IoErr() for the cause of a failure.@{b}

 NOTES@{ub}
        The process' messageport is used for I/O, take care that you only call
        this function from an AmigaDOS process and that there is no packet
        pending, when this function is called or you would meet the Guru
        (AN_AsyncPkt).@{b}

 BUGS@{ub}
        Because the AmigaOS is a multitasking OS, there is a very small chance
        that an existing file is erroneous overwritten, if it is created between
        the test of its existance and the opening for output.

@ENDNODE
@NODE "AvailMemory" "joinOS.library/AvailMemory()"
@{b}

 NAME@{ub}
        AvailMemory - determine the amount of free memory@{b}

 SYNOPSIS@{ub}
        ULONG AvailMemory (struct List *, ULONG)
        freeMem = AvailMemory (memList, Attributes)
          D0                     A0         D0@{b}

 FUNCTION@{ub}
        This function returns the amount of free memory of a list of MemHeaders.
        To find out what the largest block of a particular MemHeaders list is,
        add MEMF_LARGEST into the requirements argument. Returning the largest
        block is a slow operation.

        If the list of MemHeaders is shared between applications, you have to
        guard this function by a Forbid()/Permit() pair, or better you protect
        the list with a semaphore.@{b}

 INPUTS@{ub}
        memList - the list header of a list of MemHeaders
        Attributes - a requirement mask as specified in AllocMem(). Any of the
                    AllocMem bits are valid, as is MEMF_LARGEST which returns the
                    size of the largest block matching the requirements.@{b}

 RESULT@{ub}
        The total free space remaining in the list (or the largest free block)
        is returned.@{b}

 NOTE@{ub}
        In the current implementation, requirement flags are ignored except
        MEMF_LARGEST.

@ENDNODE
@NODE "ChangeTagList" "joinOS.library/ChangeTagList()"
@{b}

 NAME@{ub}
        ChangeTagList - change a tag list based on a second tag list.@{b}

 SYNOPSIS@{ub}
        void ChangeTagList (struct TagItem *, struct TagItem *)
        ChangeTagList (list, changeList)
                        A0      A1@{b}

 FUNCTION@{ub}
        For any tag that appears in both 'list' and 'changeList', this
        function will change the ti_Data field of the tag in 'list' to
        match the ti_Data field of the tag in 'changeList'. In effect,
        'changeList' contains a series of new values for tags already in
        'list'. Any tag in 'changeList' that is not in 'list' is ignored.@{b}

 INPUTS@{ub}
        list - a list of existing tags (may be NULL)
        changeList - a list of tags to modify 'list' with (may be NULL)@{b}

 SEE ALSO@{ub}
        <joinOS/misc/tagitem.h>, @{"FilterChangeTags()" LINK "FilterChangeTags"}

@ENDNODE
@NODE "ClearMem" "joinOS.library/ClearMem()"
@{b}

 NAME@{ub}
        ClearMem - Fills a block of memory with ZERO.@{b}

 SYNOPSIS@{ub}
        void ClearMem (APTR, ULONG)
        ClearMem (mem, size)
                  A0    D0@{b}

 FUNCTION@{ub}
        This function clears a block of memory.
        This means the whole block of memory if filled with ZERO.
        It can deal with arbitrary length, with its pointers on arbitrary
        alignments.
        The internal implementation of this function will change from system to
        system, and may be implemented via hardware DMA.@{b}

 INPUTS@{ub}
        mem   - a pointer to the data region that should be cleared.
        size  - the size (in bytes) of the memory area. Zero clears zero bytes.@{b}

 SEE ALSO@{ub}
        @{"FillMem()" LINK "FillMem"}

@ENDNODE
@NODE "ClearMemHeader" "joinOS.library/ClearMemHeader()"
@{b}

 NAME@{ub}
        ClearMemHeader - initializes a MemHeader structure@{b}

 SYNOPSIS@{ub}
        void ClearMemHeader (struct MemHeader *)
        ClearMemHeader (membh)
                         A0@{b}

 FUNCTION@{ub}
        This function is a support function for the pool-memory functions or every
        application that uses MemHeader structures on its own.
        This function initializes a MemHeader structure, as if there is no memory
        of the MemChunk list allocated. This function should only be called if you
        are sure that none of the memory managed by this MemHeader is in use, so
        you can "Deallocate()" all memory used by this MemHeader in one call,
        instead of deallocating every "Allocate'd()" MemChunk.@{b}

 INPUT@{ub}
        membh - a pointer to the MemHeader structure that should be "reseted".@{b}

 NOTE@{ub}
        Only the MemHeader structure passed as argument is initilized, if there
        is linked any other MemHeader structure with the Node structure part at
        the begin of the MemHeader, it stays untouched.

@ENDNODE
@NODE "CloneTagList" "joinOS.library/CloneTagList()"
@{b}

 NAME@{ub}
        CloneTagList - copy a tag list@{b}

 SYNOPSIS@{ub}
        struct TagItem *CloneTagList (struct TagItem *)
        clone = CloneTagList (original)
           D0                    A0@{b}

 FUNCTION@{ub}
        Copies the essential contents of a tag list into a new tag list.

        The cloning is such that calling @{"FindTag()" LINK "FindTag"} with a given tag on
        the original or cloned tag lists will always return the same
        tag value. That is, the ordering of the tags is maintained.@{b}

 INPUTS@{ub}
        original - tag list to clone. May be NULL, in which case an
                    empty tag list is returned.@{b}

 RESULTS@{ub}
        clone - copy of the original tag list, or NULL if there was not enough
                 memory. This tag list must eventually by freed by calling
                 FreeTagItems().@{b}

 SEE ALSO@{ub}
        <joinOS/misc/tagitem.h>, @{"AllocateTagList()" LINK "AllocateTagList"}, @{"FreeTagList()" LINK "FreeTagList"},
        @{"RefreshTagListClones()" LINK "RefreshTagListClones"}

@ENDNODE
@NODE "CountNodes" "joinOS.library/CountNodes()"
@{b}

 NAME@{ub}
        CountNodes - counts the number of nodes in a list@{b}

 SYNOPSIS@{ub}
        ULONG CountNodes (struct List *)
        numNodes = CountNodes (list)
           D0                   A0@{b}

 FUNCTION@{ub}
        This functions counts the number of nodes found in a particular list.@{b}

 INPUT@{ub}
        list - the list, which nodes should be count@{b}

 RESULT@{ub}
        The number of nodes found in the list is returned.

@ENDNODE
@NODE "CreateMemPool" "joinOS.library/CreateMemPool()"
@{b}

 NAME@{ub}
        CreateMemPool - allocate and prepare a new pool memory header.@{b}

 SYNOPSIS@{ub}
        void *CreateMemPool (ULONG, ULONG, ULONG)
        poolHeader = CreateMemPool (MemFlags, PuddleSize, ThreshSize)
            D0                        D0         D1           D2@{b}

 FUNCTION@{ub}
        Allocate and prepare a new pool memory header.
        The pool memory header is allocated and initialized and the first puddle
        is allocated. (On AmigaOS >= V39 it's undefined if the first puddle is
        allocated by pool creation or by the first allocate of memory of the
        pool).@{b}

 INPUTS@{ub}
        MemFlags    - specify the kind of memory of the pool, these are the same
           flags as taken by AllocMem().
        PuddleSize  - specifies the size of the "puddles".
        TreshSize   - the largest allocation that goes into normal puddles.
           Allocations larger than the <ThreshSize> are allocation in their own
           puddles. This must be less or equal to <PuddleSize>, CreateMemPool()
           will fail if it is not).@{b}

 RESULT@{ub}
        If the function succeeds, a pointer to the new pool header is returned.
        If the function fails, NULL is returned.@{b}

 NOTE@{ub}
        Don't mismatch this function with the CreatePooled() function of the
        AmigaOS >= V39.
        The MEMF_CLEAR memflag is ignored, the memory returned from
        @{"AllocPoolMem()" LINK "AllocPoolMem"} is NOT zero-initialized.@{b}

 SEE ALSO@{ub}
        @{"AllocPoolMem()" LINK "AllocPoolMem"}, @{"FreePoolMem()" LINK "FreePoolMem"}, @{"DeleteMemPool()" LINK "DeleteMemPool"}

@ENDNODE
@NODE "CreateSignalSemaphore" "joinOS.library/CreateSignalSemaphore()"
@{b}

 NAME@{ub}
        CreateSignalSemaphore - allocates and initializes a SignalSemaphore@{b}

 SYNOPSIS@{ub}
        struct SignalSemaphore *CreateSignalSemaphore (STRPTR, BYTE)
        sigSem = CreateSignalSemaphore (name, pri)
          D0                             A0   D0:8@{b}

 FUNCTION@{ub}
        This function allocates and initializes a SignalSemaphore for the use
        with the semaphore functions.
        If a name if passed to this function, the semaphore will be made public
        by this function.
        This function is new for all operating systems, but you should use it
        also for AmigaOS functions, because it is save in use. (Under AmigaOS
        previour V36 the function AddSemaphore() has a bug and doesn't work.

        If you want to create SignalSemaphores in the old fashioned manner, use
        the AllocMem() function with the memory attribute MEMF_PUBLIC for
        allocating the memory for the semaphore, or the semaphore will not be
        found by other processes.
        You should not try to use SignalSemaphores initialized by InitSemaphore()
        as public semaphores. If you try to make a Semaphore public that is in
        use, that will fail.@{b}

 INPUTS@{ub}
        name - a (optional) name of the semaphore, if this is NULL, the semaphore
               is not made public. This name will be copied to a new allocated
              buffer, so it has not to stay valid after this function succeeds.
        pri - the priority, used for linking it into the systems list of
              semaphores, if you often search the semaphore give it a higher
              priority, normaly you should pass 0.@{b}

 RESULT@{ub}
        If the function succeeds, a pointer to a fully initialized and
        "ready to use" SignalSemaphore is returned. If a name is passed to this
        function, the semaphore would be made public.
        If the function fails, NULL is returned.@{b}

 NOTE@{ub}
           Be shure that the name of a SignalSemaphore you create without using
           this function is unique in the whole Windoof system or you will produce
           unpredictable results. There is no combatible way to determine, if a
           chosen name is not used by any other Windoof process for its semaphore.
           Use the following code segment for testing:

        struct SignalSemaphore *OwnSemaphoreCreation (STRPTR name)
        {
           struct SignalSemaphore *sigSem = NULL;

           Forbid();
           if (sigSem = FindSemaphore (semaphoreName))
           {
              // There is already a public semaphore with the same name in Exec's
              // public semaphore list...
              sigSem = NULL;
           }
           else
           {
              // Create the semaphore in the old fashion manner, be shure you use
              // MEMF_PUBLIC | MEMF_CLEAR for allocating the SignalSemaphore
              // structure and MEMF_PUBLIC for the name pointed by
              // sigSem->ss_Link.ln_Name...

              AddSemaphore(sigSem);
           }
           return sigSem;
        }@{b}

 SEE ALSO@{ub}
        @{"DeleteSignalSemaphore()" LINK "DeleteSignalSemaphore"}

@ENDNODE
@NODE "DOUBLELONG2Str" "joinOS.library/DOUBLELONG2Str()"
@{b}

 NAME@{ub}
        DOUBLELONG2Str - create a decimal string according to a DOUBLELONG value@{b}

 SYNOPSIS@{ub}
        LONG DOUBLELONG2Str (DOUBLELONG *, STRPTR)
        bytesCopied = DOUBLELONG2Str (value, buffer)
            D0                         A0      A1@{b}

 FUNCTION@{ub}
        This function copies the decimal string that corresponds to the
        specified DOUBLELONG value into a buffer.@{b}

 INPUTS@{ub}
        value - a pointer to the DOUBLELONG value that should be converted
        buffer - a pointer to the buffer, where the corresponding decimal
                 string should be stored. This buffer has to be at least
                 22 bytes large.@{b}

 RESULT@{ub}
        The number of bytes copied to the destination buffer (without the
        terminating NUL-byte) is returned.@{b}

 SEE ALSO@{ub}
        @{"Str2DOUBLELONG()" LINK "Str2DOUBLELONG"}

@ENDNODE
@NODE "Date2Str" "joinOS.library/Date2Str()"
@{b}

 NAME@{ub}
        Date2Str - convert a DateStamp into a human readable string@{b}

 SYNOPSIS@{ub}
        BOOL Date2Str (@{"struct DateTime" LINK "include/AmigaDOS.h/File" 529}*)
        success = Date2Str (DateTime)
           D0                  D1@{b}

 FUNCTION@{ub}
        DateToStr converts an AmigaDOS DateStamp to a human
        readable ASCII string as requested by your settings in the
        DateTime structure.@{b}

 INPUTS@{ub}
        DateTime - a pointer to an initialized DateTime structure.

        The DateTime structure should be initialized as follows:

        dat_Stamp - a copy of the datestamp you wish to convert to ascii.

        dat_Format - a format byte which specifies the format of the dat_StrDate.
           This can be any of the following (note: If value used is something
           other than those below, the default of @{"FORMAT_DOS" LINK "include/AmigaDOS.h/File" 552} is used):

           @{"FORMAT_DOS" LINK "include/AmigaDOS.h/File" 552}:   AmigaDOS format (dd-mmm-yy).
           @{"FORMAT_INT" LINK "include/AmigaDOS.h/File" 553}:   International   format (yy-mm-dd).
           @{"FORMAT_USA" LINK "include/AmigaDOS.h/File" 554}:   American format (mm-dd-yy).
           @{"FORMAT_CDN" LINK "include/AmigaDOS.h/File" 555}:   Canadian format (dd-mm-yy).
           FORMAT_DEF:   default format for locale.

        dat_Flags - a flags byte. The only flag which affects this function is:

           @{"DTF_SUBST" LINK "include/AmigaDOS.h/File" 544}:    If set, a string such as Today, Monday, etc., will be
                    used instead of the dat_Format specification if possible.
           @{"DTF_FUTURE" LINK "include/AmigaDOS.h/File" 546}:   Ignored by this function.

        dat_StrDay - pointer to a buffer to receive the day of the week string.
           (Monday, Tuesday, etc.). If null, this string will not be generated.

        dat_StrDate -  pointer to a buffer to receive the date string, in the
           format requested by dat_Format, subject to possible modifications by
           @{"DTF_SUBST" LINK "include/AmigaDOS.h/File" 544}. If null, this string will not be generated.

        dat_StrTime -  pointer to a buffer to receive the time of day string.
           If NULL, this will not be generated.

        If non-NULL, all string buffers must be at least 16 bytes (@{"LEN_DATSTRING" LINK "include/AmigaDOS.h/File" 539})
        in size.@{b}

 RESULT@{ub}
        success  - a zero return indicates that the DateStamp was invalid, and
        could not be converted. Non-zero indicates that the call succeeded.@{b}

 SEE ALSO@{ub}
        @{"Str2Date()" LINK "Str2Date"}, @{"IsValidDate()" LINK "IsValidDate"}, @{"Long2Str()" LINK "Long2Str"}

@ENDNODE
@NODE "DatesCompare" "joinOS.library/DatesCompare()"
@{b}

 NAME@{ub}
        DatesCompare - compare two DateStamps@{b}

 SYNOPSIS@{ub}
        LONG DatesCompare (const @{"struct DateStamp" LINK "include/AmigaDOS.h/File" 147}*, const @{"struct DateStamp" LINK "include/AmigaDOS.h/File" 147}*)
        result = DatesCompare (First, Second)
          D0                    D1      D2@{b}

 FUNCTION@{ub}
        Compare two DateStamps for their relative magnitude.@{b}

 INPUTS@{ub}
        First    - the first DateStamp that should be compared against ...
        Second   - the second DateStamp.@{b}

 RESULT@{ub}
        < 0 => the second DateStamp is earlier than the first DateStamp.
        = 0 => the second DateStamp equals the first DateStamp.
        > 0 => the second DateStamp is later than the first DateStamp.@{b}

 SEE ALSO@{ub}
        @{"Date2Str()" LINK "Date2Str"}, @{"IsValidDate()" LINK "IsValidDate"}

@ENDNODE
@NODE "DayOfWeek" "joinOS.library/DayOfWeek()"
@{b}

 NAME@{ub}
        DayOfWeek - return a number representing the weekday@{b}

 SYNOPSIS@{ub}
        ULONG DayOfWeek (ULONG)
        week = DayOfWeek (days_passed)@{b}

 FUNCTION@{ub}
        This function returns the no. of the weekday (0 = sunday, 1 = monday ...)
        for a specified day.@{b}

 INPUT@{ub}
        days - number of days passed since 01.01.1978.@{b}

 RESULT@{ub}
        The number of the weekday (0 - 6).@{b}

 SEE ALSO@{ub}
        @{"Date2Str()" LINK "Date2Str"}

@ENDNODE
@NODE "Delete" "joinOS.library/Delete()"
@{b}

 NAME@{ub}
        Delete - delete a filesystem object@{b}

 SYNOPSIS@{ub}
        success = Delete (name)
        LONG Delete (STRPTR)@{b}

 FUNCTION@{ub}
        This function attempts to delete a file or directory.
        An error is returned if the deletion fails.
        Note that all the files within a directory must be deleted before the
        directory itself can be deleted.@{b}

 INPUT@{ub}
        name - a NUL-terminated C-string that identifies the filesystem object
              to be removed.@{b}

 RESULT@{ub}
        If the function succeeds, @{"DOSTRUE" LINK "include/AmigaDOS.h/File" 90} is returned.
        If the function fails, @{"DOSFALSE" LINK "include/AmigaDOS.h/File" 91} is returned.@{b}

 NOTE@{ub}
        On Amiga systems this function is implemented as macro that expands to
        a function call of the dos.library function DeleteFile().

@ENDNODE
@NODE "DeleteMemPool" "joinOS.library/DeleteMemPool()"
@{b}

 NAME@{ub}
        DeleteMemPool - destroy a memory pool@{b}

 SYNOPSIS@{ub}
        void DeleteMemPool (void *)
        DeleteMemPool (PoolHeader)
                       A0@{b}

 FUNCTION@{ub}
        Free all allocated blocks of memory and destroy the pool.
        Be sure that your application doesn' access the memory any more, otherwise
        this will result in a system crash.
        Doing a DeleteMemPool() will free all puddles and thus all of the
        allocations done with @{"AllocPoolMem()" LINK "AllocPoolMem"} in that pool. (No need to
        @{"FreePoolMem()" LINK "FreePoolMem"} each allocation)@{b}

 INPUT@{ub}
        PoolHeader  - the pointer to the pool header as returned from
                       @{"CreateMemPool()" LINK "CreateMemPool"}.@{b}

 NOTE@{ub}
        Don't confuse with the AmigaOS V39 function DeletePool().@{b}

 SEE ALSO@{ub}
        @{"AllocPoolMem()" LINK "AllocPoolMem"}, @{"FreePoolMem()" LINK "FreePoolMem"}, @{"CreateMemPool()" LINK "CreateMemPool"}, DeleteMemPool()

@ENDNODE
@NODE "DeleteSignalSemaphore" "joinOS.library/DeleteSignalSemaphore()"
@{b}

 NAME@{ub}
        DeleteSignalSemaphore - destroy a SignalSemaphore@{b}

 SYNOPSIS@{ub}
        void DeleteSignalSemaphore (struct SignalSemaphore *)
        DeleteSignalSemaphore (sigSem)
                                 A0@{b}

 FUNCTION@{ub}
        This functions destroys a SignalSemaphore previously allocated using
        @{"CreateSignalSemaphore()" LINK "CreateSignalSemaphore"}. This function is new for every system, but should
        be used for writing portable code.

        Only the task that has created the semaphore should destroy it, otherwise
        you will have problems under Windoof.@{b}

 INPUT@{ub}
        sigSem - the SignalSemaphore to be destroyed.@{b}

 NOTE@{ub}
        If you destroy a semaphore by your own, you have to take care that
        noone else accesses it while you destroy it. And take care that you close
        the Windoof semaphore handle, stored in the ss_Sem field. THIS COULD NOT
        BE DONE IN COMPATIBLE CODE.@{b}

 SPECIAL NOTE@{ub}
        If you previously created a local (nameless) semaphore using
        @{"CreateSignalSemaphore()" LINK "CreateSignalSemaphore"} and have made it public ba adding a name on your
        own to 'sigSem->ss_Link.ln_Name', you have to remove the semaphore by
        your own from the systems list (RemSemaphore()) and clear this pointer
        before you call this function (sigSem->ss_Link.ln_Name = NULL) or the
        buffer the name is located in will be freed using:

           FreeMem (sigSem->ss_Link.ln_Name, strlen (sigSem->ss_Link.ln_Name)+1);

        If you haven't allocated the name buffer in a according way, this will
        result in a system crash.@{b}

 SEE ALSO@{ub}
        @{"CreateSignalSemaphore()" LINK "CreateSignalSemaphore"}

@ENDNODE
@NODE "Divs64" "joinOS.library/Divs64()"
@{b}

 NAME@{ub}
        Divs64 - a signed 64 bit integer division@{b}

 SYNOPSIS@{ub}
        void Divs64 (DOUBLELONG *, LONG)
        Divs64 (divident, divisor)
                   A0       D0@{b}

 FUNCTION@{ub}
        This function performs a division of a signed 64 bit integer through a
        32 bit signed integer. The result is also a signed 64 bit integer.@{b}

 INPUTS@{ub}
        divident - a pointer to the 64 bit signed integer, the divident of this
                    operation. The result of this function is stored in this
                    variable.
        divisor - the 32 bit signed integer used as divisor of the operation@{b}

 NOTE@{ub}
        If a division by zero occurs the division functions returns a result with
        all bits set, the caller of this functions should take care, that such a
        case never occures, because this result could also be produced by valid
        divisors (e.g. 0xFFFF FFFF FFFF FFFF / 1)@{b}

 SEE ALSO@{ub}
        @{"Adds64()" LINK "Adds64"}, @{"Divu64()" LINK "Divu64"}, @{"Mulu64()" LINK "Mulu64"}, @{"Muls64()" LINK "Muls64"}, @{"Neg64()" LINK "Neg64"}

@ENDNODE
@NODE "Divu64" "joinOS.library/Divu64()"
@{b}

 NAME@{ub}
        Divu64 - an unsigned 64 bit integer division@{b}

 SYNOPSIS@{ub}
        void Divu64 (DOUBLELONG *, ULONG)
        Divu64 (divident, divisor)
                   A0       D0@{b}

 FUNCTION@{ub}
        This function performs a division of an unsigned 64 bit integer through
        32 bit unsigned integer. The result is also an unsigned 64 bit integer.@{b}

 INPUTS@{ub}
        divident - a pointer to the 64 bit unsigned integer, the divident of this
                    operation. The result of this function is stored in this
                    variable.
        divisor - the 32 bit unsigned integer used as divisor of the operation@{b}

 NOTE@{ub}
        If a division by zero occurs the division functions returns a result with
        all bits set, the caller of this functions should take care, that such a
        case never occures, because this result could also be produced by valid
        divisors (e.g. 0xFFFF FFFF FFFF FFFF / 1)@{b}

 SEE ALSO@{ub}
        @{"Adds64()" LINK "Adds64"}, @{"Divs64()" LINK "Divs64"}, @{"Mulu64()" LINK "Mulu64"}, @{"Muls64()" LINK "Muls64"}, @{"Neg64()" LINK "Neg64"}

@ENDNODE
@NODE "DoDosPkt" "joinOS.library/DoDosPkt()"
@{b}

 NAME@{ub}
        DoDosPkt - send a packet synchronously (i.e. wait for the reply)@{b}

 SYNOPSIS@{ub}
        LONG DoDosPkt (struct MsgPort*, LONG, LONG, LONG, LONG, LONG, LONG)
        result = DoDosPkt (mp, type, arg1, arg2, arg3, arg4, arg5)
          D0               D1   D2    D3    D4    D5    D6    D7@{b}

 FUNCTION@{ub}
        DoPkt() sends a packet to a port (usually that of a handler process),
        waits for the reply and returns both the primary and the secondary result
        to the caller. Depending on whether DoPkt() has been invoked from a
        processor or from a task environment, the secondary result is returned in
        IoErr() or under AmigaOS in register D1, under other systems it is not
        returned !
        If more than five packet parameters must be passed, one should use the
        functions SendPkt() and WaitPkt() instead of DoPkt().

        Even though the dos.library attempts to temporary allocate the resources
        required to make this function usable from a task, DoPkt() should -
        contrary to the official documentation - never be called from anything
        but a process, since DoPkt() does not know about the handler- and packet-
        specific value returned in dp_Res1 in the event of failure.

        For processes pr_MsgPort is used as the reply port, so calling DoPkt()
        or any other synchronous packet function while asynchronous packets with
        a reply port of pr_MsgPort are still pending is likely to crash the
        system with an AN_AsyncPkt Guru message.@{b}

 INPUTS@{ub}
        mp - a pointer to the port, the packet should be send to.
        type - the action (dp_Type) e.g. ACTION_FINDINPUT.
        arg1...arg5 - packet parameters dp_Arg1 to dp_Arg5@{b}

 RESULT@{ub}
        The primary result (dp_Res1) of the I/O is returned, if the calling
        instance is a process, the secondary result (dp_Res2) is returned in
        IoErr().@{b}

 SEE ALSO@{ub}
        @{"AbortDosPkt()" LINK "AbortDosPkt"}, @{"SendDosPkt" LINK "SendDosPkt"}, @{"ReplyDosPkt" LINK "ReplyDosPkt"}, @{"WaitDosPkt()" LINK "WaitDosPkt"}

@ENDNODE
@NODE "ErrorText" "joinOS.library/ErrorText()"
@{b}

 NAME@{ub}
        ErrorText - get the descriptive text to an errorcode@{b}

 SYNOPSIS@{ub}
        LONG ErrorText (LONG, STRPTR, STRPTR, LONG)
        bytescopied =  ErrorText (code, text, buffer, bufsize)
            D0                     D1    D2     D3       D4@{b}

 FUNCTION@{ub}
        Convert an (AmigaDOS) error code into a descriptive text.
        This is the Windoof-version, it also converts the Windoof
        error codes into a descriptive text using FormatMessage().
        The resulting text shouldn't be longer than @{"FAULT_MAX" LINK "include/AmigaDOS.h/File" 393} chars
        (defined in <dos/dos.h> or "AmigaDOS.h").@{b}

 INPUTS@{ub}
        code - the error number, which errortext is requested, if the errorcode
               isn't known, the text "Error <code>" is returned
        text - a preceding text, copied before the error text followed by a
               colon. If the is NULL nothing precedes the error text.
        buffer - the buffer where the error text should be copied to.
        bufsize - the bytesize of the buffer.@{b}

 RESULT@{ub}
        The function should return the number of bytes copied to the buffer,
        which will be 0 if an errorcode of 0 is passed.@{b}

 BUGS@{ub}
        The Amiga Guru Book says: The returncode is unusable, but the official
        documentation doesn't reports this bug !
        In older official documentation, this returnvalue was shown as BOOL,
        this was incorrect, it always returned the length.@{b}

 SEE ALSO@{ub}
        @{"PrintError()" LINK "PrintError"}, @{"ReportError()" LINK "ReportError"}, @{"SetIOErr()" LINK "SetIOErr"}, <joinOS/dos/AmigaDOS.h>

@ENDNODE
@NODE "ExamineAll" "joinOS.library/ExamineAll()"
@{b}

 NAME@{ub}
        ExamineAll - Examine an entire directory.@{b}

 SYNOPSIS@{ub}
            LONG ExamineAll (@{"BPTR" LINK "include/AmigaDOS.h/File" 126}, @{"struct ExAllData" LINK "include/AmigaDOS.h/File" 257}*, ULONG, ULONG, @{"struct ExAllControl" LINK "include/AmigaDOS.h/File" 282}*
        )
            success = ExamineAll (fl, buffer, bufSize, type, exAllControl)
              D0                  D1    D2      D3      D4       D5@{b}

 FUNCTION@{ub}
        ExamineAll() is the function replacement for ExAll(), which is called,
        if a dos.library with a Version < 36 is found in the system, or if the
        called handler failed with @{"ERROR_ACTION_NOT_KNOWN" LINK "include/AmigaDOS.h/File" 351}.
        See ExAll() for a description of this function.@{b}

 INPUTS@{ub}
        fl - a @{"BPTR" LINK "include/AmigaDOS.h/File" 126} to the FileLock of the directory that should be
              examined. If the Lock is not a directory, @{"DOSFALSE" LINK "include/AmigaDOS.h/File" 91} is returned
              and an IoErr() of @{"ERROR_INVALID_LOCK" LINK "include/AmigaDOS.h/File" 353} is set.
        buffer - the buffer where the ExAllData structures should be stored in.
              (MEMF_PUBLIC, MUST be at least WORD-aligned, preferably long-word
              aligned)
        bufSize - the byte size of the buffer. If the desired buffer is to small
              to hold a single directory entry the ExAll() function will NEVER
              return @{"DOSFALSE" LINK "include/AmigaDOS.h/File" 91}.
        type - the type of data that should be received (See "AmigaDOS.h").
        exAllControl - the structure used to control ExAll(), it must be allocated
              using AllocDosObject (@{"DOS_EXALLCONTROL" LINK "include/AmigaDOS.h/File" 492},NULL) and all fields must be
              initialized properly before the first call to ExAll(). Don't alter
              the fields of the structure between subsequent calls to ExAll().@{b}

 RESULT@{ub}
        If the function succeeds, either @{"DOSTRUE" LINK "include/AmigaDOS.h/File" 90} is returned or @{"DOSFALSE" LINK "include/AmigaDOS.h/File" 91} and a
        secondary result (IoErr()) equal to @{"ERROR_NO_MORE_ENTRIES" LINK "include/AmigaDOS.h/File" 371}.
        If the function fails, @{"DOSFALSE" LINK "include/AmigaDOS.h/File" 91} is returned and a secondary result not
        equal to @{"ERROR_NO_MORE_ENTRIES" LINK "include/AmigaDOS.h/File" 371}.@{b}

 NOTE@{ub}
        The filtering by using the eac_MatchFunc call-back function is currently
        not implemented.@{b}

 SEE ALSO@{ub}
        @{"ExamineAllEnd()" LINK "ExamineAllEnd"}

@ENDNODE
@NODE "ExamineAllEnd" "joinOS.library/ExamineAllEnd()"
@{b}

 NAME@{ub}
        ExamineAllEnd - Stop an @{"ExamineAll" LINK "ExamineAll"}@{b}

 SYNOPSIS@{ub}
            void ExamineAllEnd (@{"BPTR" LINK "include/AmigaDOS.h/File" 126}, @{"struct ExAllData" LINK "include/AmigaDOS.h/File" 257}*, ULONG, ULONG, struct ExAllContr
        ol*)
            ExamineAllEnd (fl, buffer, bufSize, type, exAllControl)
                           D1    D2      D3      D4       D5@{b}

 FUNCTION@{ub}
        Stops an @{"ExamineAll()" LINK "ExamineAll"} on a directory before it hits NO_MORE_ENTRIES.
        The full set of arguments that has been passed to @{"ExamineAll()" LINK "ExamineAll"} must be
        passed to ExamineAllEnd(), so it can handle filesystems that can't abort
        an @{"ExamineAll()" LINK "ExamineAll"} directly.@{b}

 INPUTS@{ub}
            fl       - a @{"BPTR" LINK "include/AmigaDOS.h/File" 126} to the FileLock, previously passed to @{"ExamineAll()" LINK "ExamineAll"}.
            buffer   - a pointer to the buffer for the data to be returned (MUST be
                        at least WORD-aligned, preferably long-word aligned).
            bufSize  - the byte-size of the buffer
            type     - type of date to be returned as previously passed to @{"ExamineAll()" LINK "ExamineAll"}.
            exAllControl - a pointer to the ExAllControl-structure used for @{"ExamineAll()" LINK "ExamineAll"}
        .@{b}

 SEE ALSO@{ub}
        @{"ExamineAll()" LINK "ExamineAll"}

@ENDNODE
@NODE "FillMem" "joinOS.library/FillMem()"
@{b}

 NAME@{ub}
        FillMem - fill a block of memory with a specified byte-value@{b}

 SYNOPSIS@{ub}
        void FillMem (APTR, ULONG, UBYTE)
        FillMem (mem, size, byte)
                 A0    D0   d1:8@{b}

 FUNCTION@{ub}
        This function fills a block of memory with the specified value.
        This means every byte in the block of memory get the specified value.
        It can deal with arbitrary length, with its pointers on arbitrary
        alignments.
        The internal implementation of this function will change from system to
        system, and may be implemented via hardware DMA.@{b}

 INPUTS@{ub}
        mem   - a pointer to the data region that should be filled.
        size  - the size (in bytes) of the memory area. Zero fills zero bytes.
        byte - the value that should be copied into every byte of the memory@{b}

 SEE ALSO@{ub}
        @{"ClearMem()" LINK "ClearMem"}

@ENDNODE
@NODE "FilterChangeTags" "joinOS.library/FilterChangeTags()"
@{b}

 NAME@{ub}
        FilterChangeTags - eliminate tags which specify no change@{b}

 SYNOPSIS@{ub}
        void FilterChangeTags(struct TagItem *, struct TagItem *, ULONG)
        FilterChangeTags(changeList, originalList, apply)
                          A0          A1         D0@{b}

 FUNCTION@{ub}
        This function goes through changeList. For each item found in
        changeList, if the item is also present in originalList, and their
        data values are identical, then the tag is removed from changeList.
        If the two tag's data values are different and the 'apply' value is
        non-zero, then the tag data in originalList will be updated to match
        the value from changeList.@{b}

 INPUTS@{ub}
        changeList - list of new tags (may be NULL)
        originalList - a list of existing tags (may be NULL)
        apply - boolean specification as to whether the data values in
                 originalList are to be updated to the data values in
                 changeList.@{b}

 EXAMPLE@{ub}
        Assume you have an attribute list for an object (originalList)
        which looks like this:

           {ATTR_Size,  "large"},
           {ATTR_Color, "orange"},
           {ATTR_Shape, "square"}

        If you receive a new tag list containing some changes (changeList),
        which looks like this:

           {ATTR_Size,  "large"},
           {ATTR_Shape, "triangle"}

        If you call FilterChangeTags(), changeList will be modified to
        contain only those attributes which are different from those
        in originalList. All other items will have their tag values set to
        TAG_IGNORE. The resulting changeList will become:

           {TAG_IGNORE, "large"},
           {ATTR_Shape, "triangle"}

        If 'apply' was set to 0, originalList would be unchanged. If 'apply'
        was non-zero, originalList would be changed to:

           {ATTR_Size,  "large"},
           {ATTR_Color, "orange"},
           {ATTR_Shape, "triangle"}@{b}

 SEE ALSO@{ub}
        <joinOS/misc/tagitem.h>, @{"ChangeTagList()" LINK "ChangeTagList"}

@ENDNODE
@NODE "FilterTagList" "joinOS.library/FilterTagList()"
@{b}

 NAME@{ub}
        FilterTagList - remove selected items from a tag list@{b}

 SYNOPSIS@{ub}
        ULONG FilterTagList (struct TagItem *, Tag *, ULONG)
        numValid = FilterTagList (tagList, filterArray, logic)
          D0                        A0         A1        D0@{b}

 FUNCTION@{ub}
        Removes tag items from a tag list (by changing ti_Tag to
        TAG_IGNORE) depending on whether its ti_Tag value is
        found in an array of tag values.

        If the 'logic' parameter is TAGFILTER_AND, then all items
        not appearing in 'tagArray' are excluded from 'tagList'.

        If 'logic' is TAGFILTER_NOT, then items not found in 'tagArray'
        are preserved, and the ones in the array are cast out.@{b}

 INPUTS@{ub}
        tagList  - input list of tag items which is to be filtered by having
                   selected items changed to TAG_IGNORE.
        filterArray - an array of tag values, terminated by TAG_DONE, as
                    specified in the documentation for TagInArray().
        logic - specification whether items in 'tagArray' are to be included
              or excluded in the filtered result.@{b}

 RESULTS@{ub}
        numValid - number of valid items left in resulting filtered list.@{b}

 SEE ALSO@{ub}
        <utility/tagitem.h>, @{"TagIsInArray()" LINK "TagIsInArray"}

@ENDNODE
@NODE "FindArgument" "joinOS.library/FindArgument()"
@{b}

 NAME@{ub}
        FindArgument - search a template string for a keyword@{b}

 SYNOPSIS@{ub}
        LONG FindArgument (STRPTR, STRPTR)
        argNum = FindArgument (template, keyword)
          D0                      D1        D2@{b}

 FUNCTION@{ub}
        This function searches the specified keyword in the template string.
        The template string is a sequence of comma-separated keywords the second
        string is matched against. If the keyword is found, the index of it in
        the template string is returned.
        The following characters have special meanings within a template string
        and thus cannot be part of a keyword:
         - the comma (',') is used to separate keywords
         - the equal sign ('=') can be used to define aliases
         - everything beyond a slash ('/'), including the slash itself, up to the
           next comma (or up to the end of the template string) is ignored. This
           is used by @{"ParseArgs()" LINK "ParseArgs"} to store the template modifier as part of the
           template string.
        The string comparison is case-insensitive.@{b}

 INPUTS@{ub}
        template - a pointer to the template string (C string) to search keyword
                    in
        keyword - a pointer to the keyword of an argument as defined by the
                    template string@{b}

 RESULT@{ub}
        If the specified keyword could be found, the index of the respective
        keyword will be returned, zero being the first keyword, one the second,
        etc.;
        if the function fails to find the specified keyword in the template
        string, -1 is returned.@{b}

 SEE ALSO@{ub}
        @{"<joinOS/dos/rdArgs.h>" link "include/rdargs.h/Main"}, @{"ParseArgs()" LINK "ParseArgs"}, @{"FreeArguments()" LINK "FreeArguments"}, @{"ParseItem()" LINK "ParseItem"}

@ENDNODE
@NODE "FindDOSEntry" "joinOS.library/FindDOSEntry()"
@{b}

 NAME@{ub}
        FindDOSEntry - find an entry by name in the dos list@{b}

 SYNOPSIS@{ub}
        struct DosList *FindDOSEntry(struct DosList *, const char *, ULONG)
        entry = FindDOSEntry(Previous, Name, AccessFlags)
          D0                   D1       D2       D3@{b}

 FUNCTION@{ub}
        Find an entry by name in the list of devices, volumes and assignments.
        The function behaves similarly to NextDosEntry(), but it will return
        an entry only if its name (dol_Name) matches the one passed as second
        argument to this function.
        The DOS list must be locked for the specified type of entry using
        LockDosList() or AttemptLockDosList() before you call this function.

        Because these functions are not available under AmigaOS versions below
        v36 (2.0), you have to embed the parsing of the doslist by a Forbid()/
        Permit() pair. Copy the information you need from the doslist and free
        it as fast as possible, the buffer you use for copying should be
        allocated outside of the Forbid()/Permit() pair, because the allocation
        may break the forbidden state.@{b}

 INPUTS@{ub}
        Previous - the last processed Dos list entry as returned by a previous
                 call to FindDosEntry() or NextDosEntry() or the value returned
                 by a successful AttemptLockDosEntry() or LockDosEntry().
        Name     - the name of the searched entry (NUL-terminated C-string)
        AccessFlags - the type of entry that is searched, be shure that the DOS
                 list is locked for that type of entry.@{b}

 RESULT@{ub}
        If an entry with the specified name is found in the DOS list behind
        the previous found entry, a pointer to that entry is returned.
        If no matching entry is found, NULL is returned.@{b}

 SEE ALSO@{ub}
        @{"LockDOSList()" LINK "LockDOSList"}, @{"UnLockDOSList()" LINK "UnLockDOSList"}, @{"NextDOSEntry()" LINK "NextDOSEntry"}

@ENDNODE
@NODE "FindFirstMatch" "joinOS.library/FindFirstMatch()"
@{b}

 NAME@{ub}
        FindFirstMatch - find the first object matching a specified pattern@{b}

 SYNOPSIS@{ub}
        errorcode = FindFirstMatch (pattern, anchor)
           D0                         D1       D2
        LONG FindFirstMatch (STRPTR, @{"struct AnchorPath" LINK "include/MatchPattern.h/File" 127} *)@{b}

 FUNCTION@{ub}
        This function - in conjunction witch MatchNext() -  searches in the
        directory-tree of a volume for all filesystem objects that match the
        specified pattern.
        This way it's easy to access all matching objects without the need of
        recursive programming.

        When an application is done using MatchFirst() and MatchNext(),
        it must call MatchEnd(), even if an error has occured.@{b}

 INPUTS@{ub}
        pattern  - the pattern that should be looked out for. A pattern string
           is any AmigaDos filesystem-path that could include wildcards
           (e.g. "Dh0:foo/#?"). The patterns are parsed on a per-directory-level,
           so it is not possible to make a directory separator partof a pattern-
           expression (e.g. "(#?|#?/#?)").
           If the pattern includes a volume name, the volume name must not
           include any pattern, if no volume is specified, the current directory
           is the root-directory of the search.
           In opposite to the AmigaDOS pattern matching functions, the asterisk
           is NEVER accepted as the universal wild card.
        anchor   - a pointer to a user-allocated and initialized AnchorPath
           structure. Since it contains a FileInfoBlock structure it must be
           longword aligned.
           The following fields of the AnchorPath structure must be initialized:
              ap_Flags - set to @{"APF_FollowHLinks" LINK "include/MatchPattern.h/File" 171} if hard links to directories
                 (which might cause a program without further checks to loop
                 endlessly) should be followed. Otherwise set this field to 0.
              ap_BreakBits - set this field to the breakbits  (SIGBREAKF_CTRL_?)
                 that you want to take a break on, or 0L, if you don't want to
                 convenience the user.
              ap_Strlen - If you need the full path of the found objects, you
                 must allocate a buffer at the end of this structure (allocate
                 sizeof (@{"struct AnchorPath" LINK "include/MatchPattern.h/File" 127}) + buffersize) and put the size of the
                 buffer into this field, If you don't want the full path name,
                 make sure you set ap_Strlen to zero.  In this case, the name of
                 the file, and stats are available in the ap_Info, as per usual.
              ap_FoundBreak - should be set to zero, if this field is required
                 by the application.
              The reserved fields should be initialized with zero, so it's best
              to allocate this structure with the MEMF_CLEAR specifier.@{b}

 RESULT@{ub}
        The function returnes the AmigaDos errorcode of an error that prevents
        the parsing of the volumes-tree, or 0 in the event of success.
        If no object matching the specified pattern could be found
        @{"ERROR_OBJECT_NOT_FOUND" LINK "include/AmigaDOS.h/File" 348} or @{"ERROR_NO_MORE_ENTRIES" LINK "include/AmigaDOS.h/File" 371} is returned.
        If the pattern does only specify a single file (pattern without wildcards)
        which couldn't be locked shared, @{"ERROR_OBJECT_IN_USE" LINK "include/AmigaDOS.h/File" 345} is returned.
        If the pattern is too complex to be parsed, @{"ERROR_TOO_MANY_LEVELS" LINK "include/AmigaDOS.h/File" 359} is set.
        If the pattern is illegal (e.g. missing a closing bracket or a separator
        is part of a pattern expression "(#?/#?)" @{"ERROR_BAD_TEMPLATE" LINK "include/AmigaDOS.h/File" 335} is returned.

        Every other errorcode (like @{"ERROR_NO_FREE_STORE" LINK "include/AmigaDOS.h/File" 333}) that could occure by
        using Lock(), Examine(), or ExNext() could also be returned.

        If the returned value is 0, the matching object could be accessed using
        the directory lock <anchor->ap_Current->an_Lock> and the filename found
        in <anchor->ap_Info.fib_FileName>.@{b}

 SEE ALSO@{ub}
        @{"FindNextMatch()" LINK "FindNextMatch"}, @{"FindMatchEnd()" LINK "FindMatchEnd"}

@ENDNODE
@NODE "FindMatchEnd" "joinOS.library/FindMatchEnd()"
@{b}

 NAME@{ub}
        FindMatchEnd - deallocate all resources used for matching@{b}

 SYNOPSIS@{ub}
        void FindMatchEnd (@{"struct AnchorPath" LINK "include/MatchPattern.h/File" 127} *)
        FindMatchEnd (anchor)
                        D1@{b}

 FUNCTION@{ub}
        This function dealloctes all resources that have been allocated by the
        functions MatchFirst() and MatchNext() during previous calls to them.
        The AnchorPath structure itself remains valid, but must be reinitialized
        before it can be reused.
        All locks that are done by MatchFirst() and MatchNext() are
        unlocked with this function, so be shure that you don't use them any
        more.@{b}

 INPUT@{ub}
        anchor - the AnchorPath structure used during MatchFirst and MatchNext@{b}

 SEE ALSO@{ub}
        @{"FindFirstMatch()" LINK "FindFirstMatch"}, @{"FindNextMatch()" LINK "FindNextMatch"}

@ENDNODE
@NODE "FindNextMatch" "joinOS.library/FindNextMatch()"
@{b}

 NAME@{ub}
        FindNextMatch - find the next matching filesystem object@{b}

 SYNOPSIS@{ub}
        LONG FindNextMatch (@{"struct AnchorPath" LINK "include/MatchPattern.h/File" 127} *)
        error = FindNextMatch (anchor)
          D0                    D1@{b}

 FUNCTION@{ub}
        This function searches the next filesystem object that matches the
        pattern passed previously to MatchFirst()
        If the last returned object was a directory and you want to process
        all object in that directory you must set the flag ADF_DODIR (by
        "or"ing it in: "anchor->ap_Flags |= ADF_DODIR"). This flag is cleared
        after every call to this function.
        Because hardlinks may produce endless loops, if they are followed, it
        must be explicitly sayed that they should be followed by setting the
        flag ADF_FollowHLinks.
        Softlinks to directories are not processed by this function.@{b}

 INPUT@{ub}
        anchor - a pointer to the AnchorPath structure that was used for a
                 previous call to MatchFirst().@{b}

 RESULT@{ub}
        If the function succeed and another matching object could be found, zero
        is returned. If not another matching object could be found,
        @{"ERROR_NO_MORE_ENTRIES" LINK "include/AmigaDOS.h/File" 371} is returned.
        Use the lock <anchor->ap_Current->an_Lock> to access the directory the
        object is found in, and <anchor->ap_Info.fib_FileName> to access the
        object.
        If entered (by setting the flag @{"APF_DODIR" LINK "include/MatchPattern.h/File" 154}), directory style objects are
        returned twice, before entering the directory and after all entries in
        that directory are done, so you are able to handle the directory before
        you process the contents of it, and after you done processing the entries
        in that directory.
        The second time a directory object is returned the flag ADF_DIDDIR is set.@{b}

 NOTE@{ub}
        It might produce unpredictable results if you call this function after a
        previous call to this or to MatchFirst() fails with any other error
        than @{"ERROR_OBJECT_NOT_FOUND" LINK "include/AmigaDOS.h/File" 348}, @{"ERROR_NO_MORE_ENTRIES" LINK "include/AmigaDOS.h/File" 371}, or @{"ERROR_NO_FREE_STORE" LINK "include/AmigaDOS.h/File" 333}
        So you better avoid calling this function after any failure.
        But nevertheless don't forget to call MatchEnd() after you are done
        using these function.@{b}

 BUGS@{ub}
        The function may return wrong full paths to the found objects, if the
        volumes directory tree is changed between the call to MatchFirst()
        and MatchEnd(), which could be done by renaming or moving a directory
        that is one of the parents of the processed directories, so you should
        only use this names (anchor->an_Buf) for statistical purpose.@{b}

 SEE ALSO@{ub}
        @{"FindFirstMatch()" LINK "FindFirstMatch"}, @{"FindMatchEnd()" LINK "FindMatchEnd"}

@ENDNODE
@NODE "FindTag" "joinOS.library/FindTag()"
@{b}

 NAME@{ub}
        FindTag - scan a tag list for a specific tag@{b}

 SYNOPSIS@{ub}
        struct TagItem *FindTag (Tag,struct TagItem *)
        tag = FindTag (tagValue, tagList)
         D0               D0        A0@{b}

 FUNCTION@{ub}
        Scans a tag list and returns a pointer to the first item with
        ti_Tag matching the 'tagValue' parameter.@{b}

 INPUTS@{ub}
        tagValue - tag value to search for
        tagList  - tag item list to search (may be NULL)@{b}

 RESULTS@{ub}
        tag - a pointer to the item with ti_Tag matching 'tagValue' or NULL
              if no match was found.@{b}

 SEE ALSO@{ub}
        <joinOS/misc/tagitem.h>, @{"GetTagItem()" LINK "GetTagItem"}, @{"PackBooleanTags()" LINK "PackBooleanTags"}, @{"NextTag()" LINK "NextTag"}

@ENDNODE
@NODE "FreeArguments" "joinOS.library/FreeArguments()"
@{b}

 NAME@{ub}
        FreeArguments - free all allocated memory used for parsing arguments@{b}

 SYNOPSIS@{ub}
        void FreeArguments (@{"struct RDArgs" LINK "include/rdargs.h/File" 146} *)
        FreeArguments (rdArgs)
                        D1@{b}

 FUNCTION@{ub}
        Free the whole RDArgs structure.
        All entries and the strings allocated by @{"ParseArgs()" LINK "ParseArgs"} are freed.
        If the RDArgs structure itself was allocated by @{"ParseArgs()" LINK "ParseArgs"} it is also
        freed, else the user is responsible for freeing the RDArgs structure.@{b}

 INPUT@{ub}
        rdArgs - a pointer to the RDArgs structure as previously returned from
                  @{"ParseArgs()" LINK "ParseArgs"}@{b}

 RESULT@{ub}
        The function has no returncode, the whole ArgFormat structure is freed.
        Don't access this structure any more.@{b}

 NOTE@{ub}
        It is save to call this function with a NULL-pointer.@{b}

 SEE ALSO@{ub}
        @{"<joinOS/dos/rdArgs.h>" link "include/rdargs.h/Main"}, @{"ParseArgs()" LINK "ParseArgs"}

@ENDNODE
@NODE "FreeDOSObject" "joinOS.library/FreeDOSObject()"
@{b}

 NAME@{ub}
        FreeDOSObject - deallocate a dos specific structure@{b}

 SYNOPSIS@{ub}
        void FreeDOSObject (ULONG, void*)
        FreeDOSObject (Type, Object)
                        D1     D2@{b}

 FUNCTION@{ub}
        Deallocate a specific DOS structure previously allocated using
        AllocDosObject().
        All objects that are allocated using AllocDosObject() *MUST* be
        deallocated using this function.@{b}

 INPUTS@{ub}
        Type - specifies the type of object that should be deallocated, can be
              any of the following types:
           @{"DOS_FILEHANDLE" LINK "include/AmigaDOS.h/File" 491} - a FileHandle for use in file-I/O-functions.
           @{"DOS_FIB" LINK "include/AmigaDOS.h/File" 493}        - a FileInfoBlock as used for Examine() or ExNext().
           @{"DOS_EXALLCONTROL" LINK "include/AmigaDOS.h/File" 492} - a ExAllControl function as used for ExAll().
           @{"DOS_STDPKT" LINK "include/AmigaDOS.h/File" 494}     - a DosPacket for packed-oriented IO
           @{"DOS_CLI" LINK "include/AmigaDOS.h/File" 495}        - a CommandLineInterface structure
           @{"DOS_RDARGS" LINK "include/AmigaDOS.h/File" 496}     - a RDArgs structure
        Object - a pointer to the object that should be deallocated as previously
                 gotten from AllocDosObject().@{b}

 BUGS@{ub}
        Under AmigaOS the buffers cli_SetName, cli_CommandName, cli_CommandFile,
        and cli_Prompt of a CommandLineInterface structure are NOT freed.@{b}

 SEE ALSO@{ub}
        @{"AllocDOSObject()" LINK "AllocDOSObject"}

@ENDNODE
@NODE "FreePoolMem" "joinOS.library/FreePoolMem()"
@{b}

 NAME@{ub}
        FreePoolMem - put a memory block back into the pool@{b}

 SYNOPSIS@{ub}
        void FreePoolMem (void *, void *, ULONG)
        FreePoolMem (PoolHeader, mem, size)
                        A0       A1    D0@{b}

 FUNCTION@{ub}
        Put a memory block previous gotten with @{"AllocPoolMem()" LINK "AllocPoolMem"} back to the memory
        pool. If an aditional puddle, the memory belonged to, isn't used any more,
        the puddle is removed and the memory of that puddle is freed.@{b}

 INPUTS@{ub}
        PoolHeader - the pointer to the pool header as returned from
                @{"CreateMemPool()" LINK "CreateMemPool"}.
        mem - a pointer to the memory previousle allocated with @{"AllocPoolMem()" LINK "AllocPoolMem"}.
                NEVER EVER try to put memory back to the pool that wasn't allocated
                using @{"AllocPoolMem()" LINK "AllocPoolMem"}.
        size - the size of the returned memory block in bytes. Freeing partial
                blocks of memory is "unwise", it may not work on AmigaOS V39 and
                above, and you should notice that memory blocks are always longword
                aligned (position and size of the blocks).@{b}

 SEE ALSO@{ub}
        @{"AllocPoolMem()" LINK "AllocPoolMem"}, @{"CreateMemPool()" LINK "CreateMemPool"}, @{"DeleteMemPool()" LINK "DeleteMemPool"}

@ENDNODE
@NODE "FreeTagList" "joinOS.library/FreeTagList()"
@{b}

 NAME@{ub}
        FreeTagList - free an allocated tag list@{b}

 SYNOPSIS@{ub}
        void FreeTagList (struct TagItem *)
        FreeTagList (tagList)
                       A0@{b}

 FUNCTION@{ub}
        Frees the memory of a TagItem list allocated either by
        @{"AllocateTagList()" LINK "AllocateTagList"} or @{"CloneTagList()" LINK "CloneTagList"}.@{b}

 INPUTS@{ub}
        tagList - list to free, must have been obtained from
                   @{"AllocateTagList()" LINK "AllocateTagList"} or @{"CloneTagList()" LINK "CloneTagList"} (may be NULL)@{b}

 SEE ALSO@{ub}
        <joinOS/misc/tagitem.h>, @{"AllocateTagList()" LINK "AllocateTagList"}, @{"CloneTagList()" LINK "CloneTagList"}

@ENDNODE
@NODE "FreeVector" "joinOS.library/FreeVector()"
@{b}

 NAME@{ub}
        FreeVector - free a memory block, allocated by AllocVec()@{b}

 SYNOPSIS@{ub}
        void FreeVector(APTR)
        FreeVector(mem)
                    A0@{b}

 FUNCTION@{ub}
        This functions frees the memory previously allocated using AllocVec().@{b}

 INPUT@{ub}
        mem - pointer to the memory block that should be freed.@{b}

 SEE ALSO@{ub}
        @{"AllocVector()" LINK "AllocVector"}

@ENDNODE
@NODE "GetSysBase" "joinOS.library/GetSysBase()"
@{b}

 NAME@{ub}
        GetSysBase - Get the address of Execs library node@{b}

 SYNOPSIS@{ub}
        SysBase = GetSysBase ()
        struct ExecBase *GetSysBase (void)@{b}

 FUNCTION@{ub}
        This function returns the address, where the Exec library base is found
        in memory.@{b}

 RESULT@{ub}
        The address of the Exec library base is returned.@{b}

 NOTE@{ub}
        This function is implemented as macro for Amiga systems.

@ENDNODE
@NODE "GetTagItem" "joinOS.library/GetTagItem()"
@{b}

 NAME@{ub}
        GetTagItem - obtain the data corresponding to a tag.@{b}

 SYNOPSIS@{ub}
        ULONG GetTagItem (Tag, ULONG, struct TagItem *)
        value = GetTagItem (tagValue, defaultVal, tagList)
          D0                   D0          D1       A0@{b}

 FUNCTION@{ub}
        Searches a tag list for a matching tag, and returns the
        corresponding ti_Data value for the TagItem found. If no match is
        found, this function returns the value passed in as 'default'.@{b}

 INPUTS@{ub}
        tagValue - tag value to search for.
        defaultVal - value to be returned if tagValue is not found.
        tagList - the tag list to search.@{b}

 RESULTS@{ub}
        value - the ti_Data value for the first matching TagItem, or 'default'
                 if a ti_Tag matching 'Tag' is not found.@{b}

 SEE ALSO@{ub}
        <joinOS/misc/tagitem.h>, @{"FindTag()" LINK "FindTag"}, @{"PackBooleanTags()" LINK "PackBooleanTags"}, @{"NextTag()" LINK "NextTag"}

@ENDNODE
@NODE "IsAmigaDosError" "joinOS.library/IsAmigaDosError()"
@{b}

 NAME@{ub}
        IsAmigaDosError - determine if an errorcode is a valid AmigaDos errorcode@{b}

 SYNOPSIS@{ub}
        BOOL IsAmigaDosError(LONG)
        amigaError = IsAmigaDosError(ec)@{b}

 FUNCTION@{ub}
        This macro checks, wheather a given error number is an AmigaDOS error
        code or a system dependent (Windoof) error code.
        This macro is usefull to determine, if the occured error is an error
        that could be handled by an application. Every system dependent error
        that is expected by the joinOS.library, is converted to an AmigaDOS
        error code, so you are able to write system independent error-handling
        function.
        If this function returns FALSE, the occured error hasn't been expected
        by the joinOS.library and therefor you could be shure, it's a hard
        error that could be displayed to the user, but not be handled without
        the users choise.@{b}

 INPUT@{ub}
        ec - an error number as returned by Ioerr()@{b}

 RESULT@{ub}
        TRUE -> if the error number belongs to an AmigaDOS error code.
        FALSE -> if the error number belongs to a system (Windoof) specific
        error code.@{b}

 SEE ALSO@{ub}
        <joinOS/dos/AmigaDOS.h>

@ENDNODE
@NODE "IsValidDate" "joinOS.library/IsValidDate()"
@{b}

 NAME@{ub}
        IsValidDate - Check if a DateStamp contains a valid date.@{b}

 SYNOPSIS@{ub}
        BOOL IsValidDate(@{"struct DateStamp" LINK "include/AmigaDOS.h/File" 147} *)
        success IsValidDate (ds)@{b}

 FUNCTION@{ub}
        Test whether a given DateStamp structure holds a valid date or not.
        It is only testet if every value of the structure is greater or equal to
        null and that at least one value is greater then null.@{b}

 INPUT@{ub}
        ds - a pointer to the DateStamp structure which contents should be testet@{b}

 RESULT@{ub}
        boolean, TRUE if the structure contains a valid date, FALSE if not.@{b}

 SEE ALSO@{ub}
        @{"Date2Str()" LINK "Date2Str"}

@ENDNODE
@NODE "IsValidMemList" "joinOS.library/IsValidMemList()"
@{b}

 NAME@{ub}
        IsValidMemList - check the returnvalue of AllocEntry()@{b}

 SYNOPSIS@{ub}
        BOOL IsValidMemList (struct MemList *);

        succeed = IsValidMemList (memList);@{b}

 FUNCTION@{ub}
        Because of the different return values - returned by AllocEntry() under
        the different systems that indicates failure, you should use this macro
        to test the result of the function AllocEntry() to write compatible code.@{b}

 INPUT@{ub}
        memList - a pointer to a MemList structure as returned by AllocEntry().@{b}

 RESULT@{ub}
        A boolean value indicating that the MemList structure is a valid MemList
        structure is returned.
        If TRUE is returned, AllocEntry() has succeed, else AllocEntry() failed
        and memList is the requirement that failed (something like MEMF_CHIP or
        MEMF_FAST etc.).@{b}

 EXAMPLE@{ub}
       if (IsValidMemList(memlist = AllocEntry (aMemList)))
       {
          // succeed
       }
       else
       {
          // failure, memlist is the type of memory we failed to allocate
       }

@ENDNODE
@NODE "LockDOSList" "joinOS.library/LockDOSList()"
@{b}

 NAME@{ub}
        LockDOSList - wait for access to the dos list@{b}

 SYNOPSIS@{ub}
        struct DosList *LockDOSList (ULONG)
        initialValue = LockDOSList (AccessFlags)
             D0                         D1@{b}

 FUNCTION@{ub}
        Try to gain access to the list of devices, volumes and assignments.
        If the function succeeds, no real pointer to a DosList node is returned,
        but just an initial value usable for FindDosEntry(), NextDosEntry().
        If the desired type of entry, with the desired type of access isn't
        available, the function will wait until it gets access. (Be careful
        not to produce deadlocks).
        After you finished parsing the DOS list you have to call UnLockDosList(),
        to free the DOS list again.
        DON'T CALL ANY IO-FUNCTION WHILE YOU HOLD THE LOCK OF THE DOS LIST, OR
        THE PROGRAM COULD END IN A DEADLOCK.@{b}

 INPUTS@{ub}
        AccessFlags - Flags specifying the type of entry that should be locked
                       and the type of lock that should be used:

        Any combination of the type of entry is possible:
           LDF_DEVICES - the list of devices should be locked
           LDF_VOLUMES - the list of volumes should be locked
           LDF_ASSIGNS - the list of assignments should be locked.
           LDF_ALL - shortcut for: LDF_DEVICES | LDF_VOLUMES | LDF_ASSIGNS

        One of the lock specifier must be used:
           LDF_READ    - read (shared) access to the DOS list entries.
           LDF_WRITE   - write (exclusive) access to the DOS list entries.@{b}

 RESULT@{ub}
        An initial value for use in NextDosEntry() or FindDosEntry() is returned.@{b}

 NOTE@{ub}
        Since there is no way to lock the DosList under AmigaOS 1.3 (v34), the
        functions LockDOSList() and @{"UnLockDOSList()" LINK "UnLockDOSList"} are implemented as
        Forbid()/Permit() pair for these systems, so it is incredibly important
        to unlock the DosList as fast as possible, because the multitasking is
        disabled while the list is locked.@{b}

 SEE ALSO@{ub}
        @{"UnLockDOSList()" LINK "UnLockDOSList"}, @{"FindDOSEntry()" LINK "FindDOSEntry"}, @{"NextDOSEntry()" LINK "NextDOSEntry"}

@ENDNODE
@NODE "Long2Str" "joinOS.library/Long2Str()"
@{b}

 NAME@{ub}
        Long2Str - convert a decimal string to a long number@{b}

 SYNOPSIS@{ub}
        LONG Long2Str (LONG, char*)
        bytesCopied = Long2Str (Value, Buffer)
            D0                     D1     D2@{b}

 FUNCTION@{ub}
        This function converts a given long integer into a human-readable form.
        The LONG is stored as decimal string in the specified buffer. Be shure
        that there is enough space in the buffer to hold the number, otherwise
        you risk to meet the Guru.@{b}

 INPUTS@{ub}
        value  - a long integer value, to be converted into a string.
        buffer - the buffer where the resulting string should be stored.@{b}

 RESULT@{ub}
        If everything wents fine, the number of bytes copied to the buffer
        (without the terminating NUL-byte) is returned.@{b}

 SEE ALSO@{ub}
        @{"Str2Long()" LINK "Str2Long"}, @{"Date2Str()" LINK "Date2Str"}

@ENDNODE
@NODE "MakeUniqueName" "joinOS.library/MakeUniqueName()"
@{b}

 NAME@{ub}
        MakeUniqueName - create an unique name@{b}

 SYNOPSIS@{ub}
        void MakeUniqueName (UBYTE *, ULONG)
        MakeUniqueName (Buffer, Count)
                          A0     D0@{b}

 FUNCTION@{ub}
        This function can be used to create unique names. It copies a (unique)
        name, created using the (unique) count-value into a specified buffer.

        This function copies in a loop an ASCII-character generated from Count
        modulo 64 into the specified buffer, then it divides Count by 64 and does
        the next character until Count is zero.

        A terminating NUL is added to the string.@{b}

 INPUTS@{ub}
        Buffer - a pointer to the destination buffer for the unique name.
                 Take care that the buffer is large enough, at a maximum 7
                 characters are added to the buffer (incl. the terminating NUL).
        Count - the value used to generate the unique name. If you increase this
                 number after every call to this function, it can generate more
                 than 4 billion unique names.

@ENDNODE
@NODE "MapTagList" "joinOS.library/MapTagList()"
@{b}

 NAME@{ub}
        MapTagList - convert ti_Tag values in a list via map pairing.@{b}

 SYNOPSIS@{ub}
        void MapTagList (struct TagItem *, struct TagItem *, ULONG)
        MapTagList (tagList, mapList, mapType)
                      A0        A1       D0@{b}

 FUNCTION@{ub}
        Apply a "mapping list" mapList to tagList.

        If the ti_Tag field of an item in tagList appears as ti_Tag in some
        item in mapList, overwrite ti_Tag with the corresponding ti_Data
        from the map list.

        The mapType parameter specifies how the mapping operation is to
        proceed, with the following available types:

           MAP_REMOVE_NOT_FOUND
           If a tag in tagList does not appear in the mapList, remove
           it from tagList.

           MAP_KEEP_NOT_FOUND
           To have items which do not appear in the mapList survive the
           mapping process as-is.

        MapTags() is central to BOOPSI gadget interconnections where you want
        to convert the tag values from one space (the sender) to another (the
        receiver).

        The procedure will change the values of the input tag list
        tagList (but not mapList).

        You can "filter" a list by passing MAP_REMOVE_NOT_FOUND as mapType,
        and having the data items in mapList equal the corresponding tags.

        You can perform the inverse filter ("everything but") by passing
        a mapType of MAP_KEEP_NOT_FOUND, and creating a map item for every tag
        you want to filter out, pairing it with a mapped data value of
        TAG_IGNORE.

        For safety and "order independence" of tag item arrays, if you
        attempt to map some tag to the value TAG_DONE, the value TAG_IGNORE
        will be substituted instead.@{b}

 INPUTS@{ub}
        tagList  - input list of tag items which is to be mapped to tag values
                   as specified in mapList.
        mapList - a "mapping list" tag list which pairs tag values expected to
                   appear in tagList with new values to be substituted in the
                   ti_Tag fields of tagList (may be NULL)
        mapType - one of the available mapping types as defined in
                   <joinOS/misc/tagitem.h>@{b}

 EXAMPLE@{ub}
        /* Consider this source list: */
        struct TagItem list[] =
        {
           {MY_SIZE,   71},
           {MY_WEIGHT, 200},
           {TAG_DONE,  }
        };

        /* And the mapping list: */
        struct TagItem map[] =
        {
           {MY_SIZE,   HIS_TALL},
           {TAG_DONE,  }
         };

        /* Then after MapTagList(list,map,MAP_REMOVE_NOT_FOUND),
         * 'list' will become:
         */
           {HIS_TALL,71},
           {TAG_IGNORE,},
           {TAG_DONE,}

        /* Or after MapTagList (list,map,MAP_KEEP_NOT_FOUND),
         * 'list' will become:
         */
           {HIS_TALL,  71},
           {MY_WEIGHT, 200},
           {TAG_DONE,  }@{b}

 SEE ALSO@{ub}
        <joinOS/misc/tagitem.h>, @{"ChangeTagList()" LINK "ChangeTagList"}, @{"FilterChangeTags()" LINK "FilterChangeTags"}

@ENDNODE
@NODE "MoveMem" "joinOS.library/MoveMem()"
@{b}

 NAME@{ub}
        MoveMem - copy a block of memory@{b}

 SYNOPSIS@{ub}
        void MoveMem (APTR, APTR, ULONG)
        MoveMem (source, dest, length)@{b}

 FUNCTION@{ub}
        MoveMem is a general purpose, fast memory copy function. It can deal with
        arbitrary length, with its pointers on arbitrary alignments.

        The function can deal with arbitrary overlapping memory blocks.

        The internal implementation of this function will change from system to
        system, and may be implemented via hardware DMA.@{b}

 INPUTS@{ub}
        source   - a pointer to the source data region.
        dest     - a pointer to the destination data region.
        length   - the size (in bytes) of the memory area. Zero copies zero bytes.

@ENDNODE
@NODE "Muls64" "joinOS.library/Muls64()"
@{b}

 NAME@{ub}
        Muls64 - a multiplication of two signed 32 bit values@{b}

 SYNOPSIS@{ub}
        void Muls64 (LONG, LONG, DOUBLELONG *)
        Muls64 (arg1, arg2,result)
                 D0    D1    A0@{b}

 FUNCTION@{ub}
        This function performs a multiplication of two signed 32 bit integers.
        The result of this function is a signed 64 bit integer.@{b}

 INPUTS@{ub}
        arg1 - the first multiplicator, a  signed 32 bit integer
        arg2 - the second multiplicator, a signed 32 bit integer
        result - a pointer to a signed 64 bit integer, where the result of this
                 operation should be stored.@{b}

 SEE ALSO@{ub}
        @{"Adds64()" LINK "Adds64"}, @{"Divu64()" LINK "Divu64"}, @{"Divs64()" LINK "Divs64"}, @{"Mulu64()" LINK "Mulu64"}, @{"Neg64()" LINK "Neg64"}

@ENDNODE
@NODE "Mulu64" "joinOS.library/Mulu64()"
@{b}

 NAME@{ub}
        Mulu64 - a multiplication of two unsigned 32 bit values@{b}

 SYNOPSIS@{ub}
        void Mulu64 (ULONG, ULONG, DOUBLELONG *)
        Mulu64 (arg1, arg2,result)
                 D0    D1    A0@{b}

 FUNCTION@{ub}
        This function performs a multiplication of two unsigned 32 bit integers.
        The result of this function is a signed 64 bit integer.@{b}

 INPUTS@{ub}
        arg1 - the first multiplicator, an unsigned 32 bit integer
        arg2 - the second multiplicator, an unsigned 32 bit integer
        result - a pointer to an unsigned 64 bit integer, where the result of
                 this operation should be stored.@{b}

 NOTE@{ub}
        Because the result is stored as signed 64 bit integer, an overflow can
        occure, if both 32 bit integers are very large. In this case the result
        will bve a negative value. If this value is interpreted as unsigned
        value it contains the exact result.@{b}

 SEE ALSO@{ub}
        @{"Adds64()" LINK "Adds64"}, @{"Divu64()" LINK "Divu64"}, @{"Divs64()" LINK "Divs64"}, @{"Muls64()" LINK "Muls64"}, @{"Neg64()" LINK "Neg64"}

@ENDNODE
@NODE "Neg64" "joinOS.library/Neg64()"
@{b}

 NAME@{ub}
        Neg64 - negate a 64 bit value@{b}

 SYNOPSIS@{ub}
        void Neg64 (DOUBLELONG *)
        Neg64 (arg)
               A0@{b}

 FUNCTION@{ub}
        This function negates a 64 bit signed integer.@{b}

 INPUT@{ub}
        arg - a pointer to the 64 bit signed integer, the result of this
              function is stored in the integer (i.e. it is overwritten).@{b}

 SEE ALSO@{ub}
        @{"Adds64()" LINK "Adds64"}, @{"Divu64()" LINK "Divu64"}, @{"Divs64()" LINK "Divs64"}, @{"Mulu64()" LINK "Mulu64"}, @{"Muls64()" LINK "Muls64"}

@ENDNODE
@NODE "NextDOSEntry" "joinOS.library/NextDOSEntry()"
@{b}

 NAME@{ub}
        NextDOSEntry  - get next entry from the dos list@{b}

 SYNOPSIS@{ub}
        struct DosList *NextDOSEntry(struct DosList *, ULONG)
        nextEntry = NextDOSEntry(Previous, AccessFlags)
           D0                      D1          D2@{b}

 FUNCTION@{ub}
            Get next entry in the list of devices, volumes and assignments.
            NextDosEntry() traverses the DOS list, which must have been locked previousl
        y.
            The control flags specified must be a subset of the access flags specified
            during LockDosList() or AttemptLockDosList(); they determine what types of
            entries are to be returned.

            Because these functions are not available under AmigaOS versions below
            v36 (2.0), you have to embed the parsing of the doslist by a Forbid()/
            Permit() pair. Copy the information you need from the doslist and free
            it as fast as possible, the buffer you use for copying should be
            allocated outside of the Forbid()/Permit() pair, because the allocation
            may break the forbidden state.@{b}

 INPUTS@{ub}
        Previous - the last processed Dos list entry as returned by a previous
                 call to FindDosEntry() or NextDosEntry() or the value returned
                 by a successful AttemptLockDosEntry() or LockDosEntry().
        AccessFlags - the type of entry that is searched.@{b}

 RESULT@{ub}
        If the function succeeds, a pointer to the next entry matching the control
        flags is returned.
        If the function fails, NULL is returned.@{b}

 SEE ALSO@{ub}
        @{"LockDOSList()" LINK "LockDOSList"}, @{"UnLockDOSList()" LINK "UnLockDOSList"}, @{"FindDOSEntry()" LINK "FindDOSEntry"}

@ENDNODE
@NODE "NextTag" "joinOS.library/NextTag()"
@{b}

 NAME@{ub}
        NextTag - iterate through a tag list@{b}

 SYNOPSIS@{ub}
        struct TagItem *NextTag (struct TagItem **)
        tag = NextTag (tagItemPtr)
         D0                    A0@{b}

 FUNCTION@{ub}
        Iterates through a tag list, skipping and chaining as dictated by
        system tags. TAG_SKIP will cause it to skip the entry and a number
        of following tags as specified in ti_Data. TAG_IGNORE ignores that
        single entry, and TAG_MORE has a pointer to another array of tags (and
        terminates the current array!). TAG_DONE also terminates the current
        array. Each call returns either the next tagitem you should examine,
        or NULL when the end of the list has been reached.@{b}

 INPUTS@{ub}
        tagItemPtr - doubly-indirect reference to a TagItem structure.
                      The pointer will be changed to keep track of the
                      iteration.@{b}

 RESULTS@{ub}
        nextTag - each TagItem in the array or chain of arrays that should be
                   processed according to system tag values defined in
                   <joinOS/misc/tagitem.h>) is returned in turn with successive
                   calls.@{b}

 EXAMPLE@{ub}
        Iterate(struct TagItem *tags);
        {
           struct TagItem *tstate;
           struct TagItem *tag;

           tstate = tags;
           while (tag = NextTag(&tstate))
           {
              switch (tag->ti_Tag)
              {
                 case TAG1: ...
                    break;

                 case TAG2: ...
                    break;

                 ...
              }
           }
        }@{b}

 WARNING@{ub}
        Do NOT use the value of *tagItemPtr, but rather use the pointer returned
        by NextTag().@{b}

 SEE ALSO@{ub}
        <joinOS/misc/tagitem.h>, @{"GetTagItem()" LINK "GetTagItem"}, @{"PackBooleanTags()" LINK "PackBooleanTags"}, @{"FindTag()" LINK "FindTag"}

@ENDNODE
@NODE "PackBooleanTags" "joinOS.library/PackBooleanTags()"
@{b}

 NAME@{ub}
        PackBooleanTags - builds a "flag" word from a tag list@{b}

 SYNOPSIS@{ub}
        ULONG PackBooleanTags (ULONG, struct TagItem *, struct TagItem *)
        flags = PackBooleanTags (initialFlags, tagList, boolMap)
          D0                         D0          A0       A1@{b}

 FUNCTION@{ub}
        Picks out the boolean tag items in a tag list and converts
        them into bit-flag representations according to a correspondence
        defined by the tag list 'boolMap'.

        A boolean tag item is one where only the logical value of
        the ti_Data is relevant. If this field is 0, the value is
        FALSE, otherwise TRUE.@{b}

 INPUTS@{ub}
        initialFlags - a starting set of bit-flags which will be changed
                        by the processing of TRUE and FALSE boolean tags
                        in tagList.
        tagList  - a TagItem list which may contain several tag items defined to
                   be boolean by their presence in boolMap. The logical value of
                   ti_Data determines whether a tag item causes the bit-flag
                   value related by boolMap to be set or cleared in the returned
                   flag longword.
        boolMap  - a tag list defining the boolean tags to be recognized, and
                   the bit (or bits) in the returned longword that are to be set
                   or cleared when a boolean Tag is found to be TRUE or FALSE in
                   tagList.@{b}

 RESULTS@{ub}
        flags - the accumulated longword of bit-flags, starting with
                 initialFlags and modified by each boolean tag item
                 encountered.@{b}

 EXAMPLE@{ub}
        /* define some nice user tag values ... */
        enum mytags { tag1 = TAG_USER+1, tag2, tag3, tag4, tag5 };

        /* this TagItem list defines the correspondence between boolean tags
         * and bit-flag values.
         */
        struct TagItem boolMap[] =
        {
           {tag1,     0x0001},
           {tag2,     0x0002},
           {tag3,     0x0004},
           {tag4,     0x0008},
           {TAG_DONE, }
        };

        /* You are probably passed these by some client, and you want
         * to "collapse" the boolean content into a single longword.
         */
        struct TagItem boolExample[] =
        {
           {tag1,     TRUE},
           {tag2,     FALSE},
           {tag5,     Irrelevant},
           {tag3,     TRUE},
           {TAG_DONE, }
        };

        /* Perhaps 'boolFlags' already has a current value of 0x800002.
         */
        boolFlags = PackBoolTags (boolFlags, boolExample, boolMap);

        /* The resulting new value of 'boolFlags' will be 0x80005. */@{b}

 WARNING@{ub}
        In a case where there is duplication of a tag in tagList, the
        last of the identical tags will hold sway.@{b}

 SEE ALSO@{ub}
        <joinOS/misc/tagitem.h>, @{"GetTagItem()" LINK "GetTagItem"}, @{"FindTag()" LINK "FindTag"}, @{"NextTag()" LINK "NextTag"}

@ENDNODE
@NODE "PackStructTags" "joinOS.library/PackStructTags()"
@{b}

 NAME@{ub}
        PackStructTags - pack a structure with values from a taglist@{b}

 SYNOPSIS@{ub}
        ULONG PackStructTags (APTR, ULONG *, struct TagItem *)
        num = PackStructTags (pack, packTable, tagList)
        D0                     A0       A1        A2@{b}

 FUNCTION@{ub}
        For each table entry, a @{"FindTag()" LINK "FindTag"} will be done and if the
        matching tag is found in the taglist, the data field will be
        packed into the given structure based on the packtable
        definition.@{b}

 INPUTS@{ub}
        pack - a pointer to the data area to fill in.
        packTable - a pointer to the packing information table.
                     See <joinOS/misc/tagItems.h> for definition and macros.
        tagList - a pointer to the taglist to pack into the structure@{b}

 RESULTS@{ub}
        num - the number of tag items packed@{b}

 SEE ALSO@{ub}
        <joinOS/misc/tagItems.h>, @{"FindTag()" LINK "FindTag"}, @{"UnpackStructTags()" LINK "UnpackStructTags"}

@ENDNODE
@NODE "ParseArgs" "joinOS.library/ParseArgs()"
@{b}

 NAME@{ub}
        ParseArgs - parse the command line input@{b}

 SYNOPSIS@{ub}
        @{"struct RDArgs" LINK "include/rdargs.h/File" 146} *ParseArgs (STRPTR, LONG*, @{"struct RDArgs" LINK "include/rdargs.h/File" 146}*)
        result = ParseArgs (template, array, rdArgs)
              D0                           D1@{b}

 FUNCTION@{ub}
        ReadArgs provides a simple, yet powerful and consistent means of
        analyzing commandline input for shell processes; it can also be used to
        parse other types of data (e.g. configuration files). For this purpose
        it uses a so-called "template" that describes the number and types of
        parameters requested.
        This function processes the whole input and parses all arguments, so the
        input could be discarded after this function returns.
        In opposite to the AmigaOS function ReadArgs(), this function works
        also under AmigaOS 1.3 and uses a lightly different template-string,
        You could specifiy the additional parameters date (/D) and time (/H).

        After you're done processing the arguments, you have to free the allocated
        buffers and structures using @{"FreeArguments()" LINK "FreeArguments"}.@{b}

 INPUT@{ub}
        template -  a pointer to the template string, used to process the input:
           A template is a list of keywords followed optionaly by an alias and
           modifiers, separated with commas.
           template = {keyword[=alias]{/modifier}[,]}keyword[=alias]{/modifier}
           Every entry in the template defines a parameter that could be entered,
           the arguments must not be entered in the order specified by the
           template, they could be entered with or without a leading keyword
           (except for parameters specified with the /K modifier, see below)
           If a keyword is provided explicitly when a command is entered, it can
           be separated from the argument by an equal sign (e.g. "TO=dest") or
           with any number of spaces (e.g. "TO dest").
           The type of a parameter is - if not different defined - a string.

           Valid modifiers are:
           /S - Switch. This is considered a boolean variable, and will be set, it
                 the optional name appears in the command-line. The entry is the
                 boolean (0 for not set, non-zero for set)

           /T - Toggle. This is similar to a switch, but it must be specified, if
                 the boolean value it TRUE or FALSE, by passing "off", "on", "no",
                 or "yes" as argument, where "on" and "yes" are specifying TRUE.
                 If the toggle is not specified, the according entry in the array
                 will not be changed.

           /N - Number. This parameter is considered a decimal number, and will
                 be converted by ReadArgs. If an invalid number is specified an
                 error will be returned. This could produce unintelligible
                 results, if you try to pass a string consisting of decimal
                 digits to a parameter without specifing the keyword.
                 The according entry in the array will be a pointer (!) to the
                 longword number (this is how you know if a number was specified)

           /K - Keyword. This means that the option will not be filled unless the
                 keyword appears. For example if the template is "Name/K", then
                 unless "Name=<string>" or "Name <string>" appears in the command
                 line, Name will not be filled.

           /A - Required. This argument must be given a value during command line
                 processing, or an error is returned.

           /F - Rest of line. If this is specified, the entire rest of the line
                 is taken without further processing as the parameter of this
                 option. You should define a "final" parameter in the template
                 string in combination with the "keyword" /K option, or you could
                 have counterintuitive results, because all unfilled parameters
                 will get a argument and only the rest will be passed to this one

           /M - Multiple. Any number of arguments can be supplied for this
                 parameter, returning them as an array of string. In opposite to
                 the AmigaDos argument parsing function, this function is able to
                 parse multiple numerical arguments (/M/N) which will result in
                 an array of long's. Only a single multiple parameter is allowed
                 for a template, and you should avoid using multiple and "final"
                 parameters in the same template, since the final parameter will
                 not get any argument, if it's keyword is not specified.
                 Any argument not considered to be part of another option will be
                 added to this parameter (except for numerical multiple parameter
                 which will only get numerical arguments).
                 There is an interaction between /M parameters and /A parameters.
                 If there are unfilled /A parameters after parsing, it will grap
                 arguments from the end of the /M parameter list to fill the /A's
                 this will only work, if the /A's have the same type as the /M.

           The next argument types are additional types, only accessable using
           ParseArgs(), @{"FreeArguments()" LINK "FreeArguments"}, @{"ParseItem()" LINK "ParseItem"}, and @{"FindArgument()" LINK "FindArgument"} instead
           of ReadArgs(), FreeArgs(), ReadItem, and FindArg():

           /D - Date. This parameter exspects a date-string. The result will be
              a pointer to a long with the number of days since 01.01.1978 (The
              value of the long could be placed in a DateStamp structures ds_Days
              field). If no date string is found, the entry in the array is not
              changed, if a found date string is not valid (see DateStamp() for
              details about valid dates),it would be passed to a string argument!
              By default a date-string must be entered in the DOS format
              "dd-mmm-yy" (e.g. "12-May-01"). The format of the date string could
              be changed by setting a flag in the RDA_Flags field of the RDArgs
              structure passed to ParseArgs():
                 @{"RDAF_DATE_INT" LINK "include/rdargs.h/File" 171} - international format "yy-mm-dd" (e.g."01-05-12")
                 @{"RDAF_DATE_USA" LINK "include/rdargs.h/File" 173} - US-American format "mm-dd-yy" (e.g. "05-12-01")
                 @{"RDAF_DATE_CDN" LINK "include/rdargs.h/File" 175} - Canadian format "dd-mm-yy" (e.g. "12-05-01")
                 @{"RDAF_DATE_DEF" LINK "include/rdargs.h/File" 177} - default format of current locale used (currently
                             not supported, defaults to DOS format).
              As a result of this, a date string has to be entered always in DOS
              format if no RDArgs structure is passed to ParseArgs().

              You could also enter "Yesterday", "Today", or "Tomorrow" instead of
              a date, the number of days will be calculated according to the
              current system date.
              If you enter the name of a weekday (e.g. "Monday"), the number of
              days will be calculated to the last of that weekdays (last monday)
              except if you set the flag @{"RDAF_FUTURE" LINK "include/rdargs.h/File" 179}, which will result the
              number of days to next weekday of the specified name (next monday).

           /H - Time. This parameter allows to enter a time in the format "hh:mm"
              or "hh:mm:ss". If a valid time string is found, the result will be
              a long pointer to the number of seconds passed since midnight.
              If the entered time string is not valid (e.g. "25:34", "12:67", or
              "13:"), the argument is passed to an empty string parameter!


        rdArgs - a pointer to a user-supplied RDArgs structure, or NULL. IF it is
           NULL, the structure is allocated inside of this function. If you
           allocate it in your user-application (using
           @{"AllocDOSObject" LINK "AllocDOSObject"}(@{"DOS_RDARGS" LINK "include/AmigaDOS.h/File" 496}, NULL) ) you could control the operation of
           ParseArgs(). See "rdArgs.h" for information how to initialize the
           structure.
              @{"RDAF_NOPROMPT" LINK "include/rdargs.h/File" 161} - suppresses the output of the template string, if
                 the first character found is the unquoted question mark.
                 As a consequence, extended help is disabled, too. This may be
                 useful for noninteractive input streams or in an unquoted
                 question mark may occur as a valid input item.
                 If RDA_Source.CS_Buffer is NULL, this flag will cause the
                 function to fail immediately if any required argument is defined
                 by the template.
              @{"RDAF_STDIN" LINK "include/rdargs.h/File" 157} - if an argumentstring is to be requested from the user
                 (af_Input == NULL, or first character found is the unquoted
                 question mark and AFF_NOPROMPT is not set) this flag will cause
                 the function to ask the user for that arguments via the stdin,
                 independent of the defined inputstream in <af_Input>.
                 This flag is currently ignored, the arguments are always
                 requested from stdin, if needed and AFF_NOPROMPT is not set.
              RDAF_DATE_??? - if a date-argument is defined in the template, these
                 flags define how the date has to be entered, they are mutualy
                 exclusive:
                 (default) - the date has to be in the format "dd-Mmm-yy" or
                          "dd-mm-yy".
                 INT - the date has to be in the format "yy-mm-dd"
                 USA - the date has to be in the format "mm-dd-yy"
                 CDN - the date has to be in the format "dd-mm-yy"
                 DEF - the date has to be in the default format of the current
                          locale being used.
                       This flag is currently not supported and defaults to DOS.
              RDAF_WEEKDAY - if this flag is specified, you could also enter a day
                 of the week ("Monday" - "Sunday", "Yesterday", "Today", or
                 "Tomorrow") to specify a date. Days of a week refers to days in
                 the past (e.g. "Monday" == last monday).
           The other fields of the structure must be initialized with zeros.@{b}

 RESULT@{ub}
        A pointer to the RDArgs structure with the parsed arguments is returned,
        or NULL in the event of an error. See IoErr() for the according AmigaDos
        errorcode in that case.
        If the function succeeds, the parsed arguments are stored in the array
        that was passed as second argument to this function.
        If the function fails, you need not to call @{"FreeArguments()" LINK "FreeArguments"} (but it is
        save to do it anyway).@{b}

 NOTE@{ub}
        After this function succeeds, you must not alter the RDArgs structure
        until you finally called @{"FreeArguments()" LINK "FreeArguments"}.

        You should always use the ParseArgs()-function call (or alias), so you
        could be shure that this implementation is called, so the application
        will have the same behaviour on every machine.@{b}

 BUGS@{ub}
        A leading equal sign in the argument string is silently skipped.

        The AmigaDOS-manual documents that a /M parameter will get at least one
        argument or the function will fail, the Amiga-RKM documents that a /M
        could get zero to many arguments. This implementation accepts zero
        entries for a /M parameter, so you should define it with the /A modifier
        to be shure that it always gets at least one argument.

        It might not work to parse the initial arguments passed to a new process
        on every system, so you should always pass the argument-string you got
        at application-start to the CSource structure part of the RDArgs struct
        to parse this command line. The startupcode "Startup.c" part of this
        "packet" will pass the commandline to the arguments of the Main()
        function, which is always the entry-function of applications written
        using this library and the according startup-module.

        If @{"MAX_MULTIARGS" LINK "include/rdargs.h/File" 73} arguments are passed to a multiple argument parameter,
        the array of that parameter is NOT terminated by a NULL value.@{b}

 SEE ALSO@{ub}
        @{"<joinOS/dos/rdArgs.h>" link "include/rdargs.h/Main"}, @{"FreeArguments()" LINK "FreeArguments"}, @{"ParseItem()" LINK "ParseItem"}, @{"FindArgument()" LINK "FindArgument"}

@ENDNODE
@NODE "ParseItem" "joinOS.library/ParseItem()"
@{b}

 NAME@{ub}
        ParseItem - read one item from a specified input source@{b}

 SYNOPSIS@{ub}
        LONG ParseItem (UBYTE*, ULONG, @{"struct CSource" LINK "include/rdargs.h/File" 106} *)
        result = ParseItem (buffer, bufSize, source)
          D0                 D1      D2       D3@{b}

 FUNCTION@{ub}
        ParseItem() reads one item from a specified input source, usually the
        buffered current input stream (if source is NULL), which - upon CLI
        start-up - contains the command-line arguments. If the data are to be
        read from a different input stream, then a non-NULL CSource pointer
        must be passed. See "rdArgs.h" for details how to initialize a CSource
        structure.
        The following values can be returned by ParseItem():
           @{"ITEM_EQUAL" LINK "include/AmigaDOS.h/File" 434} - the first character found in the source is the equal
                 sign.
           @{"ITEM_ERROR" LINK "include/AmigaDOS.h/File" 435} - an error occured, usually buffer overflow.
           @{"ITEM_NOTHING" LINK "include/AmigaDOS.h/File" 436} - line feed, carriage return or EOF found.
           @{"ITEM_UNQUOTED" LINK "include/AmigaDOS.h/File" 437} - an unquoted item found
           @{"ITEM_QUOTED" LINK "include/AmigaDOS.h/File" 438} -  a quoted item found
        A line feed or an end of file are considered terminators for all types
        of items. In addition, unquoted items are terminated by a space, a tab,
        an equals sign, or a semicolon. Items starting with a quotation mark are
        terminated by a second one; the quotation marks themselves are not copied
        to the destination buffer. Quoted items may contain the following escape
        sequences:
           *" - for "
           ** - for *
           *E or *e - for the escape character (ASCII $1B = ESC)
           *N or *n - for the line-feed ('\\n', ASCII $0A = LF)
           *R or *r - for the carriage return ('\\r', ASCII $0C = CR)@{b}

 INPUTS@{ub}
        buffer - a pointer to the buffer, where the current item should be copied
                 to.
        bufSize - the byte-size of the buffer ( > 0 )
        source - a pointer to a CSource structure, defining the input-source or
                 NULL, if STDIN should be used as source.@{b}

 RESULT@{ub}
        The function returns an identifier, that describes the found item.@{b}

 BUGS@{ub}
        The token delimiter encountered directly after an unquoted item is
        currently not pushed back into the input stream, so an equal sign
        following an unquoted item is silently skipped.

        The function may fail with a secondary result (IoErr()) of
        @{"ERROR_BUFFER_OVERFLOW" LINK "include/AmigaDOS.h/File" 387} by quoted items, even if they fit into the buffer,
        because they are copied first time as is, before the quotes are removed
        and escape sequences are transformed (which will shorten the string).

        The function currently reads all characters from an input-source under
        AmigaOS v35 and below, if the source is an interactive stream (CSource
        is equal NULL, and STDIN is the console), so all items following the
        current one are lost!

        Workaround:
           If you whish to read from an interactive file, read the bytes to a
           local buffer, and pass this buffer via CSource to this function.
        The following pseudo-code shows how to manage this:

        BOOL SaveProcessAllItems (@{"struct CSource" LINK "include/rdargs.h/File" 106} *source)
        {
           UBYTE *buffer = NULL;
           UBYTE itemBuf[@{"ARG_BUFFER_SIZE" LINK "include/rdargs.h/File" 63}];
           @{"struct CSource" LINK "include/rdargs.h/File" 106} *cs = NULL;
           LONG itemType;
           BOOL result = FALSE;
           LONG bytesRead;
           @{"BPTR" LINK "include/AmigaDOS.h/File" 126} input;

           if (!source && (((struct Library *)DOSBase)->lib_Version < 36))
           {
              if (input = Input())
              {
                 if (((@{"struct FileHandle" LINK "include/AmigaDOS.h/File" 455} *)@{"BADDR" LINK "include/AmigaDOS.h/File" 135}(input))->fh_Port)
                 {
                    // STDIN is interactive...
                    if (buffer = AllocMem (@{"ARG_BUFFER_SIZE" LINK "include/rdargs.h/File" 63}, MEMF_PUBLIC|MEMF_CLEAR))
                    {
                       if ((bytesRead = Read (fh, buffer, @{"ARG_BUFFER_SIZE" LINK "include/rdargs.h/File" 63})) != -1)
                       {
                          if (bytesRead < @{"ARG_BUFFER_SIZE" LINK "include/rdargs.h/File" 63})
                          {
                             if (cs = AllocMem (sizeof(@{"struct CSource" LINK "include/rdargs.h/File" 106}),MEMF_PUBLIC))
                             {
                                cs->CS_Buffer = buffer;
                                cs->CS_Length = bytesRead;
                                cs->CS_CurChr = 0;
                             }
                          }
                          else @{"SetIOErr" LINK "SetIOErr"} (@{"ERROR_LINE_TOO_LONG" LINK "include/AmigaDOS.h/File" 341});
                       }
                    }
                 }
              }
           }
           else cs = source;

           if (cs || (((struct Library *)DOSBase)->lib_Version >= 36))
           {
              result = TRUE;
              do
              {
                 result = ParseItem (itemBuf, @{"ARG_BUFFER_SIZE" LINK "include/rdargs.h/File" 63}, cs);
                 // now process the item, however you want
                 ...
              }
              while ((result != @{"ITEM_NOTHING" LINK "include/AmigaDOS.h/File" 436}) && (result != @{"ITEM_ERROR" LINK "include/AmigaDOS.h/File" 435}));

              if (result == @{"ITEM_ERROR" LINK "include/AmigaDOS.h/File" 435}) result = FALSE;
           }
           if (cs && (cs != source))
              FreeMem (cs, sizeof (@{"struct CSource" LINK "include/rdargs.h/File" 106}));
           if (buffer)
              FreeMem (buffer, @{"ARG_BUFFER_SIZE" LINK "include/rdargs.h/File" 63});

           return result;
        }@{b}

 SEE ALSO@{ub}
        @{"<joinOS/dos/rdArgs.h>" link "include/rdargs.h/Main"}, @{"ParseArgs()" LINK "ParseArgs"}, @{"FreeArguments()" LINK "FreeArguments"}, @{"FindArgument()" LINK "FindArgument"}

@ENDNODE
@NODE "PathFromLock" "joinOS.library/PathFromLock()"
@{b}

 NAME@{ub}
        PathFromLock - retrieve the full path to an object a lock references@{b}

 SYNOPSIS@{ub}
        LONG PathFromLock (@{"BPTR" LINK "include/AmigaDOS.h/File" 126}, UBYTE *, ULONG)
        success = PathFromLock (fl, buffer, bufSize)
          D0                    D1    D2      D3@{b}

 FUNCTION@{ub}
        This functions builds the full path name of an object descriped by a
        lock. If the buffer is too small, the function will fail.
        If the ZERO lock is passed, this function converts the ZERO lock to
        a hard coded name "SYS:", regardless of the boot volume's actual volume
        name. The function will request unmounted volumes.@{b}

 INPUTS@{ub}
        fl - a BCPL pointer to the FileLock which filepath is requested.
        buffer   - the buffer (MEMF_PUBLIC) where the path should be copied to
        bufSize  - the byte size of the buffer, at least one.@{b}

 RESULT@{ub}
        If the function succeeds, @{"DOSTRUE" LINK "include/AmigaDOS.h/File" 90} is returned.
        If the function fails, @{"DOSFALSE" LINK "include/AmigaDOS.h/File" 91} is returned, the contents of the buffer.
        is undefined.

@ENDNODE
@NODE "PatternMatch" "joinOS.library/PatternMatch()"
@{b}

 NAME@{ub}
        PatternMatch - check, whether a string could be "produced" with the
                       specified pattern (case-sensitive).@{b}

 SYNOPSIS@{ub}
        BOOL PatternMatch (UBYTE*, const UBYTE*)
        success = PatternMatch (Pattern, TokenString)
           D0                    D1         D2@{b}

 FUNCTION@{ub}
        This function checks whether a string could be "produced" with the
        specified pattern. The pattern must be previously be converted to a
        TokenString using @{"PatternParse()" LINK "PatternParse"}.
        This function compares case-sensitive, see @{"PatternMatchNoCase()" LINK "PatternMatchNoCase"} for
        a not case-sensitive matching function.@{b}

 INPUT@{ub}
        Pattern - the previously parsed pattern from @{"PatternParse()" LINK "PatternParse"}. The token
                 string that was produced by that function must be passed here.
        TokenString - the C string that should be matched against the pattern,
                 this string could include all ASCII chars except the not
                 printable characters in the range of 0x80 upto 0x8F (ANSI)
                 which are used as control-characters for the parsed pattern.@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned and all values are updated.
        If the function fails, FALSE is returned, IoErr() is set to according
        AmigaDos-errorcode, probably @{"ERROR_TOO_MANY_LEVELS" LINK "include/AmigaDOS.h/File" 359} or @{"ERROR_BAD_TEMPLATE" LINK "include/AmigaDOS.h/File" 335}.@{b}

 NOTE@{ub}
        The used pattern string is not compatible to the token string produced
        by the AmigaDos ParsePattern() function. So never call this function
        with a pattern string produced by AmigaDos ParsePattern().

        This function might match slightly different strings than the equivalent
        AmigaDos function MatchPattern(), especialy by patterns containing
        nested '#','~',() groups.@{b}

 SPECIAL NOTE@{ub}
        The function requires approximately 2000 bytes of free available stack
        space, low stack situations are NOT checked.@{b}

 BUGS@{ub}
        The amount of stack used, especialy in @{"ERROR_TOO_MANY_LEVELS" LINK "include/AmigaDOS.h/File" 359} situations,
        is currently not tested and may exceed 2000 bytes.

        The names of the arguments of this function are irritating, Pattern is
        the token string produced by @{"PatternParse()" LINK "PatternParse"} and TokenString is the string
        to compare with.@{b}

 SEE ALSO@{ub}
        @{"<joinOS/dos/MatchPattern.h>" link "include/MatchPattern.h/Main"}, @{"PatternMatchNoCase()" LINK "PatternMatchNoCase"}, @{"PatternParse()" LINK "PatternParse"}

@ENDNODE
@NODE "PatternMatchNoCase" "joinOS.library/PatternMatchNoCase()"
@{b}

 NAME@{ub}
        PatternMatchNoCase - check, whether a string could be "produced" with the
                             specified pattern (not case-sensitive).@{b}

 SYNOPSIS@{ub}
        BOOL PatternMatchNoCase (UBYTE*, const UBYTE*)
        success = PatternMatchNoCase (Pattern, TokenString)
           D0                           D1        D2@{b}

 FUNCTION@{ub}
        This function checks whether a string could be "produced" with the
        specified pattern. The pattern must be previously be converted to a
        TokenString using ParsePatternNoCase().
        This function compares case-insensitive, see @{"PatternMatch()" LINK "PatternMatch"} for a
        case-sensitive matching function.@{b}

 INPUT@{ub}
        Pattern - the previously parsed pattern from @{"PatternParseNoCase()" LINK "PatternParseNoCase"}.
                 The token string that was produced by that function must be
                 passed here.
        TokenString - the C string that should be matched against the pattern,
                 this string could include all ASCII chars except the not
                 printable characters in the range of 0x80 upto 0x8F (ANSI)
                 which are used as control-characters for the parsed pattern.@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned and all values are updated.
        If the function fails, FALSE is returned, IoErr() is set to according
        AmigaDos-errorcode, probably @{"ERROR_TOO_MANY_LEVELS" LINK "include/AmigaDOS.h/File" 359} or @{"ERROR_BAD_TEMPLATE" LINK "include/AmigaDOS.h/File" 335}.@{b}

 NOTE@{ub}
        The used pattern string is not compatible to the token string produced
        by the AmigaDos ParsePatternNoCase() function. So never call this
        function with a pattern string produced by AmigaDos ParsePatternNoCase().

        This function might match slightly different strings than the equivalent
        AmigaDos function MatchPatternNoCase(), especialy by patterns containing
        nested '#','~',() groups.@{b}

 SPECIAL NOTE@{ub}
        The function requires approximately 2000 bytes of free available stack
        space, low stack situations are NOT checked.@{b}

 BUGS@{ub}
        The amount of stack used, especialy in @{"ERROR_TOO_MANY_LEVELS" LINK "include/AmigaDOS.h/File" 359} situations,
        is currently not tested and may exceed 2000 bytes.

        The names of the arguments of this function are irritating, "Pattern" is
        the token string produced by @{"PatternParse()" LINK "PatternParse"} and "TokenString" is the
        string to compare with.@{b}

 SEE ALSO@{ub}
        @{"<joinOS/dos/MatchPattern.h>" link "include/MatchPattern.h/Main"}, @{"PatternMatch()" LINK "PatternMatch"}, @{"PatternParseNoCase()" LINK "PatternParseNoCase"}

@ENDNODE
@NODE "PatternParse" "joinOS.library/PatternParse()"
@{b}

 NAME@{ub}
        PatternParse - parse a pattern and produce a according tokenstring@{b}

 SYNOPSIS@{ub}
        LONG PatternParse (const UBYTE *, UBYTE *, ULONG)
        result = PatternParse (rawPattern, tokenBuffer, bufSize)
         D0                     D1           D2          D3@{b}

 FUNCTION@{ub}
        If you wish to use the pattern matching function @{"PatternMatch()" LINK "PatternMatch"} -
        for case-sensitiv pattern matching - you have to call this function
        previously, to parse the pattern, so it could be processed by that
        function.
        The produced tokenstring, that must be passed to @{"PatternMatch()" LINK "PatternMatch"} later,
        is stored in the user-defined buffer.@{b}

 INPUT@{ub}
        rawPattern - the pattern that should be parsed (C string), see
                    "MatchPattern.h" for details, how to build a pattern string.
                    This string could include all ASCII chars except the not
                    printable characters in the range of 0x80 upto 0x8F (ANSI)
                    which are used as control-characters for the parsed pattern.
        tokenBuffer - the buffer where the produced tokenstring should be stored.
                    This buffer must be at least strlen(rawPattern)*2+2 bytes in
                    size.
        bufSize - the size of the tokenbuffer.@{b}

 RESULT@{ub}
        The function returns a returnvalue, indicating success and the type of
        pattern parsed:
           -1 = buffer overflow or other error
           0  = pattern contains no wildcard (in the case of a filepath, you
                 could simply call Lock() or Open() with that path and need not
                 to do any pattern matching)
           1  = pattern contains wildcards, tokenbuffer holds the compiled token
                 string, that might be passed to @{"PatternMatch()" LINK "PatternMatch"}.@{b}

 SPECIAL NOTE@{ub}
        The function requires approximately 2000 bytes of free available stack
        space, low stack situations are NOT checked.@{b}

 BUGS@{ub}
        The amount of stack used, especialy in @{"ERROR_TOO_MANY_LEVELS" LINK "include/AmigaDOS.h/File" 359} situations,
        is currently not tested and may exceed 2000 bytes.@{b}

 SEE ALSO@{ub}
        @{"<joinOS/dos/MatchPattern.h>" link "include/MatchPattern.h/Main"}, @{"PatternMatch()" LINK "PatternMatch"}, @{"PatternParseNoCase()" LINK "PatternParseNoCase"}

@ENDNODE
@NODE "PatternParseNoCase" "joinOS.library/PatternParseNoCase()"
@{b}

 NAME@{ub}
        PatternParseNoCase - parse a pattern and produce a according tokenstring@{b}

 SYNOPSIS@{ub}
        LONG PatternParseNoCase (const UBYTE *, UBYTE *, ULONG)
        result = PatternParseNoCase (rawPattern, tokenBuffer, bufSize)
         D0                     D1           D2          D3@{b}

 FUNCTION@{ub}
        If you wish to use the pattern matching function @{"PatternMatchNoCase()" LINK "PatternMatchNoCase"} -
        for case-insensitiv pattern matching - you have to call this function
        previously, to parse the pattern, so it could be processed by that
        function.
        The produced tokenstring, that must be passed to @{"PatternMatchNoCase()" LINK "PatternMatchNoCase"}
        later, is stored in the user-defined buffer.@{b}

 INPUT@{ub}
        rawPattern - the pattern that should be parsed (C string), see
                    "MatchPattern.h" for details, how to build a pattern string.
                    This string could include all ASCII chars except the not
                    printable characters in the range of 0x80 upto 0x8F (ANSI)
                    which are used as control-characters for the parsed pattern.
        tokenBuffer - the buffer where the produced tokenstring should be stored.
                    This buffer must be at least strlen(rawPattern)*2+2 bytes in
                    size.
        bufSize - the size of the tokenbuffer.@{b}

 RESULT@{ub}
        The function returns a returnvalue, indicating success and the type of
        pattern parsed:
           -1 = buffer overflow or other error
           0  = pattern contains no wildcard (in the case of a filepath, you
                 could simply call Lock() or Open() with that path and need not
                 to do any pattern matching)
           1  = pattern contains wildcards, tokenbuffer holds the compiled token
                 string, that might be passed to @{"PatternMatchNoCase()" LINK "PatternMatchNoCase"}.@{b}

 NOTE@{ub}
        The produced token string is not compatible to the token string produced
        by the AmigaDos ParsePatternNoCase() function. So never call the AmigaDos
        MatchPatternNoCase() function with this token string.@{b}

 SPECIAL NOTE@{ub}
        The function requires approximately 2000 bytes of free available stack
        space, low stack situations are NOT checked.@{b}

 BUGS@{ub}
        The amount of stack used, especialy in @{"ERROR_TOO_MANY_LEVELS" LINK "include/AmigaDOS.h/File" 359} situations,
        is currently not tested and may exceed 2000 bytes.@{b}

 SEE ALSO@{ub}
        @{"<joinOS/dos/MatchPattern.h>" link "include/MatchPattern.h/Main"}, @{"PatternMatchNoCase()" LINK "PatternMatchNoCase"}, @{"PatternParse()" LINK "PatternParse"}

@ENDNODE
@NODE "PrintError" "joinOS.library/PrintError()"
@{b}

 NAME@{ub}
        PrintError - print an error text to stdout.@{b}

 SYNOPSIS@{ub}
        LONG PrintError (LONG, STRPTR)
        known = PrintError (ErrorCode, Text)
         D0                    D1       D2@{b}

 FUNCTION@{ub}
        Print a descriptive text coresponding to a DOS error code to the current
        output. Unless the error code is zero, PrintFault() outputs the error
        message generated by Fault() -- plus a trailing line feed -- to the
        standard output stream as determined by Output(). In addition it will
        set the value returned by subsequent calls to IoErr() to the error value
        passed to this function.@{b}

 INPUTS@{ub}
        ErrorCode - The error code which descriping text should be printed.
        Text      - text to precede the error message.@{b}

 RESULT@{ub}
        For known error codes, this function returns @{"DOSTRUE" LINK "include/AmigaDOS.h/File" 90}, otherwise @{"DOSFALSE" LINK "include/AmigaDOS.h/File" 91}
        is returned (this includes the errorcode zero).@{b}

 SEE ALSO@{ub}
        @{"ErrorText()" LINK "ErrorText"}, @{"ReportError()" LINK "ReportError"}, @{"SetIOErr()" LINK "SetIOErr"}, <joinOS/dos/AmigaDOS.h>

@ENDNODE
@NODE "RefreshTagListClones" "joinOS.library/RefreshTagListClones()"
@{b}

 NAME@{ub}
        RefreshTagListClones - rejuvenate a clone from the original@{b}

 SYNOPSIS@{ub}
        void RefreshTagListClones (struct TagItem *, struct TagItem *)
        RefreshTagListClones (clone, original)
                               A0       A1@{b}

 FUNCTION@{ub}
        If (and only if) the tag list 'clone' was created from 'original' by
        @{"CloneTagList()" LINK "CloneTagList"}, and if 'original' has not been changed in any way,
        you can reset the clone list to its original state by using this
        function.@{b}

 INPUTS@{ub}
        clone - return value from @{"CloneTagList" LINK "CloneTagList"}(original)
        original - a tag list that hasn't changed since @{"CloneTagList()" LINK "CloneTagList"}@{b}

 SEE ALSO@{ub}
        <joinOS/misc/tagitem.h>, @{"CloneTagList()" LINK "CloneTagList"}, @{"AllocateTagList()" LINK "AllocateTagList"},
        @{"FreeTagList()" LINK "FreeTagList"}, @{"ChangeTagList()" LINK "ChangeTagList"}

@ENDNODE
@NODE "ReplyDosPkt" "joinOS.library/ReplyDosPkt()"
@{b}

 NAME@{ub}
        ReplyDosPkt - reply a packet to the originator@{b}

 SYNOPSIS@{ub}
        void ReplyDosPkt (struct DosPacket*, LONG, LONG)
        ReplyDosPkt (dp, res1, res2)
                     D1   D2    D3@{b}

 FUNCTION@{ub}
        ReplyPkt() returns a packet to the reply port (as stored in dp_Port)
        defined by the originaring process. Before actually sending the reply,
        the dp_Port field is altered to point to the pr_MsgPort of the process
        that is about to return the packet, so it is possible to "ping-pong"
        packets between two processes.
        The other arguments of this function are transfered to dp_Res1 and
        dp_Res2, respectively. If the result fields must not be altered, the
        following technique can be used to preserve their contents:

           ReplyPkt (dp, dp->dp_Res1, dp->dp_Res2)@{b}

 INPUTS@{ub}
        dp - a pointer to the packet to be returned
        res1 - primary result to be put into dp_Res1
        res2 - secondary result to be put into dp_Res2@{b}

 NOTE@{ub}
        If the dp_Port field of the DosPacket is NULL, this functions tries - in
        opposite to the function under AmigaDos - to free the memory the packet
        uses.
        This special option requires that the packet is a StandardPacket allocated
        using 'AllocDosObject(@{"DOS_STDPKT" LINK "include/AmigaDOS.h/File" 494}, NULL)'.
        If the passed packet is not a StandardPacket, this will result in a Guru
        (AN_BadFreeAddr) which is even better than to crash the whole machine,
        which is the case under AmigaDos.@{b}

 SEE ALSO@{ub}
        @{"AbortDosPkt()" LINK "AbortDosPkt"}, @{"DoDosPkt()" LINK "DoDosPkt"}, @{"SendDosPkt" LINK "SendDosPkt"}, @{"WaitDosPkt()" LINK "WaitDosPkt"}

@ENDNODE
@NODE "ReportError" "joinOS.library/ReportError()"
@{b}

 NAME@{ub}
        ReportError - Format and display a requester after an AmigaDOS I/O error.@{b}

 SYNOPSIS@{ub}
        LONG ReportError (LONG, ULONG, ULONG, struct MsgPort *)
        retry = ReportError (code, type, arg1, mp)
         D0                   D1    D2    D3   D4@{b}

 FUNCTION@{ub}
        This function "pops-up" a requester according to the specified error code.
        The user is able to chose if the faulty operation should be retried or
        not.
        Only if one of the following error codes is passed to this function a
        requester will be shown up, if any other value is passed, this function
        simply returns @{"DOSTRUE" LINK "include/AmigaDOS.h/File" 90} without showing a requester:

           @{"ERROR_DISK_NOT_VALIDATED" LINK "include/AmigaDOS.h/File" 355}
           @{"ERROR_DISK_WRITE_PROTECTED" LINK "include/AmigaDOS.h/File" 356}
           @{"ERROR_DEVICE_NOT_MOUNTED" LINK "include/AmigaDOS.h/File" 360}
           @{"ERROR_DISK_FULL" LINK "include/AmigaDOS.h/File" 364}
           @{"ERROR_NOT_A_DOS_DISK" LINK "include/AmigaDOS.h/File" 369}
           @{"ERROR_NO_DISK" LINK "include/AmigaDOS.h/File" 370}
           @{"ABORT_BUSY" LINK "include/AmigaDOS.h/File" 383}
           @{"ABORT_DISK_ERROR" LINK "include/AmigaDOS.h/File" 384}@{b}

 INPUTS@{ub}
        code - the AmigaDos error code to be processed (see above for valid values)
        type - the type of the third parameter
        arg1 - additional information, depending on 'type', if 'type' is:
              @{"REPORT_STREAM" LINK "include/AmigaDOS.h/File" 396} - 'arg1' is a @{"BPTR" LINK "include/AmigaDOS.h/File" 126} to @{"struct FileHandle" LINK "include/AmigaDOS.h/File" 455}
              @{"REPORT_TASK" LINK "include/AmigaDOS.h/File" 397}   - <not supported>
              @{"REPORT_LOCK" LINK "include/AmigaDOS.h/File" 398}   - 'arg1' is a @{"BPTR" LINK "include/AmigaDOS.h/File" 126} to @{"struct FileLock" LINK "include/AmigaDOS.h/File" 443}
              @{"REPORT_VOLUME" LINK "include/AmigaDOS.h/File" 399} - 'arg1' is a pointer to a struct DosList
              @{"REPORT_INSERT" LINK "include/AmigaDOS.h/File" 400} - 'arg1' is pointer to a C-string
        mp - a pointer to a handler's messageport, if 'type' == @{"REPORT_LOCK" LINK "include/AmigaDOS.h/File" 398} and
              'arg1' is equal NULL.<@{b}

 RESULT@{ub}
        The function returns @{"DOSTRUE" LINK "include/AmigaDOS.h/File" 90}, if the <code> isn't understood or the
        requester couldn't be displayed or the user selects "Cancel". If the user
        selects "Retry" 0 (@{"DOSFALSE" LINK "include/AmigaDOS.h/File" 91}) is returned.@{b}

 SEE ALSO@{ub}
        @{"ErrorText()" LINK "ErrorText"}, @{"PrintError()" LINK "PrintError"}

@ENDNODE
@NODE "SemaphoreRelease" "joinOS.library/SemaphoreRelease()"
@{b}

 NAME@{ub}
        SemaphoreRelease - release a SignalSemaphore@{b}

 SYNOPSIS@{ub}
        void SemaphoreRelease (struct SignalSemaphore *)
        SemaphoreRelease (sigSem)
                            A0@{b}

 FUNCTION@{ub}
        SemaphoreRelease() is the inverse of ObtainSemaphore(). It makes
        the semaphore lockable to other users. If tasks are waiting for
        the semaphore and this this task is done with the semaphore then
        the next waiting task is signalled.

        Each ObtainSemaphore() call must be balanced by exactly one
        SemaphoreRelease() call.  This is because there is a nesting count
        maintained in the semaphore of the number of times that the current
        task has locked the semaphore. The semaphore is not released to
        other tasks until the number of releases matches the number of
        obtains.

        Needless to say, havoc breaks out if the task releases more times
        than it has obtained.@{b}

 INPUT@{ub}
        signalSemaphore -- an initialized signal semaphore structure@{b}

 NOTE@{ub}
        This call is guaranteed to preserve all registers.
        This call is new for every system, because of a name-conflict betweem
        AmigaOS ReleaseSemaphore() and Windoof ReleaseSemaphore().

        This function is implemented as macro on Amiga systems.@{b}

 BUGS@{ub}
        In the current implementation every task can release a shared locked
        semaphore, not only the one that has obtained it.

@ENDNODE
@NODE "SendDosPkt" "joinOS.library/SendDosPkt()"
@{b}

 NAME@{ub}
        SendDosPkt - send a packet asynchronously@{b}

 SYNOPSIS@{ub}
        void SendDosPkt (struct DosPacket*, struct MsgPort*, struct MsgPort*)
        SendDosPkt (dp, mp, rp)
                    D1  D2  D3@{b}

 FUNCTION@{ub}
        SendPkt() sends a packet asynchronously, i.e. it does not wait for the
        reply and may thus safely be called from a task. The packet must have
        been properly initialized.
        If WaitPkt() is to be used to wait for the reply of an asynchronous
        packet, SendPkt()'s reply port argument (rp) must point to the process's
        pr_MsgPort. Calling DoPkt() or any other asynchronous packet function
        while asynchronous packets with a reply port of pr_MsgPort are still
        pending is likely to crash the system with an AN_AsyncPkt Guru.@{b}

 INPUTS@{ub}
        dp - a pointer to the completely initialized DosPacket. This packet
              has to be accompanied by a valid Message structure.
        mp - the message port the packet is to be sent to (usually a handler
              process's message port as retrieved by GetDeviceProc()).
        rp - the message port the packet is to be replied to (dp_Port)@{b}

 SEE ALSO@{ub}
        @{"AbortDosPkt()" LINK "AbortDosPkt"}, @{"DoDosPkt()" LINK "DoDosPkt"}, @{"ReplyDosPkt" LINK "ReplyDosPkt"}, @{"WaitDosPkt()" LINK "WaitDosPkt"}

@ENDNODE
@NODE "SetIOErr" "joinOS.library/SetIOErr()"
@{b}

 NAME@{ub}
        SetIOErr - Set the secondary result of a process@{b}

 SYNOPSIS@{ub}
        LONG SetIOErr (LONG)
        lastresult = SetIOErr (result)
            D0                   D1@{b}

 FUNCTION@{ub}
        This function sets the secondary result of an process, which might be
        subsequently be retrieved via IoErr().@{b}

 INPUT@{ub}
        result - the secondary result that should be set.@{b}

 RESULT@{ub}
        The secondary result, stored for the process before this function is
        called, is returned.@{b}

 SEE ALSO@{ub}
        @{"ErrorText()" LINK "ErrorText"}, <joinOS/dos/AmigaDOS.h>

@ENDNODE
@NODE "Sqrt32" "joinOS.library/Sqrt32()"
@{b}

 NAME@{ub}
        Sqrt32 - calculate the squareroot of a 32-bit integer@{b}

 SYNOPSIS@{ub}
        ULONG Sqrt32 (ULONG)
        result = Sqrt32 (value)
          D0              D0@{b}

 FUNCTION@{ub}
        This function calculates the squareroot of an unsigned long integer.
        It operates with integers only, and uses an algorithm that finds
        the value by approximation. First it looks for good startvalues, then
        it loops until the squareroot is found.
        Even if the algorithm doesn't use a numerical way (it uses a kind of
        "try on error"), it is quite fast.@{b}

 INPUT@{ub}
        value - the value, the squareroot is looking for@{b}

 RESULT@{ub}
        The squareroot of the specified value (with a maximum error of 1) is
        returned.

@ENDNODE
@NODE "Str2DOUBLELONG" "joinOS.library/Str2DOUBLELONG()"
@{b}

 NAME@{ub}
        Str2DOUBLELONG - convert a decimal string to a DOUBLELONG@{b}

 SYNOPSIS@{ub}
        LONG Str2DOUBLELONG (STRPTR, DOUBLELONG *)
        bytesRead = Str2DOUBLELONG (string, value)
           D0                        A0       A1@{b}

 FUNCTION@{ub}
        This function converts a string consisting of decimal digits in ASCII
        into a DOUBLELONG value (64bit integer). The string may contain leading
        white spaces (spaces or tabulators) and a sign ('+' or '-'), which must
        precede the digits directly.
        The number of characters read, including possible white space and the
        sign, is returned.@{b}

 INPUTS@{ub}
        string - a pointer to the string that should be parsed.
        value  - a pointer to the DOUBLELONG that should receive the result.@{b}

 RESULT@{ub}
        The function returns the number of bytes read, if the value returned is
        at least one and the last character read (return value minus one yields
        the string offset) is a digit, then the input string did contain a valid
        number. Otherwise the variable pointed to by 'value' contains zero. Upon
        overflow, the value of this variable is undefined.@{b}

 SEE ALSO@{ub}
        @{"DOUBLELONG2Str()" LINK "DOUBLELONG2Str"}

@ENDNODE
@NODE "Str2Date" "joinOS.library/Str2Date()"
@{b}

 NAME@{ub}
        Str2Date - convert strings to date and time values@{b}

 SYNOPSIS@{ub}
        BOOL Str2Date (@{"struct DateTime" LINK "include/AmigaDOS.h/File" 529}*)
        success = Str2Date (DateTime)
           D0                  D1@{b}

 FUNCTION@{ub}
        Converts a human readable ASCII string into an AmigaDOS DateStamp.@{b}

 INPUTS@{ub}
        DateTime - a pointer to an initialized DateTime structure.

        The DateTime structure should be initialized as follows:

        dat_Stamp  - ignored on input.

        dat_Format - a format byte which specifies the format of the
           dat_StrDat. This can be any of the following (note: If value used is
           something other than those below, the default of @{"FORMAT_DOS" LINK "include/AmigaDOS.h/File" 552} is used):

           @{"FORMAT_DOS" LINK "include/AmigaDOS.h/File" 552}:   AmigaDOS format "dd-mmm-yy" (e.g. "12-May-01") or - in
                 opposite to the AmigaDOS function: "dd-mm-yy" (e.g. "12-05-01")

           @{"FORMAT_INT" LINK "include/AmigaDOS.h/File" 553}:   International format "yy-mm-dd" (e.g. "01-05-12")

           @{"FORMAT_USA" LINK "include/AmigaDOS.h/File" 554}:   American format "mm-dd-yy" (e.g. "05-12-01")

           @{"FORMAT_CDN" LINK "include/AmigaDOS.h/File" 555}:   Canadian format "dd-mm-yy" (e.g. "12-05-01")

           FORMAT_DEF:   default format for locale (currently not supported).

        dat_Flags - a flags byte. The only flag which affects this function is:

           @{"DTF_SUBST" LINK "include/AmigaDOS.h/File" 544}:  ignored by this function
           @{"DTF_FUTURE" LINK "include/AmigaDOS.h/File" 546}:  If set, indicates that strings such as (stored in
              dat_StrDate) "Monday" refer to "next" monday. Otherwise, if clear,
              strings like "Monday" refer to "last" monday.

        dat_StrDay - ignored by this function.

        dat_StrDate -  pointer to valid string representing the date.
           This can be a "@{"DTF_SUBST" LINK "include/AmigaDOS.h/File" 544}" style string such as "Today" "Tomorrow"
           "Monday", or it may be a string as specified by the dat_Format byte.
           This will be converted to the ds_Days portion of the DateStamp.
           If this pointer is NULL, DateStamp->ds_Days will not be affected.

        dat_StrTime -  Pointer to a buffer which contains the time in the ASCII
           format hh:mm:ss. This will be converted to the ds_Minutes and ds_Ticks
           portions of the DateStamp. If this pointer is NULL, ds_Minutes and
           ds_Ticks will be unchanged.@{b}

 RESULT@{ub}
        success  - a zero return indicates that a conversion could not be
        performed. A non-zero return indicates that the DateTime.dat_Stamp
        variable contains the converted values.@{b}

 BUGS@{ub}
        This function accepts dates in the range from 1-Jan-1978 until 31-Dec-2077
        which might not work under AmigaOS, because the system only accepts date
        stamps between 1-Jan-1978 and 31-Dec-2045.@{b}

 SEE ALSO@{ub}
        @{"Date2Str()" LINK "Date2Str"}, @{"Str2Long()" LINK "Str2Long"}

@ENDNODE
@NODE "Str2Long" "joinOS.library/Str2Long()"
@{b}

 NAME@{ub}
        Str2Long - convert a string representing a decimal value to a long@{b}

 SYNOPSIS@{ub}
        LONG Str2Long (STRPTR, LONG*)
        LONG Str2Long (String, Value)
         D0               D1     D2@{b}

 FUNCTION@{ub}
        This function converts a string consisting of decimal digits in ASCII
        into a signed long integer value. The string may contain leading white
        spaces (spaces or tabulators) and a negative sign, which must precede
        the digits directly.
        The number of characters read, including possible white space and the
        sign, is returned.@{b}

 INPUTS@{ub}
        String - a pointer to the string that should be parsed.
        Value  - a pointer to the unsigned long that should receive the result.@{b}

 RESULT@{ub}
        The function returns the number of bytes read, if the value returned is
        at least one and the last character read (return value minus one yields
        the string offset) is a digit, then the input string did contain a valid
        number. Otherwise the variable pointed to by <Value> contains zero. Upon
        overflow, the value of this variable is undefined.@{b}

 SEE ALSO@{ub}
        @{"Long2Str()" LINK "Long2Str"}, @{"Str2Date()" LINK "Str2Date"}

@ENDNODE
@NODE "TagIsInArray" "joinOS.library/TagIsInArray()"
@{b}

 NAME@{ub}
        TagIsInArray - check if a tag value appears in an array of tag values.@{b}

 SYNOPSIS@{ub}
        BOOL TagIsInArray (Tag, Tag *)
        result = TagIsInArray (tagValue, tagArray)
          D0                    D0        A0@{b}

 FUNCTION@{ub}
        Performs a quick scan to see if a tag value appears in an array
        terminated with TAG_DONE. Returns TRUE if the value is found.

        The 'tagArray' must be terminated by TAG_DONE. Note that this is an
        array of tag values, NOT an array of TagItems.@{b}

 INPUTS@{ub}
        tagValue - tag value to search array for in array.
        tagArray - a simple array of tag values terminated by TAG_DONE.@{b}

 RESULTS@{ub}
        result - TRUE if tagValue was found in tagArray.@{b}

 SEE ALSO@{ub}
        <joinOS/misc/tagitem.h>, @{"FilterTagList()" LINK "FilterTagList"}

@ENDNODE
@NODE "TempFileName" "joinOS.library/TempFileName()"
@{b}

 NAME@{ub}
        TempFileName - create a filename for a temporary file@{b}

 SYNOPSIS@{ub}
        STRPTR TempFileName (STRPTR, STRPTR, STRPTR)
        tempfile = TempFileName (tempdir, prefix, extension)
          A0                       A0       A1        A2@{b}

 FUNCTION@{ub}
        This function tries to create a new unique name for a temporary file.
        The created filename is tested, i.e. the function takes care that no
        file-system object with that name is currently existing.

        The filename will be created according to the following pattern:

           [<tempdir>]"~"[<prefix>]<unique string>[.(<extension>|"tmp")]

        The "unique string" will be created from the current system-time and
        always be 6 characters wide (AmigaOS) respectively 4 characters wide
        (Windoof, if no extension is specified).@{b}

 INPUTS@{ub}
        tempdir - a pointer to a NUL-terminated C-string with the path to the
                 directory, where the temporary file should be created. If
                 NULL is passed for this argument, the systems directory for
                 temporary files will be used.
        prefix - a pointer to a NUL-terminated C-string with a prefix used for
                 the filename to be created, at most the first two characters
                 of this string will be copied between the leading tilde
                 character ('~') and the unique string created from system-time.
                 If NULL is passed for this argument, no prefix is used.
        extension - a pointer to a NUL-terminated C-string that will be used as
                 extension of the filename, the filename will be followed by a
                 dot ('.') and this extension (i.e. the extension-string passed
                 with this argument should not be preceded by a dot). If NULL is
                 passed for this argument, the filename will get the extension
                 "tmp". If a pointer to an empty string ("") is passed, the
                 fillname will not have any extension.@{b}

 RESULT@{ub}
        A pointer to a new allocated buffer containing the created filename will
        be returned. You have to free this string after usage using the function
        @{"FreeVector()" LINK "FreeVector"}.
        If anything wents wrong, NULL is returned, see IoErr() for the cause of
        the failure.@{b}

 NOTES@{ub}
        Like every function accessing AmigaDOS the calling task needs to be an
        AmigaDOS process. This function may lead the calling process to wait for
        the reply of a packet send to a handler, so don't use it in time-critical
        functions.

        Even if the created filename is testet, there is no guarantee that the
        filename is not in use, when you try to create such a file, because the
        AmigaOS is a multitasking OS, a file-system object with the returned
        name might be created at any time by a concurrent task.

        The system-time is used to create an unique name, it has an accuracy of
        one fiftieth of a second, so if you call this function very often in
        short intervals, it will slow down, because the created filenames will
        often match an already existing file-system object.

        The unique name part of the created filename will only be created from
        the time elapsed since midnight, if a temporary file "lifes" longer than
        24 hours, the name may collide with a new tenporary filename (this
        collision will be detected by this function, but will take some time).

        This function is able to create over 16 million different filenames
        in the same directory with the same prefix and extension, but the more
        files are existing, the more the function will slow down because of
        collisions with existing files, so the number of usable filenames is
        quite less than this value. Use different prefixes and extensions for
        your temporary files, and delete the temporary files after usage, to
        avoid name-collisions (and safe some memory respectively disk-space).@{b}

 EXAMPLE@{ub}
       STRPTR tempFile;
       @{"BPTR" LINK "include/AmigaDOS.h/File" 126} fh;

       if (tempFile = TempFileName (NULL, "A", ".test"))
       {
          // the created filename would be something like "T:~A09C4FE.test"

          if (fh = Open (tempFile, @{"MODE_NEWFILE" LINK "include/AmigaDOS.h/File" 96}))
          {
             // work with the temporary file...
             ...
             // Close the temporary file and delete it...

             Close (fh);
             @{"Delete" LINK "Delete"} (tempFile);
          }
          // Free the temporary filename...

          @{"FreeVector" LINK "FreeVector"} (tempFile);
       }

@ENDNODE
@NODE "TextBox" "joinOS.library/TextBox()"
@{b}

 NAME@{ub}
        TextBox - vararg interface stub for @{"TextBoxA()" LINK "TextBoxA"}@{b}

 SYNOPSIS@{ub}
        LONG TextBox (APTR, const char *, const char *, UWORD, ULONG, ...)
        result = @{"TextBoxA" LINK "TextBoxA"} (window, caption, textFormat, type, arg1)@{b}

 FUNCTION@{ub}
        This is a vararg interface stub for the @{"TextBoxA()" LINK "TextBoxA"} function of the
        joinOS.library.@{b}

 INPUTS@{ub}
        window - a pointer to the Window structure of a window that is located
                 on the screen, the requester should appear.
                 If this argument is NULL, and the calling task is an AmigaDOS-
                 process, the field 'pr_WindowPtr' is taken into account. If this
                 field is NULL, or -1, or the calling task is just an Exec Task,
                 the requester will open on the default public screen.
        caption - The text that should be displayed as title of the requester.
        textFormat - the printf-alike formating text for the messages bodytext.
        type  - The requester type and button-types used for this requester,
                 see @{"<joinOS/misc/TextBox.h>" link "include/TextBox.h/Main"} for details.
        arg1  - the first of the variable number of arguments, that are used to
                 build the bodytext of the requester, according to the printf-
                 alike formating string passed in 'textFormat'.@{b}

 RESULT@{ub}
        The function returns the number of the gadget the user pressed, or
        -1 if the requester couldn't be displayed or is killed by a system event.
        The gadgets are numbered: 1,2,...,n,0 from left to right.

@ENDNODE
@NODE "TextBoxA" "joinOS.library/TextBoxA()"
@{b}

 NAME@{ub}
        TextBoxA - create a modal dialog displaying a descriptive text@{b}

 SYNOPSIS@{ub}
        LONG TextBoxA (APTR, const char *, const char *, UWORD, ULONG *)
        result = TextBoxA (window, caption, textFormat, type, args)
          D0                 A0       A1        A2      D0:16  A3@{b}

 FUNCTION@{ub}
        Display a message to the user, use the system dependent ways to display
        the message. The last argument is used for varargs arguments to be used
        to specify the message.@{b}

 INPUTS@{ub}
        window - a pointer to the Window structure of a window that is located
                 on the screen, the requester should appear.
                 If this argument is NULL, and the calling task is an AmigaDOS-
                 process, the field 'pr_WindowPtr' is taken into account. If this
                 field is NULL, or -1, or the calling task is just an Exec Task,
                 the requester will open on the default public screen.
        caption - The text that should be displayed as title of the requester.
        textFormat - the printf-alike formating text for the messages bodytext.
        type  - The requester type and button-types used for this requester,
                 see @{"<joinOS/misc/TextBox.h>" link "include/TextBox.h/Main"} for details.
        args  - a pointer to the first of the variable number of arguments,
                 that are used to build the bodytext of the requester, according
                 to the printf-alike formating string passed in 'textFormat'.@{b}
 NOTE@{ub}
        The resulting textbody for the Requester shouldn't exceed 256 bytes.@{b}

 RESULT@{ub}
        The function returns the number of the gadget the user pressed, or
        -1 if the requester couldn't be displayed or is killed by a system event.
        The gadgets are numbered: 1,2,...,n,0 from left to right.@{b}

 SPECIAL NOTES@{ub}
        "joinOS.lib" contains an interface stub for a vararg version called
        @{"TextBox()" LINK "TextBox"}.

@ENDNODE
@NODE "UnLockDOSList" "joinOS.library/UnLockDOSList()"
@{b}

 NAME@{ub}
        UnLockDOSList - free the access to the dos list@{b}

 SYNOPSIS@{ub}
        void UnLockDOSList (ULONG)
        UnLockDOSList (AccessFlags)
                           D1@{b}

 FUNCTION@{ub}
        Unlock a Dos list previously locked using LockDosList() or
        AttemptLockDosList().
        The calls to AttemptLockDosList() and LockDosList() are nested, so every
        successfull call to this functions must be matched by the same number of
        calls to this function.
        Unlock the dos list as fast as you can, other processes may wait to get
        access to it.@{b}

 INPUT@{ub}
        AccessFlags - the same accessflags as you specified by the previous call
                       to LockDosList() or AttemptLockDosList().@{b}
 NOTE@{ub}
        NEVER call this function if the previous call to AttemptLockDosList()
        failed.
        Since there is no way to lock the DosList under AmigaOS 1.3 (v34), the
        functions @{"LockDOSList()" LINK "LockDOSList"} and UnLockDOSList() are implemented as
        Forbid()/Permit() pair for these systems, so it is incredibly important
        to unlock the DosList as fast as possible, because the multitasking is
        disabled while the list is locked.@{b}

 SEE ALSO@{ub}
        @{"LockDOSList()" LINK "LockDOSList"}, @{"FindDOSEntry()" LINK "FindDOSEntry"}, @{"NextDOSEntry()" LINK "NextDOSEntry"}

@ENDNODE
@NODE "UnpackStructTags" "joinOS.library/UnpackStructTags()"
@{b}

 NAME@{ub}
        UnpackStructTags  - unpack a structure of values into a taglist@{b}

 SYNOPSIS@{ub}
        ULONG UnpackStructTags (APTR, ULONG *, struct TagItem *)
        num = UnpackStructTags (pack, packTable, tagList)
        D0                       A0      A1        A2@{b}

 FUNCTION@{ub}
        For each table entry, a @{"FindTag()" LINK "FindTag"} will be done and if the matching tag
        is found in the taglist, the data in the structure will be placed into
        the memory pointed to by the tag's ti_Data. ti_Data *must* point to a
        LONGWORD.@{b}

 INPUTS@{ub}
        pack - a pointer to the data area to be unpacked
        packTable - a pointer to the packing information table.
               See <joinOS/misc/tagItems.h> for definition and macros
        tagList - a pointer to the taglist to unpack into@{b}

 RESULTS@{ub}
        num - the number of tag items unpacked@{b}

 SEE ALSO@{ub}
        <joinOS/misc/tagItems.h>, @{"FindTag()" LINK "FindTag"}, @{"PackStructTags()" LINK "PackStructTags"}

@ENDNODE
@NODE "Upper" "joinOS.library/Upper()"
@{b}

 NAME@{ub}
        Upper - convert a character to an upper character@{b}

 SYNOPSIS@{ub}
        upper = Upper (lower)
         D0             D0
        char Upper (const char)@{b}

 FUNCTION@{ub}
        This function returns the upper character of the specified character.
        All characters - including the special characters (like 'ä') - are
        converted to upper characters. If the specified character is a number
        or something like a punctuation mark, or even already an upper character
        the character is returned unchanged.@{b}

 INPUT@{ub}
        lower - the character that should be transformed to its upper equivalent.@{b}

 RESULT@{ub}
        The equivalent upper character to the specified one is returned.
        If there is no equivalent upper character, or the specified one is
        already an upper one, the same character is returned.@{b}

 NOTE@{ub}
        This function is usually implemented as macro.

@ENDNODE
@NODE "WaitDosPkt" "joinOS.library/WaitDosPkt()"
@{b}

 NAME@{ub}
        WaitDosPkt - wait for a packet to arrive at current process's pr_MsgPort@{b}

 SYNOPSIS@{ub}
        struct DosPacket *WaitDosPkt (void)
        dp = WaitDosPkt ()
        D0@{b}

 FUNCTION@{ub}
        Packets that have been sent by an application to a handler and the
        replies thereto returned to the originating process by the handler can
        be waited for by calling this function. WaitPkt() returns a pointer to
        the packet associated with the first message enqueued at the process's
        message port (pr_MsgPort); this requires taht the Message field
        "mn_Node.ln_Name" point to an associated DosPacket structure, of course.
        The message is removed automatically from the message port; it is pointed
        to by the dp_Link field. If no message is pending, this call will wait
        for one to arrive. It will not Wait() if a packet has already been
        enqueued at the port, so calling this function may or may not clear the
        process's message-port signal (SIGF_DOS).@{b}

 RESULT@{ub}
        The first packet found in the process's message port is returned.@{b}

 SEE ALSO@{ub}
        @{"AbortDosPkt()" LINK "AbortDosPkt"}, @{"DoDosPkt()" LINK "DoDosPkt"}, @{"SendDosPkt" LINK "SendDosPkt"}, @{"ReplyDosPkt" LINK "ReplyDosPkt"}

@ENDNODE
