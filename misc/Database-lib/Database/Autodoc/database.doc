TABLE OF CONTENTS

database.library/AtChr                                   
database.library/DBF_AddAlias                            
database.library/DBF_AddOrder                            
database.library/DBF_ClearRecord                         
database.library/DBF_ClearRelation                       
database.library/DBF_FieldGet                            
database.library/DBF_FieldGetRaw                         
database.library/DBF_FieldPut                            
database.library/DBF_FieldPutRaw                         
database.library/DBF_GetOrder                            
database.library/DBF_InitA                               
database.library/DBF_LockRecord                          
database.library/DBF_Pack                                
database.library/DBF_ReIndex                             
database.library/DBF_ReadMemo                            
database.library/DBF_RemoveAlias                         
database.library/DBF_RemoveOrder                         
database.library/DBF_SetAccessMode                       
database.library/DBF_SetLockMode                         
database.library/DBF_SetRelation                         
database.library/DBF_ShowDeleted                         
database.library/DBF_UnLockRecord                        
database.library/DBF_Update                              
database.library/DBF_WriteMemo                           
database.library/DBM_ClearMemo                           
database.library/DBM_CloseMemo                           
database.library/DBM_LockMemo                            
database.library/DBM_OpenMemo                            
database.library/DBM_ReadMemo                            
database.library/DBM_UnLockMemo                          
database.library/DBM_WriteMemo                           
database.library/DC_DefaultConvert                       
database.library/DC_DefaultRevert                        
database.library/DC_SetCaption                           
database.library/DC_SetHelpText                          
database.library/DOUBLELONG2Numeric                      
database.library/DS_AddColumns                           
database.library/DS_DoUpdate                             
database.library/DS_InitA                                
database.library/DS_RemoveColumns                        
database.library/DS_Update                               
database.library/DToS                                    
database.library/Float2Double                            
database.library/IDX_ClearIndex                          
database.library/IDX_CountFields                         
database.library/IDX_Dispose                             
database.library/IDX_EndTransaction                      
database.library/IDX_EvalExpression                      
database.library/IDX_EvalExpressionA                     
database.library/IDX_EvalExpressionB                     
database.library/IDX_FindKey                             
database.library/IDX_GetKeyValue                         
database.library/IDX_InitA                               
database.library/IDX_InsertKey                           
database.library/IDX_KeyCount                            
database.library/IDX_KeyLength                           
database.library/IDX_PreCompileExpression                
database.library/IDX_ReIndex                             
database.library/IDX_RemoveKey                           
database.library/IDX_Seek                                
database.library/IDX_SeekNext                            
database.library/IDX_SetScope                            
database.library/IDX_SkipBottom                          
database.library/IDX_SkipNext                            
database.library/IDX_SkipPrevious                        
database.library/IDX_SkipTop                             
database.library/IDX_StartTransaction                    
database.library/IDX_ValidKey                            
database.library/LToS                                    
database.library/Numeric2DOUBLELONG                      
database.library/Numeric2Str                             
database.library/NumericIntDigits                        
database.library/RAtChr                                  
database.library/STR                                     
database.library/SToD                                    
database.library/SToL                                    
database.library/SToT                                    
database.library/SkipChars                               
database.library/Str2Numeric                             
database.library/TToS                                    

database.library/AtChr                                    database.library/AtChr

 NAME
    AtChr - search the first occurance of a character

 SYNOPSIS
    ULONG AtChr (UBYTE *, UBYTE, ULONG)
    position = AtChr (string, character, slen)
       D0               A0     D0:8       D1

 FUNCTION
    This function searches the first occurance of the specified character
    in the string.

 INPUTS
    string - a pointer to the string
    character - the character searched in the string
    slen - the length of the string

 RESULT
    The position of the first occurance of the character in the string is
    returned, or 0 if the character is not found.

database.library/DBF_AddAlias                      database.library/DBF_AddAlias

 NAME
    DBF_AddAlias - add an alias to an index of a DataTable

 SYNOPSIS
    BOOL DBF_AddAlias (struct DataServer *, STRPTR, STRPTR)
    success = DBF_AddAlias (server, alias, index)
      D0                      A0     A1      A2

 FUNCTION
    This function adds an alias to an index that is attached to a DataTable.
    This alias is just another name for the same index, so if this alias is
    specified for either the function DBF_GetOrder() or the operation
    DS_SETORDER, the aliased index is returned/used instead.

 INPUTS
    server - a pointer to the DataServer structure of the DataTable
    alias - a pointer to a NUL-terminated C-string with the name of the
             alias; i.e. the name that should also be usable to access
             the specified index. Index and alias names are compared
             case sensitive. This string is NOT copied and has to remain
             valid until the alias is removed again.
    index - a pointer to a NUL-terminated C-string with the name of the
             index that should be accessed using this alias.  Index and
             alias names are compared case sensitive.

 RESULT
    If the alias could be added successfully to the DataTable, TRUE is
    returned, else FALSE is returned.

database.library/DBF_AddOrder                      database.library/DBF_AddOrder

 NAME
    DBF_AddOrder - add an index to the servers list of available orders

 SYNOPSIS
    BOOL DBF_AddOrder (struct DataServer *, struct IDXHeader *)
    success = DBF_AddOrder (server, index)
      D0                      A0     A1

 FUNCTION
    This function adds a new index to the servers list of available orders.
    The IDXHeader structure has to be previously created using IDX_InitA()
    and has to reference this DataTable or the function will fail.
    Index names are compared case-sensitive.
 
    The open indexes of a DataTable are linked into a list. This list is
    ordered alphabetically.

    Any non-custom index in that list is updates whenever a record of the
    DataTable is changed (added, changed, or removed).

 INPUTS
    server - a pointer to the DataServer structure of the DataTable
    index - a pointer to the IDXHeader structure of the order to be added

 RESULT
    If the passed index is attached to this DataTable, it is linked into
    the DataTables list of available orders and TRUE is returned.
    If the IDXHeader structure of the index is created for a different
    DataTable, or the 'Name' of the index is already in use, FALSE is
    returned.

 NOTE
    Even if it is possible to add an index-alias to a DataTable using this
    function, you should prefer using the function DBF_AddAlias().

    If you add an index-aliases (IDXAlias structures) to the DataTable, the
    "aliased" index must already been added to the DataTable in a previous
    call to this function.

database.library/DBF_ClearRecord                database.library/DBF_ClearRecord

 NAME
    DBF_ClearRecord - clear the record buffer of the DataTable

 SYNOPSIS
    BOOL DBF_ClearRecord (struct DataTable *)
    success = DBF_ClearRecord (dbTable)
      D0                         A0

 FUNCTION
    This function clears the record-buffer of the DataTable and initializes
    it with the default values.

 INPUT
    dbTable - a pointer to the DataTable structure of the DataServer

 RESULT
    If the function succeeds, TRUE is returned, else FALSE is returned.
    See the 'LastError' field of the embedded DataServer structure for
    details.

 NOTE
    This function is used as callback-function from the DataTable, whenever
    a new record is created, you should NOT call this function from user-
    applications code.

database.library/DBF_ClearRelation            database.library/DBF_ClearRelation

 NAME
    DBF_ClearRelation - remove a related DataServer from a superior server

 SYNOPSIS
    BOOL DBF_ClearRelation (struct DataServer *)
    success = DBF_ClearRelation (client)
      D0                           A0

 FUNCTION
    Using this function a relation between two servers can be released again.

 INPUTS
    client - a pointer to the DataServer structure of the DataTable that
             depends on a superior DataTable. This DataServer has to be
             previously added to the list of related DataServers of the
             superior server by calling DBF_SetRelation().

 RESULT
    If the function succeeds, TRUE is returned; the client-server is removed
    from the list of related DataServer and will not react on changes to the
    current record of the superior DataServer any more.
    If the function fails, FALSE is returned. See 'LastError' for details.

 NOTE
    Even if this function fails, the relation may be cleared. This is the
    case if the 'LastError' field of the superior server is set to
    DBF_ERR_RELATED_SERVER. In this case you should close both servers
    as fast as possible to prevent damage to the database file.

database.library/DBF_FieldGet                      database.library/DBF_FieldGet

 NAME
    DBF_FieldGet - get the contents of a field in human-readable form

 SYNOPSIS
    BOOL DBF_FieldGet (struct DataServer *, STRPTR, STRPTR *)
    success = DBF_FieldGet (server, field, data)

 FUNCTION
    This function copies a pointer to the contents of the specified
    DataColumn of the current row of a DataServer to the user-suplied
    address.

    The contents is presented in human-readable form, i.e. a NUL-terminated
    C-string.

 INPUTS
    server - a pointer to the DataServer structure of the DataServer the data
             should be read from.
    field - a pointer to the NUL-terminated string with the name of the field
             (DataColumn) the data should be read from.
    data - a pointer to the address, where a pointer to the buffer containing
             the NUL-terminated string with the columns contents in human-
             readable form is stored should be copied to.
             Treat this string as constant, it is owned by the DataServer and
             you will corrupt the data of the DataServer if you write to this
             buffer.

 RESULT
    If the data could be read from the specified column of the DataServer
    TRUE is returned, else FALSE is returned.

database.library/DBF_FieldGetRaw                database.library/DBF_FieldGetRaw

 NAME
    DBF_FieldGetRaw - get the "raw" contents of a field

 SYNOPSIS
    BOOL DBF_FieldGetRaw (struct DataServer *, STRPTR, APTR *)
    success = DBF_FieldGetRaw (server, field, rawdata)

 FUNCTION
    This function copies a pointer to the contents of the specified
    DataColumn of the current row of a DataServer to the user-suplied
    address.

    The contents is presented in the "raw" format, i.e. in the format it is
    stored in the DataServer.

 INPUTS
    server - a pointer to the DataServer structure of the DataServer the data
             should be read from.
    field - a pointer to the NUL-terminated string with the name of the field
             (DataColumn) the data should be read from.
    rawdata - a pointer to the address, where a pointer to the buffer
             containing the columns contents in "raw" format is stored should
             be copied to.
             Treat this value as constant, it is owned by the DataServer and
             you will corrupt the data of the DataServer if you write to this
             address.

 RESULT
    If the data could be read from the specified column of the DataServer
    TRUE is returned, else FALSE is returned.

database.library/DBF_FieldPut                      database.library/DBF_FieldPut

 NAME
    DBF_FieldPut - write data in human-readable format into a DataColumn

 SYNOPSIS
    BOOL DBF_FieldPut (struct DataServer *, STRPTR, STRPTR)
    success = DBF_FieldPut (server, field, data)

 FUNCTION
    This function is a shortcut for locating a DataColumn in the current
    record of the DataServer and write the specified data in human-readable
    format into that column.

 INPUTS
    server - a pointer to the DataServer structure of the DataServer the data
             should be written into.
    field - a pointer to the NUL-terminated string with the name of the field
             (DataColumn) the data should be written into.
    data - a pointer to the NUL-terminated string containing the data to be
             written in human-readable format (the data is converted into the
             "raw" format it is stored into the DataServer-file by this
             function).

 RESULT
    If the data could be written into the specified column of the DataServer
    TRUE is returned, else FALSE is returned.

database.library/DBF_FieldPutRaw                database.library/DBF_FieldPutRaw

 NAME
    DBF_FieldPutRaw - write "raw" data into a DataColumn

 SYNOPSIS
    BOOL DBF_FieldPutRaw (struct DataServer *, STRPTR, APTR)
    success = DBF_FieldPutRaw (server, field, rawData)

 FUNCTION
    This function is a shortcut for locating a DataColumn in the current
    record of the DataServer and write the specified data in "raw" format
    into that column.

 INPUTS
    server - a pointer to the DataServer structure of the DataServer the data
             should be written into.
    field - a pointer to the NUL-terminated string with the name of the field
             (DataColumn) the data should be written into.
    rawData - a pointer to the data to be written in "raw" format (the data
             in the format it is stored into the DataServer-file).

 RESULT
    If the data could be written into the specified column of the DataServer
    TRUE is returned, else FALSE is returned.

database.library/DBF_GetOrder                      database.library/DBF_GetOrder

 NAME
    DBF_GetOrder - get access to an index in the servers list of orders

 SYNOPSIS
    struct IDXHeader *DBF_GetOrder (struct DataServer *, STRPTR)
    index = DBF_GetOrder (server, name)
      D0                    A0     A1

 FUNCTION
    This function searches the index with the specified 'name' in the
    DataTables list of available orders.

 INPUTS
    server - a pointer to the DataServer structure of the DataTable
    name - the name of the searched order, if NULL is passed the currently
             active order is searched.
             This function is case sensitive.
             If you specify the name of an index-alias, the according
             index is searched.

 RESULT
    If the specified index is located in the servers list of available
    orders, a pointer to the IDXHeader structure of the index is returned,
    else NULL is returned.

 NOTE
    You should check, if the flag IDX_ALIAS is set in the 'Flags' field
    of the returned structure to determine if it is a pointer to an IDXHeader
    structure or a pointer to an IDXAlias. If the flag is set, the "aliased"
    index is found at the address, the field 'ihd' of the IDXAlias structure
    point to.

database.library/DBF_InitA                            database.library/DBF_InitA

 NAME
    DBF_InitA - create a DataTable-DataServer

 SYNOPSIS
    struct DataServer *DBF_InitA (APTR, struct TagItem *)
    dataServer = DBF_InitA (unused, tagList)
        D0                    A0      A1

 FUNCTION
    This function creates a DataTable for use in a DataBase.
    Access to the records in the DataTables file are synchronized using a
    kind of locking. This function tests, which kind of locking is supported
    by the underlying filesystem. This could be either:

       DSF_LOCK_RECORD - the single records are locked by the DataTable.
             This type of locking is the cooperativest way of locking, only
             the locked records are blocked for other instances, but it
             requires the support of the filesystem, i.e. the filesystem
             has to support record locking. AmigaOS FastFileSystem does it,
             and the Ram-Handler (handline the ram-disk) supports this but
             the version of AmigaOS 3.5 and 3.9 has a mayor bug which leads
             to a Guru.
       DSF_LOCK_FILE - if the FileSystem doesn't support record locking (or
             the record locking is bad implemented as for the AmigaOS 3.5 -
             3.9 Ram-Handler) this locking type is used.
             For every file according to this DataTable (the DataTable file
             itself, the optional memo-file and all indexes attached to the
             DataTable) an additional empty lockfile is created. This file
             is locked shared for every read- and exclusive for every write-
             access.
             This is functional with every known filesystem available for
             AmigaOS, but not as cooperative as record locking, because the
             whole DataTable is inaccessable for every other instance while
             it is locked to change a single record.
             Another disadvantage of this type of locking is the greater
             overhead required for locking a whole file instead of a single
             record and the database requires twice as many files. If the
             DataTable fails to lock a file, it uses a kind of "polling"
             to determine if the file is accessable again, this results in
             a greater load of the cpu and the filesytem (and the underlying
             hardware the harddisk and controller resp. the whole network).

 INPUTS
    unused - this argument is not used in the current implementation, it is
          reserved for future use and should be set to NULL.
    tagList - a pointer to a variable sized array of TagItem structures.
          This array has to be terminated by a TagItem with the Tag
          TAG_DONE.
          Currently defined Tags are:

             THESE TAGS ARE MANDATORY:

          DBF_Name - a pointer to a NUL-terminated C-string with the name of
                   the DataTable. This name may be used to identify the
                   DataServer in an application.
                   The string is limited to 32 characters (incl. terminating
                   NUL-byte) and is truncated to this length if a longer
                   string is passed.
          DBF_FileName - a pointer to a NUL-terminated C-string with the
                   filename (and path) of the DataTable-file.
                   If the file is currently not existing, it will be created.
                   to be present in the TagItem list.
          DBF_Struct - the data of this TagItem is a pointer to an array of
                   DBStruct structures, terminated by a structure with a NULL
                   pointer as 'Name', describing the structure of every row
                   in the DataServers datatable. If the file already exists,
                   the structure described by this array has to match the
                   structure of the DataTables file, the 'Caption' and
                   'HelpText' strings are used in any case.
                   This structure-array is copied and needs not to remain
                   valid after this function returned, but the referenced
                   strings are not copied and need to remain valid until the
                   DataTable is disposed.

             THESE TAGS ARE OPTIONAL:

          DBF_StructSize - ULONG, the size of the structure that should be
                   allocated as DataServer structure. This Tag has to be
                   specified, if a subclass of the DataTable needs additional
                   space in the structure for private data.
          DBF_Exclusive - a boolean TagItem, if a TagItem with this Tag is
                   present in the TagItem list, the DataTable-file will be
                   accessed in exclusive mode, i.e. every other try to open
                   the DataTable (by the same or any other application) will
                   be rejected.
                NOTE
                   This exclusive mode is not functional on every filesystem.
                   If you place the DataTable's files in the ram-disk per
                   example, this will not guarantee exclusive access to the
                   files, due to a bug in the implementation of the
                   ACTION_CHANGE_MODE packet of the Ram-Handler found in
                   every AmigaOS from 3.1 through 3.9.
                   The FastFileSystem is functional under every supported OS.
          DBF_ReadOnly - a boolean TagItem, if a TagItem with this Tag is
                   present in the TagItem list, the DataTable-file will be
                   opened in read-only mode, i.e. any changes to the
                   DataTable will be rejected.
          DBF_ForceUnique - a boolean TagItem, if a TagItem with this Tag is
                   present in the TagItem list, all records that are added or
                   changed will be matched against all open unique indexes.
                   If an IDX_ERR_DUPLICATE_KEY occures (i.e. if the according
                   key-value is already in the index and would be added twice,
                   if the record is saved), the record will not be stored.
                   This flag does only make sence, if there will be at least
                   one unique index opened and attached to the DataTable.
          DBF_LockMode - the identifier passed with this TagItem specifies
                   how the records are locked in the DataTable:
                DSF_LOCK_OPTIMISTIC - (default) use optimistic locking, i.e.
                   the records are locked shared while they are copied into
                   the buffer, then they are unlocked until they are written,
                   then the records are locked exclusive while they are
                   written.
                DSF_LOCK_FULL - a record is locked exclusive while it is the
                   current record. This is a safe but uncooperative locking
                   method.
                DSF_LOCK_NONE - a record is not locked by the DataTable. The
                   user-application has to lock the records using the
                   functions DBF_LockRecord()/DBF_UnLockRecord(). This method
                   requires the most work, but is the way for finetuning the
                   locking of the records.
          DBF_Validate - a pointer to a function that is called, whenever a
                   new or a changed record should be written to the DataTable
                   (when the operation DS_UPDATE is performed). This function
                   should validate the contents of the record. Take care that
                   this function must in no case change the current record
                   (by seeking or skipping) nor the currently active key of
                   any index attached to the DataTable. If you have to search
                   through the DataTable or an index of the DataTable, you
                   have to use another instance of the DataTable (usually
                   opened in read-only mode) for that purpose.
                   If the validation fails, the current column of the
                   DataTable has to be the faulty one (i.e. the operation
                   DS_CURRENTCOLUMN has to return a pointer to the invalid
                   DataColumn). If a general failure occures, you have to
                   set 'server->CurrentColumn' to zero.

                      BOOL validate (struct DataServer *server)

                   The function has to return TRUE, if the record is valid,
                   or FALSE if the record is not valid.

 RESULT
    If the function succeeds, a pointer to a full initialized DataServer
    structure of the DataTable is returned.
    If the function fails, NULL is returned.

database.library/DBF_LockRecord                  database.library/DBF_LockRecord

 NAME
    DBF_LockRecord - lock a record of the DataTable

 SYNOPSIS
    BOOL DBF_LockRecord (struct DataServer *, ULONG, ULONG, ULONG)
    success = DBF_LockRecord (server, recNo, mode, timeout)
      D0                        A0      D0    D1      D2

 FUNCTION
    This function tries to lock the specified record in the DataTable for
    either exclusive or shared access. If the lock fails, the function
    retries to lock the record until at most the timeout-time is elapsed.

    It is safe to try to lock a record that is already locked by this
    instance of the DataTable, if the accessmode is the same, or the record
    is already locked in exclusive mode.

    Every successfull call to this function has to be matched by a call to
    DBF_UnLockRecord().

    Several records can be locked at the same time.

 INPUTS
    server - a pointer to the DataServer structure of the DataTable
    recNo - the number of the record that should be locked. If zero is passed
             to this argument, the header of the DataTable is locked.
    mode - the desired locking mode:
       DBF_READ - for read-only access (shared lock)
       DBF_WRITE - for writing access (exclusive lock)
    timeout - the maximum time in 50th of a second, that should be waited if
             the lock fails. You may use the following defines:
       DBF_WAIT_FOREVER - wait (nearly) forever (aware of deadlocks)
       DBF_WAIT_NONE - don't wait, return immediately
       DBF_WAIT_DEFAULT - default timeout, currently defined as 5 seconds

 RESULT
    If the record could be locked, TRUE is returned.
    If the function fails to lock the record, FALSE is returned. See
    'server->LastError' and IoErr() for errorcodes describing the cause of
    the failure.

database.library/DBF_Pack                              database.library/DBF_Pack

 NAME
    DBF_Pack - remove all deleted records from the DataTable.

 SYNOPSIS
    BOOL DBF_Pack (struct DataServer *, REINDEX_PROGRESS, APTR)
    success = DBF_Pack (server, fct, userData)
      D0                  A0     A1     A2

 FUNCTION
    This function removes every deleted record from the DataTable, so the
    according file shrinks in size. Every attached index is also adjusted
    so their keys reference the new recordnumbers of the records.

    This operation takes a long time, and should only be used, if there
    are many deleted records in the DataTable and new records are not
    inserted very often (i.e. if it makes sence to safe the disk-space
    used for the deleted records). Deleted records doesn't decrease the
    access-speed of the DataTable and are overwritten whenever a new record
    is inserted.

 INPUTS
    server - a pointer to the DataServer structure of the DataTable
    fct - a pointer to a callback function, which might be used to interact
          with the user, i.e. to show some kind of progress to the user and
          allow him to interrupt this operation.
          This function will be called everytime a deleted record is removed.
          If NULL is passed for this argument, the progress of this function
          is not visible or abortable.
          The function has to expect three arguments:
                - a pointer to the DataServer structuure of this DataTable
                - the number of records already processed
                - a pointer to user-defined data.
          The function has to return a boolean value, if FALSE is returned,
          the operation is aborted. Even if the operation is aborted, the
          DataTable stays valid.
    userData - a pointer to any data, that is passed as second argument to
          the callback function.

 RESULT
    If the function succeeds, TRUE is returned.
    If the function fails or is aborted, FALSE is returned, see the field
    'LastError' of the DataServer for the according errorcode. This will
    be zero, if the user has aborted the operation.

 NOTE
    You should have opened and attached every index of the DataTable (as
    for every function that manipulated the DataTable) when this function
    is called. Locking is not required, the operation will only start, if
    the DataTable could gain exclusive access to the according file and the
    indexes.

 KNOWN BUGS
    Not implemented yet ;-)

database.library/DBF_ReIndex                        database.library/DBF_ReIndex

 NAME
    DBF_ReIndex - recreate a whole index

 SYNOPSIS
    BOOL DBF_ReIndex (struct DataServer *, STRPTR, REINDEX_PROGRESS, APTR)
    success DBF_ReIndex (server, order, fct, userData)
      D0                   A0     A1     A2     A3

 FUNCTION
    This function is a wrapper-function for the function IDX_ReIndex().
    It performs the neccessary preparations to speed up the reindexing
    process. All indexes and related servers are temporary detached from
    the DataTable and reattached, after the reindexing process is finished.

 INPUTS
    server - a pointer to the DataServer structure of the DataTable
    order - a pointer to a NUL-terminated string with the name of the index
             to be reindexed. This index has to be currently attached to
             the server. If NULL is passed for this argument, the currently
             active order is reindexed.
    fct - a pointer to a function called everytime ten records are indexed.
          If NULL is passed for this argument, the progress of this function
          is not visible or abortable.
          The function has to expect three arguments:
                - a pointer to the IDXHeader structure of this index
                - the number of records already processed
                - a pointer to user-defined data.
          The function has to return a boolean value, if FALSE is returned,
          the indexing is aborted.
    userData - a pointer to any data, that is passed as second argument to
          the callback function.

 RESULT
    If the function succeeds, TRUE is returned.
    If the function fails, FALSE is returned.

 NOTE
    If the underlying filesystem doesn't support the SetFileSize() command,
    or due to the "Exclusive Mode"-bug in the Ram-Handler, the index may be
    destroyed by this function.
    If the index is destroyed, it is disposed completely. In that case you
    have to delete the index-file manually, before you reopen the index and
    try to recreate it again (you could see that the index is destroyed, if
    this function fails and the operation DS_AVAILABLEORDER does not list
    the index any more).

database.library/DBF_ReadMemo                      database.library/DBF_ReadMemo

 NAME
    DBF_ReadMemo - load a memoText into memory

 SYNOPSIS
    BOOL DBF_ReadMemo (struct DataColumn *, APTR)
    success = DBF_ReadMemo (column, memoAddr)
      D0                      A0       A1

 FUNCTION
    This function copies the memotext of the current record into the buffer
    of the specified DataColumn.
    If the current record doesn't own a memotext, an empty string is copied
    into the buffer (i.e. just the terminating NUL-byte).

 INPUTS
    column - a pointer to the DataColumn of the memotext
    memoAddr - a pointer to the two longwords containing the address of the
                memotext in the memofile.
                The first longword contains the number of the 'page' in the
                memofile, where the text starts, the second longword contains
                the offset into that page. If both values are equal zero, the
                record doesn't own a memotext.

 RESULT
    If the memotext could be successfully copied into memory, TRUE is
    returned, else FALSE is returned.

 NOTE
    This function is used as callback-function from the DataTable, whenever
    a memo is read, you should NOT call this function from user-applications
    code.

database.library/DBF_RemoveAlias                database.library/DBF_RemoveAlias

 NAME
    DBF_RemoveAlias - remove an alias of an index of a DataTable

 SYNOPSIS
    BOOL DBF_RemoveAlias (struct DataServer *, STRPTR)
    success = DBF_RemoveAlias (server, alias)
       D0                        A0      A1

 FUNCTION
    This function removes an alias of an index of the DataTable. The memory
    used for this alias is freed.

 INPUTS
    server - a pointer to the DataServer structure of the DataTable
    alias - a pointer to a NUL-terminated C-string with the name of the
             alias that should be removed. Index and alias names are compared
             case sensitive.

 RESULT
    If the alias could be removed successfully from the DataTable, TRUE is
    returned, else FALSE is returned.

 NOTE
    Aliases are also removed, if the "aliased" index is removed (using the
    function DBF_RemoveOrder()) or the DataTable is disposed.

database.library/DBF_RemoveOrder                database.library/DBF_RemoveOrder

 NAME
    DBF_RemoveOrder - remove an index from the servers list of orders

 SYNOPSIS
    struct IDXHeader *DBF_RemoveOrder (struct DataServer *, STRPTR)
    index = DBF_RemoveOrder (server, name)
     D0                        A0     A1

 FUNCTION
    This function removes the index with the specified 'name' from the
    DataTables list of available orders. If the index to be removed is
    the active order, the active order of the server is cleared and the
    records are ordered as they are found in the DataTable file.

 INPUTS
    server - a pointer to the DataServer structure of the DataTable
    name - the name of the order to be removed. This function is case
             sensitve

 RESULT
    If the specified order is located in the servers list of available
    orders, it is removed and a pointer to the IDXHeader structure of the
    order is returned, else NULL is returned.

 NOTES
    Even if it is possible to remove an index-alias to a DataTable using this
    function, you should prefer using the function DBF_RemoveAlias().

    You should check, if the flag IDX_ALIAS is set in the 'Flags' field
    of the returned structure to determine if it is a pointer to an IDXHeader
    structure or a pointer to an IDXAlias. If the flag is set, the "aliased"
    index is found at the address, the field 'ihd' of the IDXAlias structure
    point to.

    If an "aliased" index is removed from the DataServer, all aliases to this
    index are removed (and freed) too.

    Any alias removed using this function has to be either added back to the
    DataTable using DBF_AddOrder() or disposed by:
       FreeMem (alias, sizeof (struct IDXAlias));

database.library/DBF_SetAccessMode            database.library/DBF_SetAccessMode

 NAME
    DBF_SetAccessMode - change the accessmode of a DataTable.

 SYNOPSIS
    BOOL DBF_SetAccessMode (struct DataServer *, BOOL)
    currentAccessMode = DBF_SetAccessMode (server, exclusive)
           D0                                A0       D0

 FUNCTION
    Using this function, the accessmode of a DataTable can be changed.
    Usually the accessmode is specified during initialization (using the
    Tag DBF_Exclusive) and should not be changed, but sometimes it's
    required to have exclusive access to a DataTable (e.g. if all deleted
    records should be removed from the DataTable, so the recordnumbers of
    the remaining records will change).

    This function may fail to change the accessmode, especially if exclusive
    access is requested. Have a look to the 'LastError' field of the
    DataServer structure, which will be set to DSF_ERR_MINOR in the case of
    a failure. In that case you may also look at AmigaDOS IoErr() to get an
    idea of the cause of the failure.

 INPUTS
    server - a pointer to the DataServer structure of the DataTable
    exclusive - a boolean value, TRUE indicates that the DataTable should be
             set to exclusive access, else shared access is requested.

 RESULT
    If the DataTable was previously set to exclusive access, TRUE is
    returned, if it was set to shared access, FALSE is returned.
    By storing this value you are able to reset the DataTable to the previous
    state.

 KNOWN BUGS
    The exclusive mode is not functional on every filesystem, e.g. if you
    place the DataTable's files in the ram-disk, this will not guarantee
    exclusive access to the files, due to a bug in the implementation of the
    ACTION_CHANGE_MODE packet of the Ram-Handler found in every AmigaOS from
    version 3.1 through 3.9.
    The FastFileSystem is functional under every supported OS.

database.library/DBF_SetLockMode                database.library/DBF_SetLockMode

 NAME
    DBF_SetLockMode - change the locking-mode of a DataTable

 SYNOPSIS
    ULONG DBF_SetLockMode (struct DataServer *, ULONG)
    currentMode = DBF_SetLockMode (server, lockMode)
        D0                           A0       D0

 FUNCTION
    This function can be used to change the locking-mode of an already opened
    DataTable. Per default the locking-mode as specified during initialization
    is used (using the Tag DBF_LockMode).

    The current record may change as a result of this function, if the mode
    DSF_LOCK_FULL is specified.

 INPUTS
    server - a pointer to the DataServer structure of the DataTable
    lockMode - the new locking-mode that should be used, this could be
                either:
             DSF_LOCK_OPTIMISTIC - use optimistic locking, i.e. the records
                   are locked shared while they are copied into the buffer,
                   then they are unlocked until they are written, then the
                   records are locked exclusive while they are written.
             DSF_LOCK_FULL - a record is locked exclusive while it is the
                   current record. This is a safe but uncooperative locking
                   method.
             DSF_LOCK_NONE - a record is not locked by the DataTable. The
                   user-application has to lock the records using the
                   functions DBF_LockRecord()/DBF_UnLockRecord(). This method
                   requires the most work, but is the way for finetuning the
                   locking of the records.

 RESULT
    The active locking mode before this function was called is returned.
    By storing this value you are able to reset the DataTable to the previous
    state.
    You have to check the 'LastError' field of the DataServer for an error;
    if the locking-mode is set to DSF_LOCK_FULL, the DataTable may fail to
    lock the current record. In this case the current record is undefined,
    i.e. the recordpointer is set to EOF.

database.library/DBF_SetRelation                database.library/DBF_SetRelation

 NAME
    DBF_SetRelation - add a related DataServer to a superior DataServer

 SYNOPSIS
    BOOL DBF_SetRelation(struct DataServer*,struct DataServer*,STRPTR,STRPTR)
    success = DBF_SetRelation (server, client, order, expr)
      D0                         A0      A1     A2     A3

 FUNCTION
    This function is used to add a related DataServer to the list of related
    DataServers of a superior DataTable. This way, the two DataServers react
    like a single DataServer, e.g. the DataBrowser class handles this as a
    single DataServer and is able to display all columns of both servers. 

    While the two servers are related, the related DataServer should not be
    accessed direct, except for changing its data. the current record of this
    DataServer is changed according to the current record of the superior
    DataServer. If you change the order or current record of the related
    server, these changes are undone the next time the superior server is
    moved.

 INPUTS
    server - a pointer to the DataServer structure of the superior DataTable
    client - a pointer to the DataServer structure of the DataTable that
             depends on the superior DataTable. This DataTable will be
             positioned relative to the other one. Whenever the record of
             the superior DataServer is changed, the current record of this
             DataServer will also change, according to the relation-
             expression.
    order - a pointer to a NUL-terminated C-string with the name of the index
             that should be used by the related DataServer. Using this index
             and a key generated by the specified expression and the data of
             the superior DataServer, this DataServer is positioned to the
             correct record. This index has to be unique, i.e. every key in
             this index has to be unique.
             This string is not copied, so it has to stay valid until the
             relation is cleared again (using DBF_ClearRelation()) or one
             of the two servers is closed (and the relation is cleared
             implicit).
    expr - a pointer to a key-expression that describes the relation between
             the two DataServers. By using this expression with the data of
             the current record of the superior DataTable the key for the
             order, used by the related DataServer, is generated. This key
             has to be unique for every record of the DataServer.
             This string is not copied, so it has to stay valid until the
             relation is cleared again (using DBF_ClearRelation()) or one
             of the two servers is closed (and the relation is cleared
             implicit).

 RESULT
    If the function succeeds, TRUE is returned; the client-server is now
    inserted in the list of related DataServers and will react on changes
    to the current record of the superior DataServer.
    If the function fails, FALSE is returned. See 'LastError' of both
    DataServers for details.

database.library/DBF_ShowDeleted                database.library/DBF_ShowDeleted

 NAME
    DBF_ShowDeleted - enable/disable processing of deleted records

 SYNOPSIS
    BOOL DBF_ShowDeleted (struct DataServer *, BOOL)
    showDeleted = DBF_ShowDeleted (server, deleted)
         D0                          A0       D0

 FUNCTION
    Usually deleted records are never used as active records of a DataTable.
    By passing TRUE with the second argument to the DataTable, the according
    flag is set, so deleted records may be activated.

    Even if the flag is set, the deleted records could only be activated, if
    no index is activated! If the DataTable has a column of the type DC_TEXT
    (i.e. it owns a memo-file) the contents of that column may be disturbed,
    because that contents of the memo file is overwritten independent of the
    DataTables main file.

 INPUTS
    server - a pointer to the DataServer structure of the DataTable
    deleted - a boolean value, TRUE indicates that deleted records should be
             accessable.

 RESULT
    The setting of the deletion-flag before this function was called is
    returned. By storing this value you are able to reset the DataTable
    to the previous state.

 NOTE
    Per default deleted records are not displayed and you should not activate
    that option, except if you try to retrieve data that is stored in a
    deleted record. But you have only a small chance, because the last
    deleted record is the first one that is overwritten, if a new record is
    added to the DataTable (deleted records are referenced in a "lifo" for
    reuse).

database.library/DBF_UnLockRecord              database.library/DBF_UnLockRecord

 NAME
    DBF_UnLockRecord - unlock a  record of the DataTable

 SYNOPSIS
    BOOL DBF_UnLockRecord (struct DataServer *, ULONG)
    success = DBF_UnLockRecord (server, recNo)
      D0                          A0      D0

 FUNCTION
    This function has to be called for every DBF_LockRecord() that is called.
    If frees the lock of the specified record in the DataTable, so it can be
    accessed by any other instance.

    It is safe to try to unlock a record that is not locked; this will result
    in the errorcode DBF_ERR_REC_NOT_LOCKED set to 'server->LastError'.

 INPUTS
    server - a pointer to the DataServer structure of the DataTable
    recNo - the number of the record that should be unlocked. If zero is
             passed to this argument, the header of the DataTable is unlocked

 RESULT
    If the record could be unlocked, TRUE is returned.
    If the function fails to unlock the record, FALSE is returned. See
    'server->LastError' for an errorcode describing the cause of the failure.

database.library/DBF_Update                          database.library/DBF_Update

 NAME
    DBF_Update - perform an operation on a DataTable

 SYNOPSIS
    BOOL DBF_Update (struct DataServer *, ULONG, APTR)
    success = DBF_Update (server, operation, arg)
      D0                    A0       D0      A1

 FUNCTION
    This function performs any operation on a DataTable.
    Any operation that is not performed by this function is passed to the
    DS_Update() function of the underlying DataServer.

 INPUTS
    server - a pointer to the DataServer structure of the DataTable to be
             accessed.
    operation - the operation that should be performed, the DataTable
             supports the following operations, all other values would
             lead this function to call the DS_Update() function of the
             underlying DataServer.

          These operations are direct supported by the DataTable:

          DS_UPDATE - synchronize the changes made to the DataTables current
                   record and the DataTable-file. If the record has been
                   added or removed, the according record is added (removed)
                   to (from) the datatable and all indexes attached to the
                   the DataTable. If changes have been made to the record,
                   these changes are written to the datatable and all indexes
                   are updated to match these changes.
                   This operation should be performed before any further
                   access to the DataServer is performed, i.e. before the
                   current record is changed or all changes will be lost.
                   If a new record is added to the DataTable or a record is
                   changed, but it fails the validation (i.e. any of the
                   user-supplied validate functions fail or a column is
                   empty that must not be empty) the field 'LastError' is set
                   to DBF_ERR_REC_NOT_VALID. The operation DS_CURRENTCOLUMN
                   would return a pointer to the column that falls through
                   the validation in that case.
                   If the current record is removed, the following record
                   will be activated as current record, but you should take
                   care that the records are ordered ascend, or the current
                   record will be the logically previous one.
                   If this operation succeeds, the currently active column is
                   undefined, i.e. the result of a following DS_CURRENTCOLUMN
                   operation is undefined and may return a pointer to any
                   column, or may also fail. You have to send DS_GOTOCOLUMN
                   or DS_FINDCOLUMN first.

          DS_ADDCOLUMN - append a new column to the end of the DataServers
                   list of DataColumns; the argument 'arg' has to point to a
                   full initialized DataColumn structure. If this DataColumn
                   belongs to another DataServer (i.e. the field 'Server' of
                   this structure points to a different server), this
                   structure and the referenced strings will be copied and
                   added to the end of the list of already present columns.
                   If the DataColumn references this DataTable, this
                   operation will fail.

          DS_REMOVECOLUMN - remove a column from the DataTable, the argument
                   'arg' has to specify the number of the DataColumn to be
                   removed. IT is only allowed to remove columns that belongs
                   to another DataServer (i.e. the field 'Server' of
                   this structure points to a different server).
                   If the operation succeeds, and the removed column is the
                   current column of the DataServer, the next column will
                   went to be the current column. If no next column is
                   existent, the previous column wents to be the current
                   DataColumn.

          DS_MOVECOLUMN - this operation is not allowed for DataTables, so
                   this operation will always fail and set an errorcode of
                   DS_ERR_OP_NOT_KNOWN to 'LastError'.

          DS_FINDCOLUMN - select a column specified by its 'Name'. The
                   argument 'arg' has to be a pointer to a NUL-terminated
                   string with the 'Name' of the searched column.
                   If there are one or more client-servers related to this
                   DataTable, there might be several columns with the same
                   name in the DataTables list of columns. This operation
                   will always find the first column with the name (the
                   first columns are always the DataColumns owned by the
                   DataTable). If you want to find an equal named column of
                   a related server, the columns name has to be preceded
                   by the name of the server followed by an colon; e.g.
                   "Foobar:Foo" addresses the DataColumn named "Foo" of the
                   DataServer "Foobar".

          DS_INSERTROW - a new record should be inserted into the DataTables
                   datatable, the columns of the record are initialized to
                   defaults.
                   After this operation has succeeded, the operation
                   DS_SETRAWDATA or DS_SETCOLUMNDATA has to be called for the
                   columns that should be set-up with values, followed by the
                   operation DS_UPDATE to write the changes into the
                   datatable and the attached indexes.

          DS_REMOVEROW - the current record is marked to be deleted. The
                   operation DS_UPDATE has to be performed to remove the
                   record from the DataTables datatable.

          DS_GOTOROW - go to any record by its number; the argument 'arg',
                   interpreted as ULONG, specifies the number of the record
                   that should be selected as current record starting with 1.
                   If zero or a value greater than the number of available
                   records is specified, this function fails, the current
                   record is set to zero (EOF).
                   This operation can be used to access deleted records. In
                   this case the operation may return FALSE and set the
                   DataTables errorcode to 'IDX_ERR_NO_KEY' if any indexes
                   are attached to the DataTable. Nevertheless the columns
                   of the selected record are available.

          DS_NEXTROW - go to next record, the one behind the current one in
                   the currently active order. If there are no more records
                   available, this function will fail, the current record is
                   undefined.

          DS_PREVROW - go to previous record, the one before the current one
                   in the currently active order. If there are is no record
                   before the current one, this function will fail, the
                   current record is undefined.

          DS_FIRSTROW - go to first record, the first available record in the
                   currently active order. If there are no records available
                   at all, this function will fail.

          DS_LASTROW - go to last record, the last available record in the
                   currently active order. If there are no records available
                   at all, this function will fail.

          DS_SKIPROWS - skip any number of records, the argument 'arg' is
                   interpreted as long value, specifying the num. of records
                   that should be skipped. If the argument is less than zero,
                   the records are skipped to the top of the DataTable else
                   the records are skipped to the bottom of the DataTable.
                   If EOF or BOF are reached, this operation will fail, the
                   current record is undefined.

          DS_NUM_OF_ROWS - get number of accessable records, i.e. the number
                   of keys stored in the active order regarding the current
                   setting of the order-scope, or -- if no order is active --
                   the number of records stored in the datatable of the server
                   The result will be copied to the ULONG 'arg' points to.
                   The current record will be pointing to EOF after this
                   function has been called.

          DS_GETRAWDATA - get the data of the current column. If there is
                   a currently selected column and the current record is
                   valid, a pointer to the data of this column in the current
                   record is copied to the address, 'arg' points to. The type
                   of this pointer depends on the datatype of the column:
             DC_BYTE - pointer to a single byte
             DC_LOGIC - pointer to a single byte, 0 => FALSE, ~0 => TRUE
             DC_WORD - pointer to a word (2 byte) at an even address
             DC_LONG - pointer to a longword (4 byte) at a longword address
                      (divideable by 4)
             DC_DOUBLELONG - ptr to a DOUBLELONG (8 byte) at a longword
                      address (divideable by 4)
             DC_FLOAT - pointer to a float (4 byte) at a longword address
                      (divideable by 4)
             DC_DOUBLE  - pointer to a double (8 byte) at a longword address
                      (divideable by 4)
             DC_NUMERIC - pointer to a buffer of 'DataColumn.Length' bytes
             DC_DATE - pointer to a buffer of 8 bytes in length 
             DC_TIME - pointer to a longword (4 byte) at a longword address
                      (divideable by 4)
             DC_CHAR - pointer to a buffer of 'DataColumn.Length' bytes
             DC_TEXT - pointer to the address where the location of the
                      according string in the memo-file attached to this
                      DataTable is stored. This address is splitted into
                      two parts, the first ULONG contains the number of the
                      page in the memo-file, where the string is stored, the
                      second ULONG value is the offset into this page.
                      The size of the pages depends on the memo-file used,
                      usually a page is 1024 bytes large.
             DC_VARCHAR - pointer to a STRPTR, where the address of the
                      string is copied to, take care that the string is
                      constant and has not to be modified, copy it to a
                      local storage, before modifying it.

          DS_GETCOLUMNDATA - get the data of the current column in human-
                   readable form, i.e. the contents is converted into a
                   NUL-terminated C-string. A pointer to that read-only
                   string is copied into the address 'arg' points to.
                   If no function-pointer is placed in the 'Convert' member
                   of the DataColumn structure of the current column,
                   standard convertion is done.

          DS_SETRAWDATA - change the data of the current column. If there
                   is a currently selected column and the current record is
                   valid, the data is changed according to the new data,
                   pointed to by 'arg'. The type of data 'arg' has to point
                   to depends on the type of the current column.
                   The state of the DataServer flag DSF_READONLY respectively
                   the flag DCF_READONLY of the current DataColumn is
                   respected by this operation.

          DS_SETCOLUMNDATA - change the data of the current column as by the
                   operation DS_GETCOLUMNDATA, except that 'arg' has to point
                   to a NUL-terminated C-string with the new data, formated
                   like the string returned by DC_GETCOLUMNDATA.

          DS_SETORDER - change the order of the rows; 'arg' points to the new
                   order that should be used. This has to be a pointer to a
                   NUL-terminated C-string  with the 'Name' of the order.
                   This order has to be added already to the DataTables list
                   of orders using DBF_AddOrder().
                   The 'Name' of an order is case-sensitive !
                   The current record should be still the same after this
                   operation has been performed, but if the new order doesn't
                   contains an entry for this record, the position is set to
                   EOF.
                   Any unstored changes done to the current record are lost.

          DS_GETORDER - get the order of the records; a pointer to the
                   current order is stored in the address 'arg' points to,
                   this will be a pointer to a NUL-terminated C-string with
                   the 'Name' of the active order or NULL, if no order is
                   active.
                   By passing this name to the function DBF_GetOrder() you
                   could gain access to the IDXHeader structure of the active
                   order (index).

          DS_AVAILABLEORDER - get a pointer to a list with the available
                   orders of the DataServer; a pointer to a list of orders
                   available for this DataServer is copied to the address
                   'arg' points to.
                   The type of this list is a NULL-terminated array of
                   string-pointers. This array and the referenced strings
                   are owned by the DataTable and might be invalidated at the
                   next access to the DataTable, so you should copy the whole
                   list with all strings, if you have to do any further
                   processing using this list.

          DS_ORDERASCEND - changing the sorting-order of the records. If the
                   argument 'arg' is not NULL, the records are ordered ascend
                   else the records are ordered descend. This sorting-order
                   is used for every index. If currently no index is active,
                   the sorting order is not (visibly) changed.
                   The current record is not affected by this function.

          DS_KEYEXPRESSION - get a pointer to the expression used to generate
                   the keys for the records in the currently active order.
                   A pointer to the NUL-terminated string with the expression
                   is copied to the address 'arg' points to.

          DS_KEYLENGTH - get the length of a keyvalue of the currently active
                   order. This size is required to allocate a buffer large
                   enough to store a keyvalue as required for DS_CURRENTKEY.
                   The length is copied to the ULONG value 'arg' points to.

          DS_CURRENTKEY - get the keyvalue of the current record in the
                   currently active order . This keyvalue is copied to the
                   buffer 'arg' points to. Take care that the buffer is large
                   enough to store a keyvalue (see DS_KEYLENGTH). This value
                   might be passed to the operation DS_SEEK to find this
                   record again.

          DS_SEEK - seek to an value of the order from top to bottom; the
                   argument 'arg' points to the keyvalue to be searched. If
                   soft-seek is enabled, the search starts at the current
                   record and stops if a record is found with a keyvalue,
                   whichs is equal or greater than the specified value, else
                   the search starts at the first record and stops on the
                   first record with an exact matching keyvalue.
                   If no order is active, this operation fails with an error-
                   code of DS_ERR_OP_NOT_KNOWN.

          DS_SEEKNEXT - equivalent to DS_SEEK, except that the search starts
                   at the next record behind the current record.

          DS_ORDERASCEND - order the records ascend or descend; the argument
                   'arg' is interpreted as boolean, if 'arg' is not NULL,
                   the rows are ordered in ascend order, otherwise they are
                   ordered descend. After this operation has succeeded, the
                   operation DS_UPDATE should be performed to match the
                   new order.

          DS_SELECTROW - this operation can be used to select or unselect
                   the current record. The argument 'arg' is interpreted as
                   boolean, if it is TRUE, the current record is selected,
                   else the selection of the current row is cleared.
                   The operation returns TRUE, if it could be successfully
                   performed, it returns FALSE, if an unexpected error
                   occurs, 'LastError' is set accordingly.

          DS_FIRSTSELECTED - this operation performs a skip to the first
                   selected record, if there is one selected at all. If
                   no record is selected, 'LastError' is set to
                   "DS_ERR_NO_MORE_DATA". If 'arg' is not NULL, it has to
                   point to an ULONG, where the number of the first selected
                   record is stored. If no record is selected, the value --
                   'arg' points to -- is not changed.
                   The selected records are ordered in the order they are
                   selected, not ordered by the currently active index of the
                   DataTable !

          DS_NEXTSELECTED - if more than one record is selected, this
                   operation performs a skip to the next selected record.
                   If there are no more records selected, 'LastError' is set
                   to "DS_ERR_NO_MORE_DATA". If 'arg' is not NULL, it has to
                   point to an ULONG, where the number of the first selected
                   record is stored. If no record is selected, the value --
                   'arg' points to -- is not changed.
                   The selected records are ordered in the order they are
                   selected, not ordered by the currently active index of the
                   DataTable !

          DS_CLEARSELECTION - this operation clears all selections made.
                   The argument 'arg' is not used.

          DS_ISSELECTED - this operation evaluates if the current record is
                   selected.
                   If the current record is not selected, FALSE is returned;
                   if the current record is selected, TRUE is returned.
                   'DataServer.LastError' is set to 0.
                   The argument 'arg' is not used.

          DS_ALLOWSELECTION - the DataTable supports selection of single or
                   multiple records, so this operation will always set
                   'DataServer.LastError' to zero and return TRUE.

          DS_DISPOSE - the DataTable is disposed, all resources used by the
                   DataTable and the attached Indexes are freed.
                   The argument 'arg' is not used.

 RESULT
    If the operation succeeds, TRUE is returned. Depending on the type of
    operation performed, the address 'arg' points to may have changed.
    If the function fails, FALSE is returned, check 'DataServer.LastError'
    for the cause of the failure.

    If the current row is changed as the result of the operation (e.g.
    DS_GOTOROW, DS_SKIPNEXT, DS_SEEK, etc.) the currently active column is
    undefined, i.e. the result of a following DS_CURRENTCOLUMN operation is
    undefined and may return a pointer to any column, or may also fail. You
    have to send DS_GOTOCOLUMN or DS_FINDCOLUMN before accessing any column
    (i.e. before you read or write any data to the DataTable).

database.library/DBF_WriteMemo                    database.library/DBF_WriteMemo

 NAME
    DBF_WriteMemo - write a memotext into the buffer of a DataColumn

 SYNOPSIS
    BOOL DBF_WriteMemo (struct DataColumn *, STRPTR, APTR)
    success = DBF_WriteMemo (column, memoText, raw)
      D0                       A0       A1     A2

 FUNCTION
    This function converts a NUL-terminated string containing the text of a
    memotext into the raw format, so it can be stored in the memo-file of the
    DataTable.

 INPUTS
    column - a pointer to the DataColumn of the memotext
    memoText - a pointer to the NUL-terminated memotext
    raw - a pointer to the destination buffer, this argument is ignored by
          this function, it always uses the default buffer of the DataColumn.

 RESULT
    If the memotext could be successfully stored in the buffer of the
    DataColumn, TRUE is returned, else FALSE is returned (usually not enough
    free memory available).

 NOTE
    This function is used as callback-function from the DataTable, whenever
    a memo is written, you should NOT call this function from user-
    applications code.

database.library/DBM_ClearMemo                    database.library/DBM_ClearMemo

 NAME
    DBM_ClearMemo - clear a memo stored in the memo-file 

 SYNOPSIS
    BOOL DBM_ClearMemo (struct MemoFile *, DOUBLELONG *)
    success = DBM_ClearMemo (mf, addr)
      D0                     A0   A1

 FUNCTION
    This function disposes a memo stored in the memo-file and frees the
    storage used by it, i.e. the storage of that memo is added to the list
    of unused blocks.

    This function has to be enclosed by the function pair DBM_LockMemo()/
    DBM_UnLockMemo(), if the accoding DataTable is not opened exclusive.

 INPUTS
    mf - a pointer to the MemoFile structure of the memo-file
    addr - a pointer to a DOUBLELONG conatining the address of the memo. The
          high-longword contains the 'page' the memo starts, the low-longword
          contains the offset into that 'page'. If this is a valid address,
          the memo found there is disposed by this function and the used
          storage is freed.

 RESULT
    If the function succeeds, TRUE is returned, else FALSE is returned.

database.library/DBM_CloseMemo                    database.library/DBM_CloseMemo

 NAME
    DBM_CloseMemo - terminate the access to a memofile

 SYNOPSIS
    void DBM_CloseMemo (struct MemoFile *)
    DBM_CloseMemo (mf)
                   A0

 FUNCTION
    This function terminates the access to a memofile. All resources used
    for accessing the memofile are freed.

 INPUT
    memo - a pointer to the MemoFile structure of the memo-file

database.library/DBM_LockMemo                      database.library/DBM_LockMemo

 NAME
    DBM_LockMemo - lock the memo-file for save write-access

 SYNOPSIS
    BOOL DBM_LockMemo (struct MemoFile *mf)
    success = DBM_LockMemo (mf)
      D0                    A0

 FUNCTION
    This function locks the memo-file, so any further accesses to the file
    are refused.
    The memo-file has to be locked before any write-access is performed.
    Read-accesses to the memo-file are locked by the record-locks of the
    DataTable the memo-file is attached to.

 INPUT
    mf - a pointer to the MemoFile structure of the memo-file

 RESULT
    If the function succeeds, TRUE is returned, else FALSE is returned.

database.library/DBM_OpenMemo                      database.library/DBM_OpenMemo

 NAME
    DBM_OpenMemo - open/create the memofile

 SYNOPSIS
    BPTR DBM_OpenMemo (STRPTR)
    memoFh = DBM_OpenMemo (fileName)
      D0                      A0

 FUNCTION
    This function opens the memo-file for shared access.
    If the file is currently not existing, it is created by this function.

    The file has to contain the multi-byte character 'DBM ' in the first
    four bytes followed by the long value with the version of the file,
    which has to be one or this function will fail, setting an IoErr() of
    ERROR_OBJECT_WRONG_TYPE.
    So the first 8 bytes of the file have to be:

       0x44 0x42 0x4D 0x20 0x00 0x00 0x00 0x01

 INPUT
    fileName - a pointer to the NUL-terminated C-string containing the
             filename and (optional) the path of the file to be opened.

 RESULT
    If the function succeeds, a BPTR of the FileHandle of the memo-file
    is returned, else zero is returned.

database.library/DBM_ReadMemo                      database.library/DBM_ReadMemo

 NAME
    DBM_ReadMemo - load a memo into memory

 SYNOPSIS
    APTR DBM_ReadMemo (struct MemoFile *, DOUBLELONG *)
    memo = DBM_ReadMemo (mf, addr)
     D0                  A0   A1

 FUNCTION
    This function copies the memo of the current record into the a new
    allocated buffer.

 INPUTS
    mf - a pointer to the MemoFile structure of the memo-file
    addr - a pointer to a DOUBLELONG containing the address of the memo. The
          high-longword contains the 'page' the memo starts, the low-longword
          contains the offset into that 'page'.

 RESULT
    If the memo could be successfully copied into memory, a pointer to this
    memoryblock is returned. You have to free this block using FreeVector().
    If the function fails or the specified address of the memo is zero, NULL
    is returned. In the case of a failure, IoErr() will return a non-zero
    errorcode.

database.library/DBM_UnLockMemo                  database.library/DBM_UnLockMemo

 NAME
    DBM_UnLockMemo - release the lock of the memo-file

 SYNOPSIS
    BOOL DBM_UnLockMemo (struct MemoFile *)
    success = DBM_UnLockMemo (mf)
      D0                      A0

 FUNCTION
    This function frees the lock of the memo-file, previously set by
    DBM_LockMemo().

 INPUT
    mf - a pointer to the MemoFile structure of the memo-file

 RESULT
    If the function succeeds, TRUE is returned, else FALSE is returned.

database.library/DBM_WriteMemo                    database.library/DBM_WriteMemo

 NAME
    DBM_WriteMemo - write a memo into the memo-file

 SYNOPSIS
    BOOL DBM_WriteMemo (struct MemoFile *, DOUBLELONG *, APTR, ULONG)
    success = DBM_WriteMemo (mf, addr, memo, size)
      D0                     A0   A1    A2    D0

 FUNCTION
    This function writes a memo to the memo-file. An empty block in the
    memo-file is used for this purpose or -- if no large enough empty block
    is found -- the memo is appended to the end of the memo-file.

    This function has to be enclosed by the function pair DBM_LockMemo()/
    DBM_UnLockMemo(), if the accoding DataTable is not opened exclusive.

 INPUTS
    mf - a pointer to the MemoFile structure of the memo-file
    addr - a pointer to a DOUBLELONG conatining the address of the memo. The
          high-longword contains the 'page' the memo starts, the low-longword
          contains the offset into that 'page'. If this is a valid address,
          the memo found there is disposed by this function and the used
          storage is freed.
          The address where the memo is stored is passed to the DOUBLELONG
          this pointer points to.
    memo - a pointer to the memo to be written
    size - the number of bytes that should be written

 RESULT
    If the memotext could be successfully stored in the buffer of the
    DataColumn, TRUE is returned.

database.library/DC_DefaultConvert            database.library/DC_DefaultConvert

 NAME
    DC_DefaultConvert - convert a value into human-readable format

 SYNOPSIS
    BOOL DC_DefaultConvert (struct DataColumn *, APTR)
    success = DC_DefaultConvert (column, value)
       D0                          A0      A1

 FUNCTION
    If the value of a DataColumn has to be displayed or printed in a human-
    readable form (as string) this function performs the convertion into the
    string. This string is stored in the 'Buffer' of the DataColumn.

    The default forms of the different types of values are:

       DC_LOGIC - "true" or "false"
       DC_BYTE - a decimal string
       DC_WORD - a decimal string
       DC_LONG - a decimal string
       DC_DOUBLELONG - a decimal string
       DC_FLOAT - a number in scientific format "-d.dddddde-dd"
       DC_DOUBLE - a number in scientific format "-d.ddddddddde-dd"
       DC_NUMERIC - a decimal string as stored
       DC_CHAR - a string, truncated after the last non-whitespace
       DC_TIME - a string in the format "00:00:00"
       DC_DATE - a string in a format related to FORMAT_DOS: "dd-mmm-yyyy"
       DC_TEXT, DC_VARCHAR - no convertion performed

 INPUTS
    column - a pointer to the DataColumn, whichs value should be converted
    value - a pointer to the value to be converted, this has to be a pointer
             to an even address.

 RESULT
    If the value could be successfully converted, TRUE is returned,
    else false is returned.

database.library/DC_DefaultRevert              database.library/DC_DefaultRevert

 NAME
    DC_DefaultRevert - Revert a value from human-readable into raw format

 SYNOPSIS
    BOOL DC_DefaultRevert (struct DataColumn *, STRPTR, APTR)
    success = DC_DefaultRevert (column, value, raw)
      D0                          A0     A1     A2

 FUNCTION
    If a value of a DataColumn needs to be reverted from a human-readable
    string (e.g. as displayed in a SingleLineEdit) into the raw format, it
    is stored in the DataColumn, this function might be called to perform
    the convertion.

    The default form of the different types of values is:

       DC_LOGIC - "TRUE", "T", "J", "Y", "Yes", "On" for TRUE ('T')
                   every other string results in FALSE ('F')
                   The comparison is done case-insensitive.
       DC_BYTE - a decimal string, the fractional part is ignored
       DC_WORD - a decimal string, the fractional part is ignored
       DC_LONG - a decimal string, the fractional part is ignored
       DC_DOUBLELONG - a decimal string
       DC_FLOAT - any string representing a number, either as decimal string
                   or in scientific format
       DC_DOUBLE - any string representing a number, either as decimal string
                   or in scientific format
       DC_NUMERIC - a decimal string
       DC_CHAR - a string, truncated after the last non-whitespace
       DC_TIME - a string in the format "00:00:00.000"
       DC_DATE - a date-string in FORMAT_DOS: "dd-mmm-yy", "dd-mmm-yyyy",
                "dd-mm-yy", or "dd-mm-yyyy"
       DC_VARCHAR - just copied
       DC_TEXT - not supported

    If a numeric value overflows, the result is undefined.

 INPUTS
    column - a pointer to the DataColumn, whichs value should be converted
    value - a pointer to the value, a human-readable NUL-terminated string
             that should be reverted. NULL is handled like an empty string.
             If a numeric string exceeds the valid range of the column, the
             result is undefined.
    raw -  a pointer to the destination address, where the raw value should
             be stored, take care that there is enough space for the value
             in raw format. And that it is correct aligned.

 RESULT
    If the value could be successfully converted, TRUE is returned, the
    value is written into the specified destination memory region; else
    false is returned, nothing is changed.

 NOTE
    This function can be replaced for every single column by a custom
    function if a special convertion is required.

database.library/DC_SetCaption                    database.library/DC_SetCaption

 NAME
    DC_SetCaption - change he caption of a DataColumn

 SYNOPSIS
    BOOL DC_SetCaption (struct DataColumn *, STRPTR)
    success = DC_SetCaption (column, caption)
       D0                     A0       A1

 FUNCTION
    This function should be used to change the caption of a column.

 INPUTS
    column - a pointer to the DataColumn structure of the column to be
             changed
    caption - a pointer to a NUL-terminated C-string with the new caption
             of the column. If NULL is passed the columns 'Name' is used
             as caption of the column.
             This text is copied and needs not to remain valid.

 RESULT
    If the caption could be successfully changed, TRUE is returned, else
     FALSE is returned (if the arguments are correct, this indicates that
    not enough free memory is available).

database.library/DC_SetHelpText                  database.library/DC_SetHelpText

 NAME
    DC_SetHelpText - change the short descriptive text of a DataColumn

 SYNOPSIS
    BOOL DC_SetHelpText (struct DataColumn *, STRPTR)
    success = DC_SetHelpText (column, helpText)
      D0                        A0       A1

 FUNCTION
    This function should be used to change the short descriptive text (the
    'HelpText') of a DataColumn.

 INPUTS
    column - a pointer to the DataColumn structure of the column to be
             changed
    helpText - a pointer to a NUL-terminated C-string with the new short
             descriptive text of the column.  If NULL is passed the columns
             'HelpText' is deleted.
             This text is copied and needs not to remain valid.

 RESULT
    If the text could be successfully changed, TRUE is returned, else
     FALSE is returned (if the arguments are correct, this indicates that
    not enough free memory is available).

database.library/DOUBLELONG2Numeric          database.library/DOUBLELONG2Numeric

 NAME
    DOUBLELONG2Numeric - convert a DOUBLELONG into a NUMERIC

 SYNOPSIS
    BOOL DOUBLELONG2Numeric (DOUBLELONG *, UBYTE *, UWORD, UWORD, UWORD)
    success = DOUBLELONG2Numeric (val, num, length, decimals, exponent)
      D0                          A0   A1    D0:16    D1:16    D2:16

 FUNCTION
    This function converts a DOUBLELONG value into a NUMERIC value (a fixed
    point decimal value).
    Convertions between NUMERIC and DOUBLELONG are required for doing any
    arithmetic operations with NUMERIC values.

 INPUTS
    val - a pointer to the DOUBLELONG, that should be converted.
    num - a pointer to the address, where the NUMERIC value should be stored.
          This buffer has to be 'length' bytes long and will have the
          following format:
          the first byte is the sign: either '+' or '-', optional followed
          by zeros '\0' and than followed by the digits of the NUMERIC value
          without a comma. This value is not a NUL-terminated string.
    length - the length of the whole NUMERIC value inclusive its sign (<= 18)
          beware of overflows.
    decimals - the number of digits at the end of the value, that are
          representing the part behind the comma. There have to be at least
          'decimals' + 1 digits in the passed NUMERIC value; 'decimals' MUST
          be at least two lower than 'length'.
    exponent - this value represents the exponent to the base 10; The
          DOUBLELONG value is divided by this value to calculate the
          resulting NUMERIC.
          If any digits are truncated behind the last significant digit,
          the NUMERIC is rounded up.

 RESULT
    If the DOUBLELONG value could be successfully converted to a NUMERIC
    value TRUE is returned, else (overflow) FALSE is returned.

database.library/DS_AddColumns                    database.library/DS_AddColumns

 NAME
    DS_AddColumns - append new DataColumns to the servers list of DataColumns

 SYNOPSIS
    BOOL DS_AddColumns (struct DataServer *, struct DataColumn *, ULONG)
    success = DS_AddColumns (server, template, numCols)
      D0                       A0       A1       D0

 FUNCTION
    This function creates new DataColumns and appends them to the end of the
    DataServers list of DataColumns. The DataColumns are created according
    the 'template' DataColumns, that are copied except of the 'Buffer' member
    of the structures, this field is always set to default.

 INPUTS
    server - a pointer to the DataServer structure
    template - a pointer to an array of DataColumn structures used as
                template for the new columns.
             Every entry must at least contain:
                - a valid 'Name'
                - a non-zero 'Type' field
                - a non-zero  'Length'
             If the entry references a 'Server', this one is copied into
             the new DataColumn otherwise the new DataColumn will reference
             the DataServer it is inserted into.
    numCols - the number of valid entries into the 'template' array

 RESULT
    If the function succeeds, TRUE is returned.
    IF the function fails, FALSE is returned.

database.library/DS_DoUpdate                        database.library/DS_DoUpdate

 NAME
    DS_DoUpdate - perform an operation on a DataServer

 SYNOPSIS
    BOOL DS_DoUpdate (struct DataServer *, ULONG, APTR)
    success = DS_DoUpdate (server, operation, arg)
      D0                     A0       D0      A1

 FUNCTION
    This function is used to perform any operation on a DataServer. It
    calls the Update-function that is pointed to by the DataServers 'Update'
    function-pointer. If any subclass of the DataServer needs to do anything
    different than the default operation, it has to implement its own update
    function and store the pointer to that function in the 'Update' function-
    pointer of the DataServer structure. This function should call
    DS_Update() for any operation it doesn't supports.

 INPUTS
    server - a pointer to the DataServer structure of the DataServer to be
             accessed.
    operation - the operation that should be performed, every DataServer and
             subclass should support the following operations:

          DS_UPDATE - synchronize the contents of the DataServer and the
                   underlying "device". If any data of the current row has
                   been changed, this operation has to be performed to copy
                   the new data to the "device" to be stored.
                   If the DataServer has been newly created, the sorting
                   order of the rows, or the columns of the DataServer has
                   been changed, this operation has to be performed to read
                   all rows from the underlying "device" to match the new
                   requirements.
                   The subclasses of the DataServer should monitor the
                   underlying "device" and perform an update, everytime the
                   "device" signalizes that the data has been changed.

          DS_ADDCOLUMN - add a new column to the DataServer, the argument
                   'arg' has to point to a full initialized DataColumn
                   structure. This structure and the referenced strings will
                   be copied and added to the end of the list of already
                   present columns.
                   After this operation succeeds, you should perform an
                   DS_UPDATE to re-read the data from the "device" and this
                   new column contains valid data.

          DS_REMOVECOLUMN - remove a column from the DataServer, the argument
                   'arg' has to specify the position of the DataColumn to be
                   removed.

          DS_MOVECOLUMN - rearrange the order of the columns in the
                   DataServers array of DataColumns. The order in this array
                   will be the order the columns are selected using the
                   operations DS_GOTOCOLUMN, DS_NEXTCOLUMN and DS_PREVCOLUMN.
                   This operation will move the currently selected column to
                   the position the argument 'arg' - interpreted as ULONG -
                   specifies. 'arg' has to be between 1 and the number of
                   columns attached to the DataServer. If 'arg' is greater
                   than the number of columns, the current column is moved
                   to the last position, if 'arg' is equal 0, nothing is
                   changed, the function will fail.

          DS_GOTOCOLUMN - select the column with the number specified by
                   'arg' - interpreted as ULONG. The count of the columns
                   starts with 1. If 0 or any value larger than the number
                   of columns attached to the DataServer is specified, the
                   function will fail,the current column will not be changed.

          DS_NEXTCOLUMN - select the next column, the one behind the current
                   column, a pointer to the column will copied to the address
                   'arg' points to, if 'arg' is not equal NULL. If there are
                   no more columns, this operation will fail, the current
                   column will not be changed, the address 'arg' points to
                   will not be changed.

          DS_PREVCOLUMN - select the preceding column, the one before the
                   current column, a pointer to the column will copied to the
                   address 'arg' points to, if 'arg' is not equal NULL. If
                   there are no columns in front of the current column, this
                   operation will fail, the current column will not be
                   changed, the address 'arg' points to will not be changed.

          DS_FINDCOLUMN - select a column specified by its 'Name'. The
                   argument 'arg' has to be a pointer to a NUL-terminated
                   string with the 'Name' of the searched column, 'arg' is
                   not changed by this function.

          DS_GETRAWDATA - get the data of the current column. If there is
                   a currently selected column and the current row is valid,
                   a pointer to the data of this column in the current row is
                   copied to the address, 'arg' points to. The type of this
                   pointer depends on the datatype of the column:
             DC_BYTE - pointer to a single byte
             DC_LOGIC - pointer to a single byte, 'F' => FALSE, 'T' => TRUE
             DC_WORD - pointer to a word (2 byte) at an even address
             DC_LONG - pointer to a longword (4 byte) at a longword address
                      (divideable by 4)
             DC_DOUBLELONG - pointer to a longlong (4 byte) at a longword
                      address (divideable by 4)
             DC_FLOAT - pointer to a float (4 byte) at a longword address
                      (divideable by 4)
             DC_DOUBLE  - pointer to a double (8 byte) at a longword address
                      (divideable by 4)
             DC_NUMERIC - pointer to a buffer of 'DataColumn.Length' bytes
             DC_DATE - pointer to a buffer 8 bytes in length
             DC_TIME - pointer to a longword (4 byte) at a longword address
                      (divideable by 4)
             DC_CHAR - pointer to a buffer of 'DataColumn.Length' bytes
             DC_TEXT - pointer to a buffer where the information required
                      to locate the according string is stored. The format
                      of this address-information is implementation specific
                      so you should avoid reading this kind of columndata
                      in raw format.
             DC_VARCHAR - pointer to a STRPTR, where the address of the
                      string is copied to, take care that the string is
                      constant and has not to be modified, copy it to a
                      local storage, before modifying it.

          DS_GETCOLUMNDATA - get the data of the current column in human-
                   readable form, i.e. the contents is converted into a
                   NUL-terminated C-string. A pointer to that read-only
                   string is copied into the address 'arg' points to.
                   If no function-pointer is placed in the 'Convert' member
                   of the DataColumn structure of the current column,
                   standard convertion is done.

          DS_SETRAWDATA - change the data of the current column. If there
                   is a currently selected column and the current row is
                   valid, the data is changed according to the new data,
                   pointed to by 'arg'. The type of data 'arg' points to
                   depends on the type of the current column (see
                   DS_GETCOLUMNDATA). The state of the DataServer flag
                   DSF_READONLY respectively the flag DCF_READONLY of the
                   current DataColumn has to be respected by this operation.

          DS_SETCOLUMNDATA - change the data of the current column. If
                   there is a currently selected column and the current row
                   is valid, the data is changed according to the new data,
                   pointed to by 'arg'. 'Arg' has to point to a
                   NUL-terminated C-string with the new data, formated like
                   the string returned by DC_GETCOLUMNDATA.

          DS_GOTOROW - go to any row by its number; the argument 'arg',
                   interpreted as ULONG, specifies the number of the row that
                   should be selected as current row. The count of the rows
                   start with 1. If 0 or a value greater than the number of
                   available rows is specified, this function fails, the
                   current row is undefined.

          DS_NEXTROW - go to next row, the one behind the current one in
                   the currently active order. If there are no more rows
                   available, this function will fail, the current row is
                   undefined.

          DS_PREVROW - go to previous row, the one before the current one in
                   the currently active order. If there are is no row before
                   the current one, this function will fail, the current row
                   is undefined.

          DS_FIRSTROW - go to first row, the first available row in the
                   currently active order. If there is no row available at
                   all, this function will fail.

          DS_LASTROW - go to last row, the last available row in the
                   currently active order. If there is no row available
                   at all, this function will fail.

          DS_SKIPROWS - skip any number of rows, the argument 'arg' is
                   interpreted as long value, specifying the number of rows
                   that should be skipped. If the argument is less than zero,
                   the rows are skipped to the top of the DataServer else the
                   rows are skipped to the bottom of the DataServer. If EOF
                   or BOF are reached, this operation will fail, the current
                   row is undefined.

          DS_INSERTROW - a new row should be inserted into the DataServer.
                   The columns of the row are initialized to defaults.
                   After this operation has succeeded, the operation
                   DS_UPDATE has to be performed to access the new inserted
                   row.

          DS_REMOVEROW - the current row should be deleted. After this
                   operation has succeeded, the operation DS_UPDATE has to be
                   performed to remove the row from the DataServers buffer.

          DS_SETORDER - change the order of the rows; 'arg' points to the new
                   order that should be used. The type of data 'arg' points
                   to depends on the implementation of the subclass, usually
                   it should point to a string. After this operation has
                   succeeded, the operation DS_UPDATE should be performed to
                   match the new order.

          DS_GETORDER - get the order of the rows; a pointer to the current
                   order is stored in the address 'arg' points to, the type
                   of that pointer depends on the implementation of the
                   subclass, usually it should point to a string.

          DS_AVAILABLEORDER - get a pointer to a list with the available
                   orders of the DataServer; a pointer to a list of orders
                   available for this DataServer is copied to the address
                   'arg' points to. The type of this list depends on the
                   implementation of the subclass, usually it should be a
                   NULL-terminated array of string-pointers.

          DS_ORDERASCEND - order the rows ascend or descend; the argument
                   'arg' is interpreted as boolean, if 'arg' is not NULL,
                   the rows are ordered in ascend order, otherwise they are
                   ordered descend. After this operation has succeeded, the
                   operation DS_UPDATE should be performed to match the
                   new order.

          DS_KEYEXPRESSION - get a pointer to the expression used to generate
                   the keys for the rows in the currently active order.
                   A pointer to the expression is copied to the address 'arg'
                   points to. This should be usually a NUL-terminated string,
                   but it depends on the implementation of the subclasses of
                   the DataServer.

          DS_KEYLENGTH - get the length of a keyvalue of the currently active
                   order. This size is required to allocate a buffer large
                   enough to store a keyvalue as required for DS_CURRENTKEY.
                   The length is copied to the ULONG value 'arg' points to.

          DS_CURRENTKEY - get the keyvalue of the current row in the
                   currently active order. This keyvalue is copied to the
                   buffer 'arg' points to. Take care that the buffer is large
                   enough to store a keyvalue (see DS_KEYLENGTH). This value
                   might be passed to the operation DS_SEEK to find this
                   record again.

          DS_SEEK - seek to a row with a specific keyvalue. The row is
                   searched in the current order from top to bottom; the
                   argument 'arg' has to point to the value to be searched.
                   If soft-seek is enabled, the search starts at the current
                   row and stops on the first row with a keyvalue that is
                   equal to or greater than the specified value. If soft-seek
                   is disabled, the search starts at the first record and
                   stops if a matching keyvalue is found.
                   If no according matching key-value is found, the operation
                   fails, the current row is set to end-of-file.

          DS_SEEKNEXT - if softseek is enabled, this operation can be used
                   after a successfull DS_SEEK to seek to the next value.
                   This operation works like DS_SEEK and requires the same
                   argument, the difference is, that it starts the seek at
                   the next row, not at the first row.

          DS_SOFTSEEK - enable/disable softseek; if the argument 'arg',
                   interpreted as boolean, is TRUE, soft-seek is enabled,
                   else soft-seek is disabled.

          DS_SELECTROW - if the underlying "device" supports selection of
                   rows, this operation can be used to select or unselect
                   the current row. The argument 'arg' is interpreted as
                   boolean, if it is TRUE, the current row is selected, else
                   the selection of the current row is cleared.
                   The operation should return TRUE, if it is supported and
                   could be successfully performed, it should only return
                   FALSE, if the DataServer doesn't supports selection or
                   an unexpected error occurs, 'LastError' should be set
                   accordingly.

          DS_FIRSTSELECTED - this operation should perform a skip to the
                   first selected row, if there is one selected at all. If
                   no row is selected, 'LastError' should be set to 
                   "DS_ERR_NO_MORE_DATA". The number of the first selected
                   row is stored in the ULONG, 'arg' points to. If no row
                   is selected, the value -- 'arg' points to -- is not
                   changed.

          DS_NEXTSELECTED - if more than one row is selected, this operation
                   should perform a skip to the next selected row. If there
                   are no more rows selected, 'LastError' should be set to 
                   "DS_ERR_NO_MORE_DATA". The number of the next selected
                   row is stored in the ULONG, 'arg' points to. If no row
                   is selected, the value -- 'arg' points to -- is not
                   changed.

          DS_CLEARSELECTION - this operation clears all selections made.
                   The argument 'arg' is not used.

          DS_ISSELECTED - this operation evaluates if the current row is
                   selected. If the DataServer doesn't supports selection,
                   or no row is the current one, FALSE is returned, 
                   'DataServer.LastError' is set to the according errorcode;
                   If the DataServer supports selection, and the current row
                   is not selected, FALSE is returned, 'DataServer.LastError'
                   is set to 0; if the current row is selected, TRUE is
                   returned.

          DS_ALLOWSELECTION - using this operation, the "user" of the
                   DataServer can evaluate if the DataServer supports
                   selection of rows. The argument 'arg' indicates, which
                   kind of selection is requested: If its not NULL, the
                   DataServer should return TRUE, if multiple selection is
                   supported. If 'arg' is NULL, the DataServer should return
                   TRUE, if the selection of a single row is supported.

          DS_NUM_OF_ROWS - get number of accessable rows, the number of rows
                   accessable is copied to the ULONG 'arg' points to.

          DS_NUM_OF_COLUMNS - get number of accessable columns, the number of
                   columns accessable is copied to the ULONG 'arg' points to.

          DS_CURRENTROW - get the number of the current row;  the number of
                   the current row, as stored in the DataServer structures
                   'CurrentRow' member, will be copied to the ULONG address
                   'arg' points to. If currently no row is accessable (e.g.
                   the DataServer has just been created and no DS_UPDATE has
                   been performed, or the last DS_UPDATE failed), this
                   operation fails, the contents of the address 'arg' points
                   to is not changed.

          DS_CURRENTCOLUMN - get a pointer to the DataColumn structure of
                   the current column. If currently a column is selected,
                   a pointer to the column will be copied to the address
                   'arg' points to. If no column is selected (usually just
                   after the DataServer has been created or an DS_UPDATE has
                   been performed), this operation fails, the contents of the
                   address 'arg' points to is not changed.

          DS_DISPOSE - the DataServer is disposed, all resources used by the
                   DataServer are freed. If a subclass allocates any resource
                   dynamically or needs to terminate a connection to a
                   "device", it has to implement this operation and perform
                   it, before it calls DS_Update() to do the default clean-up
 RESULT
    If the operation succeeds, TRUE is returned. Depending on the type of
    operation performed, the address 'arg' points to may have changed.
    If the function fails, FALSE is returned, check 'DataServer.LastError'
    for the cause of the failure.

database.library/DS_InitA                              database.library/DS_InitA

 NAME
    DS_InitA - create and initialize a DataServer

 SYNOPSIS
    struct DataServer *DS_InitA (APTR, struct TagItem *)
    dataServer = DS_InitA (unused, tagList)
       D0                    A0      A1

 FUNCTION
    This function allocates and initialize a DataServer structure. The
    DataServer is the base-class used to access and present any kind of
    data, which is arranged as any number (> 2 billion) of rows that are
    equal structured in columns of single data.

 INPUTS
    unused - this argument is not used in the current implementation, it
             is reserved for future use and should be set to NULL.
    tagList - a pointer to a TagItem list used to initialize the DataServer.
             Currently defined Tags are:

                DS_Columns - a pointer to an array of of DataColumn
                         structures, which define the columns of this
                         DataServer. The structures and all strings
                         passed with this array are copied and need not to
                         remain valid, when this function has returned.
                         This array is terminated by an entry with the
                         'Name' set to NULL.
                         If this Tag is not present, the DataServer has
                         initially no columns, the columns need to be added
                         using the function DS_DoUpdate() with the operation
                         DS_ADDCOLUMN.
                DS_ReadOnly - boolean Tag, if this Tag is present in the
                         TagItem list, the DataServer is read-only, i.e. no
                         data of any column might be changed.
                DS_SoftSeek - boolean Tag, if this Tag is present in the
                         TagItem list, the soft-seek of the DataServer is
                         enabled. If soft-seek is enabled, the operation
                         DS_SEEK stops successfully on the first row that
                         is equal or greater than the searched value.
                DS_StructSize - ULONG, the size of the structure that should
                         be allocated as DataServer structure. This Tag has
                         to be specified, if a subclass of the DataServer
                         needs additional space in the structure for private
                         data.
                DS_Name -  a pointer to a NUL-terminated string specifying
                         a name for the DataServer. This string is copied and
                         needs not to remain valid after this function has
                         returned.

 RESULT
    If the function succeeds, a pointer to a full initialized DataServer
    structure is returned. If the function fails, NULL is returned.

database.library/DS_RemoveColumns              database.library/DS_RemoveColumns

 NAME
    DS_RemoveColumns - remove one or more DataColumns from a DataServer

 SYNOPSIS
    BOOL DS_RemoveColumns (struct DataServer *, ULONG, ULONG)
    success = DS_RemoveColumns (server, firstColumn, numColumns)
       D0                         A0        D0           D1

 FUNCTION
    This function removes one or more DataColumns from the DataServers array
    of DataColumns.

 INPUTS
    server - a pointer to the DataServer structure of the server
    firstColumn - the position of the first column to be removed
    numColumns - the number of columns that should be removed

 RESULT
    If everything wents fine TRUE is returned, else (usually bad arguments
    passed to this function or no free memory available) FALSE is returned.

database.library/DS_Update                            database.library/DS_Update

 NAME
    DS_Update - perform an operation on a DataServer

 SYNOPSIS
    BOOL DS_Update (struct DataServer *, ULONG, APTR)
    success = DS_Update (server, operation, arg)
      D0                   A0       D0      A1

 FUNCTION
    This function is the default implementation to perform any operation on
    a DataServer. If any subclass of the DataServer needs to do anything
    different than the default operation, it has to implement its own update
    function and store the pointer to that function in the 'Update' function-
    pointer of the DataServer structure. This function should call this
    DS_Update() for any operation it doesn't supports.

 INPUTS
    server - a pointer to the DataServer structure of the DataServer to be
             accessed.
    operation - the operation that should be performed, the DataServer
             supports the following operations, all other values would
             lead this function to return FALSE without doing anything.

          These operations are direct supported by the DataServer:

          DS_ADDCOLUMN - append a new column to the end of the DataServers
                   list of DataColumns; the argument 'arg' has to point to a
                   full initialized DataColumn structure. This structure and
                   the referenced strings will be copied and added to the end
                   of the list of already present columns.
                   After this operation has succeeded, you should perform an
                   DS_UPDATE to re-read the data from the "device" and this
                   new column contains valid data.

          DS_REMOVECOLUMN - remove a column from the DataServer, the argument
                   'arg' has to specify the number of the DataColumn to be
                   removed. If the operation succeeds, and the removed column
                   is the current column of the DataServer, the next column
                   will went to the current column. If no next column is
                   existent, the previous column wents to be the current
                   column.
                   At least a single column has to remain in the DataServer,
                   or this operation will fail.

          DS_MOVECOLUMN - rearrange the order of the columns in the
                   DataServers array of DataColumns. The order in this array
                   will be the order the columns are selected using the
                   operations DS_GOTOCOLUMN, DS_NEXTCOLUMN and DS_PREVCOLUMN.
                   This operation will move the currently selected column to
                   the position the argument 'arg' - interpreted as ULONG -
                   specifies. 'arg' has to be between 1 and the number of
                   columns attached to the DataServer. If 'arg' is greater
                   than the number of columns, the current column is moved
                   to the last position, if 'arg' is equal 0, nothing is
                   changed, the operation will fail.

          DS_GOTOCOLUMN - select the column with the number specified by
                   'arg' - interpreted as ULONG. The count of the columns
                   starts with 1. If 0 or any value larger than the number
                   of columns attached to the DataServer is specified, the
                   operation will fail,the current column will not be changed

          DS_NEXTCOLUMN - select the next column, the one behind the current
                   column, a pointer to the column will copied to the address
                   'arg' points to, if 'arg' is not equal NULL. If there are
                   no more columns, this operation will fail, the current
                   column will not be changed, the address 'arg' points to
                   will not be changed.

          DS_PREVCOLUMN - select the preceding column, the one before the
                   current column, a pointer to the column will copied to the
                   address 'arg' points to, if 'arg' is not equal NULL. If
                   there are no columns in front of the current column, this
                   operation will fail, the current column will not be
                   changed, the address 'arg' points to will not be changed.

          DS_FINDCOLUMN - select a column specified by its 'Name'. The
                   argument 'arg' has to be a pointer to a NUL-terminated
                   string with the 'Name' of the searched column.

          DS_GOTOROW - go to any row by its number; the argument 'arg',
                   interpreted as ULONG, specifies the number of the row that
                   should be selected as current row. The count of the rows
                   start with 1. If 0 or a value greater than the number of
                   available rows is specified, this function fails, the
                   current row is not changed.

          DS_NEXTROW - go to next row, the one behind the current one in
                   the currently active order. If there are no more rows
                   available, this function will fail, the current row is
                   not changed.

          DS_PREVROW - go to previous row, the one before the current one in
                   the currently active order. If there are is no row before
                   the current one, this function will fail, the current row
                   is not changed.

          DS_FIRSTROW - go to first row, the first available row in the
                   currently active order. If there is no row available at
                   all, this function will fail.

          DS_LASTROW - go to last row, the last available row in the
                   currently active order. If there is no row available
                   at all, this function will fail.

          DS_SKIPROWS - skip any number of rows, the argument 'arg' is
                   interpreted as long value, specifying the number of rows
                   that should be skipped. If the argument is less than zero,
                   the rows are skipped to the top of the DataServer else the
                   rows are skipped to the bottom of the DataServer. If EOF
                   or BOF are reached, this operation will fail, the current
                   row is not changed.

          DS_ALLOWSELECTION - this opperation will always fail, 'LastError'
                   is set to DS_ERR_NO_ERROR. This indicates that the
                   DataServer doesn't supports selection of rows per default.

          DS_NUM_OF_ROWS - get number of accessable rows; the number of rows
                   as stored in the DataServer structures 'NumRows' member,
                   will be copied to the ULONG address 'arg' points to.

          DS_NUM_OF_COLUMNS - get number of accessable columns; the number of
                   columns as stored in the DataServer structures member
                   'NumColumns', will be copied to the ULONG address 'arg'
                   points to.

          DS_CURRENTROW - get the number of the current row;  the number of
                   the current row, as stored in the DataServer structures
                   'CurrentRow' member, will be copied to the ULONG address
                   'arg' points to. If currently no row is accessable (e.g.
                   the DataServer has just been created and no DS_UPDATE has
                   been performed, or the last DS_UPDATE failed), this
                   operation fails, the address 'arg' points to is not
                   changed.

          DS_CURRENTCOLUMN - get a pointer to the DataColumn structure of
                   the current column. If currently a column is selected,
                   a pointer to the column will copied to the address 'arg'
                   points to. If no column is selected (usually just after
                   the DataServer has been created or an DS_UPDATE has been
                   performed), this operation fails, the address 'arg' points
                   to is not changed.

          DS_GETORDER - get the order of the rows; a pointer to the current
                   order is stored in the address 'arg' points to, the type
                   of that pointer depends on the implementation of the
                   subclass, usually it should point to a string.

          DS_SOFTSEEK - enable/disable softseek; if the argument 'arg',
                   interpreted as boolean, is TRUE, soft-seek is enabled,
                   else soft-seek is disabled. If soft-seek is enabled, the
                   flag DSF_SOFTSEEK is set.

          DS_ORDERASCEND - order the rows ascend or descend; the argument
                   'arg' is interpreted as boolean, if 'arg' is not NULL,
                   the flags DSF_DESCEND is cleared, rows are ordered in
                   ascend order; else the flags DSF_DESCEND is set, they
                   are ordered descend.

          DS_DISPOSE - the DataServer is disposed, all resources used by the
                   DataServer are freed. If a subclass allocates any resource
                   dynamically or needs to terminate a connection to a
                   "device", it has to implement this operation and perform
                   that operation, before it calls DS_Update() to do the
                   default clean-up.
                   

          All other operations have to be implemented by subclasses of the
          DataServer, these function will not do anything and return FALSE.

 RESULT
    If the operation succeeds, TRUE is returned. Depending on the type of
    operation performed, the address 'arg' points to may have changed.
    If the function fails, FALSE is returned, check 'DataServer.LastError'
    for the cause of the failure.

database.library/DToS                                      database.library/DToS

 NAME
    DToS - convert a date into a human readable string representing that date

 SYNOPSIS
    BOOL DToS (APTR, UBYTE *)
    valid = DToS (date, dateStr)
      D0           A0     A1

 FUNCTION
    This function creates a string in the format "dd-mmm-yyyy" according to
    the specified date.
    The date has to be a string in the format "YYYYMMDD", this string needs
    not to be NUL-terminated.

 INPUTS
    dateVal - a pointer to a string with the date to be converted
    dateStr - a pointer to a buffer, where the NUL-terminated string
          representing the date in human-readable form is copied into. This
          buffer has to be at least 12 bytes large.

 RESULT
    If the specified date is valid, TRUE is returned, else FALSE is returned.

database.library/Float2Double                      database.library/Float2Double

 NAME
    Float2Double - floating point convertion

 SYNOPSIS
    BOOL Float2Double (APTR, APTR)
    success = Float2Double (fVal, dVal)
      D0                     A0    A1

 FUNCTION
    This function converts a single precision floating point number (4 bytes)
    into a double precision floating point number (8 bytes) without the usage
    of the math.lib, so this module needs not to be linked against that lib.

 INPUTS
    fVal - a pointer to the address where the 4-byte floating point number is
          stored. This number has to be valid. This address has to be word
          aligned.
    dVal - a pointer to the address where the resulting 8-byte floating point
          number should be stored. This may be the same address as used for
          storing the 'fVal' value, if it is large enough. In this case the
          original short floating point value will be overwritten.
          This address has to be word aligned.

 RESULT
    This function always returns TRUE, but it should return FALSE if the
    specified floating point number is not valid.

database.library/IDX_ClearIndex                  database.library/IDX_ClearIndex

 NAME
     IDX_ClearIndex - remove all keys from the index

 SYNOPSIS
     BOOL IDX_ClearIndex (struct IDXHeader *)
     success = IDX_ClearIndex (ihd)
       D0                       A0

 FUNCTION
     This function clears the whole index, i.e. all keys stored in the index
     are removed. The changes are written to the index-file.

     This function tries to access the file in exclusive mode, so you need not
     to enclose this functioncall by calls the function IDX_StartTransaction()
     and IDX_EndTransaction().

 INPUT
     ihd - a pointer to the IDXHeader structure of the index, the index should
           be created with the custom-flag (using the Tag IDX_Custom)

 RESULT
     If the function succeeds, TRUE is returned.
     If the function fails, FALSE is returned.

 NOTE
     You should enclose this function-call by a call to the
     IDX_StartTransaction()/IDX_EndTransaction() function-pair to
     avoid conflicts with other instances accessing this index.

 KNOWN BUGS
     Several filesystems doesn't have implemented the ATION_SET_FILESIZE
     packet (AmigaDos function SetFileSize()). In this case the file is
     closed, reopened in MODE_NEWFILE, the header is written, than the file
     is closed again and reopened in MODE_OLDFILE.
     However because the file is closed two times, in worst case another
     process could gain exclusive access to this files, before it is reopened
     by this process. So this process will fail to reopen the files and the
     index will be left in an undefined state.

 WORKAROUND
     If this index has an according file (it is not a index only stored in
     memory), you should test 'ihd->fh' if this function fails. If this
     field contains zero, the indexfile couldn't be reopened (IoErr() should
     return ERROR_OBJECT_IN_USE for this case but other errorcodes are also
     possible). You have to close the index (IDX_Dispose()) in this case.

     Another way is suppressing the usage of this function, if you know that
     your filesystem doesn't support SetFileSize(), you can close the index
     (IDX_Dispose()), delete it from disk using AmigaDos's DeleteFile()
     function, and recreate it using IDX_InitA(). If the access fails in this
     case, IDX_InitA() will return NULL and so -- if the IDXHeader structure
     is returned -- you could be shure that it is valid.

database.library/IDX_CountFields                database.library/IDX_CountFields

 NAME
    IDX_CountFields - count the number of fields referenced by an expression

 SYNOPSIS
    ULONG IDX_CountFields (STRPTR)
    numFields = IDX_CountFields (expr)

 FUNCTION
    This function counts the number of DataBase-fields referenced by a key-
    expression.
    It doesn't checks the validity of the expression.

 INPUT
    expr - a pointer to the NUL-terminated string with the key-expression

 RESULT
    The number of fields referenced by the expression is returned.

database.library/IDX_Dispose                        database.library/IDX_Dispose

 NAME
    IDX_Dispose - dispose the index

 SYNOPSIS
    void IDX_Dispose (struct IDXHeader *)
    IDX_Dispose (ihd)
                 A0

 FUNCTION
    This function is used to dispose the index, i.e. the access to the index
    file is terminated and all memory used by the index is freed.

 INPUT
    ihd - a pointer to the IDXHeader structure of the index to be disposed.
          It is safe to pass a pointer to an IDXAlias structure to this
          function.

database.library/IDX_EndTransaction          database.library/IDX_EndTransaction

 NAME
    IDX_EndTransaction - terminate the access to the index

 SYNOPSIS
    BOOL IDX_EndTransaction (struct IDXHeader *, LONG)
    success = IDX_EndTransaction (ihd, accessType)
      D0                          A0       D0

 FUNCTION
    Every call to IDX_StartTransaction() has to be matched by a call to this
    function.
    If the index-file has been changed (IDX_WRITE), the DateStamp containing
    the time of the last change is updated to indicate other processes that
    the file has been changed.
    After this function returns, the index is free again for any access.

 INPUT
    ihd - a pointer to the IDXHeader structure of the index
    accessType - the type of access that has been performed. This could
             be either
                IDX_READ - for read-only accesses
                IDX_WRITE - for read-write accesses

 RESULT
    If the function succeeds, TRUE is returned.
    If the function failes, FALSE is returned. See IoErr() for an according
    AmigaDos errorcode.

 BUGS
    On success IoErr() is not cleared.

database.library/IDX_EvalExpression          database.library/IDX_EvalExpression

 NAME
    IDX_EvalExpression - evaluate a key-expression using user-arguments

 SYNOPSIS
    BOOL IDX_EvalExpression (struct DataServer *, STRPTR, UBYTE *, ...)
    success = IDX_EvalExpression (ds, expr, value, <args>)

 FUNCTION
    This function evaluates a key-expression and generates -- using the
    specified argument values -- a key-value. This keyvalue may be used to
    seek for a specific record in the index or may be used for setting an
    orderscope to the index.

 INPUTS
    ds - a pointer to the DataServer structure of the DataServer that should
          be indexed using this key-expression
    expr - a pointer to the NUL-terminated string with the key-expression
             as pointed to by the field 'Expression' of the IDXHeader
             structure of an index.
    key - a pointer to the buffer, where the resulting key-value of this
             function should be stored. This buffer has to have at least
             'IDXHeader.KeyLen' bytes of free space.
    <args> - a variable length list of arguments (each 32 bits wide) that are
             used to evaluate the expression. For every Database-field that
             is referenced in the expression (evaluated from left to right)
             the according value has to be passed with this argument list (in
             the same order). If a field is referenced twice, the according
             value has to be passed twice!
             The arguments have to be passed according to the type of the
             referenced Database-field:
                DC_BYTE - a byte value (casted to a 32-bit integer)
                DC_WORD - a signed 2 byte word (casted to a 32-bit integer)
                DC_LONG - a signed 4 byte word
                DC_DOUBLELONG - a pointer to a DOUBLELONG
                DC_TIME - a pointer to a string in the format "HH:MM:SS.mmm",
                         where 'HH' are the number of hours (0 - 23)
                               'MM' are the number of minutes (0 - 59)
                               'SS' are the number of seconds (0 - 59)
                               'mmm' are the number of milliseconds (0 - 999)
                         The string could be terminated by a NUL-byte after
                         each part separated by a colon or dot (e.g. "HH:MM"
                         or "HH:MM:SS")
                DC_DATE - a pointer to a string in the format "dd-mmm-yy",
                         "dd-mm-yy", "dd-mmm-yyyy", or "dd-mm-yyyy"
                         where 'yyyy' is the (any) year from 1583-9999
                               'yy' is the year between 2000 and 2099
                                     (e.g. "04" for 2004)
                               'mm' is the month in numerical form
                                     (e.g. "12" for december)
                               'mmm' is the month in alphanumerical form
                                     (e.g. "Dec" for december)
                               'dd' is the day (2 characters required)
                DC_CHAR - a pointers to a NUL-terminated C-string, if the
                         string is longer than the addressed Database-field,
                         it is truncated.
                DC_FLOAT - a pointer to a single precision (32 bit) floating
                         point value.
                DC_DOUBLE - a pointer to a double precision (64 bit) floating
                         point value.

             If wrong argument types are passed, the result of this function
             is unpredictabe.
 RESULT
    If the function succeeds, TRUE is returned, the key-value is copied into
    the specified buffer.
    If the function fails, FALSE is returned, the contents of the key-value
    buffer is not changed.

database.library/IDX_EvalExpressionA        database.library/IDX_EvalExpressionA

 NAME
    IDX_EvalExpressionA - evaluate a key-expression using user-arguments

 SYNOPSIS
    BOOL IDX_EvalExpressionA (struct DataServer *, STRPTR, APTR, ULONG *)
    success = IDX_EvalExpressionA (server, expr, key, args)
      D0                             A0     A1   A2    A3

 FUNCTION
    This function evaluates a key-expression and generates -- using the
    specified argument values -- a key-value. This keyvalue may be used to
    seek for a specific record in the index or may be used for setting an
    orderscope to the index.

 INPUTS
    server - a pointer to the DataServer structure of the DataServer that
             should be indexed using this key-expression. This reference is
             required to determine the type and size of the DataColumns
             referenced by the key-expression.
    expr - a pointer to the NUL-terminated string with a key-expression as
             pointed to by the field 'Expression' of the IDXHeader structure
             of an index.
    key - a pointer to the buffer, where the resulting key-value of this
             function should be stored. This buffer has to have at least
             'IDXHeader.KeyLen' bytes of free space.
    args - a variable length array of arguments (each casted to ULONG) that
             are used to evaluate the expression. For every Database-field
             that is referenced in the expression (evaluated from left to
             right) an entry with the according value has to be present in
             this array (in the same order). If a field is referenced twice,
             the according value has to be present twice!
             The arguments are interpreted according to the type of the
             referenced Database-field:
                DC_BYTE - a byte value
                DC_WORD - a signed 2 byte word
                DC_LONG - a signed 4 byte word
                DC_DOUBLELONG - a pointer to a DOUBLELONG
                DC_TIME - a pointer to a string in the format "HH:MM:SS.mmm",
                         where 'HH' are the number of hours (0 - 23)
                               'MM' are the number of minutes (0 - 59)
                               'SS' are the number of seconds (0 - 59)
                               'mmm' are the number of milliseconds (0 - 999)
                         The string could be terminated by a NUL-byte after
                         each part separated by a colon or dot (e.g. "HH:MM"
                         or "HH:MM:SS")
                DC_DATE - a pointer to a string in the format "dd-mmm-yy",
                         "dd-mm-yy", "dd-mmm-yyyy", or "dd-mm-yyyy"
                         where 'yyyy' is the (any) year from 1583-9999
                               'yy' is the year between 2000 and 2099
                                     (e.g. "04" for 2004)
                               'mm' is the month in numerical form
                                     (e.g. "12" for december)
                               'mmm' is the month in alphanumerical form
                                     (e.g. "Dec" for december)
                               'dd' is the day (2 characters required)
                DC_CHAR - a pointer to a NUL-terminated C-string, if the
                         string is longer than the addressed DataColumn,
                         it is truncated.
                DC_NUMERIC - a pointer to a NUL-terminated C-string
                         representing a decimal number (e.g. "-123.567")
                DC_FLOAT - a pointer to a single precision (32 bit) floating
                         point value.
                DC_DOUBLE - a pointer to a double precision (64 bit) floating
                         point value.
                DC_LOGIC - a single byte value, either 'F' or 'T'.

             If wrong argument types are passed or the number of entries in
             this array doesn't match the number of fields specified by the
             key-expression the result of this function is unpredictabe.

 RESULT
    If the function succeeds, TRUE is returned, the key-value is copied into
    the specified buffer.
    If the function fails, FALSE is returned, the contents of the key-value
    buffer is not changed.

database.library/IDX_EvalExpressionB        database.library/IDX_EvalExpressionB

 NAME
    IDX_EvalExpressionB - create a keyvalue from user input

 SYNOPSIS
    BOOL IDX_EvalExpressionB (struct DataServer *, UBYTE *, APTR, STRPTR *)
    success = IDX_EvalExpressionB (server, expr, key, args)
      D0                             A0     A1   A2    A3
 
 FUNCTION
    This function can be used to create a keyvalue from user-input.
    A NULL-terminated array of pointers to strings as read from the user
    (e.g. from the console) is passed to this function. Each entry in this
    array represents a value used instead of a fieldvalue from the DataServer
    this index is attached to.
    The arguments must occure in the same order as in the key-expression.
    If there as many entries in the array as fields referenced by the
    expression, the missing values are set to empty values (e.g. zero for
    numeric fields or an empty string for string-fields).

    The keyvalue created by this function may be used to search an entry
    in this index. Usually you should enable 'softseek' for this purpose.

 INPUTS
    server - a pointer to the DataServer structure of the DataServer that
          should be indexed using this key-expression. This reference is
          required to determine the type and size of the Database-fields
          referenced by the key-expression.
    expr - a pointer to the preprocessed expression of the key. This has to
          be a string as created by IDX_PreCompileExpression(). If this
          expression is not precompiled or not tested using IPX_KeyLength()
          this may lead to unpredictable results (you may meet the Guru).
    key - a pointer to the buffer, where the keyvalue should be stored.
          This may be the 'KeyValue' buffer in the IDXKeyEntry structure
          referenced by the 'CurrentKey' pointer of an IDXHeader structure.
    args - a pointer to a NULL-terminated array of pointers to the strings
          representing the desired values used to evaluate the key.

 RESULT
    If the function succeeds, TRUE is returned, the evaluated keyvalue is
    stored in the specified buffer.
    If the function fails, FALSE is returned, the contents of the buffer is
    not changed.

database.library/IDX_FindKey                        database.library/IDX_FindKey

 NAME
    IDX_FindKey - find the entry for the key of the current record

 SYNOPSIS
    BOOL IDX_FindKey (struct IDXHeader *, struct DataServer *)
    found = IDX_FindKey (ihd, server)
      D0                 A0   A1

 FUNCTION
    This function tries to find the key matching to the current record of the
    DataServer in the index.

    This is usefull, if you wish to remove the key for the current record of
    the DataServer. In this case the function IDX_RemoveKey() has to be
    called after this function succeeds.

 INPUT
    ihd - a pointer to the IDXHeader structure of the index
    server - a pointer to the DataServer structure of the DataServer

 RESULT
    If the key-entry for the current record of the DataServer is found, it
    is used as current key and TRUE is returned, else FALSE is returned.

database.library/IDX_GetKeyValue                database.library/IDX_GetKeyValue

 NAME
    IDX_GetKeyValue - get the key-value of the current record

 SYNOPSIS
    BOOL IDX_GetKeyValue (struct DataServer *, APTR, UBYTE *)
    success = IDX_GetKeyValue (server, keyValue, expr)
      D0                         A0    A1       A2

 FUNCTION
    This function copies the key-value according to the current record of the
    DataServer and the specified key-expression into the user-suplied buffer.

 INPUTS
    server - a pointer to the DataServers DataServer structure.
    keyValue - a pointer to the buffer, where the key should be stored. Take
          care that this buffer is large enough to contain the whole value
          (buffer overruns are not funny).
    expr - a pointer to the preprocessed expression of the key. This has to
          be a string as created by IDX_PreCompileExpression(). If this
          expression is not precompiled or not tested using IPX_KeyLength()
          this may lead to unpredictable results (you may meet the Guru).

 RESULT
    If the function succeeds, the key-value of the current record is copied
    to the specified buffer and TRUE is returned.
    If the function fails, FALSE is returned. The DataServers 'LastError'
    field is set to an according errorcode.

database.library/IDX_InitA                            database.library/IDX_InitA

 NAME
    IDX_InitA - create and initialize an index

 SYNOPSIS
    struct IDXHeader *IDX_InitA (APTR, struct TagItem *)
    indexHeader = IDX_InitA (unused, tagList)
        D0                     A0       A1

 FUNCTION
    This function creates and initializes an index. If an index-file is
    specified, this file is read -- if it's already existing -- or newly
    created.
    If a new index is created, the keys for every record of the attached
    DataBase are created, if not specified otherwise.

 INPUTS
    unused - this argument is not used in the current implementation, it is
          reserved for future use and should be set to NULL.
    tagList - a pointer to a variable sized array of TagItem structures.
          This array has to be terminated by a TagItem with the Tag
          TAG_DONE.
          Currently defined Tags are:

             THESE TAGS ARE MANDATORY:

          IDX_FileName - a pointer to a NUL-terminated C-string with the
                   filename (and path) of the index-file.
                   If the file is currently not existing, it will be created.
                   If this argument is not passed, the index will only resist
                   in memory and will be lost, if it is disposed.
                   In these cases the TagItems with the Tags IDX_Expression,
                   IDX_Name, and IDX_Server have to be present in the TagItem
                   list.
       or
          IDX_Name - a pointer to a NUL-terminated C-string with the name of
                   the index. This name is used for the DS_SETORDER command.
                   The string is limited to 32 characters (incl. terminating
                   NUL-byte) and is truncated to this length if a longer
                   string is passed. If the indexfile already exists, the
                   name stored in the file is used, this TagItem is ignored
                   in this case.
          IDX_Expression - the expression used for the index. This TagItem
                   has to be present, if no filename is passed to this
                   function (using the Tag IDX_FileName) or the according
                   file is not present. The length of an expression is
                   limited to 256 characters (incl. terminating NUL-byte).
                   If the index-file is already existing, this TagItem is
                   ignored.
          IDX_Server - a pointer to the DataServer structure of the
                   DataServer this index belongs to.
                   If the index-file is already existing, this TagItem is
                   ignored.

             THESE TAGS ARE OPTIONAL:

          IDX_PageSize - the size of one page (one node of the B-tree)
                   stored in the index-file. This value has to be 2^n, where
                   n has to be chosen so that the value is in the range from
                   1024 upto 32768. If an illegal value is passed, it is
                   rounded to match the requirements.
                   If this value is not specified, the optimal pagesize is
                   calculated by this function.
                   You may use this TagItem, if the calculated pagesize will
                   be very large and you prefer smaller pages, maybe because
                   only very few keys are stored in the index or your file-
                   system is uneffective with large block-transfers.
                   This value is ignored, if the index-file is already
                   existing.
          IDX_Unique - a boolean Tag, if the index is created and a TagItem
                   with this Tag is present in the TagItem list, the new
                   index will be unique, i.e. no duplicate keys are allowed.
                   If duplicate keys are allowed, this will slow down the
                   seek-operations.
          IDX_Descend - a boolean Tag, if a TagItem with this Tag is present
                   in the TagItem list, the index will be ordered descend,
                   i.e. the keyvalue with the "highest" value are ordered
                   first.
                   This Tag is only useful, if you doesn't attache the index
                   to a DataTable, otherwise this setting is overwritten by
                   the DataTable. Send the operation DS_ORDERASCEND with the
                   argument FALSE to the DataTable to change the ordering to
                   descend order in this case.
          IDX_Custom - a boolean Tag, if a TagItem with this Tag is present
                   in the TagItem list, the index will not be handled by the
                   DataServer itself, i.e. if rows are added or removed from
                   the DataServer, the according keys in this index have to
                   be added/removed by the application itself using
                   IDX_InsertKey() or IDX_RemoveKey()
          IDX_Exclusive - a boolean Tag, if a TagItem with this Tag is
                   present in the TagItem list, the index is opened exclusive
                   i.e. every try to open the index will be denied and the
                   index need not to be locked before every access.
          IDX_WriteBehind - a boolean Tag, if a TagItem with this Tag is
                   present in the TagItem list, the index will use a
                   write-behind caching-algorithm, i.e. the changes to the
                   pages of the index are not written immediately after they
                   are changed, instead they are written when the pages are
                   flushed from memory or the function IDX_EndTransaction()
                   is called. If this option is used, the performance of the
                   index-changing-operations will increase slightly (if more
                   than one key on the same page is changed during the same
                   transaction). On the other hand the chance that a system
                   failure (a Guru) will damage the index increases.
             NOTE:
                   If this flag is set, the functions IDX_BeginTransaction()
                   and IDX_EndTransaction() MUST be used if the index is
                   changed, or you will corrupt the index-file.

 RESULT
    If the function succeeds, a pointer to the IDXHeader structure of the
    index is returned, else NULL is returned.

 NOTE
    If a completely new index is created by this function and this index is
    not specified as custom-index (by passing a TagItem with the Tag
    IDX_Custom), every record of the attached DataServer is indexed by this
    function. This may take some time -- upto several minutes for large
    DataBases (50000 records or more), even if you use a fast processor
    (68060-50Mhz).
    Therefor you should create all indexes during application start as
    custom indexes and patch the 'Flags' field after this function succeeded.
    Then you can call IDX_ReIndex() direct by your application and so you
    are able to use a FloatBar for indicating the progress (or if you like
    programming event-driven functions you may be able to write the re-
    indexing as background process).

database.library/IDX_InsertKey                    database.library/IDX_InsertKey

 NAME
    IDX_InsertKey - add a new key to the index

 SYNOPSIS
    BOOL IDX_InsertKey (struct IDXHeader *, struct DataServer *)
    success = IDX_InsertKey (ihd, server)
       D0                    A0   A1

 FUNCTION
    This function inserts a key for the current row of the specified
    DataServer into the index. It only performs a test, if an entry with
    the same key-value is already inserted into the index, if the index
    is created using the Tag IDX_Unique.

 INPUTS
    ihd - a pointer to the IDXHeader structure of the index, the index should
          be created with the custom-flag (using the Tag IDX_Custom)
    server - a pointer to a DataServer structure. The key that should be
          inserted is the one, that references the current record of this
          server.

 RESULT
    If the function succeeds, TRUE is returned.
    If the function fails, FALSE is returned, the cause of the failure is
    stored in the 'DataServer.LastError' field of the specified DataServer.

 NOTE
    You should enclose this function-call by a call to the
    IDX_StartTransaction()/IDX_EndTransaction() function-pair to
    avoid conflicts with other instances accessing this index.

database.library/IDX_KeyCount                      database.library/IDX_KeyCount

 NAME
    IDX_KeyCount - count the keys in an index

 SYNOPSIS
    ULONG IDX_KeyCount (struct IDXHeader *)
    numKeys = IDX_KeyCount (ihd)
       D0                   A0

 FUNCTION
    This function counts the number of keys stored in the index.
    If a scope is set, only the keys inside of the scope are count.

    This is a quite slow operation, because every key in the index is
    touched by this function.

 INPUT
    ihd - a pointer to the IDXHeader structure of the index

 RESULT
    This function returns the number of keys stored in the index.

database.library/IDX_KeyLength                    database.library/IDX_KeyLength

 NAME
    IDX_KeyLength - Get the length of a key produced by an expression

 SYNOPSIS
    UWORD IDX_KeyLength (struct DataServer *, UBYTE *)
    keyLength = IDX_KeyLength (server, keyExpr)
       D0                        A0      A1

 FUNCTION
    This function has to be called after a key-expression has been pre-
    compiled to calculate the length of the key-value that will be
    "produced" by this expression.

    Another benefit of this function is, that it tests if the resulting
    expression is valid, i.e. if the referenced columns of the DataServer
    are of the expected type and the structure of the expression is valid.

    The length of a keyvalue cannot exceed 256 bytes, otherwise this
    function will fail and return zero.

 INPUT
    server - a pointer to the DataServer structure of the DataServer whichs
          data should be retrieved.
    keyExpr - a pointer to the preprocessed expression of a key.

 RESULT
    If the expression is valid, the length of the resulting keyvalue is
    returned, else zero is returned.

database.library/IDX_PreCompileExpression

 NAME
    IDX_PreCompileExpression - precompile a key-expression

 SYNOPSIS
    LONG IDX_PreCompileExpression (UBYTE *, UBYTE *, ULONG)
    bytesCopied = IDX_PreCompileExpression (server, keyExpr, buffer, bufSize)
        D0                                    A0      A1       A2       D0

 FUNCTION
    This function is used to precompile a key-expression. Precompiled
    expressions are shorter than the not-compiled ones and kann be faster
    interpreted.

 INPUTS
    server - a pointer to the DataServers DataServer structure.
    keyExpr - a pointer to the NUL-terminated string with the expression to
             be processed
    buffer - the destination buffer, where the compiled expression should be
             copied into
    bufSize - the size of the destination buffer. This buffer should be as
             large as the length of the 'keyExpr' string (plus 2 bytes).

 RESULT
    If the function succeeds, the number of bytes copied into the buffer
    is returned, else -1 is returned.

database.library/IDX_ReIndex                        database.library/IDX_ReIndex

 NAME
    IDX_ReIndex - recreate the whole index.

 SYNOPSIS
    BOOL IDX_ReIndex (struct IDXHeader *, struct DataServer *,
                                        REINDEX_PROGRESS, APTR)
    success = IDX_ReIndex (ihd, server, fct, userData)
      D0                   A0   A1  A2      A3

 FUNCTION
    This function clears all keys stored in the index and creates a new key
    for every record in the specified DataServer. Take care that you have
    exclusive access to the DataServer to avoid conflicts with other
    instances accessing this DataServer (resp. its DataBase).

    If the keys of the index are defined as unique, records with dublicate
    keys are silently skipped by this function, i.e. no keyentries for these
    records are inserted into the index.

    This function calls the function IDX_StartTransaction() at the begin and
    IDX_EndTransaction() at the end if the index is not already locked, so
    you need not to enclosed this function by that function-pair. But it is
    save to call this function with a locked index.

 INPUTS
    ihd - a pointer to the IDXHeader structure of the index. This index must
          not be attached to the server, or this operation will fail.
          If the index is not empty, you must have exclusive access to this
          index, i.e. no other FileHandle to the index-file must be opened
          (the FileHandle of this instance needs not to be opened with
          exclusive access, the function DBF_ClearIndex() will temporary
          change the mode, if required).
    server - a pointer to the DataServer, whichs records should be indexed.
          You should take care, that the server is not used by any other
          instance (you should have exclusive access) or this operation may
          fail to read the data of every record.
    fct - a pointer to a function called everytime ten records are indexed.
          If NULL is passed for this argument, the progress of this function
          is not visible or abortable.
          The function has to expect three arguments:
                - a pointer to the IDXHeader structure of this index
                - the number of records already processed
                - a pointer to user-defined data.
          The function has to return a boolean value, if FALSE is returned,
          the indexing is aborted.
    userData - a pointer to any data, that is passed as second argument to
          the callback function.

 RESULT
    If the function succeeds, TRUE is returned.
    If the function fails, FALSE is returned.

 NOTES
    If the accessed DataServer is an instance of DataTable, you have to take
    care that the server doesn't processes deleted record:
                      DBF_ShowDeleted (server,FALSE)
    otherwise, these records will occure in the created index. If these
    records are overwritten during the insertion of new records, these new
    records would be accessed by these wrong key-entries.

    The current record of the DataServer is undefined after this function
    returned.

    You should not have any relations from other DataServers to this server,
    otherwise this will result in unnecessary I/O done to synchronize these
    servers.

    You should not have any index attached to the DataServer to prevent
    unneccessary I/O, otherwise every attached index would be positioned to
    the current record on every skip through the DataTable.

 KNOWN BUGS
    This function calls the function IDX_ClearIndex() to clear the index
    before it is reindexed. See KNOWN BUGS for that function to get knowledge
    of possible problems and their solution.

 WORKAROUND
    The easiest way to supress any problems using this function, is to use
    it not ;-). You should use the function from the DataTable DBF_ReIndex()
    instead. This function hides all problems to the user and in the worst
    case the reindexed index isn't opened any more, after the function
    returned, but your application will not die.

database.library/IDX_RemoveKey                    database.library/IDX_RemoveKey

 NAME
    IDX_RemoveKey - Remove the last accessed key from the index

 SYNOPSIS
    BOOL IDX_RemoveKey (struct IDXHeader *)
    success = IDX_RemoveKey (ihd)
      D0                     A0

 FUNCTION
    This function removes the key that was last accessed (e.g. using
    IDX_Seek() or IDX_FindKey()) from the index.
    After the key is removed, the index is positioned on the successor of
    this key, so you could loop-call this function to remove any number of
    keys from the index.

 INPUT
    ihd - a pointer to the IDXHeader structure of the index, the index should
          be created with the custom-flag (using the Tag IDX_Custom)

 RESULT
    If the function succeeds, TRUE is returned.
    If the function fails, FALSE is returned.

 NOTE
    You should enclose this function-call by a call to the
    IDX_StartTransaction()/IDX_EndTransaction() function-pair to
    avoid conflicts with other instances accessing this index.

 KNOWN BUGS
    The setting of the flag IDX_DESCEND is not taken into account by this
    function, it will always position to the next key-entry, as if the flag
    is not set.

database.library/IDX_Seek                              database.library/IDX_Seek

 NAME
    IDX_Seek - search a key in the index

 SYNOPSIS
    ULONG IDX_Seek (struct IDXHeader *, APTR, BOOL)
    recNo = IDX_Seek (ihd, key, softSeek)
      D0              A0   A1      D0

 FUNCTION
    This function tries to locate the entry with the specified key in the
    index and returns the number of the according row in the DataServer.

    If the index is not unique and there are two or more entries matching
    the key, the record number of the first one of these entries is returned
    so this function could be followed by a loop-call to
          IDX_SeekNext (ihd, key, TRUE)
    to get access to all records that match this key.

 INPUTS
    ihd - a pointer to the IDXHeader structure of the index
    key - a pointer to the buffer, where the keyvalue is stored, usually
          created by IDX_EvalExpression(), IDX_GetKeyValue(), or
          IDX_KeyCreate(). This may be the 'KeyValue' buffer in the
          IDXKeyEntry structure referenced by the 'CurrentKey' pointer of
          the IDXHeader structure.
    softSeek - a boolean value, if this argument is TRUE, the search stops at
          the first entry with a keyvalue greater or equal the specified key,
          otherwise the search will only stop if a exact matching value is
          found.

 RESULT
    If the specified key is found in the index, the number of the according
    row in the DataServer is returned, else zero is returned.

 NOTE
    You should enclose this function-call by a call to the
    IDX_StartTransaction()/IDX_EndTransaction() function-pair to
    avoid conflicts with other instances accessing this index.

database.library/IDX_SeekNext                      database.library/IDX_SeekNext

 NAME
    IDX_SeekNext - search a key in the index starting at the current position

 SYNOPSIS
    ULONG IDX_SeekNext (struct IDXHeader *, APTR, BOOL)
    recNo = IDX_SeekNext (ihd, key, softSeek)
      D0                  A0   A1      D0

 FUNCTION
    This function tries to locate the entry with the specified key in the
    index starting at the current position and returns the number of the
    according row in the DataServer.

    You should search the first matching record using the function IDX_Seek()
    because that function is quite faster for this purpose.

 INPUTS
    ihd - a pointer to the IDXHeader structure of the index
    key - a pointer to the buffer, where the keyvalue is stored, usually
          created by IDX_EvalExpression(), IDX_GetKeyValue(), or
          IDX_KeyCreate(). This may be the 'KeyValue' buffer in the
          IDXKeyEntry structure referenced by the 'CurrentKey' pointer of
          the IDXHeader structure.
    softSeek - a boolean value, if this argument is TRUE, the search stops at
          the first entry with a keyvalue greater or equal the specified key,
          otherwise the search will only stop if a exact matching value is
          found.

 RESULT
    If the specified key is found in the index, the number of the according
    row in the DataServer is returned, else zero is returned.

 NOTE
    You should enclose this function-call by a call to the
    IDX_StartTransaction()/IDX_EndTransaction() function-pair to
    avoid conflicts with other instances accessing this index.

database.library/IDX_SetScope                      database.library/IDX_SetScope

 NAME
    IDX_SetScope - set or clear an orderscope

 SYNOPSIS
    BOOL IDX_SetScope (struct IDXHeader *, APTR, APTR)
    success = IDX_SetScope (ihd, topScope, bottomScope)
      D0                    A0      A1          A2

 FUNCTION
    This function sets or clears an orderscope. This scope is the range, the
    indes is operating in, i.e. only keys that are inside of this scope can
    be accessed (except for insertion or deletion).

 INPUTS
    ihd - a pointer to the IDXHeader structure of the index
    topScope - a pointer to the keyvalue of the key that should be handled as
                topmost key in the index. If NULL is passed for this argument
                the top border of the scope is cleared, i.e. the topmost key
                of the index is the top border.
    bottomScope - a pointer to the keyvalue of the key that should be handled as
                lowest key in the index. If NULL is passed for this argument
                the bottom border of the scope is cleared, i.e. the lowest key
                of the index is the bottom border.
                If both -- 'topScope' and 'bottomScope' -- are specified the
                'topScope' has to be equal to 'bottomScope' or a keyvalue
                that is ordered before 'bottomScope'

 RESULT
    If the function succeeds, TRUE is returned. You should do an
    "inplace-skip" (i.e. call IDX_SkipNext() with zero records to be skipped)
    to evaluate, if the previously current key is still valid, i.e. if it is
    inside of the scope. If the previously current key is not inside of the
    scope, it is cleared, i.e. IDX_SkipNext() will fail.
    If the function fails (system is VERY low on memory or the specified
    'topScope' is ordered behind 'bottomScope'), FALSE is returned.

database.library/IDX_SkipBottom                  database.library/IDX_SkipBottom

 NAME
    IDX_SkipBottom - skip to the last key stored in the index

 SYNOPSIS
    ULONG IDX_SkipBottom (struct IDXHeader *)
    recordNumber = IDX_SkipBottom (ihd)
         D0                        A0

 FUNCTION
    This function returns the number of the record in the DataBase according
    to the last key stored in the index respectively the last key found
    inside the set scope.

 INPUT
    ihd - a pointer to the IDXHeader structure of the index

 RESULT
    The record-number of the row in the DataServer according to the last
    key in this index is returned, or zero if no key is stored in this index.

 NOTE
    You should enclose this function-call by a call to the
    IDX_StartTransaction()/IDX_EndTransaction() function-pair to
    avoid conflicts with other instances accessing this index.

database.library/IDX_SkipNext                      database.library/IDX_SkipNext

 NAME
     IDX_SkipNext - skip a number of keys to the bottom of the index

 SYNOPSIS
     ULONG IDX_SkipNext (struct IDXHeader *, ULONG)
     recordNumber = IDX_SkipNext (ihd, numKeys)
          D0                      A0     D0

 FUNCTION
     This function can be used to skip a specified number of keys down to the
     bottom of the index, e.g. a call to IDX_SkipBottom() followed by a loop
     of calls to this function can be used to get the record-numbers of all
     records referenced by this index in the order they are stored.

 INPUTS
     ihd - a pointer to the IDXHeader structure of the index
     numKeys - the number of keys that should be skipped

 RESULT
     The record-number of the record in the DataBase according to the key in
     this index that is the specified number of keys down to the bottom of
     the index is returned, or zero if the last key in the index is passed.

 NOTE
     You should enclose this function-call by a call to the
     IDX_StartTransaction()/IDX_EndTransaction() function-pair to
     avoid conflicts with other instances accessing this index.

database.library/IDX_SkipPrevious              database.library/IDX_SkipPrevious

 NAME
    IDX_SkipPrevious - skip a number of keys to the top of the index

 SYNOPSIS
    ULONG IDX_SkipPrevious (struct IDXHeader *, ULONG)
    recordNumber = IDX_SkipPrevious (ihd, numKeys)
         D0                          A0     D0

 FUNCTION
    This function can be used to skip a specified number of keys up to the
    top of the index, e.g. a call to IDX_SkipBottom() followed by a loop
    of calls to this function can be used to get the record-numbers of all
    records referenced by this index in the reverse order.

 INPUTS
    ihd - a pointer to the IDXHeader structure of the index
    numKeys - the number of keys that should be skipped

 RESULT
    The record-number of the row in the DataServer according to the key in
    this index that is the specified number of keys up to the top of the
    index is returned, or zero if the first key in the index is passed.

 NOTE
    You should enclose this function-call by a call to the
    IDX_StartTransaction()/IDX_EndTransaction() function-pair to
    avoid conflicts with other instances accessing this index.

database.library/IDX_SkipTop                        database.library/IDX_SkipTop

 NAME
    IDX_SkipTop - skip to the first key stored in the index

 SYNOPSIS
    ULONG IDX_SkipTop (struct IDXHeader *)
    recordNumber = IDX_SkipTop (ihd)
         D0                     A0

 FUNCTION
    This function returns the number of the row in the DataServer according
    to the first key stored in the index respectively the first key found
    inside the set scope.

 INPUT
    ihd - a pointer to the IDXHeader structure of the index

 RESULT
    The record-number of the row in the DataServer according to the first
    key in this index is returned, or zero if no key is stored in this index.

 NOTE
    You should enclose this function-call by a call to the
    IDX_StartTransaction()/IDX_EndTransaction() function-pair to
    avoid conflicts with other instances accessing this index.

database.library/IDX_StartTransaction      database.library/IDX_StartTransaction

 NAME
    IDX_StartTransaction - prepare the index for a read or write access

 SYNOPSIS
    BOOL IDX_StartTransaction (struct IDXHeader *, LONG)
    success = IDX_StartTransaction (ihd, accessType)
      D0                            A0       D0

 FUNCTION
    In a multiuser (or multitasking) environment this function has to be
    called, immediately before any access to the index is performed to
    prevent other processes from changing (or reading) the index until
    the access has finished. Only if this function succeeds, the desired
    access should be performed.

    This function could only be called once, additonal calls will fail until
    the matching IDX_EndTransaction() is called, the resulting errorcode
    will be set to ERROR_LOCK_COLLISION;

    The function tests, if the index-file has been changed (by another
    instance of this index) since the last access and discards all currently
    cached pages in that case.

 INPUTS
    ihd - a pointer to the IDXHeader structure of the index
    accessType - the type of access that should be performed. This could
             be either
                IDX_READ - for read-only accesses
                IDX_WRITE - for read-write accesses

 RESULT
    If the desired access could be performed, the index is locked and TRUE
    is returned. In this case the function IDX_EndTransaction() has to be
    called after the access has finished to unlock the index again, so
    other instances could read or write the index.
    If the function failes, FALSE is returned. See IoErr() for an according
    AmigaDos errorcode.

 BUGS
    On success IoErr() is not cleared.

database.library/IDX_ValidKey                      database.library/IDX_ValidKey

 NAME
    IDX_ValidKey - determine if the index is positioned at any entry

 SYNOPSIS
    BOOL IDX_ValidKey (struct IDXHeader *)
    isValid = IDX_ValidKey (ihd)
      D0                    A0

 FUNCTION
    This function determines if the index is positioned at an entry or not,
    i.e. if the functions IDX_SeekNext(), IDX_SkipNext(), IDX_SkipPrevious(),
    and IDX_RemoveKey() could succeed.

    This function is usually called after a successfull call to the
    function IDX_StartTransaction(), because that function will clear the
    current entry, if the index-file has been changed by another instance
    of this index.

    If this function fails, but your DataServer is positioned at a valid
    record, which should have a matching entry in this index, you have to
    call IDX_FindKey() before any of the functions named above is called.

 INPUT
    ihd - a pointer to the IDXHeader structure of the index

 RESULT
    If the index is positioned on a valid entry, TRUE is returned, else
    FALSE is returned.

database.library/LToS                                      database.library/LToS

 NAME
    LToS - convert a logic value into a string

 SYNOPSIS
    BOOL LToS (APTR, UBYTE *)
    isTrue = LToS (logic, str)
      D0             A0   A1

 FUNCTION
    This function converts a logic value as stored in a column of a
    DataServer into the string "true" or "false".

 INPUTS
    logic - a pointer to a logic value as stored in a DataServer
    str - a pointer to the destination buffer, where the resulting string
          is copied into; this buffer has to be at least 6 bytes large.

 RESULT
    If the specifed logic value is 'true', TRUE is returned, else FALSE
    is returned.

database.library/Numeric2DOUBLELONG          database.library/Numeric2DOUBLELONG

 NAME
    Numeric2DOUBLELONG - convert a NUMERIC value into a DOUBLELONG

 SYNOPSIS
    BOOL Numeric2DOUBLELONG (UBYTE *, UWORD, UWORD, UWORD, DOUBLELONG *)
    valid = Numeric2DOUBLELONG (num, length, decimals, exponent, val)
     D0                         A0    D0:16   D1:16     D2:16    A1

 FUNCTION
    This function converts a NUMERIC value (a fixed point decimal value)
    into a DOUBLELONG.
    Convertions between NUMERIC and DOUBLELONG are required for doing any
    arithmetic operations with NUMERIC values.

 INPUTS
    num - a pointer to the NUMERIC value. This value is 'length' bytes long,
          the first byte is the sign: either '+' or '-', optional followed
          by zeros '\0' and than followed by the digits of the NUMERIC value
          without a comma. This value is usually not NUL-terminated
    length - the length of the whole NUMERIC value inclusive its sign (<= 18)
    decimals - the number of digits at the end of the value, that are
          representing the part behind the comma. There have to be at least
          'decimals' + 1 digits in the passed NUMERIC value; 'decimals' MUST
          be at least two lower than 'length'.
    exponent - this value represents the exponent to the base 10, that should
          be multiplied with the NUMERIC value before convertion. Beware of
          overflows.
          The resulting part behind the comma is rounded up.
    val - a pointer to the DOUBLELONG, where the result should be stored.

 RESULT
    If the NUMERIC value is valid and could be converted, TRUE is returned.
    If the passed value is not valid or an overflow occures, FALSE is
    returned.

database.library/Numeric2Str                        database.library/Numeric2Str

 NAME
    Numeric2Str - create a string representing a NUMERIC

 SYNOPSIS
    BOOL Numeric2Str (UBYTE *, UWORD, UWORD, STRPTR)
    valid = Numeric2Str (num, length, decimals, str)
     D0                  A0    D0:16    D1:16   A1

 FUNCTION
    This function creates a string representing the specified NUMERIC.

 INPUTS
    num - a pointer to the NUMERIC value. This value is 'length' bytes long,
          the first byte is the sign: either '+' or '-', optional followed
          by zeros '\0' and than followed by the digits of the NUMERIC value
          without a comma. This value is usually not NUL-terminated
    length - the length of the whole NUMERIC value inclusive its sign (<= 18)
    decimals - the number of digits at the end of the value, that are
          representing the part behind the comma. There have to be at least
          'decimals' + 1 digits in the passed NUMERIC value; 'decimals' MUST
          be at least two lower than 'length'.
    str - a pointer to the destination buffer for the resulting string. This
          buffer has to be at least 'length' + 2 bytes large.

 RESULT
    If the NUMERIC value is valid and could be converted, TRUE is returned.
    If the passed value is not valid or an overflow occures, FALSE is
    returned.

 BUGS
    The function doesn't tests if the input is valid, instead the function
    always returns TRUE. The resulting string of an invalid NUMERIC is
    undefined and might look strange.

database.library/NumericIntDigits              database.library/NumericIntDigits

 NAME
    NumericIntDigits - number of digits of the integer part of a NUMERIC

 SYNOPSIS
    UWORD NumericIntDigits (UBYTE *, UWORD, UWORD)
    numDigitis = NumericIntDigits (num, length, decimals)
      D0:16                        A0    D0:16    D1:16

 FUNCTION
    This function counts the number of digits that represent the integer part
    of a NUMERIC value (i.e. the digits that are located in front of the
    comma sign.

 INPUTS
    num - a pointer to the NUMERIC value. This value is 'length' bytes long,
          the first byte is the sign: either '+' or '-', optional followed
          by zeros '\0' and than followed by the digits of the NUMERIC value
          without a comma. This value is usually not NUL-terminated
    length - the length of the whole NUMERIC value inclusive its sign (<= 18)
    decimals - the number of digits at the end of the value, that are
          representing the part behind the comma. There have to be at least
          'decimals' + 1 digits in the passed NUMERIC value; 'decimals' MUST
          be at least two lower than 'length'.

 RESULT
    The number of digits of the integer part of the specified NUMERIC is
    returned or zero, if the specified NUMERIC is not valid.

database.library/RAtChr                                  database.library/RAtChr

 NAME
    RAtChr - search the last occurance of a character

 SYNOPSIS
    ULONG RAtChr (UBYTE *, UBYTE, ULONG)
    position = RAtChr (string, character, slen)
       D0                 A0     D0:8       D1

 FUNCTION
    This function searches the last occurance of the specified character
    in the string.

 INPUTS
    string - a pointer to the string
    character - the character searched in the string
    slen - the length of the string

 RESULT
    The position of the last occurance of the character in the string is
    returned, or 0 if the character is not found.

database.library/STR                                        database.library/STR

 NAME
    STR - generate a string according to a DOUBLELONG value

 SYNOPSIS
    UBYTE *STR (DOUBLELONG *, UBYTE, UWORD)
    string = STR (val, padByte, slen)
      D0          A0    D0:8    D1:16

 FUNCTION
    This function creates a string according to the specified DOUBLELONG
    value. A new buffer of 'slen' bytes in length is allocated for the
    string, where the generated string is copied into.
    The string is usually right aligned, the empty left bytes are filled
    with the specified 'padByte'. If the 'padByte' is zero, the string is
    left aligned in the buffer.

 INPUTS
    val - a pointer to the DOUBLELONG value
    padByte - the byte-value that should be used to fill the empty left bytes
    slen - the number of characters the resulting string should have. If the
          the resulting string is longer than this number of bytes -- i.e.
          an overflow occures -- the string will be 'slen' characters wide,
          all characters are set to '9'.

 RESULT
    A pointer to the new allocated buffer of 'slen' bytes containing the
    string is returned. This buffer has to be freed using FreeMem() after
    usage.

database.library/SToD                                      database.library/SToD

 NAME
    SToD - convert a human readable string representing a date into a date

 SYNOPSIS
    BOOL SToD (UBYTE *, APTR)
    valid = SToD (dateStr, dateVal)
      D0            A0       A1

 FUNCTION
    This function converts a date specified as human readable string into a
    date as stored in a DataServer.

 INPUTS
    dateStr - a NUL-terminated C-string containing the date in FORMAT_DOS
             "dd-mmm-yy" or "dd-mmm-yyyy", "dd-mm-yy", or "dd-mm-yyyy".
             Where 'mmm' is the shortname of the month (e.g. "Dec") and 'mm'
             is the number of the month (e.g. "12"). The year has to be any
             year after 1582 A.D..
    dateVal - a pointer to the destination buffer, where the converted date
             should be stored. This buffer has to be at least 8 bytes large.

 RESULT
    If the specified string represents a valid date, TRUE is returned, else
    FALSE is returned.

database.library/SToL                                      database.library/SToL

 NAME
    SToL - convert a string to a logic value

 SYNOPSIS
    BOOL SToL (UBYTE *, APTR)
    isTrue = SToL (str, logic)
      D0           A0     A1

 FUNCTION
    This function converts a string into a logic value as stored in a
    column of a DataServer.
    This function is able to interpret the strings (case-independent):
       'T', 'True', 'Y', 'Yes', 'On', 'J', and 'Ja'
    as 'true' values. All other strings are interpreted as 'false'.

 INPUTS
    str - a pointer to the string to be interpreted. If NULL is passed
          for this argument, it is interpreted as 'false'.
    logic - a pointer to destination buffer, where the accoding logic
          value is stored; the value 'T' will be stored for a 'true'
          string, 'F' is stored for any other input. This buffer has to
          be at least 1 byte large.

 RESULT
    If the specifed string is 'true', TRUE is returned, else FALSE is
    returned.

database.library/SToT                                      database.library/SToT

 NAME
    SToT - convert a time-string into a time-value

 SYNOPSIS
    BOOL SToT (UBYTE *, ULONG *)
    validTime = SToT (timeStr, timeVal)
       D0                A0       A1

 FUNCTION
    This function converts a time-string in the format 'HH:MM:SS.mmm' into
    a time-value, i.e. the number of milliseconds elapsed since midnight.

 INPUTS
    timeStr - a pointer to time-stirng. This must be either full qualified,
          i.e. in the format 'HH:MM:SS.mmm' with every part present, or a
          NUL-terminated C-string, where the format can be terminated after
          every part (e.g. 'HH:MM:SS' or 'HH:MM' or 'HH')
    timeVal - a pointer to the destination address, where the resulting
          time-value should be stored.

 RESULT
    If the passed time-string is valid, TRUE is returned, the according
    time-value is stored in the specified address, else FALSE is returned,
    the value in the destination address is not changed.

database.library/SkipChars                            database.library/SkipChars

 NAME
    SkipChars - skip characters at the begin of a string

 SYNOPSIS
    LONG SkipChars (UBYTE *, UBYTE, LONG)
    charsSkipped = SkipChars (string, character, slen)
        D0                      A0     D0:8       D1

 FUNCTION
    This function skips all characters at the begin of the string that match
    the specified character.

 INPUTS
    string - a pointer to the string, where the characters should be skipped.
    character - the character that should be skipped
    slen - the maximum number of characters that might be skipped

 RESULT
    The number of characters skipped is returned.

database.library/Str2Numeric                        database.library/Str2Numeric

 NAME
    Str2Numeric - convert a string into a NUMERIC

 SYNOPSIS
    BOOL Str2Numeric (STRPTR, UBYTE *, UWORD, UWORD)
    valid = Str2Numeric (str, num, length, decimals)
     D0                  A0   A1    D0:16    D1:16

 FUNCTION
    This function copies the NUMERIC value according to the specified string
    into the buffer of a NUMERIC.

 INPUTS
    str - a pointer to the string that represents the NUMERIC value. If NULL
          is passed for this argument, the NUMERIC value representing zero
          is generated.
    num - a pointer to the buffer for the NUMERIC value. This buffer has to
          be 'length' bytes large.
    length - the length of the whole NUMERIC value inclusive its sign (<= 18)
    decimals - the number of digits at the end of the value, that are
          representing the part behind the comma. There have to be at least
          'decimals' + 1 digits in the passed NUMERIC value; 'decimals' MUST
          be at least two lower than 'length'.

 RESULT
    If the specified string could be successfully converted to a NUMERIC,
    TRUE is returned, else FALSE is returned.

database.library/TToS                                      database.library/TToS

 NAME
    TToS - convert a time-value into a human-readable string

 SYNOPSIS
    BOOL TToS (ULONG, UBYTE *)
    success = TToS (timeVal, timeStr)
       D0              D0      A0

 FUNCTION
    This function converts a time-value in a range of 24 Hours into a string
    representing this time in a human readable form: 'HH:MM:SS.mmm'
    where 'HH' are the number of hours (0 - 23)
          'MM' are the number of minutes (0 - 59)
          'SS' are the number of seconds (0 - 59)
          'mmm' are the number of milliseconds (0 - 999)

    THE STRING WILL NOT BE NUL-TERMINATED !

 INPUTS
    timeVal - the time-value, i.e. the number of milliseconds elapsed since
             midnight
    timeStr - a pointer to the destination buffer, which has to be at least
             12 bytes long.

 RESULT
    If the passed value is a time-value between 00:00:00.000 and 23:59:59.999
    the function will return TRUE, if the buffer contains the time in human
    readable form, else FALSE is returned to indicate an invalid time-value.

