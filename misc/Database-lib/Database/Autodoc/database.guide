@DATABASE "database.guide"
@MASTER   "database.doc"
@REMARK   This file was created by ADtoHT 2.1 on 06-May-04 15:26:44
@REMARK   Do not edit
@REMARK   ADtoHT is © 1993-1995 Christian Stieber

@$VER: database.guide (database.library 1.0) (07.05.04)
@author "Peter Riede"
@(c) "Copyright © 2004 by Peter "Noster" Riede"

@NODE MAIN "database.doc"

---------------------------------------------------------------------------
                           @{b}@{fg shine}DataBase.library 1.0@{fg text}@{ub}
                                  @{b}AUTODOC@{ub}

                   A shared runtime library for creating
                           XBase-alike databases
                       @{fg shine}Copyright © 2004 Peter Riede
                           All Rights Reserved.@{fg text}

                           I hope you like it.
---------------------------------------------------------------------------

@{"AtChr()" LINK "AtChr"}                 @{"DBF_AddAlias()" LINK "DBF_AddAlias"}         @{"DBF_AddOrder()" LINK "DBF_AddOrder"}
@{"DBF_ClearRecord()" LINK "DBF_ClearRecord"}       @{"DBF_ClearRelation()" LINK "DBF_ClearRelation"}    @{"DBF_FieldGet()" LINK "DBF_FieldGet"}
@{"DBF_FieldGetRaw()" LINK "DBF_FieldGetRaw"}       @{"DBF_FieldPut()" LINK "DBF_FieldPut"}         @{"DBF_FieldPutRaw()" LINK "DBF_FieldPutRaw"}
@{"DBF_GetOrder()" LINK "DBF_GetOrder"}          @{"DBF_InitA()" LINK "DBF_InitA"}            @{"DBF_LockRecord()" LINK "DBF_LockRecord"}
@{"DBF_Pack()" LINK "DBF_Pack"}              @{"DBF_ReadMemo()" LINK "DBF_ReadMemo"}         @{"DBF_ReIndex()" LINK "DBF_ReIndex"}
@{"DBF_RemoveAlias()" LINK "DBF_RemoveAlias"}       @{"DBF_RemoveOrder()" LINK "DBF_RemoveOrder"}      @{"DBF_SetAccessMode()" LINK "DBF_SetAccessMode"}
@{"DBF_SetLockMode()" LINK "DBF_SetLockMode"}       @{"DBF_SetRelation()" LINK "DBF_SetRelation"}      @{"DBF_ShowDeleted()" LINK "DBF_ShowDeleted"}
@{"DBF_UnLockRecord()" LINK "DBF_UnLockRecord"}      @{"DBF_Update()" LINK "DBF_Update"}           @{"DBF_WriteMemo()" LINK "DBF_WriteMemo"}
@{"DBM_ClearMemo()" LINK "DBM_ClearMemo"}         @{"DBM_CloseMemo()" LINK "DBM_CloseMemo"}        @{"DBM_LockMemo()" LINK "DBM_LockMemo"}
@{"DBM_OpenMemo()" LINK "DBM_OpenMemo"}          @{"DBM_ReadMemo()" LINK "DBM_ReadMemo"}         @{"DBM_UnLockMemo()" LINK "DBM_UnLockMemo"}
@{"DBM_WriteMemo()" LINK "DBM_WriteMemo"}         @{"DC_DefaultConvert()" LINK "DC_DefaultConvert"}    @{"DC_DefaultRevert()" LINK "DC_DefaultRevert"}
@{"DC_SetCaption()" LINK "DC_SetCaption"}         @{"DC_SetHelpText()" LINK "DC_SetHelpText"}       @{"DOUBLELONG2Numeric()" LINK "DOUBLELONG2Numeric"}
@{"DS_AddColumns()" LINK "DS_AddColumns"}         @{"DS_DoUpdate()" LINK "DS_DoUpdate"}          @{"DS_InitA()" LINK "DS_InitA"}
@{"DS_RemoveColumns()" LINK "DS_RemoveColumns"}      @{"DS_Update()" LINK "DS_Update"}            @{"DToS()" LINK "DToS"}
@{"Float2Double()" LINK "Float2Double"}          @{"IDX_ClearIndex()" LINK "IDX_ClearIndex"}       @{"IDX_CountFields()" LINK "IDX_CountFields"}
@{"IDX_Dispose()" LINK "IDX_Dispose"}           @{"IDX_EndTransaction()" LINK "IDX_EndTransaction"}   @{"IDX_EvalExpression()" LINK "IDX_EvalExpression"}
@{"IDX_EvalExpressionA()" LINK "IDX_EvalExpressionA"}   @{"IDX_EvalExpressionB()" LINK "IDX_EvalExpressionB"}  @{"IDX_FindKey()" LINK "IDX_FindKey"}
@{"IDX_GetKeyValue()" LINK "IDX_GetKeyValue"}       @{"IDX_InitA()" LINK "IDX_InitA"}            @{"IDX_InsertKey()" LINK "IDX_InsertKey"}
@{"IDX_KeyCount()" LINK "IDX_KeyCount"}          @{"IDX_KeyLength()" LINK "IDX_KeyLength"}        @{"IDX_PreCompileExpression()" LINK "IDX_PreCompileExpression"}
@{"IDX_ReIndex()" LINK "IDX_ReIndex"}           @{"IDX_RemoveKey()" LINK "IDX_RemoveKey"}        @{"IDX_Seek()" LINK "IDX_Seek"}
@{"IDX_SeekNext()" LINK "IDX_SeekNext"}          @{"IDX_SetScope()" LINK "IDX_SetScope"}         @{"IDX_SkipBottom()" LINK "IDX_SkipBottom"}
@{"IDX_SkipNext()" LINK "IDX_SkipNext"}          @{"IDX_SkipPrevious()" LINK "IDX_SkipPrevious"}     @{"IDX_SkipTop()" LINK "IDX_SkipTop"}
@{"IDX_StartTransaction()" LINK "IDX_StartTransaction"}  @{"IDX_ValidKey()" LINK "IDX_ValidKey"}         @{"LToS()" LINK "LToS"}
@{"Numeric2DOUBLELONG()" LINK "Numeric2DOUBLELONG"}    @{"Numeric2Str()" LINK "Numeric2Str"}          @{"NumericIntDigits()" LINK "NumericIntDigits"}
@{"RAtChr()" LINK "RAtChr"}                @{"SkipChars()" LINK "SkipChars"}            @{"SToD()" LINK "SToD"}
@{"SToL()" LINK "SToL"}                  @{"SToT()" LINK "SToT"}                 @{"STR()" LINK "STR"}
@{"Str2Numeric()" LINK "Str2Numeric"}           @{"TToS()" LINK "TToS"}                 

@ENDNODE
@NODE "AtChr" "database.library/AtChr()"
@{b}

 NAME@{ub}
        AtChr - search the first occurance of a character@{b}

 SYNOPSIS@{ub}
        ULONG AtChr (UBYTE *, UBYTE, ULONG)
        position = AtChr (string, character, slen)
           D0               A0     D0:8       D1@{b}

 FUNCTION@{ub}
        This function searches the first occurance of the specified character
        in the string.@{b}

 INPUTS@{ub}
        string - a pointer to the string
        character - the character searched in the string
        slen - the length of the string@{b}

 RESULT@{ub}
        The position of the first occurance of the character in the string is
        returned, or 0 if the character is not found.

@ENDNODE
@NODE "DBF_AddAlias" "database.library/DBF_AddAlias()"
@{b}

 NAME@{ub}
        DBF_AddAlias - add an alias to an index of a DataTable@{b}

 SYNOPSIS@{ub}
        BOOL DBF_AddAlias (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, STRPTR, STRPTR)
        success = DBF_AddAlias (server, alias, index)
          D0                      A0     A1      A2@{b}

 FUNCTION@{ub}
        This function adds an alias to an index that is attached to a DataTable.
        This alias is just another name for the same index, so if this alias is
        specified for either the function @{"DBF_GetOrder()" LINK "DBF_GetOrder"} or the operation
        @{"DS_SETORDER" LINK "include/DataServer.h/File" 188}, the aliased index is returned/used instead.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataTable
        alias - a pointer to a NUL-terminated C-string with the name of the
                 alias; i.e. the name that should also be usable to access
                 the specified index. Index and alias names are compared
                 case sensitive. This string is NOT copied and has to remain
                 valid until the alias is removed again.
        index - a pointer to a NUL-terminated C-string with the name of the
                 index that should be accessed using this alias.  Index and
                 alias names are compared case sensitive.@{b}

 RESULT@{ub}
        If the alias could be added successfully to the DataTable, TRUE is
        returned, else FALSE is returned.

@ENDNODE
@NODE "DBF_AddOrder" "database.library/DBF_AddOrder()"
@{b}

 NAME@{ub}
        DBF_AddOrder - add an index to the servers list of available orders@{b}

 SYNOPSIS@{ub}
        BOOL DBF_AddOrder (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, @{"struct IDXHeader" LINK "include/Index.h/File" 71} *)
        success = DBF_AddOrder (server, index)
          D0                      A0     A1@{b}

 FUNCTION@{ub}
        This function adds a new index to the servers list of available orders.
        The IDXHeader structure has to be previously created using @{"IDX_InitA()" LINK "IDX_InitA"}
        and has to reference this DataTable or the function will fail.
        Index names are compared case-sensitive.

        The open indexes of a DataTable are linked into a list. This list is
        ordered alphabetically.

        Any non-custom index in that list is updates whenever a record of the
        DataTable is changed (added, changed, or removed).@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataTable
        index - a pointer to the IDXHeader structure of the order to be added@{b}

 RESULT@{ub}
        If the passed index is attached to this DataTable, it is linked into
        the DataTables list of available orders and TRUE is returned.
        If the IDXHeader structure of the index is created for a different
        DataTable, or the 'Name' of the index is already in use, FALSE is
        returned.@{b}

 NOTE@{ub}
        Even if it is possible to add an index-alias to a DataTable using this
        function, you should prefer using the function @{"DBF_AddAlias()" LINK "DBF_AddAlias"}.

        If you add an index-aliases (IDXAlias structures) to the DataTable, the
        "aliased" index must already been added to the DataTable in a previous
        call to this function.

@ENDNODE
@NODE "DBF_ClearRecord" "database.library/DBF_ClearRecord()"
@{b}

 NAME@{ub}
        DBF_ClearRecord - clear the record buffer of the DataTable@{b}

 SYNOPSIS@{ub}
        BOOL DBF_ClearRecord (@{"struct DataTable" LINK "include/DataTable.h/File" 90} *)
        success = DBF_ClearRecord (dbTable)
          D0                         A0@{b}

 FUNCTION@{ub}
        This function clears the record-buffer of the DataTable and initializes
        it with the default values.@{b}

 INPUT@{ub}
        dbTable - a pointer to the DataTable structure of the DataServer@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned, else FALSE is returned.
        See the 'LastError' field of the embedded DataServer structure for
        details.@{b}

 NOTE@{ub}
        This function is used as callback-function from the DataTable, whenever
        a new record is created, you should NOT call this function from user-
        applications code.

@ENDNODE
@NODE "DBF_ClearRelation" "database.library/DBF_ClearRelation()"
@{b}

 NAME@{ub}
        DBF_ClearRelation - remove a related DataServer from a superior server@{b}

 SYNOPSIS@{ub}
        BOOL DBF_ClearRelation (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *)
        success = DBF_ClearRelation (client)
          D0                           A0@{b}

 FUNCTION@{ub}
        Using this function a relation between two servers can be released again.@{b}

 INPUTS@{ub}
        client - a pointer to the DataServer structure of the DataTable that
                 depends on a superior DataTable. This DataServer has to be
                 previously added to the list of related DataServers of the
                 superior server by calling @{"DBF_SetRelation()" LINK "DBF_SetRelation"}.@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned; the client-server is removed
        from the list of related DataServer and will not react on changes to the
        current record of the superior DataServer any more.
        If the function fails, FALSE is returned. See 'LastError' for details.@{b}

 NOTE@{ub}
        Even if this function fails, the relation may be cleared. This is the
        case if the 'LastError' field of the superior server is set to
        @{"DBF_ERR_RELATED_SERVER" LINK "include/DataTable.h/File" 233}. In this case you should close both servers
        as fast as possible to prevent damage to the database file.

@ENDNODE
@NODE "DBF_FieldGet" "database.library/DBF_FieldGet()"
@{b}

 NAME@{ub}
        DBF_FieldGet - get the contents of a field in human-readable form@{b}

 SYNOPSIS@{ub}
        BOOL DBF_FieldGet (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, STRPTR, STRPTR *)
        success = DBF_FieldGet (server, field, data)@{b}

 FUNCTION@{ub}
        This function copies a pointer to the contents of the specified
        DataColumn of the current row of a DataServer to the user-suplied
        address.

        The contents is presented in human-readable form, i.e. a NUL-terminated
        C-string.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataServer the data
                 should be read from.
        field - a pointer to the NUL-terminated string with the name of the field
                 (DataColumn) the data should be read from.
        data - a pointer to the address, where a pointer to the buffer containing
                 the NUL-terminated string with the columns contents in human-
                 readable form is stored should be copied to.
                 Treat this string as constant, it is owned by the DataServer and
                 you will corrupt the data of the DataServer if you write to this
                 buffer.@{b}

 RESULT@{ub}
        If the data could be read from the specified column of the DataServer
        TRUE is returned, else FALSE is returned.

@ENDNODE
@NODE "DBF_FieldGetRaw" "database.library/DBF_FieldGetRaw()"
@{b}

 NAME@{ub}
        DBF_FieldGetRaw - get the "raw" contents of a field@{b}

 SYNOPSIS@{ub}
        BOOL DBF_FieldGetRaw (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, STRPTR, APTR *)
        success = DBF_FieldGetRaw (server, field, rawdata)@{b}

 FUNCTION@{ub}
        This function copies a pointer to the contents of the specified
        DataColumn of the current row of a DataServer to the user-suplied
        address.

        The contents is presented in the "raw" format, i.e. in the format it is
        stored in the DataServer.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataServer the data
                 should be read from.
        field - a pointer to the NUL-terminated string with the name of the field
                 (DataColumn) the data should be read from.
        rawdata - a pointer to the address, where a pointer to the buffer
                 containing the columns contents in "raw" format is stored should
                 be copied to.
                 Treat this value as constant, it is owned by the DataServer and
                 you will corrupt the data of the DataServer if you write to this
                 address.@{b}

 RESULT@{ub}
        If the data could be read from the specified column of the DataServer
        TRUE is returned, else FALSE is returned.

@ENDNODE
@NODE "DBF_FieldPut" "database.library/DBF_FieldPut()"
@{b}

 NAME@{ub}
        DBF_FieldPut - write data in human-readable format into a DataColumn@{b}

 SYNOPSIS@{ub}
        BOOL DBF_FieldPut (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, STRPTR, STRPTR)
        success = DBF_FieldPut (server, field, data)@{b}

 FUNCTION@{ub}
        This function is a shortcut for locating a DataColumn in the current
        record of the DataServer and write the specified data in human-readable
        format into that column.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataServer the data
                 should be written into.
        field - a pointer to the NUL-terminated string with the name of the field
                 (DataColumn) the data should be written into.
        data - a pointer to the NUL-terminated string containing the data to be
                 written in human-readable format (the data is converted into the
                 "raw" format it is stored into the DataServer-file by this
                 function).@{b}

 RESULT@{ub}
        If the data could be written into the specified column of the DataServer
        TRUE is returned, else FALSE is returned.

@ENDNODE
@NODE "DBF_FieldPutRaw" "database.library/DBF_FieldPutRaw()"
@{b}

 NAME@{ub}
        DBF_FieldPutRaw - write "raw" data into a DataColumn@{b}

 SYNOPSIS@{ub}
        BOOL DBF_FieldPutRaw (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, STRPTR, APTR)
        success = DBF_FieldPutRaw (server, field, rawData)@{b}

 FUNCTION@{ub}
        This function is a shortcut for locating a DataColumn in the current
        record of the DataServer and write the specified data in "raw" format
        into that column.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataServer the data
                 should be written into.
        field - a pointer to the NUL-terminated string with the name of the field
                 (DataColumn) the data should be written into.
        rawData - a pointer to the data to be written in "raw" format (the data
                 in the format it is stored into the DataServer-file).@{b}

 RESULT@{ub}
        If the data could be written into the specified column of the DataServer
        TRUE is returned, else FALSE is returned.

@ENDNODE
@NODE "DBF_GetOrder" "database.library/DBF_GetOrder()"
@{b}

 NAME@{ub}
        DBF_GetOrder - get access to an index in the servers list of orders@{b}

 SYNOPSIS@{ub}
        @{"struct IDXHeader" LINK "include/Index.h/File" 71} *DBF_GetOrder (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, STRPTR)
        index = DBF_GetOrder (server, name)
          D0                    A0     A1@{b}

 FUNCTION@{ub}
        This function searches the index with the specified 'name' in the
        DataTables list of available orders.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataTable
        name - the name of the searched order, if NULL is passed the currently
                 active order is searched.
                 This function is case sensitive.
                 If you specify the name of an index-alias, the according
                 index is searched.@{b}

 RESULT@{ub}
        If the specified index is located in the servers list of available
        orders, a pointer to the IDXHeader structure of the index is returned,
        else NULL is returned.@{b}

 NOTE@{ub}
        You should check, if the flag @{"IDX_ALIAS" LINK "include/Index.h/File" 176} is set in the 'Flags' field
        of the returned structure to determine if it is a pointer to an IDXHeader
        structure or a pointer to an IDXAlias. If the flag is set, the "aliased"
        index is found at the address, the field 'ihd' of the IDXAlias structure
        point to.

@ENDNODE
@NODE "DBF_InitA" "database.library/DBF_InitA()"
@{b}

 NAME@{ub}
        DBF_InitA - create a DataTable-DataServer@{b}

 SYNOPSIS@{ub}
        @{"struct DataServer" LINK "include/DataServer.h/File" 95} *DBF_InitA (APTR, struct TagItem *)
        dataServer = DBF_InitA (unused, tagList)
            D0                    A0      A1@{b}

 FUNCTION@{ub}
        This function creates a DataTable for use in a DataBase.
        Access to the records in the DataTables file are synchronized using a
        kind of locking. This function tests, which kind of locking is supported
        by the underlying filesystem. This could be either:

           DSF_LOCK_RECORD - the single records are locked by the DataTable.
                 This type of locking is the cooperativest way of locking, only
                 the locked records are blocked for other instances, but it
                 requires the support of the filesystem, i.e. the filesystem
                 has to support record locking. AmigaOS FastFileSystem does it,
                 and the Ram-Handler (handline the ram-disk) supports this but
                 the version of AmigaOS 3.5 and 3.9 has a mayor bug which leads
                 to a Guru.
           DSF_LOCK_FILE - if the FileSystem doesn't support record locking (or
                 the record locking is bad implemented as for the AmigaOS 3.5 -
                 3.9 Ram-Handler) this locking type is used.
                 For every file according to this DataTable (the DataTable file
                 itself, the optional memo-file and all indexes attached to the
                 DataTable) an additional empty lockfile is created. This file
                 is locked shared for every read- and exclusive for every write-
                 access.
                 This is functional with every known filesystem available for
                 AmigaOS, but not as cooperative as record locking, because the
                 whole DataTable is inaccessable for every other instance while
                 it is locked to change a single record.
                 Another disadvantage of this type of locking is the greater
                 overhead required for locking a whole file instead of a single
                 record and the database requires twice as many files. If the
                 DataTable fails to lock a file, it uses a kind of "polling"
                 to determine if the file is accessable again, this results in
                 a greater load of the cpu and the filesytem (and the underlying
                 hardware the harddisk and controller resp. the whole network).@{b}

 INPUTS@{ub}
        unused - this argument is not used in the current implementation, it is
              reserved for future use and should be set to NULL.
        tagList - a pointer to a variable sized array of TagItem structures.
              This array has to be terminated by a TagItem with the Tag
              TAG_DONE.
              Currently defined Tags are:

                 THESE TAGS ARE MANDATORY:

              @{"DBF_Name" LINK "include/DataTable.h/File" 180} - a pointer to a NUL-terminated C-string with the name of
                       the DataTable. This name may be used to identify the
                       DataServer in an application.
                       The string is limited to 32 characters (incl. terminating
                       NUL-byte) and is truncated to this length if a longer
                       string is passed.
              @{"DBF_FileName" LINK "include/DataTable.h/File" 181} - a pointer to a NUL-terminated C-string with the
                       filename (and path) of the DataTable-file.
                       If the file is currently not existing, it will be created.
                       to be present in the TagItem list.
              @{"DBF_Struct" LINK "include/DataTable.h/File" 183} - the data of this TagItem is a pointer to an array of
                       DBStruct structures, terminated by a structure with a NULL
                       pointer as 'Name', describing the structure of every row
                       in the DataServers datatable. If the file already exists,
                       the structure described by this array has to match the
                       structure of the DataTables file, the 'Caption' and
                       'HelpText' strings are used in any case.
                       This structure-array is copied and needs not to remain
                       valid after this function returned, but the referenced
                       strings are not copied and need to remain valid until the
                       DataTable is disposed.

                 THESE TAGS ARE OPTIONAL:

              @{"DBF_StructSize" LINK "include/DataTable.h/File" 182} - ULONG, the size of the structure that should be
                       allocated as DataServer structure. This Tag has to be
                       specified, if a subclass of the DataTable needs additional
                       space in the structure for private data.
              @{"DBF_Exclusive" LINK "include/DataTable.h/File" 189} - a boolean TagItem, if a TagItem with this Tag is
                       present in the TagItem list, the DataTable-file will be
                       accessed in exclusive mode, i.e. every other try to open
                       the DataTable (by the same or any other application) will
                       be rejected.
                    NOTE
                       This exclusive mode is not functional on every filesystem.
                       If you place the DataTable's files in the ram-disk per
                       example, this will not guarantee exclusive access to the
                       files, due to a bug in the implementation of the
                       ACTION_CHANGE_MODE packet of the Ram-Handler found in
                       every AmigaOS from 3.1 through 3.9.
                       The FastFileSystem is functional under every supported OS.
              @{"DBF_ReadOnly" LINK "include/DataTable.h/File" 188} - a boolean TagItem, if a TagItem with this Tag is
                       present in the TagItem list, the DataTable-file will be
                       opened in read-only mode, i.e. any changes to the
                       DataTable will be rejected.
              @{"DBF_ForceUnique" LINK "include/DataTable.h/File" 187} - a boolean TagItem, if a TagItem with this Tag is
                       present in the TagItem list, all records that are added or
                       changed will be matched against all open unique indexes.
                       If an @{"IDX_ERR_DUPLICATE_KEY" LINK "include/Index.h/File" 202} occures (i.e. if the according
                       key-value is already in the index and would be added twice,
                       if the record is saved), the record will not be stored.
                       This flag does only make sence, if there will be at least
                       one unique index opened and attached to the DataTable.
              @{"DBF_LockMode" LINK "include/DataTable.h/File" 190} - the identifier passed with this TagItem specifies
                       how the records are locked in the DataTable:
                    @{"DSF_LOCK_OPTIMISTIC" LINK "include/DataTable.h/File" 200} - (default) use optimistic locking, i.e.
                       the records are locked shared while they are copied into
                       the buffer, then they are unlocked until they are written,
                       then the records are locked exclusive while they are
                       written.
                    @{"DSF_LOCK_FULL" LINK "include/DataTable.h/File" 199} - a record is locked exclusive while it is the
                       current record. This is a safe but uncooperative locking
                       method.
                    @{"DSF_LOCK_NONE" LINK "include/DataTable.h/File" 201} - a record is not locked by the DataTable. The
                       user-application has to lock the records using the
                       functions @{"DBF_LockRecord()" LINK "DBF_LockRecord"}/@{"DBF_UnLockRecord()" LINK "DBF_UnLockRecord"}. This method
                       requires the most work, but is the way for finetuning the
                       locking of the records.
              @{"DBF_Validate" LINK "include/DataTable.h/File" 185} - a pointer to a function that is called, whenever a
                       new or a changed record should be written to the DataTable
                       (when the operation @{"DS_UPDATE" LINK "include/DataServer.h/File" 209} is performed). This function
                       should validate the contents of the record. Take care that
                       this function must in no case change the current record
                       (by seeking or skipping) nor the currently active key of
                       any index attached to the DataTable. If you have to search
                       through the DataTable or an index of the DataTable, you
                       have to use another instance of the DataTable (usually
                       opened in read-only mode) for that purpose.
                       If the validation fails, the current column of the
                       DataTable has to be the faulty one (i.e. the operation
                       @{"DS_CURRENTCOLUMN" LINK "include/DataServer.h/File" 186} has to return a pointer to the invalid
                       DataColumn). If a general failure occures, you have to
                       set 'server->CurrentColumn' to zero.

                          BOOL validate (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *server)

                       The function has to return TRUE, if the record is valid,
                       or FALSE if the record is not valid.@{b}

 RESULT@{ub}
        If the function succeeds, a pointer to a full initialized DataServer
        structure of the DataTable is returned.
        If the function fails, NULL is returned.

@ENDNODE
@NODE "DBF_LockRecord" "database.library/DBF_LockRecord()"
@{b}

 NAME@{ub}
        DBF_LockRecord - lock a record of the DataTable@{b}

 SYNOPSIS@{ub}
        BOOL DBF_LockRecord (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, ULONG, ULONG, ULONG)
        success = DBF_LockRecord (server, recNo, mode, timeout)
          D0                        A0      D0    D1      D2@{b}

 FUNCTION@{ub}
        This function tries to lock the specified record in the DataTable for
        either exclusive or shared access. If the lock fails, the function
        retries to lock the record until at most the timeout-time is elapsed.

        It is safe to try to lock a record that is already locked by this
        instance of the DataTable, if the accessmode is the same, or the record
        is already locked in exclusive mode.

        Every successfull call to this function has to be matched by a call to
        @{"DBF_UnLockRecord()" LINK "DBF_UnLockRecord"}.

        Several records can be locked at the same time.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataTable
        recNo - the number of the record that should be locked. If zero is passed
                 to this argument, the header of the DataTable is locked.
        mode - the desired locking mode:
           @{"DBF_READ" LINK "include/DataTable.h/File" 194} - for read-only access (shared lock)
           @{"DBF_WRITE" LINK "include/DataTable.h/File" 195} - for writing access (exclusive lock)
        timeout - the maximum time in 50th of a second, that should be waited if
                 the lock fails. You may use the following defines:
           @{"DBF_WAIT_FOREVER" LINK "include/DataTable.h/File" 238} - wait (nearly) forever (aware of deadlocks)
           @{"DBF_WAIT_NONE" LINK "include/DataTable.h/File" 239} - don't wait, return immediately
           @{"DBF_WAIT_DEFAULT" LINK "include/DataTable.h/File" 240} - default timeout, currently defined as 5 seconds@{b}

 RESULT@{ub}
        If the record could be locked, TRUE is returned.
        If the function fails to lock the record, FALSE is returned. See
        'server->LastError' and IoErr() for errorcodes describing the cause of
        the failure.

@ENDNODE
@NODE "DBF_Pack" "database.library/DBF_Pack()"
@{b}

 NAME@{ub}
        DBF_Pack - remove all deleted records from the DataTable.@{b}

 SYNOPSIS@{ub}
        BOOL DBF_Pack (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, @{"REINDEX_PROGRESS" LINK "include/FunctionTypes.h/File" 54}, APTR)
        success = DBF_Pack (server, fct, userData)
          D0                  A0     A1     A2@{b}

 FUNCTION@{ub}
        This function removes every deleted record from the DataTable, so the
        according file shrinks in size. Every attached index is also adjusted
        so their keys reference the new recordnumbers of the records.

        This operation takes a long time, and should only be used, if there
        are many deleted records in the DataTable and new records are not
        inserted very often (i.e. if it makes sence to safe the disk-space
        used for the deleted records). Deleted records doesn't decrease the
        access-speed of the DataTable and are overwritten whenever a new record
        is inserted.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataTable
        fct - a pointer to a callback function, which might be used to interact
              with the user, i.e. to show some kind of progress to the user and
              allow him to interrupt this operation.
              This function will be called everytime a deleted record is removed.
              If NULL is passed for this argument, the progress of this function
              is not visible or abortable.
              The function has to expect three arguments:
                    - a pointer to the DataServer structuure of this DataTable
                    - the number of records already processed
                    - a pointer to user-defined data.
              The function has to return a boolean value, if FALSE is returned,
              the operation is aborted. Even if the operation is aborted, the
              DataTable stays valid.
        userData - a pointer to any data, that is passed as second argument to
              the callback function.@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned.
        If the function fails or is aborted, FALSE is returned, see the field
        'LastError' of the DataServer for the according errorcode. This will
        be zero, if the user has aborted the operation.@{b}

 NOTE@{ub}
        You should have opened and attached every index of the DataTable (as
        for every function that manipulated the DataTable) when this function
        is called. Locking is not required, the operation will only start, if
        the DataTable could gain exclusive access to the according file and the
        indexes.@{b}

 KNOWN BUGS@{ub}
        Not implemented yet ;-)

@ENDNODE
@NODE "DBF_ReIndex" "database.library/DBF_ReIndex()"
@{b}

 NAME@{ub}
        DBF_ReIndex - recreate a whole index@{b}

 SYNOPSIS@{ub}
        BOOL DBF_ReIndex (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, STRPTR, @{"REINDEX_PROGRESS" LINK "include/FunctionTypes.h/File" 54}, APTR)
        success DBF_ReIndex (server, order, fct, userData)
          D0                   A0     A1     A2     A3@{b}

 FUNCTION@{ub}
        This function is a wrapper-function for the function @{"IDX_ReIndex()" LINK "IDX_ReIndex"}.
        It performs the neccessary preparations to speed up the reindexing
        process. All indexes and related servers are temporary detached from
        the DataTable and reattached, after the reindexing process is finished.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataTable
        order - a pointer to a NUL-terminated string with the name of the index
                 to be reindexed. This index has to be currently attached to
                 the server. If NULL is passed for this argument, the currently
                 active order is reindexed.
        fct - a pointer to a function called everytime ten records are indexed.
              If NULL is passed for this argument, the progress of this function
              is not visible or abortable.
              The function has to expect three arguments:
                    - a pointer to the IDXHeader structure of this index
                    - the number of records already processed
                    - a pointer to user-defined data.
              The function has to return a boolean value, if FALSE is returned,
              the indexing is aborted.
        userData - a pointer to any data, that is passed as second argument to
              the callback function.@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned.
        If the function fails, FALSE is returned.@{b}

 NOTE@{ub}
        If the underlying filesystem doesn't support the SetFileSize() command,
        or due to the "Exclusive Mode"-bug in the Ram-Handler, the index may be
        destroyed by this function.
        If the index is destroyed, it is disposed completely. In that case you
        have to delete the index-file manually, before you reopen the index and
        try to recreate it again (you could see that the index is destroyed, if
        this function fails and the operation @{"DS_AVAILABLEORDER" LINK "include/DataServer.h/File" 191} does not list
        the index any more).

@ENDNODE
@NODE "DBF_ReadMemo" "database.library/DBF_ReadMemo()"
@{b}

 NAME@{ub}
        DBF_ReadMemo - load a memoText into memory@{b}

 SYNOPSIS@{ub}
        BOOL DBF_ReadMemo (@{"struct DataColumn" LINK "include/DataServer.h/File" 74} *, APTR)
        success = DBF_ReadMemo (column, memoAddr)
          D0                      A0       A1@{b}

 FUNCTION@{ub}
        This function copies the memotext of the current record into the buffer
        of the specified DataColumn.
        If the current record doesn't own a memotext, an empty string is copied
        into the buffer (i.e. just the terminating NUL-byte).@{b}

 INPUTS@{ub}
        column - a pointer to the DataColumn of the memotext
        memoAddr - a pointer to the two longwords containing the address of the
                    memotext in the memofile.
                    The first longword contains the number of the 'page' in the
                    memofile, where the text starts, the second longword contains
                    the offset into that page. If both values are equal zero, the
                    record doesn't own a memotext.@{b}

 RESULT@{ub}
        If the memotext could be successfully copied into memory, TRUE is
        returned, else FALSE is returned.@{b}

 NOTE@{ub}
        This function is used as callback-function from the DataTable, whenever
        a memo is read, you should NOT call this function from user-applications
        code.

@ENDNODE
@NODE "DBF_RemoveAlias" "database.library/DBF_RemoveAlias()"
@{b}

 NAME@{ub}
        DBF_RemoveAlias - remove an alias of an index of a DataTable@{b}

 SYNOPSIS@{ub}
        BOOL DBF_RemoveAlias (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, STRPTR)
        success = DBF_RemoveAlias (server, alias)
           D0                        A0      A1@{b}

 FUNCTION@{ub}
        This function removes an alias of an index of the DataTable. The memory
        used for this alias is freed.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataTable
        alias - a pointer to a NUL-terminated C-string with the name of the
                 alias that should be removed. Index and alias names are compared
                 case sensitive.@{b}

 RESULT@{ub}
        If the alias could be removed successfully from the DataTable, TRUE is
        returned, else FALSE is returned.@{b}

 NOTE@{ub}
        Aliases are also removed, if the "aliased" index is removed (using the
        function @{"DBF_RemoveOrder()" LINK "DBF_RemoveOrder"}) or the DataTable is disposed.

@ENDNODE
@NODE "DBF_RemoveOrder" "database.library/DBF_RemoveOrder()"
@{b}

 NAME@{ub}
        DBF_RemoveOrder - remove an index from the servers list of orders@{b}

 SYNOPSIS@{ub}
        @{"struct IDXHeader" LINK "include/Index.h/File" 71} *DBF_RemoveOrder (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, STRPTR)
        index = DBF_RemoveOrder (server, name)
         D0                        A0     A1@{b}

 FUNCTION@{ub}
        This function removes the index with the specified 'name' from the
        DataTables list of available orders. If the index to be removed is
        the active order, the active order of the server is cleared and the
        records are ordered as they are found in the DataTable file.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataTable
        name - the name of the order to be removed. This function is case
                 sensitve@{b}

 RESULT@{ub}
        If the specified order is located in the servers list of available
        orders, it is removed and a pointer to the IDXHeader structure of the
        order is returned, else NULL is returned.@{b}

 NOTES@{ub}
        Even if it is possible to remove an index-alias to a DataTable using this
        function, you should prefer using the function @{"DBF_RemoveAlias()" LINK "DBF_RemoveAlias"}.

        You should check, if the flag @{"IDX_ALIAS" LINK "include/Index.h/File" 176} is set in the 'Flags' field
        of the returned structure to determine if it is a pointer to an IDXHeader
        structure or a pointer to an IDXAlias. If the flag is set, the "aliased"
        index is found at the address, the field 'ihd' of the IDXAlias structure
        point to.

        If an "aliased" index is removed from the DataServer, all aliases to this
        index are removed (and freed) too.

        Any alias removed using this function has to be either added back to the
        DataTable using @{"DBF_AddOrder()" LINK "DBF_AddOrder"} or disposed by:
           FreeMem (alias, sizeof (@{"struct IDXAlias" LINK "include/Index.h/File" 130}));

@ENDNODE
@NODE "DBF_SetAccessMode" "database.library/DBF_SetAccessMode()"
@{b}

 NAME@{ub}
        DBF_SetAccessMode - change the accessmode of a DataTable.@{b}

 SYNOPSIS@{ub}
        BOOL DBF_SetAccessMode (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, BOOL)
        currentAccessMode = DBF_SetAccessMode (server, exclusive)
               D0                                A0       D0@{b}

 FUNCTION@{ub}
        Using this function, the accessmode of a DataTable can be changed.
        Usually the accessmode is specified during initialization (using the
        Tag @{"DBF_Exclusive" LINK "include/DataTable.h/File" 189}) and should not be changed, but sometimes it's
        required to have exclusive access to a DataTable (e.g. if all deleted
        records should be removed from the DataTable, so the recordnumbers of
        the remaining records will change).

        This function may fail to change the accessmode, especially if exclusive
        access is requested. Have a look to the 'LastError' field of the
        DataServer structure, which will be set to DSF_ERR_MINOR in the case of
        a failure. In that case you may also look at AmigaDOS IoErr() to get an
        idea of the cause of the failure.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataTable
        exclusive - a boolean value, TRUE indicates that the DataTable should be
                 set to exclusive access, else shared access is requested.@{b}

 RESULT@{ub}
        If the DataTable was previously set to exclusive access, TRUE is
        returned, if it was set to shared access, FALSE is returned.
        By storing this value you are able to reset the DataTable to the previous
        state.@{b}

 KNOWN BUGS@{ub}
        The exclusive mode is not functional on every filesystem, e.g. if you
        place the DataTable's files in the ram-disk, this will not guarantee
        exclusive access to the files, due to a bug in the implementation of the
        ACTION_CHANGE_MODE packet of the Ram-Handler found in every AmigaOS from
        version 3.1 through 3.9.
        The FastFileSystem is functional under every supported OS.

@ENDNODE
@NODE "DBF_SetLockMode" "database.library/DBF_SetLockMode()"
@{b}

 NAME@{ub}
        DBF_SetLockMode - change the locking-mode of a DataTable@{b}

 SYNOPSIS@{ub}
        ULONG DBF_SetLockMode (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, ULONG)
        currentMode = DBF_SetLockMode (server, lockMode)
            D0                           A0       D0@{b}

 FUNCTION@{ub}
        This function can be used to change the locking-mode of an already opened
        DataTable. Per default the locking-mode as specified during initialization
        is used (using the Tag @{"DBF_LockMode" LINK "include/DataTable.h/File" 190}).

        The current record may change as a result of this function, if the mode
        @{"DSF_LOCK_FULL" LINK "include/DataTable.h/File" 199} is specified.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataTable
        lockMode - the new locking-mode that should be used, this could be
                    either:
                 @{"DSF_LOCK_OPTIMISTIC" LINK "include/DataTable.h/File" 200} - use optimistic locking, i.e. the records
                       are locked shared while they are copied into the buffer,
                       then they are unlocked until they are written, then the
                       records are locked exclusive while they are written.
                 @{"DSF_LOCK_FULL" LINK "include/DataTable.h/File" 199} - a record is locked exclusive while it is the
                       current record. This is a safe but uncooperative locking
                       method.
                 @{"DSF_LOCK_NONE" LINK "include/DataTable.h/File" 201} - a record is not locked by the DataTable. The
                       user-application has to lock the records using the
                       functions @{"DBF_LockRecord()" LINK "DBF_LockRecord"}/@{"DBF_UnLockRecord()" LINK "DBF_UnLockRecord"}. This method
                       requires the most work, but is the way for finetuning the
                       locking of the records.@{b}

 RESULT@{ub}
        The active locking mode before this function was called is returned.
        By storing this value you are able to reset the DataTable to the previous
        state.
        You have to check the 'LastError' field of the DataServer for an error;
        if the locking-mode is set to @{"DSF_LOCK_FULL" LINK "include/DataTable.h/File" 199}, the DataTable may fail to
        lock the current record. In this case the current record is undefined,
        i.e. the recordpointer is set to EOF.

@ENDNODE
@NODE "DBF_SetRelation" "database.library/DBF_SetRelation()"
@{b}

 NAME@{ub}
        DBF_SetRelation - add a related DataServer to a superior DataServer@{b}

 SYNOPSIS@{ub}
        BOOL DBF_SetRelation(@{"struct DataServer" LINK "include/DataServer.h/File" 95}*,@{"struct DataServer" LINK "include/DataServer.h/File" 95}*,STRPTR,STRPTR)
        success = DBF_SetRelation (server, client, order, expr)
          D0                         A0      A1     A2     A3@{b}

 FUNCTION@{ub}
        This function is used to add a related DataServer to the list of related
        DataServers of a superior DataTable. This way, the two DataServers react
        like a single DataServer, e.g. the DataBrowser class handles this as a
        single DataServer and is able to display all columns of both servers.

        While the two servers are related, the related DataServer should not be
        accessed direct, except for changing its data. the current record of this
        DataServer is changed according to the current record of the superior
        DataServer. If you change the order or current record of the related
        server, these changes are undone the next time the superior server is
        moved.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the superior DataTable
        client - a pointer to the DataServer structure of the DataTable that
                 depends on the superior DataTable. This DataTable will be
                 positioned relative to the other one. Whenever the record of
                 the superior DataServer is changed, the current record of this
                 DataServer will also change, according to the relation-
                 expression.
        order - a pointer to a NUL-terminated C-string with the name of the index
                 that should be used by the related DataServer. Using this index
                 and a key generated by the specified expression and the data of
                 the superior DataServer, this DataServer is positioned to the
                 correct record. This index has to be unique, i.e. every key in
                 this index has to be unique.
                 This string is not copied, so it has to stay valid until the
                 relation is cleared again (using @{"DBF_ClearRelation()" LINK "DBF_ClearRelation"}) or one
                 of the two servers is closed (and the relation is cleared
                 implicit).
        expr - a pointer to a key-expression that describes the relation between
                 the two DataServers. By using this expression with the data of
                 the current record of the superior DataTable the key for the
                 order, used by the related DataServer, is generated. This key
                 has to be unique for every record of the DataServer.
                 This string is not copied, so it has to stay valid until the
                 relation is cleared again (using @{"DBF_ClearRelation()" LINK "DBF_ClearRelation"}) or one
                 of the two servers is closed (and the relation is cleared
                 implicit).@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned; the client-server is now
        inserted in the list of related DataServers and will react on changes
        to the current record of the superior DataServer.
        If the function fails, FALSE is returned. See 'LastError' of both
        DataServers for details.

@ENDNODE
@NODE "DBF_ShowDeleted" "database.library/DBF_ShowDeleted()"
@{b}

 NAME@{ub}
        DBF_ShowDeleted - enable/disable processing of deleted records@{b}

 SYNOPSIS@{ub}
        BOOL DBF_ShowDeleted (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, BOOL)
        showDeleted = DBF_ShowDeleted (server, deleted)
             D0                          A0       D0@{b}

 FUNCTION@{ub}
        Usually deleted records are never used as active records of a DataTable.
        By passing TRUE with the second argument to the DataTable, the according
        flag is set, so deleted records may be activated.

        Even if the flag is set, the deleted records could only be activated, if
        no index is activated! If the DataTable has a column of the type @{"DC_TEXT" LINK "include/DataServer.h/File" 149}
        (i.e. it owns a memo-file) the contents of that column may be disturbed,
        because that contents of the memo file is overwritten independent of the
        DataTables main file.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataTable
        deleted - a boolean value, TRUE indicates that deleted records should be
                 accessable.@{b}

 RESULT@{ub}
        The setting of the deletion-flag before this function was called is
        returned. By storing this value you are able to reset the DataTable
        to the previous state.@{b}

 NOTE@{ub}
        Per default deleted records are not displayed and you should not activate
        that option, except if you try to retrieve data that is stored in a
        deleted record. But you have only a small chance, because the last
        deleted record is the first one that is overwritten, if a new record is
        added to the DataTable (deleted records are referenced in a "lifo" for
        reuse).

@ENDNODE
@NODE "DBF_UnLockRecord" "database.library/DBF_UnLockRecord()"
@{b}

 NAME@{ub}
        DBF_UnLockRecord - unlock a  record of the DataTable@{b}

 SYNOPSIS@{ub}
        BOOL DBF_UnLockRecord (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, ULONG)
        success = DBF_UnLockRecord (server, recNo)
          D0                          A0      D0@{b}

 FUNCTION@{ub}
        This function has to be called for every @{"DBF_LockRecord()" LINK "DBF_LockRecord"} that is called.
        If frees the lock of the specified record in the DataTable, so it can be
        accessed by any other instance.

        It is safe to try to unlock a record that is not locked; this will result
        in the errorcode @{"DBF_ERR_REC_NOT_LOCKED" LINK "include/DataTable.h/File" 228} set to 'server->LastError'.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataTable
        recNo - the number of the record that should be unlocked. If zero is
                 passed to this argument, the header of the DataTable is unlocked@{b}

 RESULT@{ub}
        If the record could be unlocked, TRUE is returned.
        If the function fails to unlock the record, FALSE is returned. See
        'server->LastError' for an errorcode describing the cause of the failure.

@ENDNODE
@NODE "DBF_Update" "database.library/DBF_Update()"
@{b}

 NAME@{ub}
        DBF_Update - perform an operation on a DataTable@{b}

 SYNOPSIS@{ub}
        BOOL DBF_Update (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, ULONG, APTR)
        success = DBF_Update (server, operation, arg)
          D0                    A0       D0      A1@{b}

 FUNCTION@{ub}
        This function performs any operation on a DataTable.
        Any operation that is not performed by this function is passed to the
        @{"DS_Update()" LINK "DS_Update"} function of the underlying DataServer.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataTable to be
                 accessed.
        operation - the operation that should be performed, the DataTable
                 supports the following operations, all other values would
                 lead this function to call the @{"DS_Update()" LINK "DS_Update"} function of the
                 underlying DataServer.

              These operations are direct supported by the DataTable:

              @{"DS_UPDATE" LINK "include/DataServer.h/File" 209} - synchronize the changes made to the DataTables current
                       record and the DataTable-file. If the record has been
                       added or removed, the according record is added (removed)
                       to (from) the datatable and all indexes attached to the
                       the DataTable. If changes have been made to the record,
                       these changes are written to the datatable and all indexes
                       are updated to match these changes.
                       This operation should be performed before any further
                       access to the DataServer is performed, i.e. before the
                       current record is changed or all changes will be lost.
                       If a new record is added to the DataTable or a record is
                       changed, but it fails the validation (i.e. any of the
                       user-supplied validate functions fail or a column is
                       empty that must not be empty) the field 'LastError' is set
                       to @{"DBF_ERR_REC_NOT_VALID" LINK "include/DataTable.h/File" 229}. The operation @{"DS_CURRENTCOLUMN" LINK "include/DataServer.h/File" 186}
                       would return a pointer to the column that falls through
                       the validation in that case.
                       If the current record is removed, the following record
                       will be activated as current record, but you should take
                       care that the records are ordered ascend, or the current
                       record will be the logically previous one.
                       If this operation succeeds, the currently active column is
                       undefined, i.e. the result of a following @{"DS_CURRENTCOLUMN" LINK "include/DataServer.h/File" 186}
                       operation is undefined and may return a pointer to any
                       column, or may also fail. You have to send @{"DS_GOTOCOLUMN" LINK "include/DataServer.h/File" 163}
                       or @{"DS_FINDCOLUMN" LINK "include/DataServer.h/File" 166} first.

              @{"DS_ADDCOLUMN" LINK "include/DataServer.h/File" 159} - append a new column to the end of the DataServers
                       list of DataColumns; the argument 'arg' has to point to a
                       full initialized DataColumn structure. If this DataColumn
                       belongs to another DataServer (i.e. the field 'Server' of
                       this structure points to a different server), this
                       structure and the referenced strings will be copied and
                       added to the end of the list of already present columns.
                       If the DataColumn references this DataTable, this
                       operation will fail.

              @{"DS_REMOVECOLUMN" LINK "include/DataServer.h/File" 160} - remove a column from the DataTable, the argument
                       'arg' has to specify the number of the DataColumn to be
                       removed. IT is only allowed to remove columns that belongs
                       to another DataServer (i.e. the field 'Server' of
                       this structure points to a different server).
                       If the operation succeeds, and the removed column is the
                       current column of the DataServer, the next column will
                       went to be the current column. If no next column is
                       existent, the previous column wents to be the current
                       DataColumn.

              @{"DS_MOVECOLUMN" LINK "include/DataServer.h/File" 161} - this operation is not allowed for DataTables, so
                       this operation will always fail and set an errorcode of
                       @{"DS_ERR_OP_NOT_KNOWN" LINK "include/DataServer.h/File" 220} to 'LastError'.

              @{"DS_FINDCOLUMN" LINK "include/DataServer.h/File" 166} - select a column specified by its 'Name'. The
                       argument 'arg' has to be a pointer to a NUL-terminated
                       string with the 'Name' of the searched column.
                       If there are one or more client-servers related to this
                       DataTable, there might be several columns with the same
                       name in the DataTables list of columns. This operation
                       will always find the first column with the name (the
                       first columns are always the DataColumns owned by the
                       DataTable). If you want to find an equal named column of
                       a related server, the columns name has to be preceded
                       by the name of the server followed by an colon; e.g.
                       "Foobar:Foo" addresses the DataColumn named "Foo" of the
                       DataServer "Foobar".

              @{"DS_INSERTROW" LINK "include/DataServer.h/File" 180} - a new record should be inserted into the DataTables
                       datatable, the columns of the record are initialized to
                       defaults.
                       After this operation has succeeded, the operation
                       @{"DS_SETRAWDATA" LINK "include/DataServer.h/File" 171} or @{"DS_SETCOLUMNDATA" LINK "include/DataServer.h/File" 169} has to be called for the
                       columns that should be set-up with values, followed by the
                       operation @{"DS_UPDATE" LINK "include/DataServer.h/File" 209} to write the changes into the
                       datatable and the attached indexes.

              @{"DS_REMOVEROW" LINK "include/DataServer.h/File" 181} - the current record is marked to be deleted. The
                       operation @{"DS_UPDATE" LINK "include/DataServer.h/File" 209} has to be performed to remove the
                       record from the DataTables datatable.

              @{"DS_GOTOROW" LINK "include/DataServer.h/File" 173} - go to any record by its number; the argument 'arg',
                       interpreted as ULONG, specifies the number of the record
                       that should be selected as current record starting with 1.
                       If zero or a value greater than the number of available
                       records is specified, this function fails, the current
                       record is set to zero (EOF).
                       This operation can be used to access deleted records. In
                       this case the operation may return FALSE and set the
                       DataTables errorcode to '@{"IDX_ERR_NO_KEY" LINK "include/Index.h/File" 204}' if any indexes
                       are attached to the DataTable. Nevertheless the columns
                       of the selected record are available.

              @{"DS_NEXTROW" LINK "include/DataServer.h/File" 174} - go to next record, the one behind the current one in
                       the currently active order. If there are no more records
                       available, this function will fail, the current record is
                       undefined.

              @{"DS_PREVROW" LINK "include/DataServer.h/File" 175} - go to previous record, the one before the current one
                       in the currently active order. If there are is no record
                       before the current one, this function will fail, the
                       current record is undefined.

              @{"DS_FIRSTROW" LINK "include/DataServer.h/File" 176} - go to first record, the first available record in the
                       currently active order. If there are no records available
                       at all, this function will fail.

              @{"DS_LASTROW" LINK "include/DataServer.h/File" 177} - go to last record, the last available record in the
                       currently active order. If there are no records available
                       at all, this function will fail.

              @{"DS_SKIPROWS" LINK "include/DataServer.h/File" 178} - skip any number of records, the argument 'arg' is
                       interpreted as long value, specifying the num. of records
                       that should be skipped. If the argument is less than zero,
                       the records are skipped to the top of the DataTable else
                       the records are skipped to the bottom of the DataTable.
                       If EOF or BOF are reached, this operation will fail, the
                       current record is undefined.

              @{"DS_NUM_OF_ROWS" LINK "include/DataServer.h/File" 183} - get number of accessable records, i.e. the number
                       of keys stored in the active order regarding the current
                       setting of the order-scope, or -- if no order is active --
                       the number of records stored in the datatable of the server
                       The result will be copied to the ULONG 'arg' points to.
                       The current record will be pointing to EOF after this
                       function has been called.

              @{"DS_GETRAWDATA" LINK "include/DataServer.h/File" 170} - get the data of the current column. If there is
                       a currently selected column and the current record is
                       valid, a pointer to the data of this column in the current
                       record is copied to the address, 'arg' points to. The type
                       of this pointer depends on the datatype of the column:
                 @{"DC_BYTE" LINK "include/DataServer.h/File" 134} - pointer to a single byte
                 @{"DC_LOGIC" LINK "include/DataServer.h/File" 146} - pointer to a single byte, 0 => FALSE, ~0 => TRUE
                 @{"DC_WORD" LINK "include/DataServer.h/File" 135} - pointer to a word (2 byte) at an even address
                 @{"DC_LONG" LINK "include/DataServer.h/File" 136} - pointer to a longword (4 byte) at a longword address
                          (divideable by 4)
                 @{"DC_DOUBLELONG" LINK "include/DataServer.h/File" 137} - ptr to a DOUBLELONG (8 byte) at a longword
                          address (divideable by 4)
                 @{"DC_FLOAT" LINK "include/DataServer.h/File" 138} - pointer to a float (4 byte) at a longword address
                          (divideable by 4)
                 @{"DC_DOUBLE" LINK "include/DataServer.h/File" 139}  - pointer to a double (8 byte) at a longword address
                          (divideable by 4)
                 @{"DC_NUMERIC" LINK "include/DataServer.h/File" 140} - pointer to a buffer of 'DataColumn.Length' bytes
                 @{"DC_DATE" LINK "include/DataServer.h/File" 142} - pointer to a buffer of 8 bytes in length
                 @{"DC_TIME" LINK "include/DataServer.h/File" 144} - pointer to a longword (4 byte) at a longword address
                          (divideable by 4)
                 @{"DC_CHAR" LINK "include/DataServer.h/File" 148} - pointer to a buffer of 'DataColumn.Length' bytes
                 @{"DC_TEXT" LINK "include/DataServer.h/File" 149} - pointer to the address where the location of the
                          according string in the memo-file attached to this
                          DataTable is stored. This address is splitted into
                          two parts, the first ULONG contains the number of the
                          page in the memo-file, where the string is stored, the
                          second ULONG value is the offset into this page.
                          The size of the pages depends on the memo-file used,
                          usually a page is 1024 bytes large.
                 @{"DC_VARCHAR" LINK "include/DataServer.h/File" 152} - pointer to a STRPTR, where the address of the
                          string is copied to, take care that the string is
                          constant and has not to be modified, copy it to a
                          local storage, before modifying it.

              @{"DS_GETCOLUMNDATA" LINK "include/DataServer.h/File" 168} - get the data of the current column in human-
                       readable form, i.e. the contents is converted into a
                       NUL-terminated C-string. A pointer to that read-only
                       string is copied into the address 'arg' points to.
                       If no function-pointer is placed in the 'Convert' member
                       of the DataColumn structure of the current column,
                       standard convertion is done.

              @{"DS_SETRAWDATA" LINK "include/DataServer.h/File" 171} - change the data of the current column. If there
                       is a currently selected column and the current record is
                       valid, the data is changed according to the new data,
                       pointed to by 'arg'. The type of data 'arg' has to point
                       to depends on the type of the current column.
                       The state of the DataServer flag @{"DSF_READONLY" LINK "include/DataServer.h/File" 238} respectively
                       the flag @{"DCF_READONLY" LINK "include/DataServer.h/File" 247} of the current DataColumn is
                       respected by this operation.

              @{"DS_SETCOLUMNDATA" LINK "include/DataServer.h/File" 169} - change the data of the current column as by the
                       operation @{"DS_GETCOLUMNDATA" LINK "include/DataServer.h/File" 168}, except that 'arg' has to point
                       to a NUL-terminated C-string with the new data, formated
                       like the string returned by DC_GETCOLUMNDATA.

              @{"DS_SETORDER" LINK "include/DataServer.h/File" 188} - change the order of the rows; 'arg' points to the new
                       order that should be used. This has to be a pointer to a
                       NUL-terminated C-string  with the 'Name' of the order.
                       This order has to be added already to the DataTables list
                       of orders using @{"DBF_AddOrder()" LINK "DBF_AddOrder"}.
                       The 'Name' of an order is case-sensitive !
                       The current record should be still the same after this
                       operation has been performed, but if the new order doesn't
                       contains an entry for this record, the position is set to
                       EOF.
                       Any unstored changes done to the current record are lost.

              @{"DS_GETORDER" LINK "include/DataServer.h/File" 189} - get the order of the records; a pointer to the
                       current order is stored in the address 'arg' points to,
                       this will be a pointer to a NUL-terminated C-string with
                       the 'Name' of the active order or NULL, if no order is
                       active.
                       By passing this name to the function @{"DBF_GetOrder()" LINK "DBF_GetOrder"} you
                       could gain access to the IDXHeader structure of the active
                       order (index).

              @{"DS_AVAILABLEORDER" LINK "include/DataServer.h/File" 191} - get a pointer to a list with the available
                       orders of the DataServer; a pointer to a list of orders
                       available for this DataServer is copied to the address
                       'arg' points to.
                       The type of this list is a NULL-terminated array of
                       string-pointers. This array and the referenced strings
                       are owned by the DataTable and might be invalidated at the
                       next access to the DataTable, so you should copy the whole
                       list with all strings, if you have to do any further
                       processing using this list.

              @{"DS_ORDERASCEND" LINK "include/DataServer.h/File" 190} - changing the sorting-order of the records. If the
                       argument 'arg' is not NULL, the records are ordered ascend
                       else the records are ordered descend. This sorting-order
                       is used for every index. If currently no index is active,
                       the sorting order is not (visibly) changed.
                       The current record is not affected by this function.

              @{"DS_KEYEXPRESSION" LINK "include/DataServer.h/File" 192} - get a pointer to the expression used to generate
                       the keys for the records in the currently active order.
                       A pointer to the NUL-terminated string with the expression
                       is copied to the address 'arg' points to.

              @{"DS_KEYLENGTH" LINK "include/DataServer.h/File" 193} - get the length of a keyvalue of the currently active
                       order. This size is required to allocate a buffer large
                       enough to store a keyvalue as required for @{"DS_CURRENTKEY" LINK "include/DataServer.h/File" 194}.
                       The length is copied to the ULONG value 'arg' points to.

              @{"DS_CURRENTKEY" LINK "include/DataServer.h/File" 194} - get the keyvalue of the current record in the
                       currently active order . This keyvalue is copied to the
                       buffer 'arg' points to. Take care that the buffer is large
                       enough to store a keyvalue (see @{"DS_KEYLENGTH" LINK "include/DataServer.h/File" 193}). This value
                       might be passed to the operation @{"DS_SEEK" LINK "include/DataServer.h/File" 197} to find this
                       record again.

              @{"DS_SEEK" LINK "include/DataServer.h/File" 197} - seek to an value of the order from top to bottom; the
                       argument 'arg' points to the keyvalue to be searched. If
                       soft-seek is enabled, the search starts at the current
                       record and stops if a record is found with a keyvalue,
                       whichs is equal or greater than the specified value, else
                       the search starts at the first record and stops on the
                       first record with an exact matching keyvalue.
                       If no order is active, this operation fails with an error-
                       code of @{"DS_ERR_OP_NOT_KNOWN" LINK "include/DataServer.h/File" 220}.

              @{"DS_SEEKNEXT" LINK "include/DataServer.h/File" 198} - equivalent to @{"DS_SEEK" LINK "include/DataServer.h/File" 197}, except that the search starts
                       at the next record behind the current record.

              @{"DS_ORDERASCEND" LINK "include/DataServer.h/File" 190} - order the records ascend or descend; the argument
                       'arg' is interpreted as boolean, if 'arg' is not NULL,
                       the rows are ordered in ascend order, otherwise they are
                       ordered descend. After this operation has succeeded, the
                       operation @{"DS_UPDATE" LINK "include/DataServer.h/File" 209} should be performed to match the
                       new order.

              @{"DS_SELECTROW" LINK "include/DataServer.h/File" 201} - this operation can be used to select or unselect
                       the current record. The argument 'arg' is interpreted as
                       boolean, if it is TRUE, the current record is selected,
                       else the selection of the current row is cleared.
                       The operation returns TRUE, if it could be successfully
                       performed, it returns FALSE, if an unexpected error
                       occurs, 'LastError' is set accordingly.

              @{"DS_FIRSTSELECTED" LINK "include/DataServer.h/File" 202} - this operation performs a skip to the first
                       selected record, if there is one selected at all. If
                       no record is selected, 'LastError' is set to
                       "@{"DS_ERR_NO_MORE_DATA" LINK "include/DataServer.h/File" 218}". If 'arg' is not NULL, it has to
                       point to an ULONG, where the number of the first selected
                       record is stored. If no record is selected, the value --
                       'arg' points to -- is not changed.
                       The selected records are ordered in the order they are
                       selected, not ordered by the currently active index of the
                       DataTable !

              @{"DS_NEXTSELECTED" LINK "include/DataServer.h/File" 203} - if more than one record is selected, this
                       operation performs a skip to the next selected record.
                       If there are no more records selected, 'LastError' is set
                       to "@{"DS_ERR_NO_MORE_DATA" LINK "include/DataServer.h/File" 218}". If 'arg' is not NULL, it has to
                       point to an ULONG, where the number of the first selected
                       record is stored. If no record is selected, the value --
                       'arg' points to -- is not changed.
                       The selected records are ordered in the order they are
                       selected, not ordered by the currently active index of the
                       DataTable !

              @{"DS_CLEARSELECTION" LINK "include/DataServer.h/File" 204} - this operation clears all selections made.
                       The argument 'arg' is not used.

              @{"DS_ISSELECTED" LINK "include/DataServer.h/File" 205} - this operation evaluates if the current record is
                       selected.
                       If the current record is not selected, FALSE is returned;
                       if the current record is selected, TRUE is returned.
                       'DataServer.LastError' is set to 0.
                       The argument 'arg' is not used.

              @{"DS_ALLOWSELECTION" LINK "include/DataServer.h/File" 206} - the DataTable supports selection of single or
                       multiple records, so this operation will always set
                       'DataServer.LastError' to zero and return TRUE.

              @{"DS_DISPOSE" LINK "include/DataServer.h/File" 211} - the DataTable is disposed, all resources used by the
                       DataTable and the attached Indexes are freed.
                       The argument 'arg' is not used.@{b}

 RESULT@{ub}
        If the operation succeeds, TRUE is returned. Depending on the type of
        operation performed, the address 'arg' points to may have changed.
        If the function fails, FALSE is returned, check 'DataServer.LastError'
        for the cause of the failure.

        If the current row is changed as the result of the operation (e.g.
        @{"DS_GOTOROW" LINK "include/DataServer.h/File" 173}, DS_SKIPNEXT, @{"DS_SEEK" LINK "include/DataServer.h/File" 197}, etc.) the currently active column is
        undefined, i.e. the result of a following @{"DS_CURRENTCOLUMN" LINK "include/DataServer.h/File" 186} operation is
        undefined and may return a pointer to any column, or may also fail. You
        have to send @{"DS_GOTOCOLUMN" LINK "include/DataServer.h/File" 163} or @{"DS_FINDCOLUMN" LINK "include/DataServer.h/File" 166} before accessing any column
        (i.e. before you read or write any data to the DataTable).

@ENDNODE
@NODE "DBF_WriteMemo" "database.library/DBF_WriteMemo()"
@{b}

 NAME@{ub}
        DBF_WriteMemo - write a memotext into the buffer of a DataColumn@{b}

 SYNOPSIS@{ub}
        BOOL DBF_WriteMemo (@{"struct DataColumn" LINK "include/DataServer.h/File" 74} *, STRPTR, APTR)
        success = DBF_WriteMemo (column, memoText, raw)
          D0                       A0       A1     A2@{b}

 FUNCTION@{ub}
        This function converts a NUL-terminated string containing the text of a
        memotext into the raw format, so it can be stored in the memo-file of the
        DataTable.@{b}

 INPUTS@{ub}
        column - a pointer to the DataColumn of the memotext
        memoText - a pointer to the NUL-terminated memotext
        raw - a pointer to the destination buffer, this argument is ignored by
              this function, it always uses the default buffer of the DataColumn.@{b}

 RESULT@{ub}
        If the memotext could be successfully stored in the buffer of the
        DataColumn, TRUE is returned, else FALSE is returned (usually not enough
        free memory available).@{b}

 NOTE@{ub}
        This function is used as callback-function from the DataTable, whenever
        a memo is written, you should NOT call this function from user-
        applications code.

@ENDNODE
@NODE "DBM_ClearMemo" "database.library/DBM_ClearMemo()"
@{b}

 NAME@{ub}
        DBM_ClearMemo - clear a memo stored in the memo-file@{b}

 SYNOPSIS@{ub}
        BOOL DBM_ClearMemo (@{"struct MemoFile" LINK "include/Memo.h/File" 42} *, DOUBLELONG *)
        success = DBM_ClearMemo (mf, addr)
          D0                     A0   A1@{b}

 FUNCTION@{ub}
        This function disposes a memo stored in the memo-file and frees the
        storage used by it, i.e. the storage of that memo is added to the list
        of unused blocks.

        This function has to be enclosed by the function pair @{"DBM_LockMemo()" LINK "DBM_LockMemo"}/
        @{"DBM_UnLockMemo()" LINK "DBM_UnLockMemo"}, if the accoding DataTable is not opened exclusive.@{b}

 INPUTS@{ub}
        mf - a pointer to the MemoFile structure of the memo-file
        addr - a pointer to a DOUBLELONG conatining the address of the memo. The
              high-longword contains the 'page' the memo starts, the low-longword
              contains the offset into that 'page'. If this is a valid address,
              the memo found there is disposed by this function and the used
              storage is freed.@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned, else FALSE is returned.

@ENDNODE
@NODE "DBM_CloseMemo" "database.library/DBM_CloseMemo()"
@{b}

 NAME@{ub}
        DBM_CloseMemo - terminate the access to a memofile@{b}

 SYNOPSIS@{ub}
        void DBM_CloseMemo (@{"struct MemoFile" LINK "include/Memo.h/File" 42} *)
        DBM_CloseMemo (mf)
                       A0@{b}

 FUNCTION@{ub}
        This function terminates the access to a memofile. All resources used
        for accessing the memofile are freed.@{b}

 INPUT@{ub}
        memo - a pointer to the MemoFile structure of the memo-file

@ENDNODE
@NODE "DBM_LockMemo" "database.library/DBM_LockMemo()"
@{b}

 NAME@{ub}
        DBM_LockMemo - lock the memo-file for save write-access@{b}

 SYNOPSIS@{ub}
        BOOL DBM_LockMemo (@{"struct MemoFile" LINK "include/Memo.h/File" 42} *mf)
        success = DBM_LockMemo (mf)
          D0                    A0@{b}

 FUNCTION@{ub}
        This function locks the memo-file, so any further accesses to the file
        are refused.
        The memo-file has to be locked before any write-access is performed.
        Read-accesses to the memo-file are locked by the record-locks of the
        DataTable the memo-file is attached to.@{b}

 INPUT@{ub}
        mf - a pointer to the MemoFile structure of the memo-file@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned, else FALSE is returned.

@ENDNODE
@NODE "DBM_OpenMemo" "database.library/DBM_OpenMemo()"
@{b}

 NAME@{ub}
        DBM_OpenMemo - open/create the memofile@{b}

 SYNOPSIS@{ub}
        BPTR DBM_OpenMemo (STRPTR)
        memoFh = DBM_OpenMemo (fileName)
          D0                      A0@{b}

 FUNCTION@{ub}
        This function opens the memo-file for shared access.
        If the file is currently not existing, it is created by this function.

        The file has to contain the multi-byte character 'DBM ' in the first
        four bytes followed by the long value with the version of the file,
        which has to be one or this function will fail, setting an IoErr() of
        ERROR_OBJECT_WRONG_TYPE.
        So the first 8 bytes of the file have to be:

           0x44 0x42 0x4D 0x20 0x00 0x00 0x00 0x01@{b}

 INPUT@{ub}
        fileName - a pointer to the NUL-terminated C-string containing the
                 filename and (optional) the path of the file to be opened.@{b}

 RESULT@{ub}
        If the function succeeds, a BPTR of the FileHandle of the memo-file
        is returned, else zero is returned.

@ENDNODE
@NODE "DBM_ReadMemo" "database.library/DBM_ReadMemo()"
@{b}

 NAME@{ub}
        DBM_ReadMemo - load a memo into memory@{b}

 SYNOPSIS@{ub}
        APTR DBM_ReadMemo (@{"struct MemoFile" LINK "include/Memo.h/File" 42} *, DOUBLELONG *)
        memo = DBM_ReadMemo (mf, addr)
         D0                  A0   A1@{b}

 FUNCTION@{ub}
        This function copies the memo of the current record into the a new
        allocated buffer.@{b}

 INPUTS@{ub}
        mf - a pointer to the MemoFile structure of the memo-file
        addr - a pointer to a DOUBLELONG containing the address of the memo. The
              high-longword contains the 'page' the memo starts, the low-longword
              contains the offset into that 'page'.@{b}

 RESULT@{ub}
        If the memo could be successfully copied into memory, a pointer to this
        memoryblock is returned. You have to free this block using FreeVector().
        If the function fails or the specified address of the memo is zero, NULL
        is returned. In the case of a failure, IoErr() will return a non-zero
        errorcode.

@ENDNODE
@NODE "DBM_UnLockMemo" "database.library/DBM_UnLockMemo()"
@{b}

 NAME@{ub}
        DBM_UnLockMemo - release the lock of the memo-file@{b}

 SYNOPSIS@{ub}
        BOOL DBM_UnLockMemo (@{"struct MemoFile" LINK "include/Memo.h/File" 42} *)
        success = DBM_UnLockMemo (mf)
          D0                      A0@{b}

 FUNCTION@{ub}
        This function frees the lock of the memo-file, previously set by
        @{"DBM_LockMemo()" LINK "DBM_LockMemo"}.@{b}

 INPUT@{ub}
        mf - a pointer to the MemoFile structure of the memo-file@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned, else FALSE is returned.

@ENDNODE
@NODE "DBM_WriteMemo" "database.library/DBM_WriteMemo()"
@{b}

 NAME@{ub}
        DBM_WriteMemo - write a memo into the memo-file@{b}

 SYNOPSIS@{ub}
        BOOL DBM_WriteMemo (@{"struct MemoFile" LINK "include/Memo.h/File" 42} *, DOUBLELONG *, APTR, ULONG)
        success = DBM_WriteMemo (mf, addr, memo, size)
          D0                     A0   A1    A2    D0@{b}

 FUNCTION@{ub}
        This function writes a memo to the memo-file. An empty block in the
        memo-file is used for this purpose or -- if no large enough empty block
        is found -- the memo is appended to the end of the memo-file.

        This function has to be enclosed by the function pair @{"DBM_LockMemo()" LINK "DBM_LockMemo"}/
        @{"DBM_UnLockMemo()" LINK "DBM_UnLockMemo"}, if the accoding DataTable is not opened exclusive.@{b}

 INPUTS@{ub}
        mf - a pointer to the MemoFile structure of the memo-file
        addr - a pointer to a DOUBLELONG conatining the address of the memo. The
              high-longword contains the 'page' the memo starts, the low-longword
              contains the offset into that 'page'. If this is a valid address,
              the memo found there is disposed by this function and the used
              storage is freed.
              The address where the memo is stored is passed to the DOUBLELONG
              this pointer points to.
        memo - a pointer to the memo to be written
        size - the number of bytes that should be written@{b}

 RESULT@{ub}
        If the memotext could be successfully stored in the buffer of the
        DataColumn, TRUE is returned.

@ENDNODE
@NODE "DC_DefaultConvert" "database.library/DC_DefaultConvert()"
@{b}

 NAME@{ub}
        DC_DefaultConvert - convert a value into human-readable format@{b}

 SYNOPSIS@{ub}
        BOOL DC_DefaultConvert (@{"struct DataColumn" LINK "include/DataServer.h/File" 74} *, APTR)
        success = DC_DefaultConvert (column, value)
           D0                          A0      A1@{b}

 FUNCTION@{ub}
        If the value of a DataColumn has to be displayed or printed in a human-
        readable form (as string) this function performs the convertion into the
        string. This string is stored in the 'Buffer' of the DataColumn.

        The default forms of the different types of values are:

           @{"DC_LOGIC" LINK "include/DataServer.h/File" 146} - "true" or "false"
           @{"DC_BYTE" LINK "include/DataServer.h/File" 134} - a decimal string
           @{"DC_WORD" LINK "include/DataServer.h/File" 135} - a decimal string
           @{"DC_LONG" LINK "include/DataServer.h/File" 136} - a decimal string
           @{"DC_DOUBLELONG" LINK "include/DataServer.h/File" 137} - a decimal string
           @{"DC_FLOAT" LINK "include/DataServer.h/File" 138} - a number in scientific format "-d.dddddde-dd"
           @{"DC_DOUBLE" LINK "include/DataServer.h/File" 139} - a number in scientific format "-d.ddddddddde-dd"
           @{"DC_NUMERIC" LINK "include/DataServer.h/File" 140} - a decimal string as stored
           @{"DC_CHAR" LINK "include/DataServer.h/File" 148} - a string, truncated after the last non-whitespace
           @{"DC_TIME" LINK "include/DataServer.h/File" 144} - a string in the format "00:00:00"
           @{"DC_DATE" LINK "include/DataServer.h/File" 142} - a string in a format related to FORMAT_DOS: "dd-mmm-yyyy"
           @{"DC_TEXT" LINK "include/DataServer.h/File" 149}, @{"DC_VARCHAR" LINK "include/DataServer.h/File" 152} - no convertion performed@{b}

 INPUTS@{ub}
        column - a pointer to the DataColumn, whichs value should be converted
        value - a pointer to the value to be converted, this has to be a pointer
                 to an even address.@{b}

 RESULT@{ub}
        If the value could be successfully converted, TRUE is returned,
        else false is returned.

@ENDNODE
@NODE "DC_DefaultRevert" "database.library/DC_DefaultRevert()"
@{b}

 NAME@{ub}
        DC_DefaultRevert - Revert a value from human-readable into raw format@{b}

 SYNOPSIS@{ub}
        BOOL DC_DefaultRevert (@{"struct DataColumn" LINK "include/DataServer.h/File" 74} *, STRPTR, APTR)
        success = DC_DefaultRevert (column, value, raw)
          D0                          A0     A1     A2@{b}

 FUNCTION@{ub}
        If a value of a DataColumn needs to be reverted from a human-readable
        string (e.g. as displayed in a SingleLineEdit) into the raw format, it
        is stored in the DataColumn, this function might be called to perform
        the convertion.

        The default form of the different types of values is:

           @{"DC_LOGIC" LINK "include/DataServer.h/File" 146} - "TRUE", "T", "J", "Y", "Yes", "On" for TRUE ('T')
                       every other string results in FALSE ('F')
                       The comparison is done case-insensitive.
           @{"DC_BYTE" LINK "include/DataServer.h/File" 134} - a decimal string, the fractional part is ignored
           @{"DC_WORD" LINK "include/DataServer.h/File" 135} - a decimal string, the fractional part is ignored
           @{"DC_LONG" LINK "include/DataServer.h/File" 136} - a decimal string, the fractional part is ignored
           @{"DC_DOUBLELONG" LINK "include/DataServer.h/File" 137} - a decimal string
           @{"DC_FLOAT" LINK "include/DataServer.h/File" 138} - any string representing a number, either as decimal string
                       or in scientific format
           @{"DC_DOUBLE" LINK "include/DataServer.h/File" 139} - any string representing a number, either as decimal string
                       or in scientific format
           @{"DC_NUMERIC" LINK "include/DataServer.h/File" 140} - a decimal string
           @{"DC_CHAR" LINK "include/DataServer.h/File" 148} - a string, truncated after the last non-whitespace
           @{"DC_TIME" LINK "include/DataServer.h/File" 144} - a string in the format "00:00:00.000"
           @{"DC_DATE" LINK "include/DataServer.h/File" 142} - a date-string in FORMAT_DOS: "dd-mmm-yy", "dd-mmm-yyyy",
                    "dd-mm-yy", or "dd-mm-yyyy"
           @{"DC_VARCHAR" LINK "include/DataServer.h/File" 152} - just copied
           @{"DC_TEXT" LINK "include/DataServer.h/File" 149} - not supported

        If a numeric value overflows, the result is undefined.@{b}

 INPUTS@{ub}
        column - a pointer to the DataColumn, whichs value should be converted
        value - a pointer to the value, a human-readable NUL-terminated string
                 that should be reverted. NULL is handled like an empty string.
                 If a numeric string exceeds the valid range of the column, the
                 result is undefined.
        raw -  a pointer to the destination address, where the raw value should
                 be stored, take care that there is enough space for the value
                 in raw format. And that it is correct aligned.@{b}

 RESULT@{ub}
        If the value could be successfully converted, TRUE is returned, the
        value is written into the specified destination memory region; else
        false is returned, nothing is changed.@{b}

 NOTE@{ub}
        This function can be replaced for every single column by a custom
        function if a special convertion is required.

@ENDNODE
@NODE "DC_SetCaption" "database.library/DC_SetCaption()"
@{b}

 NAME@{ub}
        DC_SetCaption - change he caption of a DataColumn@{b}

 SYNOPSIS@{ub}
        BOOL DC_SetCaption (@{"struct DataColumn" LINK "include/DataServer.h/File" 74} *, STRPTR)
        success = DC_SetCaption (column, caption)
           D0                     A0       A1@{b}

 FUNCTION@{ub}
        This function should be used to change the caption of a column.@{b}

 INPUTS@{ub}
        column - a pointer to the DataColumn structure of the column to be
                 changed
        caption - a pointer to a NUL-terminated C-string with the new caption
                 of the column. If NULL is passed the columns 'Name' is used
                 as caption of the column.
                 This text is copied and needs not to remain valid.@{b}

 RESULT@{ub}
        If the caption could be successfully changed, TRUE is returned, else
         FALSE is returned (if the arguments are correct, this indicates that
        not enough free memory is available).

@ENDNODE
@NODE "DC_SetHelpText" "database.library/DC_SetHelpText()"
@{b}

 NAME@{ub}
        DC_SetHelpText - change the short descriptive text of a DataColumn@{b}

 SYNOPSIS@{ub}
        BOOL DC_SetHelpText (@{"struct DataColumn" LINK "include/DataServer.h/File" 74} *, STRPTR)
        success = DC_SetHelpText (column, helpText)
          D0                        A0       A1@{b}

 FUNCTION@{ub}
        This function should be used to change the short descriptive text (the
        'HelpText') of a DataColumn.@{b}

 INPUTS@{ub}
        column - a pointer to the DataColumn structure of the column to be
                 changed
        helpText - a pointer to a NUL-terminated C-string with the new short
                 descriptive text of the column.  If NULL is passed the columns
                 'HelpText' is deleted.
                 This text is copied and needs not to remain valid.@{b}

 RESULT@{ub}
        If the text could be successfully changed, TRUE is returned, else
         FALSE is returned (if the arguments are correct, this indicates that
        not enough free memory is available).

@ENDNODE
@NODE "DOUBLELONG2Numeric" "database.library/DOUBLELONG2Numeric()"
@{b}

 NAME@{ub}
        DOUBLELONG2Numeric - convert a DOUBLELONG into a @{"NUMERIC" LINK q"include/Numeric.h/File" 43}@{b}

 SYNOPSIS@{ub}
        BOOL DOUBLELONG2Numeric (DOUBLELONG *, UBYTE *, UWORD, UWORD, UWORD)
        success = DOUBLELONG2Numeric (val, num, length, decimals, exponent)
          D0                          A0   A1    D0:16    D1:16    D2:16@{b}

 FUNCTION@{ub}
        This function converts a DOUBLELONG value into a @{"NUMERIC" LINK "include/Numeric.h/File" 43} value (a fixed
        point decimal value).
        Convertions between @{"NUMERIC" LINK "include/Numeric.h/File" 43} and DOUBLELONG are required for doing any
        arithmetic operations with @{"NUMERIC" LINK "include/Numeric.h/File" 43} values.@{b}

 INPUTS@{ub}
        val - a pointer to the DOUBLELONG, that should be converted.
        num - a pointer to the address, where the @{"NUMERIC" LINK "include/Numeric.h/File" 43} value should be stored.
              This buffer has to be 'length' bytes long and will have the
              following format:
              the first byte is the sign: either '+' or '-', optional followed
              by zeros '\\0' and than followed by the digits of the @{"NUMERIC" LINK "include/Numeric.h/File" 43} value
              without a comma. This value is not a NUL-terminated string.
        length - the length of the whole @{"NUMERIC" LINK "include/Numeric.h/File" 43} value inclusive its sign (<= 18)
              beware of overflows.
        decimals - the number of digits at the end of the value, that are
              representing the part behind the comma. There have to be at least
              'decimals' + 1 digits in the passed @{"NUMERIC" LINK "include/Numeric.h/File" 43} value; 'decimals' MUST
              be at least two lower than 'length'.
        exponent - this value represents the exponent to the base 10; The
              DOUBLELONG value is divided by this value to calculate the
              resulting @{"NUMERIC" LINK "include/Numeric.h/File" 43}.
              If any digits are truncated behind the last significant digit,
              the @{"NUMERIC" LINK "include/Numeric.h/File" 43} is rounded up.@{b}

 RESULT@{ub}
        If the DOUBLELONG value could be successfully converted to a @{"NUMERIC" LINK "include/Numeric.h/File" 43}
        value TRUE is returned, else (overflow) FALSE is returned.

@ENDNODE
@NODE "DS_AddColumns" "database.library/DS_AddColumns()"
@{b}

 NAME@{ub}
        DS_AddColumns - append new DataColumns to the servers list of DataColumns@{b}

 SYNOPSIS@{ub}
        BOOL DS_AddColumns (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, @{"struct DataColumn" LINK "include/DataServer.h/File" 74} *, ULONG)
        success = DS_AddColumns (server, template, numCols)
          D0                       A0       A1       D0@{b}

 FUNCTION@{ub}
        This function creates new DataColumns and appends them to the end of the
        DataServers list of DataColumns. The DataColumns are created according
        the 'template' DataColumns, that are copied except of the 'Buffer' member
        of the structures, this field is always set to default.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure
        template - a pointer to an array of DataColumn structures used as
                    template for the new columns.
                 Every entry must at least contain:
                    - a valid 'Name'
                    - a non-zero 'Type' field
                    - a non-zero  'Length'
                 If the entry references a 'Server', this one is copied into
                 the new DataColumn otherwise the new DataColumn will reference
                 the DataServer it is inserted into.
        numCols - the number of valid entries into the 'template' array@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned.
        IF the function fails, FALSE is returned.

@ENDNODE
@NODE "DS_DoUpdate" "database.library/DS_DoUpdate()"
@{b}

 NAME@{ub}
        DS_DoUpdate - perform an operation on a DataServer@{b}

 SYNOPSIS@{ub}
        BOOL DS_DoUpdate (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, ULONG, APTR)
        success = DS_DoUpdate (server, operation, arg)
          D0                     A0       D0      A1@{b}

 FUNCTION@{ub}
        This function is used to perform any operation on a DataServer. It
        calls the Update-function that is pointed to by the DataServers 'Update'
        function-pointer. If any subclass of the DataServer needs to do anything
        different than the default operation, it has to implement its own update
        function and store the pointer to that function in the 'Update' function-
        pointer of the DataServer structure. This function should call
        @{"DS_Update()" LINK "DS_Update"} for any operation it doesn't supports.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataServer to be
                 accessed.
        operation - the operation that should be performed, every DataServer and
                 subclass should support the following operations:

              @{"DS_UPDATE" LINK "include/DataServer.h/File" 209} - synchronize the contents of the DataServer and the
                       underlying "device". If any data of the current row has
                       been changed, this operation has to be performed to copy
                       the new data to the "device" to be stored.
                       If the DataServer has been newly created, the sorting
                       order of the rows, or the columns of the DataServer has
                       been changed, this operation has to be performed to read
                       all rows from the underlying "device" to match the new
                       requirements.
                       The subclasses of the DataServer should monitor the
                       underlying "device" and perform an update, everytime the
                       "device" signalizes that the data has been changed.

              @{"DS_ADDCOLUMN" LINK "include/DataServer.h/File" 159} - add a new column to the DataServer, the argument
                       'arg' has to point to a full initialized DataColumn
                       structure. This structure and the referenced strings will
                       be copied and added to the end of the list of already
                       present columns.
                       After this operation succeeds, you should perform an
                       @{"DS_UPDATE" LINK "include/DataServer.h/File" 209} to re-read the data from the "device" and this
                       new column contains valid data.

              @{"DS_REMOVECOLUMN" LINK "include/DataServer.h/File" 160} - remove a column from the DataServer, the argument
                       'arg' has to specify the position of the DataColumn to be
                       removed.

              @{"DS_MOVECOLUMN" LINK "include/DataServer.h/File" 161} - rearrange the order of the columns in the
                       DataServers array of DataColumns. The order in this array
                       will be the order the columns are selected using the
                       operations @{"DS_GOTOCOLUMN" LINK "include/DataServer.h/File" 163}, @{"DS_NEXTCOLUMN" LINK "include/DataServer.h/File" 164} and @{"DS_PREVCOLUMN" LINK "include/DataServer.h/File" 165}.
                       This operation will move the currently selected column to
                       the position the argument 'arg' - interpreted as ULONG -
                       specifies. 'arg' has to be between 1 and the number of
                       columns attached to the DataServer. If 'arg' is greater
                       than the number of columns, the current column is moved
                       to the last position, if 'arg' is equal 0, nothing is
                       changed, the function will fail.

              @{"DS_GOTOCOLUMN" LINK "include/DataServer.h/File" 163} - select the column with the number specified by
                       'arg' - interpreted as ULONG. The count of the columns
                       starts with 1. If 0 or any value larger than the number
                       of columns attached to the DataServer is specified, the
                       function will fail,the current column will not be changed.

              @{"DS_NEXTCOLUMN" LINK "include/DataServer.h/File" 164} - select the next column, the one behind the current
                       column, a pointer to the column will copied to the address
                       'arg' points to, if 'arg' is not equal NULL. If there are
                       no more columns, this operation will fail, the current
                       column will not be changed, the address 'arg' points to
                       will not be changed.

              @{"DS_PREVCOLUMN" LINK "include/DataServer.h/File" 165} - select the preceding column, the one before the
                       current column, a pointer to the column will copied to the
                       address 'arg' points to, if 'arg' is not equal NULL. If
                       there are no columns in front of the current column, this
                       operation will fail, the current column will not be
                       changed, the address 'arg' points to will not be changed.

              @{"DS_FINDCOLUMN" LINK "include/DataServer.h/File" 166} - select a column specified by its 'Name'. The
                       argument 'arg' has to be a pointer to a NUL-terminated
                       string with the 'Name' of the searched column, 'arg' is
                       not changed by this function.

              @{"DS_GETRAWDATA" LINK "include/DataServer.h/File" 170} - get the data of the current column. If there is
                       a currently selected column and the current row is valid,
                       a pointer to the data of this column in the current row is
                       copied to the address, 'arg' points to. The type of this
                       pointer depends on the datatype of the column:
                 @{"DC_BYTE" LINK "include/DataServer.h/File" 134} - pointer to a single byte
                 @{"DC_LOGIC" LINK "include/DataServer.h/File" 146} - pointer to a single byte, 'F' => FALSE, 'T' => TRUE
                 @{"DC_WORD" LINK "include/DataServer.h/File" 135} - pointer to a word (2 byte) at an even address
                 @{"DC_LONG" LINK "include/DataServer.h/File" 136} - pointer to a longword (4 byte) at a longword address
                          (divideable by 4)
                 @{"DC_DOUBLELONG" LINK "include/DataServer.h/File" 137} - pointer to a longlong (4 byte) at a longword
                          address (divideable by 4)
                 @{"DC_FLOAT" LINK "include/DataServer.h/File" 138} - pointer to a float (4 byte) at a longword address
                          (divideable by 4)
                 @{"DC_DOUBLE" LINK "include/DataServer.h/File" 139}  - pointer to a double (8 byte) at a longword address
                          (divideable by 4)
                 @{"DC_NUMERIC" LINK "include/DataServer.h/File" 140} - pointer to a buffer of 'DataColumn.Length' bytes
                 @{"DC_DATE" LINK "include/DataServer.h/File" 142} - pointer to a buffer 8 bytes in length
                 @{"DC_TIME" LINK "include/DataServer.h/File" 144} - pointer to a longword (4 byte) at a longword address
                          (divideable by 4)
                 @{"DC_CHAR" LINK "include/DataServer.h/File" 148} - pointer to a buffer of 'DataColumn.Length' bytes
                 @{"DC_TEXT" LINK "include/DataServer.h/File" 149} - pointer to a buffer where the information required
                          to locate the according string is stored. The format
                          of this address-information is implementation specific
                          so you should avoid reading this kind of columndata
                          in raw format.
                 @{"DC_VARCHAR" LINK "include/DataServer.h/File" 152} - pointer to a STRPTR, where the address of the
                          string is copied to, take care that the string is
                          constant and has not to be modified, copy it to a
                          local storage, before modifying it.

              @{"DS_GETCOLUMNDATA" LINK "include/DataServer.h/File" 168} - get the data of the current column in human-
                       readable form, i.e. the contents is converted into a
                       NUL-terminated C-string. A pointer to that read-only
                       string is copied into the address 'arg' points to.
                       If no function-pointer is placed in the 'Convert' member
                       of the DataColumn structure of the current column,
                       standard convertion is done.

              @{"DS_SETRAWDATA" LINK "include/DataServer.h/File" 171} - change the data of the current column. If there
                       is a currently selected column and the current row is
                       valid, the data is changed according to the new data,
                       pointed to by 'arg'. The type of data 'arg' points to
                       depends on the type of the current column (see
                       @{"DS_GETCOLUMNDATA" LINK "include/DataServer.h/File" 168}). The state of the DataServer flag
                       @{"DSF_READONLY" LINK "include/DataServer.h/File" 238} respectively the flag @{"DCF_READONLY" LINK "include/DataServer.h/File" 247} of the
                       current DataColumn has to be respected by this operation.

              @{"DS_SETCOLUMNDATA" LINK "include/DataServer.h/File" 169} - change the data of the current column. If
                       there is a currently selected column and the current row
                       is valid, the data is changed according to the new data,
                       pointed to by 'arg'. 'Arg' has to point to a
                       NUL-terminated C-string with the new data, formated like
                       the string returned by DC_GETCOLUMNDATA.

              @{"DS_GOTOROW" LINK "include/DataServer.h/File" 173} - go to any row by its number; the argument 'arg',
                       interpreted as ULONG, specifies the number of the row that
                       should be selected as current row. The count of the rows
                       start with 1. If 0 or a value greater than the number of
                       available rows is specified, this function fails, the
                       current row is undefined.

              @{"DS_NEXTROW" LINK "include/DataServer.h/File" 174} - go to next row, the one behind the current one in
                       the currently active order. If there are no more rows
                       available, this function will fail, the current row is
                       undefined.

              @{"DS_PREVROW" LINK "include/DataServer.h/File" 175} - go to previous row, the one before the current one in
                       the currently active order. If there are is no row before
                       the current one, this function will fail, the current row
                       is undefined.

              @{"DS_FIRSTROW" LINK "include/DataServer.h/File" 176} - go to first row, the first available row in the
                       currently active order. If there is no row available at
                       all, this function will fail.

              @{"DS_LASTROW" LINK "include/DataServer.h/File" 177} - go to last row, the last available row in the
                       currently active order. If there is no row available
                       at all, this function will fail.

              @{"DS_SKIPROWS" LINK "include/DataServer.h/File" 178} - skip any number of rows, the argument 'arg' is
                       interpreted as long value, specifying the number of rows
                       that should be skipped. If the argument is less than zero,
                       the rows are skipped to the top of the DataServer else the
                       rows are skipped to the bottom of the DataServer. If EOF
                       or BOF are reached, this operation will fail, the current
                       row is undefined.

              @{"DS_INSERTROW" LINK "include/DataServer.h/File" 180} - a new row should be inserted into the DataServer.
                       The columns of the row are initialized to defaults.
                       After this operation has succeeded, the operation
                       @{"DS_UPDATE" LINK "include/DataServer.h/File" 209} has to be performed to access the new inserted
                       row.

              @{"DS_REMOVEROW" LINK "include/DataServer.h/File" 181} - the current row should be deleted. After this
                       operation has succeeded, the operation @{"DS_UPDATE" LINK "include/DataServer.h/File" 209} has to be
                       performed to remove the row from the DataServers buffer.

              @{"DS_SETORDER" LINK "include/DataServer.h/File" 188} - change the order of the rows; 'arg' points to the new
                       order that should be used. The type of data 'arg' points
                       to depends on the implementation of the subclass, usually
                       it should point to a string. After this operation has
                       succeeded, the operation @{"DS_UPDATE" LINK "include/DataServer.h/File" 209} should be performed to
                       match the new order.

              @{"DS_GETORDER" LINK "include/DataServer.h/File" 189} - get the order of the rows; a pointer to the current
                       order is stored in the address 'arg' points to, the type
                       of that pointer depends on the implementation of the
                       subclass, usually it should point to a string.

              @{"DS_AVAILABLEORDER" LINK "include/DataServer.h/File" 191} - get a pointer to a list with the available
                       orders of the DataServer; a pointer to a list of orders
                       available for this DataServer is copied to the address
                       'arg' points to. The type of this list depends on the
                       implementation of the subclass, usually it should be a
                       NULL-terminated array of string-pointers.

              @{"DS_ORDERASCEND" LINK "include/DataServer.h/File" 190} - order the rows ascend or descend; the argument
                       'arg' is interpreted as boolean, if 'arg' is not NULL,
                       the rows are ordered in ascend order, otherwise they are
                       ordered descend. After this operation has succeeded, the
                       operation @{"DS_UPDATE" LINK "include/DataServer.h/File" 209} should be performed to match the
                       new order.

              @{"DS_KEYEXPRESSION" LINK "include/DataServer.h/File" 192} - get a pointer to the expression used to generate
                       the keys for the rows in the currently active order.
                       A pointer to the expression is copied to the address 'arg'
                       points to. This should be usually a NUL-terminated string,
                       but it depends on the implementation of the subclasses of
                       the DataServer.

              @{"DS_KEYLENGTH" LINK "include/DataServer.h/File" 193} - get the length of a keyvalue of the currently active
                       order. This size is required to allocate a buffer large
                       enough to store a keyvalue as required for @{"DS_CURRENTKEY" LINK "include/DataServer.h/File" 194}.
                       The length is copied to the ULONG value 'arg' points to.

              @{"DS_CURRENTKEY" LINK "include/DataServer.h/File" 194} - get the keyvalue of the current row in the
                       currently active order. This keyvalue is copied to the
                       buffer 'arg' points to. Take care that the buffer is large
                       enough to store a keyvalue (see @{"DS_KEYLENGTH" LINK "include/DataServer.h/File" 193}). This value
                       might be passed to the operation @{"DS_SEEK" LINK "include/DataServer.h/File" 197} to find this
                       record again.

              @{"DS_SEEK" LINK "include/DataServer.h/File" 197} - seek to a row with a specific keyvalue. The row is
                       searched in the current order from top to bottom; the
                       argument 'arg' has to point to the value to be searched.
                       If soft-seek is enabled, the search starts at the current
                       row and stops on the first row with a keyvalue that is
                       equal to or greater than the specified value. If soft-seek
                       is disabled, the search starts at the first record and
                       stops if a matching keyvalue is found.
                       If no according matching key-value is found, the operation
                       fails, the current row is set to end-of-file.

              @{"DS_SEEKNEXT" LINK "include/DataServer.h/File" 198} - if softseek is enabled, this operation can be used
                       after a successfull @{"DS_SEEK" LINK "include/DataServer.h/File" 197} to seek to the next value.
                       This operation works like @{"DS_SEEK" LINK "include/DataServer.h/File" 197} and requires the same
                       argument, the difference is, that it starts the seek at
                       the next row, not at the first row.

              @{"DS_SOFTSEEK" LINK "include/DataServer.h/File" 199} - enable/disable softseek; if the argument 'arg',
                       interpreted as boolean, is TRUE, soft-seek is enabled,
                       else soft-seek is disabled.

              @{"DS_SELECTROW" LINK "include/DataServer.h/File" 201} - if the underlying "device" supports selection of
                       rows, this operation can be used to select or unselect
                       the current row. The argument 'arg' is interpreted as
                       boolean, if it is TRUE, the current row is selected, else
                       the selection of the current row is cleared.
                       The operation should return TRUE, if it is supported and
                       could be successfully performed, it should only return
                       FALSE, if the DataServer doesn't supports selection or
                       an unexpected error occurs, 'LastError' should be set
                       accordingly.

              @{"DS_FIRSTSELECTED" LINK "include/DataServer.h/File" 202} - this operation should perform a skip to the
                       first selected row, if there is one selected at all. If
                       no row is selected, 'LastError' should be set to
                       "@{"DS_ERR_NO_MORE_DATA" LINK "include/DataServer.h/File" 218}". The number of the first selected
                       row is stored in the ULONG, 'arg' points to. If no row
                       is selected, the value -- 'arg' points to -- is not
                       changed.

              @{"DS_NEXTSELECTED" LINK "include/DataServer.h/File" 203} - if more than one row is selected, this operation
                       should perform a skip to the next selected row. If there
                       are no more rows selected, 'LastError' should be set to
                       "@{"DS_ERR_NO_MORE_DATA" LINK "include/DataServer.h/File" 218}". The number of the next selected
                       row is stored in the ULONG, 'arg' points to. If no row
                       is selected, the value -- 'arg' points to -- is not
                       changed.

              @{"DS_CLEARSELECTION" LINK "include/DataServer.h/File" 204} - this operation clears all selections made.
                       The argument 'arg' is not used.

              @{"DS_ISSELECTED" LINK "include/DataServer.h/File" 205} - this operation evaluates if the current row is
                       selected. If the DataServer doesn't supports selection,
                       or no row is the current one, FALSE is returned,
                       'DataServer.LastError' is set to the according errorcode;
                       If the DataServer supports selection, and the current row
                       is not selected, FALSE is returned, 'DataServer.LastError'
                       is set to 0; if the current row is selected, TRUE is
                       returned.

              @{"DS_ALLOWSELECTION" LINK "include/DataServer.h/File" 206} - using this operation, the "user" of the
                       DataServer can evaluate if the DataServer supports
                       selection of rows. The argument 'arg' indicates, which
                       kind of selection is requested: If its not NULL, the
                       DataServer should return TRUE, if multiple selection is
                       supported. If 'arg' is NULL, the DataServer should return
                       TRUE, if the selection of a single row is supported.

              @{"DS_NUM_OF_ROWS" LINK "include/DataServer.h/File" 183} - get number of accessable rows, the number of rows
                       accessable is copied to the ULONG 'arg' points to.

              @{"DS_NUM_OF_COLUMNS" LINK "include/DataServer.h/File" 184} - get number of accessable columns, the number of
                       columns accessable is copied to the ULONG 'arg' points to.

              @{"DS_CURRENTROW" LINK "include/DataServer.h/File" 185} - get the number of the current row;  the number of
                       the current row, as stored in the DataServer structures
                       'CurrentRow' member, will be copied to the ULONG address
                       'arg' points to. If currently no row is accessable (e.g.
                       the DataServer has just been created and no @{"DS_UPDATE" LINK "include/DataServer.h/File" 209} has
                       been performed, or the last @{"DS_UPDATE" LINK "include/DataServer.h/File" 209} failed), this
                       operation fails, the contents of the address 'arg' points
                       to is not changed.

              @{"DS_CURRENTCOLUMN" LINK "include/DataServer.h/File" 186} - get a pointer to the DataColumn structure of
                       the current column. If currently a column is selected,
                       a pointer to the column will be copied to the address
                       'arg' points to. If no column is selected (usually just
                       after the DataServer has been created or an @{"DS_UPDATE" LINK "include/DataServer.h/File" 209} has
                       been performed), this operation fails, the contents of the
                       address 'arg' points to is not changed.

              @{"DS_DISPOSE" LINK "include/DataServer.h/File" 211} - the DataServer is disposed, all resources used by the
                       DataServer are freed. If a subclass allocates any resource
                       dynamically or needs to terminate a connection to a
                       "device", it has to implement this operation and perform
                       it, before it calls @{"DS_Update()" LINK "DS_Update"} to do the default clean-up@{b}
 RESULT@{ub}
        If the operation succeeds, TRUE is returned. Depending on the type of
        operation performed, the address 'arg' points to may have changed.
        If the function fails, FALSE is returned, check 'DataServer.LastError'
        for the cause of the failure.

@ENDNODE
@NODE "DS_InitA" "database.library/DS_InitA()"
@{b}

 NAME@{ub}
        DS_InitA - create and initialize a DataServer@{b}

 SYNOPSIS@{ub}
        @{"struct DataServer" LINK "include/DataServer.h/File" 95} *DS_InitA (APTR, struct TagItem *)
        dataServer = DS_InitA (unused, tagList)
           D0                    A0      A1@{b}

 FUNCTION@{ub}
        This function allocates and initialize a DataServer structure. The
        DataServer is the base-class used to access and present any kind of
        data, which is arranged as any number (> 2 billion) of rows that are
        equal structured in columns of single data.@{b}

 INPUTS@{ub}
        unused - this argument is not used in the current implementation, it
                 is reserved for future use and should be set to NULL.
        tagList - a pointer to a TagItem list used to initialize the DataServer.
                 Currently defined Tags are:

                    @{"DS_Columns" LINK "include/DataServer.h/File" 125} - a pointer to an array of of DataColumn
                             structures, which define the columns of this
                             DataServer. The structures and all strings
                             passed with this array are copied and need not to
                             remain valid, when this function has returned.
                             This array is terminated by an entry with the
                             'Name' set to NULL.
                             If this Tag is not present, the DataServer has
                             initially no columns, the columns need to be added
                             using the function @{"DS_DoUpdate()" LINK "DS_DoUpdate"} with the operation
                             @{"DS_ADDCOLUMN" LINK "include/DataServer.h/File" 159}.
                    @{"DS_ReadOnly" LINK "include/DataServer.h/File" 127} - boolean Tag, if this Tag is present in the
                             TagItem list, the DataServer is read-only, i.e. no
                             data of any column might be changed.
                    @{"DS_SoftSeek" LINK "include/DataServer.h/File" 128} - boolean Tag, if this Tag is present in the
                             TagItem list, the soft-seek of the DataServer is
                             enabled. If soft-seek is enabled, the operation
                             @{"DS_SEEK" LINK "include/DataServer.h/File" 197} stops successfully on the first row that
                             is equal or greater than the searched value.
                    @{"DS_StructSize" LINK "include/DataServer.h/File" 126} - ULONG, the size of the structure that should
                             be allocated as DataServer structure. This Tag has
                             to be specified, if a subclass of the DataServer
                             needs additional space in the structure for private
                             data.
                    @{"DS_Name" LINK "include/DataServer.h/File" 129} -  a pointer to a NUL-terminated string specifying
                             a name for the DataServer. This string is copied and
                             needs not to remain valid after this function has
                             returned.@{b}

 RESULT@{ub}
        If the function succeeds, a pointer to a full initialized DataServer
        structure is returned. If the function fails, NULL is returned.

@ENDNODE
@NODE "DS_RemoveColumns" "database.library/DS_RemoveColumns()"
@{b}

 NAME@{ub}
        DS_RemoveColumns - remove one or more DataColumns from a DataServer@{b}

 SYNOPSIS@{ub}
        BOOL DS_RemoveColumns (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, ULONG, ULONG)
        success = DS_RemoveColumns (server, firstColumn, numColumns)
           D0                         A0        D0           D1@{b}

 FUNCTION@{ub}
        This function removes one or more DataColumns from the DataServers array
        of DataColumns.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the server
        firstColumn - the position of the first column to be removed
        numColumns - the number of columns that should be removed@{b}

 RESULT@{ub}
        If everything wents fine TRUE is returned, else (usually bad arguments
        passed to this function or no free memory available) FALSE is returned.

@ENDNODE
@NODE "DS_Update" "database.library/DS_Update()"
@{b}

 NAME@{ub}
        DS_Update - perform an operation on a DataServer@{b}

 SYNOPSIS@{ub}
        BOOL DS_Update (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, ULONG, APTR)
        success = DS_Update (server, operation, arg)
          D0                   A0       D0      A1@{b}

 FUNCTION@{ub}
        This function is the default implementation to perform any operation on
        a DataServer. If any subclass of the DataServer needs to do anything
        different than the default operation, it has to implement its own update
        function and store the pointer to that function in the 'Update' function-
        pointer of the DataServer structure. This function should call this
        DS_Update() for any operation it doesn't supports.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataServer to be
                 accessed.
        operation - the operation that should be performed, the DataServer
                 supports the following operations, all other values would
                 lead this function to return FALSE without doing anything.

              These operations are direct supported by the DataServer:

              @{"DS_ADDCOLUMN" LINK "include/DataServer.h/File" 159} - append a new column to the end of the DataServers
                       list of DataColumns; the argument 'arg' has to point to a
                       full initialized DataColumn structure. This structure and
                       the referenced strings will be copied and added to the end
                       of the list of already present columns.
                       After this operation has succeeded, you should perform an
                       @{"DS_UPDATE" LINK "include/DataServer.h/File" 209} to re-read the data from the "device" and this
                       new column contains valid data.

              @{"DS_REMOVECOLUMN" LINK "include/DataServer.h/File" 160} - remove a column from the DataServer, the argument
                       'arg' has to specify the number of the DataColumn to be
                       removed. If the operation succeeds, and the removed column
                       is the current column of the DataServer, the next column
                       will went to the current column. If no next column is
                       existent, the previous column wents to be the current
                       column.
                       At least a single column has to remain in the DataServer,
                       or this operation will fail.

              @{"DS_MOVECOLUMN" LINK "include/DataServer.h/File" 161} - rearrange the order of the columns in the
                       DataServers array of DataColumns. The order in this array
                       will be the order the columns are selected using the
                       operations @{"DS_GOTOCOLUMN" LINK "include/DataServer.h/File" 163}, @{"DS_NEXTCOLUMN" LINK "include/DataServer.h/File" 164} and @{"DS_PREVCOLUMN" LINK "include/DataServer.h/File" 165}.
                       This operation will move the currently selected column to
                       the position the argument 'arg' - interpreted as ULONG -
                       specifies. 'arg' has to be between 1 and the number of
                       columns attached to the DataServer. If 'arg' is greater
                       than the number of columns, the current column is moved
                       to the last position, if 'arg' is equal 0, nothing is
                       changed, the operation will fail.

              @{"DS_GOTOCOLUMN" LINK "include/DataServer.h/File" 163} - select the column with the number specified by
                       'arg' - interpreted as ULONG. The count of the columns
                       starts with 1. If 0 or any value larger than the number
                       of columns attached to the DataServer is specified, the
                       operation will fail,the current column will not be changed

              @{"DS_NEXTCOLUMN" LINK "include/DataServer.h/File" 164} - select the next column, the one behind the current
                       column, a pointer to the column will copied to the address
                       'arg' points to, if 'arg' is not equal NULL. If there are
                       no more columns, this operation will fail, the current
                       column will not be changed, the address 'arg' points to
                       will not be changed.

              @{"DS_PREVCOLUMN" LINK "include/DataServer.h/File" 165} - select the preceding column, the one before the
                       current column, a pointer to the column will copied to the
                       address 'arg' points to, if 'arg' is not equal NULL. If
                       there are no columns in front of the current column, this
                       operation will fail, the current column will not be
                       changed, the address 'arg' points to will not be changed.

              @{"DS_FINDCOLUMN" LINK "include/DataServer.h/File" 166} - select a column specified by its 'Name'. The
                       argument 'arg' has to be a pointer to a NUL-terminated
                       string with the 'Name' of the searched column.

              @{"DS_GOTOROW" LINK "include/DataServer.h/File" 173} - go to any row by its number; the argument 'arg',
                       interpreted as ULONG, specifies the number of the row that
                       should be selected as current row. The count of the rows
                       start with 1. If 0 or a value greater than the number of
                       available rows is specified, this function fails, the
                       current row is not changed.

              @{"DS_NEXTROW" LINK "include/DataServer.h/File" 174} - go to next row, the one behind the current one in
                       the currently active order. If there are no more rows
                       available, this function will fail, the current row is
                       not changed.

              @{"DS_PREVROW" LINK "include/DataServer.h/File" 175} - go to previous row, the one before the current one in
                       the currently active order. If there are is no row before
                       the current one, this function will fail, the current row
                       is not changed.

              @{"DS_FIRSTROW" LINK "include/DataServer.h/File" 176} - go to first row, the first available row in the
                       currently active order. If there is no row available at
                       all, this function will fail.

              @{"DS_LASTROW" LINK "include/DataServer.h/File" 177} - go to last row, the last available row in the
                       currently active order. If there is no row available
                       at all, this function will fail.

              @{"DS_SKIPROWS" LINK "include/DataServer.h/File" 178} - skip any number of rows, the argument 'arg' is
                       interpreted as long value, specifying the number of rows
                       that should be skipped. If the argument is less than zero,
                       the rows are skipped to the top of the DataServer else the
                       rows are skipped to the bottom of the DataServer. If EOF
                       or BOF are reached, this operation will fail, the current
                       row is not changed.

              @{"DS_ALLOWSELECTION" LINK "include/DataServer.h/File" 206} - this opperation will always fail, 'LastError'
                       is set to @{"DS_ERR_NO_ERROR" LINK "include/DataServer.h/File" 216}. This indicates that the
                       DataServer doesn't supports selection of rows per default.

              @{"DS_NUM_OF_ROWS" LINK "include/DataServer.h/File" 183} - get number of accessable rows; the number of rows
                       as stored in the DataServer structures 'NumRows' member,
                       will be copied to the ULONG address 'arg' points to.

              @{"DS_NUM_OF_COLUMNS" LINK "include/DataServer.h/File" 184} - get number of accessable columns; the number of
                       columns as stored in the DataServer structures member
                       'NumColumns', will be copied to the ULONG address 'arg'
                       points to.

              @{"DS_CURRENTROW" LINK "include/DataServer.h/File" 185} - get the number of the current row;  the number of
                       the current row, as stored in the DataServer structures
                       'CurrentRow' member, will be copied to the ULONG address
                       'arg' points to. If currently no row is accessable (e.g.
                       the DataServer has just been created and no @{"DS_UPDATE" LINK "include/DataServer.h/File" 209} has
                       been performed, or the last @{"DS_UPDATE" LINK "include/DataServer.h/File" 209} failed), this
                       operation fails, the address 'arg' points to is not
                       changed.

              @{"DS_CURRENTCOLUMN" LINK "include/DataServer.h/File" 186} - get a pointer to the DataColumn structure of
                       the current column. If currently a column is selected,
                       a pointer to the column will copied to the address 'arg'
                       points to. If no column is selected (usually just after
                       the DataServer has been created or an @{"DS_UPDATE" LINK "include/DataServer.h/File" 209} has been
                       performed), this operation fails, the address 'arg' points
                       to is not changed.

              @{"DS_GETORDER" LINK "include/DataServer.h/File" 189} - get the order of the rows; a pointer to the current
                       order is stored in the address 'arg' points to, the type
                       of that pointer depends on the implementation of the
                       subclass, usually it should point to a string.

              @{"DS_SOFTSEEK" LINK "include/DataServer.h/File" 199} - enable/disable softseek; if the argument 'arg',
                       interpreted as boolean, is TRUE, soft-seek is enabled,
                       else soft-seek is disabled. If soft-seek is enabled, the
                       flag @{"DSF_SOFTSEEK" LINK "include/DataServer.h/File" 241} is set.

              @{"DS_ORDERASCEND" LINK "include/DataServer.h/File" 190} - order the rows ascend or descend; the argument
                       'arg' is interpreted as boolean, if 'arg' is not NULL,
                       the flags @{"DSF_DESCEND" LINK "include/DataServer.h/File" 242} is cleared, rows are ordered in
                       ascend order; else the flags @{"DSF_DESCEND" LINK "include/DataServer.h/File" 242} is set, they
                       are ordered descend.

              @{"DS_DISPOSE" LINK "include/DataServer.h/File" 211} - the DataServer is disposed, all resources used by the
                       DataServer are freed. If a subclass allocates any resource
                       dynamically or needs to terminate a connection to a
                       "device", it has to implement this operation and perform
                       that operation, before it calls DS_Update() to do the
                       default clean-up.


              All other operations have to be implemented by subclasses of the
              DataServer, these function will not do anything and return FALSE.@{b}

 RESULT@{ub}
        If the operation succeeds, TRUE is returned. Depending on the type of
        operation performed, the address 'arg' points to may have changed.
        If the function fails, FALSE is returned, check 'DataServer.LastError'
        for the cause of the failure.

@ENDNODE
@NODE "DToS" "database.library/DToS()"
@{b}

 NAME@{ub}
        DToS - convert a date into a human readable string representing that date@{b}

 SYNOPSIS@{ub}
        BOOL DToS (APTR, UBYTE *)
        valid = DToS (date, dateStr)
          D0           A0     A1@{b}

 FUNCTION@{ub}
        This function creates a string in the format "dd-mmm-yyyy" according to
        the specified date.
        The date has to be a string in the format "YYYYMMDD", this string needs
        not to be NUL-terminated.@{b}

 INPUTS@{ub}
        dateVal - a pointer to a string with the date to be converted
        dateStr - a pointer to a buffer, where the NUL-terminated string
              representing the date in human-readable form is copied into. This
              buffer has to be at least 12 bytes large.@{b}

 RESULT@{ub}
        If the specified date is valid, TRUE is returned, else FALSE is returned.

@ENDNODE
@NODE "Float2Double" "database.library/Float2Double()"
@{b}

 NAME@{ub}
        Float2Double - floating point convertion@{b}

 SYNOPSIS@{ub}
        BOOL Float2Double (APTR, APTR)
        success = Float2Double (fVal, dVal)
          D0                     A0    A1@{b}

 FUNCTION@{ub}
        This function converts a single precision floating point number (4 bytes)
        into a double precision floating point number (8 bytes) without the usage
        of the math.lib, so this module needs not to be linked against that lib.@{b}

 INPUTS@{ub}
        fVal - a pointer to the address where the 4-byte floating point number is
              stored. This number has to be valid. This address has to be word
              aligned.
        dVal - a pointer to the address where the resulting 8-byte floating point
              number should be stored. This may be the same address as used for
              storing the 'fVal' value, if it is large enough. In this case the
              original short floating point value will be overwritten.
              This address has to be word aligned.@{b}

 RESULT@{ub}
        This function always returns TRUE, but it should return FALSE if the
        specified floating point number is not valid.

@ENDNODE
@NODE "IDX_ClearIndex" "database.library/IDX_ClearIndex()"
@{b}

 NAME@{ub}
     IDX_ClearIndex - remove all keys from the index@{b}

 SYNOPSIS@{ub}
     BOOL IDX_ClearIndex (@{"struct IDXHeader" LINK "include/Index.h/File" 71} *)
     success = IDX_ClearIndex (ihd)
       D0                       A0@{b}

 FUNCTION@{ub}
     This function clears the whole index, i.e. all keys stored in the index
     are removed. The changes are written to the index-file.

     This function tries to access the file in exclusive mode, so you need not
     to enclose this functioncall by calls the function @{"IDX_StartTransaction()" LINK "IDX_StartTransaction"}
     and @{"IDX_EndTransaction()" LINK "IDX_EndTransaction"}.@{b}

 INPUT@{ub}
     ihd - a pointer to the IDXHeader structure of the index, the index should
           be created with the custom-flag (using the Tag @{"IDX_Custom" LINK "include/Index.h/File" 163})@{b}

 RESULT@{ub}
     If the function succeeds, TRUE is returned.
     If the function fails, FALSE is returned.@{b}

 NOTE@{ub}
     You should enclose this function-call by a call to the
     @{"IDX_StartTransaction()" LINK "IDX_StartTransaction"}/@{"IDX_EndTransaction()" LINK "IDX_EndTransaction"} function-pair to
     avoid conflicts with other instances accessing this index.@{b}

 KNOWN BUGS@{ub}
     Several filesystems doesn't have implemented the ATION_SET_FILESIZE
     packet (AmigaDos function SetFileSize()). In this case the file is
     closed, reopened in MODE_NEWFILE, the header is written, than the file
     is closed again and reopened in MODE_OLDFILE.
     However because the file is closed two times, in worst case another
     process could gain exclusive access to this files, before it is reopened
     by this process. So this process will fail to reopen the files and the
     index will be left in an undefined state.@{b}

 WORKAROUND@{ub}
     If this index has an according file (it is not a index only stored in
     memory), you should test 'ihd->fh' if this function fails. If this
     field contains zero, the indexfile couldn't be reopened (IoErr() should
     return ERROR_OBJECT_IN_USE for this case but other errorcodes are also
     possible). You have to close the index (@{"IDX_Dispose()" LINK "IDX_Dispose"}) in this case.

     Another way is suppressing the usage of this function, if you know that
     your filesystem doesn't support SetFileSize(), you can close the index
     (@{"IDX_Dispose()" LINK "IDX_Dispose"}), delete it from disk using AmigaDos's DeleteFile()
     function, and recreate it using @{"IDX_InitA()" LINK "IDX_InitA"}. If the access fails in this
     case, @{"IDX_InitA()" LINK "IDX_InitA"} will return NULL and so -- if the IDXHeader structure
     is returned -- you could be shure that it is valid.

@ENDNODE
@NODE "IDX_CountFields" "database.library/IDX_CountFields()"
@{b}

 NAME@{ub}
        IDX_CountFields - count the number of fields referenced by an expression@{b}

 SYNOPSIS@{ub}
        ULONG IDX_CountFields (STRPTR)
        numFields = IDX_CountFields (expr)@{b}

 FUNCTION@{ub}
        This function counts the number of DataBase-fields referenced by a key-
        expression.
        It doesn't checks the validity of the expression.@{b}

 INPUT@{ub}
        expr - a pointer to the NUL-terminated string with the key-expression@{b}

 RESULT@{ub}
        The number of fields referenced by the expression is returned.

@ENDNODE
@NODE "IDX_Dispose" "database.library/IDX_Dispose()"
@{b}

 NAME@{ub}
        IDX_Dispose - dispose the index@{b}

 SYNOPSIS@{ub}
        void IDX_Dispose (@{"struct IDXHeader" LINK "include/Index.h/File" 71} *)
        IDX_Dispose (ihd)
                     A0@{b}

 FUNCTION@{ub}
        This function is used to dispose the index, i.e. the access to the index
        file is terminated and all memory used by the index is freed.@{b}

 INPUT@{ub}
        ihd - a pointer to the IDXHeader structure of the index to be disposed.
              It is safe to pass a pointer to an IDXAlias structure to this
              function.

@ENDNODE
@NODE "IDX_EndTransaction" "database.library/IDX_EndTransaction()"
@{b}

 NAME@{ub}
        IDX_EndTransaction - terminate the access to the index@{b}

 SYNOPSIS@{ub}
        BOOL IDX_EndTransaction (@{"struct IDXHeader" LINK "include/Index.h/File" 71} *, LONG)
        success = IDX_EndTransaction (ihd, accessType)
          D0                          A0       D0@{b}

 FUNCTION@{ub}
        Every call to @{"IDX_StartTransaction()" LINK "IDX_StartTransaction"} has to be matched by a call to this
        function.
        If the index-file has been changed (@{"IDX_WRITE" LINK "include/Index.h/File" 188}), the DateStamp containing
        the time of the last change is updated to indicate other processes that
        the file has been changed.
        After this function returns, the index is free again for any access.@{b}

 INPUT@{ub}
        ihd - a pointer to the IDXHeader structure of the index
        accessType - the type of access that has been performed. This could
                 be either
                    @{"IDX_READ" LINK "include/Index.h/File" 187} - for read-only accesses
                    @{"IDX_WRITE" LINK "include/Index.h/File" 188} - for read-write accesses@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned.
        If the function failes, FALSE is returned. See IoErr() for an according
        AmigaDos errorcode.@{b}

 BUGS@{ub}
        On success IoErr() is not cleared.

@ENDNODE
@NODE "IDX_EvalExpression" "database.library/IDX_EvalExpression()"
@{b}

 NAME@{ub}
        IDX_EvalExpression - evaluate a key-expression using user-arguments@{b}

 SYNOPSIS@{ub}
        BOOL IDX_EvalExpression (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, STRPTR, UBYTE *, ...)
        success = IDX_EvalExpression (ds, expr, value, <args>)@{b}

 FUNCTION@{ub}
        This function evaluates a key-expression and generates -- using the
        specified argument values -- a key-value. This keyvalue may be used to
        seek for a specific record in the index or may be used for setting an
        orderscope to the index.@{b}

 INPUTS@{ub}
        ds - a pointer to the DataServer structure of the DataServer that should
              be indexed using this key-expression
        expr - a pointer to the NUL-terminated string with the key-expression
                 as pointed to by the field 'Expression' of the IDXHeader
                 structure of an index.
        key - a pointer to the buffer, where the resulting key-value of this
                 function should be stored. This buffer has to have at least
                 'IDXHeader.KeyLen' bytes of free space.
        <args> - a variable length list of arguments (each 32 bits wide) that are
                 used to evaluate the expression. For every Database-field that
                 is referenced in the expression (evaluated from left to right)
                 the according value has to be passed with this argument list (in
                 the same order). If a field is referenced twice, the according
                 value has to be passed twice!
                 The arguments have to be passed according to the type of the
                 referenced Database-field:
                    @{"DC_BYTE" LINK "include/DataServer.h/File" 134} - a byte value (casted to a 32-bit integer)
                    @{"DC_WORD" LINK "include/DataServer.h/File" 135} - a signed 2 byte word (casted to a 32-bit integer)
                    @{"DC_LONG" LINK "include/DataServer.h/File" 136} - a signed 4 byte word
                    @{"DC_DOUBLELONG" LINK "include/DataServer.h/File" 137} - a pointer to a DOUBLELONG
                    @{"DC_TIME" LINK "include/DataServer.h/File" 144} - a pointer to a string in the format "HH:MM:SS.mmm",
                             where 'HH' are the number of hours (0 - 23)
                                   'MM' are the number of minutes (0 - 59)
                                   'SS' are the number of seconds (0 - 59)
                                   'mmm' are the number of milliseconds (0 - 999)
                             The string could be terminated by a NUL-byte after
                             each part separated by a colon or dot (e.g. "HH:MM"
                             or "HH:MM:SS")
                    @{"DC_DATE" LINK "include/DataServer.h/File" 142} - a pointer to a string in the format "dd-mmm-yy",
                             "dd-mm-yy", "dd-mmm-yyyy", or "dd-mm-yyyy"
                             where 'yyyy' is the (any) year from 1583-9999
                                   'yy' is the year between 2000 and 2099
                                         (e.g. "04" for 2004)
                                   'mm' is the month in numerical form
                                         (e.g. "12" for december)
                                   'mmm' is the month in alphanumerical form
                                         (e.g. "Dec" for december)
                                   'dd' is the day (2 characters required)
                    @{"DC_CHAR" LINK "include/DataServer.h/File" 148} - a pointers to a NUL-terminated C-string, if the
                             string is longer than the addressed Database-field,
                             it is truncated.
                    @{"DC_FLOAT" LINK "include/DataServer.h/File" 138} - a pointer to a single precision (32 bit) floating
                             point value.
                    @{"DC_DOUBLE" LINK "include/DataServer.h/File" 139} - a pointer to a double precision (64 bit) floating
                             point value.

                 If wrong argument types are passed, the result of this function
                 is unpredictabe.@{b}
 RESULT@{ub}
        If the function succeeds, TRUE is returned, the key-value is copied into
        the specified buffer.
        If the function fails, FALSE is returned, the contents of the key-value
        buffer is not changed.

@ENDNODE
@NODE "IDX_EvalExpressionA" "database.library/IDX_EvalExpressionA()"
@{b}

 NAME@{ub}
        IDX_EvalExpressionA - evaluate a key-expression using user-arguments@{b}

 SYNOPSIS@{ub}
        BOOL IDX_EvalExpressionA (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, STRPTR, APTR, ULONG *)
        success = IDX_EvalExpressionA (server, expr, key, args)
          D0                             A0     A1   A2    A3@{b}

 FUNCTION@{ub}
        This function evaluates a key-expression and generates -- using the
        specified argument values -- a key-value. This keyvalue may be used to
        seek for a specific record in the index or may be used for setting an
        orderscope to the index.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataServer that
                 should be indexed using this key-expression. This reference is
                 required to determine the type and size of the DataColumns
                 referenced by the key-expression.
        expr - a pointer to the NUL-terminated string with a key-expression as
                 pointed to by the field 'Expression' of the IDXHeader structure
                 of an index.
        key - a pointer to the buffer, where the resulting key-value of this
                 function should be stored. This buffer has to have at least
                 'IDXHeader.KeyLen' bytes of free space.
        args - a variable length array of arguments (each casted to ULONG) that
                 are used to evaluate the expression. For every Database-field
                 that is referenced in the expression (evaluated from left to
                 right) an entry with the according value has to be present in
                 this array (in the same order). If a field is referenced twice,
                 the according value has to be present twice!
                 The arguments are interpreted according to the type of the
                 referenced Database-field:
                    @{"DC_BYTE" LINK "include/DataServer.h/File" 134} - a byte value
                    @{"DC_WORD" LINK "include/DataServer.h/File" 135} - a signed 2 byte word
                    @{"DC_LONG" LINK "include/DataServer.h/File" 136} - a signed 4 byte word
                    @{"DC_DOUBLELONG" LINK "include/DataServer.h/File" 137} - a pointer to a DOUBLELONG
                    @{"DC_TIME" LINK "include/DataServer.h/File" 144} - a pointer to a string in the format "HH:MM:SS.mmm",
                             where 'HH' are the number of hours (0 - 23)
                                   'MM' are the number of minutes (0 - 59)
                                   'SS' are the number of seconds (0 - 59)
                                   'mmm' are the number of milliseconds (0 - 999)
                             The string could be terminated by a NUL-byte after
                             each part separated by a colon or dot (e.g. "HH:MM"
                             or "HH:MM:SS")
                    @{"DC_DATE" LINK "include/DataServer.h/File" 142} - a pointer to a string in the format "dd-mmm-yy",
                             "dd-mm-yy", "dd-mmm-yyyy", or "dd-mm-yyyy"
                             where 'yyyy' is the (any) year from 1583-9999
                                   'yy' is the year between 2000 and 2099
                                         (e.g. "04" for 2004)
                                   'mm' is the month in numerical form
                                         (e.g. "12" for december)
                                   'mmm' is the month in alphanumerical form
                                         (e.g. "Dec" for december)
                                   'dd' is the day (2 characters required)
                    @{"DC_CHAR" LINK "include/DataServer.h/File" 148} - a pointer to a NUL-terminated C-string, if the
                             string is longer than the addressed DataColumn,
                             it is truncated.
                    @{"DC_NUMERIC" LINK "include/DataServer.h/File" 140} - a pointer to a NUL-terminated C-string
                             representing a decimal number (e.g. "-123.567")
                    @{"DC_FLOAT" LINK "include/DataServer.h/File" 138} - a pointer to a single precision (32 bit) floating
                             point value.
                    @{"DC_DOUBLE" LINK "include/DataServer.h/File" 139} - a pointer to a double precision (64 bit) floating
                             point value.
                    @{"DC_LOGIC" LINK "include/DataServer.h/File" 146} - a single byte value, either 'F' or 'T'.

                 If wrong argument types are passed or the number of entries in
                 this array doesn't match the number of fields specified by the
                 key-expression the result of this function is unpredictabe.@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned, the key-value is copied into
        the specified buffer.
        If the function fails, FALSE is returned, the contents of the key-value
        buffer is not changed.

@ENDNODE
@NODE "IDX_EvalExpressionB" "database.library/IDX_EvalExpressionB()"
@{b}

 NAME@{ub}
        IDX_EvalExpressionB - create a keyvalue from user input@{b}

 SYNOPSIS@{ub}
        BOOL IDX_EvalExpressionB (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, UBYTE *, APTR, STRPTR *)
        success = IDX_EvalExpressionB (server, expr, key, args)
          D0                             A0     A1   A2    A3@{b}

 FUNCTION@{ub}
        This function can be used to create a keyvalue from user-input.
        A NULL-terminated array of pointers to strings as read from the user
        (e.g. from the console) is passed to this function. Each entry in this
        array represents a value used instead of a fieldvalue from the DataServer
        this index is attached to.
        The arguments must occure in the same order as in the key-expression.
        If there as many entries in the array as fields referenced by the
        expression, the missing values are set to empty values (e.g. zero for
        numeric fields or an empty string for string-fields).

        The keyvalue created by this function may be used to search an entry
        in this index. Usually you should enable 'softseek' for this purpose.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServer structure of the DataServer that
              should be indexed using this key-expression. This reference is
              required to determine the type and size of the Database-fields
              referenced by the key-expression.
        expr - a pointer to the preprocessed expression of the key. This has to
              be a string as created by @{"IDX_PreCompileExpression()" LINK "IDX_PreCompileExpression"}. If this
              expression is not precompiled or not tested using IPX_KeyLength()
              this may lead to unpredictable results (you may meet the Guru).
        key - a pointer to the buffer, where the keyvalue should be stored.
              This may be the 'KeyValue' buffer in the IDXKeyEntry structure
              referenced by the 'CurrentKey' pointer of an IDXHeader structure.
        args - a pointer to a NULL-terminated array of pointers to the strings
              representing the desired values used to evaluate the key.@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned, the evaluated keyvalue is
        stored in the specified buffer.
        If the function fails, FALSE is returned, the contents of the buffer is
        not changed.

@ENDNODE
@NODE "IDX_FindKey" "database.library/IDX_FindKey()"
@{b}

 NAME@{ub}
        IDX_FindKey - find the entry for the key of the current record@{b}

 SYNOPSIS@{ub}
        BOOL IDX_FindKey (@{"struct IDXHeader" LINK "include/Index.h/File" 71} *, @{"struct DataServer" LINK "include/DataServer.h/File" 95} *)
        found = IDX_FindKey (ihd, server)
          D0                 A0   A1@{b}

 FUNCTION@{ub}
        This function tries to find the key matching to the current record of the
        DataServer in the index.

        This is usefull, if you wish to remove the key for the current record of
        the DataServer. In this case the function @{"IDX_RemoveKey()" LINK "IDX_RemoveKey"} has to be
        called after this function succeeds.@{b}

 INPUT@{ub}
        ihd - a pointer to the IDXHeader structure of the index
        server - a pointer to the DataServer structure of the DataServer@{b}

 RESULT@{ub}
        If the key-entry for the current record of the DataServer is found, it
        is used as current key and TRUE is returned, else FALSE is returned.

@ENDNODE
@NODE "IDX_GetKeyValue" "database.library/IDX_GetKeyValue()"
@{b}

 NAME@{ub}
        IDX_GetKeyValue - get the key-value of the current record@{b}

 SYNOPSIS@{ub}
        BOOL IDX_GetKeyValue (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, APTR, UBYTE *)
        success = IDX_GetKeyValue (server, keyValue, expr)
          D0                         A0    A1       A2@{b}

 FUNCTION@{ub}
        This function copies the key-value according to the current record of the
        DataServer and the specified key-expression into the user-suplied buffer.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServers DataServer structure.
        keyValue - a pointer to the buffer, where the key should be stored. Take
              care that this buffer is large enough to contain the whole value
              (buffer overruns are not funny).
        expr - a pointer to the preprocessed expression of the key. This has to
              be a string as created by @{"IDX_PreCompileExpression()" LINK "IDX_PreCompileExpression"}. If this
              expression is not precompiled or not tested using IPX_KeyLength()
              this may lead to unpredictable results (you may meet the Guru).@{b}

 RESULT@{ub}
        If the function succeeds, the key-value of the current record is copied
        to the specified buffer and TRUE is returned.
        If the function fails, FALSE is returned. The DataServers 'LastError'
        field is set to an according errorcode.

@ENDNODE
@NODE "IDX_InitA" "database.library/IDX_InitA()"
@{b}

 NAME@{ub}
        IDX_InitA - create and initialize an index@{b}

 SYNOPSIS@{ub}
        @{"struct IDXHeader" LINK "include/Index.h/File" 71} *IDX_InitA (APTR, struct TagItem *)
        indexHeader = IDX_InitA (unused, tagList)
            D0                     A0       A1@{b}

 FUNCTION@{ub}
        This function creates and initializes an index. If an index-file is
        specified, this file is read -- if it's already existing -- or newly
        created.
        If a new index is created, the keys for every record of the attached
        DataBase are created, if not specified otherwise.@{b}

 INPUTS@{ub}
        unused - this argument is not used in the current implementation, it is
              reserved for future use and should be set to NULL.
        tagList - a pointer to a variable sized array of TagItem structures.
              This array has to be terminated by a TagItem with the Tag
              TAG_DONE.
              Currently defined Tags are:

                 THESE TAGS ARE MANDATORY:

              @{"IDX_FileName" LINK "include/Index.h/File" 156} - a pointer to a NUL-terminated C-string with the
                       filename (and path) of the index-file.
                       If the file is currently not existing, it will be created.
                       If this argument is not passed, the index will only resist
                       in memory and will be lost, if it is disposed.
                       In these cases the TagItems with the Tags @{"IDX_Expression" LINK "include/Index.h/File" 157},
                       @{"IDX_Name" LINK "include/Index.h/File" 155}, and @{"IDX_Server" LINK "include/Index.h/File" 158} have to be present in the TagItem
                       list.
           or
              @{"IDX_Name" LINK "include/Index.h/File" 155} - a pointer to a NUL-terminated C-string with the name of
                       the index. This name is used for the @{"DS_SETORDER" LINK "include/DataServer.h/File" 188} command.
                       The string is limited to 32 characters (incl. terminating
                       NUL-byte) and is truncated to this length if a longer
                       string is passed. If the indexfile already exists, the
                       name stored in the file is used, this TagItem is ignored
                       in this case.
              @{"IDX_Expression" LINK "include/Index.h/File" 157} - the expression used for the index. This TagItem
                       has to be present, if no filename is passed to this
                       function (using the Tag @{"IDX_FileName" LINK "include/Index.h/File" 156}) or the according
                       file is not present. The length of an expression is
                       limited to 256 characters (incl. terminating NUL-byte).
                       If the index-file is already existing, this TagItem is
                       ignored.
              @{"IDX_Server" LINK "include/Index.h/File" 158} - a pointer to the DataServer structure of the
                       DataServer this index belongs to.
                       If the index-file is already existing, this TagItem is
                       ignored.

                 THESE TAGS ARE OPTIONAL:

              @{"IDX_PageSize" LINK "include/Index.h/File" 159} - the size of one page (one node of the B-tree)
                       stored in the index-file. This value has to be 2^n, where
                       n has to be chosen so that the value is in the range from
                       1024 upto 32768. If an illegal value is passed, it is
                       rounded to match the requirements.
                       If this value is not specified, the optimal pagesize is
                       calculated by this function.
                       You may use this TagItem, if the calculated pagesize will
                       be very large and you prefer smaller pages, maybe because
                       only very few keys are stored in the index or your file-
                       system is uneffective with large block-transfers.
                       This value is ignored, if the index-file is already
                       existing.
              @{"IDX_Unique" LINK "include/Index.h/File" 161} - a boolean Tag, if the index is created and a TagItem
                       with this Tag is present in the TagItem list, the new
                       index will be unique, i.e. no duplicate keys are allowed.
                       If duplicate keys are allowed, this will slow down the
                       seek-operations.
              @{"IDX_Descend" LINK "include/Index.h/File" 162} - a boolean Tag, if a TagItem with this Tag is present
                       in the TagItem list, the index will be ordered descend,
                       i.e. the keyvalue with the "highest" value are ordered
                       first.
                       This Tag is only useful, if you doesn't attache the index
                       to a DataTable, otherwise this setting is overwritten by
                       the DataTable. Send the operation @{"DS_ORDERASCEND" LINK "include/DataServer.h/File" 190} with the
                       argument FALSE to the DataTable to change the ordering to
                       descend order in this case.
              @{"IDX_Custom" LINK "include/Index.h/File" 163} - a boolean Tag, if a TagItem with this Tag is present
                       in the TagItem list, the index will not be handled by the
                       DataServer itself, i.e. if rows are added or removed from
                       the DataServer, the according keys in this index have to
                       be added/removed by the application itself using
                       @{"IDX_InsertKey()" LINK "IDX_InsertKey"} or @{"IDX_RemoveKey()" LINK "IDX_RemoveKey"}
              @{"IDX_Exclusive" LINK "include/Index.h/File" 164} - a boolean Tag, if a TagItem with this Tag is
                       present in the TagItem list, the index is opened exclusive
                       i.e. every try to open the index will be denied and the
                       index need not to be locked before every access.
              @{"IDX_WriteBehind" LINK "include/Index.h/File" 165} - a boolean Tag, if a TagItem with this Tag is
                       present in the TagItem list, the index will use a
                       write-behind caching-algorithm, i.e. the changes to the
                       pages of the index are not written immediately after they
                       are changed, instead they are written when the pages are
                       flushed from memory or the function @{"IDX_EndTransaction()" LINK "IDX_EndTransaction"}
                       is called. If this option is used, the performance of the
                       index-changing-operations will increase slightly (if more
                       than one key on the same page is changed during the same
                       transaction). On the other hand the chance that a system
                       failure (a Guru) will damage the index increases.
                 NOTE:
                       If this flag is set, the functions IDX_BeginTransaction()
                       and @{"IDX_EndTransaction()" LINK "IDX_EndTransaction"} MUST be used if the index is
                       changed, or you will corrupt the index-file.@{b}

 RESULT@{ub}
        If the function succeeds, a pointer to the IDXHeader structure of the
        index is returned, else NULL is returned.@{b}

 NOTE@{ub}
        If a completely new index is created by this function and this index is
        not specified as custom-index (by passing a TagItem with the Tag
        @{"IDX_Custom" LINK "include/Index.h/File" 163}), every record of the attached DataServer is indexed by this
        function. This may take some time -- upto several minutes for large
        DataBases (50000 records or more), even if you use a fast processor
        (68060-50Mhz).
        Therefor you should create all indexes during application start as
        custom indexes and patch the 'Flags' field after this function succeeded.
        Then you can call @{"IDX_ReIndex()" LINK "IDX_ReIndex"} direct by your application and so you
        are able to use a FloatBar for indicating the progress (or if you like
        programming event-driven functions you may be able to write the re-
        indexing as background process).

@ENDNODE
@NODE "IDX_InsertKey" "database.library/IDX_InsertKey()"
@{b}

 NAME@{ub}
        IDX_InsertKey - add a new key to the index@{b}

 SYNOPSIS@{ub}
        BOOL IDX_InsertKey (@{"struct IDXHeader" LINK "include/Index.h/File" 71} *, @{"struct DataServer" LINK "include/DataServer.h/File" 95} *)
        success = IDX_InsertKey (ihd, server)
           D0                    A0   A1@{b}

 FUNCTION@{ub}
        This function inserts a key for the current row of the specified
        DataServer into the index. It only performs a test, if an entry with
        the same key-value is already inserted into the index, if the index
        is created using the Tag @{"IDX_Unique" LINK "include/Index.h/File" 161}.@{b}

 INPUTS@{ub}
        ihd - a pointer to the IDXHeader structure of the index, the index should
              be created with the custom-flag (using the Tag @{"IDX_Custom" LINK "include/Index.h/File" 163})
        server - a pointer to a DataServer structure. The key that should be
              inserted is the one, that references the current record of this
              server.@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned.
        If the function fails, FALSE is returned, the cause of the failure is
        stored in the 'DataServer.LastError' field of the specified DataServer.@{b}

 NOTE@{ub}
        You should enclose this function-call by a call to the
        @{"IDX_StartTransaction()" LINK "IDX_StartTransaction"}/@{"IDX_EndTransaction()" LINK "IDX_EndTransaction"} function-pair to
        avoid conflicts with other instances accessing this index.

@ENDNODE
@NODE "IDX_KeyCount" "database.library/IDX_KeyCount()"
@{b}

 NAME@{ub}
        IDX_KeyCount - count the keys in an index@{b}

 SYNOPSIS@{ub}
        ULONG IDX_KeyCount (@{"struct IDXHeader" LINK "include/Index.h/File" 71} *)
        numKeys = IDX_KeyCount (ihd)
           D0                   A0@{b}

 FUNCTION@{ub}
        This function counts the number of keys stored in the index.
        If a scope is set, only the keys inside of the scope are count.

        This is a quite slow operation, because every key in the index is
        touched by this function.@{b}

 INPUT@{ub}
        ihd - a pointer to the IDXHeader structure of the index@{b}

 RESULT@{ub}
        This function returns the number of keys stored in the index.

@ENDNODE
@NODE "IDX_KeyLength" "database.library/IDX_KeyLength()"
@{b}

 NAME@{ub}
        IDX_KeyLength - Get the length of a key produced by an expression@{b}

 SYNOPSIS@{ub}
        UWORD IDX_KeyLength (@{"struct DataServer" LINK "include/DataServer.h/File" 95} *, UBYTE *)
        keyLength = IDX_KeyLength (server, keyExpr)
           D0                        A0      A1@{b}

 FUNCTION@{ub}
        This function has to be called after a key-expression has been pre-
        compiled to calculate the length of the key-value that will be
        "produced" by this expression.

        Another benefit of this function is, that it tests if the resulting
        expression is valid, i.e. if the referenced columns of the DataServer
        are of the expected type and the structure of the expression is valid.

        The length of a keyvalue cannot exceed 256 bytes, otherwise this
        function will fail and return zero.@{b}

 INPUT@{ub}
        server - a pointer to the DataServer structure of the DataServer whichs
              data should be retrieved.
        keyExpr - a pointer to the preprocessed expression of a key.@{b}

 RESULT@{ub}
        If the expression is valid, the length of the resulting keyvalue is
        returned, else zero is returned.

@ENDNODE
@NODE "IDX_PreCompileExpression" "database.library/IDX_PreCompileExpression()"
@{b}

 NAME@{ub}
        IDX_PreCompileExpression - precompile a key-expression@{b}

 SYNOPSIS@{ub}
        LONG IDX_PreCompileExpression (UBYTE *, UBYTE *, ULONG)
        bytesCopied = IDX_PreCompileExpression (server, keyExpr, buffer, bufSize)
            D0                                    A0      A1       A2       D0@{b}

 FUNCTION@{ub}
        This function is used to precompile a key-expression. Precompiled
        expressions are shorter than the not-compiled ones and kann be faster
        interpreted.@{b}

 INPUTS@{ub}
        server - a pointer to the DataServers DataServer structure.
        keyExpr - a pointer to the NUL-terminated string with the expression to
                 be processed
        buffer - the destination buffer, where the compiled expression should be
                 copied into
        bufSize - the size of the destination buffer. This buffer should be as
                 large as the length of the 'keyExpr' string (plus 2 bytes).@{b}

 RESULT@{ub}
        If the function succeeds, the number of bytes copied into the buffer
        is returned, else -1 is returned.

@ENDNODE
@NODE "IDX_ReIndex" "database.library/IDX_ReIndex()"
@{b}

 NAME@{ub}
        IDX_ReIndex - recreate the whole index.@{b}

 SYNOPSIS@{ub}
        BOOL IDX_ReIndex (@{"struct IDXHeader" LINK "include/Index.h/File" 71} *, @{"struct DataServer" LINK "include/DataServer.h/File" 95} *,
                                            @{"REINDEX_PROGRESS" LINK "include/FunctionTypes.h/File" 54}, APTR)
        success = IDX_ReIndex (ihd, server, fct, userData)
          D0                   A0   A1  A2      A3@{b}

 FUNCTION@{ub}
        This function clears all keys stored in the index and creates a new key
        for every record in the specified DataServer. Take care that you have
        exclusive access to the DataServer to avoid conflicts with other
        instances accessing this DataServer (resp. its DataBase).

        If the keys of the index are defined as unique, records with dublicate
        keys are silently skipped by this function, i.e. no keyentries for these
        records are inserted into the index.

        This function calls the function @{"IDX_StartTransaction()" LINK "IDX_StartTransaction"} at the begin and
        @{"IDX_EndTransaction()" LINK "IDX_EndTransaction"} at the end if the index is not already locked, so
        you need not to enclosed this function by that function-pair. But it is
        save to call this function with a locked index.@{b}

 INPUTS@{ub}
        ihd - a pointer to the IDXHeader structure of the index. This index must
              not be attached to the server, or this operation will fail.
              If the index is not empty, you must have exclusive access to this
              index, i.e. no other FileHandle to the index-file must be opened
              (the FileHandle of this instance needs not to be opened with
              exclusive access, the function DBF_ClearIndex() will temporary
              change the mode, if required).
        server - a pointer to the DataServer, whichs records should be indexed.
              You should take care, that the server is not used by any other
              instance (you should have exclusive access) or this operation may
              fail to read the data of every record.
        fct - a pointer to a function called everytime ten records are indexed.
              If NULL is passed for this argument, the progress of this function
              is not visible or abortable.
              The function has to expect three arguments:
                    - a pointer to the IDXHeader structure of this index
                    - the number of records already processed
                    - a pointer to user-defined data.
              The function has to return a boolean value, if FALSE is returned,
              the indexing is aborted.
        userData - a pointer to any data, that is passed as second argument to
              the callback function.@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned.
        If the function fails, FALSE is returned.@{b}

 NOTES@{ub}
        If the accessed DataServer is an instance of DataTable, you have to take
        care that the server doesn't processes deleted record:
                          @{"DBF_ShowDeleted" LINK "DBF_ShowDeleted"} (server,FALSE)
        otherwise, these records will occure in the created index. If these
        records are overwritten during the insertion of new records, these new
        records would be accessed by these wrong key-entries.

        The current record of the DataServer is undefined after this function
        returned.

        You should not have any relations from other DataServers to this server,
        otherwise this will result in unnecessary I/O done to synchronize these
        servers.

        You should not have any index attached to the DataServer to prevent
        unneccessary I/O, otherwise every attached index would be positioned to
        the current record on every skip through the DataTable.@{b}

 KNOWN BUGS@{ub}
        This function calls the function @{"IDX_ClearIndex()" LINK "IDX_ClearIndex"} to clear the index
        before it is reindexed. See KNOWN BUGS for that function to get knowledge
        of possible problems and their solution.@{b}

 WORKAROUND@{ub}
        The easiest way to supress any problems using this function, is to use
        it not ;-). You should use the function from the DataTable @{"DBF_ReIndex()" LINK "DBF_ReIndex"}
        instead. This function hides all problems to the user and in the worst
        case the reindexed index isn't opened any more, after the function
        returned, but your application will not die.

@ENDNODE
@NODE "IDX_RemoveKey" "database.library/IDX_RemoveKey()"
@{b}

 NAME@{ub}
        IDX_RemoveKey - Remove the last accessed key from the index@{b}

 SYNOPSIS@{ub}
        BOOL IDX_RemoveKey (@{"struct IDXHeader" LINK "include/Index.h/File" 71} *)
        success = IDX_RemoveKey (ihd)
          D0                     A0@{b}

 FUNCTION@{ub}
        This function removes the key that was last accessed (e.g. using
        @{"IDX_Seek()" LINK "IDX_Seek"} or @{"IDX_FindKey()" LINK "IDX_FindKey"}) from the index.
        After the key is removed, the index is positioned on the successor of
        this key, so you could loop-call this function to remove any number of
        keys from the index.@{b}

 INPUT@{ub}
        ihd - a pointer to the IDXHeader structure of the index, the index should
              be created with the custom-flag (using the Tag @{"IDX_Custom" LINK "include/Index.h/File" 163})@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned.
        If the function fails, FALSE is returned.@{b}

 NOTE@{ub}
        You should enclose this function-call by a call to the
        @{"IDX_StartTransaction()" LINK "IDX_StartTransaction"}/@{"IDX_EndTransaction()" LINK "IDX_EndTransaction"} function-pair to
        avoid conflicts with other instances accessing this index.@{b}

 KNOWN BUGS@{ub}
        The setting of the flag @{"IDX_DESCEND" LINK "include/Index.h/File" 170} is not taken into account by this
        function, it will always position to the next key-entry, as if the flag
        is not set.

@ENDNODE
@NODE "IDX_Seek" "database.library/IDX_Seek()"
@{b}

 NAME@{ub}
        IDX_Seek - search a key in the index@{b}

 SYNOPSIS@{ub}
        ULONG IDX_Seek (@{"struct IDXHeader" LINK "include/Index.h/File" 71} *, APTR, BOOL)
        recNo = IDX_Seek (ihd, key, softSeek)
          D0              A0   A1      D0@{b}

 FUNCTION@{ub}
        This function tries to locate the entry with the specified key in the
        index and returns the number of the according row in the DataServer.

        If the index is not unique and there are two or more entries matching
        the key, the record number of the first one of these entries is returned
        so this function could be followed by a loop-call to
              @{"IDX_SeekNext" LINK "IDX_SeekNext"} (ihd, key, TRUE)
        to get access to all records that match this key.@{b}

 INPUTS@{ub}
        ihd - a pointer to the IDXHeader structure of the index
        key - a pointer to the buffer, where the keyvalue is stored, usually
              created by @{"IDX_EvalExpression()" LINK "IDX_EvalExpression"}, @{"IDX_GetKeyValue()" LINK "IDX_GetKeyValue"}, or
              IDX_KeyCreate(). This may be the 'KeyValue' buffer in the
              IDXKeyEntry structure referenced by the 'CurrentKey' pointer of
              the IDXHeader structure.
        softSeek - a boolean value, if this argument is TRUE, the search stops at
              the first entry with a keyvalue greater or equal the specified key,
              otherwise the search will only stop if a exact matching value is
              found.@{b}

 RESULT@{ub}
        If the specified key is found in the index, the number of the according
        row in the DataServer is returned, else zero is returned.@{b}

 NOTE@{ub}
        You should enclose this function-call by a call to the
        @{"IDX_StartTransaction()" LINK "IDX_StartTransaction"}/@{"IDX_EndTransaction()" LINK "IDX_EndTransaction"} function-pair to
        avoid conflicts with other instances accessing this index.

@ENDNODE
@NODE "IDX_SeekNext" "database.library/IDX_SeekNext()"
@{b}

 NAME@{ub}
        IDX_SeekNext - search a key in the index starting at the current position@{b}

 SYNOPSIS@{ub}
        ULONG IDX_SeekNext (@{"struct IDXHeader" LINK "include/Index.h/File" 71} *, APTR, BOOL)
        recNo = IDX_SeekNext (ihd, key, softSeek)
          D0                  A0   A1      D0@{b}

 FUNCTION@{ub}
        This function tries to locate the entry with the specified key in the
        index starting at the current position and returns the number of the
        according row in the DataServer.

        You should search the first matching record using the function @{"IDX_Seek()" LINK "IDX_Seek"}
        because that function is quite faster for this purpose.@{b}

 INPUTS@{ub}
        ihd - a pointer to the IDXHeader structure of the index
        key - a pointer to the buffer, where the keyvalue is stored, usually
              created by @{"IDX_EvalExpression()" LINK "IDX_EvalExpression"}, @{"IDX_GetKeyValue()" LINK "IDX_GetKeyValue"}, or
              IDX_KeyCreate(). This may be the 'KeyValue' buffer in the
              IDXKeyEntry structure referenced by the 'CurrentKey' pointer of
              the IDXHeader structure.
        softSeek - a boolean value, if this argument is TRUE, the search stops at
              the first entry with a keyvalue greater or equal the specified key,
              otherwise the search will only stop if a exact matching value is
              found.@{b}

 RESULT@{ub}
        If the specified key is found in the index, the number of the according
        row in the DataServer is returned, else zero is returned.@{b}

 NOTE@{ub}
        You should enclose this function-call by a call to the
        @{"IDX_StartTransaction()" LINK "IDX_StartTransaction"}/@{"IDX_EndTransaction()" LINK "IDX_EndTransaction"} function-pair to
        avoid conflicts with other instances accessing this index.

@ENDNODE
@NODE "IDX_SetScope" "database.library/IDX_SetScope()"
@{b}

 NAME@{ub}
        IDX_SetScope - set or clear an orderscope@{b}

 SYNOPSIS@{ub}
        BOOL IDX_SetScope (@{"struct IDXHeader" LINK "include/Index.h/File" 71} *, APTR, APTR)
        success = IDX_SetScope (ihd, topScope, bottomScope)
          D0                    A0      A1          A2@{b}

 FUNCTION@{ub}
        This function sets or clears an orderscope. This scope is the range, the
        indes is operating in, i.e. only keys that are inside of this scope can
        be accessed (except for insertion or deletion).@{b}

 INPUTS@{ub}
        ihd - a pointer to the IDXHeader structure of the index
        topScope - a pointer to the keyvalue of the key that should be handled as
                    topmost key in the index. If NULL is passed for this argument
                    the top border of the scope is cleared, i.e. the topmost key
                    of the index is the top border.
        bottomScope - a pointer to the keyvalue of the key that should be handled as
                    lowest key in the index. If NULL is passed for this argument
                    the bottom border of the scope is cleared, i.e. the lowest key
                    of the index is the bottom border.
                    If both -- 'topScope' and 'bottomScope' -- are specified the
                    'topScope' has to be equal to 'bottomScope' or a keyvalue
                    that is ordered before 'bottomScope'@{b}

 RESULT@{ub}
        If the function succeeds, TRUE is returned. You should do an
        "inplace-skip" (i.e. call @{"IDX_SkipNext()" LINK "IDX_SkipNext"} with zero records to be skipped)
        to evaluate, if the previously current key is still valid, i.e. if it is
        inside of the scope. If the previously current key is not inside of the
        scope, it is cleared, i.e. @{"IDX_SkipNext()" LINK "IDX_SkipNext"} will fail.
        If the function fails (system is VERY low on memory or the specified
        'topScope' is ordered behind 'bottomScope'), FALSE is returned.

@ENDNODE
@NODE "IDX_SkipBottom" "database.library/IDX_SkipBottom()"
@{b}

 NAME@{ub}
        IDX_SkipBottom - skip to the last key stored in the index@{b}

 SYNOPSIS@{ub}
        ULONG IDX_SkipBottom (@{"struct IDXHeader" LINK "include/Index.h/File" 71} *)
        recordNumber = IDX_SkipBottom (ihd)
             D0                        A0@{b}

 FUNCTION@{ub}
        This function returns the number of the record in the DataBase according
        to the last key stored in the index respectively the last key found
        inside the set scope.@{b}

 INPUT@{ub}
        ihd - a pointer to the IDXHeader structure of the index@{b}

 RESULT@{ub}
        The record-number of the row in the DataServer according to the last
        key in this index is returned, or zero if no key is stored in this index.@{b}

 NOTE@{ub}
        You should enclose this function-call by a call to the
        @{"IDX_StartTransaction()" LINK "IDX_StartTransaction"}/@{"IDX_EndTransaction()" LINK "IDX_EndTransaction"} function-pair to
        avoid conflicts with other instances accessing this index.

@ENDNODE
@NODE "IDX_SkipNext" "database.library/IDX_SkipNext()"
@{b}

 NAME@{ub}
     IDX_SkipNext - skip a number of keys to the bottom of the index@{b}

 SYNOPSIS@{ub}
     ULONG IDX_SkipNext (@{"struct IDXHeader" LINK "include/Index.h/File" 71} *, ULONG)
     recordNumber = IDX_SkipNext (ihd, numKeys)
          D0                      A0     D0@{b}

 FUNCTION@{ub}
     This function can be used to skip a specified number of keys down to the
     bottom of the index, e.g. a call to @{"IDX_SkipBottom()" LINK "IDX_SkipBottom"} followed by a loop
     of calls to this function can be used to get the record-numbers of all
     records referenced by this index in the order they are stored.@{b}

 INPUTS@{ub}
     ihd - a pointer to the IDXHeader structure of the index
     numKeys - the number of keys that should be skipped@{b}

 RESULT@{ub}
     The record-number of the record in the DataBase according to the key in
     this index that is the specified number of keys down to the bottom of
     the index is returned, or zero if the last key in the index is passed.@{b}

 NOTE@{ub}
     You should enclose this function-call by a call to the
     @{"IDX_StartTransaction()" LINK "IDX_StartTransaction"}/@{"IDX_EndTransaction()" LINK "IDX_EndTransaction"} function-pair to
     avoid conflicts with other instances accessing this index.

@ENDNODE
@NODE "IDX_SkipPrevious" "database.library/IDX_SkipPrevious()"
@{b}

 NAME@{ub}
        IDX_SkipPrevious - skip a number of keys to the top of the index@{b}

 SYNOPSIS@{ub}
        ULONG IDX_SkipPrevious (@{"struct IDXHeader" LINK "include/Index.h/File" 71} *, ULONG)
        recordNumber = IDX_SkipPrevious (ihd, numKeys)
             D0                          A0     D0@{b}

 FUNCTION@{ub}
        This function can be used to skip a specified number of keys up to the
        top of the index, e.g. a call to @{"IDX_SkipBottom()" LINK "IDX_SkipBottom"} followed by a loop
        of calls to this function can be used to get the record-numbers of all
        records referenced by this index in the reverse order.@{b}

 INPUTS@{ub}
        ihd - a pointer to the IDXHeader structure of the index
        numKeys - the number of keys that should be skipped@{b}

 RESULT@{ub}
        The record-number of the row in the DataServer according to the key in
        this index that is the specified number of keys up to the top of the
        index is returned, or zero if the first key in the index is passed.@{b}

 NOTE@{ub}
        You should enclose this function-call by a call to the
        @{"IDX_StartTransaction()" LINK "IDX_StartTransaction"}/@{"IDX_EndTransaction()" LINK "IDX_EndTransaction"} function-pair to
        avoid conflicts with other instances accessing this index.

@ENDNODE
@NODE "IDX_SkipTop" "database.library/IDX_SkipTop()"
@{b}

 NAME@{ub}
        IDX_SkipTop - skip to the first key stored in the index@{b}

 SYNOPSIS@{ub}
        ULONG IDX_SkipTop (@{"struct IDXHeader" LINK "include/Index.h/File" 71} *)
        recordNumber = IDX_SkipTop (ihd)
             D0                     A0@{b}

 FUNCTION@{ub}
        This function returns the number of the row in the DataServer according
        to the first key stored in the index respectively the first key found
        inside the set scope.@{b}

 INPUT@{ub}
        ihd - a pointer to the IDXHeader structure of the index@{b}

 RESULT@{ub}
        The record-number of the row in the DataServer according to the first
        key in this index is returned, or zero if no key is stored in this index.@{b}

 NOTE@{ub}
        You should enclose this function-call by a call to the
        @{"IDX_StartTransaction()" LINK "IDX_StartTransaction"}/@{"IDX_EndTransaction()" LINK "IDX_EndTransaction"} function-pair to
        avoid conflicts with other instances accessing this index.

@ENDNODE
@NODE "IDX_StartTransaction" "database.library/IDX_StartTransaction()"
@{b}

 NAME@{ub}
        IDX_StartTransaction - prepare the index for a read or write access@{b}

 SYNOPSIS@{ub}
        BOOL IDX_StartTransaction (@{"struct IDXHeader" LINK "include/Index.h/File" 71} *, LONG)
        success = IDX_StartTransaction (ihd, accessType)
          D0                            A0       D0@{b}

 FUNCTION@{ub}
        In a multiuser (or multitasking) environment this function has to be
        called, immediately before any access to the index is performed to
        prevent other processes from changing (or reading) the index until
        the access has finished. Only if this function succeeds, the desired
        access should be performed.

        This function could only be called once, additonal calls will fail until
        the matching @{"IDX_EndTransaction()" LINK "IDX_EndTransaction"} is called, the resulting errorcode
        will be set to ERROR_LOCK_COLLISION;

        The function tests, if the index-file has been changed (by another
        instance of this index) since the last access and discards all currently
        cached pages in that case.@{b}

 INPUTS@{ub}
        ihd - a pointer to the IDXHeader structure of the index
        accessType - the type of access that should be performed. This could
                 be either
                    @{"IDX_READ" LINK "include/Index.h/File" 187} - for read-only accesses
                    @{"IDX_WRITE" LINK "include/Index.h/File" 188} - for read-write accesses@{b}

 RESULT@{ub}
        If the desired access could be performed, the index is locked and TRUE
        is returned. In this case the function @{"IDX_EndTransaction()" LINK "IDX_EndTransaction"} has to be
        called after the access has finished to unlock the index again, so
        other instances could read or write the index.
        If the function failes, FALSE is returned. See IoErr() for an according
        AmigaDos errorcode.@{b}

 BUGS@{ub}
        On success IoErr() is not cleared.

@ENDNODE
@NODE "IDX_ValidKey" "database.library/IDX_ValidKey()"
@{b}

 NAME@{ub}
        IDX_ValidKey - determine if the index is positioned at any entry@{b}

 SYNOPSIS@{ub}
        BOOL IDX_ValidKey (@{"struct IDXHeader" LINK "include/Index.h/File" 71} *)
        isValid = IDX_ValidKey (ihd)
          D0                    A0@{b}

 FUNCTION@{ub}
        This function determines if the index is positioned at an entry or not,
        i.e. if the functions @{"IDX_SeekNext()" LINK "IDX_SeekNext"}, @{"IDX_SkipNext()" LINK "IDX_SkipNext"}, @{"IDX_SkipPrevious()" LINK "IDX_SkipPrevious"},
        and @{"IDX_RemoveKey()" LINK "IDX_RemoveKey"} could succeed.

        This function is usually called after a successfull call to the
        function @{"IDX_StartTransaction()" LINK "IDX_StartTransaction"}, because that function will clear the
        current entry, if the index-file has been changed by another instance
        of this index.

        If this function fails, but your DataServer is positioned at a valid
        record, which should have a matching entry in this index, you have to
        call @{"IDX_FindKey()" LINK "IDX_FindKey"} before any of the functions named above is called.@{b}

 INPUT@{ub}
        ihd - a pointer to the IDXHeader structure of the index@{b}

 RESULT@{ub}
        If the index is positioned on a valid entry, TRUE is returned, else
        FALSE is returned.

@ENDNODE
@NODE "LToS" "database.library/LToS()"
@{b}

 NAME@{ub}
        LToS - convert a logic value into a string@{b}

 SYNOPSIS@{ub}
        BOOL LToS (APTR, UBYTE *)
        isTrue = LToS (logic, str)
          D0             A0   A1@{b}

 FUNCTION@{ub}
        This function converts a logic value as stored in a column of a
        DataServer into the string "true" or "false".@{b}

 INPUTS@{ub}
        logic - a pointer to a logic value as stored in a DataServer
        str - a pointer to the destination buffer, where the resulting string
              is copied into; this buffer has to be at least 6 bytes large.@{b}

 RESULT@{ub}
        If the specifed logic value is 'true', TRUE is returned, else FALSE
        is returned.

@ENDNODE
@NODE "Numeric2DOUBLELONG" "database.library/Numeric2DOUBLELONG()"
@{b}

 NAME@{ub}
        Numeric2DOUBLELONG - convert a @{"NUMERIC" LINK "include/Numeric.h/File" 43} value into a DOUBLELONG@{b}

 SYNOPSIS@{ub}
        BOOL Numeric2DOUBLELONG (UBYTE *, UWORD, UWORD, UWORD, DOUBLELONG *)
        valid = Numeric2DOUBLELONG (num, length, decimals, exponent, val)
         D0                         A0    D0:16   D1:16     D2:16    A1@{b}

 FUNCTION@{ub}
        This function converts a @{"NUMERIC" LINK "include/Numeric.h/File" 43} value (a fixed point decimal value)
        into a DOUBLELONG.
        Convertions between @{"NUMERIC" LINK "include/Numeric.h/File" 43} and DOUBLELONG are required for doing any
        arithmetic operations with @{"NUMERIC" LINK "include/Numeric.h/File" 43} values.@{b}

 INPUTS@{ub}
        num - a pointer to the @{"NUMERIC" LINK "include/Numeric.h/File" 43} value. This value is 'length' bytes long,
              the first byte is the sign: either '+' or '-', optional followed
              by zeros '\\0' and than followed by the digits of the @{"NUMERIC" LINK "include/Numeric.h/File" 43} value
              without a comma. This value is usually not NUL-terminated
        length - the length of the whole @{"NUMERIC" LINK "include/Numeric.h/File" 43} value inclusive its sign (<= 18)
        decimals - the number of digits at the end of the value, that are
              representing the part behind the comma. There have to be at least
              'decimals' + 1 digits in the passed @{"NUMERIC" LINK "include/Numeric.h/File" 43} value; 'decimals' MUST
              be at least two lower than 'length'.
        exponent - this value represents the exponent to the base 10, that should
              be multiplied with the @{"NUMERIC" LINK "include/Numeric.h/File" 43} value before convertion. Beware of
              overflows.
              The resulting part behind the comma is rounded up.
        val - a pointer to the DOUBLELONG, where the result should be stored.@{b}

 RESULT@{ub}
        If the @{"NUMERIC" LINK "include/Numeric.h/File" 43} value is valid and could be converted, TRUE is returned.
        If the passed value is not valid or an overflow occures, FALSE is
        returned.

@ENDNODE
@NODE "Numeric2Str" "database.library/Numeric2Str()"
@{b}

 NAME@{ub}
        Numeric2Str - create a string representing a @{"NUMERIC" LINK "include/Numeric.h/File" 43}@{b}

 SYNOPSIS@{ub}
        BOOL Numeric2Str (UBYTE *, UWORD, UWORD, STRPTR)
        valid = Numeric2Str (num, length, decimals, str)
         D0                  A0    D0:16    D1:16   A1@{b}

 FUNCTION@{ub}
        This function creates a string representing the specified @{"NUMERIC" LINK "include/Numeric.h/File" 43}.@{b}

 INPUTS@{ub}
        num - a pointer to the @{"NUMERIC" LINK "include/Numeric.h/File" 43} value. This value is 'length' bytes long,
              the first byte is the sign: either '+' or '-', optional followed
              by zeros '\\0' and than followed by the digits of the @{"NUMERIC" LINK "include/Numeric.h/File" 43} value
              without a comma. This value is usually not NUL-terminated
        length - the length of the whole @{"NUMERIC" LINK "include/Numeric.h/File" 43} value inclusive its sign (<= 18)
        decimals - the number of digits at the end of the value, that are
              representing the part behind the comma. There have to be at least
              'decimals' + 1 digits in the passed @{"NUMERIC" LINK "include/Numeric.h/File" 43} value; 'decimals' MUST
              be at least two lower than 'length'.
        str - a pointer to the destination buffer for the resulting string. This
              buffer has to be at least 'length' + 2 bytes large.@{b}

 RESULT@{ub}
        If the @{"NUMERIC" LINK "include/Numeric.h/File" 43} value is valid and could be converted, TRUE is returned.
        If the passed value is not valid or an overflow occures, FALSE is
        returned.@{b}

 BUGS@{ub}
        The function doesn't tests if the input is valid, instead the function
        always returns TRUE. The resulting string of an invalid @{"NUMERIC" LINK "include/Numeric.h/File" 43} is
        undefined and might look strange.

@ENDNODE
@NODE "NumericIntDigits" "database.library/NumericIntDigits()"
@{b}

 NAME@{ub}
        NumericIntDigits - number of digits of the integer part of a @{"NUMERIC" LINK "include/Numeric.h/File" 43}@{b}

 SYNOPSIS@{ub}
        UWORD NumericIntDigits (UBYTE *, UWORD, UWORD)
        numDigitis = NumericIntDigits (num, length, decimals)
          D0:16                        A0    D0:16    D1:16@{b}

 FUNCTION@{ub}
        This function counts the number of digits that represent the integer part
        of a @{"NUMERIC" LINK "include/Numeric.h/File" 43} value (i.e. the digits that are located in front of the
        comma sign.@{b}

 INPUTS@{ub}
        num - a pointer to the @{"NUMERIC" LINK "include/Numeric.h/File" 43} value. This value is 'length' bytes long,
              the first byte is the sign: either '+' or '-', optional followed
              by zeros '\\0' and than followed by the digits of the @{"NUMERIC" LINK "include/Numeric.h/File" 43} value
              without a comma. This value is usually not NUL-terminated
        length - the length of the whole @{"NUMERIC" LINK "include/Numeric.h/File" 43} value inclusive its sign (<= 18)
        decimals - the number of digits at the end of the value, that are
              representing the part behind the comma. There have to be at least
              'decimals' + 1 digits in the passed @{"NUMERIC" LINK "include/Numeric.h/File" 43} value; 'decimals' MUST
              be at least two lower than 'length'.@{b}

 RESULT@{ub}
        The number of digits of the integer part of the specified @{"NUMERIC" LINK "include/Numeric.h/File" 43} is
        returned or zero, if the specified @{"NUMERIC" LINK "include/Numeric.h/File" 43} is not valid.

@ENDNODE
@NODE "RAtChr" "database.library/RAtChr()"
@{b}

 NAME@{ub}
        RAtChr - search the last occurance of a character@{b}

 SYNOPSIS@{ub}
        ULONG RAtChr (UBYTE *, UBYTE, ULONG)
        position = RAtChr (string, character, slen)
           D0                 A0     D0:8       D1@{b}

 FUNCTION@{ub}
        This function searches the last occurance of the specified character
        in the string.@{b}

 INPUTS@{ub}
        string - a pointer to the string
        character - the character searched in the string
        slen - the length of the string@{b}

 RESULT@{ub}
        The position of the last occurance of the character in the string is
        returned, or 0 if the character is not found.

@ENDNODE
@NODE "STR" "database.library/STR()"
@{b}

 NAME@{ub}
        STR - generate a string according to a DOUBLELONG value@{b}

 SYNOPSIS@{ub}
        UBYTE *STR (DOUBLELONG *, UBYTE, UWORD)
        string = STR (val, padByte, slen)
          D0          A0    D0:8    D1:16@{b}

 FUNCTION@{ub}
        This function creates a string according to the specified DOUBLELONG
        value. A new buffer of 'slen' bytes in length is allocated for the
        string, where the generated string is copied into.
        The string is usually right aligned, the empty left bytes are filled
        with the specified 'padByte'. If the 'padByte' is zero, the string is
        left aligned in the buffer.@{b}

 INPUTS@{ub}
        val - a pointer to the DOUBLELONG value
        padByte - the byte-value that should be used to fill the empty left bytes
        slen - the number of characters the resulting string should have. If the
              the resulting string is longer than this number of bytes -- i.e.
              an overflow occures -- the string will be 'slen' characters wide,
              all characters are set to '9'.@{b}

 RESULT@{ub}
        A pointer to the new allocated buffer of 'slen' bytes containing the
        string is returned. This buffer has to be freed using FreeMem() after
        usage.

@ENDNODE
@NODE "SToD" "database.library/SToD()"
@{b}

 NAME@{ub}
        SToD - convert a human readable string representing a date into a date@{b}

 SYNOPSIS@{ub}
        BOOL SToD (UBYTE *, APTR)
        valid = SToD (dateStr, dateVal)
          D0            A0       A1@{b}

 FUNCTION@{ub}
        This function converts a date specified as human readable string into a
        date as stored in a DataServer.@{b}

 INPUTS@{ub}
        dateStr - a NUL-terminated C-string containing the date in FORMAT_DOS
                 "dd-mmm-yy" or "dd-mmm-yyyy", "dd-mm-yy", or "dd-mm-yyyy".
                 Where 'mmm' is the shortname of the month (e.g. "Dec") and 'mm'
                 is the number of the month (e.g. "12"). The year has to be any
                 year after 1582 A.D..
        dateVal - a pointer to the destination buffer, where the converted date
                 should be stored. This buffer has to be at least 8 bytes large.@{b}

 RESULT@{ub}
        If the specified string represents a valid date, TRUE is returned, else
        FALSE is returned.

@ENDNODE
@NODE "SToL" "database.library/SToL()"
@{b}

 NAME@{ub}
        SToL - convert a string to a logic value@{b}

 SYNOPSIS@{ub}
        BOOL SToL (UBYTE *, APTR)
        isTrue = SToL (str, logic)
          D0           A0     A1@{b}

 FUNCTION@{ub}
        This function converts a string into a logic value as stored in a
        column of a DataServer.
        This function is able to interpret the strings (case-independent):
           'T', 'True', 'Y', 'Yes', 'On', 'J', and 'Ja'
        as 'true' values. All other strings are interpreted as 'false'.@{b}

 INPUTS@{ub}
        str - a pointer to the string to be interpreted. If NULL is passed
              for this argument, it is interpreted as 'false'.
        logic - a pointer to destination buffer, where the accoding logic
              value is stored; the value 'T' will be stored for a 'true'
              string, 'F' is stored for any other input. This buffer has to
              be at least 1 byte large.@{b}

 RESULT@{ub}
        If the specifed string is 'true', TRUE is returned, else FALSE is
        returned.

@ENDNODE
@NODE "SToT" "database.library/SToT()"
@{b}

 NAME@{ub}
        SToT - convert a time-string into a time-value@{b}

 SYNOPSIS@{ub}
        BOOL SToT (UBYTE *, ULONG *)
        validTime = SToT (timeStr, timeVal)
           D0                A0       A1@{b}

 FUNCTION@{ub}
        This function converts a time-string in the format 'HH:MM:SS.mmm' into
        a time-value, i.e. the number of milliseconds elapsed since midnight.@{b}

 INPUTS@{ub}
        timeStr - a pointer to time-stirng. This must be either full qualified,
              i.e. in the format 'HH:MM:SS.mmm' with every part present, or a
              NUL-terminated C-string, where the format can be terminated after
              every part (e.g. 'HH:MM:SS' or 'HH:MM' or 'HH')
        timeVal - a pointer to the destination address, where the resulting
              time-value should be stored.@{b}

 RESULT@{ub}
        If the passed time-string is valid, TRUE is returned, the according
        time-value is stored in the specified address, else FALSE is returned,
        the value in the destination address is not changed.

@ENDNODE
@NODE "SkipChars" "database.library/SkipChars()"
@{b}

 NAME@{ub}
        SkipChars - skip characters at the begin of a string@{b}

 SYNOPSIS@{ub}
        LONG SkipChars (UBYTE *, UBYTE, LONG)
        charsSkipped = SkipChars (string, character, slen)
            D0                      A0     D0:8       D1@{b}

 FUNCTION@{ub}
        This function skips all characters at the begin of the string that match
        the specified character.@{b}

 INPUTS@{ub}
        string - a pointer to the string, where the characters should be skipped.
        character - the character that should be skipped
        slen - the maximum number of characters that might be skipped@{b}

 RESULT@{ub}
        The number of characters skipped is returned.

@ENDNODE
@NODE "Str2Numeric" "database.library/Str2Numeric()"
@{b}

 NAME@{ub}
        Str2Numeric - convert a string into a @{"NUMERIC" LINK "include/Numeric.h/File" 43}@{b}

 SYNOPSIS@{ub}
        BOOL Str2Numeric (STRPTR, UBYTE *, UWORD, UWORD)
        valid = Str2Numeric (str, num, length, decimals)
         D0                  A0   A1    D0:16    D1:16@{b}

 FUNCTION@{ub}
        This function copies the @{"NUMERIC" LINK "include/Numeric.h/File" 43} value according to the specified string
        into the buffer of a @{"NUMERIC" LINK "include/Numeric.h/File" 43}.@{b}

 INPUTS@{ub}
        str - a pointer to the string that represents the @{"NUMERIC" LINK "include/Numeric.h/File" 43} value. If NULL
              is passed for this argument, the @{"NUMERIC" LINK "include/Numeric.h/File" 43} value representing zero
              is generated.
        num - a pointer to the buffer for the @{"NUMERIC" LINK "include/Numeric.h/File" 43} value. This buffer has to
              be 'length' bytes large.
        length - the length of the whole @{"NUMERIC" LINK "include/Numeric.h/File" 43} value inclusive its sign (<= 18)
        decimals - the number of digits at the end of the value, that are
              representing the part behind the comma. There have to be at least
              'decimals' + 1 digits in the passed @{"NUMERIC" LINK "include/Numeric.h/File" 43} value; 'decimals' MUST
              be at least two lower than 'length'.@{b}

 RESULT@{ub}
        If the specified string could be successfully converted to a @{"NUMERIC" LINK "include/Numeric.h/File" 43},
        TRUE is returned, else FALSE is returned.

@ENDNODE
@NODE "TToS" "database.library/TToS()"
@{b}

 NAME@{ub}
        TToS - convert a time-value into a human-readable string@{b}

 SYNOPSIS@{ub}
        BOOL TToS (ULONG, UBYTE *)
        success = TToS (timeVal, timeStr)
           D0              D0      A0@{b}

 FUNCTION@{ub}
        This function converts a time-value in a range of 24 Hours into a string
        representing this time in a human readable form: 'HH:MM:SS.mmm'
        where 'HH' are the number of hours (0 - 23)
              'MM' are the number of minutes (0 - 59)
              'SS' are the number of seconds (0 - 59)
              'mmm' are the number of milliseconds (0 - 999)

        THE STRING WILL NOT BE NUL-TERMINATED !@{b}

 INPUTS@{ub}
        timeVal - the time-value, i.e. the number of milliseconds elapsed since
                 midnight
        timeStr - a pointer to the destination buffer, which has to be at least
                 12 bytes long.@{b}

 RESULT@{ub}
        If the passed value is a time-value between 00:00:00.000 and 23:59:59.999
        the function will return TRUE, if the buffer contains the time in human
        readable form, else FALSE is returned to indicate an invalid time-value.

@ENDNODE
