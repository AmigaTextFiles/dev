@database database-library.guide

@$VER: database-library.guide 1.0 (04.05.04)
@author "Peter Riede"
@(c) "Copyright © 2004 by Peter "Noster" Riede"

This is a document in the AmigaGuide format.  To read it, use either
AmigaGuide, MultiView, or any other AmigaGuide compatible hypertext
browser.

@index Index
@node MAIN "DataBase.library - Contents"

---------------------------------------------------------------------------
                           @{b}@{fg shine}DataBase.library 1.0@{fg text}@{ub}

                   A shared runtime library for creating
                           XBase-alike databases
                       @{fg shine}Copyright © 2004 Peter Riede
                           All Rights Reserved.@{fg text}

                           I hope you like it.
---------------------------------------------------------------------------

   @{" Disclaimer                                         " link Disclaimer}

   @{" Chapter 1,  Introduction                           " link Introduction}
       @{" Quick start                                      " link Quick_start}
       @{" Basics you should know                           " link Basics_you_should_know}
       @{" Open the database.library                        " link Open_the_database.library}
       @{" Error reports                                    " link Error_reports}

   @{" Chapter 2,  Tutorial                               " link Tutorial}
       @{" Create a DataTable                               " link Create_a_DataTable}
       @{" Add Rows to the Table                            " link Add_Rows_to_the_Table}
       @{" Retrieving Data                                  " link Retrieving_Data}
       @{" Skipping through the DataServer                  " link Skipping_through_the_DataServer}
       @{" Get rid of a DataServer                          " link Get_rid_of_a_DataServer}
       @{" AlbumDB                                          " link AlbumDB}

   @{" Chapter 3,  DataServer                             " link DataServer}
       @{" The DataServer structure                         " link The_DataServer_structure}
       @{" Creation of DataServers                          " link Creation_of_DataServers}
       @{" Request performing of operations to a DataServer " link Request_performing_of_operations_to_a_DataServer}
       @{" Operations every DataServer should support       " link Operations_every_DataServer_should_support}

   @{" Chapter 4, DataColumn                              " link DataColumn}
       @{" The DataColumn structure                         " link The_DataColumn_structure}
       @{" Adding DataColumns to a DataServer               " link Adding_DataColumns_to_a_DataServer}
       @{" Removing DataColumns from a DataServer           " link Removing_DataColumns_from_a_DataServer}
       @{" Other functions for DataColumns                  " link Other_functions_for_DataColumns}

   @{" Chapter 5, Indexes                                 " link Indexes}
       @{" Key-expressions and key-values                   " link Key-expressions_and_key-values}
       @{" Converting functions of key-expressions          " link Converting_functions_and_operators_of_key-expressions}
       @{" Functions for parsing key-expressions            " link Functions_for_parsing_key-expressions}
       @{" Creating an index                                " link Creating_an_index}
       @{" Disposing an index                               " link Disposing_an_index}
       @{" The IDXHeader structure                          " link The_IDXHeader_structure}
       @{" Functions for accessing an index                 " link Functions_for_accessing_an_index}
       @{" Navigating through an index                      " link Navigating_through_an_index}
       @{" Functions for changing an index                  " link Functions_for_changing_an_index}

   @{" Chapter 6, DataTable                               " link DataTable}
       @{" Creation of DataTables                           " link Creation_of_DataTables}
       @{" The DataTable structure                          " link The_DataTable_structure}
       @{" The DBStruct structure                           " link The_DBStruct_structure}
       @{" Operations the DataTable supports                " link Operations_the_DataTable_supports}
       @{" Relations between DataTables                     " link Relations_between_DataTables}
       @{" Locking of records                               " link Locking_of_records}
       @{" Functions for managing indexes                   " link Functions_for_managing_indexes_attached_to_the_DataTables}
       @{" Other functions for accessing DataTables         " link Other_functions_for_accessing_DataTables}
       @{" Private functions of the DataTable               " link Private_functions_of_the_DataTable}

   @{" Chapter 7, Memo files                              " link Memo_files}
       @{" The MemoFile structures                          " link The_MemoFile_structures}
       @{" Functions for accessing MemoFiles                " link Functions_for_accessing_MemoFiles}

   @{" Chapter 8, Other functions of the database.library " link Other_functions_of_the_database.library}
       @{" String manipulation functions                    " link String_manipulation_functions}
       @{" Convertion functions                             " link Convertion_functions}
       @{" Convertion macros                                " link Convertion_macros}
       @{" Functions of the link library Database.lib       " link Functions_of_the_link_library Database.lib}
       @{" Functions for processing fixed point numbers     " link Functions_for_processing_fixed_point_numbers}
       @{" Calculating using fixed point numbers            " link Calculating_using_fixed_point_numbers}

   @{" Chapter 9, How to create Databases                 " link How_to_create_Databases}
       @{" Preparation                                      " link Preparation}
       @{" Creating the DataTables                          " link Creating_the_DataTables}
       @{" Indexes                                          " link HOWTO_Indexes}
       @{" Relations                                        " link Relations}
       @{" Last words                                       " link Last_words}

   @{" Appendix A, Implementation details                 " link Implementation_details}
       @{" The file structure of a DataTable file           " link The_file_structure_of_a_DataTable_file}
       @{" The file structure of a memo file                " link The_file_structure_of_a_memo_file}
       @{" The file structure of an index file              " link The_file_structure_of_an_index_file}
       @{" Format of precompiled key-expressions            " link Format_of_precompiled_key-expressions}

   @{" Appendix B, Creating own DataServer subclasses     " link Creating_own_DataServer_subclasses}
       @{" Notes for operations supported by DataServers    " link Notes_for_operations_supported_by_DataServers}
       @{" Subclasses of DataTables                         " link Subclasses_of_DataTables}

   @{" Glossary                                           " link Glossary}
   @{" Index                                              " link Index}
@endnode

@node Disclaimer "DataBase.library - Disclaimer"

@{b}@{fg shine}Disclaimer@{fg text}@{ub}

Copyright © 2004 by Peter "Noster" Riede

Many  of  the designations used by manufacturers and sellers to distinguish
their  products are claimed as trademarks.  Where those designations appear
in  this  document  and  the  author  was  aware  of a trademark claim, the
designations  have  been  printed  in  initial caps.  Amiga is a registered
trademark, AmigaOS, AmigaDOS, exec, Intuition, Kickstart, and Workbench are
trademarks  of  Amiga  Incorporated (or whoever has bought these trademarks
from  them).   dBASE  is  a  registered  trademark  of  dBASE Incorporated.
Microsoft  is  a  registered trademark, Windows is a trademark of Microsoft
Corporation  (this  trademark  may be cleared in the future, because it has
been  declared generic, so it cannot be registered as trademark).  SAS/C is
a   registered  trademark  of  SAS  Institute,  Incorporated.   UNIX  is  a
registered trademark of The Open Group.

This  publication may be free released in electronical form, as part of the
Database.library  distribution  archive,  as long as nothing is delete from
the distribution archive, nothing is added, and no part of the distribution
archive  is  changed.   All  further  rights  are  reserved,  it may not be
modified  (including  translation  from one type of media or file format to
another).

WARNING:   The  information  described in this manual may contain errors or
bugs,  and  may  not  function as described.  All information is subject to
enhancement  or upgrade for any reason including to fix bugs, add features,
or  change performance.  As with all software upgrades, full compatibility,
although a goal, cannot be guranteed, and is in fact unlikely.

DISCLAIMER:   THIS  PUBLICATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
KIND  EITHER  EXPRESSED  OR  IMPLIED,  INCLUDING,  BUT  NOT LIMITED TO, THE
IMPLIED  WARRANTIES  OR  MERCHANTABILITY  AND  FITNESS  FOR  ANY PARTICULAR
PURPOSE.   FURTHER,  THE  AUTHOR  DOES  NOT WARRANT, GUARANTEE, OR MAKE ANY
REPRESENTATION  REGARDING  THE  USE  OF,  OR THE RESULTS OF THE USE OF, THE
INFORMATION   CONTAINED   HEREIN   IN   TERMS   OF  CORRECTNESS,  ACCURACY,
RELIABILITY,  CURRENTNESS,  OR OTHERWISE; THE ENTIRE RISK AS TO ITS QUALITY
AND  ACCURACY  IS  ASSUMED SOLEY BY THE USER.  SHOULD THE INFORMATION PROVE
INACCURATE,  THE  USER  (AND NOT THE AUTHOR) ASSUMES THE ENTIRE COST OF ALL
NECESSARY  CORRECTION.   IN  NO EVENT WILL THE AUTHOR BE LIABLE FOR DIRECT,
INDICRECT,  INCIDENTAL,  OR CONSEQUENTIAL DAMAGES RESULTING FROM ANY DEFECT
OR  INACCURACY  IN  THIS PUBLICATION, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH  DAMAGES.   SOME  LAWS  DO  NOT  ALLOW  THE EXCLUSION OR LIMITATION OF
IMPLIED WARRANTIES OR LIABILITIES FOR INCIDENTIAL OR CONSEQUENTIAL DAMAGES,
SO THE ABOVE LIMITATION OR EXCLUSION MAY NOT APPLY.
@endnode

@node Introduction "DataBase.library - Chapter 1, Introduction"

@{b}@{fg shine}Chapter 1, Introduction@{fg text}@{ub}

The database.library is a powerfull shared runtime library, that allows you
to  create  large  complex  databases  with  just a few lines of code.  The
databases  are shareable by several computers/user simultaneous so you have
not  to  worry  about interferencing with other users (you may nevertheless
know  what  happens  if two users are trying to change the same record of a
datatable at the same time).

The database.library contains no functionality to visualize the contents of
a  database,  you  will  still  need  to  create an user-interface for your
applications  by using other tools/libraries or the basic AmigaOS Intuition
user-interface.

This  section  presents  some  of the basics that all programmers using the
database.library need to know.

The  next  chapter contains a (very) small @{"tutorial" link Tutorial} you should work through
to get an overview how the database.library works.

The  following  6  chapters contain detailed information required to create
databases for user-applications.

The  last  chapter  contains  a  guide that should help you in creating the
database for your application step by step.

The  appendix  describe the details required to write own extensions to the
database.library.

See  the  glossar  to  find a description of the notions used by me in this
documentation.   And  you  should  be  indulgent with my english-knowledge.
English is not my home-language, but I hope you could follow this text.

Sections:
   @{" Quick start               " link Quick_start}
   @{" Basics you should know    " link Basics_you_should_know}
   @{" Open the database.library " link Open_the_database.library}
   @{" Error reports             " link Error_reports}
@endnode

@node Quick_start "DataBase.library - Chapter 1, Introduction"
@toc Introduction

@{b}@{fg shine}Section 1.1, Quick start@{fg text}@{ub}

To  use  the database.library you should read (and understand) at least the
following @{"Tutorial" link Tutorial} chapter and the last chapter @{"How to create Databases" link How_to_create_Databases}.

The other chapters should be used for reference to get detailed information.

If  you  have become familiary with the database.library and its underlying
concept,  you  might use the information found in the appendix to write own
DataServer classes or extensions to the existing ones.
@endnode

@node Basics_you_should_know "DataBase.library - Chapter 1, Introduction"
@toc Introduction

@{b}@{fg shine}Section 1.2, Basics you should know@{fg text}@{ub}

You  should  know  the  basics  about  databases.   Don't  ask  me for good
literatur  about the basics, I've learned the basics a few years ago during
studying and doesn't own any good book (I've my scripts of course).

You  should  have  some  practice  in  Amiga-programming, especially how to
access  shared  libraries  and how to create a kind of user-interface.  The
TagItem  lists  used  by  several functions of the AmigaOS should be no new
concept to you.

You  should know the basic idea behind object-orientation (OO), even if the
database.library  and  all  examples  in this documentation are not written
using   an   OO-language,   the  basic  concept  of  OO  is  used  for  the
database.library.

To follow the examples given, you should be familiar with the C-programming
language.

I've  written  and  tested  the database.library and all examples using the
outdated  SAS/C  6.58  C-compiler.   This  compiler  isn't  supported since
several  years,  but  nevertheless -- in my opinion -- the best and fastest
C-compiler  available  for the Amiga.  You may have to make some changes to
the  source or even the include files, so they work with your compiler, but
there  should  be  documentation  how a SAS/C source has to be reworked for
your  compilers  needs (because SAS/C is the reference used in most popular
Amiga-programming books and guidelines).

You  may have a look to the autodocs of the joinOS.library, that is shipped
with  the database.library.  The functions of this library are heavily used
by the database.library.
@endnode

@node Open_the_database_library "DataBase.library - Chapter 1, Introduction"
@toc Introduction

@{b}@{fg shine}Section 1.3, Open the database.library@{fg text}@{ub}

The  database.library  is  opened as any other Amiga shared runtime-library
through the exec function OpenLibrary().  The library basepointer is called
DatabaseBase, you should declare it anywhere in your code:

   struct Library *DatabaseBase;

If  you  wish to use the database.library, take care that your calling task
is  a  full initialized AmigaDOS process.  Simple exec tasks will crash the
system,   because  the  database.library  makes  heavy  use  of  AmigaDOS's
I/O-functions.

Remember to close the database.library using exec's CloseLibrary() function
before your application terminates.

The database.library doesn't perform any form of resource-tracking, so take
care  that  every DataTable and index is closed before the database.library
is closed, or these files will remain open.
@endnode

@node Error_reports "DataBase.library - Chapter 1, Introduction"
@toc Introduction

@{b}@{fg shine}Section 1.4, Error reports@{fg text}@{ub}

If you find any error in the database.library or this documentation, please
send  an  error-report  to me, so I could remove the error and spread a new
release.

Before  you send an error-report take care that the error is located in the
database.library  and not anywhere else.  Several filesystems available for
the Amiga are not fully compatible to the AmigaOS FastFileSystem and cannot
be  used  for the files manipulated by the database.library.  So if you are
shure  that  your  code  is  bug-free,  try to run your application using a
harddisk  partition  that  is  formated using FastFileSystem to contain the
database.

Have  a  look  at  the  known bugs and known incompatibilities of available
filesystems.

Your error-report should contain a clear, complete, and concise description
of the error, feel free to send a code-fraqment that contains the code that
fails. So I could easily reproduce the error-conditions and find the bug.
The  report  should  contain  a  telephone number and -- if available -- an
email-address  that  could  be used to get contact with you, if I need more
information.

If  you  have any ideas or announcement you should also feel free to inform
me.

Send your error-reports to:

   Peter Riede
   Eichenweg 13
   23820 Pronstorf
   Germany

or contact me by email:

   Noster-Riede@T-Online.de
@endnode

@node Tutorial "DataBase.library - Chapter 2, Tutorial"

@{b}@{fg shine}Chapter 2, Tutorial@{fg text}@{ub}

This chapter contains a short example of a DataTable and how it is created.
After  you have seen this example running, you should have a closer look to
the  following  chapters  to  learn  the details required for programming a
database.

Sections:
   @{" Create a DataTable              " link Create_a_DataTable}
   @{" Add Rows to the Table           " link Add_Rows_to_the_Table}
   @{" Retrieving Data                 " link Retrieving_Data}
   @{" Skipping through the DataServer " link Skipping_through_the_DataServer}
   @{" Get rid of a DataServer         " link Get_rid_of_a_DataServer}
   @{" AlbumDB                         " link AlbumDB}
@endnode

@node Create_a_DataTable "DataBase.library - Chapter 2, Tutorial"
@toc Tutorial

@{b}@{fg shine}Section 2.1, Create a DataTable@{fg text}@{ub}

Notes:   In  the  following  chapter the names DataTable and DataServer are
heavily used, the only thing you need to know by now is that a DataTable is
a kind of DataServer, a class that is able to store information.
You  should not think the following example is a usefull application, it is
a  quick,  easy to understand example that gives you a feeling, how easy it
is to create database-applications using the database.library.

A DataTable is easily created by calling the following function:

   @{b}struct DataServer *DBF_InitA (APTR ignored, struct TagItem *tagList);@{ub}

The  first  argument  is  currently  unused,  you should pass zero for this
argument  for  future  compatibility.  The TagItem list needs to contain at
least the following TagItems:

@{b}DBF_Name@{ub}
   The  name  of the table. Data is a pointer to a NUL-terminated C-string.
   You  should  use  an  unique  name for every instance of a DataTable you
   create.

@{b}DBF_FileName@{ub}
   The filename and path of the according file. Data is a pointer to a NUL-
   terminated  C-string  with  the  filename   (and  optional  path) of the
   DataTables  file.  If this path doesn't contain a device/volumn name, it
   is interpreted relative to the current directory.

@{b}DBF_Struct@{ub}
   The  structure  array  describing  the structure of the table. Data is a
   pointer to a DBStruct structure array. This array needs to be terminated
   by  a  DBStruct structure initialized with zeros. See chapter 6, section
   @{"The DBStruct structure" link The_DBStruct_structure} for details.

There  are  several  more  TagItems  available,  they  are described in the
chapter 6, @{"DataTable" link DataTable} in detail.

So this little code-fragment will create a DataTable in the Ram-disk:


#include <joinOS/database/DataTable.h>

struct DBStruct dbs[] =
{
   {"ID",     NULL, NULL, DC_LONG, 0, 0, 0},
   {"ALBUM",  NULL, NULL, DC_CHAR, 0,40, 0},
   {"MEDIUM", NULL, NULL, DC_CHAR, 0, 2, 0},
   {"COMMENT",NULL, NULL, DC_TEXT, 0, 0, 0},
   {0}
};

struct TagItem dbfTags[] =
{
   {DBF_Name, (ULONG)"TestDB"},
   {DBF_FileName, (ULONG)"RAM:Test.dbf"},
   {DBF_Struct, (ULONG)dbs},
   {TAG_DONE, 0}
};

struct DataServer *CreateTestServer (void)
{
   struct DataServer *server;

   if (server = DBF_InitA (NULL, dbfTags))
   {
      printf ("The DataTable is successfully created.\n");
   }
   return server;
};

The name of the created DataTable is @{b}@{i}TestDB@{ub} @{ui}and it contains 4 columns:

@{b}@{i}ID@{ub} @{ui}
   The first column contains long (4 byte) integer values.

@{b}@{i}ALBUM@{ub} @{ui}
   The second column contains strings of 40 characters (without terminating
   NUL-byte)

@{b}@{i}MEDIUM@{ub} @{ui}
   The third column also contains strings but of 2 characters in length.

@{b}@{i}COMMENT@{ub} @{ui}
   The  last  column  contains variable sized NUL-terminated strings of any
   length.
@endnode

@node Add_Rows_to_the_Table "DataBase.library - Chapter 2, Tutorial"
@toc Tutorial

@{b}@{fg shine}Section 2.2, Add Rows to the Table@{fg text}@{ub}

Now  we could start adding data to the DataTable.  There is a main function
that  is  used to access a DataTable (exactly it is a function used for any
kind of DataServer) called:

   @{b}BOOL DS_DoUpdate (struct DataServer *server, ULONG operation, APTR arg);@{ub}

This  function  is  able  to  perform  several  operations  for any kind of
DataServer  regardless which subclass it exactly is.  The arguments to this
function are:

@{b}server@{ub}
   You have to pass a pointer to the DataServer structure of the DataServer
   that should process the operation.

@{b}operation@{ub}
   This  identifier  specifies  the kind of operation requested.  There are
   several operations defined, for a complete list have a look at chapter 3,
   section @{"Operations every DataServer should support" link Operations_every_DataServer_should_support}.

@{b}arg@{ub}
   The type of this argument depend on the requested operation.

The  function  will  return  @{b}TRUE@{ub},  if  the  requested  operation  could be
performed successfully, else @{b}FALSE@{ub} will be returned.

To  add a new row to a DataServer, we use the operation @{b}DS_INSERTROW@{ub}.  This
operation  will  create  a  new  empty  row,  that  can be filled with data
according  to  the  columns  of  the DataServer.  The operation requires no
further arguments, so 'arg' is set to zero:

   @{b}success = DS_DoUpdate (server, DS_INSERTROW, NULL);@{ub}

Now this row should be filled with some data, we use the function:

   @{b}BOOL DBF_FieldPut(struct DataServer *server, STRPTR field, STRPTR data);@{ub}

It is a shortcut for two calls to @{b}@{i}DS_DoUpdate() @{ui}@{ub}defined in @{i}Database.lib@ {ui}:

BOOL DBF_FieldPut(struct DataServer *server, STRPTR field, STRPTR data)
{
   BOOL success;

   if (success = DS_DoUpdate (server, DS_FINDCOLUMN, (APTR)field))
   {
      success = DS_DoUpdate (server, DS_SETCOLUMNDATA, (APTR)data);
   }
   return success;
}

Where the operations are performing the following:

@{b}DS_FINDCOLUMN@{ub}
   This operation searches the column with the specified name and activates
   it.

@{b}DS_SETCOLUMNDATA@{ub}
   This  operation  writes  the data specified by the NUL-terminated string
   into  the  current  column.   If  required  this  operation performs the
   convertion of the string into the @{i}raw @{ui}format used to store the data in
   the DataServer.


Another way of adding data is the function:

   @{b}BOOL DBF_FieldPutRaw (struct DataServer *server,
                                 STRPTR field, APTR rawdata);@{ub}

It is a shortcut for two calls to @{b}@{i}DS_DoUpdate() @{ui}@{ub}defined in @{i}Database.lib @{ui}:

BOOL DBF_FieldPutRaw (struct DataServer *server, STRPTR field, APTR rawdata)
{
   BOOL success;

   if (success = DS_DoUpdate (server, DS_FINDCOLUMN, (APTR)field))
   {
      success = DS_DoUpdate (server, DS_SETRAWDATA, rawdata);
   }
   return success;
}

In  opposide  to  @{b}DS_SETCOLUMNDATA@{ub},  @{b}DS_SETRAWDATA@{ub}  expects  the data to be
written  not  as  NUL-terminated  string  instead the data has to be in the
@{i}raw @{ui} format,  as  it  is  stored  in  the  DataTable, e.g.  if the column
contains a long integer, the @{b}@{i}rawdata @{ui}@{ub}has to be a pointer to a long integer.


After the data has been written into the new row, the completed row must be
stored  in  the  DataTables  file.  This is performed by another operation:
@{b}DS_UPDATE@{ub}.   This operation terminates any changes made to a DataServer, so
other  instances  of the same DataServer get notice about the changes made.
If  this  operation is not processed, the changes are lost by the next time
(the number of) the current row is changed.

Now we have all we need to create a new record and add it to the DataTable:


BOOL InsertRecord (struct DataServer *server,
                   ULONG Id,
                   STRPTR album,
                   STRPTR medium,
                   STRPTR comment)
{
   BOOL success;

   if (success = DS_DoUpdate (server, DS_INSERTROW, NULL))
   {
      if (success = DBF_FieldPutRaw (server, "ID", (APTR)&Id))
      {
         if (success = DBF_FieldPut (server, "Album", (APTR)album))
         {
            if (success = DBF_FieldPut (server, "Medium", (APTR)medium))
            {
               if (success = DBF_FieldPut (server, "Comment", (APTR)comment))
                  success = DS_DoUpdate (server, DS_UPDATE, NULL);
            }
         }
      }
   }
   return success;
}
@endnode

@node Retrieving_Data "DataBase.library - Chapter 2, Tutorial"
@toc Tutorial

@{b}@{fg shine}Section 2.3, Retrieving Data@{fg text}@{ub}

But how could we read data from the current row of a DataServer ?
Yes therefore we have another set of operations:

@{b}DS_GETCOLUMNDATA@{ub}
   This  operation  retrieves  the  contents  of  the current column in the
   current row as a NUL-terminated C-string, in @{i}human-readable @{ui}format.
   This  way we could easily print out the data regardless which @{i}raw @{ui}format
   the columns data has.
   The  argument @{b}@{i}arg @{ui}@{ub}has to be a pointer to the address, where a pointer to
   the NUL-terminated string with the data should be stored.

@{b}DS_GETRAWDATA@{ub}
   This  operation  retrieves  the  contents  of  the current column in the
   current row in the @{i}raw @{ui}format as it is stored in the DataServer.
   This  way  we  could  get the @{i}raw @{ui}format, e.g.  we could get the integer
   value  stored  in  a column so we are able to do some calculations using
   this  value.  The argument @{b}@{i}arg @{ui}@{ub}has to be a pointer to the address, where
   a pointer to the @{i}raw @{ui}data should be stored.

There are also the according functions in @{i}Database.lib @{ui}:

   @{b}BOOL DBF_FieldGet (struct DataServer *server,
                                    STRPTR field, STRPTR *data);@{ub}
and
   @{b}BOOL DBF_FieldGetRaw (struct DataServer *server,
                                    STRPTR field, APTR *rawdata);@{ub}


So  a PrintRecord() function that prints the contents of the current record
of our DataTable to stdout could look like this:

BOOL PrintRecord (struct DataServer *server)
{
   STRPTR data;
   BOOL success;

   if (success = DBF_FieldGet (server, "ID", (APTR)&data))
   {
      printf ("Id      = %s\n", data);
      if (success = DBF_FieldGet (server, "Album", (APTR)&data))
      {
         printf ("Album   = %s\n", data);
         if (success = DBF_FieldGet (server, "Medium", (APTR)&data))
         {
            printf ("Medium  = %s\n", data);
            if (success = DBF_FieldGet (server, "Comment", (APTR)&data))
            {
               printf ("Comment = %s\n", data);
            }
         }
      }
   }
   return success;
}
@endnode

@node Skipping_through_the_DataServer "DataBase.library - Chapter 2, Tutorial"
@toc Tutorial

@{b}@{fg shine}Section 2.4, Skipping through the DataServer@{fg text}@{ub}

To  have  a  view  to the contents of a DataServer, we need some operations
that  allows us to navigate through the rows of the DataServer.  We use the
following ones in our demo:

@{b}DS_FIRSTROW@{ub}
   This  operation  makes  the first available row in the DataServer to the
   current one. The argument @{b}@{i}arg @{ui}@{ub}is not used and should be set to zero.

@{b}DS_NEXTROW@{ub}
   This operation makes the row behind the current row in the DataServer to
   the current one. The argument @{b}@{i}arg @{ui}@{ub}is not used and should be set to zero.
   If  there  are no more rows in the DataServer, @{b}FALSE@{ub} is returned and the
   errorcode  @{b}DS_ERR_NO_MORE_DATA@{ub}  is written into the field @{b}@{i}LastError @{ui}@{ub}of
   the DataServer structure.

With  this  knowledge,  we  could  program a function that prints the whole
contents of a DataServer to @{i}stdout @{ui}:

BOOL DumpServer (struct DataServer *server)
{
   BOOL success;

   success = DS_DoUpdate (server, DS_FIRSTROW, NULL);

   while (success)
   {
      if (success = PrintRecord (server))
         success = DS_DoUpdate (server, DS_NEXTROW, NULL);
   }
   if (server->LastError == DS_ERR_NO_MORE_DATA) success = TRUE;

   return success;
}
@endnode

@node Get_rid_of_a_DataServer "DataBase.library - Chapter 2, Tutorial"
@toc Tutorial

@{b}@{fg shine}Section 2.5, Get rid of a DataServer@{fg text}@{ub}

At  least we need to know how a DataServer is closed and all resources used
by  it (except the file stored in the filesystem of course).  You only need
to send a single operation to the DataServer for this purpose:

@{b}DS_DISPOSE@{ub}
   This  operation  disposes the DataServer and frees all resource used for
   it.  The file(s) is/are closed, but remain on the filesystem for reopen.
   No argument is required for this operation, so @{b}@{i}arg @{ui}@{ub}should be set to zero.
@endnode

@node AlbumDB "DataBase.library - Chapter 2, Tutorial"
@toc Tutorial

@{b}@{fg shine}Section 2.6, AlbumDB@{fg text}@{ub}

Now  lets put our parts together, add some code for reading the contents of
a record from @{i}stdin @{ui}and voilà:
There is our first small database, usable to register our music-collection.


;/* Execute me to compile me with SAS/C 6.58
sc link Tutorial_1.c nochkabort nostkchk strt=c from lib:database.lib to AlbumDB
quit
 * Tutorial_1.c
 *
 * This is a simple tutorial, used to introduce into the usage of the
 * database.library. It should be easy to understand, so only the minimum
 * errorhandling is done.
 *
 * It implements a very small database (a single table without any index)
 * that is usable to register a music-collection, i.e. the personal CDs,
 * MCs and LPs
 */

#include <joinOS/exec/defines.h>
#include <joinOS/exec/memory.h>
#include <joinOS/database/DataServer.h>
#include <joinOS/database/DataTable.h>

#include <joinOS/protos/ExecProtos.h>
#include <joinOS/Protos/AmigaDOSProtos.h>
#include <joinOS/protos/DatabaseProtos.h>

#include <stdio.h>
#include <string.h>

struct Library *JoinOSBase = NULL;
struct Library *DatabaseBase = NULL;

struct DBStruct dbs[] =
{
   {"ID",     NULL, NULL, DC_LONG, 0, 0, 0},
   {"ALBUM",  NULL, NULL, DC_CHAR, 0,40, 0},
   {"MEDIUM", NULL, NULL, DC_CHAR, 0, 2, 0},
   {"COMMENT",NULL, NULL, DC_TEXT, 0, 0, 0},
   {0}
};

struct TagItem dbfTags[] =
{
   {DBF_Name, (ULONG)"TestDB"},
   {DBF_FileName, (ULONG)"RAM:Test.dbf"},
   {DBF_Struct, (ULONG)dbs},
   {TAG_DONE, 0}
};

/* Open the required libraries
 */
BOOL OpenLibs(void)
{
   BOOL opened = FALSE;

   if (JoinOSBase = OpenLibrary ("joinOS.library",0L))
      if (DatabaseBase = OpenLibrary ("database.library",0L))
         opened = TRUE;
      else printf ("Unable to open database.library.\n");
   else printf ("Unable to open joinOS.library.\n");

   return opened;
}

/* close the opened libraries
 */
void CloseLibs(void)
{
   if (JoinOSBase) CloseLibrary (JoinOSBase);
   if (DatabaseBase) CloseLibrary (DatabaseBase);
}

/* create the database
 */
struct DataServer *CreateTestServer (void)
{
   struct DataServer *server;

   if (server = DBF_InitA (NULL, dbfTags))
   {
      printf ("The DataTable is successfully created.\n");
   }
   return server;
}

/* wait for user-respond
 */
void WaitForReturn (void)
{
   printf ("Press ENTER to continue...");
   fflush (stdout);
   (void)getchar(); 
}

/* print a single record
 */
BOOL PrintRecord (struct DataServer *server)
{
   STRPTR data;
   BOOL success;

   if (success = DBF_FieldGet (server, "ID", (APTR)&data))
   {
      printf ("Id      = %s\n", data);
      if (success = DBF_FieldGet (server, "Album", (APTR)&data))
      {
         printf ("Album   = %s\n", data);
         if (success = DBF_FieldGet (server, "Medium", (APTR)&data))
         {
            printf ("Medium  = %s\n", data);
            if (success = DBF_FieldGet (server, "Comment", (APTR)&data))
            {
               printf ("Comment = %s\n", data);
            }
         }
      }
   }
   return success;
}

/* make a dump of the whole database to stdio
 */
BOOL DumpServer (struct DataServer *server)
{
   BOOL success;

   success = DS_DoUpdate (server, DS_FIRSTROW, NULL);

   while (success)
   {
      if (success = PrintRecord (server))
      {
         WaitForReturn ();
         success = DS_DoUpdate (server, DS_NEXTROW, NULL);
      }
   }
   if (server->LastError == DS_ERR_NO_MORE_DATA) success = TRUE;

   return success;
}

/* add a single record to the database
 */
BOOL InsertRecord (struct DataServer *server,
                   ULONG Id,
                   STRPTR album,
                   STRPTR medium,
                   STRPTR comment)
{
   BOOL success;

   if (success = DS_DoUpdate (server, DS_INSERTROW, NULL))
   {
      if (success = DBF_FieldPutRaw (server, "ID", (APTR)&Id))
      {
         if (success = DBF_FieldPut (server, "Album", (APTR)album))
         {
            if (success = DBF_FieldPut (server, "Medium", (APTR)medium))
            {
               if (success = DBF_FieldPut (server,"Comment",(APTR)comment))
                  success = DS_DoUpdate (server, DS_UPDATE, NULL);
            }
         }
      }
   }
   return success;
}

/* read the contents of a column from user-input
 */
UBYTE *ReadColumn (STRPTR columnName, UBYTE *buffer)
{
   UBYTE *data = NULL;

   printf ("Please enter a new value for the column \"%s\":\n",columnName);

   if (gets (buffer)) data = buffer;
   else printf ("I/O-error during input.\n");

   return data;
}

/* add a new record to the datatable
 */
BOOL AddRecord (struct DataServer *server, UBYTE *buffer)
{
   BOOL success = FALSE;
   LONG Id;
   STRPTR album;
   STRPTR medium;
   STRPTR comment;
   UBYTE *p;

   printf ("Adding a new record:\n");

   if (p = ReadColumn ("Id", buffer))
   {
      Id = 0;
      StrToLong (p, &Id);

      if (album = ReadColumn ("Album", buffer))
      {
         p += strlen (album) + 1;

         if (medium = ReadColumn ("Medium", p))
         {
            p += strlen (medium) + 1;
            if (comment = ReadColumn ("Comment", p))
            {
               if (!(success =
                     InsertRecord (server, Id, album, medium, comment)))
               {
                  printf ("Failed to add record to datatable.\n");
               }
            }
         }
      }
   }
   return success;
}

/* main loop
 */
void do_Operations (struct DataServer *server, UBYTE *buffer)
{
   BOOL quit = FALSE;

   printf ( "\nPlease enter a command; enter \"help\" to get a list of\n"
            "the available commands.\n");

   while (!quit)
   {
      printf ("> ");
      fflush (stdout);
      if (gets(buffer))
      {
         if (strnicmp (buffer, "HELP", strlen(buffer)) == 0)
         {
            printf ("Available commands:\n"
                     "help - see this text;\n"
                     "quit - terminate this application;\n"
                     "new - add a new record to the datatable;\n"
                     "list - list the contents of the datatable;\n");
         }
         else if (strnicmp (buffer, "QUIT", strlen (buffer)) == 0)
            quit = TRUE;
         else if (strnicmp (buffer, "NEW", strlen (buffer)) == 0)
         {
            AddRecord (server, buffer);
         }
         else if (strnicmp (buffer, "LIST", strlen (buffer)) == 0)
         {
            DumpServer (server);
         }
         else
         {
            printf ("Unknown command \"%s\".\n"
              "Enter \"help\" to get a list if the available commands.\n");
         }
      }
      else
      {
         printf ("I/O-error during input.\n");
         quit = TRUE;
      }
   }
}

/* application entry point, do the necessary initializations
 */
void main (void)
{
   if (OpenLibs())
   {
      struct DataServer *server;

      printf ("AlbumDB, © 2004, Peter Riede\n");
      printf ("A small demo of a database created using the "
                                        "database.library.\n");

      if (server = CreateTestServer ())
      {
         UBYTE *buffer;

         if (buffer = (UBYTE *)AllocMem (1024, MEMF_PUBLIC))
         {
            do_Operations (server, buffer);
            FreeMem (buffer, 1024);
         }
         else printf ("Failed to allocate I/O-buffer.\n");

         DS_DoUpdate (server, DS_DISPOSE, NULL);

         printf ("The database file \"Test.dbf\" is found in \"RAM:\".\n"
               "You should delete it, if you doesn't need it any more.\n");
      }
   }
   CloseLibs();
}
@endnode

@node DataServer "DataBase.library - Chapter 3, DataServer"

@{b}@{fg shine}Chapter 3, DataServer@{fg text}@{ub}

The  base  class  of  any set of data is the DataServer.  A DataServer is a
container  of  any  kind  of  data  organized  in  rows  and  columns.  The
DataServer  owns  the  functions  required  to  access  its  contents.  Any
subclass  of  the DataServer inherits its functionality.  Any class derived
from  the  DataServer  is  able  to  process  the  operations  defined  for
DataServers.

This chapter will try to introduce you in the basics of DataServers and the
operations that could be performed with them.

Sections:
   @{" The DataServer structure                         " link The_DataServer_structure}
   @{" Creation of DataServers                          " link Creation_of_DataServers}
   @{" Request performing of operations to a DataServer " link Request_performing_of_operations_to_a_DataServer}
   @{" Operations every DataServer should support       " link Operations_every_DataServer_should_support}
@endnode

@node The_DataServer_structure "DataBase.library - Chapter 3, DataServer"
@toc DataServer

@{b}@{fg shine}Section 3.1, The DataServer structure@{fg text}@{ub}

The  DataServer  structure, as defined in <joinOS/database/Dataserver.h> is
the basic structure used to contain the data of a DataServer.

You  need  to know this structure, because some kind of information that is
stored  in there could only be read direct from this structure, there is no
according access-function (I don't like needless overhead).

struct DataServer
{
   ULONG StructSize;           /* Size of the structure */
   ULONG NumColumns;           /* number of columns of each row */
   ULONG CurrentColumn;        /* number of the current column */
   struct DataColumn *Columns; /* pointer to structure array of columns */
   ULONG Flags;                /* flags specifying state of the server */
   ULONG LastError;            /* errorcode, see below for defines */
   DS_UPDATE_FCT Update;       /* function ptr. to update-function */
   APTR Device;                /* underlying "device" delivering the data*/
   STRPTR Name;                /* optional name of the DataServer */
   ULONG NumRows;              /* number of rows, that are available */
   ULONG CurrentRow;           /* number of the current row */
   APTR Rows;                  /* data of all rows */
   APTR Order;                 /* the current order of the rows */
};

Here are the fields of this structure:

@{b}StructSize@{ub}
   The  DataServer structure is found as leading structure of any structure
   of  the  classes  derived  from the DataServer class and its subclasses,
   this field contains the total bytesize of the whole structure.

@{b}NumColumn@{ub}
   The number of columns of the DataServer.

@{b}CurrentColumn@{ub}
   The number of the currently active column. Only a single column could be
   active  at a moment, any read or write will be touching this column.  If
   zero is stored here, no column is currently active.

@{b}Columns@{ub}
   This  field contains a pointer to the array of DataColumns, representing
   the  attributes  of  each  column  of  the  DataServer.  See  chapter 4,
   @{"DataColumn" link DataColumn} for details.

@{b}Flags@{ub}
   This  field  contains some bitflags, describing the current state of the
   DataServer.   The  following  flags are defined for the basic DataServer
   class, subclasses may define additonal flags:

   @{b}DSF_READONLY@{ub}
      If  this  flag  is  set, the DataServer is in read/only mode and will
      reject  every  operation  that  tries  to  change the contents of the
      DataServer.

   @{b}DSF_ROWCHANGED@{ub}
      If  this  flag  is  set,  the  contents  of  the  current  row of the
      DataServer has been changed and the changes are currently not stored.

   @{b}DSF_SOFTSEEK@{ub}
      If  this  flag  is  set,  the seek-operations will be processed using
      @{i}soft-seek @{ui}, see the description of the function @{b}@{i}IDX_Seek() @{ui}@{ub}in chapter
      5, section @{"Navigating through an index" link Navigating_through_an_index} for details.

   @{b}DSF_DESCEND@{ub}
      If  this  flag  is  set, the rows are ordered descend, if the flag is
      cleared the rows are ordered ascend.  See the description of the flag
      @{b}IDX_DESCEND@{ub}  in  the chapter 5, section @{"The IDXHeader structure" link The_IDXHeader_structure} for
      additonal information.

   @{b}DSF_NEWROW@{ub}
      If this flag is set, the current record is a new created record, that
      is currently not stored.

@{b}LastError@{ub}
   This  field contains the number of the error that has occured during the
   last performed operation. The DataServer class has defined the following
   errorcodes,  the  subclasses may add new errorcodes to the already known
   ones.  The errorcodes in the range from  0 to 999  are reserved  for the
   DataServer class:

   @{b}DS_ERR_NO_ERROR@{ub} (0L)
      no error occured

   @{b}DS_ERR_NO_MEMORY@{ub} (1L)
      During the last operation,  a low-memory situation occured, there was
      not enough free memory available.

   @{b}DS_ERR_NO_MORE_DATA@{ub} (2L)
      You  have tried to select a row or column that is out of range,  i.e.
      EOF is reached, or no row or column is currently active.

   @{b}DS_ERR_OP_NOT_KNOWN@{ub} (3L)
      You  have  requested  an  operation  that  is  not  supported  by the
      DataServer (or the subclass).

   @{b}DS_ERR_WRONG_ARG@{ub} (4L)
      You  have  passed  a wrong argument to the DataServer, i.e.  you have
      passed an illegal value or pointer.

   @{b}DS_ERR_MAYOR@{ub} (5L)
      An  unexpected  mayor  error  occured, the contents of the DataServer
      might be corrupt,  you should terminate the access to the DataServer.
      This error might be set,  if an I/O-error occurs,  so you should also
      have a look to AmigaDOS's @{b}@{i}IoErr() @{ui}@{ub}.

   @{b}DS_ERR_MINOR@{ub} (6L)
      An unexpected minor error occured, the last operation failed, but the
      contents of the DataServer should still be valid.  This might also be
      the  result  of  an  I/O-error,  but this error could be handled, you
      should have a look to AmigaDOS's @{b}@{i}IoErr() @{ui}@{ub}.

   @{b}DS_ERR_WRITE_PROTECT@{ub} (7L)
      You tried to add/remove rows to a write-protected DataServer or tried
      to change the contents of a read-only column.

@{b}Update@{ub}
   This is a private function-pointer used to dispatch operation-requests.
   Do  not  use  or  change  this in your user-application. Have a look at
   section  @{"Request performing of operations to a DataServer" link Request_performing_of_operations_to_a_DataServer} for details
   about dispatching operations.

@{b}Device@{ub}
   This is  a  pointer to the underlying @{i}device @{ui}, used for storing the data
   of a DataServer.  The type of data this pointer points to depends on the
   implementation of the subclass.

@{b}Name@{ub}
   Every DataServer needs to have an unique name so it could be identified,
   this is a pointer to that NUL-terminated C-string.

@{b}NumRows@{ub}
   The  number  of rows, that are available by this DataServer.  This field
   may  not  contain  the  real  number of rows, especially if running in a
   multiuser  environment.  You should request the number of rows using the
   according operation.

@{b}CurrentRow@{ub}
   The  number  of  the  current  row.  This number is used to identify the
   current row, every row must have an unique number.

@{b}Rows@{ub}
   This  is a pointer to the data of the rows respectively a structure used
   to  access  that data.  It is implementation specific, i.e.  the type of
   structure pointed to depends on the implementation of the subclass.

@{b}Order@{ub}
   This  is  a pointer to some kind of structure defining the current order
   of  the  rows.   It  is  also implementation specific, i.e.  the type of
   structure pointed to depends on the implementation of the subclass.


Even  if you think you know the exact purpose of a member of the DataServer
structure,  if you need to change any attribute, you should have a look for
a  function of the database.library for that purpose instead of changing it
by direct accesses to the structure.

In  opposide  you  may feel free to change the @{b}@{i}LastError @{ui}@{ub}field to any value
you  wish (usually you will clear it by writting @{b}0L@{ub} or the according define
@{b}DS_ERR_NO_ERROR@{ub} into that field).
@endnode

@node Creation_of_DataServers "DataBase.library - Chapter 3, DataServer"
@toc DataServer

@{b}@{fg shine}Section 3.2, Creation of DataServers@{fg text}@{ub}

You  may  skip  this  section  with  detailed  informations  about creating
DataServers and the TagItems that might be passed to the according function
and  continue  reading  in @{"Request performing of operations to a DataServer" link Request_performing_of_operations_to_a_DataServer}
the  following  section,  if  you  don't need information how to create own
subclasses derived from DataServer.

A DataServer is created by calling the function

   @{b}struct DataServer *DS_InitA (APTR ignored, struct TagItem *tagList);@{ub}

The return-value is a pointer to a DataServer structure as descipted below.
The  first  argument  is currently ignored and has to be set to zero (@{b}NULL@{ub})
for  future  compatibility.   The second argument is a pointer to a TagItem
list, describing the attributes and properties of the DataServer.

Because  the  DataServer  class  is a @{i}virtual @{ui}class, you will usually never
create  a  DataServer  direct  from  an  user-application, instead you will
create instances of subclasses of the DataServer.

The following Tags are defined for DataServers:

@{b}DS_Columns@{ub}
   The  data  is  a  pointer to an array of of DataColumn structures, which
   define  the  columns of this DataServer.  The structures and all strings
   passed with this array are copied and need not to remain valid, when the
   initialization of the DataServer has finished.
   This array is terminated by an entry with the @{b}@{i}Name @{ui}@{ub}set to @{b}NULL@{ub}.  If this
   Tag is not present, the DataServer has initially no columns.

@{b}DS_ReadOnly@{ub}
   The  data  is  ignored, this is a boolean Tag, if this Tag is present in
   the  TagItem  list,  the  DataServer  is read-only, i.e.  no data of any
   column might be changed.

@{b}DS_SoftSeek@{ub}
   The data is ignored, this is aboolean Tag, if this Tag is present in the
   TagItem  list, the @{i}soft-seek @{ui}of the DataServer is enabled.  If @{i}soft-seek @{ui}
   is  enabled,  the  operation @{"DS_SEEK" link Operations_every_DataServer_should_support} stops successfully on the first row
   that is equal or greater than the searched value (have a look at section
   @{"Operations every DataServer should support" link Operations_every_DataServer_should_support}).

@{b}DS_StructSize@{ub}
   The  data  is  an ULONG value, specifying the size of the structure that
   should  be  allocated  as  DataServer  structure.   This  Tag  has to be
   specified, if a subclass of the DataServer needs additional space in the
   structure for private data.

@{b}DS_Name@{ub}
   The  data  is a pointer to a NUL-terminated string specifying a name for
   the  DataServer.   This  string  is copied and needs not to remain valid
   after the initialization function has returned.
@endnode

@node Request_performing_of_operations_to_a_DataServer "DataBase.library - Chapter 3, DataServer"
@toc DataServer

@{b}@{fg shine}Section 3.3, Request performing of operations to a DataServer@{fg text}@{ub}

A  DataServer  and any derived class owns an operation-processing function,
the @{i}update @{ui}function.  There is one general dispatching function that has to
be  called,  whenever  an  operation-request is send to a DataServer.  This
dispatching  function  decides,  which @{i}update @{ui}function should be called and
redirects the operation-request to that function.

The @{i}dispatcher @{ui}is the following function:

   @{b}BOOL DS_DoUpdate (struct DataServer *server, ULONG operation, APTR arg);@{ub}

The  function will return @{b}TRUE@{ub} on success and @{b}FALSE@{ub} if anything went wrong.
You  should  have  a  look  to  the  DataServers  @{b}@{i}LastError @{ui}@{ub}field, to get a
descriptive errorcode.
The arguments of this function are:

@{b}server@{ub}
   A  pointer  to  the  DataServer  structure of the DataServer that should
   perform the requested operation.

@{b}operation@{ub}
   An  ULONG  number  specifying the kind of requested operation.  The next
   section lists the currently defined operations.

@{b}arg@{ub}
   The  type  and  contents  of  this  argument  depends  on  the requested
   operation.   The  required  argument is described for every operation in
   detail in the following section
@endnode

@node Operations_every_DataServer_should_support "DataBase.library - Chapter 3, DataServer"
@toc DataServer

@{b}@{fg shine}Section 3.4, Operations every DataServer should support@{fg text}@{ub}

This  list  describes  the  currently  defined  operations,  that should be
supported  by  every DataServer (and the derived classes).  You can request
these  @{i}operations @{ui} by passing the according value to the operation argument
of the @{"DS_DoUpdate()" link Request_performing_of_operations_to_a_DataServer} function.  The according defines could be found in the
include file <joinOS/Database/DataServer.h>.

If  a  derived  class  doesn't  support an operation listed here, it should
return @{b}FALSE@{ub} and set the errorcode @{b}DS_ERR_OP_NOT_KNOWN@{ub} to @{b}@{i}LastError @{ui}@{ub}.

@{b}DS_UPDATE@{ub}
   This  operation  synchronize  the  contents  of  the  DataServer and the
   underlying @{i}device @{ui}. If any data of the current row has been changed or a
   new  row is inserted, this operation has to be performed to copy the new
   data  to  the  @{i}device @{ui}to be stored.  If the current row is changed (e.g.
   using  the  operation @{b}DS_NEXTROW@{ub}) before the changes are confirmed using
   this  operation, the changes are discarded and the row remains unchanged
   (respectively the new row is not inserted).
   If the DataServer has been newly created, the sorting order of the rows,
   or the columns of the DataServer has been changed, this operation has to
   be  performed  to  read all rows from the underlying @{i}device@{ui} to match the
   new attributes.
   The  subclasses  of  the DataServer should monitor the underlying @{i}device @{ui}
   and perform an update, everytime the @{i}device @{ui}signalizes that the data has
   been changed.

@{b}DS_ADDCOLUMN@{ub}
   This  operation  can  be used to add a new column to the DataServer, the
   argument  @{b}@{i}arg @{ui}@{ub} has  to point to a full initialized DataColumn structure.
   This  structure  and  the referenced strings will be copied and added to
   the  end  of  the list of already present columns.  After this operation
    has succeeded, you should perform an @{b}DS_UPDATE@{ub} operation to re-read the
    data from the @{i}device@{ui} so this new column contains valid data.

@{b}DS_REMOVECOLUMN@{ub}
   Requesting  this operation will remove a column from the DataServer, the
   argument @{b}@{i}arg @{ui}@{ub}has to specify the position of the DataColumn to be removed.

@{b}DS_MOVECOLUMN@{ub}
   Using  this  operation the order of the columns in the DataServers array
   of  DataColumns  can be rearranged.  The order in this array will be the
   order  the  columns  are  selected  using  the operations @{b}DS_GOTOCOLUMN@{ub},
   @{b}DS_NEXTCOLUMN@{ub} and @{b}DS_PREVCOLUMN@{ub}.
   This  operation  will move the currently selected column to the position
   the  argument  @{b}@{i}arg @{ui}@{ub} -- interpreted as ULONG -- specifies. @{b}@{i}arg @{ui}@{ub}has to be
   between  1 and the number of columns attached to the DataServer.  If @{b}@{i}arg @{ui}@{ub}
   is  greater  than  the number of columns, the current column is moved to
   the  last position, if @{b}@{i}arg @{ui}@{ub}is equal 0, nothing is changed, the operation
   will fail.

@{b}DS_GOTOCOLUMN@{ub}
   This  operation  selects  the  column  with  the number specified by @{b}@{i}arg @{ui}@{ub}
   (interpreted as ULONG). The count of the columns starts with 1.  If 0 or
   any  value  larger than the number of columns attached to the DataServer
   is  specified,  the  operation  will fail,the current column will not be
   changed.

@{b}DS_NEXTCOLUMN@{ub}
   Requesting  this  operation  will  select the next column, i.e.  the one
   ordered behind the currently selected column; if @{b}@{i}arg @{ui}@{ub}is not equal NULL a
   pointer to the column will copied to the address @{b}@{i}arg @{ui}@{ub}points to.
   If there are no more columns this operation will fail, set the errorcode
   @{b}DS_ERR_NO_MORE_DATA@{ub}  to  @{b}@{i}LastError @{ui}@{ub} ,  the  current  column  will not be
   changed,  the  value  stored  at  the  address @{b}@{i}arg @{ui}@{ub}points to will not be
   changed.

@{b}DS_PREVCOLUMN@{ub}
   Corresponding to @{b}DS_NEXTCOLUMN@{ub}, this operation will select the preceding
   column, the one ordered before the currently selected column;  if @{b}@{i}arg @{ui}@{ub}is
   not  equal  @{b}NULL@{ub}, a pointer to the column will copied to the address @{b}@{i}arg @{ui}@{ub}
   points to.
   If  there  are no columns in front of the current column, this operation
   will  fail,  set  the  errorcode @{b}DS_ERR_NO_MORE_DATA@{ub}, the current column
   will  not be changed, the value stored at the address @{b}@{i}arg @{ui}@{ub}points to will
   not be changed.

@{b}DS_FINDCOLUMN@{ub}
   This operation selects a column specified by its name.  The argument @{b}@{i}arg @{ui}@{ub}
   has  to  be  a pointer to a NUL-terminated C-string with the name of the
   searched column, @{b}@{i}arg @{ui}@{ub}is not changed by this function.

@{b}DS_GETRAWDATA@{ub}
   Using  this  operation,  you can get the data of the current column.  If
   there  is  a  currently  selected column and the current row is valid, a
   pointer  to  the data of this column in the current row is copied to the
   address,  @{b}@{i}arg @{ui}@{ub} points  to.   The  type  of  this  pointer depends on the
   datatype of the column:

      @{b}DC_LOGIC@{ub}      - pointer to a single byte, 'F' => false, 'T' => true
      @{b}DC_BYTE@{ub}       - pointer to a single byte
      @{b}DC_WORD@{ub}       - pointer to a word (2 byte) at an even address
      @{b}DC_LONG@{ub}       - pointer to a longword (4 byte) at a longword address
                      (divideable by 4)
      @{b}DC_DOUBLELONG@{ub} - pointer to a longlong (4 byte) at a longword address
                      (divideable by 4)
      @{b}DC_FLOAT@{ub}      - pointer to a float (4 byte) at a longword address
      @{b}DC_DOUBLE@{ub}     - pointer to a double (8 byte) at a longword address
      @{b}DC_NUMERIC@{ub}    - pointer to a buffer of 'DataColumn.Length' bytes
      @{b}DC_DATE@{ub}       - pointer to a buffer of 8 bytes in length
      @{b}DC_TIME@{ub}       - pointer to a longword (4 byte) at a longword address
      @{b}DC_CHAR@{ub}       - pointer to a buffer of @{b}@{i}DataColumn.Length @{ui}@{ub}bytes
      @{b}DC_TEXT@{ub}       - pointer to a buffer where the information required to
                      locate the according string is stored.  The format of
                      this  address-information  is implementation specific
                      so you should avoid reading this kind of columndata
                      in raw format.
      @{b}DC_VARCHAR@{ub}    - pointer to a STRPTR,  where the address of the string
                      is copied to.

   Keep  in  mind  that  the  data pointed to is constant and has not to be
   modified, copy it to a local storage, before modifying it.

@{b}DS_GETCOLUMNDATA@{ub}
   In opposide to @{b}DS_GETRAWDATA@{ub} this operation gets the data of the current
   column  in  @{i}human-readable @{ui} form, i.e.  the contents is converted into a
   NUL-terminated  C-string.   A pointer to that read-only string is copied
   into  the address @{b}@{i}arg @{ui}@{ub}points to.  The data is presented in the following
   form by default:

      @{b}DC_LOGIC@{ub}      - "true" or "false"
      @{b}DC_BYTE@{ub}       - a decimal string
      @{b}DC_WORD@{ub}       - a decimal string
      @{b}DC_LONG@{ub}       - a decimal string
      @{b}DC_DOUBLELONG@{ub} - a decimal string
      @{b}DC_FLOAT@{ub}      - a number in scientific format "-d.dddddde-dd"
      @{b}DC_DOUBLE@{ub}     - a number in scientific format "-d.ddddddddde-dd"
      @{b}DC_NUMERIC@{ub}    - a decimal string as defined
      @{b}DC_CHAR@{ub}       - a string, truncated after the last non-whitespace
      @{b}DC_TIME@{ub}       - a string in the format "00:00:00.000"
      @{b}DC_DATE@{ub}       - a string in a format related to @{b}FORMAT_DOS@{ub}:
                      "dd-mmm-yyyy"
      @{b}DC_VARCHAR@{ub} &
      @{b}DC_TEXT@{ub}       - no convertion performed (already stored as NUL-
                      terminated C-strings)

@{b}DS_SETRAWDATA@{ub}
   Corresponding  to  @{b}DS_GETRAWDATA@{ub}  this operation changes the data of the
   current column.  If there is a currently selected column and the current
   row  is valid, the data is changed according to the new data, pointed to
   by  @{b}@{i}arg @{ui}@{ub}.  The  type  of data @{b}@{i}arg @{ui}@{ub}has to point to depends on the type of
   data  stored in the current column (see @{b}DS_GETCOLUMNDATA@{ub}).  The state of
   the  DataServer  flag @{b}DSF_READONLY@{ub} respectively the flag @{b}DCF_READONLY@{ub} of
   the current DataColumn is respected by this operation.

@{b}DS_SETCOLUMNDATA@{ub}
   Corresponding to @{b}DS_GETCOLUMNDATA@{ub} this operation changes the data of the
   current column.  If there is a currently selected column and the current
   row  is valid, the data is changed according to the new data, pointed to
   by  @{b}@{i}arg @{ui}@{ub}.  @{b}@{i}arg @{ui}@{ub} has  to  point to a NUL-terminated C-string with the new
   data,  formated  like  the  string returned by @{b}DC_GETCOLUMNDATA@{ub} with the
   following exceptions:

      @{b}DC_LOGIC@{ub}      - "TRUE", "T", "J", "Y", "Yes", "On" for true ('T');
                      every other string results in false ('F')
                      The comparison is done case-insensitive.
      @{b}DC_BYTE@{ub}       - a decimal string, a fractional part is ignored
      @{b}DC_WORD@{ub}       - a decimal string, a fractional part is ignored
      @{b}DC_LONG@{ub}       - a decimal string, a fractional part is ignored
      @{b}DC_DOUBLELONG@{ub} - a decimal string, a fractional part is ignored
      @{b}DC_FLOAT@{ub}      - any numeric string in decimal or in scientific format
      @{b}DC_DOUBLE@{ub}     - any numeric string in decimal or in scientific format
      @{b}DC_NUMERIC@{ub}    - a decimal string

   If  the  destination  column  or the whole DataServer is read-only, this
   operation will fail.

@{b}DS_GOTOROW@{ub}
   Using  this operation you could position the current row of a DataServer
   to  any  row  by its number; the argument @{b}@{i}arg @{ui}@{ub}-- interpreted as ULONG --
   specifies the number of the row that should be selected as current row.
   The  count  of the rows starts with 1.  If 0 or a value greater than the
   number  of  available  number of rows is specified, this operation fails
   and the current row is undefined.

@{b}DS_NEXTROW@{ub}
   This  operation  will position the current row of the DataServer to next
   row,  the  one behind the current one in the currently active order.  If
   there  are  no  more  rows  available,  this operation will fail and the
   current row is undefined.
   The argument @{b}@{i}arg @{ui}@{ub}is ignored by this operation.

@{b}DS_PREVROW@{ub}
   Corresponding  to  @{b}DS_NEXTROW@{ub},  this  operation  will  position  to  the
   previous  row,  the  one  before the current one in the currently active
   order.   If  there is no row before the current one, this operation will
   fail and the current row is undefined.
   The argument @{b}@{i}arg @{ui}@{ub}is ignored by this operation.

@{b}DS_FIRSTROW@{ub}
   This operation will make the first row to the currently active row, i.e.
   the  first  available row in the currently active order.  If there is no
   row available at all, this operation will fail.
   The argument @{b}@{i}arg @{ui}@{ub}is ignored by this operation.

@{b}DS_LASTROW@{ub}
   Corresponding  to  DS_FIRSTROW, this operation will position to the last
   row, i.e. the last available row in the currently active order. If there
   is no row available at all, this operation will fail.
   The argument @{b}@{i}arg @{ui}@{ub}is ignored by this operation.

@{b}DS_SKIPROWS@{ub}
   By  requesting  this  operation,  you  can  skip any number of rows, the
   argument  @{b}@{i}arg @{ui}@{ub} is  interpreted  as  long  value (signed), specifying the
   number  of  rows  that  should be skipped.  If the argument is less than
   zero,  the  rows  are  skipped  to the top (topmost is the row activated
   using  @{b}DS_FIRSTROW@{ub}) else the rows are skipped to the bottom (last row is
   the  one  activated using DS_LASTROW).  If end-of-file (EOF) is reached,
   or  the  skip  would end in front of the first row (BOF), this operation
   will fail and the current row is undefined.

@{b}DS_INSERTROW@{ub}
   This  operation  has  to  be  requested  to  insert  a  new row into the
   DataServer.   The  columns of the row are initialized to defaults (empty
   strings for string types of zero for numeric types).
   After  this operation has succeeded, the columns of the row could be set
   to   the   desired   values   (using  the  operations @{b}DS_SETRAWDATA@{ub}  or
   @{b}DS_SETCOLUMNDATA@{ub})  and  then the operation @{b}DS_UPDATE@{ub} has to be performed
   to  confirm  the  insertion  of  new  row and write it to the underlying
   @{i}device@{ui} .
   The argument @{b}@{i}arg @{ui}@{ub}is ignored by this operation.

@{b}DS_REMOVEROW@{ub}
   If  you  request this operation, the current row will be deleted.  After
   this  operation  has  succeeded,  the  operation  @{b}DS_UPDATE@{ub}  has  to  be
   performed to remove the row from the underlying @{i}device@{ui}.
   The argument @{b}@{i}arg @{ui}@{ub}is ignored by this operation.

@{b}DS_SETORDER@{ub}
   This  operation  is  the  usual way to change the order of the rows; @{b}@{i}arg @{ui}@{ub}
   points to the new order that should be used. The type of data @{b}@{i}arg @{ui}@{ub}points
   to  depends  on  the  implementation  of the subclass, usually it should
   point  to  a  NUL-terminated  C-string  with the name of the order to be
   used.   After  this  operation  has  succeeded,  the operation @{b}DS_UPDATE@{ub}
   should be performed to match the new order.

@{b}DS_GETORDER@{ub}
   If this operation is requested, the order of the rows is told; a pointer
   to the current order is stored in the address @{b}@{i}arg @{ui}@{ub}points to, the type of
   the  pointed data depends on the implementation of the subclass, usually
   it should point to a NUL-terminated C-string with the name of the order.

@{b}DS_AVAILABLEORDER@{ub}
   To  get  a pointer to a list with the available orders of the DataServer
   you  can request this operation; a pointer to a list of orders available
   for this DataServer is copied to the address @{b}@{i}arg @{ui}@{ub}points to.  The type of
   this list and its members depends on the implementation of the subclass,
   usually it should be a NULL-terminated array of C-string pointers.

@{b}DS_ORDERASCEND@{ub}
   The  rows  of  a  DataServer  can  be  ordered  ascend or descend.  This
   operation  changes  the order-direction; the argument @{b}@{i}arg @{ui}@{ub}is interpreted
   as  boolean,  if  @{b}@{i}arg @{ui}@{ub}is not NULL, the rows are ordered in ascend order,
   otherwise they are ordered descend.

@{b}DS_KEYEXPRESSION@{ub}
   To  generate  a key-value required to locate a specific row, you need to
   know  the  expression used to generate the keys for the currently active
   order.    This   operation   will   copy   a   pointer   the  expression
   (implementation  specific,  usually  a NUL-terminated C-string) into the
   address @{b}@{i}arg @{ui}@{ub}points to.

@{b}DS_KEYLENGTH@{ub}
   This  operation may be used to determine the length of a keyvalue of the
   currently active order. This size is required to allocate a buffer large
   enough to store a keyvalue as required for @{b}DS_CURRENTKEY@{ub}.
   The length is copied to the ULONG value @{b}@{i}arg @{ui}@{ub}points to.

@{b}DS_CURRENTKEY@{ub}
   To  get  the  keyvalue of the current row in the currently active order.
   This keyvalue is copied to the buffer @{b}@{i}arg @{ui}@{ub}points to.  Take care that the
   buffer  is  large  enough  to store a keyvalue (see @{b}DS_KEYLENGTH@{ub}).  This
   value might be passed to the operation @{b}DS_SEEK@{ub} to find this row again.

@{b}DS_SEEK@{ub}
   This  operation  is  used to seek to a row specified by a keyvalue.  The
   row is searched from top to bottom using the current order; the argument
   @{b}@{i}arg @{ui}@{ub} has  to  point  to  the  keyvalue  to be searched.  If @{i}soft-seek @{ui}is
   enabled, the search starts at the current row and stops on the first row
   with  a  keyvalue  that is equal to or greater than the specified value.
   If  @{i}soft-seek @{ui} is  disabled,  the  search starts at the first record and
   stops  if  an  row  with a keyvalue is found, that matches the specified
   value.   If  no  according  keyvalue  is found, the operation fails, the
   current row is set to end-of-file.

@{b}DS_SEEKNEXT@{ub}
   If  @{i}softseek @{ui} is enabled, this operation can be used after a successfull
   @{b}DS_SEEK@{ub} to seek to the next value. This operation works like @{b}DS_SEEK@{ub} and
   requires the same argument, the difference is that it starts the seek at
   the next row (i.e. the one just behind the currently active row), not at
   the first row.

@{b}DS_SOFTSEEK@{ub}
   This  operation  is  a switch, that enables or disables softseek; if the
   argument @{b}@{i}arg @{ui}@{ub}-- interpreted as boolean -- is @{b}TRUE@{ub}, @{i}soft-seek @{ui}is enabled,
   else @{i}soft-seek @{ui}is disabled (see @{b}DS_SEEK@{ub} and @{b}DS_SEEKNEXT@{ub} for details).

@{b}DS_SELECTROW@{ub}
   If  a  derived  class of the DataServer supports selection of rows, this
   operation  can  be  used  to  select  or  unselect the current row.  The
   argument  @{b}@{i}arg @{ui}@{ub} is interpreted as boolean, if it is @{b}TRUE@{ub}, the current row
   is selected,  else the selection of the current row is cleared.
   The  operation  should  return  @{b}TRUE@{ub},  if  it  is supported and could be
   successfully  performed,  it should only return FALSE, if the DataServer
   doesn't  supports  selection  or  an  unexpected error occurs, @{b}@{i}LastError @{ui}@{ub}
   should be set accordingly.

@{b}DS_FIRSTSELECTED@{ub}
   This operation should perform a skip to the first selected row, if there
   is  one selected at all.  If no row is selected, @{b}@{i}LastError @{ui}@{ub}should be set
   to  @{b}DS_ERR_NO_MORE_DATA@{ub}.  The number of the first selected row is stored
   in the ULONG, @{b}@{i}arg @{ui}@{ub}points to.
   If no row is selected, the value -- @{b}@{i}arg @{ui}@{ub}points to -- is not changed.

@{b}DS_NEXTSELECTED@{ub}
   If  more  than one row is selected, this operation should perform a skip
   to the next selected row.  If there are no more rows selected, @{b}@{i}LastError @{ui}@{ub}
   should  be  set to @{b}DS_ERR_NO_MORE_DATA@{ub}.  The number of the next selected
   row  is  stored in the ULONG, @{b}@{i}arg @{ui}@{ub}points to.  If no row is selected, the
   value -- @{b}@{i}arg @{ui}@{ub}points to -- is not changed.

@{b}DS_CLEARSELECTION@{ub}
   This operation clears all selections made. The argument 'arg' is not used.

@{b}DS_ISSELECTED@{ub}
   This  operation  evaluates  if  the  current  row  is  selected.  If the
   DataServer  doesn't  supports  selection,  or no row is the current one,
   FALSE  is  returned  and  @{b}@{i}DataServer.LastError @{ui}@{ub} is  set to the according
   errorcode;  if the DataServer supports selection, and the current row is
   not  selected,  @{b}FALSE @{ub} is returned, @{b}@{i}DataServer.LastError @{ui}@{ub}is set to 0; if
   the current row is selected, @{b}TRUE@{ub} is returned.
   The argument @{b}@{i}arg @{ui}@{ub}is not used.

@{b}DS_ALLOWSELECTION@{ub}
   Using  this  operation,  the  @{i}user @{ui}of the DataServer can evaluate if the
   DataServer supports selection of rows. The argument @{b}@{i}arg @{ui}@{ub}indicates, which
   kind  of selection is requested:  If its not @{b}NULL@{ub}, the DataServer should
   return  @{b}TRUE@{ub},  if  multiple selection is supported.  If @{b}@{i}arg @{ui}@{ub}is NULL, the
   DataServer  should  return  @{b}TRUE@{ub},  if  the  selection of a single row is
   supported.

@{b}DS_NUM_OF_ROWS@{ub}
   If you need to get the number of accessable rows,  this operation has to
   be requested.  The number of accessable rows  is copied to the ULONG @{b}@{i}arg @{ui}@{ub}
   points to.

@{b}DS_NUM_OF_COLUMNS@{ub}
   Corresponding  to @{b}DS_NUM_OF_ROWS@{ub} this operation can be used to determine
   the  number of accessable columns, the number is copied to the ULONG @{b}@{i}arg @{ui}@{ub}
   points to.

@{b}DS_CURRENTROW@{ub}
   You  can  determine  the  number  of  the current row by requesting this
   operation;  the  number  of the current row, as stored in the DataServer
   structures  @{b}@{i}CurrentRow @{ui}@{ub} member,  will be copied to the ULONG address @{b}@{i}arg @{ui}@{ub}
   points  to.  If currently no row is accessable  (e.g. the DataServer has
   just  been  created  and  no  @{b}DS_UPDATE@{ub}  has been performed, or the last
   @{b}DS_UPDATE@{ub} failed), this operation fails, the contents of the address @{b}@{i}arg @{ui}@{ub}
   points to is not changed.

@{b}DS_CURRENTCOLUMN@{ub}
   For direct manipulations of the DataColumns of a DataServer, you can use
   this  operation  to  get  a  pointer  to the DataColumn structure of the
   current  column.   If  currently  a column is selected, a pointer to the
   column  will  be  copied  to the address @{b}@{i}arg @{ui}@{ub}points to.  If no column is
   selected  (usually  just  after  the  DataServer  has been created or an
   @{b}DS_UPDATE@{ub} has been performed), this operation fails, the contents of the
   address @{b}@{i}arg @{ui}@{ub}points to is not changed.

@{b}DS_DISPOSE@{ub}
   This  operation  is  the one that has to be requested, if the DataServer
   has to be disposed; all resources used by the DataServer are freed.
   The argument @{b}@{i}arg @{ui}@{ub}is ignored by this operation.
@endnode

@node DataColumn "DataBase.library - Chapter 4, DataColumn"

@{b}@{fg shine}Chapter 4, DataColumn@{fg text}@{ub}

DataColumns  are  used  to  store  data  of the same type in every row of a
@{"DataServer" link DataServer}.   Each  DataServer  owns  several  DataColumns.  The DataServer
baseclass  doesn't  sets  an  upper limit of the number of DataColumns, the
number is just limited by the available memory of your system.

This  chapter will show you in the internals of DataColumns so you are able
to handle and manipulate them if required.

Sections:
   @{" The DataColumn structure               " link The_DataColumn_structure}
   @{" Adding DataColumns to a DataServer     " link Adding_DataColumns_to_a_DataServer}
   @{" Removing DataColumns from a DataServer " link Removing_DataColumns_from_a_DataServer}
   @{" Other functions for DataColumns        " link Other_functions_for_DataColumns}
@endnode

@node The_DataColumn_structure "DataBase.library - Chapter 4, DataColumn"
@toc DataColumn

@{b}@{fg shine}Section 4.1, The DataColumn structure@{fg text}@{ub}

The  DataColumn  structure,  as  defined  in <database/Dataserver.h> is the
basic  structure  used  to  contain  the  data  of  a  single  column  of a
@{"DataServer" link DataServer}.

You  need  to know this structure, because some kind of information that is
stored  in there could only be read direct from this structure, there is no
according access-function (I don't like needless overhead).

struct DataColumn
{
   STRPTR Name;              /* Name of the column (name of the datafield),
                              * NULL or empty strings are not allowed */
   STRPTR Caption;           /* caption that should be used for this column
                              * may be the same string as used for 'Name' */
   STRPTR HelpText;          /* a short descriptive text for that column,
                              * may be NULL */
   UWORD Flags;              /* see below for defines */
   UWORD Type;               /* Type identifier, see below for defines */
   ULONG Length;             /* length of the data (may depend on type) */
   ULONG Decimals;           /* only used with numeric values */
   ULONG Position;           /* position of the column in the row */
   UBYTE *Buffer;            /* buffer used for type-convertion */
   DC_CONVERT Convert;       /* type-convertion function */
   DC_REVERT Revert;         /* type-convertion function */
   struct DataServer *Server;/* pointer back to the owning DataServer */
};

Here are the fields of this structure:

@{b}Name@{ub}
   This field contains a pointer to a NUL-terminated C-string with the name
   of  the  column.   The  name  is  specified  during  the creation of the
   DataColumn,  the  buffer,  the  name  is  stored  in,  is  owned  by the
   DataColumn  and  is  not  allowed  to be changed.  Every DataColumn of a
   DataServer  must  have  an  unique  name (i.e.  it is not allowed to add
   columns  to  a  DataServer with a name that is already in use by another
   DataColumn  of the server).  The names are compared case-sensitive (e.g.
   "foo" is different to "Foo").

@{b}Caption@{ub}
   This  field  contains  a  pointer  to a NUL-terminated C-string with the
   caption  that  should  be  used  per  default, if the column needs to be
   titled  (e.g.   if  a  standard @{i}browser @{ui}should display the contents of a
   DataServer, it may read this @{b}@{i}Caption @{ui}@{ub}to title the displayed columns).
   If no @{b}@{i}Caption @{ui}@{ub}is specified, the @{b}@{i}Name @{ui}@{ub}is used instead.
   By using  different strings for @{b}@{i}Name @{ui}@{ub}and @{b}@{i}Caption @{ui}@{ub}you could easily create
   localized  applications:   While  the  @{b}@{i}Name @{ui}@{ub} remains  constant  in every
   language,  the  @{b}@{i}Caption @{ui}@{ub}may be changed from language to language, so you
   applications  code  will  always  access  the  columns  by the same @{b}@{i}Name @{ui}@{ub}
   regardless of the used @{b}@{i}Caption @{ui}@{ub}.

@{b}HelpText@{ub}
   This  field  contains  a  pointer  to  a  NUL-terminated C-string with a
   descriptive  help-text,  if  the  user  needs help about the contents or
   purpose  of a column (e.g.  you may create a standard @{i}browser @{ui}displaying
   the contents of a DataServer, and displaying @{i}bubblehelp @{ui}for every column
   using this @{b}@{i}HelpText @{ui}@{ub}as text of the @{i}bubble @{ui}).
   This  field  may  contain  a  @{b}NULL@{ub}  pointer,  if  no  @{b}@{i}HelpText @{ui}@{ub}should be
   available.

@{b}Flags@{ub}
   This   field  contains  bitflags  describing  the  current  state  of  a
   DataColumn and general attributes.
   The following flags are currently defined:

   @{b}DCF_READONLY@{ub}
      If this flag is set,  the DataColumn is read-only, i.e. if you try to
      write  anything  to  this  column  using  the  @{"DataServers operations" link Operations_every_DataServer_should_support}
      @{b}DS_SETRAWDATA@{ub} or @{b}DS_SETCOLUMNDATA@{ub}, these operations will fail.
      Usually  this flag is used by subclasses of the DataServer to protect
      the columns that contain private data from accidentically overwrites.

   @{b}DCF_AUTOVALUE@{ub}
      This  flag  may  be used from classes derived from DataServer to mark
      DataColumns  that  contain  any  kind  of data that is generated by a
      function  without  direct  user-input  (e.g.  a hash-value of another
      DataColumn).
      If  these  values  shouldn't  be overwritten, you should also set the
      flag @{b}DCF_READONLY@{ub} for these columns.

   @{b}DCF_OWNBUFFER@{ub}
      If  the  type-convertion buffer @{b}@{i}Buffer @{ui}@{ub}is owned by the DataColumn and
      needs  to  be  freed if the DataColumn is disposed, this flag is set.
      Under  some  circumstances  it may be usefull to handle the buffer by
      your applications code, in these cases you have to clear this flag.

   @{b}DCF_HIDDEN@{ub}
      Any  column  that contains data that is private for the DataServer or
      used  by  the  applications  code and should not be shown to the user
      (e.g.   internal  unique Ids or hash-values) may be marked using this
      flag. Any tool @{i}browsing @{ui}the contents of the DataServer should respect
      this flag and hide this column and its contents to the user.

   @{b}DCF_NOT_EMPTY@{ub}
      If  this  flag is set, the DataColumn must never contain @{b}NULL@{ub}-values.
      @{b}NULL@{ub}-values  are  empty  strings  for  the  DataColumns  of  the type
      @{b}DC_CHAR@{ub}, @{b}DC_TEXT@{ub} and @{b}DC_VARCHAR@{ub} or zero for numerical values.

   @{b}DCF_CHANGED@{ub}
      If this flag is set, this column has been changed and the changes are
      currently  not  saved  (i.e.  the  operation  @{b}DS_UPDATE@{ub}  has not been
      performed by now).

@{b}Type@{ub}
   The  @{b}@{i}Type @{ui}@{ub} field  describes the type of the data stored in a DataColumn.
   The following types are currently defined:

   @{b}DC_UNKNOWN@{ub}
      representing an unknown type, DataColumns of this type are ignored by
      the DataServer.
   @{b}DC_BYTE@{ub}
      a single byte integer value (-128 upto +127)
   @{b}DC_WORD@{ub}
      a two byte integer value (-32768 upto +32767)
   @{b}DC_LONG@{ub}
      a four byte integer value (-2147483648 upto +21474383647)
   @{b}DC_DOUBLELONG@{ub}
      a eight byte integer value
      (-9223372036854775808 upto 9223372036854775807)
   @{b}DC_FLOAT@{ub}
      a floating point number of single precision (IEEE), 4 bytes in length
   @{b}DC_DOUBLE@{ub}
      a floating point number of double precision (IEEE), 8 bytes in length
   @{b}DC_NUMERIC@{ub}
      a fixed point decimal value, with a length less or equal 19 bytes.
   @{b}DC_DATE@{ub}
      a date  in the gregorian calendar, after the year 1582 A.D., requires
      a length of 8 bytes (e.g. "20040227")
   @{b}DC_TIME@{ub}
      a time-value, the milli-seconds elapsed since midnight, it requires a
      length of 4 bytes
   @{b}DC_LOGIC@{ub}
      a boolean alike value, could be either @{i}true @{ui}('T') or @{i}false @{ui}('F'), a
      single byte in length.
   @{b}DC_CHAR@{ub}
      a fixed length string, filled up using spaces (character 32) to the
      maximum no. of characters specified by the DataColumns @{b}@{i}Length @{ui}@{ub}field.
   @{b}DC_VARCHAR@{ub}
      a NUL-terminated string, variable length, with a specified maximum
      number of characters.
   @{b}DC_TEXT@{ub}
      a variable length string, not supported by the DataServer class
      itself, it is implemented by the DataTable class.

@{b}Length@{ub}
   This  field  contains the total length of a single data in a DataColumn.
   This  value  is  set to default for every @{b}@{i}Type @{ui}@{ub}except for the columns of
   the @{b}@{i}Type @{ui}@{ub}:

   @{b}DC_NUMERIC@{ub}
      Here  the  length describes the total length of a numeric value, i.e.
      the  number  of  @{i}digits @{ui} of the integer plus the fraction part of the
      decimal  number.   The  comma  isn't stored and needs not to be taken
      into account, but the sign needs one @{i}digit @{ui};
      e.g. numeric values with 6 @{i}digits @{ui}in front of the comma (integer part)
      and  3  more  @{i}digits @{ui} behind the comma (fractional part) need a total
      length of 10 bytes (6 bytes integer + 3 bytes fraction + 1 byte sign).

   @{b}DC_CHAR@{ub} &
   @{b}DC_VARCHAR@{ub}
      The length of the data is the maximum number of characters that could
      be stored here. The terminating NUL-byte is not count.

   See  the  description  of  the  @{b}@{i}Type @{ui}@{ub}field of the DataColumn for details
   about the default sizes of the other datatypes.

@{b}Decimals@{ub}
   Except  for the @{b}DC_NUMERIC@{ub} datatype, this field is ignored and should be
   set  to  zero.   For  the  @{b}DC_NUMERIC@{ub} datatype, this field describes the
   number  of  digits  of  the fractional part of the decimal number.  This
   value must be always less than @{b}@{i}Length @{ui}@{ub}.

@{b}Position@{ub}
   This  field  specifies  the position of the DataColumn in the underlying
   @{i}device @{ui}.  It is  private to the DataServer and must not be changed under
   any circumstances.

@{b}Buffer@{ub}
   This buffer is used by the DataColumn for converting the contents into a
   @{i}human readable @{ui}string.
   Usually  it  is  owned  by  the  DataColumn and should never be accessed
   direct,  but  under  some  circumstances it may be usefull to use an own
   buffer  instead.   If  the  buffer has to be changed and is owned by the
   DataColumn  (the  flag  @{b}DCF_OWNBUFFER@{ub}  is set), you must free the buffer
   manually  (using the function @{b}@{i}FreeVector() @{ui}@{ub}found in the joinOS.library),
   clear  the  flag and store a pointer to your own buffer here.  Take care
   that this buffer is large enough.

@{b}Convert@{ub}
   A  pointer to a function used to convert the contents of this DataColumn
   from  @{i}raw @{ui} into @{i}human readable @{ui}format may be placed in this field.  This
   function should be of this type:

      @{b}BOOL ConvertFct (struct DataColumn *, APTR);@{ub}

   The  first  argument is a pointer to the DataColumn containing the value
   to be converted, the second argument is a pointer to the @{i}raw @{ui}value.  The
   result of this convertion has to be copied into the string-buffer of the
   DataColumn,  i.e.   the  memory  the  pointer  @{b}@{i}Buffer @{ui}@{ub} of the DataColumn
   structure points to.
   If  the  convertion  succeeds, i.e.  the @{i}raw @{ui}value is a valid value that
   could be converted, @{b}TRUE@{ub} has to be returned by this function.
   The  arguments  have  to  be  passed  in registers, i.e.  the DataColumn
   pointer  has to be passed in the register @{b}A0@{ub}, the second argument in the
   register  @{b}A1@{ub}.   The  returnvalue has to be passed in the register @{b}D0@{ub} (as
   usual for any AmigaOS library-function).
   A  function  type  definition for this type of function named @{b}DC_CONVERT@{ub}
   could be found in <joinOS/database/FunctionTypes.h>.

   If no function-pointer is placed in the @{b}@{i}Convert @{ui}@{ub}member of the DataColumn
   structure of a column, standard convertion is done as follows:

      @{b}DC_LOGIC@{ub}      - "true" or "false"
      @{b}DC_BYTE@{ub}       - an integer decimal string
      @{b}DC_WORD@{ub}       - an integer decimal string
      @{b}DC_LONG@{ub}       - an integer decimal string
      @{b}DC_DOUBLELONG@{ub} - an integer decimal string
      @{b}DC_FLOAT@{ub}      - a string representing the value in scientific format
                      "-d.dddddde-dd"
      @{b}DC_DOUBLE@{ub}     - a string representing the value in scientific format
                      "-d.ddddddddde-ddd"
      @{b}DC_NUMERIC@{ub}    - a decimal string as stored
      @{b}DC_CHAR@{ub}       - a string, truncated after the last non-whitespace
      @{b}DC_TIME@{ub}       - a string in the format "00:00:00.000"
      @{b}DC_DATE@{ub}       - a string in a format related to @{b}FORMAT_DOS@{ub}:
                      "dd-mmm-yyyy"
      @{b}DC_VARCHAR@{ub}    - no convertion is performed, i.e. the @{i}raw @{ui}value is
                      already @{i}human readable @{ui}, @{b}@{i}Buffer @{ui}@{ub}should just point to
                      the same value.
      @{b}DC_TEXT@{ub}       - no convertion is performed, the convertion function
                      for this kind of data has to be implementated by the
                      subclass of the DataServer class, that makes use of
                      this kind of DataColumn type

@{b}Revert@{ub}
   A  pointer  to  a  function  used  to  convert  a  @{i}human readable @{ui}string
   specifying  the contents of the DataColumn into the @{i}raw @{ui}format as stored
   in  the DataColumn may be placed in this field.  This function should be
   of the type:

      @{b}BOOL RevertFct (struct DataColumn *, STRPTR, APTR);@{ub}

   The  first argument is a pointer to the DataColumn the value belongs to,
   the second argument is a pointer to a NUL-terminated string representing
   the  value  to  be  converted  in  @{i}human  readable @{ui} form.  The @{i}raw @{ui}value
   evaluated by this function is stored in the destination buffer the third
   argument  points  to.  This would be usually a destination inside a kind
   of buffer used to store the whole contents of the current row.
   If  the  convertion  succeeds, i.e.  the string represents a valid value
   that could be converted, @{b}TRUE@{ub} has to be returned by this function.
   The  arguments  have  to  be  passed  in registers, i.e.  the DataColumn
   pointer  has to be passed in the register @{b}A0@{ub}, the second argument in the
   register @{b}A1@{ub}, and the third argument in the register @{b}A2@{ub}.  The returnvalue
   has  to  be  passed  in  the  register  @{b}D0@{ub}  (as  usual  for  any AmigaOS
   library-function).
   A  function  type  definition  for this type of function named @{b}DC_REVERT@{ub}
   could be found in <joinOS/database/FunctionTypes.h>.

   If no  function-pointer is placed in the @{b}@{i}Revert @{ui}@{ub}member of the DataColumn
   structure of a column, standard convertion is done, the passed string has to
   be formated as follows:

      @{b}DC_LOGIC@{ub}      - "TRUE", "T", "J", "Y", "Yes", "On" for @{i}true @{ui}('T')
                      every other string results in @{i}false @{ui}('F')
                      The comparison is done case-insensitive.
      @{b}DC_BYTE@{ub}       - any decimal string, the fractional part is ignored,
                      in the case of an overflow the result is undefined.
      @{b}DC_WORD@{ub}       - any decimal string, the fractional part is ignored,
                      in the case of an overflow the result is undefined.
      @{b}DC_LONG@{ub}       - any decimal string, the fractional part is ignored,
                      in the case of an overflow the result is undefined.
      @{b}DC_DOUBLELONG@{ub} - any decimal string, the fractional part is ignored,
                      in the case of an overflow the result is undefined.
      @{b}DC_FLOAT@{ub}      - any string representing a number, either as decimal
                      string or in scientific format
      @{b}DC_DOUBLE@{ub}     - any string representing a number, either as decimal
                      string or in scientific format
      @{b}DC_NUMERIC@{ub}    - a decimal string, in the case of an overflow the
                      result is undefined.
      @{b}DC_CHAR@{ub}       - any NUL-terminated C-string.  If it is longer than
                      the length of the storage-buffer of the DataColumn
                      (see @{b}@{i}Length @{ui}@{ub}), it is truncated.
      @{b}DC_TIME@{ub}       - a string in the format "00:00:00.000"
      @{b}DC_DATE@{ub}       - a date-string in @{b}FORMAT_DOS@{ub}: "dd-mmm-yy",
                      "dd-mmm-yyyy", "dd-mm-yy", or "dd-mm-yyyy"
      @{b}DC_VARCHAR@{ub}    - any NUL-terminated C-string.  If it is longer than
                      the length of the storage-buffer of the DataColumn
                      (see @{b}@{i}Length @{ui}@{ub}), it is truncated.
      @{b}DC_TEXT@{ub}       - not supported, has to be implemented by a subclass
                      of DataServer if it should be supported.

@{b}Server@{ub}
   This pointer is a pointer back to the DataServer owning the DataColumn.
@endnode

@node Adding_DataColumns_to_a_DataServer "DataBase.library - Chapter 4, DataColumn"
@toc DataColumn

@{b}@{fg shine}Section 4.2, Adding DataColumns to a DataServer@{fg text}@{ub}

DataColumns are added to a @{"DataServer" link DataServer} either during it's initialization, by
passing a pointer to an array of preinitialized DataColumn structures using
the   Tag   @{b}DS_Columns@{ub},   by   passing   such  an  array  to  the  function
@{b}@{i}DS_AddColumns() @{ui}@{ub}, or  by  requesting  the  operation  @{b}DS_ADDCOLUMN@{ub}  to  the
DataServer for adding a single DataColumn.

@{b}@{fg shine}Subsection 4.2.1, Using the Tag DS_Columns@{fg text}@{ub}
   If  you  wish  to  add  any number of DataColumns to a DataServer during
   initialization,  you  should add a TagItem with the Tag @{b}DS_Columns@{ub} and a
   pointer to an array of DataColumn structures as Data to the TagItem list
   passed to the @{"DS_InitA()" link Creation_of_DataServers} function.
   This  array has to be terminated by a DataColumn structure with its @{b}@{i}Name @{ui}@{ub}
   field set to @{b}NULL@{ub}. The following fields of the DataColumn structures in
   this array must be initialized, all unused fields should be set to zero:

   @{b}Name@{ub}
      This field must point to an unique name, the @{b}@{i}DS_InitA() @{ui}@{ub}function will
      fail  if  there  are two or more DataColumns with an equal name.  The
      string  will  be copied and need not to remain valid after @{b}@{i}DS_InitA() @{ui}@{ub}
      returned.
      Behind  the  last  DataColumn  structure  of the array that should be
      added  to  the DataServer, a DataColumn structure with the @{b}@{i}Name @{ui}@{ub}field
      set to @{b}NULL@{ub} must be placed to terminated the array.

   @{b}Type@{ub}
      The type of the DataColumns data has to be defined.

   @{b}Length@{ub}
      If  @{b}@{i}Type @{ui}@{ub} is set to DC_NUMERIC, DC_CHAR, or DC_VARCHAR, the length of
      the DataColumn needs to be specified, otherwise this field is ignored
      and the default length is used.

   @{b}Decimals@{ub}
      If  @{b}@{i}Type @{ui}@{ub}is set to @{b}DC_NUMERIC@{ub}, the number of digits of the fractional
      part  of  the  number needs to be specified.  This might be zero, but
      must be less than @{b}@{i}Length @{ui}@{ub}.

   All other fields could be initialized with desired values, but need not.
   The field @{b}@{i}Buffer @{ui}@{ub}is ignored.

@{b}@{fg shine}Subsection 4.2.2, Using the function DS_AddColumns()@{fg text}@{ub}
   You should avoid using this function to add DataColumns to a DataServer,
   because   a   subclass   of  the  DataServer  class  may  forbid  direct
   manipulations to the DataColumns and you would corrupt the DataServer in
   this case.
   If  you  are really shure you know what you are doing (e.g.  in the case
   you  implement  your  own subclass of DataServer), this function has the
   following prototype:

      @{b}BOOL DS_AddColumns  (struct DataServer *server,
                           struct DataColumn *template, ULONG numColumns);@{ub}

   Where  the  first  argument  specifies  the  DataServer, the DataColumns
   should  be  added to, the second argument points to an array of template
   DataColumns  equal  to  the  array  passed  via  the  Tag  DS_Columns to
   @{b}@{i}DS_InitA() @{ui}@{ub},  with  the  exception  that  this  array  needs  not  to be
   terminated  by a DataColumn with an empty @{b}@{i}Name @{ui}@{ub}field, instead the number
   of DataColumns to be added are specified by the third argument.
   If  the  function succeeds @{b}TRUE@{ub} is returned otherwise @{b}FALSE@{ub} is returned,
   which  indicates  either  an invalid value in the contents of the passed
   DataColumn array or a simple @{i}out-of-memory @{ui}error.

@{b}@{fg shine}Subsection 4.2.3, Using the operation DS_ADDCOLUMN@{fg text}@{ub}
   This  is the usual way to add DataColumns to a DataServer after this has
   been initialized.  This @{"operation" link Operations_every_DataServer_should_support} may not be supported by every subclass
   derived  from  DataServer,  but  it will notify you gracefully from this
   circumstances  instead  of trashing the DataServer as it would do if you
   use   the   function   @{b}@{i}DS_AddColumn() @{ui}@{ub}.  As  already  mentioned  in  the
   description  of the @{b}DS_ADDCOLUMN@{ub} operation you have to pass a pointer to
   a  DataColumn  template  -- initialized as a DataColumn structure in the
   arrays  passed  to  @{b}@{i}DS_AddColumn() @{ui}@{ub}or using the Tag @{b}DS_Columns@{ub} -- to the
   @{b}@{i}arg @{ui}@{ub}argument of the operation.
@endnode

@node Removing_DataColumns_from_a_DataServer "DataBase.library - Chapter 4, DataColumn"
@toc DataColumn

@{b}@{fg shine}Section 4.3, Removing DataColumns from a DataServer@{fg text}@{ub}

You  should  avoid  removing  of  DataColumns, this may not be supported by
every subclass of the @{"DataServer" link DataServer}.  But if you really need to, there are two
ways to remove columns from a DataServer:

@{b}@{fg shine}Subsection 4.3.1, Using the function DS_RemoveColumns()@{fg text}@{ub}
   You  should  avoid  using  this  function  to  remove DataColumns from a
   DataServer  because a subclass of the DataServer class may forbid direct
   manipulations to the DataColumns and you would corrupt the DataServer in
   this  case.   If  you are really shure you know what you are doing (e.g.
   in  the  case  you  implement  your  own  subclass  of DataServer), this
   function has the following prototype:

      @{b}BOOL DS_RemoveColumns  (struct DataServer *server,
                              ULONG firstColumn, ULONG numColumns);@{ub}

   Where  the  first  argument  specifies  the  DataServer, the DataColumns
   should  be  removed  from,  the  second  argument  specifies  the  first
   DataColumn to be removed (DataColumns are numbered from 1 to n), and the
   third argument specifies the number of DataColumns to be removed.
   If the function succeeds TRUE is returned otherwise FALSE is returned.
   This  function  frees  the  memory  used by the removed DataColumns, but
   nevertheless  the  function  may fail because of an @{i}out-of-memory @{ui}error,
   because it temporary needs additional memory for removage.

@{b}@{fg shine}Subsection 4.3.2, Using the operation DS_REMOVECOLUMN@{fg text}@{ub}
   This  @{"operation" link Operations_every_DataServer_should_support}  is  the  recommended  way to remove DataColumns from a
   DataServer.   This  way you could only remove single DataColumns, but if
   the subclass of the DataServer doesn't supports removing DataColumns, it
   would  notify  you  gracefully  about this instead of trashing the Data-
   Server.
@endnode

@node Other_functions_for_DataColumns "DataBase.library - Chapter 4, DataColumn"
@toc DataColumn

@{b}@{fg shine}Section 4.4, Other functions supporting manipulations of DataColumns@{fg text}@{ub}

For  easier  implementation of localized applications (i.e.  to support the
changing of the currently used language @{i}on the run @{ui})there are two functions
available:

   @{b}BOOL DC_SetCaption (struct DataColumn *column, STRPTR caption);@{ub}
   @{b}BOOL DC_SetHelpText (struct DataColumn *column, STRPTR helpText);@{ub}

These functions change the caption respectively the short helptext attached
to  a  DataColumn.  The specified strings are copied and need not to remain
valid after the functions have returned.

If the functions has succeeded, @{b}TRUE@{ub} is returned, else (i.e.  if not enough
free memory is available) @{b}FALSE@{ub} is returned.
@endnode

@node Indexes "DataBase.library - Chapter 5, Indexes"

@{b}@{fg shine}Chapter 5, Indexes@{fg text}@{ub}

Indexes  are  used  to  order  the  contents  of a @{"DataServer" link DataServer}.  The indexes
supported  by  the  database.library  are  able  to  order  the  rows  of a
DataServer  by nearly every column and also combinations and convertions of
the  columns  data  may  be  made for creating the sorting order.  The only
@{"DataColumn" link DataColumn}  types that cannot be indexed are the types @{b}DC_TEXT@{ub} (memo-files)
and  @{b}DC_VARCHAR@{ub}.   A key-value could be at most 256 bytes large, so @{b}DC_CHAR@{ub}
DataColumns with a @{b}@{i}Length @{ui}@{ub}above 256 characters cannot be indexed too.

The  indexes  are  optimized  for usage in conjunction with @{"DataTables" link DataTable}, but
should  also work with any kind of DataServer.  The only restriction to the
indexed  DataServer  is,  that the order of the DataColumns attached to the
DataServer  is  not  changed, respectively that no DataColumns -- that were
attached  to the DataServer during creation of an index -- are removed from
the DataTable while the index is in use.

If  the  number  of  DataColumns  of  the  DataServer  or  the order of the
DataColumns  is  changed,  all indexes of the DataServer have to be closed,
deleted from the filesystem, and completely rebuild.

If  you  are  interested  in the internal functionality of the indexes, you
should have a look into the appendix A @{"Implementation details" link Implementation_details}.

Sections:
   @{" Key-expressions and key-values          " link Key-expressions_and_key-values}
   @{" Converting functions of key-expressions " link Converting_functions_and_operators_of_key-expressions}
   @{" Functions for parsing key-expressions   " link Functions_for_parsing_key-expressions}
   @{" Creating an index                       " link Creating_an_index}
   @{" Disposing an index                      " link Disposing_an_index}
   @{" The IDXHeader structure                 " link The_IDXHeader_structure}
   @{" Functions for accessing an index        " link Functions_for_accessing_an_index}
   @{" Navigating through an index             " link Navigating_through_an_index}
   @{" Functions for changing an index         " link Functions_for_changing_an_index}
@endnode

@node Key-expressions_and_key-values "DataBase.library - Chapter 5, Indexes"
@toc Indexes

@{b}@{fg shine}Section 5.1, Key-expressions and key-values@{fg text}@{ub}

The  way  the  key-values  are  generated  is  defined  using  a  so-called
@{i}key-expression @{ui}.  This expression defines which @{"DataColumns" link DataColumn} should be taken
into  account  and  how  the  contents  of  these  columns is converted and
combined with the contents of other columns to build a single key-value.

The  shortest  possible  key-expression is the name of a single DataColumn.
This  way  the  index  orders the rows of the @{"DataServer" link DataServer} by the contents of
this DataColumn.

There are 6 different types of key-values:

Alphanumeric key-values
   These key-values are build from DataColumns of the type @{b}DC_CHAR@{ub} or other
   datatypes  that  are converted to strings using the according convertion
   function.  Key-values of this type could have any length between one and
   256  characters  and  are ordered by their ASCII-value, e.g.  the string
   "foo"  is  ordered  behind  "bar", and "foobar" is ordered behind "foo",
   where "This" is ordered before all the others.

Numeric key-values
   These key-values are build from DataColumns of the type @{b}DC_BYTE@{ub}, @{b}DC_WORD@{ub},
   @{b}DC_LONG@{ub}, @{b}DC_DOUBLELONG@{ub}, or @{b}DC_NUMERIC@{ub} or by converting the types @{b}DC_TIME@{ub},
   @{b}DC_DATE@{ub} or @{b}DC_CHAR@{ub} to numeric values using the appropirate functions.
   Key-values  of  this  type are always 8 bytes long and ordered according
   their  numeric value from minus infinite upto plus infinite, e.g.  @{b}-1@{ub} is
   ordered in front of @{b}0@{ub} and @{b}+1@{ub} is ordered behind @{b}0@{ub}.

Date key-values
   Dates are build from DataColumns of the type @{b}DC_DATE@{ub} without any further
   convertion. These values cannot be combined with any other value without
   convertion  into  a numeric or alphanumeric value.  These key-values are
   always 8 bytes long and are ordered from past to future.

Time key-values
   These  key-values  are  generated  by  indexing  DataColumns of the type
   @{b}DC_TIME@{ub}.   These  values cannot be combined with any other value without
   convertion  into  a numeric or alphanumeric value.  These key-values are
   always  4  bytes  long and are ordered from midnight (00:00:00.000) upto
   one millisecond before next midnight (23:59:59.999)

Logic key-values
   These key-values are build from DataColumns of the tyep @{b}DC_LOGIC@{ub}.  These
   values cannot be combined with any other value without convertion into a
   alphanumeric  value.  These key-values are always a single byte long and
   the @{i}false @{ui}values are ordered before the @{i}true @{ui}values.

Floating point key-values
   If  DataColumns of the type @{b}DC_FLOAT@{ub} or @{b}DC_DOUBLE@{ub} are indexed, this kind
   of  key-value  is  generated.   These values cannot be combined with any
   other  value  and there is no convertion possible.  These key-values are
   always 8 bytes long and ordered from minus infinite upto plus infinite.
@endnode

@node Converting_functions_and_operators_of_key-expressions "DataBase.library - Chapter 5, Indexes"
@toc Indexes

@{b}@{fg shine}Section 5.2, Converting functions and operators of key-expressions@{fg text}@{ub}

To  combine several @{"DataColumns" link DataColumn} to a single key-value, you usually have to
convert  the  values  of the DataColumns to the same kind of value, so they
could be combined.  The following functions and operators are supported for
this:

<value>@{b}+@{ub}<value>
   To  combine  the contents of two DataColumns or more to build a combined
   key-value,  the  operator  @{b}+@{ub}  can  be used.  The two expression that are
   combined by this operator have to be of the same type,  either a numeric
   or an alphanumeric key-value, other values have to be converted into one
   of these types before combining it.
   If  the  two key-values that should be combined are alphanumeric values,
   the  strings  are  just concatenated, e.g.  the two key-values "foo" and
   "bar" are concatenated to "foobar".
   If the two key-values are numeric values,  they are added,  e.g. the two
   key-values @{b}17@{ub} and @{b}4@{ub} are added to @{b}21@{ub}.  Overflows are ignored. An overflow
   occurs  if  the  result  is larger than 9223372036854775807 or less than
   -9223372036854775808.

@{b}Upper(@{ub}<value>@{b})@{ub}
@{b}Lower(@{ub}<value>@{b})@{ub}
   Alphanumeric  key-values  could  be converted, so the comparsion is made
   case insensitive. Therefore you could either use the function @{b}@{i}Upper() @{ui}@{ub}or
   @{b}@{i}Lower() @{ui}@{ub}.  The  according  key-expression for a DataColumn "FOO" ordered
   case  insensitive  would  look  either like "Upper(Foo)" or "lower(fOO)"
   (you see that the expressions itself are case-insensitive).

@{b}Str(@{ub}<value>@{i}[,<length>] @{ui}@{b})@{ub}
   This  convertion  function  converts  numeric  or  time  key-values into
   alphanumeric  values.   It  generates  a decimal string according to the
   value.   In  the  case  of  a  time-value  that should be converted, the
   resulting string represents the number of milliseconds since midnight as
   decimal  number.   The  default  length  of  the  generated string is 22
   characters  for  numeric  values  and 8 characters for time values.  The
   length  of  the  destination  string can be specified as optional second
   argument  of the function, but take care that the chosen length is large
   enough.   If  the  number of produced characters exceeds this length you
   produce a buffer overrun, i.e. the resulting string will contain a value
   like "-9999999" or "99999999".

   The  created  decimal  string will be right aligned with leading spaces,
   see the description of @{b}@{i}StrZero() @{ui}@{ub}for an example

@{b}StrZero(@{ub}<value>@{i}[,<length>] @{ui}@{b})@{ub}
   This function is simular to @{b}@{i}Str() @{ui}@{ub}with the exception, that the generated
   string is filled with leading zeros instead of spaces.

   Example:

      If @{i}foo @{ui}is a DataColumn of the type @{b}DC_WORD@{ub},  the following key-values
      will be generated according to the given key-expression:

        foo   | Str(foo,10) | Str(foo)                | StrZero(foo,7)
      --------+-------------+-------------------------+---------------
       123    | "       123"| "                   123"| "0000123"
      -123    | "      -123"| "                  -123"| "000-123"   (!!)
         0    | "         0"| "                     0"| "0000000"

      As  you  see,  it  is  not  wise  to use @{b}@{i}StrZero() @{ui}@{ub}if the value to be
      converted could be a negative value.

   This  function  is  very useful, if you wish to sort a @{"DataServer" link DataServer} by two
   numeric  DataColumns (lets name them @{i}"foo" @{ui}and @{i}"bar" @{ui}).  So the rows are
   ordered  primary  by @{i}foo @{ui}and that rows where the value in @{i}foo @{ui}is identi-
   cally  should  be  ordered  by  @{i}bar @{ui}.  This will result in the following
   key-values:

        foo  |  bar  | Val(Str(foo)+StrZero(bar,4))
      -------+-------+-----------------------------
        123  | 1234  | 1231234
          7  |   10  |   70010
          7  |  100  |   70100
          6  | 1000  |   61000
        123  |  -13  |    1230 (!!) -> Val("123"+"0-13") -> Val("1230-13")

      Again  you  see,  it  is not wise to use @{b}@{i}StrZero() @{ui}@{ub}if the value to be
      converted could be a negative value.

@{b}Val(@{ub}<value>@{b})@{ub}
   This  convertion  function can be used to convert any alphanumeric value
   into  a numeric key-value.  Leading spaces are skipped, an optional sign
   has to preceed the number without any space between sign and first digit.
   The convertion stops at the first non-digit. Overflows are not handled.

   Examples:

         foo   | Val(foo)
      ---------+---------
      "   -123"|   -123
      "123£   "|    123
      "foobar" |      0
      "12.98"  |     12

@{b}TToS(@{ub}<value>@{b})@{ub}
   This  function  can  be  used to convert a time key-value into an alpha-
   numeric  string  in the format "00:00:00.000".  This is not very usefull
   for  indexing,  you  should  prefer  using  the function @{b}@{i}Str() @{ui}@{ub}to get an
   alphanumeric string according to a time-value.

@{b}DToS(@{ub}<value>@{b})@{ub}
   This  function  converts  a  date  key-value as created from DataColumns
   containing @{b}DC_DATE@{ub} type data into a string in the from "YYYYMMDD".  This
   string could easily be combined with other alphanumeric values.

   Example:

      To  get  an  order that orders the rows of a DataServer that contains
      two  DataColumns  (@{i}"time"  @{ui}of the type @{b}DC_TIME@{ub} and @{i}"date" @{ui}of the type
      @{b}DC_DATE@{ub}) by date and time you could use an expression like this:

         "DTos (date) + Str (time)"

      It is wiser to enclose this expression by a @{b}@{i}Val() @{ui}@{ub}:

         "Val (DTos (date) + StrZero (time))"

      This  way  the  length of the key-value is reduced from 16 bytes to 8
      bytes which decreases the size of the index-file and reduces the time
      required to locate a specific key-value in the index.

@{b}LToC(@{ub}<value>@{b})@{ub}
   This  function converts logical key-values into alphanumeric key-values.
   The  @{i}true @{ui} value  is replaced by a 'T', the @{i}false @{ui}value is replaced by a
   'F'.   This  convertion  is  required  if a combined key-value should be
   created,  indexing  a  DataColumn  of  the  type  @{b}DC_LOGIC@{ub}  with another
   DataColumn.

A key-expression must not exceed 255 characters in length.
@endnode

@node Functions_for_parsing_key-expressions "DataBase.library - Chapter 5, Indexes"
@toc Indexes

@{b}@{fg shine}Section 5.3, Functions for parsing key-expressions@{fg text}@{ub}

These  function are used for parsing @{"key-expressions" link Key-expressions_and_key-values}.  They are used by the
indexes,  but may also be called from user-application (e.g.  to evaluate a
key-value required to seek to a specific record of a DataTable).


   @{b}LONG IDX_PreCompileExpression (struct DataServer *server, STRPTR keyExpr,
                                              UBYTE *buffer, ULONG bufSize);@{ub}

The  key-expression  used  for  an  index  should  be  precompiled  by this
function,  several  functions  expect a pointer to a precompiled expression
instead   of   the   original   NUL-terminated   C-string   containing  the
@{i}human readable @{ui}form.
By   precompiling   the  expression,  the  evaluation  speed  is  increased
dramatically.   The  first argument passed to this function is a pointer to
the  @{"DataServer" link DataServer}, that should be indexed by this key-expression. The access
to  the DataServer is required to examine the @{"DataColumns" link DataColumn} referenced by the
key-expression.
The  second argument is a pointer to the NUL-terminated C-string containing
the  key-expression  to  be compiled.  The third and fourth arguments are a
pointer  to the destination buffer for the precompiled expression, followed
by  the  bytesize  of  this  buffer.  This buffer has to be as large as the
string-length of the passed key-expression, at least two bytes.
If  the  function  succeeds,  the precompiled expression is copied into the
specified  buffer  and  the  number  of  bytes  copied  into that buffer is
returned.   If  @{b}-1@{ub}  is returned, this indicates an error, you should have a
look to @{b}@{i}IoErr() @{ui}@{ub}to get the cause of the failure:
Either  the buffer was to small (@{b}ERROR_BUFFER_OVERFLOW@{ub}), the system is run-
ning  out  of memory (@{b}ERROR_NO_FREE_STORE@{ub}), or the passed expression is not
valid (@{b}ERROR_BAD_TEMPLATE@{ub}).



   @{b}UWORD IDX_KeyLength (struct DataServer *server, UBYTE *keyExpr);@{ub}

A  precompiled  key-expression  may be passed to this function to determine
the  bytesize  of  a  key-value  that  is  produced  if  the  expression is
evaluated, so the according buffer to store such a value could be reserved.
As  another  benefit  of  this  function, the expression is tested if it is
valid.
The  function  expects  a  pointer  to  the  DataServer  structure  of  the
DataServer  that  should  be  indexed  using  the precompiled expression --
pointed to be the second argument.  If the expression is valid, the size of
the  buffer  required to store a single key-value created by evaluating the
expression  is  returned.   If  the function fails to parse the expression,
zero  is  returned.  This might be the case, if the expression is not valid
or  the system is running out of memory (in this case @{b}@{i}IoErr() @{ui}@{ub}should return
@{b}ERROR_NO_FREE_STORE@{ub}).



   @{b}BOOL IDX_GetKeyValue (struct DataServer *server,
                         APTR keyValue, UBYTE *expr);@{ub}

This function is used to generate the key-value by evaluating the specified
precompiled  key-expression  with  the  contents  of  the  current row of a
DataServer.   The  DataServer -- pointed to by the first argument -- has to
match  the  one  used  to  precompile the key-expression (pointed to by the
third argument), or this function will fail.
If  the  function succeeds, @{b}TRUE@{ub} is returned and the evaluated key-value is
copied   into   the   buffer   specified  by  the  second  argument.   This
user-supplied  buffer has to be large enough to contain the key-value.  Use
the  function  @{b}@{i}IDX_KeyLength() @{ui}@{ub} to  determine the required bytesize of this
buffer  (or  request the @{"operation" link Operations_every_DataServer_should_support} @{b}DS_KEYLENGTH@{ub} from the DataServer, if the
expression  belongs to the currently active order of the DataServer, but in
this  case  you  should  use  the  operation @{b}DS_CURRENTKEY@{ub} to determine the
key-value instead of calling this function).



   @{b}BOOL IDX_EvalExpressionA (struct DataServer *server, STRPTR expr,
                                                APTR key, ULONG *args);@{ub}

This  function  is  one of two functions available to generate a key-value,
that  is  not  generated  using  the  contents  of  the  current  row  of a
DataServer.  Instead the user has to pass an array containing the data that
should  be  used  instead  of the data of the DataColumns referenced by the
key-expression.
Nevertheless,  the  first  argument  has  to be a pointer to the DataServer
structure  of  the  DataServer  whichs  DataColumns  are  referenced by the
key-expression  (a non-compiled @{i}human readable @{ui}expression), that is pointed
to  by  the  second  argument.  The access to the DataServer is required to
determine  the  datatype  and  the  length  of  the data of the DataColumns
referenced  by  the key-expression.  If the key-expression specified by the
second  argument @{b}@{i}expr @{ui}@{ub}is not valid, the errorcode IDX_ERR_BAD_EXPRESSION is
set to the @{b}@{i}LastError @{ui}@{ub}field of this DataServer structure.
The generated key-value is stored in the user-supplied buffer pointed to by
the  third  argument @{b}@{i}key @{ui}@{ub}.  You have to take care that this buffer is large
enough to prevent a buffer-overflow.
The  data  used  to generate the key is passed in an array of ULONG values,
pointed  to  by  the fourth argument.  There must be an entry in this array
for  every DataColumn that is addressed by the key-expression.  The entries
in  the array have to be ordered as found in the expression (read from left
to right).  The type of this data depends on the datatype of the referenced
DataColumn (all values have to be casted to ULONG of cause):

   @{b}DC_BYTE@{ub} - a byte value
   @{b}DC_WORD@{ub} - a signed 2 byte word
   @{b}DC_LONG@{ub} - a signed 4 byte word
   @{b}DC_DOUBLELONG@{ub} - a pointer to a DOUBLELONG
   @{b}DC_TIME@{ub} - a pointer to a string in the format "HH:MM:SS.mmm"; where:
          'HH' is the number of hours (0 - 23)
          'MM' is the number of minutes (0 - 59)
          'SS' is the number of seconds (0 - 59)
          'mmm' is the number of milliseconds (0 - 999)
      The string could be terminated by a NUL-byte after each part sepa-
      rated by a colon or dot (e.g. "HH:MM" or "HH:MM:SS")
   @{b}DC_DATE@{ub} - a pointer to a string in the format "dd-mmm-yy",
      "dd-mm-yy", "dd-mmm-yyyy", or "dd-mm-yyyy"; where:
          'yyyy' is (any) year between 1582 and 10000
          'yy' is a year between 2000 and 2099 (e.g. "04" for 2004)
          'mm' is a month in numerical form (e.g. "12" for december)
          'mmm' is a month in alphanumerical form (e.g. "Dec" for december)
          'dd' is the day (2 characters required) (e.g. "13" or "02")
   @{b}DC_CHAR@{ub} - a pointer to a NUL-terminated C-string, if the string is
      longer than the addressed DataColumn, it is truncated.
   @{b}DC_NUMERIC@{ub} - a pointer to a NUL-terminated C-string representing a
      decimal number (e.g. "-123.567")
   @{b}DC_FLOAT@{ub} - a ptr. to a single precision (32 bit) floating point value
   @{b}DC_DOUBLE@{ub} - a ptr. to a double precision (64 bit) floating point value
   @{b}DC_LOGIC@{ub} - a single byte value, either 'F' or 'T'.

   Example:
      If  the  DataColumns  @{i}foo @{ui}, @{i}bar @{ui}, and  @{i}foobar @{ui} referenced by the key-
      expression "foo + Str (bar) + Str(foobar,5)" are of the types @{b}DC_CHAR@{ub},
      @{b}DC_TIME@{ub}, and @{b}DC_WORD@{ub} the array could look like this:

      ULONG args[] =
      {
         (ULONG)"Make love not war.",
         (ULONG)"23:55",
         32767
      };

If  the  arguments array contains the wrong number of arguments or the type
of the arguments is wrong, anything could happen (maybe you meet the @{i}Guru @{ui})
even if the system doesn't hang, the result is undefined and useless.

There  can be found an interface stub for a vararg version of this function
in the link-library @{i}Database.lib @{ui}:
   @{b}BOOL IDX_EvalExpression (struct DataServer *ds, STRPTR expr,
                                                       APTR key,...);@{ub}



   @{b}BOOL IDX_EvalExpressionB (struct DataServer *server, UBYTE *expr,
                                             APTR key, STRPTR *args);@{ub}

This is the second function available for generating key-values independent
of  the  current  rows  contents  of  the  DataServer.   In opposide to the
function  @{b}@{i}IDX_EvalExpressionA() @{ui}@{ub}, this  function  expects  a  pointer  to a
precompiled  key-expression  as second argument and an array of pointers to
NUL-terminated  C-strings for the arguments that should be used to evaluate
the  expression.   These  strings  represent  the  data that should be used
instead  of  the  data  of the referenced DataColumns and have to be in the
form as the data that would be passed to the DataColumn using the operation
@{b}DS_SETCOLUMNDATA@{ub}.

   Example:
      If  the  DataColumns  @{i}foo @{ui}, @{i}bar @{ui}, and  @{i}foobar @{ui} referenced by the key-
      expression "foo + Str (bar) + Str(foobar,5)" are of the types @{b}DC_CHAR@{ub},
      @{b}DC_TIME@{ub}, and @{b}DC_WORD@{ub} the array could look like this:

      STRPTR args[] =
      {
         "Make love not war.",
         "23:55",
         "32767"
      };

The  advantage  of  this function to the function @{b}@{i}IDX_EvalExpressionA() @{ui}@{ub}is,
that  it  could  be  used  easier for creating a key-value according to the
users  input.   You could pass the users input to this function without the
need of previously converting it to the destination format.
This  function  is  much  more  safer to use, because the key-expression is
already precompiled and therefore should be valid and a wrong argument just
produces  an  unusable key-value, but no system hang, as it could occure if
@{b}@{i}IDX_EvalExpressionA() @{ui}@{ub}is used.



   @{b}ULONG IDX_CountFields (STRPTR expr);@{ub}

This  function  is  located in the link-library @{i}Database.lib @{ui}and counts the
number  of  DataColumns  referenced  by a key-expression.  A pointer to the
NUL-terminated  C-string  containing  the  key-expression in @{i}human readable @{ui}
form  has to be passed as argument and the number of DataColumns referenced
is returned.
This  may  be  useful to know, to pass the right number of arguments in the
argument   arrays   passed   to  the  functions  @{b}@{i}IDX_EvalExpressionA() @{ui}@{ub} and
@{b}@{i}IDX_EvalExpressionB() @{ui}@{ub}.
@endnode

@node Creating_an_index "DataBase.library - Chapter 5, Indexes"
@toc Indexes

@{b}@{fg shine}Section 5.4, Creating an index@{fg text}@{ub}

Indexes   are   very   easy   to  create,  you  just  have  to  define  the
@{"key-expression" link Key-expressions_and_key-values}, build a TagItem list specifying the attributes of the index
and call the function:

   @{b}struct IDXHeader *IDX_InitA (APTR unused, struct TagItem *tagList);@{ub}

The function expects two arguments, where the first one @{b}@{i}unused @{ui}@{ub}is currently
not used and should be set to @{b}NULL@{ub} and the second is a pointer to a TagItem
list.

The  function  returns  a  pointer to the @{"IDXHeader structure" link The_IDXHeader_structure} of the opened
index.   If  specified  the according index file is opened or created if it
wasn't created previously.
If the function fails, @{b}NULL@{ub} is returned.  You should have a look at @{b}@{i}IoErr() @{ui}@{ub}
for an descriptive AmigaDOS errorcode.

The following Tags are defined for indexes:

@{b}IDX_FileName@{ub}
   The  data  of a TagItem with this Tag contains a pointer to a NUL-termi-
   nated  C-string  with the filename (and path) of the index-file.  If the
   file is currently not existing, it will be created.
   If this argument is not passed, the index will only resist in memory and
   will be lost, if it is disposed.
   In this case or if the index is currently not existing the TagItems with
   the Tags  @{b}IDX_Expression@{ub}, @{b}IDX_Name@{ub}, and @{b}IDX_Server@{ub} have to be present in
   the TagItem list.

@{b}IDX_Name@{ub}
   A pointer to a NUL-terminated C-string with the name of the index has to
   be stored in the data of a TagItem with this Tag.  This name is used for
   the @{b}DS_SETORDER@{ub} @{"operation" link Operations_every_DataServer_should_support}.
   The  string is limited to 32 characters (inclusive terminating NUL-byte)
   and is truncated to this length if a longer string is passed.  The sting
   is  case-sensitive.  If the indexfile already exists, the name stored in
   the file is used and this TagItem is ignored.

@{b}IDX_Expression@{ub}
   A Tagitem with this Tag has to be used to pass a pointer to a NUL-termi-
   nated C-string with the expression used for the index.  This TagItem has
   to  be  present  in  the  TagItem list, if no filename is passed to this
   function  (using  the  Tag  @{b}IDX_FileName@{ub})  or  the according file is not
   present.   The  length  of  an  expression  is limited to 256 characters
   (inclusive terminating NUL-byte).
   If the index-file is already existing, this TagItem is ignored.

@{b}IDX_Server@{ub}
   Using  a Tagitem with this Tag, a pointer to the DataServer structure of
   the DataServer this index should be attached to can be passed.
   The  DataServer  needs  to  be accessed, if the index-file isn't already
   existing or the index is completely build in memory
   If the index-file is already existing, this TagItem is ignored.

@{b}IDX_PageSize@{ub}
   The data of a TagItem with this Tag contains the size of one @{i}page @{ui}stored
   in the index-file. An index is organized in @{i}pages@{ui}. The larger the  page,
   the more keys could be stored in it, so fewer I/O's are required. On the
   other hand the data to  be read by a single I/O is larger and the index-
   file  wastes  more  space  because the @{i}pages @{ui}are justed filled something
   between 50 to 100 percent.
   This value has to be @{b}2^n@{ub},  where @{b}n@{ub} has to be chosen that the value is in
   the  range  from  @{b}1024@{ub} upto @{b}32768@{ub}.  If an illegal value is passed, it is
   rounded to match the requirements.
   If  this  value  is not specified, the optimal pagesize is calculated by
   this function.
   You  may use this TagItem, if the calculated pagesize will be very large
   and  you  prefer  smaller  pages,  maybe  because only very few keys are
   stored in the index or your file-system is uneffective with large block-
   transfers.
   This value is ignored, if the index-file is already existing.

@{b}IDX_Unique@{ub}
   This is a boolean Tag, i.e. if a TagItem with this Tag is present in the
   TagItem  list  and  the  index  is  newly created, the new index will be
   unique, no duplicate keys are allowed in this index.

@{b}IDX_Descend@{ub}
   This is also a boolean Tag, if a TagItem with this Tag is present in the
   TagItem list, the index will be ordered descend, i.e. the keyvalues with
   the @{i}highest @{ui}value are ordered first.
   This Tag is only useful, if you doesn't attache the index to a DataTable,
   otherwise  this setting is overwritten by the DataTable.  Send the oper-
   ation  @{b}DS_ORDERASCEND@{b} with the argument @{b}FALSE@{ub} to the DataTable to change
   the ordering to descend order in this case.

@{b}IDX_Custom@{ub}
   Another  boolean  Tag,  if  a  TagItem  with  this Tag is present in the
   TagItem  list,  the  index will not be handled by the DataServer itself,
   i.e. if  rows  are  added  or removed from the DataServer, the according
   keys  in  this  index have to be added/removed by the application itself
   using the @{"function" link Functions_for_changing_an_index} @{b}@{i}IDX_InsertKey() @{ui}@{ub}respectively @{b}@{i}IDX_RemoveKey() @{ui}@{ub}.

@{b}IDX_Exclusive@{ub}
   If this Tag is set in a TagItem of the TagItem list, the index is opened
   exclusive, i.e. every additonal try to open the index will be denied and
   the index need not to be locked before every access.

@{b}IDX_WriteBehind@{ub}
   If  a  TagItem  with  this Tag is present in the TagItem list, the index
   will  use  a  write-behind  caching-algorithm,  i.e.  the changes to the
   @{i}pages @{ui} of  the index are not written immediately after they are changed,
   instead  they  are written when the @{i}pages @{ui}are flushed from memory or the
   function  @{"IDX_EndTransaction()" link Functions_for_accessing_an_index}  is called.  If this option is used, the
   performance  of the index-changing-operations will increase slightly (if
   more  than  one  key  on  the  same  @{i}page @{ui} is  changed  during  the same
   transaction).   On  the  other  hand the chance that a system failure (a
   @{i}Guru @{ui}) will damage the index increases.

   NOTE:
      If   this  flag  is  set  the  functions  @{b}@{i}IDX_BeginTransaction() @{ui}@{ub} and
      @{b}@{i}IDX_EndTransaction() @{ui} MUST@{ub}  be used whenever the index is changed, or
      you will corrupt the index-file.


@{b}Example:@{ub}
   This is a small code-part showing how easy it is to create an index.  It
   is  not  a complete example, have a look at the examples provided in the
   @{i}"example" @{ui}directory shipped with the database.library.

   #include <joinOS/database/Index.h>
   #include <joinOS/database/DataServer.h>
   #include <joinOS/protos/DatabaseProtos.h>

   /* This is a TagItem list that may be used to create an index usable to
    * sort the music-collection DataTable created as example in the first
    * chapter of this documentation.
    * The index created using this TagItem list orders the DataTable by the
    * column "ALBUM", the name of the albums.
    */
   struct TagItem idxTags[] =
   {
      {IDX_FileName, (ULONG)"RAM:Album.idx"},
      {IDX_Name, (ULONG)"Album"},
      {IDX_Expression, (ULONG)"Upper(Album)"},
      {IDX_Server, 0L},        /* pointer is set-up just before creation */
      {TAG_DONE, 0}
   };

   struct IDXHeader *OpenIndex (struct DataServer *server)
   {
      /* This function creates the index that indexes the specified
       * DataServer that has to be already set-up somewhere else...
       */
      idxTags[3].ti_Data = (ULONG)server;

      return IDX_InitA (NULL, idxTags);
   }
@endnode

@node Disposing_an_index "DataBase.library - Chapter 5, Indexes"
@toc Indexes

@{b}@{fg shine}Section 5.5, Disposing an index@{fg text}@{ub}

If you need to dispose an index  (without deleting the according index-file
of cause), you only need to call the function:

   @{b}void IDX_Dispose (struct IDXHeader *idh);@{ub}

This  function will dispose the specified index and free all memory used by
it.   The index-file is closed, all outstanding writes are performed.  Take
care  that  the  index isn't attached to a @{"DataTable" link DataTable}, when this function is
called or you will crash the system.

Any  index  that  is attached to a DataTable is disposed when the DataTable
is  disposed,  i.e.   if  the  @{"operation" link Operations_every_DataServer_should_support}  @{b}DS_DISPOSE@{ub}  is performed for that
DataTable.
@endnode

@node The_IDXHeader_structure "DataBase.library - Chapter 5, Indexes"
@toc Indexes

@{b}@{fg shine}Section 5.6, The IDXHeader structure@{fg text}@{ub}

Every  index  is  accessed  through an IDXHeader structure used as a handle
(defined  in  <joinOS/database/Index.h>).   Usually you don't have to worry
about  this  structure,  but  sometimes  it  is  useful  to know about this
structures  and  its fields.  If not mentioned explicit you must not change
any  value  found  in  this  structure,  they  are  read-only  and most are
absolutely  private  and may be subject of change in future versions of the
database.library.

struct IDXHeader
{
   struct Node Link;               /* used to link to a list, 'ln_Name'
                                    * contains the name of the order */
   BPTR fh;                        /* FileHandle of index-file */
   UBYTE Flags;                    /* see below for defines */
   UBYTE Reserved[3];              /* reserved for future use */
   ULONG FirstPage;                /* offset to root node of the tree */
   ULONG FirstEmptyPage;           /* offset to first unused page */
   struct IDXMemPage *PagePtr;     /* ptr. to first page */
   struct IDXMemPage *CurrentPage; /* ptr. to currently processed page */
   struct DateStamp LastChanged;   /* date & time of last change of file,
                                    * this might be an illegal date ! */
   STRPTR Expression;              /* NUL-term. string with key-expr. */
   UBYTE *PreParsedExpr;           /* the prepcompiled key-expression */
   ULONG NumKeys;                  /* number of keys stored in the index */
   UWORD KeyLen;                   /* length of a key-value */
   UWORD Decimals;                 /* no. of decimals in key (not used) */
   UWORD KeySize;                  /* 'KeyLen'+8 rounded up to a multiple
                                    * of 4 */
   UWORD PageSize;                 /* size of a page */
   UWORD KeysPerPage;              /* maximum no. of Keys per page */
   UWORD CurrentKeyPos;            /* pos. of current key on the current
                                    * page, required for "skipping" */
   struct IDXKeyEntry *CurrentKey; /* buffer for the currently compared
                                    * key-value ('KeySize' bytes) */
   UBYTE *TopScope;                /* buffer for the key-value of the upper
                                    * boundary of a "Scope",'KeyLen' bytes*/
   UBYTE *BottomScope;             /* buffer for the key-value of the upper
                                    * boundary of a "Scope",'KeyLen' bytes*/
   struct IDXSFH sfh;              /* used to determine changes */
};

The fields of this structure have the following purpose:

@{b}Link@{ub}
   This is an embedded exec Node structure, used to link the structure into
   a list (e.g. the @{"DataTable structure" link The_DataTable_structure} contains a list of these structures
   representing the list of indexes attached to the @{"DataTable" link DataTable}).
   The @{b}@{i}ln_Name @{ui}@{ub}field of this structure contains a pointer to the NUL-termi-
   nated  C-string  with the name of the index, this name is used to access
   the index through the DataTables @{"functions" link Functions_for_managing_indexes_attached_to_the_DataTables} and @{"operations" link Operations_the_DataTable_supports}.

@{b}fh@{ub}
   This  field  may contain a valid BCPL-pointer to an AmigaDOS FileHandle.
   If  this  field contains zero, the index is a temporary index without an
   according  index  file located in any filesystem.  It is completely hold
   in memory and lost if the index is closed.

@{b}Flags@{ub}
   This  field  contains some flags, that notify about the current state of
   the index and its general attributes:

   @{b}IDX_UNIQUE@{ub}
      If  this flag is set, the key-values stored in this index are unique.
      If  you  try  to  add a new entry into this kind of index, that has a
      key-value  that  is  already  found in the index, this insertion will
      fail.
      Unique  indexes are a good choise for the main index of a DataServer,
      so you could address every row of the DataServer using an unique key-
      value.
      The DataTable class knows a flag -- @{b}DSF_FORCE_UNIQUE@{ub} -- that works in
      conjunction  with  unique  indexes.   If that flag is set (usually by
      placing  a TagItem with the Tag @{b}DBF_ForceUnique@{ub} into the TagItem list
      passed  to  the  function  @{"DBF_InitA()" link Creation_of_DataTables}),  the DataTable would fail to
      insert/update  records  that  injure  the unique key-value rule of an
      unique index.

   @{b}IDX_DESCEND@{ub}
      The  key-values  in an index are ordered as mentioned at the begin of
      this chapter.  If this flag is set, the index operates as if the key-
      values  were  ordered in descend order.  This flag may be set/cleared
      at any time, but if the index is attached to a DataServer, you should
      use  the  DataServers operation @{b}DS_ORDERASCEND@{ub} instead of @{i}poking @{ui}this
      flag by hand.

   @{b}IDX_CUSTOM@{ub}
      Usually the indexes attached to a DataTable are changed, whenever the
      contents  of  a  record  is  changed, so the indexes always match the
      contents  of  the  DataTable  (therefore  you  should always open and
      attache all indexes existing for a DataTable to that DataTable or the
      indexes  that  are not attached will become invalid).  If you want to
      create  and use an index, that is not managed by the DataTable itself
      (e.g.  you  could use such an index for marking records, only records
      that  are  marked  are  found in the index), this flag has to be set.
      This  is usually done by passing a TagItem with the Tag @{b}IDX_Custom@{ub} to
      the @{"index initializing function" link Creating_an_index}).
      The  key-entries  of an index with this flag set have to be added and
      removed  by the user-application using the @{"functions" link Functions_for_changing_an_index} @{b}@{i}IDX_InsertKey() @{ui}@{ub}
      and @{b}@{i}IDX_RemoveKey() @{ui}@{ub}.

   @{b}IDX_EXCLUSIVE@{ub}
      This flag indicates that the index is used exclusively, so no locking
      is required, which speeds up the access to the index.  You must never
      change this flag,  it could be set during initialization of the index
      by  passing  a  TagItem  with  the  Tag IDX_Exclusive to the function
      @{"IDX_InitA()" link Creating_an_index}.

   @{b}IDX_WRITEBEHIND@{ub}
      This  flags  setting  indicates, weather a write-behind-caching algo-
      rithm  is used or all changes to the index are written immediately to
      the  according  index-file.  it could be set during initialization of
      the  index  by  passing a TagItem with the Tag @{b}IDX_WriteBehind@{ub} to the
      function  @{b}@{i}IDX_InitA() @{ui}@{ub}.  You may change it, if the index is currently
      not attached to a DataServer and not inside of a transaction.
      Write-behind-caching  could  speed up the accesses to the index under
      some  circumstances,  but the risk to lose data and corrupt the index
      is  much higher than without write-behind-caching.  It should only be
      used,  if  the  application  and  the  connection  (network)  to  the
      underlying filesytem is absolute stable.

   @{b}IDX_ALIAS@{ub}
      If  this  flag  is  set, this structure isn't an IDXHeader structure.
      Instead  it  is  an IDXAlias structure of an alias of an index.  Most
      functions  accessing  indexes  will crash if you pass a pointer to an
      IDXAlias  structure  instead of an IDXHeader structure, so you should
      test  this  flag  if you are not shure what kind of structure this is
      (the  only  @{i}legal @{ui} way  to get access to an IDXAlias structure is the
      function   @{b}@{i}DBF_RemoveOrder() @{ui}@{ub}  of  the  DataTable  class,  all  other
      functions and operations will hide the alias and return the IDXHeader
      structure of the aliased index).

   @{b}IDX_RESERVED@{ub}
      This flagbit is reserved for future use and should not be accessed or
      misused.

   @{b}IDX_LOCKED@{ub}
      The last flag is used by the index itself to determine if the accord-
      ing  file is locked.  Whenever the index is locked, this flag is set,
      to  prevent  the  index  from  dead-locking  itself if it tries to to
      obtain another lock of the file.

@{b}Reserved@{ub}
   These three bytes are reserved for future use. You shouldn't access them.

@{b}FirstPage@{ub}
   This  field  contains the number of the @{i}page @{ui}containing the root node of
   the indexes tree in the indexes file.

@{b}FirstEmptyPage@{ub}
   The  unused  @{i}pages @{ui} in  the  index file are linked to a list, this field
   points  to the first @{i}page @{ui}in this list.  If this value is zero, there is
   no empty @{i}page @{ui}in the index file.

@{b}PagePtr@{ub}
   The index caches some @{i}pages @{ui}in memory to reduce I/O. This field contains
   the  pointer  to the  IDXMemPage  structure with the first cached @{i}page @{ui},
   usually  the  root  of  the tree.  See <joinOS/database/Index.h> for the
   definition of this structure.

@{b}CurrentPage@{ub}
   To  improve  the  performance  in accessing the currently processed key-
   entry,  a pointer to the IDXMemPage structure to the currently processed
   @{i}page @{ui}is stored here.

@{b}LastChanged@{ub}
   This embedded DateStamp structure contains the date and time of the last
   change of the indexes file that is known by this instance.
   If the DateStamp stored in the file is different to this, all @{i}pages @{ui}that
   are  cached by this instance of the index have to be disposed and reread
   from the file, because they might have been changed in the meantime.
   The DateStamp stored here might be an illegal date, don't pass it to any
   AmigaDOS function without previously checking it (@{b}@{i}ds_Tick @{ui}@{ub}may contain an
   illegal value).

@{b}Expression@{ub}
   This  field  contains  a pointer to the NUL-terminated C-string with the
   @{"key-expression" link Key-expressions_and_key-values} in @{i}human readable @{ui}form. This string is used for reference
   only  and  isn't  used  by  the index itself (nevertheless you shouldn't
   change it).

@{b}PreParsedExpr@{ub}
   The buffer pointed to by this field contains the @{"prepcompiled" link Format_of_precompiled_key-expressions} key-expres-
   sion used by the index to generate the key-values.

@{b}NumKeys@{ub}
   This  field contains the number of keys stored in the index.  This value
   is not always valid, it might be wrong if any other instance has changed
   the index in the meantime. You should use the function @{b}@{i}IDX_KeyCount() @{ui}@{ub}to
   determine the exact number of keys.

@{b}KeyLen@{ub}
   The bytesize of a buffer required to store a single keyvalue is found in
   this field. If the index is attached to a DataTable and is the currently
   active  index,  you  should  prefer  to get this value via the operation
   @{b}DS_KEYLENGTH@{ub}.  The  length  of a key could not exceed 256 bytes (in this
   version of the database.library).

@{b}Decimals@{ub}
   Imagined  for  indexing  @{"fixed-point numbers" link Functions_for_processing_fixed_point_numbers} this field was added to the
   IDXHeader structure. Because another faster way of indexing this kind of
   data was found, this field is meaningless now.
   It  may  be used for another purpose in the future, so don't access this
   field in any form (it may even be renamed).

@{b}KeySize@{ub}
   The contents of this field is: @{b}@{i}KeyLen @{ui}+ 8@{ub} rounded up to a multiple of 4.
   It  is  stored here so the index need not to calculate this value every-
   time it is required.

@{b}PageSize@{ub}
   The  index  is  stored  divided  in @{i}pages @{ui}in the index file.  This field
   contains  the bytesize of a single @{i}page @{ui}. It is always a @{i}power of 2 @{ui}, at
   least 1024.

@{b}KeysPerPage@{ub}
   This  field contains the number of keys that could be stored in a single
   @{i}page @{ui}.

@{b}CurrentKeyPos@{ub}
   To  improve  the  performance  in accessing the currently processed key-
   entry, the position of the current key on the current @{i}page @{ui}(@{b}@{i}CurrentPage @{ui}@{ub})
   is stored here.

@{b}CurrentKey@{ub}
   This  pointer  points to an IDXKeyEntry structure used to store the cur-
   rently  compared key-value.  This structure contains a buffer of @{b}@{i}KeySize @{ui}@{ub}
   bytes: @{b}@{i}KeyValue @{ui}@{ub}, that  may  be used by an user-application to store the
   key-value that should be located in the index.
   See <joinOS/database/Index.h> for the definition of this structure

   Example:

      ULONG FindRecord (struct DataServer *server,
                        struct IDXHeader *index, ULONG *args)
      {
         ULONG recNo = 0;

         if (IDX_EvalExpressionA (server, index->Expression,
                                 index->CurrentKey->KeyValue, args))
         {
            recNo = IDX_Seek (index, index->CurrentKey->KeyValue, FALSE);
         }
         return recNo;
      }

@{b}TopScope@{ub}
   This field contains a pointer to a buffer for the key-value of the upper
   boundary of a "Scope".

@{b}BottomScope@{ub}
   This field contains a pointer to a buffer for the key-value of the lower
   boundary of a "Scope".

@{b}sfh@{ub}
   This embedded IDXSFH structure is used by the index to determine changes
   to the index-file. For this purpose it is used as read-buffer.
   See <joinOS/database/Index.h> for the definition of this structure
@endnode

@node Functions_for_accessing_an_index "DataBase.library - Chapter 5, Indexes"
@toc Indexes

@{b}@{fg shine}Section 5.7, Functions for accessing an index@{fg text}@{ub}

There  are  several  functions in the database.libarary that are usable for
direct   accesses  to  indexes.   Most  of  them  you  will  not  need  for
user-applications  but  for  several special purposes there is no other way
than accessing them direct.

Whenever  these function needs to access a @{"DataServer" link DataServer}, they might store an
errorcode  in  the  @{b}@{i}LastError @{ui}@{ub} field  of  the  according  structure, if the
function  failed.   The  errorcodes  in  the  range  from  2000 to 2999 are
reserved for the indexes.



   @{b}BOOL IDX_StartTransaction (struct IDXHeader *idh, LONG accessType);@{ub}

Whenever  you want to access an index that is not opened exclusive (or that
is opened with write-behind caching enabled) you have to call this function
before   accessing   it  to  gain  control  over  the  index  and  suppress
access-conflicts.   The first argument passed to this function is a pointer
to  the  @{"IDXHeader structure" link The_IDXHeader_structure}  of  the  index,  the  second  argument is an
identifier, specifying which kind of access should be performed:

   @{b}IDX_READ@{ub}
      For  read-only  accesses,  several  instances could lock an index for
      read  access  at  the  same time, but as long as any instance holds a
      read-lock of the index, no write-lock could be obtained.

   @{b}IDX_WRITE@{ub}
      If you need to change the index, it has to be locked for write access.
      This  is  an  exclusive lock.  While it is locked exclusive, no other
      instance  of  this  index could gain any kind of access to it, so you
      should release this lock as fast as possible.

If  the lock of the index could not be performed immediately, because there
is  a  conflict  with  an  already  set  lock, this function will wait upto
@{b}LOCK_TIMEOUT@{ub}  (currently  defined  as 15) seconds for the lock to be freed,
before it will fail.
If  @{b}FALSE@{ub}  is  returned indicating a failure (instead of @{b}TRUE@{ub} for success),
you  should  have  a  look  to  AmigaDOS @{b}@{i}IoErr() @{ui}@{ub}function for a descriptive
errorcode.    This   should   usually  be  either  @{b}ERROR_LOCK_COLLISION@{ub}  or
@{b}ERROR_LOCK_TIMEOUT@{ub} for a detected lock-collision.



   @{b}BOOL IDX_EndTransaction (struct IDXHeader *idh, LONG accessType);@{ub}

Every  successfull  call  to  @{b}@{i}IDX_StartTransaction() @{ui}@{ub}has to be matched by a
call  to  this function.  This function-call should be performed as fast as
possible to allow other instances to access the index.
The  first  argument  is a pointer to the IDXHeader structure of the index,
thesecond  one  has  to  be  the  same  value  as  passed  to  the matching
@{b}@{i}IDX_StartTransaction() @{ui}@{ub}call.
If write-behind caching is enabled, this is the latest moment, when changes
are  written to the index file.  After this function returned successfully,
the index file should be updated to the changes made to the index.



   @{b}BOOL IDX_ValidKey (struct IDXHeader *ihd);@{ub}

This  function  determines  if  the index is positioned at an entry or not,
i.e.  if  a call to any @{"function" link Navigating_through_an_index} like @{b}@{i}IDX_SeekNext() @{ui}@{ub}, @{b}@{i}IDX_SkipPrevious() @{ui}@{ub},
@{b}@{i}IDX_SkipNext() @{ui}@{ub}, or @{b}@{i}IDX_RemoveKey() @{ui}@{ub}could succeed.
This  function  is  usually called after a successfull call to the function
@{b}@{i}IDX_StartTransaction() @{ui}@{ub}, because that function will clear the current entry,
if the index-file has been changed by another instance of this index.
If  this  function fails, but the index is attached to a DataServer and the
DataServer is positioned at a valid row, which should have a matching entry
in  this  index, you have to call @{b}@{i}IDX_FindKey() @{ui}@{ub}before any of the functions
named above is called.



   @{b}BOOL IDX_SetScope (struct IDXHeader *ihd,
                        APTR topScope, APTR bottomScope);@{ub}

A  scope  might be established for an index.  A scope is a range within the
key-entries  of  the  index,  where the functions that operate on the index
should  work  within.   A  scope  is  specified  by  its top and its bottom
boundary.   Each  boundary  is  specified  by  a  @{"key-value" link Key-expressions_and_key-values}.  If you try to
position  (seek  or skip) to a key-entry that is less than the top boundary
or  that is greater than the bottom boundary, it would fail; it seems as if
the begin or end of the index is reached.
This  way  you  can easily filter the processed entries without performance
loss.   This  function  has  to be used to set and clear such a scope.  You
have to specify the index by a pointer to its IDXHeader structure passed as
first  argument,  the  second  and  third  arguments  are  pointers  to the
key-values  that  should  be used as boundaries of the scope.  You may pass
NULL  to  any of these key-values to clear the according boundary, i.e.  if
the  top  scope  is  cleared,  the  index  operates  starting  at the first
key-entry  stored  in it, if the bottom scope is cleared, the last entry in
the index is the bottom boundary.
If  you  specify both boundaries, the top boundary must be less or equal to
the bottom boundary or this function will fail.



   @{b}ULONG IDX_KeyCount (struct IDXHeader *ihd);@{ub}

This  function determines the number of key-entries currently accessable in
the  index,  i.e.   it  takes  the setting of the top and bottom scope into
account.   If  you  wish  to  know  the  total  number of keys in the index
independent  of  the  current  setting  of  the  scopes,  you  may read the
@{b}@{i}NumKeys @{ui}@{ub} field  of  the  IDXHeader structure, if you enclose this access to
the     structure     by     the    functionpair    @{b}@{i}IDX_StartTransaction()/
IDX_EndTransaction() @{ui}@{ub}. This is the fasted way to determine this value.
@endnode

@node Navigating_through_an_index "DataBase.library - Chapter 5, Indexes"
@toc Indexes

@{b}@{fg shine}Section 5.8, Navigating through an index@{fg text}@{ub}

The  following  functions  are  used  to  select  a  key-entry in an index.
Usually  they  return  the  number  of  the  according  row  in the indexed
@{"DataServer" link DataServer}.    Most   functions  operate  relative  to  the  last  accessed
key-entry, the so-called current key.


   @{b}BOOL IDX_FindKey (struct IDXHeader *ihd, struct DataServer *server);@{ub}

This  function  tries  to  find  the key matching to the current row of the
specified  DataServer in the index.  This is usefull, if you wish to remove
the  key  for the current row of the DataServer.  In this case the function
@{b}@{i}IDX_RemoveKey() @{ui}@{ub}has to be called after this function has succeeded.
If the key-entry for the current row of the DataServer is found, it is used
as current key and @{b}TRUE@{ub} is returned, else @{b}FALSE@{ub} is returned.



   @{b}ULONG IDX_Seek (struct IDXHeader *ihd, APTR key, BOOL softSeek);@{ub}

This function tries to locate the entry with the specified @{"key-value" link Key-expressions_and_key-values} in the
index and returns the number of the according row in the DataServer.
The  function  expects  a  pointer  to  the  @{"IDXHeader structure" link The_IDXHeader_structure}  as  first
argument,  followed  by a pointer to the key-value as second argument and a
boolean  value as third argument.  This boolean value specifies weather the
search  should  stop  at the first entry with an equal or greater key-value
than  the  specified  one  (@{b}TRUE@{ub})  or  if  it  should only seek to an equal
matching  key-value  (@{b}FALSE@{ub}).  If the index is not unique and there are two
or  more  entries  matching  the key, the record number of the first one of
these entries is returned so this function could be followed by a loop-call
to  @{b}@{i}IDX_SeekNext  (ihd,  key, TRUE) @{ui}@{ub}to get access to all records that match
this key.
If  a  matching  key-value is found, the number of the according row in the
DataServer  is returned; if no matching key-value is found (respectively no
key-value greater than the searched one if @{b}@{i}softSeek @{ui}@{ub}is set to @{b}TRUE@{ub}), zero
is returned.
See the following description of the function @{b}@{i}IDX_SeekNext() @{ui}@{ub}for an example.



   @{b}ULONG IDX_SeekNext (struct IDXHeader *ihd, APTR key, BOOL softSeek);@{ub}

This  function  is  somehow simular to @{b}@{i}IDX_Seek() @{ui}@{ub}, but in opposide to that
function it tries to locate the entry starting at the current position, not
at the begin of the index (or scope).
You  should  search  the  first  matching row using the function @{b}@{i}IDX_Seek() @{ui}@{ub}
because that function is quite faster for this purpose.

Example:

   This  code-fragment is  designed  for the @{i}Album @{ui}DataTable created in the
   @{"first chapter" link AlbumDB}  and uses  an  index as mentioned in the first section of
   this  chapter (i.e.  an index of the @{i}Album @{ui}DataTable, with a key-expres-
   sion of "Upper (Album)").

   void FindAll (struct IDXHeader *index,
                  struct DataServer *server, STRPTR name)
   {
      /* This function finds and displays the recordnumbers of all rows in
       * the indexed DataServer where the indexed DataColumn contains a
       * string that starts with the specified string.
       */
      APTR keyValue;

      /* Use the 'keyValue'-buffer provided by the index...
       */
      keyValue = index->CurrentKey->KeyValue;

      /* Evaluate the key-expression and generate the key-value...
       */
      if (IDX_EvalExpression (server, index->Expression, keyValue, name))
      {
         if (IDX_StartTransaction (index, IDX_READ))
         {
            ULONG recNo;

            if (recNo = IDX_Seek (index, keyValue, FALSE))
            {
               printf ("%ld", recNo);

               while (recNo = IDX_SeekNext (index, keyValue, FALSE))
                  printf (", %ld", recNo);

               printf ("\n");
            }
            else printf ("No matching record found.\n");

            IDX_EndTransaction (index, IDX_READ);
         }
      }
   }

   To find all records with an album named "Best of":

      FindAll (index, server, "Best of");



   @{b}ULONG IDX_SkipTop (struct IDXHeader *ihd);@{ub}

This  function returns the number of the row in the DataServer according to
the  first  key-entry  stored in the index respectively the first key-entry
found inside the set scope.


   @{b}ULONG IDX_SkipBottom (struct IDXHeader *ihd);@{ub}

This  function returns the number of the row in the DataServer according to
the  last  key-entry  stored  in  the index respectively the last key-entry
found inside the set scope.


   @{b}ULONG IDX_SkipNext (struct IDXHeader *ihd, ULONG numKeys);@{ub}

Using  this  function,  a  following  key-entry  of  the current one can be
skipped  to.  The  second argument @{b}@{i}numKeys @{ui}@{ub}is used to specify the number of
key-entries that should be skipped.
The  number of the according row in the indexed DataServer is returned.  If
you  pass  the  last  accessable  key-entry  in  the  index or the index is
currently not positioned at a valid entry, zero is returned.

Example:

   To get all records in the order they are stored in the index:

   if (IDX_StartTransaction (index, IDX_READ))
   {
      ULONG recNo;

      if (recNo = IDX_SkipTop (index))
      {
         printf ("%ld", recNo);

         while (recNo = IDX_SkipNext (index))
            printf (", %ld", recNo);

         printf ("\n");
      }
      else printf ("Index (or the current scope) is empty.\n");

      IDX_EndTransaction (index, IDX_READ);
   }



   @{b}ULONG IDX_SkipPrevious (struct IDXHeader *ihd, ULONG numKeys);@{ub}

Equivalent to @{b}@{i}IDX_SkipNext() @{ui}@{ub}you can use this function to skip to a preced-
ing key-entry of the current one.   The  second argument @{b}@{i}numKeys @{ui}@{ub}is used to
specify the number of key-entries that should be skipped.
The  number of the according row in the indexed DataServer is returned.  If
you  pass  the  topmost  available  key-entry  in the index or the index is
currently not positioned at a valid entry, zero is returned.
@endnode

@node Functions_for_changing_an_index "DataBase.library - Chapter 5, Indexes"
@toc Indexes

@{b}@{fg shine}Section 5.9, Functions for changing an index@{fg text}@{ub}

The  following  functions  are  usable to manipulate an index.  Usually the
indexes  are  manipulated  inplicit,  but  if you create custom-indexes (by
passing  a TagItem with the Tag @{b}IDX_Custom@{ub} to the @{"initialization function" link Creating_an_index}),
you need to add and remove the key-entries manually.
However,  if  you wish to manipulate an index that is not opened exclusive,
you   have   to   enclose   the   function-call   by   the   function  pair
@{"IDX_StartTransaction()/IDX_EndTransaction()" link Functions_for_accessing_an_index} using the lock-mode @{b}IDX_WRITE@{ub}.


   @{b}BOOL IDX_InsertKey (struct IDXHeader *ihd, struct DataServer *server);@{ub}

This  function  inserts  a  key-entry  for the current row of the specified
@{"DataServer" link DataServer}  into  the  index.  It only performs a test, if there is already
a  key-entry  with  the  same  key-value  part  of  the index, if the index
is  created  using  the  Tag  @{b}IDX_Unique@{ub}.   If  a  duplicate  @{"key-value" link Key-expressions_and_key-values}  is
found  in   this   case,   the   insertion   will   fail   with  an  error-
code  of  @{b}IDX_ERR_DUPLICATE_KEY@{ub}  stored  in  the  @{b}@{i}LastError @{ui}@{ub} field  of  the
@{"DataServer structure" link The_DataServer_structure}.
If  the  function succeeds, @{b}TRUE@{ub} is returned, the new inserted key-entry is
the current one (i.e.  skips will be performed relative to this entry).  If
the  insertion  fails,  @{b}FALSE@{ub} is returned.  See @{b}@{i}LastError @{ui}@{ub}of the DataServer
structure  for  a  descriptive  errorcode.   You  may  also  have a look to
AmigaDOS's  IoErr() function for the cause of I/O-errors (usually indicated
by an errorcode of @{b}DS_ERR_MAYOR@{ub} found in @{b}@{i}LastError @{ui}@{ub}).



   @{b}BOOL IDX_RemoveKey (struct IDXHeader *ihd);@{ub}

This function removes the key that was last accessed (e.g. using @{"IDX_Seek()" link Navigating_through_an_index}
or @{"IDX_FindKey()" link Navigating_through_an_index}) from the index.
After  the key is removed, the index is positioned on the successor of this
key, so you could loop-call this function to remove any number of keys from
the index.

   @{b}ATTENTION:@{ub}
      The setting of the flag @{b}IDX_DESCEND@{ub} is not taken into account by this
      function,  it  will  always position to the next key-entry, as if the
      flag is not set.



   @{b}BOOL IDX_ClearIndex (struct IDXHeader *ihd);@{ub}

If  you  need  to  remove  all key-entries from an index (e.g.  if a custom
index  is  used  to  remember  rows  of a DataServer that have been somehow
selected  and all selections made should be discarded) this function may be
used  for  this  purpose.   It  is  quite  faster than removing the entries
one-by-one using the function @{b}@{i}IDX_RemoveKey() @{ui}@{ub}.
You   need   not   to   enclose   this   function   by   the  function-pair
@{b}@{i}IDX_StartTransaction()/IDX_EndTransaction() @{ui}@{ub}.  This  function  will  try to
obtain exclusive access to the index-file, before it clears the index.

@{u}There are two mayor problems in using this function:@{uu}

At  first  there are several filesystems in use for the Amiga, that doesn't
have  implemented  the  @{b}ACTION_SET_FILESIZE@{ub}  packet  (used  by the AmigaDOS
function @{b}@{i}SetFileSize() @{ui}@{ub}).  If this function detects this error, it tries to
close the file, delete it from the filesystem and recreate it.  Because the
exclusive  access  to  the file is not guaranteed for this whole procedure,
another  process  may  gain  control  over the file during this function is
performed  and  the  index  couldn't be recreated successfully.  You should
try,  not  to  run  any  application in the background that does access the
filesystem  during  this  function  is  processed  (e.g.   have  a  running
backup-program  in  background)  to  avoid this kind of problem if you know
that  your  filesystem is missing the @{b}ACTION_SET_FILESIZE@{ub} packet (or if you
don't know if it is implemented).

A second problem is known in conjunction with the AmigaOS Ram-handler, that
handles  the ram-disk.  Every known version of this handler doesn't support
exclusive  file-accesses, i.e.  even if you gain exclusive access to a file
(e.g.   by  using the AmigaDOS function @{b}@{i}ChangeMode() @{ui}@{ub}) the Ram-handler will
not  reject  any  further  accesses  to  this  file,  the file is shareable
nevertheless.
To  detect  such  an  error-condition  after  this function has failed, you
should  have  a look to the @{b}@{i}fh @{ui}@{ub}field of the @{"IDXHeader structure" link The_IDXHeader_structure}.  If it was
previously not zero (i.e.  there is an according index-file) and this field
is  zero  after this function returned, the index-file is damaged.  In this
case  you  should  terminate  your  application,  delete  the  damaged file
manually  and  restart the application.  The next time the index is opened,
the file should be created correct.



   @{b}BOOL IDX_ReIndex (struct IDXHeader *ihd, struct DataServer *server,
                                 REINDEX_PROGRESS fct, APTR userdata);@{ub}

As every access to a physical medium may fail (e.g.  power fault), an index
may  become  invalid  under  serveral circumstances.  If you detect such an
illegal  index,  you  should  perform  a reindexing of the damaged index by
calling this function.
This  function  will try to obtain exclusive access (so you need not to en-
close this function call by the @{b}@{i}IDX_StartTransaction()/IDX_EndTransaction() @{ui}@{ub}
function pair), clear the index and then try to add one key-entry for every
row of the DataServer to the index. Besides the first argument -- a pointer
to  the  IDXHeader  structure  of  the index -- a pointer to the DataServer
structure  of  the  DataServer  to be indexed has to be specified as second
argument.   This  DataServer  should  not  have any active order (shouldn't
currently  use  an  index),  because  this  would  slow down the reindexing
process  and  you wouldn't access the rows that aren't found in that index.
You  should  also  take care, that the @{b}DSF_SHOW_DELETED@{ub} flag is not set, or
the index would contain key-entries for already deleted rows.

The  additonal two arguments are used for user notification of the progress
of  this  function.   Because  this  function  takes quite long if a larger
DataServer  is  indexed,  the user-application calling this function should
notify  the  user  about  the  progress  made  and  may  enable the user to
interrupt  the  reindexing  process.   For  this  purpose you may specify a
pointer  to a function that is called everytime 10 key-entries are added to
the index.
This function has to be of the form (an according function-type definition
named @{b}REINDEX_PROGRESS@{ub} is found in <joinOS/database/FunctionTypes.h>):

   @{b}BOOL progressFct (struct IDXHeader *ihd, ULONG rows, APTR userdata)@{ub}

This function will get three arguments passed via registers:  The first one
is  a  pointer  to the IDXHeader structure of the processed index (register
@{b}A0@{ub}),  the  second  one is the number of already added key-entries (register
@{b}D0@{ub}),  and  the third argument is the pointer that has been passed as fourth
argument  to  @{b}@{i}IDX_ReIndex() @{ui}@{ub} (register  @{b}A1@{ub}).  This can point to any kind of
data  and  may  be @{b}NULL@{ub}, e.g.  you may pass a pointer to the window used to
display a progress-bar using this pointer.
This  function  should  return  @{b}TRUE@{ub}  (in register @{b}D0@{ub}) to indicate that the
reindexing  should  be  continued  or @{b}FALSE@{ub} if the user wishes to abort the
reindexing  process.   Be  aware  that aborting the reindexing process will
result  in an uncomplete index and you have to restart the whole reindexing
process, there is no way to continue an interrupted reindexing.

As  of the same reasions mentioned for @{b}@{i}IDX_ClearIndex() @{ui}@{ub}, this function may
fail  because  of  inadequate  implemented filesystems.  You should use the
DataTables  @{b}@{i}DBF_ReIndex() @{ui}@{ub}function for reindexing indexes that are attached
to a DataTable, this function will handle the possible errors in a way that
prevents the system from crashing.
@endnode

@node DataTable "DataBase.library - Chapter 6, DataTable"

@{b}@{fg shine}Chapter 6, DataTable@{fg text}@{ub}

DataTables  are  the  main  components  of  a database.  Usually a database
consists  of  several  related  datatables.   Each  datatable could contain
(nearly) an innumerable set of records, each containing up to 255 fields of
data of any type (see @{"DataColumns" link DataColumn}).

The DataTable is a subclass of @{"DataServer" link DataServer}.  The instances of this class are
able to process datatables stored in a filesystem.  Each DataTable contains
several  rows  -- the records -- each containing the same set of columns of
data -- the DataColumns.

The  records  of DataTables could be ordered using indexes.  See chapter 5,
@{"Indexes" link Indexes} for details.

The  DataTable hides the accesses to the datatable files and indexes to the
application designer and takes care that these files are always valid.  You
should  have  a look at the appendix A, @{"Implementation details" link Implementation details}, if you wish
to know more details.

Sections:
   @{" Creation of DataTables                   " link Creation_of_DataTables}
   @{" The DataTable structure                  " link The_DataTable_structure}
   @{" The DBStruct structure                   " link The_DBStruct_structure}
   @{" Operations the DataTable supports        " link Operations_the_DataTable_supports}
   @{" Relations between DataTables             " link Relations_between_DataTables}
   @{" Locking of records                       " link Locking_of_records}
   @{" Functions for managing indexes           " link Functions_for_managing_indexes_attached_to_the_DataTables}
   @{" Other functions for accessing DataTables " link Other_functions_for_accessing_DataTables}
   @{" Private functions of the DataTable       " link Private_functions_of_the_DataTable}
@endnode

@node Creation_of_DataTables "DataBase.library - Chapter 6, DataTable"
@toc DataTable

@{b}@{fg shine}Section 6.1, Creation of DataTables@{fg text}@{ub}

You create a new DataTable (or open an existing one stored in a filesystem)
using the function:

   @{b}struct DataServer *DBF_InitA (APTR ignored, struct TagItem *tagList);@{ub}

The  return-value is a pointer to the @{"DataServer structure" link The_DataServer_structure} according to the
new  DataTable.  The truth is,  this is a pointer to a DataTable structure,
but  usually  you  require a DataServer pointer as argument for calling the
functions of the database.library.

The  first  argument  is  currently  ignored  (see  also chapter 3, section
@{"Creation of DataServers" link Creation_of_DataServers})  and  has to be set to zero (@{b}NULL@{ub}) for future com-
patibility.  The second argument is a pointer to a TagItem list, describing
the attributes and properties of the DataTable.

The  following  Tags  are  defined for DataTables; the first three Tags are
mandatory,  i.e.  there  have to be TagItems with these Tags in the TagItem
list passed to the @{b}@{i}DBF_InitA() @{ui}@{ub}function:

@{b}DBF_Name@{ub}
   The  data is a pointer to a NUL-terminated C-string with the name of the
   DataTable. This name may be used to identify the @{"DataServer" link DataServer} in an appli-
   cation, so you should use an unique name for every DataTable.
   The  string is limited to 32 characters (inclusive terminating NUL-byte)
   and is truncated to this length if a longer string is passed.

@{b}DBF_FileName@{ub}
   The  data  is  a  pointer to a NUL-terminated C-string with the filename
   (and optionally the path) of the DataTable file.
   If the file is currently not existing, it will be created.

@{b}DBF_Struct@{ub}
   The data of this TagItem is a pointer to an array of @{"DBStruct structures" link The_DBStruct_structure}
   each structure initialized as mentioned in the secondnext section.  This
   array is terminated by a structure with a @{b}NULL@{ub} pointer as @{b}@{i}Name @{ui}@{ub}.
   This array describes the structure of every record in the DataTable.
   If the file already exists, the structure described by this array has to
   match  the  structure  of  the DataTables file, the @{b}@{i}Caption @{ui}@{ub}and @{b}@{i}HelpText @{ui}@{ub}
   strings are used in any case.
   This  structure-array is copied and needs not to remain valid after this
   function returned, but the referenced strings are not copied and need to
   remain valid until the DataTable is disposed.

@{b}DBF_StructSize@{ub}
   The data specifies the size of the structure that should be allocated as
   DataTable structure.  This Tag has to be specified, if a subclass of the
   DataTable needs additional space in the structure for private data.

@{b}DBF_Exclusive@{ub}
   A  TagItem  with  this Tag is a boolean TagItem, i.e.  if a TagItem with
   this  Tag  is  present  in  the TagItem list, the DataTable file will be
   accessed  in exclusive mode, i.e.  every other try to open the DataTable
   (by the same or any other application) will be rejected.

   @{b}NOTE@{ub}
      This  exclusive  mode  is not functional on every filesystem.  If you
      place  the  DataTable's  files in the ram-disk per example, this will
      not  guarantee  exclusive  access  to  the files, due to a bug in the
      Ram-Handler found in every AmigaOS from 3.1 through 3.9.
      The FastFileSystem is functional under every supported OS.

@{b}DBF_ReadOnly@{ub}
   A  TagItem  with  this  Tag is a boolean TagItem, i.e. if a TagItem with
   this  Tag  is  present  in  the TagItem list, the DataTable file will be
   opened  in  read-only  mode,  i.e.  any changes to the DataTable will be
   rejected.

@{b}DBF_ForceUnique@{ub}
   This  is  also  a  boolean  TagItem, i.e.  if a TagItem with this Tag is
   present  in the TagItem list, all records that are added or changed will
   be  matched against all open unique @{"indexes" link Indexes}, if an @{b}IDX_ERR_DUPLICATE_KEY@{ub}
   occures  (i.e.  if  the  according @{"key-value" link Key-expressions_and_key-values} is already in the index and
   would  be  added  twice, if the record is saved), the record will not be
   stored.
   This  flag  does  only  make sence, if there will be at least one unique
   index opened and attached to the DataTable.

@{b}DBF_LockMode@{ub}
   The  identifier  passed with the data of this TagItem, specifies how the
   records are locked in the DataTable.  This might be one of the following
   values (have a look to the section @{"Locking of records" link Locking_of_records} for details about
   record locking):

   @{b}DSF_LOCK_OPTIMISTIC@{ub}
      (default) use optimistic locking
   @{b}DSF_LOCK_FULL@{ub}
      a record is locked exclusive while it is the current record.
   @{b}DSF_LOCK_NONE@{ub}
      a record is not locked by the DataTable.
      The  user-application  has  to  lock  the records using the functions
      @{"DBF_LockRecord()/DBF_UnLockRecord()" link Locking of records}.

@{b}DBF_Validate@{ub}
    A  TagItem  with this Tag might be used to pass a pointer to a function
   that  is called, whenever a new or a changed record should be written to
   the DataTable (when the @{"operation" link Operations_the_DataTable_supports} @{b}DS_UPDATE@{ub} is performed).
   This function should validate the contents of the record. Take care that
   this  function  must in no case change the current record (by seeking or
   skipping)  nor  the  currently  active  key of any index attached to the
   DataTable.
   If you have to search through the DataTable or an index of the DataTable,
   you  have  to  use  another instance of the DataTable (usually opened in
   read-only mode) for that purpose.
   If  the  validation fails, the current column of the DataTable has to be
   the  faulty  one  (i.e.  the  @{"operation" link Operations_every_DataServer_should_support} @{b}DS_CURRENTCOLUMN@{ub} has to return a
   pointer to the invalid @{"DataColumn" link DataColumn}).
   If a general failure occures, you have to set the @{b}@{i}CurrentColumn @{ui}@{ub}field of
   the DataServer structure to zero.

   The function has to be of the following type (an according functiontype-
   definition  is  found in  <joinOS/database/FunctionTypes.h>, it is named
   @{b}VALIDATE_RECORD@{ub}).

      @{b}BOOL ValidateRecord (struct DataServer *server)@{ub}

   The  argument is a pointer to the DataServer structure of the DataTable,
   where  the  current  record  should  be  validated and is passed via the
   register @{b}A0@{ub}.
   The function has to return @{b}TRUE@{ub}, if the record is valid, or @{b}FALSE@{ub} if the
   record  is  not  valid.  The returnvalue has to be passed in register @{b}D0@{ub}
   (every AmigaOS-function returns its result in @{b}D0@{ub}).
@endnode

@node The_DataTable_structure "DataBase.library - Chapter 6, DataTable"
@toc DataTable

@{b}@{fg shine}Section 6.2, The DataTable structure@{fg text}@{ub}

The DataTable structure is an enhanced @{"DataServer structure" link The_DataServer_structure}.  Usually there
is  no  need  to access the fields of this structure by an user-application
with  the exception of the fields @{b}@{i}LastError @{ui}@{ub}, @{b}@{i}Flags @{ui}@{ub}, and @{b}@{i}NumColumns @{ui}@{ub}of the
embedded DataServer structure that might be read at any time.

struct DataTable
{
   struct DataServer DS;        /* embedded DataServer structure */
   ULONG HeaderSize;            /* size of the header in the file */
   ULONG NumRecords;            /* total number of records in DataTable */
   UWORD RecordLength;          /* bytesize of a single record */
   UBYTE NullMemo;              /* used as "empty" memo */
   UBYTE pad;                   /* align to longword size */
   struct DBStruct *Structure;  /* the structure of the records */
   UBYTE *CurrentRecord;        /* buffer with copy of current record */
   UBYTE *OriginalRecord;       /* unchanged copy of current record */
   UWORD *Offsets;              /* array of offsets into a record */
   STRPTR *OrderNames;          /* array with 'Names' of orders */
   VALIDATE_RECORD Validate;    /* user-function for validating records */
   struct List Orders;          /* list of available orders (Index) */
   struct DataServer *Superior; /* server this one is related to */
   struct List Relations;       /* list of related DataServers */
   struct MinList Selected;     /* list of selected records */
   struct MinList Locks;        /* list of locked records */
};

Fields of the DataTable structure:

@{b}DS@{ub}
   This is an embedded DataServer structure as described in @{"chapter 3" link DataServer}.
   The  field @{b}@{i}Device @{ui}@{ub}of this DataServer structure contains the BCPL pointer
   to  the FileHandle of the datatable file.  The field @{b}@{i}Rows @{ui}@{ub}references the
   MemoFile structure if the DataTable has a @{"DataColumn" link DataColumn} of the type @{b}DC_TEXT@{ub}
   or @{b}NULL@{ub}, if no DataColumn of this type is attached to the DataTable (see
   chapter 7, @{"Memo fields" link Memo_fields}).
   At  last  the  field  @{b}@{i}Order @{ui}@{ub} of  this  embedded  structure points to the
   @{"IDXHeader structure" link The_IDXHeader_structure} of the currently active index.

   There  are  a couple of new flags available for DataTables that might be
   set to the @{b}@{i}Flags @{ui}@{ub}field of this embedded DataServer structure. You should
   not  change  these  flags  direct,  use  the functions provided for this
   purpose:

   @{b}DSF_DBTABLE@{ub}
      If you need to determine weather a DataServer pointer points to a
      DataServer structure or an enhanced structure, the DataTable structure,
      you should test this flag. If this flag is set, it's a DataTable
      structure.

   @{b}DSF_FORCE_UNIQUE@{ub}
      This flag indicates that changes or insertion of records should fail,
      if any unique index attached to the DataTable would contain duplicate
      keyvalues  as  result  of  that changes.  See chapter 5 @{"Indexes" link Indexes} for a
      detailed description of unique indexes.

   @{b}DSF_SHOW_DELETED@{ub}
      If this flag is set, you are able to skip to deleted records, if cur-
      rently  no  index  is  active, i.e.  the records are ordered by their
      record number. If this flag is not set or an index is active, deleted
      records are skipped silently.
      There is a function called @{"DBF_ShowDeleted()" link Other_functions_for_accessing_DataTables} that changes this flags
      setting.

   @{b}DSF_EXCLUSIVE@{ub}
      If  this  flag  is  set,  it  indicates  that the datatable is opened
      exclusive,  i.e.  no more instances could access the datatable.  This
      mode is required if major changes are made to the datatable.
      You must not change this flag, use the Tag @{b}DBF_EXCLUSIVE@{ub} or the func-
      tion @{b}@{i}DBF_SetAccessMode() @{ui}@{ub}instead.

   @{b}DSF_LOCK_OPTIMISTIC@{ub}
      This  is  one  of a pair of flags that indicate the locking mode used
      for record locking of the DataTable.  If this flag is set, @{i}optimistic @{ui}
      locking  is used.  If neither this flag nor the flag @{b}DSF_LOCK_NONE@{ub} is
      set, @{i}full @{ui}locking (@{b}DSF_LOCK_FULL@{UB}) is used.
      The locking mode could be changed via the function @{b}@{i}DBF_SetLockMode() @{ui}@{ub}.
      See the section @{"Locking of records" link Locking_of_records} for details about record locking.

   @{b}DSF_LOCK_NONE@{ub}
      This  is  one  of a pair of flags that indicate the locking mode used
      for  record locking of the DataTable.  If this flag is set, no record
      locking is done.
      If  neither  this  flag nor the flag @{b}DSF_LOCK_OPTIMISTIC@{ub} is set, @{i}full @{ui}
      locking (@{b}DSF_LOCK_FULL@{ub}) is used.
      The locking mode could be changed via the function @{b}@{i}DBF_SetLockMode() @{ui}@{ub}.
      See the section @{"Locking of records" link Locking_of_records} for details about record locking.

   @{b}DSF_HASMEMO@{ub}
      @{b}STRICTLY PRIVATE@{ub} if this flag is set, it indicates that the DataTable
      owns a memo-file, i.e. there is a DataColumn of the type @{b}DC_TEXT@{ub}.

   @{b}DSF_MEMO_READ@{ub}
      @{b}STRICTLY PRIVATE@{ub}, this flag is used by the DataTable to keep tracking
      of  the  read data.  The flag is set, if the memo-text of the current
      record is copied into memory.

   @{b}DSF_MEMO_CHANGED@{ub}
      @{b}STRICTLY  PRIVATE@{ub},  this  flag  is  set whenever the memo-text of the
      current  record  has  been  changed and the changes are currently not
      confirmed.

   @{b}DSF_REC_CACHED@{ub}
      @{b}STRICTLY PRIVATE@{ub}, this flag is used by the DataTable to keep tracking
      of  the  read  data.  The flag is set, if the contents of the current
      record is copied into memory.

   @{b}DSF_REC_DELETED@{ub}
      @{b}STRICTLY PRIVATE@{ub},  this flag is set, if the current record is deleted
      and the deletion is currently not confirmed.


   There  are  also a couple of additional errorcodes that may be stored in
   the @{b}@{i}LastError @{ui}@{ub}field of the embedded DataServer structure.
   The errorcodes in the range from 1000 to 1999 are reserved for the Data-
   Table class:

   @{b}DBF_ERR_DUPLICATE_NAME@{ub}
      This errorcode is set, if the name of an index or a column is already
      in  use, i.e. if you try to add a DataColumn or an index to the Data-
      Table with a name that is already in use.

   @{b}DBF_ERR_LOCK_TIMEOUT@{ub}
      If  a  timeout while locking a record occurs, this errorcode is found
      in @{b}@{i}LastError @{ui}@{ub}.

   @{b}DBF_ERR_LOCK_FAILURE@{ub}
      This  errorcode  is  set,  if  the DataTable failed to lock a record.
      Usually  the errorcode @{b}DBF_ERR_LOCK_TIMEOUT@{ub} will be used instead, but
      some  filesystems doesn't difference between timeout and general lock
      failures.

   @{b}DBF_ERR_INDEX_TIMEOUT@{ub}
      If  a  timeout occurs while locking an index, this errorcode is found
      in @{b}@{i}LastError @{ui}@{ub}.

   @{b}DBF_ERR_INDEX_LOCK@{ub}
      This  errorcode  is  set,  if  the DataTable failed to lock an index.
      Usually the errorcode @{b}DBF_ERR_INDEX_TIMEOUT@{ub} will be used instead, but
      some  filesystems doesn't difference between timeout and general lock
      failures.

   @{b}DBF_ERR_REC_NOT_LOCKED@{ub}
      If  you  try to unlock a record that isn't locked (usually by calling
      the function @{b}@{i}DBF_UnLockRecord() @{ui}@{ub}), this errorcode is set.

   @{b}DBF_ERR_REC_NOT_VALID@{ub}
      If you try to position the current record pointer to a deleted record
      (using the @{"operation" link Operations_the_DataTable_supports} DS_GOTOROW) or you try to confirm changes to the
      current  record that are not allowed, this errorcode will be found in
      the DataServers @{b}@{i}LastError @{ui}@{ub}field.

   @{b}DBF_ERR_NO_INDEX@{ub}
      This  errorcode  indicates  that you have tried to locate a record by
      seeking to a specified key-value but currently no index is active.

   @{b}DBF_ERR_REC_CHANGED@{ub}
      If  you  try  to confirm changes to the contents or the deletion of a
      record, this errorcode will be set, if the record has been changed by
      another  instance  of the DataTable (e.g. another user in the network)
      in the meanwhile.  In this case the changes couldn't be confirmed and
      must be thrown away.

   @{b}DBF_ERR_RELATED_SERVER@{ub}
      This  error  occurs,  if  two  or more servers are related (using the
      function  @{"DBF_SetRelation()" link Relations_between_DataTables}  and  an  error  occurs  while a related
      server  is accessed implicit (e.g.  if you change the current record,
      the current record of the related server is changed implicit). Have a
      look to the @{b}@{i}LastError @{ui}@{ub}field of the related DataServer for details.

   @{b}DBF_ERR_RELATION_LOOP@{ub}
      This errorcode is set by the function @{b}@{i}DBF_SetRelation() @{ui}@{ub},if a loop in
      the list of related servers is detected, i.e. if you try to establish
      a  relation  between  two DataTables, where the superior DataTable is
      already  placed  in  the list of clients (or clients of these) of the
      client DataTable.

@{b}HeaderSize@{ub}
   This  field  contains  the bytesize of the header of the DataTables main
   file;  the  header  of  that  file contains the information required for
   accessing the DataTables contents, see appendix A @{"Implementation details" link Implementation_details}
   for additional information about the structure of the files header.

@{b}NumRecords@{ub}
   Here  is  stored  the  number of all records currently stored in a Data-
   Table.  This  includes  all  currently  deleted  records and it might be
   wrong, if another instance of the DataTable has added new records in the
   meanwhile, so it isn't a usefull value for user applications. You should
   use  the  operation @{b}DS_NUM_OF_ROWS@{ub} to determine the number of accessable
   records instead of reading this fields contents.

@{b}RecordLength@{ub}
   This  field contains the bytesize of a single record.  This includes all
   bytes required to store status information and the pad bytes that may be
   required for the record.

@{b}NullMemo@{ub}
   This  byte  has to be set to zero, it is used as NUL-terminated C-string
   for the memo-text of that records, where no memo-text is stored.

@{b}pad@{ub}
   A byte used to align the structure, this field should not be changed.

@{b}Structure@{ub}
   This field contains a pointer to a @{"DBStruct structure" link The_DBStruct_structure} that describes the
   structure  of  the records.  See the next section for details about this
   structure.

@{b}CurrentRecord@{ub}
   This  pointer  points  to  a buffer with a copy of current record.  This
   buffer  contains  all  changes made to the record that are not confirmed
   until now. The contents of this buffer may not match the contents of the
   current  record  because  the record is not cached to memory, if not re-
   quired  to,  so  you  should  never  access  this buffer direct, use the
   operations  available  to  read and write to a record (@{b}DS_GETCOLUMNDATA@{ub},
   @{b}DS_GETRAWDATA@{ub}, @{b}DS_SETCOLUMNDATA@{ub}, and @{b}DS_SETRAWDATA@{ub}) instead.

@{b}OriginalRecord@{ub}
   This  pointer  points  to  a buffer with a copy of the unchanged current
   record.   If  the  current  record  is changed, the original contents is
   stored here to be able to undo the changes made to the record.

@{b}Offsets@{ub}
   This  field  contains  a  pointer  to an array of offsets into a record.
   These  offsets  are  used  to  locate the data of the DataColumns in the
   record buffer.

@{b}OrderNames@{ub}
   The array -- that is pointed to by this pointer -- contains the pointers
   to the @{i}names @{ui}of all orders (indexes) currently attached to the DataTable.
   You  should not access this array using this field, because the array is
   only  set up,  if  you  request  the operation @{b}DS_AVAILABLEORDER@{ub} and may
   become invalid at any time.
   
@{b}Validate@{ub}
   This  field  contains  the  pointer  to  a  user-function for validating
   records.  This function has to be specified during initialization of the
   DataTable using the Tag @{b}DBF_Validate@{ub}.
   See the section @{"Creation of DataTables" link Creation_of_DataTables} for details.

@{b}Orders@{ub}
   This  is an exec List containing all orders (indexes) that are currently
   attached to the DataTable and so are available for usage. You should not
   parse  this list by your own, use the functions and operations available
   for processing the indexes.

@{b}Superior@{ub}
   If  a  DataTable  is related to another DataTable the dependent (client)
   DataTables reference their superior DataTable using this field.

@{b}Relations@{ub}
   If a relation is established between a DataTable and one or more dependent
   DataTables (clients) this list references all DataTables that are dependent
   to this superior DataTable.

@{b}Selected@{ub}
   If  some  records  of  the  DataTable  are  selected using the operation
   DS_SELECTROW, this list contains references to all selected records.
   Never parse this list by your own, use the available operations for this
   purpose.

@{b}Locks@{ub}
   This  list  contains  a  reference for every successfully locked record.
   This  list  is  for  private use of the DataTable and is accessed by the
   functions @{b}@{i}DBF_LockRecord() @{ui}@{ub}and @{b}@{i}DBF_UnLockRecord() @{ui}@{ub}.
@endnode

@node The_DBStruct_structure "DataBase.library - Chapter 6, DataTable"
@toc DataTable

@{b}@{fg shine}Section 6.3, The DBStruct structure@{fg text}@{ub}

The  DBStruct  structure is used to descibe a single field of a record of a
DataTable.   An array of these structures is used to describe the structure
and  contents  of the complete records.  It's just easier to create such an
array  than  creating an array of template @{"DataColumn structures" link The_DataColumn_structure}, therefore
this structure is used for the @{"DataTable initialization" link Creation_of_DataTables}:

struct DBStruct
{
   STRPTR Name;     /* Name of the column (name of the datafield, 32 chars
                     * max.), NULL or empty strings are not allowed */
   STRPTR Caption;  /* a caption that should be used for this column,
                     * may be the same string as used for 'Name' */
   STRPTR HelpText; /* a short descriptive text for that column,
                     * may be NULL */
   UWORD Type;      /* Type identifier */
   UWORD Flags;     /* DataColumn-flags */
   UWORD Length;    /* length of the data (may depend on type) */
   UWORD Decimals;  /* only used with numeric values */
};

@{b}Name@{ub}
   This  is  a  pointer to the NUL-terminated C-string with the @{i}name @{ui}of the
   DataColumn.   This  string  has to be at maximum 32 characters in length
   (not counting the terminating NUL-byte).
   Setting this @{b}@{i}Name @{ui}@{ub}to @{b}NULL@{ub} or an empty string is not allowed.

@{b}Caption@{ub}
   This  is  a  pointer  to the NUL-terminated C-string with a caption that
   should be used for this @{"DataColumn" link DataColumn}. This caption may be displayed to the
   user  hiding  the  -- language independent -- @{b}@{i}Name @{ui}@{ub}to the user.  If this
   field is set to @{b}NULL@{ub}, the @{b}@{i}Name @{ui}@{ub}of the DataColumn is used as caption.

@{b}HelpText@{ub}
   This  field  contains  a  pointer  to a NUL-terminated C-string with the
   helptext  copied  to  the  DataColumn.   This  field  may contain a @{b}NULL@{ub}
   pointer, if no @{b}@{i}HelpText @{ui}@{ub}should be available.

@{b}Type@{ub}
   The  type  of the DataColumn, this might be any of the types defined for
   DataColumns,  even  the  @{b}DC_TEXT@{ub}  variable length string (memo).  Only a
   single memo-column is allowed per DataTable.  See chapter 7 @{"Memo files" link Memo_files}
   for details.

@{b}Flags@{ub}
   The following DataColumn-flags may be placed here:

   @{b}DCF_READONLY@{ub}
      If this flag is set, the DataColumn is read-only.

   @{b}DCF_HIDDEN@{ub}
      The DataColumn is hidden to the user, if this flag is set.

   @{b}DCF_NOT_EMPTY@{ub}
      If  this  flag is set, the DataColumn must never contain @{b}NULL@{ub} values,
      i.e.  if  you  try  to  store a record into the DataTable, where this
      column  is  empty, the DataTable will fail to confirm the changes and
      set  the errorcode @{b}DBF_ERR_REC_NOT_VALID@{ub} to the DataServers @{b}@{i}LastError @{ui}@{ub}
      field.

@{b}Length@{ub}
   The  length  of  the  DataColumns  data;  this is ignored for every @{b}@{i}Type @{ui}@{ub}
   except @{b}DC_CHAR@{ub}, @{b}DC_VARCHAR@{ub}, and @{b}DC_NUMERIC@{ub}.

@{b}Decimals@{ub}
   This  field is ignored for every DataColumn type, except for @{b}DC_NUMERIC@{ub},
   where  it  specifies  the number of digits of the fractional part of the
   number.  This has to be a value less than @{b}@{i}Length @{ui}@{ub}.
@endnode

@node Operations_the_DataTable_supports "DataBase.library - Chapter 6, DataTable"
@toc DataTable

@{b}@{fg shine}Section 6.4, Operations the DataTable supports@{fg text}@{ub}

The DataTable class supports every @{"operation" link Operations_every_DataServer_should_support} defined for @{"DataServers" link DataServer}.  You
request an operation by calling the dispatcher function

   @{b}BOOL DS_DoUpdate (struct DataServer *server, ULONG operation, APTR arg);@{ub}

as mentioned in @{"chapter 3, section 3.3" link Request_performing_of_operations_to_a_DataServer}.

Some  operations -- that aren't supported directly by the DataServer -- are
implemented in the DataTableas follows:

@{b}DS_UPDATE@{ub}
   This operation is used to synchronize the changes made to the DataTables
   current record and the DataTable-file.
   If  the  record has been added or removed, the according record is added
   (removed)  to  (from) the datatable file and all @{"indexes" link Indexes} attached to the
   DataTable.
   If  changes  have  been made to the record, these changes are written to
   the datatable file and all indexes are updated to match these changes.
   This  operation  should  be  performed  before any further access to the
   DataTable  is performed -- i.e.  before the current record is changed --
   or all changes will be lost.
   If  a  new  record is added to the DataTable or a record is changed, but
   the  validation fails (i.e.  any of the user-supplied validate functions
   fail or a column is empty that must not be empty) the field @{b}@{i}LastError @{ui}@{ub}is
   set  to  @{b}DBF_ERR_REC_NOT_VALID@{ub}.   The  operation  @{b}DS_CURRENTCOLUMN@{ub} would
   return  a pointer to the @{"DataColumn" link DataColumn} that falls through the validation in
   that case.
   If the current record is removed, the following record will be activated
   as current record, but you should take care that the records are ordered
   ascend, or the current record will be the logically previous one.
   If this operation succeeds, the currently active DataColumn is undefined
   i.e.  the  result of a following @{b}DS_CURRENTCOLUMN@{ub} operation is undefined
   and  may return a pointer to any DataColumn, or may also fail.  You have
   to send @{b}DS_GOTOCOLUMN@{ub} or @{b}DS_FINDCOLUMN@{ub} first.

@{b}DS_ADDCOLUMN@{ub}
   Using  this  operation  will  append  a new DataColumn to the end of the
   DataTables  list of DataColumns; the argument @{b}@{i}arg @{ui}@{ub}has to point to a full
   initialized @{"DataColumn structure" link The_DataColumn_structure}.

   If this DataColumn belongs to another DataServer  (i.e. the field @{b}@{i}Server @{ui}@{ub}
   of this structure points to a different server),  this structure and the
   referenced  strings  will  be copied and added to the end of the list of
   already present DataColumns.
   If  the  DataColumn  belongs to this DataTable (i.e. the field @{b}@{i}Server @{ui}@{ub}of
   the  DataColumn  structure points to this DataTable) this operation will
   fail.

@{b}DS_REMOVECOLUMN@{ub}
   This operation should be used to remove a DataColumn from the DataTable,
   the  argument  @{b}@{i}arg @{ui}@{ub} has  to  specify  the number of the DataColumn to be
   removed.   It  is only allowed to remove columns that belongs to another
   DataServer  (i.e.  the  field  @{b}@{i}Server @{ui}@{ub} of  this  structure  points  to a
   different DataServer).
   If  the  operation succeeds, and the removed column is the current Data-
   Column  of  the  DataTable,  the next column will went to be the current
   DataColumn.  If no next column is existent, the previous column wents to
   be the current column.

@{b}DS_MOVECOLUMN@{ub}
   This  operation  is  not  allowed for DataTables, so this operation will
   always fail and set an errorcode of @{b}DS_ERR_OP_NOT_KNOWN@{ub} to the @{b}@{i}LastError @{ui}@{ub}
   field of the embedded DataServer structure.

@{b}DS_FINDCOLUMN@{ub}
   This operation selects a column specified by its @{i}name @{ui}. The argument @{b}@{i}arg @{ui}@{ub}
   has  to  be  a  pointer  to a NUL-terminated string with the @{i}name @{ui}of the
   searched column.
   If there are one or more client-servers related to this DataTable, there
   might  be  several DataColumns with the same name in the DataTables list
   of  columns.   This operation will always find the first column with the
   name  (the  first  DataColumns  are  always the DataColumns owned by the
   DataTable).   If  you  want  to  find an equal named column of a related
   server,  the  columns  name has to be preceded by the name of the server
   followed  by an colon; e.g.  "Foobar:Foo" addresses the DataColumn named
   "Foo" of the related DataServer "Foobar".

@{b}DS_INSERTROW@{ub}
   If  you  need  to insert a new record into the DataTable, this operation
   has to be used. The columns of the record are initialized to defaults.
   After  this  operation  has  succeeded the operation @{b}DS_SETCOLUMNDATA@{ub} or
   @{b}DS_SETRAWDATA@{ub}  has  to  be  called for the columns that should be set up
   with  values,  followed  by the operation @{b}DS_UPDATE@{ub} to write the changes
   into the datatable and the attached indexes.

@{b}DS_REMOVEROW@{ub}
   This  operation  marks  the  current  record  as deleted.  The operation
   @{b}DS_UPDATE@{ub}  has  to  be performed to remove the record from the DataTable
   and the according key-entries from the attached indexes.
   The  next  time a new record is inserted (@{b}DS_INSERTROW@{ub}) the last deleted
   record is overwritten. This handling has the advantage that you need not
   to  @{i}pack @{ui} the DataTable to remove the deleted records permanent from the
   file,  but  it  has  the  disadvantage that records that are deleted are
   really deleted and cannot be undeleted.

@{b}DS_GOTOROW@{ub}
   As  mentioned  for  the DataServer class, this operation skips direct to
   any record by its number; the argument @{b}@{i}arg, @{ui}@{ub}interpreted as ULONG, speci-
   fies  the number of the record that should be selected as current record
   starting with 1.
   If  zero  or  a  value  greater  than the number of available records is
   specified this function fails, the current record is set to zero (EOF).
   This  operation can be used to access deleted records.  In this case the
   operation  will return @{b}FALSE@{ub} and set the @{b}@{i}LastError @{ui}@{ub}field of the embedded
   DataServer  structure  to @{b}IDX_ERR_NO_KEY@{ub}, if any indexes are attached to
   the DataTable.  Nevertheless the columns of the selected record would be
   accessable.
   Due  to the fact that deleted records are overwritten if new records are
   added  to the DataTable, the contents of a deleted record may be changed
   at  any  time, you might not be able to read the contents of the deleted
   record (e.g. for undeleting the record).

@{b}DS_NUM_OF_ROWS@{ub}
   This  operation  determines  the number of accessable records, i.e.  the
   number  of keys stored in the active order regarding the current setting
   of the order-scope, or -- if no order is active -- the number of records
   stored in the datatable of the server
   The result will be copied to the ULONG @{b}@{i}arg @{ui}@{ub}points to. The current record
   will be pointing to EOF after this function has been called.

@{b}DS_GETRAWDATA@{ub}
   This  operation  is  used to get the data of the current DataColumn.  If
   there  is a currently selected column and the current record is valid, a
   pointer  to  the  data of this column in the current record is copied to
   the address, @{b}@{i}arg @{ui}@{ub}points to.  The type of the data this pointer points to
   depends on the datatype of the DataColumn:
 
      @{b}DC_TEXT@{ub}
         @{b}@{i}arg @{ui}@{ub}will point to the address, where the location of the according
         string in the memo-file attached to this DataTable is stored. This
         address  is splitted into two parts,  the first ULONG contains the
         number  of  the page in the memo-file, where the string is stored,
         the second ULONG value is the offset into this page.
         The  size  of  the  pages depends on the memo-file used, usually a
         page is 1024 bytes large.  See chapter 7, @{"Memo files" link Memo_files} for details.

   The  @{i}raw @{ui} format of the other available datatypes is described in detail
   in chapter 3, @{"DataServer" link Operations_every_DataServer_should_support}.

@{b}DS_SETORDER@{ub}
   Using  this  operation  you  could  change the order of the records; @{b}@{i}arg @{ui}@{ub}
   points  to  the new order (index) that should be used.  This has to be a
   pointer to a NUL-terminated C-string  with the name of the order.
   This  order  has  to  be  added already to the DataTables list of orders
   using the function @{"DBF_AddOrder()" link Functions_for_managing_indexes_attached_to_the_DataTables}.
   The name of an order is case-sensitive !
   The  current  record  should  be still the same after this operation has
   been  performed, but if the new order doesn't contains an entry for this
   record, the position is set to EOF.
   Any unconfirmed changes done to the current record are lost.

@{b}DS_GETORDER@{ub}
   You  can  get  the  name  of  the current order of the records with this
   operation;  a  pointer to a NUL-terminated C-string with the name of the
   active  order  (index) is stored in the address @{b}@{i}arg @{ui}@{ub}points to after this
   operation  has  performed;  this  address  will  be @{b}NULL@{ub}, if no order is
   active.

All  other  operations  not  listed  here  are  implemented as mentioned in
chapter 3, @{"Operations every DataServer should support" link Operations_every_DataServer_should_support}
@endnode

@node Relations_between_DataTables "DataBase.library - Chapter 6, DataTable"
@toc DataTable

@{b}@{fg shine}Section 6.5, Relations between DataTables@{fg text}@{ub}

A  database  is usually build by several DataTables that are related at any
kind.

Per  example you might create a database used to store address information.
You  could  put  any  information that belongs to a single address into one
large  DataTable,  but  this  way you will have much redundant data in your
database and many fields of the DataTable are empty.

You  should  prefer  dividing  the  information  into several parts, so you
reduce redundant and empty data.

In  an  address-database  you might use one DataTable to store the names of
your addressee, a second one for the postal-address and a third one for the
titles of the adressees.

To  identify  the records of every DataTable you need a kind of unique key,
the so-called @{i}primary keys @{ui}.
To  resolve a relation between the DataTables, you have to store the key of
the  record  in  the related DataTable in the referencing DataTable.  These
entries in the records are named @{i}foreign keys @{ui}.

In our example we will create the three DataTables (@{i}addressDB, titleDB, @{ui}and
@{i}postalDB @{ui}) with structures that would somehow look like these:

struct DBStruct address[] =
{
  {"ADRN", "Adressno.","unique Id of an address",DC_LONG,DCF_NOT_EMPTY,0,0},
  {"TITLE","Title",    "foreign key to titleDB", DC_WORD,DCF_HIDDEN, 0, 0},
  {"FNAME","Firstname","firstname of addressee", DC_CHAR, 0, 40, 0},
  {"NAME", "Name",     "familyname of addressee",DC_CHAR, 0, 40, 0},
  {"ADDR", "Address",  "foreign key to postalDB",DC_LONG,DCF_HIDDEN, 0, 0},
  {0}
};

struct DBStruct title[] =
{
  {"TNR","Titleno.","unique number",DC_WORD,DCF_NOT_EMPTY | DCF_HIDDEN,0,0},
  {"TITLE","Titel","title of an addressee",DC_CHAR,0,40,0},
  {0}
};

struct DBStruct postal[] =
{
   {"ADDR",   "Postalno","unique number",        DC_LONG,DCF_NOT_EMPTY,0,0},
   {"STREET", "Street",  "street and housenumber",DC_CHAR, 0, 60, 0},
   {"POSTBOX","Postbox", "post-office box",       DC_CHAR, 0, 40, 0},
   {"TOWN",   "Town",    "town of postal address",DC_CHAR, 0, 32, 0},
   {"CODE",   "Postcode","postcode of the town",  DC_CHAR, 0, 8, 0},
   {"COUNTRY","Country", "Country of the address",DC_CHAR,0,32,0},
   {0}
};

Now we need some indexes to find the related records in the title DataTable
@{i}titleDB @{ui}  and  the  postal-address  DataTable  @{i}postalDB @{ui}  (see  chapter 5
@{"Indexes" link Indexes} for details):

One index  for @{i}titleDB @{ui}, that orders the records by the unique title number
"TNR":

struct TagItem idx_Title_Tags[] =
{
   {IDX_Name,       (ULONG)"TitleNumber"},
   {IDX_Expression, (ULONG)"TNR"},
   {IDX_FileName,   (ULONG)"Title.idx"} ,
   {IDX_Server,     (ULONG)titleDB},
   {IDX_Unique,     0},
   {TAG_DONE,       0}
};

Another index  for @{i}postalDB @{ui}, that orders the records by the unique postal-
address number "ADDR":

struct TagItem idx_Postal_Tags[] =
{
   {IDX_Name,       (ULONG)"PostalNumber"},
   {IDX_Expression, (ULONG)"ADDR"},
   {IDX_FileName,   (ULONG)"postal.idx"},
   {IDX_Server,     (ULONG)postalDB},
   {IDX_Unique,     0},
   {TAG_DONE,       0}
};

If  we  have  some  data in these DataTables there might be a record in the
main  addressee  DataTable  @{i}addressDB @{ui} with  the following contents (hidden
@{"DataColumns" link DataColumn} are also shown in this example):

Addressno.:      3
Title     :      2
Firstname : Donald
Name      : Duck
Address   :      7

There  should  be  a related record in the title DataTable @{i}titleDB @{ui}with the
unique title number '2', e.g.:

Titleno.:      2
Title   : Mister

and  there  should also be a related record in the postal-address DataTable
@{i}postalDB @{ui}with the number '7':

Postalno.:            7
Street   : Drakeroad 13
Postbox  : Box 555
Town     : Duckburg
Postcode : 1313
Country  : Disneyland

Now  you  could  handle  the  relations  between  the  DataTables  by  your
applications  code,  i.e.   if  you need the postal address according to an
addressee,  you  could  @{"seek" link Operations_every_DataServer_should_support}  in the postal-address DataTable to the record
with  the  postal-number  that  is  equal to the number found in the "ADDR"
field of the main addressee DataTable, or you could establish this relation
using  the  @{b}@{i}DBF_SetRelation() @{ui}@{ub} function,  so  you don't need to worry about
finding the correct record in a related server.

The  postal-address  DataTable  and  the  title DataTable would be added as
childs  to  the  superior  addressee  DataTable,  so  you  could access all
information  that is stored for a single address by just accessing a single
DataTable, the other related DataTables are handled by the database.library
and are always positioned to the correct record:

   DBF_SetRelation (addressDB, titleDB, "TitleNumber", "TITLE");
   DBF_SetRelation (addressDB, postalDB, "PostalNumber", "ADDR");

Now  you  could read all information by reading all DataColumns attached to
the main DataTable @{i}addressDB @{ui}:

Addressno.:            3
Firstname : Donald
Name      : Duck
Title     : Mister
Street    : Drakeroad 13
Postbox   : Box 555
Town      : Duckburg
Postcode  : 1313
Country   : Disneyland


@{b}@{fg shine}Subsection 6.5.1,Functions for managing relations between two DataTables@{fg text}@{ub}

   @{b}BOOL DBF_SetRelation (struct DataServer *server,
                         struct DataServer *client,
                         STRPTR order, STRPTR expr);@{ub}

This  powerfull  function  can  be  used to establish relations between two
DataTables.   The  first DataTable @{b}@{i}server @{ui}@{ub}is the superior DataTable and the
second DataTable @{b}@{i}client @{ui}@{ub}the client DataTable.
All  DataColumns  of the client are added to the list of DataColumns of the
superior  DataTable,  so you could read the contents of the current records
of  both  DataTables  by accessing the superior DataTable without knowledge
about any related DataTables.
The  current record of the client DataTable is changed in dependency to the
current  record  of the superior DataTable.  How the client is dependent to
the  superior  is  described  by the specified @{b}@{i}order @{ui}@{ub}and the @{"key-expression" link Key-expressions_and_key-values}
@{b}@{i}expr @{ui}@{ub}.  Where @{b}@{i}order @{ui}@{ub}is a pointer to a NUL-terminated C-string with the name
of  the  index  that  should  be  used  to  order the records of the client
DataTable  and  @{b}@{i}expr @{ui}@{ub} is  a  pointer  to  a  NUL-terminated C-string with a
key-expression as mentioned in the chapter 5 @{"Indexes" link Indexes}.  This expression is
used to evaluate a key-value with the contents of the current record of the
superior  DataTable.   This key-value is used to locate the according entry
in  the  specified  index  @{b}@{i}order @{ui}@{ub} and to position the client server to that
record.

There  should  be  one or zero records in the client DataTable that match a
record  in  the  superior  DataTable.   If more records match the evaluated
key-value, the client DataTable is positioned to the first one found.



   @{b}BOOL DBF_ClearRelation (struct DataServer *client);@{ub}

This function should be used to clear any relations established between two
DataTables  by  the  function  @{b}@{i}DBF_SetRelation() @{ui}@{ub}.  All  DataColumns of the
client DataTable that are added to the superior DataTable (and its superior
DataTable etc.) are removed by this function.
The only argument of this function is a pointer to the @{"DataServer structure" link The_DataServer_structure}
of the client DataTable.
If  the  function succeeds, @{b}TRUE@{ub} is returned; if this function fails, @{b}FALSE@{ub}
is returned, the relation may be cleared nevertheless.  This is the case if
the  @{b}@{i}LastError @{ui}@{ub} field of the DataServer structure of the superior DataTable
contains  the  errorcode  @{b}DBF_ERR_RELATED_SERVER@{ub}.   In this case you should
close  both  DataTables  as  fast  as possible to prevent corruption of the
DataTables files.
@endnode

@node Locking_of_records "DataBase.library - Chapter 6, DataTable"
@toc DataTable

@{b}@{fg shine}Section 6.6, Locking of records@{fg text}@{ub}

If  a  DataTable  is  accessed  by  several  instances, especially if these
instances  are  opened from different users working with different machines
or  with a computer that supports multiuser accesses like a Unix-machine or
an Amiga...

@{fg shine}----- ZIP -----------------------------------------------------------------@{fg text}
Every Amiga supports simultan multiuser access with some restrictions:  The
other  user  has  to use a terminal that is attached to the serial-port and
therefore he has only a textual cli, no Workbench, but this way he has full
access to the Amiga (@{b}AUX:@{ub}).
@{fg shine}----- ZAP -----------------------------------------------------------------@{fg text}

...there  must be any kind of protection against interfere in accessing the
DataTables  contents.  While at least one instance is reading a record from
the  DataTable,  no  other  instance  is allowed to change this record, but
others may also read the same record.
If  an  instance writes a record, it needs exclusive access to this record,
i.e.  it is not allowed that any other instance reads or writes to the same
record.  This protection is implemented via record locking.
The  read  accesses are always locked by the database.library, and there is
no  way  to  change  this  behaviour,  but  there are three different modes
available for the write locks:

@{b}DSF_LOCK_OPTIMISTIC@{ub}
   This  is the default locking method.  Optimistic locking means, that the
   current  record  is  not  (write)locked  until  the changes made to this
   record  should  be  written  to the DataTables file, i.e.  the record is
   locked when the operation @{b}DS_UPDATE@{ub} is requested.  Immediately after the
   record is written it is unlocked again.
   The benefit of this locking mechanism is, that the records are locked as
   short  as  possible,  i.e.  lock failures are nearly impossible if every
   instance accessing the same DataTable uses this locking technique.
   The disadvantage of using optimistic locking is, that you never know, if
   the  record  could  be  successfully  locked for writing and hasn't been
   changed  by  another  instance  in  the  meantime.  You may make several
   changes  to  a  record,  and  when  you  try to confirm the changes, the
   DataTable  determines  that  the record has been changed in the meantime
   and your changes are discarded.

@{b}DSF_LOCK_FULL@{ub}
   This  is  a  very safe but uncooperative locking mechanism.  A record is
   locked  exclusive  the  whole time while it is the current record.  This
   way  you  can  be  shure  that you are able to write your changes to the
   DataTables  file, but no other instance can even read the locked record.
   Therefore you should avoid using this mechanism except if you need to be
   shure that any changes are written (e.g.  if the changes are not made by
   a  human being that could redo the changes if they are discarded because
   of  an  access  violation,  but  if the changes are made by some kind of
   automatism released by an event that cannot be repeated).

@{b}DSF_LOCK_NONE@{ub}
   This  last  locking  method  requires  the  most work by the application
   designer,  but  this  way  the  behaviour  of the DataTable is under the
   complete control of the programmer.
   If  this locking method is chosen, the DataTable doesn't lock any record
   for  write  accesses,  your user-application has to do the locking using
   the function-pair @{b}@{i}DBF_LockRecord()/DBF_UnLockRecord() @{ui}@{ub}.
   But  don't  forget  to lock the record or you may corrupt the DataTables
   files completely !

Independent  of  the used locking mechanism, all record locks are freed, if
the DataTable is closed.

The  following  two  functions  have  to  be  used,  if  the  locking  mode
@{b}DSF_LOCK_NONE@{ub}  is  chosen,  these  function  could  also be used if another
locking mode is used, but this doesn't really makes sence:


   @{b}BOOL DBF_LockRecord (struct DataServer *server, ULONG recNo,
                                       ULONG mode, ULONG timeout);@{ub}

This function locks the specified record of the DataTable.

The  first  argument  is  a  pointer  to  the  @{"DataServer structure" link The_DataServer_structure} of the
DataTable,  the  second  one  the  number  of the record to be locked.  The
number  of  the  current  record  could  be  determined using the operation
@{b}DS_CURRENTROW@{ub}.  If zero is passed for this argument, the header of the file
is locked, but this should not be done by an user-application.
A  record  could be locked either for exclusive access (for write accesses)
or  for  shared  access  (for  read  accesses),  the third argument of this
function expects a value that specifies the desired mode:

   @{b}DBF_READ@{ub}
      The  record should be locked for read-only access.  Several instances
      of  the  DataTable  could  lock the same record in shared mode at the
      same time.

   @{b}DBF_WRITE@{ub}
      The record should be locked for write access.  Only a single instance
      of the DataTable could lock a record in exclusive mode.  If any other
      instance  holds  either a shared or an exclusive lock of this record,
      this function will wait for the lock to be released.

The  last  argument  @{b}@{i}timeout @{ui}@{ub} specifies  the time in 50th of a second, that
should  be  waited if a lock collision is detected for the lock to be freed
by  the  other  instance.   If  this  time exceeds, this function fails and
usually  sets  the errorcode @{b}DBF_ERR_LOCK_TIMEOUT@{ub} to the @{b}@{i}LastError @{ui}@{ub}field of
the  DataServer  structure,  but  this  may  also  result  in the errorcode
@{b}DBF_ERR_LOCK_FAILURE@{ub}, depending on the underlying filesystem.

There are three predefined values for this timeout:

   @{b}DBF_WAIT_FOREVER@{ub}
      The  function  should  wait (nearly) forever until it gains the lock.
      Take care that you don't run into a dead-lock if you use this value.

   @{b}DBF_WAIT_NONE@{ub}
      The  function  shouldn't  wait  for  a  locked record to be released,
      instead it should return immediately.

   @{b}DBF_WAIT_DEFAULT@{ub}
      This is the default time the DataTable itself uses, whenever it needs
      to  lock  a  record (i.e.  if the locking mode @{b}DSF_LOCK_OPTIMISTIC@{ub} or
      @{b}DSF_LOCK_FULL@{ub} is used).  This timeout time is currently defined as 15
      seconds.

Any other value may also be used for this argument.

If  the  record could be successfully locked, @{b}TRUE@{ub} is returned.  You should
release this lock as fast as possible using the function @{b}@{i}DBF_UnLockRecord() @{ui}@{ub}.

If the function fails, @{b}FALSE@{ub} is returned.

It  is safe to try to lock a record twice or more that is already locked by
this  instance  of  the  DataTable,  if  the accessmode is the same, or the
record is already locked in exclusive mode.



   @{b}BOOL DBF_UnLockRecord (struct DataServer *server, ULONG recNo);@{ub}

Any  record  locked  by the function @{b}@{i}DBF_LockRecord() @{ui}@{ub}has to be freed using
this  function.   If  the same record has been locked twice or more by this
instance of the DataTable, the record locks are freed in upside-down order,
i.e.  the last set lock is freed first, the first set lock is freed last.

The  first  argument  of  this  function  is  a  pointer  to the DataServer
structure  of  the DataTable, the second one the number of the record to be
unlocked.

If the function succeeds, @{b}TRUE@{ub} is returned; if the function fails, @{b}FALSE@{ub} is
returned.   This  is usually the case if you specify the number of a record
that   hasn't   been   locked  previously   (@{b}@{i}LastError @{ui}@{ub} would  be  set  to
@{b}DBF_ERR_REC_NOT_LOCKED@{ub}).
@endnode

@node Functions_for_managing_indexes_attached_to_the_DataTables "DataBase.library - Chapter 6, DataTable"
@toc DataTable

@{b}@{fg shine}Section 6.7, Functions for managing indexes attached to the DataTables@{fg text}@{ub}

A  couple  of  functions is used to manage the indexes that are attached to
the  DataTables.  See  chapter 5, @{"Indexes" link Indexes}  for  detailed  information about
indexes.


   @{b}BOOL DBF_AddAlias (struct DataServer *server,STRPTR alias,STRPTR index);@{ub}

Using  this  function  an alias-name for an index attached to the DataTable
could  be  defined.   Every index attached to a DataTable could be accessed
either  by  its name or any alias-name defined using this function.  If the
function succeeds, TRUE is returned else FALSE is returned; you should have
a look  at  the  @{b}@{i}LastError @{ui}@{ub} field  of  the  @{"DataServer structure" link The_DataServer_structure}  to get a
descriptive errorcode.  The function expects three arguments, the first one
is  a pointer to the DataServer structure of the DataTable, the second is a
pointer  to  a  NUL-terminated  C-string with the alias-name.  This name is
compared  case  sensitive  with  the  names of all aliases that are already
defined  and  all indexes that are attached to the DataTable.  It has to be
unique  or this function will fail.  The third argument is a pointer to the
NUL-terminated  C-string  with the name of the index, that should @{i}aliased @{ui}.
This  index  has  to  be  attached  to  the  DataTable  (using the function
@{b}@{i}DBF_AddOrder() @{ui}@{ub}). This string is also compared case-sensitive.



   @{b}BOOL DBF_RemoveAlias (struct DataServer *server, STRPTR alias);@{ub}

Every  alias  successfully defined using the function @{b}@{i}DBF_AddAlias() @{ui}@{ub}can be
removed  at  any time using this function.  The first argument is a pointer
to  the  DataServer structure of the DataTable, the second one is a pointer
to a NUL-terminated C-string that identifies the alias to be removed.  This
string  is  compared  case-sensitive  with  all  aliases  attached  to  the
DataTable.  If  the  function  succeeds,  @{b}TRUE@{ub}  is  returned  else @{b}FALSE@{ub} is
returned;  you  should have a look at the @{b}@{i}LastError @{ui}@{ub}field of the DataServer
structure to get a descriptive errorcode.
Aliases  are  removed  implicit, when the aliased index is removed from the
DataTable  (using  the  function  @{b}@{i}DBF_RemoveOrder() @{ui}@{ub}) or  the  DataTable is
disposed (with the @{"operation" link Operations_every_DataServer_should_support} @{b}DS_DISPOSE@{ub}).



   @{b}BOOL DBF_AddOrder (struct DataServer *server, struct IDXHeader *index);@{ub}

Every  index  that should be maintained by the DataTable, i.e.  that should
be  updated whenever a record is changed or added to the DataTable, must be
attached  to  the DataTable using this function.  If the function succeeds,
@{b}TRUE@{ub}  is  returned  else  @{b}FALSE@{ub}  is returned; you should have a look at the
@{b}@{i}LastError @{ui}@{ub}field of the DataServer structure to get a descriptive errorcode.
The  first  argument  is  a  pointer  to  the  DataServer  structure of the
DataTable,  the  second  one is a pointer to the IDXHeader structure of the
index to be attached to the DataTable; see chapter 5, @{"Indexes" link Indexes} for details.



   @{b}struct IDXHeader *DBF_GetOrder (struct DataServer *server, STRPTR name);@{ub}

You  might  require  to  have access to the @{"IDXHeader structure" link The_IDXHeader_structure} of an index
attached  to a DataTable.  In that case you can use this function.  It will
return  a pointer to the IDXHeader structure of the named index, or @{b}NULL@{ub} if
no index with the specified name is attached to the DataTable.
The  first  argument  is  a  pointer  to  the  DataServer  structure of the
DataTable,  the second one is a pointer to the NUL-terminated C-string with
the name of the requested index.  This name is compared case-sensitive.  If
you  specify  the  name of an alias, the IDXHeader structure of the @{i}aliased @{ui}
index is returned.
The index retrieved using this function is still attached to the DataTable,
so  don't perform any changes to this index.  If you have to manipulate the
index  direct, you should previously remove it from the DataTable using the
function @{b}@{i}DBF_RemoveOrder() @{ui}@{ub}.



   @{b}struct IDXHeader *DBF_RemoveOrder (struct DataServer *server,
                                                      STRPTR name);@{ub}

This  function  is  usable  to  remove  an  index from a DataTables list of
attached  indexes.   You have to remove an index, whenever you need to make
manipulations  to that index, except read/only accesses.  The function will
return  a  pointer  to  the  IDXHeader  structure  of the returned index on
success, or @{b}NULL@{ub} if the specified index is not found.
The  first  argument  is  a  pointer  to  the  DataServer  structure of the
DataTable,  the second one is a pointer to the NUL-terminated C-string with
the name of the index to be removed.  This name is compared case-sensitive.
You should test the @{b}@{i}Flags @{ui}@{ub}field of the structure referenced by the returned
pointer  for  the  setting of the @{b}IDX_ALIAS@{ub} flag.  If this flag is set, the
returned   pointer   points   to   an   IDXAlias   structure   (defined  in
<joinOS/database/Index.h>)  instead  of an IDXHeader structure (this is the
case if you specify the name of an alias).
Either  you have to add the removed index/alias back to the DataTables list
of  attached  indexes using the function @{b}@{i}DBF_AddOrder() @{ui}@{ub}or you must dispose
the index/alias calling the function @{b}@{i}IDX_Dispose() @{ui}@{ub}.
@endnode

@node Other_functions_for_accessing_DataTables "DataBase.library - Chapter 6, DataTable"
@toc DataTable

@{b}@{fg shine}Section 6.8, Other functions for accessing DataTables@{fg text}@{ub}

There  are several functions that are only used for DataTables, that cannot
be used for any other kind of DataServer.
These  functions  are  usually for administating the DataTable respectively
for setting up the DataTable.


   @{b}BOOL DBF_Pack (struct DataServer *server,
                     REINDEX_PROGRESS fct, APTR userData);@{ub}

This  administrative  function  should  remove all deleted records from the
DataTable.   But because the deleted records are overwritten whenever a new
record   is  added  to  the  DataTable,  this  function  is  currently  not
implemented.   If  you  call  this  function  in the current version of the
database.library,   this  function  will  fail  and  set  an  errorcode  of
@{b}DS_ERR_OP_NOT_KNOWN@{ub}  to the @{b}@{i}LastError @{ui}@{ub}field of the @{"DataServer structure" link The_DataServer_structure} and
@{b}ERROR_NOT_IMPLEMENTED@{ub} to @{b}@{i}IoErr() @{ui}@{ub}.
This  function  entry  point is included in the database.library for future
compatibility.  This function may be implemented in a future version of the
database.library.



   @{b}BOOL DBF_ReIndex (struct DataServer *server, STRPTR order,
                           REINDEX_PROGRESS fct, APTR userData);@{ub}

This  administrative function is the usual way to recreate an @{"index" link Indexes} that is
attached to the DataTable.
The  first  argument  is a pointer to the DataServer structure of the Data-
Table,  the second one is a pointer to the NUL-terminated C-string with the
name  of  the  index to be reindexed.  This index has to be attached to the
DataTable (by the function @{"DBF_AddOrder()" link Functions_for_managing_indexes_attached_to_the_DataTables}).
This  function prepares the DataTable for reindexing and handles a possible
failure due to a bug in the AmigaOS Ram-Handler.  You should have a look to
the  chapter 5, @{"Indexes" link Indexes}  and  read  the description of the @{"IDX_ReIndex()" link Functions_for_changing_an_index}
function for details and a description of the other two optional arguments.

If  this function fails and the @{b}@{i}LastError @{ui}@{ub}field of the DataServer structure
is set to @{b}DS_ERR_MAYOR@{ub}, the specified index may be corrupted (the chance is
very  small).   To  test  if the index is corrupted, you should request the
@{"operation" link Operations_every_DataServer_should_support}  @{b}DS_AVAILABLEORDER@{ub}.  If  the specified index isn't available any
more,  it is corrupted.  In that case you have to delete the according file
@{i}by hand @{ui} (or  implement  code in your user-application that does this), and
then try to recreate the index.



   @{b}BOOL DBF_SetAccessMode (struct DataServer *server, BOOL exclusive);@{ub}

Using this function, the accessmode of a DataTable can be changed.  Usually
the   accessmode   is   specified  during  initialization  (using  the  Tag
@{"DBF_Exclusive" link Creation_of_DataTables})  and  should  not be changed, but sometimes it's required to
have  exclusive  access to a DataTable (e.g.  if all deleted records should
be  removed  from  the  DataTable,  so  the  recordnumbers of the remaining
records will change).
The  first  argument  is  a  pointer  to  the  DataServer  structure of the
DataTable,  the  second  one  is  a  boolean value, TRUE indicates that the
DataTable  should  be  set  to  exclusive  access,  else  shared  access is
requested.
The  function  returns  the  previous  setting  of  the DataTable, i.e.  it
returns  @{b}TRUE@{ub}  if  the  DataTable  has  have  exclusive  access before this
function was called or @{b}FALSE@{ub} if shared access was set.
This  function  may  fail to change the accessmode, especially if exclusive
access  is requested.  Have a look to the @{b}@{i}LastError @{ui}@{ub}field of the DataServer
structure, which will be set to @{b}DSF_ERR_MINOR@{ub} in the case of a failure.  In
that case you may also look at AmigaDOS @{b}@{i}IoErr() @{ui}@{ub}to get an idea of the cause
of the failure.


The  last functions available for accessing DataTables are used to set some
attributes of the DataTables:


   @{b}ULONG DBF_SetLockMode (struct DataServer *server, ULONG lockMode);@{ub}

There  are  three different locking-modes available for record locking of a
DataTable.  Usually  the  locking  mode  is specified during initialization
using  the  Tag  @{b}DBF_LockMode@{ub}.   This  function  should  be  used,  if  the
locking-mode of an already opened DataTable needs to be changed.
The  first  argument  is  a  pointer  to  the  DataServer  structure of the
DataTable,  the  second  one  is  the  identifier  specifying  the  desired
locking-mode:

   @{b}DSF_LOCK_OPTIMISTIC@{ub}
      use optimistic locking, i.e. the records are locked shared while they
      are  copied  into  the  buffer, then they are unlocked until they are
      written, then the records are locked exclusive while they are written.
   @{b}DSF_LOCK_FULL@{ub}
      a record is locked exclusive while it is the current record.
   @{b}DSF_LOCK_NONE@{ub}
      a  record  is  not locked by the DataTable.  The user-application has
      to  lock  the  records using the  @{b}@{i}DBF_LockRecord()/DBF_UnLockRecord() @{ui}@{ub}
      functions.
   
See  the  section @{"Locking of records" link Locking_of_records} for details about record locking.  The
function  returns the locking-mode that was active, before the function has
been  called.  You  have to check the @{b}@{i}LastError @{ui}@{ub}field of the DataServer for
an  error;  if the locking-mode is set to  @{b}DSF_LOCK_FULL@{ub}, the DataTable may
fail  to  lock  the  current  record.  In  this  case the current record is
undefined, i.e. the recordpointer is set to EOF.



   @{b}BOOL DBF_ShowDeleted (struct DataServer *server, BOOL deleted);@{ub}

Usually  deleted  records  are never used as active records of a DataTable.
Using  this  function the according flag can be set, so deleted records may
be accessed.
Even if the flag is set, the deleted records could only be activated, if no
index  is  activated.   If  a  deleted record is the current record and the
DataTable  has a @{"DataColumn" link DataColumn} of the type @{b}DC_TEXT@{ub} (i.e. it owns a @{"memo-file" link Memo_files})
the  contents  of that DataColumn may be disturbed, because the contents of
the memo file is overwritten independent of the DataTables main file.
The first argument is a pointer to the DataServer structure of the DataTable,
the second one is a boolean value, @{b}TRUE@{ub} indicates that deleted records should
be accessable.
The  setting  of  the  deletion-flag  before  this  function  was called is
returned.  By storing this value you are able to reset the DataTable to the
previous state.
Per  default  deleted records are not displayed and you should not activate
that option, except if you try to retrieve data that is stored in a deleted
record.   But you have only a small chance, because the last deleted record
is  the  first  one  that  is  overwritten, if a new record is added to the
DataTable (deleted records are referenced in a @{i}lifo@{ui} for reuse).
@endnode

@node Private_functions_of_the_DataTable "DataBase.library - Chapter 6, DataTable"
@toc DataTable

@{b}@{fg shine}Section 6.9, Private functions of the DataTable@{fg text}@{ub}

The following functions are declared as private for the internal use of the
DataTable, but they are documented for completeness:


   @{b}BOOL DBF_ClearRecord (struct DataTable *dbTable);@{ub}

This  function  is used to clear the contents of the current record.  It is
used  by  the  DataTable,  whenever  a  new  record  is  inserted  into the
DataTable.
You should pass an empty value to any @{"DataColumn" link DataColumn} of the DataTable using the
@{"operation" link Operations_every_DataServer_should_support}  @{b}DS_SETCOLUMNDATA@{ub}  with  the  argument @{b}@{i}arg @{ui}@{ub} set to @{b}NULL@{ub} instead of
calling this function from an user-application.



   @{b}BOOL DBF_ReadMemo (struct DataColumn *column, APTR memoAddr);@{ub}

This  function copies the @{"memotext" link Memo_files} of the current record into the @{b}@{i}Buffer @{ui}@{ub}of
the  specified  DataColumn,  which  has  to be of the type @{b}DC_TEXT@{ub}.  If the
current  record  doesn't own a memotext, an empty string is copied into the
@{b}@{i}Buffer @{ui}@{ub} instead.  This  function  is  used  as @{i}convertion function @{ui}from the
DataColumns  with the datatype @{b}DC_TEXT@{ub} instead of standard convertion (i.e.
a pointer to this function is stored in the @{b}@{i}Convert @{ui}@{ub}function-pointer of the
@{"DataColumn structure" link The_DataColumn_structure}.  You  should  never call this function direct from an
user-application, use the operation @{b}DS_GETCOLUMNDATA@{ub} instead.



   @{b}BOOL DBF_WriteMemo (struct DataColumn *column,STRPTR memoText,APTR raw);@{ub}

This  function  copies  a  new NUL-terminated C-string into the @{b}@{i}Buffer @{ui}@{ub}of a
DataColumn  of  the  type  @{b}DC_TEXT@{ub}.   This  function  is used as convertion
function from the DataColumns with the datatype @{b}DC_TEXT@{ub} instead of standard
convertion,  i.e.  a  pointer to this function is stored in the DataColumns
function-pointer  @{b}@{i}Revert @{ui}@{ub}.  You should never call this function direct from
an user-application, use the operation @{b}DS_SETCOLUMNDATA@{ub} instead.
@endnode

@node Memo_files "DataBase.library - Chapter 7, Memo files"

@{b}@{fg shine}Chapter 7, Memo files@{fg text}@{ub}

This chapter describes the memo-files used by the @{"DataTables" link DataTable}.  If you don't
think  about  own  extensions  to  the  database.library, you may skip this
chapter,  because  these  files  are  completely  handled by the DataTable,
absolutely hidden to the user.

If  a  DataTable  contains  a  @{"DataColumn" link DataColumn} of the type @{b}DC_TEXT@{ub} -- and only a
single  column  of  this  type  is  allowed per DataTable -- a memo file is
created, which contains the text written to this DataColumn.  The record of
the  DataTable  only  contains  the address, where this text could be found
inside of the memo-file.

This  address  is  build from two 32 bit values, the first one contains the
number  of the @{i}page @{ui}, the entry in the memo-file beginns, the second one is
the  offset  into  this  @{i}page @{ui}.  For simplicity these addresses are usually
stored  in  a DOUBLELONG value, where the pagenumber is stored in the upper
longword, the offset into the @{i}page @{ui}is stored in the lower longword.

A  single  @{i}page @{ui} is  1024 bytes wide in this version of the memo-files, but
maybe this will be increased in future versions of the database.library, if
the resulting maximum filesize of about 4 TB becomes too small ;-).

A  single  entry  in a memofile could be upto 4 GB wide, but since there is
currently  no  existing  Amiga with more than 128 MB continous physical RAM
(except  emulated  Amigas  which  might  have  some more memory), this is a
theoretical  value,  because an entry must be copied completely into memory
for accessing.

The  memo-file according to a DataTable is located in the same directory as
the  DataTable  file  and  has  the  same  filename except that it uses the
extension  ".dbm",  e.g.  if  a  DataTable  with  the file "foo.dbf" owns a
memo-file this would be named "foo.dbm".

Sections:
   @{" The MemoFile structures           " link The_MemoFile_structures}
   @{" Functions for accessing MemoFiles " link Functions_for_accessing_MemoFiles}
@endnode

@node The_MemoFile_structures "DataBase.library - Chapter 7, Memo files"
@toc Memo_files

@{b}@{fg shine}Section 7.1, The MemoFile structures@{fg text}@{ub}

All  accesses  to  a  memo-file  are  done  using  a  pointer to a MemoFile
structure  as a handle.  See <joinOS/database/Memo.h> for the definition of
this structure:

struct MemoFile
{
   BPTR fh;               /* FileHandle of the memofile */
   DOUBLELONG *addr;      /* ptr to a storage with an address of a memo */
   struct MemoBlock emb;  /* used as buffer */
};

The fields of this structure are used as follows:

@{b}fh@{ub}
   This  is  a  BCPL-pointer to the FileHandle of the memo-file.  It is re-
   quired for I/O using AmigaDOS functions/packets.

@{b}addr@{ub}
   This  field contains a pointer to a DOUBLELONG used to store the address
   of an entry in the memo-file.  This pointer is not used by the memo-file
   @{"functions" link Functions_for_accessing_MemoFiles} of the database.library  (i.e. the functions with a name pre-
   ceded  by  the  prefix  'DBM_'), instead this pointer may be used by the
   @{i}user @{ui}of the memo  (e.g. the DataTable class  uses this pointer for poin-
   ting into the buffer with the current records data).

@{b}emb@{ub}
   This  is  an  embedded MemoBlock structure that is used as buffer by the
   memo-file functions.  See below for a description of this structure.


Every  entry  in  a memo-file is preceded by a special block containing the
information that is required to handle the entries:

struct MemoBlock
{
   ULONG Page;
   ULONG Offset;
   ULONG Size;
};

Where the fields have the following purpose:

@{b}Page@{ub}
   The  empty  spaces in the memo-file, that are arise whenever an entry is
   removed from the memo-file, are linked into a empty-space list  (somehow
   simular  to  a  free-memory list as handled by exec).  If a new entry is
   added  to  the  memo-file, this list is scanned for an empty space large
   enough to contain the new entry.  If no space is found, the new entry is
   appended to the end of the memo-file.

   If  this  field or the field @{b}@{i}Offset @{ui}@{ub}contains any value except zero, this
   indicates  that  this entry is deleted.  If both fields contain @{b}-1L@{ub} (all
   bits  set),  this indicates that this entry is the last one in the chain
   of  empty  spaces,  else  this  is the pagenumber and offset to the next
   empty space in the list.

@{b}Offset@{ub}
   This  field  is the offset into the page @{b}@{i}Page @{ui}@{ub}of the next empty space in
   the  list  of  empty  spaces.  See the description of the field @{b}@{i}Page @{ui}@{ub}for
   details.

@{b}Size@{ub}
   This  is the size of the data stored behind this leading MemoBlock, i.e.
   this  is  the  length  of  the string stored in this entry, or -- if the
   entry is empty -- the size of the empty block.
@endnode

@node Functions_for_accessing_MemoFiles "DataBase.library - Chapter 7, Memo files"
@toc Memo_files

@{b}@{fg shine}Section 7.2, Functions for accessing MemoFiles@{fg text}@{ub}

As  already  mentioned,  the  memo-files  are  handled  by the @{"DataTable" link DataTable} so
usually  you doesn't need to know any of the following functions, except if
you  wish  to  implement  extensions to the database.library, e.g.  you may
want to implement a new datatype, something like @{b}DC_ILBM@{ub}, iff-ilbm pictures
stored  in  a  memo-file.   In  this  case  you  should also have a look at
appendix  A,  section  @{"The file structure of a memo file" link The_file_structure_of_a_memo_file}  and  appendix B,
@{"Creating own DataServer subclasses" link Creating_own_DataServer_subclasses}.


   @{b}struct MemoFile *DBM_OpenMemo (STRPTR fileName);@{ub}

This  function  creates  a MemoFile structure and opens the specified file.
If the file is currently not existing, it will be created.  If the function
returns  @{b}NULL@{ub},  you  should  have  a  look  to  @{b}@{i}IoErr() @{ui}@{ub} for  the according
errorcode,  which  will be @{b}ERROR_OBJECT_WRONG_TYPE@{ub} if the file found at the
the specified path (@{b}@{i}fileName @{ui}@{ub}) isn't a memo-file.



   @{b}void DBM_CloseMemo (struct MemoFile *mf);@{ub}

This  function  terminates  access  to  a memo-file.  The according file is
closed and the memory used for the MemoFile structure is freed.



   @{b}BOOL DBM_LockMemo (struct MemoFile *mf);@{ub}

This  function  is  used  if the contents of a memo-file should be changed.
This  is  an  exclusive  write-lock  of the whole file, because the changes
could  be  made  anywhere  in the file (because of the linked list of empty
entries) there can't be locked only a part of the memo-file.
Read-locks are not supported by the memo-file, because the read-accesses to
the memo-file are locked via the record-locking mechanism of the DataTable,
the memo file belongs to.



   @{b}BOOL DBM_UnLockMemo (struct MemoFile *mf);@{ub}

Everytime  the  memo-file is locked using @{b}@{i}DBM_LockMemo() @{ui}@{ub}it has to be freed
as fast as possible using this function.  While the memo-file is locked, no
other instance has access to it.



   @{b}BOOL DBM_ClearMemo (struct MemoFile *mf, DOUBLELONG *addr);@{ub}

This  function  clears  the  entry  at  the  specified  address.  The upper
longword  of  the DOUBLELONG pointed to by the second argument contains the
number of that @{i}page @{ui}the begin of the entry to be cleared is located in, the
lower longword contains the offset into that @{i}page @{ui}.
Clearing  an  entry  means,  the  entry is inserted into the linked list of
unused empty space of the memo-file.



   @{b}APTR DBM_ReadMemo (struct MemoFile *mf, DOUBLELONG *addr);@{ub}

This  function returns a pointer to the data found at the specified address
in  the  memo-file,  i.e.   this  is  usually a pointer to the begin of the
NUL-terminated   C-string  stored  in  the  specified  entry.   The  buffer
containing  this string (i.e.  the memory-region pointed to by the returned
pointer)  is  allocated  by  this  function,  and has to be freed using the
@{b}@{i}FreeVector() @{ui}@{ub}function of the joinOS.library after usage.



   @{b}BOOL DBM_WriteMemo (struct MemoFile *mf, DOUBLELONG *addr,
                                       APTR memo, ULONG size);@{ub}

This  function  writes data into a memo-file.  If the DOUBLELONG pointed to
by  the  second  argument  contains  a valid address in the memo-file, this
entry  is  cleared first (by calling the function @{b}@{i}DBM_ClearMemo() @{ui}@{ub}with this
address),  before  the  data pointed to by the third argument @{b}@{i}memo @{ui}@{ub}with the
bytesize @{b}@{i}size @{ui}@{ub}is written to the memo-file.  The address, where this data is
stored is written to the DOUBLELONG pointed to by the argument @{b}@{i}addr @{ui}@{ub}.

If the function succeeds, @{b}TRUE@{ub} is returned, else @{b}FALSE@{ub} is returned.  In the
event  of  an  error, you should look to the AmigaDOS errorcode returned by
the AmigaDOS function @{b}@{i}IoErr() @{ui}@{ub}.
@endnode

@node Other_functions_of_the_database.library "DataBase.library - Chapter 8, Other functions of the database.library"

@{b}@{fg shine}Chapter 8, Other functions of the database.library@{fg text}@{ub}

These functions are used by the database.library itself, but maybe the one or
other function is useful for your applications too.

Sections:
   @{" String manipulation functions                " link String_manipulation_functions}
   @{" Convertion functions                         " link Convertion_functions}
   @{" Convertion macros                            " link Convertion_macros}
   @{" Functions of the link library Database.lib   " link Functions_of_the_link_library Database.lib}
   @{" Functions for processing fixed point numbers " link Functions_for_processing_fixed_point_numbers}
   @{" Calculating using fixed point numbers        " link Calculating_using_fixed_point_numbers}
@endnode

@node String_manipulation_functions "DataBase.library - Chapter 8, Other functions of the database.library"
@toc Other_functions_of_the_database.library

@{b}@{fg shine}Section 8.1, String manipulation functions@{fg text}@{ub}

There  might  be  ANSI/C-functions  that  do the same, however I cannot use
ANSI/C  library  functions from assembler, so these functions are also part
of the database.library:

   @{b}ULONG AtChr (UBYTE *string, UBYTE character, ULONG slen);@{ub}

This  function  searches the first occurrence of the specified character in
the source string.
You have to pass a pointer to the string to scan to the first argument, the
second argument is the character to be searched and the third the length of
the  string  (the  number  of  characters in @{b}@{i}string @{ui}@{ub}that should be tested).
Because  the  length  of  the  string is specified, it needs not to be NUL-
terminated.
The  position of the frontmost matching character in the string is returned
or zero if no matching character is found.

Examples:

   AtChr ("1234567890", '3', 10) -> 3
   AtChr ("1234567890", 'N', 10) -> 0
   AtChr ("1234567890", '6',  5) -> 0
   AtChr ("abcabcabc",  'b',  9) -> 2



   @{b}ULONG RAtChr (UBYTE *string, UBYTE character, ULONG slen);@{ub}

This  function  is  simular to the function @{b}@{i}AtChr() @{ui}@{ub}except that is searches
the last occurrence of the specified character in the source string.

Examples:

   RAtChr ("1234567890", '3', 10) -> 3
   RAtChr ("1234567890", 'N', 10) -> 0
   RAtChr ("1234567890", '6',  5) -> 0
   RAtChr ("abcabcabc",  'b',  9) -> 8



   @{b}LONG SkipChars (UBYTE *string, UBYTE character, LONG slen);@{ub}

The  name of this function may be somehow confusing, the function skips all
characters  at  the  begin  of  the  source  string pointed to by the first
argument,  that  match the character specified by the second argument.  The
number  of skipped characters is returned, not a pointer behind the skipped
characters, so this function should better be named @{i}CountPrecedingChars() @{ui}.
The  length  of the source string is specified by the third argument, so it
needs not to be NUL-terminated.

Examples:

   SkipChars ("1111112345", '1', 10) -> 6
   SkipChars ("1111112345", '2', 10) -> 0
   SkipChars ("1111112345", '1',  5) -> 5
   SkipChars ("   Hello",   ' ',  8) -> 3
@endnode

@node Convertion_functions "DataBase.library - Chapter 8, Other functions of the database.library"
@toc Other_functions_of_the_database.library

@{b}@{fg shine}Section 8.2, Convertion functions@{fg text}@{ub}

These functions are used by the @{"DataServer" link DataServer} for converting the "raw" data
stored in the @{"DataColumns" link DataColumn} into @{i}human readable @{ui}form and vice versa.


   @{b}UBYTE *STR (DOUBLELONG *val, UBYTE padByte, UWORD slen);@{ub}

This  function  is  somehow  simular  to the AmigaDOS function @{b}@{i}LongToStr() @{ui}@{ub},
except  that  it  converts  DOUBLELONG values (64 bit signed integers) into
decimal  strings.  The length  of the  resulting string is specified by the
third  argument,  if  the  decimal string representing the DOUBLELONG value
(pointed  to by the first argument) is shorter than the desired length, the
string  is  left-paded  with  the  character  specified  using  the  second
argument.
If  the  number  of digits of the decimal string exceeds the desired string
length (i.e.  an overflow occurs), all digits in the buffer are set to '9'.
The maximum number of characters required for a decimal string representing
a DOUBLELONG value is 20 ("-9223372036854775808").
The resulting string is stored in a new allocated buffer of @{b}@{i}slen @{ui}+ 1 @{ub}bytes;
a  pointer to this buffer is returned by this function.  This buffer has to
be freed by calling @{b}@{i}FreeMem() @{ui}@{ub}after usage.
If the function fails to allocate a new buffer, @{b}NULL@{ub} is returned.

Examples:

   DOUBLELONG dl = {0, 123456};
   STR (&dl, ' ', 10) -> "    123456";
   STR (&dl, '0', 10) -> "0000123456";

   DOUBLELONG dl = {-1L, -123456L};
   STR (&dl, ' ', 10) -> "   -123456";
   STR (&dl, '0', 10) -> "000-123456";

   DOUBLELONG dl = {0, 12345678};
   STR (&dl, ' ', 6) -> "999999";
 


   @{b}BOOL TToS (ULONG timeVal, UBYTE *timeStr);@{ub}

This  function  converts a time-value as stored in a DataColumn of the type
@{b}DC_TIME@{ub}  (i.e.   the  number of milliseconds elapsed since midnight) into a
@{i}human readable@{ui} time-string in the format "00:00:00.000".
The  time-value  is  passed  as  first  argument,  the second argument is a
pointer  to the buffer, where the string should be stored.  This buffer has
to be at least 13 bytes large to prevent a buffer-overrun.
If  the  passed  time-value  is  valid  (i.e.  a value below 86400000 == 24
hours), @{b}TRUE@{ub} is returned else @{b}FALSE@{ub} is returned.

Examples:

   UBYTE buffer[13];

   TToS (0, buffer)        -> "00:00:00.000"
   TToS (1234, buffer)     -> "00:00:01.234"
   TToS (51664300, buffer) -> "14:21:04.300"
   TToS (92000000, buffer) -> failure, contents of buffer undefined



   @{b}BOOL SToT (UBYTE *timeStr, ULONG *timeVal);@{ub}

This  is  the reverse function of @{b}@{i}TToS() @{ui}@{ub}, it converts a time-string in the
format  "HH:MM:SS.mmm"  into  the  according timevalue (i.e.  the number of
milliseconds  representing  that  time).   A  pointer to the NUL-terminated
C-string  specifying the time is passed as first argument.  This string may
be  terminated  after  each part of the time, i.e.  either after the hours,
the minutes, seconds, or milli- seconds.
If the passed string represents a valid time-value, the according number of
milliseconds  is  written  to the address the second argument points to and
@{b}TRUE@{ub}  is  returned,  else @{b}FALSE@{ub} is returned and the contents of the address
pointed to by the second argument is not changed.

Examples:

   ULONG timeVal;

   SToT ("00:00:00.000", &timeVal) -> 0
   SToT ("14:21:04.300", &timeVal) -> 51664300
   SToT ("12:00", &timeVal)        -> 43200000
   SToT ("1:7:4", &timeVal)        -> 4024000
   SToT ("7:24 Tuesday", &timeVal) -> failure, illegal time-string
   SToT ("25:10", &timeVal)        -> failure, illegal time-string
   SToT ("10:77", &timeVal)        -> failure, illegal time-string



   @{b}BOOL DToS (APTR date, UBYTE *dateStr);@{ub}

A   convertion-function   usable  to  convert  date-strins  in  the  format
"YYYYMMDD"  (a  terminating  NUL-byte  is  not  required)  into  the format
"dd-mmm-yyyy"  (terminated  by  a  NUL-byte).   A pointer to the date to be
converted is passed by the first argument, the second argument is a pointer
to  the  destination buffer.  This buffer has to be at least 12 bytes large
to  prevent  a  buffer  overrun.   The  source  date  is  not  checked, any
characters  are  accepted, except for the month, which must be in the valid
range of "01" to "12".
The  shortname  of  the  month  in  the  destination string is localized if
AmigaOS 2.1 or above is running, if you are using AmigaOS 2.0 the name will
be always in english.

Examples:

   UBYTE dateStr[12];

   DToS ("20040312", dateStr) -> "12-Mar-2004"
   DToS ("20030254", dateStr) -> "54-Feb-2003"   !!!
   DToS ("YEAR09DD", dateStr) -> "DD-Sep-YEAR"  !!!
   DToS ("20041301", dateStr) -> failure, illegal date



   @{b}BOOL SToD (UBYTE *dateStr, APTR date);@{ub}

This  is  the reverse function of @{b}@{i}DToS() @{ui}@{ub}, it converts a date-string into a
date  value.   The  format  of the date-string -- specified by a pointer to
this  string passed via the first argument -- has to be either "dd-mmm-yy",
"dd-mmm-yyyy", "dd-mm-yy", or "dd-mm-yyyy". Where 'mmm' is the shortname of
the  month  (e.g.  "Dec") and 'mm' is the number of the month (e.g.  "12").
If  you're running AmigaOS 2.1 or above, the short-name of the month has to
be  localized,  if  AmigaOS  2.0 is running, the name has to be in english.
The year has to be any year after 1582 A.D..
The  resulting date-value -- that is stored in the buffer pointed to by the
second  argument -- will be in the format "YYYYMMDD".  This string will not
be NUL-terminated, so a buffersize of 8 bytes will be large enough.
If  the  specified date-string is not valid, @{b}FALSE@{ub} will be returned and the
contents of the destination buffer is undefined.

Examples:

   UBYTE dateVal[8];

   SToD ("12-Mar-2004", dateVal) -> "20040312"
   SToD ("11-Nov-03", dateVal)   -> "20031111"
   SToD ("20-03-99", dateVal)    -> "20990320"
   SToD ("29-02-03", datVal)     -> failure, illegal date
   SToD ("04-Jul-1492", dateVal) -> failure, illegal date



   @{b}BOOL LToS (APTR logic, UBYTE *str);@{ub}

This  simple  function  converts  a  @{i}logic @{ui}value (either 'T' or 'F') into a
boolean  string.   If the logic value, pointed to by the first argument, is
equal  to  'T',  the  NUL-terminated  string  "true" will be written to the
destination  buffer,  the  second  argument  points  to.  In any other case
"false" is written to that buffer.
The primary result of this function will always be @{b}TRUE@{ub}.

Examples:

   UBYTE buffer[6];
   UBYTE logic;

   logic = 'T';
   LToS (&logic, buffer) -> "true"

   logic = 'F';
   LToS (&logic, buffer) -> "false"

   logic = 't';
   LToS (&logic, buffer) -> "false"

   logic = '\0';
   LToS (&logic, buffer) -> "false"



   @{b}BOOL SToL (UBYTE *str, APTR logic)@{ub};

This is the reverse function of @{b}@{i}LToS() @{ui}@{ub},it converts a NUL-terminated string
representing a boolean value into a @{i}logic @{ui}(either 'T' or 'F').
If  the  boolean string pointed to by the first argument is equal to any of
the  following  strings  (compared  case  insensitive)  the @{i}logic @{ui}value the
second argument points to is set to 'T', in any other case it is set to 'F':

   "T", "True", "Y", "Yes", "On", "J", or "Ja"

The  boolean  value  returned  by  this function is equivalent to the value
stored  in  the @{i}logic @{ui}, i.e.  if the @{i}logic @{ui}is set to 'T', @{b}TRUE@{ub} is returned,
else @{b}FALSE@{ub} is returned.

Examples:

   UBYTE logic;

   SToL ("True", &logic) -> 'T'
   SToL ("j", &logic) -> 'T'
   SToL ("No", &logic) -> 'F'
   SToL ("Windows® rules", &logic) -> 'F'


   @{b}BOOL Float2Double (APTR fVal, APTR dVal);@{ub}

This  is  a  small  function, that converts single precision floating point
numbers  (4  bytes long, IEEE) into double precision floating point numbers
(8  bytes  long  IEEE).   Any  compiler  may do this convertion by explicit
casting one type to another, but that requires linkage with a math library.
The  database.library  doesn't do any floating point arithmetic so the size
of  the library is reduced by using this function for convertion instead of
linking  with  a math library.  The first argument is a pointer to a single
precision  floating  point  number, the second argument is a pointer to the
double precison floating point number, where the result should be stored.
   If  the  function  succeeds,  @{b}TRUE@{ub}  is  returned; a returnvalue of @{b}FALSE@{ub}
indicates that the specified floating point number is not valid.
@endnode

@node Convertion_macros "DataBase.library - Chapter 8, Other functions of the database.library"
@toc Other_functions_of_the_database.library

@{b}@{fg shine}Section 8.3, Convertion macros@{fg text}@{ub}

There  are a few macros defined in <joinOS/protos/DatabaseProtos.h>.  These
macros are used for simple convertions and are used by the database.library
itself.
If  you  are  programming using C/C++ you may also use these macros in your
code.


   @{b}BOOL Logic2Bool (UBYTE logic);@{ub}

This  little  macro converts a @{i}logic @{ui}value (single byte, either 'T' or 'F')
into  the  according boolean value.  If the @{i}logic @{ui}value is equal to 'T', it
is replaced by @{b}TRUE@{ub}, otherwise it is replaced by @{b}FALSE@{ub}.



   @{b}UBYTE Upper (UBYTE c);@{ub}

This  macro  convert  a single character into an uppercase character.  This
should work for most characters found in the latin-1 charset as usally used
by  the  Amiga, with the exception of the special character '×' (ASCII 215)
that  is  converted  to  '÷' (ASCII 247).  Other special characters are not
affected.
Take  care  that the argument of this macro isn't an algrebraically expres-
sion  (e.g. "c + 1", "c++", etc.), because this would produce unpredictable
results.



   @{b}UBYTE Lower (UBYTE c);@{ub}

This  macro  convert  a  single character into a lowercase character.  This
should work for most characters found in the latin-1 charset as usally used
by  the  Amiga, with the exception of the special character '÷' (ASCII 247)
that  is  converted  to  '×' (ASCII 215).  Other special characters are not
affected.
Take  care  that the argument of this macro isn't an algrebraically expres-
sion  (e.g. "c + 1", "c++", etc.), because this would produce unpredictable
results.
@endnode

@node Functions_of_the_link_library Database.lib "DataBase.library - Chapter 8, Other functions of the database.library"
@toc Other_functions_of_the_database.library

@{b}@{fg shine}Section 8.4, Functions of the link library Database.lib@{fg text}@{ub}

There are several wrapper-functions in the link library @{i}Database.lib @{ui},these
functions  are  just shortcuts that could be used instead of requesting two
or more operations from a @{"DataServer" link DataServer}.
If  these  functions  are  used  or  the  direct  access to the DataServers
operations  is  just  a  question of personal preserve.  If the DataServers
operations  are  used  instead of these wrapper functions you may save some
time  if  the  same  @{"DataColumn" link DataColumn}  is  accessed  multiple times,  due to the
operation  @{b}DS_FINDCOLUMN@{ub}  is  only  performed  once instead of during every
access  (but  that  operation  is  quite  fast, so don't expect any measur-
able  speed-up).   You  should  have  a  look  to  the  chapter 3,  section
@{"Operations every DataServer should support" link Operations_every_DataServer_should_support}  for  details about the wrapped
operations.


   @{b}BOOL DBF_FieldPut (struct DataServer *server,
                              STRPTR field, STRPTR data);@{ub}

This  is  a shortcut for requesting the operation @{b}DS_FINDCOLUMN@{ub} followed by
the  operation  @{b}DS_SETCOLUMNDATA@{ub}.   The  first argument is a pointer to the
DataServer  structure, the second argument has to point to a NUL-terminated
C-string with the name of the DataColumn to be accessed and the third argu-
ment  should  point  to the NUL-terminated C-string specifying the new con-
tents of the DataColumn.
If  the  data  could be successfully written to the the DataColumn, @{b}TRUE@{ub} is
returned by this function.


   @{b}BOOL DBF_FieldPutRaw (struct DataServer *server,
                              STRPTR field, APTR rawData);@{ub}

This  is  a shortcut for requesting the operation @{b}DS_FINDCOLUMN@{ub} followed by
the  operation @{b}DS_SETRAWDATA@{ub}.  The first argument is a pointer to the Data-
Server  structure,  the  second  argument  has to point to a NUL-terminated
C-string with the name of the DataColumn to be accessed and the third argu-
ment  should  point  to the buffer containing the new contents of the Data-
Column in @{i}raw @{ui}format.
If  the  data  could be successfully written to the the DataColumn, @{b}TRUE@{ub} is
returned by this function.


   @{b}BOOL DBF_FieldGet (struct DataServer *server,
                              STRPTR field, STRPTR *data);@{ub}

This  is  a shortcut for requesting the operation @{b}DS_FINDCOLUMN@{ub} followed by
the  operation  @{b}DS_GETCOLUMNDATA@{ub}.   The  first argument is a pointer to the
DataServer  structure, the second argument has to point to a NUL-terminated
C-string  with  the  name  of  the  DataColumn to be accessed and the third
argument should point to the address, where a pointer to the NUL-terminated
C-string containing the DataColumns data should be stored.
If  the data could be successfully read from the specified DataColumn, @{b}TRUE@{ub}
is returned.


   @{b}BOOL DBF_FieldGetRaw (struct DataServer *server,
                              STRPTR field, APTR *rawdata);@{ub}

This  is  a shortcut for requesting the operation @{b}DS_FINDCOLUMN@{ub} followed by
the  operation @{b}DS_GETRAWDATA@{ub}.  The first argument is a pointer to the Data-
Server  structure,  the  second  argument  has to point to a NUL-terminated
C-string with the name of the DataColumn to be accessed and the third argu-
ment  should  point to the address, where a pointer to the DataColumns data
in @{i}raw @{ui}format should be stored.
If  the data could be successfully read from the specified DataColumn, @{b}TRUE@{ub}
is returned.



The  following  functions  are  also  located  in the Database.lib they are
already mentioned in chapter 5, @{"Functions for parsing key-expressions" link Functions_for_parsing_key-expressions}:

   @{b}BOOL IDX_EvalExpression (struct DataServer *ds, STRPTR expr, APTR key,...);
   ULONG IDX_CountFields (STRPTR expr);@{ub}
@endnode

@node Functions_for_processing_fixed_point_numbers "DataBase.library - Chapter 8, Other functions of the database.library"
@toc Other_functions_of_the_database.library

@{b}@{fg shine}Section 8.5, Functions for processing fixed point numbers@{fg text}@{ub}

The @{"DataTable" link DataTable} class of the database.library supports a DataColumn type for
fixed  point decimal numbers (@{b}DC_NUMERIC@{ub}).  This datatype is useful, if you
have  to  be  shure that you have no rounding problem as you would probably
have if you use floating point numbers (e.g.  the fixed point value "20.17"
may  be  stored  as "20.169999999" if you use floating point numbers).  But
there  has to be a way to do arithmetics with the fixed point numbers to be
really useful.
A  small set of functions for this purpose is part of the database.library.
Using  this  functions  the  fixed  point  numbers  can be converted to use
64 bit algebra  for this  purpose  (the according prototype include file is
<joinOS/protos/NumericProtos.h>)
You  should have a look to chapter 4, @{"DataColumn" link DataColumn} to get familiar with this
kind of data.

In  the  include-file  <joinOS/database/Numeric.h>  the following structure
usable to specify a fixed point value is defined:

struct fixedPointNumeric
{
   UBYTE *Value;
   UWORD Length;
   UWORD Decimals;
};

Where the fields have the following purpose:

@{b}Value@{ub}
   This is a pointer to the buffer, where the numeric value is stored.

@{b}Length@{ub}
   This  field  contains  the length of the fixed point numeric value (i.e.
   the bytesize of the buffer @{b}@{i}Value @{ui}@{ub}points to).  A fixed point number needs
   one  byte  for the sign plus one byte per digit (in front and behind the
   comma);
   e.g.   a  fixed  point  number  of a maximum of 6 digits in front of the
   comma  and 3 digits behind of the comma (fractional part) has an overall
   length of 10 bytes.
   Such a number could have any value between -999999.999 and +999999.999.
   The maximum length a fixed point numeric value might have is 18.

@{b}Decimals@{ub}
   This  field  contains the number of digits of the fractional part of the
   number.

There is an according type-definition named @{b}NUMERIC@{ub}.



   @{b}UWORD NumericIntDigits (UBYTE *num, UWORD length, UWORD decimals);@{ub}

This  function counts the number of digits of a fixed point value, that are
used in front of the comma.  A pointer to the buffer the fixed point number
is  stored  in  is  passed  via  the  first  argument,  the second argument
specifies  the overall size of that buffer, the third argument contains the
number of digits of the fractional part of the number.

Examples:

   UBYTE *ptrNum;

   @{b}@{i}ptrNum @{ui}@{ub} should  be  a  pointer  to  a  fixed point number of 12 bytes in
   length, having 3 decimal digits behind the comma...

   containing a value of "12.450":

      NumericIntDigits (ptrNum, 12, 3) -> 2

   containing a value of "4096.100":

      NumericIntDigits (ptrNum, 12, 3) -> 4

   containing a value of "0.999":

      NumericIntDigits (ptrNum, 12, 3) -> 0

There is a macro defined, which wrapps the functions arguments by a pointer
to a @{b}NUMERIC@{ub}:

   @{b}UWORD NUMERICIntDigits (NUMERIC *num)@{ub}

Take  care  that the argument of this macro isn't an algrebraically expres-
sion (e.g. "num + 1", "num++", etc.), because this would produce unpredict-
able results.



   @{b}BOOL Numeric2DOUBLELONG (UBYTE *num, UWORD length, UWORD decimals,
                                       UWORD exponent, DOUBLELONG *val);@{ub}

This  function  converts  a  fixed  point number into a DOUBLELONG value by
multiplying  the value with a @{i}power of 10 @{ui}and truncating the remaining rest
behind the comma.
The  first  three  arguments  are  a pointer to the buffer, the fixed point
number is  stored  ( @{b}@{i}num @{ui}@{ub}),  the  overall  length of the fixed point number
( @{b}@{i}length @{ui}@{ub})  and  the  number of digits of the fractional part of the number
( @{b}@{i}decimals @{ui}@{ub}).
The  forth  argument  specifies the exponent of the @{i}power of 10 @{ui}, the fixed
point  number  should be multiplied with and the last argument is a pointer
to the DOUBLELONG value, where the result should be stored.
The function returns @{b}TRUE@{ub} on success and @{b}FALSE@{ub} if the specified fixed point
value isn't valid or an overflow occured.

Examples:

   UBYTE *ptrNum;
   DOUBLELONG val;

   @{b}@{i}ptrNum @{ui}@{ub}should be a pointer to a fixed point number of 12 bytes in length,
   having 3 decimal digits behind the comma, containing a value of "12.450":

      Numeric2DOUBLELONG (ptrNum, 12, 3, 0, &val) -> 12
      Numeric2DOUBLELONG (ptrNum, 12, 3, 1, &val) -> 124
      Numeric2DOUBLELONG (ptrNum, 12, 3, 2, &val) -> 1245
      Numeric2DOUBLELONG (ptrNum, 12, 3, 3, &val) -> 12450
      Numeric2DOUBLELONG (ptrNum, 12, 3, 4, &val) -> 124500

There is a macro defined, which wrapps the functions arguments by a pointer
to a @{b}NUMERIC@{ub}:

   @{b}BOOL NUMERIC2DOUBLELONG(NUMERIC *num, UWORD exp, DOUBLELONG *val);@{ub}

Take care that the arguments of this macro aren't an algrebraically expres-
sion (e.g. "exp + 1", "num++", etc.), because this would produce unpredict-
able results.



   @{b}BOOL DOUBLELONG2Numeric (DOUBLELONG *val, UBYTE *num, UWORD length,
                                       UWORD decimals, UWORD exponent);@{ub}

This  is  the  reverse  function  to  Numeric2DOUBLELONG();  it  converts a
DOUBLELONG  value  into a fixed point number by dividing it through a @{i}power
of 10 @{ui}.

The  first  argument  is a pointer to the DOUBLELONG value to be converted,
the  next  three  arguments  are  a  pointer to the buffer, the fixed point
number  is  stored  ( @{b}@{i}num @{ui}@{ub}),  the  overall length of the fixed point number
( @{b}@{i}length @{ui}@{ub})  and  the  number of digits of the fractional part of the number
( @{b}@{i}decimals @{ui}@{ub}). The last argument specifies the exponent of the @{i}power of 10 @{ui},
the DOUBLELONG value should be devided through.
If  the  DOUBLELONG  value could be successfully converted to a fixed point
number @{b}TRUE@{ub} is returned by the functiom, else (overflow) @{b}FALSE@{ub} is returned.

Examples:

   UBYTE num[12];
   DOUBLELONG val;

   @{b}@{i}num @{ui}@{ub} should  be  a  fixed  point  number of 12 bytes in length, having 3
   decimal  digits  behind the comma, the DOUBLELONG should contain a value
   of "12450":

      DOUBLELONG2Numeric (&val, num, 12, 3, 0) -> 12450.000
      DOUBLELONG2Numeric (&val, num, 12, 3, 1) -> 1245.000
      DOUBLELONG2Numeric (&val, num, 12, 3, 2) -> 124.500
      DOUBLELONG2Numeric (&val, num, 12, 3, 3) -> 12.450

There is a macro defined, which wrapps the functions arguments by a pointer
to a @{b}NUMERIC@{ub}:

   @{b}BOOL DOUBLELONG2NUMERIC (DOUBLELONG *val, NUMERIC *num, UWORD exp)@{ub}

Take care that the arguments of this macro aren't an algrebraically expres-
sion (e.g. "exp + 1", "num++", etc.), because this would produce unpredict-
able results.



   @{b}BOOL Str2Numeric (STRPTR str, UBYTE *num, UWORD length, UWORD decimals);@{ub}

This  function is the easiest way to set a fixed point numeric value to the
value according to the user-input.  The NUL-terminated C-string, pointed to
by  the first argument, has to be a decimal string.  Overflows are detected
by  this  function and if the string contains more digits in the fractional
part than the @{b}NUMERIC@{ub} can store, the additional digits are truncated.
The  other  three  arguments  are  a pointer to the buffer, the fixed point
number  is  stored  ( @{b}@{i}num @{ui}@{ub}),  the  overall length of the fixed point number
( @{b}@{i}length @{ui}@{ub})  and  the  number of digits of the fractional part of the number
( @{b}@{i}decimals @{ui}@{ub}).
If the string could be successfully converted, @{b}TRUE@{ub} is returned.

Examples:

   UBYTE *ptrNum;

   @{b}@{i}ptrNum @{ui}@{ub} should  be  a  pointer  to  a  fixed point number of 12 bytes in
   length, having 3 decimal digits behind the comma:

      Str2Numeric ("123.45", ptrNum, 12, 3) -> 123.450
      Str2Numeric ("12.345", ptrNum, 12, 3) -> 12.345
      Str2Numeric ("1.2345", ptrNum, 12, 3) -> 1.234
      Str2Numeric ("1234567890123.456", ptrNum, 12, 3) -> overflow

There is a macro defined, which wrapps the functions arguments by a pointer
to a @{b}NUMERIC@{ub}:

   @{b}BOOL Str2NUMERIC (STRPTR str, NUMERIC *num)@{ub}

Take care that the arguments of this macro aren't an algrebraically expres-
sion (e.g. "num + 1", "num++", etc.), because this would produce unpredict-
able results.



   @{b}BOOL Numeric2Str (UBYTE *num, UWORD length, UWORD decimals, STRPTR str);@{ub}

To convert a fixed point numeric value into a decimal string, this function
is  provided.   The fixed point numeric value, specified by the first three
arguments (a pointer to the value itself, its overall length and the number
of  digits  that  follows  the  comma)  is  converted into a NUL-terminated
C-string,  that  is  written to the buffer pointed to by the last argument.
This buffer has to be at least  @{b}@{i}length @{ui}+ 2@{ub}  bytes large to prevent a buffer
overrun.
If the specified fixed point numeric value is valid, @{b}TRUE@{ub} is returned, else
@{b}FALSE@{ub} should be returned, but currently the value is not tested and @{b}TRUE@{ub} is
always returned.

Example:

   UBYTE *ptrNum;

   @{b}@{i}ptrNum @{ui}@{ub}should be a pointer to a fixed point number of 12 bytes in length,
   having 3 decimal digits behind the comma, containing a value of "12.450":

   UBYTE buffer[14];

   Numeric2Str (ptrNum, 12, 3, buffer) -> "12.450"
   
There is a macro defined, which wrapps the functions arguments by a pointer
to a @{b}NUMERIC@{ub}:

   @{b}BOOL NUMERIC2Str (NUMERIC *num, STRPTR str)@{ub}

Take care that the arguments of this macro aren't an algrebraically expres-
sion (e.g. "num + 1", "num++", etc.), because this would produce unpredict-
able results.
@endnode

@node Calculating_using_fixed_point_numbers "DataBase.library - Chapter 8, Other functions of the database.library"
@toc Other_functions_of_the_database.library

@{b}@{fg shine}Section 8.6, Calculating using fixed point numbers@{fg text}@{ub}

Using  the functions mentioned above, you are able to write code performing
simple arithmetics with fixed point (@{b}NUMERIC@{ub}) numbers.

You  can convert the @{b}NUMERIC@{ub}s into DOUBLELONGs and use the 64bit math func-
tions  supported  by  the joinOS.library.  This way you are able to perform
simple   addition  and  substraction  (using  the  functions  @{b}@{i}Adds64() @{ui}@{ub} and
@{b}@{i}Neg64() @{ui}@{ub}).  You  may  also be able to write a multiplication and a division
function by your own, if you are familiar in binary algebra.
The  other  way is to use a higher level programming language that supports
64bit algebra,  and  convert  the  DOUBLELONG  value into the 64bit integer
required for that compiler-specific datatype.

Here  is  an  example  of  how  you can perform the addition of two or more
@{b}NUMERIC@{ub}s:

   This example uses two  @{b}NUMERIC@{ub}s,  the first @{b}@{i}foo @{ui}@{ub}has an overall length of
   10 bytes,  using 3 digits for the fractional part, the seond one @{b}@{i}bar @{ui}@{ub}has
   a length of 12 bytes, using 2 digits for the fractional part.
   The result should be stored in the @{b}NUMERIC@{ub} @{b}@{i}foobar @{ui}@{ub}:  10 bytes in length,
   4 digits for the fractional part:

   UBYTE num1[10];
   UBYTE num2[12];
   UBYTE num3[10];

   NUMERIC foo = {num1, 10, 3};
   NUMERIC bar = {num2, 12, 2};
   NUMERIC foobar = {num3, 10, 4};

   In this example we preset the  @{b}NUMERIC@{ub}s using the function @{b}@{i}Str2Numeric() @{ui}@{ub}
   (respectively  the  according macro @{b}@{i}Str2NUMERIC() @{ui}@{ub}) usually this is done
   simular, if the values are read from userinput, but in @{i}real @{ui}applications
   these values may also be read from a @{"DataTable" link DataTable}.

   Str2NUMERIC ("123.456", &foo);
   Str2NUMERIC ("23.10", &bar);

   Now  we  have  a  look to the number of digits in the fractional part of
   every  @{b}NUMERIC@{ub}  that  should  be  added and get the maximum value.  This
   would be 3 in this example.

   UWORD exp = max (foo.Decimals, bar.Decimals);

   You  should take care that you don't run into an overflow during conver-
   tion  of  the @{b}NUMERIC@{ub} to DOUBLELONG value, that might be the case if you
   access @{b}NUMERIC@{ub} values that have great differences in the number of frac-
   tional digits.
   The  easiest  way  is  using  the function @{b}@{i}NumericIntDigits() @{ui}@{ub}with every
   value  to  be  added  and  to  take  care that the @{i}power of ten @{ui}plus the
   largest  value got via @{b}@{i}NumericIntDigits() @{ui}@{ub}doesn't exceeds 18.  Otherwise
   (or if you expect that the sum would have more than 18 digits) the @{i}power
   of 10 @{ui}must be reduced so the limit is not exceeded  (in this example the
   limit  could  not  be  exceeded,  because  none  of the @{b}NUMERIC@{ub}s is long
   enough).

   UWORD digits;

   digits = NUMERICIntDigits (&foo);
   if ((digits + exp) > 17) exp = 17 - digits;
   digits = NUMERICIntDigits (&bar);
   if ((digits + exp) > 17) exp = 17 - digits;

   Now  we  convert  all  fixed  point  numbers  that  should be added into
   DOUBLELONG  values,  by enlarging both values by the @{i}power of ten @{ui}previ-
   ously found:

   DOUBLELONG dfoo;
   DOUBLELONG dbar;

   NUMERIC2DOUBLELONG (&foo, exp, &dfoo);
   NUMERIC2DOUBLELONG (&bar, exp, &dbar);

   Now we could add these values using @{b}@{i}Adds64() @{ui}@{ub}.

   Adds64 (&dfoo, &dbar);

   And reconvert the result into the destination @{b}NUMERIC@{ub} @{b}@{i}foobar @{ui}@{ub}:

   DOUBLELONG2NUMERIC (&dfoo, &foobar, exp);

   The result is converted into a string and printed:

   UBYTE buffer[20];

   NUMERIC2Str (&foobar, buffer);
   puts (buffer);                     -> "146.5560"

This  seems to be complicated but you don't have rounding errors using this
way.   Maybe there is someone out there who creates a library that supports
the basic math functions for @{b}NUMERIC@{ub}s  -- if these are written in assembler,
BCD-numbers  and  the  according assembler instructions (ABCD, SBCD) may be
usefull  for  this purpose -- or maybe I get in need of this and create one
of my own.
@endnode

@node How_to_create_Databases "DataBase.library - Chapter 9, How to create Databases"

@{b}@{fg shine}Chapter 9, How to create Databases@{fg text}@{ub}

This  chapter  should help you to set-up your databases.  It's only a short
guide, you should already be familar with the functionality provided by the
database.library and know how to design a relational database.  If you have
designed  a  relational  database,  this chapter will help you in realizing
your plans using the database.library.

As already mentioned, you should design your database.

What's the purpose of the database ?
What should it contain, how is the database structured ?

Usually  you  would  have  to create something like an entity-relationship-
model (ERM).  The  according  diagram  (ERD)  should  not  contain any  @{b}n:m@{ub}
relations, normalize your ERM if it still contains such relations.

Sections:
   @{" Preparation             " link Preparation}
   @{" Creating the DataTables " link Creating_the_DataTables}
   @{" Indexes                 " link HOWTO_Indexes}
   @{" Relations               " link Relations}
   @{" Last words              " link Last_words}
@endnode

@node Preparation "DataBase.library - Chapter 9, How to create Databases"
@toc How_to_create_Databases

@{b}@{fg shine}Section 9.1, Preparation@{fg text}@{ub}

Lets have a look at an example,  a database for storing your private music-
collection the @{i}MusicDB @{ui}.
This database should contain some information about every song found in the
private  collection  inclusive  information  about the according album, the
medium it is stored on (e.g.  "CD", "LP" or "MC"), and the artist.

                          /\\
                         /  \\
     +------------------<  F >------------------+
     |                   \\  /                   |
     |                    \\/                    |
  0,1|                                       1,n|
 +--------+     /\\     +-------+     /\\     +-------+     /\\     +--------+
 |        |1   /  \\ 1,n|       |1,n /  \\   1|       |0,n /  \\   1|        |
 | Artist |---<  A >---|  Song |---<  B >---| Album |---<  E >---| Medium |
 |        |    \\  /    |       |    \\  /    |       |    \\  /    |        |
 +--------+     \\/     +-------+     \\/     +-------+     \\/     +--------+
  0,n|                  0,n|                 0,n|
     |                     |                    |
     |                     /\\                   |
     |                    /  \\                  |
     |                   <  C >                 |
     |                    \\  /                  |
     |                     \\/                   |
     |                     |                    |
     |                  0,1|                    |
     |          /\\     +-------+     /\\         |
     |         /  \\ 0,1|       |0,1 /  \\        |
     +--------<  D >---| Style |---<  G >-------+
               \\  /    |       |    \\  /
                \\/     +-------+     \\/

                      The ERD of the MusicDB

The relations in words:

A - Every  song  is  interpreted  by  an artist;  every artist has rendered
    several songs (at least one)
B - Every song is located at a single album; every album contains an uncer-
    tain number of songs (at least one)
C - Every song might be arranged to a music-style;  every style is rendered
    by any number of songs.
D - Every artist might have a main music-style, every style is performed by
    any number of artists.
E - Every  album is stored at a single medium;  every type of medium can be
    used by any number of albums.
F - Every album could have a main artist;  every artist could have rendered
    any number of albums, at least one.
G - Every  album might have a main music-style;  every style might be found
    on several albums.

Note  that  this  is  an simple example, for a @{i}real@{ui} database you might take
into account that there may be several songs located on more than one album
and  there  may  be  also  albums twice or more in the collection stored on
different mediums.

Every entity of this database contains several fields of information, where
all  of  them  have an unique value used to identify a single record -- the
so-called  @{i}primary key @{ui}.  The  relations  to the other entities are done by
referencing  the  @{i}primary key @{ui} of  the  related entity.  This  reference is
called @{i}foreign key @{ui}.

The  contents  of the entities of the @{i}MusicDB @{ui}(the @{i}primary key @{ui}is marked by
an @{b}'@'@{ub}, the @{i}foreign keys @{ui}by an @{b}'&'@{ub})

 field   | type     |length| unique |not empty| comment
---------+----------+------+--------+---------+----------------------------
@ATNR    | integer  | 4    | TRUE   | TRUE    | @{i}primary key @{ui}of @{i}Artist@ {ui}
ARTISTS  | alphanum.| 50   | FALSE  | TRUE    | name of the artist/band
NICKNAME | alphanum.| 40   | FALSE  | FALSE   | @{i}Nickname @{ui}used for searching
&STYLE   | integer  | 4    | FALSE  | FALSE   | @{i}foreign key@{ui} of musicstyle
COMMENT  | alphanum.| any  | FALSE  | FALSE   | any comment about artist

                     The entity @{i}Artists @{ui}


 field   | type     |length| unique |not empty| comment
---------+----------+------+--------+---------+----------------------------
@SGNR    | integer  | 4    | TRUE   | TRUE    | @{i}primary key @{ui}of @{i}Song @{ui}
TRACK    | integer  | 2    | FALSE  | TRUE    | no. of track in the @{i}Album @{ui}
SONG     | alphanum.| 50   | FALSE  | TRUE    | name of the song
&ABNR    | integer  | 4    | FALSE  | TRUE    | @{i}foreign key @{ui}of @{i}Album @{ui}
&ATNR    | integer  | 4    | FALSE  | TRUE    | @{i}foreign key @{ui}of @{i}Artist @{ui}
&STYLE   | integer  | 4    | FALSE  | FALSE   | @{i}foreign key @{ui}of @{i}Style @{ui}
LENGTH   | time     | -    | FALSE  | FALSE   | length of the song
YEAR     | integer  | 2    | FALSE  | FALSE   | year of release of song
BPM      | integer  | 1    | FALSE  | FALSE   | beats-per-minute

                     The entity @{i}Song @{ui}


 field    | type     |length| unique |not empty| comment
----------+----------+------+--------+---------+---------------------------
@STYLE    | integer  | 4    | TRUE   | TRUE    | @{i}primary key @{ui}of @{i}Style @{ui}
STYLENAME | alphanum.| 30   | FALSE  | FALSE   | name of the music-style
BPM       | integer  | 1    | FALSE  | FALSE   | average beats-per-minute

                     The entity @{i}Style @{ui}


 field  | type     |length| unique |not empty| comment
--------+----------+------+--------+---------+-----------------------------
@ABNR   | integer  | 4    | TRUE   | TRUE    | @{i}primary key @{ui}of @{i}Album @{ui}
ALBUM   | alphanum.| 50   | FALSE  | TRUE    | name of the song
&MEDIUM | alphanum.| 3    | FALSE  | TRUE    | @{i}foreign key @{ui}of @{i}Medium @{ui}
&ATNR   | integer  | 4    | FALSE  | FALSE   | main-artist/@{i}foreign key @{ui}
&STYLE  | integer  | 4    | FALSE  | FALSE   | main-style/@{i}foreign key @{ui}
YEAR    | integer  | 2    | FALSE  | FALSE   | year of release of album
COMMENT | alphanum.| any  | FALSE  | FALSE   | any comment about the album

                     The entity 'Album'


 field  | type     |length| unique |not empty| comment
--------+----------+------+--------+---------+-----------------------------
@MEDIUM | alphanum.| 3    | TRUE   | TRUE    | @{i}primary key @{ui},shortname("CD")
NAME    | alphanum.| 30   | FALSE  | FALSE   | name of the medium
DIGITAL | boolean  | -    | FALSE  | FALSE   | digital or analog medium ?
  
                     The entity @{i}Medium @{ui}
@endnode

@node Creating_the_DataTables "DataBase.library - Chapter 9, How to create Databases"
@toc How_to_create_Databases

@{b}@{fg shine}Section 9.2, Creating the DataTables@{fg text}@{ub}

After the database is designed, the next step is quite simple:

Every  entity  is  represented  by  a  @{"DataTable" link DataTable}, so you have to set-up the
according  @{"DBStruct structure" link The_DBStruct_structure}-arrays and the @{"TagItem lists" link Creation_of_DataTables} to create these
DataTables:

struct DBStruct artistDBS[] =
{
   {"ATNR",     "Artistno.", "unique identifier of an artist",
                                           DC_LONG,  DCF_NOT_EMPTY, 0,  0},
   {"ARTIST",   "Artist",    "name of the artist/band",
                                           DC_CHAR,  DCF_NOT_EMPTY, 50, 0},
   {"NICKNAME", "Nickname",  "short name used for easier search of artists",
                                           DC_CHAR,  0,             40, 0},
   {"STYLE",    "Styleno.",  "foreign key of artists usual music-style",
                                           DC_LONG,  0,             0,  0},
   {"COMMENT",  "Comment",   "private comments",
                                           DC_TEXT,  0,             0,  0},
   {0}
};

struct TagItem artistTags[] =
{
   {DBF_Name,        (ULONG)"Artist"},
   {DBF_FileName,    (ULONG)"Artist.dbf"},
   {DBF_Struct,      (ULONG)artistDBS},
   {DBF_ForceUnique, 0},
   {TAG_DONE,        0}
};


struct DBStruct songDBS[] =
{
   {"SGNR",     "Songno.",   "unique identifier of a song",
                                           DC_LONG,  DCF_NOT_EMPTY, 0,  0},
   {"TRACK",    "Trackno.",  "number of the track in the according album",
                                           DC_WORD,  DCF_NOT_EMPTY, 0,  0},
   {"SONG",     "Song",      "name of the song",
                                           DC_CHAR,  DCF_NOT_EMPTY, 50, 0},
   {"ABNR",     "Albumno.",  "identifier referencing the album",
                                           DC_LONG,  DCF_NOT_EMPTY, 0,  0},
   {"ATNR",     "Artistno.", "identifier referencing the artist",
                                           DC_LONG,  DCF_NOT_EMPTY, 0,  0},
   {"STYLE",    "Styleno.",  "identifier referencing the music-style",
                                           DC_LONG,  0,             0,  0},
   {"LENGTH",   "Length",    "length of the song",
                                           DC_TIME,  0,             0,  0},
   {"YEAR",     "Year",      "year of first release",
                                           DC_WORD,  0,             0,  0},
   {"BPM",      "bpm",       "beats-per-minute",
                                           DC_BYTE,  0,             0,  0},
   {0}
};

struct TagItem songTags[] =
{
   {DBF_Name,        (ULONG)"Song"},
   {DBF_FileName,    (ULONG)"Song.dbf"},
   {DBF_Struct,      (ULONG)songDBS},
   {DBF_ForceUnique, 0},
   {TAG_DONE,        0}
};


struct DBStruct styleDBS[] =
{
   {"STYLE",    "Styleno.",  "unique identifier of a music-style",
                                           DC_LONG,  DCF_NOT_EMPTY, 0,  0},
   {"STYLENAME","Style",     "name of the music-style",
                                           DC_CHAR,  DCF_NOT_EMPTY, 30, 0},
   {"BPM",      "bpm",       "average beats-per-minute",
                                           DC_BYTE,  0,             0,  0},
   {0}
};

struct TagItem styleTags[] =
{
   {DBF_Name,        (ULONG)"Style"},
   {DBF_FileName,    (ULONG)"Style.dbf"},
   {DBF_Struct,      (ULONG)styleDBS},
   {DBF_ForceUnique, 0},
   {TAG_DONE,        0}
};


struct DBStruct albumDBS[] =
{
   {"ABNR",     "Albumno.",  "unique identifier of an album",
                                           DC_LONG,  DCF_NOT_EMPTY, 0,  0},
   {"ALBUM",    "Album",     "name of the album",
                                           DC_CHAR,  DCF_NOT_EMPTY, 50, 0},
   {"MEDIUM",   "Medium",    "identifier referencing the medium",
                                           DC_CHAR,  DCF_NOT_EMTY,  3,  0},
   {"ATNR",     "Artistno.", "identifier referencing the main artist",
                                           DC_LONG,  0,             0,  0},
   {"STYLE",    "Styleno.",  "identifier referencing the main music-style",
                                           DC_LONG,  0,             0,  0},
   {"YEAR",     "Year",      "year of the release of the album",
                                           DC_WORD,  0,             0,  0},
   {"COMMENT",  "Comment",   "private comments",
                                           DC_TEXT,  0,             0,  0},
   {0}
};

struct TagItem albumTags[] =
{
   {DBF_Name,        (ULONG)"Album"},
   {DBF_FileName,    (ULONG)"Album.dbf"},
   {DBF_Struct,      (ULONG)albumDBS},
   {DBF_ForceUnique, 0},
   {TAG_DONE,        0}
};


struct DBStruct mediumDBS[] =
{
   {"MEDIUM",   "Medium",    "abbreviation of the mediums name",
                                           DC_CHAR,  DCF_NOT_EMPTY, 3,  0},
   {"NAME",     "Name",      "name of the medium",
                                           DC_CHAR,  DCF_NOT_EMPTY, 30, 0},
   {"DIGITAL",  "Digital",   "Is the medium a digital or an analog medium ?",
                                           DC_LOGIC, 0,             0,  0},
   {0}
};

struct TagItem mediumTags[] =
{
   {DBF_Name,        (ULONG)"Medium"},
   {DBF_FileName,    (ULONG)"Medium.dbf"},
   {DBF_Struct,      (ULONG)mediumDBS},
   {DBF_ForceUnique, 0},
   {TAG_DONE,        0}
};


Now  the DataTables of the new database could be created.  In the following
sections of this chapter, we suggest the DataTables are already created and
the pointers to the according DataTable structures are named:

   @{b}@{i}artistDB, songDB, styleDB, albumDB, @{ui}@{ub}and @{b}@{i}mediumDB @{ui}@{ub}

@endnode

@node HOWTO_Indexes "DataBase.library - Chapter 9, How to create Databases"
@toc How_to_create_Databases

@{b}@{fg shine}Section 9.3, Indexes@{fg text}@{ub}

What's  still  missing  are the @{"indexes" link Indexes} used for accessing the @{"DataTables" link DataTable}.
There is a simple rule, which indexes are required at least:

You  need  an  unique  index for every @{"DataColumn" link DataColumn} of every DataTable, that
should  contain  unique  contents,  e.g.  for  all DataColumns used for the
@{i}primary keys @{ui}.

In this example these are the following DataColumns:

 DataColumn | DataTable
------------+-----------
 ATNR       | Artist
 SGNR       | Song
 STYLE      | Style
 ABNR       | Album
 MEDIUM     | Medium

Usually  the  @{"key-expression" link Key-expressions_and_key-values}  of  these  indexes  is  just  the name of the
DataColumn,  so  it's  quite  easy to set-up the TagItem lists required for
@{"creating the indexes" link Creating_an_index}:

struct TagItem idx_artistTags[]
{
   {IDX_Name,       (ULONG)"ATNR"},
   {IDX_FileName,   (ULONG)"ATNR.idx"},
   {IDX_Expression, (ULONG)"ATNR"},
   {IDX_Server,     (ULONG)artistDB},
   {IDX_Unique,     0},
   {TAG_DONE,       0}
};

struct TagItem idx_songTags[]
{
   {IDX_Name,       (ULONG)"SGNR"},
   {IDX_FileName,   (ULONG)"SGNR.idx"},
   {IDX_Expression, (ULONG)"SGNR"},
   {IDX_Server,     (ULONG)songDB},
   {IDX_Unique,     0},
   {TAG_DONE,       0}
};

struct TagItem idx_styleTags[]
{
   {IDX_Name,       (ULONG)"STYLE"},
   {IDX_FileName,   (ULONG)"Style.idx"},
   {IDX_Expression, (ULONG)"STYLE"},
   {IDX_Server,     (ULONG)styleDB},
   {IDX_Unique,     0},
   {TAG_DONE,       0}
};

struct TagItem idx_albumTags[]
{
   {IDX_Name,       (ULONG)"ABNR"},
   {IDX_FileName,   (ULONG)"ABNR.idx"},
   {IDX_Expression, (ULONG)"ABNR"},
   {IDX_Server,     (ULONG)albumDB},
   {IDX_Unique,     0},
   {TAG_DONE,       0}
};

struct TagItem idx_mediumTags[]
{
   {IDX_Name,       (ULONG)"MEDIUM"},
   {IDX_FileName,   (ULONG)"Medium.idx"},
   {IDX_Expression, (ULONG)"MEDIUM"},
   {IDX_Server,     (ULONG)mediumDB},
   {IDX_Unique,     0},
   {TAG_DONE,       0}
};

You  may  also  create some more indexes, used for @{"seeking" link Navigating_through_an_index} and sorting the
DataTables, these are usually indexes that work on the @{i}foreign keys @{ui}and the
alphanumeric columns, so we MAY add the following indexes to the database:

DataTable| key-expression        | purpose
---------+-----------------------+-----------------------------------------
Artist   | "Upper(Artist)"       | searching for an artist by its name
Artist   | "Upper(Nickname)"     | searching for an artist by its nickname
Artist   | "Style"               | sorting the artists by their music-style
Song     | "Upper(Song)"         | searching a song by its name
Song     | "ATNR"                | searching all songs of an artist
Song     | "Style"               | sorting the songs by their music-style
Song     | "length"              | sorting the songs by their length
Song     | "year"                | searching songs of the same timeperiod
Song     | "bpm"                 | sorting the songs by their speed
Song     | "Val(Str(Album,10)+   | sorting songs by their album and all...
         |     StrZero(Track,5))"| ..songs on the same album by their track
Style    | "Upper(Stylename)"    | sorting the music-styles by name
Style    | "bpm"                 | sorting the music-styles by their speed
Album    | "Upper(Album)"        | searching an album by its name
Album    | "ATNR"                | searching all albums of an artist
Album    | "style"               | sorting the albums by their music-style
Album    | "year"                | searching albums of the same timeperiod
Album    | "medium"              | searching albums stored on a mediumtype
Medium   | "digital"             | searching all digital/analog mediums

You  should  not  create  all  possible  indexes,  this would slow down the
database  a  lot;  the  indexes  that  are very rare used, might be created
temporary  (without an according file, if you have enough memory available)
if required and disposed after usage.
@endnode

@node Relations "DataBase.library - Chapter 9, How to create Databases"
@toc How_to_create_Databases

@{b}@{fg shine}Section 9.4, Relations@{fg text}@{ub}

The  @{"relations" link Relations_between_DataTables}  between the entities (@{"DataTables" link DataTable}) of the database could be
either  established  by  your  user-applications code (i.e.  if you want to
read the data in a related DataTable referenced by a @{i}foreign key @{ui}, you have
to  use  the  main  @{"index" link Indexes}  --  the one indexing the @{i}primary key @{ui}-- for that
DataTable  and  @{"seek" link Operations_every_DataServer_should_support}  for the @{i}foreign key @{ui}value) or you could establish the
relations by using the function @{b}@{i}DBF_SetRelation() @{ui}@{ub}.

To  establish  a  relation using @{b}@{i}DBF_SetRelation() @{ui}@{ub}you have to identify the
superior and the client DataServer of the relation.  The client @{"DataServer" link DataServer}
is  the  one  related  to  the  superior  DataServer,  i.e.   the client is
positioned,  depending  on  the  current record of the superior DataServer.
You  need+  also  to  identify the index that has to be used for the client
server  and  the  @{"key-expression" link Key-expressions_and_key-values}  that  has  to  be  used to  generate the
key-values used to seek into that index.

For the seven relations in the example above, these are as follows:

 relation | superior |  client  | index  | key-expression
----------+----------+----------+--------+---------------
    A     | Song     | Artist   | ATNR   | "ATNR"
    B     | Song     | Album    | ABNR   | "ABNR"
    C     | Song     | Style    | STYLE  | "Style"
    D     | Artist   | Style    | STYLE  | "Style"
    E     | Album    | Medium   | MEDIUM | "Medium"
    F     | Album    | Artist   | ATNR   | "ATNR"
    G     | Album    | Style    | STYLE  | "Style"

There  are  two possible orders in establishing relations between more than
two  DataTables:   Either  from  bottom to top or from top to bottom.  This
means the relations between three or more DataTables -- lets name them 'A',
'B',  and 'C' -- could be either established by first relating the superior
DataTable  'B' with its client 'C' and then relating the superior DataTable
'A'  with  its client 'B' (bottom to top), or by first relating 'A' and 'B'
and then 'B' and 'C' (top to bottom).
The difference is found in the behaviour of the @{b}@{i}DBF_SetRelation() @{ui}@{ub}function.
This  function adds all @{"DataColumns" link DataColumn} of the client DataTable to the superior
DataTables  list  of  DataColumns  if  a relation is established.  This way
these  columns  could  be read via accessing the superior DataTable without
further  knowledge  of the related DataTable.  It makes it easier to browse
the  contents of these related servers by an universal databrowser.  If the
relations  are  established  from  bottom  to  top,  all DataColumns of the
DataTable  'C' are added to the superior DataTable 'B', if now the relation
between  the  superior DataTable 'A' and its client 'B' is established, all
DataColumns  of  'B'  and  'C'  are  added  to  the  list of DataColumns of
DataTable 'A'.
If  the  first  made  relation  is  the  one  between 'A' and 'B', only the
DataColumns  of  the  DataTable 'B' are added to the list of Datacolumns of
'A'.   If the relation between 'B' and 'C' is established now, the existing
relation  between  'A'  and  'B' is not effected, so the DataColumns of the
DataTable  'C' are NOT added to the DataTable 'A' (they are added to 'B' of
cause).

Confused ?  Try  it out using the examples in the "examples" directory pro-
vided with the database.library.
@endnode

@node Last_words "DataBase.library - Chapter 9, How to create Databases"
@toc How_to_create_Databases

@{b}@{fg shine}Section 9.5, Last words@{fg text}@{ub}

You should only open DataTables, their according indexes, and establish re-
lations  between DataTables, if it is required.  Every unnecessary seek in-
creases  the  I/O-load.   All  related  DataTables are seeked, whenever the
superior DataServer is repositioned.

Now have fun and create your own databases.
@endnode

@node Implementation_details "DataBase.library - Appendix A, Implementation details"

@{b}@{fg shine}Appendix A, Implementation details@{fg text}@{ub}

This appendix contains information that is only required, if you want to write
own extensions to the database.library, i.e. writing own subclasses of the
DataServer class or enhance existing classes.
Here you could also find a description of the structure of the DataTable, memo,
and index files. This information is required, if you want to access these
files from operating systems, that are not supported by the database.library,
i.e. for that operating systems, where no native library is available from me.

Sections:
   @{" The file structure of a DataTable file " link The_file_structure_of_a_DataTable_file}
   @{" The file structure of a memo file      " link The_file_structure_of_a_memo_file}
   @{" The file structure of an index file    " link The_file_structure_of_an_index_file}
   @{" Format of precompiled key-expressions  " link Format_of_precompiled_key-expressions}
@endnode

@node The_file_structure_of_a_DataTable_file "DataBase.library - Appendix A, Implementation details"
@toc Implementation details

@{b}@{fg shine}Section A.1, The file structure of a DataTable file@{fg text}@{ub}

As  every  file  used  by  the  database.library,  the  data written to the
@{"DataTable" link DataTable}  files is  stored in big endian format as usual for Amiga files.
Other  operating  systems that use the little endian format (i.e.  anything
using the Intel-x86 architecture) have to do proper convertion.

A  DataTable  file  is  divided in a header part containing the information
about the structure of the data stored in the second part:  the data part.

In  opposide  to  the @{"DataServer" link DataServer} class itself, the records in this file are
numbered  from zero to @{i}n @{ui}, so the @{i}n@{ui}'th record of a DataTable references the
record @{i}n @{ui}- 1 in  this  file.  The record with the number zero starts at the
first  byte behind the header part  (i.e. the first byte of the data part).
The next record is stored direct behind the previous one.

The  following structure -- defined in <joinOS/database/DataTable.h> -- de-
scribes the header of the file:

struct DataTableHeader
{
   ULONG FileID;                /* 'DBF ' */
   ULONG VersionID;             /* 1L */
   ULONG HeaderSize;            /* size of this structure (>= 1024) */
   ULONG EmptyRecord;           /* number of the first unused record */
   ULONG NumberOfRecords;       /* number of valid records in the file */
   ULONG TotalNumRecords;       /* total no. of records (valid & deleted)*/
   UWORD RecordLength;          /* size of a single record (8 - 32767) */
   UWORD NumberOfColumns;       /* number of columns per record */
   struct DBFColumn Columns[0]; /* array of 'NumberOfColumns' structures */
};

The fields of this @{i}structure @{ui}have the following purpose/contents:

@{b}FileID@{ub} (offset 0)
   The  first 4 bytes of every DataTable file contains the ASCII characters
   'D',  'B',  'F',  and  '  ' (a space, ASCII 32).  This Id may be used to
   identify  the  DataTable files as what they are (if you have an OS, that
   doesn't  is so stupid as Wind**f that just looks for a file-extension, a
   relict from earliest DOS days).

@{b}VersionID@{ub} (offset 4)
   The  second longword of the file contain a version number (in big endian
   format  as already mentioned).  This should be 1 for the current version
   of the database.library.  Future versions may use higher version numbers
   if the file structure would be changed,  so it contains improvements not
   usable by older versions of the database.library.

@{b}HeaderSize@{ub} (offset 8)
   This  longword contains the overall size of the DataTables header.  This
   has  to be at least 1024, but may be larger if more space is required to
   store  the  whole  header-information.   This  value  has to be always a
   multiple of 4 bytes.

@{b}EmptyRecord@{ub} (offset 12)
   The  empty  (deleted) records of the DataTable are linked into a list of
   empty  records.   This  longword  contains the number of the first empty
   record in that list.
   If a record is deleted,  its record number is stored here and the previ-
   ously stored value from this longword is stored in the first longword of
   the just deleted record.
   If a new record is added to the DataTable, and there is a deleted record
   referenced  by  this longword, that record is overwritten and the number
   of  the  next deleted record referenced by the overwritten one is stored
   here;  so  this list of deleted records is implemented as @{b}LIFO@{ub} (@{b}L@{ub}ast @{b}I@{ub}n,
   @{b}F@{ub}irst  @{b}O@{ub}ut).   If  every  bit  of this longword is set (-1), there is no
   empty  record  in  the  file, new records are appended to the end of the
   file in this case.

@{b}NumberOfRecords@{ub} (offset 16)
   This  longword  contains  the number of valid (not deleted) records cur-
   rently stored in the file.  This field has to be updated everytime a new
   record  is  added  to the DataTable or a record is deleted (added to the
   list of empty records).

@{b}TotalNumRecords@{ub} (offset 20)
   This  longword  contains the total number of records currently stored in
   the  file, i.e.  the number of valid plus the number of deleted records.
   This  field  has to be updated everytime a new record is appended to the
   end of the file.

@{b}RecordLength@{ub} (offset 24)
   This word (2 bytes) contains the bytesize of a single record. This value
   has  to  be  a multiple of 4, at least 8, since 4 bytes are required for
   the  linked list of empty records and there should be any data stored in
   a  record.   At  maximum  a  record could be 32764 bytes in length.  The
   length of a record depends of the length of all @{"columns" link DataColumn} of the record.

   Some pad-bytes may be added between the columns for alignment:
     - columns of the type @{b}DC_CHAR@{ub}, @{b}DC_VARCHAR@{ub}, @{b}DC_BYTE@{ub}, @{b}DC_LOGIC@{ub}, @{b}DC_DATE@{ub},
       and @{b}DC_NUMERIC@{ub} are not paded at all, they may start at odd addresses
     - a  column  of the  type @{b}DC_WORD@{ub} is preceded by a single pad-byte, if
       it  would start at an odd address otherwise. @{b}DC_WORD@{ub} columns have to
       start at even addresses.
     - all  other  columns are preceded by as many pad-bytes as required to
       reach an address that is a multiple of 4.

   Every  record  in  the file has exact this length and is written without
   any  further pading behind its preceding record.  So it's easy to locate
   any  record in this file by its number (recNo), the record starts at the
   byte:

      @{b}@{i}HeaderSize @{ui}@{ub}+ recNo * @{b}@{i}RecordLength @{ui}@{ub}

   Keep in mind that the record-numbers used by the DataTable class are one
   above the record-numbers used in the file.

@{b}NumberOfColumns@{ub} (offset 26)
   This  word  (2  bytes)  contains the number of columns every record has.
   There is no direct upper limit for this value, except that a record must
   not  exceed  32764  bytes  in  length and only the first 255 columns are
   indexable.

@{b}Columns@{ub} (offset 28)
   This variable length array has @{b}@{i}NumberOfColumns @{ui}@{ub}40 bytes large structures
   as  entries describing the structure of the records stored in this file,
   i.e.  the  structure of the DataColumns is described with every entry in
   this array.
   A single entry in this array can be described by the following structure.

struct DBFColumn    /*  size 40 bytes */
{
   UBYTE Name[32];  /* name of the column, only NUL-terminated if less
                     * than 32 characters */
   UWORD Type;      /* Type-identifier */
   UWORD Flags;     /* column-flags (see <joinOS/database/DataServer.h>) */
   UWORD Length;    /* length of the data (may depend on type) */
   UWORD Decimals;  /* only used with numeric values */
};

This structure contains the fields:

@{b}Name@{ub}
   A  32 byte large buffer for the name of the column.  This is the name of
   the  according DataColumn in the DataTable.  If the name is shorter than
   32  bytes,  it  is  stored  followed  by  a terminating NUL-byte in this
   buffer.  If  the  name is exact 32 bytes large, it is not NUL-terminated
   (longer  names  are  not allowed and would be truncated by the DataTable
   class during creation of the file).

@{b}Type@{ub}
   The type of the column using the type-identifiers mentioned in chapter 4
   @{"DataColumn" link DataColumn}.

@{b}Flags@{ub}
   This 2 byte word contains a subset of the flags defined for DataColumns.
   The following flags are currently stored here (if they are set):

   @{b}DCF_AUTOVALUE@{ub}, @{b}DCF_READONLY@{ub}, @{b}DCF_HIDDEN@{ub}, and @{b}DCF_NOT_EMPTY@{ub}

   See  chapter 4, section  @{"The DataColumn structure" link The_DataColumn_structure}  for  a description of
   these flags.

@{b}Length@{ub}
   This  2  byte  word contains the length of the column (without pad-bytes
   that may follow the column). Most columns have a fixed length, depending
   on  their  type  of  data.   For  those columns the value stored here is
   ignored,  so  only the types @{b}DC_CHAR@{ub}, @{b}DC_VARCHAR@{ub}, and @{b}DC_NUMERIC@{ub} respect
   this value.

@{b}Decimals@{ub}
   This  2 byte word  is only used by the columns of the type @{b}DC_NUMERIC@{ub} to
   specify  the number of digits of the fractional part of the number.  All
   other column types ignore this value.

The  first  DBFColumn  structure stored in a DataTable file contains always
the  name  "STATE",  is  of the type @{b}DC_LONG@{ub} and therfore has a length of 4
bytes   and   0  decimals.   The  flags  @{b}DCF_AUTOVALUE@{ub},  @{b}DCF_READONLY@{ub},  and
@{b}DCF_HIDDEN@{ub}  are set.  This column hides the first longword of every record,
used to link the deleted records in the list of empty records.
You  should  never  access  this  column  from  any user-application, it is
@{b}PRIVATE@{ub}.

If the header inclusive the variable length array of column descriptions is
less than 1024 characters in length, the contents of the remaining space is
undefined  (FastFileSystem  and Ram-Handler of the AmigaOS sets these bytes
to zero, but other filesystems may not clear this area).
@endnode

@node The_file_structure_of_a_memo_file "DataBase.library - Appendix A, Implementation details"
@toc Implementation details

@{b}@{fg shine}Section A.2, The file structure of a memo file@{fg text}@{ub}

The  @{"memo files" link Memo_files} are very simple build, but it's somehow tricky to add and
remove  entries  from  these files, so you should better use the @{"functions" link Functions_for_accessing_MemoFiles}
provided by the database.library where ever possible.

The  memo  files  just  have  a minimal header, followed by the data of the
entries stored in the file. A memo file is structured in @{i}pages @{ui}, where each
page  has  currently  a  size of 1024 bytes.  These pages are just used for
easier  accesses  to  the  memo  files  (every  read  from  the  underlying
filesystem  will  at  least transfer a whole page, so the number of I/Os is
reduced)  and  to  allow memo files containing more than 4 GB of data on 32
bit computer systems as the Amiga is.

A  single  entry is not limited to a single page, it could be larger than a
single  page, respectively be placed so it starts at one page and laps into
the  next  page.  The maximum size of a single entry is theoretically 2 GB,
but  in  the  current implementation it has to fit completely into the main
memory  of the computer so it should be much smaller, depending on the free
continous physical ram available at the destination system.

The  header  of  a  memo file could be described by the following structure
(Note:   The  structure in this form isn't defined anywhere, it's just used
here for simplicity.):

struct MemoFileHeader      /* size 16 bytes */
{
   ULONG FileID;           /* 'DBM ' */
   ULONG VersionID;        /* 1L */
   ULONG FirstEmptyPage;   /* page-no. of first page with an empty space */
   ULONG EmptyPageOffset;  /* offset into page to the empty space */
};

The fields have the following purpose/contents:

@{b}FileID@{ub} (offset 0)
   The  first  four  bytes of a memo file contain the ASCII-characters 'D',
   'B',  'M', and '  ' (a space,  ASCII 32).  You should  read  these bytes
   everytime  a  memo  file  is  opened  to take care that it is a memo and
   nothing else.

@{b}VersionID@{ub} (offset 4)
   The  second  longword  of a memo file contains the version number of the
   memo  file.   The current implementation of the database.library creates
   and  handles memo files with an Id of 1 (written in big endian format as
   any contents of any file handled by the database.library).

   Memo files of the version 1 have a page-size of 1024 bytes and do handle
   the  list of unused space as mentioned later.  Future versions may write
   the entries using another method or using other page-sizes.

@{b}FirstEmptyPage@{ub} (offset 8)
   This  longword  contains  the page-number of the first page in the file,
   that  contains  an  empty  space,  that may be used to store a new entry
   there.  All empty spaces in the memo file are linked in an ordered list,
   ordered from the begin to the end of the file.
   If  all  bits are set in this longword (-1) and also all bits are set in
   the  following longword @{b}@{i}EmptyPageOffset @{ui}@{ub} this indicates that there is no
   empty  space in the memo file.  In this case new entries are appended to
   the end of the file.

@{b}EmptyPageOffset@{ub} (offset 12)
   This  longword  contains the offset from the begin of the page specified
   by @{b}@{i}FirstEmptyPage @{ui}@{ub}to the begin of the empty space.


The header of the memo file is followed by the entries, where each entry is
structured  as  follows  (Note:   The  structure in this form isn't defined
anywhere, it's just used here for simplicity.):

struct MemoEntry
{
   ULONG NextPage;   /* page-no. of the next page with an empty space */
   ULONG NextOffset; /* offset into page to the empty space */
   ULONG Size;       /* size of the following data of this entry */
   UBYTE Data[0];    /* 'size' bytes of data (may be paded) */
};

The fields of this @{i}structure @{ui}have the following purpose/contents:

@{b}NextPage@{ub}
   If  the  entry  is  one of the entries in the list of empty space of the
   memo  file,  this  longword  contains the page number of the empty space
   that follows this one in that list.
   If every bit of this value and the following longword @{b}@{i}NextOffset @{ui}@{ub}are set
   (-1),  this  indicates  that  this  entry is the last one in the list of
   empty space and there is no following one.
   If  this  entry is not placed in the list of empty space, this field has
   to contain zero.

@{b}NextOffset@{ub}
   If  the  entry  is  one of the entries in the list of empty space of the
   memo  file, this longword contains the offset into the page -- specified
   by @{b}@{i}NextPage @{ui}@{ub}-- to the empty space that follows this one in that list.
   If  every  bit of this value and the preceding longword @{b}@{i}NextPage @{ui}@{ub}are set
   (-1),  this  indicates  that  this  entry is the last one in the list of
   empty space and there is no following one.
   If  this  entry is not placed in the list of empty space, this field has
   to contain zero.

@{b}Size@{ub}
   This  longword  contains either the bytesize of the data this entry con-
   tains  or  the  bytesize  of  the  empty space of this entry -- if it is
   located in the list of empty space.
   The  difference  is that the data stored here may be of any size (odd or
   even), whilst the size of the empty space is inclusive the pad-bytes not
   specified  by  the  data's  size.   The following data-block is always a
   multiple of 4 bytes large.

@{b}Data@{ub}
   This  block  contains the entries data.  It may be followed by pad-bytes
   to pad this block to a multiple of 4 bytes in size.

The  entries  are  referenced by the @{"DataTable" link DataTable} by their page-number and the
offset  into  the page.  Since the contents of an entry into a memo file is
only  read,  if it is explicit accessed, which might be much later than the
time  the  referencing  record was read from the DataTable, and there is no
mechanism  in determining if the contents has been changed in the meantime,
you  should be prepared to read garbish from the memo file (or the read may
fail  completely  because  of not enough free memory, if the area where the
entry  should  be  located has been reused already and therefore you try to
read  from  the  middle  of  an  entry  and so the 'Size' might contain any
value).
Write  accesses  are  protected  by  the  referencing record, the DataTable
performs  a test, if the record has been changed in the meantime, before it
writes  a  record  and  the  change of the memo-file would be mirrowed by a
changed  record  (the  referencing  page-number  or offset in the record is
changed).
If  a new entry is added to a memo file, the list of empty spaces is parsed
to  locate an empty entry that is either as large as the entry to be added,
or  at  least  16  bytes  larger.   If  such an empty space is found, it is
removed from the list of empty space, and the remaining empty space of that
block -- if there is any -- is inserted into the list.
If  no matching entry is found, the new entry is appended to the end of the
memo file.

If  an  entry is removed from the memo file, its space is inserted into the
list  of  empty  spaces  of  the  memo  file.  If the new space is directly
followed by another empty space, both blocks are added to a single one.  If
the  entry  is  preceded  by another empty space, these are also added to a
single  entry.   This  preserves the memo file from becoming too fragmented
and wasting space.

Nevertheless  there  may  be  a worst-case scenario, where the empty spaces
could  not be reused and the memo file grows in size and accesses are slown
down  by  a  growing  and  growing  empty  space  list.  If you implement a
database,  where  this  could be the case you should make a kind of garbage
collection from time to time:
   - Create an empty clone of the DataTable inclusive all @{"indexes" link Indexes}.
   - Copy  the  whole  contents  of the old DataTable to the new one, there
     will  not  be any empty space in the memo file respectively no deleted
     record in the new DataTable.
   - Delete  the old DataTable,  its memo file and indexes and replace them
     by the new copy.
@endnode

@node The_file_structure_of_an_index_file "DataBase.library - Appendix A, Implementation details"
@toc Implementation details

@{b}@{fg shine}Section A.3, The file structure of an index file@{fg text}@{ub}

As   DataTable   files  and  memo  files,  the  index  files  used  by  the
database.library  can  be  divided into two parts, a header and the indexes
data.  @{"Indexes" link Indexes} are also written in big endian format.
The  format  of the header is described by the following structure (defined
in  <joinOS/database/Index.h>),  an  index file header is always 1024 bytes
large.

struct IDXFileHeader
{
   ULONG FileID;                 /* 'IDX ' */
   ULONG VersionID;              /* 1L */
   ULONG FirstPage;              /* offset to root node of the tree */
   ULONG FirstEmptyPage;         /* offset to first unused page */
   struct DateStamp LastChanged; /* last time the file has been changed,
                                  * this might be an illegal date ! */
   UBYTE Reserved[4];            /* reserved for future use, set to 0 */
   ULONG NumKeys;                /* number of keys stored in the index */
   UWORD KeyLen;                 /* length of a key-value */
   UWORD Decimals;               /* currently not used */
   UWORD PageSize;               /* size of a single page (2^n >= 1024) */
   UWORD KeysPerPage;            /* maximum no. of keys per page */
   UBYTE Flags;                  /* flags specifying the index */
   UBYTE Name[32];               /* name of the index */
   UBYTE Expression[256];        /* the key-expr. in human readable form */
   UBYTE PreParsedExpr[256];     /* the prepcompiled key-expression */
   UBYTE Unused[435];            /* the rest of 1024 bytes are unused */
};

The fields of this structure have the following purpose/contents:

@{b}FileID@{ub} (offset 0)
   The  first  4  bytes of an index file contains the ASCII-characters 'I',
   'D',  'X',  and  '  '  (space,  ASCII 32).  These characters are used to
   identify  the  file  as  index  file,  if  you  access  an index file by
   bypassing the database.library's functions, you should always test these
   bytes to be shure that the accessed file is an index file.

@{b}VersionID@{ub} (offset 4)
   This  longword  specifies  the  version  of the index file.  The current
   implementation  of  the database.library supports the index files with a
   VersionID of 1. Future improvements to the database.library that results
   in changes to the file structure that are not backwards compatible would
   lead to higher version IDs.

@{b}FirstPage@{ub} (offset 8)
   The  data  of an index is stored in @{i}pages @{ui}. Every @{i}page @{ui}contains a single
   node of the search-tree of the index.  This longword contains the number
   of the @{i}page @{ui}that contains the root-node of the tree.

@{b}FirstEmptyPage@{ub} (offset 12)
   If key-entries are removed from the index, nodes of the indexes tree may
   become  empty.  The  resulting  empty @{i}pages @{ui}in the index file are linked
   into  a list.  This longword contains the number of the first empty @{i}page @{ui}
   in the file.
   The  @{i}pages @{ui} in the list of empty @{i}pages @{ui}are ordered by the time they went
   empty,  the  newest  empty @{i}page @{ui}-- i.e.  the @{i}page @{ui}that has gone empty at
   last -- is the first in the list,  the oldest empty @{i}page @{ui}is the last one
   in the list.

@{b}LastChanged@{ub} (offset 16)
   This  DataStamp  structure contains the date and time of the last change
   made  to  the  index  file.   If  the  index  file  is  changed  via the
   database.library's functions, it is guaranteed, that every change gets a
   unique, newer DateStamp.  As a result of this, the DateStamp may contain
   an illegal value in the @{b}@{i}ds_Tick @{ui}@{ub}field (i.e.  a value greater than 2999),
   so  you  shouldn't  pass  a  pointer  to  this structure to any AmigaDOS
   function (e.g.  @{b}@{i}DateToStr() @{ui}@{ub}) without any further check.

@{b}Reserved@{ub} (offset 28)
   These  four  bytes are reserved for future use and should always contain
   zero.

@{b}NumKeys@{ub} (offset 32)
   This  long  value contains the number of keys stored in the index and is
   updated  everytime a new key-entry is added to or a key-entry is removed
   from the index.

@{b}KeyLen@{ub} (offset 36)
   A 2 byte word value containing the byte-size of a single key-value.
   The  length  of a key could not exceed 256 bytes (in this version of the
   database.library).

@{b}Decimals@{ub} (offset 38)
   This 2 byte word is currently unused.  It may be used by future versions
   of the database.library and should always contain zero for future compa-
   tibility.

@{b}PageSize@{ub} (offset 40)
   The  byte-size  of  a  single @{i}page @{ui}in the index-file is stored in this 2
   byte  word.  A  @{i}page @{ui} has  to be 1024, 2048, 4096, 8192, 16384, or 32768
   bytes large.
   The  size  of the @{i}page @{ui}depends on the size of a single key-value and the
   number of keys that are stored in a single @{i}page @{ui}.

@{b}KeysPerPage@{ub} (offset 42)
   A  2  byte  word  containing  the number of keys that can be stored in a
   single @{i}page @{ui}.

@{b}Flags@{ub} (offset 44)
   This  single  byte contains a subset of the flags that are also found in
   the @{b}@{i}Flags @{ui}@{ub}field of the @{"IDXHeader structure" link The_IDXHeader_structure} of an index:

   @{b}IDX_UNIQUE@{ub}
      If  this flag is set, the @{"key-values" link Key-expressions_and_key-values} stored in this index are unique.
      If  you  try  to  add a new entry into this kind of index, that has a
      key-value  that  is  already  found in the index, this insertion will
      fail.

   @{b}IDX_DESCEND@{ub}
      This flag is stored in the index files header,  but is ignored by the
      database.library.   The  equal  named  flag in the @{b}@{i}Flags @{ui}@{ub}field of the
      IDXHeader  structure is set by either the Tag @{"IDX_Descend" link Creating_an_index} during ini-
      tialization,  by  the  DataTable the index is attached to, or must be
      set/cleared by direct access.

   @{b}IDX_CUSTOM@{ub}
      Usually the indexes attached to a @{"DataTable" link DataTable} are changed, whenever the
      contents  of  a  record  is  changed, so the indexes always match the
      contents of the DataTable.
      If  this flag is set, it indicates that this index, is not managed by
      the DataTable,  its key-entries have to be added/removed by the user-
      application.

@{b}Name@{ub} (offset 45)
   These 32 bytes contain the name of the index (inclusive terminating NUL-
   byte).  This  name  is copied to the @{b}@{i}Link.ln_Name @{ui}@{ub}field of the IDXHeader
   structure  of  an index if the index file is @{"opened" link Creating_an_index} via the functions of
   the database.library.
   This must always be a valid, not empty NUL-terminated C-string.

@{b}Expression@{ub} (offset 77)
   These  256  bytes  contain the @{"key-expression" link Key-expressions_and_key-values} in @{i}human readable @{ui}form (as
   NUL-terminated  C-string).   The  contents of the remaining unused bytes
   behind the terminating NUL-byte is undefined.

@{b}PreParsedExpr@{ub} (offset 333)
   This area of 256 bytes in width contains the prepcompiled key-expression
   (as produced by the function @{"IDX_PreCompileExpression()" link Functions_for_parsing_key-expressions}).
   The  contents  of  the  remaining  unused  bytes  behind the terminating
   byte  of  this  expression  is  undefined.   See  the  following section
   @{"Format of precompiled key-expressions" link Format_of_precompiled_key-expressions} for a description of the format of
   such an expression.

@{b}Unused@{ub} (offset 589)
   The  contents  of the remaining 435 bytes of the header of an index file
   is  undefined.   Future  extensions  to  the index file format may store
   further information here.

The  index  itself  is organized as B-tree.  If you don't know B-trees, you
should  inform  you by another source, this documentation presumes that you
are  familiar with this data structure and the algorithm used to find, add,
and  remove  entries  into  this kind of tree.  B-trees are well known data
structures  and  described  in every good book (or handout for the students
under the readers) about data structures.

A page  in the index file represents a node in the tree and has the follow-
ing (difficult to describe/not easy to understand) format:

It generaly consist of two main parts. The first is a table of offsets into
the second part.  The second part is the list of the key-entries, generally
ordered by the time of their insertion.
The  order  of the key-entries in the second part is never changed, removed
entries are overwritten, when new entries are added.  The order of the key-
entries  in the node of the tree is given via the offset-array in the first
part  of  the  page.   If  a new key-entry is inserted into the node, it is
stored  in  the  first empty @{i}slot @{ui}in the second part and the offset to this
@{i}slot @{ui} is  inserted into the offset-array, by moving the offsets to the key-
entries ordered behind the inserted one.
This  way  only  the  contents  of  the short offset-array must be moved to
insert  an entry and not the entire key-entry list, which is much larger as
you will see.

Each  offset  in  the offset-array is a 16 bit wide value.  There is stored
one  more  offset  in  this  array  than  key-entries  could be stored in a
node/page.  The purpose for this extra offset is to reference the rightmost
pointer  to  the  subnodes  of  the  tree,  because  every node in a B-tree
contains upto @{i}n @{ui}key-values and @{i}n @{ui}+ 1 subnode pointers.

The  first  16  bit  word (named @{b}@{i}keysUsed @{ui}@{ub}) in a @{i}page @{ui}is the counter of the
number  of  key-entries  stored  in the according node of the tree.  So the
first @{b}@{i}keysUsed @{ui}@{ub}entries in the offset-array reference the key-entries in the
second part,  the  (@{b}@{i}keysUsed @{ui}@{ub}+ 1)'th offset references the righmost pointer
to  the subnodes of this node (i.e.  the pointer to the node containing the
key-entries  with the key-values that are greater than any key-value of the
entries in this node).  This @{i}pointer @{ui}is always stored in the first longword
following  the  offset array  (this longword is always stored at an address
divideable by 4),  of cause no pointer is stored in the index file, instead
the number of the @{i}page @{ui}containing the subnode is stored here.

All  unused  offsets in the offset array -- following the {@{b}@{i}keysUsed @{ui}@{ub}+ 1}'th
offset -- reference the unused key-entries in the second part of the @{i}page @{ui}.

The  key-entries  in  the  second part of the page -- that is stored direct
behind the pointer to the rightmost subnode -- are of the following format:

struct KeyEntry
{
   ULONG LeftPage;   /* 'left' subtree */
   ULONG RecNo;      /* record number in the according Database */
   UBYTE KeyValue[]; /* bytes for the key-value */
}

Where the field have the following purpose:

@{b}LeftPage@{ub}
   This  longword  contains  the number of the page that contains the left-
   handed  subnode  of  this  entry, i.e.  the key-entries with a key-value
   between the key-value of this entry and the preceding entry in this node.

@{b}RecNo@{ub}
   This  longword contains the number of the row of the indexed DataServer,
   that is matched by this key-entry.

@{b}KeyValue@{ub}
   This area of @{b}@{i}keyLen @{ui}@{ub}bytes contains the key-value of this key-entry.

Every key-entry is paded to a size divideable by 4.


@{b}Summary:@{ub}

   A @{i}page @{ui}with space for @{b}@{i}keysPP @{ui}@{ub}key-entries is structured as follows:

   UWORD keysUsed               /* number of entries stored in page */
   UWORD offsets [KeysPP + 1]   /* offset array */
   {UWORD pad}                  /* pad-word, inserted if 'KeysPP' is odd */
   ULONG rightPage              /* "page" number of "rightmost" subpage */
   struct KeyEntry[KeysPP]      /* the key-entries */

As  you  can  imagine,  the  space  required for a key-entry depends on the
length  of  a  key-value.  If using fixed-size @{i}pages @{ui}(e.g.  1024 bytes) for
any  kind  of index, this will result in several bytes per @{i}page @{ui}that aren't
usable  (e.g.   if  a  key-value  is 68 bytes in length, you could place 14
key-entries in a @{i}page @{ui}of 1024 bytes and 36 bytes will remain unused).

If  a  new  index  is  created, and the page-size is not specified explicit
(using  the  Tag  @{b}IDX_PageSize@{ub}),  the  database.library will try to chose a
page-size, that minimizes the waste of unused space.  In the example above,
it will use a page size of 2048; with this page size, 29 key-entries with a
key-value length of 68 bytes could be stored in a @{i}page@{ui}, while only 10 bytes
are unused.
@endnode

@node Format_of_precompiled_key-expressions "DataBase.library - Appendix A, Implementation details"
@toc Implementation details

@{b}@{fg shine}Section A.4, Format of precompiled key-expressions@{fg text}@{ub}

If  a  @{"key-expression" link Key-expressions_and_key-values}  in @{i}human readable @{ui}form is precompiled, the tokens of
the @{"functions and operations" link Converting_functions_and_operators_of_key-expressions} found in the expression string are replaced by
single  byte tokens.  The functions @{b}@{i}Str() @{ui}@{ub}and @{b}@{i}StrZero() @{ui}@{ub}are replaced by the
token  according to the function and a second byte containing the resulting
length of the string to be created.
The  column-names  are  replaced  by a token describing the datatype of the
column  and  a  second  byte with its position in the record (therefore the
order  of the @{"DataColumns" link DataColumn} of a @{"DataTable" link DataTable} are not allowed to be changed and
only  the first 255 columns may be indexed) and the resulting expression is
transformed into @{i}Reverse-Polish-Notation @{ui}.

The tokens of the available functions and operations are (defined in
<joinOS/database/Parse.h>):

token-name | value | datatype/operation/function
-----------+-------+-------------------------------------------------------
K_PLUS     |  '+'  | concatenating two expressions '+'
K_STRING   | 0x80  | a string (DC_CHAR)
K_INTEGER  | 0x81  | DC_BYTE, DC_WORD, DC_LONG, DC_LONGLONG, or DC_NUMERIC
K_LOGIC    | 0x82  | a boolean (DC_LOGIC)
K_DATE     | 0x83  | a date (DC_DATE)
K_TIME     | 0x84  | a time (DC_TIME)
K_FLOAT    | 0x85  | a floating point value (DC_FLOAT or DC_DOUBLE)
K_RESERVED | 0x86  | Reserved for future datatypes
K_STOP     | 0x87  | end of expression
K_VAL      | 0x88  | VAR() - convert K_STRING into K_INTEGER
K_STR      | 0x89  | STR() - convert K_INTEGER or K_TIME to K_STRING
K_UPPER    | 0x8A  | UPPER() - all chars to uppercase
K_LOWER    | 0x8B  | LOWER() - all chars to lowercase
K_STRZERO  | 0x8C  | STRZERO() - STR() fill up using '0'
K_LTOC     | 0x8D  | LTOC() - convert K_LOGIC to K_STRING
K_DTOS     | 0x8E  | DTOS() - convert K_DATE to K_STRING
K_TTOS     | 0x8F  | TTOS() - convert K_TIME to K_STRING

The  precompiled  key-expressions  are always terminated by a @{b}K_STOP@{ub} token.
For  some  examples  take  a hex-editor/viewer and have a look at the index
files  created  by the examples provided in the "example" directory shipped
with the database.library.
@endnode

@node Creating_own_DataServer_subclasses "DataBase.library - Appendix B, Creating own DataServer subclasses"

@{b}@{fg shine}Appendix B, Creating own DataServer subclasses@{fg text}@{ub}

It's quite simple to create a new @{"DataServer" link DataServer} subclass (i.e.  it's simple to
subclass  the  DataServer, it might be quite hard to create an own database
engine).
If  you want to subclass a DataServer you just have to design the structure
required  to hold the private data of your objects (i.e.  something simular
to  the  @{"DataTable structure" link The_DataTable_structure}).  This  structure must embed the DataServer
@{"structure" link The_DataServer_structure} as first structure element.

Example:

   struct FooServer
   {
      struct DataServer DS;   /* embedded DataServer structure */
      ULONG fooBar;           /* additional data used by FooServer */
   };

If  you have defined this structure you have to write your own initializing
function,  usual  a function expecting it's initialization data in the form
of a TagItem list.
This  function  has to initialize your subclasses data-structure and should
do anything required, so the returned pointer to your data-structure can be
savely passed to the dispatcher function @{"DS_DoUpdate()" link Request_performing_of_operations_to_a_DataServer}.
For this purpose your init-function should first allocate and preinitialize
its data-structure by invoking the function @{"DS_InitA()" link Creation_of_DataServers}, passing the desired
size  of  the  structure  to  be  allocated  via  a  TagItem  with  the Tag
DS_StructSize.
You  should  also  pass  an  array  of @{"DataColumn structures" link The_DataColumn_structure} that should be
copied  for the @{"DataColumns" link DataColumn} attached to the DataServer using a TagItem with
the  Tag  DS_Columns  to  that  function.   The DataTable does the same, by
converting the  @{"DBStruct structure" link The_DBStruct_structure} -- passed to the DataTables @{"DBF_InitA()" link Creation_of_DataTables}
function  via the Tag DBF_Struct or read from the @{"DataTables file" link The_file_structure_of_a_DataTable_file} -- into a
DataColumn  array  and passing a pointer to this to the superior DataServer
classes @{b}@{i}DS_InitA() @{ui}@{ub}function.
If  you  doesn't pass such an structure array, the DataColumns may be added
later to the DataServer, e.g.  by using the @{"operation DS_ADDCOLUMN" link Adding_DataColumns_to_a_DataServer}.

Example:

   struct TagItem dsTags[] =
   {
      {DS_StructSize, sizeof (struct FooServer)},
      {TAG_DONE,      0}
   };


After  the DS_InitA() function has successfully returned (i.e.  it returned
a   pointer  to  the  new  allocated  and  preinitialized  structure)  your
initialization  function  should  finish  initialization  and  storing  the
required information in the new fields of the enhanced DataServer structure
(e.g.   initialize  the  field  @{b}@{i}fooBar @{ui}@{ub} of  the FooServer structure of this
example).   Every  field  in  the  structure that is not initialized by the
DataServer's  @{b}@{i}DS_InitA() @{ui}@{ub} function  contains  zero  after that function has
returned.
The fields @{b}@{i}Device, Rows, @{ui}@{ub}and @{b}@{i}Order @{ui}@{ub}of the DataServer structure are not used
by  the  DataServer class, they are reserved for the use by the subclasses,
e.g.  for use by @{i}FooServer @{ui}.

At  least  you  have  to  write  a  function  that  performs the operations
requested  from  the  DataServer,  i.e.   a  replacement  for  the standard
@{b}@{i}DS_Update() @{ui}@{ub} function.  This function has to handle every operation that is
not  processed by the default @{b}@{i}DS_Update() @{ui}@{ub}function respectively that should
do  something else not done by the default operation-handling.  Have a look
to  chapter  3,  section @{"Operations every DataServer should support" link Operations_every_DataServer_should_support} for a
description of the operations your DataServer subclass should support.  The
following section describes some additional notes to some operations.

For  every  operation your DataServer subclass doesn't support, you have to
call  the  @{b}@{i}DS_Update() @{ui}@{ub} function  of the underlying DataServer class or you
have to set the errorcode @{b}DS_ERR_OP_NOT_KNOWN @{ub}to the @{b}@{i}LastError @{ui}@{ub}field of the
embedded DataServer structure and return @{b}FALSE@{ub}.

A  pointer  to  this  new function has to be stored in the @{b}@{i}Update @{ui}@{ub}function-
pointer  of  the  DataServer  structure,  overwriting  the  pointer  to the
@{b}@{i}DS_Update() @{ui}@{ub} function  currently  stored there.  The function referenced by
this  pointer  is  called  whenever  a DataServer structure (or an enhanced
structure) is passed to the global dispatcher @{b}@{i}DS_DoUpdate( @{ui}@{ub}).

Thats  all  you  must  do.   You  may add additional functions, if your new
DataServer  needs  to  perform an action, no according operation is defined
for   (so   as  the  @{"functions" link Other_functions_for_accessing_DataTables}  available  for  the  DataTable  class  like
@{"DBF_SetRelation()" link Relations_between_DataTables}).


Sections:
   @{" Notes for operations supported by DataServers " link Notes_for_operations_supported_by_DataServers}
   @{" Subclasses of DataTables                      " link Subclasses_of_DataTables}
@endnode

@node Notes_for_operations_supported_by_DataServers "DataBase.library - Appendix B, Creating own DataServer subclasses"
@toc Creating_own_DataServer_subclasses

@{b}@{fg shine}Section B.1, Notes for operations supported by DataServers@{fg text}@{ub}

Here  are  some  implementation notes for @{"DataServer" link DataServer} subclasses; things you
should look at if you write your own @{"operation processing" link Operations_every_DataServer_should_support} functions.

@{b}DS_DISPOSE@{ub}
   If a subclass allocates any resource dynamically or needs to terminate a
   connection  to a @{i}device @{ui}, it has to implement this operation and perform
   it, before it calls @{b}@{i}DS_Update() @{ui}@{ub}to do the default clean-up.

@{b}DS_ADDCOLUMN@{ub}, @{b}DS_REMOVECOLUMN@{ub}, and @{b}DS_MOVECOLUMN@{ub}
   If  you  wish  to  use the @{"indexes" link Indexes} as supported by the database.library,
   your  subclass  should  not  allow  to  rearrange the order of the Data-
   Columns, nor should it allow to add or remove @{"DataColumns" link DataColumn} (except to the
   end  of  the  list  of DataColumns).  The indexes access the DataColumns
   they  are  ordering  by  their  position.  If  you  really want to allow
   the  rearranging  of  the  DataColumns,  you  have  to  @{"precompile" link Functions_for_parsing_key-expressions}  the
   @{"key-expression" link Key-expressions_and_key-values}  of  every index of the DataServer after every change to
   the DataColumns order  (take care that the new key-expression is written
   to the fileheader of the @{"index file" link The_file_structure_of_an_index_file}).

@endnode

@node Subclasses_of_DataTables "DataBase.library - Appendix B, Creating own DataServer subclasses"
@toc Creating_own_DataServer_subclasses

@{b}@{fg shine}Section B.2, Subclasses of DataTables@{fg text}@{ub}

You  may  wish  to  enhance  the  @{"DataTable" link DataTable}  class (e.g. for supporting new
@{"DataColumn" link DataColumn}  types).   This  is  possible,  you  may  enhance  the DataTable
structure  the same way as the @{"DataServer structure" link The_DataServer_structure}.  In opposide to direct
subclasses of the DataServer class, you have to call @{"DBF_InitA()" link Creation_of_DataTables} instead of
@{"DS_InitA()" link Creation_of_DataServers} from your initialization code of cause.  You shouldn't touch any
field  of  the  embedded @{"DataTable structure" link The_DataTable_structure} except the @{b}@{i}Update @{ui}@{ub}field of the
DataServer structure.

If  you need to write a new operation processing function, this has to call
@{b}@{i}DBF_Update() @{ui}@{ub}for the default operations (instead of @{b}@{i}DS_Update() @{ui}@{ub}).

For  every  DataColumn of a new type, not supported by the DataTable class,
you  have  to write your own convertion functions and store the pointers to
these  functions  in  the  @{b}@{i}Convert @{ui}@{ub} and  @{b}@{i}Revert @{ui}@{ub} fields  of  the  according
@{"DataColumn structures" link The_DataColumn_structure}.

The  @{b}@{i}Buffer @{ui}@{ub} of these DataColumns has to be handled by your subclass of the
DataTable class,  it will be initially set to @{b}NULL@{ub} for DataColumn types not
known  by  the  DataTable class (remember this buffer needs to be allocated
using  the  function  AllocVector() @{ui}@{ub} of the joinOS.library).  If the buffer
should  be  freed  on disposage of the underlying DataTable (i.e.  when the
@{"operation" link Notes_for_operations_supported_by_DataServers} @{b}DS_DISPOSE@{ub}  is  passed to @{b}@{i}DBF_Update() @{ui}@{ub}) you should set the flag
@{b}DCF_OWNBUFFER@{ub}  for  that  DataColumns, otherwise you have to take care that
this buffer is freed by your subclass itself.

The  identifier  of  your  added datatype should be @{b}DC_USER@{ub} or greater, see
<joinOS/database/DataServer.h>.
@endnode

@node Glossary "DataBase.library - Glossary"

@{b}@{fg shine} Glossary@{fg text}@{ub}

This glossary descibes the meaning of words found in this documentation.

@{b}browser@{ub} - a kind of listview, able to show several columns of any number of
        rows of a DataServer simultaneously.

@{b}client server@{ub} - a client server is a server  that is related to another --
        the superior server. The client is dependent on the superior server

@{b}column@{ub} - the  data of a DataServer is organized in rows and columns.  Every
        record is divide into a fixed number (table-specific) of columns.
        Each column can contain different data of a columnspecific type.

@{b}database@{ub} - a database is a complex structure of several related servers and
        all according orders.

@{b}DataColumn@{ub} - a  DataColumn  is  the  structure describing the contents of a
        column in a DataServer.

@{b}DataServer@{ub} - the  basic server class used by the database.library.  A Data-
        Server  is  a  virtual  class, i.e.  you can't create a stand-alone
        DataServer instead you have to use one of the subclasses. But every
        subclass  of the DataServer class inherits its attributes and basic
        functionality.   So  you could perform most operations on any Data-
        Server  subclass, no matter which subclass really is used.  This is
        required  for  example for an universal DataServer-browser, that is
        able to browse the contents of any DataServer.

@{b}datatable@{ub} - a  datatable  (written  in  lower case) is a single entity of a
        database.

@{b}DataTable@{ub} - a DataTable  (written in upper case) is a subclass of the Data-
        Server  able  to store over 2 billion records, each upto 32KB wide,
        on a filesystem.
        There are a few more classes related to the DataTable:
            the MemoFile and the Indexes.

@{b}DOUBLELONG@{ub} - a 64-bit signed integer,  implemented  as structure containing
        two 32-bit integers. The first 32-bit integer contains the upper 32
        bit  of  the  64-bit value,  the second 32-bit integer contains the
        lower  32  bits  of t he 64-bit  value.  The according structure is
        defined  in  <joinOS/exec/defines.h>.   Some  functions  for 64-bit
        algebra are supported by the joinOS.library.

@{b}entity-relationship-model@{ub} - The  entity-relationship  model  (or ER modell)
        is  a  way of graphically representing the logical relationships of
        entities  (or objects)  in order to create a database.  The ERM was
        was  1th proposed by Peter Pin-Shan Chen of Massachusetts Institute
        of Technology (MIT) in the 1970s. 

@{b}field@{ub} - a  field  is  a single data of a server, i.e. the field specifies a
        column of a single row.

@{b}index@{ub} - a file-based order used by the DataTables. These indexes are imple-
        mented  as  B-Trees  and are used for fast access to the records in
        the  specified sorting order.  They support seeking for a specified
        key-value to get direct access to any record of a DataTable.
        Indexes can work with scopes: By setting a top and a bottom @{i}border @{ui},
        you will only access the records within this scope.  This speeds up
        accessing  the  database  and  makes  it easy to filter the records
        shown to the user (in conjunction with a @{i}browser @{ui})

@{b}joinOS.library@{ub} - a shared runtime library shipped with the database.library.
        This  library  contains  several  functions  that  are  used by the
        database.library and may also be used by any user-application. This
        library  provides functions that aren't available for all operating-
        systems  and  other  usefull functions that aren't available at any
        operating-system.
        Using  this  libraries functions makes it easier to write code that
        can be compiled/run at different operating-system versions.
        There  is  an  @{b}AUTODOC@{ub}-file  that  describes  the  functions of the
        joinOS.library located in the "document" directory shipped with the
        database.library.

@{b}key@{ub} - a key is an object that addresses a single row of a DataServer

@{b}key-entry@{ub} - an  entry  into  an  index, containing the key to a row and the
        according key-value

@{b}key-value@{ub} - is the value that is used to find a key. A key-value is usually
        created  from  the  contents  of  one or more columns of a row of a
        DataServer

@{b}operation@{ub} - DataServers  are  forced  to process or serve their data by re-
        questing operations from them.  There are a few operations that are
        defined to be supported by every kind of DataServer.

@{b}order@{ub} - a  named  sorting order of the rows of data in a DataServer.  There
        might be several different orders available for every DataServer.

@{b}record@{ub} - a  record  is  a row of data in a DataTable with an unique record-
        number.

@{b}recordnumber@{ub} - usually the records in a DataTable are numbered in the order
        they  have  been  inserted  into  the  DataTable, starting with the
        number 1.

@{b}relation@{ub} - a  relation  between  servers  is a combination of that servers.
        There  has to be a superior server and a client server.  The client
        server  is positioned using the order specified during establishing
        the relation. The key-value used to search in this order is created
        from the contents of the current row of the superior server.  These
        two related servers act like a single one containing the columns of
        both servers.  Every row of the superior server should have none or
        a  single  matching  row in the client server, but every row of the
        client  server  could  be  matched  by several rows of the superior
        server.

@{b}row@{ub} - the  data  of  a  DataServer is organized in rows and columns.  Every
        DataServer  can contain a large number of rows, each of them having
        a fixed number of columns containing individual data.

@{b}seek@{ub} - Seeking  is  the search for a row that matches the key identified by
        the specified key-value. You could either seek for the first occur-
        rence of the key-value or for the next occurrence. You could search
        for  an  exact  match  or  the  first row with a key-value equal or
        greater than the specified one.

@{b}server@{ub} - a server is an object that serves data

@{b}skip@{ub} - Skipping is the sequentiell movement of the current row pointer of a
        DataServer.   You  could either skip single rows (i.e.  move to the
        next or previous row in the active order) or multiple rows at once.
        You  could  also  skip direct to the first and the last rows in the
        active order.

@{b}superior server@{ub} - a superior server is a server that has one or more depen-
        dend client servers.

@{b}table@{ub} - a table is a single table of a database. Every table has a variable
        number of records, each with the same defined number of DataColumns.

@{b}TagItem@{ub} - a  structure introduced to the AmigaOS in release 2.  This struc-
        ture  could  be used to add parameters to functions in a expandable
        way  so  new parameters could be passed to functions without inter-
        fering with the original parameters. They also make spoecific para-
        meter lists muchg clearer and easier.
        There are several functions in AmigaOS's utility.library and in the
        joinOS.library  (which  should be prefered for usage in conjunction
        with  the  database.library)  that support the handling of lists of
        TagItems.

@{b}transaction@{ub} - a transaction is an atomar operation performed on a database.
        A  transaction  cannot  be  interrupted, or if it is, the performed
        changes  are  undone,  so the database remains in the state it was,
        before the transaction has been started.

@{b}user@{ub} - There are different forms of users:
       1. The (usually) human-being sitting in front of the computer system
          and handling it (or trying to/thinking he does).
       2. The application designer that uses the database.library to create
          and  handle  a database for an application that should be used by
          users(1).

@{b}XBase@{ub} - Generic term for the dBASE family of database languages.  Coined in
        response  to  threatened  litigation  over  use  of the copyrighted
        trademark 'dBASE'.
@endnode

@node Index "DataBase.library - Index"

@{b}@{fg shine} Index@{fg text}@{ub}

   @{" +                         " link Converting_functions_and_operators_of_key-expressions}      @{" DS_SEEKNEXT               " link Operations_every_DataServer_should_support}
   @{" AmigaDOS                  " link Functions_for_changing_an_index}      @{" DS_SELECTROW              " link Operations_every_DataServer_should_support}
   @{" AtChr()                   " link String_manipulation_functions}      @{" DS_SETCOLUMNDATA          " link Operations_every_DataServer_should_support}
   @{" big endian                " link The_file_structure_of_a_DataTable_file}      @{" DS_SETORDER               " link Operations_the_DataTable_supports}
   @{" ChangeMode()              " link Functions_for_changing_an_index}      @{" DS_SETRAWDATA             " link Operations_every_DataServer_should_support}
   @{" CloseLibrary()            " link Open_the_database.library}      @{" DS_SKIPROWS               " link Operations_every_DataServer_should_support}
   @{" DatabaseBase              " link Open_the_database.library}      @{" DS_SoftSeek               " link Creation_of_DataServers}
   @{" DataColumn                " link DataColumn}      @{" DS_SOFTSEEK               " link Operations_every_DataServer_should_support}
   @{" DataServer                " link DataServer}      @{" DS_StructSize             " link Creation_of_DataServers}
   @{" DataTable                 " link DataTable}      @{" DS_Update()               " link Creating_own_DataServer_subclasses}
   @{" DataTableHeader           " link The_file_structure_of_a_DataTable_file}      @{" DS_UPDATE                 " link Operations_the_DataTable_supports}
   @{" DBF_AddAlias()            " link Functions_for_managing_indexes_attached_to_the_DataTables}      @{" DS_UPDATE_FCT             " link The_DataServer_structure}
   @{" DBF_AddOrder()            " link Functions_for_managing_indexes_attached_to_the_DataTables}      @{" DSF_DESCEND               " link The_DataServer_structure}
   @{" DBF_ClearRecord()         " link Private_functions_of_the_DataTable}      @{" DSF_DBTABLE               " link The_DataTable_structure}
   @{" DBF_ClearRelation()       " link Relations_between_DataTables}      @{" DSF_EXCLUSIVE             " link The_DataTable_structure}
   @{" DBF_ERR_DUPLICATE_NAME    " link The_DataTable_structure}      @{" DSF_FORCE_UNIQUE          " link The_DataTable_structure}
   @{" DBF_ERR_INDEX_LOCK        " link The_DataTable_structure}      @{" DSF_HASMEMO               " link The_DataTable_structure}
   @{" DBF_ERR_INDEX_TIMEOUT     " link The_DataTable_structure}      @{" DSF_LOCK_FULL             " link The_DataTable_structure}
   @{" DBF_ERR_LOCK_FAILURE      " link The_DataTable_structure}      @{" DSF_LOCK_NONE             " link The_DataTable_structure}
   @{" DBF_ERR_LOCK_TIMEOUT      " link The_DataTable_structure}      @{" DSF_LOCK_OPTIMISTIC       " link The_DataTable_structure}
   @{" DBF_ERR_NO_INDEX          " link The_DataTable_structure}      @{" DSF_NEWROW                " link The_DataServer_structure}
   @{" DBF_ERR_REC_CHANGED       " link The_DataTable_structure}      @{" DSF_MEMO_CHANGED          " link The_DataTable_structure}
   @{" DBF_ERR_REC_NOT_LOCKED    " link The_DataTable_structure}      @{" DSF_MEMO_READ             " link The_DataTable_structure}
   @{" DBF_ERR_REC_NOT_VALID     " link The_DataTable_structure}      @{" DSF_READONLY              " link The_DataServer_structure}
   @{" DBF_ERR_RELATED_SERVER    " link The_DataTable_structure}      @{" DSF_REC_CACHED            " link The_DataTable_structure}
   @{" DBF_ERR_RELATION_LOOP     " link The_DataTable_structure}      @{" DSF_REC_DELETED           " link The_DataTable_structure}
   @{" DBF_Exclusive             " link Creation_of_DataTables}      @{" DSF_ROWCHANGED            " link The_DataServer_structure}
   @{" DBF_FieldGet()            " link Functions_of_the_link_library Database.lib}      @{" DSF_SHOW_DELETED          " link The_DataTable_structure}
   @{" DBF_FieldGetRaw()         " link Functions_of_the_link_library Database.lib}      @{" DSF_SOFTSEEK              " link The_DataServer_structure}
   @{" DBF_FieldPut()            " link Functions_of_the_link_library Database.lib}      @{" DToS()                    " link Convertion_functions}
   @{" DBF_FieldPutRaw()         " link Functions_of_the_link_library Database.lib}      @{" entity-relationship-model " link How_to_create_Databases}
   @{" DBF_FileName              " link Creation_of_DataTables}      @{" error reports             " link Error_reports}
   @{" DBF_ForceUnique           " link Creation_of_DataTables}      @{" errorcode                 " link The_DataServer_structure}
   @{" DBF_GetOrder()            " link Functions_for_managing_indexes_attached_to_the_DataTables}      @{" exec                      " link Open_the_database.library}
   @{" DBF_InitA()               " link Creation_of_DataTables}      @{" exec List                 " link The_DataTable_structure}
   @{" DBF_LockMode              " link Creation_of_DataTables}      @{" exec Node                 " link The_IDXHeader_structure}
   @{" DBF_LockRecord()          " link Locking_of_records}      @{" FastFileSystem            " link Error_reports}
   @{" DBF_Name                  " link Creation_of_DataTables}      @{" filesystem                " link Functions_for_changing_an_index}
   @{" DBF_Pack()                " link Other_functions_for_accessing_DataTables}      @{" fixedPointNumeric         " link Functions_for_processing_fixed_point_numbers}
   @{" DBF_READ                  " link Locking_of_records}      @{" Float2Double()            " link Convertion_functions}
   @{" DBF_ReadMemo()            " link Private_functions_of_the_DataTable}      @{" IDX_ALIAS                 " link The_IDXHeader_structure}
   @{" DBF_ReadOnly              " link Creation_of_DataTables}      @{" IDX_ClearIndex()          " link Functions_for_changing_an_index}
   @{" DBF_ReIndex()             " link Other_functions_for_accessing_DataTables}      @{" IDX_CountFields()         " link Functions_of_the_link_library Database.lib}
   @{" DBF_RemoveAlias()         " link Functions_for_managing_indexes_attached_to_the_DataTables}      @{" IDX_Custom                " link Creating_an_index}
   @{" DBF_RemoveOrder()         " link Functions_for_managing_indexes_attached_to_the_DataTables}      @{" IDX_CUSTOM                " link The_IDXHeader_structure}
   @{" DBF_SetAccessMode()       " link Other_functions_for_accessing_DataTables}      @{" IDX_Descend               " link Creating_an_index}
   @{" DBF_SetLockMode()         " link Other_functions_for_accessing_DataTables}      @{" IDX_DESCEND               " link The_IDXHeader_structure}
   @{" DBF_SetRelation()         " link Relations_between_DataTables}      @{" IDX_Dispose()             " link Disposing_an_index}
   @{" DBF_ShowDeleted()         " link Other_functions_for_accessing_DataTables}      @{" IDX_EndTransaction()      " link Functions_for_accessing_an_index}
   @{" DBF_Struct                " link Creation_of_DataTables}      @{" IDX_ERR_BAD_EXPRESSION    " link Functions_for_parsing_key-expressions}
   @{" DBF_StructSize            " link Creation_of_DataTables}      @{" IDX_ERR_DUPLICATE_KEY     " link Functions_for_changing_an_index}
   @{" DBF_UnLockRecord()        " link Locking_of_records}      @{" IDX_ERR_NO_KEY            " link Operations_the_DataTable_supports}
   @{" DBF_Update()              " link Subclasses_of_DataTables}      @{" IDX_Exclusive             " link Creating_an_index}
   @{" DBF_Validate              " link Creation_of_DataTables}      @{" IDX_EXCLUSIVE             " link The_IDXHeader_structure}
   @{" DBF_WAIT_DEFAULT          " link Locking_of_records}      @{" IDX_Expression            " link Creating_an_index}
   @{" DBF_WAIT_FOREVER          " link Locking_of_records}      @{" IDX_EvalExpression()      " link Functions_of_the_link_library Database.lib}
   @{" DBF_WAIT_NONE             " link Locking_of_records}      @{" IDX_EvalExpressionA()     " link Functions_for_parsing_key-expressions}
   @{" DBF_WRITE                 " link Locking_of_records}      @{" IDX_EvalExpressionB()     " link Functions_for_parsing_key-expressions}
   @{" DBF_WriteMemo()           " link Private_functions_of_the_DataTable}      @{" IDX_FileName              " link Creating_an_index}
   @{" DBFColumn                 " link The_file_structure_of_a_DataTable_file}      @{" IDX_FindKey()             " link Navigating_through_an_index}
   @{" DBM_ClearMemo()           " link Functions_for_accessing_MemoFiles}      @{" IDX_GetKeyValue()         " link Functions_for_parsing_key-expressions}
   @{" DBM_CloseMemo()           " link Functions_for_accessing_MemoFiles}      @{" IDX_InitA()               " link Creating_an_index}
   @{" DBM_LockMemo()            " link Functions_for_accessing_MemoFiles}      @{" IDX_InsertKey()           " link Functions_for_changing_an_index}
   @{" DBM_OpenMemo()            " link Functions_for_accessing_MemoFiles}      @{" IDX_KeyCount()            " link Functions_for_accessing_an_index}
   @{" DBM_ReadMemo()            " link Functions_for_accessing_MemoFiles}      @{" IDX_KeyLength()           " link Functions_for_parsing_key-expressions}
   @{" DBM_UnLockMemo()          " link Functions_for_accessing_MemoFiles}      @{" IDX_LOCKED                " link The_IDXHeader_structure}
   @{" DBM_WriteMemo()           " link Functions_for_accessing_MemoFiles}      @{" IDX_Name                  " link Creating_an_index}
   @{" DBStruct                  " link The_DBStruct_structure}      @{" IDX_PageSize              " link Creating_an_index}
   @{" DC_BYTE                   " link The_DataColumn_structure}      @{" IDX_PreCompileExpression()" link Functions_for_parsing_key-expressions}
   @{" DC_CHAR                   " link The_DataColumn_structure}      @{" IDX_READ                  " link Functions_for_accessing_an_index}
   @{" DC_CONVERT                " link The_DataColumn_structure}      @{" IDX_ReIndex()             " link Functions_for_changing_an_index}
   @{" DC_DATE                   " link The_DataColumn_structure}      @{" IDX_RemoveKey()           " link Functions_for_changing_an_index}
   @{" DC_DOUBLE                 " link The_DataColumn_structure}      @{" IDX_RESERVED              " link The_IDXHeader_structure}
   @{" DC_DOUBLELONG             " link The_DataColumn_structure}      @{" IDX_Seek()                " link Navigating_through_an_index}
   @{" DC_FLOAT                  " link The_DataColumn_structure}      @{" IDX_SeekNext()            " link Navigating_through_an_index}
   @{" DC_ILBM                   " link Functions_for_accessing_MemoFiles}      @{" IDX_Server                " link Creating_an_index}
   @{" DC_LOGIC                  " link The_DataColumn_structure}      @{" IDX_SetScope()            " link Functions_for_accessing_an_index}
   @{" DC_LONG                   " link The_DataColumn_structure}      @{" IDX_SkipBottom()          " link Navigating_through_an_index}
   @{" DC_NUMERIC                " link The_DataColumn_structure}      @{" IDX_SkipNext()            " link Navigating_through_an_index}
   @{" DC_REVERT                 " link The_DataColumn_structure}      @{" IDX_SkipPrevious()        " link Navigating_through_an_index}
   @{" DC_SetCaption()           " link Other_functions_for_DataColumns}      @{" IDX_SkipTop()             " link Navigating_through_an_index}
   @{" DC_SetHelpText()          " link Other_functions_for_DataColumns}      @{" IDX_StartTransaction()    " link Functions_for_accessing_an_index}
   @{" DC_TEXT                   " link The_DataColumn_structure}      @{" IDX_Unique                " link Creating_an_index}
   @{" DC_TIME                   " link The_DataColumn_structure}      @{" IDX_UNIQUE                " link The_IDXHeader_structure}
   @{" DC_UNKNOWN                " link The_DataColumn_structure}      @{" IDX_ValidKey()            " link Functions_for_accessing_an_index}
   @{" DC_USER                   " link Subclasses_of_DataTables}      @{" IDX_WriteBehind           " link Creating_an_index}
   @{" DC_VARCHAR                " link The_DataColumn_structure}      @{" IDX_WRITE                 " link Functions_for_accessing_an_index}
   @{" DC_WORD                   " link The_DataColumn_structure}      @{" IDX_WRITEBEHIND           " link The_IDXHeader_structure}
   @{" DCF_AUTOVALUE             " link The_DataColumn_structure}      @{" IDXAlias                  " link The_IDXHeader_structure}
   @{" DCF_CHANGED               " link The_DataColumn_structure}      @{" IDXFileHeader             " link The_file_structure_of_an_index_file}
   @{" DCF_HIDDEN                " link The_DataColumn_structure}      @{" IDXHeader                 " link The_IDXHeader_structure}
   @{" DCF_NOT_EMPTY             " link The_DataColumn_structure}      @{" IDXKeyEntry               " link The_IDXHeader_structure}
   @{" DCF_OWNBUFFER             " link The_DataColumn_structure}      @{" IDXMemPage                " link The_IDXHeader_structure}
   @{" DCF_READONLY              " link The_DataColumn_structure}      @{" IDXSFH                    " link The_IDXHeader_structure}
   @{" DOUBLELONG                " link Glossary}      @{" index                     " link Creating_an_index}
   @{" DOUBLELONG2Numeric()      " link Functions_for_processing_fixed_point_numbers}      @{" index locking             " link Functions_for_accessing_an_index}
   @{" DOUBLELONG2NUMERIC()      " link Functions_for_processing_fixed_point_numbers}      @{" Intel                     " link The_file_structure_of_a_DataTable_file}
   @{" DS_ADDCOLUMN              " link Operations_the_DataTable_supports}      @{" Intuition                 " link Introduction}
   @{" DS_AddColumns()           " link Adding_DataColumns_to_a_DataServer}      @{" joinOS.library            " link Basics_you_should_know}
   @{" DS_ALLOWSELECTION         " link Operations_every_DataServer_should_support}      @{" key entry                 " link Navigating_through_an_index}
   @{" DS_AVAILABLEORDER         " link Operations_every_DataServer_should_support}      @{" key expression            " link Key-expressions_and_key-values}
   @{" DS_CLEARSELECTION         " link Operations_every_DataServer_should_support}      @{" key value                 " link Key-expressions_and_key-values}
   @{" DS_Columns                " link Creation_of_DataServers}      @{" LastError                 " link The_DataServer_structure}
   @{" DS_CURRENTCOLUMN          " link Operations_every_DataServer_should_support}      @{" little endian             " link The_file_structure_of_a_DataTable_file}
   @{" DS_CURRENTKEY             " link Operations_every_DataServer_should_support}      @{" Logic2Bool()              " link Convertion_macros}
   @{" DS_CURRENTROW             " link Operations_every_DataServer_should_support}      @{" LongToStr()               " link Convertion_functions}
   @{" DS_DoUpdate()             " link Request_performing_of_operations_to_a_DataServer}      @{" Lower()                   " link Convertion_macros}
   @{" DS_DISPOSE                " link Operations_every_DataServer_should_support}      @{" LToS()                    " link Convertion_functions}
   @{" DS_ERR_MAYOR              " link The_DataServer_structure}      @{" memo                      " link Memo_files}
   @{" DS_ERR_MINOR              " link The_DataServer_structure}      @{" MemoBlock                 " link The_MemoFile_structures}
   @{" DS_ERR_NO_ERROR           " link The_DataServer_structure}      @{" MemoEntry                 " link The_file_structure_of_a_memo_file}
   @{" DS_ERR_NO_MEMORY          " link The_DataServer_structure}      @{" MemoFile                  " link The_MemoFile_structures}
   @{" DS_ERR_NO_MORE_DATA       " link The_DataServer_structure}      @{" MemoFileHeader            " link The_file_structure_of_a_memo_file}
   @{" DS_ERR_OP_NOT_KNOWN       " link The_DataServer_structure}      @{" NUMERIC                   " link Functions_for_processing_fixed_point_numbers}
   @{" DS_ERR_WRITE_PROTECT      " link The_DataServer_structure}      @{" NUMERIC calculation       " link Calculating_using_fixed_point_numbers}
   @{" DS_ERR_WRONG_ARG          " link The_DataServer_structure}      @{" Numeric2DOUBLELONG()      " link Functions_for_processing_fixed_point_numbers}
   @{" DS_FINDCOLUMN             " link Operations_the_DataTable_supports}      @{" NUMERIC2DOUBLELONG()      " link Functions_for_processing_fixed_point_numbers}
   @{" DS_FIRSTROW               " link Operations_every_DataServer_should_support}      @{" Numeric2Str()             " link Functions_for_processing_fixed_point_numbers}
   @{" DS_FIRSTSELECTED          " link Operations_every_DataServer_should_support}      @{" NUMERIC2Str()             " link Functions_for_processing_fixed_point_numbers}
   @{" DS_GETCOLUMNDATA          " link Operations_every_DataServer_should_support}      @{" NumericIntDigits()        " link Functions_for_processing_fixed_point_numbers}
   @{" DS_GETORDER               " link Operations_the_DataTable_supports}      @{" NUMERICIntDigits()        " link Functions_for_processing_fixed_point_numbers}
   @{" DS_GETRAWDATA             " link Operations_the_DataTable_supports}      @{" OpenLibrary()             " link Open_the_database.library}
   @{" DS_GOTOCOLUMN             " link Operations_every_DataServer_should_support}      @{" operating system          " link Implementation_details}
   @{" DS_GOTOROW                " link Operations_the_DataTable_supports}      @{" operations                " link Request_performing_of_operations_to_a_DataServer}
   @{" DS_InitA()                " link Creation_of_DataServers}      @{" Ram-handler               " link Functions_for_changing_an_index}
   @{" DS_INSERTROW              " link Operations_the_DataTable_supports}      @{" RAtChr()                  " link String_manipulation_functions}
   @{" DS_ISSELECTED             " link Operations_every_DataServer_should_support}      @{" record locking            " link Locking_of_records}
   @{" DS_KEYEXPRESSION          " link Operations_every_DataServer_should_support}      @{" REINDEX_PROGRESS          " link Functions_for_changing_an_index}
   @{" DS_KEYLENGTH              " link Operations_every_DataServer_should_support}      @{" relation                  " link Relations_between_DataTables}
   @{" DS_LASTROW                " link Operations_every_DataServer_should_support}      @{" row                       " link DataServer}
   @{" DS_Name                   " link Creation_of_DataServers}      @{" SetFileSize()             " link Functions_for_changing_an_index}
   @{" DS_NEXTCOLUMN             " link Operations_every_DataServer_should_support}      @{" SkipChars()               " link String_manipulation_functions}
   @{" DS_NEXTROW                " link Operations_every_DataServer_should_support}      @{" SToD()                    " link Convertion_functions}
   @{" DS_NEXTSELECTED           " link Operations_every_DataServer_should_support}      @{" SToL()                    " link Convertion_functions}
   @{" DS_NUM_OF_COLUMNS         " link Operations_every_DataServer_should_support}      @{" SToT()                    " link Convertion_functions}
   @{" DS_NUM_OF_ROWS            " link Operations_the_DataTable_supports}      @{" Str()                     " link Converting_functions_and_operators_of_key-expressions}
   @{" DS_MOVECOLUMN             " link Operations_the_DataTable_supports}      @{" STR()                     " link Convertion_functions}
   @{" DS_ORDERASCEND            " link Operations_every_DataServer_should_support}      @{" Str2Numeric()             " link Functions_for_processing_fixed_point_numbers}
   @{" DS_PREVCOLUMN             " link Operations_every_DataServer_should_support}      @{" Str2NUMERIC()             " link Functions_for_processing_fixed_point_numbers}
   @{" DS_PREVROW                " link Operations_every_DataServer_should_support}      @{" StrZero()                 " link Converting_functions_and_operators_of_key-expressions}
   @{" DS_ReadOnly               " link Creation_of_DataServers}      @{" token                     " link Format_of_precompiled_key-expressions}
   @{" DS_REMOVECOLUMN           " link Operations_the_DataTable_supports}      @{" TToS()                    " link Convertion_functions}
   @{" DS_RemoveColumns()        " link Removing_DataColumns_from_a_DataServer}      @{" Upper()                   " link Convertion_macros}
   @{" DS_REMOVEROW              " link Operations_the_DataTable_supports}      @{" Val()                     " link Converting_functions_and_operators_of_key-expressions}
   @{" DS_SEEK                   " link Operations_every_DataServer_should_support}      @{" VALIDATE_RECORD           " link Creation_of_DataTables}
@endnode
