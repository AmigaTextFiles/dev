TABLE OF CONTENTS

pchg.lib/--background--
pchg.lib/PCHG_CompHuffmann
pchg.lib/PCHG_FastDecomp
pchg.lib/PCHG_ParsePCHG
pchg.lib/PCHG_SetUserCopList
pchg.lib/PCHG_SHAM2PCHG
pchg.lib/--background--                               pchg.lib/--background--

  The purpose of this library is to give programmers an easy way to
  implement PCHG display technology in their programs. The library
  allows to read and write easily PCHG chunks by providing
  compression/decompression routines and CopperList building
  functions.

  When reading PCHG chunks, you have three function you can use:
  PCHG_ParsePCHG() will automagically parse the chunk (possibly using
  decompression) and build the Copperlist for your ViewPort. If you're
  using the ViewPort of an Intuition Screen, when you will call
  CloseScreen() the Copperlist will be automatically deallocated.

  Otherwise, you can use PCHG_SetUserCopList(), which gives you a finer
  control (for instance, you can build a Copperlist with an offset).
  However, the chunk parsing is left to you, apart from the
  decompression, which is handled by PCHG_FastDecomp(). This routine
  is called with register parameter passing, so if you're not using
  SAS C or Assembly, you'd better call PCHG_CFastDecomp(), which has
  standard parameter passing.

  When writing a PCHG chunk, the function PCHG_CompHuffmann() will
  pack with static Huffmann encoding your LINEDATA (i.e., the line mask
  followed by a SmallLineChanges or BigLineChanges array, as from
  the PCHG specification).

  Finally, the function PCHG_SHAM2PCHG() will build a fake PCHG chunk from
  a SHAM chunk, making easy for people to partially support the old
  "standard".

  There are two versions of this library: pchg.lib has stack parameter
  passing, while pchgr.lib was compiled with the SAS/C -rr (registerized
  parameter passing) option.

  The prototypes for pchg.lib can be found in clib/pchglib_protos.h, while
  the general PCHG include file is iff/pchg.h.

  This library was written by Sebastiano Vigna, and it's placed in
  the public domain.

pchg.lib/PCHG_CompHuffmann                         pchg.lib/PCHG_CompHuffmann

  NAME
      PCHG_CompHuffmann -- Compress a memory block with static Huffmann

  SYNOPSIS
      compData = CompHuffmann(Source, SourceSize, DataSize, TreeSize);

      UBYTE *PCHG_CompHuffmann(APTR, ULONG, ULONG *, ULONG *);

  FUNCTION
      Compress a block of memory into the typical PCHG compression
      format: static Huffmann encoding. A pointer to the compressed data
      (tree+code) is returned. After use, the block of
      *DataSize+*TreeSize length pointed by compData has to be
      FreeMem()ed. The longword pointed by TreeSize will be set to the
      number of bytes used by the tree coding, the one pointed by DataSize
      to the number of bytes of Huffmann code (rounded to longword bounds).

  INPUTS
      Source        - A pointer to the start of the data to be compressed.
      SourceSize    - Size in bytes of the data to be compressed
      DataSize      - A pointer to a longword that will receive the length
                      in bytes of the data part of the compressed chunk.
      TreeSize      - A pointer to a longword that will receive the length
                      in bytes of the tree part of the compressed chunk.

  RESULT
      compData      - A pointer to the compressed data (tree+data,
                      *DataSize+*TreeSize bytes) or NULL if a
                      memory allocation failed. You have to free
                      this memory after you use it with a
                      FreeMem(compData, *TreeSize+*DataSize).

  EXAMPLE

  NOTES

  BUGS

  SEE ALSO
      PCHG_FastDecomp(), PCHG_CFastDecomp()

pchg.lib/PCHG_FastDecomp                             pchg.lib/PCHG_FastDecomp

   NAME
       PCHG_FastDecomp -- Decompress a PCHG chunk, fast.

   SYNOPSIS
       PCHG_FastDecomp(Source, Dest, TreeCode, OriginalSize);
                        A0      A1      A2        D0

       VOID PCHG_FastDecomp(APTR, APTR, WORD *, ULONG);

       PCHG_CFastDecomp(Source, Dest, TreeCode, OriginalSize);

       VOID PCHG_CFastDecomp(APTR, APTR, WORD *, ULONG);

   FUNCTION
       Unpack reasonably fast a PCHG chunk. This routine will
       never bypass the OriginalSize limit while writing to
       Dest.

   INPUTS
       Source        - The PCHG compressed data (just after the
                       PCHGCompHeader).
       Dest          - A block of memory OriginalSize bytes long
                       which will contain the unpacked data.
       TreeCode      - A pointer to the last word of the code
                       of the tree used when compressing the data.
                       If you're unpacking a standard PCHG chunk,
                       you should set this entry to
                       (char *)(PCHGCompHeader+1)+PCHGCompHeader->TreeSize-2
       OriginalSize  - The original length of the compressed data.
                       If you're unpacking a standard PCHG chunk,
                       you should set this entry to
                       PCHGCompHeader->OriginalSize

   RESULT
       None.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

pchg.lib/PCHG_ParsePCHG                               pchg.lib/PCHG_ParsePCHG

  NAME
      PCHG_ParsePCHG -- Parse a PCHG chunk and build Copperlist.

  SYNOPSIS
      Error = PCHG_ParsePCHG(PCHG, ViewPort);

      LONG PCHG_ParsePCHG(struct PCHGHeader *, struct ViewPort *);

  FUNCTION
      I-do-all-for-you function. PCHG_ParsePCHG() frees you from
      every hassle. You simply pass it the content of the PCHG
      chunk (i.e., what follows the IFF chunk size) and a pointer
      to your ViewPort. The Copperlist will be built and stuffed in.

  INPUTS
      PCHG          - A pointer to the contents of the PCHG chunk.
      ViewPort      - A pointer to the ViewPort that will receive the
                      Copperlist described in the PCHG chunk.

  RESULT
      Error will be set to 0 if everything OK. Otherwise you can
      the error listed in iff/pchg.h (PCHGERR_NOMEM, etc.).

  EXAMPLE

  NOTES
      The Copperlist created by this function will be
      automatically deallocated when you call CloseScreen() if
      you're using the ViewPort of an Intuition Screen.
      This function parses the chunk and then calls
      PCHG_SetUserCopList(); thus, it needs grahics.library.
      After calling it, you will probably need a RethingDisplay()
      if you're using an Intuition Screen, or the suitable graphics
      calls (MrgCop() etc.) if you're directly handling the
      ViewPort.

  BUGS

  SEE ALSO
      PCHG_SetUserCopList(), iff/pchg.h

pchg.lib/PCHG_SetUserCopList                     pchg.lib/PCHG_SetUserCopList

  NAME
      PCHG_SetUserCopList -- Set a ViewPort Copperlist using a PCHG chunk

  SYNOPSIS
      PCHG_SetUserCopList(Offset, Length, ViewPort, PCHG, LineMask, LineData)
;

      VOID PCHG_SetUserCopList(WORD, UWORD, struct ViewPort *,
                                    struct PCHGHeader *, APTR, APTR);

  FUNCTION
      Creates the Copperlist defined by a PCHG header and data. If a user
      Copperlist is already defined on the ViewPort, it is first
      deallocated. If Length is 0, every change specified by the PCHG
      chunk will be generated. If Length is not 0, every change which
      happens on a line in the range Offset<->Offset+Length will be
      generated.  In each case, an offset equal to Offset is subtracted
      from the PCHG indications. For instance, if Offset == 8, Length ==
      10, the changes specified in the PCHG chunk for the line range 8-17
      will happen on the line range 0-9. This allows setting a Copperlist
      for a scrolled picture (i.e., the first displayed line is not the
      first picture line). If Offset == 0, Length == ViewPort->DHeight, only
      the changes which happen inside the ViewPort will be generated (with
      no offset). Do NOT ask for odd offsets for a laced picture, because
      of the well-known limitations of MrgCop(). Note that when Offset is
      non-zero, this function will stuff via SetRGB4() all the changes which
      happens before the Offset line, so that the image will be correctly
      displayed. This however implies you have to reload the CMAP before each
      call with an offset.

  INPUTS
      Offset       - A positive offset which will be subtracted from the
                     line specified by the PCHG->StartLine field.
      Length       - A number of lines which will limit the
                     Copperlist generation. Ignored if == 0.
      ViewPort     - The ViewPort which will receive the Copperlist.
      PCHG         - The PCHGHeader.
      LineMask     - The line mask pointer. Technically, the LINEMASK
                     part of the PCHG grammar.
      LineData     - The (Small|Big)PaletteChange array
                     pointer. Technically, the second part of the LINEDATA
                     part of the PCHG grammar.

  RESULT
      None.

  EXAMPLE

  NOTES
      The MAX_PER_LINE_CHANGES #define at the start of the source
      code limits the maximum number of changes allowed on a
      single line. No check is done for changes on odd lines if
      the ViewPort is laced. MaxReg and MinReg are ignored.
      This function does *not* call RethinkDisplay() for you,
      and needs graphics.library. Remember to free the user Copperlist
      (if you're using a &Screen->Viewport, Intuition will do it for you).

  BUGS
      Background Copperlists which a PCHGHeader->StartLine
      negative value will not be correctly displayed if Offset
      is not 0, because only changes on a line >=Offset will be
      generated. This shouldn't be a problem however.

  SEE ALSO

pchg.lib/PCHG_SHAM2PCHG                               pchg.lib/PCHG_SHAM2PCHG

  NAME
      PCHG_SHAM2PCHG -- Fakes a PCHG chunk from a SHAM chunk

  SYNOPSIS
      PCHGHeader = PCHG_SHAM2PCHG(SHAMChunk, SHAMSize, Increment);

      struct PCHGHeader *PCHG_SHAM2PCHG(UWORD *, ULONG, WORD);

  FUNCTION
      Creates a PCHGHeader and a LINEMASK (see the PCHG specs) by parsing a
      SHAM chunk. The memory block containing the SHAM is overwritten by an
      array of SmallPaletteChanges (this array is always shorter than the
      original SHAM chunk). A memory block is allocated for the PCHGHeader
      and for the LINEMASK (which is of course placed just after the
      PCHGHeader), and is returned by the function. You can then free it
      using as dimension the size of a PCHGHeader plus the number of bytes
      required by the longword mask, i.e.,

           sizeof(struct PCHGHeader)+((PCHGHeader->LineCount+31)/32)*4

      You can parse this chunk as any PCHG chunk, but the changes per line
      could be more than seven (up to fifteen). This function, however, is
      intelligent, and doesn't generate useless color changes (i.e., it
      never pokes again the same value two times). You will usually call

      PCHG_SetUserCopList(0, 0, Screen, PCHGHeader, &PCHGHeader[1], SHAMChunk
);

      after using PCHG_SHAM2PCHG().


  INPUTS
      SHAMChunk    - The address of the SHAM chunk.
      SHAMSize     - The size of the SHAM chunk (we handle >200
                     lines chunks).
      Increment    - The increment to add to the line number while parsing
                     the SHAM chunk. It has to be 1 for non-laced pictures,
                     2 for laced pictures.

  RESULT
      PCHGHeader   - A pointer to a memory block contaning a PCHGHeader
                     followed by a LINEMASK, or NULL if the memory
                     allocation failed. You have to free this memory after
                     you used it.

  EXAMPLE

  NOTES
      This function will not generate any change on line 0, because the
      line 0 colors should be the same of the CMAP. If you get any problem,
      you can feed the first line of the SHAM chunk as a color table to the
      screen before calling this function.

      Since this function writes in the fake PCHG chunk only the real
      changes, you will generally get a better display using this function
      and PCHG_SetUserCopList() than with SHAMVIEW, for instance.

  BUGS

  SEE ALSO

