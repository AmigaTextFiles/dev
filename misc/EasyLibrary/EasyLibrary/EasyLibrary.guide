@database EasyLibrary.guide
@master Devel:EasyLibrary/EasyLibrary.guide
@author "Tom Bampton"
@(c) "(c) Copyright 1998 Eden Developments"
@wordwrap on

@node "main" "EasyLibrary Documentation"

                          EasyLibrary Version 1.0
                          Written by Tom Bampton

                   (c) Copyright 1998 Eden Developments

  Section 1 - Introductions and Legalities
  @{" 1.1 Introduction         " link intro}
  @{" 1.2 Disclaimer           " link disc}
  
  Section 2 - Developing your library
  @{" 2.1 Developing a Library " link devel}
  @{" 2.2   The library.asm    " link lib.asm}
  @{" 2.3   The library.i      " link lib.i}
  @{" 2.4   The functable.i    " link func.i}
  @{" 2.5   The functions.asm  " link func.asm}
  @{" 2.6 Linking with C Code  " link linkc}
  @{" 2.7 Assemblers           " link asm}
  @{" 2.8 Troubleshooting      " link trouble}
  
  Section 3 - All those extra files you need for using your library
  @{" 3.1 FD Files             " link fd}
  @{" 3.2 LVO Includes         " link lvo}
  @{" 3.3 Pragmas Headers      " link pragmas}
  @{" 3.4 Link Libraries       " link linklib}
  @{" 3.5 Prototypes           " link proto}
  @{" 3.6 Other Includes       " link otherinc}
  
  Section 4 - Support and extra information
  @{" 4.1 Support              " link support}
  @{" 4.2 The Author           " link author}
  @{" 4.3 Eden Developments    " link eden}

@endnode

@node "intro" "EasyLibrary - Introduction"

EasyLibrary is a set of source files to make developing a library easy.
EasyLibrary came about due to my need to have a quick and simple method to
get libraries developed. Until I wrote this I was writing libraries using
example code from Dice C, and that doesnt use autoinit or allow too well for
assembly and C functions at the same time. So, I wrote this small, fast,
autoinit generic library that I can reuse over and over. I then decided to
release this with some extensive documentation on Amiga Libraries to help
other people. 

I have tried to make it as easy as possible for C developers who dont
understand assembly language to use this, in each of the descriptions on
the files there is a small part on what is expected by the assembler. In
the @{"Linking with C Code" link linkc} section there is also a part on writing tag
functions.

Assembly Language programmers should have no trouble with this, and can
probably get away with only reading @{"Section 2.1" link devel} which details the basic
parts of this package.

The library created with EasyLibrary will be a standard autoinit library,
and is based upon the sample source in the RKM. The library code itself
isnt very commented, only basic comments are included. The comments in the
starter files however are quite detailed, but you will probably still need
to check back here if you havent used it before.

If you use EasyLibrary to write a library you distribute to the public,
either as freeware, shareware or commercially, I'd like it if you'd include
a mention such as "Libraries written using EasyLibrary by Tom Bampton" or
something to that effect. This is not a requirement, its just courtesy on
your part. I have spent a lot of time developing this and writing this
guide, I think I deserve some credit if you use it.

@endnode

@node "disc" "EasyLibrary - Disclaimer"

I make no warranty, either expressed or implied, that this will work and not
destroy your computer. I will not be made liable for any damage incurred
through the use or misuse of this source code. You use this at your own
risk.

@endnode

@node "devel" "EasyLibrary - Developing a Library"

Developing a Library with EasyLibrary is very easy, hence the name :)
The library is split into five files, four of which you need to supply
yourself. The files are as follows:

  library.asm     The main library code, you wont need to change this
  functable.i     The Library Vector table
  functions.asm   The functions for your library
  library.i       Some macros needed by library.asm
  xxxx_rev.i      BumpRev generated include providing the rest of the macros

For a complete description of the files, see the relevant sections of this
guide.

library.asm includes all the other files when it needs them, so you cannot
use any actual code in them, excepting functions.asm.

If you dont have BumpRev, you can write the include by hand or put the macros
in library.i. library.asm doesnt include the revision include itself, its
assumed that library.i either includes it or provides the macros itself.
See the @{"library.i" link lib.i} section for more information.

Before you start, please make sure you copy the files to an appropriate
directory. If you wipe the originals, then you'll have to download it
again :)

@endnode

@node "lib.asm" "EasyLibrary - The library.asm"

The library.asm file is the core of the library. It provides the startup
code, Open(), Close() Expunge(), RomTag, and other needed structures. 

It is unlikely you will need to edit this, as everything is provided for you
in external files. There are some symbols you can define to determine the
way the library works, as follows:

   EL_GIMMEOPEN     Set if you want to specify your own open routine.
                    After the usual open code Open() will bsr to UserOpen()
                    with the version in d0 and the library base in a6
                    You must return the library base in d0 if you succeded,
                    or 0 for failure.
   
   EL_GIMMECLOSE    The same as above, except on Close(). The code will bsr
                    to UserClose() with the library base in a6. This will
                    be called BEFORE a possible Expunge. NEVER call Expunge()
                    yourself.
                    
   EL_GIMMEINIT     The same as above, but for init. You should only use this
                    to allocate any STATIC data. The library base will be
                    in d0, and the segment list in a0. The routine called is
                    UserInit(), and should return zero on failure or nonzero
                    on success.
                    
   EL_GIMMEEXP      The same as above, but for Expunge(). UserExpunge() will
                    be called with the library pointer in a6. NEVER EVER
                    Wait() or take a long time to complete, this is called
                    from the memory allocator. UserExpunge() shouldnt
                    make any assumptions or do much, use it ONLY to free
                    static data allocated by UserInit()
   
   EL_CUSTBASE      Set if you want a custom library base other then the
                    one provided. See below for more information.

@{i}A note on library bases@{ui}

The library base used is somewhat automatic, if you havent defined a base in
library.i then it will use the default base. There are certain restrictions
on the library base, however. The start of the base MUST be the same as the
default one, with the same labels. After this you can extend it as you like.
You must set the label LibraryBase_SIZEOF to the size of your library
base. Setting EL_CUSTBASE currently has no effect as the base is
automatically defined using LibraryBase_SIZEOF. This behaviour may change
in the future.

@endnode

@node "lib.i" "EasyLibrary - The library.i"

This include file contains the various macros and settings needed by
library.asm It is here that you should set all your settings for what you
want called, the revision macros, the name macro and (optionally) the library
base. If you dont specify a library base here, the default will be used.

If you have BumpRev, you can simply include a generated revision header.
If you dont, then use the following (dont forget to change the name, version
and date!). Do NOT change the macro names.

VERSION		EQU	1
REVISION	EQU	1
DATE	MACRO
		dc.b	'24.7.98'
	ENDM
VERS	MACRO
		dc.b	'sample 1.1'
	ENDM
VSTRING	MACRO
		dc.b	'sample 1.1 (24.7.98)',13,10,0
	ENDM
VERSTAG	MACRO
		dc.b	0,'$VER: sample 1.1 (24.7.98)',0
	ENDM

You also need a LIBRARYNAME macro, as follows:

LIBRARYNAME	macro
		dc.b	"sample.library",0
		endm

Please see the @{"library.asm" link "lib.asm"} section for information on the library base.
@endnode

@node "func.i" "EasyLibrary - The functable.i"

functable.i is simply a table of your functions. You do not include the
Open, Close, Expunge and Null functions in this table as they're set by
library.asm ... you must put the table in LVO order, that is, the order in
which the functions appear in your library, starting at -30.

The table looks like this:

	dc.l	Func1
	dc.l	Func2
	....
	dc.l	FuncN

That is @{b}ALL@{ub} that is permitted in this file. Putting code into this
file will screw up the function table and possibly crash your library, you
have been warned!

@endnode

@node "func.asm" "EasyLibrary - The functions.asm"

functions.asm is where you put all your library functions that are in the
table vector table. If you are using C to write your functions, you should
include tags to them here, or leave this file blank (NOTE: It MUST exist)
and put your C functions directly into the table. If you do this, then
the functions MUST take their parameters in registers. If you want stack
based functions, then you'll need to write some tags in functions.asm. See
@{"Linking with C Code" link linkc} for more information on this.

@endnode

@node "linkc" "EasyLibrary - Linking with C Code"

If you want to use C to write some or all of your library functions, you
have two options. The easiest is to set your compiler to use registerized
parameters, either by using a compiler switch or by putting the relevant
modifier in front of the functions. In Dice and SAS/C, the modifier is
__regargs. The compiler switch for Dice is -mRR and for SAS/C it's parm=r.
You must also specify which register each argument goes into. Under Dice,
you specify __Dx or __Ax before the variable definition in the function.
For example,

__regargs void MyFunc(__D0 int a, __A0 char *b)
{
    ....
}

Under SAS/C it's slightly different, you have to use register Ax or
register Dx to specify the register. Also, the __regargs has to be in
a different place. For example, 

void __regargs MyFunc(register D0 int a, register A0 char *b)
{
    ....
}

I am a little unsure of the SAS/C method, so please check your manual if
that doesnt work. It is also worth noting that some compilers, notably Dice,
change the name of the function when using registerized parameters. Usually
the name in assembler is _MyFunc, but it changes to @MyFunc when using
registers for parameters. I think SAS/C doesnt change it, you will have
to check.

The second method of linking C functions, is using stubs in functions.asm
to convert registered parameters to stack based parameters. This requires
knowledge of Asm, so for C only people, you should use the method above.

When writing stubs, remember that the arguments go on the stack in reverse
order. For example:

MyStub:		move.l	long,-(sp)
		move.b	byte,-(sp)
		bsr	_MyFunc
		
would be used for a C function like this:

void MyFunc(char byte, int long)

When you have called the function, it is important that you reset the stack
to how it was before you changed it. In our example above we pushed 5 bytes
onto the stack (a longword and a byte), so we can simply do:

		addq.l	#5,sp
		rts

So, our completed stub function would look like this:

MyStub:		move.l	long,-(sp)
		move.b	byte,-(sp)
		bsr	_MyFunc
		addq.l	#5,sp
		rts

You should also remember that not all C library functions will be available
to you, even if you link with the standard C library. Functions like malloc()
and other ANSI C memory handling functions WONT work as they need special
startup code. You also wont be able to use functions such as printf() and
other stdio related functions as there wont be a stdio handle setup. If you
need to do file IO and memory handling, its best to use the OS for it. Also
be aware of functions like strdup() that call malloc() to allocate a string.
If you must use strdup() or those other functions, write a couple of similar
functions that use the Amiga's OS. Also take a look at the utility.library
autodocs, which has some string handling routines in it. 

Also remember that you should NEVER link with standard startup code,
always link library.o first then any other modules you need such as
c.lib, amiga.lib etc.

@endnode

@node "asm" "EasyLibrary - Assemblers"

EasyLibrary has been tested and is known to work with Devpac 3. It does
*not* work with a68k and das (Dice's assembler). The a68k problem may just
be from the version of the includes i used to test it with.

If you manage to get it to work with a68k, please write to fosters@dvalley.demon.co.uk
and tell me how you did it.

@endnode

@node "trouble" "EasyLibrary - Troubleshooting"

If you have a problem assembling and you're using Devpac 3, reread the
documentation and make sure you have everything correct.

If you have a problem in using the library, make sure your library code AND
your test code is correct. 

If the problem persists send me the library source code and the source code
your testing it with, with a description of the problem and what assembler
you are using. If you're using C as well tell me which compiler it is.
Send all that to fosters@dvalley.demon.co.uk and Ill get onto it and let
you know what the problem is and how to fix it.

@endnode

@node "fd" "EasyLibrary - FD Files"

FD stands for function description. These files describe the library and
are used for automatic generation of LVO include files and link libraries.

There are many utilities around on Aminet for these conversions, one such
is my FDConvert program. You could also use the FDtoLVO program which comes
with Devpac 3, but it isnt very flexible.

FD files follow a simple format, as follows:

##base _MegaBookIOBase
##bias 30
##public
MBIOInit(funcs)(a0)
MBIOLoad(file,list)(a0,a1)
MBIOSave(file,list)(a0,a1)
MBIOIdentify(file)(a0)
MBIOUnInit()()
##end

The lines beginning with ## tell programs what to do. ##base sets the name
of the library base, which is used for stub generators. ##bias tells where
to start the vector offsets (LVOs) from. This is usually 30. The only time
this would be different is if you had some private functions in the
beginning of the library, however the FD file format has consessions for
private functions. You can use ##bias anywhere throughout the file to change
the current LVO value, however this is probably not a good idea.

Next follows either ##public or ##private. ##public tells the converter
that the following functions are public and should be included upto the
end of the FD file or the next ##private. ##private is the opposite, it
tells converters to ignore the following functions upto the next ##public
or ##private. 

In between these we have the function descriptions. These are the name of
the function, as will appear in the generated includes/libraries, then
the names of the arguments in brackets seperated by commas. Following this
in another set of brackets is a list of registers in the correct order to
place the arguments in. This is only used by stub generators. The registers
can be seperated by a comma (,) or a slash (/). A slash means that a stub
generator can use movem to take the arguments off the stack, whereas a comma
means a single move for each register will be used. Private functions can
be simply defined as privateN()() where N is a unique number. 

You must terminate the file using ##end. Have a look at the OS FD files
included with your Compiler or Assembler for more full examples.

@endnode

@node "lvo" "EasyLibrary - LVO Includes"

LVO includes are used by assembly language programmers to give a symbolic
name to each vector offset. They look like this:

_LVOColdReboot		equ	-726

Put simply, they are a negative offset relative to the library base which
can be jsr'd to to call a library function. Even if you are not an assembly
programmer, you will need to generate these files from your FD files to
include with your developer information for assembly programmers.

It is much easier to use a converter to convert an FD file to LVO includes
rather then make them by hand.

@endnode

@node "pragmas" "EasyLibrary - Pragmas Headers"

Pragmas are used by C programmers, and are the equivalent of LVO files that
assembly programmers use. These describe the LVO and the registers as a hex
number, which the compiler can use to generate the relevant assembly code
to call the library.

Going with our previous example, ColdReboot() as a pragmas would look like
this:

#pragma libcall SysBase ColdReboot 2d6 00

As before, you should generate these headers using a converter program.

@endnode

@node linklib "EasyLibrary - Link Libraries"

Link Libraries are another option for C programmers. They contain stubs
that act like glue to the library. Basically, each function in the library
has a corresponding stub that moves the parameters from the stack into the
correct registers.

You can either write these yourself or use a converter program on the FD
files. You should also make these for as many compilers as you can, as not
all compilers share the same library format. For example, Dice and SAS/C
tend to not like each other's library files. For this reason, it is sometimes
easier to write the library yourself, which also gives you the option of
adding extra support functions as link library functions. The amiga.lib works
in this way.

@endnode

@node proto "EasyLibrary - Prototypes"

These are yet another C thang. A function prototype is like a function
definition, only it ends in a ;. Usually they begin with an extern as well.
These tell the compiler what type of arguments the function expects, and
helps prevent the programmer from giving the function the wrong arguments
and therefore potentially crashing the program. 

If you defined a function as

void MyFunc(char byte, int long)
{
    ...
}

Then the prototype would be:

extern void MyFunc(char byte, int long);

You need to write these yourself, unless you have a program that will take
prototypes out of source files and make a header of them. Dice C has a 
utility like this, but it doesnt help much if you wrote your library in
assembler :)

@endnode

@node otherinc "EasyLibrary - Other Includes"

You should also include in your developer pack C and Assembler versions of
all your includes. These include (forgive the pun) library base structures,
structures passed to the functions, flag values, constants, etc etc.

You should have as many of these as you need, and it depends from library
to library. Generally speaking, a small library wont need any extras unless
it has a customized library base that the programmer would need to access.
A large library, Amiga's exec.library for example, may need many to cover
the whole library without haveing too many large include files. 

If you only know one language, either get someone to help you convert them
to the other, or look at the system headers. Converting header files is
quite easy even if you dont know Assembler or C. 

@endnode

@node support "EasyLibrary - Support"

The only support I can offer on EasyLibrary is that outlined in @{"Troubleshooting" link trouble}
as programming is too wide a subject for me to help with, i just dont have
the time. 

@endnode

@node author "EasyLibrary - The Author"

I can be contacted at fosters@dvalley.demon.co.uk or found on IRC as Fosters.

@endnode

@node eden "EasyLibrary - Eden Developments"

Eden Developments is the successor to the old Eden Software group. Eden is
now an actual company, operating in the UK. We provide computer services
for businesses and home users, including repairs and upgrades, web pages,
internet setups, etc.

So, what exactly happened to Eden Software ? The Internet. It just got
impossible to keep up with what people were doing, fights happened, BBSs
closed, I left the Amiga scene, and Eden died. Eden was reborn in January
1998 when I started the company Eden Developments, and recently I found the
old MegaBook sources so I emailed people who had asked about it in the past
and decided to restart the project. Steve's helped a little with beta testing,
as for the rest of the old Eden ... who knows ? If you used to be in Eden
feel free to email me and tell me :)

@endnode
