<HTML>
<HEAD>
<TITLE>Utilisation de resload_Protect#?</TITLE>
<meta name="DC.Language" content="fr">
<meta http-equiv="content-language" content="fr">
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
<!-- $Id: prot.html 1.5 2004/04/07 19:59:52 wepl Exp wepl $ -->
</HEAD>
<BODY>
<h3>Utilisation de resload_Protect#?</h3>
<h4>Th&eacute;orie</h4>
Dans certaines situations, il est tr&egrave;s utile d'&ecirc;tre inform&eacute; quand le programme
install&eacute; acc&egrave;de &agrave; certaines zones de la m&eacute;moire.
Avec la fonction <a href="../../Autodoc/whdload.doc">resload_Protect#?</a>, il est
possible de prot&eacute;ger certaines parties de la m&eacute;moire contre la lecture et/ou
l'&eacute;criture du processeur. "Prot&eacute;ger" veut dire que chaque acc&egrave;s &agrave; une r&eacute;gion
de la m&eacute;moire prot&eacute;g&eacute;e cr&eacute;era un Access Fault exception avec comme r&eacute;sultat
un message appropri&eacute; g&eacute;n&eacute;r&eacute; par WHDLoad. Si vous d&eacute;clarez une partie de la
m&eacute;moire comme prot&eacute;g&eacute;e en utilisant la fonction <a
href="../../Autodoc/whdload.doc">resload_Protect#?</a> WHDLoad modifiera les
"affected page descriptor" dans l'arbre de traduction MMU.
Maintenant chaque acc&egrave;s &agrave; cette page prot&eacute;g&eacute;e, le CPU provoquera un Access Fault
exception. Cette exception est trait&eacute;e dans WHDLoad qui en v&eacute;rifiera la raison.
Si c'&eacute;tait un acc&egrave;s &agrave; une page prot&eacute;g&eacute;e mais que l'acc&egrave;s ne touche pas &agrave; la
m&eacute;moire prot&eacute;g&eacute;e, cet acc&egrave;s sera &eacute;mul&eacute;, et le programme continuera &agrave; fonctionner
normalement. Autrement, WHDLoad quittera avec un message appropri&eacute;. Si l'acc&egrave;s
&eacute;tait un acc&egrave;s &agrave; des "instructions stream" (par ex. le CPU essaye de charger
le code), ce sera toujours &eacute;mul&eacute;, en d'autres termes, les fonctions <a
href="../../Autodoc/whdload.doc">resload_Protect#?</a> affecteront seulement
la lecture et l'&eacute;criture des donn&eacute;es. Le fait est que chaque acc&egrave;s &agrave; une page
prot&eacute;g&eacute;e (actuellement la taille de la page est de $1000) produira un Access Fault,
m&ecirc;me si la partie prot&eacute;g&eacute;e n'est que de 1 octect, en cons&eacute;quence la vitesse
d'ex&eacute;cution du programme pourra ralentir &eacute;norm&eacute;ment. Sp&eacute;cialement si une partie du
code se trouve dans la m&ecirc;me page. Si le programme d&eacute;pend de la vitesse d'ex&eacute;cution,
il se peut que le programme ne fontionnera pas avec de la m&eacute;moire prot&eacute;g&eacute;e.
<h4>Exemple: checksums en dehors du code</h4>
Si vous installez un jeu en utilisant WHDLoad, vous devez patcher les routines
originales du loader dans le jeu, dans un m&ecirc;me temps, elles utiliseront WHDLoad
pour charger les donn&eacute;es du jeu. Quelques jeux ex&eacute;cutent des sommes de contr&ocirc;le
en dehors du code pour d&eacute;tecter si le code original a &eacute;t&eacute; modifi&eacute;. Ces d&eacute;tections
peuvent &ecirc;tre dures &agrave; trouver. Mais rien n'est plus facile qu'en utilisant les
fonctions <a href="../../Autodoc/whdload.doc">resload_Protect#?</a> dans WHDLoad.
Ce que devez faire n'est d'autre que de prot&eacute;ger en lecture les octets que vous
avez chang&eacute;s dans le code du jeu. Maintenant chaque routine qui essayera de calculer
un checksum et lira votre code patch&eacute;, provoquera un Access Fault.
Vous saurez donc o&ugrave; la routine se trouve.
<h4>Limitations</h4>
Vous ne devez pas prot&eacute;ger une page de m&eacute;moire o&ugrave; le pointeur de pile superviseur
(SSP) se trouve. Si vous
faites cela, et qu'une exception se produit, il y aura un "Double Bus Fault"
car le CPU sera incapable d'&eacute;crire le stackframe de l'exception. Apr&egrave;s un
Double Bus Fault, un reset de l'ordinateur doit &ecirc;tre effectu&eacute;. WHDLoad s'assure qu'il n'y pas de conflit entre la zone protégée et le SSP et quitte, mais il ne peut rien faire si le changement de SSP se fait par la suite.
<ul>
<li>68020 + 68851
<ul>
<li>Ce hardware n'est pas support&eacute; actuellement
</ul>
<li>68030
<ul>
<li>Les transfers de 3-Byte ne sont pas support&eacute;s et provoqueront un vrai Access
Fault, de tels transfers se produisent s'il y a un acc&egrave;s &agrave; un mot long &agrave; une
adresse impaire dans une fronti&egrave;re de page (ex. "tst.l ($fff)" o&ugrave; la page est prot&eacute;g&eacute;e
&agrave; partir de $1000), parce que c'est une instruction invalide sur 68000, vous
ne la verrez probablement pas.
<li>Les transfers bloqu&eacute;s caus&eacute;s par tas, cas ou cas2 ne sont pas support&eacute;s et cr&eacute;eront
un vrai Access Fault, ce n'est pas un probl&egrave;me car les transferts bloqu&eacute;s ne sont
pas support&eacute;s par le hardware Amiga.
</ul>
<li>68040
<ul>
<li>Ce hardware n'est pas support&eacute; actuellement
</ul>
<li>68060
<ul>
<li>L'acc&egrave;s aux donn&eacute;es non align&eacute;es ne sont pas support&eacute;s et provoqueront un
vrai Access Fault, un tel acc&egrave;s est un acc&egrave;s qui couvre 2 pages (dont une est
au moins prot&eacute;g&eacute;e), par exemple "tst.l ($ffe)" affecte la page $0..$fff et la
page $1000..$1fff, cette limitation est un vrai probl&egrave;me et fait que la fonction
resload_Protect est parfois inutile. J'essayerai peut-&ecirc;tre de supporter ceci
mais c'est difficile.
<li>L'acc&egrave;s aux instructions stream non align&eacute;s ne sont pas support&eacute;s et cr&eacute;eront
un vrai Access Fault si toutes les deux pages affect&eacute;es sont prot&eacute;g&eacute;es. La
plupart du temps, ceci devrait &ecirc;tre &eacute;vit&eacute;.
<li>Les transfers bloqu&eacute;s caus&eacute;s par tas, cas ou cas2 ne sont pas support&eacute;s et cr&eacute;eront
un vrai Access Fault, ce n'est pas un probl&egrave;me car les transferts bloqu&eacute;s ne sont
pas support&eacute;s par le hardware Amiga.
<li>Les instructions qui se trouvent dans la page prot&eacute;g&eacute;e (et donc
&eacute;mul&eacute;s) et les acc&egrave;s &agrave; l'octet superviseur du registre d'&eacute;tat sera mal
ex&eacute;cut&eacute;, ces instructions verront toujours le bit du mode trace &agrave; 1 et les
masques d'interruption &agrave; 7, aucune modification de l'octet superviseur
ne sera faite (l'octet superviseur restera intacte).
<li>Les instructions movem peuvent acc&eacute;der &agrave; une m&eacute;moire sans provoquer un
Access Fault exception, ceci est possible car seulement le 1er acc&egrave;s sera
v&eacute;rifi&eacute;.
<li>Move16 et les op&eacute;rations &agrave; double pr&eacute;cision (FPU) ne sont pas support&eacute;s
et cr&eacute;eront un vrai Access Fault.
<li>Un "move (mem),(mem)" avec un chevauchement de l'adresse de la source et de
la destination g&eacute;n&eacute;reront un Access Fault car le "non alignement" ne sera pas
ex&eacute;cut&eacute; correctement. Par exemple "move.l ($ffc),($ffe)" o&ugrave; la page
$1000..$1fff est prot&eacute;g&eacute;e et la m&eacute;moire avant ex&eacute;cution contient ($ffc)=$11112222,
($1000)=$33334444, apr&egrave;s ex&eacute;cution, $1000 contiendra $11114444 au lieu de $22224444
</ul>
</ul>
</BODY>
</HTML>
