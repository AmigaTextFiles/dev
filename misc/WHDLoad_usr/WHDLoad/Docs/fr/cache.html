<HTML>
<HEAD>
<TITLE>Gestion du cache CPU</TITLE>
<meta name="DC.Language" content="fr">
<meta http-equiv="content-language" content="fr">
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
<!-- $Id: cache.html 1.6 2007/08/19 12:24:49 wepl Exp wepl $ -->
</HEAD>
<BODY>
<h3>G&eacute;n&eacute;ralit&eacute;s sur le cache CPU</h3>
Afin d'am&eacute;liorer la vitesse d'ex&eacute;cution des programmes, certains CPUs de la famille des 68000 sont capable de "cacher" les acc&egrave;s m&eacute;moire.
<br>Les caches sont toujours appel&eacute;s &agrave; l'aide d'adresses logiques, incluant le code fonctionnel de l'acc&egrave;s. Cela signifie que des acc&egrave;s en mode utilisateur ou superviseur cr&eacute;&eacute;ent des entr&eacute;es diff&eacute;rentes dans le cache (consultez les documentations Motorola pour plus d'informations).
<p>Voici un bref aper&ccedil;u sur les CPUs de la famille des 68000:
<ul><li>68000
pas de cache
<li>68010<ul>
<li>Prefetch d'instructions
<br>Prefetch de 2 mots, registre de d&eacute;codage &agrave; un mot
<li>Mode boucle
<br>activ&eacute; quand une instruction de taille un mot est suivie d'un DBcc. Le processeur ne va pas rechercher plus d'instructions jusqu'&agrave; la fin de la boucle.
</ul><li>68020<ul>
<li>Prefetch d'instructions
<br>un mot long
<li>Cache d'instructions
<br>16 lignes * 16 octets = 256 octets
<br>peut &ecirc;tre activ&eacute;/d&eacute;sactiv&eacute; par l'interm&eacute;diaire du CACR
</ul><li>68030<ul>
<li>Prefetch d'instructions
<br>un mot long
<li>Cache d'instructions
<br>16 lignes * 16 octets = 256 octets
<br>peut &ecirc;tre activ&eacute;/d&eacute;sactiv&eacute; par l'interm&eacute;diaire du CACR
<li>Cache de donn&eacute;es
<br>16 lignes * 16 octets = 256 octets
<br>peut &ecirc;tre activ&eacute;/d&eacute;sactiv&eacute; par l'interm&eacute;diaire du CACR
<br>Toujours "writethrough" (les octets &eacute;crits sont plac&eacute;s dans le cache pour relecture ult&eacute;rieure)
<br>mode allocation &eacute;criture s&eacute;lectionnable.
</ul><li>68040<ul>
<li>Prefetch d'instructions
<br>un mot long
<li>Cache d'instructions
<br>16 lignes * 16 octets = 256 octets
<br>peut &ecirc;tre activ&eacute;/d&eacute;sactiv&eacute; par l'interm&eacute;diaire du CACR
<li>Cache de donn&eacute;es
<br>16 lignes * 16 octets = 256 octets
<br>peut &ecirc;tre activ&eacute;/d&eacute;sactiv&eacute; par l'interm&eacute;diaire du CACR
<br>modes copyback ou writethrough (contr&ocirc;l&eacute; par le MMU)
</ul><li>68060<ul>
<li>Prefetch d'instructions
<br>un mot long
<li>Cache d'instructions
<br>512 lignes * 16 octets = 8192 octets
<br>peut &ecirc;tre activ&eacute;/d&eacute;sactiv&eacute; et r&eacute;duit &agrave; la moiti&eacute; par l'interm&eacute;diaire du CACR
<li>Cache de branchement
<br>peut &ecirc;tre activ&eacute;/d&eacute;sactiv&eacute; par le CACR
<br>pas affect&eacute; par les r&eacute;glages MMU!
<li>Diffusion Superscalaire
<br>peut &ecirc;tre activ&eacute;e/d&eacute;sactiv&eacute;e par le CACR
<li>Cache de donn&eacute;es
<br>512 lignes * 16 octets = 256 octets
<br>peut &ecirc;tre activ&eacute;/d&eacute;sactiv&eacute; et r&eacute;duit &agrave; la moiti&eacute; par l'interm&eacute;diaire du CACR
<br>modes copyback ou writethrough (contr&ocirc;l&eacute; par le MMU)
<li>Push Buffer
<br>peut &ecirc;tre d&eacute;sactiv&eacute; par l'interm&eacute;diaire du PCR
<li>Store Buffer
<br>peut &ecirc;tre d&eacute;sactiv&eacute; par l'interm&eacute;diaire du CACR
<br>Les pages ne doivent pas &ecirc;tre non cach&eacute;es s&eacute;rialis&eacute;es (pr&eacute;cis)
</ul></ul>
<h4><a name="cache">Gestion du cache dans WHDLoad</a></h4>
La premi&egrave;re chose importante est de comprendre que les caches sur 68030..68060 sont control&eacute;s par le registre de contr&ocirc;le de cache (CACR) <b>et</b> le MMU
(quand WHDLoad utilise et contr&ocirc;le le MMU)!
<br>Dans le CACR les caches sont activ&eacute;s ou d&eacute;sactiv&eacute;s globalement. Les pages simples MMU (4 kilo-octets avec WHDLoad) poss&egrave;dent un &eacute;tat d&eacute;crivant comment elles sont cach&eacute;es.
<br>Sur le 68030 une page m&eacute;moire peut &ecirc;tre cachable ou non cachable. Sur un
68040/68060 elle peut &ecirc;tre cachable "writethrough", cachable "copyback" (pas d'&eacute;criture m&eacute;moire imm&eacute;diate), non cachable (impr&eacute;cis) ou non cachable s&eacute;rialis&eacute; (pr&eacute;cis).
<p>Si le MMU n'est pas utilis&eacute; par WHDLoad, seulement le registre CACR sera modifi&eacute;.
<h4>R&eacute;glages de cache par d&eacute;faut</h4>
Par d&eacute;faut, les zones utilis&eacute;es par WHDLoad, le slave et l'extension m&eacute;moire,
sont marqu&eacute;es en tant que cachable, copyback. La m&eacute;moire de base (chip) est marqu&eacute;e comme non cachable, et les caches donn&eacute;e et instruction sont activ&eacute;s dans le CACR. Ainsi, le programme situ&eacute; dans la zone de m&eacute;moire de base fonctionne sans caches mais WHDLoad et le slave utilisent les caches pour une performance optimale.
<h4>Contr&ocirc;le du cache par programme</h4>
Il existe deux fonctions resload pour contr&ocirc;ler les caches: <A
HREF="../../Autodoc/whdload.doc">resload_SetCACR</a> et <A
HREF="../../Autodoc/whdload.doc">resload_SetCPU</a>. resload_SetCACR est la
vieille routine, et peut &ecirc;tre compl&egrave;tement remplac&eacute;e par resload_SetCPU (WHDLoad
retravaille les arguments pass&eacute;s &agrave; resload_SetCACR de fa&ccedil;on interne et appelle resload_SetCPU).
Cependant, l'utilisation de resload_SetCACR est recommand&eacute;e pour tous les progammeurs qui ne connaissent pas tout sur les caches et leur comportement dans le syst&egrave;me Amiga.
En utilisant resload_SetCACR, le cache instruction et donn&eacute;e peuvent &ecirc;tre activ&eacute;s ou d&eacute;sactiv&eacute;s s&eacute;par&eacute;ment. resload_SetCACR affecte uniquement la cachabilit&eacute; de la m&eacute;moire de base.
<h4>Contr&ocirc;le du cache par l'utilisateur</h4>
Si le programmeur a bien travaill&eacute;, alors l'utilisateur n'a rien &agrave; faire &agrave; propos des caches parce que les r&eacute;glages sont d&eacute;j&agrave; effectu&eacute;s dans le slave.
<br>N&eacute;anmoins, il peut y avoir deux raisons pour justifier un changement manuel des r&eacute;glages du cache. D'abord pour faire fonctionner un install qui ne fonctionne pas bien parce qu'il tourne trop vite (ex: erreurs graphiques) et ensuite
pour faire tourner plus vite un programme install&eacute;.
<p>Pour faire fonctionner un programme qui plante, l'option <a
href="opt.html#NoCache">NoCache</a> peut &ecirc;tre utilis&eacute;e. Cette option d&eacute;sactive
tous les caches et marque toute la m&eacute;moire comme non cachable s&eacute;rialis&eacute;e (precis). Si la machine poss&egrave;de de la m&eacute;moire chip 32 bits, cela restera plus rapide que sur un A500 de base.
<p>Pour am&eacute;liorer la vitesse d'un programme install&eacute;, certaines options peuvent &ecirc;tre positionn&eacute;es pour activer les caches. Ces options sont prioritaires par rapport aux r&eacute;glages du slave. Sur un 68020, l'option
<a href="opt.html#Cache">Cache</a> peut &ecirc;tre positionn&eacute;e. Sur un 68030, l'option <a
href="opt.html#DCache">DCache</a> peut &ecirc;tre &eacute;galement utilis&eacute;e, et elle inclut l'option Cache. Sur un 68060 il y a des options suppl&eacute;mentaires:
<a href="opt.html#BranchCache">BranchCache</a>,
<a href="opt.html#StoreBuffer">StoreBuffer</a> et
<a href="opt.html#SuperScalar">SuperScalar</a>. L'option <a
href="opt.html#ChipNoCache">ChipNoCache/S</a> permet d'am&eacute;liorer les performances sur68040 et 68060, voir ci-dessous.
<a name="chipmem"></a><h4>Cachabilit&eacute; de la m&eacute;moire chip</h4>
La cachabilit&eacute; peut &ecirc;tre r&eacute;gl&eacute;e non seulement par le processeur lui-m&ecirc;me (CACR) et les r&eacute;glages MMU, mais &eacute;galement par du mat&eacute;riel externe. Le processeur signale sur le bus quand il tente de cacher un acc&egrave;s. De m&ecirc;me, un p&eacute;riph&eacute;rique externe peut envoyer un signal au processeur (apr&egrave;s qu'une adresse ait &eacute;t&eacute; plac&eacute;e sur le bus d'adresse pendant un acc&egrave;s m&eacute;moire) lui demandant &agrave; ce qu'un acc&egrave;s ne soit pas cach&eacute;.
<br>Le m&eacute;canisme qui signale au processeur que la m&eacute;moire est cachable ou non est (d'apr&egrave;s ce que je sais) utilis&eacute; sur tous les Amigas et cartes CPU qui contiennent un CPU 68030 ou sup&eacute;rieur (parce qu'ils poss&egrave;dent un cache de donn&eacute;es).
Les zones affect&eacute;es sont la totalit&eacute; de la m&eacute;moire chip et l'espace m&eacute;moire des entr&eacute;es-sorties (Cia/Custom/Horloge temps r&eacute;el) qui ne doivent pas &ecirc;tre cach&eacute;s par le cache de donn&eacute;es. Cela est n&eacute;cessaire afin d'&eacute;viter les incoh&eacute;rences, par exemple &agrave; cause des m&eacute;canismes DMA.
<br>La r&eacute;action du processeur sur un rejet de cachabilit&eacute; pour une adresse d&eacute;pend des types de processeurs. Sur le 68030 il n'y a pas d'impact sur la vitesse d'acc&egrave;s, les donn&eacute;es ne sont pas cach&eacute;es, c'est tout. Sur le 68040, les acc&egrave;s en lecture sont effectu&eacute;es sans perte de vitesse mais les acc&egrave;s en &eacute;criture (copyback) sont annul&eacute;s et red&eacute;marr&eacute;s sans cachabilit&eacute;, ce qui donne des acc&eacute;s 5 fois plus lents par rapport &agrave; des adresses non cachables.
Sur le 68060, les acc&egrave;s en lecture et &eacute;criture sont annul&eacute;s et red&eacute;marr&eacute;s. Les acc&egrave;s lecture seront 3 fois plus lents, et les acc&egrave;s &eacute;criture seront 5 fois plus lents.
<br>Les probl&egrave;mes cit&eacute;s ci-dessus sont li&eacute;s aux acc&egrave;s donn&eacute;e. Les acc&egrave;s instruction ne sont pas affect&eacute;s et sont aussi cachables dans la m&eacute;moire chip.
Il existe des mat&eacute;riels (bugg&eacute;s) qui ne tol&egrave;rent pas que les instructions soient cach&eacute;s dans la m&eacute;moire chip. Sur de tels mat&eacute;riels, l'option <a
href="opt.html#ChipNoCache">ChipNoCache/S</a> doit &ecirc;tre utilis&eacute;e pour &eacute;viter un gros ralentissement de l'ex&eacute;cution (les acc&egrave;s instruction seront 2 fois plus lents).
<p>Vous pouvez tester ce comportement sur votre machine en ex&eacute;cutant <i>Speed.Slave</i> contenu dans le r&eacute;pertoire <tt>src/memory-speed</tt> de l'archive de d&eacute;veloppement.
<h4>Allocation &eacute;criture</h4>
L'allocation &eacute;criture contr&ocirc;le la gestion du cache sur 68030 quand un d&eacute;faut de cache se produit sur une op&eacute;ration d'&eacute;criture. L'allocation &eacute;criture doit &ecirc;tre activ&eacute;e quand des parties du programme fonctionnent en mode utilisateur. Si le programme install&eacute; fonctionne uniquement en mode superviseur alors l'allocation &eacute;criture peut &ecirc;tre d&eacute;sactiv&eacute;e, ce qui donne un l&eacute;ger avantage en termes de performances.
<h4>Cache de branchement</h4>
<p>Le cache de branchement est disponible uniquement sur le 68060. C'est une sorte de cache instructions pour les instructions de branchement. Mais la diff&eacute;rence avec le cache d'instructions c'est qu'il n'est pas affect&eacute; par les r&eacute;glages MMU! Cela signifie que m&ecirc;me si la page souhait&eacute;e est marqu&eacute;e comme non cachable, les instructions de branchement seront cach&eacute;es si le cache de branchement est activ&eacute;.</p>
<hr>Lisez le Manuel Utilisateur des Microprocesseurs Motorola pour des informations suppl&eacute;mentaires.
Si vous avez des corrections ou des ajouts &agrave; faire sur cette page, <a
href="mailto:wepl@whdload.de">contactez</a> moi SVP.
</BODY>
</HTML>
