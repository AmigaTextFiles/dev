<HTML>
<HEAD>
<TITLE>Moniteurs syst&egrave;me</TITLE>
<meta name="DC.Language" content="fr">
<meta http-equiv="content-language" content="fr">
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
<!-- $Id: freezer.html 1.4 2006/11/16 08:23:24 wepl Exp wepl $ -->
</HEAD>
<BODY>
<h3>Moniteurs syst&egrave;me</h3>
Il existe bon nombre de moniteurs syst&egrave;me logiciels. L'utilisation de tels outils
s'av&egrave;re tr&egrave;s utile pendant le d&eacute;veloppement et le debug des slaves et du programme install&eacute;. WHDLoad est directement interfac&eacute; avec HrtMon et ThrillKill. D'autres peuvent &ecirc;tre utilis&eacute;s avec l'option <a
href="opt.html#NoTrapHandler">NoTrapHandler/S</a> (cela pr&eacute;sente des inconv&eacute;nients bien s&ucirc;r).
Si vous voulez une interface directe pour un autre moniteur, contactez-moi et si c'est possible, je le ferai. Au d&eacute;marrage de WHDLoad, celui-ci v&eacute;rifie si l'un des moniteurs connus est actif. S'il en trouve un, WHDLoad effectue des op&eacute;rations sp&eacute;ciales. Si le MMU est utilis&eacute; par WHDLoad, celui-ci d&eacute;clare la m&eacute;moire utilis&eacute;e par le moniteur comme WriteThrough cachable. Pendant que le jeu ou la d&eacute;mo tourne, WHDLoad redirige toutes les NMI (exceptions non masquables) vers le vecteur NMI r&eacute;cup&eacute;r&eacute; de la table des vecteurs du moniteur. De plus, si le VBR est relog&eacute; par WHDLoad (<a href="opt.html#NoVBRMove">NoVBRMove/S</a>
n'est pas positionn&eacute; et le processeur est au moins un 68010) il compare la <a
href="opt.html#FreezeKey">"FreezeKey"</a> avec la valeur actuelle du clavier &agrave; chaque interruption. Si la valeur correspond, WHDLoad traite le clavier, transforme la structure de la pile en stackframe NMI et appelle le moniteur par son handler NMI.
<h4>HrtMon</h4>
La d&eacute;tection en m&eacute;moire est relativement s&ucirc;re. Je pense que cela fonctionne pour les versions &agrave; venir. Attention si le MMU est utilis&eacute; par WHDLoad: ne pas acc&eacute;der &agrave; des zones en dehors des zones m&eacute;moires valides (m&eacute;moire de base, extension, slave, ...). Cela plante car HrtMon ne g&egrave;re pas les exceptions de violation d'acc&egrave;s.


<p>Dans le programme de préférence HRTmonPrefs, vous devez activer l'option 'No VBR move'. Sinon vous ne pourrez
 pas entrer dans le monitor lors de l'exécution de WHDLoad.
<p>Après avoir été dans HRTMon, le programme sous WHDLoad peut afficher un écran graphique incorrect. Ceci
peut arriver car HRTMon écrit quelques informations dans les registres DMA. Vous pouvez contourner ceci en
disant à HRTMon d'écrire la valeur adéquate, par exemple utilisez <tt>'e $100 $5200'</tt> pour afficher un écran de 32
couleurs avant de retourner dans le programme installé.
<h4>ThrillKill</h4>
Il n'y a pas de signature utilisable dans le moniteur, aussi, des comparaisons de code sont utilis&eacute;es. Du coup, la d&eacute;tection ne fonctionnera pas avec d'autres versions.
</BODY>
</HTML>
