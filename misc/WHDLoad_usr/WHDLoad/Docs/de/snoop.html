<HTML>
<HEAD>
<TITLE>Snooping</TITLE>
<meta name="DC.Language" content="de">
<meta http-equiv="content-language" content="de">
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
<!-- $Id: snoop.html 1.5 2004/04/07 19:36:16 wepl Exp wepl $ -->
</HEAD>
<BODY>
<h3>Snooping</h3>
<h4>Was ist Snooping?</h4>
Snooping ist die F&auml;higkeit von WHDLoad Zugriffe auf Custom- und Cia-Register zu validieren und zu protokollieren. Wenn <a href="opt.html#Snoop">Snoop</a> aktiviert ist, f&uuml;hren alle ung&uuml;ltigen oder nicht erlaubten Zugriffe zu einem Access Fault und das installierte Programm wird beendet. Solche Zugriffe sind:
<ul>
<li>Zugriffe auf nicht existierende Register
<li>Lesezugriffe auf Nur-Schreib-Register
<li>Schreibzugriffe auf Nur-Lese-Register
<li>Zugriffe auf Early-Read-Register
<li>Byte-Schreibzugriffe (au&szlig;er <tt>bltcon0l</tt> und <tt>aud*vol+1</tt>)
</ul>
Strobe-Register k&ouml;nnen gelesen und geschrieben werden. Die Liste der erlaubten Custom-Register kann auf OCS (Old ChipSet - A500, A1000, alte A2000), ECS (Enhanced ChipSet - A600, neue A2000, A3000) und AGA (Advanced Graphics - A1200, A4000) eingestellt werden. Dies ist insbesondere sinnvoll um Fehler in alten Programmen zu lokalisieren, die durch Zugriffe auf neue AGA Register verursacht werden.
<h4>Wie es funktioniert</h4>
Wenn Snoop eingeschalten ist, markiert WHDLoad den Bereich der Custom- und Cia-Register als ung&uuml;ltig im MMU-&Uuml;bersetzungsbaum. Dadurch verursacht jeder Zugriff auf solch eine Adresse eine Access Fault Exception. Der Exception-Handler in WHDLoad bearbeitet diese Exception. Zuerst &uuml;berpr&uuml;ft er, ob die zugegriffene Adresse erlaubt ist. Wenn nicht wird das installierte Programm beendet. Wenn der Zugriff erlaubt ist und eine Leseoperation ist, wird der Zugriff emuliert und die normale Programmausf&uuml;hrung fortgesetzt. Bei einer Schreiboperation speichert WHDLoad zus&auml;tzlich den geschriebenen Wert intern ab.
<br>Wegen dem Zusatzaufwand f&uuml;r die Exception, die &Uuml;berpr&uuml;fung und die Emulation, verlangsamt sich die Ausf&uuml;hrungsgeschwindigkeit des installierten Programmes. Wie intensiv diese Verlangsamung ist, h&auml;ngt von dem Prozessor, dem Speichertyp (16/32-Bit) und der Stackpointer-Ausrichtung (LongWord aligned oder nicht) bei 32-Bit Speicher ab. Sie h&auml;ngt auch von der Art des Zugriffes (Byte/Word/LongWord, Read/Write) ab. Auf dem 68030 sind Schreibzugriffe schneller als Lesezugriffe (da die Stackframegr&ouml;&szlig;en unterschiedlich sind, Lesen 92 Byte, Schreiben 32 Byte). Auf dem 68060 sind Lesezugriffe schneller, weil die Emulation der Schreibzugriffe komplizierter ist.
<h4>Fast-Snoop Modus</h4>
Die Option <a href="opt.html#Snoop">Snoop/S</a> schaltet den schnellen Snoop Modus ein. Lesezugriffe werden in diesem Modus nicht mehr validiert. Auch werden keine speziellen &Uuml;berpr&uuml;fungen mehr durchgef&uuml;hrt. Dieser Modus ist hilfreich, wenn es nur darauf ankommt den Inhalt der Custom- und Cia-Register zu erfahren, z.B. um ein Bild mittels <a href="sp.html">SP</a> zu extrahieren.
<h4>Copper-Listen Scanner</h4>
Seit WHDLoad Version 13 werden auch die Inhalte von Copperlisten gepr&uuml;ft. Der Scanner wird aktiv bei Schreibzugriffen auf <tt>coplc</tt> wenn die Copper-DMA eingeschalten ist oder wenn das installierte Programm die Copper-DMA mit einem Schreibzugriff auf <tt>dmacon</tt> einschaltet. Der Scanner folgt den Copperlisten und pr&uuml;ft f&uuml;r jede Move Instruktion, ob die Restriktionen die durch die Snoop-Option (OCS/ECS/AGA) vorgegeben sind, eingehalten werden. Skip und Wait (au&szlig;er CEND) Instruktionen werden ignoriert. Wenn ein nicht erlaubter Eintrag gefunden wird, wird das installierte Programm beendet. Der Scanner folgt Spr&uuml;ngen (<tt>copjmp</tt>), entdeckt Schleifen und kann bis zu 16 Unterlisten untersuchen. Die Operanden der Move Instruktionen speichert WHDLoad in einer internen Tabelle. Der Scanner ist im Fast-Snoop Modus nicht aktiv.
<h4>Blitter Priorit&auml;ts &Uuml;berpr&uuml;fung</h4>
Wenn die Option ChkBltHog/S aktiv ist, &uuml;berwacht WHDLoad das installierte Programm dahingehend, dass dieses das <tt>BltHog</tt> Bit mittels eines Schreibzugriffes auf das <tt>dmacon</tt> Register nicht einschaltet. Die Blitter-Priorit&auml;t kann im Zusammenhang mit gro&szlig;en Blitteroperationen (alle Kan&auml;le verwendet) Probleme auf einigen Hardwarekonfigurationen bereiten.
<h4>Blitter Gr&ouml;&szlig;en &Uuml;berpr&uuml;fung</h4>
Wenn die Option ChkBltSize/S aktiv ist, pr&uuml;ft WHDLoad, dass keine Blitteroperationen gestartet werden, die Speicher au&szlig;erhalb des BaseMem-Bereiches betreffen. Bei Schreibzugriffen auf <tt>bltsize</tt> oder <tt>bltsizh</tt> wird getestet ob der Linienmodus in <tt>bltcon1</tt> eingestellt ist. Wenn dies der Fall ist, wird keine Gr&ouml;&szlig;enpr&uuml;fung durchgef&uuml;hrt. Ansonsten berechnet WHDLoad f&uuml;r jeden benutzten DMA-Kanal das erste und letzte durch den Blitter zugegriffene Wort. Wenn eines von beiden au&szlig;erhalb des BaseMem-Bereiches liegt wird das installierte Programm beendet und ein entsprechender Requester angezeigt. Die Berechnung ist so gestaltet, dass s&auml;mtliche Modi unterst&uuml;tzt werden (ascending/descending, positive/negative modulos, ungerade modulos/Zeiger).
<br>Beachtet werden sollte, dass der Linienmodus nicht validiert wird und das alle Blitter-Register auch mit dem Copper beschrieben werden k&ouml;nnen wenn <tt>copcon</tt> entsprechend gesetzt ist.
<h4>Blitter Warte &Uuml;berpr&uuml;fung</h4>
Wenn die Option ChkBltWait/S aktiv ist, benutzt WHDLoad eine Art Instruktionenverfolgung um festzustellen, ob das installierte Programm korrekt auf das Ende von Blitteroperationen wartet bevor es neue Blitterjobs startet. Es wird dabei eine interne Variable verwendet, die den aktuellen Status des Blitters repr&auml;sentiert. Die Variable wird gesetzt, wenn ein Schreibzugriff auf <tt>bltsize</tt> oder <tt>bltsizh</tt> erfolgt und gel&ouml;scht bei einem Lesezugriff auf das <tt>dmaconr</tt> Register. Bei jedem Schreibzugriff auf ein Blitter-Register wird der Wert der internen Variable getestet. Wenn diese einen laufenden Blitter anzeigt, wird das installierte Programm terminiert und WHDLoad zeigt den PC der letzten gestarteten Blitteroperation zusammen mit den aktuellen Daten an.
<br>Zwei wesentliche Sachen sind zu beachten! Erstens werden Blitteroperationen initiiert durch den Copper nicht gepr&uuml;ft und zweitens meldet die Funktion bei der Verwendung von Blitter-Interrupts Fehler, ohne dass dies wirklich Fehler sind.
<h4>Zukunft</h4>
Es ist geplant solche Dinge wie Einfrieren und Ikonifizieren sp&auml;ter in WHDLoad zu implementieren. F&uuml;r diese Funktionen ist Snoop eine Voraussetzung. Deshalb sollten Installautoren ihre Installs mit dem Snoop Modus testen, um eine zuk&uuml;nftige Kompatibilit&auml;t ihrer Installs sicherzustellen.
<h4>Voraussetzungen</h4>
Eine MMU ist Voraussetzung f&uuml;r den Snoop Modus. Auch muss WHDLoad die MMU <a href="mmu.html#usercontrol">benutzen</a>, damit verbunden, muss die Option <a href="opt.html#MMU">MMU/S</a> auf 68030 Systemen eingeschalten sein.
<h4>Einschr&auml;nkungen</h4>
<ul>
<li>68020 + 68851
<ul>
<li>diese Hardware wird gegenw&auml;rtig nicht unterst&uuml;tzt
</ul>
<li>68030
<ul>
<li>keine bekannten Einschr&auml;nkungen
</ul>
<li>68040
<ul>
<li>diese Hardware wird gegenw&auml;rtig nicht unterst&uuml;tzt
</ul>
<li>68060
<ul>
<li><tt>movem</tt> Instruktionen k&ouml;nnen auf nicht erlaubte Register zugreifen, ohne das ein Access Fault ausgel&ouml;st wird; dies ist m&ouml;glich da nur der erste Speicherzugriff &uuml;berpr&uuml;ft wird
<li><tt>move &lt;Cia-/Custom-Register&gt;,sr</tt> wird fehlerhaft ausgef&uuml;hrt, wenn er versucht den Supervisor-Teil des Statusregisters zu ver&auml;ndern, der Supervisor-Teil bleibt immer unver&auml;ndert
<li>jeder <tt>(ssp)+</tt> oder <tt>-(ssp)</tt> in Verbindung mit einem Schreibzugriff auf ein Custom- oder Cia-Register kann nicht verarbeitet werden, WHDLoad entdeckt solche Zugriffe und terminiert mit einem entsprechenden Fehlerrequester
<li>Instruktionen, die auf zwei Custom- oder Cia-Register zugreifen (z.B. <tt>move.b ($dff006),($bfd800)</tt>), k&ouml;nnen nicht verarbeitet werden, WHDLoad terminiert in solch einem Fall mit einem entsprechenden Requester
</ul>
</ul>
</BODY>
</HTML>
