<HTML>
<HEAD>
<TITLE>Benutzung von resload_Protect#?</TITLE>
<meta name="DC.Language" content="de">
<meta http-equiv="content-language" content="de">
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
<!-- $Id: prot.html 1.5 2004/04/07 19:44:40 wepl Exp wepl $ -->
</HEAD>
<BODY>
<h3>Benutzung von resload_Protect#?</h3>
<h4>Theorie</h4>
Es gibt viele Situationen, bei denen es sehr hilfreich w&auml;re informiert zu werden, wenn das installierte Programm auf bestimmte Speicherzellen zugreift. Mithilfe der <a href="../../Autodoc/whdload.doc">resload_Protect#?</a> Funktionen ist es m&ouml;glich, bestimmte Speicherbereiche vor dem Lesen und/oder Schreiben durch den Prozessor zu sch&uuml;tzen. Sch&uuml;tzen meint dabei, dass jeder Zugriff auf ein solcherart markierten Bereich eine "Access Fault" Exception ausl&ouml;st, die in einem Fehlerrequester von WHDLoad angezeigt wird. Wenn ein Speicherbereich durch <a href="../../Autodoc/whdload.doc">resload_Protect#?</a> gesch&uuml;tzt wird, ver&auml;ndert WHDLoad die entsprechenden Kachel-Descriptoren im MMU-&Uuml;bersetzungsbaum. Dadurch generiert jeder Zugriff auf eine gesch&uuml;tzte <a href="mmu.html">Kachel</a> durch den Prozessor eine "Access Fault" Exception. Der Exception-Handler im WHDLoad pr&uuml;ft den Grund f&uuml;r jede Exception. Wenn der Grund ein Zugriff auf eine gesch&uuml;tzte Kachel war, aber die zugegriffene Adresse nicht in einem gesch&uuml;tzten Bereich lag, wird der Zugriff emuliert und die normale Programmausf&uuml;hrung fortgesetzt. Ansonsten wird das installierte Programm mit einem entsprechendem Fehlerrequester beendet. Zugriffe des Instruction-Stream (d.h. Zugriffe bei denen Prozessorcode geladen wird) werden immer emuliert, oder mit anderen Worten: die <a href="../../Autodoc/whdload.doc">resload_Protect#?</a> Funktionen &uuml;berwachen nur das Schreiben und Lesen von Daten.
<br>Dadurch, dass jeder Zugriff auf eine gesch&uuml;tzte Kachel (Kachelgr&ouml;&szlig;e gegenw&auml;rtig $1000 Byte) ein "Access Fault" generiert auch wenn der gesch&uuml;tzte Bereich nur eine Gr&ouml;&szlig;e von einem Byte hat, bedingt eine starke Verlangsamung der Ablaufgeschwindigkeit des installierten Programmes. Insbesondere wenn sich Programmcode auf derselben Kachel befindet. Wenn das installierte Programm sehr von seiner Ausf&uuml;hrungsgeschwindigkeit abh&auml;ngt, k&ouml;nnen sich Unterschiede in der Ausf&uuml;hrung ergeben. Es kann auch sein, dass einige Programme deshalb nicht mit resload_Protect zusammen arbeiten.
<h4>Beispiel: Codepr&uuml;fsummen</h4>
Wenn ein Spiel mit WHDLoad installiert werden soll, muss die original Laderoutine so ver&auml;ndert werden, dass sie nun WHDLoad nutzt um die Spieldaten zu laden. Einige Spiele verwenden Pr&uuml;fsummen &uuml;ber Codebereiche um festzustellen, ob der urspr&uuml;ngliche Code ver&auml;ndert worden ist. Solche Pr&uuml;fsummenroutinen sind manchmal nicht leicht zu finden. Unter Verwendung der <a href="../../Autodoc/whdload.doc">resload_Protect#?</a> Funktionen in WHDLoad ist dies aber ganz einfach! Alles was man tun sollte, ist die ver&auml;nderten Bytes mit Leseschutz zu versehen. Dadurch erzeugt jede Routine, die versucht eine Pr&uuml;fsumme zu berechnen indem sie die ge&auml;nderten Bytes liest, eine "Access Fault" Exception. Womit die entsprechende Routine identifiziert ist.
<h4>Einschr&auml;nkungen</h4>
Die Kachel, auf den der SSP zeigt, darf nicht gesch&uuml;tzt werden. Falls dies doch getan wird und eine Exception auftritt, f&uuml;hrt dies zu einem "Double Bus Fault", weil der Prozessor nicht in der Lage ist das Exception Stackframe zu schreiben. Nach einem "Double Bus Fault" ist nur noch ein Hardwarereset m&ouml;glich. WHDLoad prüft beim Setzen des geschützten Bereiches ob dieser sich mit dem aktuellen SSP überdeckt. Wenn dies der Fall ist, beendet es sich mit einer entsprechenden Fehlermeldung. Das hilft aber natürlich nicht wenn sich der SSP später ändert.
<ul>
<li>68020 + 68851
<ul>
<li>diese Hardware wird gegenw&auml;rtig nicht unterst&uuml;tzt
</ul>
<li>68030
<ul>
<li>3-Byte Operationen werden nicht unterst&uuml;tzt und resultieren in einem "Access Fault", solche Operationen treten auf, wenn versucht wird auf ein Langwort an einer ungeraden Kachelgrenze zuzugreifen (z.B. "<code>tst.l ($fff)</code>", wenn die Kachel ab Adresse $1000 gesch&uuml;tzt wurde), da dies auf einem 68000 nicht erlaubt ist, d&uuml;rfte das kaum Praxisrelevant sein
<li>"locked" Operationen ausgel&ouml;st durch <code>tas</code>, <code>cas</code> oder <code>cas2</code> werden nicht unterst&uuml;tzt und resultieren in einem "Access Fault", dies ist kein Problem da "locked" Operationen von der Amiga-Hardware ohnehin nicht unterst&uuml;tzt werden
</ul>
<li>68040
<ul>
<li>diese Hardware wird gegenw&auml;rtig nicht unterst&uuml;tzt
</ul>
<li>68060
<ul>
<li>nicht ausgerichtete Datenzugriffe werden nicht unterst&uuml;tzt und resultieren in einem "Access Fault", ein nicht ausgerichteter Zugriff ist ein Zugriff welcher &uuml;ber zwei Kacheln reicht (und mindestens eine davon gesch&uuml;tzt ist), zum Beispiel betrifft "<code>tst.l ($ffe)</code>" sowohl die Kachel $0..$fff als auch die Kachel $1000..$1fff, diese Einschr&auml;nkung kann ein Problem sein und in bestimmten F&auml;llen den Einsatz der resload_Protect Funktionen unm&ouml;glich machen, m&ouml;glicherweise wird diese Einschr&auml;nkung in einer sp&auml;teren Version behoben
<li>nicht ausgerichtete Codezugriffe resultieren in einem "Access Fault", wenn beide betroffenen Kacheln gesch&uuml;tzt sind, in der Regel sollten sich solche Konstellationen vermeiden lassen
<li>"locked" Operationen ausgel&ouml;st durch <code>tas</code> oder <code>cas</code> werden nicht unterst&uuml;tzt und resultieren in einem "Access Fault", dies ist kein Problem da "locked" Operationen von der Amiga-Hardware ohnehin nicht unterst&uuml;tzt werden
<li>Instruktionen die auf einer gesch&uuml;tzten Kachel liegen (und deshalb emuliert werden) und auf den Supervisor Teil des Status Registers zugreifen, werden abweichend ausgef&uuml;hrt, f&uuml;r diese Instruktionen ist das Trace-Bit immer 1 und die Interruptpriorit&auml;tsmaske immer 7, falls die Instruktion versucht den Supervisor Teil des Status Registers zu ver&auml;ndern, bleibt das ohne Auswirkung (d.h. der Supervisor Teil bleibt unver&auml;ndert)
<li><code>movem</code> Instruktionen k&ouml;nnen auf einen gesch&uuml;tzten Bereich zugreifen, ohne dass eine "Access Fault" Exception ausgel&ouml;st wird, dies ist m&ouml;glich da nur der erste Speichertransfer (erstes Wort oder Langwort) auf &Uuml;bereinstimmung mit dem gesch&uuml;tzten Bereich &uuml;berpr&uuml;ft wird
<li><code>move16</code> und Operationen mit doppelter Genauigkeit (FPU) werden nicht unterst&uuml;tzt und resultieren in einem "Access Fault"
<li>ein "<code>move (mem),(mem)</code>" mit &uuml;berlappender Quell- und Zieladresse, welcher eine Exception wegen nicht ausgerichteter Adresse erzeugt, wird fehlerhaft ausgef&uuml;hrt, zum Beispiel "<code>move.l ($ffc),($ffe)</code>" mit der gesch&uuml;tzten Kachel $1000..$1fff mit dem Speicher ($ffc)=$11112222, ($1000)=$33334444 vor der Ausf&uuml;hrung enth&auml;lt danach ($1000)=$11114444 und nicht $22224444
</ul>
</ul>
</BODY>
</HTML>
