<HTML>
<HEAD>
<TITLE>Το WHDLoad και το MMU</TITLE>
<meta name="DC.Language" content="gr">
<meta http-equiv="content-language" content="gr">
<meta http-equiv="content-type" content="text/html; charset=iso-8859-7">
<!-- $Id: mmu.html 1.1 2006/06/07 06:35:47 wepl Exp wepl $ -->
</HEAD>
<BODY>
<h3>Το WHDLoad και το Memory Managment Unit (MMU)</h3>
Ένα MMU περιέχεται στους ακόλουθους επεξεργαστές της οικογένειας 68000: 68030,
68040, 68060. Υπάρχουν επίσης και οι λεγόμενες EC εκδόσεις αυτών των επεξεργαστών
που έχουν ένα χαλασμένο, εκτός λειτουργίας MMU. Για παράδειγμα, όλες οι standard A4000/030
έχουν μόνο έναν 68EC030 CPU. Σε επιταχυντές τρίτων αυτό είναι διαφορετικό,
δείτε στις κατάλληλες οδηγίες για να μάθετε περισσότερα. Από όσο
γνωρίζω, όλοι οι 68040/68060 που μπήκαν ποτέ σε Amiga είναι πλήρης CPU και
περιέχουν ένα λειτουργικό MMU (γιατί το burstmode και η Zorro III απαιτεί MMU mapping του IO
space). Ο διαχωρισμός μεταξύ ενός πλήρης CPU και μίας έκδοσης EC δεν μπορεί να γίνει
με λογισμικό (τουλάχιστον σε αποδεκτό χρόνο). Οπότε ο χρήστης πρέπει να το κάνει αυτό
ορίζοντας τις <a href="#usercontrol">κατάλληλες επιλγογές</a> για το WHDLoad.
<br>Για τον 68020 υπάρχει ένα εξωτερικό MMU που ονομάζεται 68851, αλλά αυτό
προς το παρόν δεν υποστηρίζεται από το WHDload.
<h4>Χαρακτηριστικά ενός MMU και η χρήση του στο WHDLoad</h4>
Ο κύριος σκοπός του MMU είναι να μεταφράζει λογικές διευθύνσεις σε φυσικές
διευθύνσεις. Αυτό απαιτείται για virtual memory και ξεχωριστούς χώρους διευθύνσεων (για
παράδειγμα σε ένα προστατευόμενο σύστημα πολυ-διεργασιών). Ένα άλλο χαρακτηριστικό είναι ο ορισμός
ειδικών ιδιοτήτων όπως Supervisor Only, Write Protected και Caching mode για
κάθε φυσικό χώρο διεύθυνσης (σε βάση σελίδας, όπου μία σελίδα που χρησιμοποιείται από το WHDLoad
έχει μέγεθος 4096 bytes). Το WHDLoad δεν χρησιμοποιεί μετάφραση λογικής σε φυσική
διεύθυνση. Αλλά χρησιμοποιεί το MMU για <a href="#mem">προστασία μνήμης</a>, <a
href="cache.html">διαχείριση cache</a> και μερικά ειδικά χαρακτηριστικά  (<a
href="snoop.html">Snooping</a>, <A
HREF="../../Autodoc/whdload.doc">resload_Protect#?</a>).
<h4><a name="mem">Προστασία μνήμης στο WHDLoad</a></h4>
Στην εκκίνηση, το WHDLoad σαρώνει τη λίστα μνήμης και δημιουργεί ένα δέντρο μετάφρασης
που συμπεριλαμβάνει όλη τη προσβάσιμη μνήμη. Σημειώνει τους ακόλουθους χώρους διευθύσεων ως
έγκυρους και προσβάσιμους: $0...BaseMem (χρησιμοποιώντας τις πληροφορίες από το Slave),
$dff000...$dff200 (Ειδικοί καταχωρητές), $bfd000...$bff000 (Καταχωρητές Cia) και
τη μνήμη που χρησιμοποιείται από το Slave και το WHDLoad. Εάν βρεθεί Freezer στη μνήμη, η
μνήμη που χρησιμοποιείται από το Freezer θα σημειωθεί επίσης ως έγκυρη. Όλη η υπόλοιπη μνήμη
σημειώνεται ώς άκυρη, και συνεπώς κάθε πρόσβαση σε τέτοια περιοχή (Read ή Write)
θα δημιουργήσει μία εξαίρεση Access Fault Exception που θα τερματίσει με ένα κατάλληλο
επιλογέα σφάλματος που θα δημιουργηθεί από το WHDLoad.
<h4><a name="usercontrol">Έλεγχος χρήστη του χειρισμού του MMU στο WHDLoad</a></h4>
Υπάρχουν 3 διαφορετικά modes για το πως το WHDLoad επηρρεάζει ένα MMU.
<ol>
<li><b>αγνόηση MMU</b>:<br>
Σε αυτή τη κατάσταση το WHDLoad δεν αλλάζει κανένα καταχωρητή που σχετίζεται με το MMU.
Αυτό μπορεί να είναι χρήσιμο αν έχετε προγράμματα που χτυπούν το MMU να τρέχουν και θέλετε
οι λειτουργίες αυτών των προγραμμάτων να παραμείνουν άθικτες (για παράδειγμα ένα
freezer λογισμικού όπως το TK).
<br>
Προειδοποίηση: Επειδή το WHDLoad δεν ελέγχει το MMU μόνο του είναι πιθανά
πολλά προβλήματα. Αυτά τα προβλήματα μπορεί να προκαλέσουν δυσλειτουργίες, ή άλλες
απρόβλεπτες συμπεριφορές. Παρακάτω είναι μία λίστα υπαρκτών ρίσκων:
<ul>
<li>τρέχοντας Enforcer/CyberGuard ή αντίστοιχα εργαλεία θα παγώσει/παρουσιάσει crash το μηχάνημα,
γιατί το WHDLoad θα δημιουργήσει πολλά Hits κάθε φορά που απενεργοποιεί και ενεργοποιεί το OS.
Αυτά τα Hits δεν είναι bugs του WHDLoad αλλά μέρος της κανονικής του λειτουργίας.
<li>νεότερες εκδόσεις της 68060.library (ξεκινώντας με τη v41.1) θα προωθήσουν τη μνήμη
$0-$1000 (τη πρώτη σελίδα) σε μία περιοχή μνήμης της Fast χρησιμοποιώντας το MMU, στη κατάσταση "αγνόηση
MMU" αυτή η μετάφραση μνήμης θα παραμείνη άθικτη, αν το εγκατεστημένο πρόγραμμα
προσπαθήσει να χρησιμοποιήσει αυτή τη περιοχή για λειτουργίες DMA (π.χ. ένα copperlist σε αυτή
τη περιοχή) τα αποτελέσματα θα είναι απρόβλεπτα, γιατί το CPU θα διαβάσει/γράψει στη περιοχή
μνήμης της Fast ενώ τα DMA στην πραγματική μνήμη Chip που περιέχει
τυχαία δεδομένα.
<li>εάν τα τρέχοντα πράγματα του MMU εξαρτώνται στο χειριστή εξαιρέσεών του (εξαίρεση "Access Fault")
η επιλογή <a href="http://www.whdload.de/docs/en/opt.html#NoTrapHandler">NoTrapHandler/S</a>
πρέπει να ενεργοποιηθεί, διαφορετικά κάθε εξαίρεση που συμβαίνει θα χειρίζεται από το
WHDLoad, που θα τερματίσει το εγκατεστημένο πρόγραμμα αν συμβούν ανεπιθύμητα πράγματα
<li>αν τα τρέχοντα πράγματα του MMU χρησιμοποιούν μνήμη (χειριστής εξαιρέσεων, δέντρο
μετάφρασης, ...) μέσα στη BaseMem του εγκατεστημένου προγράμματος, μπορεί να αποτύχει, γιατί η
BaseMem θα επανεγγραφεί κατά τη διάρκεια εκτέλεσης του εγκατεστημένου προγράμματος
(προσωρινά)
<li>γενικά κάθε πρόγραμμα που αλλάζει βασικές λειτουργίες του συστήματος (χρησιμοποιώντας
το MMU) μπορεί να συγκρουστεί με το WHDLoad ...
</ul>
<li><b>απενεργοποίηση MMU</b>:<br>
Σε αυτή τη κατάσταση, που είναι δυνατή μόνο σε 68030, το MMU θα απενεργοποιηθεί από το
WHDLoad, κανένα χαρακτηριστικό σχετικό με το MMU δεν θα είναι διαθέσιμο.
<li><b>χρήση MMU</b>:<br>
Σε αυτή τη κατάσταση το WHDLoad παίρνει το πλήρη έλεγχο του MMU και πραγματοποιεί
προστασία μνήμης και διαχείριση cache όπως εξηγείται παραπάνω.
</ol>
Στον 68030 η προεπιλεγμένη κατάσταση είναι <i>απενεργοποίηση MMU</i>. Στον 68040/68060 η προεπιλογή είναι <i>χρήση MMU</i>. Υπάρχουν δύο επιλογές για τον έλεγχο αυτής της συμπεριφοράς. <a href="http://www.whdload.de/docs/en/opt.html#MMU">MMU/S</a> αναγκάζει το WHDLoad να <i>χρησιμοποιήσει</i> το <i>MMU</i> και απαιτείται σε συστήματα με 68030 για να ενεργοποιηθούν όλα τα χαρακτηριστικά του MMU. <a href="http://www.whdload.de/docs/en/opt.html#NoMMU">NoMMU/S</a> απενεργοποιεί τη χρήση του MMU από το WHDLoad (<i>αγνόηση MMU</i>).
<center><p><cite>Ένα Enforcer hit είναι ένα Enforcer hit, τέλος.</cite> (Michael Sinz)</p></center>
</BODY>
</HTML>
