<html>

<head>
<title>Using resload_Protect#?</title>
<meta name="DC.Language" content="ru">
<meta http-equiv="content-language" content="ru">
<meta http-equiv="content-type" content="text/html; charset=windows-1251">
<!-- $Id: prot.html 1.5 2005/12/04 12:44:34 wepl Exp wepl $ -->
</head>

<body>

<h3>Использование функции resload_Protect *?</h3>

<h4>Теория</h4>

<p>Есть различные ситуации, при которых&nbsp; было бы
очень полезно получать информацию о том, что
установленная программа обращается к
определенным участкам памяти. С помощью функции <a
href="../../Autodoc/whdload.doc">resload_Protect *?</a>&nbsp; можно защищать
участки памяти от чтения и/или записи
процессором. Защита подразумевает, что каждый
доступ к такой защищенной области инициирует
исключительное событие &quot;Ошибка Доступа&quot;,
которое создаст соответствующее окно с
сообщением от WHDLoad. Если вы объявляете область
памяти защищенной, используя функцию <a
href="../../Autodoc/whdload.doc">resload_Protect *?</a>, то WHDLoad изменит
затронутые дескрипторы страниц в списке
перевода диспетчера памяти (MMU). Теперь при каждом
доступе к защищенной странице центральный
процессор будет инициировать исключительное
событие &quot;Ошибка Доступа&quot;. Обработчик
исключительных событий внутри WHDLoad проверит его
причину. Если причиной был доступ к защищенной <a
href="mmu.html">странице</a>, но доступ не тронул
защищенную область, то этот доступ будет
эмулироваться, и продолжится нормальное
выполнение программы. Иначе WHDLoad закончит работу
и выдаст соответствующее окно с сообщением. Если
происходит доступ к инструкции (т.е. центральный
процессор пытается загрузить код), то это всегда
будет эмулироваться, или иначе говоря, функция <a
href="../../Autodoc/whdload.doc">resload_Protect *?</a> затрагивает
только чтение и запись данных. Факт тот, что
каждый доступ к защищенной странице (в настоящее
время размер страницы равен $1000), создаст ошибку
доступа, даже если защищенная область имеет
длину всего 1 байт, в результате скорость
выполнения программы очень сильно упадёт.
Особенно, если части кода расположены на одной и
той же странице. Если программа зависит от
скорости выполнения, то возможна разница в
выполнении. Таким образом, возможен вариант, что
&nbsp; некоторые программы не будут работать с
защищенной памятью. </p>

<h4>Пример: контрольные суммы по коду</h4>

<p>Если вы устанавливаете игру, используя WHDLoad, вы
должны исправить в игре процедуры оригинальных
загрузчиков таким образом, чтобы они
использовали WHDLoad, для загрузки данных игры.
Некоторые игры выполняют подсчет контрольных
сумм в некоторых областях кода, чтобы определить,
не изменялся ли оригинальный код. Эти
подпрограммы проверки иногда очень трудно найти.
Но использование функции <a href="../../Autodoc/whdload.doc">resload_Protect
*?</a>&nbsp; в WHDLoad делает этот процесс очень легким.
Все, что вы должны сделать, это защитить от чтения
те байты, которые вы изменили в коде игры. Теперь
каждая подпрограмма, которая попробует
подсчитать контрольную сумму и прочитать ваш
исправленный код, создаст ошибку доступа. И вы
узнаете где расположена эта подпрограмма.</p>

<h4>Ограничения</h4>

<p>Вы не в коем случае не должны защищать участок
памяти, куда указывает SSP. Если вы всё же это
сделали, то произойдет Исключение, что приведёт к
двойной ошибке шины (Double Bus Fault), потому что
центральный процессор не сможет записать stackframe
исключения. После двойной ошибки шины должна
быть произведена перезагрузка для продолжения
работы. WHDLoad проверяет конфликт защищенной
области с SSP и заканчивает устраняет его, но это
не помогает, если SSP изменяется позже.

<ul>
  <li>68020 + 68851 <ul>
      <li>эта конфигурация в данный момент не
        поддерживается </li>
    </ul>
  </li>
  <li>68030 <ul>
      <li>3-байтовые передачи не поддерживаются и создают
        Ошибку Доступа, такие передачи будут возникать,
        если произойдёт обращение к &quot;длинному
        слову&quot; на нечетном адресе на границе страницы
        (например, &quot;<code>tst.l ($fff)</code> &quot; где защищена
        страница, начиная с адреса $1000). Т.к. это не
        применимо к процессорам 68000, то Вы скорее всего
        никогда не столкнётесь с подобной ситуацией.</li>
      <li>блокированные перемещения типа <strong><code>tas</code></strong>,
        <strong><code>cas </code></strong>или<strong><code> cas2</code></strong> не
        поддерживаются и создадут реальную Ошибку
        Доступа, но это не является проблемой, потому что
        эти команды не поддерживаются аппаратными
        средствами Амиги. </li>
    </ul>
  </li>
  <li>68040 <ul>
      <li>эта конфигурация в данный момент не
        поддерживается </li>
    </ul>
  </li>
  <li>68060 <ul>
      <li>Доступ к невыровненным данным не
        поддерживается и создаст Ошибку Доступа,
        невыровненный доступ - это доступ, который
        охватывает две страницы (и, по крайней, мере одна
        из них защищена), например, &quot;<code>tst.l ($ffe)</code> &quot;
        затрагивает страницу $0...$fff и страницу $1000...$1fff,
        это ограничение - настоящая проблема и является
        причиной того, что иногда невозможно
        использовать функцию <strong>resload_Protect</strong>. Я
        попытаюсь позже сделать поддержку этого, но это
        очень трудно. </li>
      <li>невыровненные доступы потоков инструкций не
        поддерживаются и создают реальную Ошибку
        Доступа, если обе затронутые страницы защищены. В
        большинстве случаев, такую ситуацию можно
        обойти.</li>
      <li>блокированные перемещения, вызванные <code>tas</code>
        или <code>cas</code> не поддерживаются и создают
        реальную Ошибку Доступа, но это не является
        проблемой, потому что эти команды не
        поддерживаются аппаратными средствами Амиги.</li>
      <li>инструкции, которые находятся на защищенной
        странице (следовательно, эмулируемые) и доступ к
        функциям supervisor'а регистра статуса, будут
        выполнены неправильно, эти инструкции будут
        всегда видеть что <strong>trace bit</strong>&nbsp; выставлен в 1,
        а маска приоритета прерывания выставлена в 7,
        поэтому любое изменение функций supervisor'а не будет
        иметь никакого эффекта (т.е. supervisor останется без
        изменений). </li>
      <li><code>инструкция <strong>movem</strong></code>&nbsp; может
        получить доступ к защищенной области, не
        создавая исключение &quot;Ошибка Доступа&quot;, это
        возможно, потому что только первое обращение
        (слово или длинное слово) будет проверено на
        соответствие защищенной области.</li>
      <li><code>инструкция <strong>move16</code> </strong>и операции с
        плавающей запятой (FPU) не поддерживаются и
        создают Ошибку Доступа.</li>
      <li>Команда &quot;<code>move (mem),(mem)</code>&quot; с
        перекрывающимися адресами источника и
        назначения, создаёт Ошибку Доступа, т.к. Misalignment
        будет выполняться некорректно, например &quot;<code>move.l
        ($ffc), ($ffe)</code>&quot;, где страница $1000...$1fff защищена и
        память перед выполнение содержит ($ffc) =$11112222, ($1000)
        =$33334444, а после выполнения, $1000 содержит $11114444, а не
        $22224444.</li>
    </ul>
  </li>
</ul>
</body>
</html>
