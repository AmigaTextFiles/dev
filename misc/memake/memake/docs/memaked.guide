@DATABASE MEMake
@$VER: MEMake.GUIDE 2.0 (30.01.1997)

@NODE Main "Übersicht"

	Anleitung zu MEMake V2.0 (30.01.1997)

	- @{" Rechtliches/Autor   " LINK "Recht"}
	- @{" Voraussetzungen     " LINK "Voraus"}
	- @{" Wozu?               " LINK "Wozu"}
	- @{" Bedienung           " LINK "Bedienung"}
	- @{" Makefile            " LINK "Makefile"}
	- @{" ARexx-Port          " LINK "ARexx"}
	- @{" Konfiguration/Prefs " LINK "Config"}
	- @{" Geschichte/Zukunft  " LINK "Geschichte"}

	Ob das Programm weiterentwickelt wird, hängt davon
	ab, ob ich ein Rücklauf dazu bekommen. Ich nutze das
	Programm zwar selber und ich habe noch selbst einige
	Verbesserungsideen, aber die Weiterentwicklung kostet
	auch eine Menge Zeit, die ich nur für mich alleine nicht
	aufbringen möchte (und kann).

@ENDNODE

@NODE Recht " Rechtliches/Autor"

	MEMake ist Giftware, sollten Sie also das Programm nutzen
	müßen Sie mir ein Geschenk zukommen lassen (z.B. Geld, 
	Regestration zu Ihren Shareware-Prg., usw.).

	Alle Rechte an MEMake bleiben bei mir!

	Die Benutzung des Programmes geschieht auf EIGENE GEFAHR!
	Sollte das Programm also Schäden jeglicher Art verursachen
	Hafte ich NICHT dafür!!

		   MEMake © Malte Eller,1995-1997

			Malte Eller
			Allensteiner Ring 15
			23879 Mölln

	Konto:  Volksbank Moelln, BLZ: 23092706,
		Konto NR. 1308250, Malte Eller

	Internet: http://www.informatik.mu-luebeck.de/~eller
	EMail: eller@informatik.mu-luebeck.de

@ENDNODE

@NODE Voraus " Voraussetzungen"

	MEMake braucht mindestens OS 2.0. Ansonsten sollte
	das Programm auf jedem AMIGA laufen.
	(ab OS2.1 wird die Locale-Library unterstüzt)

	Getestet auf:
	MEMake konnte leider nur auf einem AMIGA 500 (OS2.1, 3 MB
	RAM, 520 MB AT-Festplatte) getestet werden.


@ENDNODE

@NODE Wozu " Wozu??"

	MEMake ist ein Makeutility in Form eines Commodity, natürlich
	mit GUI. MEMake kann zu einer Schaltzentrale fürs Programmieren
	gemacht werden, z.B. können alle benötigten Programme von hier
	gestartet werden, usw.


@ENDNODE

@NODE bedienung " Bedienung"

	Dürfte eigentlich klar sein...,	aber allgemein gilt:
	
	Die Programme werden übrigens Asynchron gestartet, ein
	weiterarbeiten ist also möglich.
	Zudem werden die Fenster Tools und Info ebenfalls "ausgekoppelt"
	d.h. sie gleichzeitig zum Hauptfenster geöffnet sein und
	benutzt werden (das Parameter und Neu-Fenster dagegen nicht
	und während ein Requester offen ist natürlich auch nicht).
	Mit der Tab-Taste kann zwischen den Fenster gesprungen werden.

	Wenn es neben dem Stringgadget die Möglichkeit gibt direkt einen
	Filerequester zu öffnen (z.B. Makefile im Hauptfenster), dann
	kann aus dem Stringgadget mit der HELP-Taste der Filerequester
	geöffnet werden.

	- @{" Hauptfenster " LINK "Hauptfenster"}
	- @{" Toolsfenster " LINK "Toolsfenster"}
	- @{" Infofenster  " LINK "Infofenster"}
	- @{" Prefsfenster " LINK "Prefsfenster"}
	- @{" Neufenster   " LINK "Neufenster"}
	- @{" Parameterfe. " LINK "Parameterfenster"}
	
@ENDNODE

@NODE Hauptfenster " Hauptfenster"

	Die eigentliche Schaltzentrale.

	Gadgets:
	- File
	 das aktuelle Makefile
	- Module
	 die im @{"Makefile" LINK "Makefile"} enthaltenen Komponeneten
	- Info
	 öffnet ein Fenster, indem mehrere @{"Infos" LINK "Infofenster"} zum Project ausgegeben
	- Tools
	 öffnet ein Fenster, indem mehrere Tools zur verfügung stehen
	 (@{"Toolsfenster" LINK "Toolsfenster})
	
	Die anderen Gadgets werden in den @{"Prefsfenster" LINK "Prefsfenster"} mit Funktion ausgefült,
	diese Gadgets können auch mit den Tasten 1,2,...,0 angesprochen werden.
	 
	Menüs:
	- Klar oder?	

@ENDNODE

@NODE Infofenster " Infofenster"

	In diesem Fenster werden folgende Informationen ausgegeben:
	- Aktuelles Directory
	- Aktuelles Makefile
	- Größe des Programms in Byte
	- Freier Systemspeicher
	- Anzahl der Module aus dem das gesamte Project besteht

	Gadgets:
	- Ok
	 schließt das Fenster
	 
	Menüs:
	- Ok
	 schließt das Fenster
	- Verbergen
	 verbirgt das gesamte Commodity
	- Quit
	 beendet das gesamte Commodity

	Die angezeigten Daten werden jedesmal, wenn das Fenster
	aktiviert wird oder in dem Fenster eine Taste gedrückt
	wird, o.ä. aktualisiert. (Ich denke das reicht)

@ENDNODE

@NODE Neufenster " Neufenster"

	In diesem Fenster wird eine Buttonaktion, oder
	ein Toolseintrage festgelegt.
	
	Gadgtes:
	- Buttontext
	 Text der in der Toolsliste bzw. im Button angezeigt wird
	- Befehl
	 die Aktion die daraufhin ausgeführt wird
	 (die speziellen Befehle siehe @{"Befehl" LINK "Befehl"})
	- Console
	 da sie Befehle als CLI/Shell ausgeführt werden, muß eine
	 Console angegeben werden in der sie ablaufen.
	 (Standartmäßig ist das Flag Auto angegeben, d.h. die Console
	 öffnet sich nur, wenn das gestartete Prg. dort etwas ausgeben
	 möchte)
	- Ok
	 schließt das Fenster, die Eingaben werden übernommen
	- Abbruch
	 schließt das Fenster, die Eingaben werden vergessen
	
	Menüs:
	- Abbruch
	 schließt das Fenster, die Eingaben werden vergessen
	- Verbergen
	 verbirgt das gesamte Commodity
	- Quit
	 beendet das gesamte Commodity

@ENDNODE

@NODE Befehl " Befehl"

	Bei den Befehlen könne mehrere Parameter angegeben werden,
	da wären:
	
	- &d oder &D
	 der Pfad aus dem Makefile wird in den String eingebaut
	 
	 z.B. List &d listet das Verzeichnis des im MF angegebenen
	 Pfades auf

	- &a oder &A
	 beim Start werden sie zusätzlichen Parameter abgefragt und
	 eingebaut (siehe @{"Paramterfenster" LINK "Paramterfenster"})
	
	- &n oder &N
	 der Namen des Projectes wird eingesetzt (TO=...)
	
	- &l oder &L
	 die FROM=... Angaben werden eingebaut
	 
	 z.B. BLink &L.o TO &N ergibt z.B.
	 BLINK MEMake.o MEMake.win.o TO MEMake
	 
	- &P
	 startet das gerade im Module-Listview selektierte File,
	 ohne Test ob das Archiveflag gesetzt ist
	
	- &p
	 startet das gerade im Module-Listview selektierte File,
	 mit Test ob das Archiveflag gesetzt ist, danach wird es
	 gesetzt
	
	- &s
	 die FROM... Angaben werden nach einander eingegeben, d.h.
	 z.B. AMS &s ->
	 1. asm memake.s
	 2. asm memake.win.s
	 (mit Test ob Archivfalg gesetzt ist)

	- &S
	 die FROM... Angaben werden nach einander eingegeben, d.h.
	 z.B. ASM &S ->
	 1. asm memake.s
	 2. asm memake.win.s
	 (ohne Test ob Archivfalg gestezt ist)

	- &t
	 die FROM... Angaben werden nach einander eingegeben, d.h.
	 z.B. ASM &t ->
	 1. asm memake.s
	 2. asm memake.win.s
	 (mit Test ob Archivfalg gesetzt ist, und mit Test ob das
	  File überhaupt vorhanden ist)

	(WICHTIG: Hier wird der Start nicht Asyncron gestaltet, die
	Befehle werden nach einander ausgeführt)

	- &T
	 die FROM... Angaben werden nach einander eingegeben, d.h.
	 z.B. ASM &T ->
	 1. asm memak
	 2. asm memake.win.s
	 (ohne Test ob Archivfalg gesetzt ist, aber mit Test ob das
	  File überhaupt vorhanden ist)

	(WICHTIG: Hier wird der Start nicht Asyncron gestaltet, die
	Befehle werden nach einander ausgeführt)

@ENDNODE

@NODE Parameterfenster " Parameterfenster"

	Wird der &a in einem Befehlsstring angegeben öffnet
	sich dieses Fenster und zusätzliche Parameter können
	angegeben werden.

	Gadgets:
	- Parameter
	 hier wird der Parameter eingegeben
	- Starten
	 startet nun den Befehl
	- Abbruch
	 bricht den Start ab
	
	Menüs:
	- Abbruch
	 bricht den Start ab
	- Verbergen
	 verbirgt das gesamte Commodity
	- Quit
	 beendet das gesamte Commodity

@ENDNODE


@NODE Makefile " Makefile"

	Das Makefile kann folgende Schlüsselwörter enthalten

	- DIR=
		In diesem Pfad läuft alles ab, z.B.:
		DIR=DH2:Assembler/Quelltexte/MEMake
		(wird DIR nicht angegeben, so wird das gerade aktuelle
		 Verzeichnis angenommen)
	- TO=
		Name des Projectes, sollte VOR den einzelnen Modulen
		des Projectes kommen.
	- FROM=
		Namen der Module die zum Project gehören (getrennt
		durch ein <;>)
	- OTHERS=
		andere Programme die direkt im Hauptfenster angezeigt
		werden sollen, diese werden aber nicht mit in die
		Module-Liste aufgenommen
	- PREFS=
		gibt das Prefs-File an welches geladen werden soll
		(wird es nicht angegeben, bleibt natürlich das geladene
		Prefsfile aktiv) (wenn kein Pfad angegeben ist wird im 
		s: Verzeichnis danach gesucht).

	Kommentare können mit ";" oder "*" am Angfang der Zeile eingebaut
	werden, die Zeile wird dann ignoriert.

	z.B:
	*
	* Dies ist ein Testproject
	*
	DIR=Quelltexte:Test/
	TO=Test
	FROM=Test;Test.win

@ENDNODE

@NODE Config " Konfiguration/Prefs"

	MEMake kann in folgenden Bereichen geändert werden:
	
	- @{" Tooltypes " LINK "Tooltypes"}
	- @{" Cli/Shell " LINK "Shell"}
	- @{" Prefs     " LINK "Prefsfenster"}
	- @{" Tools     " LINK "Toolsfenster"}

@ENDNODE

@NODE Tooltypes " Tooltypes"

	Über das Icon des Programms können zum einen die Standard
	Eintragungen für ein Commodity (CX_POPUP,CX_PRIORITY,CX_POPKEY)
	unterstützt.

	Zudem kann mit PREFS= ein Prefsfile angegeben werden (wenn kein
	Pfad angegeben ist wird im s: Verzeichnis danach gesucht).

	Mit Name kann ein Makefile angegeben werden, dann wird das
	ext. im Prefsfile angegebe Makefile nicht geladen.
	
@ENDNODE

@NODE Shell " Cli/Shell"

	Beim Start können folgende Parameter übergeben werden:

	- P=Prefsfile
	  zu ladenes Prefsfile
	- M=Makefile
	  zu ladenes Makefile
	- N=NoIcon
	  wird dieser Schalter angegeben wird nicht versucht das
	  Icon auszulesen ( dieser Schalter ist bei Angabe eines
	  Prefsfile oder Makefiles überflüssig).
	  
	  Bei Shellstart ohne Parameter wird versucht das Icon
	  auszulesen.

@ENDNODE

@NODE Prefsfenster " Prefsfenster"

	Im Prefs-Fenster kann folgendes gemacht werden, die dann
	gespeichert werden können.

	Gadgets:
	- Buttontexte
	  hier sind die Einträge für die Gadgets aufgelistet,
	  mit einem darauf können die Einträge geändert werden
	- Ende Signal senden
	  Noch nicht unterstüzt!!
	- Letztes Proj. File laden
	 soll das zuletzt geladene File beim Ende abgespeichert
	- Project File
	 das Projectfile, welches beim Start geladen werden soll
	- Pfad zu den Makefiles
	 hier wird nach den Makefiles gesucht
	 ( ich finde es sinnvoll alle Makefiles in einem Verzeichnis
	  unterzubringen (z.B. Quelltexte:Makefiles) und in den Makefiles
	  dann denn Pfad anzugeben, in dem sich das Project befindet)

	Der Rest ist hoffentlich klar?

	- Sichern
	- Benutzen
	- Abbruch
	
	Menüs:
	- Project:
	 - Sichern
	 - Sichern Unter
	 - Laden
	 - Abbruch
	 - Verbergen
	 - Quit
	
	- Prefs:
	 - Standarteinstellung
	 - Auf zuletzt gesichertes
	 
@ENDNODE

@NODE Toolsfenster "Toolsfenster"

	Im Tools-Fenster kann folgendes gemacht werden:

	Gadgets:
	- ToolsListe
	  hier sind alle Programme aufgelistet, die gestartet
	  werden können
	- Starten
	  Startet das ausgewählt Tool (dies kann auch mit einem
	  Doppel-Klick auf den Eintrag geschehen)
	- Neu
	  fügt ein neues Tool der Liste hinzu
	- Abbruch
	  schließt das Fenster
	
	Menüs:
	- Sichert die Toolsliste (wichtig wenn neue Tools
	  hinzugefügt wurden)
	- Ändern
	  öffnet ein Fenster zum ändern des angewählten Tools
	- Löschen
	  löscht das gerade angewählt Tool aus der Liste
	- Abbruch
	  schließt das Fenster
	- Verbergen
	  verbirgt das gesamte Commodity 
	- Quit
	  beendet das gesamte Commodity

@ENDNODE

@NODE ARexx " ARexx-Port"

	MEMake hat einen kleinen ARexx-Port, zur Zeit mit folegenden
	Befehlen:

	- Show:
	  zeigt das Fenster
	- Hide:
	  versteckt es wieder
	- Quit:
	  beendet das Programm
	- LoadMake <Name.Make>:
	  lädt ein neues Project-File
	  (wenn kein Pfad angegeben ist wird im Pfad nachgeschaut welches
	  in den Prefs angegeben ist).
	- LoadPrefs <Name.Prefs>:
	  lädt ein neues Prefs-File
	  (wenn kein Pfad angegeben ist wird im s: Verzeichnis danach
	   gesucht).
	- Start <Name>:
	  startet ein Befehl (z.B. Start Linken)
	- Get <Nummer>:
	  gibt den Befehl mit der <Nummer> zurück (z.B. Get 3 -> Linken)
	- STool <Name>:
	  startet das Tool (z.B. Start SnoopDos)
	- GTool <Nummer>:
	  gibt das Tool mit der <Nummer> zurück
	
	Es wird in Zukunft noch die Befehle Info (Gibt die Infos zu
	einem Project zurück) und Make (gibt das Makefile zurück)
	und die Möglichkeit von MEMake aus ARexx-Befehle zu starten
	(d.h. z.B. ARexx-Scripts auf die Buttons legen)	geben.
	
@ENDNODE

@NODE Geschichte " Geschichte/Zukunft"

	Version 1.0:
	 erste veröffentlichte Version

	Version 1.1:

	Version 2.0: (30.01.1997)
	 - Komplett überarbeitet, hat nur noch wenig mit V1.1 zu tun

	Zukunft:
	- Fehlerbeseitigung
	- Bessere ARexx-Unterstützung
	- Alle Fenster parallel offen
	- mehr Paramtermöglichkeiten bei den Befehlen

	Ob das Programm weiterentwickelt wird, hängt davon
	ab, ob ich ein Rücklauf dazu bekommen. Ich nutze das
	Programm zwar selber und ich habe noch selbst einige
	Verbesserungsideen, aber die Weiterentwicklung kostet
	auch eine Menge Zeit, die ich nur für mich alleine nicht
	aufbringen möchte (und kann).

@ENDNODE

