
	IFND	WILTDCore
WILTDCore	SET	1

		STRUCTURE	WildTDCoreModuleBASE,wm_SIZEOF
			LABEL	wtdm_SIZEOF

_LVOSetUpTDCore		EQU	-42		; A0:App
_LVOCloseTDCore		EQU	-48		; A0:App
_LVORefreshTDCore	EQU	-54
_LVOTDCChildToBrother	EQU	-60		; A(B(?))=C(?) A0:A(Child),A1:B(Parent),A2:C(NewBrother)
_LVOTDCBrotherToChild	EQU	-66		; A(?)=C(B(?)) A0:A(Brother),A1:B(Brother,becomes Parent),A2:C(New child)
_LVOTDCRealyze		EQU	-72		; A0:App

; Notes about these structs, WROTE AFTER THE TYPE CONCEPT INTRODUCTION.
; If everything can change, with types, why these are fixed ?
; These are fixed because:
; - i think they are quite good, and won't need to be touched for a quite long time.
; - if also these change, what is fix in wild ? It would became a useless thing:
;   would not offer any standard.
; - the math I want is this.
; - these structs are also used by apps, directly and indireclty. So, if they change,
;   compatibility with the past is loss.
; - I WANT THESE STUPID NAMES TO BE USED BY THE WORLD !!!!! (shell,wire,NEBULA..! how long idiot may the mind of this coder be to call them like that?...)
; But, in fact, it's not true that these are not changeable.
; Soft changings, in fact, like using another math (floating point!?) may be done by
; using a new TYPE of TDCore. Nobody said the 32bit fields must be 16.16 or 32.0 integers. May be single precision floats.
; BUT, also the program calling WILD must know. Maybe using a TYPE flag also with applications.
; BUT, this may be the future. NOW, i don't want to think on.

		STRUCTURE	Vek,0
			LONG	vek_X
			LONG	vek_Y
			LONG	vek_Z
			LABEL	Vek_SIZE

		STRUCTURE	RAC,0
			STRUCT	Rel,Vek_SIZE
			STRUCT	Abs,Vek_SIZE
			STRUCT	Cam,Vek_SIZE
			LABEL	rac_SIZE
	
		STRUCTURE	Ref,0
			STRUCT	ref_O,rac_SIZE
			STRUCT	ref_I,rac_SIZE
			STRUCT	ref_J,rac_SIZE
			STRUCT	ref_K,rac_SIZE
			LABEL	Ref_SIZE
			
		STRUCTURE	Entity,MLN_SIZE
			STRUCT	ent_Ref,Ref_SIZE		
			APTR	ent_Parent			; points to parent entity
			APTR	ent_Tmp			; tmp data, specific for any entity, created freely by tdcores if they need. UNUSED DIRECTLY BY WILD!
			BYTE	ent_Flags
			BYTE	ent_RunTime
			LABEL	Entity_SIZE			

	BITDEF	ENRT,Absolute,0			; done the absolute ref.

		STRUCTURE	DotEntity,MLN_SIZE		; !! DotEntity may ONLY be child, not parent of nothing !
			STRUCT	den_Pos,Ref_SIZE		; Here there is only O, no i,j,k ! it's a dot !
			APTR	den_Parent
			APTR	den_Tmp
			BYTE	den_Flags
			BYTE	den_RunTime
			LABEL	DotEntity_SIZE	; NOTE: DotEntity&Entity have SAME STRUCT! Only data changes: the Pos has only the ref_O,no more.

	BITDEF	EN,DotEntity,0			; That's a dot entity. 
			
		STRUCTURE	Moving,0
			STRUCT	mov_V,Ref_SIZE
			STRUCT	mov_A,Ref_SIZE
			LABEL	Moving_SIZE
			
		STRUCTURE	Alien,Entity_SIZE
			STRUCT	ali_Sectors,MLH_SIZE			
			LABEL	Alien_SIZE
		
		STRUCTURE	Sphere,0
			STRUCT	sph_Center,Vek_SIZE
			LONG	sph_Radius
			LABEL	Sphere_SIZE
			
		STRUCTURE	Sector,Entity_SIZE
			APTR	sec_Shell
			APTR	sec_Wire
			APTR	sec_Nebula
			STRUCT	sec_Blinks,MLH_SIZE		; these are more bsp entries, not faces, may be bitmaps, lensflares, or more.
			STRUCT	sec_Bounds,Sphere_SIZE
		
		STRUCTURE	Arena,Alien_SIZE
			STRUCT	are_Aliens,MLH_SIZE
			STRUCT	are_Lights,MLH_SIZE
			STRUCT	are_ViewBounds,Sphere_SIZE	; Fuori da questa sfera, è invisibile l'arena
			STRUCT	are_InitBounds,Sphere_SIZE	; Quando si entra in questa sfera, l'arena viene inizializzata
			STRUCT	are_KillBounds,Sphere_SIZE	; Quando il player esce da questa sfera, l'arena viene tolta dalla memoria (deve essere + grande della init!)
			APTR	are_InitRoutine			; Questa routine inizializza l'arena.
			LABEL	Arena_SIZE
	
		STRUCTURE	World,0
			STRUCT	wor_Arenas,MLH_SIZE
			STRUCT	wor_SuperAliens,MLH_SIZE	; Aliens wich are always visualized, like the player.
			APTR	wor_Player			; Pointer to the player's alien, a SUPERALIEN!
			LABEL	World_SIZE						
		
		STRUCTURE	Scene,0
			APTR	sce_World			
			STRUCT	sce_Camera,Ref_SIZE
			LABEL	Scene_SIZE				

		STRUCTURE	BSPEntry,0
			APTR	bsp_Plus
			APTR	bsp_Minus
			BYTE	bsp_Flags			
			BYTE	bsp_RunTime
			BYTE	bsp_Type	
			BYTE	bsp_HoleFill00
			LABEL	bsp_SIZE

	BITDEF	BSP,DotEntry,0		;That's a dot entry: only 1 point, never split.
	
BSPTY_FACE	EQU	0
BSPTY_BITMAP	EQU	1
		
		STRUCTURE	Face,bsp_SIZE
			APTR	fac_PointA
			APTR	fac_PointB
			APTR	fac_PointC
			APTR	fac_EdgeA
			APTR	fac_EdgeB
			APTR	fac_EdgeC
			APTR	fac_Texture
			BYTE	fac_TXA
			BYTE	fac_TYA
			BYTE	fac_TXB
			BYTE	fac_TYB
			BYTE	fac_TXC
			BYTE	fac_TYC
			APTR	fac_Tmp
			LABEL	fac_SIZE
		
		STRUCTURE	DotEntry,bsp_SIZE	; Any dot entry must have this (to insert in a bsp tree...)
			APTR	dot_Point
			LABEL	dot_SIZE
					
		STRUCTURE	Edge,0
			APTR	edg_PointA
			APTR	edg_PointB
			BYTE	edg_Flags
			BYTE	edg_RunTime
			BYTE	edg_UseCount		; How many faces use this edge ?
			BYTE	edg_RTUseCount		; To fill this hole, use that.
			APTR	edg_Tmp	
			LABEL	edg_SIZE
				
		STRUCTURE	Point,0
			STRUCT	pnt_Vek,Vek_SIZE
			LONG	pnt_Color
			BYTE	pnt_Flags
			BYTE	pnt_RunTime
			APTR	pnt_Tmp
			LABEL	pnt_SIZE	
			
		STRUCTURE	Light,0
			APTR	lig_Point		; Point (from any nebula) of the lightsource
			LONG	lig_Color		; for who uses... (nb: rgb also define the intensity of the light: $7f0000 is half intense than $ff0000)
			WORD	lig_Intentiry		; if the engine does not support colorlights, this is used. (0-255) Usually is MAX(R,G,B) or (R+G+B)/3. Depending on your needings,try some values.
		
		STRUCTURE	DataBlock,0		; nebulas,shells and wires are that.
			LONG	dat_Num			; num of entities
			BYTE	dat_Flags
			BYTE	dat_RunTime
			LABEL	dat_Data

		STRUCTURE	Shell,dat_Data		; shell have the Root field...
			APTR	she_Root		; the root bspentry
			LABEL	she_Data		
		
DefAbs		MACRO 	;x,y,z (consts). Abs is x,y,z. Rel&Cam are 0
		dc.l	0,0,0
		dc.l	\1,\2,\3
		dc.l	0,0,0
		ENDM
		
DefRel		MACRO	;x,y,z (consts). Rel is x,y,z. Abs&Cam are 0
		dc.l	\1,\2,\3
		dc.l	0,0,0
		dc.l	0,0,0
		ENDM
							
QuickRefRel	MACRO	;x,y,z (consts). i,j,k are normal versors. (1,0,0 0,1,0 0,0,1)				
		DefRel	\1,\2,\3
		DefRel	1<<16,0,0
		DefRel	0,1<<16,0
		DefRel	0,0,1<<16
		ENDM

QuickRefAbs	MACRO	;x,y,z (consts). i,j,k normal versors. Used to define camera.
		DefAbs	\1,\2,\3
		DefAbs	1<<16,0,0
		DefAbs	0,1<<16,0
		DefAbs	0,0,1<<16
		ENDM	

;---------------------------------------------------------------------------------------
; Now there are the definitions of the Type 1 of Tmp buffers. That are the first I
; implement. My first TDCores will use these. If I'll find better things, i'll create
; a type 2,3,4... tmp buffers. The Light, the Broker willl receive this tmps, and they
; will REQUIRE them. That's to make an absolute compatibility but even a possibility
; to expand or totally rewrite in the future.
;---------------------------------------------------------------------------------------

		include	WildPJ:Include/Wild/tdcore_type1.i
		

	ENDC