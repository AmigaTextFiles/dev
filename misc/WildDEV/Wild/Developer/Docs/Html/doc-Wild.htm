<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Description" CONTENT="Important to program anything in the 3D world of Wild, and even to make objects to be used in Wild.">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (Win95; I) [Netscape]">
   <META NAME="Author" CONTENT="Pyper">
   <TITLE>Wild.library doc.</TITLE>
</HEAD>
<BODY TEXT="#FFFFFF" BGCOLOR="#000000" LINK="#FF0000" VLINK="#FF6600" ALINK="#FFCC33">

<CENTER>
<H3>
<FONT COLOR="#FFFF00">Wild.library doc...</FONT></H3></CENTER>
TABLE OF CONTENTS

<P><A HREF="#AddWildApp">wild.library/AddWildApp</A>
<BR><A HREF="#AddWildThread">wild.library/AddWildThread</A>
<BR><A HREF="#AllocVecPooled">wild.library/AllocVecPooled</A>
<BR><A HREF="#BuildWildObject">wild.library/BuildWildObject</A>
<BR>wild.library/DisplayFrame
<BR>wild.library/FindWildApp
<BR><A HREF="#FreeVecPooled">wild.library/FreeVecPooled</A>
<BR>wild.library/FreeWildObject
<BR>wild.library/GetWildAppTags
<BR><A HREF="#InitFrame">wild.library/InitFrame</A>
<BR>wild.library/LoadExtension
<BR><A HREF="#LoadFile">wild.library/LoadFile</A>
<BR>wild.library/LoadModule
<BR>wild.library/LoadTable
<BR><A HREF="#LoadWildObject">wild.library/LoadWildObject</A>
<BR>wild.library/KillExtension
<BR>wild.library/KillModule
<BR>wild.library/KillTable
<BR>wild.library/RealyzeFrame
<BR><A HREF="#RemWildApp">wild.library/RemWildApp</A>
<BR>wild.library/RemWildThread
<BR><A HREF="#SetWildAppTags">wild.library/SetWildAppTags</A>
<BR><A HREF="#--Tags--">wild.library/--tags--</A>
<BR><A HREF="#--BuildingTags--">wild.library/--Building tags--</A>
<BR>wild.library/--Display tags--
<BR><A HREF="#--LoadingTags--">wild.library/--Loading tags--</A>
<BR><A HREF="#--ObjectTags--">wild.library/--Object tags--</A>
<BR>wild.library/--Saving tags--
<BR>wild.library/--TDCore tags--
<BR><A HREF="#--WildAppTags--">wild.library/--WildApp tags--</A>
<BR><A HREF="#--ThreadTags--">wild.library/--WildThread tags--</A>

<P><A NAME="AddWildApp"></A><FONT COLOR="#FF6600">wild.library/AddWildApp</FONT>
<BR>NAME
<BLOCKQUOTE>AddWildApp</BLOCKQUOTE>
SYNOPSIS
<BLOCKQUOTE>wildapp = AddWildApp(WildPort,TagList);
<BR>D0 A0 A1
<BR>struct WildApp *AddWildApp(struct MSGPort *,struct TagItem *);</BLOCKQUOTE>
FUNCTION
<BLOCKQUOTE>Allocates a WildApp struct, and initializes it with the provided
tags. Not specified tags are set to wild's default. SetWildAppTags is called
by this function.</BLOCKQUOTE>
INPUTS
<BLOCKQUOTE>WildPort - A STD exec MSGPort, used to comunicate with wild
<BR>TagList - taglist to initialize the app.</BLOCKQUOTE>
RESULT
<BLOCKQUOTE>WildApp - a WildApp struct, used for everything in Wild.</BLOCKQUOTE>
SEE ALSO
<BLOCKQUOTE>RemWildApp,SetWildAppTags</BLOCKQUOTE>
<A NAME="AddWildThread"></A><FONT COLOR="#FF6600">wild.library/AddWildThread</FONT>
<BR>NAME
<BLOCKQUOTE>AddWildThread</BLOCKQUOTE>
SYNOPSIS
<BLOCKQUOTE>wildthread= AddWildThread(WildApp,TagList)
<BR>D0 A0 A1
<BR>struct WildThread *AddWildThread(struct WildApp *,struct TagItem *);</BLOCKQUOTE>
FUNCTION
<BLOCKQUOTE>Allocated a WildThread struct and starts the new thread.Note:
Your thread doesn't need to preserve any regs, or to manage any Process
Flag (those boring PRF_FreeCli,FreeOutput,Free??) because Wild manages
them for you. The WildThread structure is given to the Thread as input
in the A0 register: read there your Args (specified with WITH_Args tag.).
See tags definitions.</BLOCKQUOTE>
INPUTS
<BLOCKQUOTE>WildApp - A WildApp structure.
<BR>TagList - A TagList to init the Thread.</BLOCKQUOTE>
RESULT
<BLOCKQUOTE>WildThread - A WildThread structure.</BLOCKQUOTE>
SEE ALSO
<BLOCKQUOTE>RemWildThread</BLOCKQUOTE>
<A NAME="AllocVecPooled"></A><FONT COLOR="#FF6600">wild.library/AllocVecPooled</FONT>
<BR>NAME
<BLOCKQUOTE>AllocVecPooled</BLOCKQUOTE>
SYNOPSIS
<BLOCKQUOTE>memory = AllocVecPooled(memsize,pool);
<BR>D0 D0 A0
<BR>UBYTE *AllocVecPooled(memsize,pool);</BLOCKQUOTE>
FUNCTION
<BLOCKQUOTE>Allocates a chunk of memory from a memory pool, and keeps the
size and pool info there, so when you free you need only the chunk address,
not the size or the pool.</BLOCKQUOTE>
INPUTS
<BLOCKQUOTE>memsize = memory size needed.
<BR>pool = the pool to alloc from; now that's a normal exec pool, but you
should use only wild's pools: in the future I may expand them.</BLOCKQUOTE>
RESULT
<BLOCKQUOTE>memory = a memory block, or 0.</BLOCKQUOTE>
SEE ALSO
<BLOCKQUOTE>FreeVecPooled</BLOCKQUOTE>
<A NAME="BuildWildObject"></A><FONT COLOR="#FF6600">wild.library/BuildWildObject</FONT>
<BR>NAME
<BLOCKQUOTE>BuildWildObject</BLOCKQUOTE>
SYNOPSIS
<BLOCKQUOTE>object= BuildWildObject(tags)
<BR>D0 A0
<BR>void *BuildWildObject(struct TagItem *tags);</BLOCKQUOTE>
FUNCTION
<BLOCKQUOTE>That's a powerful function to create anything in the Scene.It's
quite low-level, is mainly used by the Loader modules when loading a scene-file.You
can use this func to create new objects or to modify existing.See tags
description.Then, you can specify ATTRS and FRIENDS, but not CHILDS. Those
are used to code Loader modules. See object tags definitions and build
tags definitions.</BLOCKQUOTE>
INPUTS
<BLOCKQUOTE>tags = A taglist defining the properties of the object to build
or modify.</BLOCKQUOTE>
RESULT
<BLOCKQUOTE>object = The modified or builded object.</BLOCKQUOTE>
SEE ALSO
<BLOCKQUOTE>FreeWildObject(),LoadWildObject(),objects.h</BLOCKQUOTE>
<A NAME="FreeVecPooled"></A><FONT COLOR="#FF6600">wild.library/FreeVecPooled</FONT>
<BR>NAME
<BLOCKQUOTE>FreeVecPooled</BLOCKQUOTE>
SYNOPSIS
<BLOCKQUOTE>FreeVecPooled(memoryblock)
<BR>A1
<BR>void FreeVecPooled(UBYTE *memoryblock);</BLOCKQUOTE>
FUNCTION
<BLOCKQUOTE>Frees a block of memory allocated with AllocVecPooled.</BLOCKQUOTE>
INPUTS
<BLOCKQUOTE>memoryblock = address of the memoryblock to free.</BLOCKQUOTE>
RESULT
<BLOCKQUOTE>None.</BLOCKQUOTE>
SEE ALSO
<BLOCKQUOTE>AllocVecPooled,exec.library/FreeVec</BLOCKQUOTE>
<A NAME="InitFrame"></A><FONT COLOR="#FF6600">wild.library/InitFrame</FONT>
<BR>NAME
<BLOCKQUOTE>InitFrame</BLOCKQUOTE>
SYNOPSIS
<BLOCKQUOTE>InitFrame(WildApp)
<BR>A0
<BR>void InitFrame(struct WildApp *wildApp);</BLOCKQUOTE>
FUNCTION
<BLOCKQUOTE>Inits a new frame, and currently does also engine manutention,
so refreshes it first of all.
<BR>Then, calls the Display's InitFrame() and the Draw's InitFrame().</BLOCKQUOTE>
INPUTS
<BLOCKQUOTE>wildApp = the WildApp to init the frame of.</BLOCKQUOTE>
RESULT
<BLOCKQUOTE>None.</BLOCKQUOTE>
SEE ALSO
<BLOCKQUOTE>DisplayFrame(),RealyzeFrame()</BLOCKQUOTE>
<A NAME="LoadFile"></A><FONT COLOR="#FF6600">wild.library/LoadFile</FONT>
<BR>NAME
<BLOCKQUOTE>LoadFile</BLOCKQUOTE>
SYNOPSIS
<BLOCKQUOTE>data = LoadFile(offset,name,pool)
<BR>D0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
D0&nbsp;&nbsp; D1&nbsp;&nbsp;&nbsp;&nbsp; A0
<BR>UBYTE *LoadFile(ULONG offset, char *name, struct Pool *pool);</BLOCKQUOTE>
FUNCTION
<BLOCKQUOTE>Loads the file specified by the name allocating the memory
from the specified pool. If no pool specified (passed 0) the wild pool
is used. You should always pass your's app pool.
<BR>The offset specifies the empty space at the start of the data block.
For example, if you have:
<BR>a file containing [0xAABBCCDDEEFF] and you specify offset = 0, the
data you get will be this: [0xAABBCCDDEEFF].
<BR>a file containing [0xAABBCCDDEEFF] and you specify offset = 8, the
data you get will be this: [0x0000000000000000AABBCCDDEEFF].
<BR>So, if you only want to load the file without putting a header then,
simply specify 0 for offset. I added the offset option simply because I
use internally this to load tables, so I have to load the data and then
fill the header with the Table struct.
<BR>Note: this function supports XPK packed data ! You can pass a packed
file, and will automatically be recognized and unpacked.
<BR>Note2: the data you get can be freed using FreeVecPooled, because it's
allocated with AllocVecPooled.</BLOCKQUOTE>
INPUTS
<BLOCKQUOTE>offset = data header space size;
<BR>name = pointer to filename string;
<BR>pool = pointer to an exec's Pool (NULL = use wild's pool);</BLOCKQUOTE>
RESULT
<BLOCKQUOTE>data = the data loaded from the file.</BLOCKQUOTE>
SEE ALSO
<BLOCKQUOTE>FreeVecPooled</BLOCKQUOTE>
<A NAME="LoadWildObject"></A><FONT COLOR="#FF6600">wild.library/LoadWildObject</FONT>
<BR>NAME
<BLOCKQUOTE>LoadWildObject</BLOCKQUOTE>
SYNOPSIS
<BLOCKQUOTE>object= LoadWildObject(wildapp,tags)
<BR>D0 A0 A1
<BR>void *BuildWildObject(struct WildApp *wapp,struct TagItem *tags);</BLOCKQUOTE>
FUNCTION
<BLOCKQUOTE>Loads an object from a filehandle, or using a readhook.Note
that the specified file (or filehandle, or readhook) must contain the object
you specified, not anything else.Usually, you should load a Level, or a
Scene, but you can also load Textures, or Aliens, or even Faces (but these
are untested). See also tags.
<BR>Then, add more ATTRS and FRIENDS, used as you specified. Note that
those will affect only the object you load, but not any other child: if
you load a scene, you cannot modify the world, the arenas, the aliens loeded
with it. You can only modify the scene. Note that the object you have is
made by BuildWildObject, so you can free it with FreeWildObject(); but
remember: FreeWildObject won't free the object's childs.</BLOCKQUOTE>
INPUTS
<BLOCKQUOTE>wildapp = your WildApp.
<BR>tags = taglist defining the file and the attrs of the object to load.</BLOCKQUOTE>
RESULT
<BLOCKQUOTE>object = a wildobject, or NULL if no object can be loaded.</BLOCKQUOTE>
SEE ALSO
<BLOCKQUOTE>BuildWildObject(),FreeWildObject(),objects.h</BLOCKQUOTE>
<A NAME="RemWildApp"></A><FONT COLOR="#FF6600">wild.library/RemWildApp</FONT>
<BR>NAME
<BLOCKQUOTE>RemWildApp</BLOCKQUOTE>
SYNOPSIS
<BLOCKQUOTE>RemWildApp(wildApp)
<BR>A0
<BR>void RemWildApp(struct WildApp *wapp);</BLOCKQUOTE>
FUNCTION
<BLOCKQUOTE>Removes the app from the list of Wild applications, frees all
the allocated memory (the pool), so levels, aliens, structs, anything.
Modules are kept, they are an independent list, and also tables. Also the
files loaded with LoadFileOffset() are flushed, if the wildApp's pool were
passed.</BLOCKQUOTE>
INPUTS
<BLOCKQUOTE>wildApp = The application to kill.</BLOCKQUOTE>
RESULT
<BLOCKQUOTE>None.</BLOCKQUOTE>
SEE ALSO
<BLOCKQUOTE>AddWildApp</BLOCKQUOTE>
<A NAME="SetWildAppTags"></A><FONT COLOR="#FF6600">wild.library/SetWildAppTags</FONT>
<BR>NAME
<BLOCKQUOTE>SetWildAppTags</BLOCKQUOTE>
SYNOPSIS
<BLOCKQUOTE>success = SetWildAppTags(WildApp,TagList)
<BR>D0 A0 A1
<BR>BOOL SetWildAppTags(struct WildApp *wapp,struct TagItem *tags);</BLOCKQUOTE>
FUNCTION
<BLOCKQUOTE>Modifies the application with the requested tags. You can specify
all the App tags (exceptions: the Pools ones, the pool is defined firstly
and then is always the same), and all the Modules tags, even the Module-specific
tags.
<BR>The tags are firstly changed in the WildApp's taglist (wap_Tags), then
are processed by Wild and then module by module, calling the SetModuleTags()
for anyone. Note that WildApp's taglist DOES NOT KEEP the module-specific
tags, but only the wild ones: for example, DrawDrScott module has some
specific tags. These must be tracked by the module.</BLOCKQUOTE>
INPUTS
<BLOCKQUOTE>WildApp = the WildApp to modify.
<BR>TagList = the tags to change it.</BLOCKQUOTE>
RESULT
<BLOCKQUOTE>success = if something went wrong, is 0. For now, no more specific
error codes.</BLOCKQUOTE>
SEE ALSO
<BLOCKQUOTE>AddWildApp(),wild.h</BLOCKQUOTE>
<A NAME="--Tags--"></A><FONT COLOR="#FF6600">wild.library/--tags--</FONT>
<BR>This section explains the tags used in Wild, grouped mainly by function.

<P><A NAME="--BuildingTags--"></A><FONT COLOR="#FF6600">wild.library/--Building
tags--</FONT>
<BR><FONT COLOR="#00EE00">WIBU_ObjectType</FONT>
<BR>(REQUIRED) The type of object to create/modify.One of those OBJECT_???.
<BR><FONT COLOR="#00EE00">WIBU_BuildObject</FONT>
<BR>If you want to create a NEW object, set this to true; you MUST also
give the WIBU_WildApp tag, when creating new things, because wild needs
to have memory from your pool.
<BR><FONT COLOR="#00EE00">WIBU_WildApp</FONT>
<BR>Pass your WildApp here, NEEDED when creating NEW objects.
<BR><FONT COLOR="#00EE00">WIBU_ModifyObject</FONT>
<BR>If you want to modify an existing object, pass it here. Obviously,
you CAN'T specify that with WIBU_BuildObject !!!

<P><A NAME="--LoadingTags--"></A><FONT COLOR="#FF6600">wild.library/--Loading
tags--</FONT>
<BR><FONT COLOR="#00EE00">WILO_ObjectType</FONT>
<BR>(REQUIDED) The type of object (OBJECT_???) to load.
<BR><FONT COLOR="#00EE00">WILO_FileName</FONT>
<BR>The filename to load. If you specify that, the file will be loaded
using dos.library. (in the future, also XPK support, but not now).
<BR><FONT COLOR="#00EE00">WILO_FileHandle</FONT>
<BR>Alternative, you can specify a filehandle of an already open file.
The file will be readed from the current position, no Seek(0) will be performed.
This allows you to read files step by step.
<BR><FONT COLOR="#00EE00">WILO_ReadHook</FONT>
<BR>Another alternative, you can specify a hook to be called to read from
anywhere: you can fake and read from mem, or using trackdisk, or anything
else. Hook convention: A0:Hook A1:Buffer to fill A2:Len to read.Your hook
should contain something like a file handle in the h_Data.
<BR><FONT COLOR="#00EE00">WILO_LoadedAttrsFirst</FONT>
<BR>Says to use first the attrs found in the file, and then, use yours
attrs to fill the ones not present in the file. If you specify FALSE this,
wild will first use your attrs and then fill the more needed with the ones
loaded from the file.

<P><A NAME="--ObjectTags--"></A><FONT COLOR="#FF6600">wild.library/--Object
tags--</FONT>
<BR><FONT COLOR="#66FFFF">Object tags conventions:</FONT>
<BR><FONT COLOR="#66FFFF">ATTR_&lt;OBJECT>_&lt;ATTRIBUTE> : &lt;OBJECT>
is the type of object that this tag affects. &lt;ATTRIBUTE> is the attribute
of the object that is modified, and can be a number or a pointer to a string
or a pointer to some data, but NOT a pointer to another Wild object: FRIENDS
and CHILDD are done for that. Example: ATTR_FACE_TXA.</FONT>
<BR><FONT COLOR="#66FFFF">FRIEND_&lt;OBJECT>_&lt;FRIEND> : &lt;OBJECT>
is the type of object which has this friend. &lt;FRIEND> is the name of
the attribute of the object that is modified, and MUST contain a pointer
to another Wild object, of a specific type. Example: FRIEND_FACE_PLUS is
to define the BSP-Tree node of a face, and needs a pointer to another face.</FONT>
<BR><FONT COLOR="#66FFFF">CHILD_&lt;OBJECT>_&lt;CHILD> : &lt;OBJECT> is
the type of object which has this child. &lt;CHILD> is the name of the
child that this object has, and MUST contain a pointer to another Wild
object, of a specific type. Example: CHILD_SCENE_WORLD specifies wich World
is child of the modified Scene.</FONT>

<P><A NAME="--WildAppTags--"></A><FONT COLOR="#FF6600">wild.library/--WildApp
tags--</FONT>
<BR><FONT COLOR="#00EE00">WIAP_???Module</FONT>
<BR>Specifies the module to load at startup for this application, of the
specified group. If some modules aren't specified, Wild won't load them:
some are not always needed, like Brokers or Light.
<BR><FONT COLOR="#00EE00">WIAP_BaseName</FONT>
<BR>That's the base name, used when a wild requester says about an app,
or in prefs handling (the prefs file for an application is in ENV:Wild/_&lt;BaseName>.prefs)
and should not have spaces in it, and should not be more than 16 chars.
<BR><FONT COLOR="#00EE00">WIAP_Name</FONT>
<BR>That's the name of the application, you can specify here the name,
even with spaces and everything you want.
<BR><FONT COLOR="#00EE00">WIAP_PrefsHandle</FONT>
<BR>If you specify that to TRUE, the application will have its prefsfile,
and this will override the tags you specify by default. That's HIGHLY recommenced,
because you NEVER know the best configuration for any target machine. So,
you should specify a veery basic configuration internally (like wireframe,
of flat shaded, and a friendly display). If you have some presets you like,
you can always save them with the WildPrefsEditor (when will come) and
include them in your program.

<P><A NAME="--ThreadTags--"></A><FONT COLOR="#FF6600">wild.library/--WildThread
tags--</FONT>
<BR><FONT COLOR="#00EE00">WITH_Args</FONT>
<BR>The args for the thread, to be read from the WildThread structure passed
to your thread routine.
<BR><FONT COLOR="#00EE00">WITH_Entry</FONT>
<BR>The initial PC of the thread: REQUIDED !
<BR><FONT COLOR="#00EE00">WITH_Name</FONT>
<BR>The name for the new thread. Default "Generic Wild Thread..."
<BR><FONT COLOR="#00EE00">WITH_Priority</FONT>
<BR>The new process priority. Default is 0.
<BR><FONT COLOR="#00EE00">WITH_Stack</FONT>
<BR>The stack size. Default 4096.
<BR><FONT COLOR="#00EE00">WITH_TimeOut</FONT>
<BR>The time to wait when killing for the task auto-killing, before killing
it roughly. So, when RemWildThread is called, will send the "KillYourSelf"
message, and will wait this ticks to see if the task kills itself, and
then will remove it by hand.

<P><A NAME="NONE"></A><FONT COLOR="#FF6600">wild.library/</FONT>
<BR>NAME
<BLOCKQUOTE>a</BLOCKQUOTE>
SYNOPSIS
<BLOCKQUOTE>a</BLOCKQUOTE>
FUNCTION
<BLOCKQUOTE>a</BLOCKQUOTE>
INPUTS
<BLOCKQUOTE>a</BLOCKQUOTE>
RESULT
<BLOCKQUOTE>a</BLOCKQUOTE>
SEE ALSO
<BLOCKQUOTE>a</BLOCKQUOTE>

</BODY>
</HTML>
