Animation Extension Project.

That's to do after a good GFX is done, or will be useless.
The animation must have:

- Paths for any sector: a path is a traslation and a rotation in a fixed time.
- x,Vx,Ax (and y,z,RI,RJ,RK).
  Any movement is defined by those initial conditions, or maybe only by some:
  for example, only Ax means to have a acceleration in x, if you are stopped
  but also if you are moving. For example, a car's action: stop ! should be a
  deceleration, not to set any V or x.
  A movement must stop when a condition is lacked.
  The condition may be: time expired, value reached (for any variable) or
  user-defined. So, there should be a queue of routines to check if the
  movement has to stop. This should be defined by an array like that:

  EXCHK_TIMEOUT,timeoutvalue,EXCHK_HADVALUE,var,value,EXCHK_USER,code,data,
  EXCHK_DONE.

  Something like a taglist, but more flexible: with all the params needed,
  not only one. There is no problem, because ALL the "tags" are supported,
  and no problems like "this tag is unknow, how can I skip it if I don't
  know how many args has ?".

  The action should stop also if a new action is said to be done.

- Tha functions to have:

DoAction()    Make the object(s) know to do the specified action, so must
              take the moment to do timed actions then. Can also stop
              precedent movements, if needed. Example: a kick of a fighter
              should stop if he hits the wall, and should start the new
              action "stop kick and take the leg down".

Animate()     Makes the object(s) move, so modifies the refs.
              An option to add: the instant made is the current, but there
              should be an option (a space in the structure) to add some
              time. An example: if you have to animate 10 objects sychronously,
              you have to call 10 times Animate(). But doing that, 10 different
              times are taken, and 10 different positions are showed in
              the display. So, the option should let you specify a specific time.
              This time should be calced to be exactly the moment of the display
              of the scene. So, a func should be provided, something like
              a CatchCalcTime() and CatchDisplayTime().
              So, before animating any object, you should call CatchCalcTime(),
              and this will:
              1) catch the current time =calctime.
              2) return the current time + the gap (see above)
              The CatchDisplayTime() should:
              1) catch the current time =displaytime.
              2) calc the gap: displaytime-calctime.
                 This may be calced also seeing precedent frames and doing
                 something like a median time, because this is supposed to
                 work when all frames have the same calc-render time, and
                 this is not true. So, a median can help to reduce strange
                 effects.

Catch...() said before.

LoadAnimation() Should load the animations for any object, from a std file:
                so, the LoaderModule must support also this.
                An extension to the loader should be performed.
                Something like a Extend format, with some things managed
                not only by wild but also from somewhere.
                And also wild should call extern routines when loading, so
                add something like a LoaderHandlerAdd func to wild.


NEW IDEAS....

AnimateSingle: ha il LastAnimShot che è lo shapshot dell'INIZIO dell'ultima Move fatta,
	       quindi deve: fare COMPLETAMENTE tutte le actions fino a quella attuale.
	       NO alle ottimizzazioni tipo se c'è SET non fare quelle indietro,..., sono
	       noiose, COMPLICATE e poco affidabili: ci sono un sacco di casi da fare.
	       Tanto fare una Move è abbastanza veloce...
	     
finalc=startc+t*startv+t*t*starta/2
finalv=startv+t*starta
finala=starta

opt:
deltav=t*starta
finalc=startc+t*startv+deltav*t/2
finalv=startv+deltav
finala=starta

(mul *3 più varie somme...) una Move sono 6 vars: 18 mul

Devo trovare il modo di trasformare I,J,K in Rx,Ry,Rz e definire quest'ultime in qualche
modo... Poi devo fare il contrario al momento giusto...


