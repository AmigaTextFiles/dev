
That's the first format i'll implement, and will be much like the META format.
The important thing is that is FAST and EXPANDIBLE.

Needed: Parent/Child features.

Format specs:
Very simple:

Everything is based on "command lines":

!?command/[args]

!	:is the line starter. My routine looks for this, not for $a
? 	:stands for control char. (determinates the type of line)
command :stands for the type of command defined.
/	:terminates the command. NO SPACES BETWEEN THE COMMAND AND THIS !!
	(a #Root/ and a #Root / and a # Root/ and a # Root / are ALL DIFFERENT
	THINGS !!)
[args] 	:the value of the command. If no value is needed, [] MUST BE USED!! 
	(my lineinput routine LOOKS FOR THEM !!)
args 	:NO MULTIPLE ARGS ARE ACCEPTED!! Please, i wait this format to be simple.
	So, if you have to specify a position, I want 3 lines (x,y,z) to be used, 
	not a complex Position line with 3 args. That's to make things easy.
	This format must be simple, not fast.

NB: Binary are not allowed: if you have to include something from out, use a command.

!#Root/[]
!#Level/[GoingNowhere]
!$Desc/[
Hello boyz!
Nice level, eh?
]
!-Level/[]
!-Root/[]

NB2: Multiple lines are allowed: the lineinput stops on ], not on $A.

If you want to insert comments, use a * line:

!*/[my opinion is that this is a bad thing because of the lack of foxxy]

This line will be ignored by the parser, but the lineinput always wants the / and [].

NB3: You can specify an object in multiple parts:

!#Root/[]
!#Level/[GoingNowhere]
!$Desc/[
Hello boyz!
Nice level, eh?
]
!-Level/[]
!#SomeTrash/[!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!]
!-SomeTrash/[]
!#Level/[GoingNowhere]
!$Author/[That's me!]
!-Level/[]
!-Root/[]

Here, the Level GoingNowhere is split in 2 parts, but the loader will give you
a single structure.

When loaded, you will receive from the loader the pointer to a struct containing
some useful info and the root node.

