@database
@REM Right block margin using helvetica: 152
@REM Right block margin using courier: 87

@index Hunks

@help Help

@node main "DropHunk 1.0 guide"
@font helvetica.font 13


DropHunk Version 1.0 (11/98)

DropHunk  is  a  Shell (CLI) only tool to list all AmigaDOS® segments of a binary load file or an AmigaDOS®
compatible binary object file, where one file segment is called a "hunk".

There   are  only  three  segments  required  to  produce  a  loadable  file,  which  can  be  executed  by  the
AmigaOS®. These three segments get arranged through these types:

	HUNK_CODE
	HUNK_DATA
	HUNK_BSS

Respectively  there  is  only  one  section required to produce an Amiga load file this is the HUNK_CODE. An
executable file will then look like this:

	HUNK_HEADER
	HUNK_CODE
	HUNK_END

Compilers and linkers will create another form of an Amiga executable file that could look like this:

	HUNK_HEADER

	HUNK_CODE
	HUNK_RELOC32
	HUNK_END

	HUNK_DATA
	HUNK_RELOC32
	HUNK_END

	HUNK_BSS
	HUNK_RELOC32
	HUNK_END

DropHunk  does  not  show the hunks HUNK_END and HUNK_BREAK because an output listing of an object-
or load file is better readable without these hunks.


DropHunk  does  not  print  any  faults  that  might  occur  (such as File Not Found) onscreen, instead a valid
return-code  is  made  for  the CLI; use the original Why command in your Command drawer to get the human
readable description of a possible DropHunk fault.


Also  some  hunk types that are currently not supported will abort the parsing of a load- or object file such as
HUNK_EXT in conjunction with EXT_COMMON.


To invoke DropHunk you call it from your CLI/Shell as:

DropHunk <path of file and filename itself>.

If the filename or the pathname contains spaces (blanks) use double quotes:

1> drophunk "work-II:app/src/exe/noisy silence"


To  run  DropHunk  you  need  an Amiga or Draco computer with at least Kickstart version 33 (Kikckstart / OS
1.2) or later. DropHunk will display any hunks it can handle even under OS 1.2 .


Any  person  &  company  can  use  DropHunk  without written permission from the author if no one makes me
held liable for any possible fault that might occur.


Any person may improve the enclosed source-code so long the original source-code remain to me. 

Author:

	Jörg van de Loo	("ONIX")
	Hövel 15
	47559 Kranenburg
	Federal Republic of Germany	(FRG)

@endnode



@node Hunks "List of AmigaDOS® supported hunks"
@font courier.font 13
 

@{"HUNK_UNIT        " link HUNK_UNIT}
@{"HUNK_NAME        " link HUNK_NAME}
@{"HUNK_CODE        " link HUNK_CODE}
@{"HUNK_DATA        " link HUNK_DATA}
@{"HUNK_BSS         " link HUNK_BSS}
@{"HUNK_RELOC32     " link HUNK_RELOC32}
@{"HUNK_RELOC16     " link HUNK_RELOC16}
@{"HUNK_RELOC8      " link HUNK_RELOC8}
@{"HUNK_EXT         " link HUNK_EXT}
@{"HUNK_SYMBOL      " link HUNK_SYMBOL}
@{"HUNK_DEBUG       " link HUNK_DEBUG}
@{"HUNK_END         " link HUNK_END}
@{"HUNK_HEADER      " link HUNK_HEADER}
 HUNK_Unknown		* unsupported - if you have information about this hunk, please tell me
@{"HUNK_OVERLAY     " link HUNK_OVERLAY}
@{"HUNK_BREAK       " link HUNK_BREAK}
@{"HUNK_DREL32      " link HUNK_DREL32}
@{"HUNK_DREL16      " link HUNK_DREL16}
@{"HUNK_DREL8       " link HUNK_DREL8}
@{"HUNK_LIB         " link HUNK_LIB}	*
@{"HUNK_INDEX       " link HUNK_INDEX}	*
@{"HUNK_RELOC32SHORT" link HUNK_RELOC32SHORT}
@{"HUNK_RELRELOC32  " link HUNK_RELRELOC32}	*
@{"HUNK_ABSRELOC16  " link HUNK_ABSRELOC16}	*

@{"EXT_SYMB     " link EXT_SYMB}
@{"EXT_DEF      " link EXT_DEF}
@{"EXT_ABS      " link EXT_ABS}
@{"EXT_RES      " link EXT_RES}
@{"EXT_REF32    " link EXT_REF32}
@{"EXT_COMMON   " link EXT_COMMON}
@{"EXT_REF16    " link EXT_REF16}
@{"EXT_REF8     " link EXT_REF8}
@{"EXT_DEXT32   " link EXT_DEXT32}		*
@{"EXT_DEXT16   " link EXT_DEXT16}		*
@{"EXT_DEXT8    " link EXT_DEXT8}		*
@{"EXT_RELREF32 " link EXT_RELREF32}		*
@{"EXT_RELCOMMON" link EXT_RELCOMMON}		*
@{"EXT_ABSREF16 " link EXT_ABSREF16}		*
@{"EXT_ABSREF8  " link EXT_ABSREF8}		*

(*) unsupported

@endnode

@node HUNK_UNIT	"Hunk type: HUNK_UNIT"
@font courier.font 13

A  HUNK_UNIT  is only used and allowed in Amiga object files or for an object file with
several parts, so called link-libs.
A  HUNK_UNIT  identifies  such  an  object  file, ready to use by an Amiga linker. This
hunk-type must be the first hunk of such a file.

Format:
	1st longword	HUNK_UNIT
	2nd longword	Length  of  name  for the complete file in used longwords
		for name or zero (no name)

	If second longword is non zero:
	9th byte	Starting with first character (letter)of name

	Due to the Amiga hunk-format the name must end at a longword boundary.

Example:
	00 00 03 E7
	00 00 00 03
	_ C p y L i b . a s m 00

Notes:
	There  is  no necessity to terminate the name of this string with a zero
	byte. The section name is not a C- neither a BCPL-string equivalent.

@endnode

@REM ----------------------------------------------------




@node HUNK_NAME "Hunk type: HUNK_NAME"
@font courier.font 13

The  HUNK_NAME  is  allowed in object- and load files. Usually it's used in object- and
linker-files only. It's used to give a file-section a name.

Format:	1st longword	HUNK_NAME
	2nd longword	Length  of  name  for  this section in used longwords for
		name or zero (no name)

	If second longword is non zero:
	9th byte	Starting with first character (letter) of name

	Due to the Amiga hunk-format the name must end at a longword boundary.

Example:
	00 00 03 E8
	00 00 00 02
	T E X T . A S M

Notes:
	There  is  no necessity to terminate the name of this string with a zero
	byte.
	The section name is not a C- neither a BCPL-string equivalent.

@endnode

@REM ----------------------------------------------------




@node HUNK_CODE "Hunk type: HUNK_CODE"
@font courier.font 13

The  HUNK_CODE  is  the  most  important hunk for load files although it occurs also in
object  files.
In  load  files  it should be the first hunk to load, starting the program at the first
used  word  of  this  hunk, usually the start-up-code or init routine. Thus it contains
the CPU instruction code set.

Format:
	1st longword	HUNK_CODE
	2nd longword	Amount  of used longwords containing the CPU instructions
		or zero (no CPU instructions)

	If second longword is non zero:
	5th word	Starting with first instruction

Example:
	00 00 03 E9
	00 00 00 01
	70 FF 4E 75

Notes:
	Due  to  the  Amiga  hunk-format  this  section  must  be completed at a
	longword  boundary  even  if there is one instruction less than required
	to  perform the longword boundary. In this case Assemblers and Compilers
	extent  such  a  section  automatically  with  a  zero  word, RTS or NOP
	instruction (00 00, 4E 75, 4E 71).

@endnode

@REM ----------------------------------------------------




@node HUNK_DATA "Hunk type: HUNK_DATA"
@font courier.font 13

Usually  a  HUNK_DATA contains static or initialised data. Often tables or even pointer
tables are located here or on the bad side un-initialised data remain here.

Format:
	1st longword	HUNK_DATA
	2nd longword	Amount of used longwords containing the data

	If second longword is non zero:
	9th byte	Starting with first data byte

Example:
	00 00 03 EA
	00 00 00 01
	O N I X

Notes:
	Due  to  the  Amiga  hunk-format  this  section  must  be completed at a
	longword  boundary  even  if there are less data to perform the longword
	boundary.  In  this  case  Assemblers  and  Compilers will extent such a
	section automatically with a zero word.

@endnode

@REM ----------------------------------------------------




@node HUNK_BSS "Hunk type: HUNK_BSS"
@font courier.font 13

A  HUNK_BSS  is  a  virtual  storage that is first present at runtime, which means that
only  the  size  of longwords that must be present at runtime is written along with the
file.  Thus  the memory area used at runtime is not initialised. This is only valid for
Kickstart  30  to  Kickstart  35.  With  Kickstart  36  the  DOS  library module got an
incredible  overhaul  and  therewith  some  changes.  Under Kickstart 36 (and of course
later  versions) it's guaranteed that a BSS memory area is zeroed before the program is
fired  up.  This  will  safe some instructions in the load file because the clearing of
that memory area isn't required to be done by the application itself.


Format:
	1st longword	HUNK_BSS
	2nd longword	The  amount of longwords that have to be allocated before
		the application is fired up.

Example:
	00 00 03 EB
	00 00 00 11

In  this  example  the  BSS  section is 17*4 bytes in size. Since this section contains
nothing, no more data get written to disk.
A  BSS  section  is  preferably used to hold variables that can be initialised first at
runtime, such as a library base pointer.

@endnode

@REM ----------------------------------------------------




@node HUNK_RELOC32 "Hunk type: HUNK_RELOC32"
@font courier.font 13

A  HUNK_RELOC32  is  used  at  load  time to re-calculate a specific address. Since the
Amiga  has  got  an almost non rigid memory configuration where the same program can be
put  into  any  memory  locations a concept had to brought in that makes it possible to
move a program into different memory locations without touching the load file.
This  is  very  clever  done.  Any  Amiga  executable  program  is ever written for the
physical  address  0.  When  now  it must be loaded in at the physical address 5000 the
HUNK_RELOC32  is  used  to  re-calculate  it.  The initial value where the HUNK_RELOC32
points  to, will be changed to the initial value plus the real address of this segment,
e.g. initial value equal to 430, physical address 5000, new value = 5430.

Format:
	1st longword	HUNK_RELOC32
	2nd longword	The  amount  of  addresses those have to be re-calculated
		before firing up the program.
	3rd longword	The "hunk" number whose addresses must be corrected. 
	4th longword	The offset in "hunk" that must be corrected.
	....	The other offsets

Example:
	00 00 03 EC
	00 00 00 01	Refer to "hunk" number two!
	00 00 00 02	We have to correct 2 offset
	00 00 00 04	First  offset (longword) to correct is offset 4 in "hunk"
		two
	00 00 00 4C	Second  offset  (longword)  to  correct  is  offset 76 in
		"hunk" two
 	00 00 03 EC
	00 00 00 03	Refer to "hunk" four!
	00 00 00 02	Correct 2 offsets
	00 00 00 10	First  offset  to  correct in "hunk" four is the longword
		at position 16
	00 00 00 20	First  offset  to  correct in "hunk" four is the longword
		at position 32

@endnode

@REM ----------------------------------------------------




@node HUNK_RELOC16 "Hunk type: HUNK_RELOC16"
@font courier.font 13

This  hunk  is  identical to @{"HUNK_RELOC32" link HUNK_RELOC32} with the exception that instead of a longword
offset  a  word-offset is corrected. Mostly, it occurs when PC-relative addressing mode
is used.

@endnode

@REM ----------------------------------------------------



@node HUNK_RELOC8 "Hunk type: HUNK_RELOC8"
@font courier.font 13

This  hunk  is  identical to @{"HUNK_RELOC32" link HUNK_RELOC32} with the exception that instead of a longword
offset a byte offset is corrected.
I'm  afraid that I'm too stupid to understand for what this hunk is good. I'm told that
this  relocation  is used when PC-relative addressing mode is used - but I haven't seen
any  load  or  object  file that uses an 8 bit PC relative mode, even the M680000 isn't
able to produce such fragments (so far I know).

@endnode

@REM ----------------------------------------------------




@node HUNK_EXT "Hunk type: HUNK_EXT"
@font courier.font 13

This  hunk  indicates that references follow. This hunk is only allowed in object files
because references will ever point out to something unknown!
A linker normally initialises these references.

Format:
	1st longword	HUNK_EXT
	4th byte	Indicator which extern type follows
	5th to 7th byte Three  (3)  byte  value  for length of name in amount of
		longwords
 	3rd longword	Start of this symbol name
	....longword	Position depends on the length for the symbol name
		|
		|
		 ------>If SYM,DEF,ABS,RES and so on this longword contains the value 		 ------>If REF32,REF16,REF8 and so on this longword contains the amount 		|	 of made references to this symbol
		|	then, the next longword contains the byte offset to which the 		|	 address of the referenced object must be written to
		 ------>If COMMON, this is the start of the COMMON block, and then the 			 byte offset follow as described above (REF32 ...) 

Example:
	00 00 03 EF	HUNK_EXT

	81 00 00 02
	_stdout 00
	00 00 00 01	1 reference within this hunk to this reference
	00 00 00 02	reference value must be written to offset 2 within this hunk

	81 00 00 02
	_strlen 00
	00 00 00 01	1 reference within this hunk to this reference
	00 00 00 0E	reference  value must be written to offset 14 within this
		hunk

 	81 00 00 02
	_DOSBase
	00 00 00 01	1 reference within this hunk to this reference
	00 00 00 1C	reference  value must be written to offset 28 within this
		hunk 
	00 00 00 00	No more entries

	The layout of this hunk differs from type to type

	EXT_SYM EXT_DEF EXT_ABS EXT_RES have got the same layout

	EXT_RES32  EXT_COMMON  EXT_REF16  EXT_REF8 have got the same layout with
	the  exception  of EXT_COMMON, where between the name and the reference-
	value the size of the COMMON block is written.

@endnode

@REM ----------------------------------------------------




@node HUNK_SYMBOL "Hunk type: HUNK_SYMBOL"
@font courier.font 13

The  HUNK_SYMBOL has got nothing to do with a linker. It is used when debugging a load-
file.

Format:
	1st longword	HUNK_SYMBOL
	2nd longword	Amount of longwords used to take up name
	3rd longword	Start of name
	....longword	Offset within this hunk to which this symbol is assigned

Example:
	00 00 03 F0
	00 00 00 01	Length of name in amount of longwords 
	_end	Name
	00 00 00 26	Byte offset to which this symbol refers

	00 00 00 02	Length of name in amount of longwords 
	_rela 00 00 00	Name
	00 00 00 00	Byte offset to which this symbol refers

	00 00 00 00	No more entries
@endnode

@REM ----------------------------------------------------




@node HUNK_DEBUG "Hunk type: HUNK_DEBUG"
@font courier.font 13

The  HUNK_DEBUG  is  not limited to anything and is not defined. It is up to the author
of a Compiler (builder) how he implements and translates this hunk.

Format:
	1st longword	HUNK_DEBUG
	2nd longword	Amount of used longwords that follow
	3rd longword	Contents up to the author....


Example:
	00 00 03 F1	HUNK_DEBUG
	00 00 00 1A	Amounts of longword that follow
	00 00 00 00	.....
	LINE
	00 00 00 03
	Untitled.s 00 00
	00 00 00 08
	00 00 00 00
	00 00 00 09
	...........

@endnode

@REM ----------------------------------------------------




@node HUNK_END "Hunk type: HUNK_END"
@font courier.font 13

The  HUNK_END  terminates  a  hunk. It's stands on its one. It must be present for each
hunk, i.e. CODE, DATA, BSS. It must be present in load- and object files.

Format:
	HUNK_END

Example:
	00 00 03 F2

@endnode

@REM ----------------------------------------------------




@node HUNK_HEADER "Hunk type: HUNK_HEADER"
@font courier.font 13

The  HUNK_HEADER tells AmigaDOS® that this file is a load file. The HUNK_HEADER may not
be  used  in  object files! It contains memory attributes and sizes and also the amount
of  hunks  of which this file consist. The file that is moved from a medium into memory
will depend on this hunk description!

Format:
	1st longword	HUNK_HEADER
	2nd longword	Length  of  name  for  this section in used longwords for
		name or zero (no name at all)

	If second longword is non zero:
	9th byte	Starting with first character (letter)
		of name
	Due to the Amiga hunk-format the name must end at a longword boundary.

	So on for each section (hunk).

	'Zeroed' longword	End of name list

	Next longword	Highest hunk number (counting up from 1!!!)
	Next longword	Number of first hunk to load into memory
	Next longword	Number of last hunk to load into memory
	Table of longwords containing each hunk length in longwords

Example:
	00 00 03 F3	HUNK_HEADER
	00 00 00 00	Amount  of longwords used to hold name of this hunk (here
		zero) = no names given
	00 00 00 05	Highest hunk number is 5
	00 00 00 00	First hunk to load is number zero
	00 00 00 04	Last hunk to load is number 4 (highest)
	00 00 00 A6	Hunk zero requires 664 bytes of memory (RAM)
	00 00 12 60	Hunk one requires 18816 bytes of memory (RAM)
	00 00 04 39	Hunk two requires 4324 bytes of memory (RAM)
	40 00 00 20	Hunk  three  requires  128 bytes of memory (RAM) and must
		reside in CHIP-RAM (bit 30 set)
	40 00 04 A5	Hunk  four  requires  4756 bytes of memory (RAM) and must
		reside in CHIP-RAM (bit 30 set)

@endnode

@REM ----------------------------------------------------




@node HUNK_OVERLAY "Hunk type: HUNK_OVERLAY"
@font courier.font 13

As  the  name already tells this hunk forces another part of it to overwrite an already
loaded  hunk.  The  HUNK_OVERLAY  is currently dead, the only program that had used the
HUNK_OVERLAY feature was DPaint®.
So I don't go into the deep.

Format:
	1st longword	HUNK_OVERLAY
	2nd longword	Table size
	3rd longword	Amount of overwrites to be performed
	4th longword	The start of the data themselves

Example:
	Too complicated to explain, sorry

@endnode

@REM ----------------------------------------------------




@node HUNK_BREAK "Hunk type: HUNK_BREAK"
@font courier.font 13

The  HUNK_BREAK  is  used  in  conjunction  with  @{"HUNK_OVERLAY" link HUNK_OVERLAY}.  This is a real hard to
explain feature of the AmigaDOS® and I won't do it here.
Only so much: The HUNK_BREAK is similar to @{"HUNK_END" link HUNK_END}.

@endnode

@REM ----------------------------------------------------




@node HUNK_DREL32 "Hunk type: HUNK_DREL32"
@font courier.font 13

The  HUNK_DREL32  is  similar  to  @{"HUNK_RELOC32" link HUNK_RELOC32}  but  differs  in that words instead of
longwords get stored. HUNK_DREL32 is identical to @{"HUNK_RELOC32SHORT" link HUNK_RELOC32SHORT} while
HUNK_DREL32  is not allowed in load files but due to bug in DOS library v37 HUNK_DREL32
is supported in load files. @{"HUNK_RELOC32SHORT" link HUNK_RELOC32SHORT} can only be used up from OS3.0 .

Format:
	1st longword	HUNK_DREL32
	3rd word	Amount of relocations
	4th word	Hunk number for which these relocations are
	5th word	Offset which must be corrected
	6th word	Another one to be corrected and so on

Example:
	00 00 03 F7	HUNK_DREL32
	00 03 00 00	Amount of relocation (3) for hunk number zero (0)
	00 20 00 0E	Correct offset at position 32 and 14
	00 1C 00 00	Correct  offset  at  position  28  and perform a longword
		boundary 

@endnode

@REM ----------------------------------------------------




@node HUNK_DREL16 "Hunk type: HUNK_DREL16"
@font courier.font 13

The  HUNK_DREL16  is  identical  to  @{"HUNK_DREL32" link HUNK_DREL32}  and  it  is  mainly  for  PC relative
addressing modes.
See also @{"HUNK_RELOC16" link HUNK_RELOC16}.

@endnode

@REM ----------------------------------------------------





@node HUNK_DREL8 "Hunk type: HUNK_DREL8"
@font courier.font 13

The  HUNK_DREL8 is identical to @{"HUNK_DREL32" link HUNK_DREL32} and it is mainly for PC relative addressing
modes (or - I guess, for base displacements).
See also @{"HUNK_RELOC8" link HUNK_RELOC8}.

@endnode

@REM ----------------------------------------------------




@node HUNK_LIB "Hunk type: HUNK_LIB"
@font courier.font 13

No idea what it is good for.

@endnode

@REM ----------------------------------------------------




@node HUNK_INDEX "Hunk type: HUNK_INDEX"
@font courier.font 13

No idea what it is good for.

@endnode

@REM ----------------------------------------------------




@node HUNK_RELOC32SHORT "Hunk type: HUNK_RELOC32SHORT"
@font courier.font 13

The  HUNK_RELOC32SHORT  is similar to @{"HUNK_RELOC32" link HUNK_RELOC32} but differs in that words instead of
longwords  get  stored  in  the  file.  Since  words  have  a limit of 65536 bytes only
references  within  this  range can be accessed by HUNK_RELOC32SHORT. HUNK_RELOC32SHORT
is  only  useable  under  OS3  and up and was (so far I know) broken in V37 and did not
exist in earlier versions.
If  you develop programs for V37 of DOS library use @{"HUNK_DREL32" link HUNK_DREL32} instead, it's identical
to HUNK_RELOC32SHORT.


Format:
	1st longword	HUNK_RELOC32SHORT
	3rd word	Amount of relocations
	4th word	Hunk number for which these relocations are
	5th word	Offset which must be corrected
	........	and further offset to be corrected

Example:
	00 00 03 FC	HUNK_RELOC32SHORT
	00 03 00 00	Amount of relocation (3) for hunk number zero (0)
	00 20 00 0E	Correct offset at position 32 and 14
	00 1C 00 00	Correct  offset  at  position  28  and perform a longword
		boundary

Notes:
	Due  to  the  Amiga  hunk-format  this  section  must  be completed at a
	longword  boundary  even  if there are less data to perform the longword
	boundary.   In   this   case   linkers   would  extent  such  a  section
	automatically with a zero word.

@endnode

@REM ----------------------------------------------------




@node HUNK_RELRELOC32 "Hunk type: HUNK_RELRELOC32"
@font courier.font 13

For  this  (HUNK_RELRELOC32) I require information. Currently, I can only guess what it
is good for.

@endnode

@REM ----------------------------------------------------




@node HUNK_ABSRELOC16 "Hunk type: HUNK_ABSRELOC16"
@font courier.font 13

Unsupported through the system so far I know...

@endnode

@REM ----------------------------------------------------




@node EXT_SYMB "HUNK_EXT: EXT_SYMB"
@font courier.font 13

This one indicates that a symbol name will follow.
Normally, this is the name of a label or function, which is made public.

@endnode

@REM ----------------------------------------------------




@node EXT_DEF "HUNK_EXT: EXT_DEF"
@font courier.font 13

This one indicates that a definition will follow.
Can  be  a  reference  to a variable, label or function. The name of this reference and
the offset within this hunk are stored.

@endnode

@REM ----------------------------------------------------




@node EXT_ABS "HUNK_EXT: EXT_ABS"
@font courier.font 13

This one indicates that an absolute reference will follow.
For example, a library function name and its offset are stored. 

@endnode

@REM ----------------------------------------------------




@node EXT_RES "HUNK_EXT: EXT_RES"
@font courier.font 13

This one indicates that an absolute reference to a resident library will follow.
Dropped as name and reference.

@endnode

@REM ----------------------------------------------------




@node EXT_REF32 "HUNK_EXT: EXT_REF32"
@font courier.font 13

This one indicates that an absolute address must be corrected.
Dropped as name, how often to correct and the offset(s) themselves.

@endnode

@REM ----------------------------------------------------




@node EXT_COMMON "HUNK_EXT: EXT_COMMON"
@font courier.font 13

Similar to @{"EXT_REF32" link EXT_REF32} but with implied common block.

@endnode

@REM ----------------------------------------------------




@node EXT_REF16 "HUNK_EXT: EXT_REF16"
@font courier.font 13

Similar @{"EXT_REF32" link EXT_REF32} hunk but for 16-bit offsets.

@endnode

@REM ----------------------------------------------------




@node EXT_REF8 "HUNK_EXT: EXT_REF8"
@font courier.font 13

This hunk is Similar to the hunk @{"EXT_REF32" link EXT_REF32} but for 8-bit offset.

@endnode

@REM ----------------------------------------------------




@node EXT_DEXT32 "HUNK_EXT: EXT_DEXT32"
@font courier.font 13

No idea what it is good for.

@endnode

@REM ----------------------------------------------------




@node EXT_DEXT16 "HUNK_EXT: EXT_DEXT16"
@font courier.font 13

No idea what it is good for.

@endnode

@REM ----------------------------------------------------




@node EXT_DEXT8 "HUNK_EXT: EXT_DEXT8"
@font courier.font 13

No idea what it is good for.

@endnode

@REM ----------------------------------------------------




@node EXT_RELREF32 "HUNK_EXT: EXT_RELREF32"
@font courier.font 13

No idea what it is good for.

@endnode

@REM ----------------------------------------------------




@node EXT_RELCOMMON "HUNK_EXT: EXT_RELCOMMON"
@font courier.font 13

No idea what it is good for.

@endnode

@REM ----------------------------------------------------




@node EXT_ABSREF16 "HUNK_EXT: EXT_ABSREF16"
@font courier.font 13

No idea what it is good for.

@endnode

@REM ----------------------------------------------------




@node EXT_ABSREF8 "HUNK_EXT: EXT_ABSREF8"
@font courier.font 13

No idea what it is good for (base / outer displacement?).

@endnode

@REM ----------------------------------------------------





@node Help "DropHunk Guide Help"
@font helvetica.font 13

H E L P P A G E

For   backgrounds  about  the  Amiga  hunk  types  click  the  INDEX  button.  If  you  want  general-purpose
background  at the Amiga DOS, linker and hunk forms click the buttons below. If you want general hints about
optimising your hunk layout click the hint button: Else click one of the bar buttons.

General purpose @{" Amiga DOS    " link AmigaDOS}
General purpose @{" Amiga Linkers " link AmigaLink}
General purpose @{" Amiga Hunks  " link GHunks}

Some @{"  Hints  " link Hints}

@endnode

@REM ----------------------------------------------------




@node AmigaDOS "AmigaDOS background"

The  first  version  of  the  AmigaDOS  was  a  modified  disk-operating kernel developed by the University of
Cambridge  called  TRIPOS.  Some  concepts  of  UNIX  went  into  the  AmigaDOS, too. First versions (below
kickstart  v36)  were  written  using  a  language  that  produced  BCPL  code. BCPL code will ever reference
addresses that differ from the real in that it is only 1/4 of it, e.g. physical address 16 becomes under BCPL to 4.

@endnode

@REM ----------------------------------------------------




@node AmigaLink "Linkers supporting AmigaDOS"

The  standard  linker  concepts  today  are  still the same as the earliest linker concepts in the late 50th of the
current  (20)  century.  Nothing  basically  has  been  changed.  A linker takes a file or several and joins them
together into a single file ready to run under the specific OS and CPU.
The  object file written by you (for example) is one of these files the linker investigates for un-implemented but
referenced  variables and static data. It will copy them to your object file if it will find them in other object files.
Some CPU instruction parts have to copy also to your object file.

Basically on the Amiga you have to link three object files:

	startup.o
	main.o
	amiga.lib

The  startup.o  file  contains  the so called start-up-code written as first program entry when the executable is
fired up.
In  the  main.o  file  your  CPU  instructions  are  formed  so  that  something  you  want your machine to do is
performed.
The  amiga.lib is one single file with several Amiga specific functions and declarations that are almost used by
any executable program.

After  these  three  parts have been linked an executable is produced by the linker which is able to run under
your 68k CPU.

Currently this task does the:
	ALink linker, written as first available linker for the Amiga
	BLink linker, written as replacement for ALink
	LC linker, SAS-C package
	LN linker, AZTEC-C package
	PhxLnk linker, an up-to-date linker
	and several linkers that come with a developer package

Even ALink is currently able to do all necessary steps to build an Amiga load file.

Special,  in  form  of  non-standard,  are  C++  linkers.  They have to insert code or init variables or call code
even  no  declaration  is  made  within  your  source  (information  hiding)  that  in  most  cases  blow up your
executable  and  you wonder why. When you use classes, you don't see the work behind it. Since a compiler
translates  only code from one language to another (e.g. human readable to machine readable), the linker has
to bind and init such fragments.

@endnode

@REM ----------------------------------------------------




@node GHunks "General purpose of hunks"

A normal Amiga program consist of three (#3) logical segments, CODE, DATA,
BSS.

CODE contains the instruction code that the CPU understands.
In the DATA segment static variables or initialised data reside.
BSS is a virtual storage, only physical at runtime.

Because  an  Amiga has got a dynamic memory management where nothing is ridged simply loading in a load
file  into  memory  does  not  work,  because  the  file will not be loaded all the time in the same memory area.
Also, some other programs may demand the same memory area. So a flexible concept had to brought in.

Any  Amiga  program  is  written  for  the  physical  address  zero.  When it is loaded now to address 5000 all
absolute addresses are corrected to run at this place. Therefore the HUNK_RELOC.xx are used.

@endnode

@REM ----------------------------------------------------




@node Hints

The Linker itself.

First of all, a linker should use the HUNK_HEADER to demand the right workspace.
Then,  the  HUNK_DATA  is  parsed  from  the  end  to  the  bottom  for  a connected block of zero bytes. This
requires a Compiler that stores zero bytes at the end of the DATA area.
Only  data  that  are  non-zero are saved along with the object- or load file. The size in HUNK_HEADER tells
the system how many bytes it has to reserve for this segment.
The next step is, that it should use RELOC_SHORT instead of LONG.
Another  good  idea  is to optimise the code so that long jumps (jsr/jmp) are converted to (jsr(pc), jmp(pc) or to
bsr/bra). This one is tricky because other relative addresses must be corrected, too.

Jumps over 32Kbyte should not be optimised, e.g. jsr _foo	->	jsr (_foo.l,pc)	<- don't use!

@endnode
