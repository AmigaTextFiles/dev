@database Programming_Languages.guide
SETENV HYPERPENS 21213001

@Index TheIndex
@node Main "Programming Languages - A Comparison"
@{" Introduction " link Introduction}       - Read me first

@{" Speed comparison " link sc}   - Execution speed, size of executables

@{" General comparison " link gc} - Capabilities, hints

@{" Test programs " link tp}      - Listings

@{" C++ verification " link cppv}   - Am I using a true C++ compiler?

@{" Author " link Author}             - Address

@{" History " link hist}            - What's new?

@{" Credits " link Credits}            - Thank you very much!

Internet: http://www.reibold-online.de
@endnode

@node Introduction
@{b}Overview@{ub}

This document contains a comparison of some programming languages, including
C/C++, Basic, Pascal, Fortran, Forth, and Cobol.

@{b}Sections@{ub}

The @{" Speed comparison " link sc} is the main section of this document. It
contains the test results for several programming languages.

The @{" General comparison " link gc} is subdivided into several sub sections
for C, Pascal, and other programming languages.

Most of its sub sections start with a short description of the programming
language. Each sub section describes compilers and / or interpreters which
support that programming languages. Compilers are preferred here.

The @{" Test programs " link tp} section contains the source codes for the
test programs.

If you are a C++ programmer, you should have a look at the @{" C++ verification " link cppv}
section.

The programs presented in that section can be used to check if your compiler
really is a C++ compiler.
@endnode

@node sc "Speed comparison"
@{b}Tables@{ub}

@{" Test #1 (for loop) " link t1}

@{" Test #2 (CLI window output) " link t2}

@{" Abbreviations " link ab}

@{b}Notes@{ub}

@{" How the execution times have been measured " link htm}

@{" Notes concerning the execution speeds " link nes}

@{" Notes concerning the program lengths " link npl}

@{" Notes about startup codes and optimizations " link sacodes}
@endnode

@node t1 "Test #1 (for loop)"
A loop counting from 1 to 1,000,000 results in the following execution times
and program lengths:

  Language                 Bytes     Ticks
  --------------------------------------------
  Assembler A68kN (optimized)   48        5.00
  Assembler Barfly 2.x          48        5.00
  Assembler PhxAss              48        5.00
  Assembler A68kN               48        5.00
  Assembler as (GCC/egcs)       68        5.00
  StromCPP 3.0 reg.          2,104        6.00
  ACE 2.0 - ASM              4,568        6.00
  BB2 1.9 - ASM              6,228        6.50
  Assembler masm (Maxon C++)    56        7.00
  StromCPP 2.0 reg.          2,320        7.00
  MaxonC++ 3.1 reg.            708        7.00
  GCC 2.7.2                  1,940        7.00
  PCQ 2.0 (A68kN)            1,280        7.00
  egcs 1.0.2 (GCC 2.9.27)    2,024        7.00
  Struct 1.0                   224        8.00
  BCF 77                    16,748        8.00
  TurboDEX                     132        8.00
  Dice 2.0 reg.              2,744        8.00
  Creative E 2.1               536        9.00
  PCQ 1.2d (Phx)               552        9.00
  PCQ 2.1 (Phx)              1,124        9.00
  HighSpeed Pascal 1.2       1,776       13.00
  Oberon-A                     980       14.00
  Cyclone 0.94 reg./inl.       496       14.00
  MaxonPASCAL 3.0            4,588       14.00
  egcs 1.0.2 (G77 2.9.27)   12,704       14.00
  PowerD 0.16                  296       15.00
  E 3.3a                       528       15.00
  GFA Basic 3.5              6,764       16.00
  PDC                        6,288       16.00
  SAS/C 6.58                 1,700       16.00
  Struct 1.0                   224       17.00
  MaxonC++ 3.1                 752       17.00
  Pure Basic 2.9               352       19.00
  Cyclone 0.92                 500       19.00
  M2Amiga 4.1 Demo           1,512       19.00
  Turbo Modula-2             2,764       20.00
  Fortran2C & GCC 2.7.2     14,040       21.00
  G77 Fortran 2.7.2         16,268       21.00
  BB2 2.1                      236       27.00
  Free Pascal fpc 0.995d    56,360       28.00
  Oberon_2                     728       28.50
  ACE 2.40 (Phx+SO)          3,240       34.00
  Maxon/HisoftBasic 3.0     15,772       52.00
  AMOS Professional 2.0     54,504       58.00
  GForth VM                      -       63.00
  TILE-Forth VM                  -      150.00
  Cursor 1.7                32,468      281.00
  Pike 0.4                      63      361.00
  Python 1.5 bytecode          153      617.00
  Python 1.5                    34      622.00
  EXECREXX                     884      817.00
  BRexx 2.0                     31    1,665.00
  Perl 5.004                    33    1,679.00
  CanDo 3.0                  1,072    4,700.00
  NR Cobol 1.0d                596    9,200.00 (est.)
  ARexx 1.15                    31   12,100.00 (est.)
  Bywater Basic 1.11            41   24,100.00 (est.)
  Tcl 7.6                       43   50,500.00 (est.)
  pdksh                         50  149,100.00 (est.)
  UCB Logo 4.0                  25  267,500.00 (est.)
@endnode

@node t2 "Test #2 (CLI window output)"
Writing "Hello, world" 1,000 times in a CLI window results in the following
execution times and program lengths:

  Language                 Bytes   Ticks
  ---------------------------------------
  Assembler PhxAss, C-like     172    668
  StormCPP 2.0               6,724    668
  Cursor 1.7                32,536    669 *
  GFA-Basic 3.51             9,284    670 *
  GCC 2.7.2                 58,804    686
  Assembler Barfly 2.x         128    690
  Creative E 12.1              712    694
  StormCPP 3.0              31,712    704
  Assembler 68kN (optimized)   120    705
  Assembler PhxAss             132    706
  Assembler A68kN              132    706
  Assembler masm (Maxon C++)   148    706
  Assembler as (GCC)           152    706
  ACE 2.40 (Phx)            28,832    706
  MaxonC++ 3.1                 856    707
  E 3.3a                       704    707
  Free Pascal fpc 0.995d    56,428    707
  BB2 (optimized version)    2,320    713
  HighSpeed Pascal 1.2       4,120    713
  PowerD 0.16                  364    714
  Turbo Modula-2            10,324    714
  Cyclone 0.92               1,612    715
  Pure Basic 2.9               624    716
  SAS/C 6.56 (C++ 7.01)     17,104    717
  SAS/C 6.58                39,056    717
  MaxonPASCAL 3.0            4,628    720
  BB2 2.1                    4,084    720
  egcs 1.0.2 (GCC 2.9.27)   81,800    721
  PCQ Pascal 1.2d (Phx)      2,520    723
  PCQ Pascal 2.0 (Phx)       2,540    727
  PCQ Pascal 2.0 (A68kN)     2,964    727
  Maxon/Hisoft Basic 3.0    15,984    731
  vbcc 0.6a                  3,492    731
  CanDo 3.0                  1,100    755
  vbcc 0.6a (ixemul.library) 1,256    757
  egcs 1.0.2 (G77 2.9.27)   40,804    768
  Oberon-A                   4,360    770
  BRexx 2.0                     49    799
  Fortran2C & GCC 2.7.2     40,744  1,123
  G77 Fortran 2.7.2         47,992  1,158
  TILE-Forth VM                  -  1,164
  GForth0.4.0 VM                 -  1,178
  Python 1.5 bytecode          181  1,274
  Python 1.5                    53  1,284
  ARexx 1.15                    49  1,337
  Perl 5.004                    55  1,369
  pdksh                         69  1,448
  Bywater Basic 1.11            63  1,505
  UCB Logo 4.0                  42  1,515
  Pike 0.4                      89  1,520
  Tcl 7.6                       63  1,609
@endnode

@node ab Abbreviations
The following abbreviations have been used:

  Abbreviation  Explanation
  -------------------------------------------------------------------
  reg.          register variables have been used
  inl.          inline code has been used
  Phx           Phx Assembler and linker have been used
  A68kN         A68kN Assembler (successor of A68k) has been used
  ACE           ACE Basic Compiler
  ASM           internal Assembler has been used
  BB2           Blitz Basic 2
  GCC           GNU C/C++ compiler
  SO            ACE Super Optimizer has been used
  est.          execution time has been estimated by executing a loop
                with a maximum value of 10,000 (instead of 1,000,000)
  *             uses buffered output to file "*"
@endnode

@node htm "How the execution times have been measured"
The program »exe_timer« has been used to calculate the execution time
of the test programs in intuition ticks (1/50 second). »exe_timer« has
been written using Blitz Basic 2.

The results stated above have been measured on an Amiga 4000/040 25 MHz
with 16 MB fast and 2 MB graphics RAM.

All programs have been copied to RAM: before testing them. 2 ticks have been
subtracted from the results computed by »exe_timer« because about 2 ticks
are necessary to load a program using »exe_timer«.

@{b}cbsi@{ub}

»cbsi« is a system information tool. Two sample outputs of this utility
have been included:

  File            Remarks
  --------------------------------------------------------------------
  cbsi.out.no-ss  Amiga started without executing »S:Startup-Sequence«
                  (*** see below ***)
  cbsi.out.wb     "normal" Workbench startup

@{b}Important notes@{ub}

The tests have been made by booting an Amiga 4000 WITHOUT executing the
»S:Startup-Sequence« file in order to disable all other programs.

Only »SetPatch« and »CPU cache burst« have been executed.
@endnode

@node sacodes "Notes about startup codes and optimizations"
@{b}Startup codes@{ub}

In addition to the tests, the startup code of the programs is measured.
This code is quite large for higher programming languages like C and is
used for opening libraries and the like. This code is very small or does 
not even exist for machine code (Assembler) programs. Most of the execution
time measured is needed for the test.

Gunther Nikl recommends the following to omit the startup code of the
GNU C/egcs compiler 2.95.x (test #1):

  gcc -nostdlib -s -Os -fomit-frame-pointer -o test1 test1.c

These options shall lead to an executable file of 60 bytes only.

Unfortunately, I could not test this because my egcs compiler is only
version 2.90.x and refuses the -Os option. If I omit that option, the
linker generates a "__main symbol is missing" error message.


@{b}Optimizations@{ub}

Olaf Koenders suggests to use the shortest and fastest Assembler
instructions. One should not test for internal libraries like
"dos.library" or "graphics.library" (unless a minimum version
is required by the program) because programs cannot be executed if
"dos.library" is missing.

The output should be buffered in order to be as fast as possible.

You should do as much as possible *outside* loops.
@endnode

@node nes "Notes concerning the execution speeds"
@{b}PowerD@{ub} executables require a 68020+ processor. All programs
have been compiled with FPU support.

@{b}DEX@{ub} uses register variables automagically.

@{b}Struct@{ub} has been tested twice: using register variables and without using
register variables.

@{b}SAS/C@{ub} eliminates empty loops - this results in 1,680 bytes and only 1
tick execution time for test #1.

@{b}GNU CC@{ub} eliminates empty loops if the "-funroll-loops" option is specified.
This results in 2,380 bytes and an execution time of 1 tick.

@{b}Blitz Basic@{ub} programs with error checks turned on need about 160 ticks for
test #1.

@{b}Maxon/Hisoft Basic@{ub} programs with error checks turned on need 388 ticks for
test #1.

All @{b}NR Cobol@{ub} programs use floating-point values and error checks cannot be
turned off. Cobol does not allow "empty loops", thus a sub program has been
used to simulate this. (The execution time stated above does not include the
time needed to call the sub routine, of course.)

The global optimizer of @{b}vbcc@{ub} eliminates empty loops.

@{b}Fortran2C & GCC2.7.2@{ub}: GCC with -m68040 or with -O3 option has been used.

About 26 ticks are necessary to load a @{b}GForth VM @{ub} using »exe_timer«.
3 ticks are necessary to compile Test #1 and 5 for Test #2.

About 10 ticks are necessary to load a @{b}TILE-Forth VM @{ub} using »exe_timer«.
10 ticks are necessary to compile Test #1 and 13 for Test #2.

@{b}GFA-Basic@{ub} does not provide CLI output. Buffered output to the "*" file has
been used.

The C-like @{b}Assembler@{ub} code writes its output to a buffer and outputs the whole
buffer at one time. Thus the overhead of the operating system is reduced.

@{b}Cursor 1.7@{ub} does not provide CLI output. Buffered output to the "*" file has
been used. The options "-w0 -b2 -s" have been used in order to get a fast program.

Both @{b}E@{ub} and @{b}Creative E@{ub} have special compiler switches which
cause them to use register variables automagically and to optimize the code.

@{b}UCB Logo@{ub} opens its own screen (16 colours). The output is redirected to the
CLI window.

@{b}PureBasic@{ub} executables are faster if a suitable PhxAss assembler option is
used. (Refer to the PhxAss documentation for details or use he command line
version of the PureBasic compiler.)
@endnode
    
@node npl "Notes concerning the program lengths"
@{b}PowerD@{ub} Assembler sources may be linked using the PhxLnk linker in order to get
shorter executable files.

The GNU Assembler @{b}as@{ub} has been invoked via GCC with the -nostdlib option
enabled.

@{b}Oberon_2@{ub} requires the »garbagecollector.library« (11,088 bytes).

@{b}EXECREXX@{ub} requires the »rexxapp.library« (1,568 bytes) and  ARexx.

@{b}Cursor@{ub} executables can load the »basic.library« (30 KB) alternatively.

@{b}Maxon/Hisoft Basic@{ub} executables can load the »hbasic2.library« (50 KB)
alternatively, resulting in files of less than 600 bytes.

@{b}Oberon-A@{ub}: Startup and System/IO/Errors need about 9 KB.

@{b}StormCPP@{ub} executables are significantly shorter if the C++ mode is turned
on.

@{b}Cyclone@{ub} executables are shorter and slower if inlines are turned off.

@{b}GCC@{ub} executables may load the »ixemul.library« (150 KB) alternatively.

@{b}G77@{ub} executables load the »ixemul.library« (150 KB).

@{b}AMOS Professional 2.0@{ub} executables can alternatively use the »amos.library«
(50 KB) reducing the program length to 7,616 bytes.

@{b}CanDo@{ub} executables can be linked with the »cando.library« (190 KB)
alternatively.

@{b}NR Cobol@{ub} executables need the »runcobol« run-time system (120 KB).

The @{b}PCQ@{ub} executable for test #1 has been compiled using the "-s" option (small
init).

@{b}PureBasic@{ub} executables may be shortened by using other PhxLnk linker
options
@endnode

@node gc "General comparison"
This section shows the capabilities of some programming languages and gives
you some hints.

@{" Assembler " link Assembler}            - A68k, Blink, Phx, GNU C++ · intermediate assembly

@{" Authoring systems " link as}    - CanDo, Helm

@{" Basic " link Basic}                - ACE, Maxon/Hisoft Basic, GFA Basic, Blitz Basic 2, AMOS

@{" C/C++ " link c}                - SAS/C, GNU C++, egcs, Maxon C++, Storm CPP

@{" Cobol " link cbl}                - NR Cobol

@{" E " link E}                    - E · Visual E · Creative E · PowerD

@{" Fortran " link Fortran}              - BCF 77 Fortran, G77, F2C

@{" Modula and Oberon " link om}    - Turbo Modula, Cyclone, Oberon-A, M2Amiga

@{" Other languages " link ol}      - Forth, Struct, DEX, UCB Logo

@{" Pascal " link Pascal}               - PCQ, Maxon Pascal, Hisoft Pascal, Free Pascal

@{" Scripting languages " link batch}  - Perl, ARexx, pdksh, Tcl, Pike, Python

@{" Conclusion " link Conclusion}           - How to select your programming language
@endnode

@node Fortran
@{b}Introduction@{ub}

The Fortran programming language is used for solving mathematical and
scientific problems. It offers high-precision floating point numbers and
a lot of mathematical functions.

In contrast to Fortran 77, Fortran 90 supports structured programming (WHILE,
REPEAT).

@{b}Compilers@{ub}

@{b}BCF 77@{ub} is shareware. The resulting executables are quite long.

@{b}F2C@{ub} translates Fortran sources to C sources and needs GCC. @{b}G77@{ub} is the
GNU Fortran compiler. The resulting executables are very long. Unlike BCF 77, this
compiler works correctly with *all* sources of Fortran and is not restricted
to Fortran 77.

egcs, the Experimental GNU Compiler System, comes with a new @{b}G77@{ub} Fortran
compiler. The executables load the »ixemul.library« (150 KB).
@endnode

@node batch "Scripting Languages"
@{b}Introduction@{ub}

Most scripting languages have been ported from Unix / Linux and therefore
provide excellent support for networking (TCP/IP, HTTP, FTP).

Scripting languages read commands from text files ("scripts") and perform
these commands on the fly. (An executable file is not created.)

ARexx has been ported from IBM's OS/2 operating system.

The execution times vary because they depend on your system (background
tasks, speed of your disks etc).

@{b}Links@{ub}

@{i}UCB Logo@{ui} 4.0 is described in the @{" Other languages " link ol} section.

@{i}Forth@{ui} is described in the @{" Other languages " link ol} section.

@{i}Bywater Basic@{ui} 1.11 is described in the @{" Basic " link Basic} section.

@{b}Interpreters@{ub}

@{b}Perl@{ub} is a scripting language used with Unix and Linux. Perl combines the
best features of C, awk, and the Bourne/Korn shell. The main purpose of
this "Practical Extraction and Report Language" is text or file processing.

Perl is a fast interpreted language that is used for system maintenance
and CGI scripts. All Unix (Posix) system calls are supported. A lot of
support scripts ("modules") are included. Extensions of Perl can be used
for programming graphical X Window applications.

@{b}ARexx@{ub} is the standard scripting language on the Amiga. String processing
and inter-process communication are the most important features of this
language. ARexx is much slower than Perl and less powerful.

@{b}BRexx@{ub} is an alternative Rexx interpreter which is quite fast. It lacks support
for ARexx ports of applications.

@{b}pdksh@{ub} is an Amiga port of the Unix @{b}Korn shell@{ub}. That shell is more powerful
than the Amiga shell. External programs are needed for advanced programming.
(Conditions are tested with "test", for instance.) pdksh is very slow.

@{b}Tcl@{ub} ("Tool Command Language") is a small scripting language which can also be
linked to executable programs. (Tcl can be used as a macro language this way.)
You can extend the language with your own C functions.

Tcl is less powerful than Perl. Tcl's "Toolkit" (@{b}Tk@{ub}) is used to write
graphical X Window applications. If you want to write an X application, you
should consider using Tcl/Tk (it's easy). The Linux WWW browser "Grail" uses
Tcl/Tk.

@{b}Pike@{ub} is a programming language similar to C++. Pike comes with an extensive
documentation and support programs. This language is quite fast and can be
used to write simple (text based) WWW browsers, for instance.

@{b}Python@{ub} is similar to Perl, but uses a different syntax. Blocks of code have
to be indented rather than putting braces or keywords around them. Python
comes with several support modules and is able to compile script files to
bytecode (similar to Java). Byte-compiled scripts are slightly faster than
regular scripts.

Note: Python 1.5 requires a 68030+ processor.

@{b}awk@{ub} is a language designed for text / file processing. Code blocks are
associated with patterns of characters. If a text matches a pattern, the
corresponding code block is executed.
@endnode

@node E
@{b}Introduction@{ub}

E is an all-purpose programming language similar to C and Pascal. All data
is considered to be a long integer. Variables may be kept in processor
registers in order to make the programs running faster.

E supports object oriented programming.

@{b}Compiler@{ub}

Its main @{b}features@{ub} are:

o  generation of *very* short executables
o  fast compilation
o  fast executables
o  ability to create shared library files with ease
o  integrated Assembler
o  supports all Amiga OS 3.1 system libraries
o  optimizations

The @{b}disadvantage@{ub} of E is the strange support for floating point numbers
which requires a special conversion operator each time such a variable is
to be used.

You can find a lot of E utilities on the Aminet such as library modules,
GUI creators and a GUI creation library.

E has special compiler switches which cause it to use register variables
automagically and to optimize the code.

E has been in the public domain until version 2.1b. E 3.0+ is shareware.

@{b}Visual E@{ub}

Visual E is a visual programming environment similar to Microsoft Visual
Basic for Windows.

@{b}Creative E@{ub}

The development of the original E compiler has been stopped. Its successor
Creative E is giftware and adds the following features to E:

o support for memory pools, 68020+ processors, FPU, MMU
o better inline Assembler
o enhanced commands
o faster and shorter executable files

Creative E 2.x is different from 1.x and much faster.

@{b}PowerD@{ub}

PowerD is a programming language similar to Creative E.

According to its documentation, PowerD adds the following
features to E:

o  more return values
o  more operators (like >>, <<, >|, <|, etc)
o  more assign operators (like +=, *=, etc)
o  more intelligent equation computing (PowerD: 1+2*3=7, AmigaE: 1+2*3=9)
o  changable introduction of precedence
o  names can contain high/low letters in all cases
o  for object oriented programming you don't have to use self.#?, you can use only #?
o  better polymorphism
o  more types (FLOAT, DOUBLE, BOOL, etc.)
o  fpu using
o  compilation to object files
o  automatic generation of external modules
o  linked library functions using
o  inline lists (OpenWindowTags/OpenWindowTagList)
o  IFN, WHILEN, ... for reverse condition (IF a<>10 is the same as IFN a=10)
o  constants and variables can be declared everywhere you like

PowerD executables are slightly slower than E executables, but they are
also shorter.
@endnode

@node Assembler
@{b}Introduction@{ub}

A processor (CPU) has its own programming language called "machine
language". Each command consists of a series of "0"s and "1"s and thus is
an integer value.

An Assembler associates a name with each command in order to make programming
somewhat easier. It compiles (assembles) the source code to an object
file which has to be linked by a linker. The linker adds an "executable file
header" which is needed by the AmigaOS. (A program without such a header
is considered to be non-executable.)
      
@{i}Intermediate assembly@{ui}

Some programming languages do not produce object code directly. They create
an assembly source file and use an Assembler to generate an @{b}object file@{ub}.
The object file is then linked to a startup code and run-time libraries. In
such cases you should try to use the Phx Assembler and linker mentioned
below.

@{i}Integrated Assemblers@{ui}

A couple of programming languages offer @{b}integrated Assemblers@{ub}. This is
of use if you write a program in, for example, Basic and want to include some
Assembler instructions for a time critical procedure. This way, there is no
need for a seperate Assembler package any longer. Blitz Basic provides his
feaure, for instance.

@{b}Assemblers@{ub}

For the speed comparisons, the @{b}A68k@{ub} Assembler has been used. It is placed in
the public domain. The @{b}blink@{ub} linker has been used to link the object code
generated by A68k. The successor of A68k, @{b}A68kN@{ub}, does also support some
68020+ opcodes.

The @{b}Phx@{ub} Assembler does a whole bunch of optimizations to ensure that the
resulting object files are as fast as possible. To shorten the file length
of your executables, you should use the Phx linker.

Note: The Phx Assembler seems to have problems when it is used in
      conjunction with an optimizer like "peep" of PCQ Pascal or ACE's
      "SuperOptimizer". It might generate slower code in that case.

Note: Phx does not support the "$" (dollar sign) in function names. Have a
      look at the description of ACE Basic for details.
      
@{b}SNMA@{ub} and @{b}OMA@{ub} do not perform as much optimizations as PHX.

The @{b}Barfly@{ub} 2.x Assembler does a lot of optimizations. It supports the 680x0
and PowerPC processors, 68881 and comes with a great debugger. The package
contains examples, macros, and pre-compiled header files.

@{b}Devpac@{ub} is the standard Assembler package for the Amiga. It is integrated into
an editor and comes with a debugger.

The Assembler @{b}masm@{ub} of Maxon C++ is similar to PhxAss but it does fewer
optimizations.

GNU C++/egcs contains its own Assembler (@{b}as@{ub}) and linker (@{b}ld@{ub}). These are the
utilities used with Unix and Linux. You can invoke both programs separately,
but it is much easier to use GCC instead.

Just type "gcc assembly.s -nostdlib -o runme.exe" to assemble and link
»assembly.s« to »runme.exe«.

Note: Your assembly source must not contain the "end" directive. GCC does not
      need it.

Note: The directives supported by GCC are different. You must replace "dc.b"
      by ".ascii", for instance.
@endnode

@node Basic
@{b}Introduction@{ub}

Programming is very easy with Basic. The declaration of variables is not
required. Thus the use of an undefined variable creates a new one.

Old versions of Basic did not support loops and used to be interpreters rather
than compilers. They relied on "goto" commands, thus resulting in fuzzy
program logics called "spaghetti code".

The compilers mentioned below support loops and sub programs.

@{b}Interpreter@{ub}

@{b}Bywater Basic@{ub} 1.11 is a Basic interpreter and does not support sub programs.
Commands unknown to the interpreter are treated as external programs and
are executed within the CLI.

Bywater Basic source codes must contain line numbers. If you want it to
terminate when your program has finished, use the "system" command to
achieve this.

@{b}Compilers@{ub}

The @{b}Cursor@{ub} Basic compiler generates executables directly. It is able to
compile allmost all Amiga Basic source codes. Unfortunately, the resulting
executables are very slow. Screens created by Cursor executables may have
up to 8 bitplanes.

If no options are specified, all executables open a window for text output.
CLI output has to be done via the "*" file and with the "-w0" option enabled
in order to avoid opening the default window.

@{b}ACE@{ub} (= Amiga Basic Compiler with Extras) is placed in the public domain. ACE
uses A68k and the blink linker to generate executables. The intermediate
Assembler source code it generates is fairly understandable. You should use
the @{b}Phx Assembler and linker@{ub} to get shorter and faster executables (in this
case, you must not use the '$' char in SUB names; use SUB STRING trim(a$)
instead of SUB trim$(a$), for instance).

ACE supports allmost all Amiga Basic statements and has the following
features:

o  integrated Assembler (via A68k or PhxAss)
o  very good support of the serial device
o  gadgets, requesters, speech, gadtools menus, turtle graphics, sound, IFF
o  interprocess communication, error handling
o  include files, external submodules
o  random access files can be handled very easily
o  programming environment AIDE
o  graphical user interface (GUI) creator

The ACE Enhancement Project AEP provides new link libraries for ACE in order
to get shorter and faster executables and supports 68020+ processors.

@{b}Maxon/Hisoft Basic@{ub} is fully compatible with Amiga Basic and partially with
Microsoft Quick Basic for the PC. It comes with include files for Amiga OS
3.1 and supports AGA screens. The programming environment is very good (like
Hisoft Pascal). The documentation supplied with this Basic compiler is very
extensive, too.

Hisoft Basic has several extensions in order to provide better support of
the operating system. This includes the BEGINIO and TAGLIST commands. The
run-time system is configurable via altering a system table. The function
SYSTAB returns the address of that table. Type "POKE SYSTAB+33,0" if you
do not want Hisoft Basic to create icons for your files, for instance.

Reading and writing files ist quite slow with Hisoft Basic. You should
either increase the buffer size by using the LEN= option of the OPEN
command or by processing the files in memory (BLOAD and BSAVE commands).

If you use the "hbasic2.library" which is supplied with Hisoft Basic, the
resulting executables are very short (at about 1K for all tests).

@{b}GFA Basic@{ub} generates very fast and short executables. Unfortunately, it does
not support Amiga OS 2.0+ directly. ECS/AA screen modes are not possible. The
GFA-Basic interpreter cannot be run with Amiga OS 2.0+ unless you switch
ECS/AA screen modes and processor caches off. GFA Basic executables are known
to throw a lot of Enforcer hits. The CLI is not supported (use the file "*"
to access it).

Note: Use the "GFA-Basic Fix" toolkit if you want to run GFA Basic with
      Amiga OS 2.0+

Note: Have a look at "GFA_Enforcer.txt". This package provides a replacement
      for the TITLEW and CLOSEW commands. (The TITLEWW command causes the
      Enforcer hits.)

Note: For Workbench 2.0+ support, you have to convert the new *_lib.fd files
      using the FDCONV utility. Assembler-like statements (RCALL ...) are
      used to call the library functions. (You have to open all libraries
      before using them.)

Note: Have a look at "GFA_Menus.lha" and "GFA_Gadgets.lha" for information
      on how to use (system friendly) menus and gadgets.

Note: Use the GetArgStr() function of the "dos.library" to get the command
      line options passed to your program.

Warning: You must not run GFA Basic programs using windows under Amiga OS
         3.5 or above because they will crash immediately while closing the
         window.
      
@{b}Blitz Basic@{ub} supports all library functions of the Amiga OS directly; you do
not need to declare any library function. Blitz Basic is of use if you
want your programs to have a nice user interface. The support for graphics
and game creation is excellent. Blitz Basic executables can get very long if
you use a lot of graphics statements, windows, or requesters. The resulting
executables are quite slow, especially if you need to access files. The AGA
chipset is supported. A GUI creator is included.

@{b}AMOS Professional 2.0@{ub} is a good choice if you want do develop multi media
applications.

@{b}PureBasic@{ub} is a new Basic dialect that looks like Blitz Basic 2.
PureBasic provides an integrated development environment and uses so-called
libraries to support windows, screens, Amiga OS, networking, etc.

Executables created by PureBasic are short and fast. An inline assembler is
provided.

The PureBasic source codes used for testing look like the corresponding
Blitz Basic sources except that @{i}NPrint "Hello, world" @{ui}is replaced by
@{i}PrintN ("Hello, world")@{ui}.

Unfortunately, PureBasic 2.9 seems to produce larger executables than
PureBasic 1.x Demo. This might be because of more features.

If you encounter problems in compiling PureBasic sources to disk, one of the
following might apply:

  1. You should use correct PhxAss / PhxLnk versions and options. (Revise the
     PATH environment variable and delete old options from "ENV:Phx#?". I use
     "path work:ace/bin remove" to remove ACE's version of PhxAss from the
     path.)
  2. Compile to "RAM:" instead of the directory containing your source code
  3  Obtain the old "blink" linker from the Aminet and execute the following
     command if you can compile your programs but executing them fails
     (assuming that your executable is named "a"):

       blink a

     This builds "a.exe" which should be executable.

PureBasic Professional is available for Amiga OS 3.0+, Windows 9x/Me/NT/XP, and
Linux. You should use PureBasic if you want to be platform-independent. However,
some modules are not available on all platforms. There are modules for
networking, sound, menus etc. All system calls / OS libraries / OS DLLs may be
used like normal Basic commands or functions, respectively. (PureBasic for
Windows is easier to use than Visual Basic and generates fast and short
executables which need no external libraries.)

Test #2 shows that Cursor executables are the fastest ones in writing text to
a CLI window. The Hisoft Basic executable is quite long and slow.

(If you use the library function @{i}putstr@{ui}, the @{b}Blitz Basic@{ub} program needs
only 713 ticks and the size of the executable file is only 2,320 bytes.)

I prefer using ACE and Maxon Basic, but I also continue using GFA and Blitz
Basic for some programs. In the future, I plan to switch to PureBasic because
it is platform-independent and fast.
@endnode

@node c "C/C++"
@{b}Introduction@{ub}

C and C++ are the most important programming languages. Several operating
systems have been written in C: Unix / Linux, AmigaOS, and Windows.

@{i}C@{ui}

C is an all-purpose programming language like Pascal and Basic. C sources
often look very strange, especially if pointers are used. (C programs usually
contain  zillions of pointers (to pointers, and so forth)). C is sometimes
called a "high-level Assembler" because it combines features of both machine
language and high-level programming languages like Pascal.

C compilers usually generate tons of error messages because missing
characters confuse them and everything is case sensitive.

C executables are usually the fastest ones because they do not perform error
checks. You can declare a string to be 20 bytes long and then write to byte
5 000, for instance. This might crash the operating system if its vital data
has been destroyed. (Users of Microsoft Windows know that such an error is
called a "General Protection Fault / Access Violation".)

C does not provide commands for input / output. It uses library functions
instead. These funtions use cryptic format strings like "%5.2f\\n" which
describe the data types of the variables to be processed. The input function
@{i}scanf()@{ui} is known to be unusable.

The support for strings is very poor - they are only arrays of characters
which are terminated by a special "end of string" character (ASCII 0).
String processing functions are sometimes problematic - some add an "end of
string" character and some do not :-(

@{i}C++@{ui}

C++ is an extension of C which uses references instead of pointers. C++
supports object oriented programming (OOP) by introducing classes, encap-
sulation, and derivation of classes (inheritance). Inheritance allows you
to reuse classes. Functions with different parameter lists may have the same
name (overloading). C++ checks the data types of the variables stronger than
C does.

C++ uses objects for input and output. This results in easier programming
and (sometimes) larger programs. Most C++ compilers provide string classes
which are easier to use than the C functions.

If you want to use C++, have a look at the @{" C++ verification " link cppv} section first.

The most important C++ Compilers are GNU C++ (Unix, Linux, AmigaOS, MS-DOS)
and Borland C++ Builder (Windows).

@{b}Compilers@{ub}

@{b}SAS/C@{ub} is the standard C compiler for the Amiga. You should not use SAS/C to
compile @{b}C++@{ub} source codes because these are converted to C by SAS/C and thus
the resulting executables are very long.

SAS/C does neither support C++ exceptions nor templates.

The optimizer of SAS/C uses auto-register variables, thus the "register"
keyword is not required. All programs can be stopped by hitting <CTRL-C>.

Note: The new (7.01) C++ to C translator which can be found on the Aminet
      generates significantly smaller files than the old one (less than
      20,000 bytes), but it does not support exceptions. It does only
      provide a subset of templates.

SAS/C comes with a lot of utilities, documentation, and example sources.

The @{b}PDC@{ub} compiler does not support all features of ANSI C. It is placed
in the public domain. C++ is not supported.

The free C compiler @{b}VBCC@{ub} comes with a global optimizer and uses the Phx
Assembler and linker. It is able to generate PowerPC executables. One may
use the »ixemul.library« of GNU C/C++ in order to get shorter executables.

@{b}GNU C/C++ (GCC)@{ub} is compatible with UNIX C compilers. Using GCC, you can write
UNIX and Amiga programs. C++ executables are even longer than those created
by SAS/C, but they are also much faster.

Hint: If your programs crash, do not use small code (data) / -fbase-rel or
      increase the stack size.

@{b}egcs@{ub} is the successor of GCC. It creates executables which are larger and
slower than those compiled by GCC 2.7.X because exceptions are enabled by 
default now. GCC 2.9.27 supports all features of the C++ language (templates,
exceptions, STL) and is part of the Experimental GNU Compiler System.

Note: The "ppctools" package provides a PowerPC cross compiler for egcs.

GCC/egcs executables use one of two libraries:

  o "ixemul.library" is an emulation of Unix. You need this library if you
    want to port Unix sources or if you want to get short executables.

  o "libnix" is a link library that does not emulate Unix. Use this library
    in order to avoid "ixemul.library" (about 150 KB) for Amiga executables.

The best C/C++ compilers are Maxon C++ and StormCPP. @{b}Maxon C++@{ub} executables
are slightly more efficient, but @{b}StormCPP@{ub} executables are compatible with
the new @{i}pOS@{ui} operating system and the PowerPC processor chip. StormCPP has
the best programming environment, too. The disadvantage of Maxon C++ and
StormCPP is that they do not support the STL correctly.

StormCPP includes a fast ANSI C library and a MUI class library. Maxon C++
includes an Intuition class library for an easy creation of C++ programs.

The separate @{i}Storm Wizard package@{ui} is used to create graphical user interfaces
very easily.

StormCPP 3.0 creates faster and smaller C executables. The C++ executables are
much larger than those created by StormCPP 2.0.

The @{b}Amiga Developer CD 2.1@{ub} contains a non comercial version of StormCPP 3.0.

Test #2 shows that Maxon C++ creates the shortest executable files, but
StormCPP 2.0 creates the fastest ones. SAS/C and GCC executables are very long,
but they are quite fast, too.

I prefer using StormCPP and egcs.
@endnode

@node Pascal
@{b}Introduction@{ub}

Programming with Pascal is as easy as it is with Basic. Pascal generates
executables which are nearly as fast as those generated by C Compilers.
Pascal supports loops and sub programs. All variables have to be declared
before using them. The compiler checks all accesses to variables before
compiling the program in order to avoid accessing invalid memory
adresses.

The Pascal compiler does a lot of error checks. Thus Pascal executables
generate fewer system crashes than C programs.

A lot of schools and universities still use Pascal for teaching computer
programming.

The most important Pascal compilers are Borland Turbo Pascal (MS-DOS) and
Borland Delphi (Windows). Delphi uses an object oriented extension of Pascal
called Object Pascal and ships with GUI objects and a GUI designer which
is far better than Microsoft Visual C++.

@{b}Compilers@{ub}

@{b}Free Pascal (fpc)@{ub} is a free incarnation of Borland's Delphi / Pascal 7.0
compiler, which is the mother of all Pascal compilers. Unfortunately,
the Amiga port of fpc lacks an IDE.

fpc is in all other aspects like Hisoft Pascal. It supports all standard
units like DOS, CRT, GRAPH, and OBJECTS. It is like an object-oriented
successor of Hisoft Pascal which is used via the command line.

As fpc stems from the Linux operating system, the resulting executables
are quite long (similar to GNU C++).

The documentation of fpc is very good and can be purchased as a book, too.

@{b}PCQ@{ub} is a public domain Pascal compiler. It uses A68k and blink to generate
executables. The 1.2d version supports the Phx Assembler and linker and is
faster than version 1.2b. The »Gfx4PCQ« package provides graphics support
for PCQ and can be found on the Aminet.

PCQ Pascal 2.0 uses a new link library and the successor of A68k (A68kN).
Varargs functions are also supported by PCQ 2.0.

PCQ Pascal 2.1 provides better support for the "triton.library" which is
used for GUI creation.

In comparison to A68kN and blink, using the Phx Assembler and linker in
conjunction with PCQ 2.x will result in shorter executable files. (If you use
PCQ's optimizer and Phx, the executable might be slower than an executable
created by A68kN and blink.)

Note: The "spmake" script has been used to build the test executables.

@{b}Maxon Pascal@{ub} and Hisoft Pascal are commercial Pascal compilers. @{b}Hisoft Pascal@{ub}
has the better programming environment and does even support nearly all 
statements of @{i}Turbo Pascal@{ui} 5.0 for MS-DOS. This is of use if you are
learning Turbo Pascal at school or university and want to write your own
programs. Thus you can run Turbo Pascal on your Amiga and do not have to wait
5 minutes until MS Windows 98 has booted and Turbo Pascal has been loaded...

The graphics support of Hisoft Pascal is excellent because you are able to
use the graphics capabilities of Turbo Pascal. If you want to write a program
which creates business graphics, you should use Hisoft Pascal.

Test #2 shows that HighSpeed Pascal executables provide the fastest output
to CLI windows.

The PCQ 2.0 executable for test #1 is fast.

I prefer using Hisoft Pascal.
@endnode

@node om "Modula and Oberon"
@{b}Introduction@{ub}

@{i}Modula@{ui} is the successor of Pascal and supports modularization.

@{i}Oberon@{ui} is the successor of Modula and supports object oriented programming.

@{b}Compilers@{ub}

@{b}M2Amiga@{ub} supports all features of the Amiga operating system. The resulting
executables are short and fairly fast.

@{b}Turbo Modula@{ub} is a freeware compiler. It uses DICE C to generate the
executables, thus being able to call functions of the standard C run-time
library.

@{b}Cyclone@{ub} is a new object orientated Modula-2 compiler and is giftware. It
supports @{i}multi-threaded executables@{ui} and is able to compile @{i}shared libraries@{ui}.
Cyclone features register access, static lists and C++ exceptions, for
instance. The new version creates shorter executables than version 0.92.

@{b}Oberon_2@{ub} is a commercial Oberon-2 compiler. The newest version is Oberon 3.0.

@{b}Oberon-A@{ub} is a free Oberon-2 compiler. It comes with a lot of documentation
and sample source codes, including an Oberon operating system. Oberon-A is
intended for freeware programmers.

Test #2 shows that the Turbo Modula-2 executable is the fastest one. (Note
that this is also the longest file.) The Oberon-A executable is very slow.

I prefer using Cyclone.
@endnode

@node ol "Other languages"
@{b}DEC@{ub} is similar to but not as powerful as E.

@{b}Struct@{ub} is a very restricted programming language. The resulting executables
are very short and fast.

@{b}EXECREXX@{ub} is an ARexx "compiler". The resulting executable still needs the
@{i}ARexx@{ui} interpreter and thus is very slow.

The @{b}LOGO@{ub} programming language is well known for its "turtle graphics." LOGO
makes extensive use of [lists]. @{b}UCB Logo@{ub} 4.0 adds several extensions to
LOGO (message boxes, filerequester, etc.). UCB Logo 4.0 opens a screen with
16 colours (may be changed via ASL requester).

Note: UCB Logo requires a 68020+ processor.

@{b}GForth Virtual Machine@{ub} is an interpreter. It is freeware and can't
create independent programs yet.

@{b}TILE-Forth Virtual Machine@{ub} is an interpreter. It is freeware and has a
big number of bugs. It can't create independent programs yet.
@endnode

@node as "Authoring systems"
@{b}Introduction@{ub}

Authoring systems like CanDo and Helm are of use for computer based
training only. The scripts associated to buttons and other objects are
interpreted, thus resulting in slow programs.

@{b}Descriptions@{ub}

@{b}CanDo@{ub} executable files are quite long (about 160 KB as for version 2.5), but
they can call the »cando.library« alternatively. 

In contrast to pure scripting languages, CanDo executables run quite fast.

@{b}Helm@{ub} files have to be interpreted by the Helm browser software.
@endnode

@node cbl "Cobol"
@{b}Introduction@{ub}

Cobol is the "COmmon Business Oriented Language" and is used for data bases,
calculations, payroll applications etc. It is mainly used on mainframes and
IBM clones.

Cobol is still the most important programming language.

@{b}Description@{ub}

@{b}NR Cobol@{ub} is used to compile Microsoft Cobol source codes. The resulting ".INT"
files have to be interpreted by the run-time system »runcob«.

You should have no problems in converting most Microsoft / Microfocus Cobol
programs to NR Cobol. (There might be problems in converting the user inter-
faces to the Amiga, because each Cobol has its own set of screen formatting
codes. Even standard commands like ACCEPT have a different syntax.)

The executables generated by NR Cobol are generally smaller than those of
IBM clones. (I know a database management application compiled with Microfocus
Professional Cobol for MS-DOS which needed about five times the disk space of
the corresponding Turbo Pascal executable, still requiring 150 KB of run-time
system.)
@endnode

@node Conclusion
Generally, C/C++ executables are @{b}faster@{ub} than Pascal/Modula/Oberon
executables, which in turn are faster than Basic executables.

On the other side, C++ and Basic executable files can get very @{b}long@{ub} in some
cases.

You should select a programming language which fits your needs concerning the
execution speed and the size of the resulting executable file. If you are a
@{b}beginner@{ub}, I suggest to use Pascal, Modula-2, Oberon, or BASIC.

If you need fast executables, you should use the library functions provided
by the @{b}operating system@{ub} instead of commands offered by your programming
language. (This is very important if you use a Basic compiler like Blitz
Basic 2.)

People learning @{b}C++@{ub} at school or university need to use egcs because the
other compilers do not support all features of this programming language.

If you are looking for a @{b}scripting language@{ub}, your knowledge of programming
languages is important. If you know C or C++, you might want to use Pike.
Other people might want to use Perl or Tcl.
@endnode

@node scando
@{b}Test #1@{ub}

Deck "Name"
    AfterAttachment
        Loop I,1000000
        EndLoop
    EndScript
EndObj

@{b}Test #2@{ub}

Deck "Name"
    AfterAttachment
        Loop I,1000
            Echo "Hello, world"
        EndLoop
    EndScript
EndObj

@endnode

@node sb Basic
@{b}Test #1@{ub}

FOR i& = 1 TO 1000000
NEXT i&

@{b}Test #2@{ub}

FOR t% = 1 TO 1000
  PRINT "Hello, world"
NEXT t%

  
@{b}Optimized version for Blitz Basic 2@{ub}

a$ = "Hello, world" + CHR$(10) ;add carriage return
FOR t.w = 1 TO 1000
  PutStr_ a$                   ;call Amiga OS library function
NEXT t
  
@{b}GFA Basic 3.5 - Test #2@{ub}

The file "*", which is associated to the current CLI, has to be used
since GFA Basic provides no CLI support.

OPEN "o", #2, "*"
FOR t& = 1 TO 1000
  PRINT #2, "Hello, world"
NEXT t&
CLOSE #2

@{b}Cursor - Test #2@{ub}

The file "*", which is associated to the current CLI, has to be used
since Cursor 1.7 provides no CLI support. (Use the "-w0" option to avoid
opening an intuition window.)

open "*" for output as #1
for t% = 1 to 1000
  print #1, "hello, world"
next t%
close #1
@endnode

@node scl "C/C++"
@{b}Test #1@{ub}

#include <stdio.h>
  
main()

  register long t;
  
  for( t = 1; t < 1000000; t++)
  {
  }

@{b}Test #2@{ub}

#include <iostream.h>

main()

  int i;

  for(i = 1; i < 1000; ++i)
  {
    cout << "Hello, world\\n";
  }
  return(0);

  
@{b}Note@{ub}

Listing #1 is a C program, whereas listing #2 is a C++ program.
@endnode

@node spd "PowerD"
@{b}Comparison with E@{ub}

The following sources are similar to that provided
for E.

PowerD does not supports E's REG keyword. WriteF is
replaced by PrintF.

@{b}Test #1@{ub}

PROC main()
  DEFL x
  FOR x:=1 TO 1000000
  ENDFOR
ENDPROC

@{b}Test #2@{ub}

PROC main()
  DEFW x
  FOR x:=1 TO 1000
    PrintF('hello, world\\n');
  ENDFOR
ENDPROC
@endnode

@node sp Pascal
@{b}Test #1@{ub}

program test;
  
var
  t: integer;
  
begin
  for t := 1 to 1000000 do
  begin
  end;
end.

Note: 'longint' has been changed to 'integer' in order to be compatible
      with PCQ Pascal.

@{b}Test #2@{ub}

program hello;

var
  t: integer;

begin
  for t := 1 to 1000 do writeln('Hello, world');
end.
@endnode

@node sm "Modula / Oberon"
@{b}Test #1@{ub}

MODULE test;
  
VAR i: LONGINT;
  
BEGIN
  FOR i := 1 TO 1000000 DO
  END;
END test.

@{b}Test #2@{ub}

MODULE cm;

FROM InOut IMPORT WriteString, WriteLn;

VAR
  i: LONGINT;

BEGIN
  FOR i := 1 TO 1000 DO
    WriteString("Hello World!"); WriteLn;
  END;
END cm.
@endnode

@node se "E"
@{b}Test #1@{ub}

PROC main()
  DEF x:REG
  FOR x:=1 TO 1000000
  ENDFOR
ENDPROC

@{b}Test #2@{ub}
  
PROC main()
  DEF x:REG
  FOR x:=1 TO 1000
    WriteF('hello, world\\n');
  ENDFOR
ENDPROC
@endnode

@node scbl "Cobol"
       identification division.
       program-id. test.
       environment division.
       data division.
       working-storage section.
       01  t pic 9(11).
       procedure division.
       main.
           move 1 to t.
           perform x until t >= 10000.
           stop run.
       x.
           add 1 to t.
@endnode

@node sasm "Assembler"
@{b}Test #1@{ub}

    move.l #1000000,d0
loop:
    subq.l #1,d0  ;"subq" is faster and assembles shorter
    bne.b loop    ;".b" or ".s" declare as short branch = smaller code
    rts
    end

Note: The GNU Assembler "as" does not support the "end" directive - remove it
      in this case.
      
@{b}Test #2@{ub}

execbase = 4

_LVOOpenLibrary  = -552
_LVOCloseLibrary = -414
_LVOOutPut       =  -60
_LVOWrite        =  -48

  lea    DOSName(PC),a1
  move.l execbase,a6
  jsr    _LVOOpenLibrary(a6)
  move.l d0,a6           ;dos always exists anyway
  jsr    _LVOOutPut(a6)  ;get output channel once only!
  move.l d0,d5           ;store in d5 to avoid losing it
  beq.b  exit            ;go away quietly if no output found
  lea Hello(PC),a5       ;store in a5
  move.w #999,d7         ;1000 - 1 as dbra exits when negative
loop:
  move.l d5,d1           ;output channel to d1
  move.l a5,d2           ;text address to d2
  moveq #Hello2-Hello,d3 ;"moveq" because text is less than 128 bytes
  jsr    _LVOWrite(a6)   ;and dump to CLI
  dbf d7,loop            ;will exit when d7 = -1.. 999 to -1 = 1000

exit:
  move.l a6,a1
  move.l execbase,a6
  jsr    _LVOCloseLibrary(a6)
  moveq  #0,d0
  rts

DOSName:
  dc.b 'dos.library',0

Hello:
  dc.b 'Hello, World',10
Hello2:

  END

@{b}Test #2 (GNU C++)@{ub}

@{i}Replace the lines following "rts" with this piece of code:@{ui}

DOSName:                      
  .asciz "dos.library"

Hello:                             
  .ascii "Hello, World"
  .byte 10
Hello2:

Note: The GNU Assembler "as" does not support the Amiga directives - "dc.b"
      must be replaced by ".ascii", for instance. "end" must be removed.

@{b}Test #2, C-like Assembler@{ub}

Stuart Kyzer Caie recommends the following piece of code for Test #2.

The program writes its output to a buffer and displays the whole buffer after
that. Thus the overhead of the operating system is reduced.

_LVOOpenLibrary  = -552          
_LVOCloseLibrary = -414
_LVOOutput       =  -60
_LVOWrite        =  -48

        SECTION 1,CODE

        lea     DOSName(pc),a1
        moveq   #0,d0
        move.l  4.w,a6
        jsr     _LVOOpenLibrary(a6)
        tst.l   d0
        beq.b   nodos
        move.l  d0,a6

        lea     PrintBuf,a2
        move.l  a2,a1
        move.w  #1000-1,d0
oloop:  lea     Hello(pc),a0
iloop:  move.b  (a0)+,(a1)+
        bne.b   iloop
        subq    #1,a1
        dbra    d0,oloop

        jsr     _LVOOutput(a6)
        move.l  d0,d1
        beq.b   nofh
        move.l  a2,d2
        move.l  #EndPrintBuf-PrintBuf,d3
        jsr     _LVOWrite(a6)

nofh:   move.l  a6,a1
        move.l  4.w,a6
        jsr     _LVOCloseLibrary(a6)
nodos:  moveq   #0,d0
        rts

DOSName:
  dc.b 'dos.library',0

Hello:
  dc.b 'Hello, World',10,0

        SECTION 2,BSS
PrintBuf:
        ds.b    13000
EndPrintBuf:

        END
@endnode

@node tp "Test programs"
@{b}Introduction@{ub}

The test program #1 consists of a loop counting from 1 to 1,000,000 using
long integer variables.

Test program #2 writes "Hello, world" 1,000 times and is run in the CLI.

Error checks have been disabled. If necessary, Motorola 68000 object code
generation has been selected.

@{b}Note@{ub}

Before using the programs, replace double slashes (\\\\) by single ones (\\).
AmigaGuide requires all documents to use double slashes because single
slashes are used my AmigaGuide itself.

@{b}Listings@{ub}

@{" ARexx sources " link sar}

@{" Assembler sources " link sasm}

@{" Basic sources " link sb}

@{" C/C++ sources " link scl}

@{" CanDo sources " link scando}

@{" Cobol sources " link scbl}

@{" E sources " link se}

@{" Fortran sources " link 4tran}

@{" Forth sources " link TILE_GForth}

@{" Korn shell (pdksh) sources " link sksh}

@{" LOGO sources " link slog}

@{" Modula/Oberon sources " link sm}

@{" Pascal sources " link sp}

@{" Perl sources " link sper}

@{" Pike sources " link spik}

@{" PowerD sources " link spd}

@{" Python sources " link spy}

@{" Tcl sources " link stcl}
@endnode

@node spy "Python sources"
@{b}Test #1@{ub}

i = 0
while i < 1000000:
    i = i+1

@{b}Test #2@{ub}

i = 0
while i < 1000:
    i = i+1
    print "hello, world"
@endnode

@node slog "LOGO sources"
@{b}Test #1@{ub}

for [i 1 1000000] []
bye

@{b}Test #2@{ub}

for [i 1 1000] [print [hello, world]]
bye
@endnode

@node spik "Pike sources"
@{b}Test #1@{ub}

int main()

  int i;
  for(i = 0; i < 1000000; i++)
  {
  }

@{b}Test #2@{ub}

int main()

  int i;
  for(i = 0; i < 1000; i++)
  {
    write("hello, world\\n");
  }

@endnode

@node stcl "Tcl sources"
@{b}Test #1@{ub}

set x 0
while {$x < 1000000} {
  incr x;

@{b}Test 2@{ub}

set x 0
while {$x < 1000} {
  incr x;
  puts "Hello, world";

@endnode

@node sksh "Korn shell (pdksh) sources"
@{b}Test #1@{ub}

i=0
while [ $i -lt 1000000 ]
do
  let i=$i+1
done

@{b}Test #2@{ub}

i=0
while [ $i -lt 1000 ]
do
  echo "Hello, world"
  let i=$i+1
done
@endnode

@node sper "Perl sources"
@{b}Test #1@{ub}

for( $i=0; $i<1000000; $i++)

@{b}Test #2@{ub}

for( $i=0; $i<1000; $i++)

  print "Hello, world\\n"

@{b}Alternative sources@{ub}

Stuart Kyzer Caie supplied the following alternatives for test #1 and
test #2:

# test 1
for (1..1000000) { }

# test 2
print "Hello, World\\n" x 1000;

On my Amiga, test #2 is a little bit slower than before. Executing the
script for test #1 generates an "Out of memory" error message.
@endnode

@node sar "ARexx sources"
@{b}Test #1@{ub}

/**/
do i = 1 to 1000000
end i

@{b}Test #2@{ub}

/**/
do i = 1 to 1000
  say "Hello, world"
end i

Note: Each program must start with a comment (/* ... */).
@endnode

@node 4tran "Fortran sources"
@{b}Test #1@{ub}

c     Program Test#1
      DO i = 1,1000000
      ENDDO
      STOP
      END

@{b}Test #2@{ub}

c     Program Test#2
      DO i = 1,1000
        WRITE(*,*)'Hello, World'
      ENDDO
      STOP
      END
@endnode

@node TILE_GForth "GForth and TILE-Forth Virtual Machines"
@{b}Test #1@{ub}

: Test#1 ( -- )
  1000001 1 do loop ;

@{b}Test #2@{ub}

: Test#2 ( -- )
  1001 1 do
           ." Hello, World" cr
         loop ;
@endnode

@node Author
This document may be freely distributed. I hope that it is helpfull for
people looking for a programming language which fits their needs.

If you want to send me a report of another programming language, please
include the following:

  o  compiler options enabled
  o  a short description of the programming language
  o  the source codes of the test programs
  o  a description of your Amiga
  o  the output of »cbsi«

Send bug reports and / or suggestions to:

Frank Reibold
Ottberger Weg 13
D-31737 Rinteln

GERMANY

eMail: frank@reibold-online.de

Inernet: www.reibold-online.de

@endnode

@node hist
1.00   First public release.

2.00   o  revised / updated comparisons
       o  added E, Cobol, Authoring Systems, and AMOS section
       o  new cbsi utility

3.00   o  revised / updated comparisons
       o  added GNU Fortran 77, GForth 0.4.0 and TILE-Forth 3.33 Virtual
          Machines
       o  new cbsi utility (MIPS calculation changed, MFLOPS calculation
          added)
          
4.00   o  new results for *all* tests and *all* languages (some had been
          wrong)
       o  added test #2 for GFA Basic
       o  added PCQ Pascal 2.x results
       o  added short description of A68kN
       o  revised Assembler descriptions

5.00   o  revised E sources and description
       o  added egcs (GCC 2.8+) description and results
       o  added C++ verification test, sources, and results
       o  new Assembler results, descriptions, and sources
       o  revised some results of test #2
       o  added a general introduction for each of the programming
          languages
       o  revised G77 description and results
       o  added UCB Logo and Bywater Basic
       o  added a "Scripting Languages" section which describes Perl etc.
       o  revised Cursor 1.7 results
       o  improved version of »exe_timer«
       o  updated SAS/C description and results to version 6.58
       o  updated VBCC description and results
       o  added Creative E description
       o  new version of »cbsi« for Amiga OS 3.5
       o  updated Storm C description and results to version 3.0
       o  added Pure Basic section
       o  added BRexx section

6.00   o  Revised CanDo sources, description, and results
       o  faster Assembler sources with results
       o  alternative Perl sources
       o  Revised GCC/egcs results and description
       o  optimized Assembler sources
       o  discussion of startup codes and optimizations

7.00   o added PowerD description
       o new "cbsi" detects Amiga OS 3.9
       o new "cbsi" calculates MIPS ans FLOPS more precisely under
         Amiga OS 3.9
       o revised Creative E description and results due to
         new version 2.x
       o added Free Pascal (fpc) description and results

8.00   o revised PureBasic section and results
       o revised text
@endnode

@node Credits
The information for GNU Fortran 77, GForth 0.4.0 and TILE-Forth 3.33 Virtual
Machines has been supplied by:

     Andrei Shestakov       e-mail:mobydick@aha.ru
     Amiga1260/50           http://www.aha.ru/~mobydick
                            2:5020/659.79@FidoNet
                            39:241/200.60@AmigaNet

                            
Revised results for PCQ Pascal 1.2d have been supplied by:

     Nils Sjoholm (nils.sjoholm@mailbox.swipnet.se)

Hints for optimizing the E sources have been supplied by:

     Rainer Müller

The CanDo source codes have been supplied by:

    AMiga CLUb STeinfurt
    Christian Effenberger (YouCan@A2.amclust.de) 

The C-like Assembler sources and the alternatives for Perl
have been supplied by:

    Stuart Kyzer Caie -- kyzer@4u.net
    http://zap.to/kyz    ICQ: 45612337

Notes about egcs and Assembler have been supplied by:

    Gunther Nikl
    gni@gecko.de

Notes about Assembler and optimizations have been
supplied by:

    Olaf Koenders
    ollyk@one.net.au

Notes about PowerD have been provided by its
author:

    Martin Kuchinka
    kuchinka@volny.cz
@endnode

@node cppv "C++ verification"
This section helps you in verifying whether your C++ compiler supports all
features of C++.

@{b}Tests@{ub}

A C++ compiler must support exceptions and templates and should be able to
compile programs using the STL. (Your compiler package should include a copy
of the STL.)

Exceptions execute parts of your program if an unusual situation occurs, e. g.
           dividing by zero.

Templates  allow you to write a piece of code for one generic data type and let
           the C++ compiler generate the source code for the data type actually
           used by your program. This is of use e. g. for stacks which hold
           objects of a certain data type. Thus templates result in
           programming less than before.

STL        The "Standard Template Library" provides templates for a variety of
           objects, including vectors and stacks.

@{i}Exceptions@{ui}

@{" e.cpp " system "more cpp_verification/e.cpp"} tests whether your compiler supports exceptions. The program tries
to divide 3 by 0 and thus throws an exception.

@{" e.out " system "more cpp_verification/e.out"} is the result you should see on your screen.

@{i}STL@{ui}

@{" s.cpp " system "more cpp_verification/s.cpp"} tests whether your compiler supports the Standard Template Library
(STL). egcs is the only compiler which comes with a copy of the STL. If you
have another compiler, you should have a look at @{u}http://www.sgi.com@{uu}.

@{" s.out " system "more cpp_verification/s.out"} is the result.

@{i}Templates@{ui}

@{" t.cpp " system "more cpp_verification/t.cpp"} tests whether your compiler supports templates. The program consists
of a swap() function which is suitable for nearly all data types.

@{" t.out " system "more cpp_verification/t.out"} is the result. (The order of the numbers should be reversed in the
second line.)

@{b}C++ compilers@{ub}

  Test / Compiler | egcs 1.0.2  Maxon C++ 3.0  StormCPP 2.0  SAS/C 6.58
  -------------------------------------------------------------------------
  Exceptions      |     83,684          5,168        11,068  Exceptions and
  STL             |     87,784   *** compilation error ***   templates are
  Templates       |     83,444          3,496         9,036  not supported

@{b}Results@{ub}

Only egcs 1.0.2 is a true C++ compiler. Maxon C++ and StormCPP are not able
to compile the STL header files.

SAS/C converts from C++ to C. The new (7.01) translator supports a subset
of templates only.
@endnode

@node TheIndex Index
@remark Index created with 'mkagidx' (C) Captain CrossBones

@{"Abbreviations" link ab}
@{"ARexx sources" link sar}
@{"Assembler sources" link sasm}
@{"Assembler" link Assembler}
@{"Author" link Author}
@{"Authoring systems" link as}

@{"Basic sources" link sb}
@{"Basic" link Basic}

@{"C++ verification" link cppv}
@{"C/C++ sources" link scl}
@{"C/C++" link c}
@{"CanDo sources" link scando}
@{"Cobol sources" link scbl}
@{"Cobol" link cbl}
@{"Conclusion" link Conclusion}
@{"Credits" link Credits}

@{"E sources" link se}
@{"E" link E}
@{"e.cpp" system "more cpp_verification/e.cpp"}
@{"e.out" system "more cpp_verification/e.out"}

@{"Forth sources" link TILE_GForth}
@{"Fortran sources" link 4tran}
@{"Fortran" link Fortran}

@{"General comparison" link gc}

@{"History" link hist}
@{"How the execution times have been measured" link htm}

@{"Introduction" link Introduction}

@{"Korn shell (pdksh) sources" link sksh}

@{"LOGO sources" link slog}

@{"Modula and Oberon" link om}
@{"Modula/Oberon sources" link sm}

@{"Notes about startup codes and optimizations" link sacodes}
@{"Notes concerning the execution speeds" link nes}
@{"Notes concerning the program lengths" link npl}

@{"Other languages" link ol}

@{"Pascal sources" link sp}
@{"Pascal" link Pascal}
@{"Perl sources" link sper}
@{"Pike sources" link spik}
@{"Python sources" link spy}

@{"s.cpp" system "more cpp_verification/s.cpp"}
@{"s.out" system "more cpp_verification/s.out"}
@{"Scripting languages" link batch}
@{"Speed comparison" link sc}

@{"t.cpp" system "more cpp_verification/t.cpp"}
@{"t.out" system "more cpp_verification/t.out"}
@{"Tcl sources" link stcl}
@{"Test #1 (for loop)" link t1}
@{"Test #2 (CLI window output)" link t2}
@{"Test programs" link tp}
@endnode
