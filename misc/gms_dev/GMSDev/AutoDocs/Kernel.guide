@DATABASE "DPKernel"
@AUTHOR   "Paul Manias"
@NODE     "Main" "Library: DPKernel"

@{b}@{u}SYSTEM DOCUMENTATION@{uu}@{ub}
Name:      @{"DPKERNEL" LINK "Functions"}
Version:   2.1
Date:      October 1998
Author:    Paul Manias
Copyright: DreamWorld Productions, 1996-1998.  All rights reserved.
Note:      Please report any documentation errors to pmanias@ihug.co.nz

@{b}@{u}CHANGES VERSION 2.1@{uu}@{ub}
Added:   AddResource()
         FreeResource()
         GetContainer()
         SetContext()

Edited:  FindDPKTask()
         TotalMem()

Removed: AddTrack()
         DeleteTrack()
         AddSysEvent()
         RemSysEvent()

Replaced: CheckField() with FindField()

@{b}@{u}CHANGES VERSION 2.0@{uu}@{ub}
Added:   AllocObjectID()
         CheckField()
         CloneMemBlock()
         DebugOff()
         DebugOn()
         GetByName()
         GetField()
         GetFieldName()
         FindReference()
         FindSysName()
         SetField()
         SetFieldName()

Edited:  AllocMemBlock() [MEM_NOCLEAR]

@{b}@{u}CHANGES VERSION 1.1@{uu}@{ub}
Added:   Rename()
         Realloc()
         CheckAction()

Edited:  AllocMemBlock()

@{b}@{u}CHANGES VERSION 1.0@{uu}@{ub}
Added:   Unhook()
         MoveToBack()
         MoveToFront()
         GetExtension()
         GetFileType()
         GetTypeList()
         AttemptExclusive()
         Exclusive()
         FreeExclusive()
         Seek()
         RemSysObject()
         CheckInit()

Renamed: Save() to SaveToFile()
         Display() to Show()

Edited:  Detach()
         SaveToFile()
         SelfDestruct()
         AllocMemBlock()
         Init()
         Get()
         Clear()
         AddSysObject()
         AddTrack()
         FastRandom() [Synopsis]
         SlowRandom() [Synopsis]
         FindSysObject()
         Load()
         SaveToFile()

Removed: Switch()

@{b}@{u}CHANGES VERSION 0.9B@{uu}@{ub}
Added:   Flush()
         Read() (moved from files.guide)
         Reset()
         Write() (moved from files.guide)
         Detach()
         AutoStop()

         @{u}Moved from the master.guide@{uu}
         FastRandom()
         ReadKey()
         SlowRandom()
         WaitLMB()
         WaitTime()
         WriteDec()

Deleted: SetUserPrefs()
         WaitLMB()
         WriteDec()
         ReadKey()
         AutoSwitch()

Edited:  WaitTime()
         CloseDPK()
         Activate()
         AddSysObject()

@EndNode
---------------------------------------------------------------------------
@NODE "Functions" "DPKernel"

 @{b}OBJECTS@{ub}
 @{"ItemList" LINK "GMSDev:AutoDocs/Objects/ItemList.guide/Description"}
 @{"Module" LINK "GMSDev:AutoDocs/Objects/Module.guide/Description"}
 @{"RawData" LINK "GMSDev:AutoDocs/Objects/RawData.guide/Description"}
 @{"Reference" LINK "GMSDev:AutoDocs/Objects/Reference.guide/Description"}
 @{"Segment" LINK "GMSDev:AutoDocs/Objects/Segment.guide/Description"}
 @{"SysObject" LINK "GMSDev:AutoDocs/Objects/SysObject.guide/Description" }
 @{"Task" LINK "GMSDev:AutoDocs/Objects/Task.guide/Description"}
 @{"Time" LINK "GMSDev:AutoDocs/Objects/Time.guide/Description"}

 @{b}FUNCTIONS@{ub}
 @{"AutoStop()" LINK "AutoStop()"}
 @{"CloseDPK()" LINK "CloseDPK()"}
 @{"DebugOff()" LINK "DebugOff()"}
 @{"DebugOn()" LINK "DebugOn()"}
 @{"DPKForbid()" LINK "DPKForbid()"}
 @{"DPKPermit()" LINK "DPKPermit()"}
 @{"FastRandom()" LINK "FastRandom()"}
 @{"FindDPKTask()" LINK "FindDPKTask()"}
 @{"GetByName()" LINK "GetByName()"}
 @{"GetContainer()" LINK "GetContainer()"}
 @{"GetExtension()" LINK "GetExtension()"}
 @{"GetFileType()" LINK "GetFileType()"}
 @{"GetTypeList()" LINK "GetTypeList()"}
 @{"OpenModule()" LINK "OpenModule()"}
 @{"SlowRandom()" LINK "SlowRandom()"}
 @{"WaitTime()" LINK "WaitTime()"}

 @{b}Field Handling@{ub}
 @{"FindField()" LINK "FindField()"}
 @{"GetField()" LINK "GetField()"}
 @{"GetFieldName()" LINK "GetFieldName()"}
 @{"SetField()" LINK "SetField()"}
 @{"SetFieldName()" LINK "SetFieldName()"}

 @{b}Memory Management@{ub}
 @{"AllocMemBlock()" LINK "AllocMemBlock()"}
 @{"CloneMemBlock()" LINK "CloneMemBlock()"}
 @{"FreeMemBlock()" LINK "FreeMemBlock()"}
 @{"GetMemSize()" LINK "GetMemSize()"}
 @{"GetMemType()" LINK "GetMemType()"}
 @{"Realloc()" LINK "Realloc()"}
 @{"TotalMem()" LINK "TotalMem()"}

 @{b}Resource Tracking@{ub}
 @{"AddResource()" LINK "AddResource()"}
 @{"FreeResource()" LINK "FreeResource()"}
 @{"InitDestruct()" LINK "InitDestruct()"}
 @{"SelfDestruct()" LINK "SelfDestruct()"}

 @{b}System Functions@{ub}
 @{"AddSysObject()" LINK "AddSysObject()"}
 @{"AllocObjectID()" LINK "AllocObjectID()"}
 @{"FindReference()" LINK "FindReference()"}
 @{"FindSysName()" LINK "FindSysName()"}
 @{"FindSysObject()" LINK "FindSysObject()"}
 @{"RemSysObject()" LINK "RemSysObject()"}
 @{"SetContext()" LINK "SetContext()"}
 @{"TagInit()" LINK "TagInit()"}

 @{b}ACTIONS@{ub}
 @{"Activate()" LINK "Activate()"}
 @{"AttemptExclusive()" LINK "AttemptExclusive()"}
 @{"CheckAction()" LINK "CheckACtion()"}
 @{"CheckExclusive()" LINK "CheckExclusive()"}
 @{"CheckInit()" LINK "CheckInit()"}
 @{"CheckLock()" LINK "CheckLock()"}
 @{"Clear()" LINK "Clear()"}
 @{"Copy()" LINK "Copy()"}
 @{"CopyStructure()" LINK "Copystructure()"}
 @{"Deactivate()" LINK "Deactivate()"}
 @{"Detach()" LINK "Detach()"}
 @{"Draw()" LINK "Draw()"}
 @{"Exclusive()" LINK "Exclusive()"}
 @{"Flush()" LINK "Flush()"}
 @{"Free()" LINK "Free()"}
 @{"FreeExclusive()" LINK "FreeExclusive()"}
 @{"Get()" LINK "Get()"}
 @{"Hide()" LINK "Hide()"}
 @{"Init()" LINK "Init()"}
 @{"Load()" LINK "Load()"}
 @{"Lock()" LINK "Lock()"}
 @{"MoveToBack()" LINK "MoveToBack()"}
 @{"MoveToFront()" LINK "MoveToFront()"}
 @{"Query()" LINK "Query()"}
 @{"Read()" LINK "Read()"}
 @{"Rename()" LINK "Rename()"}
 @{"Reset()" LINK "Reset()"}
 @{"SaveToFile()" LINK "SaveToFile()"}
 @{"Seek()" LINK "Seek()"}
 @{"Show()" LINK "Show()"}
 @{"Unhook()" LINK "Unhook()"}
 @{"Unlock()" LINK "Unlock()"}
 @{"Write()" LINK "Write()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Activate()" "Kernel: Activate()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Activate()
Short:    Perform the native action of the object.
Synopsis: LONG Activate(*Object [a0]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  executes  the native action for a given object.  The action
taken  by  each object class is extremely varied, here are some examples of
what some current objects do for Activate():

  Sound     - Plays sample data over the speakers.
  Restore   - Replaces destroyed backgrounds.
  Directory - Grabs a list of directory contents.
  JoyData   - Reads a joyport.

Some objects will continue to perform their native action after they return
back  to  you,  for  example  a Sound will play in the background while you
continue  processing.  If for some reason you wish to cancel an action, you
can attempt a call to Deactivate().

@{b}@{u}INPUT@{uu}@{ub}
Object - Pointer to an initialised object structure.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK on success.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Deactivate()" LINK "Deactivate()"}

@EndNode
---------------------------------------------------------------------------
@NODE "AddSysObject()" "Kernel: AddSysObject()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     AddSysObject()
Short:    Adds a new object to the system.
Synopsis: *SysObject AddSysObject(WORD ClassID [d0], WORD ObjectID [d1],
            BYTE *Name [a1], APTR Tags [a0]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  adds  a new object/class to the system.  This allows you to
create  an  object  that  supports  the various "Action" functions, such as
Init(),  Get(), Free() etc.  Here is an example for the initialisation of a
JPEG object:

  JPEGObject = AddSysObjectTags(ID_PICTURE, ID_CHILD, "Jpeg",
                 TAGS, NULL,
                 SOA_FileExtension,    "jpeg;jpg",
                 SOA_FileDesc,         "Jpeg (J Bloggs)",
                 SOA_CopyToUniverse,   &PIC_CopyToUniverse,
                 SOA_CopyFromUniverse, &PIC_CopyFromUniverse,
                 SOA_Load,             &PIC_Load,
                 TAGEND);

In this example, AddSysObject() will create a Child type (called Jpeg) that
belongs to the Picture class.  Because child types inherit actions from the
parent, this Jpeg object will also support actions such as Query(), Init(),
Get() and Free().

Since  Jpeg  is  a  file-based  object,  we  also set the FileExtension and
FileDesc   fields   appropriately   (read   about  this  in  the  SysObject
documentation).

@{u}Master Objects@{uu}
Any  SysObject  that is created with ObjectID == ClassID will be treated as
the  master  object  of  the  class.  If a master is already present in the
system  when  you  do this, AddSysObject() will NOT create a new SysObject.
Instead  it  will add your object specifications to the existing SysObject,
as a way of "enhancing" its support.

To  illustrate:   If  you  were  to  add  a  Picture  master  with a tag of
SOA_Activate,  and  the existing Picture does not support that action, your
supporting  function  will be added to the existing Picture master.  If you
specify  SOA_Activate|TREPLACE,  then your Activate function will be placed
in  the  Picture  master  even  if  it  already has support for Activate().
Please  do  not take the TREPLACE flag lightly - only do this if absolutely
necessary.

@{u}Child Objects@{uu}
These  object  types are useful when you want to add support for a new data
format to an object.  Example:  Normally when a jpeg picture is loaded, the
master  class  will  fail because it only supports IFF files.  This failure
will  cause  the Load() function to look for child objects belonging to the
ID_PICTURE  class.  Consequently if the Jpeg support object was present, it
would  tell the system "Yes I understand this format" and the file would be
loaded.

To  declare  a  child  object,  set  ID_CHILD  in  ObjectID,  and the class
identifer in ClassID (e.g. ID_PICTURE).

Remember  that  as  a  child  object, you get function inheritance from the
master.   So if any action is unsupported by your object, you will still be
able to inherit support from the master's functions.

@{u}Hidden Objects@{uu}
You  can  declare a "hidden" system object by passing ID_HIDDEN in both the
ClassID and ObjectID arguments.  What this creates is an object that has no
identification  characters.   This means that the only way for a program to
find your object in the system is going to be through the Name.

By  using  hidden  objects,  you  can  create  your own SysObjects for your
personal projects.

@{u}Application Objects@{uu}
If  you  wish  to  create  your own object orientated programs by using the
system,   call   AllocObjectID()   and   then   send  the  returned  ID  to
AddSysObject().  By doing this, you can create object orientated structures
that can also be used by other Tasks (but you will need to tell them the ID
number).

@{b}@{u}INPUT@{uu}@{ub}
ClassID
  Specify  the  class  that your object belongs to, or ID_HIDDEN if you are
  creating a hidden object.

ObjectID
  If  you  are  the master of a class, use your ClassID here.  If you are a
  child, specify ID_CHILD.  If you are hidden, use ID_HIDDEN.

Name
  Specifies a string pointing to the name that you wish to give the object.
  NOTE  that  your  name  should  not  be  the same as other objects in the
  system!   If  you are concerned about this, you can register your name at
  DreamWorld Productions in order to protect it.

Tags
  Pointer to a standard tag list.

@{b}@{u}RESULT@{uu}@{ub}
Returns a pointer to the created SysObject or NULL if failure.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"AllocObjectID()" LINK "AllocObjectID()"}
        @{"Free()" LINK "Free()"}
        @{"RemSysObject()" LINK "RemSysObject()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "AddResource()" "Kernel: AddResource()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     AddResource() (V2.1)
Short:    Adds a resource tracking node to an object.
Synopsis: *Resource AddResource(*Object [a0], WORD Type [d0], *Pointer [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This function is intended for use by the system modules, but you may use it
in your program if necessary.

@{u}About Resource Tracking@{uu}
Each  object  is  given  a  special  list  of  system  resources that it is
currently  using.   Each  resource  has  its  own  list  node that uniquely
identifies  it  as  either  an Object or Memory pointer.  When a particular
resource  has  been  freed  the  list  is  checked  and its related node is
deleted.   When the program shuts down, any resources that are still in the
list  can be freed by the kernel so that unused resources are not lingering
in the system.

When you call AddResource() you need to give it a resource ID which will be
one of the following types:

  RSF_OBJECT
  RSF_MEMORY

This  determines  wether  the  Pointer argument is pointing to an object or
memory  block.   The  Object  argument is optional, if you leave it as NULL
then the resource will be added to the current Task.

@{b}@{u}NOTE@{uu}@{ub}
Remember to call FreeResource() once the resource is no longer in use.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to the object that you want to track the resource against.  The
  object must be a valid structure obtained from Get(), otherwise use NULL
  to associate the resource node with the current Task.

Type
  Either RSF_OBJECT or RSF_MEMORY.

Pointer
  Points to a memory block or object, as dependant on the Type.

@{b}@{u}RESULT@{uu}@{ub}
Returns the resource node that has been allocated to the object.  You can
use this pointer when calling FreeResource().

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"FreeResource()" LINK "FreeResource()"}

@EndNode
---------------------------------------------------------------------------
@NODE "AllocMemBlock()" "Kernel: AllocMemBlock()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     AllocMemBlock()
Short:    Allocate a new memory block.
Synopsis: APTR AllocMemBlock(LONG Size [d0], LONG MemType [d1]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  allocates  a  memory  block from the system memory pool and
returns it to your program.  By default all memory is private.  If you want
to pass a memory block to another Task, you will have to use the MEM_PUBLIC
flag when allocating your memory.

@{u}Protection and Resource Tracking@{uu}
Header  and  Tail  ID's  are  used  to  offer  a security system similar to
MungWall,  acting  as  cookies  at each end of a memory block.  You will be
alerted  by  FreeMemBlock()  if  the ID's are damaged.  This is a permanent
debugging  feature,  so  there is little need to run MungWall for debugging
your programs.

Resource  tracking  is  automatic,  so  you  will be warned if you allocate
memory  and forget to free it on exit (ie when you close down).  Any memory
that is found will be freed for your convenience.

By  default  all memory is cleared before it is given to you.  Here are the
memory types:

  @{u}MEM_DATA@{uu}
  Suitable for storing data and variables, this is the default allocation
  type.  On the Amiga, MEM_DATA is allocated in Fast memory if available,
  otherwise it will use Chip memory.  Note that you are disallowed from
  running program code in MEM_DATA memory blocks.

  @{u}MEM_CODE@{uu}
  This can store and execute CPU instructons.  It also fits the
  requirements of MEM_DATA, so you can store variables and data in it.

  @{b}For the following mem-types, please use their associated functions
  to allocate them (ie AllocVideoMem(), AllocBlitMem(), AllocSoundMem()).@{ub}

  @{u}MEM_VIDEO@{uu}
  Is for displaying graphics, and is also compatible with the Blitter
  interface.

  @{u}MEM_BLIT@{uu}
  This memory is compatible with the blitter module.  Currently this module
  only uses chip memory, but future versions could also support CPU drawing
  from fast if the graphic is located in that area.

  @{u}MEM_SOUND@{uu}
  For memory that is compatible with the Sound interface.

You  may  also  use  the  following  extra  flags  when  making your memory
allocation:

  @{u}MEM_PUBLIC@{uu}
  If other programs should have access to your memory.

  @{u}MEM_PRIVATE@{uu}
  Make certain that only your task has access to the memory.

  @{u}MEM_UNTRACKED@{uu}
  Set if you don't want resource tracking on your allocation.  Untracked
  memory will still be contained by the system task, allowing it to be
  detected during a system shutdown.

  @{u}MEM_RESOURCED@{uu}
  This special flag is only for use by the system.  Resourced memory is
  specified for blocks that are to be tracked under a different type.

  @{u}MEM_NOCLEAR@{uu}
  If you specify this flag, AllocMemBlock() will not waste time in clearing
  the memory.

@{b}@{u}INPUT@{uu}@{ub}
Size
  Size of the required memblock in bytes.

MemType
  The type of memory to allocate, eg MEM_VIDEO.

@{b}@{u}RESULT@{uu}@{ub}
Pointer to the start of your allocated memblock or NULL if failure.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"FreeMemBlock()" LINK "FreeMemBlock()"}
        @{"GetMemSize()" LINK "GetMemSize()"}
        @{"GetMemType()" LINK "GetMemType()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "AllocObjectID()" "Kernel: AllocObjectID()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     AllocObjectID() (V2.0)
Short:    Generates a unique Object ID for your program's use.
Synopsis: LONG AllocObjectID()

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  generates  unique  Object  ID's that any program can use to
create new System Objects.  Any ID that comes from this function is safe to
use with AddSysObject().

There is no need to free your allocated ID once you have finished with it.
Allocated Object ID's start at 15,000 and end at 30,000.

@{b}@{u}RESULT@{uu}@{ub}
Returns  an  Object  ID that you can use for AddSysObject().  This function
never fails, so you will always get a valid ID.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"AddSysObject()" LINK "AddSysObject()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "AttemptExclusive()" "Kernel: AttemptExclusive()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     AttemptExclusive()
Short:    Make an attempt for exclusive access to an object.
Synopsis: LONG AttemptExclusive(*Object [a0], WORD MicroSeconds [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This function is provided so that Tasks can gain exclusive access to public
objects.   This  is  often  necessary  to prevent tasks from using the same
object  at  the  same time (very dangerous).  If your Task is running under
multiple processes, then you may want to use this action to synchronise the
use of your objects.

Once  you  call  this action, it will immediately attempt to get the object
for  you.   If  it cannot, it will wait until it becomes available within X
amount  of  MicroSeconds.   If  time  runs  out,  the call will return with
ERR_TIMEOUT.   If  successful,  ERR_OK  will be returned and your Task will
have  exclusive  access  to the object.  Once you are done with the object,
call FreeExclusive() to allow other Tasks to use it.

@{b}@{u}NOTE@{uu}@{ub}
ALL  OBJECTS are capable of supporting exclusive locking, even if it is not
mentioned  in their documentation.  Exclusive locks are handled entirely by
the kernel, which helps to relieve objects from handling this mode.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to an initialised object that you want exclusive access to.

MicroSeconds
  The  amount of micro-seconds you are prepared to wait before your attempt
  times-out.   The  maximum wait is 5 minutes (30000 micro-seconds).  Use a
  value of 0 if you only want to try once.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK if you have gained exclusive access to the object.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"CheckExclusive()" LINK "CheckExclusive()"}
        @{"Exclusive()" LINK "Exclusive()"}
        @{"FreeExclusive()" LINK "FreeExclusive()"}

@EndNode
---------------------------------------------------------------------------
@NODE "AutoStop()" "Kernel: AutoStop()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     AutoStop()
Short:    Pauses your task when the user leaves your screen or windows.
Synopsis: void AutoStop(void)

@{b}@{u}DESCRIPTION@{uu}@{ub}
If the user moves away from your task by switching to a different screen or
window, you may want to pause your actions until the user returns the focus
back  to  your  task.   This  is  very useful in games and other "non-stop"
programs  which  can  continue  regardless  of  any user interaction.  Such
non-stop  programs  can be counter productive if the user is at a different
task, and your program is stealing resources in the background.

If  this  function  finds that the user has moved away, it pauses your task
immediately.   When  the user returns the focus to your task, this function
will execute the next instruction in your program.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Switch()" LINK "Switch()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Awaken()" "Kernel: Awaken()"

Private.

@EndNode
-----------------------------------------------------------------------------
@NODE "CallEventList()" "Kernel: CallEventList()"

Undocumented.

@EndNode
-----------------------------------------------------------------------------
@NODE "CheckAction()" "Kernel: CheckAction()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     CheckAction()
Short:    Finds out if an object supports a specific action.
Synopsis: CheckAction(*Object [a0], LONG ActionTag [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  checks  if  a  particular  object's  class supports a given
action.  This is enabled through the SOA Tags of the SysObject.

@{b}@{u}EXAMPLE@{uu}@{ub}
To check if a Picture object supports Query(), you would do this:

   ErrCode = CheckAction(Picture, SOA_Query);

The  use of CheckAction() is fairly straightforward and there are no hidden
details.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to the object/class that you want to check.

ActionTag
  One of the SOA action tags as specified in "system/sysobjects.h".

@{b}@{u}RESULT@{uu}@{ub}
If  the  object  supports  the  specified  action  then ERR_OK is returned,
otherwise ERR_NOSUPPORT will be returned to indicate that the action is not
supported.  If some other error occurs (e.g.  you pass incorrect arguments)
then one of the failure codes will be returned.

@{b}@{u}SEE ALSO@{uu}@{ub}
Include: @{"system/sysobject.h" LINK "GMSDev:Includes/system/sysobject.h/Main"}

@EndNode
-----------------------------------------------------------------------------
@NODE "CheckExclusive()" "Kernel: CheckExclusive()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     CheckExclusive()
Short:    Checks if an object is currently in exclusive mode.
Synopsis: *DPKTask CheckExclusive(*Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  allows  you to check if an object is currently in exclusive
mode.   If  this is the case, a pointer to the Task that owns the exclusive
lock  is  returned.  Otherwise NULL is returned to indicate that the object
is not locked at the time of calling.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to the object that you want to check.

@{b}@{u}RESULT@{uu}@{ub}
Returns a pointer to the Task that owns the exclusive lock, or NULL.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Exclusive()" LINK "Exclusive()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "CheckInit()" "Kernel: CheckInit()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     CheckInit()
Short:    Checks if an object has been initialised or not.
Synopsis: LONG CheckInit(*Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action  will  check an object to see if it has been initialised.  (An
initialised object is one that has successfully passed the Init() process.)

@{b}@{u}RESULT@{uu}@{ub}
Returns  FALSE  (0) if the object is not initialised yet.  If the object is
initialised, TRUE (1) is returned.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Init()" LINK "Init()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "CheckLock()" "Kernel: CheckLock()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     CheckLock()
Short:    Checks if an object is currently under lock conditions.
Synopsis: LONG CheckLock(*Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  tells you how many locks are currently placed on an object.
Each  time  a  Lock()  is  made,  the  count  is increased.  Every Unlock()
decreases  the  count.   If the count is at 0, then the object is not under
lock conditions.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to the initialised object that you want to check for a lock.

@{b}@{u}RESULT@{uu}@{ub}
Returns  a  total count of the locks placed on an object.  If the object is
not locked, this function returns NULL.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Lock()" LINK "Lock()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Clear()" "Kernel: Clear()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Clear()
Short:    Clears an object's data.
Synopsis: LONG Clear(APTR Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action  will  clear  an object of all its data.  Here are some likely
examples:

  File   - Clear the data by taking the file length down to 0.
  Bob    - Clear a Bob image from a Bitmap.
  Bitmap - Clear an entire Bitmap of visible data.

Note  that  with  drawable  objects like Bobs, this action will not restore
what  was  previously under the graphic - it just clears it all away.  This
means  that  you  will  get  an empty rectangle or mask of the object, most
likely with a colour of black.

@{b}@{u}INPUT@{uu}@{ub}
Object - Pointer to the object you wish to clear.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK if successful.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Draw()" LINK "Draw()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "CloseDPK()" "Kernel: CloseDPK()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     CloseDPK()
Short:    Closes the kernel library.
Synopsis: void CloseDPK(void)

@{b}@{u}DESCRIPTION@{uu}@{ub}
Before  your  program exits you will have to call this function so that the
system  knows you are shutting down.  If you do not close the kernel before
you exit you will leave certain memory allocations unfreed and there may be
other adverse system effects.

This  function  will  perform a resource tracking check, so if you have not
freed  any  system resources you will be notified here (if you get a yellow
alert  box,  you  will need to use IceBreaker to get a detailed list of the
errors).

CloseDPK()  is  responsible  for  handling the OnRemTask event.  This event
will be activated as soon as CloseDPK() is called by your task.

@{b}@{u}NOTE@{uu}@{ub}
Remember that you may not call any more functions after calling CloseDPK().

This  function  is  used in the STARTDPK macro and the dpk.o file, so C and
assembler  programmers  do  not  need  to  call  this  function explicitly.
Programs  that  are  started natively or from the StartDPK executable, will
not  have  to  call  CloseDPK().   This is because the call will be handled
within the system for these cases.

@EndNode
-----------------------------------------------------------------------------
@NODE "CloneMemBlock()" "Kernel: CloneMemBlock()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     CloneMemBlock() (V2.0)
Short:    Makes an exact duplicate of a memory block.
Synopsis: APTR CloneMemBlock(*Memory [a0], LONG Flags [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  allows you to make a duplicate of any memory block that has
been  allocated  from  AllocMemBlock().   The  new  memory  block  will  be
completely  identical  to  the block you have specified, except the type of
memory which may be changed through the Flags argument.

@{b}@{u}INPUT@{uu}@{ub}
Memory
  Pointer to the memory block that you want to clone.

Flags
  Specifies the memory flags that you want to use for your newly cloned
  memory block.  See AllocMemBlock() for flag definitions.

@{b}@{u}RESULT@{uu}@{ub}
Returns a duplicate of the memory block or NULL if error.  Remember to free
the cloned memory block when you are finished with it.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"AllocMemBlock()" LINK "AllocMemBlock()"}
        @{"FreeMemBlock()" LINK "FreeMemBlock()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Copy()" "Kernel: Copy()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Copy()
Short:    Copy data from one object to another.
Synopsis: LONG Copy(APTR Source, APTR Destination)

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action has been provided so that objects can copy data to each other.
Some examples for the use of this function might be:

  Opening 2 files and copying the contents from one to the other.
  Copying data from an unknown object on the clipboard to another object.
  Copying Bitmap graphics.

The  Copy()  action  is  considered  to  be quite abstract and results will
differ,  according  to  the Source object that you are copying from.  It is
recommended  that  you  read  the  Copy() notes on the Source object before
using it with this action.

@{b}@{u}INPUT@{uu}@{ub}
Source
  The object that is acting as the source of the data.

Destination
  The object that you are copying the data to.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK if successful.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"CopyStructure()" LINK "CopyStructure()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "CopyStructure()" "Kernel: CopyStructure()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     CopyStructure()
Short:    Copies details from one structure to another.
Synopsis: LONG CopyStructure(APTR Source [a0], APTR Destination [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action  copies  one  structure's  details  across  to  another.   The
structures  can  be similar or completely different (even a Screen -> Sound
copy is possible, although there won't be much of a result).

This  action  only copies fields that are currently present in the Universe
object.  This action DOES NOT copy fields that contain option flags, fields
that contain pointers to the main area of data (eg Bitmap->Data), or fields
designated as private.

Only  the  NULL fields in the Destination structure will be written to.  If
the  Destination  structure has already been initialised, you may find that
CopyStructure() has no effect due to this condition.

@{b}@{u}INPUT@{uu}@{ub}
Source
  Points to the source object.

Destination
  Points to the destination object.

@{b}@{u}RESULT@{uu}@{ub}
Returns  ERR_OK  on success, otherwise may fail due to unrecognised objects
or invalid arguments.

@EndNode
-----------------------------------------------------------------------------
@NODE "Deactivate()" "Kernel: Deactivate()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Deactivate()
Short:    Stop the object from performing its native action.
Synopsis: void Deactivate(APTR Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Deactivate()  stops  the  given  object  from continuing its native action.
This  function  only works if the object has recently had Activate() called
on  it.   If  the  object is not performing any actions, then this function
will simply do nothing.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to an initialised object structure.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Activate()" LINK "Activate()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "DebugOff()" "Kernel: DebugOff()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     DebugOff() (V2.0)
Short:    Turns off debug messages.
Synopsis: void DebugOff(void)

@{b}@{u}DESCRIPTION@{uu}@{ub}
Call this function to turn off all further output to the debugger.  You can
turn debugging back on again with DebugOn().

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"DebugOn()" LINK "DebugOn()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "DebugOn()" "Kernel: DebugOn()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     DebugOn() (V2.0)
Short:    Turns on debug messages.
Synopsis: void DebugOn(void)

@{b}@{u}DESCRIPTION@{uu}@{ub}
Call  this  function  after  calling  DebugOff()  in order to get the debug
messages back.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"DebugOff()" LINK "DebugOff()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Detach()" "Kernel: Detach()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Detach()
Short:    Detach an object from a parent structure.
Synopsis: LONG Detach(APTR Object [a0], APTR Parent [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action  will  separate  an  object from its parent structure, without
causing  any undue harm to either object.  If this operation is successful,
you can then use the detached object independantly of its parent.

It  is  possible  to detach a chain of objects from a parent structure.  If
you  do  this, it will be your responsibility to Free() every object on the
chain  before  your  program shuts down.  A real-world description of chain
detachment is given in the Directory autodoc.

Some detachments are impossible or too dangerous to attempt, e.g.  a Screen
object cannot survive without its Bitmap.  Also, for Detach() to work it is
necessary for both objects to support this action.

@{b}@{u}INPUTS@{uu}@{ub}
Object
  The object that needs to be detached.

Parent
  Pointer to the parent object that you want to be detached from.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK if successful.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Unhook()" LINK "Unhook()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DPKForbid()" "Kernel: DPKForbid()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     DPKForbid()
Short:    Stop other tasks/processes from executing.
Synopsis: void DPKForbid(void)

@{b}@{u}DESCRIPTION@{uu}@{ub}
Stops  all  other  tasks  and  processes  from  executing  until  you  call
DPKPermit().  This call will not turn off interrupts.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"DPKPermit()" LINK "DPKPermit()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "DPKPermit()" "Kernel: DPKPermit()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:      DPKPermit()
Short:     Allow other tasks to continue their processing.
Synopsis:  void DPKPermit(void)

@{b}@{u}DESCRIPTION@{uu}@{ub}
Reverses  a  previous  call  to DPKForbid(), so that all tasks can continue
their normal processes.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"DPKForbid" LINK "DPKForbid()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Draw()" "Kernel: Draw()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Draw()
Short:    Draws an object's graphic to its container.
Synopsis: LONG Draw(*Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action  will  draw  an  object's graphic to the container that it was
originally  initialised  to.   If  the  object  was  never initialised to a
container   that  supports  drawing,  this  action  will  have  no  effect.
Secondly, if the object has no graphical representation then nothing can be
drawn.

If  you are drawing a graphic to a Screen that has lost the focus (i.e.  it
is  not  on  display) your task could be stopped until that Screen receives
the  focus  again.  This is due to the video locking issue, as described in
the  Screen  documents.   For  this  reason,  any functions that need to be
completed  every few seconds (such as serial communications) should be in a
separate Process that can continue activity in the background.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to an initialised object that you wish to draw.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK if successful.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Clear()" LINK "Clear()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Exclusive()" "Kernel: Exclusive()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Exclusive()
Short:    Get exclusive access to a shared object.
Synopsis: LONG Exclusive(*Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action  is identical to AttemptExclusive(), but it will wait up to 30
seconds  before  failing.  Please read the docs on AttemptExclusive() for a
complete run down on this action.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to an initialised object that you want exclusive access to.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK if you have gained exclusive access to the object.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"AttemptExclusive()" LINK "Exclusive()"}
        @{"FreeExclusive()"    LINK "FreeExclusive()"}

@EndNode
---------------------------------------------------------------------------
@NODE "FastRandom()" "Kernel: FastRandom()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:	  FastRandom()
Short:    Generate a random number between 0 and <Range>.
Synopsis: LONG FastRandom(LONG Range [d1]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  generates  a  random  number  as  quickly as possible.  The
routine  uses  one  divide  to  determine  the range and will automatically
change  the random seed value each time you call it.  This routine has been
fully tested and is known to generate 100% patternless numbers.

Remember  that  all  generated numbers fall BELOW the Range.  Add 1 to your
range if you want this number included.

@{b}@{u}INPUTS@{uu}@{ub}
Range
  A  range  between  1  and  32767.  An invalid range of 0 will result in a
  division by zero error.

@{b}@{u}RESULT@{uu}@{ub}
Returns a number greater or equal to 0, and @{i}less than@{ui} Range.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"SlowRandom()" LINK "SlowRandom()"}
Demos:  @{"demos/randomplot" SYSTEM "GMS:demos/RandomPlot"}

@EndNode
-----------------------------------------------------------------------------
@NODE "FindDPKTask()" "Kernel: FindDPKTask()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     FindDPKTask()
Short:    Find the DPKTask structure for the current task.
Synopsis: *Task FindDPKTask(void)

@{b}@{u}DESCRIPTION@{uu}@{ub}
This function will return the DPKTask structure for the Task that is making
the  call (ie "you").  The DPKTask structure is used for storing data that
is  specific  to  your  Task - things like preference settings for example.
Almost  all  of  the DPKTask fields are private and you you cannot write to
this structure unless you are a system module.

@{b}@{u}NOTE@{uu}@{ub}
It  is  not  unusual  for FindDPKTask() to return a NULL pointer.  This can
occur  if  there is no related Task structure, or if the Task structure has
been  corrupted.   For  object and module programmers, it is essential that
calls to FindDPKTask() are enclosed within an IF statement.

If  there  is no current Task, for example if this function is being called
from  an  interrupt, then the System Task will be returned (the System Task
controls and maintains the kernel).

@{b}@{u}RESULT@{uu}@{ub}
Returns a pointer to the current Task structure or NULL.

@{b}@{u}SEE ALSO@{uu}@{ub}
Include: @{"system/tasks.h" LINK "GMSDev:Includes/system/tasks.h/Main"}

@EndNode
-----------------------------------------------------------------------------
@NODE "FindField()" "Kernel: FindField()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     FindField() (V2.1)
Short:    Finds and returns field entries, either by Name or ID.
Synopsis: *Field FindField(*Object [a0], LONG FieldID [d0], BYTE *Name [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This function will check if an object supports a specified field, either by
FieldID  or  Name.   If  the  class  supports the field, this function will
return a descriptor for that field.

For example:

  Field = FindField(Screen, FID_WIDTH, "Width");

Once  you  have  obtained a Field structure you may read information on its
size, format and so on.  You may not write values to a Field structure.

@{b}@{u}INPUTS@{uu}@{ub}
Object
  Points to the object that you wish to check.

FieldID
  The "FID" number that you wish to check for, or NULL if you wish to
  search on the Name.

Name
  The Name of the field you wish to search for, or NULL if there is an
  equivalent FieldID.

@{b}@{u}RESULT@{uu}@{ub}
Returns  a pointer to the field descriptor (struct Field *), otherwise NULL
if not found.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"GetField()" LINK "GetField()"}
        @{"GetFieldName()" LINK "GetFieldName()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "FindReference()" "Kernel: FindReference()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     FindReference() (V2.0)
Short:    Allows you to search through the system reference list.
Synopsis: *Reference FindReference(LONG ClassID [d0], *Reference [a0]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function allows you to search through all of the References currently
loaded  in  the  system.   You  can  search  for a specific class, or use a
ClassID of NULL to look at all of the available References.

If  we  wanted to search for all References belonging to the Picture class,
we would use the following code:

  Reference = NULL;
  while (Reference = FindReference(ID_PICTURE, Reference)) {
     ...
  }

If  a  matching  Reference  is  found  in  the  system, it will be returned
immediately.   If  there are no References available, NULL will be returned
to indicate an end to the search.

The  first matching Reference to be returned is always the master Reference
of  that  particular  class.   Note  that if you are looking for a specific
child  or hidden Reference, you will need to check the Reference->ClassName
string.

@{b}@{u}INPUTS@{uu}@{ub}
ClassID
  A class ID as specificed in "system/register.h".

Reference
  Specify  the  last  received  Reference if continuing a search, otherwise
  NULL to start a new search.

@{b}@{u}RESULT@{uu}@{ub}
Returns  a  pointer to the Reference that has been found as a result of the
search, or NULL if no matching objects were found.

@EndNode
-----------------------------------------------------------------------------
@NODE "FindSysName()" "Kernel: FindSysName()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     FindSysName() (V2.0)
Short:    Finds a system object from a given name.
Synopsis: *SysObject FindSysName(BYTE *Name [d0], *SysObject [a0]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function can be used to search for all available SysObjects belonging
to   a   particular  class.   Its  functionality  is  almost  identical  to
FindSysObject(), but it searches by Name rather than ID.

If  we  wanted to search for all SysObjects belonging to the Picture class,
we would use the following code:

  SysObject = NULL;
  while (SysObject = FindSysName("Picture", SysObject)) {
     ...
  }

If  a  matching  SysObject  is  found  in  the  system, it will be returned
immediately.   If  there  are no SysObject's left, NULL will be returned to
indicate an end to the search.

The  first matching SysObject to be returned is always the master object of
that  particular class.  If you wish to search for a specific child object,
please  use  a string format of "Master~Child".  For example, to search for
the Jpeg object you would use a name of "Picture~Jpeg".

@{b}@{u}INPUTS@{uu}@{ub}
Name
  A string that identifies the name of the object that you want to search
  for.  Note that names are case sensitive.

SysObject
  You  must  specify  the  last  received SysObject if continuing a search,
  otherwise NULL to start a new search.

@{b}@{u}RESULT@{uu}@{ub}
Returns  a  pointer to the SysObject that has been found as a result of the
search, or NULL if no matching objects were found.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"FindSysObject()" LINK "FindSysObject()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "FindSysObject()" "Kernel: FindSysObject()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     FindSysObject()
Short:    Finds a system object based on the Class.
Synopsis: *SysObject FindSysObject(LONG ClassID [d0], *SysObject [a0]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
This function is used to search for all available SysObjects belonging to a
particular class.

If  we  wanted to search for all SysObjects belonging to the Picture class,
we would use the following code:

  SysObject = NULL;
  while (SysObject = FindSysObject(ID_PICTURE, SysObject)) {
     ...
  }

If  a  matching  SysObject  is  found  in  the  system, it will be returned
immediately.   If  there  are no SysObject's left, NULL will be returned to
indicate an end to the search.

The  first matching SysObject to be returned is always the master object of
that  particular  class.   There  is no particular order given to ID_HIDDEN
objects.

Note  that  if  you  are looking for a specific child or hidden object, you
will need to check the SysObject->Name string.

@{b}@{u}INPUTS@{uu}@{ub}
ClassID
  A class ID as specificed in "system/register.h".

SysObject
  The  last  received  SysObject  if continuing a search, otherwise NULL to
  start a new search.

@{b}@{u}RESULT@{uu}@{ub}
Returns  a  pointer to the SysObject that has been found as a result of the
search, or NULL if no matching objects were found.

@{b}@{u}SEE ALSO@{uu}@{ub}
Include: @{"system/register.h" LINK "GMSDev:Includes/system/register.h/Main"}

@EndNode
-----------------------------------------------------------------------------
@NODE "FingerOfDeath()" "Kernel: FingerOfDeath()"

Private.

@EndNode
-----------------------------------------------------------------------------
@NODE "Flush()" "Kernel: Flush()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Flush()
Short:    Flush buffered data from an object.
Synopsis: LONG Flush(*Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action  will  flush  all  buffered data from an object.  It is mostly
intended for file objects that may buffer data to speed up processing time.
As a result of flushing, any un-written data will be dumped to its physical
location, if this is practical for the object in question (eg files).

Note  that  any object using a buffering technique will automatically flush
its data when you Free() it.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to an initialised object.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK on success.  All errors returned from Flush() are non-fatal,
so you may continue to use the object after failure.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Reset()" LINK "Reset()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Free()" "Kernel: Free()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Free()
Short:    Frees an object and any of its associated parts.
Synopsis: LONG Free(*Pointer [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action  will  take any system object and free its resources.  It also
accepts LIST arrays for multiple deallocations.

Once  the  object  has  been freed, the original pointer that you passed to
Free() immediately becomes invalid.  For this reason, any references to the
object  should  be  driven  to  NULL to prevent bugs from appearing in your
program.

@{b}@{u}INPUT@{uu}@{ub}
Pointer
  Points to one of the following:

  Object, ListV1, ListV2, TagList, ObjectList

@{b}@{u}RESULT@{uu}@{ub}
Returns an errorcode if the object was found to be invalid.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Get()"  LINK "Get()"}
        @{"Init()" LINK "Init()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "FreeExclusive()" "Kernel: FreeExclusive()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     FreeExclusive()
Short:    Free an object from exclusive use.
Synopsis: void FreeExclusive(*Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
If you have obtained exclusive access to an object and you want to free the
lock  for other tasks, you can call this action.  Once this action returns,
you will no longer have exclusive access to the object.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to an object that you have obtained for exclusive use.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"AttemptExclusive()" LINK "AttemptExclusive()"}
        @{"Exclusive()"        LINK "Exclusive()"}

@EndNode
---------------------------------------------------------------------------
@NODE "FreeMemBlock()" "Kernel: FreeMemBlock()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     FreeMemBlock()
Short:    Free a previously allocated mem block.
Synopsis: LONG FreeMemBlock(APTR MemBlock [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This   function   frees   a   memory  area  allocated  by  AllocMemBlock(),
AllocVideoMem(), AllocBlitMem(), or AllocSoundMem().

Crash  protection  is incorporated into various areas of this function.  If
the  memory  header  or  tail is missing from the block, then it is assumed
that  something  has  written over its boundaries, or you are attempting to
free  a  non-existant  allocation.   Normally  this  would cause a complete
system  crash, but instead we simply send a message to IceBreaker and leave
the memory block in the system.

Bear  in  mind that it does pay to save your work and reset your machine if
such a message appears, as it indicates that important memory data may have
been destroyed.

@{b}@{u}NOTE@{uu}@{ub}
Never attempt to free the same MemBlock twice.

@{b}@{u}INPUT@{uu}@{ub}
MemBlock
  Points to the start of a memblock.  If NULL, then no action will be taken
  (function exits).

@{b}@{u}RESULT@{uu}@{ub}
Returns an errorcode if the memory block was found to be invalid.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"AllocMemBlock()" LINK "AllocMemBlock()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "FreeResource()" "Kernel: FreeResource()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     FreeResource() (V2.1)
Short:    Free a resource tracking node.
Synopsis: void FreeResource(*Pointer [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  deletes  a resource node allocated from AddResource().  You
can  either supply a pointer to the resource node itself, or you can supply
the original Pointer argument that you passed to AddResource().

Note  that  this  function only deletes the @{b}resource node@{ub}, it will
not attempt to deallocate the resource itself.

@{b}@{u}INPUT@{uu}@{ub}
Pointer
  Pointer to a resource node or an original resource pointer.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"AddResource()" LINK "AddResource()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Get()" "Kernel: Get()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     Get()
Short:    Gets the latest version of a specified object.
Synopsis: APTR Get(LONG ID [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This function will get the latest version of any object that you specify in
the  ID  argument  (e.g  ID_PICTURE).  That is of course, if the object has
been  correctly installed by the user and is available to the system.  Once
you  have  an  object,  you can then set the fields and Init()ialise it for
active use.

Screens,  Pictures,  Sounds,  Files etc are permanent objects and therefore
always  recognised by Get(), while something like a CardSet is an extra and
must  have  been installed first [Get() will find such objects by using the
reference files in GMS:System/References/].

All  objects  going  through  Get() are tagged with a resource key.  Before
your program exits you will need to free the object with the Free() action.
If  you  want  your program to exit and leave certain objects in the system
(e.g  for  other  programs to use), then you can logical OR the ID argument
with GET_NOTRACK.

Secondly,  all  objects  are  PRIVATE  by  default.   That is, they will be
exclusive to your Task and no-one else is allowed to use them.  If you want
to  be  able to pass your object to other tasks, logical OR the ID argument
with GET_PUBLIC.

Another  flag that complements GET_PUBLIC is the GET_SHARE attribute.  This
is an extra flag that only a few classes take advantage of.  An object that
is  allocated with GET_SHARE will not only be in PUBLIC mode, but will also
be  placed  on  a  publicly  accessible list that any Task can get hold of.
This  effectively  means  that  other  tasks  can easily gain access to the
object,  wether  or  not you say so.  An important note here is that before
using a SHARED object, you must obtain an exclusive lock before you attempt
to  do  anything with it.  This will help to prevent two or more tasks from
using one object at the same time.

@{b}@{u}NOTE@{uu}@{ub}
The Get() function provides you with the only way you can legally obtain an
object.   If  you  ever  think  of  compiling  objects directly inside your
program, forget it - your program will crash.

@{b}@{u}INPUT@{uu}@{ub}
ID
  One of the ID's as specified in the "system/register.h" file.

@{b}@{u}RESULT@{uu}@{ub}
Returns  the  latest  version  of  the  specified object or NULL if failure
(usually caused by lack of memory or unrecognised ID).

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel:  @{"Free()" LINK "Free()"}
         @{"GetByName()" LINK "GetByName()"}
         @{"Init()" LINK "Init()"}
Include: @{"system/register.h" LINK "GMSDev:Includes/system/register.h/Main"}

@EndNode
-----------------------------------------------------------------------------
@NODE "GetByName()" "Kernel: GetByName()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     GetByName() (V2.0)
Short:    Gets the latest version of a specified object.
Synopsis: APTR GetByName(BYTE *Name [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  is  a  special  version of Get() which will grab an object for you by
searching  for  its name.  This is slower than using the normal Get() as we
have to use string comparisons, but this function can be very useful.

If  you  wish  to  search for a child object, please use a string format of
"Master~Child".  For example, to search for the Jpeg object you would use a
name of "Picture~Jpeg".

@{b}@{u}INPUT@{uu}@{ub}
Name
  The name of the object you are searching for, e.g. "Picture", "Screen",
  "File".  Note that all names are case sensitive (for speed reasons).

@{b}@{u}RESULT@{uu}@{ub}
Returns the latest version of the specified object or NULL if failure.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel:  @{"Free()" LINK "Free()"}
         @{"Get()" LINK "Get()"}
         @{"Init()" LINK "Init()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "GetContainer()" "Kernel: GetContainer()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     GetContainer()
Short:    Returns the container that owns an object.
Synopsis: *Object GetContainer(*Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
You can find the container of any object by calling this function.  Because
every  object is assigned a container, this call will always succeed.  Note
that  objects  that  are  not  given  a  container  by Init() or by natural
inheritance, will be contained within a Task.

@{b}@{u}NOTE@{uu}@{ub}
The  only  time  that  this  function  can  return  NULL  is  if  you  call
GetContainer() on the system task (if you call GetContainer() in a loop you
will eventually reach this object).

If  you  want  to  climb  an  object  with the intent of finding a specific
container,  you  can  use  the  following  code  (which  is searching for a
Desktop):

   Object = Bitmap;
   while ((Object) AND (Object->ID != ID_DESKTOP)) {
      Object = GetParent(Object);
   }

@{b}@{u}INPUT@{uu}@{ub}
Object
  The object that you need to know the container of.

@{b}@{u}RESULT@{uu}@{ub}
Returns the container of the object.

@EndNode
-----------------------------------------------------------------------------
@NODE "GetExtension()" "Kernel: GetExtension()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     GetExtension()
Short:    Returns the file extension parameters for an object.
Synopsis: BYTE * GetExtension(*Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  will  return  the  default file extension parameters for an
object.  Typical file extensions for a Picture object initialised to a Jpeg
support class might be:

  "jpeg;jpg"

Which would support filenames such as:

  "MyPicture.jpeg"
  "YourPicture.jpg"

Remember  that you will only be getting the default settings for the object
that  you  are  passing.  If you want all of the available file types for a
class, use GetTypeList().

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to an initialised object.

@{b}@{u}RESULT@{uu}@{ub}
Returns  a string containing the file extension parameters.  Each parameter
will be delimited by a ";" character.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"GetFileType()" LINK "GetFileType()"}
        @{"GetTypeList()" LINK "GetTypeList()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "GetField()" "Kernel: GetField()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     GetField() (V2.0)
Short:    Gets data from a specific field in an Object.
Synopsis: LONG GetField(*Object [a0], LONG FieldID [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Through  the  use  of  this function you can get detailed field information
from  any  object,  even  when  you  don't  know  what that object is.  For
example,  if  you have an object which is drawable and you want to find out
its screen location, you could use GetField() to find its XCoord and YCoord
details.

Given this example, if we wanted to find the XCoord and YCoord of an object
we would use this code:

  XCoord = GetField(Object,FID_XCoord);
  YCoord = GetField(Object,FID_YCoord);

As  GetField() is based on ID's which reflect field names (FID_XCoord = 42)
you  will find that there are occasions when there is no ID for the name of
the  field  you  wish  to  search  for.  In these cases, use GetFieldName()
instead.

Here follows the current list of avaiable FieldID's, as taken from "system/
sysobject.h".   If  you  would  like  more  Field  ID's added, send in your
submissions for an appearance in the next version.

  FID_Flags       FID_FPlane      
  FID_Source      FID_PropWidth   
  FID_ScrHeight   FID_PropHeight  
  FID_ScrWidth    FID_Attrib      
  FID_ScrMode     FID_PlaneSize   
  FID_Width       FID_MaskCoords  
  FID_Height      FID_AmtFrames   
  FID_Size        FID_XCoord      
  FID_Data        FID_YCoord      
  FID_Array       FID_Frequency   
  FID_MaxSize     FID_Pair        
  FID_Parent      FID_Volume      
  FID_Child       FID_Priority    
  FID_Restore     FID_Length      
  FID_MemType     FID_Octave      
  FID_Planes      FID_Bitmap      
  FID_AmtColours  FID_Sound       
  FID_Palette     FID_Name        
  FID_LineMod     FID_Colour      
  FID_PlaneMod    FID_Point       
  FID_ByteWidth   FID_Gutter      
  FID_Type        FID_Char        
  FID_Buffers     FID_ClipLX      
  FID_Owner       FID_ClipRX      
  FID_Entries     FID_ClipTY      
  FID_GfxCoords   FID_ClipBY      
  FID_Frame       

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to an object allocated from Get().

FieldID
  The FID number of the field you wish to search for.  

@{b}@{u}RESULT@{uu}@{ub}
Returns  a  long-word of the field data.  If there was a failure in finding
the  field  then  this function will return NULL.  Note that you should use
FindField()  if  you  wish  to  ensure that the field exists before calling
GetField().

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"FindField()" LINK "FindField()"}
        @{"GetFieldName()" LINK "GetFieldName()"}
        @{"SetField()" LINK "SetField()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "GetFieldName()" "Kernel: GetFieldName()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     GetFieldName() (V2.0)
Short:    Gets data from a specific field in an Object.
Synopsis: LONG GetFieldName(*Object [a0], BYTE *Name [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field is identical to GetField() but will use field names rather than
the  ID.   This  is a lot slower than GetField(), so only use this function
when   necessary.   The  XCoord/YCoord  example  given  in  the  GetField()
documentation is the equivalent of this in GetFieldName():

  XCoord = GetField(Object,"XCoord");
  YCoord = GetField(Object,"YCoord");

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to an object allocated from Get().

Name
  The name of the field you wish to search for.  

@{b}@{u}RESULT@{uu}@{ub}
Returns  a  long-word of the field data.  If there was a failure in finding
the  field  then  this function will return NULL.  Note that you should use
FindField()  if  you  wish  to  ensure that the field exists before calling
GetFieldName().

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"FindField()" LINK "FindField()"}
        @{"GetField()" LINK "GetField()"}
        @{"SetFieldName()" LINK "SetFieldName()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "GetFileType()" "Kernel: GetFileType()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     GetFileType()
Short:    Get the default file type for an object.
Synopsis: BYTE * GetFileType(Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function returns a string pointer that describes the object's default
file type.  Typical strings that could be returned from this function are:

   "IFF 8SVX Sound"
   "IFF Picture"
   "GIF Picture"
   "GIF Anim"
   "Transparent GIF"

If you want all of the available file types for a class, use GetTypeList().

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to an initiailised object.

@{b}@{u}RESULT@{uu}@{ub}
Returns  a  string  containing  a  description of the object's default file
type.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"GetExtension()" LINK "GetExtension()"}
        @{"GetTypeList()" LINK "GetTypeList()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "GetMemSize()" "Kernel: GetMemSize()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     GetMemSize()
Short:    Identifies the size of a given memory block.
Synopsis: LONG GetMemSize(APTR MemBlock [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  will get the size of any memory block legally obtained from
AllocMemBlock().  Illegal pointers will result in a return of NULL.

@{b}@{u}INPUT@{uu}@{ub}
MemBlock
  Pointer to the start of the memory block to be identified.

@{b}@{u}RESULT@{uu}@{ub}
The size of the memory block in bytes.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"GetMemType()" LINK "GetMemType()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "GetMemType()" "Kernel: GetMemType()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     GetMemType()
Short:    Identifies the type of memory in use by a particular memory block.
Synopsis: LONG GetMemType(APTR MemBlock [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  will  get  the  memory  flags  of  any memory block legally
obtained from AllocMemBlock().  Illegal pointers will result in a return of
-1.

@{b}@{u}INPUT@{uu}@{ub}
MemBlock
  Pointer to the start of the memory block to be identified.

@{b}@{u}RESULT@{uu}@{ub}
Returns memory flags that identify the block (see @{"AllocMemBlock()" LINK "AllocMemBlock()"}).

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"GetMemSize()" LINK "GetMemSize()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "GetTypeList()" "Kernel: GetTypeList()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     GetTypeList()
Short:    Get a list of all available file types for a class.
Synopsis: *ItemList GetTypeList(WORD ClassID [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  allows you to obtain a list of all the available file types
and  their  extensions  for  a  specific class.  It will return an ItemList
object with an array formatted to the following standard:

  "FileType", "FileExtension"
  ...
  -1

Here is an example of what might be returned for the Picture class
(ID_PICTURE):

  "IFF Picture",     "iff;pic",
  "GIF Picture",     "gif",
  "GIF Anim",        "gif;anim",
  "Transparent GIF", "gif;tgif",
  -1

@{b}@{u}NOTE@{uu}@{ub}
This function will return no more than 25 file types.

@{b}@{u}INPUT@{uu}@{ub}
ClassID
  A standard class ID such as ID_PICTURE, ID_FILE etc.

@{b}@{u}RESULT@{uu}@{ub}
Returns  a  pointer  to  an  ItemList object.  You will have to Free() this
object once you are done with it.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"GetExtension()" LINK "GetExtension()"}
        @{"GetFileType()" LINK "GetFileType()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Hide()" "Kernel: Hide()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Hide()
Short:    Hides a displayed object from view.
Synopsis: void Hide(APTR Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Hiding  is  an  action that is used to remove objects from the sight of the
user.   Examples  of this include hiding Screens and Files.  Usually Hide()
is used in conjunction with Show().

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to an initialised object that you want to hide.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Show()" LINK "Show()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Init()" "Kernel: Init()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Init(), InitTags()
Short:    Initialises an object so that it is ready for active use.
Synopsis: APTR Init(APTR Data [a0], APTR Container [a1])
          APTR InitTags(APTR Container, LONG Tag, ...)

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  initialises  any  recognised  system object.  The container
argument is dependent on the type of object that you are initialising (eg a
Bob requires a Screen or Bitmap container) so it is not always necessary to
supply one.

If you provide a List or ObjectList then be aware that Init() will pass the
original  container  to  ALL  the objects in the list.  For this reason all
objects  must  share  some  commonalities  to  the  container  (eg  do  not
initialise a Sound in a list of Bobs).  Of course if you supply a container
of NULL, this will not be of a concern you.

If  the  initialisation  action  fails, then Init() will look for any child
classes  that  can  handle  initialisation of the object.  If a child class
succeeds  it  will  gain  full  ownership of the object and the master will
retain only partial ownership.

@{b}@{u}INPUTS@{uu}@{ub}
Data
  Points to an Object, TagList, ListV1, ListV2 or an ObjectList.

Container
  Some objects need to be initialised to a "container" or parent object.
  If this is the case, specify that object here.

@{b}@{u}RESULT@{uu}@{ub}
Pointer to the initialised object, or NULL on error.  Use IceBreaker if you
want to get informative error messages.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Free()" LINK "Free()"}
        @{"Get()"  LINK "Get()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "InitDestruct()" "Kernel: InitDestruct()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     InitDestruct()
Short:    Initialise the task for use of SelfDestruct().
Synopsis: void InitDestruct(APTR DestructCode [a0], APTR DestructStack [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  is  a  special  function  that is called in the STARTDPK macro, gms.o
startup  file  and  StartDPK  program  only.   You  should  never call this
function explicitly unless you are writing your own startup code.

InitDestruct()  will  prepare  your task so that it may be destroyed by the
SelfDestruct() function.  DestructCode must point to the exit code for your
task.   The exit code must call CloseDPK() at some point if you are to free
your  tasks  resources.  DestructStack must point to the correct stack area
for  your  exit  code,  otherwise  your  task  cannot  return to the system
correctly.

To  see an example of how this function works look at the STARTDPK macro in
file "dpkernel/dpkernel.i".

@{b}@{u}INPUTS@{uu}@{ub}
DestructCode
  Points to the code at which your task makes its exit.

DestructStack
  Points to the stack that will be used for the exit.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"SelfDestruct()" LINK "SelfDestruct()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Load()" "Kernel: Load()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Load()
Short:    Load a file and initialise it as a system object.
Synopsis: APTR Load(APTR Source [a0], LONG ClassID [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action  loads  in  a file, finds its object class and then returns an
object that is Init()ialised and ready for use.

If  you supply a special ID of ID_MEMBLOCK, Load() will allocate a MEM_DATA
memory  block,  load  all of the file contents into it, and then return the
memory  block pointer back to you.  You will need to free this pointer with
FreeMemBlock() when you are finished with it.

The  file  will be loaded according to the object's default format.  If you
require  more  power  in the loading of a particular object, use the Init()
function instead of Load().

@{b}@{u}NOTE@{ub}@{uu}
When  supplying  a  ClassID  of  NULL:   If there are no other objects that
recognise the file, the RawData object will probably obtain it (this object
can load all file types).

@{b}@{u}INPUTS@{uu}@{ub}
Source
  FileName or Memory location pointer.

ClassID
  Forces  the type of object that you want to be returned.  Use NULL if you
  want Load() to assess the file and return the most suitable object.

@{b}@{u}RESULT@{uu}@{ub}
Returns  a pointer to the initialised object, or NULL if failure.  Remember
that RawData is used if no other object recognises the source file.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Free()" LINK "Free()"}
        @{"Init()" LINK "Init()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Lock()" "Kernel: Lock()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     Lock()
Short:    Locks an object's "physical" position and other attributes.
Synopsis: LONG Lock(*Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Locking  an object is helpful when you don't want it being moved or deleted
while you are using it.

The most common example of locking under any system is in Files.  Locking a
file prevents it from being deleted or moved around, which is useful if you
want  it to stay in one place while you are reading or writing to it.  Once
Unlock() is called, these actions become available again.

@{b}@{u}Conditions of Locking@{uu}@{ub}
1. Other tasks MAY be able to gain limited access to the object after you
   have locked it (ie share the object).  The object you are attempting to
   Lock() should have specific documentation on this.  If it doesn't, make
   the assumption that other tasks will have some limited access.

2. The object will be fixed in place and cannot be moved or deleted, even
   by your own task, until it is unlocked (moving breaks the conditions of
   a lock for a lot of objects, e.g. Screens).

3. If you Free() a locked object, it will be automatically unlocked for
   safety reasons.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to an initialised object that you want to lock.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK if the lock was successful.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Unlock()" LINK "Unlock()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "MoveToBack()" "Kernel: MoveToBack()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     MoveToBack()
Short:    Move an object to the back of its current location.
Synopsis: LONG MoveToBack(*Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action  is  used for shuffling objects to the back of their location.
Obvious  examples  for  this  are  Screens  and  Windows,  but more obscure
functionality may appear in future (probably for sorting purposes).

This is a very simple action and rarely returns error codes.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to the object that should be moved to the back.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK if successful.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"MoveToFront()" LINK "MoveToFront()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "MoveToFront()" "Kernel: MoveToFront()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     MoveToFront()
Short:    Move an object to the front of its current location.
Synopsis: LONG MoveToFront(*Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action  is used for shuffling objects to the front of their location.
Obvious  examples  for  this  are  Screens  and  Windows,  but more obscure
functionality may appear in future (probably for sorting purposes).

This is a very simple action and rarely returns error codes.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to the object that should move to the front.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK if successful.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"MoveToBack()" LINK "MoveToBack()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "OpenModule()" "Kernel: OpenModule()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     OpenModule()
Short:    Provides a quick way of opening a module.
Synopsis: *Module OpenModule(LONG ModuleID [d0], BYTE *Name [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This is a very simple function that initialises a Module with the ID and/or
Name that you supply.  It basically performs the following:

  InitTags(NULL,
    TAGS_MODULE, NULL,
    MODA_Number, <ID>,
    MODA_Name,   <Name>,
    TAGEND);

That's it!

@{b}@{u}INPUTS@{uu}@{ub}
ModuleID
  ID of the module to open (can be NULL if name is supplied).

Name
  Name of the module to open (not required if the ModuleID is specified).

@{b}@{u}RESULT@{uu}@{ub}
Pointer to an initialised Module structure or NULL if failure.

@{b}@{u}SEE ALSO@{uu}@{ub}
Object: @{"Module" LINK "GMSDev:AutoDocs/Objects/Module.guide/Description"}
Kernel: @{"Init()" LINK "Init()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Query()" "Kernel: Query()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Query()
Short:    Gets the latest information on a particular object.
Synopsis: LONG Query(APTR Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Calling  the  Query()  action will update all fields in the given object to
reflect any changes since the last Query() or initialisation.

Examples  of  using  the  Query()  action are to get information on picture
files (such as width, height, amount of colours) and obtaining consistently
changing data, such as joystick information.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to an object allocated from Get().  Some objects require that the
  object is Init()ialised before a Query(), others do not.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK on success.

@EndNode
-----------------------------------------------------------------------------
@NODE "Read()" "Kernel: Read()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Read()
Short:    Read data from an object into a buffer.
Synopsis: LONG Read(APTR Object [a0], APTR Buffer [a1], LONG Length [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This action will read the amount of bytes as determined by Length, from the
Object  and  into  the  given  memory  Buffer.   The read will start at the
position  determined  by the object's Byte Position field.  This field will
be  incremented  to  BytePos+Length if the call succeeds.  Further calls to
Read() will therefore begin from the finishing position of the last Read().

If  the  Length exceeds the total size of the data, this function will only
read as many bytes as there are left in the object.  You can always compare
the  BytePos and Size of the data to see how many bytes are left to read in
the object.

@{b}@{u}INPUTS@{uu}@{ub}
Object
  Pointer to an initialised Object.

Buffer
  Pointer to a memory area in which the data will be written to.

Length
  Amount of bytes to read from the object.

@{b}@{u}RESULT@{uu}@{ub}
Returns  the  total amount of data read into the buffer.  NULL can indicate
an error, or maybe there is no more data left to read.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Write()" LINK "Write()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Realloc()" "Kernel: Realloc()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     Realloc()
Short:    Reallocates a memory buffer.
Synopsis: APTR Realloc(APTR Memory [a0], LONG NewSize [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function reallocates a memory block to a new size.  You can shrink or
expand  a  memory  block  as  per  your  request.   NULL is returned if the
reallocation  fails,  in  which  case your existing memory block will still
remain valid.

The  data  of  your  original  memory  block will be copied over to the new
block.   If  the  new  block  is a larger size, the left-over bytes will be
filled  with  NULL values.  If the new block is smaller, you will lose some
of the original data.

@{b}@{u}INPUTS@{uu}@{ub}
Memory
  Pointer to a memory block obtained from AllocMemBlock() or
  AllocVideoMem() etc.

NewSize
  The new size to be set for the memory block.

@{b}@{u}RESULT@{uu}@{ub}
Returns  a  pointer  to the newly allocated memory block.  If this function
returns  NULL  then  the  reallocation has failed - but your original block
will still remain valid and be in the system.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"AllocMemBlock()" LINK "AllocMemBlock()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "RemSysObject()" "Kernel: RemSysObject()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     RemSysObject()
Short:    Remove a SysObject structure.
Synopsis: void RemSyObject(*SysObject [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Use this function to remove a SysObject structure from the system.  This is
the  only  way  to  remove  a  SysObject, although you can use Free() which
routes directly to this function.

@{b}@{u}INPUT@{uu}@{ub}
SysObject
  Pointer to a SysObject structure that your module created with
  AddSysObject().

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"AddSysObject()" LINK "AddSysObject()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Rename()" "Kernel: Rename()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Rename()
Short:    Renames an object.
Synopsis: LONG Rename(APTR Object [a0], BYTE *Name [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Objects  that  support naming conventions (files and directories are fairly
obvious examples) may support renaming.

Although  Rename()  does not impose limits on the naming length, you should
read the object's documentation for what limits might be imposed.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to an initialised object.

Name
  The new name for the object.

@EndNode
-----------------------------------------------------------------------------
@NODE "Reset()" "Kernel: Reset()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Reset()
Short:    Resets an object to a receptive state.
Synopsis: LONG Reset(APTR Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action  will  reset  an object to a state that is similar to when the
object  was first initialised.  Its behaviour depends greatly on the object
at  hand.   Files  will  reset  their  byte  position to 0 for the next I/O
operation,  while  the  Restore object dumps all current restore states and
forgets about any buffered data.

@{b}@{u}NOTE@{uu}@{ub}
Reset()  is  not  the  same as Flush().  Some objects will flush themselves
before  performing  the  reset  action,  others may not.  It depends on the
circumstances,  but  if  you  want  the  data  flushed then use the Flush()
action.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to an initialised object.

@{b}@{u}RESULT@{uu}@{ub}
An  error  will  be  returned if the action could not execute.  This should
only happen if the object does not support or require the Reset() action.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Flush()" LINK "Flush()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "SaveToFile()" "Kernel: SaveToFile()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     SaveToFile()
Short:    Writes all of an object's information to a destination file.
Synopsis: LONG SaveToFile(APTR Object [a0], *FileName [a1],
            BYTE *FileType [a2])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action  will  save  an  object's  data  to  a  file, in a data format
specified by the FileType argument.  If the FileType is NULL, the data will
be saved in the object's default format.

To  illustrate:  As a default, the Picture object saves all pictures in IFF
format, and it supports the loading of pictures in IFF format.  If there is
a  JPEG  support object in the system and you specify that as the type, you
can instead save the data as a JPEG file.

For  simple  applications,  you should just accept the default save format.
For  more  "user  friendly"  programs however, it is better for the user to
select  a  save  format.   To  do  this you need to find what FileTypes are
available before you call SaveToFile().  You can find this out by using the
GetFileType() and GetTypeList() functions.  When you know what FileType you
want  to  use,  you  can  then  call SaveToFile() with the correct FileType
pointer.

@{b}@{u}INPUTS@{uu}@{ub}
Object
  Pointer to an initialised object.

FileName
  Pointer to a FileName structure.  NB:  It is up to you to set the file
  extension (e.g ".jpeg"), if any.

FileType
  Pointer to a FileType as obtained from GetFileType() or GetTypeList().
  The FileType string describes the data format that you want to save as.
  Leave this argument at NULL to accept the default file format.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK on success.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"GetExtension()" LINK "GetExtension()"}
        @{"GetFileType()"  LINK "GetFileType()"}
        @{"GetTypeList()"  LINK "GetTypeList()"}
        @{"Load()"         LINK "Load()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "SearchForTask()" "Kernel: SearchForTask()"

Private.

@EndNode
-----------------------------------------------------------------------------
@NODE "Seek()" "Kernel: Seek()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     Seek()
Short:    Seek to a byte position in an object.
Synopsis: LONG Seek(*Object [a0], LONG Offset [d0], LONG Mode [d1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Seek()  sets  the read/write position for a given Object.  This position is
used by both Read() and Write() as a place to start reading or writing.

The  Mode  can  be  POS_START/POS_BEGINNING, POS_CURRENT or POS_END.  It is
used  to specify the relative start position.  For example, 20 from current
is  a  position  20  bytes  forward from current, -20 is 20 bytes back from
current.

You cannot Seek() beyond the end of an object (an error will be returned).

@{b}@{u}INPUTS@{uu}@{ub}
Object
  Pointer to an initialised object.

Offset
  The byte position that you want to seek to, relative to the Mode
  argument.

Mode
  Either POS_START/POS_BEGINNING, POS_CURRENT or POS_END.

@{b}@{u}RESULT@{uu}@{ub}
Returns the old byte position of the object, or -1 if error.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Read()" LINK "Read()"}
        @{"Write()" LINK "Write()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "SelfDestruct()" "Kernel: SelfDestruct()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     SelfDestruct()
Short:    Destroys the task and frees resources.
Synopsis: void SelfDestruct(void)

@{b}@{u}DESCRIPTION@{uu}@{ub}
This function destroys the task that called this function and then proceeds
to  free  all  of its resources according to the resource nodes.  This is a
completely  safe and effective way for a task to destroy itself, and can be
used  for  deconstructing  a  task  when  it  has  got  into  unrecoverable
circumstances.

You  must  have called InitDestruct() before calling this function.  If you
are  programming  in  C  or assembler this initialisation is already in the
STARTDPK macro and gms.o startup file, so this does not concern you.

@{b}@{u}NOTE@{uu}@{ub}   This   function   will  not  return.   However  if
InitDestruct() has not been called then the function will not be able to do
anything  and  will  return  back to the task.  This can also happen if the
user has turned off the resource tracking feature from GMSPrefs.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"InitDestruct()" LINK "InitDestruct()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "SetContext()" "Kernel: SetContext()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     SetContext() (V2.1)
Short:    Tells the system which object has control over the current Task.
Synopsis: APTR SetContext(*Object [a0]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
This function provides a way of telling the system which object has control
of  the  current  Task.   Through  the use of this function, you can assign
resources  to  an  object.   This  is particularly important for memory and
object handling.  For example:

  Screen = Init(Screen, NULL);
  Context = SetContext(Screen);
    Get(Bitmap);
    AllocMemBlock(1000, MEM_DATA);
  SetContext(Context);
  Free(Screen);

In the above code, we allocated a Bitmap and a memory block which will both
be  contained  by  the  Screen.  When the Free() action is called, both the
Bitmap  and  memory  block  will  be  freed  automatically because they are
dependent  on  the  Screen's  existance.  This is a basic resource tracking
feature.  Please keep in mind that the following is incorrect:

  Screen = Init(Screen, NULL);
  Context = SetContext(Screen);
    Bitmap = Get(Bitmap);
    Memory = AllocMemBlock(1000, MEM_DATA);
  SetContext(Context);
  Free(Screen);
  Free(Bitmap);
  FreeMemBlock(Memory);

Freeing the Bitmap and Memory block AFTER the Screen is invalid, however we
are  allowed to free them before the Screen if necessary.  Most of the time
you might want to leave it to the system though.

@{b}@{u}NOTE@{uu}@{ub}
SetContext() is intended for use by system modules, most programmers should
not be concerned with this function.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to the object that will take on the new context.

@{b}@{u}RESULT@{uu}@{ub}
Returns  a  pointer  to  the  previous  context.   You  will  need  to call
SetContext()  a second time with the returned pointer, in order to keep the
system stable.

@EndNode
-----------------------------------------------------------------------------
@NODE "SetField()" "Kernel: SetField()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     SetField() (V2.0)
Short:    Sets field data for an object.
Synopsis: LONG SetField(*Object [a0], LONG FieldID [d0], LONG Data [d1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  is identical in operation to GetField(), but will allow you
to  write data to a field rather than read from it.  Going from the example
given  in  GetField(),  in order to write to the XCoord/YCoord fields of an
object, you would use this code:

  SetField(Object,FID_XCoord,150);
  SetField(Object,FID_YCoord,237);

Remember  that  some  fields  are set to read-only after an object has been
initialised, so keep that in mind.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to an object allocated from Get().

FieldID
  The FID number of the field you wish to write to.

Data
  A long-word defining the data that you wish to write to the field.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK if successful or ERR_SEARCH if the field was not found.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"GetField()" LINK "GetField()"}
        @{"SetFieldName()" LINK "SetFieldName()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "SetFieldName()" "Kernel: SetFieldName()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     SetFieldName() (V2.0)
Short:    Sets field data for an object.
Synopsis: LONG SetFieldName(*Object [a0], BYTE *Name [a1], LONG Data [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  is identical in operation to GetFieldName(), but will allow
you  to  write  data  to  a field rather than read from it.  Going from the
example  given in GetField(), in order to write to the XCoord/YCoord fields
of an object, you would use this code:

  SetField(Object,"XCoord",150);
  SetField(Object,"YCoord",237);

Remember  that  some fields are noted as read-only after an object has been
initialised, so keep that in mind.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to an object allocated from Get().

Name
  The name of the field you wish to write to.

Data
  A long-word defining the data that you wish to write to the field.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK if successful or ERR_SEARCH if the field was not found.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"GetFieldName()" LINK "GetFieldName()"}
        @{"SetField()" LINK "SetField()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Show()" "Kernel: Show()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Show()
Short:    Makes an object visible to the user.
Synopsis: LONG Show(APTR Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Calling this action will make the specified object visible to the user.

Visual objects (Bobs, Buttons, Windows...) will usually appear on a Screen.
Non-visual  objects such as Files will simply have their state changed.  If
you Show() an object that is already visible, there will be no effect.

If you want to make the object invisible, call the Hide() action.

@{b}@{u}INPUT@{uu}@{ub}
Object
  The object to be shown.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK on success.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Hide()" LINK "Hide()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SlowRandom()" "Kernel: SlowRandom()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     SlowRandom()
Short:    Generate a random number between 0 and <Range>.
Synopsis: LONG SlowRandom(LONG Range [d1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  generates  a  very good random number in a relatively short
amount  of  time.   This  routine takes approximately two times longer than
FastRandom(),   but   is  guaranteed  of  giving  excellent  random  number
sequences.

Remember that all generated numbers fall 1 value BELOW the Range.

@{b}@{u}INPUT@{uu}@{ub}
Range
  A range between 1 and 32767.

@{b}@{u}RESULT@{uu}@{ub}
Returns a number greater or equal to 0, and @{i}less than@{ui} Range.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"FastRandom()" LINK "FastRandom()"}
Demos:  @{"demos/randomplot" SYSTEM "GMS:demos/RandomPlot"}

@EndNode
---------------------------------------------------------------------------
@NODE "Stream()" LINK "Kernel: Stream()"

Private.

@EndNode
-----------------------------------------------------------------------------
@NODE "TagInit()" "Kernel: TagInit()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     TagInit()
Short:    Initialise a structure according to a tag list.
Synopsis: LONG TagInit(APTR Structure [a0], APTR TagList [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  is  intended  for  system modules but may be used by normal
programs if required.

It will process a standard tag list and store specified values in the given
structure,  which should be empty although this is not a pre-requisite.  It
is important that the tags themselves have been correctly defined using the
TBYTE, TWORD and TLONG flags.  Check the include files for examples.

This  function  has  some software based memory protection and will prevent
values from being written outside of the structure's memory area.  Detected
errors will be sent to the system debugger.

@{b}@{u}INPUTS@{uu}@{ub}
Structure
  Pointer to the allocated structure memory.

TagList
  Pointer to a standard tag list (see tags).

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK if successful.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Get()" LINK "Get()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "TotalMem()" "Kernel: TotalMem()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     TotalMem()
Short:    Returns the total amount of memory in use by any given object.
Synopsis: LONG TotalMem(*Object [a0], LONG Flags [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function calculates the total amount of memory currently in use by an
object.   This  total  can be calculated for a specific type of memory (e.g
MEM_VIDEO),  or  a  total  of  all  memory  in  use  by the object if -1 is
specified.   If  the  Object  argument is passed as NULL then this function
will sum up the total amount of memory for the calling Task.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to an object that you want a memory total for.

Flags
  The  memory  type  that  you want to be calculated (MEM_VIDEO, MEM_SOUND,
  MEM_DATA,  MEM_CODE  or  MEM_BLIT).   If you want a complete total of all
  memory in use by an object, specify -1 here.

@{b}@{u}RESULT@{uu}@{ub}
Returns the amount of memory in use (in bytes).

@EndNode
-----------------------------------------------------------------------------
@NODE "Unhook()" "Kernel: Unhook()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Unhook()
Short:    Safely removes a single object from an object chain.
Synopsis: LONG Unhook(*Object [a0], *Chain [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action  has  been provided for objects that support chain formations.
Examples  are  the File and Directory objects, which support chains through
the Next and Prev fields in order to build file and directory trees.

By  using  Unhook(), you can pull individual objects out of a chain without
harming  the  other  objects.   If  successful, the object will then become
independant  and  the  chain  will be patched so that there are no "holes".
You can now use the newly independant object as you wish.

@{b}@{u}NOTE@{uu}@{ub}
You will be responsible for Free()ing the object after unhooking it.

@{b}@{u}INPUT@{uu}@{ub}
Object
  The object that you want to remove.

Chain
  Points  to  the first object of the chain, or NULL if the object does not
  require this argument.

@{b}@{u}RESULT@{uu}@{ub}
Returns  ERR_OK  if  successful.  If unsuccessful, the chain will remain in
its original state.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Detach()" LINK "Detach()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Unlock()" "Kernel: Unlock()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     Unlock()
Short:    Remove a lock from an object.
Synopsis: LONG Unlock(*Object [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
After  you  have  Lock()ed  an  object,  you  will  eventually have to call
Unlock().   Once  you  have  Unlock()ed  the  object,  all  of  the locking
conditions  will  be  removed.  (Although because locks will nest, you will
need to call Unlock() for every Lock() that is still waiting to be freed).

If  you  Free()  an  object  with locks that are still waiting, Free() will
automatically  Unlock()  them  for  you.   This  is for safety though, your
program will be considered to be buggy if this occurs...

@{b}@{u}INPUT@{uu}@{ub}
Object
  The object that you want to unlock.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Lock()" LINK "Lock()"}

@EndNode
---------------------------------------------------------------------------
@NODE "WaitTime()" "Kernel: WaitTime()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     WaitTime()
Short:    Wait for a specified amount of micro-seconds.
Synopsis: void WaitTime(LONG MicroSeconds [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This function waits for the specified amount of micro-seconds.  During this
time your task will be idle and will not steal CPU cycles.

@{b}@{u}INPUT@{uu}@{ub}
MicroSeconds
  Amount of micro-seconds to wait for (100 = 1 Second).

@EndNode
-----------------------------------------------------------------------------
@NODE "Write()" "Kernel: Write()"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Write()
Short:    Writes a given amount of bytes to an object's data space.
Synopsis: LONG Write(APTR Object [a0], APTR Buffer [a1], LONG Length [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action will write the amount of bytes as determined by 'Length', from
the  memory  buffer and into the Object's data space.  The write will start
at  the  position  determined  by  the  object's  BytePos  field.  The byte
position will be incremented to BytePos+Length if the call succeeds.

If  the  BytePos+Length exceeds the total size of the file, then the object
may  increase  its  data  space  to  cope  with writing out the rest of the
buffer.   This will always happen with Files, but memory based objects will
rarely be able to do this unless they can safely Realloc() the data block.

@{b}@{u}INPUTS@{uu}@{ub}
Object
  Pointer to an initialised object.

Buffer
  A pointer to the raw data that will be written to the object.

Length
  Amount of bytes to write.

@{b}@{u}RESULT@{uu}@{ub}
Returns the amount of bytes written.  NULL indicates an error.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Read()" LINK "Read()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "()" "Kernel: ()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     ()
Short:    
Synopsis: 

@{b}@{u}DESCRIPTION@{uu}@{ub}

@{b}@{u}NOTE@{uu}@{ub}

@{b}@{u}INPUT@{uu}@{ub}

@{b}@{u}RESULT@{uu}@{ub}

@{b}@{u}SEE ALSO@{uu}@{ub}

@EndNode
