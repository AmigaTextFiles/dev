@DATABASE "Directory"
@AUTHOR   "Paul Manias"
@NODE     "Main" "Object: Directory"

@{b}@{u}OBJECT DOCUMENTATION@{uu}@{ub}
Name:      @{"DIRECTORY" LINK "Description"}
Date:      March 1998
Author:    Paul Manias
Copyright: DreamWorld Productions, 1996-1998.  All rights reserved.

@{b}@{u}CHANGES VERSION 1.0@{uu}@{ub}
Removed: Directory->Comments
         Directory->Permissions
         Directory->Date
         Directory->Query()

Edited:  All

@{b}@{u}CHANGES VERSION 0.9B@{uu}@{ub}
Added:   Directory->ChildDir
         Directory->ChildFile
         Directory->Next
         Directory->Prev

Edited:  Directory->Comment
         Directory->Date

Renamed: Directory->UserFlags to Directory->Permissions

@EndNode
---------------------------------------------------------------------------
@NODE "Description" "Object: Directory"

@{b}@{u}OBJECT@{uu}@{ub}
Name:     Directory
Version:  1
ID:       ID_DIRECTORY
Module:   @{"Files" LINK "GMSDev:AutoDocs/Files.guide/Functions"}
Include:  @{"files/files.h" LINK "GMSDev:Includes/files/files.h/Main"}
Type:     Complex
Children: Directories, Files

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  object  is  used  for  file  and  directory  management purposes.  It
supports   Comments,   DateStamps  and  Permissions.   Due  to  the  object
orientation,  it also gives you the ability to build complex directory tree
structures with very little effort.

Here  is  an  example  of what sort of hierarchy can be created through the
structure  of  Directories  and  Files.  A tree like this can be created by
simply calling the Activate() action on a Directory and its children.  Each
name  in  quotes (eg 'GMS:') represents an actual Directory or File object.
The links are created through use of the Next, Prev, ChildFile and ChildDir
fields.
 
   'GMS:' --- 'GMS:Documents/'
     |               |
     |        'GMS:Modules/' ---- 'GMS:Modules/Emulation/'
     |               | |
     |               | +-'blitter.mod'
     |               |   'joyports.mod'
     |               |   'screens.mod'
     |               |
     |        'GMS:Utils/' ------ 'GMS:Utils/GMSPrefs/'
     |
     +-'GMS:Copyright.txt'
       'GMS:Questionnaire.txt'

As  you  can  see,  you can travel as deep into a directory as you want and
easily  link  files  into  the  hierarchy.   If you later want to break the
structure  down,  you  can  Detach()  and  Unhook() the objects to use them
independantly.   If  the  diagram is a bit confusing to you, read the field
sections on ChildDir, ChildFile and Next and Prev.

@{b}@{u}FUNCTIONS@{ub}@{uu}
Some functions supporting the Directory object are:

     @{"GetFComment()" LINK "GMSDev:AutoDocs/Files.guide/GetFComment()"}     - Get the comment from a Directory.
     @{"GetFDate()" LINK "GMSDev:AutoDocs/Files.guide/GetFDate()"}        - Get a Directory's date stamp.
     @{"GetFPermissions()" LINK "GMSDev:AutoDocs/Files.guide/GetFPermissions()"} - Get the user permissions on a Directory.
     @{"SetFComment()" LINK "GMSDev:AutoDocs/Files.guide/SetFComment()"}     - Write a comment to a Directory.
     @{"SetFDate()" LINK "GMSDev:AutoDocs/Files.guide/SetFDate()"}        - Set a Directory's date stamp.

@{b}@{u}ACTIONS@{ub}@{uu}
The Directory object supports the following actions:

   * @{"Activate()" LINK "DIR_Activate()"} - Get a directory listing.
   * @{"Detach()" LINK "DIR_Detach()"}   - Detach a file/dir chain from a master directory.
   * @{"Free()" LINK "DIR_Free()"}     - Free a Directory object.
     @{"Get()" LINK "GMSDev:AutoDocs/Kernel.guide/Get()"}      - Get a new Directory structure.
     @{"Init()" LINK "GMSDev:AutoDocs/Kernel.guide/Init()"}     - Initialise a Directory.
     @{"Unhook()" LINK "GMSDev:AutoDocs/Kernel.guide/Unhook()"}   - Unhook a directory from within a chain.

@{b}@{u}STRUCTURE@{uu}@{ub}
The Directory structure consists of the following public fields:

   + @{"ChildDir" LINK "DIR_ChildDir"}  - Pointer to first sub-directory in list.
   + @{"ChildFile" LINK "DIR_ChildFile"} - Pointer to first sub-file list.
     @{"Flags" LINK "DIR_Flags"}     - Directory flags and options.
     @{"Next" LINK "DIR_Next"}      - Next directory in list.
     @{"Prev" LINK "DIR_Prev"}      - Previous directory in list.
     @{"Source" LINK "DIR_Source"}    - Pointer to Directory source.

@EndNode
---------------------------------------------------------------------------
@NODE "DIR_ChildDir" "Object: Directory"

@{b}@{u}FIELD@{uu}@{ub}
Name:        ChildDir
Type:        struct Directory *
Inheritance: Activate()
Status:      Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This   field   points   to   the   first  structure  of  a  linked-list  of
sub-directories  for your master Directory.  This list is only built if you
call the Activate() function.  Each sub-directory will be Init()ialised, so
you can get information such as comments and dates from them.

You may treat the sub-directories as normal objects, and call Activate() on
each child to start building complex tree structures if you wish.

Note  that  when  you  free your Directory object, all child directories on
this linked-list will be freed.  If you want to keep a child directory, you
may  use  the  Detach()  and  Unhook()  actions to do this.  After you have
extracted a child object you will be responsible for Free()ing it.

If  there  are no sub-directories then this field will be set to NULL after
an Activate().

@{b}@{u}SEE ALSO@{uu}@{ub}
Fields: @{"ChildFile" LINK "DIR_ChildFile"}
        @{"Next"      LINK "DIR_Next"}
        @{"Prev"      LINK "DIR_Prev"}

@EndNode
---------------------------------------------------------------------------
@NODE "DIR_ChildFile" "Object: Directory"

@{b}@{u}FIELD@{uu}@{ub}
Name:        ChildFile
Type:        struct File *
Inheritance: Activate()
Status:      Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field points to the first structure of a linked-list of sub-files for
your  master Directory.  This list is only built if you call the Activate()
function.   Each sub-file will be Init()ialised, so you can get information
such as comments and dates from them.

You  may  treat them as normal objects and use the various action functions
for files (OpenFile() is okay too).

Note  that  when  you  free  your  Directory object, all child files on the
linked-list  will  be freed.  If you want to keep a child File, you may use
the  Detach()  and  Unhook()  actions to do this.  After you have extracted
your object you will be responsible for Free()ing it.

If  there  are  no  sub-files  then this field will be set to NULL after an
Activate().

@{b}@{u}SEE ALSO@{uu}@{ub}
Fields: @{"ChildDir" LINK "DIR_ChildDir"}
        @{"Next"     LINK "DIR_Next"}
        @{"Prev"     LINK "DIR_Prev"}

@EndNode
---------------------------------------------------------------------------
@NODE "DIR_Flags" "Object: Directory"

@{b}@{u}FIELD@{uu}@{ub}
Name:   Flags
Type:   LONG
Status: Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This field specifies the Flags to use when initialising a Directory.  These
flags  are  identical to the ones in File->Flags, so for a full description
please read that documentation.

Most  flags  do  not  apply  to  the  Directory  object,  here are the ones
currently in use:

  FL_AUTOCREATE - Automatically create the directory if it does not exist.

  FL_FIND       - Attempts to find the directory if necessary.

  FL_NEWFILE    - Identical to FL_AUTOCREATE.

  FL_NOBUFFER   - Do not place this directory in the cache.

@{b}@{u}SEE ALSO@{uu}@{ub}
File: @{"Flags" LINK "GMSDev:AutoDocs/Objects/File.guide/FILE_Flags"}

@EndNode
---------------------------------------------------------------------------
@NODE "DIR_Next" "Object: Directory"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Next
Type:        struct Directory *
Inheritance: Activate()
Status:      Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This field only applies when a Directory object forms part of a linked-list
of directories.  It points directly to the next Directory in the chain.  If
the value is NULL, then this is the last link.

To build a linked-list of child directories, call Activate() on your master
directory.

@{b}@{u}SEE ALSO@{uu}@{ub}
Fields: @{"ChildDir" LINK "DIR_ChildDir"}
        @{"Prev"     LINK "DIR_Prev"}

@EndNode
---------------------------------------------------------------------------
@NODE "DIR_Prev" "Object: Directory"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Prev
Type:        struct Directory *
Inheritance: Activate()
Status:      Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This field only applies when a directory object forms part of a linked-list
of directories.  It points directly to the previous directory in the chain.
If the value is NULL, then this is the first link.

To build a linked-list of child directories, call Activate() on your master
directory.

@{b}@{u}SEE ALSO@{uu}@{ub}
Fields: @{"ChildDir" LINK "DIR_ChildDir"}
        @{"Next"     LINK "DIR_Next"}

@EndNode
---------------------------------------------------------------------------
@NODE "DIR_Source" "Object: Directory"

@{b}@{u}FIELD@{uu}@{ub}
Name:   Source
Type:   struct FileName *
Status: Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
Points  to  a  source  object,  which  currently  can  only  be  a FileName
structure.   This  field  is  required  - you cannot initialise a Directory
without specifying a valid Source.

Here is a typical example of a Directory Source:

  struct FileName MyDir = { ID_FILENAME, "GMS:Demos/" }

If  you  put  a "/" at the end it will be ignored by this function, but you
may want to use it for clarity.

@EndNode
---------------------------------------------------------------------------
@NODE "DIR_Detach()" "Action: Detach(Object, Directory)"

@{b}@{u}ACTION@{uu}@{ub}
Name:   Error = Detach(Object, Directory)
Object: Directory
Short:  Detach a sub-directory or sub-file chain from a Directory.

@{b}@{u}DESCRIPTION@{uu}@{ub}
After  Activate()ing a Directory, sub-directory and sub-file chains will be
created  and  attached  to the now "master" directory object.  By using the
Detach() action, you can pull out the chain so that it no longer belongs to
the master Directory.

There are only two correct usages for this action:

  Detach(Directory->ChildFile,Directory);

OR

  Detach(Directory->ChildDir,Directory);

Once  you have detached a chain, you will be responsible for Free()ing each
object individually.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Detach()" LINK "GMSDev:AutoDocs/Kernel.guide/Detach()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DIR_Activate()" "Action: Activate(Directory)"

@{b}@{u}ACTION@{uu}@{ub}
Name:   Error = Activate(Directory)
Object: Directory
Short:  Generate a list of all files and sub-directories in a Directory.

@{b}@{u}DESCRIPTION@{uu}@{ub}
By  calling  Activate()  you  can  quickly  obtain  a list of all files and
sub-directories in a Directory object.  As a result of calling this action,
two  lists  will  be  created  and pointed to in the ChildFile and ChildDir
fields.

If you call Activate() a second time, ALL objects on the existing ChildFile
and  ChildDir  chains  will be freed.  The directory structure will then be
read again from scratch.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Activate()" LINK "GMSDev:AutoDocs/Kernel.guide/Activate()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DIR_Free()" "Action: Free(Directory)"

@{b}@{u}ACTION@{uu}@{ub}
Name:   Free(Directory)
Object: Directory
Short:  Free a Directory and its children.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Calling  this  action  will  free  a  Directory  from  the  system.  If the
Directory  has  a  ChildFile  and/or a ChildDir chain, each object on those
chains  will  also  be  Free()ed.  This will cause a recursive effect, i.e.
any "grand-children" chains will also be freed if they exist and so on.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Free()" LINK "GMSDev:AutoDocs/Kernel.guide/Free()"}

@EndNode
---------------------------------------------------------------------------
