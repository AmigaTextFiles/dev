@DATABASE "Screen"
@AUTHOR   "Paul Manias"
@NODE     "Main" "Object: Screen"

@{b}@{u}OBJECT DOCUMENTATION@{uu}@{ub}
Name:      @{"SCREEN" LINK "Description"}
Date:      August 1998
Author:    Paul Manias
Copyright: DreamWorld Productions, 1996-1998.  All rights reserved.

@{b}@{u}CHANGES VERSION 2@{uu}@{ub}
Edited:  Screen->Attrib flag names.

@{b}@{u}CHANGES VERSION 1@{uu}@{ub}
Deleted: References to LockVideo() and UnlockVideo().

Removed: Screen->Attrib:BLANKPALETTE, SPRITES
         Screen->Palette
         Screen->Task

Edited:  Screen->Link
         Screen->XOffset/YOffset
         Screen->Width/Height
         Screen->BmpXOffset/BmpYOffset
         Screen->Attrib
         Screen->ScrMode

@EndNode
---------------------------------------------------------------------------
@NODE  "Description" "Object: Screen"

@{b}@{u}OBJECT@{ub}@{uu}
Name:     Screen
Version:  2
ID:       ID_SCREEN
Module:   @{"Screens" LINK "GMSDev:AutoDocs/Screens.guide/Functions"}
Include:  @{"graphics/screens.h" LINK "GMSDev:Includes/graphics/screens.h/Main"}
Type:     Complex
Children: Bitmap, Raster

@{b}@{u}DESCRIPTION@{ub}@{uu}
The  Screen represents an area of displayable video memory.  Although it is
probably  the  most  complex  structure, it is fairly simple to initialise.
Indeed  it  is  possible  to initialise a Screen by passing an empty Screen
structure  to  Init()  and  accepting all the user defaults (recommended if
possible).

For more demanding applications however you may often need to specify a few
fields.   Before  doing  so,  make  sure that you understand how each field
operates  and what implications setting them may bring.  Where possible try
to  avoid  setting  field  values,  as  the  user  default should always be
considered as acceptable.

@{b}@{u}NOTE@{uu}@{ub}
The MemPtrX fields can change without notice while your program is running.
This  is  because the memory pointers move around when the screen is hidden
or  moved  from the display.  To ensure the screen does not move its memory
position you can use the Lock() action.

@{b}@{u}ACTIONS@{uu}@{ub}
The Screen object supports the following actions:

     @{"Clear()" LINK "GMSDev:AutoDocs/Kernel.guide/Clear()"}         - Clear the Screen->Bitmap's current data area.
     @{"CopyStructure()" LINK "GMSDev:AutoDocs/Kernel.guide/CopyStructure()"} - Copy Screen details to another object.
     @{"Free()" LINK "GMSDev:AutoDocs/Kernel.guide/Free()"}          - Free a Screen from the system.
     @{"Get()" LINK "GMSDev:AutoDocs/Kernel.guide/Get()"}           - Get a new Screen structure.
     @{"Hide()" LINK "GMSDev:AutoDocs/Kernel.guide/Hide()"}          - Hide a Screen from view.
   * @{"Init()" LINK "GS_Init()"}          - Initialise a Screen.
   * @{"Lock()" LINK "GS_Lock()"}          - Lock a Screen object.
     @{"Show()" LINK "GMSDev:AutoDocs/Kernel.guide/Show()"}          - Display a Screen on a monitor or TV.
     @{"Unlock()" LINK "GMSDev:AutoDocs/Kernel.guide/Unlock()"}        - Unlock a Screen.

@{b}@{u}FUNCTIONS@{uu}@{ub}
For  a  list  of  all  the  Screen  functions, see the documentation on the
Screens module.

@{b}@{u}STRUCTURE@{ub}@{uu}
The Screen structure consists of the following public fields:

     @{"Attrib" LINK "GS_Attrib"}     - Special Attributes are?
   + @{"Bitmap" LINK "GS_Bitmap"}     - Pointer to bitmap structure (for blitting).
     @{"BmpXOffset" LINK "GS_BmpXOffset"} - X offset of a Screen's Bitmap.
     @{"BmpYOffset" LINK "GS_BmpXOffset"} - Y offset of a Screen's Bitmap.
     @{"Height" LINK "GS_Width"}     - The height of the visible screen window.
     @{"MemPtr1" LINK "GS_MemPtr"}    - Pointer to screen 1
     @{"MemPtr2" LINK "GS_MemPtr"}    - Pointer to screen 2 (doubled buffer)
     @{"MemPtr3" LINK "GS_MemPtr"}    - Pointer to screen 3 (tripled buffer)
   + @{"Raster" LINK "GS_Raster"}     - Pointer to a Raster object.
     @{"ScrMode" LINK "GS_ScrMode"}    - What screen mode is it?
     @{"Switch" LINK "GS_Switch"}     - Handles switching of display buffers.
     @{"Width" LINK "GS_Width"}      - The width of the visible screen window.
     @{"XOffset" LINK "GS_XOffset"}    - Hardware co-ordinate for the top of Screen.
     @{"YOffset" LINK "GS_XOffset"}    - Hardware co-ordinate for the top of Screen.

@EndNode
---------------------------------------------------------------------------
@NODE "GS_Attrib" "Object: Screen"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Attrib
Type:        LONG
Inheritance: Some flags can be set by the user.
On Change:   Cannot change after initialisation.
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  defines  the  special  attributes  for  the screen.  Currently
available flags are:

  @{u}SCR_BLKBDR@{uu}
  Turns all colours outside of the viewport to black.  Works on AGA only.

  @{u}SCR_CENTRE@{uu}
  Centres  the screen by calculating the correct offsets for ScrXOffset and
  ScrYOffset  for  any  screen mode.  The calculated values will over-write
  any values already set in these fields.

  @{u}SCR_DBLBUFFER@{uu}
  Allocates  an  extra  screen  buffer which is placed in MemPtr2.  See the
  SwapBuffers() function for more information on double buffering.

  @{u}SCR_HSCROLL@{uu}
  Set if you want to use horizontal picture scrolling.

  @{u}SCR_NOSCRBDR@{uu}
  Allows  sprites  and  other  displayable objects to appear outside of the
  viewport.  Works on AGA only.

  @{u}SCR_SBUFFER@{uu}
  Allocates  extra  space  to  allow  you  to  horizontally scroll up to 50
  screens  in  either  X direction.  Technically this is a hack and may not
  work on all hardware.

  @{u}SCR_TPLBUFFER@{uu}
  Allocates two extra buffers which are placed in MemPtr2 and MemPtr3.  See
  the SwapBuffers() for more information on triple buffering.  Note:  Never
  set the DBLBUFFER flag in conjunction with the TPLBUFFER flag.

  @{u}SCR_VSCROLL@{uu}
  Set if you want to use vertical picture scrolling.

@EndNode
---------------------------------------------------------------------------
@NODE "GS_Bitmap" "Object: Screen"

@{b}@{u}FIELD@{uu}@{ub}
Name:   @{"Bitmap" LINK "GMSDev:AutoDocs/Objects/Bitmap.guide/Main"}
Type:   struct Bitmap *
Status: Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
The Bitmap object sets display information on how the data will be shown on
screen.  It holds details on the width, height, type, number of colours and
so  on.   The  Screen inherits and uses all of these fields, so you can set
them on initialisation as per normal.

@{b}@{u}NOTE@{uu}@{ub}
The  Bitmap's Width and Height can be larger than the Screen area, but must
never be smaller than the Screen area.

@EndNode
---------------------------------------------------------------------------
@NODE "GS_BmpXOffset" "Object: Screen"

@{b}@{u}FIELDS@{uu}@{ub}
Names:     BmpXOffset, BmpYOffset
Type:      WORD
To Change: @{"SetBmpOffsets()" LINK "GMSDev:AutoDocs/Screens.guide/SetBmpOffsets()"}
Status:    Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
These  two  fields  set the offsets for the Bitmap "behind" the Screen.  If
you   want   to   achieve   hardware  scrolling,  you  will  need  to  call
SetBmpOffsets() in order to change these values and update the display.

@{b}@{u}SEE ALSO@{uu}@{ub}
Screens: @{"SetBmpOffsets()" LINK "GMSDev:AutoDocs/Screens.guide/SetBmpOffsets()"}

@EndNode
---------------------------------------------------------------------------
@NODE "GS_Link" "Object: Screen"

@{b}@{u}FIELD@{uu}@{ub}
Name:      Link
Type:      struct Screen *
On Change: Cannot change after initialisation.
Status:    Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
If  you  want  to  set  up  a  second screen at a different position in the
viewport,  or  create an extra (double) playfield, point to the next Screen
structure here.

@{b}@{u}BUGS@{uu}@{ub}
Due  to  the  complexity  of  writing the code for this field, work was not
completed  in  time  for  Version 1.0.  Full support will appear at a later
date.

@EndNode
---------------------------------------------------------------------------
@NODE "GS_MemPtr" "Object: Screen"

@{b}@{u}FIELDS@{uu}@{ub}
Names:       MemPtr1, MemPtr2, MemPtr3
Type:        APTR
Inheritance: Allocated by Init().
On Change:   Cannot change after initialisation.
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
These  fields point to the screen display data.  They should be NULL if you
want Init() to allocate the memory for you (highly recommended).  Otherwise
it  will  be assumed that the values are valid pointers to video memory and
screen based functions will use them as such.

@{b}@{u}NOTE@{uu}@{ub}
THIS  IS  IMPORTANT.   You cannot read any of the MemPtrX fields unless you
have  called Lock(Screen).  Also, remember to Unlock() your Screen when you
are  no  longer  using  the  MemPtrX fields, otherwise you can cause memory
problems.

@EndNode
---------------------------------------------------------------------------
@NODE "GS_Raster" "Object: Screen"

@{b}@{u}FIELD@{uu}@{ub}
Name:        @{"Raster" LINK "GMSDev:AutoDocs/Objects/Raster.guide/Main"}
Type:        struct Raster *
Inheritance: None
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
Point  this  to  an initialised Raster object, or leave it as NULL.  Raster
objects  are  made up of instructions that are executed as the monitor beam
travels down the screen.  See the Raster documentation for more information
on this.

@{b}@{u}NOTE@{uu}@{ub}
There  exists  the  possibility that in future, users could build their own
raster  lists  and apply them to public Screens (for fun effects).  This is
something  to keep in mind if you initialise a public Screen and leave this
field as NULL.

@EndNode
---------------------------------------------------------------------------
@NODE "GS_ScrMode" "Object: Screen"

@{b}@{u}FIELD@{uu}@{ub}
Name:        ScrMode
Type:        WORD
Inheritance: User default.
On Change:   Cannot change after initialisation.
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field defines the display mode for the screen.  If you do not fill in
this field, you will get the user's default resolution.

This field does not allow programmed mode promotion (DBLPAL, MULTISCAN etc)
-  this  matter  is  handled internally and by user selections in GMSPrefs.
You  cannot  force  mode  promotion  from inside your program.  NB:  If you
require  compatibility  for  NTSC, set ScrHeight to 200 (or accept the user
default  for  ScrHeight)  and  assume  that the user has selected NTSC mode
promotion in GMSPrefs.

  @{u}SM_LORES@{uu}
  Specifies a low resolution screen.

  @{u}SM_HIRES@{uu}
  Specifies a high resolution screen (1/2 pixels horizontal).

  @{u}SM_SHIRES@{uu}
  Specifies a super-high resolution screen (1/4 pixels horizontal).

  @{u}SM_LACED@{uu}
  Creates an interlaced display (1/2 pixels vertical).

  @{u}SM_SLACED@{uu}
  Specifies super-laced resolution (1/4 pixels vertical).

@EndNode
---------------------------------------------------------------------------
@NODE "GS_Switch" "Object: Screen"

@{b}@{u}FIELDS@{uu}@{ub}
Name:   Switch
Type:   WORD
Status: Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  gives  the  current  switching status of the Screen.  If it is
NULL,  then  the Screen is not waiting to have its buffers switched.  If it
is 1, then the Screen is waiting for the buffers to switch.

This  field is handled by the ReadySwitch() and WaitSwitch() functions.  If
you never use these functions, then the Switch field will always be NULL.

@{b}@{u}SEE ALSO@{uu}@{ub}
Screens: @{"ReadySwitch()"     LINK "GMSDev:AutoDocs/Screens.guide/ReadySwitch()"}
         @{"WaitSwitch()"      LINK "GMSDev:AutoDocs/Screens.guide/WaitSwitch()"}
Theory:  @{"Display Buffering" LINK "GMSDev:AutoDocs/Screens.guide/DisplayBuffering"}

@EndNode
---------------------------------------------------------------------------
@NODE "GS_XOffset" "Object: Screen"

@{b}@{u}FIELDS@{uu}@{ub}
Names:       XOffset, YOffset
Type:        WORD
Inheritance: None, but the user has a hidden influence.
To Change:   @{"SetScrOffsets()" LINK "GMSDev:AutoDocs/Screens.guide/SetScrOffsets()"}
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
These  fields  specify  the hardware offset for a Screen.  These two values
are  added  to  the  user's screen offset in GMSPrefs.  A setting of 0,0 in
these fields should be sufficient for the majority of programs.

Negative  values are allowed.  If you go out of the displayable range, then
the field values will be automatically restricted.

@EndNode
---------------------------------------------------------------------------
@NODE "GS_Width" "Object: Screen"

@{b}@{u}FIELDS@{uu}@{ub}
Names:       Width, Height
Type:        WORD
Inheritance: User default.
To Change:   @{"SetScrDimensions()" LINK "GMSDev:AutoDocs/Screens.guide/SetScrDimensions()"}
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
These  fields  define  a  Screen's  height and width.  This is known as the
"viewport"  that  the  bitmap  data is displayed through.  The width of the
Screen must be divisible by 16 (e.g.  320, 336, 640).

If   the  width  or  height  setting  is  too  large,  then  they  will  be
automatically restricted to values that the display hardware can handle.

@{b}@{u}SEE ALSO@{uu}@{ub}
Bitmap:  @{"Height" LINK "GMSDev:AutoDocs/Objects/Bitmap.guide/BMP_Height"}
         @{"Width"  LINK "GMSDev:AutoDocs/Objects/Bitmap.guide/BMP_Width"}

@EndNode
---------------------------------------------------------------------------
@NODE "GS_Lock()" "Action: Lock(Screen)"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Lock()
Synopsis: void Lock(*Screen)
Object:   Screen
Short:    Locks a screen for video operations.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This action needs to be called whenever you want to use the MemPtrX fields.
Locking  a  screen is the only way to guarantee that the MemPtrX fields are
pointing to CPU drawable memory.

Attempting  to draw to an unlocked screen with the CPU can have disasterous
results, so use this function as often as necessary.

Some  systems  will  grant  locks  immediately, which is valid for most UMA
computers  and  standard  Amigas.   Other systems using graphics cards will
usually  not do this.  Your task may have to wait until enough video memory
is  ready, which may be until another task drops a screen lock or until the
user moves you to the front of the display.

@{b}@{u}NOTE@{uu}@{ub}
To keep the system stable, screen locks will nest.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Lock()" LINK "GMSDev:AutoDocs/Kernel.guide/Lock()"}
        @{"Unlock()" LINK "GMSDev:AutoDocs/Kernel.guide/Unlock()"}

@EndNode
---------------------------------------------------------------------------
@NODE "GS_Init()" "Action: Init(Screen, Container)"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Init()
Synopsis: Screen = Init(*Screen, *Container)
Short:    Initialises a Screen for use.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function will initialise a Screen, at which point you will be able to
proceed to put it on display by calling Show().

At  the  moment there are no available containers for the Screen object, so
leave this argument as NULL.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Init()" LINK "GMSDev:AutoDocs/Kernel.guide/Init()"}
        @{"Free()" LINK "GMSDev:AutoDocs/Kernel.guide/Free()"}

@EndNode
---------------------------------------------------------------------------
