@DATABASE "JoyPorts"
@AUTHOR   "Paul Manias"
@NODE     "Main" "JoyData Object Documenation"

@{b}@{u}OBJECT DOCUMENTATION@{uu}@{ub}
Name:      @{"JOYDATA" LINK "Description"}
Date:      October 1998
Author:    Paul Manias
Copyright: DreamWorld Productions, 1996-1998.  All rights reserved.

@{b}@{u}CHANGES OCTOBER 1998@{uu}@{ub}
Edited: JoyData->Port

@EndNode
---------------------------------------------------------------------------
@NODE "Description" "Object: JoyData"

@{b}@{u}OBJECT@{uu}@{ub}
Name:    JoyData
Version: 2
ID:      ID_JOYDATA
Module:  JoyPorts
Include: @{"input/joyports.h" LINK "GMSDev:Includes/input/joyports.h/Main"}
Type:    Simple

@{b}@{u}DESCRIPTION@{uu}@{ub}
The JoyData object provides a simple interface that allows you to read data
from  any available joyport.  The object supports both digital and analogue
inputs  from devices such as joysticks, mouse, joypads etc, and returns the
data in a convenient X/Y coordinate format.

Returned values are spread across a default range of -100 to +100 in either
direction,  but  you  can define you own range using X/Y Limit fields.  You
can  also  specify  "time-out"  values, which is useful when you want input
older than X amount of micro-seconds to be cleared.

Whenever you want to read a joyport, just use the Query() action.

@{b}@{u}ACTIONS@{uu}@{ub}
The JoyData object supports the following actions:

     @{"Activate()" LINK "GMSDev:AutoDocs/Kernel.guide/Activate()"} - Same as Query().
     @{"Free()" LINK "GMSDev:AutoDocs/Kernel.guide/Free()"}     - Free a JoyData object.
     @{"Get()" LINK "GMSDev:AutoDocs/Kernel.guide/Get()"}      - Get a new JoyData object.
     @{"Init()" LINK "GMSDev:AutoDocs/Kernel.guide/Init()"}     - Initialises the object.
   * @{"Query()" LINK "JoyData_Query()"}    - Reads the joyport.

@{b}@{u}STRUCTURE@{uu}@{ub}
The JoyData object consists of the following public fields:

     @{"Buttons" LINK "JOY_Buttons"}       - Contains button status flags.
     @{"ButtonTimeOut" LINK "JOY_ButtonTimeOut"} - Micro-seconds before buttons time-out.
     @{"MoveTimeOut" LINK "JOY_MoveTimeOut"}   - Micro-seconds before movements time-out.
     @{"NXLimit" LINK "JOY_NXLimit"}       - Negative X limit.
     @{"NYLimit" LINK "JOY_NXLimit"}       - Negative Y limit.
     @{"Port" LINK "JOY_Port"}          - Port number, 1/2/3/4.
     @{"PXLimit" LINK "JOY_NXLimit"}       - Positive X limit.
     @{"PYLimit" LINK "JOY_NXLimit"}       - Positive Y limit.
     @{"XChange" LINK "JOY_Change"}       - Change in the X coordinate.
     @{"YChange" LINK "JOY_Change"}       - Change in the Y coordinate.
     @{"ZChange" LINK "JOY_Change"}       - Change in the Z coordinate.

@EndNode
---------------------------------------------------------------------------
@NODE "JOY_Buttons" "Object: JoyData"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Buttons
Type:        LONG
Inheritance: Driven to 0 on initialisation.
On Change:   Dynamic.
Status:      Read/Write

@{b}@{u}DESCRIPTION@{uu}@{ub}
The  Buttons  field  contains  the  current  status of any buttons that are
currently  being held down on the given device.  Currently available button
flags are:

  JD_FIRE1   /* Standard Fire Button (1) - LMB */
  JD_FIRE2   /* Standard Fire Button (2) - RMB */
  JD_FIRE3   /* Standard Fire Button (3) - MMB */
  JD_FIRE4   /* "Start"    */
  JD_FIRE5   /* "Select"   */
  JD_FIRE6   /* Rewind  L1 */
  JD_FIRE7   /* Forward R1 */
  JD_FIRE8   /* Rewind  L2 */
  JD_FIRE9   /* Forward R2 */
  JD_LMB     /* = JD_FIRE1 */
  JD_RMB     /* = JD_FIRE2 */
  JD_MMB     /* = JD_FIRE2 */

Writing to this field has no effect on the JoyData object.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"ButtonTimeOut" LINK "JOY_ButtonTimeOut"}

@EndNode
---------------------------------------------------------------------------
@NODE "JOY_ButtonTimeOut" "Object: JoyData"

@{b}@{u}FIELD@{uu}@{ub}
Name:      ButtonTimeOut
Type:      WORD
Default:   200 (2 Seconds)
On Change: Dynamic
Status:    Read/Write

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  specifies  the amount of micro-seconds before any given button
press  times-out.  As an example, say the user presses the LMB and you read
the  joyport  within  0.4  seconds, when the time-out is for 2 seconds.  In
this  case  the  LMB  will be set and you will be able to detect the press.
However if you were to read the joyport after 2.5 seconds, the button would
have timed out and you would not detect the button press.

If   your  program  does  some  intense  calculations  (like  real-time  3D
rendering)  then  you will probably want to set this field to a value of at
least 400 micro-seconds.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"MoveTimeOut" LINK "JOY_MoveTimeOut"}

@EndNode
---------------------------------------------------------------------------
@NODE "JOY_Change" "Object: JoyData"

@{b}@{u}FIELDS@{uu}@{ub}
Names:       XChange, YChange, ZChange
Type:        WORD
Inheritance: Driven to 0 on initialisation.
On Change:   Dynamic.
Status:      Read/Write

@{b}@{u}DESCRIPTION@{uu}@{ub}
These  fields contain the changes in direction since the last time you took
a  reading  from  the  given  joyport.  If you do not take any readings for
longer than the time specified in JoyData->MoveTimeOut, then the timer will
be reset and you will actually get a return of NULL in all these fields.

One  of the important notes here is the way data is returned.  If a digital
device  such  as a joystick is plugged in, you will usually get values like
-1,  0, and +1 in these fields.  Analogue devices such as the mouse, return
values  over  a  range  usually  between  -10 and +10.  However:  In future
GMSPrefs  will  allow  the  user to set acceleration and speed settings for
digital  devices,  allowing  them to "emulate" analogue movements.  This is
worth keeping in mind for the future of your program.  If you want to limit
movements  so  that  they  are  always digital, set the Limit fields, (e.g.
JoyData->NYLimit) to values of 1 and -1.

@EndNode
---------------------------------------------------------------------------
@NODE "JOY_MoveTimeOut" "Object: JoyData"

@{b}@{u}FIELD@{uu}@{ub}
Name:      MoveTimeOut
Type:      WORD
Default:   200 (2 Seconds)
On Change: Dynamic
Status:    Read/Write

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field specifies the amount of micro-seconds before any given movement
times-out.   By  movement, this specifically means the XChange, YChange and
ZChange   fields.    For  an  example  of  what  time-out  means,  see  the
ButtonTimeOut field.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"ButtonTimeOut" LINK "JOY_ButtonTimeOut"}

@EndNode
---------------------------------------------------------------------------
@NODE "JOY_NXLimit" "Object: JoyData"

@{b}@{u}FIELD@{uu}@{ub}
Names:     NXLimit, NYLimit, PXLimit, PYLimit
Type:      WORD
Defaults:  100 and -100
On Change: Dynamic
Status:    Read/Write

@{b}@{u}DESCRIPTION@{uu}@{ub}
The  Limit  fields  specify  the  range over which a joyport can move.  The
field names have been abbreviated, here is their full meaning:

  NXLimit - Negative X Limit (user moves left)
  PXLimit - Positive X Limit (user moves right)
  NYLimit - Negative Y Limit (user moves up)
  PYLimit - Positive Y Limit (user moves down)

Note that the negative fields can only contain negative values, the postive
fields can only contain positive values.

@{b}@{u}Example@{uu}@{ub}
If  you  were to set each of these fields to 10 and -10 respectively, every
time  you  read the joyport you would be returned values within this range.
To illustrate, if the user was to move the mouse 15 coordinates right, that
movement would be automatically restricted to 10 coordinates right.

@EndNode
---------------------------------------------------------------------------
@NODE "JOY_Port" "Object: JoyData"

@{b}@{u}FIELD@{uu}@{ub}
Name:      Port
Type:      WORD
Default:   User setting.
On Change: Cannot change after initialisaton.
Status:    Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This field specifies the port that you will read from.  Generally this will
only  be set to 1 (the mouse port) or 2 (the 1st player joystick).  Setting
it  to  3 or 4 will activate the preferred user setting, which could be the
keyboard or extra joysticks plugged into the parallel port.

Special  settings  are  provided  for  port abstraction:  JPORT_DIGITAL for
joystick  style devices and JPORT_ANALOGUE for mouse style devices.  If you
use  these  settings,  they  MUST be set before initialisation because they
will be updated to the correct port number during Init().

Where  possible,  we  recommend  that you do not set this field (accept the
user default) or use the abstract settings if necessary.

@{b}@{u}NOTE@{uu}@{ub}
This  field is not dynamic!  If you attempt to change the port number after
Init(), you will not get the results that you want.

@EndNode
--------------------------------------------------------------------------
@NODE "JoyData_Query()" "JoyData: Query()"

@{b}@{u}ACTION@{uu}@{ub}
Name:   Query(*JoyData)
Object: JoyData
Short:  Reads the current status of a joyport.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Reads the joyport and returns its status, regardless of what playing device
is  plugged  in.   This  action  updates  the XChange, YChange, ZChange and
Buttons fields.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Query()" LINK "GMSDev:AutoDocs/Kernel.guide/Query()"}

@EndNode
--------------------------------------------------------------------------
