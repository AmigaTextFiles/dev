@DATABASE "File"
@AUTHOR   "Paul Manias"
@NODE     "Main" "Object: File"

@{b}@{u}OBJECT DOCUMENTATION@{uu}@{ub}
Name:      @{"FILE" LINK "Description"}
Version:   1.1
Date:      June 1998
Author:    Paul Manias
Copyright: DreamWorld Productions, 1996-1998.  All rights reserved.

@{b}@{u}CHANGES VERSION 1.1@{uu}@{ub}
Added:  Support for Rename()

Edited: File->Source

@{b}@{u}CHANGES VERSION 1.0@{uu}@{ub}
This document was completely revised.

@{b}@{u}CHANGES VERSION 0.9B@{uu}@{ub}
Added:  Query() to action support list.
        File->Permissions

Edited: File->Comment
        File->Date

@EndNode
---------------------------------------------------------------------------
@NODE "Description" "Object: File"

@{b}@{u}OBJECT@{uu}@{ub}
Name:    File
Version: 1
ID       ID_FILE
Module:  @{"Files" LINK "GMSDev:AutoDocs/Files.guide/Functions"}
Include: @{"files/files.h" LINK "GMSDev:Includes/files/files.h/Main"}
Type:    Complex

@{b}@{u}DESCRIPTION@{uu}@{ub}
The  File  object  is used for basic file management purposes.  Unlike file
handles  in  AmigaDOS, this object allows you to find out many details on a
file with almost no effort.

Files  support  auto-unpacking  and  finding  capabilities.  Since all File
objects  are  tracked,  there  is  no  chance of the system allowing you to
forget the closing of a File.  Files are also integrated with the Directory
object, so managing large amounts of files can easily be achieved.

Reading  and  writing to files is fully object-orientated, which allows new
file sources to become available in future.  At the moment you can also use
memory  blocks  as  file  space,  which  has  some  useful  applications by
providing a fast method of data storage.

@{b}@{u}File Initialisation@{uu}@{ub}
When  you  Init()ialise a File object, all this does is prepare the File so
that  you  can  find  out certain information such as the date-stamp, size,
comment  and  so on.  If you want to read/write to the object you will need
to call OpenFile().  In order to make things easier, if you specify FL_READ
and/or  FL_WRITE,  Init()  will  automatically  call  OpenFile()  for  you.
Otherwise  you  can  call  OpenFile() at a later time (or not at all if you
don't want to do any I/O).

@{b}@{u}ACTIONS@{ub}@{uu}
The File object supports the following actions:

     @{"Detach()" LINK "GMSDev:AutoDocs/Kernel.guide/Detach()"} - Detach a File chain from a Directory.
     @{"Free()" LINK "GMSDev:AutoDocs/Kernel.guide/Free()"}   - Free the File object.
     @{"Get()" LINK "GMSDev:AutoDocs/Kernel.guide/Get()"}    - Get a File structure.
   * @{"Init()" LINK "FILE_Init()"}   - Initialise a File.
     @{"Read()" LINK "GMSDev:AutoDocs/Kernel.guide/Read()"}   - Read data from an opened File.
     @{"Rename()" LINK "GMSDev:AutoDocs/Kernel.guide/Rename()"} - Rename a File.
     @{"Seek()" LINK "GMSDev:AutoDocs/Kernel.guide/Seek()"}   - Seek to a byte position in a File.
     @{"Unhook()" LINK "GMSDev:AutoDocs/Kernel.guide/Unhook()"} - Pull a single File out from a chain.
     @{"Write()" LINK "GMSDev:AutoDocs/Kernel.guide/Write()"}  - Write data to an opened File.

@{b}@{u}FUNCTIONS@{ub}@{uu}
Some functions relating to the File object are:

     @{"GetFComment()" LINK "GMSDev:AutoDocs/Files.guide/GetFComment()"}     - Get the comment from a File.
     @{"GetFDate()" LINK "GMSDev:AutoDocs/Files.guide/GetFDate()"}        - Get a File's date stamp.
     @{"GetFPermissions()" LINK "GMSDev:AutoDocs/Files.guide/GetFPermissions()"} - Get the user permissions on a File.
     @{"GetFSize()" LINK "GMSDev:AutoDocs/Files.guide/GetFSize()"}        - Determine the size of a File.
     @{"OpenFile()" LINK "GMSDev:AutoDocs/Files.guide/OpenFile()"}        - Prepare a File for reading and writing.
     @{"SetFComment()" LINK "GMSDev:AutoDocs/Files.guide/SetFComment()"}     - Write a comment to a File.
     @{"SetFDate()" LINK "GMSDev:AutoDocs/Files.guide/SetFDate()"}        - Set a File's date stamp.

@{b}@{u}STRUCTURE@{uu}@{ub}
The File structure consists of the following public fields:

     @{"BytePos" LINK "FILE_BytePos"} - Current position in file.
     @{"Flags" LINK "FILE_Flags"}   - File flags and options.
     @{"Next" LINK "FILE_Next"}    - Next File in the chain (directories).
     @{"Prev" LINK "FILE_Prev"}    - Previous File in the chain (directories).
     @{"Source" LINK "FILE_Source"}  - Pointer to source of the file.

@EndNode
---------------------------------------------------------------------------
@NODE "FILE_BytePos" "Object:  File"

@{b}@{u}FIELD@{uu}@{ub}
Name:      BytePos
Type:      LONG
To Change: Use Seek() to alter the byte position.
Status:    Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field tells you the current byte position in the opened file.  If you
want to change the position, use the Seek() action.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Seek()" LINK "GMSDev:AutoDocs/Kernel.guide/Seek()"}

@EndNode
---------------------------------------------------------------------------
@NODE "FILE_Flags" "Object: File"

@{b}@{u}FIELD@{uu}@{ub}
Name:      Flags
Type:      LONG
On Change: Cannot change dynamically.
Status:    Read/Init.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  specifies  the commands to use when initialising and opening a
file.   After  opening  your  file  you  may  only  refer to this field for
historical purposes.

Here  are the flags that you can specify (NB: These flags can also be used
in the OpenFile() function).

  @{u}FL_READ@{uu}
  Set this flag if you want to read data from the file.

  @{u}FL_WRITE@{uu}
  Prepares  the file for writing data, starting at byte position 0.  If you
  want  to  start  writing  from  the  end of a File, call Seek(File, NULL,
  POS_END) after your file has been opened successfully.

  @{u}FL_NEWFILE@{uu}
  Set  this  flag if you are creating a new file.  Note that if a file with
  the  same  name already exists, the old file (with all its data), will be
  destroyed.   If  you  try  to create a new file on a file that is already
  open by some other task, the initalisation will fail.

  When  you create a new file, it will be given default user permissions of
  FPF_READ, FPF_WRITE and FPF_DELETE.

  @{u}FL_EXCLUSIVE@{uu}
  Setting  this  will open the file for exclusive access - no other process
  will  be  able  to open the file while you are using it.  If this flag is
  not  set,  then the file will be available for shared access.  Attempting
  to  exclusively  lock a file that is already open by another process will
  result in failure.

  @{u}FL_FIND@{uu}
  This  flag allows the opening process to use some intelligence and try to
  find  the  file  if  it is not immediately located at the given FileName.
  The process involves a simple but powerful tree search.

  @{u}Example@{uu}
  You try to load a file at "Game:Data/PIC.Crocodile".  However the "Game:"
  assignment  does  not  exist.   You  are  being  run  from  the directory
  "HD1:Game/Data/"   which  is  a  directory  above  the  required  logical
  assignment.   OpenFile()  will  find  the  file  by  using  the following
  procedure:

  Open - Game:Data/PIC.Crocodile  (FAIL)
         Data/PIC.Crocodile       (FAIL - HD1:Game/Data/Data/PIC.Crocodile)
         PIC.Crocodile            (SUCCESS - HD1:Game/Data/PIC.Crocodile)

  @{u}Note@{uu}
  The  file  finding  feature is limited to localised searching, no attempt
  will  be  made to do a tree search of all directories in an assignment (a
  lengthy process).

  @{u}FL_NOUNPACK/FL_NOPACK@{uu}
  If  you  specifically  do  not  want packing/unpacking modes used on your
  file,  specify  either  one of these flags.  Under most circumstances you
  should  never  set  these flags, because if the user does not want to use
  compression he/she can say so in the system preferences.

  @{u}FL_NOBUFFER@{uu}
  Setting  this  flag  prevents  the  file  data from being put in the file
  cache.   You  may  want  to  do  this  if  it is imperative that the file
  physically reflects its data at all points in time.

  @{u}FL_AUTOCREATE@{uu}
  If  you  try  to  initialise/open a file that does not exist, the call to
  Init()  will  fail.   If  you  set  this flag however, a new file will be
  created if it does not already exist on disk.

@EndNode
---------------------------------------------------------------------------
@NODE "FILE_Next" "Object: File"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Next
Type:        struct File *
Inheritance: Links are automatically formed when listing directories.
Status:      Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
The  Next  field  is  usually  involved  with  the  building  of  Directory
structures.   For  example,  if  you  Activate() a Directory object it will
build a list of all Files in that directory, and point to the first File in
the list.  All further Files will then be joined via the File->Next field.

You can remove a single File from the chain by using the @{"Unhook()" LINK "GMSDev:AutoDocs/Kernel.guide/Unhook()"} action.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field:  @{"Prev" LINK "FILE_Prev"}
Kernel: @{"Unhook()" LINK "GMSDev:AutoDocs/Kernel.guide/Unhook()"}
Object: @{"Directory" LINK "GMSDev:AutoDocs/Objects/Directory.guide/Description"}

@EndNode
---------------------------------------------------------------------------
@NODE "FILE_Prev" "Object: File"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Prev
Type:        struct File *
Inheritance: Links are automatically formed when listing directories.
Status:      Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
The  Prev  field  is  usually  involved  with  the  building  of  Directory
structures.   For  example,  if  you  Activate() a Directory object it will
build a list of all Files in that Directory, and point to the first File in
the  list.   The  Prev  field  will  assist in moving backwards through the
chain.

You can remove a single File from the chain by using the @{"Unhook()" LINK "GMSDev:AutoDocs/Kernel.guide/Unhook()"} action.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field:  @{"Next" LINK "FILE_Next"}
Kernel: @{"Detach()" LINK "GMSDev:AutoDocs/Kernel.guide/Detach()"}
Object: @{"Directory" LINK "GMSDev:AutoDocs/Objects/Directory.guide/Description"}

@EndNode
---------------------------------------------------------------------------
@NODE "FILE_Source" "Object: File"

@{b}@{u}FIELD@{uu}@{ub}
Name:   Source
Type:   APTR
Status: Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
Points  to  a  source  object,  which may currently be either a FileName or
MemPtr structure.  This field is compulsory for initialisation.

The structure format for the FileName looks like this:

  struct FileName {
    WORD ID;           /* ID_FILENAME */
    BYTE *Name;        /* Pointer to file-name, e.g. "GMS:Readme.txt" */
  };

The structure format for the MemPtr looks like this:

  struct MemPtr {      /* Memory location structure */
    WORD ID;           /* ID_MEMPTR */
    APTR Address;      /* Pointer to memory area */
    LONG Size;         /* Must supply a size unless you are a MemBlock */
  };

If MemPtr->Address points to the beginning of a memory block allocated from
AllocMemBlock(),  you  may  leave  the  Size  as  NULL.  Otherwise you MUST
specify the Size of your memory block.  Make sure it's correct!

@{b}@{u}NOTE@{uu}@{ub}
When initialising a File with a FileName source, Init() will make a copy of
the  FileName  structure  and  replace File->Source with the new structure.
This  is done in order to cope with the moving or renaming of files, as the
Name may need to be reallocated and/or extended.

@EndNode
---------------------------------------------------------------------------
@NODE "FILE_Init()" "Action: Init(File, Container)"

@{b}@{u}ACTION@{uu}@{ub}
Name:     @{"Init()" LINK "GMSDev:AutoDocs/Kernel.guide/Init()"}
Synopsis: File = Init(File, Container)
Short:    Partially initialise a File object.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This action will 'partially' initialise a file from the given File->Source.
After  calling  Init()  you  will be allowed to get information such as the
file's Size, Comment, Permissions and so on.

If  you want to read and write data with the File immediately, then specify
the   FL_READ   and/or   FL_WRITE   modes  in  File->Flags  to  do  a  full
initialisation.   This  will  actually prompt Init() to call OpenFile() for
you, which is responsible for read/write handling.

The  read/write  modes  can  be  set at any time with a call to OpenFile().
Note  that  this is the only way that you can gain access to the Read() and
Write() actions.

@EndNode
---------------------------------------------------------------------------
