@DATABASE "SysObject"
@AUTHOR   "Paul Manias"
@NODE     "Main" "Object: SysObject"

@{b}@{u}OBJECT DOCUMENTATION@{uu}@{ub}
Name:      @{"SYSOBJECT" LINK "Description"} AUTODOC
Date:      October 1998
Author:    Paul Manias
Copyright: DreamWorld Productions, 1996-1998.  All rights reserved.

@{b}@{u}CHANGES VERSION 2@{uu}@{ub}
Edited: SysObject->FieldArray
        SysObject->Free [Function Example]

Added:  SysObject->ClassVersion
        SysObject->FieldSize
        SysObject->ObjectSize

@{b}@{u}CHANGES VERSION 1@{uu}@{ub}
Added:  SysObject->FieldArray
        SysObject->Fieldtotal

@EndNode
---------------------------------------------------------------------------
@NODE "Description" "Object: SysObject"

@{b}@{u}OBJECT@{uu}@{ub}
Name:    SysObject
Module:  @{"Kernel" LINK "GMSDev:AutoDocs/Kernel.guide/Functions"}
Version: 2
Type:    Complex
Notes:   This structure concerns module programmers only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
The  SysObject forms the core of all object orientation in the DPKernel.  A
SysObject  contains all of the details for a particular type of class.  The
system  maintains  a  list of all current SysObjects, which you can find by
calling FindSysObject().  You can add a new SysObject to the system through
AddSysObject(), and you can remove them using Free() or RemSysObject().

Through the use of SysObject's, you can create a standard object class that
supports  actions like Init(), Detach(), Show() and others mentioned in the
kernel  document.   Further down this page you will find a list of function
references.   To  support  a particular action for your object, you need to
write the code for one or more of these functions and initialise it to your
object.

The  best  way  to  understand  all  this  is to view the source code to an
existing  module.   There  is  also  a  section  on  object creation in the
GMS.guide  document.  Keep in mind that to create a new object, you need to
go  through  various procedures with DreamWorld Productions in order to get
it registered.

@{b}@{u}ACTIONS@{uu}@{ub}
The SysObject supports the following actions:

     @{"Free()" LINK "GMSDEV:AutoDocs/Kernel.guide/Free()"} Free a SysObject.

@{b}@{u}FUNCTIONS@{uu}@{ub}
Here are some functions supporting the SysObject:

     @{"AddSysObject()" LINK "GMSDEV:AutoDocs/Kernel.guide/AddSysObject()" }  - Add a new SysObject to the system.
     @{"FindSysObject()" LINK "GMSDEV:AutoDocs/Kernel.guide/FindSysObject()"} - Search for a SysObject.
     @{"RemSysObject()" LINK "GMSDEV:AutoDocs/Kernel.guide/RemSysObject()" }  - Remove a SysObject from the system.

@{b}@{u}STRUCTURE@{uu}@{ub}
The SysObject structure consists of the following public fields:

     @{"ClassID" LINK "SYS_ClassID"}       - Class ID that the object belongs to.
     @{"ClassVersion" LINK "SYS_ClassVersion"}  - The version number of the class.
     @{"FieldArray" LINK "SYS_FieldArray"}    - Points to a descriptive field array.
     @{"FieldSize" LINK "SYS_FieldSize"}     - The size of each field entry.
     @{"FieldTotal" LINK "SYS_FieldTotal"}    - Amount of descripted fields in the object.
     @{"FileDesc" LINK "SYS_FileDesc"}      - A string that describes the file type.
     @{"FileExtension" LINK "SYS_FileExtension"} - A string that specifies the file extension.
     @{"Master" LINK "SYS_Master"}        - Reference to the master object for child classes.
     @{"Name" LINK "SYS_Name"}          - The name of your object.
     @{"ObjectID" LINK "SYS_ObjectID"}      - ID for the object (eg ID_PICTURE, ID_HIDDEN).
     @{"ObjectSize" LINK "SYS_ObjectSize"}    - Specify the size of your object here.
     @{"TagTrigger" LINK "SYS_TagTrigger"}    - An active function for trigger based tags.

The  following  function references, which are located inside the SysObject
structure,  are  only  available to system module developers.  You may only
set  these  fields during the initialisation process.  If you read or write
to  these  fields,  or  attempt  to  make  direct function calls with these
addresses, your program/module will simply fail in future releases.

     @{"Activate" LINK "SYS_Activate"}         - Perform the native action for this object.
     @{"AttemptExclusive" LINK "SYS_AttemptExclusive} - Useful for detecting exclusive locks.
     @{"CheckFile" LINK "SYS_CheckFile"}        - Check for file recognition.
     @{"Clear" LINK "SYS_Clear"}            - Clear an object from its container.
     @{"Copy" LINK "SYS_Copy"}             - Copy one object's data to another.
     @{"CopyFromUnv" LINK "SYS_CopyUnv"}      - Copy from universe to object.
     @{"CopyToUnv" LINK "SYS_CopyUnv"}        - Copy from object to universe.
     @{"Deactivate" LINK "SYS_Deactivate"}       - End the native action for this object.
     @{"DetachChild" LINK "SYS_Detach"}      - Detaches a child from a parent.
     @{"DetachParent" LINK "SYS_Detach"}     - Detach a parent from a child.
     @{"Draw" LINK "SYS_Draw"}             - Draw an object inside its container.
     @{"Flush" LINK "SYS_Flush"}            - Flush buffered data from an object.
     @{"Free" LINK "SYS_Free"}             - Free object.
     @{"FreeExclusive" LINK "Sys_FreeExclusive"}    - Allows you to detect freed locks.
     @{"Get" LINK "SYS_Get"}              - Get a new object structure (master only).
     @{"Hide" LINK "SYS_Hide"}             - Hide/Remove the object from the display.
     @{"Init" LINK "SYS_Init"}             - Initialise object.
     @{"Load" LINK "SYS_Load"}             - Load a file that belongs to this object.
     @{"Lock" LINK "SYS_Lock"}             - Put a lock on an object.
     @{"MoveToBack" LINK "SYS_MoveTo"}       - Move an object to the back of its environment.
     @{"MoveToFront" LINK "SYS_MoveTo"}      - Move an object to the front of its environment.
     @{"Query" LINK "SYS_Query"}            - Query the information held on this object.
     @{"Read" LINK "SYS_Read"}             - Read some data from the object.
     @{"Reset" LINK "SYS_Reset"}            - Reset an object to a ready state.
     @{"SaveToFile" LINK "SYS_SaveToFile"}       - Save this entire object as a file.
     @{"Seek" LINK "SYS_Seek"}             - Seek to the byte position of an object.
     @{"Show" LINK "SYS_Show"}             - Make an object visible to the user.
     @{"Unhook" LINK "SYS_Unhook"}           - Unhook an object from a chain.
     @{"Unlock" LINK "SYS_Unlock"}           - Unlock an object.
     @{"Write" LINK "SYS_Write"}            - Write some data to the object.

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_ClassID" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        ClassID
Type:        WORD
Inheritance: AddSysObject()
Status:      Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  specifies  the Class or "group" that the SysObject belongs to.
This  setting  is  especially  important  for  child  classes, as they will
inherit  function  and  data  support  from  the  parent  class  when first
initialised.

This  field  is  set when you call AddSysObject(), so never set the ClassID
directly.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field:    @{"ObjectID"          LINK "SYS_ObjectID"}
Includes: @{"system/register.h" LINK "GMSDev:Includes/system/register.h/Main"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_ClassVersion" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:   ClassVersion
Type:   WORD
Status: Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This field specifies the version of the class that you are supporting.  The
value  present  here  will be used by the Get() function whenever a program
obtains one of your objects.

If  you  are writing a child class then you can leave this value at NULL if
you  can  get  away  with it, but master classes certainly must set a value
here.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field:    @{"ObjectID" LINK "SYS_ObjectID"}
Includes: @{"system/register.h" LINK "GMSDev:Includes/system/register.h/Main"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_FieldArray" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:   FieldArray
Type:   struct Field *
Status: Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field points to a special array that describes each one of the public
fields in an object.  If you are creating a master class then you will need
to  create  this  array  yourself,  whereas child classes will inherit this
array from their master.

The  Field Array is required if an object is to support "field orientation"
(a  deeper  form  of  object  orientation).   Field  orientation  allows  a
developer  to  inspect or use parts of your object even when that object is
not understood.  It is also extremely useful for debugging purposes.

The Field structure is arranged as follows:

  struct Field {
    BYTE *Name;     /* The english name for the field, e.g. "Width" */
    WORD Offset;    /* The field's position in the object structure */
    WORD FieldID;   /* Provides a fast way of finding fields, eg FID_WIDTH */
    LONG Flags;     /* Special flags that describe the field */
    LONG Data1;     /* Value is dependent on Flags */
    LONG Data2;     /* Value is dependent on Flags */
    LONG GetField(*Object [a0]);
    LONG SetField(*Object [a0], Value [d0]);
  };

The  use  of  the  Field Array is best illustrated by this example from the
Pictures class:

  struct FieldDef OptionFlags[] = {
    { "RESIZEX", 0x00000001 },
    { "REMAP",   0x00000004 },
    { "RESIZEY", 0x00000008 },
    { NULL, NULL }
  };

  struct FieldDef ScrFlags[] = {
    { "HIRES",  0x00000001 },
    { "SHIRES", 0x00000002 },
    { "LACED",  0x00000004 },
    { "LORES",  0x00000008 },
    { "SLACED", 0x00000010 },
    { NULL, NULL }
  };

  struct Field PictureFields[6] = {
    { "Bitmap",    12, FID_Bitmap,    FDF_CHILD,          ID_BITMAP, 0,          NULL, NULL },
    { "Options",   16, FID_Flags,     FDF_LONG|FDF_FLAGS, (LONG)&OptionFlags, 0, NULL, NULL },
    { "Source",    20, FID_Source,    FDF_SOURCE,         0, 0,                  NULL, NULL },
    { "ScrMode",   24, FID_ScrMode,   FDF_WORD|FDF_FLAGS, (LONG)&ScrFlags, 0,    NULL, NULL },
    { "ScrHeight", 26, FID_ScrHeight, FDF_WORD|FDF_RANGE, 0, 2560,               NULL, NULL },
    { "ScrWidth",  28, FID_ScrWidth,  FDF_WORD|FDF_RANGE, 0, 2560,               NULL, NULL },
  };

Now for some notes:

The  FDF  flags  allow  you  to describe in detail exactly what a field is.
With these flags you can say wether the field points to a string, wether or
not it is an array, if it has range limitations, if it is word, longword or
byte sized and so on.

The FID field is optional, you can only specify it if the Name of the field
is  also  listed  in  the  FieldID list in "system/sysobjects.h".  Wherever
possible, Field ID's must be used to allow quick searching of field names.

The  Data1  and  Data2  settings  are  available  for debugging, corruption
testing  and  gathering  field  information.  In the above example we see 3
different uses of these two fields.  ScrHeight is limited to the following:
"0  =<  ScrHeight  <= 2560".  This is something that a debugger can pick up
when  testing  an object.  The Bitmap field is specified as a child, so the
ID_BITMAP  presence  shows  us  what  type  of  child that is.  Finally the
FDF_FLAGS  specification  requires  that  a  pointer  to  a  string list is
specified in Data1.

The complete list of currently available FDF flags is as follows:

  FDF_BYTE      - Field is byte sized.
  FDF_WORD      - Field is word sized.
  FDF_LONG      - Field is long sized.
  FDF_QUAD      - Field is 2xlong sized.

  FDF_OBJECT    - Field refers to another object.
  FDF_CHILD     - Field refers to a child object.
  FDF_STRING    - Field points to a string.
  FDF_POINTER   - Field points to variable data.
  FDF_BYTEARRAY - Points to an array of bytes.
  FDF_WORDARRAY - Points to an array of words.
  FDF_LONGARRAY - Points to an array of longs.
  FDF_UNSIGNED  - Field is unsigned (no negatives).
  FDF_RANGE     - Enforce range limitations.
  FDF_FLAGS     - Field contains flags.
  FDF_HEX       - Field is in hexadecimal.
  FDF_SOURCE    - Pointer to a source such as ID_FILENAME or ID_MEMPTR.
  FDF_LOOKUP    - Similar to FDF_FLAGS but uses a lookup table format.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"FieldSize" LINK "SYS_FieldSize"}
       @{"FieldTotal" LINK "SYS_FieldTotal"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_FieldSize" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:   FieldSize
Type:   LONG
Status: Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
Specifies  the  size  of  each  field  entry in SysObject->FieldArray.  You
should set this field to the following:

  sizeof(struct FieldEntry)

If  you  do not give a value in this field, you may confuse the system over
which FieldEntry version you are using.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"FieldArray" LINK "SYS_FieldArray"}
       @{"FieldTotal" LINK "SYS_FieldTotal"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_FieldTotal" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:   FieldTotal
Type:   WORD
Status: Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
If  you  have  created  a  Field  Array for your object, then you must also
specify  the  total amount of listed fields here.  From the Picture example
given in the FieldArray description, the correct setting here would be "6".

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"FieldTotal" LINK "SYS_FieldTotal"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_FileExtension" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:   FileExtension
Type:   BYTE *
Status: Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This   field  describes  the  file  extension/s  that  your  SysObject  can
recognise.  Examples include:

  "raw"            [Data]
  "iff;8svx;snd"   [Sound]
  "jpg;jpeg"       [Picture]

By  using  the ; character you can specify more than one file extension for
your  object.   The  file extension that you prefer to save in should go at
the start, e.g.  in the second example any object saved will have a default
filename  of "<Name>.iff".  The following "8svx" and "snd" extensions would
be useful when recognising files to load.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"FileDesc" LINK "SYS_FileDesc"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_FileDesc" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:   FileDesc
Type:   BYTE *
Range:  Maximum of 50 characters.
Status: Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  allows  you  to  give a description of the object's file type.
This is important as it helps to distinguish your class from the others.

Look at the following table:

  File Extension | File Description
  ---------------+----------------------
       .iff      | IFF 8SVX Sound
       .iff      | IFF Picture
       .gif      | GIF Picture
       .gif      | GIF Anim
       .jpg      | JPEG High Compression

As you can see the extensions can often be the same, but the file types may
be completely different.

Always  make  sure  that  your  file type is short, descriptive and unique.
Naming  your  object's  file  type  with  a  single word like "JPEG" is not
acceptable, "JPEG Picture V1.2" would be far more appropriate.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"FileExtension" LINK "SYS_FileExtension"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Master" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:   Master
Type:   struct SysObject *
Status: Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
If  a  SysObject  has  been initialised as the child of a class, this field
will  point  to the class master.  This provides a quick way of finding the
class master, without having to refer to FindSysObject().

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Name" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:   Name
Type:   BYTE *
Status: Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  specifies  the name of your object or class.  Names are fairly
straight-forward,  eg  the  Picture object has a name of "Picture".  If you
are  writing  a child class then you need to create your own name, but keep
it simple.  For example, the JPEG child class would have a name of "Jpeg".

Bear  in mind that sometimes the Name may be used by some programs in order
to find a class or object when they do not know the ID.  Make sure that you
do not mis-spell the name.

@{b}@{u}NOTE@{uu}@{ub}
You  are  required  to set the Name from AddSysObject(), so do not write to
this field directly.

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_ObjectID" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:   ObjectID
Type:   WORD
Status: Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  will  be  the same as the ClassID if this is the master of the
class.   If the object is hidden or is a child of the class, then ID_HIDDEN
or ID_CHILD will be specified respectively.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field:    @{"ClassID" LINK "SYS_ClassID"}
Includes: @{"system/register.h" LINK "GMSDev:Includes/system/register.h/Main"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_ObjectSize" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:   ObjectSize
Type:   LONG
Status: Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
Set this field to tell the system how large your object is.  As an example,
if  you  were  responsible  for maintaining the Picture class you would set
this value to:

  sizeof(struct Picture)

By  setting the ObjectSize field you will also alter the way that the Get()
action  behaves.   When  Get()  detects  a  value  in  ObjectSize,  it will
automatically  allocate  the  object's  memory  and performs other enhanced
activity.   Otherwise  you  will  need  to  add extra support to your Get()
function.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"Get()" LINK "SYS_Get"}

@EndNode
---------------------------------------------------------------------------
---------------------------------------------------------------------------
@NODE "SYS_Activate" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Activate()
Type:        Function
Synopsis:    LONG Activate(APTR Object [a0])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Activate()  is  the  most abstract of all the available actions, so you can
pretty much do whatever you want in your support for this action.  Read the
Activate() documentation in the kernel documentation for some examples.

If  your  object performs an action which continues in the background after
returning  to  the  program,  you  may also want to support Deactivate() to
cancel an action.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to an initialised object that needs to be activated.

@{b}@{u}RETURN@{uu}@{ub}
If  your activation is successful, return ERR_OK.  Otherwise any one of the
other error codes can be used to inidicate failure.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Activate()" LINK "GMSDev:AutoDocs/Kernel.guide/Activate()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_AttemptExclusive" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        AttemptExclusive()
Type:        Function
Synopsis:    LONG AttemptExclusive(APTR Object [a0])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Although  the  AttemptExclusive()  and  Exclusive()  actions  work  for any
object, you may want to be informed when an exclusive lock is taking place.
By  supporting  this  function,  you  can  take  a more active role in your
object's exclusiveness.

@{b}@{u}Procedure@{uu}@{ub}
When  a  program  calls  AttemptExclusive(), a check will be made to see if
your  class  supports  the AttemptExclusive() function.  If you do, it will
make a call to your support routine.  If you do not have a support routine,
AttemptExclusive()  will  assume  that  you do not wish to be informed, and
will proceed to grant the lock if one is available.

If you return an error code other than ERR_OK, AttemptExclusive() will keep
on  calling  you  until its timer runs out.  If when the timer runs out you
are  still returning an error code, AttemptExclusive() will inform the user
of  failure.   Of  course  if  Exclusive()  is  calling  you,  it will fail
immediately if you return an error code.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to an object that requires an exclusive lock.  The object may or
  may not be initialised.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"AttemptExclusive()" LINK "GMSDev:AutoDocs/Kernel.guide/AttemptExclusive()"}
        @{"Exclusive()" LINK "GMSDev:AutoDocs/Kernel.guide/Exclusive()"}
        @{"FreeExclusive()" LINK "GMSDev:AutoDocs/Kernel.guide/FreeExclusive()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_CheckFile" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        CheckFile()
Type:        Function
Synopsis:    LONG CheckFile(struct File * [a0], APTR Buffer [a1])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  was  created  to provide an abstraction for the reading and
writing of files.  It is currently used in the Load() action so that it can
find  out  who  best understands a given file type.  It is also used by the
File  object  to  check  for compressed data (see the File documentation on
this) but the principle is the same.

When  the Load() action is presented with an unknown file type, it will ask
every  object in the system that supports CheckFile() to return a rating of
its understanding of the file.  This rating goes from 0 - 100.  A rating of
zero  indicates  the  object  has no understanding, while 100 indicates the
object has a perfect understanding of the file.

The  following  example  is  taken  from  the Picture class.  It checks the
buffer  for  the  "ILBM"  and  "FORM"  headers that identify an IFF Picture
object.   If  successful  this  indicates  a  high  probability that we can
understand it, so a value of 99 is returned.

LIBFUNC LONG PIC_CheckFile(mreg(__a0) struct File *File,
                           mreg(__a1) LONG *Buffer)
{
  if (Buffer) {
     if (Buffer[0] IS CODE_FORM AND Buffer[2] IS CODE_ILBM) {
        DPrintF("Pictures:","File identified as Picture");
        return(99);
     }
  }

  return(NULL);
}

@{b}@{u}NOTE@{uu}@{ub}
Sometimes  the  Buffer will point to an area containing nothing but 0's, or
you  might  get  a Buffer argument of NULL.  This can occur when a new file
has  been opened in WRITE mode.  In this case, you will have to assess from
the  Source  details  wether  you  want  to  support  the File object.  For
example,  the user might tell the XPK compression support that DF0:  should
be  packed.  In this case, XPK would check for a FileName source that had a
string containing "DF0:".

@{b}@{u}INPUT@{uu}@{ub}
File
  This points to a standard File object that has been fully initialised.
  You may look at it to gain information, but DO NOT mess with it!

Buffer
  This is a cache of the first 256 bytes of the file.  If the file is not
  at least 256 bytes in length, then the buffer will only be partially
  filled, and the rest of the buffer will be filled with NULL.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Load()" LINK "GMSDev:AutoDocs/Kernel.guide/Load()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Clear" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Clear()
Type:        Function
Synopsis:    LONG Clear(APTR Object [a0])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Clearing  is  an interesting action as it can have a very different meaning
for each object.  Clearing a Bob for example will leave a black area on the
screen, while clearing a File might delete it from the file system.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Pointer to an object that needs to be cleared.

@{b}@{u}RETURN@{uu}@{ub}
If  your  clear is successful then return ERR_OK, otherwise return an error
code such as ERR_FAILED.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Clear()" LINK "GMSDev:AutoDocs/Kernel.guide/Clear()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Copy" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Copy()
Type:        Function
Synopsis:    LONG Copy(APTR Source [a0], APTR Destination [a1])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
The  Copy()  action was provided so that data in one object could be copied
across  to  another.   This  may or may not involve data conversion issues.
For example, copying data between files is a very straight forward process.
However,  copying  data  between  two  Bitmap's  would be more complicated,
because  we  need to consider clipping and type conversion issues.  Copying
between  different  types  of  objects  is  also permitted, e.g.  copying a
Picture to a File could output the image as raw data.

The  important  question  to  consider  is "Which object is responsible for
handling the copy - the Source or the Destination?".

Answer:   The  Copy  action  will  -always-  ask  the Source to copy to the
Destination.   If the Source fails to do the copy or if it does not support
the copy action, the Destination will be asked to do the copy instead.

This means that your copy routine must be written to detect wether:

    A) You are copying data from the Source to the Destination.
    B) You are copying data from the Destination to the Source.

How do you check?  Well if you were writing the copy support for the Bitmap
object,  you would simply compare the Source->Head.ID for ID_BITMAP.  If it
is  a  match  then  your  object is the Souce, otherwise your object is the
Destination.

Once  you  have  established  what one you are, you need to check the other
object  to  see  wether  you  support it or not.  If you do not support the
object,  return  ERR_NOSUPPORT.  If you do support it, then you can proceed
with  the  copy.   If  your  copy  fails,  simply  return  ERR_FAILED.   If
successful, return ERR_OK.

@{b}@{u}INPUT@{uu}@{ub}
Source
  The object that contains the data that is to be copied.

Destination
  The object that is receiving the data.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Copy()" LINK "GMSDev:AutoDocs/Kernel.guide/Copy()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_CopyUnv" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        CopyToUnv(), CopyFromUnv()
Type:        Function
Synopsis:    LONG CopyToUnv(*Universe [a0], *Object [a1])
             LONG CopyFromUnv(*Universe [a0], *Object [a1])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
CopyFromUnv()  and  CopyToUnv()  work  together to form the CopyStructure()
action.  In case you didn't know, Unv is short for Universe.

Universe  is  a big object that supports many common field types.  Examples
are  Width,  Height,  Frequency,  Length and Size.  Through the use of this
object,  CopyStructure()  can  provide  a single point of location for data
storage.

What does this allow?  Well so long as your object supports CopyToUnv() and
CopyFromUnv(), you can copy details from your object to any other object in
the system.  All you need to understand is the Universe object.

Here  are two examples from the Picture class.  Notice how the child object
(Bitmap)  is  copied  first,  then  the  Picture  fields  are copied to the
Universe object.

LIBFUNC void PIC_CopyToUnv(mreg(__a0) struct Universe *unv,
                           mreg(__a1) struct Picture  *pic)
{
  CopyStructure(pic->Bitmap,unv);
  unv->Height  = pic->ScrHeight;
  unv->ScrMode = pic->ScrMode;
  unv->Source  = pic->Source;
  unv->Width   = pic->ScrWidth;
}

*****

LIBFUNC void PIC_CopyFromUnv(mreg(__a0) struct Universe *unv,
                             mreg(__a1) struct Picture  *pic)
{
  CopyStructure(unv,pic->Bitmap);
  if (!pic->ScrHeight) pic->ScrHeight = unv->Height;
  if (!pic->ScrMode)   pic->ScrMode   = unv->ScrMode;
  if (!pic->Source)    pic->Source    = unv->Source;
  if (!pic->ScrWidth)  pic->ScrWidth  = unv->Width;
}

The  last  important  note  is  the  'flatness'  of  the  Universe  object.
Extremely  complex  objects may not be able to convert themselves to such a
flat  level.   If you find that this is the case with your object, you will
probably not be able to support the CopyStructure() action.

If  you  need  a  particular  field  in  the  Universe  object  that is not
available,  write  to  DreamWorld  Productions and describe your problem to
have it rectified.

@{b}@{u}RETURN@{uu}@{ub}
If successful, return an error code of ERR_OK.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"CopyStructure()" LINK "GMSDev:AutoDocs/Kernel.guide/CopyStructure()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Deactivate" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Deactivate()
Type:        Function
Synopsis:    LONG Deactivate(*Object [a0])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
If  your  class supports Activate() you may also want to write support code
to  deactivate  an object.  However you must note that this only applies to
objects that support background processing.  For example after activating a
Sound  object,  the  audio  will play in the background.  Because the Sound
object supports Deactivate(), it is possible for a program to cut the audio
short whenever it wants to.

If your object does not act in such a manner, supporting Deactivate() is a
fairly useless exercise.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to an initialised object belonging to your class.

@{b}@{u}RETURN@{uu}@{ub}
If the deactivation is successful, return ERR_OK.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Deactivate()" LINK "GMSDev:AutoDocs/Kernel.guide/Deactivate()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Detach" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Names:       DetachChild(), DetachParent()
Type:        Function
Synopsis:    LONG DetachChild(APTR Child [a0], APTR Parent [a1])
             LONG DetachParent(APTR Child [a0], APTR Parent [a1])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
These  functions are used in conjunction with each other in order to create
the Detach() action.

The process for the Detach() action in the dpkernel is as follows:

  1. Make sure that the child object supports DetachParent(), and that the
     parent object supports DetachChild()
  2. Call DetachChild() on the parent object.
  3. Call DetachParent() on the child object.
  4. Return ERR_OK if the process was successful.

The  job  of  the parent object (Step 2) is to remove its references to the
given  child,  and  perform any necesary actions for removal.  For example,
when  a  Raster  object  is  detached  from  a Screen, the first thing that
happens  is  that  the  Screen  ensures the Raster has been hidden from the
display.   If  the  parent  does  not understand the child that it has been
sent, it MUST return an error-code so that Detach() can fail accordingly.

If succesful, Detach() will continue by calling DetachParent() on the child
object  (Step  3).   The  child is not expected to perform any actions, and
should  only delete its references to the parent object.  If the child does
not make references to the parent, then the child should return with ERR_OK
immediately.   Note  that  unlike  the parent object, if the child does not
understand the parent then it must return ERR_OK anyway.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Detach()" LINK "GMSDev:AutoDocs/Kernel.guide/Detach()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Draw" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Draw()
Type:        Function
Synopsis:    LONG Draw(*Object [a0])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Draw()  is  intended  for  objects that have been initialised to Containers
that  support drawable areas.  Classic examples for this are Bobs which are
initialised  to  Bitmaps.   You will need to make sure that your object has
kept a note of what container it was originally initialised to.

This  action  is essentially very simple and it is up to you to do the hard
work.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to an initialised object belonging to your class.

@{b}@{u}RETURN@{uu}@{ub}
Return  ERR_OK to indicate success.  If you fail to draw the object, return
any one of the bad error codes.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Draw()" LINK "GMSDev:AutoDocs/Kernel.guide/Draw()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Flush" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Flush()
Type:        Function
Synopsis:    LONG Flush(*Object [a0])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Flush is an action which is very useful for buffered objects such as Files.
Buffering  is a concept often used to speed up data processing, for example
reading  and  writing to memory is a lot faster than a hard drive or floppy
disk.   However,  it  is  also  important  that  the  physical  data should
represent  the buffered data from time to time.  By supporting Flush(), you
can ensure that this is possible.

When Flush() is called for your object, you will be expected to dump all of
the  buffered  data  back  to  where it should be, plus you must clear your
buffer of all its existing contents.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to an initialised object belonging to your class.

@{b}@{u}RETURN@{uu}@{ub}
Return ERR_OK if the flush was successful.

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Free" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Free()
Type:        Function
Synopsis:    void Free(*Object [a0])
Status:      Init only.
Inheritance: None.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This function is called whenever the programmer wants to Free() one of your
objects  from  the  system.   If  you  are  a  master,  you  must undo your
allocations  and then free the structure itself.  If you are a child class,
you must only undo the allocations that you have made.

@{b}@{u}NOTE@{uu}@{ub}
If  you  are a child class, Free() will first call your free function, then
it  will  call the free function of the master.  This is important as it is
the only way that the structure and any child structures can be effectively
removed from the system.

To  prevent  allocations  between  the  master  and  child routines getting
confused,  if  you  free  any  fields make sure that you drive them to NULL
afterwards.   Remember that if your sub-class requires its own private data
fields,  there  is an Object->Stats->ChildPrivate field which allows you to
place a pointer to private memory containing extra fields.

@{b}@{u}EXAMPLE@{uu}@{ub}
This example is derived from the Picture master class.

LIBFUNC void PIC_Free(mreg(__a0) struct Picture *pic)
{
  FreeMemBlock(pic->prvData);
  FreeMemBlock(pic->prvPalette);
  Free(pic->Bitmap);
}

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points  to  an object belonging to your class.  The object may or may not
  be initialised.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Free()" LINK "GMSDev:AutoDocs/Kernel.guide/Free()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_FreeExclusive" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        FreeExclusive()
Type:        Function
Synopsis:    void FreeExclusive(APTR Object [a0])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
If  you  wish to be informed when an exclusive lock is being freed, you may
write  a support routine for this function.  This is entirely optional, and
the FreeExclusive() action does not depend on your support for this.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points  to  an object belonging to your class.  The object may or may not
  be initialised.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"FreeExclusive()" LINK "GMSDev:AutoDocs/Kernel.guide/FreeExclusive()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Get" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Get()
Type:        Function
Synopsis:    APTR Get(struct Stats * [a0])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  is  called  whenever  a  program  wants to Get() the latest
version  of your particular object.  The routine that you place here should
be  fairly  simple,  depending  on  wether  or  not  you are supporting the
ObjectSize field.

If  you leave the ObjectSize at NULL, you will need to allocate a RESOURCED
memory  block  of the MEM_DATA type.  You need to set up the ID and Version
number, and may allocate some children if necessary.

If  you  support  the ObjectSize field, then you don't need to allocate any
system  memory  or  set any fields.  In fact the most you may need to do is
support  the  Public->OpenCount++ statement, depending on the simplicity of
your  object.   The  following  examples  show  the  two  different support
functions that you can write:

@{b}@{u}EXAMPLE 1@{uu}@{ub}
This  example  is derived from the Picture object, which as you will notice
also  has  a  child  Bitmap  that is allocated from Get().  This particular
version is related to a SysObject that has an ObjectSize set to NULL.

LIBFUNC struct Picture * PIC_Get(mreg(__a0) struct Stats *Stats)
{
  struct Picture *Picture;

  if (Picture = AllocMemBlock(sizeof(struct Picture), Stats->MemFlags|MEM_UNTRACKED|MEM_DATA)) {
     Picture->Head.ID      = ID_PICTURE;
     Picture->Head.Version = VER_PICTURE;

     if (Picture->Bitmap = Get(ID_BITMAP|GET_NOTRACK)) {
        Picture->Bitmap->Parent = Picture;
        Public->OpenCount++;
        return(Picture);
     }
     else DPrintF("!Get:","Failed to get Bitmap.");
  }
  else DPrintF("!Get:","Failed to allocate picture memory.");

  return(NULL);
}

@{b}@{u}EXAMPLE 2@{uu}@{ub}
Use this style of code if you have given an ObjectSize for your object:

LIBFUNC struct Picture * PIC_Get(mreg(__a0) struct Picture *Picture)
{
   if (Picture->Bitmap = Get(ID_BITMAP)) {
      Picture->Bitmap->Parent = Picture;
      Public->OpenCount++;
      return(Picture);
   }
   else DPrintF("!Get:","Failed to obtain a Bitmap for this Picture.");

   return(NULL);
}

@{b}@{u}NOTE@{uu}@{ub}
The  Get()  action  applies  to  parent classes only, so if you are a child
class, you will have to accept whatever your master decides to allocate.

@{b}@{u}INPUT@{uu}@{ub}
When ObjectSize is NULL:

Stats
  This argument points to a standard Stats structure, which is
  automatically built for an object when Get() is called.  The Stats
  structure contains some special information such as the recommended
  memory flags, wether the object is shared or not etc.  Wether you need
  to use this information or not is dependent on your object's design.

When ObjectSize has a value:

Object
  Points to an area of memory that matches the size of your object.  It
  will have automatically been given a Version, ID and Stats pointer by the
  Get() action.

@{b}@{u}RETURN@{uu}@{ub}
You are required to return a pointer to the newly allocated object, or NULL
if failure.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Get()" LINK "GMSDev:AutoDocs/Kernel.guide/Get()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Hide" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Hide()
Type:        Function
Synopsis:    void Hide(*Object [a0])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
If  your  object  is  visible to the user (e.g.  Screens and Files are such
cases)  then  you may also want to provide a way to make it invisible.  You
can do this by providing support for the Hide() action.

This  function has no return code, so your hide routine is expected to work
without  fail.   If for some reason you cannot perform the action, then you
should leave the object in its visible state.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to the object that needs to be hidden.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field:  @{"Show" LINK "SYS_Show"}
Kernel: @{"Hide()" LINK "GMSDev:AutoDocs/Kernel.guide/Hide()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Init" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Init()
Type:        Function
Synopsis:    LONG Init(*Object [a0], *Container [a1]);
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  is called when the programmer calls the Init() action on an
object.   It's  purpose is to prepare the object for the necessary handling
for actions such as Draw(), Activate(), Show() etc.

@{b}@{u}Rules for Initialisation@{uu}@{ub}
If  the initialisation fails due to the fact that your object cannot handle
the data (eg an IFF class gets sent a JPEG source) then your Init() routine
must undo any changes it has made to the object's structure.  You must then
return  an  error code of ERR_NOSUPPORT.  This will cause the Init() action
to look for a sub-class that can support the object better.

If the object was recognised but initialisation fails due to a system error
or  similar,  then  any error-code can be returned except for ERR_NOSUPPORT
and  ERR_OK.   This  will  cause  the Init() action to fail immediately and
return to the program.

@{b}@{u}NOTE #1@{uu}@{ub}
It is highly recommended that before proceeding with full initialisation of
an object, you always check the data sources and ensure that you understand
them.   If  you  check the data near the middle or end of your routine, you
may  make  things  difficult  to  undo  if you find that you need to return
ERR_NOSUPPORT.

@{b}@{u}NOTE #2@{uu}@{ub}
You  must never call Free() on your object while inside the Init() routine.
If  your  call  fails  (eg you returned ERR_FAILED), then the Init() action
will call Free() at a later time.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Init()" LINK "GMSDev:AutoDocs/Kernel.guide/Init()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Load" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Load()
Type:        Function
Synopsis:    APTR Load(*File [a0])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
If  your object is capable of being loaded from files, you will most likely
want to support the Load() action.  Loading is great for grabbing an entire
file from disk and processing it into the correct object.  This is what you
need to achieve if you want to support Load().

To  offer full support for this action, you should also write a routine for
the  CheckFile()  field.  Load() may ask if you understand a file before it
asks  you  to  load it, and if you do not support CheckFile() you may never
get that opportunity.  This is especially important for sub-classes.

@{b}@{u}INPUT@{uu}@{ub}
File
  The Load() action will send you a File as the only argument.  This is the
  source  from which you can Read() data from.  Do not mess around with the
  File object more than what is necessary.

@{b}@{u}RETURN@{uu}@{ub}
This action requires that you Get() a fresh object from your class, and you
will  need  to  return  it in an Init()ialised state.  All the data must be
loaded and ready to go.  If you fail, return NULL.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field:  @{"CheckFile" LINK "SYS_CheckFile"}
Kernel: @{"Load()" LINK "GMSDev:AutoDocs/Kernel.guide/Load()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Lock" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Lock()
Type:        Function
Synopsis:    LONG Lock(*Object [a0], WORD LockCount [d0])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Locking  is intended for preventing objects from physically moving position
(e.g.   files)  and  prevents  tasks  from  performing  certain actions and
changes  to  an  object.  Locks can either be shared or exclusive to tasks,
depending on what is suitable for the object.

As  a  result  of  locking, the object will be fixed in place and cannot be
moved or deleted, even by the task that holds the lock, until the object is
Unlock()ed.  As the object programmer, you have a responsibility to enforce
this  rule.   Feel  free  to  place  other restrictions on the object where
appropriate.

@{b}@{u}NOTE@{uu}@{ub}
It  is  extremely  important that you document the behaviour of locking for
your  particular  object.   The issue of shared/exclusive locking on public
objects is an important issue for you to consider.

You  should  also  support the Unlock() function, this is the only way that
you can receive information on the unlocking of an object.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to an initialised object that belongs to your class.

LockCount
  Tells  you  the  current  number of locks on this object.  Note that this
  only  applies  to the object itself, and not the physical representation.
  For  example,  if two tasks open the same file with separate objects from
  Get(),  you  would  get a LockCount of 0 both times.  To get the physical
  lock  count,  you  need  to  develop  your  own  internal  mechanism that
  remembers who has locked out what.

@{b}@{u}RETURN@{uu}@{ub}
Return ERR_OK if the lock has been granted successfully.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field:  @{"Unlock" LINK "SYS_Unlock"}
Kernel: @{"CheckLock()" LINK "GMSDev:AutoDocs/Kernel.guide/CheckLock()"}
        @{"Lock()" LINK "GMSDev:AutoDocs/Kernel.guide/Lock()"}
        @{"Unlock()" LINK "GMSDev:AutoDocs/Kernel.guide/Unlock()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_MoveTo" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        MoveToBack(), MoveToFront()
Type:        Function
Synopsis:    void MoveToBack(*Object [a0])
             void MoveToFront(*Object [a0])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
In  many  instances  where displayable objects are on screen, there will be
cases  of  overlapping  graphics.   Bobs,  Windows and Screens are all good
examples  of  this.   So long as you support the MoveTo*() actions, you can
provide  the  programmer some assistance in ordering objects (starting from
the back and on to the front).

How  you  go  about  providing  this  support  is  your  own business - the
MoveTo*() actions will do no more than to call your support routines.

@{b}@{u}NOTE@{uu}@{ub}
If  your  class  supports  the Lock() action, it may be best for any locked
objects  to hold their position.  That is, a locked object should be not be
capable  of  being  moved.  Wether you decide to do this or not is your own
decision, so document your object's behaviour on this.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to an initialised object that belongs to your class.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"MoveToBack()" LINK "GMSDev:AutoDocs/Kernel.guide/MoveToBack()"}
        @{"MoveToFront()" LINK "GMSDev:AutoDocs/Kernel.guide/MoveToFront()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Query" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Query()
Type:        Function
Synopsis:    LONG Query(*Object [a0])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Query() is a commonly supported action that programs can use to get updated
information  on  an  object.  If you want to support Query(), then you will
need  to decide what fields you are going to update, and then document this
properly.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to an initialised object that belongs to your class.

@{b}@{u}RETURN@{uu}@{ub}
You  are  required  to  return  a standard error code after your routine is
complete (ERR_OK on success).

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Query()" LINK "GMSDev:AutoDocs/Kernel.guide/Query()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Read" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Read()
Type:        Function
Synopsis:    LONG Read(*Object [a0], APTR Buffer [a1], LONG Length [d0])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
The  Read()  action  was  initially written in order to support reading and
writing data to Files.  Besides this intention, any object which supports a
data storage area is capable of supporting Read().

The Buffer argument points directly to the area that will receive data from
your  Object.   Generally the Length will indicate the amount of bytes that
need  to be written to this area.  If you have a good reason for the Length
to indicate words, long-words, array size, or similar then you may document
this  as  a  requirement for your object.  Make sure that the programmer is
well informed on this!

If  your  Read()  fails,  return one of the failure error-codes.  Otherwise
return ERR_OK.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to an initialised object that belongs to your class.

Buffer
  Points to the data area that will accept information from the Object.

Length
  An abstract indicator of how much data should be written.

@{b}@{u}SEE ALSO@{uu}@{ub}
Fields: @{"Write" LINK "SYS_Write"}
        @{"Seek" LINK "SYS_Seek"}
Kernel: @{"Read()" LINK "GMSDev:AutoDocs/Kernel.guide/Read()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Reset" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Reset()
Type:        Function
Synopsis:    LONG Reset(*Object [a0])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
The  common  reason for supporting Reset() is so that it is possible to get
an  object  back  to a refreshed state.  Examples could be resetting a file
position  back  to the beginning, or clearing out old data so that new data
can be added to an object.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to an initialised object that belongs to your class.

@{b}@{u}RETURN@{uu}@{ub}
If  the  object is successfully refreshed, return ERR_OK.  Otherwise return
ERR_FAILED or similar.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Reset()" LINK "GMSDev:AutoDocs/Kernel.guide/Reset()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_SaveToFile" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        SaveToFile()
Type:        Function
Synopsis:    LONG SaveToFile(*Object [a0], *File [a1])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
By  supporting SaveToFile(), you can make it possible to save your object's
data  to  disk.   This  can  be  extremely  important  for objects that are
intended  for  interactive  use  with  the  user, such as Pictures, Sounds,
Documents etc.

When  your  SaveToFile() support routine is called, you will be sent a File
object  that has been opened in FL_NEWFILE and FL_WRITE modes.  All you are
required to do is Write() your data to the given File object.

@{b}@{u}NOTE@{uu}@{ub}
You  should/must  save your file information in a format that is recognised
by  your  Load() and CheckFile() support.  This will allow the user to read
back the data at a later time.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to an initialised object that belongs to your class.

File
  Points  to  an  initialised File object which you are expected to Write()
  to.

@{b}@{u}RETURN@{uu}@{ub}
If successful, return ERR_OK.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"SaveToFile()" LINK "GMSDev:AutoDocs/Kernel.guide/SaveToFile()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Seek" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Seek()
Type:        Function
Synopsis:    LONG Seek(*Object [a0], LONG Position [d0], WORD Mode [d1])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
If  your  object  supports read/write functionality, you will most probably
also  want  to support Seek().  Seeking is used to position the 'read/write
head'  so  that  the next time some I/O occurs, it will start at the seeked
position.

You  are required to remember the current byte position in your object, and
you  will  obviously need to closely integrate read, write and seek support
together.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to an initialised object that belongs to your class.

Position
  The byte position that is to be seeked to, relative to the Mode argument.

Mode
  Either POS_BEGINNING, POS_CURRENT or POS_END.

@{b}@{u}RETURN@{uu}@{ub}
If successful, you are required to return your old byte position before the
Seek() occurred.  If you failed to seek to the requested position, return a
value of -1.

@{b}@{u}SEE ALSO@{uu}@{ub}
Fields: @{"Read" LINK "SYS_Read"}
        @{"Write" LINK "SYS_Write"}
Kernel: @{"Seek()" LINK "GMSDev:AutoDocs/Kernel.guide/Seek()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Show" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Show()
Type:        Function
Synopsis:    LONG Show(*Object [a0])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action  is for objects that have the ability to become visible to the
user.   Examples  are  Screens, Bobs, Files, Buttons, Windows etc.  Visible
does  not  necessarily  mean displayable, e.g.  Files are visible only from
the hard-drive, as opposed to Bobs which are displayed on Screens.

If your object supports initialisation to a container, then you most likely
will  want  to  show  your  object inside that container.  This is true for
Windows  and  Bobs,  which  are  contained  within  Screens.   It  is  your
responsibility to remember what containers your objects are initialised to.

To  accompany  the  Show()  action,  Hide() is also provided.  It is highly
recommended that you support both actions, not just one of them.

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to an initialised object that belongs to your class.

@{b}@{u}RETURN@{uu}@{ub}
Return ERR_OK on success.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field:  @{"Hide" LINK "SYS_Hide"}
Kernel: @{"Hide()" LINK "GMSDev:AutoDocs/Kernel.guide/Hide()"}
        @{"Show()" LINK "GMSDev:AutoDocs/Kernel.guide/Show()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_TagTrigger" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        TagTrigger
Type:        Function
Synopsis:    LONG TagTrigger(LONG *TagPos [a0], *Object [a1]);
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  is  a  special  function which allows you to interact with tag lists.
The  Bob  object  for example uses a tag trigger for its Source field.  The
setting for this tag is defined as:

#define BOB_SourceTags (TSTEPIN|TTRIGGER|72)

Why is it set up like this?  Look at the following code:  

  if (Worm = InitTags(screen,
      TAGS_BOB,      NULL,
      BBA_Width,     32,
      BBA_Height,    24,
        BBA_SourceTags, NULL,           /* <--- Look Here */
        PCA_Source,     &bobfile,
          PCA_BitmapTags, NULL,
          BMA_MemType,    MEM_BLIT,
          TAGEND,NULL,
        TAGEND,NULL,
      TAGEND)) {

Now, since the Bob->Source has not been set, this code is actually illegal!
There  is  simply  no Picture object in the Bob->Source field, so who knows
what  it  is actually writing to with the PCA tags.  The way to fix this is
to  implement  a tag-trigger, which can detect when BBA_SourceTags has been
specified.   When  TagInit() finds such a trigger, it will immediately look
for  the  object's support for the TagTrigger definition.  If found it will
make  a  call  to  the function, and then TagInit() will continue about its
normal business.

So  in  our  Bob  example above, we can solve our problem by allocating the
appropriate  object for Bob->Source.  In order to make sure that we get the
correct object, we have to ask the user what class is required, which means
a new tags format:

  ...
  BBA_Height,    24,
    BBA_SourceTags, ID_PICTURE,       /* <--- Class ID Specified */
    PCA_Source,     &bobfile,
    ...

It is now possible for us to see that the user wants a Picture, allowing us
to allocate the object for Bob->Source and preventing a crash.  To help you
with  creating  your  own tag triggers, here is the actual code used in the
Bob class:

__asm __saveds LONG BOB_TagTrigger(register __a0 LONG *TagPos,
                                   register __a1 struct Bob *Bob)
{
  DMsg("Bob trigger received.");

  /* Check what field caused the trigger, then Get() the
  ** appropriate child object.
  */

  if (TagPos[0] IS BBA_SourceTags) {
     if (Bob->Source = Get(TagPos[1]|GET_NOTRACK)) {
        Bob->prvAFlags |= AF_SOURCE;
        return(ERR_OK);
     }
     else DPrintF("Error:","Could not allocate required Source object.");
  }
  else DPrintF("Error:","Invalid tag detected.");

  return(ERR_FAILED);
}

@{b}@{u}NOTE@{uu}@{ub}
If  you  return  an  error  code  other than ERR_OK, you will terminate the
entire tag initialisation process.  All errors will be considered fatal.

@{b}@{u}INPUT@{uu}@{ub}
TagPos
  The current position in the tag-list, which will be the field that caused
  the tag trigger.

Object
  Pointer  to  an  object that belongs to your class.  The object will have
  been obtained from Get() and will not be initialised.

@{b}@{u}RETURN@{uu}@{ub}
If successful, return ERR_OK.

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Unhook" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Unhook()
Type:        Function
Synopsis:    LONG Unhook(*Object [a0], *Chain [a1])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Unhook()  is  for  pulling  an  object out from a list or chain of mulitple
objects.  The best example of this are Files, which are chained together in
order  to  form the contents of a directory.  By supporting Unhook(), it is
possible to extract single File objects out of the chain.

In  order to form a chain of objects, your object must support a Next field
and  preferably  a Prev field as well.  Bearing this in mind, you will need
to  patch  up  both  of these fields in order to keep the chain functional.
Breaking a chain is considered to be quite unacceptable!

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to the object that is to be removed.

Chain
  Points  to  the  first  object  that  begins  the  chain.  If your object
  supports  both Next and Prev fields this may not be necessary, so you can
  document it as an optional argument.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Unhook()" LINK "GMSDev:AutoDocs/Kernel.guide/Unhook()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Unlock" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Unlock()
Type:        Function
Synopsis:    void Unlock(*Object [a0])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
Unlock()  serves  as  an  accompanient  to  the  Lock()  action.  It is not
compulsory  to  support  Unlock()  if  you have written Lock() support, but
chances are you will probably need to write a routine for this.

What  you  do for your Unlock() support is entirely up to you, just make it
appropriate for your object.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field:  @{"Lock" LINK "SYS_Lock"}
Kernel: @{"Lock()" LINK "GMSDev:AutoDocs/Kernel.guide/Lock()"}
        @{"Unlock()" LINK "GMSDev:AutoDocs/Kernel.guide/Unlock()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_Write" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Write()
Type:        Function
Synopsis:    LONG Write(*Object [a0], APTR Buffer [a1], LONG Length [d0])
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}
The  Write()  action  was initially written in order to support reading and
writing data to Files.  Besides this intention, any object which supports a
data storage area is capable of supporting Write().

The Buffer argument points directly to the data that needs to be written to
your  Object.   Generally the Length will indicate the amount of bytes that
need  to  be written.  If you have a good reason for the Length to indicate
words,  long-words,  array size, or similar then you may document this as a
requirement  for  your  object.   Make  sure  that  the  programmer is well
informed on this!

@{b}@{u}INPUT@{uu}@{ub}
Object
  Points to an initialised object that belongs to your class.

Buffer
  Points to the data that needs to be written to the Object.

Length
  An abstract indicator of how much data should be written.

@{b}@{u}RETURN@{uu}@{ub}
If  your  Write()  fails, return one of the failure error-codes.  Otherwise
return ERR_OK.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field:  @{"Read" LINK "SYS_Read"}
Kernel: @{"Write()" LINK "GMSDev:AutoDocs/Kernel.guide/Write()"}

@EndNode
---------------------------------------------------------------------------
@NODE "SYS_" "Object: SysObject"

@{b}@{u}FIELD@{uu}@{ub}
Name:        
Type:        Function
Synopsis:    
Status:      Init only.
Inheritance: Parent class.

@{b}@{u}DESCRIPTION@{uu}@{ub}



@EndNode
---------------------------------------------------------------------------
