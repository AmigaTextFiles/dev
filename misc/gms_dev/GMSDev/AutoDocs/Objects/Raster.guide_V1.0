@DATABASE "Raster"
@AUTHOR   "Paul Manias"
@NODE     "Main" "Object: Raster"

@{b}@{u}OBJECT DOCUMENTATION@{uu}@{ub}
Name:      @{"RASTER" LINK "Description"}
Version:   1.0
Date:      March 1998
Author:    Paul Manias
Copyright: DreamWorld Productions, 1996-1998.  All rights reserved.

@{b}@{u}OBJECT DOCUMENTATION@{uu}@{ub}
Renamed: Display() to Show()

@EndNode
---------------------------------------------------------------------------
@NODE  "Description" "Object: Raster"

@{b}@{u}OBJECT@{uu}@{ub}
Name:    Raster
Version: 1
ID:      ID_RASTER
Module:  @{"Screens" LINK "GMSDev:AutoDocs/Screens.guide/Functions"}
Include: @{"graphics/screens.h" LINK "GMSDev:Includes/graphics/screens.h/Main"}
Type:    Complex

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  object  was  created  to  allow  easy  handling  of raster-line based
graphics hardware.  In the Amiga, this means the copper chip.  Because most
graphics  boards  do  not  allow  for raster based commands, this object is
considered  to  be  "unreliable".   Simply  put,  if you decide to use this
object  then  you cannot expect it to work on all machines.  Make sure that
you prepare for this in your code.

A raster list is created by building a chain of commands which are attached
to  the main Raster object.  These commands are executed in order, at their
relative  points on the display.  Any commands that are not recognised will
be ignored.

@{b}@{u}EXAMPLE@{ub}@{uu}
The  following  example will attach a Raster object to a Screen.  Note that
in  this  case,  initialising  the  Screen  object will also initialise the
Raster for us.

   struct RColourList RColourList = {
      ID_RASTCOLOURLIST, 1, NULL, NULL, NULL,
      000,1,0,Colourlist
   };

   if (Raster = Get(ID_RASTER)) {
      Raster->Command = (struct RHead *)&RColourList1;

      if (Screen = InitTags(NULL,
          TAGS_SCREEN, NULL,
          GSA_Raster,  Raster,
          TAGEND)) {

         Display(Screen);

      Free(Screen);
      }
   Free(Raster);
   }

@{b}@{u}ACTIONS@{ub}@{uu}
The Raster object supports the following actions:

     @{"Activate()" LINK "GMSDev:AutoDocs/Kernel.guide/Activate()"} - Calculates all the commands in a Raster object.
     @{"Detach()" LINK "GMSDev:AutoDocs/Kernel.guide/Detach()"}   - Detach a Raster object from a Screen.
     @{"Free()" LINK "GMSDev:AutoDocs/Kernel.guide/Free()"}     - Free a Raster object.
     @{"Get()" LINK "GMSDev:AutoDocs/Kernel.guide/Get()"}      - Get a new Raster structure.
     @{"Hide()" LINK "GMSDev:AutoDocs/Kernel.guide/Hide()"}     - Hide a Raster from a Screen.
     @{"Init()" LINK "GMSDev:AutoDocs/Kernel.guide/Init()"}     - Initialise a Raster object.
     @{"Show()" LINK "GMSDev:AutoDocs/Kernel.guide/Show()"}     - Display a Raster on Screen.

@{b}@{u}STRUCTURE@{uu}@{ub}
The Raster structure consists of the following public fields:

     @{"Command" LINK "RAS_Command"} - Pointer to the first Raster command.
     @{"Flags" LINK "RAS_Flags"  }   - Special flags.
     @{"Screen" LINK "RAS_Screen" }  - Pointer to the Screen owner.

@EndNode
---------------------------------------------------------------------------
@NODE "RAS_Command" "Object: Raster"

@{b}@{u}FIELD@{uu}@{ub}
Name:      Command
Type:      struct RHead *
On Change: Cannot change after initialisation.
Status:    Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This field points to the first Raster command in your programmed list.

Command  structures  are  supported  as children of the Raster object.  You
need  to link each command structure via the Next and Prev fields to create
a  chain  of  commands.   Each  command structure begins with a header that
contains the following public fields:

     @{"ID" LINK "RHD_ID"}      - ID code for the command.
     @{"Next" LINK "RHD_Next"}    - Next command in the list.
     @{"Prev" LINK "RHD_Prev"}    - Previous command in list.
     @{"Version" LINK "RHD_Version"} - Version number for the particular command.

The "arguments" for the command then follow after this header structure.

@{b}@{u}COMMANDS@{uu}@{ub}
This version of the Raster object supports the following commands:

     @{"Colour" LINK "CMD_Colour"}     - Set the value of a colour.
     @{"ColourList" LINK "CMD_ColourList"} - Generate a list of colour values.
     @{"Flood" LINK "CMD_Flood"}      - Used to create a special "flood" effect.
     @{"Wait" LINK "CMD_Wait"}       - Wait for the beam to reach a set line.

@EndNode
---------------------------------------------------------------------------
@NODE "RAS_Flags" "Object: Raster"

@{b}@{u}FIELD@{uu}@{ub}
Name:      Flags
Type:      LONG
On Change: Cannot change after initialisation.
Status:    Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This field contains all raster based flags.  They are:

  @{u}RSF_DISPLAYED@{uu}
  This  is  set if the raster is currently displayed on screen.  You cannot
  set this flag yourself - it is handled by Hide() and Show().

@EndNode
---------------------------------------------------------------------------
@NODE "RAS_Screen" "Object: Raster"

@{b}@{u}FIELD@{uu}@{ub}
Name:   Screen
Type:   struct Screen *
Status: Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This field points to the Screen that owns the Raster object.

Note that there is no need for you to set this field for initialisation.

@{b}@{u}SEE ALSO@{uu}@{ub}
Object: @{"Screen" LINK "GMSDev:AutoDocs/Objects/Screens.guide/Description"}

@EndNode
---------------------------------------------------------------------------
@NODE "CMD_Colour" "Object: Raster"

@{b}COLOUR <Colour>,<0xAARRGGBB>@{ub}

  struct RColour {
    struct RHead Head;
    LONG   Colour;
    LONG   Value;
  };

Changes  the  24 bit value of a colour in the screen palette.  This command
does not work on true colour and similar non-palette based screen types.

@{b}@{u}ARGUMENTS@{uu}@{ub}
Colour - The colour number that you wish to change (0 - 255).
Value  - The new value of the colour in $AARRGGBB format.

@EndNode
---------------------------------------------------------------------------
@NODE "CMD_ColourList" "Object: Raster"

@{b}COLOURLIST <YCoord>,<Skip>,<Colour>,<Values>@{ub}

  struct RColourList {
    struct RHead Head;
    WORD   YCoord;
    WORD   Skip;
    LONG   Colour;
    LONG   *Values;
  };

This  command  allows  you  to  generate the classic coloured lines used by
games   and   demos   everywhere.    This  command  is  mostly  useful  for
sky/background effects, although you could probably use it for all sorts of
things.   It  does  not  work  on true colour and similar non-palette based
screen types.

@{b}@{u}ARGUMENTS@{uu}@{ub}
YCoord - The coordinate that the colour-list should start executing.
Skip   - The gap between each coloured line.  Minimum of 1.
Colour - The colour number that is going to be changed (0 - 255).
Values - A long-word array of colour values in $AARRGGBB format.

@EndNode
---------------------------------------------------------------------------
@NODE "CMD_Flood" "Object: Raster"

@{b}FLOOD@{ub}

  struct RFlood {
    struct RHead Head;
  };

This  special  effect reverses the bitplane modulo, causing the bitplane to
repeat  itself.   This  effect  is  used  as a novel way of "fading in" the
screen.

@{b}@{u}ARGUMENTS@{uu}@{ub}
None.

@EndNode
---------------------------------------------------------------------------
@NODE "CMD_Wait" "Object: Raster"

@{b}WAIT <Line>@{ub}

  struct RWait {
    struct RHead Head;
    WORD   Line;
  };

Waits  for the vertical beam to reach the specified screen position.  It is
perfectly  legal to enter numbers that go outside of your screen's vertical
limits  (ie  negative  numbers and numbers greater than the screen height),
but no more than a value of 10.

Note  that the purpose of this command is to specify the screen position at
which the next command will be executed.  All line values must be specified
in lo-res pixels, regardless of your screen resolution.

@{b}@{u}ARGUMENTS@{uu}@{ub}
Line - The Y coordinate that you are waiting for.

@EndNode
---------------------------------------------------------------------------
@NODE "RHD_ID" "Object: Command"

@{b}@{u}FIELD@{uu}@{ub}
Name:      ID
Type:      WORD
On Change: Cannot change after initialisation.
Status:    Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  defines the command type.  Valid commnd ID's are listed in the
"graphics/screens.h" file.

@EndNode
---------------------------------------------------------------------------
@NODE "RHD_Next" "Object: Command"

@{b}@{u}FIELD@{uu}@{ub}
Name:      Next
Type:      struct RHead *
On Change: Cannot change after initialisation.
Status:    Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  points  to the next command in the chain.  If this is the last
command, this field will be set to NULL.

@EndNode
---------------------------------------------------------------------------
@NODE "RHD_Prev" "Object: Command"

@{b}@{u}FIELD@{uu}@{ub}
Name:      Prev
Type:      struct RHead *
On Change: Cannot change after initialisation.
Status:    Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  points  to  the previous command in the chain.  If this is the
first command in the list, then this field will be set to NULL.

@EndNode
---------------------------------------------------------------------------
@NODE "RHD_Version" "Object: Command"

@{b}@{u}FIELD@{uu}@{ub}
Name:      Version
Type:      WORD
On Change: Cannot change after initialisation.
Status:    Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field specifies the version number of the command.  Note that version
numbers start at 1 and go up from there.

@EndNode
---------------------------------------------------------------------------
