@DATABASE "Segment"
@AUTHOR   "Paul Manias"
@NODE     "Main" "Object: Segment"

@{b}@{u}OBJECT DOCUMENTATION@{uu}@{ub}
Name:      @{"SEGMENT" LINK "Description"}
Date:      June 1998
Author:    Paul Manias
Copyright: DreamWorld Productions, 1996-1998.  All rights reserved.

@{b}@{u}CHANGES VERSION 1.1@{uu}@{ub}
Added: Segment->Size

@EndNode
---------------------------------------------------------------------------
@NODE "Description" "Object: Segment"

@{b}@{u}OBJECT@{uu}@{ub}
Name:    Segment
Version: 2
ID:      ID_SEGMENT
Module:  @{"Kernel" LINK "GMSDev:AutoDocs/Kernel.guide/Functions"}
Include: @{"files/segments.h" LINK "GMSDev:Includes/files/segments.h/Main"}
Type:    Complex

@{b}@{u}DESCRIPTION@{uu}@{ub}
The  segment  object  is  used  for  loading  complex  data files, which if
formatted  correctly,  can  be  scatter  loaded  into  any  area of memory.
Currently  only  AmigaDOS  segments  are  supported,  but theoretically any
segment format from other systems could be added.

@{b}@{u}ACTIONS@{uu}@{ub}
The Segment object supports the following actions:

     @{"Free()" LINK "GMSDEV:AutoDocs/Kernel.guide/Free()"} - Free the segment and others on the chain.
     @{"Get()" LINK "GMSDEV:AutoDocs/Kernel.guide/Get()"}  - Get a new segment object.
     @{"Init()" LINK "GMSDEV:AutoDocs/Kernel.guide/Init()"} - Initialise a segment object.
     @{"Load()" LINK "GMSDEV:AutoDocs/Kernel.guide/Load()"} - Load a segment file.

@{b}@{u}STRUCTURE@{uu}@{ub}
The Segment object consists of the following public fields:

     @{"Address" LINK "SEG_Address"} - Pointer to segment data.
     @{"CPU" LINK "SEG_CPU"}     - Reference to the CPU type, applies to CODE segments.
     @{"MemType" LINK "SEG_MemType"} - Type of memory that the Address points to.
     @{"Next" LINK "SEG_Next"}    - Next segment in list.
     @{"Prev" LINK "SEG_Prev"}    - Previous segment in list.
     @{"Size" LINK "SEG_Size"}    - The total byte size of the segment.
     @{"Source" LINK "SEG_Source"}  - Origin of this segment.

@EndNode
---------------------------------------------------------------------------
@NODE "SEG_Address" "Object: Segment"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Address
Type:        APTR
Inheritance: Allocated on loading.
On Change:   Cannot change after initialisation.
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field points to the actual data of the given segment.  If the segment
is of the MEM_CODE type, you can execute it by jumping to this address (NB:
Check the Segment->CPU before doing this).

@EndNode
---------------------------------------------------------------------------
@NODE "SEG_CPU" "Object: Segment"

@{b}@{u}FIELD@{uu}@{ub}
Name:        CPU
Type:        WORD
Inheritance: Set on loading.
On Change:   Cannot change after initialisation.
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
If  the  segment  is  a MEM_CODE type, then this field will specify the CPU
that the code is written for.

Examples of CPU's are:

  CPU_68000
  CPU_68040
  CPU_68060
  ...

If  a  code  segment  does  not match the machine's CPU (e.g 680x0 on a PPC
machine)  then the code will need to be emulated.  Don't worry about this -
in  future  GMS  will  provide  support for CPU emulation once it becomes a
necessity.

@EndNode
---------------------------------------------------------------------------
@NODE "SEG_MemType" "Object: Segment"

@{b}@{u}FIELD@{uu}@{ub}
Name:        MemType
Type:        LONG
Inheritance: Source
On Change:   Cannot change after initialisation.
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This field reflects the memory type that this Segment has been loaded into.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"Address" LINK "SEG_Address"}

@EndNode
---------------------------------------------------------------------------
@NODE "SEG_Next" "Object: Segment"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Next
Type:        struct Segment *
Inheritance: Source
On Change:   Cannot change after initialisation.
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
The  Next  field  points  to  the next Segment in the chain.  This field is
driven to NULL if no more Segments are left on the chain.

@EndNode
---------------------------------------------------------------------------
@NODE "SEG_Prev" "Object: Segment"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Prev
Type:        struct Segment *
Inheritance: Source
On Change:   Cannot change after initialisation.
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
Prev  points to the previous Segment in the chain.  This field is driven to
NULL if this is the first Segment on the chain.

@EndNode
---------------------------------------------------------------------------
@NODE "SEG_Size" "Object: Segment"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Size
Type:        LONG
Inheritance: Source
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
The size of the Segment (in bytes) is reflected here.

@EndNode
---------------------------------------------------------------------------
@NODE "SEG_Source" "Object: Segment"

@{b}@{u}FIELD@{uu}@{ub}
Name:      Source
Type:      APTR
On Change: Cannot change after initialisation.
Status:    Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  points to a standard GMS source structure, eg a FileName.  You
must  supply  a  Source here when calling Init(), otherwise you will not be
able to load anything in.

@{b}@{u}NOTE@{uu}@{ub}
If  you  are  going  to create an entirely new Segment and later save it to
disk,  then  you would specify the Segment->Address and leave the Source as
NULL.   However this particular functionality is not supported yet, it will
be available at a later date...

@EndNode
---------------------------------------------------------------------------
