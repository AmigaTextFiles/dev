@DATABASE "Module"
@AUTHOR   "Paul Manias"
@NODE     "Main" "Object: Module"

@{b}@{u}OBJECT DOCUMENTATION@{uu}@{ub}
Name:      @{"MODULE" LINK "Description"} AUTODOC
Date:      June 1998
Author:    Paul Manias
Copyright: DreamWorld Productions, 1996-1998.  All rights reserved.

@{b}@{u}CHANGES VERSION 1.1@{uu}@{ub}
Added:   Module->Public
Renamed: Module->Version to Module->MinVersion
         Module->Revision to Module->MinRevision

@{b}@{u}CHANGES VERSION 1.0@{uu}@{ub}
This document was completely revised.

@{b}@{u}CHANGES VERSION 0.9B@{uu}@{ub}
Added: Module->Name

@EndNode
---------------------------------------------------------------------------
@NODE "Description" "Object: Module"

@{b}@{u}OBJECT@{uu}@{ub}
Name:    Module
Version: 2
ID:      ID_MODULE
Module:  @{"Kernel" LINK "GMSDev:AutoDocs/Kernel.guide/Functions"}
Include: @{"system/modules.h" LINK "GMSDev:Includes/system/modules.h/Main"}
Type:    Simple

@{b}@{u}DESCRIPTION@{uu}@{ub}
The  module  object  serves  as  a  launching  pad  for all system modules.
Examples of system modules are screens.mod, pictures.mod, and keyboard.mod,
all  of  which  are held in the System/ directory.  Each module can carry a
set  of  functions  which you can use to your programs' advantage.  Certain
modules  such  as pictures.mod only carry objects.  Since they do not carry
any functions, there is no need for you to open those directly.

When  you  want  to  load  a  module,  you  may  either  specify  the  Name
("screens.mod")  or  the  Number (MOD_SCREENS).  If the module has a Number
then  you  MUST  use it as this is preferred over a Name string.  Generally
the  only  time a Name needs to be used is when a module is being developed
and an official ID has not been assigned to it yet.

You  may  specify a minimum Version and Revision number for the module.  If
the  module meets or betters this criteria it will be loaded, otherwise the
initialisation will fail safely.

After  a module is initialised, there is actually very little that you need
to  do  with  the structure itself.  Assuming that the module has functions
that  you  want  to use, you can grab the Module Function Base and store it
for  future  referencing.   Writing  to  any  of  the  Module  fields after
initialisation is not possible (and has no purpose).

@{b}@{u}NOTES@{uu}@{ub}
Modules  are  shared  between programs.  That means that once the module is
loaded it is never loaded again, as the functionality is already in memory.
Each  program  will  still get its own personal Module object with function
base though.

For  anyone interested in writing a system module, please read the "Writing
a New Module" section in the general documentation.

@{b}@{u}FUNCTIONS@{uu}@{ub}
The following functions support the Module object:

     @{"OpenModule()" LINK "GMSDev:AutoDocs/Kernel.guide/OpenModule()"}

@{b}@{u}ACTIONS@{uu}@{ub}
The Module object supports the following actions:

     @{"Free()" LINK "GMSDev:AutoDocs/Kernel.guide/Free()"} - Free a module from use.
     @{"Get()" LINK "GMSDev:AutoDocs/Kernel.guide/Get()"}  - Get a new module structure.
   * @{"Init()" LINK "MOD_Init()"} - Initialise/Load a module.

@{b}@{u}STRUCTURE@{uu}@{ub}
The Module object consists of the following public fields:

     @{"MinRevision" LINK "MOD_MinRevision"} - Minimum required Revision number.
     @{"MinVersion" LINK "MOD_MinVersion"}  - Minimum required Version number.
     @{"ModBase" LINK "MOD_ModBase"}     - Module Function Base (jump table).
     @{"Name" LINK "MOD_Name"}        - Name of the module.
     @{"Number" LINK "MOD_Number"}      - ID of the associated module, if any.
   + @{"Public" LINK "MOD_Public"}      - Points to a public structure of more detail.
     @{"TableType" LINK "MOD_TableType"}   - The type of function table that you want.

@EndNode
---------------------------------------------------------------------------
@NODE "MOD_MinRevision" "Object: Module"

@{b}@{u}FIELD@{uu}@{ub}
Name:        MinRevision
Type:        LONG
Inheritance: Init()
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
When  opening  the  Module, the value that you insert here will specify the
minimum revision of the module that you require.

Note  that  the  Revision  is closely tied to the Version number.  So, when
asking  for  version 1 revision 4 (1.4), when the available version is 2.2,
you  will still open the module successfully even though you have requested
a higher revision number.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"MinVersion" LINK "MOD_MinVersion"}

@EndNode
---------------------------------------------------------------------------
@NODE "MOD_MinVersion" "Object: Module"

@{b}@{u}FIELD@{uu}@{ub}
Name:        MinVersion
Type:        LONG
Inheritance: Init()
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
When  opening  the  Module, the value that you insert here will specify the
minimum version of the module that you require.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"MinRevision" LINK "MOD_MinRevision"}

@EndNode
---------------------------------------------------------------------------
@NODE "MOD_ModBase" "Object: Module"

@{b}@{u}FIELD@{uu}@{ub}
Name:   ModBase
Type:   APTR
Status: Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
When  the  module is initialised a jump table will be created and placed in
this  field.   Once you grab the ModBase, you can use it to call any of the
module's  functions.  How you call functions from the table is dependant on
the TableType setting (more on this soon).

Unlike  amiga  libraries, the jump table is not shared between tasks.  This
allows  each  module  to  use  a different function model between versions,
without  losing  backwards  compatibility.   When a module is opened it can
check the Version number argument and then pass a tailor-made function list
back  to your program.  So if a function had to change in future (e.g.  new
arguments),  your  older  program  would simply be routed to a routine that
provides  backwards  compatibility  to  the  newer  function  model.  Newly
written programs would of course go straight to the expected function.

Secondly,  you have the option of what kind of function base you would like
returned  (this  is  where  the TableType comes in).  Amiga programmers are
quite used to using the following code to make library calls:

      move.l  DPKBase(pc),a6
      jsr     -XXX(a6)

However   library   calls  on  other  platforms  may  be  taken  completely
differently.   This  is  quite  important  when  producing a cross platform
binary  as there could be some confusion as to what function base should be
returned.   So,  what  the Module does is allow you to specify exactly what
sort  of  function  base  you  want returned.  This is also very useful for
certain  programming languages, e.g.  Amiga E requires a special jump table
format.

@{b}@{u}NOTE@{uu}@{ub}
Remember  that  after you Free() your module, the function base will become
invalid.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"TableType" LINK "MOD_TableType"}

@EndNode
---------------------------------------------------------------------------
@NODE "MOD_Name" "Object: Module"

@{b}@{u}FIELD@{uu}@{ub}
Name:   Name
Type:   BYTE *
Status: Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  string  pointer  specifies the name of the module.  This name will be
used to load the module from the System/ directory, so it actually reflects
the filename of the module.  It is also possible to specify sub-directories
before the module name itself, this could become more common in future.

This  field is optional and should only be used if you don't know the ID of
a module.

@{b}@{u}Example@{uu}@{ub}
The Name you would give for the Screens module is:

  "screens.mod"

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"Number" LINK "MOD_Number"}

@EndNode
---------------------------------------------------------------------------
@NODE "MOD_Number" "Object: Module"

@{b}@{u}FIELD@{uu}@{ub}
Name:   Number
Type:   WORD
Status: Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  identifies  the  number of the Module.  All modules registered
with  DreamWorld Productions will have an ID and this is the fastest way to
reference them.

As an example, here are the first 10 officially recognised numbers:

  MOD_BLITTER = 1
  MOD_SOUND   = 2
  MOD_SCREENS = 3
  MOD_VECTORS = 4
  MOD_CACTUS  = 5
  MOD_ANIM    = 6
  MOD_CARDS   = 7
  MOD_TEXT    = 8
  MOD_OBJECTS = 9
  MOD_NETWORK = 10

You can check the numbers in the "system/register.h" include file.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field:   @{"Name" LINK "MOD_Name"}
Include: @{"system/register.h" LINK "GMSDev:Includes/system/register.h/Main"}

@EndNode
---------------------------------------------------------------------------
@NODE "MOD_Public" "Object: Module"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Public
Type:        struct ModPublic *
Inheritance: Init()
Status:      Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field points to a public structure that is accessible by all programs
that currently have the module open.  It gives you further information such
as who wrote the module, its current version/revision numbers and so on.

Here are the fields that are publicly accessible:

  WORD  Version;      /* Version of the ModPublic structure */
  WORD  OpenCount;    /* Amount of programs with this module open */
  LONG  CPU;          /* CPU that this module is compiled for */
  LONG  ModVersion;   /* Version of this module */
  LONG  ModRevision;  /* Revision of this module */
  BYTE  *Author;      /* Author of the module */
  BYTE  *Copyright;   /* Copyright details */
  BYTE  *Date;        /* Date of compilation */
  BYTE  *Name;        /* Name of the module */

All  other  fields  that are not listed here are private, or are for module
use only.

@EndNode
---------------------------------------------------------------------------
@NODE "MOD_TableType" "Object: Module"

@{b}@{u}FIELD@{uu}@{ub}
Name:    TableType
Type:    WORD
Default: JMP_DEFAULT
Status:  Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  can  be  specified  on  initialisation  so  that  you  can get
tailor-made  jump  tables.   This  is  essential for certain languages, for
example AmigaE requires that this is always set to JMP_AMIGAE.  The default
is  JMP_DEFAULT,  which  is  suitable for C and asm programmers.  There are
currently no other table types, but there will definitely be more to follow
in future.

@{b}@{u}NOTE@{uu}@{ub}
Once  you  initialise the module, the generated table will be placed in the
ModBase field.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"ModBase" LINK "MOD_ModBase"}

@EndNode
---------------------------------------------------------------------------
@NODE "MOD_Init()" "Action: Init(Module, NULL)"

@{b}@{u}ACTION@{uu}@{ub}
Name:     Init()
Synopsis: Module = Init(Module, NULL)
Short:    Loads in a system module and initialises it for function calls.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action loads in a module and initialises it ready for function calls.
After  successful  initialisation  you  will  be able to interface with the
module through the ModBase jump table.

If  the  module  contains  system objects, they will be prepared for use as
well.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Init()" LINK "Init()"}

@EndNode
-----------------------------------------------------------------------------
